ADDATA *s_pFreeList;
};

// Global Variables
int v_iTls;                  // The thread local storage slot we used to store our shadow stack
FUNDATA *v_rgFunData = NULL; // A pointer to the FUNDATA we put in the instrumented binary
int v_cProc;                 // The number of FUNDATA entries in the instrumented binary

// An silly allocator that reduces our interfernce with the running program
void *_fastcall Allocate(int cb)
{
    static BYTE *v_pbAllocNext = NULL;  // A pointer to the next allocation
    static BYTE *v_pbAllocMax;

    if (NULL == v_pbAllocNext ||
        v_pbAllocMax - v_pbAllocNext < cb)
    {
        // We preserve the last error because some programs use it, and VirtualAlloc touches it
        DWORD dwError = GetLastError();
       
        v_pbAllocNext = (BYTE*)VirtualAlloc( NULL, 64*1024, MEM_COMMIT, PAGE_READWRITE );
        v_pbAllocMax = v_pbAllocNext + 64*1024;

        SetLastError(dwError);
    }

    void *pvRet = v_pbAllocNext;
    v_pbAllocNext += ((cb + 3) & ~3); //Keep DWORD aligned

    return pvRet;
}

THREADDATA *THREADDATA::s_pFreeList;
void *THREADDATA::operator new( size_t cb )
{
   // Only 1 thread can be destroyed or created at a time
   if (s_pFreeList)
   {
      THREADDATA *pRet = s_pFreeList;
      s_pFreeList = s_pFreeList->pNext;
      return (void *)pRet;
   }
   else
   {
      return Allocate( cb );
   }
}

void THREADDATA::operator delete( void *pv )
{
   // Only 1 thread can be destroyed or created at a time
   THREADDATA *pData = (THREADDATA *)pv;
   pData->pNext = s_pFreeList;
   s_pFreeList = pData;
}

#pragma warning( disable: 4200 )

// A linked list of FUNSTACK describes each different stack in the program,
// and how much time was spent there.

struct FUNSTACK
{
    __int64 time;       // This will be the total time spent with this stack as the stack (timeLeave - timeEntry)
    __int64 timeEx;     // This will be the exclusive time spent with this stack on the stack (time - time from all children)
    DWORD c;            // The number of times this routine got called with this exact stack
    DWORD dwKey;        // This is a hash key we will use to identify this stack
    FUNSTACK *pNext;    // This is a pointer to the next stack in this hash
    DWORD cdwAddr;      // This is a the number of addresses on this stack
    DWORD rgdwAddr[0];  // This is an array of addresses of function that were on the stack
};

// We have a little hash table here... 4k entries... a linked list to change

const int cFunStack = 1024*4;
FUNSTACK **rgFunStackHash = (FUNSTACK **)Allocate( cFunStack * sizeof(FUNSTACK *) );
#pragma warning(disable:4311 4312)

void AddFunStackTime( SHADOWSTACKENTRY *pTop, SHADOWSTACKENTRY *pBase, __int64 time )
{
   // This routine is called when a function returns to add the time spent
   // inside it to the assocated FUNSTACK

   // Create the hash key based on the addresses on the stack

   DWORD dwKey = 0;
   for (SHADOWSTACKENTRY *p = pBase; p < pTop; p++)
   {
      dwKey ^= (DWORD)p->pvTarget;
      dwKey  = _rotl( dwKey, 1 );
   }

   // Compute the hash bucket this stack will be in

   DWORD hash = dwKey % cFunStack;

   // And the height of the stack

   DWORD c = pTop - pBase;

   // We search for the entry in that hash bucket for this key

   for (FUNSTACK *pStack = rgFunStackHash[hash]; pStack; pStack = pStack->pNext)
   {
      if (pStack->dwKey == dwKey &&
          pStack->cdwAddr == c)
      {
         // Is this really the right one?

         p = pBase;
         int i = 0;
         while (p < pTop)
         {
            if ((DWORD)p->pvTarget != pStack->rgdwAddr[i])
            {
               // This is not the right one
               break;
            }

            p++; i++;
         }

         if (p == pTop)
         {
            // Yes, this is the right entry

            break;
         }
      }
   }

   if (pStack)
   {
      // We have seen this stack before... add the time and count

      pStack->time += time;
      pStack->c++;
   }
   else
   {
      // We have not seen this stack before.... make a new entry
      // Note that there is an small chance in a multithreaded app
      // that this would happen more than once for a stack.

      FUNSTACK *pStack = (FUNSTACK *)Allocate( c * sizeof(DWORD) + sizeof(FUNSTACK) );
      pStack->time = time;
      pStack->dwKey = dwKey;
      pStack->cdwAddr = c;
      pStack->c = 1;

      int i = 0;
      for (p = pBase; p < pTop; p++)
      {
          pStack->rgdwAddr[i] = (DWORD)p->pvTarget;
          i++;
      }

      // We must be thread safe as we add this entry to the list
      // so we don't lose stacks.

      do
      {
         pStack->pNext = rgFunStackHash[hash];
      }
      while (pStack->pNext != 
#ifdef InterlockedCompareExchangePointer
               InterlockedCompareExchangePointer( (void **)&rgFunStackHash[hash],
                                                  pStack,
                                                  pStack->pNext ));
#else //InterlockedCompareExchangePointer
               InterlockedCompareExchange( (void **)&rgFunStackHash[hash],
                                           pStack,
                                           pStack->pNext ));
#endif //InterlockedCompareExchangePointer

   }
}

int _cdecl CmpPFunStack( const void *ppv1, const void *ppv2)
{
    // This routine allows us to sort the stack before we write them out

    FUNSTACK *p1 = *(FUNSTACK **)ppv1;
    FUNSTACK *p2 = *(FUNSTACK **)ppv2;

    DWORD c = min(p1->cdwAddr, p2->cdwAddr);

    for (DWORD i=0; i<c; i++)
    {
        if (p2->rgdwAddr[i] != p1->rgdwAddr[i])
        {
            return p1->rgdwAddr[i]- p2->rgdwAddr[i];
        }
    }

    return p1->cdwAddr - p2->cdwAddr;
}

int _cdecl CmpFunData( const void * pvKey, const void *pv )
{
    // This routine help us to find the name of a routine from an address

    FUNDATA *pfd = (FUNDATA *)pv;
    DWORD addr = (DWORD)pvKey;

    if (addr >=  pfd->addr &&
        addr <   (pfd + 1)->addr)
    {
       return 0;
    }
    else
    {
       return addr - pfd->addr;
    }
}

const char *NameFromAddr( DWORD addr )
{
    // This routine lets us find the name of a routine from an address

    static char szTemp[256];
    FUNDATA *pfd = (FUNDATA *)bsearch( (void *)(addr), v_rgFunData, v_cProc, sizeof(FUNDATA), CmpFunData );
    if (pfd && pfd->szFun)
    {
        return pfd->szFun;
    }
    else
    {
        sprintf(szTemp, "0x%08X", addr );
        return szTemp;
    }
}

void DumpData()
{
   // This routine is called when the program exits to write out
   // the profile information.

   FILE *pf = fopen( "procprof.log", "w" );
   int cStack = 0;
   DWORD cMaxDepth = 0;
   for (int i=0; i<cFunStack; i++)
   {
      for (FUNSTACK *pStack = rgFunStackHash[i]; pStack; pStack = pStack->pNext)
      {
         cStack++;

         if (pStack->cdwAddr > cMaxDepth)
         {
             cMaxDepth = pStack->cdwAddr;
         }
      }
   }

   FUNSTACK **rgpStack = new FUNSTACK*[ cStack ];
   int iStack = 0;
   for (i=0; i<cFunStack; i++)
   {
      for (FUNSTACK *pStack = rgFunStackHash[i]; pStack; pStack = pStack->pNext)
      {
         rgpStack[iStack++] = pStack;
      }
   }

   qsort( rgpStack, cStack, sizeof(FUNSTACK *), CmpPFunStack );

   // Compute exclusive time

   FUNSTACK **rgParents = new FUNSTACK*[cMaxDepth];
   rgParents[0] = NULL; // hasn't returned yet

   for (iStack=0; iStack<cStack; iStack++)
   {
      FUNSTACK *pStack = rgpStack[iStack];
      pStack->timeEx = pStack->time;

      // Subtract me from my parents

      if (pStack->cdwAddr > 1)
      {
         FUNSTACK *pParent = rgParents[pStack->cdwAddr-2];
         if (pParent)
         {
             pParent->timeEx -= pStack->time;
         }
      }

      rgParents[pStack->cdwAddr - 1] = pStack;
   }

   fprintf(pf, "Inclusive\tExclusive\tCount\tStack\n");
   for (iStack=0; iStack<cStack; iStack++)
   {
      FUNSTACK *pStack = rgpStack[iStack];
      fprintf(pf, "%I64d\t%I64d\t%d", pStack->time, pStack->timeEx, pStack->c );

      for (DWORD j=0; j<pStack->cdwAddr; j++)
      {
         // fprintf(pf, "\t0x%08X", pStack->rgdwAddr[j] );

         fprintf(pf, "\t\"%s\"", NameFromAddr(pStack->rgdwAddr[j]) );
      }

      fprintf(pf, "\n");
   }

   fclose(pf);
}


extern "C" _declspec (dllexport) void _cdecl InitProcProf( FUNDATA *rgFunData, int cProc )
{
   // This is the initialization routine.  Note the we don't handle instrumenting
   // more than one program per process.

   if (v_rgFunData == NULL)
   {
      v_rgFunData = rgFunData;
      v_cProc = cProc;
   }
}

void * _fastcall ProcExitProf( SHADOWSTACKENTRY *psseLeave )
{
   // This routine is called as each function returns

   __int64 time = RDTSC();

   THREADDATA *ptd = (THREADDATA *)TlsGetValue( v_iTls );

   for (SHADOWSTACKENTRY *psse = ptd->pTop - 1; psse >= psseLeave; psse--)
   {
       __int64 delta = time - psse->timeEnter;
       AddFunStackTime( psse + 1, ptd->rgEntries, delta );
   }

   ptd->pTop = psseLeave;

   return psseLeave->pvRASave;
}

_declspec(naked) void _stdcall ProcExitProfAsm()
{
   // This assembly routine is called as each function returns
   // Note that we must preserve volitle registers and the flags

                             // 12 param (psseLeave)
   _asm push ecx             // 8
   _asm push edx             // 4
   _asm pushfd               // 0
   _asm xchg [esp + 12], eax // Save old eax where the return address will go
   _asm mov ecx, eax         // _fastcall ProcExitProf uses ecx for param

   _asm call ProcExitProf    // eax contains the return value

   _asm popfd
   _asm pop edx
   _asm pop ecx
   _asm xchg [esp], eax      // swap eax and our new target

   _asm ret
}


extern "C"
BOOL WINAPI DllMain(HINSTANCE, DWORD dwReason, LPVOID)
{
   switch (dwReason)
   {
      case DLL_PROCESS_ATTACH:
         v_iTls = TlsAlloc();
         // Fall through to thread attach which isn't called for the first thread

      case DLL_THREAD_ATTACH:
      {
          THREADDATA *ptd = new THREADDATA;
          TlsSetValue( v_iTls, ptd );

          // Build the code for each entry in the shadow stack (this never changes after this point)
          ptd->pTop = ptd->rgEntries;
          for ( SHADOWSTACKENTRY *psse = ptd->rgEntries; psse < ptd->rgEntries + 200; psse++)
          {
              psse->push = 0x68;
              psse->psse = psse;
              psse->jump = 0xE9;
              psse->ibProcExit = (BYTE *)&ProcExitProfAsm - (BYTE *)&psse->pvRASave;
          }
          break;
      }

      case DLL_THREAD_DETACH:
      {
          // Free data assocated with this thread
          THREADDATA *ptd = (THREADDATA *)TlsGetValue( v_iTls );
          delete ptd;
          break;
      }

      case DLL_PROCESS_DETACH:
      {
          // Time to write out the profile information
          DumpData();
          break;
      }

   }

   return TRUE;
}

void _stdcall ProcProfEnter( DWORD **ppvRA, DWORD * pvTarget )
{
   // This routine is called as we enter each procedure

   __int64 time = RDTSC();

   // pvRA points at the RA for the function we just called

   THREADDATA *ptd = (THREADDATA *)TlsGetValue( v_iTls );
   SHADOWSTACKENTRY *psse = ptd->pTop;
   ptd->pTop++;

   // Fill in the rest of the SHADOWSTACKENTRY structure

   psse->timeEnter = time;
   psse->pvRASave = *ppvRA;
   psse->pvTarget = pvTarget;

   // Patch the stack with our exit routine

   *ppvRA = (DWORD *)psse;
}

extern "C" _declspec (dllexport) _declspec(naked) void _stdcall ProcProf()
{
   // Assembly routine called a the beginning of each instrumented routine
   // Volatile register and flags are live

                     // 20 caller ra
                     // 16 ra
   _asm push eax     // 12
   _asm push ecx     // 8
   _asm push edx     // 4
   _asm pushfd       // 0

   _asm lea eax, [esp + 20]  // compute ppvRA
   _asm push [esp + 16]      // push pvTarget
   _asm push eax             // push ppvRA
   _asm call ProcProfEnter

   _asm popfd
   _asm pop edx
   _asm pop ecx
   _asm pop eax
   _asm ret
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\Samples\src\ProcTrace\proctrace.cpp ===
/***********************************************************************
* Microsoft  Vulcan
*
* Microsoft Confidential.  Copyright 1997-1999 Microsoft Corporation.
*
* File: VATrack.cpp
*
* File Comments:
*
*
***********************************************************************/
#pragma warning(disable: 4514)

#include "stdio.h"
#include "vulcanapi.h"
#include "string.h"

int __cdecl main(int argc, char** argv);
void __stdcall Myhandler(VErr verr);

void ProcTrace(char* szImage, char *szCmdFile)
{
   VProg *pprog = VProg::Open(szImage, false, szCmdFile);

   for(VComp *pComp = pprog->FirstComp(); pComp; pComp = pComp->Next())
   {
      printf("%s\n",pComp->InputName());

      // Create the prototype
      VProtoList *pProtoList = VProtoList::CreateProtoList();
      VProto *pProto = pProtoList->CreateProto(pComp, "ProcTraceDll.dll", "ProcTrace(char*)" );

      // Instrument the beginning of each routine
      for (VProc *pProc = pComp->FirstProc(); pProc; pProc = pProc->Next())
      {
         pProto->AddCall( pProc, BEFORE, pProc->Name() );
      }

      // Commit the changes
      pProtoList->Commit();

      // Write out the image
      pComp->Write();
   }
}


int __cdecl main(int argc, char** argv)
{

   if (argc != 2 && argc != 3)
   {
      printf("usage: ProcTrace foo.exe [foo.cmdfile]\n");
      return 1;
   }

   try
   {
      ProcTrace(argv[1], argv[2]);
   }
   catch (VErr& verr) 
   {
      printf("Error: %s\n",verr.GetWhat());
      return 1;
   }
   catch (...)
   {
      printf("Error: unknown\n");
      return 1; 
   }

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\Samples\src\Peephole\peephole.cpp ===
/***********************************************************************
* Microsoft  Vulcan
*
* Microsoft Confidential.  Copyright 1997-2000 Microsoft Corporation.
*
* File: Peephole.cpp
*
* File Comments:
*
*
***********************************************************************/
#include "vulcanapi.h"

#include <stdio.h>

void BranchChaining(VInst *vinst)
{
   while (true)
   {
      VBlock *targetblk = vinst->BlockTarget();
      if (targetblk &&
          targetblk->IsDataBlock() ||
          (NULL == targetblk->FirstInst()))
      {
         break;
      }

      VInst *targetinst = targetblk->FirstInst();
      EOpcodes vinstOpcode = vinst->Opcode();
      EOpcodes targetOpcode = targetinst->Opcode();        
      if (targetOpcode == COp::JMP || targetOpcode == COp::CEE_BR)
      {
         if (targetinst->BlockTarget())
         {
            vinst->SetBlockTarget( targetinst->BlockTarget() );
         }
         else if (targetinst->Operand(Inst::Src1).Type() == OpndAddress &&
                  (vinstOpcode == COp::JMP /* || vinstOpcode == COp::CALL */))
         {
            VAddress *pAddr = VAddress::Create(
                                  targetinst->Operand(Inst::Src1).Address() );

            vinst->SetOperand(Inst::Src1, VOperand( pAddr ) );
            break;
         }
         else break;

      }
      else if (COp::IsCondBranch(vinstOpcode) && targetOpcode == vinstOpcode)
      {
         if (targetinst->BlockTarget())
         {
             vinst->SetBlockTarget(targetinst->BlockTarget()); 
         }
         else break;
      }
      else break;
   }
}

void Peephole(VProg *vprog)
{
   for (VComp *pComp = vprog->FirstComp(); pComp; pComp = pComp->Next() )
   {
      for (VSect *pSect = pComp->FirstSect(); pSect; pSect = pSect->Next() )
      {
         for (VProc *pProc = pSect->FirstProc(); pProc; pProc = pProc->NextSectProc() )
         {
            for (VBlock *pBlk = pProc->FirstBlock(); pBlk; pBlk = pBlk->Next() )
            {
#define SUPERBLOCKS
#ifdef SUPERBLOCKS

               for (VInst *pInst = pBlk->FirstInst(); pInst; pInst = pInst->Next() )
               {
                  EOpcodes opcode = pInst->Opcode();

                  if ((opcode == COp::JMP    ||
                       opcode == COp::CEE_BR ||
                    /* opcode == COp::CALL   || */
                       COp::IsCondBranch(opcode)) &&
                      (pInst->Operand(Inst::Src1).Type() == OpndBlock) &&
                      pInst->BlockTarget())
                  {
                     BranchChaining(pInst);
                  }
               }

#else // SUPERBLOCKS

               VInst *vinst = pBlk->LastInst();
               EOpcodes opcode = vinst->Opcode();
               if ((opcode == COp::JMP    ||
                    opcode == COp::CEE_BR ||
                 /* opcode == COp::CALL   || */
                   COp::IsCondBranch(opcode)) &&
                   vinst->BlockTarget())
               {
                  BranchChaining(vinst);
               }

#endif // SUPERBLOCKS

                }
            }
        }

        pComp->Write();
    }
}



int __cdecl main(int argc, char** argv)
{
   
   if (argc != 2)
   {
      printf("Usage: Peephole [Image-Name]\n");
      return 1;
   }

   try
   {
      VProg *vprog = VProg::Open(argv[1]);
      Peephole(vprog);  

      // To save time, we don't destroy the vprog
      // vProg->Destroy();
   }

   catch (VErr& verr) 
   {
      printf("Error: %s\n",verr.GetWhat());
      return 1;
   }

   catch (...)
   {
      printf("Error: unknown\n");
      return 1; 
   }

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\wavmerge\CWaveFile.h ===
#pragma once

#include "globals.h"

class CWaveFile
{
public:
    CWaveFile(void);
    ~CWaveFile(void);
    HRESULT OpenForRead     (const LPSTR szFileName);
    HRESULT OpenForSilence  (const WAVEFORMATEX &wfx);
    HRESULT OpenForWrite    (const LPSTR szFileName, const WAVEFORMATEX &wfx, DWORD cbSize);
    HRESULT ReadData        (VOID *pData, DWORD dwSize, LPDWORD pcbRead);
    HRESULT WriteData       (VOID *pData, DWORD dwSize, LPDWORD pcbWritten);
    HRESULT Close           (void);
    
    HRESULT GetWaveFormatEx(WAVEFORMATEX *pWfx);
    HRESULT GetFileName(LPSTR szFileName);
    HRESULT GetLength(LPDWORD pdwLength);

private:

    HRESULT InternalFree(void);
    bool         m_bLoadedForRead;
    bool         m_bLoadedForWrite;
    LPWAVEFORMATEX m_pWfx;
    DWORD        m_cbDataTotal;
    DWORD        m_cbDataRemaining;
    CHAR         m_szFileName[MAX_PATH];
    HANDLE       m_hFile;
    BOOL         m_bSilence;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\wavmerge\globals.h ===
#pragma once

#include <windows.h>
#include <mmsystem.h>
#include <stdio.h>
#include <conio.h>
#include <io.h>
#include "macros.h"
extern const LPSTR szSilence;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\wavmerge\CWaveFile.cpp ===
#include "cwavefile.h"
#include "helpers.h"

/********************************************************************************
********************************************************************************/
CWaveFile::CWaveFile(void)
{
m_pWfx = NULL;
memset(m_szFileName, 0, MAX_PATH);
m_cbDataTotal = 0;
m_cbDataRemaining=0;
m_hFile = NULL;
m_bSilence = FALSE;
m_bLoadedForRead  = FALSE;
m_bLoadedForWrite = FALSE;
};


/********************************************************************************
********************************************************************************/
CWaveFile::~CWaveFile(void)
{
    InternalFree();
};

/********************************************************************************
********************************************************************************/
HRESULT CWaveFile::OpenForRead(const LPSTR szFileName)
{
    HRESULT hr = S_OK;
    DWORD   dwRead = 0;
    BOOL bResult = false;
    
    //Check to see if this object already has data.
    if (m_bLoadedForRead)
    {
        Log("Loading %s over already-loaded file %s; unloading %s", szFileName, m_szFileName, m_szFileName);
        InternalFree();
    }
    
    //Save the filenane
    strncpy(m_szFileName, szFileName, MAX_PATH-1);

    //Get the WFX and file length, and set m_hFile to the beginning of the wave data.
    if (SUCCEEDED(hr))
    {
        m_hFile = WaveOpenFile(szFileName, &m_pWfx, &m_cbDataTotal);
        if (INVALID_HANDLE_VALUE == m_hFile)
        {
            m_hFile = NULL;
            hr = E_FAIL;
        }
    }

    if (SUCCEEDED(hr))
    {
        m_pWfx->cbSize = 0;
        m_cbDataRemaining = m_cbDataTotal;
    }


    //If this procedure failed, free everything..
    if (FAILED(hr))
    {
        InternalFree();
    }
    else
        m_bLoadedForRead = true;

    return hr;
};


/********************************************************************************
********************************************************************************/
HRESULT CWaveFile::OpenForSilence(const WAVEFORMATEX &wfx)
{
    //Check to see if this object already has data.
    if (m_bLoadedForRead)
    {
        Log("Internal Error: Loading Silence over already-loaded file %s; unloading %s", m_szFileName, m_szFileName);
        InternalFree();
    }

    m_pWfx = (LPWAVEFORMATEX)LocalAlloc(LPTR, sizeof(WAVEFORMATEX));
    *m_pWfx = wfx;

    //m_pvData = LocalAlloc(LPTR, wfx.nBlockAlign);
    m_cbDataTotal = 0;
    m_bLoadedForRead = true;
    m_bSilence = TRUE;
    strcpy(m_szFileName, szSilence);
    return S_OK;
};




/********************************************************************************
********************************************************************************/
HRESULT CWaveFile::ReadData(LPVOID pvData, DWORD cbSize, LPDWORD pcbRead)
{
    DWORD cbDataRead = 0;
    HRESULT hr = S_OK;
    BOOL bResult = TRUE;

    if (m_bSilence)
    {
        memset(pvData, (m_pWfx->wBitsPerSample==16) ? 0 : 0x80 , cbSize);
        *pcbRead = cbSize;
    }
    else
    {
        bResult = ReadFile(m_hFile, pvData, cbSize, &cbDataRead, NULL);
        if (!bResult)
        {
            Error("Failure reading %s", m_szFileName);
            hr = E_FAIL;
        }
        else
        {
            //If we read more than we thought we had, that's weird.  But handle it by just saying we read the correct amount.
            if (cbDataRead > m_cbDataRemaining)
                cbDataRead = m_cbDataRemaining;

            m_cbDataRemaining -= cbDataRead;
        }

        *pcbRead = cbDataRead;
    }

    return hr;
};



/********************************************************************************
********************************************************************************/
HRESULT CWaveFile::OpenForWrite(const LPSTR szFileName, const WAVEFORMATEX &wfx, DWORD cbSize)
{
HRESULT hr = S_OK;
BOOL bResult = true; //true = success, false = failure.
DWORD dwRes = 0;
CHAR szFullPathName[MAX_PATH * 2] = {0};
ULARGE_INTEGER li = {0};
CHAR *szFilePart = NULL;

m_pWfx = (LPWAVEFORMATEX)LocalAlloc(LPTR, sizeof(WAVEFORMATEX));
*m_pWfx = wfx;

//Is something already loaded?
if (m_bLoadedForWrite)
{
    Log("Opening %s for write over already-loaded-for-write file %s; unloading %s", szFileName, m_szFileName, m_szFileName);
    hr = E_FAIL;
}

//Can we open this?
if (SUCCEEDED(hr))
{
    strncpy(m_szFileName, szFileName, MAX_PATH - 1);
    m_hFile = WaveOpenFileForSave(m_szFileName, m_pWfx, cbSize);
    if (!m_hFile || m_hFile==INVALID_HANDLE_VALUE)
    {
        Error("Can't save data to %s", m_szFileName);
        hr = E_FAIL;
    }
}


//Check the disk space.
if (SUCCEEDED(hr))
{
    dwRes = GetFullPathName(szFileName, MAX_PATH * 2 - 1, szFullPathName, &szFilePart);
    if (!dwRes)
    {
        Log("Error: Couldn't GetFullPathName for %s; can't check for available disk space.", szFileName);
    }
    else
    {
        //Wipe off the file name completely.
        szFilePart[0] = NULL;
        GetDiskFreeSpaceEx(szFullPathName, &li, 0, 0);
        if (li.QuadPart <= cbSize)
        {
            Log("Error: Not enough disk space.");
            Log("       You need %d bytes but only have %I64u.", cbSize, li.QuadPart);
            hr = E_FAIL;
        }
    }
}


if (SUCCEEDED(hr))
    m_bLoadedForWrite = TRUE;
else
{
    InternalFree();
}

return hr;
};


/********************************************************************************
********************************************************************************/
HRESULT CWaveFile::WriteData(LPVOID pvData, DWORD cbSize, LPDWORD pcbWritten)
{
HRESULT hr = S_OK;
DWORD cbWritten = 0;
BOOL bResult;

    bResult = WriteFile(m_hFile, pvData, cbSize, pcbWritten, NULL);
    if (!bResult)
    {
        Error("Failure writing %s", m_szFileName);
        hr = E_FAIL;
    }
    else if (*pcbWritten != cbSize)
    {
        Error("Error: Wrote %u instead of %u bytes from %s", *pcbWritten, cbSize, m_szFileName);
        hr = E_FAIL;
    }

    return hr;
};



/********************************************************************************
********************************************************************************/
HRESULT  CWaveFile::Close(void)
{
    HRESULT hr = S_OK;
    if (!m_bLoadedForRead && !m_bLoadedForWrite)
    {
        Error("Trying to free a file that's not loaded for read or write");
        hr = E_FAIL;
    }
    InternalFree();

    return hr;
};



/********************************************************************************
********************************************************************************/
HRESULT CWaveFile::InternalFree(void)
{
    HRESULT hr = S_OK;

    if (m_pWfx)
    {
        LocalFree(m_pWfx);
        m_pWfx = NULL;
    }

    memset(m_szFileName, 0, MAX_PATH);
    m_cbDataTotal     = 0;
    m_cbDataRemaining = 0;
    m_bLoadedForRead = false;
    m_bSilence = false;
    if (m_hFile)
    {        
        CloseHandle(m_hFile);
        m_hFile = NULL;
    }
    return hr;
};


/********************************************************************************
********************************************************************************/
HRESULT CWaveFile::GetWaveFormatEx(WAVEFORMATEX *pWfx)
{
    if (m_bLoadedForRead || m_bLoadedForWrite)
    {
        //Copy the data out.
        *pWfx = *m_pWfx;    
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}




/********************************************************************************
********************************************************************************/
HRESULT CWaveFile::GetFileName(LPSTR szFileName)
{
    if (m_bLoadedForRead || m_bLoadedForWrite)
    {
        strncpy(szFileName, m_szFileName, MAX_PATH - 1);
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
};




/********************************************************************************
********************************************************************************/
HRESULT CWaveFile::GetLength(LPDWORD pcbData)
{
    *pcbData = m_cbDataTotal;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\Samples\src\Reprocess\reprocess.cpp ===
/***********************************************************************
* Microsoft Vulcan
*
* Microsoft Confidential.  Copyright 1996-2000 Microsoft Corporation.
*
* Component:
*
* File: reprocess.cpp
*
* File Comments:
* Demonstrates how to generate a Re-Vulcanizable binary.
*
* Vulcan can now re-process a Vulcan processed executable.  To enable this
* functionality, pass the value TRUE for the fRereadable parameter to
* VComp::Write.  When fRereadable is TRUE, Write will create a new image which
* contains a copy of the IR.  The IR is stored in the output PDB file (VC 6.x or
* greater), or in the generated output image (VC 5.x).  Storing the IR allows
* another Vulcan application to determine the block level information of this new
* image.  When another Vulcan application opens the new image, the stored IR will
* be detected and used.
*
*
***********************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <direct.h>
#include <sys/stat.h>

#include "vulcanapi.h"
#include "vulcancmdfile.h"
#include "vulcancmdline.h"

#define DEFAULTOUTDIR "REPROCESS\\"
#define DEFAULTPDBEXT ".pdb"
#define DEFAULTCMDEXT ".bbtcmd"
#define DEFAULTASMEXT ".asm"

/***********************************************************************
* fRereadable is passed in as the fRereadable parameter value to VComp::Write
* When this is true, the IR will be saved in the output image's PDB (VC6x),
* or the output image (VC5x). You can override the default value of true by
* using the /noreprocess switch.
*
***********************************************************************/
bool  fRereadable = true;               // True to generate a Re-Vulcanizable image

char  *szAsm;                          // Asm filename
char  *szCmd;                          // Cmdfile name
char  *szO;                            // Output file name
char  *szPdb;                          // Name of pdb file.
char  *szCmdCmd;                       // Cmd file specified on /cmd
char  *szCmdAsm;                       // Asm file specified on /asm
char  *szCmdPdb;                       // Pdb file specified on /pdb
char  *szCmdO;                         // Output file specified on /o
char  *szOrgDir;                       // Directory for input files
char  *szOutDir;                       // Directory for Output files
char  *szImage;                        // Input Image

bool  fnocmd;                          // True if /nodefaultcmd specified
bool  fout;                            // True if /o specified
bool  fcmd;                            // True if /cmd specified
bool  fasm;                            // True if /asm specified
bool  fpdb;                            // True if /pdb specified
bool  fCompact;                        // True if /compact specified
bool  fBlockInfo;                      // True if /fBlockInfo specified
bool  fWriteFast;                      // True if /writefast specified
bool  fDoHelp;                         // True if /?
bool  fVerbose = false;
bool  fTerse = false;
bool  fNoLogo = false;
bool  fNoChange = false;
bool  fNoReprocess = false;
bool  fNoCount = false;
bool  fPrintNop = false;
bool  fSkipObsolete = true;
int   iArg;                            // First non-option argument

//
// Command line options
//    Type                 OptionName     fOptReq  pvValue
//
const CMDLINE::OPTDEF rgoptdef[] =
{
   { CMDLINE::argtHelp,       "?",           false,   &fDoHelp                   },
   { CMDLINE::argtOptString,  "asm",         false,   &szCmdAsm,        &fasm    },
   { CMDLINE::argtOptString,  "asmemit",     false,   &szCmdAsm,        &fasm    },
   { CMDLINE::argtNil,        "blockinfo",   false,   &fBlockInfo,               }, // not in usage
   { CMDLINE::argtString,     "cmd",         false,   &szCmdCmd,        &fcmd    },
   { CMDLINE::argtNil,        "compact",     false,   &fCompact                  },
   { CMDLINE::argtHelp,       "help",        false,   &fDoHelp                   },
   { CMDLINE::argtNil,        "nocmd",       false,   &fnocmd                    },
   { CMDLINE::argtOptString,  "o",           false,   &szCmdO ,         &fout    },
   { CMDLINE::argtOptString,  "pdb",         false,   &szCmdPdb,        &fpdb    },
   { CMDLINE::argtNil,        "verbose"  ,   false,   &fVerbose                  },
   { CMDLINE::argtNil,        "writefast",   false,   &fWriteFast                },
   { CMDLINE::argtNil,        "terse"    ,   false,   &fTerse                    },
   { CMDLINE::argtNil,        "q"    ,       false,   &fTerse                    },
   { CMDLINE::argtNil,        "nologo"   ,   false,   &fNoLogo                   },
   { CMDLINE::argtNil,        "nochange",    false,   &fNoChange,                },
   { CMDLINE::argtNil,        "noreprocess", false,   &fNoReprocess,             },
   { CMDLINE::argtNil,        "nocount",     false,   &fNoCount,                 },
   { CMDLINE::argtNil,        "printnop",    false,   &fPrintNop,                },
   { CMDLINE::argtNil,        "obsolete",    false,   &fSkipObsolete,            },
   { CMDLINE::argtEnd,        NULL,          false,   &iArg                      },
};

void __cdecl Error(const unsigned flags, const char *fmt, ...)
{
    char buf[512];

    va_list items;
    va_start(items, fmt);

    vsprintf(buf, fmt, items);
    va_end(items);

    VErr verr(buf, flags);
    verr.DoErrHandler();
}

void Usage(int iExit)
{
   printf("Microsoft (R) Vulcan Reprocess Sample\n");
   printf("Usage: REPROCESS [options] Executable\n\n"
          "Options:\n\n"
          "/?                  Display this help\n"
          "/asmemit [filename] Write a disassembly listing for output binary\n"
          "/cmd     filename   Read the specified command file\n"
//        "/compact            Use compact bblocks\n"
          "/help               Display this help\n"
          "/nocmd              Do not use a command file\n"
          "/nologo             Do not display a banner message\n"
          "/nochange           Do not add NOPs to the output image\n"
          "/noreprocess        Do not emit a reprocessible image\n"
          "/o       filename   Output binary name\n"
          "/pdb     filename   Pdb output filename\n"
          "/q                  Terse output mode\n"
//        "/verbose            Verbose output mode\n"
          "/writefast          Generate output file with VComp->WriteFast intead of Write\n"
          );

   exit(iExit);
}

void InitParams(int argc, char *argv[])
{
   char szDrive[_MAX_DRIVE];
   char szDir[_MAX_DIR];
   char szFname[_MAX_FNAME];
   char szExt[_MAX_EXT];
   char szBuf[5000];
   struct _stat rgStatBuf;

   bool fSuccess = true;                // avoid uninitialized var warning.
   //
   // Call the Command Line processor to parse the argyuments using rgoptdef
   // as the strucuture to define how to handle the various arguements.
   //
   try
   {
      fSuccess = CMDLINE::FProcessArgs("REPROCESS", argc, (const char **) argv, rgoptdef);
   }
   //
   // Handle the various error situations and validate correct usage
   //
   catch (...)
   {
      Usage(1);
   }

   if (!fSuccess)
   {
      Usage(1);
   }

   if (fDoHelp)
   {
      Usage(0);
   }

   if (iArg >= argc)
   {
      Usage(1);
   }

   szImage = argv[iArg++];

   if (iArg != argc)
   {
      Usage(1);
   }

   if (fTerse)
   {
      fNoLogo = true;
   }

   //
   // Display the startup banner for this utility
   //
   if (!fNoLogo)
   {
      printf("Microsoft (R) Vulcan Reprocess Sample\n");
   }

   //
   // Set the re-readable flag
   //
   if (fNoReprocess)
   {
      printf("Generating a non-reprocessible image\n");
      fRereadable = false;
   }

   //
   // Setup output directory for output file name
   //
   if (fout)
   {
      _splitpath(szCmdO, szDrive, szDir, szFname, szExt);
      if (strlen(szDir) + strlen(szDrive))
      {
         szOutDir = new char[strlen(szDir) + strlen(szDrive) + 1];
         sprintf(szOutDir, "%s%s", szDrive, szDir);
         szOutDir[strlen(szOutDir) -1] = '\0';

         if ((strlen(szDir) > 1) && (_stat(szOutDir, &rgStatBuf)))
         {
            char szbuf[512 + _MAX_DIR + _MAX_DRIVE];
            sprintf(szbuf, "The /o option specifies a directory '%s' which does not exist.\n", szOutDir);
            Error(VErr::FLG_FATAL, szbuf);
         }

         sprintf(szOutDir, "%s%s", szDrive, szDir);
      }
      else
      {
         szOutDir = new char[3];
         strcpy(szOutDir, ".\\");
      }
   }
   else
   {
      szOutDir = new char[sizeof(DEFAULTOUTDIR)+1];
      strcpy(szOutDir, DEFAULTOUTDIR);
      szOutDir[strlen(szOutDir) - 1] = '\0';

      // Create the Reprocess Directory if it doesn't yet exist

      size_t staterr = _stat(szOutDir, &rgStatBuf);
      if (staterr || (rgStatBuf.st_mode & _S_IFREG))
      {
         if(_mkdir(szOutDir))
         {
            throw VErr("Unable to create reprocess directory", VErr::FLG_FATAL);
         }
      }
      strcpy(szOutDir, DEFAULTOUTDIR);
   }

   _splitpath(szImage, szDrive, szDir, szFname, szExt);

   //
   // Setup the org and Reprocess directory names
   // The orgdir is constructed from the name of input binary.
   //

   if (strlen(szDir))
   {
      szOrgDir = new char[strlen(szDir) + strlen(szDrive) + 1];
      sprintf(szOrgDir, "%s%s", szDrive, szDir);
   }
   else
   {
      szOrgDir = new char[3];
      strcpy(szOrgDir, ".\\");
   }

   if (!fcmd)
   {
      if (fnocmd)
      {
         szCmd = NULL;
      }
      else
      {
         sprintf(szBuf, "%s%s%s%s", szOrgDir, szFname, szExt, DEFAULTCMDEXT);
         szCmd = new char[strlen(szBuf) + 1];
         strcpy(szCmd, szBuf);
         if (_stat(szCmd, &rgStatBuf))
         {
            szCmd = NULL;
         }
      }
   }
   else
   {
      szCmd = szCmdCmd;
   }

   //
   // Setup file names for the pdb, cmd, asm and output files
   //
   if (fout)
   {
      _splitpath(szCmdO, szDrive, szDir, szFname, szExt);
   }

   if (fasm)
   {
      if (szCmdAsm)
      {
         szAsm = szCmdAsm;
      }
      else
      {
         sprintf(szBuf, "%s%s%s%s", szOutDir, szFname, szExt, DEFAULTASMEXT);
         szAsm = new char[strlen(szBuf) + 1];
         strcpy(szAsm, szBuf);
      }
   }

   if (!fpdb)
   {
      sprintf(szBuf, "%s%s%s%s", szOutDir, szFname, szExt, DEFAULTPDBEXT);
      szPdb = new char[strlen(szBuf) + 1];
      strcpy(szPdb, szBuf);
   }
   else
   {
      char szCmdPdbDrive[_MAX_DRIVE];
      char szCmdPdbDir[_MAX_DIR];
      char szCmdPdbFname[_MAX_FNAME];
      char szCmdPdbExt[_MAX_EXT];

      _splitpath(szCmdPdb, szCmdPdbDrive, szCmdPdbDir, szCmdPdbFname, szCmdPdbExt);
      if (strlen(szCmdPdbDir) + strlen(szCmdPdbDrive))
      {
         char *szPdbDir = new char[strlen(szCmdPdbDir) + strlen(szCmdPdbDrive) + 1];
         sprintf(szPdbDir, "%s%s", szCmdPdbDrive, szCmdPdbDir);
         szPdbDir[strlen(szPdbDir)-1] = '\0';

         if ((strlen(szCmdPdbDir) > 1) && (_stat(szPdbDir, &rgStatBuf)))
         {
            char szbuf[512 + _MAX_DRIVE +_MAX_DIR];
            sprintf(szbuf, "The /pdb option specifies a directory '%s' which does not exist.\n", szPdbDir);
            Error(VErr::FLG_FATAL, szbuf);
         }
      }

      szPdb = szCmdPdb;
   }

   if (!fout)
   {
      sprintf(szBuf, "%s%s%s", szOutDir, szFname, szExt);
      szO = new char[strlen(szBuf) + 1];
      strcpy(szO, szBuf);
   }
   else
   {
      szO = szCmdO;
   }
}

void ReportFiles()
{
   if (!fTerse)
   {
      char szFullPath[_MAX_PATH];

      fprintf(stdout, "Input Files:\n");
      _fullpath(szFullPath, szImage, _MAX_PATH);
      fprintf(stdout, "\tInput Binary:\t%s\n", szFullPath);

      if (szCmd)
      {
         _fullpath(szFullPath, szCmd, _MAX_PATH);
         fprintf(stdout, "\tCommand File:\t%s\n", szFullPath);
      }

      fprintf(stdout, "Output Files:\n");
      _fullpath(szFullPath, szO, _MAX_PATH);
      fprintf(stdout, "\tOutput Binary:\t%s\n", szFullPath);

      if ((szPdb != NULL) && strlen(szPdb))
      {
         _fullpath(szFullPath, szPdb, _MAX_PATH);
         fprintf(stdout, "\tPDB File:\t%s\n", szFullPath);
      }

      if (fasm)
      {
         _fullpath(szFullPath, szAsm, _MAX_PATH);
         fprintf(stdout, "\tAsm File:\t%s\n", szFullPath);
      }
   }
}

void AddNop(VProg *pprog)
{
   if (fNoChange)
      return;

   int count = 0;

   for(VComp *pComp = pprog->FirstComp(); pComp; pComp = pComp->Next())
   {
      printf("%s\n",pComp->InputName());
      for(VProc *pProc = pComp->FirstProc(); pProc; pProc = pProc->Next())
      {
         for(VBBlock *pBlk = pProc->FirstBlock(); pBlk; pBlk = pBlk->Next())
         {
            if (fSkipObsolete && pBlk->IsObsolete())
            {
                continue;
            }

            //If we used FirstAllBlock and NextAll instead of FirstBlock and Next,
            //we would need to avoid data blocks (pBlk->IsDataBock())
            for(VInst *pInst = pBlk->FirstInst(); pInst; pInst = pInst->Next())
            {
               VInst * newInst;

               switch (pBlk->PlatformT())
               {

                  case platformtMSIL:
                       pInst->InsertPrev(VInst::Create(COp::CEE_NOP));
                       count++;
                       break;

                  case platformtX86:
                       pInst->InsertPrev(VInst::Create(COp::NOP));
                       count++;
                       break;

                  case platformtIA64:

                       // Alloc must always appear first in a bundle.
                       if (pInst->Opcode() != COp::ALLOC &&
                           // IA64 implements switch tables in code
                           // Hence there are some sequences that
                           // are not allowed to changed in size.
                           // These tests screen them out of consideration.
                           pInst->Opcode() != COp::NOP_M &&
                           pInst->Opcode() != COp::NOP_I &&
                           pInst->Opcode() != COp::NOP_B &&
                           pInst->Opcode() != COp::NOP_F &&
                           pInst->Opcode() != COp::NOP_X &&
                           pInst != pBlk->LastInst())
                       {
                          newInst = VInst::Create(COp::NOP_M, 0xbeef);
                          pInst->InsertPrev(newInst);
                          count++;
                       }
                       break;

                  default:
                       fprintf(stderr, "Unsupported architecture type\n");
                       exit(1);
               }
            }
         }
      }

      printf("%d nop's inserted.\n", count);
   }
}

void CountNop(VProg *pprog)
{
   if (fNoCount)
   {
      return;
   }

   int count = 0;

   for(VComp *pComp = pprog->FirstComp(); pComp; pComp = pComp->Next())
   {
      printf("%s\n",pComp->InputName());
      for(VProc *pProc = pComp->FirstProc(); pProc; pProc = pProc->Next())
      {
         for(VBBlock *pBlk = pProc->FirstBlock(); pBlk; pBlk = pBlk->Next())
         {
            if (fSkipObsolete && pBlk->IsObsolete())
            {
                continue;
            }

            //If we used FirstAllBlock and NextAll instead of FirstBlock and Next,
            //we would need to avoid data blocks (pBlk->IsDataBock())
            for(VInst *pInst = pBlk->FirstInst(); pInst; pInst = pInst->Next())
            {
               switch (pBlk->PlatformT())
               {

                  case platformtMSIL:
                     if (pInst->Opcode() == COp::CEE_NOP)
                     {
                       count++;
                       if (fPrintNop)
                       {
                           printf("NOP in block %8X addr=%08X\n", pBlk->BlockId(), pBlk->Addr());
                       }
                     }
                     break;

                  case platformtX86:
                     if (pInst->Opcode() == COp::NOP)
                     {
                       count++;
                       if (fPrintNop)
                       {
                           printf("NOP in block %8X addr=%08X\n", pBlk->BlockId(), pBlk->Addr());
                       }
                     }
                     break;

                  case platformtIA64:
                     if (pInst->Opcode() == COp::NOP_M ||
                         pInst->Opcode() == COp::NOP_I ||
                         pInst->Opcode() == COp::NOP_B ||
                         pInst->Opcode() == COp::NOP_F ||
                         pInst->Opcode() == COp::NOP_X)
                     {
                       count++;
                       if (fPrintNop)
                       {
                           printf("NOP in block %8X addr=%08X\n", pBlk->BlockId(), pBlk->Addr());
                       }
                     }
                     break;

                  default:
                       fprintf(stderr, "Unsupported architecture type\n");
                       exit(1);
               }
            }
         }
      }

      printf("Found %d nop's.\n", count);
   }
}

void GenerateReprocessibleImage()
{
   printf("Generating reprocessible image\n");

   DWORD openFlags = 0;
   if ( fCompact )
   {
      openFlags |= Open_CompactBlocks;
   }
   VProg *vprog = VProg::Open( szImage, szCmd, openFlags );
   VComp *pComp = vprog->FirstComp();

   // Currently only X86 PE binaries are supported.
   //
   if (pComp->InputType() != VComp::PE)
   {
      Error(VErr::FLG_FATAL, "Unsupported architecture.");
      exit(1);
   }

   if (pComp->CanWritePdb() && (szPdb == NULL))
   {
          Error(VErr::FLG_FATAL,"This executable (VC6 or higher) requires the /pdb option.");
   }

   if (!pComp->CanWritePdb() && (szPdb != NULL))
   {
      // If the /pdb switch was explicitly set and the binary is not VC6 or greater
      // then produce a warning that the PDB cannot be written.   If the /pdb switch
      // was not explicitly set,  then the szPdb contains a pdb name generated as the
      // default name and since it is not VC6 or greater the pdb name should be ignored.

      if(!fpdb)
      {
         szPdb = NULL;
      }
      else
      {
         Error(VErr::FLG_WARNING, "The option '/pdb' is not required for linking VC50 or earlier binaries - No PDB file generated.\n");
      }
   }

   if (pComp->IsEmittedByVulcan())
   {
      if (pComp->IsEmittedByBBT())
      {
         if (pComp->IsInstrumentedByBBT())
         {
            Error(VErr::FLG_FATAL,"REPROCESS cannot process a binary that was emitted by the BBT tool BBINSTR.");
         }
      }

      else if (!pComp->IsRereadable())
      {
         Error(VErr::FLG_FATAL,"REPROCESS can only process an original binary, a BBOPT binary or a DLLMERGE binary.");
      }
   }

   ReportFiles();

   //
   //  Check for Data / Resource Only binaries
   //  Cannot insert code into a binary which has no code section.
   //
   for (VSect* pSect = pComp->FirstSect(); pSect; pSect = pSect->Next())
   {
      if (pSect->IsExecutable())
         break;
   }
   if (!pSect)
   {
      printf("NOPs cannot be added to an binary which has no code.\n");
      fNoChange = true;
   }

   //
   // Count NOPs before any changes
   //
   CountNop(vprog);

   //
   // Add NOPs
   //
   AddNop(vprog);

   /***********************************************************************
   *
   * Now write the Re-Vulcanizable output image, which is enabled by passing
   * true for the fRereadable parameter to Write / WriteFast.
   * When fRereadable is TRUE, the output image can be reprocessed
   *
   ***********************************************************************/

   if ( fWriteFast )
   {
      pComp->WriteFast(szO, szPdb, NULL, fRereadable);
   }
   else
   {
      pComp->Write(szO, szPdb, NULL, fRereadable);
   }

   if (szAsm != NULL)
   {
       pComp->PrintAsm(szAsm);
   }

   vprog->Destroy();

   // Some info about the block types.
   if ( fBlockInfo )
   {
      VBlock::PrintBlockStats( "" );
   }
}

void ProcessReprocessibleImage()
{
   if (!fRereadable || fNoCount)
   {
      return;
   }

   printf("Processing reprocessible image\n");

   DWORD openFlags = 0;
   if ( fCompact )
   {
      openFlags |= Open_CompactBlocks;
   }
   //
   // Open the reprocessible image
   //
   VProg *vprog = VProg::Open( szO, szCmd, openFlags );

   // Currently only X86 PE binaries are supported.
   //
   if (vprog->FirstComp()->InputType() != VComp::PE)
   {
      Error(VErr::FLG_FATAL, "Unsupported architecture.");
      exit(1);
   }

   //
   // Count NOPs
   //
   CountNop(vprog);

   vprog->Destroy();
}

int RealMain(int argc, char *argv[])
{
/***********************************************************************
*
* RealMain() uses the Vulcan supplied command line interpreter to interpret the
* arguments (inside InitParams) and then makes sure that output file selected
* for the instrumented executable is not the same as the input executable.
* Finally the constructor for the Vulcan program is called and then the Reprocess
* process can begin.
*
***********************************************************************/

   InitParams(argc, argv);

   if (CMDLINE::FSamePath(szO, szImage))
   {
       Error(VErr::FLG_FATAL,"Reprocessed binary will overwrite input image file");
   }

   GenerateReprocessibleImage();
   ProcessReprocessibleImage();

   return(0);
}

int __cdecl main(int argc, char *argv[])
{

/***********************************************************************
*
* main() establishes the name of the utility as REPROCESS for the
* default error handler and then goes on to try running the real program.  If a
* throw occurs whiles processing with Vulcan,  the error is flagged as fatal
* and the default error handler is called to display the message.
*
***********************************************************************/

   VErr::SetErrHandler("REPROCESS");

   try
   {
      return RealMain(argc, argv);
   }
   catch (VErr &verr)
   {
      verr.SetFatal();
      verr.DoErrHandler();
   }

   return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\wavmerge\Helpers.cpp ===
#include "globals.h"
#include "cwavefile.h"

#define READBUFFERSIZE  131072 //must be divisible by 2

//------------------------------------------------------------------------------
//-----------------------------------------------------------------------------
HRESULT Error
(
    LPSTR                   szFormat,
    ...
)
{
    va_list va;
    char szBuffer[1000];

    va_start(va, szFormat);
    vsprintf(szBuffer, szFormat, va);
    va_end(va);

    printf("%s\n",szBuffer);
    return S_OK;
};


//------------------------------------------------------------------------------
//-----------------------------------------------------------------------------
HRESULT Log
(
    LPSTR                   szFormat,
    ...
)
{
    va_list va;
    char szBuffer[1000];

    va_start(va, szFormat);
    vsprintf(szBuffer, szFormat, va);
    va_end(va);

    printf("%s\n",szBuffer);
    return S_OK;
};


//------------------------------------------------------------------------------
//-----------------------------------------------------------------------------
HANDLE WaveOpenFile
(
    IN  LPCSTR          szFileName,
    OUT WAVEFORMATEX**  ppWaveFormatEx,
    OUT PULONG          pcbData
)
{
    HMMIO	        hmmio;              // mmio style file handle
    MMCKINFO        mmckinfoParent;	    // parent chunk info struct
    MMCKINFO        mmckinfoSubchunk;	// sub chunk

    HANDLE          hFile = INVALID_HANDLE_VALUE;
    ULONG	        cbFormat;
    LONG            lDataPos;

    // open the file
    if(!(hmmio = mmioOpen((LPSTR)szFileName, NULL, MMIO_READ | MMIO_ALLOCBUF))) 
    {
        return INVALID_HANDLE_VALUE;
    }

    // verify that the file is of type "WAVE" 
    mmckinfoParent.fccType = MAKEFOURCC('W', 'A', 'V', 'E');
    if(mmioDescend(hmmio, (LPMMCKINFO)&mmckinfoParent, NULL, MMIO_FINDRIFF))
    {
        // not a "WAVE" file!!
        Error("WaveOpenFile:  Missing 'WAVE' chunk.This does not appear to be a wave file.", "Error opening wave file!");
        goto _error_;
    }

    // find the "fmt " chunk (must be a subchunk of the "WAVE" chunk)
    mmckinfoSubchunk.ckid = MAKEFOURCC('f', 'm', 't', ' ');
    if(mmioDescend(hmmio, (LPMMCKINFO)&mmckinfoSubchunk, (LPMMCKINFO)&mmckinfoParent, MMIO_FINDCHUNK))
    {
        // file has no "fmt " chunk
        Error("WaveOpenFile:  Missing 'fmt ' chunk", "Error opening wave file!");
        goto _error_;
    }

    // get the size of the "fmt " chunk
    cbFormat = mmckinfoSubchunk.cksize;

    // allocate waveformat
    //*ppWaveFormatEx = (LPWAVEFORMATEX)LocalAlloc(LPTR, cbFormat);
    
    //Cheap hack.
    *ppWaveFormatEx = (LPWAVEFORMATEX)LocalAlloc(LPTR, sizeof(WAVEFORMATEX));
    if(!*ppWaveFormatEx)
    {
        // failed to allocate
        Error("WaveOpenFile:  Failed to allocate memory", "Error opening wave file!");
        goto _error_;
    }

    // read the "fmt " chunk
    if(mmioRead(hmmio, (HPSTR)*ppWaveFormatEx, cbFormat) != (LONG)cbFormat)
    {
        // failed to read the "fmt " chunk
        Error("WaveOpenFile:  Error reading 'fmt ' chunk", "Error opening wave file!");
        goto _error_;
    }

    // ascend out o' the "fmt " chunk
    mmioAscend(hmmio, &mmckinfoSubchunk, 0);

    // and find the data subchunk.  (current file pos should be at the beginning of the 
    // data chunk, but when you assume...)
    mmckinfoSubchunk.ckid = MAKEFOURCC('d', 'a', 't', 'a');
    if(mmioDescend(hmmio, &mmckinfoSubchunk, &mmckinfoParent, MMIO_FINDCHUNK))
    {
        // wave file doesn't appear to have a data chunk
        Error("WaveOpenFile:  Missing 'data' chunk", "Error opening wave file!");
        goto _error_;
    }

    // get the size of the "data" subchunk
    *pcbData = mmckinfoSubchunk.cksize;
    if(0L == *pcbData)
    {
        // the data chunk contains no data
        Error("WaveOpenFile:  Error reading 'data' chunk", "Error opening wave file!");
        goto _error_;
    }

    // remember the data 
    lDataPos = mmioSeek(hmmio, 0, SEEK_CUR);
    mmioClose(hmmio, 0);

    //
    // now we are done with the mmio functions.  Reopen the file and seek to the data chunk using normal
    // file io routines
    //

    __try
    {
        hFile = 
            CreateFile
            ( 
                szFileName, 
                GENERIC_READ, 
                FILE_SHARE_READ,
                NULL, 
                OPEN_EXISTING, 
                FILE_ATTRIBUTE_NORMAL,
                NULL 
            );
    }    
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        Error("HANDLING EXCEPTION THROWN BY CreateFile!", "Error opening wave file!");
        goto _error_;
    }

    if (INVALID_HANDLE_VALUE  == hFile)
    {
        goto _error_;
    }

    SetFilePointer
    (
        hFile,
        lDataPos,  
        NULL, 
        FILE_BEGIN
    ); 

    return hFile;
    
_error_:
    CloseHandle(hFile);
    if(hmmio)
    {
        mmioClose(hmmio, 0);
    }
    return INVALID_HANDLE_VALUE;
}




// -----------------------------------------------------------------------------------------
BOOL
WaveSaveFile
(
    IN  LPCSTR          szFileName,
    OUT WAVEFORMATEX*   pWaveFormatEx,
    IN  PVOID           pvData,
    IN  ULONG           cbData
)
{
    HANDLE          hFile = INVALID_HANDLE_VALUE;
    ULONG           cbWritten;
	HRSRC           hrsrc = (HRSRC)INVALID_HANDLE_VALUE;
    void*           pv = NULL;

    //
    // now we are done with the mmio functions.  Reopen the file and seek to the data chunk using normal
    // file io routines
    //

    __try
    {
        hFile = 
            CreateFile
            ( 
                szFileName, 
                GENERIC_WRITE, 
                0,
                NULL, 
                CREATE_ALWAYS, 
                FILE_ATTRIBUTE_NORMAL,
                NULL 
            );
    }    
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        Error("HANDLING EXCEPTION THROWN BY CreateFile!", "Error opening wave file!");
        goto _error_;
    }

    if (INVALID_HANDLE_VALUE == hFile)
        goto _error_;

	// 
	// write file header
	//

    // standard wave goo
    struct
    {
        DWORD   fourccData;
        DWORD   dwDataLength;
    } DataHeader;

    DataHeader.fourccData         = MAKEFOURCC('d','a','t','a');
    DataHeader.dwDataLength       = cbData;

    struct 
    {
        DWORD       dwRiff;
        DWORD       dwFileSize;
        DWORD       dwWave;
        DWORD       dwFormat;
        DWORD       dwFormatLength;
    } FileHeader;

    FileHeader.dwRiff             = MAKEFOURCC('R','I','F','F');
    FileHeader.dwWave             = MAKEFOURCC('W','A','V','E');
    FileHeader.dwFormat           = MAKEFOURCC('f','m','t',' ');
    FileHeader.dwFormatLength     = sizeof(WAVEFORMATEX) + pWaveFormatEx->cbSize;

    // File size is size of the whole file except for the dwRiff and dwFileSize fields.

    FileHeader.dwFileSize         = sizeof(FileHeader) + FileHeader.dwFormatLength + sizeof(DataHeader) + cbData - 8;

    if(!WriteFile(hFile, &FileHeader, sizeof(FileHeader), &cbWritten, NULL))
        goto _error_;

    // wave format
    if(!WriteFile(hFile, pWaveFormatEx, sizeof(WAVEFORMATEX) + pWaveFormatEx->cbSize, &cbWritten, NULL))
        goto _error_;

    // data chuck
    if(!WriteFile(hFile, &DataHeader, sizeof(DataHeader), &cbWritten, NULL))
        goto _error_;

    //
    // Write wave data
    //
    if(!WriteFile(hFile, pvData, cbData, &cbWritten, NULL))
        goto _error_;

    CloseHandle(hFile);
    return TRUE;
    
_error_:
    Error("Error Writing File", "Error!");
    CloseHandle(hFile);
    return FALSE;
}



// -----------------------------------------------------------------------------------------
HANDLE
WaveOpenFileForSave
(
    IN  LPCSTR          szFileName,
    OUT WAVEFORMATEX*   pWaveFormatEx,
    DWORD               cbData
)
{
    HANDLE          hFile = INVALID_HANDLE_VALUE;
    ULONG           cbWritten;
	HRSRC           hrsrc = (HRSRC)INVALID_HANDLE_VALUE;
    void*           pv = NULL;

    //
    // now we are done with the mmio functions.  Reopen the file and seek to the data chunk using normal
    // file io routines
    //

    __try
    {
        hFile = 
            CreateFile
            ( 
                szFileName, 
                GENERIC_WRITE, 
                0,
                NULL, 
                CREATE_ALWAYS, 
                FILE_ATTRIBUTE_NORMAL,
                NULL 
            );
    }    
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        Error("HANDLING EXCEPTION THROWN BY CreateFile!", "Error opening wave file!");
        goto _error_;
    }

    if (INVALID_HANDLE_VALUE == hFile)
        goto _error_;

	// 
	// write file header
	//

    // standard wave goo
    struct
    {
        DWORD   fourccData;
        DWORD   dwDataLength;
    } DataHeader;

    DataHeader.fourccData         = MAKEFOURCC('d','a','t','a');
    DataHeader.dwDataLength       = cbData;

    struct 
    {
        DWORD       dwRiff;
        DWORD       dwFileSize;
        DWORD       dwWave;
        DWORD       dwFormat;
        DWORD       dwFormatLength;
    } FileHeader;

    FileHeader.dwRiff             = MAKEFOURCC('R','I','F','F');
    FileHeader.dwWave             = MAKEFOURCC('W','A','V','E');
    FileHeader.dwFormat           = MAKEFOURCC('f','m','t',' ');
    FileHeader.dwFormatLength     = sizeof(WAVEFORMATEX) + pWaveFormatEx->cbSize;

    // File size is size of the whole file except for the dwRiff and dwFileSize fields.

    FileHeader.dwFileSize         = sizeof(FileHeader) + FileHeader.dwFormatLength + sizeof(DataHeader) + cbData - 8;

    if(!WriteFile(hFile, &FileHeader, sizeof(FileHeader), &cbWritten, NULL))
        goto _error_;

    // wave format
    if(!WriteFile(hFile, pWaveFormatEx, sizeof(WAVEFORMATEX) + pWaveFormatEx->cbSize, &cbWritten, NULL))
        goto _error_;

    // data chuck
    if(!WriteFile(hFile, &DataHeader, sizeof(DataHeader), &cbWritten, NULL))
        goto _error_;

    return hFile;
    
_error_:
    Error("Error Writing File", "Error!");
    CloseHandle(hFile);
    return INVALID_HANDLE_VALUE;
}


/********************************************************************************
********************************************************************************/
BOOL YesOrNo(void)
{
    CHAR c = 'a';

    do
    {
        //c = (char)_getch();
        scanf("%c", &c);
    }
    while (tolower(c) != 'n' && tolower(c) != 'y');

    if (tolower(c) != 'y')
        return FALSE;
    else
        return TRUE;

};


/********************************************************************************
Hack together a CWaveFile object in 5.1 and write it out to disk.
********************************************************************************/
#define MAXCHANNELS 10
HRESULT Merge(CWaveFile WaveFile[], LPSTR szOutputFile, DWORD dwNumChannels)
{
    CWaveFile OutputFile;
    WAVEFORMATEX wfxIn = {0};
    WAVEFORMATEX wfxOut = {0};
    DWORD i = 0;
    DWORD j = 0;
    HRESULT hr = S_OK;
    DWORD dwTemp = 0;
    DWORD dwNextPercentGoal= 0;
    
    DWORD cbDataLongest = 0;        //Data length of longest file.
    DWORD cbSamplesRemaining = 0;   //Samples remaining to write to output file.
    DWORD cbSamplesMix       = 0;   //How many samples to mix this iteration.
    DWORD cbSamplesPerBuffer = 0;
    DWORD dwSampleSize       = 0;
    bool bEightBit = false;
    LPVOID *pvRead = NULL;
    LPVOID pvWrite   = NULL;

    if (READBUFFERSIZE % 2)
    {
        //Log("Error: specified buffer size %u is not divisible by NUMCHANNELS * 2 (%u)", READBUFFERSIZE, NUMCHANNELS * 2);
        Log("Error: specified buffer size %u is not divisible by 2", READBUFFERSIZE);
        return E_FAIL;
    }

    //Allocate an array of void ptrs for the channels.
    pvRead = new LPVOID[dwNumChannels];
    if (!pvRead)
    {
        Log("Error: Couldn't allocate a measly %u bytes; exitting", dwNumChannels * sizeof(LPVOID));
        return E_FAIL;
    }

    ZeroMemory(pvRead, dwNumChannels * sizeof(LPVOID));
    //Check to see if the file exists.
    if (_access(szOutputFile, 00) == 0)
    {

        //Check to see if the file is writeable.
        if (_access(szOutputFile, 02) != 0)
        {
            Log("Error: Cannot write to %s.", szOutputFile);
            return E_FAIL;
        }

        printf("%s exists, overwrite? (y/n) ", szOutputFile);
        if (!YesOrNo())
            return E_FAIL;
    }


    
    //Get the length of the longest file; that will determine the length of our output file.
    for (i=0; i<dwNumChannels; i++)
    {   
        WaveFile[i].GetLength(&dwTemp);
        if (dwTemp > cbDataLongest)
            cbDataLongest = dwTemp;
    }

    //Allocate the read buffers
    for (i=0; i<dwNumChannels; i++)
    {
        pvRead[i] = LocalAlloc(LPTR, READBUFFERSIZE);
        if (!pvRead[i])
        {
            Log("Out of memory, failed to allocate %u bytes", READBUFFERSIZE);
            hr = E_FAIL;
        }
    }

    //our output buffer is NUMCHANNELS times the size of our regular one.
    if (SUCCEEDED(hr))
    {
        pvWrite = LocalAlloc(LPTR, READBUFFERSIZE * dwNumChannels);
        if (!pvWrite)
        {
            Log("Out of memory, failed to allocate %u bytes", READBUFFERSIZE * dwNumChannels);
            hr = E_FAIL;
        }
    }
    
    //Set the WFX to the proper format.  All the wave files (even when silenced) have the same wave format.
    CHECKRUN(WaveFile[0].GetWaveFormatEx(&wfxIn));

    if (SUCCEEDED(hr))
    {
        wfxOut.wFormatTag = wfxIn.wFormatTag;
        wfxOut.nChannels  = (unsigned short)dwNumChannels;
        wfxOut.nSamplesPerSec = wfxIn.nSamplesPerSec;
        wfxOut.nAvgBytesPerSec = wfxIn.nAvgBytesPerSec * dwNumChannels;
        wfxOut.nBlockAlign = wfxIn.nBlockAlign * (unsigned short)dwNumChannels;
        wfxOut.wBitsPerSample = wfxIn.wBitsPerSample;
        wfxOut.cbSize = 0;

        //Samples are half as many if we're 16-bit.
        if (8 == wfxIn.wBitsPerSample)
        {
            bEightBit = true;
            dwSampleSize = 1;
        }
        else if (16 == wfxIn.wBitsPerSample)
        {
            bEightBit = false;
            dwSampleSize = 2;
        }
        else
        {
            Log("Error: Data is not 8 or 16-bit!");
            hr = E_FAIL;
        }
    }

    if (SUCCEEDED(hr))
    {
        //Open this file for writing.
        CHECKRUN(OutputFile.OpenForWrite(szOutputFile, wfxOut, cbDataLongest * dwNumChannels));
        if (SUCCEEDED(hr))
        {
            cbSamplesPerBuffer = READBUFFERSIZE / dwSampleSize;
            cbSamplesRemaining = cbDataLongest / dwSampleSize;
            //Initialize the output:
            printf("% Done: 0%%");
        }

        while (cbSamplesRemaining && SUCCEEDED(hr))
        {
                //Zero out the destination buffer.
                memset(pvWrite, 0, READBUFFERSIZE);

                //How many samples are we mixing?  Take the minimum of what's remaining and the maximum size we can take.
                cbSamplesMix = (cbSamplesRemaining > cbSamplesPerBuffer) ? cbSamplesPerBuffer : cbSamplesRemaining;

                for (j=0; j<dwNumChannels && SUCCEEDED(hr); j++)
                {
                    DWORD cbSamplesRead = 0;

                    //Simply read in the data for this channel.
                    memset(pvRead[j], 0xCC, cbSamplesMix * dwSampleSize);  //if we see a line of 0xCC values when viewing the wave file we'll know something's wrong.
                    CHECKRUN(WaveFile[j].ReadData(pvRead[j], READBUFFERSIZE, &cbSamplesRead));

                    cbSamplesRead /= dwSampleSize;

                    for (i=0; i<cbSamplesMix && SUCCEEDED(hr); i++)
                    {
                        
                        //Again, note that silence for 8-bit buffers is 0x80, while silence for 16-bit buffers is 0x0000                        
                        if (bEightBit)
                        {
                            //Set up our in and out pointers.
                            BYTE *pbOut = (BYTE *)pvWrite;
                            const BYTE *pbIn = (BYTE *)pvRead[j];

                            if (i < cbSamplesRead)
                                pbOut[i * dwNumChannels + j] = pbIn[i];
                            else
                                pbOut[i * dwNumChannels + j] = 0x80;
                        }

                        else
                        {
                            //Set up our in and out pointers.
                            WORD *pwOut = (WORD *)pvWrite;
                            const WORD *pwIn = (WORD *)pvRead[j];

                            if (i < cbSamplesRead)
                                pwOut[i * dwNumChannels + j] = pwIn[i];
                            else
                                pwOut[i * dwNumChannels + j] = 0x0000;
                        }
                    }
                }


                //Write the mixed buffer to disk.
                DWORD cbWritten;
                CHECKRUN(OutputFile.WriteData(pvWrite, cbSamplesMix * dwSampleSize * dwNumChannels, &cbWritten));
                if (cbWritten != cbSamplesMix * dwSampleSize * dwNumChannels)
                { 
                    Log("Error: Only wrote %u bytes instead of %u", cbWritten, cbSamplesMix * dwSampleSize * dwNumChannels);
                    hr = E_FAIL;
                }

                cbSamplesRemaining -= cbSamplesMix;

                //remaining samples
                while (  FLOAT((cbDataLongest / dwSampleSize) - cbSamplesRemaining) * 100.f / FLOAT(cbDataLongest / dwSampleSize) >= FLOAT(dwNextPercentGoal + 10))
                {
                    dwNextPercentGoal += 10;
                    printf("...%d%%", dwNextPercentGoal);
                }
        }
    }
    
    //Carriage return.
    Log("");



    //Close all our files and free our buffers.
    delete []pvRead;        
    CHECKRUN(OutputFile.Close());
    for (i=0; i<dwNumChannels && SUCCEEDED(hr); i++)
    {
        CHECKRUN(WaveFile[i].Close());
        if (pvRead[i])
            LocalFree(pvRead[i]);
    }
    if (pvWrite)
        LocalFree(pvWrite);

return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\Samples\src\SymIter\symiter.cpp ===
/***********************************************************************
* Microsoft  Vulcan
*
* Microsoft Confidential.  Copyright 1997-1999 Microsoft Corporation.
*
* File: symiter.cpp
*
* File Comments:
*
*
***********************************************************************/
#pragma warning(disable: 4514)

#include <stdio.h>
#include "vulcanapi.h"


void symiter(char* szImage)
{
   VProg *pprog = VProg::Open(szImage);

   for(VComp *pComp = pprog->FirstComp(); pComp; pComp = pComp->Next())
   {
      ADDR         addr;
      const char*  szName;
      VSymIter     *psiProc;   
      VSymIter     *psiBlk;

      printf("*** Inputname : %s ***\n", pComp->InputName());

      //
      // Print symbols for procedures
      //
      for(VProc *pProc = pComp->FirstProc(); pProc; pProc = pProc->Next())
      {
         psiProc = pProc->Symbols(pComp);
         for (psiProc->First(); !psiProc->Done() ; psiProc->Next())
         {
            addr = pProc->Addr();
            printf("<%08lx>\n", addr);

            if (psiProc->IsPublic())
            {
              szName = psiProc->SymName();
              printf("\tPublicProc   : %s\n", szName);

              szName = psiProc->Name();
              printf("\tPublicProcUnd: %s\n", szName);
            }
            else
            {
              szName = psiProc->SymName();
              printf("\tProc   : %s\n", szName);

              szName = psiProc->Name();
              printf("\tProcUnd: %s\n", szName);
            }
         }

         //
         // Print symbols for blocks
         //
         for(VBBlock *pBlk = pProc->FirstBlock(); pBlk; pBlk = pBlk->Next())
         {
            psiBlk = pBlk->Symbols(pComp);
            for (psiBlk->First(); !psiBlk->Done(); psiBlk->Next())
            {
               addr = pBlk->Addr();
               printf("\t\t<%08lx>\n", addr);

               if (psiBlk->IsPublic())
               {
                  szName = psiBlk->SymName();
                  printf("\t\t\tPublicBlk    : %s\n", szName);

                  szName = psiBlk->SymName();
                  printf("\t\t\tPublicBlkUnd : %s\n", szName);
               }
               else
               {
                  szName = psiBlk->SymName();
                  printf("\t\t\tBlk          : %s\n", szName);

                  szName = psiBlk->Name();
                  printf("\t\t\tBlkUnd       : %s\n", szName);
               }
            }
         }
       
         if (psiBlk)
         {
             // 
             // Always destroy to avoid leaks
             //
             psiBlk->Destroy();
         }
      }

      if (psiProc)
      {
         // 
         // Always destroy to avoid leaks
         //
         psiProc->Destroy();
      }
   }

   pprog->Destroy();
}


int __cdecl main(int argc, char** argv)
{

   if (argc != 2)
   {
      printf("usage: symiter foo.exe\n");
      return 1;
   }

   try
   {
      symiter(argv[1]);
   }
   catch (VErr& verr)
   {
      verr.SetFatal();
      verr.DoErrHandler();
   }

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\Samples\src\RegsUseDef\regsusedef.cpp ===
/***********************************************************************
* Microsoft  Vulcan
*
* Microsoft Confidential.  Copyright 1997-1999 Microsoft Corporation.
*
* File: RegsUseDef.cpp
*
* File Comments:
*
*
***********************************************************************/
#pragma warning(disable: 4514)

#include "vulcanapi.h"
#include "vulcanbmp.h"

#include <stdlib.h>
#include <stdio.h>

int __cdecl main(int argc, char** argv);
void __stdcall Myhandler(VErr verr);
void UIRegs(char* szImage);
void PrintSetRegs( CBmp *pBmp );


void UIRegs(char* szImage)
{
   VProg *pprog = VProg::Open(szImage);

   CBmp bmp( X86Register::X86REGMAX );

   for(VComp *pComp = pprog->FirstComp(); pComp; pComp = pComp->Next())
   {
      printf("%s\n",pComp->InputName());
      for(VProc *pProc = pComp->FirstProc(); pProc; pProc = pProc->Next())
      {
         printf("%s:\n",pProc->Name());
         for(VBlock *pBlk = pProc->FirstBlock(); pBlk; pBlk = pBlk->Next())
         {
            for(VInst *pInst = pBlk->FirstInst(); pInst; pInst = pInst->Next())
	         {
               char szBuf[256]; 
               pInst->PrintAsm( szBuf, sizeof(szBuf), pComp );
               printf(szBuf);

               bmp.ReInitialize();
               pInst->RegsUse( &bmp, true );

               printf("\tUses (no cover): ");
               PrintSetRegs( &bmp );
               printf("\n");

               bmp.ReInitialize();
               pInst->RegsUse( &bmp, false );
               
               printf("\tUses (cover): ");
               PrintSetRegs( &bmp );
               printf("\n");

               bmp.ReInitialize();
               pInst->RegsDef( &bmp, true );

               printf("\tDefs (no cover): ");
               PrintSetRegs( &bmp );
               printf("\n");

               bmp.ReInitialize();
               pInst->RegsDef( &bmp, false );

               printf("\tDefs (cover): ");
               PrintSetRegs( &bmp );
               printf("\n\n");
            }
         }
      }                             
   }

   // To save time, we don't destroy the program object
   // pprog->Destroy();

   // This should only be called after ALL Vulcan objects have been Destroyed
   // It will clean up any outstanding allocations
   // VulcanCleanUpAllAllocations();
}

char* ConvertX86RegToStr(ERegister reg)
{
   X86Reg ereg = (X86Reg) reg;


   // You'll notice in this function references to registers like EAH
   // We created EAH to independantly represent the high 16 bits of EAX.  
   // Thus, the x86 register picture looks like:
   //
   // +===========================+
   // |            EAX            |
   // +=============+=============+
   // |             |     AX      |
   // |     EAH     +======+======+
   // |             |  AH  |  AL  |
   // +=============+======+======+
   //


   switch (ereg)
   {
   case X86Register::AL:           return "AL";
   case X86Register::AH:           return "AH";
   case X86Register::AX:           return "AX";
   case X86Register::EAX:          return "EAX";
   case X86Register::EAH:          return "EAH"; 

   case X86Register::BL:           return "BL";
   case X86Register::BH:           return "BH";
   case X86Register::BX:           return "BX";
   case X86Register::EBX:          return "EBX";
   case X86Register::EBH:          return "EBH";

   case X86Register::CL:           return "CL";
   case X86Register::CH:           return "CH";
   case X86Register::CX:           return "CX";
   case X86Register::ECX:          return "ECX";
   case X86Register::ECH:          return "ECH";

   case X86Register::DL:           return "DL";
   case X86Register::DH:           return "DH";
   case X86Register::DX:           return "DX";
   case X86Register::EDX:          return "EDX";
   case X86Register::EDH:          return "EDH";

   case X86Register::SI:           return "SI";
   case X86Register::ESI:          return "ESI";
   case X86Register::SIH:          return "SIH";

   case X86Register::DI:           return "DI";
   case X86Register::EDI:          return "EDI";
   case X86Register::DIH:          return "DIH";

   case X86Register::SP:           return "SP";
   case X86Register::ESP:          return "ESP";
   case X86Register::SPH:          return "SPH";

   case X86Register::BP:           return "BP";
   case X86Register::EBP:          return "EBP";
   case X86Register::BPH:          return "BPH";

   //case X86Register::EFLAGS:     return "EFLAGS";
   case X86Register::CF:           return "CF";
   case X86Register::PF:           return "PF";
   case X86Register::AF:           return "AF";
   case X86Register::ZF:           return "ZF";
   case X86Register::SF:           return "SF";
   case X86Register::TF:           return "TF";
   case X86Register::IF:           return "IF";
   case X86Register::DF:           return "DF";
   case X86Register::OF:           return "OF";

   case X86Register::IP:           return "IP";
   case X86Register::EIP:          return "EIP";

   case X86Register::CS:           return "CS";
   case X86Register::DS:           return "DS";
   case X86Register::SS:           return "SS";
   case X86Register::ES:           return "ES";
   case X86Register::FS:           return "FS";
   case X86Register::GS:           return "GS";

   case X86Register::TR0:          return "TR0";
   case X86Register::TR1:          return "TR1";
   case X86Register::TR2:          return "TR2";
   case X86Register::TR3:          return "TR3";
   case X86Register::TR4:          return "TR4";
   case X86Register::TR5:          return "TR5";
   case X86Register::TR6:          return "TR6";
   case X86Register::TR7:          return "TR7";

   case X86Register::DR0:          return "DR0";
   case X86Register::DR1:          return "DR1";
   case X86Register::DR2:          return "DR2";
   case X86Register::DR3:          return "DR3";
   case X86Register::DR4:          return "DR4";
   case X86Register::DR5:          return "DR5";
   case X86Register::DR6:          return "DR6";
   case X86Register::DR7:          return "DR7";

   case X86Register::CR0:          return "CR0";
   case X86Register::CR1:          return "CR1";
   case X86Register::CR2:          return "CR2";
   case X86Register::CR3:          return "CR3";
   case X86Register::CR4:          return "CR4";
   case X86Register::CR5:          return "CR5";
   case X86Register::CR6:          return "CR6";
   case X86Register::CR7:          return "CR7";

   case X86Register::MM0:          return "MM0";
   case X86Register::MM1:          return "MM1";
   case X86Register::MM2:          return "MM2";
   case X86Register::MM3:          return "MM3";
   case X86Register::MM4:          return "MM4";
   case X86Register::MM5:          return "MM5";
   case X86Register::MM6:          return "MM6";
   case X86Register::MM7:          return "MM7";

   case X86Register::XMM0:         return "XMM0";
   case X86Register::XMM1:         return "XMM1";
   case X86Register::XMM2:         return "XMM2";
   case X86Register::XMM3:         return "XMM3";
   case X86Register::XMM4:         return "XMM4";
   case X86Register::XMM5:         return "XMM5";
   case X86Register::XMM6:         return "XMM6";
   case X86Register::XMM7:         return "XMM7";
   
   default:
         return "?";
   }
};


void PrintSetRegs( CBmp *pBmp )
{
   size_t iBit = ibitNil;
   while (ibitNil != (iBit = pBmp->IbitNextSet( iBit )))
   {
      printf(" %s", ConvertX86RegToStr( (ERegister)iBit ));
   }
}

int __cdecl main(int argc, char** argv)
{

   if (argc != 2)
   {
      printf("usage: RegsUseDef foo.exe\n");
      return 1;
   }

   try
   {
      UIRegs(argv[1]);
   }
   catch (VErr& verr) 
   {
      printf("Error: %s\n",verr.GetWhat());
      return 1;
   }
   catch (...)
   {
      printf("Error: unknown\n");
      return 1; 
   }

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\Vulcan\Samples\src\Recover\recover.cpp ===
/***********************************************************************
* Microsoft  Vulcan
*
* Microsoft Confidential.  Copyright 1999 Microsoft Corporation.
*
* File: Recover.cpp
*
* File Comments: Force execution IA64 recovery code sequences.
*
*
***********************************************************************/
#pragma warning(disable: 4514)

#include "vulcanapi.h"

#include <stdio.h>
#include <stdlib.h>

int __cdecl main(int argc, char** argv);
void __stdcall Myhandler(VErr verr);
void StressRecoveryCode(char* szImage);


void StressRecoveryCode(char* szImage)
{
   VProg *pprog = VProg::Open(szImage);
   int aTrans = 0, sTrans = 0, saTrans = 0;

   for(VComp *pComp = pprog->FirstComp(); pComp; pComp = pComp->Next())
   {
      printf("%s\n",pComp->InputName());
      for(VProc *pProc = pComp->FirstProc(); pProc; pProc = pProc->Next())
      {
         for(VBBlock *pBlk = pProc->FirstBlock(); pBlk; pBlk = pBlk->Next())
         {
            if (pBlk->PlatformT() != platformtIA64)
            {
               printf("usage: recover foo.exe (IA64 binaries only)\n");
               exit(1);
            }

            // If we used FirstAllBlock and NextAll instead of FirstBlock
            // and Next, we would need to avoid data blocks.

            for(VInst *pInst = pBlk->FirstInst(); pInst; pInst = pInst->Next())
            {
               if (pInst->IsMarker()) continue;

               switch (pInst->Opcode())
               {
                  case COp::LDD:
                  case COp::LDW:
                  case COp::LDH:
                  case COp::LDB:

                     // Currently not handling post-incrementing,
                     // speculative loads.

                     if (pInst->Operand(Inst::Src2).Type() != OpndNotUsed)
                     {
                        break;
                     }

                     // Replace ld.a rx=[ry] with ld rx=[ry]

                     if (pInst->TestCompleter(LdAdvanced))
                     {
                        pInst->SetCompleter(LdNone);
                        aTrans++;
                     }

                     else if (pInst->TestCompleter(LdSpeculative))
                     {
                        // Replace ld.s rx=[ry] with ld.s rx=[r0]

                        VOperand address = VAddress::Create(Register::GR0, 0 );
                        pInst->SetOperand(Inst::Src1, address);
                        sTrans++;
                     }

                     else if (pInst->TestCompleter(LdSpeculativeAdvanced))
                     {
                        // Replace ld.sa rx=[ry] with ld.sa rx=[r0]

                        VOperand address = VAddress::Create(Register::GR0, 0 );
                        pInst->SetOperand(Inst::Src1, address);
                        saTrans++;
                     }
                     break;
                       
                  default:
                     break;
               }
            }
         }
      }

      pComp->Write();
   }

   // To save time, we don't destroy the program object
   // pprog->Destroy();

   printf("\nld.a  Transformations = %d\n", aTrans);
   printf("ld.s  Transformations = %d\n", sTrans);
   printf("ld.sa Transformations = %d\n", saTrans);
}


int __cdecl main(int argc, char** argv)
{

   if (argc != 2)
   {
      printf("usage: recover [Image-Name] (IA64 binaries only)\n");
      return 1;
   }

   try
   {
      StressRecoveryCode(argv[1]);
   }

   catch (VErr& verr) 
   {
      printf("Error: %s\n", verr.GetWhat());
      return 1;
   }

   catch (...)
   {
      printf("Error: unknown\n");
      return 1; 
   }

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xcrypt\enc.h ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    enc.h

Abstract:


--*/

#ifndef _ENC_H
#define _ENC_H

#include <windows.h>
 
#define XC_ENCFILE_SIG             'k2ne' // signature dword in the encrypted file


#define RC4_CONFOUNDER_LEN          8
#define HMAC_K_PADSIZE              64

typedef struct _RC4_SHA1_HEADER {
    UCHAR Checksum[A_SHA_DIGEST_LEN];
    UCHAR Confounder[RC4_CONFOUNDER_LEN];
} RC4_SHA1_HEADER, *PRC4_SHA1_HEADER;



typedef struct _XC_ENCFILE_HEADER
{
    DWORD Sig;
    RC4_SHA1_HEADER CryptHeader;
    DWORD MsgLen;
    UCHAR MsgDigest[A_SHA_DIGEST_LEN];
} XC_ENCFILE_HEADER, *PXC_ENCFILE_HEADER;



BOOL
XcWriteEncryptedFile(
    PBYTE pMessage,
    DWORD cbMsgLen,
    LPCSTR pszFN,
    LPCSTR pszPassword,
    PBYTE pConfounder  // RC4_CONFOUNDER_LEN bytes
    );
 
BOOL 
XcReadEncryptedFile(
    LPCSTR pszFN, 
    LPCSTR pszPassword,
    PBYTE pMsgBuf,
    DWORD cbMsgBufLen
    );

BOOL 
XcGetEncryptedFileMsgLen(
    LPCSTR pszFN,
    PDWORD pdwSize
    );


#endif // _ENC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\wavmerge\Helpers.h ===
#pragma once


HANDLE WaveOpenFile
(
    IN  LPCSTR          szFileName,
    OUT WAVEFORMATEX**  ppWaveFormatEx,
    OUT PULONG          pcbData
);



BOOL
WaveSaveFile
(
    IN  LPCSTR          szFileName,
    OUT WAVEFORMATEX*   pWaveFormatEx,
    IN  PVOID           pvData,
    IN  ULONG           cbData
);


// -----------------------------------------------------------------------------------------
HANDLE
WaveOpenFileForSave
(
    IN  LPCSTR          szFileName,
    OUT WAVEFORMATEX*   pWaveFormatEx,
    DWORD               cbData

);




HRESULT Error(LPSTR szFormat, ...);
HRESULT Log  (LPSTR szFormat, ...);
HRESULT Merge(CWaveFile WaveFile[], LPSTR szOutputFile, DWORD dwNumChannels);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xcrypt\list.h ===
//  LIST.H
//
//		Doubly-linked lists
//
//	Created 15-Mar-2000 [JonT]


#ifndef __LIST_H__
#define __LIST_H__

// To use this very simple list package, create a CListHead object then add CNode objects to it

class CListHead;

class CNode
{
private:
	CNode* m_pNext;
	CNode* m_pPrev;

public:
	CNode() 
    { 
        m_pNext = m_pPrev = NULL;
    }
	virtual ~CNode();
	
    CNode* Next() { return m_pNext; }
	CNode* Prev() { return m_pPrev; }

    void Link(CListHead* pList, CNode* pBefore);
	void Unlink(CListHead* pList);

    virtual void Dump();
};

class CListHead
{
private:
	CNode* m_pHead;
	CNode* m_pTail;

public:
	CListHead() { m_pHead = m_pTail = NULL; }
	~CListHead();
	CNode* GetHead(void) { return m_pHead; }
	CNode* GetTail(void) { return m_pTail; }

    void Dump(LPCSTR pszTitle, int nLevel);

    DWORD Count();

friend CNode;
};


#endif // #ifndef __LIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\wavmerge\macros.h ===
#pragma once

#define QUOTE0(a)               #a
#define QUOTE1(a)               QUOTE0(a)

#define MESSAGE(a)              message(__FILE__ "(" QUOTE1(__LINE__) "): " a)
#define TODO(a)                 MESSAGE("TODO: " a)

#define RELEASE( p )                                                 \
{                                                                    \
	if( NULL != p )                                                  \
		p->Release();                                                \
                                                                     \
    p = NULL;                                                        \
}

#define SAFEDELETE( p )                                              \
{                                                                    \
	delete p;                                                        \
	p = NULL;                                                        \
}

#define SAFECLOSEHANDLE( h )                                         \
{                                                                    \
	if ( NULL != h )                                                 \
		CloseHandle( h );                                            \
		                                                             \
	h = NULL;                                                        \
}

#define CHECKPTR( p )												 \
if ( NULL == p )													 \
{																	 \
	DbgPrint( "Argument was NULL\n" );								 \
	hr = E_POINTER;													 \
}

#define CHECKALLOC( p )                                              \
if ( NULL == p )                                                     \
{                                                                    \
	DbgPrint( #p ## " was NULL\n" );                                 \
	hr = E_OUTOFMEMORY;                                              \
}                                                                    

#define ALLOCATEANDCHECKSTRUCT( p, type )                            \
if ( SUCCEEDED( hr ) )			                                     \
{								                                     \
	p = new type();				                                     \
									                                 \
	CHECKALLOC( p );                                                 \
	                                                                 \
	if ( SUCCEEDED( hr ) )                                           \
	{                                                                \
	   memset( p, 0, sizeof( type ) );                               \
	}                                                                \
}	

#define ALLOCATEANDCHECK( p, type )                                  \
if ( SUCCEEDED( hr ) )                                               \
{                                                                    \
    p = new type();                                                  \
                                                                     \
    CHECKALLOC( p );                                                 \
                                                                     \
}							

#ifdef NOLOGGING
#define SETLOG( handle, name, comp, subcomp, func )
#else // NOLOGGING
#define SETLOG( handle, name, comp, subcomp, func )                  \
{                                                                    \
   g_hLog = handle;                                                  \
   xSetOwnerAlias( g_hLog, name );                                   \
   xSetComponent( g_hLog, comp, subcomp );                           \
   xSetFunctionName( g_hLog, func );                                 \
}
#endif //NOLOGGING

#ifdef NOLOGGING
#define EXECUTE( func )                                              \
{                                                                    \
	hr = func;                                                       \
	if ( FAILED( hr ) )                                              \
	{                                                                \
	    DbgPrint( #func ## " returned: 0x%x\n", hr );                \
	}                                                                \
}
#else // NOLOGGING
#define EXECUTE( func )                                              \
{                                                                    \
	hr = func;                                                       \
	if ( FAILED( hr ) )                                              \
	{                                                                \
	    DbgPrint( #func ## " returned: 0x%x\n", hr );                \
		xLog( g_hLog, XLL_FAIL, #func ## " returned: 0x%x\n", hr );  \
	}                                                                \
	else                                                             \
	{                                                                \
		xLog( g_hLog, XLL_PASS, #func ## " returned: 0x%x\n", hr );  \
	}                                                                \
	                                                                 \
}   
#endif // NOLOGGING                                                                 

#define CHECKEXECUTE( func )                                         \
if ( SUCCEEDED( hr ) )                                               \
{                                                                    \
    EXECUTE( func );                                                 \
}

#define CHECK( exp )                                                 \
if ( SUCCEEDED( hr ) )                                               \
{                                                                    \
	exp;                                                             \
}

#define FAIL_ON_CONDITION( exp )                                     \
if ( exp )                                                           \
{                                                                    \
    ASSERT( ! ( exp ) );                                             \
    hr = E_FAIL;                                                     \
}

//Runs the function without printing anything.
#define RUN( func )                                                  \
{                                                                    \
	hr = func;                                                       \
}                                                                    

//Checks and runs the function without printing anything.
#define CHECKRUN( exp )                                              \
if ( SUCCEEDED( hr ) )                                               \
{                                                                    \
	RUN(exp);                                                        \
}


#define NUMELEMS(x) ( sizeof( x ) / sizeof( ( x ) [0] ) )

#define SUCCEED_ON_FAIL( hr, expected ) expected == hr ? S_OK : hr
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xcrypt\property.h ===
//  PROPERTY.H
//
//		Text property handling
//
//	Created 15-Mar-2000 [JonT]

#ifndef __PROPERTY_H__
#define __PROPERTY_H__

class CProperty;

#define TABLE_SIZE 4001		// prime number

class CPropertyBundle
{
private:
	CListHead m_lhHashTable[TABLE_SIZE];
	int HashNameToIndex(LPCTSTR lpszName);
	CProperty* Find(LPCTSTR lpszName);

public:
	LPCTSTR Get(LPCTSTR lpszName);
	void Set(LPCTSTR lpszName, LPCTSTR lpszValue);
};


// CProperty
//	Handles storage for property values. This is a private class, it's never handed back.
//	It's just used for CPropertyBundle's use.

class CProperty : public CNode
{
public:
    CProperty()
        : m_lpszName(NULL),
          m_lpszValue(NULL)
    {
    }

    ~CProperty()
    {
        if (m_lpszName != NULL)
            free(m_lpszName);
        if (m_lpszValue != NULL)
            free(m_lpszValue);
    }

    void SetName(LPCSTR pszName)
    {
        if (m_lpszName != NULL)
            free(m_lpszName);
        m_lpszName = _strdup(pszName);
    }
    LPCSTR GetName()
    {
        return m_lpszName;
    }

    void SetValue(LPCSTR pszValue)
    {
        if (m_lpszValue != NULL)
            free(m_lpszValue);
        m_lpszValue = _strdup(pszValue);
    }
    LPCSTR GetValue()
    {
        return m_lpszValue;
    }


private:
	LPTSTR m_lpszName;
	LPTSTR m_lpszValue;
};


#endif // #ifndef __PROPERTY_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\wavmerge\resource.h ===
#define IDS_NOTDIR 1000
#define IDS_ISDIR 1001
#define IDS_NOTEMPFILE 1002
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\wavmerge\Main.cpp ===
/******************************************************************************************

WavMerge

Merge NUMCHANNELS mono files into 1 5.1 file.

danhaff      7/23/01    Started
******************************************************************************************/

#include "globals.h"
#include "cwavefile.h"
#include "helpers.h"
/******************************************************************************************
******************************************************************************************/

const LPSTR szSixChannelNames[] = {"Left", "Right", "Center", "LFE", "LeftRear", "RightRear"};
const LPSTR szFourChannelNames[]= {"Left", "Right","LeftRear", "RightRear"};
const LPSTR szSilence = ".";

HRESULT CheckParams(int cArg, char *argv[], LPDWORD dwNumChannels)
{
    HRESULT hr = S_OK;
        
    if (cArg != (NUMELEMS(szSixChannelNames) + 2) && cArg!= (NUMELEMS(szFourChannelNames)+2))
    {
        Log("");
        Log("  Error: Incorrect number of parameters specified");
        Log("");
        Log("  Usage: wavmerge [%s | %s] [%s | %s] [%s | %s] [%s | %s]\n                  [%s | %s] [%s | %s] %s",


                                          szSixChannelNames[0], szSilence,
                                          szSixChannelNames[1], szSilence,
                                          szSixChannelNames[2], szSilence,
                                          szSixChannelNames[3], szSilence,
                                          szSixChannelNames[4], szSilence,
                                          szSixChannelNames[5], szSilence,
                                          "OUTPUT");
        Log("     or");
        Log("  Usage: wavmerge [%s | %s] [%s | %s] [%s | %s] [%s | %s] %s",


                                          szFourChannelNames[0], szSilence,
                                          szFourChannelNames[1], szSilence,
                                          szFourChannelNames[2], szSilence,
                                          szFourChannelNames[3], szSilence,
                                          "OUTPUT");
        Log("");
        Log("");
        Log("    WavMerge combines mono wave files into a 4- or 6-channel WaveFormatEx   ");
        Log("    interleaved PCM wave file.  The bit depths and sampling rates of the       ");
        Log("    mono wave files must be identical.  Their durations, however, may differ.  ");
        Log("    The output file's duration will equal that of the longest input file.      ") ;
        Log("    You may pass \".\" to denote silence for a channel.                        ");
        Log("                                                                               ");
        Log("    Examples:                                                                  ");
        Log("       wavmerge left.wav . . . . . result.wav                                  ");
        Log("       Creates a 6-channel wave file with the left channel audible and         ");
        Log("       silence in the other channels.                                          ");
        Log("                                                                               ");
        Log("       wavmerge . right.wav . . . . result.wav                                 ");
        Log("       Creates a 6-channel wave file with the right channel audible and        ");
        Log("       silence in the other channels.                                          ");
        Log("                                                                               ");
        Log("       wavmerge left.wav right.wav . . result.wav                              ");
        Log("       Creates a 4-channel wave file with the left and right channels audible  ");
        Log("       and silence in the other channels.                                      ");

        hr = E_FAIL;
        *dwNumChannels = 0;
    }
    else
    {
        *dwNumChannels = cArg - 2;
    }
    return hr;
};

/******************************************************************************************
Load up the files, G.
******************************************************************************************/
HRESULT LoadFiles(CWaveFile WaveFile[], char *argv[], DWORD dwNumChannels)
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    BOOL bFound = 0;
    WAVEFORMATEX wfxSilence = {0};

    //Load all the non-silence files.
    for (i=0; i<dwNumChannels && SUCCEEDED(hr); i++)
    {
        if (_strcmpi(argv[1+i], szSilence) != 0)
        {
            CHECKRUN(WaveFile[i].OpenForRead(argv[1+i]));
            if (FAILED(hr))
            {
                Log("Failed to load %s", argv[1+i]);
            }
        }
    }

    //Find the format of the first non-silence file.  We'll use that for the silence files.
    bFound = FALSE;
    for (i=0; i<dwNumChannels && SUCCEEDED(hr); i++)
    {
        if (_strcmpi(argv[1+i], szSilence) != 0)
        {
            WaveFile[i].GetWaveFormatEx(&wfxSilence);
            bFound = TRUE;
            break;
        }
    }

    //If all the files are silent, set the format to 8-bit mono, 8khz.
    if (SUCCEEDED(hr))
        if (!bFound)
        {
            Log("All channels are set to silence.  You must specify an input file for at least one channel.");
            return E_FAIL;
    /*
            wfxSilence.wFormatTag = 1;
            wfxSilence.nChannels = 1;
            wfxSilence.nSamplesPerSec = 8000;
            wfxSilence.nAvgBytesPerSec = 8000;
            wfxSilence.nBlockAlign = 1;
            wfxSilence.wBitsPerSample = 8;
            wfxSilence.cbSize = 0;
    */
        }


    //Go through all the "silence" files and set them to the wave format we've found/created.
    for (i=0; i<dwNumChannels && SUCCEEDED(hr); i++)
    {
        if (_strcmpi(argv[1+i], szSilence) == 0)
            CHECKRUN(WaveFile[i].OpenForSilence(wfxSilence));
    }

    return hr;
}



/******************************************************************************************
Make sure these files are all mono and of the same bit depths and sample rate.
******************************************************************************************/
HRESULT VerifyFormats(CWaveFile WaveFile[], DWORD dwNumChannels)
{
    HRESULT hr = S_OK;
    DWORD i,j = 0;
    WAVEFORMATEX wfx[2]  = {NULL};
    CHAR szFileName[2][MAX_PATH];
    DWORD dwLength[2] = {NULL};

    //Check channels and bit-rate for non-silence files.
    for (i=0; i<dwNumChannels && SUCCEEDED(hr); i++)
    {
        WaveFile[i].GetWaveFormatEx(&wfx[0]);
        WaveFile[i].GetFileName(szFileName[0]);

        if (_strcmpi(szFileName[0], szSilence) == 0)
            continue;

        if (wfx[0].nChannels != 1)
        {
            Log("Error: %s has %u channels instead of 1.  Input files must be mono.", szFileName[0], wfx[0].nChannels);
            hr = E_FAIL;
            break;
        }

        if (wfx[0].wBitsPerSample!=8 && wfx[0].wBitsPerSample!=16)
        {
            Log("Error: %s is %u-bit; it must be 8- or 16- bit.", szFileName[0], wfx[0].wBitsPerSample);
            hr = E_FAIL;
            break;
        }
    }

    //Check
    for (i=0; i<dwNumChannels - 1 && SUCCEEDED(hr); i++)
    {
        for (j=i+1; j<dwNumChannels && SUCCEEDED(hr); j++)
        {
            WaveFile[i].GetWaveFormatEx(&wfx[0]);
            WaveFile[j].GetWaveFormatEx(&wfx[1]);
            
            WaveFile[i].GetFileName(szFileName[0]);
            WaveFile[j].GetFileName(szFileName[1]);

            if (_strcmpi(szFileName[0], szSilence) == 0)
                continue;
            if (_strcmpi(szFileName[1], szSilence) == 0)
                continue;


            if (wfx[0].nSamplesPerSec != wfx[1].nSamplesPerSec)
            {
                Log("Error: sample rate mismatch: %s's sample rate is %u: %s's sample rate is %u", szFileName[0], wfx[0].nSamplesPerSec,                                                                                                   
                                                                                                   szFileName[1], wfx[1].nSamplesPerSec);
                hr = E_FAIL;
                break;
            }

            if (wfx[0].wBitsPerSample != wfx[1].wBitsPerSample)
            {
                Log("Error: bit depth mismatch: %s's bit depth is %u: %s's bit depth is %u", szFileName[0], wfx[0].wBitsPerSample,
                                                                                             szFileName[1], wfx[1].wBitsPerSample);
                hr = E_FAIL;
                break;
            }
        }
    }

    return hr;
}


/******************************************************************************************
******************************************************************************************/
#define MAX 10
int __cdecl main(int cArg, char *argv[])
{
	HRESULT hr = S_OK;
    CWaveFile InputFiles[MAX];              //NUMCHANNELS input files
    CWaveFile OutputFile;                           //1 output file.
    DWORD dwNumChannels = 0;


//    CWaveFile temp;
//    temp.Load("Output.wav");

    //Make sure the correct number of paramters are present.
    CHECKRUN(CheckParams(cArg, argv, &dwNumChannels));
    if (MAX < dwNumChannels)
        Log("NOT ENOUGH CHANNELS IN MAIN FUNCTION!!");
    
    //Load da files
    CHECKRUN(LoadFiles(InputFiles, argv, dwNumChannels));

    //Make sure the wave files all have the same format.
    CHECKRUN(VerifyFormats(InputFiles, dwNumChannels));

    //Merge them into a single file.
    CHECKRUN(Merge(InputFiles, argv[dwNumChannels + 1], dwNumChannels));

    if (SUCCEEDED(hr))
    {
        Log("Successfully created %s",argv[dwNumChannels + 1]);
    }

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xcrypt\list.cpp ===
//  LIST.CPP
//
//		Doubly-linked lists
//
//	Created 15-Mar-2000 [JonT]

#include "xcmain.h"

//---------------------------------------------------------------------
//  CListHead class

CListHead::~CListHead()
{
	CNode* pNode;

	// Nuke all remaining nodes in the list
	while (m_pHead)
	{
		pNode = m_pHead;
		m_pHead = m_pHead->Next();
		delete pNode;
	}
}


void
CListHead::Dump(
    LPCSTR pszTitle, 
    int nLevel                
    )
{

    if (nLevel > g_ib.m_nTraceLevel)
    {
        return;
    }

//    g_ib.m_dwDumpVar = 0;

    if (pszTitle != NULL && pszTitle[0] != '\0')
    {
        TRACE_OUT(nLevel, "\n%s:", pszTitle);
    }

    for (CNode* pNode = m_pHead; pNode != NULL; pNode = pNode->Next())
    {
        pNode->Dump();
    }
}


DWORD
CListHead::Count()
{
    DWORD dwCnt = 0;

    for (CNode* pNode = m_pHead; pNode != NULL; pNode = pNode->Next())
    {
        dwCnt++;
    }
    return dwCnt;
}


//---------------------------------------------------------------------
//  CNode class
//		Using this class is very simple: Start by doing a 'new CNode.' or a derived class
//		Once you have a new CNode, link it into a list by passing to CNode::Link
//		pointing to the list head already created and to the node to insert after.
//		Pass in NULL to link to the end of the list.
//		Don't delete a CNode before Unlink'ing it!

CNode::~CNode()
{
    // derived class should clean up in its own destructor
}


//  CNode::Link
//		Links in an element to the list before the node passed in.
//		Pass in NULL to link at end of list.

void
CNode::Link(
	CListHead* pList,
	CNode* pBefore
	)
{
    if (!pList->m_pHead)
    {
        m_pPrev = m_pNext = NULL;
        pList->m_pHead = pList->m_pTail = this;
    }
    else if (pBefore == NULL)
    {
        m_pPrev = pList->m_pTail;
        m_pNext = NULL;
        pList->m_pTail->m_pNext = this;
        pList->m_pTail = this;
    }
    else
    {
        m_pPrev = pBefore->m_pPrev;
        m_pNext = pBefore;
        if (pBefore->m_pPrev == NULL)
            pList->m_pHead = this;
        else
            pBefore->m_pPrev->m_pNext = this;
        pBefore->m_pPrev = this;
    }
}


//  CNode::Unlink
//		Removed the current element from the list. The memory is not reclaimed
//		until the node is delete'ed.

void
CNode::Unlink(
	CListHead* pList
	)
{
    // Check the previous element
    if (!m_pPrev)
        pList->m_pHead = m_pNext;
    else
        m_pPrev->m_pNext = m_pNext;

    // Check the next element
    if (!m_pNext)
        pList->m_pTail = m_pPrev;
    else
        m_pNext->m_pPrev = m_pPrev;
}


void
CNode::Dump()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xcrypt\enc.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    enc.cpp

Abstract:


--*/

#include <windows.h>
#include <stdlib.h>
#include <conio.h>
#include <rsa.h>
#include <sha.h>
#include <rc4.h>
#include <xcrypt.h>
#include "key.h"
#include "xcmain.h"
#include "enc.h"



void 
shaHmac(
    IN PBYTE pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PBYTE pbData,
    IN ULONG cbData,
    IN PBYTE pbData2,
    IN ULONG cbData2,
    OUT PBYTE HmacData // length must be A_SHA_DIGEST_LEN
    )
{
    BYTE Kipad[HMAC_K_PADSIZE];
    BYTE Kopad[HMAC_K_PADSIZE];
    BYTE HMACTmp[HMAC_K_PADSIZE+A_SHA_DIGEST_LEN];
    ULONG dwBlock;
    A_SHA_CTX shaHash;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;

    RtlZeroMemory(Kipad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kipad, pbKeyMaterial, cbKeyMaterial);

    RtlZeroMemory(Kopad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kopad, pbKeyMaterial, cbKeyMaterial);

    //
    // Kipad, Kopad are padded sMacKey. Now XOR across...
    //
    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)Kipad)[dwBlock] ^= 0x36363636;
        ((DWORD*)Kopad)[dwBlock] ^= 0x5C5C5C5C;
    }

    //
    // prepend Kipad to data, Hash to get H1
    //

    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash, Kipad, HMAC_K_PADSIZE);
    if (cbData != 0)
    {
        A_SHAUpdate(&shaHash, pbData, cbData);
    }
    if (cbData2 != 0)
    {
        A_SHAUpdate(&shaHash, pbData2, cbData2);
    }

    // Finish off the hash
    A_SHAFinal(&shaHash,HMACTmp+HMAC_K_PADSIZE);

    // prepend Kopad to H1, hash to get HMAC
    RtlCopyMemory(HMACTmp, Kopad, HMAC_K_PADSIZE);

    // final hash: output value into passed-in buffer
    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash,HMACTmp, sizeof(HMACTmp));
    A_SHAFinal(&shaHash,HmacData);
}


void 
rc4HmacEncrypt(
    IN PUCHAR confounder, // RC4_CONFOUNDER_LEN bytes
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
    BYTE LocalKey[A_SHA_DIGEST_LEN];
    RC4_KEYSTRUCT Rc4KeyStruct;

    //
    // Create the header - the confounder & checksum
    //
    RtlZeroMemory( CryptHeader->Checksum, A_SHA_DIGEST_LEN );
    RtlCopyMemory( CryptHeader->Confounder, confounder, RC4_CONFOUNDER_LEN );

    //
    // Checksum everything but the checksum
    //
    shaHmac( pbKey, cbKey,
             CryptHeader->Confounder, RC4_CONFOUNDER_LEN,
             pbInput, cbInput,
             CryptHeader->Checksum );

    //
    // HMAC the checksum into the key
    //
    shaHmac( pbKey, cbKey,
             CryptHeader->Checksum, A_SHA_DIGEST_LEN,
             NULL, 0,
             LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    rc4_key( &Rc4KeyStruct, A_SHA_DIGEST_LEN, LocalKey );

    //
    // Encrypt everything but the checksum
    //
    rc4( &Rc4KeyStruct, RC4_CONFOUNDER_LEN, CryptHeader->Confounder );
    rc4( &Rc4KeyStruct, cbInput, pbInput );
}


BOOL 
rc4HmacDecrypt(
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    IN PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
    RC4_SHA1_HEADER TempHeader;
    BYTE LocalKey[A_SHA_DIGEST_LEN];
    RC4_KEYSTRUCT Rc4KeyStruct;

    RtlCopyMemory( TempHeader.Confounder, CryptHeader->Confounder, RC4_CONFOUNDER_LEN );

    //
    // HMAC the checksum into the key
    //
    shaHmac( pbKey, cbKey,
             CryptHeader->Checksum, A_SHA_DIGEST_LEN,
             NULL, 0,
             LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    rc4_key( &Rc4KeyStruct, A_SHA_DIGEST_LEN, LocalKey );

    //
    // Decrypt confounder and data
    //
    rc4( &Rc4KeyStruct, RC4_CONFOUNDER_LEN, TempHeader.Confounder );
    rc4( &Rc4KeyStruct, cbInput, pbInput );

    //
    // Now verify the checksum.
    //
    shaHmac( pbKey, cbKey,
             TempHeader.Confounder, RC4_CONFOUNDER_LEN,
             pbInput, cbInput,
             TempHeader.Checksum );

    //
    // Decrypt is successful only if checksum matches
    //
    return ( RtlEqualMemory(
                 TempHeader.Checksum,
                 CryptHeader->Checksum,
                 A_SHA_DIGEST_LEN) );
}



BOOL
XcWriteEncryptedFile(
    PBYTE pMessage,
    DWORD cbMsgLen,
    LPCSTR pszFN,
    LPCSTR pszPassword,
    PBYTE pConfounder  // RC4_CONFOUNDER_LEN bytes
    )
{
    HANDLE hFile;
    DWORD dwBytes;
    BOOL bRet = FALSE;

    hFile = CreateFile(pszFN, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, 
        FILE_ATTRIBUTE_NORMAL, NULL);
    
    if (hFile != INVALID_HANDLE_VALUE) {
        
        DWORD dwEncSize = sizeof(XC_ENCFILE_HEADER) + cbMsgLen;
        PBYTE pEncBuffer = (PBYTE)malloc(dwEncSize);
        PXC_ENCFILE_HEADER pEncHead = (PXC_ENCFILE_HEADER)pEncBuffer;

        pEncHead->Sig = XC_ENCFILE_SIG;
        pEncHead->MsgLen = cbMsgLen;

        XCCalcDigest(pMessage, cbMsgLen, pEncHead->MsgDigest);

        //
        // Copy the message data in
        //
        memcpy((pEncBuffer + sizeof(XC_ENCFILE_HEADER)), pMessage, cbMsgLen);

        //
        // Encrypt it
        //
        rc4HmacEncrypt(pConfounder, (PBYTE)pszPassword, strlen(pszPassword), 
            (pEncBuffer + sizeof(XC_ENCFILE_HEADER)), cbMsgLen, (PBYTE)&(pEncHead->CryptHeader)); 

        //
        // Write the buffer out
        //
        if (WriteFile(hFile, pEncBuffer, dwEncSize, &dwBytes, NULL)) {
            bRet = TRUE;
        } else {
            ERROR_OUT("Cannot write to key file %s", pszFN);
        }

        CloseHandle(hFile);

        //
        // Free the buffer used for encryption
        //
        free(pEncBuffer);
    
    } else {
        ERROR_OUT("Cannot create encrypted file %s", pszFN);
    }

    if (bRet) {
        TRACE_OUT(TRACE_ALWAYS, "Encrypted file %s created successfully", pszFN);
    }

    return bRet;
}



BOOL 
XcReadEncryptedFile(
    LPCSTR pszFN, 
    LPCSTR pszPassword,
    PBYTE pMsgBuf,
    DWORD cbMsgBufLen
    )
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwBytes;
    BOOL bRet = FALSE;
    DWORD dwEncSize;
    PBYTE pEncBuffer = FALSE;
    PXC_ENCFILE_HEADER pEncHead;
    BYTE CalcDigest[XC_DIGEST_LEN];

    hFile = CreateFile(pszFN, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    
    if (hFile == INVALID_HANDLE_VALUE) {
        ERROR_OUT("Cannot open from encrypted file %s", pszFN);
        goto CleanupAndExit;
    }

    dwEncSize = GetFileSize(hFile, NULL);
    if (dwEncSize < sizeof(XC_ENCFILE_HEADER)) {
        ERROR_OUT("Invalid encrypted file format %s", pszFN);
        goto CleanupAndExit;
    }

    pEncBuffer = (PBYTE)malloc(dwEncSize);
    pEncHead = (PXC_ENCFILE_HEADER)pEncBuffer;

    if (!ReadFile(hFile, pEncBuffer, dwEncSize, &dwBytes, NULL)) {
        ERROR_OUT("Cannot read from file %s", pszFN);
        goto CleanupAndExit;
    }

    if (pEncHead->Sig != XC_ENCFILE_SIG || pEncHead->MsgLen != (dwEncSize - sizeof(XC_ENCFILE_HEADER))) {
        ERROR_OUT("File %s is not an encrypted file", pszFN);
        goto CleanupAndExit;
    }
            
    
    if (cbMsgBufLen != pEncHead->MsgLen) {
        ERROR_OUT("Not enough space allocated to load the file");                        
        goto CleanupAndExit;
    }
    
    //
    // Decrypt it
    //
    if (rc4HmacDecrypt((PBYTE)pszPassword, strlen(pszPassword), (pEncBuffer + sizeof(XC_ENCFILE_HEADER)), 
        pEncHead->MsgLen, (PBYTE)&(pEncHead->CryptHeader))) {

        //
        // Copy the plain text message
        //
        memcpy(pMsgBuf, (pEncBuffer + sizeof(XC_ENCFILE_HEADER)), pEncHead->MsgLen);

        //
        // Calculate message digest
        //
        XCCalcDigest(pMsgBuf, cbMsgBufLen, CalcDigest);

        //
        // Compare the calculated message digest with the decrypted digest
        //
        if (memcmp(CalcDigest, pEncHead->MsgDigest, XC_DIGEST_LEN) == 0) {

            bRet = TRUE;
        
        } 
    }
    
    if (bRet == FALSE) {
        ERROR_OUT("Decryption of file %s failed--invalid password", pszFN);
    }
    


CleanupAndExit:
    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);        
    }

    if (pEncBuffer != NULL) {
        free(pEncBuffer);
    }

    if (bRet) {
        TRACE_OUT(TRACE_ALWAYS, "Successfully read encrypted file %s", pszFN);
    }

    return bRet;
}


BOOL 
XcGetEncryptedFileMsgLen(
    LPCSTR pszFN,
    PDWORD pdwSize
    )
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    BOOL bRet = FALSE;
    DWORD dwBytes;
    XC_ENCFILE_HEADER EncHead;

    hFile = CreateFile(pszFN, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    
    if (hFile == INVALID_HANDLE_VALUE) {
        goto CleanupAndExit;
    }

    if (!ReadFile(hFile, &EncHead, sizeof(EncHead), &dwBytes, NULL) || dwBytes != sizeof(EncHead)) {
        goto CleanupAndExit;
    }

    if (EncHead.Sig == XC_ENCFILE_SIG) {
        bRet = TRUE;
        *pdwSize = EncHead.MsgLen;
    }


CleanupAndExit:
    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);        
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xcrypt\key.h ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    key.h

Abstract:

    Contains definition of key handling class

--*/

#ifndef _KEY_H
#define _KEY_H

#include <windows.h>


#define KEYFILE_PUBPAIR      1      // public and private keys
#define KEYFILE_PUBONLY      2      // public key only
#define KEYFILE_SYM          3      // symmetric key


typedef struct _XBOX_KEYFILE_HEADER
{
    USHORT KeyType;                 // KEYFILE_ defines
    USHORT KeyBits;                 // number of bits in the key
    GUID   KeyGUID;                 // unique guid genereted at the time the key file was created
    ULONG  KeyNumber;               // a number assigned key
    ULONG  PublicKeyBytes;          // bytes used by public key structure
    ULONG  PrivateKeyBytes;         // bytes used by private key structure

} XBOX_KEYFILE_HEADER, *PXBOX_KEYFILE_HEADER;




class CKeyFile 
{
public:
    CKeyFile()
        : m_pData(NULL),
          m_dwLen(0)
    {
    }

    ~CKeyFile()
    {
        Free();
    }

    BOOL IsNull()
    {
        return (m_pData == NULL);
    }


    PXBOX_KEYFILE_HEADER KeyHeader()
    {
        return (PXBOX_KEYFILE_HEADER)m_pData;
    }

    BOOL CreatePubKeyPair(DWORD dwKeyBits);
    BOOL CreateSymKey(DWORD dwKeyBits);
    BOOL CreateSymKey2();

    PBYTE PublicKey();
    PBYTE PrivateKey();
    PBYTE SymmetricKey();

    BOOL ReadFromFile(LPCSTR pszFN);
    BOOL WriteToFile(LPCSTR pszFN);

    BOOL ReadFromEncFile(LPCSTR pszFN, LPCSTR pszPassword);
    BOOL WriteToEncFile(LPCSTR pszFN, LPCSTR pszPassword);

    BOOL IsEncFile(LPCSTR pszFN);

private:
    PBYTE m_pData;
    DWORD m_dwLen;

    void Alloc(DWORD dwSize);
    void Free();
};



#endif // _KEY_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xcrypt\key.cpp ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    key.cpp

Abstract:

    This module contains implementation of CKeyFile and CKeyPair class to handle
    public and private keys


--*/

#include <windows.h>
#include <stdlib.h>
#include <conio.h>
#include <rsa.h>
#include <sha.h>
#include <rc4.h>
#include <xcrypt.h>
#include "key.h"
#include "xcmain.h"
#include "enc.h"


//
// CKeyFile class
//


BOOL 
CKeyFile::CreatePubKeyPair(
    DWORD dwKeyBits
    )
{
    DWORD dwKeySize = dwKeyBits;
    DWORD dwPublicKeyBytes;
    DWORD dwPrivateKeyBytes;
    PBYTE pPublicKeyData;
    PBYTE pPrivateKeyData;

    Free();

    //
    // Calculate key size
    // BSsafeComputeKeySizes uses the 3rd parameter for internal calculation thus 
    // modifying the value >> 1.  This new value should be ignored.
    //
    if (!BSafeComputeKeySizes(&dwPublicKeyBytes, &dwPrivateKeyBytes, &dwKeySize))
    {
        ERROR_OUT("Cannot get keysizes because BSafeComputeKeySizes failed");
        return FALSE;
    }

    Alloc(sizeof(XBOX_KEYFILE_HEADER) + dwPublicKeyBytes + dwPrivateKeyBytes);

    KeyHeader()->KeyType = KEYFILE_PUBPAIR;
    KeyHeader()->KeyBits = (USHORT)dwKeyBits;
    KeyHeader()->PublicKeyBytes = dwPublicKeyBytes;
    KeyHeader()->PrivateKeyBytes = dwPrivateKeyBytes;

    pPublicKeyData = m_pData + sizeof(XBOX_KEYFILE_HEADER);
    pPrivateKeyData = pPublicKeyData + dwPublicKeyBytes;
    
    //
    // generate keys
    //
    if(!BSafeMakeKeyPair(
         (LPBSAFE_PUB_KEY)pPublicKeyData,
         (LPBSAFE_PRV_KEY)pPrivateKeyData,
         dwKeyBits)
         )
    {
        ERROR_OUT("Cannot generate keys because BSafeMakeKeyPair failed");
        return FALSE;
    }

    return TRUE;
}


BOOL 
CKeyFile::CreateSymKey(
    DWORD dwKeyBits
    )
{
    DWORD dwKeySize = dwKeyBits;
    DWORD dwPublicKeyBytes;
    DWORD dwPrivateKeyBytes;
    PBYTE pPublicKeyData;
    PBYTE pPrivateKeyData;

    Free();

    //
    // Calculate key size
    // BSsafeComputeKeySizes uses the 3rd parameter for internal calculation thus 
    // modifying the value >> 1.  This new value should be ignored.
    //
    if (!BSafeComputeKeySizes(&dwPublicKeyBytes, &dwPrivateKeyBytes, &dwKeySize))
    {
        ERROR_OUT("Cannot get keysizes because BSafeComputeKeySizes failed");
        return FALSE;
    }

    Alloc(sizeof(XBOX_KEYFILE_HEADER) + dwPublicKeyBytes);

    KeyHeader()->KeyType = KEYFILE_SYM;
    KeyHeader()->KeyBits = (USHORT)dwKeyBits;
    KeyHeader()->PublicKeyBytes = dwPublicKeyBytes;
    KeyHeader()->PrivateKeyBytes = 0;

    pPublicKeyData = m_pData + sizeof(XBOX_KEYFILE_HEADER);
    pPrivateKeyData = (PBYTE)malloc(dwPrivateKeyBytes);
    
    //
    // generate keys
    //
    if(!BSafeMakeKeyPair(
         (LPBSAFE_PUB_KEY)pPublicKeyData,
         (LPBSAFE_PRV_KEY)pPrivateKeyData,
         dwKeyBits)
         )
    {
        free(pPrivateKeyData);
        ERROR_OUT("Cannot generate keys because BSafeMakeKeyPair failed");
        return FALSE;
    }
    free(pPrivateKeyData);

    return TRUE;
}

BOOL 
CKeyFile::CreateSymKey2(
    )
{
    BYTE rgbHash[20];
    FILETIME ft;
    BYTE rgbKeys[32];
    struct RC4_KEYSTRUCT RC4key;
    A_SHA_CTX   SHAHash;
    char ch;

    CreateSymKey(128);

    
    A_SHAInit(&SHAHash);
    GetSystemTimeAsFileTime(&ft);
    A_SHAUpdate(&SHAHash, (PBYTE)&ft, sizeof ft);
    _cputs("Enter random data to create a key:");
    do {
        ch = (char)_getch();
        _asm {
            lea ecx, ft
            rdtsc
            mov [ecx], eax
            mov [ecx+4], edx
        }
        A_SHAUpdate(&SHAHash, (PBYTE)&ft, sizeof ft);
    } while(ch != 10 && ch != 13);
    _putch('\r');
    _putch('\n');
    
    GetSystemTimeAsFileTime(&ft);
    A_SHAUpdate(&SHAHash, (PBYTE)&ft, sizeof ft);
    A_SHAFinal(&SHAHash, rgbHash);
    
    memset(rgbKeys, 0, sizeof rgbKeys); // or leave it unknown
    memcpy(rgbKeys, SymmetricKey(), 16);
    rc4_key(&RC4key, 20, rgbHash);
    rc4(&RC4key, sizeof rgbKeys, rgbKeys);

    memcpy(SymmetricKey(), rgbKeys, 16);

    return TRUE;
}






PBYTE CKeyFile::PublicKey()
{
    if (KeyHeader()->KeyType == KEYFILE_PUBPAIR)
    {
        return m_pData + sizeof(XBOX_KEYFILE_HEADER);
    }
    else
    {
        return NULL;
    }
}


PBYTE CKeyFile::PrivateKey()
{
    if (KeyHeader()->KeyType != KEYFILE_PUBONLY)
    {
        return m_pData + sizeof(XBOX_KEYFILE_HEADER) + KeyHeader()->PublicKeyBytes;
    }
    else
    {
        return NULL;
    }
}


PBYTE CKeyFile::SymmetricKey()
{
    if (KeyHeader()->KeyType == KEYFILE_SYM)
    {
        return m_pData + sizeof(XBOX_KEYFILE_HEADER) + sizeof(BSAFE_PUB_KEY);
    }
    else
    {
        return NULL;
    }
}



void
CKeyFile::Free()
{
    if (m_pData != NULL)
    {
        free(m_pData);
        m_pData = NULL;
    }
    m_dwLen = 0;

}



void
CKeyFile::Alloc(
    IN DWORD dwSize
    )
{
    Free();
    
    m_pData = (PBYTE)malloc(dwSize);
    if (m_pData != NULL)
    {
        m_dwLen = dwSize;
        memset(m_pData, 0, m_dwLen);
    }
}



BOOL
CKeyFile::ReadFromFile(
    IN LPCSTR pszFN
    )
/*++

Routine Description:

    Reads a public or private key from the file

Arguments:

    pszFN - supplies the name of the file

Return Value:

    TRUE if succesful, FALSE otherwise

--*/
{
    HANDLE hFile;
    DWORD dwBytes;
    DWORD dwSize;
    BOOL bRet = FALSE;

    Free();

    hFile = CreateFile(pszFN, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        dwSize = GetFileSize(hFile, NULL);
        if (dwSize > 0)
        {
            Alloc(dwSize);
            if (ReadFile(hFile, m_pData, m_dwLen, &dwBytes, NULL))
            {
                bRet = TRUE;
            }
            else
            {
                Free();
                ERROR_OUT("Cannot read from key file %s", pszFN);
            }
        }
        CloseHandle(hFile);
    }
    else
    {
        ERROR_OUT("Cannot open from key file %s", pszFN);
    }

    if (bRet) 
    {
        TRACE_OUT(TRACE_ALWAYS, "Successfully read plain text keyfile %s", pszFN);
    }

    return bRet;
}


BOOL
CKeyFile::WriteToFile(
    IN LPCSTR pszFN
    )
/*++

Routine Description:

    Writes a key to the a file

Arguments:

Return Value:

    TRUE if succesful, FALSE otherwise

--*/
{
    HANDLE hFile;
    DWORD dwBytes;
    BOOL bRet = FALSE;

    if (IsNull())
    {
        return bRet;
    }

    hFile = CreateFile(pszFN, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        if (WriteFile(hFile, m_pData, m_dwLen, &dwBytes, NULL))
        {
            bRet = TRUE;
        }
        else
        {
            ERROR_OUT("Cannot write to key file %s", pszFN);
        }

        CloseHandle(hFile);
    }
    else
    {
        ERROR_OUT("Cannot create key file %s", pszFN);
    }

    if (bRet) 
    {
        TRACE_OUT(TRACE_ALWAYS, "Plain text file %s created successfully", pszFN);
    }

    return bRet;
}



BOOL 
CKeyFile::ReadFromEncFile(
    LPCSTR pszFN, 
    LPCSTR pszPassword
    )
/*++

Routine Description:

    Reads a public or private key from an encrypted file

Arguments:

Return Value:

    TRUE if succesful, FALSE otherwise

--*/
{
    BOOL bRet = FALSE;
    DWORD MsgLen;

    Free();

    if (XcGetEncryptedFileMsgLen(pszFN, &MsgLen)) {

        //
        // Allocate memory for the plain text message
        //
        Alloc(MsgLen);


        //
        // Read the message from encrypted file
        //
        bRet = XcReadEncryptedFile(pszFN, pszPassword, m_pData, m_dwLen);

        if (bRet == FALSE) {
            Free();
        }
    }
    else {
        ERROR_OUT("File %s is not an encrypted file", pszFN);
    }

    return bRet;
}


BOOL
CKeyFile::WriteToEncFile(
    IN LPCSTR pszFN,
    LPCSTR pszPassword
    )
/*++

Routine Description:

    Writes a key to the an encrypted file

Arguments:

Return Value:

    TRUE if succesful, FALSE otherwise

--*/
{
    UCHAR Confounder[RC4_CONFOUNDER_LEN];
    CRandom rand;

    if (IsNull())
    {
        return FALSE;
    }

    //
    // Generate random confounder
    //
    rand.RandBytes(Confounder, RC4_CONFOUNDER_LEN);

    //
    // rc4hmac encrypt and write the key data to a file
    //
    return XcWriteEncryptedFile(m_pData, m_dwLen, pszFN, pszPassword, Confounder);
}


BOOL 
CKeyFile::IsEncFile(
    LPCSTR pszFN
    )
{
    DWORD MsgLen;


    return XcGetEncryptedFileMsgLen(pszFN, &MsgLen);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xcrypt\property.cpp ===
//  PROPERTY.CPP
//
//		Text property handling
//
//	Created 15-Mar-2000 [JonT]

#include "xcmain.h"

//---------------------------------------------------------------------
//  CPropertyBundle - public

//  CPropertyBundle::GetProperty
//		Returns the value for a given property.
//		Note that properties can come from different places:
//			*from command line switches: imgbld /d1 makes a property 'd' with value '1'
//			*from a configuration file
//			*from a previous call to SetProp
//		Properties are returned as constant strings.
//		NULL means property does not exist.

LPCTSTR
CPropertyBundle::Get(
	LPCTSTR lpszName
	)
{
	CProperty* pp;

	if ((pp = Find(lpszName)) == NULL)
		return NULL;
	else
		return pp->GetValue();
}


//  CPropertyBundle::SetProperty
//		Sets a value for the given property, creates the property if necessary.

void
CPropertyBundle::Set(
	LPCTSTR lpszName,
	LPCTSTR lpszValue
	)
{
	CProperty* pp;
	int nHashBucket;

	// See if we need to create it
	if ((pp = Find(lpszName)) == NULL)
	{
		// Create the new property
		pp = new CProperty;
		if (!pp)
			g_ib.Exit(-1, "Error: Out of Memory");
		pp->SetName(lpszName);
		pp->SetValue(lpszValue);

		// Create a list node to link it into
		//pnode = new CNode;
		//pnode->SetData(pp);

		// Find the hash bucket to link it into
		nHashBucket = HashNameToIndex(lpszName);

		// Link the node into the end of the bucket list
		pp->Link(&m_lhHashTable[nHashBucket], NULL);
	}

	// Already exists, so just replace the value
	else
	{
		pp->SetValue(lpszValue);
	}
}


//---------------------------------------------------------------------
//  CPropertyBundle - private

CProperty*
CPropertyBundle::Find(
	LPCTSTR lpszName
	)
{
	int nBucket;
	CNode* pnode;

	// Get the bucket number
	nBucket = HashNameToIndex(lpszName);

	// Search this bucket for the name
	for (pnode = m_lhHashTable[nBucket].GetHead() ; pnode ; pnode = pnode->Next())
		if (_stricmp(lpszName, ((CProperty*)pnode)->GetName()) == 0)
			break;

	if (pnode)
		return (CProperty*)pnode;
	else
		return NULL;
}


int
CPropertyBundle::HashNameToIndex(
	LPCTSTR lpszName
	)
{
	DWORD dwHash = 0;
	TCHAR ch;
	int i;
	int nIncr = strlen(lpszName) / 3;

	ASSERT(lpszName != NULL && *lpszName != '\0');

	for (i = 0 ; i < 3 ; i++)
	{
		// Get the next character
		if ((ch = *lpszName) == 0)
			break;
		lpszName += nIncr;

		// Compute next random number in sequence using character to modify
		dwHash =  1664525 * (dwHash ^ ch) + 1013904223;
	}

	dwHash = dwHash % TABLE_SIZE;

	return (int)dwHash;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xcrypt\xcmain.cpp ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    xcmain.cpp

Abstract:

    xcrypt command line tool


--*/

#include <windows.h>
#include <stdio.h>
#include <conio.h>
#include <stdlib.h>
#include <rsa.h>
#include <sha.h>
#include <rc4.h>
#include <xcrypt.h>

#include "xctool.h"
#include "key.h"

#include <string.h>
#include "xcmain.h"
#include <xboxverp.h>

// We need to manually define this crt method because it does not exist in the XBOX version
// of the crt and therefore does not exist in the headers this method includes.  
//
extern "C" _CRTIMP void __cdecl exit(int);


// 
// main object for tracking global state
//
CXCryptMain g_ib;

//
// property names
//
#define PROP_HELP            TEXT("Help")
#define PROP_CONFIG          TEXT("Config")
#define PROP_GENKEY          TEXT("GenKey")
#define PROP_KEYOUT          TEXT("KeyOut")
#define PROP_KEYOUTENC       TEXT("KeyOutEnc")
#define PROP_KEYIN           TEXT("KeyIn")
#define PROP_DUMPTYPE        TEXT("DumpType")



// 
// command table. NOTE: Must be sorted by lpCmdLine
//
CMDTABLE CmdTable[] =
{
    {"?",            PROP_HELP,         CMDTABLE::VAR_NONE,       NULL},
    {"CONFIG:",      PROP_CONFIG,       CMDTABLE::VAR_NONE,       NULL},
    {"DUMPTYPE:",    PROP_DUMPTYPE,     CMDTABLE::VAR_NONE,       NULL},
    {"GENKEY:",      PROP_GENKEY,       CMDTABLE::VAR_NONE,       NULL},
    {"KEYIN:",       PROP_KEYIN,        CMDTABLE::VAR_NONE,       NULL},
    {"KEYOUT:",      PROP_KEYOUT,       CMDTABLE::VAR_NONE,       NULL},
    {"KEYOUTENC:",   PROP_KEYOUTENC,    CMDTABLE::VAR_NONE,       NULL},
    {"V:",           "",                CMDTABLE::VAR_INT,        &g_ib.m_nTraceLevel}
};



// 
// CXCryptMain class 
//

void
CXCryptMain::PrintUsage()
{
    fprintf(stderr,
        "Usage: XCRYPT [switches] [cfgfile]\n\n"
        "  /GENKEY:{PUB|SYM}\tGenerate key PUB=Public, SYM=Symmetric\n"
        "  /KEYOUT:file\t\tKey file to be created (plain text)\n"
        "  /KEYOUTENC:file\tKey file to be created (cipher text)\n"
        "  /KEYIN:file\t\tKey file to be read\n"
        "  /DUMPTYPE:{BIN|ASM|C}\tDump type\n"
        "  /?\t\t\tDisplay this message\n"
        "\n\nEx: Generate public keypair plain text file:\n"
        "  XCRYPT /GENKEY:PUB /KEYOUT:test.xck\n"
        "\nEx: Generate symmetric key in cipher text file:\n"
        "  XCRYPT /GENKEY:SYM /KEYOUTENC:test.key\n"
        "\nEx: Dump a key file in ASM format:\n"
        "  XCRYPT /KEYIN:test.key /DUMPTYPE:ASM\n"
        "\nEx: Create a new cipher text file by copying an existing file:\n"
        "  XCRYPT /KEYIN:test.key /KEYOUTENC:test2.key\n"
        );
}



//  CXCryptMain::Initialize
//      In lieu of constructor, called to set up everything for an image run.
//      Assumed to return success. Any failure will cause the initialize function
//      to force an exit.
void
CXCryptMain::Initialize(
    int argc,
    char** argv
    )
{
    printf("Microsoft (R) XCRYPT - MICROSOFT CONFIDENTIAL %s\n"
           "Copyright (C) Microsoft Corporation 2000. All rights reserved.\n\n", 
           VER_PRODUCTVERSION_STR);

    //
    // read switches from command line
    //
    for (int i = 1 ; i < argc ; i++)
    {
        if (*argv[i] == '-' || *argv[i] == '/')
        {
            ParseSwitch(argv[i]);
        }
        else
        {
            // 
            // not a switch. See if we already have an exe file. If we do, this is an error
            //
            if (g_ib.m_prop.Get(PROP_CONFIG))
            {
                g_ib.PrintUsage();
                g_ib.Exit(-1, "Only one config file can be specified at a time");
            }
            g_ib.m_prop.Set(PROP_CONFIG, argv[i]);

        }
    }

    // 
    // if a config file is specified, read switches from it
    //
    if (g_ib.m_prop.Get(PROP_CONFIG))
    {
        ReadSwitchesFromFile(g_ib.m_prop.Get(PROP_CONFIG));
    }

}


void
CXCryptMain::ParseSwitch(
    LPCTSTR pszArg
    )
{
    LPCTSTR lpKey;
    CMDTABLE* lpCommand;


    // Search for the command in the command table, bail if we don't find it
    lpKey = pszArg + 1;
    lpCommand = (CMDTABLE*)bsearch((char*)&lpKey, (char*)&CmdTable[0],
        ARRAYSIZE(CmdTable), sizeof (CMDTABLE), 
        CMDTABLE::Compare);
    if (!lpCommand)
    {
        g_ib.PrintUsage();
        ERROR_OUT("Invalid switch '%s'", lpKey);
        g_ib.Exit(-1, NULL);
    }

    // Note that the CRT handles quoted (")
    // command line arguments and puts them in argv correctly and strips the quotes
    lpKey = pszArg + strlen(lpCommand->lpCmdLine) + 1;

    // if a property name is specified, add the command and value as a property. 
    if (lpCommand->lpPropName[0] != '\0')
    {
        g_ib.m_prop.Set(lpCommand->lpPropName, lpKey);
    }

    // if there's a variable, set it
    if (lpCommand->lpVar && lpCommand->vartype != CMDTABLE::VAR_NONE)
    {
        switch (lpCommand->vartype)
        {
            case CMDTABLE::VAR_STRING:
                *(char**)lpCommand->lpVar = (char*)lpKey;
                break;

            case CMDTABLE::VAR_INT:
                *(int*)lpCommand->lpVar = atoi(lpKey);
                break;

            case CMDTABLE::VAR_STRINGLIST:
                BLOCK
                {
                    CStrNode* pStrNode;

                    pStrNode = new CStrNode;
                    pStrNode->SetValue(lpKey);
                
                    // add it to the list
                    pStrNode->Link((CListHead*)(lpCommand->lpVar), NULL);
                }
                break;


        }  // switch
    }
}



void
CXCryptMain::ReadSwitchesFromFile(
    LPCSTR pszFN
    )
{
    FILE* f;
    char szLine[255];
    int ret;

    f = fopen(pszFN, "r");
    if (f != NULL)
    {
        while (!feof(f))
        {
            ret = fscanf(f, "%s", szLine);
            if (ret == 0 || ret == EOF)
                break;

            if (szLine[0] == '-' || szLine[0] == '/')
            {
                ParseSwitch(szLine);
            }
            else
            {
                g_ib.Exit(-1, "Invalid entry in config file");
            }
        }
        fclose(f);
    }
    else
    {
        g_ib.Exit(-1, "Could not open config file");
    }
        
}



//  CXCryptMain::Exit
//      Called to force the application to exit. All exits, fatal or not, should be done through this
//      method. Pass in NULL if there is no fatal error message.
void
CXCryptMain::Exit(
    int nReturnCode,
    LPCSTR lpszFatalError
    )
{
    // 
    // spew the final messages if any
    //

    TRACE_OUT(TRACE_ALWAYS, "");

    for (CNode* pNode = m_Warnings.GetHead(); pNode != NULL; pNode = pNode->Next())
    {
        CStrNode* pStr = (CStrNode*)pNode;

        WARNING_OUT(pStr->GetValue());
    }

    if (lpszFatalError)
    {
        ERROR_OUT(lpszFatalError);
    }
    if (m_pszExitMsg)
    {
        ERROR_OUT(m_pszExitMsg);
        
        // if exit msg was specified, force return code to be -1
        nReturnCode = -1;
    }


    if (nReturnCode == -1)
    {
        //
        // we had a fatal error, delete the out file because it is invalid
        //
    }


    exit(nReturnCode);
}


void
CXCryptMain::SetExitMsg(
    HRESULT hr,
    LPCSTR pszExitMsg
    )
{
    LPSTR pszMsg;
    char szMsg[512];
    const char szNULL[] = "NULL";
    int l;

    if (pszExitMsg == NULL)
    {
        pszExitMsg = szNULL;
    }

    if (hr == E_UNEXPECTED)
    {
        sprintf(szMsg, "%s (Unexpected error occurred)", pszExitMsg);
    }
    else
    {
        if (FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            hr,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
            (LPSTR)&pszMsg,
            0,
            NULL) != 0)
        {
            sprintf(szMsg, "%s (%s", pszExitMsg, pszMsg);

            LocalFree(pszMsg);

            // strip the end of line characters
            l = strlen(szMsg);
            if (l >= 2 && szMsg[l - 2] == '\r')
            {
                szMsg[l - 2] = '\0';
            }

            strcat(szMsg, ")");
        }
        else
        {
            sprintf(szMsg, "%s", pszExitMsg);
        }
    }

    SetExitMsg(szMsg);
}


void
CXCryptMain::SetExitMsg(
    LPCSTR pszMsg
    )
{

    m_pszExitMsg = _strdup(pszMsg);
}



//  CXCryptMain::TraceOut
//      Called by TRACE_OUT macro. Don't put in line feeds.
void
CXCryptMain::TraceOut(
    int nLevel,
    LPCSTR lpszFormat,
    va_list vararg
    )
{
    char szOutput[4096];

    // Make sure we're at an appropriate trace level
    if (nLevel > g_ib.m_nTraceLevel)
        return;

    vsprintf((char*)szOutput, (char*)lpszFormat, vararg);

    // Spew it out
    printf(TEXT("%s\n"), szOutput);
}


void
CXCryptMain::ErrorOut(
    BOOL bErr,
    LPCSTR lpszFormat,
    va_list vararg
    )
{
    char szOutput[4096];

    vsprintf((char*)szOutput, (char*)lpszFormat, vararg);

    if (bErr)
    {
        fprintf(stderr, "XCRYPT : Error : %s\n", szOutput);
    }
    else
    {
        fprintf(stderr, "XCRYPT : Warning : %s\n", szOutput);
    }
}



void
CXCryptMain::AddWarning(
    LPCSTR pszFormat, ...
    )
{
    CStrNode* pStrNode;
    char szBuf[512];
    va_list ArgList;
    
    va_start(ArgList, pszFormat);
    wvsprintf(szBuf, pszFormat, ArgList);
    va_end(ArgList);

    pStrNode = new CStrNode;
    pStrNode->SetValue(szBuf);

    // add it to the list
    pStrNode->Link(&m_Warnings, NULL);
   
}



int
_cdecl
CMDTABLE::Compare(
    const void* p1, 
    const void* p2
    )
{
    char** pkey = (char**)p1;
    CMDTABLE* ptab = (CMDTABLE*)p2;

    return _strnicmp(*pkey, ptab->lpCmdLine, strlen(ptab->lpCmdLine));
}



//
// CXCMainTool
//
class CXCMainTool : public CXCTool
{
public:
    void Out(LPCSTR pszFormat, ...);

};


void 
CXCMainTool::Out(
    LPCSTR pszFormat, 
    ...
    )
/*++

Routine Description:

    printf functality

Arguments:

Return Value:

    None

--*/
{
    char szBuf[2048];
    va_list ArgList;
    
    va_start(ArgList, pszFormat);
    wvsprintf(szBuf, pszFormat, ArgList);
    va_end(ArgList);

    printf(szBuf);
}



BOOL
CXCTool::ReadPassword(
    LPCSTR pszPrompt, 
    LPSTR pszPassword
    )
{
    int c;
    int n = 0;

    printf(pszPrompt);

    for (;;)
    {
         c = _getch();

         //
         // ^C
         //
         if (c == 0x3)
         {
             putchar('\n');
             ExitProcess(0);
         }

         //
         // Backspace
         //
         if (c == 0x8)
         {
             if (n)
             {
                n--;
                _putch(0x8);
                _putch(' ');
                _putch(0x8);
             }
             continue;
         }

         //
         // Return
         //
         if (c == '\r')
             break;

         if ((n + 1) < PASSWORD_MAXSIZE) 
         {
             pszPassword[n++] = (char)c;
             _putch('*');
         }
    }

    pszPassword[n] = 0;
    putchar('\n');

    if (strlen(pszPassword) < PASSWORD_MINLEN) 
    {
        ERROR_OUT("Password must at least be %d characters", PASSWORD_MINLEN);
        pszPassword[0] = 0;
        return FALSE;        
    }

    return TRUE;
} 

 
void
CStrNode::Dump()
{
    TRACE_OUT(TRACE_ALWAYS, m_pszValue);
}



const ULONG CRandom::rgulMults[] = {
    0x52F690D5,
    0x534D7DDE,
    0x5B71A70F,
    0x66793320,
    0x9B7E5ED5,
    0xA465265E,
    0xA53F1D11,
    0xB154430F,
};

CRandom::CRandom(void)
{
    FILETIME ft;

    /* If this call fails, we still have random data in ft */
    GetSystemTimeAsFileTime(&ft);
    Seed(ft.dwHighDateTime ^ ft.dwLowDateTime);
}

void CRandom::Seed(ULONG ulSeed)
{
    m_ulMask = 0;
    m_ulMult = rgulMults[ulSeed & 7];
    m_ulCur = ulSeed;
    m_ulMask = Rand();
}

ULONG CRandom::Rand(void)
{
    ULARGE_INTEGER li;

    /* We're not a true 32-bit generator, since 2^32+1 isn't prime, so we use
     * 2^32-5 instead */
    li.QuadPart = m_ulCur;
    li.QuadPart += 1;
    li.QuadPart *= m_ulMult;
    li.QuadPart %= 0xFFFFFFFB;
    m_ulCur = li.LowPart;
    return m_ulCur ^ m_ulMask;
}

void CRandom::RandBytes(LPBYTE pb, DWORD cb)
{
    PUSHORT pus;

    if(cb == 0)
        return;
    if((ULONG)pb & 1) {
        *pb++ = (BYTE)(Rand() >> 14);
        --cb;
    }
    pus = (PUSHORT)pb;
    while(cb > 1) {
        *pus++ = (USHORT)(Rand() >> 8);
        cb -= 2;
    }
    if(cb)
        *pb = (BYTE)(Rand() >> 12);
}




extern "C"
int
_cdecl
main(
    int argc,
    char** argv
    )
{

    HRESULT hr;
    CXCMainTool Tool;
    BOOL bUsage = TRUE;
    CXCMainTool::DUMPTYPE DumpType = CXCMainTool::DUMP_NONE;

    g_ib.Initialize(argc, argv);

    LPCSTR pszGenKey = g_ib.m_prop.Get(PROP_GENKEY);
    LPCSTR pszDumpType = g_ib.m_prop.Get(PROP_DUMPTYPE);

    if (pszDumpType != NULL)
    {
        
        if (_stricmp(pszDumpType, "BIN") == 0)
            DumpType = CXCMainTool::DUMP_BIN;
        else if (_stricmp(pszDumpType, "ASM") == 0)
            DumpType = CXCMainTool::DUMP_ASM;
        else if (_stricmp(pszDumpType, "C") == 0)
            DumpType = CXCMainTool::DUMP_C;
        else
        {
            g_ib.SetExitMsg("Invalid dump type");
            goto Cleanup;
        }        
    }

    if (pszGenKey != NULL)
    {
        //
        // genereate key
        //

        if (g_ib.m_prop.Get(PROP_KEYOUT) == NULL && g_ib.m_prop.Get(PROP_KEYOUTENC) == NULL)
        {
            g_ib.SetExitMsg(-1, "Must specify /KEYOUT or /KEYOUTENC with /GENKEY");
        }
        else if (_stricmp(pszGenKey, "PUB") == 0)
        {
            if (g_ib.m_prop.Get(PROP_KEYOUTENC) != NULL)
            {
                //
                // Generate public key pair as cipher text
                //
                hr = Tool.GeneratePubPair(g_ib.m_prop.Get(PROP_KEYOUTENC), TRUE);
            }
            else
            {
                //
                // Generate public key pair as plain text
                //
                hr = Tool.GeneratePubPair(g_ib.m_prop.Get(PROP_KEYOUT), FALSE);

            }
            if (FAILED(hr))
            {
                g_ib.SetExitMsg(hr, "Could not generate public key pairs");
                goto Cleanup;
            }

            if (DumpType != CXCMainTool::DUMP_NONE)
            {
                //
                // Dump out the key
                //
                if (g_ib.m_prop.Get(PROP_KEYOUTENC) != NULL)
                {
                    Tool.DumpKeyFile(g_ib.m_prop.Get(PROP_KEYOUTENC), DumpType);
                }
                else
                {
                    Tool.DumpKeyFile(g_ib.m_prop.Get(PROP_KEYOUT), DumpType);
                }
            }

            bUsage = FALSE;
        }
        else if (_stricmp(pszGenKey, "SYM") == 0)
        {

            if (g_ib.m_prop.Get(PROP_KEYOUTENC) != NULL)
            {
                //
                // Generate symetric key as cipher text
                //
                hr = Tool.GenerateSymKey(g_ib.m_prop.Get(PROP_KEYOUTENC), TRUE);
            }
            else
            {
                //
                // Generate symetric key as plain text
                //
                hr = Tool.GenerateSymKey(g_ib.m_prop.Get(PROP_KEYOUT), FALSE);
            }

            if (FAILED(hr))
            {
                g_ib.SetExitMsg(hr, "Could not generate symmetric key");
                goto Cleanup;
            }

            if (DumpType != CXCMainTool::DUMP_NONE)
            {
                //
                // Dump out the key
                //
                if (g_ib.m_prop.Get(PROP_KEYOUTENC) != NULL)
                {
                    Tool.DumpKeyFile(g_ib.m_prop.Get(PROP_KEYOUTENC), DumpType);
                }
                else
                {
                    Tool.DumpKeyFile(g_ib.m_prop.Get(PROP_KEYOUT), DumpType);
                }
                if (FAILED(hr))
                {
                    g_ib.SetExitMsg(hr, "Could not copy key file");
                    goto Cleanup;
                }
            }

            bUsage = FALSE;
        }
        else
        {
            g_ib.SetExitMsg(-1, "/GENKEY can only be PUB or SYM");
        }
    }
    else if (pszDumpType != NULL)
    {
        //
        // dump key
        //
        if (g_ib.m_prop.Get(PROP_KEYIN) == NULL)
        {
            g_ib.SetExitMsg(-1, "Must specify /KEYIN with /DUMPTYPE");
        }
        else
        {
            Tool.DumpKeyFile(g_ib.m_prop.Get(PROP_KEYIN), DumpType);
            bUsage = FALSE;
        }
    }
    else if (g_ib.m_prop.Get(PROP_KEYOUT) != NULL || g_ib.m_prop.Get(PROP_KEYOUTENC)) 
    {
        //
        // Output a key file from existing keyfile
        //
        if (g_ib.m_prop.Get(PROP_KEYIN) == NULL)
        {
            g_ib.SetExitMsg(-1, "Must specify /KEYIN to copy key to another keyfile");
        }
        
        if (g_ib.m_prop.Get(PROP_KEYOUTENC) != NULL)
        {
            hr = Tool.CopyKeyFile(g_ib.m_prop.Get(PROP_KEYIN), g_ib.m_prop.Get(PROP_KEYOUTENC), TRUE);
        }
        else
        {
            hr = Tool.CopyKeyFile(g_ib.m_prop.Get(PROP_KEYIN), g_ib.m_prop.Get(PROP_KEYOUT), FALSE);
        }
        
        bUsage = FALSE;
    }

Cleanup:
    if (bUsage)
    {
        g_ib.PrintUsage();
    }

      
    // successful exit, does not return
    g_ib.Exit(0, NULL);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xcrypt\xctool.h ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    xctool.h

Abstract:

    Generates and dumps keys

--*/

 
#ifndef _XCTOOL_H
#define _XCTOOL_H

#include <windows.h>

class CXCTool
{
public:

    enum DUMPTYPE {DUMP_NONE, DUMP_BIN, DUMP_ASM, DUMP_C};

    CXCTool() {}
    
    BOOL GeneratePubPair(LPCSTR pszKeyFileName, BOOL bEnc);
    BOOL GenerateSymKey(LPCSTR pszKeyFileName, BOOL bEnc);
    BOOL DumpKeyFile(LPCSTR pszKey, DUMPTYPE DumpType);
    BOOL CopyKeyFile(LPCSTR pszInFileName, LPCSTR pszOutFileName, BOOL bEncOut);

    virtual void Out(LPCSTR pszFormat, ...);
    virtual void DumpBytes(DUMPTYPE DumpType, LPCSTR pszLabel, PBYTE pbData, DWORD dwDataLen);
    virtual BOOL ReadPassword(LPCSTR pszPrompt, LPSTR pszPassword);
};


#endif //_XCTOOL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\test\pentam\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <stdio.h>
#include <assert.h>
#include <D3DX8Math.h>
#include <xgraphics.h>

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const WCHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}


//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };

    D3DLOCKED_RECT lockRect;
    if(pSurface->LockRect(&lockRect, NULL,
            D3DLOCK_NOSYSLOCK | D3DLOCK_RAWDATA) != S_OK)
    {
        assert(FALSE);
        return;
    }

    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);

    PVOID pBits = Swizzler_GetUnswizzledBits(&lockRect, &desc);
    if (pBits == NULL)
    {
        assert(FALSE);
        pSurface->UnlockRect();
        return;
    }

    PVOID pBitsOld = lockRect.pBits;
    lockRect.pBits = pBits;

    UINT BitsPerPixel =
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );

    lockRect.pBits = pBitsOld;
    Swizzler_SwizzleFromBits(pBits, &lockRect, &desc);

    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
    case D3DFMT_LIN_A8R8G8B8:
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
    case D3DFMT_LIN_X8R8G8B8:
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
    case D3DFMT_LIN_R5G6B5:
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
    case D3DFMT_LIN_X1R5G5B5:
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
    case D3DFMT_LIN_A4R4G4B4:
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
    case D3DFMT_LIN_A1R5G5B5:
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};

//----------------------------------------------------------------------------
// Map our 'new' directly to LocalAlloc
void* __cdecl operator new(size_t size)
{
    return LocalAlloc(0, size);
}

//----------------------------------------------------------------------------
// Map our 'delete' directly to LocalFree   
VOID __cdecl operator delete(VOID* alloc)
{
    LocalFree(alloc);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xcrypt\xctool.cpp ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    xctool.cpp

Abstract:

    Implements the CXCTool class which handles most of the functionality of the tool

--*/

#include <windows.h>
#include <stdlib.h>
#include <rsa.h>
#include <sha.h>
#include <rc4.h>
#include <xcrypt.h>

#include "xctool.h"
#include "xcmain.h"
#include "key.h"


//
// CXCTool class
//

BOOL
CXCTool::GeneratePubPair(
    IN LPCSTR pszKeyFileName,
    IN BOOL bEnc
    )
{
    CKeyFile KeyFile;

    //
    // Generate public/private keys
    //
    if (!KeyFile.CreatePubKeyPair(XC_KEY_BITS))
    {
        return FALSE;
    }

    if (bEnc) 
    {
        char szPassword[PASSWORD_MAXSIZE];
        char szPassword2[PASSWORD_MAXSIZE];

        if (ReadPassword("Password to encrypt new file: ", szPassword))
        {
            if (ReadPassword("Reenter password to verify: ", szPassword2))
            {
                if (strcmp(szPassword, szPassword2) == 0)
                {
                    //
                    // Write the keys out as cipher text
                    //
                    return KeyFile.WriteToEncFile(pszKeyFileName, szPassword);
                }
                else 
                {
                    ERROR_OUT("Password reentered incorrectly");
                }
            }
        }
    }
    else
    {
        //
        // Write the keys out as plain text
        //
        return KeyFile.WriteToFile(pszKeyFileName);
    }
    return FALSE;
}


BOOL
CXCTool::GenerateSymKey(
    IN LPCSTR pszKeyFileName,
    IN BOOL bEnc
    )
{
    CKeyFile KeyFile;

    //
    // Generate symmetric key
    //
    if (!KeyFile.CreateSymKey2())
    {
        return FALSE;
    }

    if (bEnc) 
    {
        char szPassword[PASSWORD_MAXSIZE];
        char szPassword2[PASSWORD_MAXSIZE];

        if (ReadPassword("Password to encrypt new file: ", szPassword))
        {
            if (ReadPassword("Reenter password to verify: ", szPassword2))
            {
                if (strcmp(szPassword, szPassword2) == 0)
                {
                    //
                    // Write the keys out as cipher text
                    //
                    return KeyFile.WriteToEncFile(pszKeyFileName, szPassword);
                }
                else 
                {
                    ERROR_OUT("Password reentered incorrectly");
                }
            }
        }
    }
    else
    {
        //
        // Write the keys out as plain text
        //
        return KeyFile.WriteToFile(pszKeyFileName);
    }
    return FALSE;
}


BOOL 
CXCTool::CopyKeyFile(
    LPCSTR pszInFileName, 
    LPCSTR pszOutFileName, 
    BOOL bEncOut
    )
{
    CKeyFile KeyFile;
    BOOL bInEnc;
    char szPassword[PASSWORD_MAXSIZE];

    bInEnc = KeyFile.IsEncFile(pszInFileName);

    if (bInEnc) 
    {

        if (ReadPassword("Password to read file: ", szPassword))
        {
            if (!KeyFile.ReadFromEncFile(pszInFileName, szPassword))
            {
                return FALSE;
            }
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        if (!KeyFile.ReadFromFile(pszInFileName))
        {
            return FALSE;
        }
    }

    if (bEncOut) 
    {
        char szPassword2[PASSWORD_MAXSIZE];

        if (ReadPassword("Password to encrypt new file: ", szPassword))
        {
            if (ReadPassword("Reenter password to verify: ", szPassword2))
            {
                if (strcmp(szPassword, szPassword2) == 0)
                {
                    //
                    // Write the keys out as cipher text
                    //
                    return KeyFile.WriteToEncFile(pszOutFileName, szPassword);
                }
                else 
                {
                    ERROR_OUT("Password reentered incorrectly");
                }
            }
        }
    }
    else
    {
        //
        // Write the keys out as plain text
        //
        return KeyFile.WriteToFile(pszOutFileName);
    }
    return FALSE;

}



BOOL
CXCTool::DumpKeyFile(
    LPCSTR pszFN,
    DUMPTYPE DumpType
    )
{
    CKeyFile KeyFile;
    LPBSAFE_PUB_KEY pBSafe;
    BOOL bEnc;

    bEnc = KeyFile.IsEncFile(pszFN);

    if (bEnc) 
    {
        char szPassword[PASSWORD_MAXSIZE];

        if (ReadPassword("Password to read file: ", szPassword))
        {
            if (!KeyFile.ReadFromEncFile(pszFN, szPassword))
            {
                return FALSE;
            }
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        if (!KeyFile.ReadFromFile(pszFN))
        {
            return FALSE;
        }
    }

    if (KeyFile.KeyHeader()->KeyType == KEYFILE_SYM)
    {
        Out("%s SYMMETRIC KEY FILE: %s\n", bEnc ? "CIPHER TEXT" : "PLAIN TEXT", pszFN);
    }
    else
    {
        Out("%s PUBLIC KEY PAIR FILE: %s\n", bEnc ? "CIPHER TEXT" : "PLAIN TEXT", pszFN);
    }

    Out("    Bits in key:                %d\n", KeyFile.KeyHeader()->KeyBits);
    Out("    Key number:                 %d\n", KeyFile.KeyHeader()->KeyNumber);

    if (KeyFile.KeyHeader()->KeyType == KEYFILE_SYM)
    {
        DumpBytes(DumpType, "Symmetric Key Dump", KeyFile.SymmetricKey(), KeyFile.KeyHeader()->KeyBits / 8);
    }
    else
    {
        pBSafe = (LPBSAFE_PUB_KEY)(KeyFile.PublicKey());

        Out("    Bits in modulus(bitlen):    %d\n", pBSafe->bitlen);
        Out("    Size of modulus(keylen):    %d\n", pBSafe->keylen);
        Out("    Max bytes encoded(datalen): %d\n", pBSafe->datalen);
        Out("    Public exponent(pubexp):    %d\n", pBSafe->pubexp);
        Out("\n");
        //
        // dump public key
        //
        if (pBSafe != NULL)
        {
            DumpBytes(DumpType, "Public Key Dump", (PBYTE)pBSafe, KeyFile.KeyHeader()->PublicKeyBytes);
        }

        //
        // dump private key
        //

        pBSafe = (LPBSAFE_PUB_KEY)(KeyFile.PrivateKey());
        if (pBSafe != NULL)
        {
            DumpBytes(DumpType, "Private Key Dump", (PBYTE)pBSafe, KeyFile.KeyHeader()->PrivateKeyBytes);
        }
    }


    return TRUE;
}


void 
CXCTool::Out(
    LPCSTR, 
    ...
    )
/*++

Routine Description:

    printf functality.  Must be overridden by the calling module

Arguments:

Return Value:

    None

--*/
{
}




void
CXCTool::DumpBytes(
    DUMPTYPE DumpType,
    LPCSTR pszLabel, 
    PBYTE pbData, 
    DWORD dwDataLen
    )
/*++

Routine Description:

    Dumps the given data as hex and ascii

Arguments:

Return Value:

    None

--*/
{
    DWORD i;
    DWORD beg;

    Out("    %s (%d bytes):\n", pszLabel, dwDataLen);
    if (DumpType == DUMP_BIN)
    {
        beg = 0;
        for (i = 0; i < dwDataLen; i++)
        {
            Out("%02X ", pbData[i]);
            if ((i + 1) % 16 == 0 || (i + 1) == dwDataLen)
            {
                DWORD j;

                for (j = (i - beg); j < 16; j++)
                {
                    Out("   ");
                }

                for (j = beg; j <= i; j++)
                {
                    if (pbData[j] >= 32)
                        Out("%c", pbData[j]);
                    else
                        Out(".");
                }
                beg = i + 1;

                Out("\n");
            }
        }
        Out("\n");
    }
    else 
    {
        if (DumpType == DUMP_C)
            Out("    {\n");

        for (i = 0; i < dwDataLen; i++)
        {
            if (i % 8 == 0)
            {
                if (DumpType == DUMP_ASM)
                    Out("        DB ");
                else
                    Out("           ");
            }

            if (DumpType == DUMP_ASM)
            {
                Out("0%02Xh", pbData[i]);

                if ((i + 1) % 8 == 0)
                    Out("\n");
                else if ((i + 1) != dwDataLen)
                    Out(",");
            }
            else
            {
                Out("0x%02X", pbData[i]);
                
                if ((i + 1) != dwDataLen)
                    Out(",");
                if ((i + 1) % 8 == 0)
                    Out("\n");
            }
            
        }

        if (DumpType == DUMP_C)
            Out("\n    }\n");

        Out("\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xcrypt\xcmain.h ===
#ifndef __XCRYPT_H__
#define __XCRYPT_H__

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <stdarg.h>
#include <time.h>
#include "list.h"
#include "property.h"

#define ARRAYSIZE(a) (sizeof(a) / sizeof(a[0]))

#if DBG == 1
    #define DEBUG
#else
    #undef DEBUG
#endif



// Debug defines. Note that we could completely remove in retail, but since this
// is a tool, it's quite useful to be able to optionally turn on debug spew.
#define TRACE_ALWAYS      0       // Always display
#define TRACE_VERBOSE     1       // Display if verbose logging turned on
#define TRACE_DEBUG       2       // Display if debug-level logging turned on
#define TRACE_SPEW        3       // Display only if very chatty logging turned on

#define PASSWORD_MAXSIZE  21
#define PASSWORD_MINLEN   8


class CXCryptMain
{

public:
    CPropertyBundle m_prop;
    int             m_nTraceLevel;
    CListHead       m_Warnings;         // Warnings to be displayed at the end--list of CStrNode

    CXCryptMain() 
        : m_nTraceLevel(TRACE_VERBOSE),
          m_pszExitMsg(NULL)
    { 
    }

    ~CXCryptMain() 
    { 
        // Global object, everything should be cleaned up by Exit() 
    }

    void Initialize(int argc, char** argv);
    void ReadSwitchesFromFile(LPCSTR pszFN);
    void Exit(int nReturnCode, LPCSTR lpszFatalError);
    void SetExitMsg(HRESULT hr, LPCSTR pszExitMsg);
    void SetExitMsg(LPCSTR pszExitMsg);
    void AddWarning(LPCSTR pszFormat, ...);

    void BuildImage();
    void PrintUsage();
  
    // static functions
    static void TraceOut(int nLevel, LPCSTR lpszFormat, va_list vararg); // Use TRACE_OUT inline
    static void ErrorOut(BOOL bErr, LPCSTR lpszFormat, va_list vararg);  // use ERROR_OUT or WARNING_OUT inlines


private:
    void ParseSwitch(LPCTSTR pszArg);

    LPSTR m_pszExitMsg;
};


typedef struct
{
    enum VARTYPE {VAR_NONE, VAR_INT, VAR_STRING, VAR_STRINGLIST};

    LPCTSTR lpCmdLine;
    LPCTSTR lpPropName;
    VARTYPE vartype;
    void* lpVar;

    static int _cdecl Compare(const void*, const void*);
} CMDTABLE;


class CStrNode : public CNode
{
public:
    CStrNode() 
        : m_pszValue(NULL)
    {
    }
    ~CStrNode()
    {
        if (m_pszValue != NULL)
            free(m_pszValue);
    }
    void SetValue(LPCSTR pszValue)
    {
        if (m_pszValue != NULL)
            free(m_pszValue);
        m_pszValue = _strdup(pszValue);
    }
    LPCSTR GetValue()
    {
        return m_pszValue;
    }

    virtual void Dump();

private:
    LPSTR m_pszValue;
};



class CRandom
{
public:
    CRandom(void);

    ULONG Rand(void);
    void RandBytes(LPBYTE pb, DWORD cb);
private:
    static const ULONG rgulMults[];
    void Seed(ULONG ulSeed);
    ULONG m_ulMult;
    ULONG m_ulCur;
    ULONG m_ulMask;
};



// Global class
extern CXCryptMain g_ib;

#define BLOCK

inline void TRACE_OUT(int nLevel, LPCSTR lpszFormat, ...)
{
    va_list vararg;
    va_start(vararg, lpszFormat);
    CXCryptMain::TraceOut(nLevel, lpszFormat, vararg);
    va_end(vararg);
}


inline void ERROR_OUT(LPCSTR lpszFormat, ...)
{
    va_list vararg;
    va_start(vararg, lpszFormat);
    CXCryptMain::ErrorOut(TRUE, lpszFormat, vararg);
    va_end(vararg);
}


inline void WARNING_OUT(LPCSTR lpszFormat, ...)
{
    va_list vararg;
    va_start(vararg, lpszFormat);
    CXCryptMain::ErrorOut(FALSE, lpszFormat, vararg);
    va_end(vararg);
}


inline void DEBUG_STOP_FORMAT(LPCSTR lpszFormat, ...)
{
    va_list vararg;
    va_start(vararg, lpszFormat);
    TRACE_OUT(TRACE_VERBOSE, TEXT("DebugStop:"));
    CXCryptMain::TraceOut(TRACE_ALWAYS, lpszFormat, vararg);
    va_end(vararg);
}

#ifdef DEBUG
#ifdef _M_IX86
#define DEBUG_STOP_HERE { __asm int 3 }
#else
#define DEBUG_STOP_HERE { DebugBreak(); }
#endif
#else
#define DEBUG_STOP_HERE
#endif
    
#define DEBUG_STOP(x)   \
{                       \
    TRACE_OUT(TRACE_VERBOSE, TEXT("DebugStop in %s at line %d (message follows):"), TEXT(__FILE__), __LINE__); \
    TRACE_OUT(TRACE_ALWAYS, x); \
    DEBUG_STOP_HERE \
}

#define ASSERT(x)   \
    (void)((x) || (TRACE_OUT(TRACE_VERBOSE, TEXT("Assert: failed [%s] in %s(%d)"), #x, \
        TEXT(__FILE__), __LINE__),0))


#endif // #ifndef __XCRYPT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\test\pentam\buildnt.h ===
#ifndef _BUILDNT_H_
#define _BUILDNT_H_

/*
	to compile within Visual C++'s IDE, go to
	Project/Settings/C++/Preprocessor/Preprocessor Definitions
	and add the BUILD_FROM_VC define

	and add the following include paths in Tools/Options/Directories:

		include:	\xbox\public\oak\inc
		include:	\xbox\public\sdk\inc
		include:	\xbox\private\sdk\inc
		include:	\xbox\public\sdk\inc\crt [for XBox apps]
		lib:		\xbox\public\sdk\lib\i386

	Note to self: for custom entry points like xbounce, go to
	Project/Settings/Link/Category:Output/Entry-Point Symbol
	[xbounce uses wWinMainCRTStartup]

	Note: need to remove /GZ call if default libraries are disabled

*/

#ifdef BUILD_FROM_VC

/*
	A default XBox project will have the following defines:

	Debug:   WIN32,_XBOX,_DEBUG,_WINDOWS,_MBCS
	Release: WIN32,_XBOX,NDEBUG,_WINDOWS,_MBCS
*/

/* force UNICODE */

#ifdef _MBCS
#pragma message("Undefining _MBCS macro")
#undef _MBCS
#endif

#ifndef UNICODE
#pragma message("Adding UNICODE macro")
#define UNICODE
#endif

#define i386					1
#define _X86_					1
#define STD_CALL
#define CONDITION_HANDLING		1
#define NT_UP					1
#define NT_INST					0

#ifdef WIN32
#undef WIN32
#endif
#define WIN32					100

#define _NT1X_					100
#define WINNT					1
#define _WIN32_WINNT			0x0500
#define WINVER					0x0500
#define _WIN32_IE				0x0501
#define	XBOX					1
#define WIN32_LEAN_AND_MEAN		1
#define DBG						1
#define DEVL					1
#define FPO						0
#define _MT						1
#define DEVKIT


#if NDEBUG
#define FREEBUILD 1
#else
#define FREEBUILD 0
#endif

#include "warning.h"

#else
#include <xtl.h> /* Xbox app master file */
#endif /* #ifdef BUILD_FROM_VC */

#endif /* #ifndef _BUILDNT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\test\pentam\draw.cpp ===
/*--
Copyright (c) 2000 Microsoft Corporation - Xbox SDK

Module Name:

    Main.cpp

Abstract:

    Simple sample for drawing text on the screen.

Revision History:

    Derived from a DX8 sample.
--*/

#include "buildnt.h"
#include "draw.h"

//------------------------------------------------------------------------------
// CDraw
//
// Handy little D3D encapsulation for simple 2D drawing.


//------------------------------------------------------------------------------
// CDraw::m_pDevice
//
// Instantiate static class member, initialized to NULL.

IDirect3DDevice8* CDraw::m_pDevice;

//------------------------------------------------------------------------------
// CDraw constructor

CDraw::CDraw(INT width, INT height)
{
    m_pBackBuffer = NULL;

    // If we're invoked multiple times, we inherit the old mode (largely
    // because we don't support multiple mode sets on Xbox yet):

    if (m_pDevice == NULL)
    {
        // Create D3D 8.
    
        IDirect3D8 *pD3D = Direct3DCreate8(D3D_SDK_VERSION);
        if (pD3D == NULL)
            return;
    
        // Set the screen mode.
    
        D3DPRESENT_PARAMETERS d3dpp;
        ZeroMemory(&d3dpp, sizeof(d3dpp));
    
        d3dpp.BackBufferWidth           = width;
        d3dpp.BackBufferHeight          = height;
        d3dpp.BackBufferFormat          = D3DFMT_X8R8G8B8;
        d3dpp.BackBufferCount           = 1;
        d3dpp.Windowed                  = false;    // Must be false for Xbox
        d3dpp.EnableAutoDepthStencil    = true;
        d3dpp.AutoDepthStencilFormat    = D3DFMT_R5G6B5;
        d3dpp.SwapEffect                = D3DSWAPEFFECT_DISCARD;
        d3dpp.FullScreen_RefreshRateInHz= 60;
        d3dpp.hDeviceWindow             = NULL;
    
        // Create the device.
	HRESULT hr = pD3D->CreateDevice
		(
		    D3DADAPTER_DEFAULT,
		    D3DDEVTYPE_HAL,
		    NULL,
		    D3DCREATE_HARDWARE_VERTEXPROCESSING,
		    &d3dpp,
		    &m_pDevice
		);
	if (hr != S_OK)
        {
            pD3D->Release();

            return;
        }
    
        // Now we no longer need the D3D interface so let's free it.
    
        pD3D->Release();
    }

    m_pDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &m_pBackBuffer);
}

//------------------------------------------------------------------------------
// CDraw::~CDraw

CDraw::~CDraw()
{
    if (m_pBackBuffer)
        m_pBackBuffer->Release();
}

//------------------------------------------------------------------------------
// CDraw::FillRect

VOID CDraw::FillRect(
    INT x,
    INT y,
    INT width,
    INT height,
    D3DCOLOR color)
{
    D3DRECT rect;

    if (m_pDevice != NULL)
    {
        rect.x1 = x;
        rect.y1 = y;
        rect.x2 = x + width;
        rect.y2 = y + height;

        m_pDevice->Clear(1, &rect, D3DCLEAR_TARGET, color, 0, 0);
    }
}

//------------------------------------------------------------------------------
// CDraw::DrawText

VOID CDraw::DrawText(
    const WCHAR* string,
    INT x,
    INT y,
    D3DCOLOR foregroundColor,   // 0xff0000 is red
    D3DCOLOR backgroundColor,
    DWORD flags)
{
    if (m_pBackBuffer != NULL)
    {
        m_font.DrawText(m_pBackBuffer, string, x, y, flags, foregroundColor,
                        backgroundColor);
    }
}

//------------------------------------------------------------------------------
// CDraw::Present
//
// Make the current back-buffer visible

VOID CDraw::Present()
{
    if (m_pDevice != NULL)
    {
        m_pDevice->Present(NULL, NULL, NULL, NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\test\pentam\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_


#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#endif

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

// pack the structure as we're reading it from the disk
#pragma pack(1)

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const WCHAR* filename);

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const WCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void BitFont::DrawText
    (
        IDirect3DSurface8 *pSurface,
        const WCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};

#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\test\pentam\draw.h ===
#ifndef __DRAW_H__
#define __DRAW_H__

#include <d3d8.h>
#include "bitfont.h"

#define BACKDROP_BLUE 0x000080
#define PITCH_BLACK 0x0
#define LABEL_WHITE 0xffffff
#define DISCONNECTED_BLUE 0x000040
#define CONNECTED_YELLOW 0xffff00

class CDraw
{
private:

    static IDirect3DDevice8* m_pDevice;

    IDirect3DSurface8* m_pBackBuffer;

    BitFont m_font;

public:

    CDraw(INT width = 640, INT height = 480);

    ~CDraw();

    VOID FillRect(
        INT x,
        INT y,
        INT width,
        INT height,
        D3DCOLOR color);

    VOID DrawText(
        const WCHAR* string,
        INT x,
        INT y,
        D3DCOLOR foregroundColor,           // 0xff0000 is red
        D3DCOLOR backgroundColor = 0,
        DWORD flags = DRAWTEXT_TRANSPARENTBKGND);

    VOID Present();

    BOOL IsValid() { return m_pDevice != NULL; }
};


#endif __DRAW_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbbsweep\xbbsweep.cpp ===
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <xboxdbg.h>

//
// Name of the IDF data file on the xbox
//
#define XBOX_IRTSWEEP_FILENAME "E:\\irtsweep.dat"

CHAR* programname;

//
// Error message spews
//
VOID usage()
{
    fprintf(stderr, "usage: %s [-x xboxname] IDF-filename\n", programname);
    exit(1);
}

VOID checkerr(BOOL err, CHAR* format, ...)
{
    if (!err) return;

    va_list arglist;

    va_start(arglist, format);
    vfprintf(stderr, format, arglist);
    va_end(arglist);

    exit(-1);
}

INT __cdecl main(INT argc, CHAR** argv)
{
    // Parse command line options

    HRESULT hr;
    programname = *argv++;
    argc--;

    while (argc && **argv == '-') {
        if (argc > 1 && _stricmp(*argv, "-x") == 0) {
            hr = DmSetXboxName(argv[1]);
            checkerr(FAILED(hr), "Error setting xbox name: %x\n", hr);
            argv += 2; argc -= 2;
        } else {
            usage();
        }
    }
    if (argc != 1) usage();

    DmUseSharedConnection(TRUE);

    // Send irtsweep command to the xbox
    hr = DmSendCommand(NULL, "IRTSWEEP", NULL, 0);
    checkerr(FAILED(hr), "Error sending command to xbox: %x\n", hr);

    hr = DmReceiveFile(*argv, XBOX_IRTSWEEP_FILENAME);
    checkerr(FAILED(hr), "Error retrieving IDF data: %x\n", hr);

    DmUseSharedConnection(FALSE);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\test\pentam\pentam.cpp ===
#include "pentam.h"

// ---------------------------------------------------------------------------
// RenderBoard()
// Renders the board at the specified location.
// ---------------------------------------------------------------------------
void  CGameBoard::RenderBoard(CDraw *draw, int left, int top, BOOL bPaused)
{
	// clear the board background
	draw->FillRect(left, top, BOARD_WIDTH * SQUARE_SIZE + 1, BOARD_HEIGHT * SQUARE_SIZE + 1, 0xFF202020);
	
	if(bPaused)
	{
		for(int x=0;x<BOARD_WIDTH;x++)
		{
			for(int y=0;y<BOARD_HEIGHT;y++)
			{
				draw->FillRect(
					left + x * SQUARE_SIZE + 2, 
					top  + y * SQUARE_SIZE + 2, 
					SQUARE_SIZE - 2, 
					SQUARE_SIZE - 2, 
					g_dwSquareColorDK[COLOR_YELLOW]);
				
				draw->FillRect(
					left + x * SQUARE_SIZE + 1, 
					top  + y * SQUARE_SIZE + 1, 
					SQUARE_SIZE - 1, 
					1, 
					g_dwSquareColorLT[COLOR_YELLOW]);
				
				draw->FillRect(
					left + x * SQUARE_SIZE + 1, 
					top  + y * SQUARE_SIZE + 1, 
					1, 
					SQUARE_SIZE - 1, 
					g_dwSquareColorLT[COLOR_YELLOW]);
			}
		}
		
		return;
	}
	
	for(int x=0;x<BOARD_WIDTH;x++)
	{
		for(int y=0;y<BOARD_HEIGHT;y++)
		{
			unsigned char color = m_board[x][y];
			if(color)
			{
				draw->FillRect(
					left + x * SQUARE_SIZE + 2, 
					top  + y * SQUARE_SIZE + 2, 
					SQUARE_SIZE - 2, 
					SQUARE_SIZE - 2, 
					g_dwSquareColorDK[color]);
				
				draw->FillRect(
					left + x * SQUARE_SIZE + 1, 
					top  + y * SQUARE_SIZE + 1, 
					SQUARE_SIZE - 1, 
					1, 
					g_dwSquareColorLT[color]);
				
				draw->FillRect(
					left + x * SQUARE_SIZE + 1, 
					top  + y * SQUARE_SIZE + 1, 
					1, 
					SQUARE_SIZE - 1, 
					g_dwSquareColorLT[color]);
			}
		}
	}

	// Draw Cursor : top
	draw->FillRect(
		left + m_dwCursorX * SQUARE_SIZE, 
		top  + m_dwCursorY * SQUARE_SIZE, 
		SQUARE_SIZE << 1, 
		2, 
		0xffffffff);

	// Draw Cursor : bottom
	draw->FillRect(
		left + m_dwCursorX * SQUARE_SIZE, 
		top  + m_dwCursorY * SQUARE_SIZE + SQUARE_SIZE - 1,
		SQUARE_SIZE << 1, 
		2, 
		0xffffffff);

	// Draw Cursor : left
	draw->FillRect(
		left + m_dwCursorX * SQUARE_SIZE, 
		top  + m_dwCursorY * SQUARE_SIZE,
		2, 
		SQUARE_SIZE, 
		0xffffffff);

	// Draw Cursor : right
	draw->FillRect(
		left + m_dwCursorX * SQUARE_SIZE + (SQUARE_SIZE << 1) - 1,
		top  + m_dwCursorY * SQUARE_SIZE,
		2, 
		SQUARE_SIZE, 
		0xffffffff);
}

// ---------------------------------------------------------------------------
// ClearBoard()
// Clears the board data.
// ---------------------------------------------------------------------------
void  CGameBoard::ClearBoard()
{
	memset(m_board,COLOR_EMPTY,sizeof(m_board));
	m_dwScore = 0;
}

// ---------------------------------------------------------------------------
// AddRow()
// Adds a row to the bottom of the board. Pushes existing rows up. Returns
// TRUE if there was room, and FALSE if the board was full (end of game).
// ---------------------------------------------------------------------------
BOOL  CGameBoard::AddRow()
{
	int x;
	int y;

	for(x=0;x<BOARD_WIDTH;x++)
	{
		if(m_board[x][0])
		{
			return FALSE;
		}
	}

	for(x=0;x<BOARD_WIDTH;x++)
	{
		for(y=0;y<BOARD_HEIGHT;y++)
		{
			if( y < BOARD_HEIGHT - 1 )
			{
				m_board[x][y]=m_board[x][y+1];
			}
			else
			{
				m_board[x][y]=(unsigned char)
				((rand() * (COLOR_COUNT - 2)) / RAND_MAX) + 1;
			}
		}
	}

	MoveCursor(0,-1,MOVE_RELATIVE);

	return TRUE;
}

// ---------------------------------------------------------------------------
// CheckBoard()
// Scans each row and column to see if any squares can be cleared. If any 
// squares are cleared, the score is updated and the function returns TRUE.
// Otherwise, it returns FALSE. Returns after the first clear. Keep calling
// until the function returns FALSE to clear the whole board. I set it up 
// this way so that I could animate each cleared set. For now, they just 
// flash white, then vanish.
// ---------------------------------------------------------------------------
BOOL  CGameBoard::CheckBoard()
{
	int x;
	int y;

	// Delete cleared squares
	for(y=0;y<BOARD_HEIGHT;y++)
	{
		for(x=0;x<BOARD_WIDTH;x++)
		{
			if(m_board[x][y] == COLOR_CLEARED_SQUARE)
			{
				m_board[x][y] = COLOR_EMPTY;
			}
		}
	}

	// Enforce gravity
	for(x=0;x<BOARD_WIDTH;x++)
	{
		int i=BOARD_HEIGHT-1;
		for(y=i;y>=0;y--)
		{
			if(m_board[x][y] != COLOR_EMPTY)
			{
				if(i!=y)
				{
					m_board[x][i]=m_board[x][y];
				}
				i--;
			}
		}

		for(;i>=0;i--)
		{
			m_board[x][i]=COLOR_EMPTY;
		}
	}

	// Scan rows
	for(y=0;y<BOARD_HEIGHT;y++)
	{
		int nMatchCount = 0;
		int last_color  = COLOR_EMPTY;
		for(x=0;x<BOARD_WIDTH;x++)
		{
			int this_color = m_board[x][y];
			if(this_color)
			{
				if(this_color == last_color)
				{
					nMatchCount++;
					if(nMatchCount == 2)
					{
						m_board[x  ][y]=COLOR_CLEARED_SQUARE;
						m_board[x-1][y]=COLOR_CLEARED_SQUARE;
						m_board[x-2][y]=COLOR_CLEARED_SQUARE;
					}
					else if(nMatchCount > 2)
					{
						m_board[x][y]=COLOR_CLEARED_SQUARE;
					}
				}
				else
				{
					if(nMatchCount >= 2)
					{
						m_dwScore += nMatchCount * SCORE_PER_SQUARE;
						m_dwScore += (nMatchCount == 4)?SCORE_BONUS_QUAD :0;
						m_dwScore += (nMatchCount >= 5)?SCORE_BONUS_PENTA:0;
						return TRUE;
					}
					nMatchCount = 0;
					last_color  = COLOR_EMPTY;
				}
			}
			else
			{
				if(nMatchCount >= 2)
				{
					m_dwScore += nMatchCount * SCORE_PER_SQUARE;
					m_dwScore += (nMatchCount == 4)?SCORE_BONUS_QUAD :0;
					m_dwScore += (nMatchCount >= 5)?SCORE_BONUS_PENTA:0;
					return TRUE;
				}
				nMatchCount = 0;
				last_color  = COLOR_EMPTY;
			}
			last_color = this_color;
		}

		if(nMatchCount >= 2)
		{
			m_dwScore += nMatchCount * SCORE_PER_SQUARE;
			m_dwScore += (nMatchCount == 4)?SCORE_BONUS_QUAD :0;
			m_dwScore += (nMatchCount >= 5)?SCORE_BONUS_PENTA:0;
			return TRUE;
		}
	}
	
	// Scan columns
	for(x=0;x<BOARD_WIDTH;x++)
	{
		int nMatchCount = 0;
		int last_color  = COLOR_EMPTY;
		for(y=0;y<BOARD_HEIGHT;y++)
		{
			int this_color = m_board[x][y];
			if(this_color)
			{
				if(this_color == last_color)
				{
					nMatchCount++;
					if(nMatchCount == 2)
					{
						m_board[x][y  ]=COLOR_CLEARED_SQUARE;
						m_board[x][y-1]=COLOR_CLEARED_SQUARE;
						m_board[x][y-2]=COLOR_CLEARED_SQUARE;
					}
					else if(nMatchCount > 2)
					{
						m_board[x][y]=COLOR_CLEARED_SQUARE;
					}
				}
				else
				{
					if(nMatchCount >= 2)
					{
						m_dwScore += nMatchCount * SCORE_PER_SQUARE;
						m_dwScore += (nMatchCount == 4)?SCORE_BONUS_QUAD :0;
						m_dwScore += (nMatchCount >= 5)?SCORE_BONUS_PENTA:0;
						return TRUE;
					}
					nMatchCount = 0;
					last_color  = COLOR_EMPTY;
				}
			}
			else
			{
				if(nMatchCount >= 2)
				{
					m_dwScore += nMatchCount * SCORE_PER_SQUARE;
					m_dwScore += (nMatchCount == 4)?SCORE_BONUS_QUAD :0;
					m_dwScore += (nMatchCount >= 5)?SCORE_BONUS_PENTA:0;
					return TRUE;
				}
				nMatchCount = 0;
				last_color  = COLOR_EMPTY;
			}
			last_color = this_color;
		}

		if(nMatchCount >= 2)
		{
			m_dwScore += nMatchCount * SCORE_PER_SQUARE;
			m_dwScore += (nMatchCount == 4)?SCORE_BONUS_QUAD :0;
			m_dwScore += (nMatchCount >= 5)?SCORE_BONUS_PENTA:0;
			return TRUE;
		}
	}

	return FALSE;
}

// ---------------------------------------------------------------------------
// MoveCursor()
// Move the game cursor.
// ---------------------------------------------------------------------------
void  CGameBoard::MoveCursor(int dx, int dy, int mode)
{
	switch(mode)
	{
	case MOVE_RELATIVE:
		m_dwCursorX += dx;
		m_dwCursorY += dy;
		break;
	case MOVE_ABSOLUTE:
		m_dwCursorX = dx;
		m_dwCursorY = dy;
		break;
	case MOVE_CENTER:
	default:
		m_dwCursorX = BOARD_WIDTH  / 2 - 1;
		m_dwCursorY = BOARD_HEIGHT / 2 - 1;
		break;
	}
	
	if( m_dwCursorX < 0 )
	{
		m_dwCursorX = 0;
	}
	
	if( m_dwCursorX > BOARD_WIDTH - 2 )
	{
		m_dwCursorX = BOARD_WIDTH - 2;
	}

	if( m_dwCursorY < 0 )
	{
		m_dwCursorY = 0;
	}
	
	if( m_dwCursorY > BOARD_HEIGHT - 1 )
	{
		m_dwCursorY = BOARD_HEIGHT - 1;
	}
}

// ---------------------------------------------------------------------------
// SwapSelected()
// Swaps the two pieces that are under the cursor.
// ---------------------------------------------------------------------------
void  CGameBoard::SwapSelected()
{
	unsigned char temp = m_board[m_dwCursorX][m_dwCursorY];
	m_board[m_dwCursorX][m_dwCursorY] = m_board[m_dwCursorX + 1][m_dwCursorY];
	m_board[m_dwCursorX + 1][m_dwCursorY] = temp;
}

// ---------------------------------------------------------------------------
// GetScore()
// Returns the current score.
// ---------------------------------------------------------------------------
DWORD CGameBoard::GetScore()
{

	return m_dwScore;
}



// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------



// ---------------------------------------------------------------------------
// Init()
// Initialize application data.
// ---------------------------------------------------------------------------
void Init()
{
	g_dwCurrentTick = GetTickCount();
	g_dwTickLastMove1 = g_dwCurrentTick;
	g_dwTickLastMove2 = g_dwCurrentTick;
	srand(g_dwCurrentTick);

	g_dwCountDown = 0;

	g_bPlayer1Active = FALSE;
	g_bPlayer2Active = FALSE;

	g_bStartPressedLastFrame1 = FALSE;
	memset(g_cButtonsPressedLastFrame1,0,sizeof(g_cButtonsPressedLastFrame1));

	g_bStartPressedLastFrame2 = FALSE;
	memset(g_cButtonsPressedLastFrame2,0,sizeof(g_cButtonsPressedLastFrame2));

	g_pDraw = new CDraw(SCREEN_WIDTH, SCREEN_HEIGHT);
	g_pDraw->FillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, 0xFF000000);
	
	g_pPlayer1 = new CGameBoard();
	g_pPlayer2 = new CGameBoard();
	
	g_dwGameState = STATE_DEMO;
	
	g_hGamepad1 = XInputOpen(XDEVICE_TYPE_GAMEPAD,0,XDEVICE_NO_SLOT,NULL);
	g_hGamepad2 = XInputOpen(XDEVICE_TYPE_GAMEPAD,1,XDEVICE_NO_SLOT,NULL);
}

// ---------------------------------------------------------------------------
// ShutDown()
// Clean up before exit.
// ---------------------------------------------------------------------------
void ShutDown() // Will this ever happen?  8-)
{
	XInputClose(g_hGamepad1);
	XInputClose(g_hGamepad2);
}

// ---------------------------------------------------------------------------
// NewGame()
// Initialize game data.
// ---------------------------------------------------------------------------
void NewGame()
{
	g_pPlayer1->ClearBoard();
	g_pPlayer2->ClearBoard();
	for(int i=0;i<INIT_ROW_COUNT;i++)
	{
		g_pPlayer1->AddRow();
		g_pPlayer2->AddRow();
	}

	m_dwTickLastAddRow1 = GetTickCount();
	m_dwTickLastAddRow2 = GetTickCount();

	while(g_pPlayer1->CheckBoard());
	g_pPlayer1->MoveCursor(0,0,MOVE_CENTER);

	while(g_pPlayer2->CheckBoard());
	g_pPlayer2->MoveCursor(0,0,MOVE_CENTER);
}

// ---------------------------------------------------------------------------
// DemoMode()
// Render stuff to keep the player happy between games.
// ---------------------------------------------------------------------------
void DemoMode()
{
	g_pPlayer1->RenderBoard(g_pDraw,PLAYER1_BOARD_X,PLAYER1_BOARD_Y,TRUE);
	g_pPlayer2->RenderBoard(g_pDraw,PLAYER2_BOARD_X,PLAYER2_BOARD_Y,TRUE);

	g_dwCountDownLastTick = GetTickCount();
	g_dwCountDown = 10;

	if(g_hGamepad1)
	{
		WORD wButtons = g_Gamepad1State.Gamepad.wButtons;

		if((wButtons & XINPUT_GAMEPAD_START) && !g_bStartPressedLastFrame1)
		{
			g_dwGameState = STATE_PRE_PLAY;
			g_bStartPressedLastFrame1 = TRUE;
			g_bPlayer1Active = TRUE;
			g_bPlayer2Active = FALSE;
			NewGame();
			return;
		}
	}

	if(g_hGamepad2)
	{
		WORD wButtons = g_Gamepad2State.Gamepad.wButtons;

		if((wButtons & XINPUT_GAMEPAD_START) && !g_bStartPressedLastFrame2)
		{
			g_dwGameState = STATE_PRE_PLAY;
			g_bStartPressedLastFrame2 = TRUE;
			g_bPlayer1Active = FALSE;
			g_bPlayer2Active = TRUE;
			NewGame();
			return;
		}
	}
}

// ---------------------------------------------------------------------------
// PauseMode()
// Paused game.
// ---------------------------------------------------------------------------
void PauseMode()
{
	g_pPlayer1->RenderBoard(g_pDraw,PLAYER1_BOARD_X,PLAYER1_BOARD_Y,TRUE);
	g_pPlayer2->RenderBoard(g_pDraw,PLAYER2_BOARD_X,PLAYER2_BOARD_Y,TRUE);

	if(g_hGamepad1)
	{
		WORD wButtons = g_Gamepad1State.Gamepad.wButtons;

		if((wButtons & XINPUT_GAMEPAD_START) && !g_bStartPressedLastFrame1)
		{
			g_dwGameState = STATE_PLAY;
			g_bStartPressedLastFrame1 = TRUE;
			return;
		}
	}

	if(g_hGamepad2)
	{
		WORD wButtons = g_Gamepad2State.Gamepad.wButtons;

		if((wButtons & XINPUT_GAMEPAD_START) && !g_bStartPressedLastFrame2)
		{
			g_dwGameState = STATE_PLAY;
			g_bStartPressedLastFrame2 = TRUE;
			return;
		}
	}
}

// ---------------------------------------------------------------------------
// PrePlayMode()
// Will other player join?
// ---------------------------------------------------------------------------
void PrePlayMode()
{
	g_pPlayer1->RenderBoard(g_pDraw,PLAYER1_BOARD_X,PLAYER1_BOARD_Y,TRUE);
	g_pPlayer2->RenderBoard(g_pDraw,PLAYER2_BOARD_X,PLAYER2_BOARD_Y,TRUE);

	if(GetTickCount() - g_dwCountDownLastTick >= COUNTDOWN_DELAY)
	{
		g_dwCountDownLastTick = GetTickCount();

		if(--g_dwCountDown <= 0)
		{
			g_dwGameState = STATE_PLAY;
			return;
		}
	}

	WCHAR buf[80];
	wsprintf(buf,L"Waiting...(%d)",g_dwCountDown);
	
	if(g_bPlayer1Active)
	{
		g_pDraw->DrawText(L"Ready!",PLAYER1_BOARD_X,PLAYER1_BOARD_Y-20,0xff00ff00,0xff000000,0);
	}
	else
	{
		g_pDraw->DrawText(buf,PLAYER1_BOARD_X,PLAYER1_BOARD_Y-20,0xff00ff00,0xff000000,0);

		if(g_hGamepad1)
		{
			WORD wButtons = g_Gamepad1State.Gamepad.wButtons;

			if((wButtons & XINPUT_GAMEPAD_START) && !g_bStartPressedLastFrame1)
			{
				g_dwGameState = STATE_PLAY;
				g_bStartPressedLastFrame1 = TRUE;
				g_bPlayer1Active = TRUE;
				return;
			}
		}
	}


	if(g_bPlayer2Active)
	{
		g_pDraw->DrawText(L"Ready!",PLAYER2_BOARD_X,PLAYER2_BOARD_Y-20,0xff00ff00,0xff000000,0);
	}
	else
	{
		g_pDraw->DrawText(buf,PLAYER2_BOARD_X,PLAYER2_BOARD_Y-20,0xff00ff00,0xff000000,0);
		if(g_hGamepad2)
		{
			WORD wButtons = g_Gamepad2State.Gamepad.wButtons;

			if((wButtons & XINPUT_GAMEPAD_START) && !g_bStartPressedLastFrame2)
			{
				g_dwGameState = STATE_PLAY;
				g_bStartPressedLastFrame2 = TRUE;
				g_bPlayer2Active = TRUE;
				return;
			}
		}
	}

	if(g_bPlayer1Active && g_bPlayer2Active)
	{
		g_dwGameState = STATE_PLAY;
	}
}

// ---------------------------------------------------------------------------
// PlayMode()
// The game!
// ---------------------------------------------------------------------------
void PlayMode()
{
	while(g_pPlayer1->CheckBoard() || g_pPlayer2->CheckBoard())
	{
		g_pPlayer1->RenderBoard(g_pDraw,PLAYER1_BOARD_X,PLAYER1_BOARD_Y,g_bPlayer1Active?FALSE:TRUE);
		g_pPlayer2->RenderBoard(g_pDraw,PLAYER2_BOARD_X,PLAYER2_BOARD_Y,g_bPlayer2Active?FALSE:TRUE);
		g_pDraw->Present();
		DWORD current_tick = GetTickCount();
		while(GetTickCount() - current_tick < CLEAR_DELAY);
	}

	if(g_bPlayer1Active && (GetTickCount() - m_dwTickLastAddRow1 > ADDROW_DELAY))
	{
		if(!g_pPlayer1->AddRow())
		{
			g_dwGameState = STATE_POST_PLAY;
		}
		m_dwTickLastAddRow1 = GetTickCount();
	}

	if(g_bPlayer2Active && (GetTickCount() - m_dwTickLastAddRow2 > ADDROW_DELAY))
	{
		if(!g_pPlayer2->AddRow())
		{
			g_dwGameState = STATE_POST_PLAY;
		}
		m_dwTickLastAddRow2 = GetTickCount();
	}

	if(g_hGamepad1 && g_bPlayer1Active)
	{
		WORD wButtons = g_Gamepad1State.Gamepad.wButtons;

		if((g_Gamepad1State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_A]) && !g_cButtonsPressedLastFrame1[XINPUT_GAMEPAD_A])
		{
			g_pPlayer1->SwapSelected();
		}

		if((wButtons & XINPUT_GAMEPAD_START) && !g_bStartPressedLastFrame1)
		{
			g_dwGameState = STATE_PAUSE;
			g_bStartPressedLastFrame1 = TRUE;
			return;
		}

		if(g_dwCurrentTick - g_dwTickLastMove1 > MOVE_DELAY)
		{
			g_pPlayer1->MoveCursor(
				(wButtons & XINPUT_GAMEPAD_DPAD_LEFT)?-1:
					((wButtons & XINPUT_GAMEPAD_DPAD_RIGHT)?1:0),
				(wButtons & XINPUT_GAMEPAD_DPAD_UP)?-1:
					((wButtons & XINPUT_GAMEPAD_DPAD_DOWN)?1:0),
				MOVE_RELATIVE);
			g_dwTickLastMove1 = g_dwCurrentTick;
		}
	}

	if(g_hGamepad2 && g_bPlayer2Active)
	{
		WORD wButtons = g_Gamepad2State.Gamepad.wButtons;

		if((g_Gamepad2State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_A]) && !g_cButtonsPressedLastFrame2[XINPUT_GAMEPAD_A])
		{
			g_pPlayer2->SwapSelected();
		}

		if((wButtons & XINPUT_GAMEPAD_START) && !g_bStartPressedLastFrame2)
		{
			g_dwGameState = STATE_PAUSE;
			g_bStartPressedLastFrame2 = TRUE;
			return;
		}

		if(g_dwCurrentTick - g_dwTickLastMove2 > MOVE_DELAY)
		{
			g_pPlayer2->MoveCursor(
				(wButtons & XINPUT_GAMEPAD_DPAD_LEFT)?-1:
					((wButtons & XINPUT_GAMEPAD_DPAD_RIGHT)?1:0),
				(wButtons & XINPUT_GAMEPAD_DPAD_UP)?-1:
					((wButtons & XINPUT_GAMEPAD_DPAD_DOWN)?1:0),
				MOVE_RELATIVE);
			g_dwTickLastMove2 = g_dwCurrentTick;
		}
	}

	g_pPlayer1->RenderBoard(g_pDraw,PLAYER1_BOARD_X,PLAYER1_BOARD_Y,g_bPlayer1Active?FALSE:TRUE);
	g_pPlayer2->RenderBoard(g_pDraw,PLAYER2_BOARD_X,PLAYER2_BOARD_Y,g_bPlayer2Active?FALSE:TRUE);
}

// ---------------------------------------------------------------------------
// FrameUpdate()
// Called on every frame.
// ---------------------------------------------------------------------------
BOOL FrameUpdate()
{
	g_dwCurrentTick = GetTickCount();

	XInputGetState( g_hGamepad1,&g_Gamepad1State );
	XInputGetState( g_hGamepad2,&g_Gamepad2State );
	
	g_pDraw->FillRect(0,0,SCREEN_WIDTH,SCREEN_HEIGHT,0xff000000);

	switch(g_dwGameState)
	{
	case STATE_DEMO:
		DemoMode();
		g_pDraw->DrawText(L"DemoMode",0,0,0xffff0000,0xff000000,0);
		break;
	case STATE_PRE_PLAY:
		PrePlayMode();
		g_pDraw->DrawText(L"PrePlay",0,0,0xffff0000,0xff000000,0);
		break;
	case STATE_PLAY:
		PlayMode();
		g_pDraw->DrawText(L"PlayMode",0,0,0xffff0000,0xff000000,0);
		break;
	case STATE_PAUSE:
		PauseMode();
		g_pDraw->DrawText(L"PauseMode",0,0,0xffff0000,0xff000000,0);
		break;
	case STATE_POST_PLAY:
		g_pDraw->DrawText(L"PostPlay",0,0,0xffff0000,0xff000000,0);
		g_dwGameState = STATE_DEMO;
		break;
	case STATE_INIT:
		// do nothing
		break;
	case STATE_QUIT:
	default:
		// ERROR! Should never happen.
		return FALSE;
	}


	WCHAR buf[30];
	
	wsprintf(buf,L"Score: %d",g_pPlayer1->GetScore());
	if(g_bPlayer1Active && g_dwGameState != STATE_PRE_PLAY)
	{
		g_pDraw->DrawText(buf,PLAYER1_BOARD_X,PLAYER1_BOARD_Y-20,0xff00ff00,0xff000000,0);
	}

	wsprintf(buf,L"Score: %d",g_pPlayer2->GetScore());
	if(g_bPlayer2Active && g_dwGameState != STATE_PRE_PLAY)
	{
		g_pDraw->DrawText(buf,PLAYER2_BOARD_X,PLAYER2_BOARD_Y-20,0xff00ff00,0xff000000,0);
	}
	
	g_pDraw->Present();

	// gamepad state housekeeping
	g_bStartPressedLastFrame1 = g_Gamepad1State.Gamepad.wButtons & XINPUT_GAMEPAD_START;
	memcpy(g_cButtonsPressedLastFrame1,g_Gamepad1State.Gamepad.bAnalogButtons,8);

	g_bStartPressedLastFrame2 = g_Gamepad2State.Gamepad.wButtons & XINPUT_GAMEPAD_START;
	memcpy(g_cButtonsPressedLastFrame2,g_Gamepad2State.Gamepad.bAnalogButtons,8);

	if(!(g_Gamepad1State.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_ALL))
	{
		g_dwTickLastMove1 = 0; // delay is only for "auto repeat"
	}

	if(!(g_Gamepad2State.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_ALL))
	{
		g_dwTickLastMove2 = 0; // delay is only for "auto repeat"
	}


	return TRUE;
}

// ---------------------------------------------------------------------------
// wWinMain()
// App's point of entry.
// ---------------------------------------------------------------------------
extern "C" int WINAPI wWinMain(HINSTANCE hi, HINSTANCE hprev, LPSTR lpcmd, int nShow)
{
	Init();

	while (FrameUpdate());

	ShutDown();	// Will this ever happen?  8-)
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbcap\capdump.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    capdump.cpp

Abstract:

    Dump binary profile data to human-readable text format

--*/

#include "xbcap.h"
#include <stddef.h>
#include <dbghelp.h>

typedef ULONG NTSTATUS;

#ifndef PAGE_SIZE
#define PAGE_SIZE 0x1000
#endif

#ifndef _XBOX_ENABLE_PROFILING
#define _XBOX_ENABLE_PROFILING
#endif

#include "xprofp.h"

BOOL verbose = FALSE;
BOOL dumpdpc = FALSE;
BOOL rawdump = FALSE;
BOOL noidle = FALSE;
HANDLE process = NULL;
CHAR* symbolpath = NULL;
UINT symcnt;
struct SymbolFile {
    DWORD loadaddr;
    DWORD size;
    DWORD baseaddr;
    CHAR name[XPROF_MAX_MODULE_NAMELEN];
    CHAR symname[MAX_PATH+16];
} symfiles[XPROF_MAX_MODULES];

//
// Spew error debug message if verbose mode is enabled
//
#define VERBOSE !verbose ? (void)0 : errmsg


//
// A simple hash table for maintaining recently used symbol information
//
struct SymEntry {
    SymEntry* next;
    UINT module;
    DWORD address;
    CHAR name[1];
};

class SymbolTable {
public:
    SymbolTable() {
        for (UINT i=0; i < SYMTABLE_SIZE; i++) {
            entries[i] = NULL;
        }
    }

    ~SymbolTable() {
        for (UINT i=0; i < SYMTABLE_SIZE; i++) {
            SymEntry* symentry = entries[i];
            while (symentry) {
                VOID* p = symentry;
                symentry = symentry->next;
                free(p);
            }
        }
    }

    SymEntry* Lookup(DWORD address) {
        //
        // Simple function to map from an address to a hash bucket
        //
        DWORD hash = address % SYMTABLE_SIZE;
        SymEntry* symentry = entries[hash];

        //
        // If the address is already in the symbol table,
        // return the symbol entry now.
        //
        while (symentry) {
            if (symentry->address == address)
                return symentry;
            symentry = symentry->next;
        }

        //
        // Lookup the address in the symbol files
        // and map it to a symbol name
        //
        struct {
            IMAGEHLP_SYMBOL s;
            CHAR extrabuf[MAX_PATH+16];
        } syminfo;

        syminfo.s.SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
        syminfo.s.MaxNameLength = MAX_PATH;

        DWORD disp = 0;
        BOOL ok = SymGetSymFromAddr(
                    process,
                    address,
                    &disp,
                    &syminfo.s);

        CHAR* name = syminfo.s.Name;

        if (ok) {
            // Address is successfully mapped to a symbol
            //  add displacement if needed
            if (disp) {
                sprintf(name + strlen(name), "+%x", disp);
            }
        } else {
            // Address cannot be mapped to a symbol
            // Just dump the hexdecimal string
            sprintf(name, "%x", address);
        }

        //
        // Add the new address-to-symbol mapping to symbol table
        //
        UINT n = strlen(name) + 1;
        symentry = (SymEntry*) malloc(offsetof(SymEntry, name) + n);
        checkerr(symentry == NULL, "Out of memory\n");

        symentry->next = entries[hash];
        entries[hash] = symentry;

        symentry->address = address;
        memcpy(symentry->name, name, n);

        //
        // Figure out which module the symbol belongs to
        //
        symentry->module = 0;
        for (n=0; n < symcnt; n++) {
            if (address >= symfiles[n].baseaddr &&
                address < symfiles[n].baseaddr + symfiles[n].size) {
                symentry->module = n;
                break;
            }
        }
        if (n == symcnt) {
            VERBOSE("Address not in range of any module: %x\n", address);
        }

        return symentry;
    }

private:
    // Maximum symbol table size (should be a prime number)
    enum { SYMTABLE_SIZE = 4091 };

    SymEntry* entries[SYMTABLE_SIZE];
};

SymbolTable* symtable;
inline CHAR* lookupsymname(DWORD addr) {
    SymEntry* symentry = symtable->Lookup(addr);
    return symentry->name;
}


//
// Map SYM_TYPE to a readable string
//
CHAR* symtypestr(SYM_TYPE symtype) {
    return (symtype == SymPdb) ? "PDB" :
           (symtype == SymCoff) ? "COFF" :
           (symtype == SymCv) ? "CodeView" :
           (symtype == SymExport) ? "Export" :
           (symtype == SymDeferred) ? "Deferred" :
           (symtype == SymSym) ? "SYM" : "NONE";
}

//
// Load / unload symbol files
//
VOID loadsymfiles()
{
    BOOL ok = SymInitialize(process, symbolpath, FALSE);
    checkerr(!ok, "Failed to initialize DBGHELP.DLL\n");

    SymSetOptions(SYMOPT_UNDNAME);

    SymbolFile* symfile = symfiles;
    for (UINT i=0; i < symcnt; i++, symfile++) {
        symfile->baseaddr = SymLoadModule(
                                    process,
                                    NULL,
                                    symfile->name,
                                    NULL,
                                    symfile->loadaddr,
                                    symfile->size);

        if (symfile->baseaddr == 0) {
            errmsg("Can't load symbols for image file %s: %d\n", symfile->name, GetLastError());
            continue;
        }

        if (symfile->loadaddr != symfile->baseaddr) {
            VERBOSE("Odd, loadaddr %x != baseaddr %x?\n", symfile->loadaddr, symfile->baseaddr);
        }

        IMAGEHLP_MODULE modinfo;
        modinfo.SizeOfStruct = sizeof(modinfo);
        if (SymGetModuleInfo(process, symfile->baseaddr, &modinfo)) {
            sprintf(symfile->symname,
                    "%s (%s)",
                    modinfo.LoadedImageName,
                    symtypestr(modinfo.SymType));
        }
    }
}

VOID
unloadsymfiles()
{
    for (UINT i=0; i < symcnt; i++) {
        if (symfiles[i].baseaddr) {
            SymUnloadModule(process, symfiles[i].baseaddr);
        }
    }
    SymCleanup(process);
}


//
// Function call-tree data specific to each thread
//
class ThreadData {
public:
    ThreadData(DWORD tid, ULONGLONG tick, BOOL dpcflag = FALSE);
    ~ThreadData();
    DWORD ThreadId() { return threadid; }

    UINT Dump(FILE* fout);
    UINT RawDump(FILE* fout);
    VOID CallBegin(ULONGLONG tick, DWORD caller, DWORD callee, DWORD calltype);
    VOID CallEnd(ULONGLONG tick, DWORD caller, DWORD calltype);
    VOID Comment(ULONGLONG tick, DWORD param);
    VOID Activate(ULONGLONG tick, INT action, DWORD newtid = 0);
    VOID PostProcessing(ULONGLONG firsttick, ULONGLONG lasttick);

    BOOL IsDpcThread() { return isdpc; }
    UINT CallLevel() { return calllevel; }
    VOID SetPriorThread(ThreadData* priorthread) { this->priorthread = priorthread; }

public:
    ThreadData* next;

private:
    // NOTE: Don't change the size of this structure
    struct DataEntry {
        ULONGLONG starttime;
        ULONGLONG duration;
        BYTE type;
        BYTE flags;
        WORD level;
        union {
            struct {            // for ENTRYTYPE_FUNCCALL
                DWORD caller;
                DWORD callee;
            };
            DWORD param;        // for ENTRYTYPE_COMMENT
            DWORD newtid;       // for ENTRYTYPE_THREADSWITCH
            DWORD filler[3];
        };
    };

    enum {
        ENTRYTYPE_FUNCCALL,
        ENTRYTYPE_COMMENT,
        ENTRYTYPE_THREADSWITCH,

        ENTRYFLAG_NOEND = 0x01,
        ENTRYFLAG_ORPHAN = 0x02,
        ENTRYFLAG_DPC = 0x04,
    };

    enum {
        MAX_CHUNKS = 1024,
        CHUNK_SIZE = 64*1024,
        ENTRY_SIZE = sizeof(DataEntry)
    };

    VOID* chunks[MAX_CHUNKS];
    UINT numchunks, freespace;
    DataEntry* nextentry;

    DataEntry* CreateNewEntry();

    ThreadData* priorthread;
    ULONGLONG starttime;
    ULONGLONG lastactivetime;
    ULONGLONG inactivetime;
    ULONGLONG timeadjust;
    DWORD threadid;
    BOOL isdpc;
    DataEntry* inactiveentry;
    UINT totalcalls;
    UINT percalloverhead;

    struct FunctionCall {
        DWORD caller;
        DWORD callee;
        DataEntry* entry;
        DWORD calltype;
        ULONGLONG timeadjust;
    };

    enum {
        MAX_CALL_LEVELS = 1024,

        // This number is obtained by timing
        // _CAP_Start_Profiling and _CAP_End_Profiling functions.
        PER_CALL_OVERHEAD = 59
    };

    FunctionCall callstack[MAX_CALL_LEVELS];
    UINT calllevel;

    BOOL IsActive() { return (inactiveentry == NULL); }
    BOOL InsideCall() { return (calllevel != 0); }
    FunctionCall* LastCall() { return &callstack[calllevel-1]; }
    VOID AdjustCallOverhead(ULONGLONG tick) {
        if (InsideCall()) {
            LastCall()->timeadjust += tick;
        } else {
            this->timeadjust += tick;
        }
    }

    static VOID DumpThreadName(FILE* fout, DWORD tid) {
        if (tid == 0xffffffff) {
            fprintf(fout, "[DPC]");
        } else if (tid == 0) {
            fprintf(fout, "[IDLE]");
        } else {
            fprintf(fout, "%x", tid);
        }
    }

    static VOID DumpIndent(FILE* fout, UINT level) {
        for (UINT i=0; i < level; i++) {
            fprintf(fout, "%-2d ", i);
        }
    }
};


//
// Initialize per-thread call-tree data
//
ThreadData::ThreadData(
    DWORD tid,
    ULONGLONG tick,
    BOOL dpcflag
    )
{
    next = NULL;
    threadid = tid;
    priorthread = NULL;
    starttime = lastactivetime = tick;
    inactivetime = timeadjust = 0;
    isdpc = dpcflag;
    inactiveentry = NULL;
    totalcalls = 0;
    percalloverhead = rawdump ? 0 : PER_CALL_OVERHEAD;

    freespace = numchunks = 0;
    memset(chunks, 0, sizeof(chunks));

    calllevel = 0;
    memset(callstack, 0, sizeof(callstack));
}


//
// Cleanup per-thread call-tree data
//
ThreadData::~ThreadData()
{
    for (UINT i=0; i < numchunks; i++) {
        VirtualFree(chunks[i], 0, MEM_RELEASE);
    }
}


//
// Allocate space for a new data entry
//
ThreadData::DataEntry*
ThreadData::CreateNewEntry()
{
    if (freespace < ENTRY_SIZE) {
        checkerr(numchunks >= MAX_CHUNKS, "Too much profile data.\n");

        // NOTE: memory returned by VirutalAlloc is already zeroed
        VOID* p = VirtualAlloc(NULL, CHUNK_SIZE, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
        checkerr(p == NULL, "Out of memory\n");

        chunks[numchunks++] = p;
        nextentry = (DataEntry*) p;
        freespace = CHUNK_SIZE;
    }

    freespace -= ENTRY_SIZE;
    return nextentry++;
}


//
// Process a CALL-BEGIN data entry
//
VOID
ThreadData::CallBegin(
    ULONGLONG tick,
    DWORD caller,
    DWORD callee,
    DWORD calltype
    )
{
    checkerr(calllevel >= MAX_CALL_LEVELS, "Too many levels of nested calls.\n");

    DataEntry* entry = CreateNewEntry();

    entry->starttime = tick;
    entry->type = ENTRYTYPE_FUNCCALL;
    entry->flags = ENTRYFLAG_NOEND;
    entry->level = (WORD)calllevel;

    if (caller == 0 && IsDpcThread()) {
        entry->flags |= ENTRYFLAG_DPC;
        caller = callee;
    } else if (InsideCall() && calltype == XPROFREC_FASTCAP_START && caller != LastCall()->callee) {
        entry->flags |= ENTRYFLAG_ORPHAN;
    }

    entry->caller = caller;
    entry->callee = calltype == XPROFREC_FASTCAP_START ? callee : 0;

    FunctionCall* call = &callstack[calllevel];
    call->caller = caller;
    call->callee = callee;
    call->calltype = calltype;
    call->entry = entry;
    call->timeadjust = percalloverhead;

    calllevel++;
}

//
// Process a Call-End data entry
//
VOID
ThreadData::CallEnd(
    ULONGLONG tick,
    DWORD caller,
    DWORD calltype
    )
{
    if (!InsideCall()) {
        VERBOSE("Unmatched Call-End record: %s\n", lookupsymname(caller));
        return;
    }

    FunctionCall* call = LastCall();
    calllevel--;

    DWORD ExpectedCallType = call->calltype;
    DWORD Match;

    switch (call->calltype) {
    case XPROFREC_FASTCAP_START:
        ExpectedCallType = XPROFREC_FASTCAP_END;
        Match = call->caller;
        break;

    case XPROFREC_CALLCAP_START:
        ExpectedCallType = XPROFREC_CALLCAP_END;
        Match = call->caller;
        break;

    case XPROFREC_PENTER:
        ExpectedCallType = XPROFREC_PEXIT;
        Match = call->callee;
        break;

    default:
        ExpectedCallType = 0;
        Match = 0;
    }

    if (ExpectedCallType != calltype || Match != caller) {
        errmsg(
            "Call-End record doesn't match the last Call-Begin:\n"
            "    thread: %x\n"
            "    actual %s\n"
            "    expect %s %s\n",
            threadid,
            lookupsymname(caller),
            lookupsymname(call->caller),
            lookupsymname(call->callee));
        return;
    }

    DataEntry* entry = call->entry;
    entry->duration = tick - entry->starttime - call->timeadjust;
    entry->flags &= ~ENTRYFLAG_NOEND;

    AdjustCallOverhead(call->timeadjust + percalloverhead);
}


//
// Process a Comment data entry
//
VOID
ThreadData::Comment(
    ULONGLONG tick,
    DWORD param
    )
{
    DataEntry* entry = CreateNewEntry();

    entry->starttime = tick;
    entry->type = ENTRYTYPE_COMMENT;
    entry->level = (WORD) calllevel;
    entry->param = param;
}


//
// Activate or deactivate the thread
//
#define THREAD_ACTIVE   1
#define THREAD_INACTIVE 0
#define THREAD_STOP     (-1)

VOID
ThreadData::Activate(
    ULONGLONG tick,
    INT action,
    DWORD newtid
    )
{
    if (action == THREAD_ACTIVE) {
        if (IsActive()) {
            VERBOSE("Thread is already active: %x!\n", threadid);
        } else {
            lastactivetime = tick;
            tick -= inactivetime;
            inactiveentry->duration = tick;
            inactiveentry = NULL;
            AdjustCallOverhead(tick);
        }
    } else {
        if (IsActive()) {
            inactivetime = tick;

            if (action == THREAD_INACTIVE) {
                DataEntry* entry = CreateNewEntry();
                entry->starttime = tick;
                entry->level = 0;
                entry->newtid = newtid;
                entry->type = ENTRYTYPE_THREADSWITCH;
                inactiveentry = entry;

                if (noidle && threadid == 0 && priorthread) {
                    // NOTE: We're attributing the time spent in idle thread
                    // to the last thread that was running.
                    priorthread->AdjustCallOverhead(lastactivetime-inactivetime);
                }
            }
        } else {
            VERBOSE("Thread is already inactive: %x!\n", threadid);
        }
    }
}


//
// Perform per-thread post-processing after
// we finish parsing the profile data file.
//
VOID
ThreadData::PostProcessing(
    ULONGLONG firsttick,
    ULONGLONG lasttick
    )
{
    // If this thread is still active, deactivate it
    if (IsActive()) {
        Activate(lasttick, THREAD_STOP, 0);
    }

    if (calllevel) {
        VERBOSE("CALL-BEGIN record without matching CALL-END: %x\n", threadid);
        while (calllevel) {
            FunctionCall* call = &callstack[--calllevel];
            VERBOSE("  %s => %s\n",
                lookupsymname(call->caller),
                lookupsymname(call->callee));

            // For incomplete call, forget about overhead adjustment
            call->timeadjust -= percalloverhead;

            DataEntry* entry = call->entry;
            entry->duration = inactivetime - entry->starttime - call->timeadjust;
            AdjustCallOverhead(call->timeadjust);
        }
    }

    // Count the total number of function calls
    ULONGLONG totalcalltime = 0;
    for (UINT i=0; i < numchunks; i++) {
        DataEntry* entry = (DataEntry*) chunks[i];
        UINT count = CHUNK_SIZE - ((i == numchunks-1) ? freespace : 0);

        for (count /= ENTRY_SIZE; count--; entry++) {
            if (entry->type == ENTRYTYPE_FUNCCALL) {
                if (entry->level == 0) totalcalltime += entry->duration;
                totalcalls++;
            }
            entry->starttime -= firsttick;
        }
    }

    if (IsDpcThread()) {
        timeadjust = inactivetime - starttime - totalcalltime;
    }
}


//
// Dump out per-thread call-tree data in .OPF format
//
UINT
ThreadData::Dump(
    FILE* fout
    )
{
    fprintf(fout, "0\t0\tThread ");
    DumpThreadName(fout, threadid);
    fprintf(fout, "\t0\t%I64u\t \t0\n", inactivetime - starttime - timeadjust);

    for (UINT i=0; i < numchunks; i++) {
        DataEntry* entry = (DataEntry*) chunks[i];
        UINT count = CHUNK_SIZE - ((i == numchunks-1) ? freespace : 0);

        for (count /= ENTRY_SIZE; count--; entry++) {
            if (entry->type != ENTRYTYPE_FUNCCALL) continue;

            SymEntry* symentry = symtable->Lookup(entry->callee ? entry->callee : entry->caller);

            fprintf(fout,
                "%d\t%d\t%s\t%d\t%I64u\t%c%s\n",
                1,
                entry->level+1,
                symentry->name,
                symentry->module,
                entry->duration,
                'F',
                (entry->flags & ENTRYFLAG_NOEND) ? "\tIncomplete call" :
                (entry->flags & ENTRYFLAG_ORPHAN) ? "\tCallback?" : "");
        }
    }

    return totalcalls;
}


//
// Dump out per-thread call tree data in raw text format
//
UINT
ThreadData::RawDump(
    FILE* fout
    )
{
    fprintf(fout, "Thread ");
    DumpThreadName(fout, threadid);
    fprintf(fout, " : time = %I64u\n", inactivetime - starttime - timeadjust);

    fprintf(fout, "%12s %12s   function\n", "start time", "duration");

    for (UINT i=0; i < numchunks; i++) {
        DataEntry* entry = (DataEntry*) chunks[i];
        UINT count = CHUNK_SIZE - ((i == numchunks-1) ? freespace : 0);

        for (count /= ENTRY_SIZE; count--; entry++) {
            if (entry->type == ENTRYTYPE_THREADSWITCH && IsDpcThread())
                continue;

            fprintf(fout, "%12I64u %12I64u ", entry->starttime, entry->duration);
            fprintf(fout, "%c ", (entry->flags & ENTRYFLAG_NOEND) ? '-' :
                     (entry->flags & ENTRYFLAG_ORPHAN) ? '?' : ' ');

            if (entry->type == ENTRYTYPE_FUNCCALL) {
                SymEntry* symentry;
                if (entry->level == 0) {
                    if (isdpc) {
                        fprintf(fout, "[DPC] ");
                    } else if (entry->callee) {
                        symentry = symtable->Lookup(entry->caller);
                        fprintf(fout, "%s => ", symentry->name);
                    }
                } else {
                    DumpIndent(fout, entry->level);
                    if (entry->callee && (entry->flags & ENTRYFLAG_ORPHAN)) {
                        symentry = symtable->Lookup(entry->caller);
                        fprintf(fout, "%s => ", symentry->name);
                    }
                }

                symentry = symtable->Lookup(entry->callee ? entry->callee : entry->caller);
                fprintf(fout, "%s\n", symentry->name);
            } else if (entry->type == ENTRYTYPE_THREADSWITCH) {
                fprintf(fout, "thread-switch ");
                DumpThreadName(fout, entry->newtid);
                fprintf(fout, "\n");
            } else if (entry->type == ENTRYTYPE_COMMENT) {
                DumpIndent(fout, entry->level);
                fprintf(fout, "comment %x\n", entry->param);
            } else {
                fprintf(fout, "*** unknown entry type: %x\n", entry->type);
            }
        }
    }

    fprintf(fout, "\n");
    return totalcalls;
}


//
// Parse profile data file and
// generate per-thread function call tree
//
ULONGLONG capstarttick, capstoptick;

ThreadData*
capparse(
    VOID* fileview,
    DWORD filesize
    )
{
    checkerr(
        filesize < XPROF_FILE_HEADER_SIZE ||
        (filesize & 3) != 0,
        "File size error: too small or not a multiple of 4\n");

    XProfpFileHeader* fileheader = (XProfpFileHeader*) fileview;
    if (fileheader->version != XPROF_FILE_VERSION) {
        errmsg("File version mismatch: %x != %x\n",
            fileheader->version,
            XPROF_FILE_VERSION);
    }

    symcnt = fileheader->module_count;
    for (UINT i=0; i < symcnt; i++) {
        symfiles[i].loadaddr = fileheader->modules[i].loadaddr;
        symfiles[i].size = fileheader->modules[i].size;
        strcpy(symfiles[i].name, fileheader->modules[i].name);
    }

    loadsymfiles();

    fileview = fileheader+1;
    filesize -= XPROF_FILE_HEADER_SIZE;

    UINT count = filesize >> 2;
    ULONG* buf = (ULONG*) fileview;
    ThreadData* threads = NULL;
    ThreadData* curthread = NULL;
    ThreadData* dpcthread = NULL;
    ULONGLONG firsttick, lasttick;

    firsttick = lasttick = 0;
    while (count) {
        if (count < 2) goto badrec;

        ULONGLONG tick;
        ULARGE_INTEGER* uli = (ULARGE_INTEGER*) &tick;
        uli->HighPart = buf[0] & ~XPROFREC_TYPEMASK;
        uli->LowPart = buf[1];
        lasttick = tick;

        DWORD rectype = buf[0] & XPROFREC_TYPEMASK;
        DWORD recsize;

        checkerr(
            (rectype != XPROFREC_CONTROL || buf[2] != XPROF_START) &&
            (curthread == NULL),
            "The first record must be a START record.\n");

        switch (rectype) {
        case XPROFREC_FASTCAP_START:
        case XPROFREC_PENTER:
            //
            // Call-Begin record:
            //  params[0] = caller
            //  params[1] = callee
            //
            recsize = 4;
            if (count < recsize) goto badrec;
            checkerr(buf[2] == 0 || buf[3] == 0, "Invalid function address 0.\n");
            curthread->CallBegin(tick, buf[2], buf[3], rectype);
            break;

        case XPROFREC_CALLCAP_START:
            //
            // Call-Begin record:
            //  params[0] = caller
            //
            recsize = 3;
            if (count < recsize) goto badrec;
            checkerr(buf[2] == 0, "Invalid function address 0.\n");
            curthread->CallBegin(tick, buf[2], 0, rectype);
            break;

        case XPROFREC_FASTCAP_END:
        case XPROFREC_CALLCAP_END:
            //
            // Call-End record:
            //  params[0] = caller
            //
            recsize = 3;
            if (count < recsize) goto badrec;
            curthread->CallEnd(tick, buf[2], rectype);
            break;

        case XPROFREC_PEXIT:
            //
            // Call-End record:
            //  params[0] = caller
            //  params[1] = ESP
            //
            recsize = 4;
            if (count < recsize) goto badrec;
            curthread->CallEnd(tick, buf[3], rectype);
            break;

        case XPROFREC_CONTROL:
            //
            // Control record:
            //  params[0] = type
            //  params[1] = type-specific parameter
            //
            recsize = 4;
            if (count < recsize) goto badrec;

            switch (buf[2]) {
            case XPROF_START:
                //
                // Must be the first record of the profile data file
                //  params[1] = calling thread id
                //
                if (curthread) {
                    VERBOSE("Second START record treated as STOP.\n");
                    recsize = count;
                } else {
                    firsttick = tick;
                    curthread = threads = new ThreadData(buf[3], tick);
                    checkerr(curthread == NULL, "Out of memory\n");
                }
                break;

            case XPROF_STOP:
                //
                //  params[1] = calling thread id
                //
                if (count > recsize) {
                    VERBOSE("Ignore data after STOP record.\n");
                }
                recsize = count;
                break;

            case XPROF_COMMENT:
                //
                //  params[1] = user-defined parameter
                //
                curthread->Comment(tick, buf[3]);
                break;

            case XPROF_THREAD_SWITCH:
                //
                //  params[1] = new thread id
                //
                checkerr(curthread->IsDpcThread(),
                    "Thread switch in the middle of a DPC routine!\n");

                {
                    DWORD newtid = buf[3];

                    // Deactivate the current thread
                    if (newtid == curthread->ThreadId()) {
                        errmsg("Switching to the same thread: %x?!\n", newtid);
                    }
                    curthread->Activate(tick, THREAD_INACTIVE, newtid);

                    // Check if the new thread is already present
                    ThreadData* oldthread = curthread;
                    curthread = threads;
                    while (curthread && curthread->ThreadId() != newtid) {
                        curthread = curthread->next;
                    }

                    if (curthread) {
                        // Activate the new thread if already present
                        curthread->Activate(tick, THREAD_ACTIVE);
                    } else {
                        // Otherwise, create the new thread
                        curthread = new ThreadData(newtid, tick);
                        checkerr(curthread == NULL, "Out of memory\n");

                        curthread->next = threads;
                        threads = curthread;
                    }
                    curthread->SetPriorThread(oldthread);
                }
                break;

            case XPROF_DPC_BEGIN:
                //
                //  params[1] = DPC routine address
                //
                checkerr(curthread->IsDpcThread(), "Nested DPC call not expected!\n");
                curthread->Activate(tick, THREAD_INACTIVE, -1);

                if (dpcthread == NULL) {
                    dpcthread = new ThreadData(-1, tick, TRUE);
                    checkerr(dpcthread == NULL, "Out of memory\n");
                } else {
                    dpcthread->Activate(tick, THREAD_ACTIVE);
                }

                dpcthread->next = curthread;
                curthread = dpcthread;
                curthread->CallBegin(tick, 0, buf[3], rectype);
                break;

            case XPROF_DPC_END:
                //
                //  params[1] = DPC routine address
                //
                if (curthread == dpcthread) {
                    checkerr(dpcthread->CallLevel() != 1, "Unbalanced DPC call.\n");
                    dpcthread->CallEnd(tick, buf[3], rectype);

                    dpcthread->Activate(tick, THREAD_INACTIVE);
                    curthread = dpcthread->next;
                    curthread->Activate(tick, THREAD_ACTIVE);
                } else {
                    VERBOSE("Unexpected DPC-END record.\n");
                }
                break;

            default:
                goto badrec;
            }
            break;

        default:
            goto badrec;
        }

        count -= recsize;
        buf += recsize;
    }

    if (dpcthread) {
        if (dumpdpc) {
            dpcthread->next = threads;
            threads = dpcthread;
        } else {
            delete dpcthread;
        }
    }

    // Revert the thread list and perform postprocessing
    curthread = threads;
    threads = NULL;
    while (curthread) {
        ThreadData* p = curthread;
        curthread = p->next;
        p->next = threads;
        threads = p;
        p->PostProcessing(firsttick, lasttick);
    }

    capstarttick = firsttick;
    capstoptick = lasttick;
    return threads;

badrec:
    errmsg("Bad record at offset: %x\n", (BYTE*) buf - (BYTE*) fileview);
    exit(-1);
}


//
// Map a file into memory
//
VOID*
mapfile(
    CHAR* filename,
    DWORD* size
    )
{
    HANDLE file, filemap;
    VOID* fileview = NULL;

    file = CreateFile(
                filename,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_FLAG_SEQUENTIAL_SCAN,
                NULL);

    if (file == INVALID_HANDLE_VALUE)
        return NULL;

    *size = GetFileSize(file, NULL);
    if (*size == 0xFFFFFFFF) {
        CloseHandle(file);
        return NULL;
    }

    filemap = CreateFileMapping(file, NULL, PAGE_READONLY, 0, 0, NULL);
    if (filemap != NULL) {
        fileview = MapViewOfFile(filemap, FILE_MAP_READ, 0, 0, 0);
        CloseHandle(filemap);
    }

    CloseHandle(file);
    return fileview;
}


//
// Dump binary profile data to human-readable text format
//
VOID
capdump(
    CHAR* cap_filename,
    CHAR* dump_filename
    )
{
    process = GetCurrentProcess();

    // Map the profile data file into memory
    VOID* fileview;
    DWORD filesize;
    ThreadData* threads;

    fileview = mapfile(cap_filename, &filesize);
    checkerr(fileview == NULL,
        "Couldn't open profile data file\n",
        cap_filename);

    symtable = new SymbolTable();

    // Parse the profile data file
    __try {
        threads = capparse(fileview, filesize);
        UnmapViewOfFile(fileview);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        checkerr(TRUE, "Error reading profile data\n");
    }

    // Dump the profile data file in text format
    FILE* fout = fopen(dump_filename, "w");
    checkerr(fout == NULL,
        "Can't open dump file %s\n",
        dump_filename);

    if (!rawdump) {
        fprintf(fout, "Calls\tLevel\tFunction\tModule\tTime\tType\tWarnings\n");
    }

    UINT totalcalls = 0;
    UINT threadcnt = 0;
    ThreadData* p;
    for (p = threads; p; p = p->next) {
        if (noidle && p->ThreadId() == 0) continue;
        UINT n = rawdump ? p->RawDump(fout) : p->Dump(fout);
        totalcalls += n;
        threadcnt++;
    }

    fprintf(fout, "\n");
    fprintf(fout, "MODULES:\n");

    SymbolFile* symfile = symfiles;
    for (UINT i=0; i < symcnt; i++, symfile++) {
        fprintf(fout, "#%d %s\n", i, symfile->name);
        fprintf(fout, "Path = %s\n", symfile->name);
        fprintf(fout, "Symbols = %s\n", symfile->symname);
        fprintf(fout, "Base Address = 0x%08x Size = 0x%x\n\n", symfile->baseaddr, symfile->size);
    }

    fprintf(fout, "INSTRUMENTATION:\n");
    fprintf(fout, "F = /fastcap 0 0\n");
    fprintf(fout, "start   : %12I64u\n", capstarttick);
    fprintf(fout, "stop    : %12I64u\n", capstoptick);
    fprintf(fout, "duration: %12I64u\n\n", capstoptick-capstarttick);

    fprintf(fout, "STATISTICS:\n");
    fprintf(fout, "Total Threads = %d\n", threadcnt);
    fprintf(fout, "Maximum Concurrent Threads = %d\n", threadcnt);
    fprintf(fout, "Total Function Nodes = %d\n", totalcalls);
    fprintf(fout, "Total Function Calls = %d\n", totalcalls);

    delete symtable;
    unloadsymfiles();
    fclose(fout);

    // Cleanup

    while (threads) {
        p = threads;
        threads = p->next;
        delete p;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\test\pentam\pentam.h ===
#include "buildnt.h"
#include <xbox.h>
#include <xtl.h>
#include "draw.h"

#ifndef __pentam_h_
#define __pentam_h_

int const SCREEN_WIDTH  = 640;
int const SCREEN_HEIGHT = 480;
int const BOARD_WIDTH   =   6;
int const BOARD_HEIGHT  =  12;
int const SQUARE_SIZE   =  32;

int const PLAYER1_BOARD_X =  64;
int const PLAYER1_BOARD_Y =  50;

int const PLAYER2_BOARD_X = 384;
int const PLAYER2_BOARD_Y =  50;

int const INIT_ROW_COUNT =  5;

int const SCORE_PER_SQUARE  =  5;
int const SCORE_BONUS_QUAD  =  5;
int const SCORE_BONUS_PENTA = 15;

enum
{
	STATE_INIT,
	STATE_DEMO,
	STATE_PRE_PLAY,
	STATE_PLAY,
	STATE_PAUSE,
	STATE_POST_PLAY,
	STATE_QUIT,
	STATE_COUNT
};

enum
{
	MOVE_RELATIVE,
	MOVE_ABSOLUTE,
	MOVE_CENTER
};

enum {
	COLOR_EMPTY,  // bogus value. [square not occupied]
	COLOR_RED,
	COLOR_YELLOW,
	COLOR_CYAN,
	COLOR_GREEN,
	COLOR_MAGENTA,
	COLOR_CLEARED_SQUARE,
	COLOR_COUNT
};

DWORD g_dwSquareColorLT[COLOR_COUNT] = 
{
	0xff000000,  // bogus value. [square not occupied]
	0xffff0000,
	0xffffff00,
	0xff00ffff,
	0xff00ff00,
	0xffff00ff,
	0xffffffff
};

DWORD g_dwSquareColorDK[COLOR_COUNT] = 
{
	0xff000000,  // bogus value. [square not occupied]
	0xff800000,
	0xff808000,
	0xff008080,
	0xff008000,
	0xff800080,
	0xffffffff
};

class CGameBoard 
{
	unsigned char m_board[BOARD_WIDTH][BOARD_HEIGHT];
	long  m_dwCursorX;
	long  m_dwCursorY;
	DWORD m_dwScore;

	public:
		void  RenderBoard(CDraw *draw, int left, int top, BOOL bPaused);
		void  ClearBoard();
		BOOL  AddRow();
		BOOL  CheckBoard();
		void  MoveCursor(int dx, int dy, int mode);
		void  SwapSelected();
		DWORD GetScore();
};

int         g_dwGameState;
CDraw      *g_pDraw;
DWORD       g_dwCurrentTick;
HANDLE      g_hGamepad1;
HANDLE      g_hGamepad2;

CGameBoard *g_pPlayer1;
CGameBoard *g_pPlayer2;

BOOL g_bPlayer1Active;
BOOL g_bPlayer2Active;

XINPUT_STATE g_Gamepad1State;
XINPUT_STATE g_Gamepad2State;

DWORD m_dwTickLastAddRow1;
DWORD m_dwTickLastAddRow2;

DWORD g_dwTickLastMove1;
DWORD g_dwTickLastMove2;

BOOL g_bStartPressedLastFrame1;
BYTE g_cButtonsPressedLastFrame1[8];

BOOL g_bStartPressedLastFrame2;
BYTE g_cButtonsPressedLastFrame2[8];

DWORD g_dwCountDown;
DWORD g_dwCountDownLastTick;

int const XINPUT_GAMEPAD_DPAD_ALL = 
	XINPUT_GAMEPAD_DPAD_LEFT  | 
	XINPUT_GAMEPAD_DPAD_RIGHT | 
	XINPUT_GAMEPAD_DPAD_UP    | 
	XINPUT_GAMEPAD_DPAD_DOWN;

int const MOVE_DELAY      =  200;
int const CLEAR_DELAY     =   50;
int const ADDROW_DELAY    = 5000;
int const COUNTDOWN_DELAY = 1000;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\cdropsource.h ===
class CDropSource : public IDropSource
{
protected:
    long                m_cRef;
public:
    CDropSource();
    
    //IDropSource interface members
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP QueryContinueDrag(BOOL, DWORD);
    STDMETHODIMP GiveFeedback(DWORD);
};

typedef CDropSource* PCDropSource;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbcap\xbcap.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    xbcap.h

Abstract:

    Profile control utility - declarations

--*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

//
// Error functions
//
VOID errmsg(CHAR* format, ...);
VOID checkerr(BOOL err, CHAR* format, ...);

extern BOOL verbose;
extern BOOL dumpdpc, rawdump, noidle;
extern CHAR* symbolpath;

//
// Dump a binary profile data file to human-readable text format
//
VOID capdump(CHAR* cap_filename, CHAR* dump_filename);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\CDropSource.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     CDropSource.cpp
// Contents: UNDONE-WARN: Add file description
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDropSource::CDropSource
// Purpose:   CDropSource constructor. Sole purpose is to preset the ref count to 1.
// Arguments: None.
// Return:    None.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CDropSource::CDropSource() : m_cRef(1)
{
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDropSource::QueryInterface
// Purpose:   Obtain a particular interface to this object.
// Arguments: riid          -- The interface to this object being queried for.
//            ppvObject     -- Buffer to fill with obtained interface.
// Return:    S_OK if interface obtained; E_NOINTERFACE otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CDropSource::QueryInterface(REFIID riid, void **ppvObject)
{ 
    *ppvObject = NULL;

    if (riid == IID_IUnknown) 
        *ppvObject = this;
    else if (riid == IID_IDropSource) 
        *ppvObject = static_cast<IDropSource*>(this);
    else
        return E_NOINTERFACE;

    if (*ppvObject)
    {
        static_cast<LPUNKNOWN>(*ppvObject)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}   

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDropSource::AddRef
// Purpose:   Add a reference to this object
// Arguments: None
// Return:    New reference count
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP_(ULONG) CDropSource::AddRef()
{
    return (ULONG)InterlockedIncrement(&m_cRef);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDropSource::Release
// Purpose:   Subtract a reference to this object.  If the new number of references is zero, then
//            delete the object.
// Arguments: None
// Return:    New reference count.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP_(ULONG) CDropSource::Release()
{
    if (0 == InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return (ULONG)m_cRef;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDropSource::QueryDragContinue
// Purpose:   Determines whether to continue a drag operation or cancel it. 
// Arguments: fEsc          -- 'true' if the esc key was pressed.
//            dwKeyState    -- Provides state of the keys and mouse buttons.
// Return:    DROPDROP_S_CANCEL to stop the drag, DRAGDROP_S_DROP to drop the data where it is,
//            or NOERROR to continue
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CDropSource::QueryContinueDrag(BOOL fEsc, DWORD dwKeyState)
{
    if (fEsc)
        return ResultFromScode(DRAGDROP_S_CANCEL);
    if (!(dwKeyState & MK_LBUTTON))
        return ResultFromScode(DRAGDROP_S_DROP);
    return NOERROR;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDropSource::GiveFeedback
// Purpose:   Provides cursor feedback to the user since the source task always has the mouse
//            capture.  We can also provide any other type of feedback above cursors if we so
//            desire. 
// Arguments: dwEffect      -- Effect flags returned from the last target.
// Return:    DRAGDROP_S_USEDEFAULTCURSORS so that OLE does all the work for us.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CDropSource::GiveFeedback(DWORD dwEffect)
{
    return ResultFromScode(DRAGDROP_S_USEDEFAULTCURSORS);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbcap\xbcap.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    xbcap.cpp

Abstract:

    Start / stop profiling on the xbox

--*/

#include "xbcap.h"
#include <xboxdbg.h>

//
// Name of the profile data file on the xbox
//
#define XBOX_CAP_FILENAME "E:\\xboxcap.dat"

//
// Supported commands
//
enum {
    INVALIDCMD,
    STARTCMD,
    STOPCMD,
    DUMPCMD
};


//
// Global variables
//

CHAR* programName;
INT cmd;

//
// Dump usage information and exit
//
VOID
usage()
{
    fprintf(stderr,
        "usage: %s options ...\n"
        "-x xboxname\n"
        "    Specifies the target xbox name.\n"
        "start\n"
        "    Start profile data collection on the xbox.\n"
        "stop cap-filename\n"
        "    Stop profile data collection on the xbox, and retrieve\n"
        "    the profile data and store it in the specified file.\n"
        "dump cap-filename dump-filename\n"
        "    Dump the profile data to a human-readable text file.\n"
        "-s symbol-path\n"
        "    Specifies the symbol search path.You can specify multiple\n"
        "    directories by separating them with a semicolon. If -s option\n"
        "    is not present, _NT_SYMBOL_PATH environment variable is used.\n"
        "-idle\n"
        "    Do not dump the time spent in the idle thread.\n"
        "    Instead, the time is attributed to the thread that was running\n"
        "    before the system switched to the idle thread.\n"
        "-dpc\n"
        "    Whether to dump DPC calls in the output.\n"
        "-raw\n"
        "    Produce raw text dump instead of .OPF file.\n",
        programName);

    exit(1);
}

//
// Check error and exit
//
VOID
checkerr(
    BOOL err,
    CHAR* format,
    ...
    )
{
    if (!err) return;

    va_list arglist;

    va_start(arglist, format);
    vfprintf(stderr, format, arglist);
    va_end(arglist);

    exit(-1);
}

VOID
errmsg(
    CHAR* format,
    ...
    )
{
    va_list arglist;

    va_start(arglist, format);
    vfprintf(stderr, format, arglist);
    va_end(arglist);
}


//
// Main program entrypoint
//
#define optequ(s1, s2) (_stricmp(s1, s2) == 0)

INT __cdecl
main(
    INT argc,
    CHAR** argv
    )
{
	HRESULT hr;
    INT cmd = INVALIDCMD;
    char* cap_filename = NULL;
    char* dump_filename = NULL;

    programName = *argv++;
    argc--;

	// Process arguments
    while (argc--) {
        char* opt = *argv++;
        int params = 0;

        if (optequ(opt, "-x") && argc >= 1) {
            //
            // -x xboxname
            //
            hr = DmSetXboxName(*argv);
            checkerr(FAILED(hr), "Error setting xbox name: %x\n", hr);
            params += 1;
        } else if (optequ(opt, "start") && !cmd) {
            cmd = STARTCMD;
        } else if (optequ(opt, "stop") && !cmd && argc >= 1) {
            cmd = STOPCMD;
            cap_filename = *argv;
            params += 1;
        } else if (optequ(opt, "dump") && !cmd && argc >= 2) {
            cmd = DUMPCMD;
            cap_filename = argv[0];
            dump_filename = argv[1];
            params += 2;
        } else if (optequ(opt, "-s") && !symbolpath && argc >= 1) {
            symbolpath = *argv;
            params += 1;
        } else if (optequ(opt, "-v")) {
            verbose = TRUE;
        } else if (optequ(opt, "-idle")) {
            noidle = TRUE;
        } else if (optequ(opt, "-raw")) {
            rawdump = TRUE;
        } else if (optequ(opt, "-dpc")) {
            dumpdpc = TRUE;
        } else {
            usage();
        }

        argv += params;
        argc -= params;
    }

    switch (cmd) {
    case STARTCMD:
    case STOPCMD:
        // Cut down on repeated connection requests
        DmUseSharedConnection(TRUE);

        // Compose the command and send it
        hr = DmCAPControl(cmd == STARTCMD ? "start" : "stop");
        checkerr(FAILED(hr), "Error sending command to xbox: %x\n", hr);
    
        if (cmd == STOPCMD) {
            hr = DmReceiveFile(cap_filename, XBOX_CAP_FILENAME);
            checkerr(FAILED(hr), "Error retrieving profile data: %x\n", hr);
        }

        DmUseSharedConnection(FALSE);
        break;

    case DUMPCMD:
        capdump(cap_filename, dump_filename);
        break;

    default:
        usage();
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\CDropTarget.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     cdroptarget.h
// Contents: UNDONE-WARN: Add file description
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


typedef struct
{
    bool fXbox; // if true, then the dataobject is sourced from an Xbox
    char szName[MAX_PATH];  // The name of the source Xbox (if sourced from one)
    HWND hwnd;      // Handle to the window the dataobject was sourced from.
} sSourceInfo;

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ CLASS DECLARATIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


class CDropTarget : public IDropTarget
{
protected:
    long                m_cRef;
public:
    CDropTarget();
    
    //IDropTarget interface members
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP DragEnter(LPDATAOBJECT pIDataSource, DWORD grfKeyState, POINTL pt,
                           LPDWORD pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, LPDWORD pdwEffect);
    STDMETHODIMP DragLeave(void);
    STDMETHODIMP Drop(LPDATAOBJECT pIDataSource, DWORD grfKeyState, POINTL pt, LPDWORD pdwEffect);

private:
    IDataObject *m_pidataobject;
};

typedef CDropTarget* PCDropTarget; 

void GetDropSourceInfo(IDataObject *pidataobject, sSourceInfo *psourceinfo);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\CFileContainer.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     cfilecontainer.cpp
// Contents: UNDONE-WARN: Add file description
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"
#include "CFileContainerFormats.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CFileContainer::CFileContainer() : m_cRef(1)
{
    m_cFiles = 0;
    m_fCut = false;
    m_fPaste = false;
    m_fPasteSucceeded = false;
}

CFileContainer::~CFileContainer()
{
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CFileContainer::QueryInterface
// Purpose:   Obtain a particular interface to this object.
// Arguments: riid          -- The interface to this object being queried for.
//            ppvObject     -- Buffer to fill with obtained interface.
// Return:    S_OK if interface obtained; E_NOINTERFACE otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CFileContainer::QueryInterface(REFIID riid, void **ppvObject)
{ 
    *ppvObject = NULL;

    if (riid == IID_IUnknown) 
        *ppvObject = this;
    else if (riid == IID_IDataObject) 
        *ppvObject = static_cast<IDataObject*>(this);
    else
        return E_NOINTERFACE;

    if (*ppvObject)
    {
        static_cast<LPUNKNOWN>(*ppvObject)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}   

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CFileContainer::AddRef
// Purpose:   Add a reference to this object
// Arguments: None
// Return:    New reference count
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP_(ULONG) CFileContainer::AddRef()
{
    return (ULONG)InterlockedIncrement(&m_cRef);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CFileContainer::Release
// Purpose:   Subtract a reference to this object.  If the new number of references is zero, then
//            delete the object.
// Arguments: None
// Return:    New reference count.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP_(ULONG) CFileContainer::Release()
{
    if (0 == InterlockedDecrement(&m_cRef))
    {
        bool fQuery = false;
        DM_FILE_ATTRIBUTES dmfa;

        // If a cut originated from us, and a paste finished us, then remove the original files!
        if (m_fCut && m_fPasteSucceeded)
        {
            for (int i = 0; i < m_cFiles; i++)
            {
                xbfu.GetFileAttributes(m_listFiles[i], &dmfa);
                xbfu.Del(m_listFiles[i], &fQuery, NULL);
            }
            listview.SortListView(-1, NULL);
        }
        g_progress.EndThread();
    
        delete this;
        return 0;
    }

    return (ULONG)m_cRef;
}

// ==== IDataObject functions ====
STDMETHODIMP CFileContainer::GetData(FORMATETC *pformatetcIn, STGMEDIUM *pstgm)
{
    int nSize;
    bool bHere = false;
    HGLOBAL hGlobal;
    LPSTR pData = NULL;
    FILEGROUPDESCRIPTOR *pfgd;

    if (!bHere) {
        pstgm->tymed = NULL;
        pstgm->hGlobal = NULL;
        pstgm->pstm = NULL;
        pstgm->pUnkForRelease = NULL;
    }

    if (pformatetcIn->cfFormat == g_suXboxObject)
    {
        // Asking for Xbox-specific information about us.
        if (pformatetcIn->tymed != TYMED_HGLOBAL)
            return DV_E_FORMATETC;
        pstgm->pUnkForRelease = 0;
        pstgm->tymed = TYMED_HGLOBAL ;

        if (!bHere) { 
            // Allocate space for the file descriptor table and lock it so we can write to it
            hGlobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_SHARE, sizeof(sSourceInfo));
            if (!hGlobal)
                return E_FAIL;
        }
        else
            hGlobal = pstgm->hGlobal;

        sSourceInfo *si = (sSourceInfo*)GlobalLock(hGlobal);

        // Copy information about 'us' to the sSourceInfo block.
        
        // Mark that we're an Xbox (NOTE: It's possible to construe the simple acknowledgement of
        // the g_suXboxObject request as us being an Xbox).  Left as-is to ease sSourceInfo
        // construction on the 'droptarget' side.
        si->fXbox = true;
        
        // Copy information into the sSourceInfo block that uniquely identifies which Xbox we're
        // currently pointing at.
        strcpy(si->szName, g_TargetXbox);

        // Track which window this objeect originated from.  This is so that we can track xbox->xbox
        // drag/drop from both same and different windows..
        si->hwnd = g_hwnd;

        // Unlock the memory
        GlobalUnlock(hGlobal);

        if (!bHere)
        {
            pstgm->tymed   = TYMED_HGLOBAL;
            pstgm->hGlobal = hGlobal;
        }

        return S_OK;
    }
    else if (pformatetcIn->cfFormat == g_suFileGroupDesc)
    {
        // Asking for the file group descriptor.  Note that the FGD request
        // will only come in HGLOBAL format...
        if (pformatetcIn->tymed != TYMED_HGLOBAL)
            return DV_E_FORMATETC;

		// Expand the list of files to include subfiles (if not already done)
		m_listFiles.IncludeSubDirs();
		m_cFiles = m_listFiles.GetNumFiles();

        nSize = sizeof(FILEGROUPDESCRIPTOR) + sizeof(FILEDESCRIPTOR) * m_cFiles;

        if (!bHere) { 
            // Allocate space for the file descriptor table and lock it so we can write to it
            pstgm->hGlobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_SHARE, nSize);
            if (!pstgm->hGlobal)
                return E_FAIL;
            pstgm->tymed = TYMED_HGLOBAL;
        }
        else
            hGlobal = pstgm->hGlobal;

		// UNDONE-FUTURE: This is where the 'calculating time to copy' dialog would pop up if we supported them.

		// Add all of the files to the groupdesc
        pfgd = (FILEGROUPDESCRIPTOR*)GlobalLock(pstgm->hGlobal);
        for (int i = 0; i < m_cFiles; i++)
		{
			DM_FILE_ATTRIBUTES dmfa;

			FILEDESCRIPTOR *pfd = &pfgd->fgd[i];
			pfd->dwFlags = FD_ATTRIBUTES | FD_FILESIZE;
			strcpy(pfd->cFileName, m_listFiles[i] + MyStrlen(g_szCopyDir));

			xbfu.GetFileAttributes(m_listFiles[i], &dmfa);
			pfd->nFileSizeHigh = dmfa.SizeHigh;
			pfd->nFileSizeLow = dmfa.SizeLow;
			pfd->dwFileAttributes = dmfa.Attributes;
		}

        pfgd->cItems = m_cFiles;

        // Start the thread that handles the progress dialog.  It won't actually display anything for
        // a couple of seconds to avoid displaying it for small copies...
        g_progress.StartThread();
        g_progress.SetError();
        return S_OK;
    }
    else if (pformatetcIn->cfFormat == g_suFileContents)
    {
        g_progress.ClearError();
        CXboxStream *pxboxstream = new CXboxStream(m_listFiles[pformatetcIn->lindex], m_fCut);
        // undone-err: check if failed to open file
        pstgm->tymed = TYMED_ISTREAM;
        pstgm->pstm = pxboxstream;
        m_fPaste = true;
        ULARGE_INTEGER ul;
        ul.QuadPart = 0;
        g_progress.SetFileInfo(strrchr(m_listFiles[pformatetcIn->lindex], '\\') + 1, ul);
        return S_OK;
    }
    else if (pformatetcIn->cfFormat == g_suXboxFiles)
    {
        // Simple HDROP.  We do this through our own format rather than CF_HDROP because
        // we must be sure reply ONLY if we're the destination.  We have to force the shell
        // through the filecontents approach above since we need to stream the data over.
        if (!bHere) { 
            int nMemSize = (MAX_PATH + 1) * m_cFiles + 1;
            hGlobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_SHARE, nMemSize);
            if (!hGlobal) return FALSE;
        } else {
            hGlobal = pstgm->hGlobal;
        }

        DROPFILES *pdf = (DROPFILES*)GlobalLock(hGlobal);
        if (pdf) {
            pdf->pFiles = sizeof(DROPFILES);
            pdf->fWide = false;

            // Add all of the files to the list
            BYTE *pby = (BYTE*)pdf+pdf->pFiles;
            for (int i = 0; i < m_cFiles; i++)
            {
                memcpy(pby, m_listFiles[i], MyStrlen(m_listFiles[i]));
                pby += MyStrlen(m_listFiles[i]);
                *pby++ = '\0';
            }

            *pby++ = '\0';

            GlobalUnlock(hGlobal);
        }
        if (!bHere)
        {
            pstgm->tymed   = TYMED_HGLOBAL;
            pstgm->hGlobal = hGlobal;
        }
        m_fPaste = true;
        return S_OK;
    }
    else if (pformatetcIn->cfFormat == g_suPrefDropEffect && m_fCut)
    {
        if (!bHere) { 
            int nMemSize = 4;
            hGlobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_SHARE, nMemSize);
            if (!hGlobal) return FALSE;
        } else {
            hGlobal = pstgm->hGlobal;
        }
        DWORD *pdw = (DWORD*)GlobalLock(hGlobal);
        if (m_fCut)
            *pdw = DROPEFFECT_MOVE;
        GlobalUnlock(hGlobal);

        if (!bHere)
        {
            pstgm->tymed   = TYMED_HGLOBAL;
            pstgm->hGlobal = hGlobal;
        }
        return S_OK;
    }
    else if (pformatetcIn->cfFormat == g_suPerfDropEffect && m_fCut)
    {
        if (!bHere) { 
            int nMemSize = 4;
            hGlobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_SHARE, nMemSize);
            if (!hGlobal) return FALSE;
        } else {
            hGlobal = pstgm->hGlobal;
        }
        DWORD *pdw = (DWORD*)GlobalLock(hGlobal);
        if (m_fCut)
            *pdw = DROPEFFECT_MOVE;
        else
            *pdw = DROPEFFECT_COPY;
        GlobalUnlock(hGlobal);


        DM_FILE_ATTRIBUTES dmfa;
        bool fQuery = false;
        for (int i = 0; i < m_cFiles; i++)
        {
            xbfu.GetFileAttributes(m_listFiles[i], &dmfa);
            xbfu.Del(m_listFiles[i], &fQuery, NULL);
        }
        m_cFiles = 0;
        listview.SortListView(-1, NULL);

        if (!bHere)
        {
            pstgm->tymed   = TYMED_HGLOBAL;
            pstgm->hGlobal = hGlobal;
        }
        return S_OK;
    }
    else if (pformatetcIn->cfFormat == g_suPasteSucceeded)
    {
        m_fPasteSucceeded = true;
        return S_OK;
    }

    return DV_E_FORMATETC;
}

STDMETHODIMP CFileContainer::GetDataHere(FORMATETC *pformatetc, STGMEDIUM *pmedium)
{
    return E_NOTIMPL;
}

STDMETHODIMP CFileContainer::QueryGetData(FORMATETC *pformatetc) 
{
    if (pformatetc->cfFormat == g_suFileGroupDesc)
    {
        if (pformatetc->ptd == NULL  && (pformatetc->dwAspect & DVASPECT_CONTENT) &&
            pformatetc->lindex == -1 && (pformatetc->tymed    & TYMED_HGLOBAL))
            return S_OK;

        return E_INVALIDARG;
    }

    if (pformatetc->cfFormat == g_suFileContents)
    {
        if (pformatetc->ptd == NULL && (pformatetc->dwAspect & DVASPECT_CONTENT) &&
            (pformatetc->tymed & TYMED_ISTREAM))
            return S_OK;

        return E_INVALIDARG;
    }

    if (pformatetc->cfFormat == g_suXboxFiles)
    {
        if (pformatetc->ptd == NULL && (pformatetc->dwAspect & DVASPECT_CONTENT) &&
            (pformatetc->tymed & TYMED_HGLOBAL))
            return S_OK;

        return E_INVALIDARG;
    }
#if 0
    if (pformatetc->cfFormat == g_suPrefDropEffect)
    {
        if (pformatetc->ptd == NULL && (pformatetc->dwAspect & DVASPECT_CONTENT) &&
            (pformatetc->tymed & TYMED_HGLOBAL))
            return S_OK;

        return E_INVALIDARG;
    }
#endif
    // UNDONE- this should not be allowed!  Removing this may make shell send us proper filecontent requests
    if (pformatetc->cfFormat == CF_HDROP)
        return S_OK;

    // We don't handle the specified format
    return E_NOTIMPL;
}

STDMETHODIMP CFileContainer::GetCanonicalFormatEtc(FORMATETC *pformatectIn, FORMATETC *pformatetcOut)
{
    return E_NOTIMPL;
}

STDMETHODIMP CFileContainer::SetData(FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease)
{
    HRESULT hr = S_OK;
    IDataObject *pidataobj;
    if (pformatetc->cfFormat == g_suPerfDropEffect)
    {
        DWORD *pdw = (DWORD*)GlobalLock(pmedium->hGlobal);
        bool fCut = (*pdw == DROPEFFECT_MOVE);        
        GlobalUnlock(pmedium->hGlobal);
        
        // If this was from a cut, then we need to clear out the clipboard so that it will release
        // the final reference TO US.  Be sure to just return afterwards
        OleGetClipboard(&pidataobj);
        
        // check if it was a cut from us; if so, flush the clipboard 
        sSourceInfo sourceinfo;
        GetDropSourceInfo(pidataobj, &sourceinfo);
        if (sourceinfo.fXbox && fCut)
            OleSetClipboard(NULL);

        pidataobj->Release();
        g_progress.EndThread();
        m_fPasteSucceeded = true;
        goto done;
    }
    else if (pformatetc->cfFormat == g_suPasteSucceeded)
    {
        m_fPasteSucceeded = true;
        goto done;
    }
    hr = DV_E_FORMATETC;

done:
    if (fRelease)
        ReleaseStgMedium(pmedium);

    return hr;
}


STDMETHODIMP CFileContainer::EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppienumformatetc)
{
    FORMATETC fmte[] = {
        {(USHORT)g_suFileContents,  NULL, DVASPECT_CONTENT, -1, TYMED_ISTREAM},
        {(USHORT)g_suFileGroupDesc, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
        {(USHORT)g_suXboxObject,    NULL, DVASPECT_CONTENT, -1, TYMED_NULL},
        {(USHORT)g_suXboxFiles,     NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},        
        {(USHORT)g_suPrefDropEffect,NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},        
        {(USHORT)g_suPerfDropEffect,NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},        
        {(USHORT)g_suPasteSucceeded,NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},        
    };

    // Create a new file container format object.  This derives from IEnumFORMATETC and defines
    // all of the necessary behaviours.
    CFileContainerFormats *pfcf = new CFileContainerFormats(7, fmte);
    if (!pfcf)
        return E_OUTOFMEMORY;

    // Obtain a IEnumFORMATETC interface to our file container formats object.
    HRESULT hRes = pfcf->QueryInterface(IID_IEnumFORMATETC, (void **)ppienumformatetc);
    return hRes;
}

STDMETHODIMP CFileContainer::DAdvise(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink, DWORD *pdwConnection)
{
    return E_NOTIMPL;
}

STDMETHODIMP CFileContainer::DUnadvise(DWORD dwConnection) 
{
    return E_NOTIMPL;
}

STDMETHODIMP CFileContainer::EnumDAdvise(IEnumSTATDATA **ppenumAdvise)  
{
    return E_NOTIMPL;
}


bool CFileContainer::AddDir(char *szDirName)
{
    return AddFile(szDirName);
}

bool CFileContainer::AddFile(char *szFileName)
{
    //Add the file to the list of files to drag
    m_listFiles.Add(szFileName);
    m_cFiles++;
    return true;
}

#include <assert.h>
CList::CList()
{
    m_pnodeHead = NULL;
    m_pnodeTail = NULL;
	m_fExpanded = false;
	m_cFiles = 0;
}

CList::~CList()
{
    // Delete all the entries
    while (m_pnodeHead)
    {
        CNode *pnodeNext = m_pnodeHead->m_pnodeNext;
        free(m_pnodeHead->m_sz);
        delete m_pnodeHead;
        m_pnodeHead = pnodeNext;
    }
    m_pnodeTail = NULL;
}


void CList::Add(char *sz)
{
    CNode *pnodeNew = new CNode(MyStrdup(sz));
    if (m_pnodeTail)
        m_pnodeTail->m_pnodeNext = pnodeNew;
    else
        m_pnodeHead = pnodeNew;

    m_pnodeTail = pnodeNew;
	m_cFiles++;
}

// UNDONE-OPT: Using this approach since the code above uses it.  Ideally I would replace all
// enumerations of the list with normal list handling, but that change, while simple, would touch
// enough code to potentially introduce bugs.  At this stage of the release, we'll take the minimal
// speed hit.
char *CList::operator[] (int iIndex) const
{
    CNode *pnode = m_pnodeHead;
    for (int i = 0; i < iIndex; i++)
        pnode = pnode->m_pnodeNext;

    return pnode->m_sz;
}

void CList::IncludeSingle(char *szFile)
{
	DM_FILE_ATTRIBUTES dmfa;
	xbfu.GetFileAttributes(szFile, &dmfa);

	// If szFile is dir,then recurse into it.
	if (dmfa.Attributes & FILE_ATTRIBUTE_DIRECTORY)
	{
 		HANDLE hfile = xbfu.FindFirstFile(szFile, &dmfa, true);
		if (hfile != INVALID_HANDLE_VALUE)
		{
			do
			{
				char szSourceSubDir[MAX_PATH];
				wsprintf(szSourceSubDir, "%s\\%s", szFile, dmfa.Name);

				if (dmfa.Attributes & FILE_ATTRIBUTE_DIRECTORY)
					IncludeSingle(szSourceSubDir);
				else
					Add(szSourceSubDir);
			}
			while (xbfu.FindNextFile(hfile, &dmfa, true));
		}
		xbfu.FindClose(hfile, true);
	}
}

void CList::IncludeSubDirs()
{
	// Only do this if we haven't already expanded
	if (m_fExpanded)
		return;

	CNode *pnodeEnd = m_pnodeTail;
	CNode *pnodeCur = m_pnodeHead;

	// note that end doesn't extend.
	while (pnodeCur != pnodeEnd)
	{
		IncludeSingle(pnodeCur->m_sz);
		pnodeCur = pnodeCur->m_pnodeNext;
	}
	IncludeSingle(pnodeCur->m_sz);	// include end node

	m_fExpanded = true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\CDropTarget.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     CDropTarget.cpp
// Contents: UNDONE-WARN: Add file description
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDropTarget::CDropTarget
// Purpose:   CDropTarget constructor. Sole purpose is to preset the ref count to 1.
// Arguments: None.
// Return:    None.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CDropTarget::CDropTarget() : m_cRef(1)
{
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDropTarget::QueryInterface
// Purpose:   Obtain a particular interface to this object.
// Arguments: riid          -- The interface to this object being queried for.
//            ppvObject     -- Buffer to fill with obtained interface.
// Return:    S_OK if interface obtained; E_NOINTERFACE otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CDropTarget::QueryInterface(REFIID riid, void **ppvObject)
{ 
    *ppvObject = NULL;

    if (riid == IID_IUnknown) 
        *ppvObject = this;
    else if (riid == IID_IDropTarget) 
        *ppvObject = static_cast<IDropTarget*>(this);
    else
        return E_NOINTERFACE;

    if (*ppvObject)
    {
        static_cast<LPUNKNOWN>(*ppvObject)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}   

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDropTarget::AddRef
// Purpose:   Add a reference to this object
// Arguments: None
// Return:    New reference count
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP_(ULONG) CDropTarget::AddRef()
{
    return (ULONG)InterlockedIncrement(&m_cRef);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDropTarget::Release
// Purpose:   Subtract a reference to this object.  If the new number of references is zero, then
//            delete the object.
// Arguments: None
// Return:    New reference count.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP_(ULONG) CDropTarget::Release()
{
    if (0 == InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return (ULONG)m_cRef;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDropTarget::DragEnter
// Purpose:   Called when an object is dragged into us.  Return what sort of operation we allow
//            given the current key state (ie move, copy, none).
// Arguments: pidataobject      -- The object containing information on all of the files
//            dwKeyState        -- Provides state of the keys and mouse buttons.
//            pt                -- The position of the mouse cursor.
//            pdwEffect         -- On exit, will contain allowed operation.
// Return:    NOERROR to represent valid pdwEffect, E_FAIL otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CDropTarget::DragEnter(LPDATAOBJECT pidataobject, DWORD dwKeyState, POINTL pt,
                                    LPDWORD pdwEffect)
{
    HRESULT hr;
    bool fSourceXbox = false;

    // We need to track the 'current' data object since CDropTarget::DragOver isn't passed the
    // actual data object.  We NULL it out here in case we determine farther down that no drop
    // is allowed.
    m_pidataobject = NULL;

    // Check to see if the object being dropped is a file (or collection of files).  We only
    // support files passed through CF_HDROP or our own custom format (See CFileContainer for an
    // explanation of why we have our own custom format).
    FORMATETC fe = {(USHORT)g_suXboxFiles, 0, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    hr = pidataobject->QueryGetData(&fe);
    if (hr != S_OK)
    {
        // The data object didn't recognize our custom format, so check if it's a standard CF_HDROP
        // format object.
        fe.cfFormat = CF_HDROP;
        hr = pidataobject->QueryGetData(&fe);
    }
    else
        fSourceXbox = true;
    
    if (hr != S_OK)
    {
        // We don't know what it is...
        *pdwEffect=DROPEFFECT_NONE;
        return NOERROR;
    }
  
    // Return effect flags based on keys.
    if (fSourceXbox)
    {
        // From an xbox, so use same-drive convention
        *pdwEffect=DROPEFFECT_MOVE;    
        if (dwKeyState & MK_CONTROL)     
            *pdwEffect=DROPEFFECT_COPY;
    }
    else
    {
        // From PC, so use cross-drive convention
        *pdwEffect=DROPEFFECT_COPY;    
        if (dwKeyState & MK_SHIFT)     
            *pdwEffect=DROPEFFECT_MOVE;
    }
    
    // Keep a pointer to the data being dragged for CDropTarget::DragOver
    m_pidataobject = pidataobject;

    // Track our reference to the data object.  Must be released when DragLeave occurs
    m_pidataobject->AddRef();

    // Bring our app's window to the top
//    BringWindowToTop(g_hwnd);
//    UpdateWindow(g_hwnd);

    return NOERROR;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDropTarget::DragOver
// Purpose:   Called whenever the mouse moves over the drag target while dragging.
// Arguments: dwKeyState        -- Provides state of the keys and mouse buttons.
//            pt                -- The position of the mouse cursor.
//            pdwEffect         -- On exit, will contain allowed operation.
// Return:    NOERROR to represent valid pdwEffect, E_FAIL otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CDropTarget::DragOver(DWORD dwKeyState, POINTL ptl, LPDWORD pdwEffect)    
{
    bool fDropAllowed;
    sSourceInfo si;
    GetDropSourceInfo(m_pidataobject, &si);

    // Check if the particular data was determined to be allowed in the CDropTarget::DragEnter
    // function.  If not, then we don't allow the drop
    if (m_pidataobject == NULL)
        fDropAllowed = false;
    else
    {
        POINT pt;
        pt.x = ptl.x;
        pt.y = ptl.y;

        // Tell the listview to set the temporary drag/drop highlight.  It will handle highlighting
        // of directories and NOT files, and will remove highlight when appropriate.
        bool fValidDropItem = listview.SetDragHighlight(true, &pt);

        // If the cursor is over a 'valid drop item' (ie a folder) then we can drop regardless of source
        if (fValidDropItem)
            fDropAllowed = true;
        else
        {
            // Not over a valid drop item; if *we* are the source of the drag, then no drop is
            // allowed.  If something external is the source, then the drop is allowed
            if (si.fXbox && g_hwnd == si.hwnd)
            {
                // We are dragging files within our own window and are not currently over a folder;
                // therefore no drop is allowed
                fDropAllowed = false;
            }
            else
            {
                // We are dragging files from another window; therefore a drop is allowed
                // (regardless of whether the source is an Xbox or PC).
                fDropAllowed = true;
            }
        }
    }

    if (fDropAllowed)
    {
        // Return effect flags based on keys.
        if (si.fXbox)
        {
            // From an xbox, so use same-drive convention
            *pdwEffect=DROPEFFECT_MOVE;    
            if (dwKeyState & MK_CONTROL)     
                *pdwEffect=DROPEFFECT_COPY;
        }
        else
        {
            // From PC, so use cross-drive convention
            *pdwEffect=DROPEFFECT_COPY;    
            if (dwKeyState & MK_SHIFT)     
                *pdwEffect=DROPEFFECT_MOVE;
        }
    }
    else
        *pdwEffect=DROPEFFECT_NONE;

    return NOERROR;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDropTarget::DragLeave
// Purpose:   Called whenever the mouse cursor leaves the drag target while dragging.
// Arguments: None.
// Return:    NOERROR.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CDropTarget::DragLeave()  
{
    // If we had a valid data object dragged in, then release our reference to it now.
    if (m_pidataobject != NULL)       
    { 
        m_pidataobject->Release();

        // Tell the listview to unhighlight the temporary drag highlight.
        listview.SetDragHighlight(false, NULL);
    } 
    return NOERROR;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDropTarget::Drop
// Purpose:   Called when the user drops data onto us.
// Arguments: pidataobject      -- The object containing information about all of the files
//            dwKeyState        -- Provides state of the keys and mouse buttons.
//            pt                -- The position of the mouse cursor.
//            pdwEffect         -- On exit, will contain performed operation.
// Return:    NOERROR to represent valid pdwEffect, E_FAIL otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CDropTarget::Drop(LPDATAOBJECT pidataobject, DWORD dwKeyState, POINTL pt,
                               LPDWORD pdwEffect)  
{
    HRESULT   hr = S_OK;
    STGMEDIUM stm;
    char      *szNextSourcePathFile;
    char szBuf[1024], szBuf2[1024];
    bool fContinue;

    // Clear out our performed effect in case things fail below
    *pdwEffect=DROPEFFECT_NONE;

    // If we determined earlier that the data was not valid for us, then return failure now.
    if (pidataobject == NULL)
        return ResultFromScode(E_FAIL);

    g_progress.StartThread();

    sSourceInfo sourceinfo;
    GetDropSourceInfo(pidataobject, &sourceinfo);

    // Get the file names from the dropobject and do the copy.  There are two possible sources of
    // the data; us (xbExplorer), and not us (Shell32, other drag sources).  In the first case,
    // we go through our own format since our CFileContainer does not support CF_HDROP (See that
    // object definition for the reason why).  In the second case, we go through CF_HDROP.  In
    // either case, the format of the data matches CF_HDROP's definition (See MSDN), so we can
    // continue on in the same code path...

    // First, check if the source is one of our custom jobbies (this could be the user dragging
    // from one place to another in the same xbExplorer, or dragging files from xbExplorer A
    // to xbExplorer B).
    FORMATETC fe = {(USHORT)g_suXboxFiles, 0, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    hr = pidataobject->GetData(&fe, &stm);
    if (hr != S_OK)
    {
        // The data object didn't recognize our custom format, so it must be a standard CF_HDROP
        // data object.
        fe.cfFormat = CF_HDROP;
        hr = pidataobject->GetData(&fe, &stm);
    }
    if (hr == S_OK && stm.hGlobal != NULL)
    {
        DROPFILES *pdf = (DROPFILES*)GlobalLock(stm.hGlobal);
        bool fSourceXbox = false;
        
        // Copy each of the files over
	    char szDestFilePath[MAX_PATH];

        // If we are the source and target then it's an xbox->xbox copy.
        // Else it's a PC->xbox copy.
        //     XBox->PC copies are handled in the CFileContainer object
        //     We handle xbox->xbox and PC->xbox here...

//        if (sourceinfo.fXbox && MyStrcmp(sourceinfo.szName, g_TargetXbox))
        if (sourceinfo.fXbox && g_hwnd != sourceinfo.hwnd)
        {
            // We don't allow copying from one xbox to another yet
            LoadString(hInst, IDS_XTOX_COPY_NOT_ALLOWED, szBuf, MAX_PATH);
            LoadString(hInst, IDS_UNSUPPORTED_FEATURE, szBuf2, MAX_PATH);

            MessageBox(g_hwnd, szBuf, szBuf2, MB_ICONWARNING | MB_OK);
            goto done;
        }
        // Check to see if the files were dropped onto a directory
        char szFolderName[MAX_PATH];
        bool fDroppedOnDir = listview.GetDragItemName(szFolderName);

        // First check to see if the user simply dragged a collection of objects around and ended
        // up dropped them back onto one of the folders in that collection.  In that case, do
        // nothing.  We can tell if this happened by looking at the list of dropped objects and
        // checking to see if the destination folder contains any of them.
        // This only happens if the source was an xbox, and the files were dropped onto a specific
        // directory.
        if (fDroppedOnDir && sourceinfo.fXbox)
        {
            szNextSourcePathFile = (char*)(pdf) + pdf->pFiles;
            while (*szNextSourcePathFile)
            {
                char *pszSource;

                // UNDONE: Note - current assumption is that Xbox HD requires ASCII chars...
                if (pdf->fWide)
                {
                    // Convert from wide to single byte
                    pszSource = WideToSingleByte((WCHAR*)szNextSourcePathFile);
                }
                else
                    pszSource = szNextSourcePathFile;

                wsprintf(szDestFilePath, "%s%s", g_CurrentDir, szFolderName);
                if (!MyStricmp(szDestFilePath, pszSource))
                {
                    // The user clicked on a file/folder on the Xbox, dragged it around, and finally
                    // dropped it *back* onto the same file/folder.  Ignore everything!
                    hr = E_UNEXPECTED;
                    goto done;
                }
                if (pdf->fWide)
                    szNextSourcePathFile += (MyStrlen(pszSource)+1)*2;
                else
                    szNextSourcePathFile += MyStrlen(pszSource)+1;
            }
        }

        // If here, then we're good to copy/move...
        bool fQuery = true;
        szNextSourcePathFile = (char*)(pdf) + pdf->pFiles;
        while (*szNextSourcePathFile)
        {
            char *pszSource;

            if (pdf->fWide)
            {
                // Convert from wide to single byte
                pszSource = WideToSingleByte((WCHAR*)szNextSourcePathFile);
            }
            else
                pszSource = szNextSourcePathFile;
            
            if (fDroppedOnDir)
            {
                // Dropped onto a directory! Combine its name into the destination path
                if (sourceinfo.fXbox)
                    wsprintf(szDestFilePath, "%s%s\\%s", g_CurrentDir, szFolderName,
                             pszSource + MyStrlen(g_szCopyDir));
                else
                    wsprintf(szDestFilePath, "%s%s\\%s", g_CurrentDir, szFolderName,
                             strrchr(pszSource,'\\') + 1);
            }
            else
            {
                // Dropped directly into us
                if (sourceinfo.fXbox)
                    wsprintf(szDestFilePath, "%s%s", g_CurrentDir, pszSource + MyStrlen(g_szCopyDir));
                else
                    wsprintf(szDestFilePath, "%s%s", g_CurrentDir, strrchr(pszSource,'\\') + 1);
            }

            // Perform the actual copy.  The 'Copy' command will take care of directories auto-
            // matically (ie creating and recursively copying them).
            // NOTE: This code is only called in the Xbox->Xbox or PC->Xbox cases.
            bool fDoMove = true;
            if ((sourceinfo.fXbox  && (dwKeyState & MK_CONTROL)) ||
                (!sourceinfo.fXbox && !(dwKeyState & MK_SHIFT)))
                fDoMove = false;

            fContinue = (xbfu.CopyMoveToXbox(pszSource, szDestFilePath, &fQuery, true, sourceinfo.fXbox, true, fDoMove) == S_OK);
            if (!fContinue)
                break;
            
            if (pdf->fWide)
                szNextSourcePathFile += (MyStrlen(pszSource)+1)*2;
            else
                szNextSourcePathFile += MyStrlen(pszSource)+1;
        }

        GlobalUnlock(stm.hGlobal);
    }
    else
        hr = E_UNEXPECTED;
done:
    
    ReleaseStgMedium(&stm);
    
    // Return effect flags based on keys.
    if (hr != S_OK)
        *pdwEffect = DROPEFFECT_NONE;
    else if (sourceinfo.fXbox)
    {
        // From an xbox, so use same-drive convention
        *pdwEffect=DROPEFFECT_MOVE;    
        if (dwKeyState & MK_CONTROL)     
            *pdwEffect=DROPEFFECT_COPY;
    }
    else
    {
        // From PC, so use cross-drive convention
        *pdwEffect=DROPEFFECT_COPY;    
        if (dwKeyState & MK_SHIFT)     
            *pdwEffect=DROPEFFECT_MOVE;
    }

    g_progress.EndThread();

    // Refresh the listview with the new files
	listview.SortListView(-1, FALSE);

    DragLeave();

    /* Make sure we have focus if the drop succeeded */
    if(SUCCEEDED(hr))
        SetForegroundWindow(g_hwnd);

    return hr;
}


void GetDropSourceInfo(IDataObject *pidataobject, sSourceInfo *psourceinfo)
{
    STGMEDIUM   stm;

    // Check to see if the data object is originating from an xbFileMgr (us or other)
    FORMATETC fe = {(USHORT)g_suXboxObject, 0, DVASPECT_CONTENT, (USHORT)-1,TYMED_HGLOBAL};

    if (pidataobject->GetData(&fe, &stm) == S_OK)
    {
        sSourceInfo *psi = (sSourceInfo *)GlobalLock(stm.hGlobal);
        
        // Copy the info
        *psourceinfo = *psi;

        GlobalUnlock(stm.hGlobal);
    }
    else
    {
        // the object didn't recognize our 'g_suXboxObject' request, so it's therefore not an
        // xbox!
        psourceinfo->fXbox = false;
    }

    // Release the storage memory allocated by the GetData call above.
    ReleaseStgMedium(&stm);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\CFileContainer.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     cfilecontainer.h
// Contents: UNDONE-WARN: Add file description
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class CNode
{
public:
    CNode(char *sz) {m_sz = sz; m_pnodeNext = NULL;}
    CNode *m_pnodeNext;
    char *m_sz;
};

class CList
{
public:
    CList();
    ~CList();
    void Add(char *sz);
    char *operator[] (int iIndex) const;
    void IncludeSingle(char *szFile);
	void IncludeSubDirs();
	int GetNumFiles() {return m_cFiles;}
private:
	bool m_fExpanded;
    char **m_rgszEntries;
    int m_nSize;
    int m_iCurEntry;
    CNode *m_pnodeHead;
    CNode *m_pnodeTail;
	int  m_cFiles;
};


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ CLASS DECLARATIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

class CFileContainer : public IDataObject
{
public: 
    CFileContainer();
    ~CFileContainer();
    
    // IUnknown functions
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObject);
    STDMETHODIMP_(ULONG) AddRef(); 
    STDMETHODIMP_(ULONG) Release();

    // IDataObject functions
    STDMETHODIMP GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium);
    STDMETHODIMP GetDataHere(FORMATETC *pformatetc, STGMEDIUM *pmedium);
    STDMETHODIMP QueryGetData(FORMATETC *pformatetc); 
    STDMETHODIMP GetCanonicalFormatEtc(FORMATETC *pformatectIn, FORMATETC *pformatetcOut);
    STDMETHODIMP SetData(FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease);
    STDMETHODIMP EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppenumFormatEtc);
    STDMETHODIMP DAdvise(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink, DWORD *pdwConnection);
    STDMETHODIMP DUnadvise(DWORD dwConnection); 
    STDMETHODIMP EnumDAdvise(IEnumSTATDATA **ppenumAdvise);  

    // Our functions
    bool AddDir(char *szDirName);
    bool AddFile(char *szFileName);

    bool m_fCut, m_fPaste, m_fPasteSucceeded;
private:
    long m_cRef;

    CList m_listFiles;
    int m_cDirs, m_cFiles;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\CProgress.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     cprogress.h
// Contents: 
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ CLASS DECLARATIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

class CProgress
{
public:
    CProgress();
    ~CProgress();

    void StartThread();
    void EndThread();
    void SetFileInfo(char *szFileName, ULARGE_INTEGER uliFileSize);
    DWORD GetCurOperation() {return m_dwCurOperation; }
    bool InThread() {return m_fInThread; }
    void SetError();
    void ClearError();
    bool ErrorSet();

private:
    HANDLE m_hthread;
    bool m_fInThread;
    bool m_fError;

    DWORD m_dwCurOperation;
};


extern CProgress g_progress;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\CFileContainerFormats.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     cfilecontainerformats.cpp
// Contents: UNDONE-WARN: Add file description
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"
#include "CFileContainerFormats.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CFileContainerFormats::CFileContainerFormats(UINT cfmt, const FORMATETC afmt[]) : m_cRef(1)
{
    m_iFmt = 0;
    m_cFmt = cfmt;
    m_aFmt = new FORMATETC[cfmt];
    if (m_aFmt)
        CopyMemory(m_aFmt, afmt, cfmt*sizeof(afmt[0]));
}

CFileContainerFormats::~CFileContainerFormats()
{
    if (m_aFmt)
        delete m_aFmt;
}

// ==== IUnknown methods ====
STDMETHODIMP CFileContainerFormats::QueryInterface( REFIID riid, void **ppvObject)
{
    *ppvObject = NULL;

    if (riid == IID_IUnknown) 
        *ppvObject = this;
    else if (riid == IID_IEnumFORMATETC) 
        *ppvObject = static_cast<IEnumFORMATETC*>(this);
    else
        return E_NOINTERFACE;

    if (*ppvObject)
    {
        static_cast<LPUNKNOWN>(*ppvObject)->AddRef();
        return S_OK;
    }

   return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CFileContainerFormats::AddRef(void)
{
    return (ULONG)InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CFileContainerFormats::Release(void)
{
    if (0 == InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return (ULONG)m_cRef;
}

// ==== IEnumFORMATETC functions===
STDMETHODIMP CFileContainerFormats::Next(ULONG celt, FORMATETC *rgelt, ULONG *pceltFethed)
{
    UINT cfetch; 
    HRESULT hres = S_FALSE;
    
    // assume less numbers  
    if (m_iFmt < m_cFmt) 
    {
        cfetch = m_cFmt - m_iFmt; 
        if (cfetch >= celt) 
        { 
            cfetch = celt;
            hres = S_OK;
        }  
        
        CopyMemory(rgelt, &m_aFmt[m_iFmt], cfetch * sizeof(FORMATETC)); 
        m_iFmt += cfetch; 
    }
    else
    { 
        cfetch = 0;
    }
    
    if (pceltFethed) 
    { 
        *pceltFethed = cfetch;
    }
    return hres; 
}  

STDMETHODIMP CFileContainerFormats::Skip(ULONG celt)
{
    m_iFmt += celt;
    if (m_iFmt > m_cFmt) 
    { 
        m_iFmt = m_cFmt; 
        return S_FALSE; 
    } 
    return S_OK; 
}  

STDMETHODIMP CFileContainerFormats::Reset() 
{ 
    m_iFmt = 0; 
    return S_OK; 
}  

STDMETHODIMP CFileContainerFormats::Clone(IEnumFORMATETC ** ppenum)
{ 
    return(E_NOTIMPL); 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\CProgress.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     cprogress.cpp
// Contents: UNDONE-WARN: Add file description
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ GLOBAL VARIABLES ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// g_progress       -- The global progress bar object.
CProgress g_progress;

static char gs_szFileName[MAX_PATH];

static ULARGE_INTEGER gs_uliFileSize;

static HANDLE g_hWakeup;
static HANDLE g_hError;

static bool g_fNewFileInfo;

HBITMAP gs_hbmpCopy[4];

int gs_iCurFileBmp;
DWORD gs_rgFileBmpDelay[] = {500, 500, 500, 1000};


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void UpdateFileBmp(HWND hwndControl, int iBmp)
{
  //  char szBmp[20];
//    sprintf(szBmp, "FILECOPY%d", iBmp);
//    SetDlgItemText(hwndControl, IDC_ANIM, szBmp);
//    SetWindowText(hwndControl, szBmp);
SendMessage( hwndControl, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM) gs_hbmpCopy[iBmp] );
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CopyInProgressDlg
// Purpose:   Message handler for the 'File Copy in Progress' dialog. This function is automatically
//            called by Windows whenever a message needs to be sent to the dialog box (ie 'paint',
//            'move', etc).
// Arguments: hwnd          -- Handle to the Dialog box's window
//            message       -- The message sent to the dialog box
//            wParam        -- A message parameter.
//            lParam        -- Another message parameter
// Return:    nonzero if we processed the message
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LRESULT CALLBACK CopyInProgressDlg(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    static int s_iTimer;
    static int gs_iCurBmpFile;
    static DWORD s_dwLastAnimTime;
    DWORD dwTime;

	switch(message)
	{
	case WM_INITDIALOG:
        s_iTimer = SetTimer(hwnd, 1, 50, NULL);
        CenterDialog(hwnd);

        // Force an animation update immediately
        gs_iCurFileBmp = 0;
        s_dwLastAnimTime = GetTickCount();
        UpdateFileBmp(GetDlgItem(hwnd, IDC_ANIM), gs_iCurBmpFile);
        SetForegroundWindow(hwnd);
		return TRUE;
        
    case WM_TIMER:
        // Done?
        if (g_progress.InThread() == false)
        {
            // we're done!
            KillTimer(hwnd, s_iTimer);
            EndDialog(hwnd, 0);
            return TRUE;
        }

        // New file?
        if (g_fNewFileInfo)
        {
            char szBuf[MAX_PATH];
            ULONGLONG ull = gs_uliFileSize.QuadPart;
            if (ull == 0)
                sprintf(szBuf, "%s", gs_szFileName);
            else
                sprintf(szBuf, "%s (%s bytes)", gs_szFileName, FormatBigNumber(ull));
            SetDlgItemText(hwnd, IDC_FILENAME, szBuf);
            g_fNewFileInfo = false;
        }

        // Time to update our animation bitmap?
        dwTime = GetTickCount();

        if (dwTime > s_dwLastAnimTime + gs_rgFileBmpDelay[gs_iCurFileBmp])
        {
            gs_iCurFileBmp = (gs_iCurFileBmp + 1) % 4;
            UpdateFileBmp(GetDlgItem(hwnd, IDC_ANIM), gs_iCurBmpFile);            
        }
        break;
	}
	return FALSE;
}


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  ProgressThread
// Purpose:   Thread that handles displaying and updating the progress bar
// Arguments: pvUnused          -- Ignore.
// Returns:   '0' if successfully connected; '-1' otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
DWORD WINAPI ProgressThread(LPVOID pvArg)
{
    DWORD dwCurOperation;

    while (true)
    {
        // Kick back and wait for something to tell us to wake up (ie a file operation beginning).
        WaitForSingleObject(g_hWakeup, INFINITE);

        // Hey, a file operation began! Wait for a bit to see if the operation is still going.
        dwCurOperation = g_progress.GetCurOperation();
        Sleep(1000);

check:
        // If the file operation is still going on, then we need to pop up the file copy dialog
        // We animate the file copy dialog until we're told to stop.
        if (g_progress.InThread() && g_progress.GetCurOperation() == dwCurOperation)
        {
            // The progress bar is still copying files in the operation that started us above.
            // Display the dialog box
            if (g_progress.ErrorSet())
            {
                // Something has specified that it's displaying it's own error dialog.  Let's
                // kick back until it's no longer set, and then we'll recheck everything.
                // UNDONE-ERR: Can do something like WaitForSingleObject(g_hError, INFINITE), but
                //             I'm a bit too tired and unsure of semaphores to try it right now.
                //             Rethink and do it right for V2.
                while (true)
                {
                    Sleep(50);
                    if (!g_progress.ErrorSet())
                        goto check;
                }
            }
            DialogBox(hInst, "COPY_IN_PROGRESS", NULL, (DLGPROC) CopyInProgressDlg);
        }
        else
        {
            // The progress bar is still copying files, BUT it's in another operation that began
            // while we were sleeping (the previous operation ended).  Just fall through and loop
            // back up at the top.  The worst case is that the user waits 2 seconds instead of
            // one to see the progress dialog.
        }

        // At this point, we're done with the current file operation, so loop back around and wait
        // for another one to begin.
    }

    return 0;
}


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CProgress::CProgress
// Purpose:   CProgress constructor
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CProgress::CProgress()
{
    m_dwCurOperation = -1;
    m_fInThread = false;

    // load our bitmaps
    gs_hbmpCopy[0] = LoadBitmap(hInst, MAKEINTRESOURCE("FILECOPY1"));
    gs_hbmpCopy[1] = LoadBitmap(hInst, TEXT("FILECOPY2"));
    gs_hbmpCopy[2] = LoadBitmap(hInst, "FILECOPY3");
    gs_hbmpCopy[3] = LoadBitmap(hInst, "FILECOPY4");

    g_hWakeup = CreateEvent(NULL, false, false, NULL);
    //g_hError  = CreateEvent(NULL, false, false, NULL);

    ClearError();

    // Create the progress bar thread
    m_hthread = CreateThread(NULL, 0, ProgressThread, this, 0, NULL);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CProgress::~CProgress
// Purpose:   CProgress destructor
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CProgress::~CProgress()
{
    for (int i = 0; i <4; i++)
        DeleteObject(gs_hbmpCopy[i]);

    CloseHandle(g_hWakeup);
    CloseHandle(g_hError);

    // Delete the progress bar thread
    CloseHandle(m_hthread);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CProgress::StartThread
// Purpose:   Starts up the progress bar thread
// Arguments: None
// Return:    Non
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CProgress::StartThread()
{
    m_dwCurOperation++;

    // Tell the progress bar thread to start waiting two seconds.  After a moment, it'll
    // wake up and look around to see if we're still copying.  If we are, then it displays the
    // progress bar dialog and starts updating it appropriately.
    SetEvent(g_hWakeup);
    ResetEvent(g_hError);
    m_fInThread = true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CProgress::EndThread
// Purpose:   Stops the progress bar thread
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CProgress::EndThread()
{
    m_fInThread = false;
    g_fNewFileInfo = false;
}

void CProgress::SetError()
{
    m_fError = true;
//    SetEvent(g_hError);
}

void CProgress::ClearError()
{
    m_fError = false;
//    ResetEvent(g_hError);
}

bool CProgress::ErrorSet()
{
    return m_fError;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CProgress::SetFileInfo
// Purpose:   Tracks the newest file info
// Arguments: 
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CProgress::SetFileInfo(char *szFileName, ULARGE_INTEGER uliFileSize)
{
    // Track the new file info.  The progress bar thread will update itself automatically
    strcpy(gs_szFileName, szFileName);
    gs_uliFileSize.QuadPart = uliFileSize.QuadPart;
    g_fNewFileInfo = true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\CProperties.h ===
LRESULT CALLBACK FolderPropertiesDlg( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );
LRESULT CALLBACK FilePropertiesDlg( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\CFileContainerFormats.h ===
class CFileContainerFormats : public IEnumFORMATETC 
{ 
public: 
    CFileContainerFormats(UINT cfmt, const FORMATETC afmt[]); 
    ~CFileContainerFormats();
    
    // *** IUnknown methods ***    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);     
    STDMETHODIMP_(ULONG) AddRef();     
    STDMETHODIMP_(ULONG) Release();
    
    // *** IEnumFORMATETC methods ***     
    STDMETHODIMP Next(ULONG celt, FORMATETC *rgelt, ULONG *pceltFethed);     
    STDMETHODIMP Skip(ULONG celt);     
    STDMETHODIMP Reset();     
    STDMETHODIMP Clone(IEnumFORMATETC ** ppenum);

private:
    long m_cRef;
    UINT m_iFmt;
    UINT m_cFmt;
    FORMATETC *m_aFmt;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\CProperties.cpp ===
#include "stdafx.h"


char *g_rgszMonth[] = {"January", "February", "March", "April", "May", "June",
                       "July", "August", "September", "October", "November", "December"};
DM_FILE_ATTRIBUTES g_dmfa;

void GetTimeBuf(FILETIME *pft, char *szBuf)
{
    SYSTEMTIME systime;
    listview.FileTime2LocalTime(pft, &systime);

    wsprintf(szBuf, "%s %d, %d, %d:%02d:%02d %s", g_rgszMonth[systime.wMonth-1], systime.wDay,
            systime.wYear, (systime.wHour % 12), systime.wMinute, systime.wSecond, 
            (systime.wHour) < 12 ? "AM" : "PM");
}

static char g_szBuffer[32] = {'\0'};

char *FormatBigNumber(ULONGLONG n)
{
    // Convert the number into a comma-separated string; ie "1,234,567,890"
    char *sz = (char*)(g_szBuffer + 31);
    int i = 0;

    *sz = '\0';
    do {
        *--sz = ((char)(n%10)) + '0';
        if ((++i)%3 == 0 && n/10)
            *--sz = ',';
    } while (n/=10);

    return sz;
}

void DrawFolderProperties(HWND hwnd, DM_FILE_ATTRIBUTES *pdmfa, char *szPath, char *szType,
                          HICON hicon)
{
    char szBuf[256];

    SetDlgItemText(hwnd, IDC_FOLDEREPROP_EDIT_TYPE, szType);
    SetDlgItemText(hwnd, IDC_FOLDEREPROP_EDIT_LOC,  szPath);

    ULARGE_INTEGER ulSize;
    ulSize.LowPart = pdmfa->SizeLow;
    ulSize.HighPart= pdmfa->SizeHigh;

    // UNDONE-ERR: Remove or fix these!
    SetDlgItemText(hwnd, IDC_FOLDEREPROP_EDIT_SIZE, "Size of all sub files");
    SetDlgItemText(hwnd, IDC_FOLDEREPROP_EDIT_SIZEONDISK, "File size on disk");

    SetDlgItemText(hwnd, IDC_FOLDEREPROP_EDIT_CONTAINS, "# sub files and folders");

    // File times
    GetTimeBuf(&pdmfa->CreationTime, szBuf);
    SetDlgItemText(hwnd, IDC_FOLDEREPROP_EDIT_CREATED, szBuf);

    SetDlgItemText(hwnd, IDC_FOLDEREPROP_EDIT_NAME, pdmfa->Name);

    if (pdmfa->Attributes & FILE_ATTRIBUTE_HIDDEN)
        SendMessage(GetDlgItem(hwnd, IDC_FOLDERPROP_ATTR_HIDDEN), BM_SETCHECK, BST_CHECKED, 0);
    else
        SendMessage(GetDlgItem(hwnd, IDC_FOLDERPROP_ATTR_HIDDEN), BM_SETCHECK, BST_UNCHECKED, 0);

    if (pdmfa->Attributes & FILE_ATTRIBUTE_READONLY)
        SendMessage(GetDlgItem(hwnd, IDC_FOLDERPROP_ATTR_RO), BM_SETCHECK, BST_CHECKED, 0);
    else
        SendMessage(GetDlgItem(hwnd, IDC_FOLDERPROP_ATTR_RO), BM_SETCHECK, BST_UNCHECKED, 0);

    SendMessage(GetDlgItem(hwnd, IDC_FOLDERPROP_ICON), STM_SETICON, (WPARAM)hicon, 0);

    if (!MyStrcmp(g_dmfa.Name, szPath))
    {
        // Root drive
        EnableWindow(GetDlgItem(hwnd, IDC_FOLDEREPROP_EDIT_NAME), false);
        EnableWindow(GetDlgItem(hwnd, IDC_FOLDERPROP_ATTR_HIDDEN), false);
        EnableWindow(GetDlgItem(hwnd, IDC_FOLDERPROP_ATTR_RO), false);
        ShowWindow(GetDlgItem(hwnd, IDC_FOLDEREPROP_EDIT_CREATED), false);
    }
}

void GetFolderProperties(DM_FILE_ATTRIBUTES *pdmfa, char *szPath, char *szType, HICON *phicon)
{
    char szFileName[MAX_PATH];
    bool fRoot = false, fThis = false;
    char *sz;
    char szFilePath[MAX_PATH];

    SHFILEINFO sfi;
	ZeroMemory( &sfi, sizeof(sfi) );
	DWORD flg = SHGFI_ICON | SHGFI_LARGEICON | SHGFI_USEFILEATTRIBUTES;
    // if g_iPopupFileItem == ITEM_NONE, then its 'this' dir
    if (g_iPopupFileItem == ITEM_NONE)
    {
        strcpy(szFileName, g_CurrentDir);
        strcpy(szPath, g_CurrentDir);
        if (MyStrlen(szPath) == 4)
            fRoot = true;
        else
            fRoot = false;
        fThis = true;
    }
    else
    {
        // Get file name from list view
	    ListView_GetItemText(listview.GetHwnd(), g_iPopupFileItem, COLUMN_NAME, szFileName, MAX_PATH);

        strcpy(szPath, g_CurrentDir);
        if (MyStrlen(szPath) > 4)
            szPath[MyStrlen(szPath)-1] = '\0';
    }

    if (fRoot)
    {
        // it's a root drive!
        strcpy(szType, "Xbox Drive");
    	SHGetFileInfo("C:\\", 0, &sfi, sizeof(sfi), flg );
        wsprintf(szFilePath, "%s%s", g_CurrentDir, szFileName);
    }
    else
    {
        strcpy(szType, "File Folder");
	    SHGetFileInfo(szPath, 0, &sfi, sizeof(sfi), flg );
        if (fThis)
        {   
            sz = strrchr(szFileName, '\\');
            if (sz)
                *sz = '\0';
            sz = strrchr(szPath, '\\');
            if (sz)
                *sz = '\0';

            sz = strrchr(szPath, '\\');
            if (sz == szPath + 3)
            {
                // First level folder - keep the \ on XE:\!
                *(sz+1) = '\0';
            }
            else
            {
                // Deeper folder.  Remove the slach
                *sz = '\0';
            }
            wsprintf(szFilePath, "%s", szFileName);
        }
        else
            wsprintf(szFilePath, "%s%s", g_CurrentDir, szFileName);
    }
    *phicon = sfi.hIcon;

    xbfu.GetFileAttributes(szFilePath, pdmfa);

    // Account for root drive
    if (fRoot)
        strcpy(pdmfa->Name, szFileName);
}

LRESULT CALLBACK FolderPropertiesDlg(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    static char szPath[MAX_PATH];
    char szType[256], szBuf[MAX_PATH], szOrig[MAX_PATH];
    TCITEM tie; 
    HICON hicon;
    bool fNewHidden, fNewReadOnly;
    bool fOldHidden, fOldReadOnly;

	switch(message)
	{
	case WM_INITDIALOG:
        // Set the initial values

        // Add 'general' tab
        tie.mask = TCIF_TEXT | TCIF_IMAGE; 
        tie.iImage = -1; 
        tie.pszText = "General"; 
 
        TabCtrl_InsertItem(GetDlgItem(hDlg, IDC_TAB), 0, &tie);
    
        GetFolderProperties(&g_dmfa, szPath, szType, &hicon);

        DrawFolderProperties(hDlg, &g_dmfa, szPath, szType, hicon);
//		CenterDialog(hDlg);
		return TRUE;

    case WM_COMMAND:
		switch(LOWORD(wParam))
		{
        case IDAPPLY:
		case IDOK:
            // Check to see if the user (a) changed the app name or (b) changed attribute
            // state -- if so, then make the modifications now.  
            fNewHidden   = SendMessage(GetDlgItem(hDlg, IDC_FOLDERPROP_ATTR_HIDDEN), BM_GETCHECK, 0, 0) == BST_CHECKED;
            fNewReadOnly = SendMessage(GetDlgItem(hDlg, IDC_FOLDERPROP_ATTR_RO),     BM_GETCHECK, 0, 0) == BST_CHECKED;
            fOldHidden   = g_dmfa.Attributes & FILE_ATTRIBUTE_HIDDEN   ? true : false;
            fOldReadOnly = g_dmfa.Attributes & FILE_ATTRIBUTE_READONLY ? true : false;

            GetDlgItemText(hDlg, IDC_FOLDEREPROP_EDIT_NAME, szBuf, MAX_PATH);

            // Determine the name of the file or folder being modified
            if (g_iPopupFileItem == -1)
            {
                // User clicked on white space - use current dir as the full pathname
                strcpy(szOrig, g_CurrentDir);
                
                // Remove the trailing '\'
                szOrig[strlen(szOrig) - 1] = '\0';
            }
            else
                wsprintf(szOrig, "%s%s", g_CurrentDir, g_dmfa.Name);

            if (MyStrcmp(g_dmfa.Name, szBuf))
            {
                char szNew[MAX_PATH];
                bool fRename = true;

                // Determine the new path
                if (g_iPopupFileItem == -1)
                {
                    // User clicked on white space - use current dir as the full pathname
                    strcpy(szNew, g_CurrentDir);
                
                    // Remove the trailing '\'
                    szNew[strlen(szNew) - 1] = '\0';

                    // Remove the name of the current dir from the fullpath
                    *(strrchr(szNew, '\\') + 1) = '\0';

                    // Add the *new* name of the current dir to the fullpath
                    strcat(szNew, szBuf);
                }
                else
                    wsprintf(szNew, "%s%s", g_CurrentDir, szBuf);

                // User changed the name.  Read only? 
                if (g_dmfa.Attributes & FILE_ATTRIBUTE_READONLY)
                {
                    sprintf(szType, "Are you sure you want to rename the read-only folder '%s' to '%s'?", g_dmfa.Name, szBuf);
                    if (MessageBox(hDlg, szType, "Confirm Folder Rename", MB_ICONWARNING | MB_YESNO) == IDYES)
                    {
                        // Remove the read only bit
                        xbfu.RemoveAttribute(szOrig, FILE_ATTRIBUTE_READONLY, true);
                        xbfu.Ren(szOrig, szNew);
                        xbfu.SetAttribute(szNew, FILE_ATTRIBUTE_READONLY, true);
                    }
                    else
                    {
                        SetDlgItemText(hDlg, IDC_FOLDEREPROP_EDIT_NAME, g_dmfa.Name);
                        fRename = false;
                    }
                }
                else
                    xbfu.Ren(szOrig, szNew);
                if (fRename)
                {
                    // if the user changed the name of the current directory (right-clicked on whitespace),
                    // then we need to change g_CurrentDir now
                    if (g_iPopupFileItem == -1)
                    {
                        strcpy(g_CurrentDir, szNew);
                        strcat(g_CurrentDir, "\\");
                    }

                    strcpy(g_dmfa.Name, szBuf);
                    listview.SortListView(-1, false);
                }
            }

            if ((fNewHidden && !fOldHidden) || (fOldHidden && !fNewHidden) ||
                (fNewReadOnly && !fOldReadOnly) || (fOldReadOnly && !fNewReadOnly))
            {
                // user swapped the hidden and/or readonly states
                g_dmfa.Attributes = (fNewHidden   ? FILE_ATTRIBUTE_HIDDEN   : 0) |
                                  (fNewReadOnly ? FILE_ATTRIBUTE_READONLY : 0);

                xbfu.SetFileAttributes(szOrig, &g_dmfa);
                listview.SortListView(-1, false);
            }

            if (LOWORD(wParam) == IDOK)
            {
                // We're done
			    EndDialog(hDlg, TRUE);
			    return TRUE;
            }
               
            break;

        case IDCANCEL:
			EndDialog(hDlg, TRUE);
			return TRUE;
		}
		break;
	}
	return FALSE;
}

void FormatSize(ULARGE_INTEGER ulSize, char *szBuf, bool fBytes)
{
    if (ulSize.QuadPart < 1024)
        sprintf(szBuf, "%d bytes", ulSize.LowPart);
    else if (ulSize.QuadPart / 1024 < 1024)
        sprintf(szBuf, "%.2f KB", ((float)(ulSize.QuadPart)) / 1024.0);
    else if (ulSize.QuadPart / 1024 / 1024< 1024)
        sprintf(szBuf, "%.2f MB", ((float)(ulSize.QuadPart/1024)) / 1024.0);
    else 
        sprintf(szBuf, "%.2f GB",((float)(ulSize.QuadPart/1024/1024)) / 1024.0);

    if (fBytes)
    {
        char szTemp[100];
        wsprintf(szTemp, "%s (%s bytes)", szBuf, FormatBigNumber(ulSize.QuadPart));
        wsprintf(szBuf, szTemp);
    }
}

void DrawFileProperties(HWND hwnd, DM_FILE_ATTRIBUTES *pdmfa, char *szPath, char *szType,
                        HICON hicon)
{
    char szBuf[256];

    SetDlgItemText(hwnd, IDC_FILEPROP_EDIT_TYPE, szType);
    SetDlgItemText(hwnd, IDC_FILEPROP_EDIT_LOC,  szPath);

    ULARGE_INTEGER ulSize;
    ulSize.LowPart = pdmfa->SizeLow;
    ulSize.HighPart= pdmfa->SizeHigh;

    FormatSize(ulSize, szBuf, true);
    SetDlgItemText(hwnd, IDC_FILEPROP_EDIT_SIZE, szBuf);
    
#if 0
    // UNDONE-ERR: Assuming sector size of 4096 bytes.  Verify and change if necessary!
#define SECTOR_SIZE 4096
    ulSize.QuadPart = (ulSize.QuadPart / SECTOR_SIZE + 1) * SECTOR_SIZE;

    FormatSize(ulSize, szBuf, true);
    SetDlgItemText(hwnd, IDC_FILEPROP_EDIT_SIZEONDISK, szBuf);
#endif

    // File times
    GetTimeBuf(&pdmfa->CreationTime, szBuf);
    SetDlgItemText(hwnd, IDC_FILEPROP_EDIT_CREATED, szBuf);
    GetTimeBuf(&pdmfa->ChangeTime, szBuf);
    SetDlgItemText(hwnd, IDC_FILEPROP_EDIT_MODIFIED, szBuf);
    SetDlgItemText(hwnd, IDC_FILEPROP_EDIT_ACCESSED, "file accessed");

    SetDlgItemText(hwnd, IDC_FILEPROP_EDIT_NAME, pdmfa->Name);

    if (pdmfa->Attributes & FILE_ATTRIBUTE_HIDDEN)
        SendMessage(GetDlgItem(hwnd, IDC_FILEPROP_ATTR_HIDDEN), BM_SETCHECK, BST_CHECKED, 0);
    else
        SendMessage(GetDlgItem(hwnd, IDC_FILEPROP_ATTR_HIDDEN), BM_SETCHECK, BST_UNCHECKED, 0);

    if (pdmfa->Attributes & FILE_ATTRIBUTE_READONLY)
        SendMessage(GetDlgItem(hwnd, IDC_FILEPROP_ATTR_RO), BM_SETCHECK, BST_CHECKED, 0);
    else
        SendMessage(GetDlgItem(hwnd, IDC_FILEPROP_ATTR_RO), BM_SETCHECK, BST_UNCHECKED, 0);

    SendMessage(GetDlgItem(hwnd, IDC_FILEPROP_ICON), STM_SETICON, (WPARAM)hicon, 0);
}

void GetFileProperties(DM_FILE_ATTRIBUTES *pdmfa, char *szPath, char *szType, HICON *phicon)
{
    char szFileName[MAX_PATH];
    char szFilePath[MAX_PATH];

    // Get file name from list view
	ListView_GetItemText(listview.GetHwnd(), g_iPopupFileItem, COLUMN_TYPE, szType, MAX_PATH);
	ListView_GetItemText(listview.GetHwnd(), g_iPopupFileItem, COLUMN_NAME, szFileName, MAX_PATH);

    strcpy(szPath, g_CurrentDir);
    if (MyStrlen(szPath) > 4)
        szPath[MyStrlen(szPath)-1] = '\0';
    strcpy(szFilePath, g_CurrentDir);
    strcat(szFilePath, szFileName);

	SHFILEINFO sfi;
	ZeroMemory( &sfi, sizeof(sfi) );
	DWORD flg = SHGFI_ICON | SHGFI_LARGEICON | SHGFI_USEFILEATTRIBUTES;
	SHGetFileInfo(szFilePath, 0, &sfi, sizeof(sfi), flg );
    *phicon = sfi.hIcon;

    xbfu.GetFileAttributes(szFilePath, pdmfa);
}

LRESULT CALLBACK FilePropertiesDlg(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    static char szPath[MAX_PATH];
    char szType[256], szBuf[MAX_PATH];
    TCITEM tie; 
    HICON hicon;
    bool fNewHidden, fNewReadOnly;
    bool fOldHidden, fOldReadOnly;

	switch(message)
	{
	case WM_INITDIALOG:
        // Set the initial values
        // Add 'general' tab
        tie.mask = TCIF_TEXT | TCIF_IMAGE; 
        tie.iImage = -1; 
        tie.pszText = &szBuf[0];
        LoadString(hInst, IDS_GENERAL, szBuf, MAX_PATH);

        TabCtrl_InsertItem(GetDlgItem(hDlg, IDC_TAB), 0, &tie);

        GetFileProperties(&g_dmfa, szPath, szType, &hicon);

        DrawFileProperties(hDlg, &g_dmfa, szPath, szType, hicon);
        
//		CenterDialog(hDlg);
		return TRUE;

    case WM_COMMAND:
		switch(LOWORD(wParam))
		{
        case IDAPPLY:
		case IDOK:
            // Check to see if the user (a) changed the app name or (b) changed attribute
            // state -- if so, then make the modifications now.  
            fNewHidden   = SendMessage(GetDlgItem(hDlg, IDC_FILEPROP_ATTR_HIDDEN), BM_GETCHECK, 0, 0) == BST_CHECKED;
            fNewReadOnly = SendMessage(GetDlgItem(hDlg, IDC_FILEPROP_ATTR_RO),     BM_GETCHECK, 0, 0) == BST_CHECKED;
            fOldHidden   = g_dmfa.Attributes & FILE_ATTRIBUTE_HIDDEN   ? true : false;
            fOldReadOnly = g_dmfa.Attributes & FILE_ATTRIBUTE_READONLY ? true : false;

            GetDlgItemText(hDlg, IDC_FILEPROP_EDIT_NAME, szBuf, MAX_PATH);
            if (MyStrcmp(g_dmfa.Name, szBuf))
            {
                char szOrig[MAX_PATH], szNew[MAX_PATH];
                sprintf(szOrig, "%s%s", g_CurrentDir, g_dmfa.Name);
                sprintf(szNew, "%s%s", g_CurrentDir, szBuf);
                bool fRename = true;

                // User changed the name.  Read only? 
                if (g_dmfa.Attributes & FILE_ATTRIBUTE_READONLY)
                {
                    sprintf(szType, "Are you sure you want to rename the read-only file '%s' to '%s'?", g_dmfa.Name, szBuf);
                    if (MessageBox(hDlg, szType, "Confirm File Rename", MB_ICONWARNING | MB_YESNO) == IDYES)
                    {
                        // Remove the read only bit
                        xbfu.RemoveAttribute(szOrig, FILE_ATTRIBUTE_READONLY, true);
                        xbfu.Ren(szOrig, szNew);
                        xbfu.SetAttribute(szNew, FILE_ATTRIBUTE_READONLY, true);
                    }
                    else
                    {
                        SetDlgItemText(hDlg, IDC_FILEPROP_EDIT_NAME, g_dmfa.Name);
                        fRename = false;
                    }
                }
                else
                    xbfu.Ren(szOrig, szNew);
                if (fRename)
                {
                    strcpy(g_dmfa.Name, szBuf);
                    listview.SortListView(-1, false);
                }
            }

            if ((fNewHidden && !fOldHidden) || (fOldHidden && !fNewHidden) ||
                (fNewReadOnly && !fOldReadOnly) || (fOldReadOnly && !fNewReadOnly))
            {
                // user swapped the hidden and/or readonly states
                g_dmfa.Attributes = (fNewHidden   ? FILE_ATTRIBUTE_HIDDEN   : 0) |
                                  (fNewReadOnly ? FILE_ATTRIBUTE_READONLY : 0);

                wsprintf(szBuf, "%s%s", g_CurrentDir, g_dmfa.Name);
                xbfu.SetFileAttributes(szBuf, &g_dmfa);
                listview.SortListView(-1, false);
            }

            if (LOWORD(wParam) == IDOK)
            {
                // We're done
			    EndDialog(hDlg, TRUE);
			    return TRUE;
            }
            break;

		case IDCANCEL:
			EndDialog(hDlg, TRUE);
			return TRUE;
		}
		break;
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\CXboxConnection.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     
// Contents: 
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
extern bool g_fForceWaitCursor;
HANDLE g_hA, g_hB;

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  ConnectThread
// Purpose:   Thread that handles connecting to the user's Xbox.
// Arguments: pvUnused          -- Ignore.
// Returns:   '0' if successfully connected; '-1' otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
DWORD WINAPI ConnectThread(LPVOID pvArg)
{
    while (true)
    {
        WaitForSingleObject(g_hA, INFINITE);
        if (WaitForSingleObject(g_hB, 2000) == WAIT_TIMEOUT)
            SetCursor(LoadCursor(NULL, IDC_WAIT));
    }

    return 0;
}

CXboxConnection::CXboxConnection()
{
    g_hA = CreateEvent(NULL, false, false, NULL);
    g_hB = CreateEvent(NULL, true, false, NULL);

    // Create the connection thread. 
    m_hthreadConnect = CreateThread(NULL, 0, ConnectThread, this, 0, NULL);
}

CXboxConnection::~CXboxConnection()
{
    CloseHandle(g_hA);
    CloseHandle(g_hB);
    
    // Close off our Connect thread
    CloseHandle(m_hthreadConnect);
}

void CXboxConnection::Before()
{
    DmUseSharedConnection(TRUE);
    ResetEvent(g_hB);
    SetEvent(g_hA);
}

void CXboxConnection::After()
{
    DmUseSharedConnection(FALSE);
    SetEvent(g_hB);
    if (!g_fForceWaitCursor)
        SetCursor(LoadCursor(NULL, IDC_ARROW));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\CXboxConnection.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     cxboxconnection.h
// Contents: UNDONE-WARN: Add file description
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ CLASS DECLARATIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

class CXboxConnection
{
public:
    CXboxConnection();
    ~CXboxConnection();
    void Before();
    void After();
    HANDLE m_hthreadConnect;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\DPDA.h ===
//******************************************************************************************* 
// 
// Filename : Dpda.h 
// 
//Definitions of DPA routines 
// 
// Copyright 1994 - 1998 Microsoft Corporation. All rights reserved 
// 
//*******************************************************************************************  
#ifndef _DPDA_H_ 
#define _DPDA_H_   
#ifdef __cplusplus 
extern "C" 
{ 
#endif  

// Dynamic pointer array  
typedef struct _DPA * HDPA;
HDPA   DPA_Create(int cItemGrow);
HDPA   DPA_CreateEx(int cpGrow, HANDLE hheap);
BOOL   DPA_Destroy(HDPA hdpa);
HDPA   DPA_Clone(HDPA hdpa, HDPA hdpaNew);
void * DPA_GetPtr(HDPA hdpa, int i);
int    DPA_GetPtrIndex(HDPA hdpa, LPVOID p);
BOOL   DPA_Grow(HDPA pdpa, int cp);
BOOL   DPA_SetPtr(HDPA hdpa, int i, LPVOID p);
int    DPA_InsertPtr(HDPA hdpa, int i, LPVOID p);
void * DPA_DeletePtr(HDPA hdpa, int i);
BOOL   DPA_DeleteAllPtrs(HDPA hdpa);
#define       DPA_GetPtrCount(hdpa)   (*(int *)(hdpa))  
#define DPA_GetPtrPtr(hdpa)     (*((LPVOID * *)((BYTE *)(hdpa) + sizeof(int))))  
#define DPA_FastGetPtr(hdpa, i) (DPA_GetPtrPtr(hdpa)[i])   

typedef int (CALLBACK *PFNDPACOMPARE)(LPVOID p1, LPVOID p2, LPARAM lParam);
BOOL   DPA_Sort(HDPA hdpa, PFNDPACOMPARE pfnCompare, LPARAM lParam);
typedef struct _DSA * HDSA;

// Search array.  If DPAS_SORTED, then array is assumed to be sorted  
// according to pfnCompare, and binary search algorithm is used.  
// Otherwise, linear search is used.  
//  
// Searching starts at iStart (-1 to start search at beginning).  
//  
// DPAS_INSERTBEFORE/AFTER govern what happens if an exact match is not  
// found.  If neither are specified, this function returns -1 if no exact  
// match is found.  Otherwise, the index of the item before or after the  
// closest (including exact) match is returned.  
//  
// Search option flags  
//  
#define DPAS_SORTED             0x0001
#define DPAS_INSERTBEFORE       0x0002  
#define DPAS_INSERTAFTER        0x0004   

int DPA_Search(HDPA hdpa, LPVOID pFind, int iStart,                        PFNDPACOMPARE pfnCompare,                        LPARAM lParam, UINT options);  

#ifdef __cplusplus
} 
#endif  
#endif // _DPDA_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\CXboxStream.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     CXboxStream.h
// Contents: UNDONE-WARN: Add file description
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ CLASS DECLARATIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

class CXboxStream : public IStream
{
public:
    CXboxStream(char *szFile, bool fCut);
    ~CXboxStream();

    // IUnknown
    STDMETHODIMP QueryInterface (REFIID iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IStream
    STDMETHODIMP Read(void *pv, ULONG cb, ULONG *pcbRead);     
    STDMETHODIMP Write(VOID const *pv, ULONG cb, ULONG *pcbWritten);
    STDMETHODIMP Seek(LARGE_INTEGER dbMove, DWORD dwOrigin, ULARGE_INTEGER *pbNewPosition);
    STDMETHODIMP SetSize(ULARGE_INTEGER cbNewSize);
    STDMETHODIMP CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead,
                        ULARGE_INTEGER *pcbWritten);
    STDMETHODIMP Commit(DWORD grfCommitFlags);
    STDMETHODIMP Revert();
    STDMETHODIMP LockRegion(ULARGE_INTEGER bOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER bOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHODIMP Stat(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHODIMP Clone(IStream **ppstm);

protected:

    bool m_fCut;
    char m_szFile[MAX_PATH];
    long m_cRef;
    HANDLE m_hfile;

    char m_szTempPathFileName[MAX_PATH];
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\DPA.cpp ===
#include "stdafx.h"
#include "dpda.h" 
#include <assert.h>
  
#ifdef _DEBUG 
#define DPA_MAGIC   ('P' | ('A' << 256)) 
#define IsDPA(pdpa) ((pdpa) && (pdpa)->magic == DPA_MAGIC) 
#else 
#define IsDPA(pdsa) 

#endif   
#define ControlAlloc(hheap, cb)       HeapAlloc((hheap), HEAP_ZERO_MEMORY, (cb)) 
#define ControlReAlloc(hheap, pb, cb) HeapReAlloc((hheap), HEAP_ZERO_MEMORY, (pb),(cb)) 
#define ControlFree(hheap, pb)        HeapFree((hheap), 0, (pb)) 
#define ControlSize(hheap, pb)        HeapSize((hheap), 0, (LPCVOID)(pb))  
#define hmemcpy memcpy    
typedef struct {     
    void **pp;
    PFNDPACOMPARE pfnCmp;
    LPARAM lParam;
    int cp;
    void **ppT;
 } SORTPARAMS;

  BOOL DPA_MergeSort(SORTPARAMS * psp);
  void DPA_MergeSort2(SORTPARAMS * psp, int iFirst, int cItems);    

//================== Dynamic pointer array implementation ===========  
typedef struct _DPA
 { 
    // NOTE: The following two fields MUST be defined in this order, at 
    // the beginning of the structure in order for the macro APIs to work. 
    //     
    int cp;
    void **pp;
    HANDLE hheap;        
    // Heap to allocate from if NULL use shared
    int cpAlloc;
    int cpGrow; 
#ifdef DEBUG   
    UINT magic; 
#endif 
} DPA;

HANDLE g_hSharedHeap = NULL;
void * Alloc(long cb) 
{     
    // I will assume that this is the only one that needs the checks to     
    // see if the heap has been previously created or not   
   if (g_hSharedHeap == NULL)     
   {
        g_hSharedHeap = HeapCreate(0, 1, 0);          
        // If still NULL we have problems!   
        if (g_hSharedHeap == NULL)       
            return(NULL);     
   }
   return HeapAlloc(g_hSharedHeap, HEAP_ZERO_MEMORY, cb);
}

void * ReAlloc(void * pb, long cb) 
{
    if (pb == NULL)         
        return Alloc(cb);     
    
    return HeapReAlloc(g_hSharedHeap, HEAP_ZERO_MEMORY, pb, cb); 
}

BOOL Free(void * pb)
{     
    return HeapFree(g_hSharedHeap, 0, pb); 
}

DWORD GetSize(void * pb) 
{  
   return HeapSize(g_hSharedHeap, 0, pb); 
}   

HDPA DPA_Create(int cpGrow) 
{     
    HDPA pdpa = (HDPA)Alloc(sizeof(DPA));     
    if (pdpa)    
    {         
        pdpa->cp = 0;         
        pdpa->cpAlloc = 0;         
        pdpa->cpGrow = (cpGrow < 8 ? 8 : cpGrow);         
        pdpa->pp = NULL;         
        pdpa->hheap = g_hSharedHeap;   
   
        // Defaults to use shared one (for now...) 
#ifdef DEBUG         
        pdpa->magic = DPA_MAGIC; 
#endif     
    }     
    return pdpa; 
}

// Should nuke the standard DPA above...
HDPA DPA_CreateEx(int cpGrow, HANDLE hheap) 
{  
   HDPA pdpa;     
   if (hheap == NULL)     
   {      
       pdpa = (HDPA)Alloc(sizeof(DPA));  
       hheap = g_hSharedHeap; 
   }    
   else   
       pdpa = (HDPA)ControlAlloc(hheap, sizeof(DPA));  
   if (pdpa)  
   {        
       pdpa->cp = 0;    
       pdpa->cpAlloc = 0;       
       pdpa->cpGrow = (cpGrow < 8 ? 8 : cpGrow);    
       pdpa->pp = NULL;       
       pdpa->hheap = hheap; 
#ifdef DEBUG    
       pdpa->magic = DPA_MAGIC; 
#endif   
   }   
   return pdpa; 
}  

BOOL DPA_Destroy(HDPA pdpa) 
{     
   //assert(IsDPA(pdpa));  
    if (pdpa == NULL)    // allow NULL for low memory cases, still assert        
        return TRUE;      
    assert (pdpa->hheap);  

#ifdef DEBUG    
    pdpa->cp = 0;  
    pdpa->cpAlloc = 0;
    pdpa->magic = 0; 
#endif    
    if (pdpa->pp && !ControlFree(pdpa->hheap, pdpa->pp))      
        return FALSE;   
    return ControlFree(pdpa->hheap, pdpa);
}

HDPA DPA_Clone(HDPA pdpa, HDPA pdpaNew)
{
    BOOL fAlloc = FALSE;   
    if (!pdpaNew)   
    {         
        pdpaNew = DPA_CreateEx(pdpa->cpGrow, pdpa->hheap);  
        if (!pdpaNew)        
            return NULL;       
        fAlloc = TRUE;    
    }
    
    if (!DPA_Grow(pdpaNew, pdpa->cpAlloc)) 
    {
        if (!fAlloc)    
            DPA_Destroy(pdpaNew); 
        return NULL;     
    }
    pdpaNew->cp = pdpa->cp;   
    hmemcpy(pdpaNew->pp, pdpa->pp, pdpa->cp * sizeof(void *));  
    return pdpaNew;
 }  

void * DPA_GetPtr(HDPA pdpa, int index) 
{ 
     //    assert(IsDPA(pdpa));   
    if (index < 0 || index >= pdpa->cp)         
        return NULL;    
    return pdpa->pp[index]; 
}  

int DPA_GetPtrIndex(HDPA pdpa, void * p) 
{   
    void **pp;
    void **ppMax;  
    if (pdpa->pp)   
    {      
        pp = pdpa->pp;   
        ppMax = pp + pdpa->cp;    
        for ( ; pp < ppMax; pp++)     
        {            
            if (*pp == p)     
                return (pp - pdpa->pp); 
        }  
    }  
    return -1;
}

BOOL DPA_Grow(HDPA pdpa, int cpAlloc)
{   
    if (cpAlloc > pdpa->cpAlloc) 
    {     
        void **ppNew;   
        cpAlloc = ((cpAlloc + pdpa->cpGrow - 1) / pdpa->cpGrow) * pdpa->cpGrow;       
        if (pdpa->pp)       
            ppNew = (void * *)ControlReAlloc(pdpa->hheap, pdpa->pp, cpAlloc * sizeof(void *));       
        else         
            ppNew = (void * *)ControlAlloc(pdpa->hheap, cpAlloc * sizeof(void *));        
        if (!ppNew)        
            return FALSE;      
        pdpa->pp = ppNew;   
        pdpa->cpAlloc = cpAlloc; 
    }   
    return TRUE; 
}  

BOOL DPA_SetPtr(HDPA pdpa, int index, void * p) 
{    
    if (index < 0)   
    {         
        // DebugMsg(DM_ERROR, "DPA: Invalid index: %d", index); 
        return FALSE;   
    }    
    if (index >= pdpa->cp)  
    {      
        if (!DPA_Grow(pdpa, index + 1))  
            return FALSE;       
        pdpa->cp = index + 1;    
    }     
    pdpa->pp[index] = p;   
    return TRUE;
} 

int DPA_InsertPtr(HDPA pdpa, int index, void * p) 
{
     if (index < 0) 
     {   
         return -1;    
     }   
     if (index > pdpa->cp)   
         index = pdpa->cp;      
     // Make sure we have room for one more item     
     //     
     if (pdpa->cp + 1 > pdpa->cpAlloc)   
     {  
         if (!DPA_Grow(pdpa, pdpa->cp + 1))   
             return -1;    
     }      
     // If we are inserting, we need to slide everybody up     
     //   
     if (index < pdpa->cp)   
     {    
         hmemcpy(&pdpa->pp[index + 1], &pdpa->pp[index], (pdpa->cp - index) * sizeof(void *)); 
     }     
 
     pdpa->pp[index] = p;
     pdpa->cp++;   
     return index; 
}  

void * DPA_DeletePtr(HDPA pdpa, int index)
{   
    void * p;  
    //    assert(IsDPA(pdpa));  
    if (index < 0 || index >= pdpa->cp) 
    {      
        //   DebugMsg(DM_ERROR, "DPA: Invalid index: %d", index);    
        return NULL;
    }   
    p = pdpa->pp[index];
    if (index < pdpa->cp - 1)
    {       
        hmemcpy(&pdpa->pp[index], &pdpa->pp[index + 1], (pdpa->cp - (index + 1)) * sizeof(void *));     
    }     
    pdpa->cp--;  
    if (pdpa->cpAlloc - pdpa->cp > pdpa->cpGrow)   
    {     
        void **ppNew;   
        ppNew = (void**)ControlReAlloc(pdpa->hheap, pdpa->pp, (pdpa->cpAlloc - pdpa->cpGrow) * sizeof(void *));    
        assert(ppNew);  
        pdpa->pp = ppNew;   
        pdpa->cpAlloc -= pdpa->cpGrow;  
   }  
    return p;
 } 

 BOOL DPA_DeleteAllPtrs(HDPA pdpa) 
 {    
     if (pdpa->pp && !ControlFree(pdpa->hheap, pdpa->pp))   
         return FALSE;
     pdpa->pp = NULL;   
     pdpa->cp = pdpa->cpAlloc = 0;   
     return TRUE; 
 }  
BOOL DPA_Sort(HDPA pdpa, PFNDPACOMPARE pfnCmp, LPARAM lParam)
 {   
    SORTPARAMS sp;  
    sp.cp = pdpa->cp;     
    sp.pp = pdpa->pp;   
    sp.pfnCmp = pfnCmp;   
    sp.lParam = lParam;      
    return DPA_MergeSort(&sp);
 }  
#define SortCompare(psp, pp1, i1, pp2, i2) \
 (psp->pfnCmp(pp1[i1], pp2[i2], psp->lParam))  
// 
//  This function merges two sorted lists and makes one sorted list. 
//   psp->pp[iFirst, iFirst+cItes/2-1], psp->pp[iFirst+cItems/2, iFirst+cItems-1] 
// 
void DPA_MergeThem(SORTPARAMS * psp, int iFirst, int cItems) 
{    
    //     
    // Notes:     
    //  This function is separated from DPA_MergeSort2() to avoid comsuming     
    // stack variables. Never inline this.     
    //   
    int cHalf = cItems/2;     
    int iIn1, iIn2, iOut; 
    LPVOID * ppvSrc = &psp->pp[iFirst];      
    // Copy the first part to temp storage so we can write directly into     
    // the final buffer.  Note that this takes at most psp->cp/2 DWORD's    
    hmemcpy(psp->ppT, ppvSrc, cHalf*sizeof(LPVOID));   
    for (iIn1=0, iIn2=cHalf, iOut=0;;)   
    {
        if (SortCompare(psp, psp->ppT, iIn1, ppvSrc, iIn2) <= 0)
        { 
            ppvSrc[iOut++] = psp->ppT[iIn1++];    
            if (iIn1==cHalf)
            { 
                // We used up the first half; the rest of the second half 
                // should already be in place 
                break;  
            }
        }
        else
        { 
            ppvSrc[iOut++] = ppvSrc[iIn2++];   
            if (iIn2==cItems) 
            { 
               // We used up the second half; copy the rest of the first half 
               // into place
                hmemcpy(&ppvSrc[iOut], &psp->ppT[iIn1], (cItems-iOut)*sizeof(LPVOID));
                break;   
            } 
        } 
    } 
}  

// 
//  This function sorts a give list (psp->pp[iFirst,iFirst-cItems-1]). 
//

 void DPA_MergeSort2(SORTPARAMS * psp, int iFirst, int cItems) {     
   //     
   // Notes:     
   //   This function is recursively called. Therefore, we should minimize     

   //  the number of local variables and parameters. At this point, we     
   //  use one local variable and three parameters.     
   //    
     int cHalf;   
     switch(cItems)     
    {   
     case 1: return;
     case 2: 
        // Swap them, if they are out of order. 
         if (SortCompare(psp, psp->pp, iFirst, psp->pp, iFirst+1) > 0)
         {   
             psp->ppT[0] = psp->pp[iFirst]; 
             psp->pp[iFirst] = psp->pp[iFirst+1];    
             psp->pp[iFirst+1] = psp->ppT[0];
         } 
         break;    
     default: 
         cHalf = cItems/2; 
        // Sort each half
         DPA_MergeSort2(psp, iFirst, cHalf); 
         DPA_MergeSort2(psp, iFirst+cHalf, cItems-cHalf); 
        // Then, merge them. 
         DPA_MergeThem(psp, iFirst, cItems); 
         break;  
     }
 }  
 
BOOL DPA_MergeSort(SORTPARAMS * psp) 
{  
    if (psp->cp==0) 
       return TRUE;      
   // Note that we divide by 2 below; we want to round down   
   psp->ppT = (void**)LocalAlloc(LPTR, psp->cp/2 * sizeof(LPVOID)); 
   if (!psp->ppT) return FALSE;   
   DPA_MergeSort2(psp, 0, psp->cp);   
   LocalFree(psp->ppT);  
   return TRUE; 

}  
// Search function 
//
int DPA_Search(HDPA pdpa, void * pFind, int iStart,             
        PFNDPACOMPARE pfnCompare, LPARAM lParam, UINT options) 
{  
    int cp = DPA_GetPtrCount(pdpa);     
    assert(pfnCompare);   
    assert(0 <= iStart);      

   // Only allow these wierd flags if the list is sorted  
    assert((options & DPAS_SORTED) || !(options & (DPAS_INSERTBEFORE | DPAS_INSERTAFTER)));  
    if (!(options & DPAS_SORTED))  
    {         
        // Not sorted: do lisearch.       
        int i;     
        for (i = iStart; i < cp; i++)   
        {        
            if (0 == pfnCompare(pFind, DPA_FastGetPtr(pdpa, i), lParam))     
                return i;  
        }      
        return -1;   
    }   
    else     
    {         
        // Search the array using binary search.  If several adjacent          
        // elements match the target element, the index of the first         
        // matching element is returned.  
        int iRet = -1;      
        // assume no match   
        BOOL bFound = FALSE;  
        int nCmp = 0;      
        int iLow = 0;       
        // Don't bother using iStart for binary search 
        int iMid = 0;      
        int iHigh = cp - 1;          
        // (OK for cp == 0)    
        while (iLow <= iHigh)   
        {          
            iMid = (iLow + iHigh) / 2;        
            nCmp = pfnCompare(pFind, DPA_FastGetPtr(pdpa, iMid), lParam);       
            if (0 > nCmp)   
                iHigh = iMid - 1;       
            // First is smaller      
            else if (0 < nCmp)    
                iLow = iMid + 1;        
            // First is larger 
            else         
            {                 
                // Match; search back for first match        
                bFound = TRUE;     
                while (0 < iMid)                 
                {
                    if (0 != pfnCompare(pFind, DPA_FastGetPtr(pdpa, iMid-1), lParam))   
                        break;
                    else     
                        iMid--;   
                }           
                break;     
            }         
        }   
        if (bFound)  
        {       
            assert(0 <= iMid);   
            iRet = iMid;       
        }          
        // Did the search fail AND         
        // is one of the strange search flags set?   
        if (!bFound && (options & (DPAS_INSERTAFTER | DPAS_INSERTBEFORE)))      
        {            
            // Yes; return the index where the target should be inserted             
            // if not found       
            if (0 < nCmp)       
                // First is larger           
                iRet = iLow;     
            else 
                iRet = iMid;             
            // (We don't distinguish between the two flags anymore)   
        }       
        else if ( !(options & (DPAS_INSERTAFTER | DPAS_INSERTBEFORE)) )    
        {             
            // Sanity check with lisearch       
            assert(DPA_Search(pdpa, pFind, iStart, pfnCompare, lParam, options & ~DPAS_SORTED) == iRet);         
        }
        return iRet;     
    } 
}  

//=========================================================================== 
// 
// String ptr management routines 
// 
// Copy as much of *psz to *pszBuf as will fit 
// 
int Str_GetPtr(LPCSTR psz, LPSTR pszBuf, int cchBuf)
{ 
    int cch = 0;      
    // if pszBuf is NULL, just return length of string.     
    //    
    if (!pszBuf && psz)       
        return MyStrlen(psz);   
    if (cchBuf)
    {         
        if (psz) 
        {           
            cch = MyStrlen(psz);    
            if (cch > cchBuf - 1)           
                cch = cchBuf - 1;    
            hmemcpy(pszBuf, psz, cch);  
        }  
        pszBuf[cch] = 0; 
    }   
    return cch; 
}

BOOL Str_Set(LPSTR *ppsz, LPCSTR psz) 
{ 
    if (!psz) 
    {        
        if (*ppsz)      
        {        
            LocalFree(*ppsz); 
            *ppsz = NULL;      
        } 
    }    
    else  
    { 
        LPSTR pszNew;
        UINT cbSize = MyStrlen(psz) + 1; 
        if (*ppsz)   
            pszNew = (char*)LocalReAlloc(*ppsz, cbSize, LMEM_MOVEABLE | LMEM_ZEROINIT);
        else    
            pszNew = (char*)LocalAlloc(LPTR, cbSize);   
        if (!pszNew)  
            return FALSE;   
       lstrcpy(pszNew, psz);  
       *ppsz = pszNew;   
    }    
    return TRUE; 
}  
// Set *ppsz to a copy of psz, reallocing as needed 
//

BOOL Str_SetPtr(LPSTR * ppsz, LPCSTR psz) 
{    
    if (!psz)  
    {        
        if (*ppsz)  
        {          
            Free(*ppsz);   
            *ppsz = NULL;      
       }    
     }   
    else    
    {    
        LPSTR pszNew = (LPSTR)ReAlloc(*ppsz, MyStrlen(psz) + 1);
        if (!pszNew)        
            return FALSE;    
        lstrcpy(pszNew, psz);   
        *ppsz = pszNew;  
   }    
    return TRUE;
 }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\DlgProcs.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     DlgProcs.cpp
// Contents: Contains Dialog procedures for various dialogs 
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void PromoteWindow(HWND hwnd)
{
    SetForegroundWindow(hwnd);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  AboutDlgProc
// Purpose:   Message handler for About dialog. This function is automatically called by Windows
//            whenever a message needs to be sent to the dialog box (ie 'paint', 'move', etc).
// Arguments: hwnd          -- Handle to the Dialog box's window
//            message       -- The message sent to the dialog box
//            wParam        -- A message parameter.
//            lParam        -- Another message parameter
// Return:    nonzero if we processed the message
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LRESULT CALLBACK AboutDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch(message)
	{
	case WM_INITDIALOG:
        g_progress.SetError();
		return TRUE;
        
	case WM_COMMAND:
		switch(LOWORD(wParam))
		{
		case IDOK:
            // User clicked the 'OK' button; shut down the dialog box.
			EndDialog(hwnd, TRUE);
            g_progress.ClearError();
			return TRUE;
        }
	}
	return FALSE;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  ConfirmDeleteFolderDlg
// Purpose:   Message handler for the 'Confirm folder delete' dialog. This function is
//            automatically called by Windows whenever a message needs to be sent to the dialog box
//            (ie 'paint', 'move', etc).
// Arguments: hwnd          -- Handle to the Dialog box's window
//            message       -- The message sent to the dialog box
//            wParam        -- A message parameter.
//            lParam        -- Another message parameter
// Return:    nonzero if we processed the message
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LRESULT CALLBACK ConfirmDeleteFolderDlg(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    TCHAR szBuf[MAX_PATH];
    TCHAR szBuf2[MAX_PATH];

	switch(message)
	{
	case WM_INITDIALOG:
        g_progress.SetError();
        PromoteWindow(hwnd);
        LoadString(hInst, IDS_CONFIRM_RO_FOLDER, szBuf, MAX_PATH);
        wsprintf(szBuf2, szBuf, g_szDelFile);
        SetDlgItemText(hwnd, IDC_FOL_TEXT, szBuf2);
		return TRUE;
        
	case WM_COMMAND:
		EndDialog(hwnd, LOWORD(wParam));
        g_progress.ClearError();
		return TRUE;
	}
	return FALSE;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  ConfirmDeleteFileDlg
// Purpose:   Message handler for the 'Confirm file delete' dialog. This function is automatically
//            called by Windows whenever a message needs to be sent to the dialog box (ie 'paint',
//            'move', etc).
// Arguments: hwnd          -- Handle to the Dialog box's window
//            message       -- The message sent to the dialog box
//            wParam        -- A message parameter.
//            lParam        -- Another message parameter
// Return:    nonzero if we processed the message
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LRESULT CALLBACK ConfirmDeleteFileDlg(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    TCHAR szBuf[MAX_PATH];
    TCHAR szBuf2[MAX_PATH];

	switch(message)
	{
	case WM_INITDIALOG:
        g_progress.SetError();
        PromoteWindow(hwnd);
        LoadString(hInst, IDS_CONFIRM_RO_FILE, szBuf, MAX_PATH);
        wsprintf(szBuf2, szBuf, g_szDelFile);
        SetDlgItemText(hwnd, IDC_FILE_TEXT, szBuf2);
		return TRUE;
        
	case WM_COMMAND:
        g_progress.ClearError();
		EndDialog(hwnd, LOWORD(wParam));
		return TRUE;
	}
	return FALSE;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  ConfirmFileOverwriteDlg
// Purpose:   Message handler for the 'Confirm file overwrite' dialog. This function is automatically
//            called by Windows whenever a message needs to be sent to the dialog box (ie 'paint',
//            'move', etc).
// Arguments: hwnd          -- Handle to the Dialog box's window
//            message       -- The message sent to the dialog box
//            wParam        -- A message parameter.
//            lParam        -- Another message parameter
// Return:    nonzero if we processed the message
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LRESULT CALLBACK ConfirmFileOverwriteDlg(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    TCHAR szBuf[MAX_PATH];
    TCHAR szBuf2[MAX_PATH];

	switch(message)
	{
	case WM_INITDIALOG:
        g_progress.SetError();
        PromoteWindow(hwnd);
        LoadString(hInst, IDS_CONFIRM_FILE_OVERWRITE, szBuf, MAX_PATH);
        wsprintf(szBuf2, szBuf, g_szDelFile);
        SetDlgItemText(hwnd, IDC_OVERWRITE_TEXT, szBuf2);
		return TRUE;
        
	case WM_COMMAND:
        g_progress.ClearError();
		EndDialog(hwnd, LOWORD(wParam));
		return TRUE;
	}
	return FALSE;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  ConfirmFolderOverwriteDlg
// Purpose:   Message handler for the 'Confirm folder overwrite' dialog. This function is automatically
//            called by Windows whenever a message needs to be sent to the dialog box (ie 'paint',
//            'move', etc).
// Arguments: hwnd          -- Handle to the Dialog box's window
//            message       -- The message sent to the dialog box
//            wParam        -- A message parameter.
//            lParam        -- Another message parameter
// Return:    nonzero if we processed the message
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LRESULT CALLBACK ConfirmFolderOverwriteDlg(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    TCHAR szBuf[MAX_PATH];
    TCHAR szBuf2[MAX_PATH];

	switch(message)
	{
	case WM_INITDIALOG:
        g_progress.SetError();
        PromoteWindow(hwnd);
        LoadString(hInst, IDS_CONFIRM_FOLDER_OVERWRITE, szBuf, MAX_PATH);
        wsprintf(szBuf2, szBuf, g_szDelFile);
        SetDlgItemText(hwnd, IDC_OVERWRITE_TEXT, szBuf2);
		return TRUE;
        
	case WM_COMMAND:
        g_progress.ClearError();
		EndDialog(hwnd, LOWORD(wParam));
		return TRUE;
	}
	return FALSE;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  ConfirmMoveROFileDlg
// Purpose:   Message handler for the 'Confirm file move' dialog. This function is automatically
//            called by Windows whenever a message needs to be sent to the dialog box (ie 'paint',
//            'move', etc).
// Arguments: hwnd          -- Handle to the Dialog box's window
//            message       -- The message sent to the dialog box
//            wParam        -- A message parameter.
//            lParam        -- Another message parameter
// Return:    nonzero if we processed the message
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LRESULT CALLBACK ConfirmMoveROFileDlg(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    TCHAR szBuf[MAX_PATH];
    TCHAR szBuf2[MAX_PATH];

	switch(message)
	{
	case WM_INITDIALOG:
        g_progress.SetError();
        PromoteWindow(hwnd);
        LoadString(hInst, IDS_CONFIRM_RO_FILE_MOVE, szBuf, MAX_PATH);
        wsprintf(szBuf2, szBuf, g_szDelFile);
        SetDlgItemText(hwnd, IDC_OVERWRITE_TEXT, szBuf2);
		return TRUE;
        
	case WM_COMMAND:
        g_progress.ClearError();
		EndDialog(hwnd, LOWORD(wParam));
		return TRUE;
	}
	return FALSE;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  ConfirmMoveROFolderDlg
// Purpose:   Message handler for the 'Confirm folder move' dialog. This function is automatically
//            called by Windows whenever a message needs to be sent to the dialog box (ie 'paint',
//            'move', etc).
// Arguments: hwnd          -- Handle to the Dialog box's window
//            message       -- The message sent to the dialog box
//            wParam        -- A message parameter.
//            lParam        -- Another message parameter
// Return:    nonzero if we processed the message
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LRESULT CALLBACK ConfirmMoveROFolderDlg(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    TCHAR szBuf[MAX_PATH];
    TCHAR szBuf2[MAX_PATH];

	switch(message)
	{
	case WM_INITDIALOG:
        g_progress.SetError();
        PromoteWindow(hwnd);
        LoadString(hInst, IDS_CONFIRM_RO_FOLDER_MOVE, szBuf, MAX_PATH);
        wsprintf(szBuf2, szBuf, g_szDelFile);
        SetDlgItemText(hwnd, IDC_OVERWRITE_TEXT, szBuf2);
		return TRUE;
        
	case WM_COMMAND:
        g_progress.ClearError();
		EndDialog(hwnd, LOWORD(wParam));
		return TRUE;
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\CXboxStream.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     cxboxstream.cpp
// Contents: UNDONE-WARN: Add file description
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CXboxStream::CXboxStream
// Purpose:   CXboxStream constructor
// Arguments: None.
// Return:    None.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CXboxStream::CXboxStream(char *szFile, bool fCut) : m_cRef(1)
{
    // Open the file, but don't read anything in yet.
    // Copy the file from the target xbox to a temporary file on this machine., and then open that
    // file.  Note: Be sure to delete the temp file when done!
    char szTempPath[MAX_PATH];

    m_hfile = NULL;
    
    // Create a temporary file name for the new file
    if (GetTempPath(MAX_PATH, szTempPath) == 0)
        return;
    
    if (GetTempFileName(szTempPath, "xbx", 0, m_szTempPathFileName) == 0)
        return;
    
    // Now that we have a valid name for our temporary file, copy the file from the Xbox
    // to the temporary file so that we can read from it as requested.
    if (DmReceiveFile(m_szTempPathFileName, szFile) != XBDM_NOERR)
        return;
    strcpy(m_szFile, szFile);
    m_fCut = fCut;

    // Open the file for subsequent reads
    m_hfile = CreateFile(m_szTempPathFileName, FILE_GENERIC_READ, 0, NULL, OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL, 0);
    if (m_hfile == INVALID_HANDLE_VALUE)
        m_hfile = NULL;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CXboxStream::~CXboxStream
// Purpose:   CXbox destructor
// Arguments: None.
// Return:    None.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CXboxStream::~CXboxStream()
{
    // Close our file
    if (m_hfile)
        CloseHandle(m_hfile);

    // Need to delete the temp file we created
    DeleteFile(m_szTempPathFileName);

    if (0 && m_fCut)
    {
        DM_FILE_ATTRIBUTES dmfa;
        // Delete our source file
        xbfu.GetFileAttributes(m_szFile, &dmfa);
        xbfu.Del(m_szFile, false, NULL);
    }
}


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ IUNKNOWN METHODS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CXboxStream::QueryInterface
// Purpose:   Obtain a particular interface to this object.
// Arguments: riid          -- The interface to this object being queried for.
//            ppvObject     -- Buffer to fill with obtained interface.
// Return:    S_OK if interface obtained; E_NOINTERFACE otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CXboxStream::QueryInterface(REFIID riid, void **ppvObject)
{ 
    *ppvObject = NULL;

    if (riid == IID_IUnknown) 
        *ppvObject = this;
    else if (riid == IID_IStream) 
        *ppvObject = static_cast<IStream*>(this);
    else
        return E_NOINTERFACE;

    if (*ppvObject)
    {
        static_cast<LPUNKNOWN>(*ppvObject)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}   

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CXboxStream::AddRef
// Purpose:   Add a reference to this object
// Arguments: None
// Return:    New reference count
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP_(ULONG) CXboxStream::AddRef()
{
    return (ULONG)InterlockedIncrement(&m_cRef);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CXboxStream::Release
// Purpose:   Subtract a reference to this object.  If the new number of references is zero, then
//            delete the object.
// Arguments: None
// Return:    New reference count.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP_(ULONG) CXboxStream::Release()
{
    if (0 == InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return (ULONG)m_cRef;
}


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ ISTREAM METHODS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CXboxStream::Read
// Purpose:   Read a string of bytes.
// Arguments: pv            -- Buffer into which the bytes are read.
//            cb            -- Number of bytes to read
//            pcbRead       -- Number of bytes actually read.
// Return:    S_OK if successful; error code otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CXboxStream::Read(void *pv, ULONG cb, ULONG *pcbRead)
{
    // Read the bits from our source file.
    if (!ReadFile(m_hfile, pv, cb, pcbRead, NULL))
        return GetLastError();

    return S_OK;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CXboxStream::Read
// Purpose:   Read a string of bytes.
// Arguments: pv            -- Buffer into which the bytes are read.
//            cb            -- Number of bytes to read
//            pcbRead       -- Number of bytes actually read.
// Return:    S_OK if successful; error code otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CXboxStream::Write(VOID const *pv, ULONG cb, ULONG *pcbWritten)
{
    // Write the specified bits to our temporary destination file.
    WriteFile(m_hfile, pv, cb, pcbWritten, NULL);
    return S_OK;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CXboxStream::Seek
// Purpose:   Seeks to a particular position in the stream
// Arguments: dbMove        -- Number of bytes in which to move.
//            dwOrigin      -- Starting location of move.
//            pbNewPosition -- Filled with new file pointer.
// Return:    S_OK if successful; error code otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CXboxStream::Seek(LARGE_INTEGER dbMove, DWORD dwOrigin, ULARGE_INTEGER *pbNewPosition)
{
    // Seek to the specified position in our source and destination files.
    LARGE_INTEGER li = dbMove;
    li.LowPart = SetFilePointer(m_hfile, li.LowPart, &li.HighPart, dwOrigin);

    // Test for failure
    if (li.LowPart == 0xFFFFFFFF)
    {
        // Check if actually an error
        DWORD dwErr = GetLastError();
        if (dwErr != NO_ERROR)
            return dwErr;
    } 
    
    if (pbNewPosition)
        (*pbNewPosition).QuadPart = li.QuadPart;

    return S_OK;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CXboxStream::SetSize
// Purpose:   unimplemented
// Arguments: UNDONE-WARN: Fill in
// Return:    S_OK if successful; error code otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CXboxStream::SetSize(ULARGE_INTEGER cbNewSize)
{
    return E_NOTIMPL;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CXboxStream::CopyTo
// Purpose:   unimplemented
// Arguments: UNDONE-WARN: Fill in
// Return:    S_OK if successful; error code otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CXboxStream::CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead,
                    ULARGE_INTEGER *pcbWritten)
{
    return E_NOTIMPL;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CXboxStream::Commit
// Purpose:   unimplemented
// Arguments: UNDONE-WARN: Fill in
// Return:    S_OK if successful; error code otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CXboxStream::Commit(DWORD grfCommitFlags)
{
    return E_NOTIMPL;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CXboxStream::Revert
// Purpose:   unimplemented
// Arguments: UNDONE-WARN: Fill in
// Return:    S_OK if successful; error code otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CXboxStream::Revert()
{
    return E_NOTIMPL;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CXboxStream::LockRegion
// Purpose:   unimplemented
// Arguments: UNDONE-WARN: Fill in
// Return:    S_OK if successful; error code otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CXboxStream::LockRegion(ULARGE_INTEGER bOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    return E_NOTIMPL;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CXboxStream::UnlockRegion
// Purpose:   unimplemented
// Arguments: UNDONE-WARN: Fill in
// Return:    S_OK if successful; error code otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CXboxStream::UnlockRegion(ULARGE_INTEGER bOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    return E_NOTIMPL;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CXboxStream::Stat
// Purpose:   unimplemented
// Arguments: UNDONE-WARN: Fill in
// Return:    S_OK if successful; error code otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CXboxStream::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    return E_NOTIMPL;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CXboxStream::Clone
// Purpose:   unimplemented
// Arguments: UNDONE-WARN: Fill in
// Return:    S_OK if successful; error code otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CXboxStream::Clone(IStream **ppstm)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\History.cpp ===
// String history Class
//
// 1/20/2000	Shinji Chiba

#include "stdafx.h"

HISTORY::HISTORY()
{
	int i;
	historyRewind = new char*[N_HISTORY];
	historyForward = new char*[N_HISTORY];
	for( i = 0; i < N_HISTORY; i++ )
	{
		historyRewind[i] = (char *) new char[L_HISTORY];
		historyForward[i] = (char *) new char[L_HISTORY];
		ZeroMemory( historyRewind[i], L_HISTORY * sizeof(char) );
		ZeroMemory( historyForward[i], L_HISTORY * sizeof(char) );
	}
}

HISTORY::~HISTORY()
{
	int i;
	for( i = 0; i < N_HISTORY; i++ )
	{
		delete historyForward[i];
		delete historyRewind[i];
	}
	delete historyForward;
	delete historyRewind;
}

void HISTORY::Clear()
{
	historyRewind[0][0] = historyForward[0][0] = '\0';
}

void HISTORY::AddForwardHistory( char *str )
{
	int i;
	for( i = N_HISTORY; i > 1; )
	{
		i--;
		strcpy( historyForward[i], historyForward[i - 1] );
	}
	strcpy( historyForward[0], str );
}

void HISTORY::SaveHistory( char *str )
{
	int i;
	for( i = N_HISTORY; i > 1; )
	{
		i--;
		strcpy( historyRewind[i], historyRewind[i - 1] );
		historyForward[i][0] = '\0';
	}
	strcpy( historyRewind[0], str );
	historyForward[0][0] = '\0';
}

void HISTORY::RestoreRewindHistory( char *str )
{
	if ( historyRewind[0][0] )
	{
		int i;
		AddForwardHistory( str );
		strcpy( str, historyRewind[0] );
		for( i = 0; i < N_HISTORY - 1; i++ )
		{
			strcpy( historyRewind[i], historyRewind[i + 1] );
		}
		historyRewind[N_HISTORY - 1][0] = '\0';
	}
}

void HISTORY::RestoreForwardHistory( char *str )
{
	if ( historyForward[0][0] )
	{
		int i;
		for( i = N_HISTORY; i > 1; )
		{
			i--;
			strcpy( historyRewind[i], historyRewind[i - 1] );
		}
		strcpy( historyRewind[0], str );
		strcpy( str, historyForward[0] );
		for( i = 0; i < N_HISTORY - 1; i++ )
		{
			strcpy( historyForward[i], historyForward[i + 1] );
		}
		historyForward[N_HISTORY - 1][0] = '\0';
	}
}

DWORD HISTORY::GetRewindCount()
{
	int i;
	DWORD count;
	for( i = 0, count = 0; i < N_HISTORY; i++ )
	{
		if ( historyRewind[i][0] ) count++;
		else break;
	}
	return count;
}

DWORD HISTORY::GetForwardCount()
{
	int i;
	DWORD count;
	for( i = 0, count = 0; i < N_HISTORY; i++ )
	{
		if ( historyForward[i][0] ) count++;
		else break;
	}
	return count;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\History.h ===
// String history Class
//
// 1/20/2000	Shinji Chiba

#ifndef __HISTORY_H__
#define __HISTORY_H__

#include <windows.h>

#define N_HISTORY 64
#define L_HISTORY MAX_PATH

class HISTORY
{
private:
	char **historyRewind;
	char **historyForward;

	void AddForwardHistory( char* );

public:
	HISTORY();
	~HISTORY();
	void Clear();
	void SaveHistory( char* );
	void RestoreRewindHistory( char* );
	void RestoreForwardHistory( char* );
	DWORD GetRewindCount();
	DWORD GetForwardCount();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\Registry.h ===
//
//	Registry I/O class
//
//	Author: Shinji Chiba 1997-1-23
//

#ifndef __REGISTRY_H__
#define __REGISTRY_H__

#define REG_STRMAX 1024

class REGISTRY
{
private:
	HKEY hMainKey;
	char szSubkey[1024];

public:
	REGISTRY();
	~REGISTRY();
	void Init( HKEY, char* );
	BOOL GetString( char*, char* );
	BOOL GetValue( char*, LPDWORD );
	BOOL SetString( char*, char* );
	BOOL SetValue( char*, DWORD );
	BOOL Delete( char* = NULL, HKEY = NULL );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\DlgProcs.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     DlgProcs.h
// Contents: Contains function and class declarations for the DlgProcs.cpp file
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  AboutDlgProc
// Purpose:   Message handler for About dialog. This function is automatically called by Windows
//            whenever a message needs to be sent to the dialog box (ie 'paint', 'move', etc).
// Arguments: hwnd          -- Handle to the Dialog box's window
//            message       -- The message sent to the dialog box
//            wParam        -- A message parameter.
//            lParam        -- Another message parameter
// Return:    nonzero if we processed the message
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LRESULT CALLBACK AboutDlgProc( HWND, UINT, WPARAM, LPARAM );

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  ConfirmDeleteFolderDlg
// Purpose:   Message handler for the 'Confirm folder delete' dialog. This function is
//            automatically called by Windows whenever a message needs to be sent to the dialog box
//            (ie 'paint', 'move', etc).
// Arguments: hwnd          -- Handle to the Dialog box's window
//            message       -- The message sent to the dialog box
//            wParam        -- A message parameter.
//            lParam        -- Another message parameter
// Return:    nonzero if we processed the message
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LRESULT CALLBACK ConfirmDeleteFolderDlg( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  ConfirmDeleteFileDlg
// Purpose:   Message handler for the 'Confirm file delete' dialog. This function is automatically
//            called by Windows whenever a message needs to be sent to the dialog box (ie 'paint',
//            'move', etc).
// Arguments: hwnd          -- Handle to the Dialog box's window
//            message       -- The message sent to the dialog box
//            wParam        -- A message parameter.
//            lParam        -- Another message parameter
// Return:    nonzero if we processed the message
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LRESULT CALLBACK ConfirmDeleteFileDlg( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  ConfirmFileOverwriteDlg
// Purpose:   Message handler for the 'Confirm file overwrite' dialog. This function is automatically
//            called by Windows whenever a message needs to be sent to the dialog box (ie 'paint',
//            'move', etc).
// Arguments: hwnd          -- Handle to the Dialog box's window
//            message       -- The message sent to the dialog box
//            wParam        -- A message parameter.
//            lParam        -- Another message parameter
// Return:    nonzero if we processed the message
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LRESULT CALLBACK ConfirmFileOverwriteDlg(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  ConfirmFolderOverwriteDlg
// Purpose:   Message handler for the 'Confirm folder overwrite' dialog. This function is automatically
//            called by Windows whenever a message needs to be sent to the dialog box (ie 'paint',
//            'move', etc).
// Arguments: hwnd          -- Handle to the Dialog box's window
//            message       -- The message sent to the dialog box
//            wParam        -- A message parameter.
//            lParam        -- Another message parameter
// Return:    nonzero if we processed the message
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LRESULT CALLBACK ConfirmFolderOverwriteDlg(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  ConfirmMoveROFileDlg
// Purpose:   Message handler for the 'Confirm file move' dialog. This function is automatically
//            called by Windows whenever a message needs to be sent to the dialog box (ie 'paint',
//            'move', etc).
// Arguments: hwnd          -- Handle to the Dialog box's window
//            message       -- The message sent to the dialog box
//            wParam        -- A message parameter.
//            lParam        -- Another message parameter
// Return:    nonzero if we processed the message
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LRESULT CALLBACK ConfirmMoveROFileDlg(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  ConfirmMoveROFolderDlg
// Purpose:   Message handler for the 'Confirm folder move' dialog. This function is automatically
//            called by Windows whenever a message needs to be sent to the dialog box (ie 'paint',
//            'move', etc).
// Arguments: hwnd          -- Handle to the Dialog box's window
//            message       -- The message sent to the dialog box
//            wParam        -- A message parameter.
//            lParam        -- Another message parameter
// Return:    nonzero if we processed the message
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LRESULT CALLBACK ConfirmMoveROFolderDlg(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\ListView.h ===
#define N_COLUMN 4
#define CHAR_DIR "<DIR>"
#define ITEM_NONE -1

enum {
	MENU_FILE,
    MENU_EDIT,
	MENU_VIEW,
	MENU_HELP
};
enum {
	COLUMN_NAME,
	COLUMN_SIZE,
	COLUMN_TYPE,
	COLUMN_MODIFIED
};
extern char g_szCopyDir[MAX_PATH];

class CFileContainer;
class LISTVIEW
{
private:
	HWND hListWnd;
	TIME_ZONE_INFORMATION g_tzi;
	BOOL fHaveTimeZone;
	BOOL sortreverse;
	DWORD viewmode;
	int columnSize[N_COLUMN];
	char cszColumn[N_COLUMN][100];

    bool PopulateWithSelected(CFileContainer *pfc);
	BOOL InsertFiles( int = COLUMN_NAME, BOOL = FALSE );

    CDropTarget *m_pdroptarget;
    int m_nDragHighlightItem;
    bool m_fCut;
    
public:
    bool BeginDrag();
	LISTVIEW();
	~LISTVIEW();
	BOOL FileTime2LocalTime( LPFILETIME, LPSYSTEMTIME );
	HWND GetHwnd();
	void Focus();
	HWND CreateListView( HWND, LPRECT = NULL );
	HWND RedrawListView( HWND, LPRECT = NULL );
	bool SortListView( int, BOOL );
	void ChangeListView( DWORD );
	void CheckFiles( int*, int*, int* );
	BOOL CheckSelectedFiles( int*, int*, int* );
	BOOL IsParentFolder( int );
	BOOL IsFolder( int );
	BOOL IsSelected( int );
	int IsExistence( char* );
	void ChangeView( DWORD = 0 );
	DWORD GetViewMode();
    int GetItemAtPoint(POINT *ppt);
    bool SetDragHighlight(bool fEnable, POINT *ppt);
    bool GetDragItemName(char szName[MAX_PATH]);
    void CutCopy(bool fCut);
    void Paste();
    void Delete(HWND hwndOwner);
    int GetNumSelected();
    void Clear();
    void ClearSelection();
    int m_nLastSort;
};


int CALLBACK ListViewCompareProc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\ListView.cpp ===
//
//	SCMPX MPEG/Audio Player.
//
//	Implement: Playlist
//	Author: Shinji Chiba 1997-4-13
//

#include "stdafx.h"

//bool g_fCut = false;
char g_szCopyDir[MAX_PATH];

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void DebugOutput(char *szMsg, ...)
{
    char szMsgOut[1024];
    va_list valist;
    
    // Create the final formatted string.
    va_start (valist, szMsg);
    vsprintf (szMsgOut, szMsg, valist);
    OutputDebugString(szMsgOut);
    va_end (valist);
}

LISTVIEW::LISTVIEW()
{
	hListWnd = NULL;
	fHaveTimeZone = FALSE;
	sortreverse = FALSE;
	viewmode = LVS_REPORT;
	columnSize[COLUMN_NAME] = 160;
	columnSize[COLUMN_SIZE] = 80;
	columnSize[COLUMN_TYPE] = 120;
	columnSize[COLUMN_MODIFIED] = 110;
    m_pdroptarget = NULL;
    m_nDragHighlightItem = ITEM_NONE;

    // Load the column name strings
    LoadString(hInst, IDS_COLUMN_NAME, cszColumn[0], MAX_PATH);
    LoadString(hInst, IDS_COLUMN_SIZE, cszColumn[1], MAX_PATH);
    LoadString(hInst, IDS_COLUMN_TYPE, cszColumn[2], MAX_PATH);
    LoadString(hInst, IDS_COLUMN_MODIFIED, cszColumn[3], MAX_PATH);
}

LISTVIEW::~LISTVIEW()
{
    if (m_pdroptarget)
        m_pdroptarget->Release();
}

BOOL LISTVIEW::FileTime2LocalTime(LPFILETIME lpft, LPSYSTEMTIME lpst)
{
	SYSTEMTIME stZ;

	if (! FileTimeToSystemTime(lpft, &stZ)) return FALSE;
	if (! fHaveTimeZone) fHaveTimeZone = GetTimeZoneInformation(&g_tzi) != TIME_ZONE_ID_UNKNOWN;
	if (! fHaveTimeZone || ! SystemTimeToTzSpecificLocalTime(&g_tzi, &stZ, lpst)) *lpst = stZ;
	return TRUE;
}

HWND LISTVIEW::GetHwnd()
{
	return hListWnd;
}

HWND LISTVIEW::CreateListView(HWND hWndParent, LPRECT lprc/* = NULL */)
{
	RECT rcl;
	int index;
	LV_COLUMN lvC;
	char szText[32];
	INITCOMMONCONTROLSEX icex;

	icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
	icex.dwICC = ICC_LISTVIEW_CLASSES;
	InitCommonControlsEx(&icex);

	if (lprc) CopyMemory(&rcl, lprc, sizeof(RECT));
	else GetClientRect(hWndParent, &rcl);
	hListWnd = CreateWindow(WC_LISTVIEW, "", viewmode | (WS_BORDER | WS_VISIBLE | WS_CHILD | LVS_AUTOARRANGE | LVS_EDITLABELS | LVS_SHAREIMAGELISTS | LVS_SHOWSELALWAYS), rcl.left, rcl.top, rcl.right - rcl.left, rcl.bottom - rcl.top, hWndParent, (HMENU) 1, hInst, NULL);
	if (! hListWnd) return NULL;
     
	lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
	lvC.pszText = szText;
	for (index = 0; index < N_COLUMN; index++)
	{
		lvC.cx = columnSize[index];
		if (index == COLUMN_SIZE) lvC.fmt = LVCFMT_RIGHT;
		else lvC.fmt = LVCFMT_LEFT;

		lvC.iSubItem = index;
		wsprintf(szText, cszColumn[index]);
		if (ListView_InsertColumn(hListWnd, index, &lvC) == -1) return NULL;
	}

	HIMAGELIST hil;
	SHFILEINFO sfi;
	ZeroMemory(&sfi, sizeof(sfi));
	hil = (HIMAGELIST) SHGetFileInfo(".\\", 0, &sfi, sizeof(sfi), SHGFI_SYSICONINDEX | SHGFI_USEFILEATTRIBUTES | SHGFI_ICON | SHGFI_SMALLICON | SHGFI_TYPENAME);
	ListView_SetImageList(hListWnd, hil, LVSIL_SMALL);
	//ListView_SetExtendedListViewStyle(hListWnd, LVS_EX_FULLROWSELECT);

	hil = (HIMAGELIST) SHGetFileInfo(".\\", 0, &sfi, sizeof(sfi), SHGFI_SYSICONINDEX | SHGFI_USEFILEATTRIBUTES | SHGFI_ICON | SHGFI_TYPENAME);
	ListView_SetImageList(hListWnd, hil, LVSIL_NORMAL);
    
//	if (! InsertFiles()) return NULL;

    // Register ourself as a DropTarget (ie things can be dragged/dropped onto us.
    m_pdroptarget = new CDropTarget();

    IDropTarget *pidroptarget; 
    if (FAILED(m_pdroptarget->QueryInterface(IID_IDropTarget, (LPVOID*)&pidroptarget)))
        return false;

    RegisterDragDrop(GetHwnd(), pidroptarget);

	return hListWnd;
}
int StrToN(char *sz)
{
    int n = 0;
    while (*sz)
    {
        if (*sz >= '0' && *sz <= '9')
            n = n * 10 + *sz - '0';
        sz++;
    }
    return n;
}

int CompTime(char *szDate1, char *szDate2)
{
    int nYear1, nMonth1, nDate1, nHour1, nMinute1;
    int nYear2, nMonth2, nDate2, nHour2, nMinute2;
    sscanf(szDate1, "%04d/%02d/%02d %02d:%02d", &nYear1, &nMonth1, &nDate1, &nHour1, &nMinute1);
    sscanf(szDate2, "%04d/%02d/%02d %02d:%02d", &nYear2, &nMonth2, &nDate2, &nHour2, &nMinute2);

    if (nYear1 > nYear2) return 1;
    else if (nYear2 > nYear1) return -1;
    if (nMonth1 > nMonth2) return 1;
    else if (nMonth2 > nMonth1) return -1;
    if (nDate1 > nDate2) return 1;
    else if (nDate2 > nDate1) return -1;
    if (nHour1 > nHour2) return 1;
    else if (nHour2 > nHour1) return -1;
    if (nMinute1 > nMinute2) return 1;
    else if (nMinute2 > nMinute1) return -1;
   
    return 0;
}

// ListViewCompareFunc - sorts the list view control. It is a 
//     comparison function. 
// Returns a negative value if the first item should precede the 
//     second item, a positive value if the first item should 
//     follow the second item, and zero if the items are equivalent. 
// lParam1 and lParam2 - item data for the two items (in this 
//     case, pointers to application-defined MYITEM structures). 
// lParamSort - value specified by the LVM_SORTITEMS message 
//     (in this case, the index of the column to sort). 

bool m_fInvert = false;
int CALLBACK ListViewCompareProc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    char sz1[MAX_PATH], sz2[MAX_PATH], szTemp[MAX_PATH], szTemp2[MAX_PATH];
    bool fDir1, fDir2;

    listview.m_nLastSort = lParamSort;

    int nRet;
    switch(lParamSort)
    {
    case 0:     // Sort by name.
        // Get the file names
        ListView_GetItemText(listview.GetHwnd(), lParam1, COLUMN_NAME, sz1, MAX_PATH);
        ListView_GetItemText(listview.GetHwnd(), lParam2, COLUMN_NAME, sz2, MAX_PATH);
        ListView_GetItemText(listview.GetHwnd(), lParam1, COLUMN_SIZE, szTemp, MAX_PATH);
        fDir1 = !MyStrcmp(szTemp, CHAR_DIR);
        ListView_GetItemText(listview.GetHwnd(), lParam2, COLUMN_SIZE, szTemp, MAX_PATH);
        fDir2 = !MyStrcmp(szTemp, CHAR_DIR);

        // '..' always comes first
        if (!MyStrcmp(sz1, ".."))
        { if (m_fInvert) nRet = 1; else nRet = -1; }
        else if (!MyStrcmp(sz2, ".."))
        { if (m_fInvert) nRet = -1; else nRet = 1; }
        // Directories come before files
        else if (fDir1 && !fDir2)
            nRet = -1;
        else if (fDir2 && !fDir1)
            nRet = 1;
        else
            nRet = MyStricmp(sz1, sz2);
        break;
        
    case 1:     // Sort by size.
        ListView_GetItemText(listview.GetHwnd(), lParam1, COLUMN_NAME, sz1, MAX_PATH);
        ListView_GetItemText(listview.GetHwnd(), lParam2, COLUMN_NAME, sz2, MAX_PATH);
        ListView_GetItemText(listview.GetHwnd(), lParam1, COLUMN_SIZE, szTemp, MAX_PATH);
        fDir1 = !MyStrcmp(szTemp, CHAR_DIR);
        ListView_GetItemText(listview.GetHwnd(), lParam2, COLUMN_SIZE, szTemp2, MAX_PATH);
        fDir2 = !MyStrcmp(szTemp, CHAR_DIR);

        // Directories come before files
        // '..' always comes first
        if (!MyStrcmp(sz1, ".."))
        { if (m_fInvert) nRet = 1; else nRet = -1; }
        else if (!MyStrcmp(sz2, ".."))
        { if (m_fInvert) nRet = -1; else nRet = 1; }
        else if (fDir1 && !fDir2)
            nRet = -1;
        else if (fDir2 && !fDir1)
            nRet = 1;
        else
        // Convert size strings into numbers and compare them...
        {
            int n1 = StrToN(szTemp);
            int n2 = StrToN(szTemp2);
            nRet = n1 > n2 ? 1 : -1;
        }
        break;

    case 2:     // Sort by type.
        ListView_GetItemText(listview.GetHwnd(), lParam1, COLUMN_NAME, sz1, MAX_PATH);
        ListView_GetItemText(listview.GetHwnd(), lParam2, COLUMN_NAME, sz2, MAX_PATH);
        
        if (!MyStrcmp(sz1, ".."))
        { if (m_fInvert) nRet = 1; else nRet = -1; }
        else if (!MyStrcmp(sz2, ".."))
        { if (m_fInvert) nRet = -1; else nRet = 1; }
        else
        {
            ListView_GetItemText(listview.GetHwnd(), lParam1, COLUMN_TYPE, sz1, MAX_PATH);
            ListView_GetItemText(listview.GetHwnd(), lParam2, COLUMN_TYPE, sz2, MAX_PATH);
            nRet = MyStricmp(sz1, sz2);
        }
        break;

    case 3:     // Sort by date
        ListView_GetItemText(listview.GetHwnd(), lParam1, COLUMN_NAME, sz1, MAX_PATH);
        ListView_GetItemText(listview.GetHwnd(), lParam2, COLUMN_NAME, sz2, MAX_PATH);
        
        if (!MyStrcmp(sz1, ".."))
        { if (m_fInvert) nRet = 1; else nRet = -1; }
        else if (!MyStrcmp(sz2, ".."))
        { if (m_fInvert) nRet = -1; else nRet = 1; }
        else
        {
            ListView_GetItemText(listview.GetHwnd(), lParam1, COLUMN_MODIFIED, sz1, MAX_PATH);
            ListView_GetItemText(listview.GetHwnd(), lParam2, COLUMN_MODIFIED, sz2, MAX_PATH);
            nRet = CompTime(sz1, sz2);
        }
        break;

    default:
        nRet = 0;
        break;
    }

    if (m_fInvert)
        return -nRet;
    else
        return nRet;
}	

void SetlParam(int i)
{
    LV_ITEM lvI = {0};

    lvI.mask = LVIF_PARAM;
    lvI.iItem = i;
    lvI.iSubItem = 0;

    ListView_GetItem(listview.GetHwnd(), &lvI);
    lvI.lParam = i;
    ListView_SetItem(listview.GetHwnd(), &lvI);
}

BOOL LISTVIEW::InsertFiles(int sortcolumn /* = 0 */, BOOL updown/* = FALSE */)
{
	LV_ITEM lvI;
	int index=0;
	if (! hListWnd) return FALSE;

#if 0
    // Only add '..' if we're not at the root
    if (g_CurrentDir[4] != '\0')
    {
        LVITEM item;

		LPCTSTR pExt;
		UINT flg;
		SHFILEINFO sfi;
		ZeroMemory(&sfi, sizeof(sfi));
		pExt = "*";
		flg = SHGFI_ICON | SHGFI_SMALLICON | SHGFI_USEFILEATTRIBUTES ;
		SHGetFileInfo(pExt, FILE_ATTRIBUTE_DIRECTORY, &sfi, sizeof(sfi), flg);
		item.iImage = sfi.iIcon;
		item.iImage = 0;
        item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE | LVIF_PARAM;
		item.state = 0;
		item.stateMask = 0;
		item.iSubItem = 0;
        item.iItem = 1;
        item.lParam = 0;
		item.pszText = "..";
		index = ListView_InsertItem(hListWnd, &item);
	}
#endif
    
    char szBinary[100], szBadDate[100];
    LoadString(hInst, IDS_BINARY, szBinary, MAX_PATH);
    LoadString(hInst, IDS_BAD_DATE, szBadDate, MAX_PATH);

	DM_FILE_ATTRIBUTES fa;
    bool fXbox = (*g_CurrentDir == 'x' || *g_CurrentDir == 'X');
	HANDLE hFind = xbfu.FindFirstFile(g_CurrentDir, &fa, fXbox, g_TargetXbox);
	if (hFind != INVALID_HANDLE_VALUE)
	{
		do {
			char isdir[8];
			ZeroMemory(isdir, 8);

            SHFILEINFO sfi;
			ZeroMemory(&sfi, sizeof(sfi));
			LPCTSTR pExt;
			UINT flg;
			if (fa.Attributes & FILE_ATTRIBUTE_DIRECTORY)
			{
				pExt = fa.Name;
        		flg = SHGFI_ICON | SHGFI_SMALLICON | SHGFI_USEFILEATTRIBUTES | SHGFI_TYPENAME ;
//				flg = SHGFI_SYSICONINDEX | SHGFI_ICON | SHGFI_SMALLICON | SHGFI_TYPENAME;
			}
			else
			{
				pExt = fa.Name;
				flg = SHGFI_SYSICONINDEX | SHGFI_USEFILEATTRIBUTES | SHGFI_ICON | SHGFI_SMALLICON | SHGFI_TYPENAME;
			}
			SHGetFileInfo(pExt, fa.Attributes & FILE_ATTRIBUTE_DIRECTORY, &sfi, sizeof(sfi), flg);
			lvI.iImage = sfi.iIcon;

			lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE | LVIF_PARAM;
			lvI.state = 0;
			lvI.stateMask = 0;
			lvI.iItem = 0;
			lvI.iSubItem = 0;
			lvI.pszText = fa.Name;
			if (fa.Attributes & FILE_ATTRIBUTE_HIDDEN)
			{
				lvI.mask |= LVIF_STATE;
				lvI.stateMask |= LVIS_CUT;
				lvI.state |= LVIS_CUT;
			}

            if ((index = ListView_InsertItem(hListWnd, &lvI)) == -1) return FALSE;

			if (! (fa.Attributes & FILE_ATTRIBUTE_DIRECTORY))
			{
				char szSize[32];
				int ichReal = 0;
				int ich = 0;
				DWORD dwSize = fa.SizeLow;
				double fSize = (double) dwSize;

				while(dwSize)
				{
					if (ich && (ich % 3) == 0) ichReal++;
					ichReal++;
					ich++;
					dwSize /= 10;
				}

				ich = 0;
				dwSize = fa.SizeLow;
				if (dwSize == 0)
				{
					szSize[0] = '0';
					szSize[1] = '\0';
				}
				else
				{
					szSize[ichReal] = '\0';
					while(ichReal-- && dwSize)
					{
						if (ich && (ich % 3) == 0) szSize[ichReal--] = ',';
						szSize[ichReal] = (char) (dwSize % 10) + '0';
						dwSize /= 10;
						++ich;
					}
					while(ichReal >= 0) szSize[ichReal--] = ' ';
				}

				lvI.mask = LVIF_TEXT;
				lvI.iItem = index;
				lvI.iSubItem = COLUMN_SIZE;
				lvI.pszText = szSize;
				if (ListView_SetItem(hListWnd, &lvI) == -1) return NULL;
			}
			else
			{
				lvI.mask = LVIF_TEXT;
				lvI.iItem = index;
				lvI.iSubItem = COLUMN_SIZE;
				lvI.pszText = CHAR_DIR;
				if (ListView_SetItem(hListWnd, &lvI) == -1) return NULL;
			}
			lvI.iSubItem = COLUMN_TYPE;
			lvI.pszText = sfi.szTypeName;

            if (sfi.szTypeName[0] == '\0') lstrcpy(sfi.szTypeName, szBinary);
			if (ListView_SetItem(hListWnd, &lvI) == -1) return NULL;
			{
				char szTime[32];
				SYSTEMTIME st;
				if (FileTime2LocalTime(&fa.ChangeTime, &st)) wsprintf(szTime, "%04d/%02d/%02d  %02d:%02d", st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute);
				else wsprintf(szTime, "%-18.18s", szBadDate);
				lvI.iSubItem = COLUMN_MODIFIED;
				lvI.pszText = szTime;
				if (ListView_SetItem(hListWnd, &lvI) == -1) return NULL;
			}
		} while(xbfu.FindNextFile(hFind, &fa, fXbox));
		xbfu.FindClose(hFind, fXbox);
	}
    else
    {
        if (xbfu.FailedConnect())
        {
            // Failed to connect to current xbox.  reset the failed flag
            xbfu.SetFailed();
            return FALSE;
        }
    }
	int items = ListView_GetItemCount(hListWnd);
	for (int nItem = 0; nItem < items; nItem++)
	{
        SetlParam(nItem);
	}

    return TRUE;
}

HWND LISTVIEW::RedrawListView(HWND hWndParent, LPRECT lprc/* = NULL */)
{
	RECT rcl;

	if (lprc) CopyMemory(&rcl, lprc, sizeof(RECT));
	else GetClientRect(hWndParent, &rcl);
	SetWindowPos(hListWnd, NULL, rcl.left, rcl.top, rcl.right - rcl.left, rcl.bottom - rcl.top, SWP_NOZORDER | SWP_SHOWWINDOW);
	return hListWnd;
}

char *g_rgszSelectedFiles[1000];
int m_cSelected =0;

void SaveSelectedItems()
{
	char str[512] = "";
	int nItem = -1;
    m_cSelected = 0;
	while((nItem = ListView_GetNextItem(listview.GetHwnd(), nItem, LVNI_ALL | LVNI_SELECTED)) > -1)
	{
		ListView_GetItemText(listview.GetHwnd(), nItem, COLUMN_NAME, str, 512);
        g_rgszSelectedFiles[m_cSelected] = new char[MyStrlen(str) + 1];
        strcpy(g_rgszSelectedFiles[m_cSelected], str);
        m_cSelected++;
	}
}

void SetSelected(char *szItemName)
{
    if (szItemName)
    {
        // Find the item, then set it's state to selected
        LVFINDINFO lvfi;
    
        lvfi.flags = LVFI_STRING;
        lvfi.psz = szItemName;
        int i = ListView_FindItem(listview.GetHwnd(), -1, &lvfi);
        if (i == -1)
            return;

        ListView_SetItemState(listview.GetHwnd(), i, LVIS_SELECTED , LVIS_SELECTED );
    }
    else
        ListView_SetItemState(listview.GetHwnd(), -1, 0, LVIS_SELECTED );
}
        

void RestoreSelectedItems()
{
    for (int i = 0; i < m_cSelected; i++)
    {
        SetSelected(g_rgszSelectedFiles[i]);
        
        delete g_rgszSelectedFiles[i];
    }
    m_cSelected = 0;
}

void DeferSelected(char *szItemName)
{
//    strcpy(g_rgszSelectedFiles[m_cSelected], szItemName);
  //  m_cSelected++;
}

void LISTVIEW::ClearSelection()
{
    SetSelected(NULL);
}
extern void TotalFiles();
bool LISTVIEW::SortListView(int sortcolumn, BOOL fColumnclick)
{
    char szBuf[MAX_PATH];
    wsprintf(szBuf, "xbExplorer - %s: %s", g_TargetXbox, g_CurrentDir);
    SetWindowText(g_hwnd, szBuf);

    SaveSelectedItems();

    ListView_DeleteAllItems(hListWnd);

    // if this was from a column click, and we're setting the same column, then invert the ordering
    bool updown =false;
    if (fColumnclick && sortcolumn == m_nLastSort)
        m_fInvert = !m_fInvert;
	if (!InsertFiles(sortcolumn, updown))
    {
        // Failed to insert files
        return false;
    }

    if (sortcolumn == -1)
        sortcolumn = m_nLastSort;
    
    ListView_SortItems(GetHwnd(), ListViewCompareProc, sortcolumn);

    RestoreSelectedItems();
    
	Focus();
	TotalFiles();
    return true;
}

void LISTVIEW::Clear()
{
    ListView_DeleteAllItems(hListWnd);
    SetWindowText(g_hwnd, "xbExplorer - not connected");
}

void LISTVIEW::ChangeListView(DWORD dwView)
{
	DWORD dwStyle;

	dwStyle = GetWindowLong(hListWnd, GWL_STYLE);

	if ((dwStyle & LVS_TYPEMASK) != dwView)
	{
		SetWindowLong(hListWnd, GWL_STYLE, (dwStyle & ~LVS_TYPEMASK) | dwView);
	}
}

void LISTVIEW::CheckFiles(int *totalfolders, int *totalfiles, int *totalsize)
{
	char str[SHORTFILELEN * 2] = "";
	int i, items, nItem, len;

	*totalfiles = *totalsize = *totalfolders = 0;
	items = ListView_GetItemCount(hListWnd);
	for (nItem = 0; nItem < items; nItem++)
	{
        
        ListView_GetItemText(hListWnd, nItem, COLUMN_SIZE, str, SHORTFILELEN * 2);
		len = MyStrlen(str);
		if (len && MyStrcmp(str, CHAR_DIR))
		{
			(*totalfiles)++;
			for (i = 0; i < len; i++)
			{
				if (str[i] == '\0') break;
				else if (str[i] == ',')
				{
					str[i] = '\0';
					strcat(str, &str[i] + 1);
				}
			}
			(*totalsize) += atoi(str);
		}
		else
		{
			ListView_GetItemText(hListWnd, nItem, COLUMN_NAME, str, SHORTFILELEN * 2);
			if (MyStrcmp(str, "..")) (*totalfolders)++;
		}
	}
}

BOOL LISTVIEW::CheckSelectedFiles(int *totalfolders, int *totalfiles, int *totalsize)
{
	char str[512] = "";
	BOOL parentfolder = FALSE;
	int i, nItem, len;

	nItem = -1;
    *totalfiles = *totalsize = *totalfolders = 0;
	while((nItem = ListView_GetNextItem(hListWnd, nItem, LVNI_ALL | LVNI_SELECTED)) > -1)
	{
		ListView_GetItemText(hListWnd, nItem, COLUMN_SIZE, str, 512);
		len = MyStrlen(str);
		if (len && MyStrcmp(str, CHAR_DIR))
		{
			(*totalfiles)++;
			for (i = 0; i < len; i++)
			{
				if (str[i] == '\0') break;
				else if (str[i] == ',')
				{
					str[i] = '\0';
					strcat(str, &str[i] + 1);
				}
			}
			(*totalsize) += atoi(str);
		}
		else
		{
			ListView_GetItemText(hListWnd, nItem, COLUMN_NAME, str, 512);
			if (MyStrcmp(str, "..")) (*totalfolders)++;
			else parentfolder = TRUE;
		}
	}
	return parentfolder;
}

int LISTVIEW::GetNumSelected()
{
	int nSelected, nItem;

	nSelected = 0;
    nItem = -1;
	while((nItem = ListView_GetNextItem(hListWnd, nItem, LVNI_ALL | LVNI_SELECTED)) > -1)
        nSelected++;

    return nSelected;
}
BOOL LISTVIEW::IsParentFolder(int iItem)
{
    return FALSE;
	char str[256];
	ListView_GetItemText(hListWnd, iItem, COLUMN_NAME, str, 256);
	if (! MyStrcmp(str, "..")) return TRUE;
	return FALSE;
}

BOOL LISTVIEW::IsFolder(int iItem)
{
	char str[256];
	ListView_GetItemText(hListWnd, iItem, COLUMN_SIZE, str, 256);
	if (! MyStrcmp(str, CHAR_DIR)) return TRUE;
	return FALSE;
}

int LISTVIEW::GetItemAtPoint(POINT *ppt)
{
    RECT rc;
    
	int nItem = ListView_GetItemCount(hListWnd);
    for (int i = 0; i < nItem; i++)
    {
        ListView_GetItemRect(hListWnd, i, &rc, LVIR_BOUNDS);
        if (PtInRect(&rc, *ppt))
            return i;   // Just return first one we're over.
    }

    return ITEM_NONE;
}

bool LISTVIEW::SetDragHighlight(bool fEnable, POINT *pptScreen)
{
    int nItem;
    RECT rc;

    // First, determine whether or not we want to set the highlight
    if (fEnable)
    {
        // Convert the screen coordinate into list coordinate
        ScreenToClient(g_hwnd, pptScreen);

        // Offset by the toolbar
		GetWindowRect(toolview.GethWnd(), &rc);

        pptScreen->y -= (rc.bottom - rc.top);
        
        // Check if the specified cursor point is over a directory in the list; if so, then
        // we need to hilight the directory and store it's name so that we know to copy into it

        nItem = GetItemAtPoint(pptScreen);
        if (!IsFolder(nItem))
            nItem = ITEM_NONE; 
    }
    else
        nItem = ITEM_NONE;

    // Determine if we need to remove the old highlight
    if (nItem != m_nDragHighlightItem && m_nDragHighlightItem != ITEM_NONE)
    {
        // A different item (or NO item) is being highlighted; unhighlight the previously highlighted
        // item.  Note: only unhighlight the item if it was not already selected (ie part of the 
        // drag list).
        ListView_SetItemState(hListWnd, m_nDragHighlightItem, 0, LVIS_DROPHILITED);
        m_nDragHighlightItem = ITEM_NONE;
    }

    // Finally, add a new highlight if appropriate
    if (nItem != ITEM_NONE)
    {
        ListView_SetItemState(hListWnd, nItem, LVIS_DROPHILITED, LVIS_DROPHILITED);
        m_nDragHighlightItem = nItem;

        return true;
    }

    return false;
}

//return true ONLY if current drag item == directory
bool LISTVIEW::GetDragItemName(char szName[MAX_PATH])
{
    // if no item selected, then return false
    if (m_nDragHighlightItem == ITEM_NONE)
        return false;

    if (!IsFolder(m_nDragHighlightItem))
        return false;

    // It's a folder - grab its name
    ListView_GetItemText(hListWnd, m_nDragHighlightItem, COLUMN_NAME, szName, MAX_PATH);

    return true;
}

void LISTVIEW::Focus()
{
//	ListView_SetItemState(hListWnd, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
	ListView_EnsureVisible(hListWnd, 0, TRUE);
	SetFocus(hListWnd);
}

BOOL LISTVIEW::IsSelected(int nItem)
{
	return (BOOL) ListView_GetItemState(hListWnd, nItem, LVIS_SELECTED);
}

int LISTVIEW::IsExistence(char* str)
{
	char name[SHORTFILELEN] = "";
	int nItem, items;
	items = ListView_GetItemCount(hListWnd);
	for (nItem = 0; nItem < items; nItem++)
	{
		ListView_GetItemText(hListWnd, nItem, COLUMN_NAME, name, SHORTFILELEN);
		if (! MyStricmp(name, str)) return nItem;
	}
	return -1;
}

void LISTVIEW::ChangeView(DWORD dwView)
{
	DWORD dwStyle;

	dwStyle = GetWindowLong(hListWnd, GWL_STYLE);

    SetWindowLong (hListWnd, GWL_STYLE, (dwStyle & ~LVS_TYPEMASK) | dwView);
	viewmode = dwView;
}

DWORD LISTVIEW::GetViewMode()
{
	return viewmode;
}

bool LISTVIEW::PopulateWithSelected(CFileContainer *pfc)
{
    // Enumerate the list of selected items and add them to the specified file container
	char szFile[512] = "";
	int nItem;
    char szBuf[MAX_PATH];
    bool fFiles = false;
	nItem = -1;
	while((nItem = ListView_GetNextItem(hListWnd, nItem, LVNI_ALL | LVNI_SELECTED)) > -1)
	{
        ListView_GetItemText(hListWnd, nItem, COLUMN_NAME, szFile, 512);
        wsprintf(szBuf, "%s%s", g_CurrentDir, szFile);
        ListView_GetItemText(listview.GetHwnd(), nItem, COLUMN_SIZE, szFile, MAX_PATH);
        if (!MyStrcmp(szFile, CHAR_DIR))
            pfc->AddDir(szBuf);
        else
            pfc->AddFile(szBuf);
        fFiles = true;
	}

    return fFiles;
}

void LISTVIEW::Delete(HWND hwndOwner)
{
    bool fDelete = (hwndOwner == NULL);

    // Logic flow:
    //  If the user selected one file
    //      if the file is read only
    //          display the 'this file is read only' dialog.
    //      else
    //          display the regular 'delete' dialog.
    //  else
    //      display the regular 'delete' dialog
    //      for each file
    //          if the file is read only
    //              display the 'this file is read only' dialog.

	char str[MAX_PATH], szFile[MAX_PATH];
	int i, count;
    bool fReadOnly = false;
    DM_FILE_ATTRIBUTES dmfa;
    int cFiles = 0;

    // Check if any of the selected files are read-only
    count = ListView_GetItemCount(hListWnd);
	for (i = 0; i < count; i++)
	{
		if (listview.IsSelected(i))
		{
			ListView_GetItemText(hListWnd, i, COLUMN_NAME, str, MAX_PATH);

            // Check if the file is a readonly file
            wsprintf(szFile, "%s%s", g_CurrentDir, str);
            xbfu.GetFileAttributes(szFile, &dmfa);
            if (dmfa.Attributes & FILE_ATTRIBUTE_READONLY)
            {
                fReadOnly = true;
                break;
            }
		}
	}

    if (hwndOwner)
    {
        // Ask the user if they want to actually delete the files
        int totalfolders, totalfiles, totalsize;
	    listview.CheckSelectedFiles(&totalfolders, &totalfiles, &totalsize);
	    if (totalfolders || totalfiles)
	    {
            if (totalfiles + totalfolders > 1 || !fReadOnly)
            {
                // More than one file/folder specified, or none of them were read only.
                // display the 'deletion confirmation' dialog
		        char str[128];
		        strcpy(str, "Delete ");
		        if (totalfolders)
		        {
			        wsprintf(str, "%s%d folder", str, totalfolders);
			        if (totalfolders > 1) strcat(str, "s");
			        if (totalfiles) strcat(str, " and ");
		        }
		        if (totalfiles)
		        {
			        wsprintf(str, "%s%d file", str, totalfiles);
			        if (totalfiles > 1) strcat(str, "s");
		        }
		        strcat(str, "?");
		        if (MessageBox(hwndOwner, str, szAppName, MB_YESNO) == IDYES)
                    fDelete = true;
            }
            else
                fDelete = true;
        }
    }
    
    if (fDelete)
    {
		char str[MAX_PATH];
		int i, count;
        bool fQuery = true;
		count = ListView_GetItemCount(hListWnd);
		for (i = 0; i < count; i++)
		{
			if (listview.IsSelected(i))
			{
				ListView_GetItemText(hListWnd, i, COLUMN_NAME, str, MAX_PATH);
                if (MyStrcmp(str, ".."))
                {
                    sprintf(szFile, "%s%s", g_CurrentDir, str);
                    if (!xbfu.Del(szFile, &fQuery, GetHwnd()))
                        break;
                }
            }
		}
    	SortListView(-1, FALSE);
    }

    // Clear the clipboard when done
    if (m_fCut)
        OleSetClipboard(NULL);
}

bool g_fForceWaitCursor = false;

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  LISTVIEW::CutCopy
// Purpose:   
// Arguments: UNDONE-WARN: Fill in
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void LISTVIEW::CutCopy(bool fCut)
{
    // Create the IDataObject that contains information about the files being copied
    CFileContainer *pfc = new CFileContainer;

    g_fForceWaitCursor = true;
    SetCursor(LoadCursor(NULL, IDC_WAIT));

    // Populate the new file container with the files that are selected in us.
    bool fFiles = PopulateWithSelected(pfc);
 
    SetCursor(LoadCursor(NULL, IDC_ARROW));

    g_fForceWaitCursor = false;

    if (!fFiles)
    {
        OleSetClipboard(NULL);
        return;
    }

    IDataObject *pidataobject; 
    if (FAILED(pfc->QueryInterface(IID_IDataObject, (LPVOID*)&pidataobject)))
        return;

    m_fCut = fCut;
    pfc->m_fCut = fCut;
    strcpy(g_szCopyDir, g_CurrentDir);
    OleSetClipboard(pidataobject);  // addrefs it.


    pidataobject->Release();
    pfc->Release();

//    __asm int 3;
    if (fCut)
    {
        LV_ITEM lvI;

        // Set the currently selected files to 'cut' icons
	    int cItems = ListView_GetItemCount(hListWnd);
	    for (int i = 0; i < cItems; i++)
	    {
		    if (listview.IsSelected(i))
		    {
	            lvI.iItem = i;
	            lvI.mask = LVIF_STATE;
	            lvI.stateMask = LVIS_CUT;
	            lvI.state = LVIS_CUT;
	            ListView_SetItem(hListWnd, &lvI);
		    }
	    }
    }
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  LISTVIEW::Paste
// Purpose:   
// Arguments: UNDONE-WARN: Fill in
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void LISTVIEW::Paste()
{
    IDataObject *pidataobject; 
    STGMEDIUM stgm;
    sSourceInfo sourceinfo;
    char szBuf[512], szBuf2[100];
    bool fContinue, fSkipped;

    // UNDONE-WARN: I'm sure I could be reusing code between this and the drag/drop code.  Revisit later.
    // Get the data object from the clipboard
    OleGetClipboard(&pidataobject);
    
    // Start the thread that handles the progress dialog.  It won't actually display anything for
    // a couple of seconds to avoid displaying it for small copies...
    g_progress.StartThread();
    
    bool fQuery = true;
    GetDropSourceInfo(pidataobject, &sourceinfo);
    if (sourceinfo.fXbox)
    {
//        if (MyStrcmp(sourceinfo.szName, g_TargetXbox))
        if (g_hwnd != sourceinfo.hwnd)
        {
            // We don't allow copying from one xbExplorer to another yet
            LoadString(hInst, IDS_XTOX_COPY_NOT_ALLOWED, szBuf, 512);
            LoadString(hInst, IDS_UNSUPPORTED_FEATURE, szBuf2, 100);

            MessageBox(g_hwnd, szBuf, szBuf2, MB_ICONWARNING | MB_OK);
            goto done;
        }

        // Xbox->Xbox (same) copy.
        FORMATETC fmte= {(USHORT)g_suXboxFiles,  NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        if (pidataobject->GetData(&fmte, &stgm) == S_OK)
        {
            char szDestFilePath[MAX_PATH];

            // Get the list of filenames
            DROPFILES *pdf = (DROPFILES*)GlobalLock(stgm.hGlobal);
            char *szNextSourcePathFile = (char*)(pdf) + pdf->pFiles;

            while (*szNextSourcePathFile)
            {
                char *pszSource;

                if (pdf->fWide)
                {
                    // Convert from wide to single byte
                    pszSource = WideToSingleByte((WCHAR*)szNextSourcePathFile);
                }
                else
                    pszSource = szNextSourcePathFile;

                wsprintf(szDestFilePath, "%s%s", g_CurrentDir, pszSource + MyStrlen(g_szCopyDir));

                // Perform the actual copy.
                // NOTE: This code is only called in the Xbox->Xbox case.
                fContinue = (xbfu.CopyMoveToXbox(pszSource, szDestFilePath, &fQuery, true, true,
                                                 true, m_fCut, &fSkipped) == S_OK);
                if (!fContinue)
                    break;

				if (!fSkipped && m_fCut)
				{
					bool f = false;
					xbfu.Del(pszSource, &f, g_hwnd);
				}

                DeferSelected(strrchr(szDestFilePath, '\\') + 1);

                if (pdf->fWide)
                    szNextSourcePathFile += (MyStrlen(pszSource)+1)*2;
                else
                    szNextSourcePathFile += MyStrlen(pszSource)+1;
            }

            szNextSourcePathFile = (char*)(pdf) + pdf->pFiles;

            GlobalUnlock(stgm.hGlobal);
        }
        else
        {
            // UNDONE-ERR: Handle error case
        }
    }
    else
    {
        // PC->Xbox copy.
        // Request the contents of the file.  Because it's coming from the PC, we
        // can just request it as an HDROP and use the names to copy the files using
        // XboxDbg.  There's currently no way to stream directly to the Xbox.
        bool fCut;

        // Check if the source was a 'cut' command
        FORMATETC fmte= {(USHORT)g_suPrefDropEffect,  NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        if (pidataobject->GetData(&fmte, &stgm) == S_OK)
        {
            DWORD *pdwEffect = (DWORD*)GlobalLock(stgm.hGlobal);
            fCut = (*pdwEffect == DROPEFFECT_MOVE);
            GlobalUnlock(stgm.hGlobal);
        }
        else
            fCut = false;

       
        fmte.cfFormat = (USHORT)CF_HDROP;
        if (pidataobject->GetData(&fmte, &stgm) == S_OK)
        {
            char szDestFilePath[MAX_PATH];

            // Get the list of filenames
            DROPFILES *pdf = (DROPFILES*)GlobalLock(stgm.hGlobal);
            char *szNextSourcePathFile = (char*)(pdf) + pdf->pFiles;
            while (*szNextSourcePathFile)
            {
                char *pszSource;

                if (pdf->fWide)
                {
                    // Convert from wide to single byte
                    pszSource = WideToSingleByte((WCHAR*)szNextSourcePathFile);
                }
                else
                    pszSource = szNextSourcePathFile;

                wsprintf(szDestFilePath, "%s%s", g_CurrentDir, strrchr(pszSource,'\\') + 1);

                // Perform the actual copy.  The 'Copy' command will take care of directories auto-
                // matically (ie creating and recursively copying them).
                // NOTE: This code is only called in the Xbox->Xbox or PC->Xbox cases.
            	fContinue = (xbfu.CopyMoveToXbox(pszSource, szDestFilePath, &fQuery, true, sourceinfo.fXbox, true, fCut, &fSkipped) == S_OK);
                if (!fContinue)
                    break;

                DeferSelected(strrchr(szDestFilePath, '\\') + 1);
            
                if (pdf->fWide)
                    szNextSourcePathFile += (MyStrlen(pszSource)+1)*2;
                else
                    szNextSourcePathFile += MyStrlen(pszSource)+1;
            }

            GlobalUnlock(stgm.hGlobal);

            if (fCut)
            {
                // Source was a cut.  inform it that the paste was done.
                fmte.cfFormat = (USHORT)g_suPerfDropEffect;
                stgm.pUnkForRelease = 0;
                stgm.hGlobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_SHARE, 12);
                if (!stgm.hGlobal)
                    goto done;
                stgm.tymed = TYMED_HGLOBAL;
                DWORD *pdwEffect = (DWORD*)GlobalLock(stgm.hGlobal);
                *pdwEffect = DROPEFFECT_MOVE;
                GlobalUnlock(stgm.hGlobal);
                pidataobject->SetData(&fmte, &stgm, true);

                // Inform the caller that the paste succeeded
                fmte.cfFormat = (USHORT)g_suPasteSucceeded;

                stgm.hGlobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_SHARE, 12);
                if (!stgm.hGlobal)
                    goto done;
                stgm.tymed = TYMED_HGLOBAL;
                pdwEffect = (DWORD*)GlobalLock(stgm.hGlobal);
                *pdwEffect = fSkipped ? DROPEFFECT_NONE : DROPEFFECT_MOVE;
                GlobalUnlock(stgm.hGlobal);
                pidataobject->SetData(&fmte, &stgm, true);
            }
        }
        else
        {
            // UNDONE-ERR: Handle error case
        }
    }

done:
    // We're done with our data object, so release our reference to it.
    pidataobject->Release();

    g_progress.EndThread();
    
    // redraw
    SortListView(-1, FALSE);
}


bool LISTVIEW::BeginDrag()
{
    ULONG dwEffect = DROPEFFECT_MOVE | DROPEFFECT_COPY; 
    
    strcpy(g_szCopyDir, g_CurrentDir);

    // Create the IDataObject that contains information about the files being copied
    CFileContainer *pfc = new CFileContainer;

    // Populate the new file container with the files that are selected in us.
    PopulateWithSelected(pfc);

    // Create the drop source object
    CDropSource *pdropsource = new CDropSource;
    pdropsource->AddRef();
    
    IDropSource *pidropsource; 
    if (FAILED(pdropsource->QueryInterface(IID_IDropSource, (LPVOID*)&pidropsource)))
        return false;

    // And then perform the actual drag and drop.  This is a modal call...
    DoDragDrop((IDataObject*)pfc, pidropsource, dwEffect, &dwEffect);

    if (dwEffect == DROPEFFECT_MOVE)
        pfc->m_fCut = true;

	pidropsource->Release();
    pdropsource->Release();
    pfc->Release();
    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\resrc1.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by xbExplorer.rc
//
#define IDC_OVERWRITE_TEXT              1039
#define IDC_ANIM                        1040
#define IDC_FILENAME                    1041
#define IDS_CONFIRM_RO_FOLDER           40022
#define IDS_CONFIRM_RO_FILE             40023
#define IDS_XTOX_COPY_NOT_ALLOWED       40024
#define IDS_UNSUPPORTED_FEATURE         40025
#define IDS_CONFIRM_RO_FILE_MOVE        40026
#define IDS_CONFIRM_RO_FOLDER_MOVE      40027
#define IDS_CONFIRM_RO_MOVE             40028
#define IDS_GENERAL                     40029
#define IDS_COLUMN_NAME                 40030
#define IDS_COLUMN_SIZE                 40031
#define IDS_COLUMN_TYPE                 40032
#define IDS_COLUMN_MODIFIED             40033
#define IDS_BINARY                      40034
#define IDS_BAD_DATE                    40035
#define IDS_PROPERTIES                  40036
#define IDS_XBOX_NOT_RESPONDING_QUERY   40037
#define IDS_XBOX_NOT_RESPONDING         40038
#define IDS_CONFIRM_FILE_OVERWRITE      40039
#define IDS_CONFIRM_FOLDER_OVERWRITE    40040
#define IDS_CONFIRM_RENAME_RO_FOLDER_QUERY 40041
#define IDS_CONFIRM_RENAME_RO_FOLDER    40042
#define IDS_CONFIRM_RENAME_RO_FILE      40043
#define IDS_CONFIRM_RENAME_RO_FILE_QUERY 40044
#define IDS_FAIL_RENAME                 40045
#define IDS_FAIL_RENAME_CAPTION         40046
#define IDS_CANT_MOVE_SAME_NAME_TEXT    40047
#define IDS_CANT_MOVE_SAME_NAME_CAPTION 40048
#define IDS_FILENAME_TOO_LONG_TEXT      40049
#define IDS_FILENAME_TOO_LONG_CAPTION   40050
#define IDS_CANT_MOVE_SUBFOLDER_CAPTION 40051
#define IDS_CANT_MOVE_SUBFOLDER_TEXT    40052
#define IDS_CONFIRM_FILE_MOVE_CAPTION   40053
#define IDS_CONFIRM_FOLDER_MOVE_CAPTION 40054
#define IDS_CONFIRM_FILE_MOVE_TEXT      40055
#define IDS_CONFIRM_FOLDER_MOVE_TEXT    40056
#define IDS_NOSPACE_TEXT                40057
#define IDS_NOSPACE_CAPTION             40058
#define IDS_FAILED_COPYMOVE_TEXT        40059
#define IDS_FAILED_COPYMOVE_CAPTION     40060
#define IDS_CANT_COPY_SAME_NAME_TEXT    40061
#define IDS_CANT_COPY_SAME_NAME_CAPTION 40062
#define IDS_RENAME                      40063

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        136
#define _APS_NEXT_COMMAND_VALUE         40043
#define _APS_NEXT_CONTROL_VALUE         1042
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\Registry.cpp ===
//
//	Registry I/O class
//
//	Author: Shinji Chiba 1997-1-23
//

#include "stdafx.h"

REGISTRY::REGISTRY()
{
	hMainKey = NULL;
}

REGISTRY::~REGISTRY()
{
}

void REGISTRY::Init( HKEY hKey, char *szName )
{
	hMainKey = hKey;
	lstrcpy( szSubkey, szName );
}

BOOL REGISTRY::GetString( char *szName, char *szValue )
{
	HKEY hKey;
	DWORD dwType = REG_SZ;
	DWORD dwByte = REG_STRMAX;

	if ( ! hMainKey ) return FALSE;
	if ( RegOpenKeyEx( hMainKey, szSubkey, 0, KEY_READ, &hKey ) ) return FALSE;
	if( RegQueryValueEx( hKey, szName, NULL, &dwType, (LPBYTE) szValue, &dwByte )) return FALSE;
	RegCloseKey( hKey );
	return TRUE;
}

BOOL REGISTRY::GetValue( char *szName, LPDWORD dwRet )
{
	HKEY hKey;
	DWORD dwType = REG_DWORD;
	DWORD dwByte = REG_STRMAX;

	if ( ! hMainKey ) return FALSE;
	if ( RegOpenKeyEx( hMainKey, szSubkey, 0, KEY_READ, &hKey ) ) return FALSE;
	if( RegQueryValueEx( hKey, szName, NULL, &dwType, (LPBYTE) dwRet, &dwByte )) return FALSE;
	RegCloseKey( hKey );
	return TRUE;
}

BOOL REGISTRY::SetString( char *szName, char *szData )
{
	HKEY hKey;
	DWORD dw;
	LONG lResult;

	if ( ! hMainKey ) return FALSE;
	RegCreateKeyEx( hMainKey, szSubkey, 0, "", REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, &dw );
	lResult = RegSetValueEx( hKey, szName, 0, REG_SZ, (CONST LPBYTE) szData, MyStrlen( szData ) );
	RegCloseKey( hKey );
	return TRUE;
}

BOOL REGISTRY::SetValue( char *szName, DWORD dwData )
{
	HKEY hKey;
	DWORD dw;

	if ( ! hMainKey ) return FALSE;
	RegCreateKeyEx( hMainKey, szSubkey, 0, "", REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, &dw );
	RegSetValueEx( hKey, szName, 0, REG_DWORD, (CONST LPBYTE) &dwData, sizeof(DWORD) );
	RegCloseKey( hKey );
	return TRUE;
}

BOOL REGISTRY::Delete( char *sub/* = NULL */, HKEY main/* = NULL */ )
{
	if ( ! main )
	{
		if ( ! hMainKey ) return FALSE;
		main = hMainKey;
	}
	if ( sub ) RegDeleteKey( main, sub );
	else RegDeleteKey( main, szSubkey );
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\StatusView.cpp ===
#include "stdafx.h"

STATUSVIEW::STATUSVIEW()
{
	hStatusWnd = NULL;
}

STATUSVIEW::~STATUSVIEW()
{
}

void STATUSVIEW::SetSeparateSize( int size )
{
	sb_size[1] = size;
	sb_size[0] = size / 2;
}

HWND STATUSVIEW::GethWnd()
{
	return hStatusWnd;
}

HWND STATUSVIEW::CreateStatusView( HWND hWndParent )
{
	RECT rect;

	GetClientRect( hWndParent, &rect );
	SetSeparateSize( rect.right );
	hStatusWnd = CreateStatusWindow( WS_CHILD | WS_VISIBLE | CCS_BOTTOM | SBARS_SIZEGRIP, NULL, hWndParent, ID_STATUS );
	SendMessage( hStatusWnd, SB_SETPARTS, N_SEPARATE, (LPARAM) sb_size );
	GetClientRect( hStatusWnd, &statusRect );
	if ( ! hStatusWnd ) return NULL;
	return hStatusWnd;
}

HWND STATUSVIEW::RedrawStatusView( HWND hWndParent, WPARAM wParam, LPARAM lParam )
{
	SetSeparateSize( LOWORD( lParam ) );
	SendMessage( hStatusWnd, SB_SETPARTS, N_SEPARATE, (LPARAM) sb_size );
    SendMessage( hStatusWnd, WM_SIZE, wParam, lParam );
	return hStatusWnd;
}

void STATUSVIEW::SetText( int nseparate, LPCTSTR str )
{
	SendMessage( hStatusWnd, SB_SETTEXT, nseparate, (LPARAM) str );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by xbExplorer.rc
//
#include <windows.h>
#define IDCANCEL2                       3
#define ID_TOOLBAR                      114
#define IDB_TOOLBAR                     121
#define IDD_FILEPROP                    126
#define IDB_BITMAP1                     127
#define IDD_ABOUT                       128
#define IDC_ROTX                        1000
#define IDC_ABOUTINFO                   1001
#define IDC_TARGETNAME                  1002
#define IDC_XBOXLINK                    1003
#define IDC_MSLINK                      1004
#define IDC_SHOWSPLASH                  1005
#define IDC_CHECK1                      1007
#define IDC_FOLDERPROP_ATTR_RO          1007
#define IDC_CHECK2                      1008
#define IDC_FOLDERPROP_ATTR_HIDDEN      1008
#define IDC_EDIT1                       1009
#define IDC_FOLDEREPROP_EDIT_NAME       1009
#define IDC_FILEPROP_EDIT_TYPE          1010
#define IDC_FILEPROP_EDIT_DESC          1011
#define IDC_FILEPROP_EDIT_LOC           1012
#define IDC_FILEPROP_EDIT_SIZE          1013
#define IDC_FILEPROP_EDIT_SIZEONDISK    1014
#define IDC_FILEPROP_EDIT_CREATED       1015
#define IDC_FILEPROP_EDIT_MODIFIED      1016
#define IDC_FILEPROP_EDIT_ACCESSED      1017
#define IDC_FILEPROP_EDIT_NAME          1018
#define IDC_FOLDEREPROP_EDIT_TYPE       1019
#define IDC_FOLDEREPROP_EDIT_LOC        1020
#define IDC_FOLDERPROP_ICON             1021
#define IDC_FOLDEREPROP_EDIT_SIZE       1022
#define IDC_FOLDEREPROP_EDIT_SIZEONDISK 1023
#define IDC_FOLDEREPROP_EDIT_CONTAINS   1024
#define IDC_FOLDEREPROP_EDIT_CREATED    1025
#define IDC_TAB                         1026
#define IDC_FILEPROP_ICON               1027
#define IDC_FILEPROP_ATTR_RO            1028
#define IDC_FILEPROP_ATTR_HIDDEN        1029
#define IDAPPLY                         1030
#define IDM_ABOUT                       40001
#define IDM_REBOOT                      40003
#define IDM_TARGETMACHINE               40004
#define IDM_UPLOAD                      40008
#define IDM_DOWNLOAD                    40009
#define IDM_RENAME                      40010
#define IDM_DELETE                      40011
#define IDM_ALLSELECT                   40012
#define IDM_BACK                        40013
#define IDM_FORWARD                     40014
#define IDM_VIEWLIST                    40015
#define IDM_VIEWDETAIL                  40016
#define IDM_DOWNLOADDIR                 40017
#define IDM_PARENTDIR                   40018
#define IDM_VIEWOPTION                  40019
#define IDM_MKDIR                       40020
#define IDM_DELREG                      40021
#define IDS_APP_TITLE                   40021
#define IDM_EXIT                        40022
#define IDM_VIEWLARGEICONS              40023
#define IDM_VIEWSMALLICONS              40024
#define IDM_ARRANGE_BYNAME              40027
#define IDM_ARRANGE_BYTYPE              40028
#define IDM_ARRANGE_BYSIZE              40029
#define IDM_ARRANGE_BYDATE              40030
#define IDM_REFRESH                     40032
#define IDM_NEW_FOLDER                  40033
#define IDM_PROPERTIES                  40034
#define IDM_CUT                         40035
#define IDM_COPY                        40036
#define IDM_PASTE                       40037
#define ID_EDIT_PASTETCTRLV             40040
#define ID_EDIT_SELECTALL               40041
#define ID_EDIT_DELETE                  40042
#define IDC_STATIC			-1
#define ABOUTDLG                        128
#define IDD_CONFIRMREPLACE              129
#define IDC_YES                         1032
#define IDC_YESALL                      1033
#define IDC_NOPE                        1034
#define IDC_CANCEL                      1035
#define IDC_FILE_TEXT                   1037
#define IDC_FOL_TEXT                    1038

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         40043
#define _APS_NEXT_CONTROL_VALUE         1031
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\StdAfx.cpp ===
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\StatusView.h ===
#ifndef __STATUSVIEW_H__
#define __STATUSVIEW_H__

#define N_SEPARATE 2
#define ID_STATUS 100

enum {
	SELECTED_STATUS,
	TOTAL_STATUS
};

class STATUSVIEW
{
private:
	HWND hStatusWnd;
	RECT statusRect;
	int sb_size[N_SEPARATE];

private:
	void SetSeparateSize( int );

public:
	STATUSVIEW();
	~STATUSVIEW();
	HWND GethWnd();
	HWND CreateStatusView( HWND );
	HWND RedrawStatusView( HWND, WPARAM, LPARAM );
	void SetText( int, LPCTSTR );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\StdAfx.h ===
#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <windows.h>
#include <ole2.h>
#include <shlobj.h>
#include <shellapi.h>
#include <shlguid.h>  
#include <commctrl.h>
#include "resource.h"
#include "resrc1.h"
#include "CXboxstream.h"
#include "CDropSource.h"
#include "CDropTarget.h"
#include "Registry.h"
#include "History.h"
#include "ListView.h"
#include "Registry.h"
#include "StatusView.h"
#include "resource.h"
#include "TargetMachine.h"
#include "ToolView.h"
#include "ViewOption.h"
#include "xboxdbg.h"
#include "DlgProcs.h"
#include "XBFU.h"
#include "xbExplorer.h"
#include "CFileContainer.h"
#include "CProperties.h"
#include "CXboxConnection.h"
#include "CProgress.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\TargetMachine.cpp ===
#include "stdafx.h"

LRESULT CALLBACK TargetDlg( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam )
{
	switch( message )
	{
	case WM_INITDIALOG:
		SetDlgItemText( hDlg, IDC_TARGETNAME, g_TargetXbox );
		CenterDialog( hDlg );
		return TRUE;
	case WM_COMMAND:
		switch( LOWORD( wParam ) )
		{
		case IDOK:
			GetDlgItemText( hDlg, IDC_TARGETNAME, g_TargetXbox, sizeof(g_TargetXbox) );
		case IDCANCEL:
			EndDialog( hDlg, LOWORD( wParam ) );
			return TRUE;
		}
		break;
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\TargetMachine.h ===
#ifndef __TARGETMACHINE_H__
#define __TARGETMACHINE_H__

LRESULT CALLBACK TargetDlg( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\ViewOption.h ===
#ifndef __VIEWOPTION_H__
#define __VIEWOPTION_H__

LRESULT CALLBACK ViewOptionDlg( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\ToolView.h ===
#ifndef __TOOLVIEW_H__
#define __TOOLVIEW_H__

#undef FOURBUTTONS

#ifdef FOURBUTTONS
#define N_TOOLS 4
#else
#define N_TOOLS 2
#endif
#define N_DRIVE 26
#define ID_COMBOBOX 101
#define ID_REBAR 102

class TOOLVIEW
{
private:
	HWND hWndCB, hWndTB;
	HWND hToolWnd;
	void CreateToolBar( HWND );
	void CreateComboBox( HWND );
	int InsertDriveNameToComboBox();

	RECT toolRect;
	static TBBUTTON tbb[N_TOOLS];
	const static TBBUTTON tb;
	const static char *drivename[N_DRIVE];

public:
	void InsertToolBar();
	void InsertComboBox();
	TOOLVIEW();
	~TOOLVIEW();
	HWND GethWnd();
	HWND CreateToolView( HWND );
	HWND RedrawToolView( HWND );
    void Refresh();
    void Clear();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\ViewOption.cpp ===
#include "stdafx.h"

LRESULT CALLBACK ViewOptionDlg( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam )
{
	switch( message )
	{
	case WM_INITDIALOG:
		if ( splashscreen ) CheckDlgButton( hDlg, IDC_SHOWSPLASH, BST_CHECKED );
		CenterDialog( hDlg );
		return TRUE;
	case WM_COMMAND:
		switch( LOWORD( wParam ) )
		{
		case IDOK:
			if ( IsDlgButtonChecked( hDlg, IDC_SHOWSPLASH ) == BST_CHECKED ) splashscreen = TRUE;
			else splashscreen = FALSE;
		case IDCANCEL:
			EndDialog( hDlg, TRUE );
			return TRUE;
		}
		break;
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\xbExplorer.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     xbexplorer.cpp
// Contents: UNDONE-WARN: Add file description
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


#define DEFAULTXSIZE 510
#define DEFAULTYSIZE 440
#define MAINKEY HKEY_CURRENT_USER
#define SUBKEYATGXFBU	"Software\\Microsoft\\XboxSDK\\xbExplorer"
#define ATGKEYCURDIR	"Current"
#define ATGKEYDLDIR		"Download"
#define ATGKEYX			"x"
#define ATGKEYY			"y"
#define ATGKEYCX		"cx"
#define ATGKEYCY		"cy"
#define ATGKEYSPLASH	"Splash"
#define ATGKEYVIEW		"View"
#define MUTEXOFCH3SCMPX	"_XboxFileManager"
#define STARTUPDIR		"XE:\\"
#define NEWDIRNAME		"New Folder"
#define MULTIFILES		256
#ifdef JAPANESE
#define FILTER	"fBA (*.bmp;*.jpg;*.wav;*.mpg;*.wma;*.wmv;*.dls)\0*.bmp;*.jpg;*.wav;*.mpg;*.wma;*.wmv;*.dls\0"	\
				"Xbest@C (*.xbe)\0*.xbe\0"	\
				"XboxtHg (*.abc)\0*.abc\0"		\
				"ׂẴt@C (*.*)\0*.*\0"
#define OUTPUTDIRSTR "_E[hw肵Ă"
#else
#define FILTER	"Media files (*.bmp;*.jpg;*.wav;*.mpg;*.wma;*.wmv;*.dls)\0*.bmp;*.jpg;*.wav;*.mpg;*.wma;*.wmv;*.dls\0"	\
				"Xbe file (*.xbe)\0*.xbe\0"		\
				"Xbox font (*.abc)\0*.abc\0"	\
				"All Types (*.*)\0*.*\0"
#define OUTPUTDIRSTR "Select a directory for download."
#endif

char szAppName[] = "xbExplorer";
char szResName[] = "xbExplorer";
char szClassName[] = MUTEXOFCH3SCMPX;
int g_iPopupFileItem;
HINSTANCE hInst;
char g_TargetXbox[256];
char g_CurrentDir[MAX_PATH];
LISTVIEW listview;
STATUSVIEW statusview;
TOOLVIEW toolview;
HISTORY history;
BOOL splashscreen;
XBFU xbfu;
HWND g_hwnd;
int g_iTimer;

UINT g_suFileGroupDesc;
UINT g_suFileContents;
UINT g_suXboxObject;
UINT g_suXboxFiles;
UINT g_suPrefDropEffect;
UINT g_suPerfDropEffect;
UINT g_suPasteSucceeded;

CXboxConnection *g_pxboxconn;

UINT g_dropTypes[20];

// Register the clipboard formats necessary to transfer files.
bool RegisterFormats()
{
    g_suFileGroupDesc  = RegisterClipboardFormat(CFSTR_FILEDESCRIPTOR);
    g_suFileContents   = RegisterClipboardFormat(CFSTR_FILECONTENTS);
    g_suXboxObject     = RegisterClipboardFormat("XBOX_CLIP_FORMAT");
    g_suXboxFiles      = RegisterClipboardFormat("XBOX_FILES_LIST");
    g_suPrefDropEffect = RegisterClipboardFormat(CFSTR_PREFERREDDROPEFFECT);
    g_suPerfDropEffect = RegisterClipboardFormat(CFSTR_LOGICALPERFORMEDDROPEFFECT);
    g_suPasteSucceeded = RegisterClipboardFormat(CFSTR_PASTESUCCEEDED);

    // UNDONE-ERR: Need to make sure MitchD's code uses the same format so that we can talk to each other...

    return true;
}

void Init(LPRECT rect)
{
	REGISTRY *registry;
	char str[MAX_PATH] = "";
	DWORD dw, viewmode;
	RECT desktopRect;
	int x, y;
	registry = new REGISTRY;

        xbfu.GetTarget(g_TargetXbox, sizeof g_TargetXbox);

	registry->Init(MAINKEY, SUBKEYATGXFBU);
	if (registry->GetString(ATGKEYCURDIR, str))
        strcpy(g_CurrentDir, str);
	else strcpy(g_CurrentDir, STARTUPDIR);

    strcpy(g_CurrentDir, "XD:\\");

    // Handle old instance case -- if g_CurrentDir doesn't have 'x' at start, then add it
    if (g_CurrentDir[0] != 'X')
    {
        wsprintf(str, "X%s", g_CurrentDir);
        strcpy(g_CurrentDir, str);
    }
    
	if (registry->GetValue(ATGKEYX, &dw)) rect->left = (int) dw;
	else rect->left = CW_USEDEFAULT;
	if (registry->GetValue(ATGKEYY, &dw)) rect->top = (int) dw;
	else rect->top = CW_USEDEFAULT;
	if (registry->GetValue(ATGKEYCX, &dw)) rect->right = (int) dw;
	else rect->right = DEFAULTXSIZE;
	if (registry->GetValue(ATGKEYCY, &dw)) rect->bottom = (int) dw;
	else rect->bottom = DEFAULTYSIZE;
	if (registry->GetValue(ATGKEYSPLASH, &dw)) splashscreen = (BOOL) dw;
	else splashscreen = TRUE;
	viewmode = LVS_REPORT;
	if (registry->GetValue(ATGKEYVIEW, &dw))
        viewmode = dw;
	listview.ChangeView(viewmode);

    delete registry;

	SystemParametersInfo(SPI_GETWORKAREA, 0, &desktopRect, 0);
	x = rect->left + rect->right;
	y = rect->top + rect->bottom;
	if (x >= desktopRect.right) rect->left -= (x - desktopRect.right);
	if (rect->left < 0) rect->left = 0;
	if (y >= desktopRect.bottom) rect->top -= (y - desktopRect.bottom);
	if (rect->top < 0) rect->top = 0;
}

void UnInit(HWND hWnd)
{
	REGISTRY *registry;
	RECT rect;
	GetWindowRect(hWnd, &rect);
	rect.right -= rect.left;
	rect.bottom -= rect.top;
	registry = new REGISTRY;
	registry->Init(MAINKEY, SUBKEYATGXFBU);
	registry->SetString(ATGKEYCURDIR, g_CurrentDir);
	registry->SetValue(ATGKEYX, rect.left);
	registry->SetValue(ATGKEYY, rect.top);
	registry->SetValue(ATGKEYCX, rect.right);
	registry->SetValue(ATGKEYCY, rect.bottom);
	registry->SetValue(ATGKEYVIEW, (DWORD) listview.GetViewMode());
	delete registry;
}

bool Reload()
{
	if (!listview.SortListView(-1, FALSE))
        return false;
    toolview.Refresh();
    return true;
}

void SetTitleName(HWND hWnd)
{
	char str[256];
	strcpy(str, szAppName);
	strcat(str, " - ");
	strcat(str, g_TargetXbox);
	SetWindowText(hWnd, str);
}

void ReturnToParentDir()
{
	char *pStr1, *pStr2;
	char str[MAX_PATH];
	strcpy(str, g_CurrentDir);
	pStr1 = strrchr(str, '\\');
	if (pStr1)
	{
		pStr1[0] = '\0';
		pStr2 = strrchr(str, '\\');
		if (pStr2)
		{
			history.SaveHistory(g_CurrentDir);
			pStr2[1] = '\0';
			strcpy(g_CurrentDir, str);
			Reload();
		}
	}
}

void GetListRect(HWND hWnd, HWND statusWnd, HWND toolWnd, LPRECT lpRect)
{
	RECT rect2;
	GetClientRect(hWnd, lpRect);
	GetWindowRect(toolWnd, &rect2);
	lpRect->top += (rect2.bottom - rect2.top);
	GetWindowRect(statusWnd, &rect2);
	lpRect->bottom -= (rect2.bottom - rect2.top);
}

void CenterDialog(HWND hDlg)
{
	int x, y;
    POINT pt = {0};
	RECT rc, parentrc;
	GetWindowRect(hDlg, &rc);
	GetClientRect(g_hwnd, &parentrc);
    ClientToScreen(g_hwnd, &pt);
	x = pt.x + (parentrc.right / 2 - (rc.right - rc.left) / 2);
	y = pt.y + (parentrc.bottom / 2 - (rc.bottom - rc.top) / 2);
	SetWindowPos(hDlg, NULL, x, y, 0, 0, SWP_NOZORDER | SWP_NOSIZE | SWP_SHOWWINDOW);
    BringWindowToTop(hDlg);
}

char *FormatNumber(int n)
{
    return FormatBigNumber((ULONGLONG)n);
}


void TotalFiles()
{
	char str[256] = "";
	int totalfolders, totalfiles, totalsize;
	listview.CheckFiles(&totalfolders, &totalfiles, &totalsize);
	if (totalfiles > 0 || totalfolders > 0)
	{
		wsprintf(str, "Total ");
		if (totalfolders)
		{
			wsprintf(str, "%s%s folder", str, FormatNumber(totalfolders));
			if (totalfolders > 1) wsprintf(str, "%ss", str);
		}
		if (totalfiles)
		{
			if (totalfolders) wsprintf(str, "%s and ", str);
			wsprintf(str, "%s%s bytes", str, FormatNumber(totalsize));
			wsprintf(str, "%s in %s file", str, FormatNumber(totalfiles));
			if (totalfiles > 1) wsprintf(str, "%ss", str);
		}
	}
	statusview.SetText(TOTAL_STATUS, str);
}

void AllocFileNameBuffer(char **lpstrOpenFile)
{
	int i;
	for(i = 0; i < MULTIFILES; i++)
	{
		lpstrOpenFile[i] = new char[MAX_PATH];
		ZeroMemory(lpstrOpenFile[i], MAX_PATH);
	}
}

void FreeFileNameBuffer(char **lpstrOpenFile)
{
	int i;
	for(i = 0; i < MULTIFILES; i++)
	{
		delete lpstrOpenFile[i];
	}
}

bool ClipContents()
{
    IDataObject *pidataobject;

    OleGetClipboard(&pidataobject);
    if (pidataobject)
    {
        // There's data in the clipboard.  Is it files?
        STGMEDIUM stgm;
        FORMATETC fmte= {(USHORT)g_suXboxFiles,  NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        if (pidataobject->GetData(&fmte, &stgm) == S_OK)
            return true;
     
        fmte.cfFormat = (USHORT)CF_HDROP;
        if (pidataobject->GetData(&fmte, &stgm) == S_OK)
            return true;
    }

    return false;
}

void CheckViewmodeMenu(HMENU hMenu)
{
	CheckMenuItem(hMenu, IDM_VIEWLARGEICONS, MFS_UNCHECKED);
	CheckMenuItem(hMenu, IDM_VIEWSMALLICONS, MFS_UNCHECKED);
	CheckMenuItem(hMenu, IDM_VIEWLIST,       MFS_UNCHECKED);
	CheckMenuItem(hMenu, IDM_VIEWDETAIL,     MFS_UNCHECKED);
    switch(listview.GetViewMode())
	{
    case LVS_ICON:
		CheckMenuItem(hMenu, IDM_VIEWLARGEICONS, MFS_CHECKED);
        break;

    case LVS_SMALLICON:
		CheckMenuItem(hMenu, IDM_VIEWSMALLICONS, MFS_CHECKED);
        break;

	case LVS_LIST:
		CheckMenuItem(hMenu, IDM_VIEWLIST,       MFS_CHECKED);
		break;
	case LVS_REPORT:
		CheckMenuItem(hMenu, IDM_VIEWDETAIL,     MFS_CHECKED);
		break;
	}

    if (ClipContents())
		EnableMenuItem(hMenu, IDM_PASTE, MF_ENABLED);
    else
		EnableMenuItem(hMenu, IDM_PASTE, MF_GRAYED);

    if (listview.GetNumSelected() > 0)
    {
        EnableMenuItem(hMenu, IDM_DELETE, MF_ENABLED);
        EnableMenuItem(hMenu, IDM_CUT, MF_ENABLED);
        EnableMenuItem(hMenu, IDM_COPY, MF_ENABLED);
    }
    else
    {
        EnableMenuItem(hMenu, IDM_DELETE, MF_GRAYED);
        EnableMenuItem(hMenu, IDM_CUT, MF_GRAYED);
        EnableMenuItem(hMenu, IDM_COPY, MF_GRAYED);
    }
}

void Selected(HWND hWnd, HWND hListWnd)
{
	char str[512];
	int i, count;
	UINT ret;
	count = ListView_GetItemCount(hListWnd);
	for(i = 0; i < count; i++)
	{
		ret = ListView_GetItemState(hListWnd, i, LVIS_SELECTED);
		if (ret) break;
	}
        if (i >= count)
            return;
	ListView_GetItemText(hListWnd, i, COLUMN_NAME, str, 512 - 1);
	if (! MyStrcmp(str, "..")) ReturnToParentDir();
	else
	{
		char dir[32];
		ListView_GetItemText(hListWnd, i, COLUMN_SIZE, dir, 32 - 1);
		if (! MyStrcmp(dir, CHAR_DIR))
		{
			history.SaveHistory(g_CurrentDir);
			strcat(g_CurrentDir, str);
			strcat(g_CurrentDir, "\\");
			Reload();
		}
		else
		{
            // UNDONE-WARN: Remove this code.  No longer needed since we have drag/drop
	//		PostMessage(hWnd, WM_COMMAND, IDM_DOWNLOAD, 0);
		}
	}
}

LRESULT CALLBACK WndProc(HWND hWnd, unsigned uMsg, WPARAM wParam, LPARAM lParam)
{
	static LPTOOLTIPTEXT lptip;
	static HWND hListWnd;
	static HWND hStatusWnd;
	static HWND hToolWnd;
	static HWND hSplashWnd = NULL;
    static bool fHack = false;
	switch (uMsg)
	{
	case WM_STATUSTEXT:
		statusview.SetText((int) wParam, (LPCTSTR) lParam);
		break;
	case WM_COMMAND:
		switch(wParam)
		{
        case IDM_PARENTDIR:
			ReturnToParentDir();
			break;
		case IDM_DELETE:
            listview.Delete(hWnd);
			break;

		case IDM_RENAME:
			{
				int i, count;
				UINT ret;
				count = ListView_GetItemCount(hListWnd);
				for(i = 0; i < count; i++)
				{
					ret = ListView_GetItemState(hListWnd, i, LVIS_FOCUSED);
					if (ret) break;
				}
				ListView_EditLabel(hListWnd, i);
			}
			break;
		case IDM_MKDIR:
			{
				char str[MAX_PATH + SHORTFILELEN];
				char str2[SHORTFILELEN] = NEWDIRNAME;
				int i;
				for(i = 1; i < 1000; i++)
				{
					strcpy(str, g_CurrentDir);
					strcat(str, str2);
					if (listview.IsExistence(str2) == -1) break;
					wsprintf(str2, NEWDIRNAME".%03d", i);
				}
				xbfu.Md(str);
				Reload();
				i = listview.IsExistence(str2);
				ListView_EditLabel(hListWnd, i);
			}
			break;
		case IDM_BACK:
			if (history.GetRewindCount())
			{
				history.RestoreRewindHistory(g_CurrentDir);
				Reload();
			}
			break;
		case IDM_FORWARD:
			if (history.GetForwardCount())
			{
				history.RestoreForwardHistory(g_CurrentDir);
				Reload();
			}
			break;
		case IDM_ALLSELECT:
			{
				int i, j;
				j = ListView_GetItemCount(hListWnd);
				for(i = 0; i < j; i++)
				{
					ListView_SetItemState(hListWnd, i, LVIS_SELECTED, LVIS_SELECTED);
				}
			}
			break;
		case IDM_REBOOT:
			{
				char str[300];
				strcpy(str, "Reboot ");
				strcat(str, g_TargetXbox);
				strcat(str, "?");
				if (MessageBox(hWnd, str, szAppName, MB_YESNO) == IDYES) xbfu.Reboot();
			}
			break;

        case IDM_VIEWLARGEICONS:
			listview.ChangeView(LVS_ICON);
            break;

        case IDM_VIEWSMALLICONS:
			listview.ChangeView(LVS_SMALLICON);
            break;

        case IDM_ARRANGE_BYNAME:
            listview.SortListView(0, true);
            break;

        case IDM_ARRANGE_BYTYPE:
            listview.SortListView(1, true);
            break;

        case IDM_ARRANGE_BYSIZE:
            listview.SortListView(2, true);
            break;

        case IDM_ARRANGE_BYDATE:
            listview.SortListView(3, true);
            break;

        case IDM_REFRESH:
            Reload();
			break;

        case IDM_PROPERTIES:
            // Open up the appropriate property sheet.
            if (g_iPopupFileItem == -1)
            {
                // user cliked on white space = show folder prop with current folder
    			DialogBox(hInst, "FOLDERPROP", hWnd, (DLGPROC) FolderPropertiesDlg);
            }
            else
            {
                // user clicked on item - folder?
                // UNDONE-ERR: Multiple selection not supported.  Need to combine all information
                //             from all selected items
                if (listview.IsFolder(g_iPopupFileItem))
        			DialogBox(hInst, "FOLDERPROP", hWnd, (DLGPROC) FolderPropertiesDlg);
                else
        			DialogBox(hInst, "FILEPROP", hWnd, (DLGPROC) FilePropertiesDlg);
            }
            break;

        case IDM_PASTE:
            listview.Paste();
            break;

        case IDM_CUT:
            listview.CutCopy(true);
            break;

        case IDM_COPY:
            listview.CutCopy(false);
            break;


		case IDM_TARGETMACHINE:
			{
                bool fDone;
                do
                {
				    if (DialogBox(hInst, "TARGETDLG", hWnd, (DLGPROC) TargetDlg) == IDOK)
				    {
                        xbfu.SetTarget(g_TargetXbox);
                        fDone = Reload();
				    }
                    else
                        fDone = true;
                } while (!fDone);
			}
			break;
		case IDM_ABOUT:
			DialogBox(hInst, "ABOUTDLG2", hWnd, (DLGPROC) AboutDlgProc);
			break;
		case IDM_VIEWLIST:
			listview.ChangeView(LVS_LIST);
			break;
		case IDM_VIEWDETAIL:
			listview.ChangeView(LVS_REPORT);
			break;
		case IDOK:
			PostMessage(hWnd, WM_CLOSE, 0, 0);
			break;
		}
		{
			WORD wID = LOWORD(wParam);
			WORD wNotifyCode = HIWORD(wParam);
			if (wID == ID_COMBOBOX)
			{
				switch(wNotifyCode)
				{
				case CBN_SELCHANGE:
					{
						char str[MAX_PATH];
						int i;
						i = SendMessage((HWND) lParam, CB_GETCURSEL, 0, 0);
						SendMessage((HWND) lParam, CB_GETLBTEXT, i, (LPARAM) str);
						if (xbfu.IsDrive(str[1]))
						{
							history.SaveHistory(g_CurrentDir);
							strcpy(g_CurrentDir, str);
						}
						Reload();
					}
					break;
				}
			}
		}
		break;
	case WM_ERASEBKGND:
		break;
	case WM_CREATE:
		{
			RECT rect;

			SetTitleName(hWnd);
            hToolWnd = toolview.CreateToolView(hWnd);
			hStatusWnd = statusview.CreateStatusView(hWnd);
			GetClientRect(hWnd, &rect);
			GetListRect(hWnd, hStatusWnd, hToolWnd, &rect);
			hListWnd = listview.CreateListView(hWnd, &rect);
            g_iTimer = SetTimer(hWnd, 1, 250, NULL);
        }
		break;

    case WM_TIMER:
        KillTimer(hWnd, g_iTimer);
        {
	        char str[MAX_PATH] = "";
            extern bool g_fForceWaitCursor;
            
            // Handle old instance case -- if g_CurrentDir doesn't have 'x' at start, then add it
            if (g_CurrentDir[0] != 'X')
            {
                wsprintf(str, "X%s", g_CurrentDir);
                strcpy(g_CurrentDir, str);
            }

            g_fForceWaitCursor = true;
            SetCursor(LoadCursor(NULL, IDC_WAIT));

            if (!xbfu.IsDrive(g_CurrentDir[0]))
            {
                // Check if we weren't able to connect at all
                while (xbfu.FailedConnect())
                {
                    // Couldn't connect to the currently named xbox.  force the
                    // user to select a new xbox
				    if (DialogBox(hInst, "TARGETDLG2", hWnd, (DLGPROC) TargetDlg) == IDOK)
				    {
                        xbfu.SetTarget(g_TargetXbox);
                        if (Reload())
                            break;
				    }
                    else
                    {
                        // User canceled
                        exit(-1);
                    }
                }

                // drive disappeared.  Default to E:
                strcpy(g_CurrentDir, "XE:\\");
            }
            SetCursor(LoadCursor(NULL, IDC_ARROW));
        }

        listview.SortListView(0, false); // 0 = by name (default)
        toolview.InsertComboBox();
	    toolview.InsertToolBar();

        break;
        
	case WM_DESTROY:
		if (hSplashWnd) DestroyWindow(hSplashWnd);
		UnInit(hWnd);
		PostQuitMessage(0);
		break;

	case WM_SIZE:
		{
			RECT rect;
			toolview.RedrawToolView(hWnd);
			statusview.RedrawStatusView(hWnd, wParam, lParam);
			GetListRect(hWnd, hStatusWnd, hToolWnd, &rect);
			listview.RedrawListView(hWnd, &rect);
		}
		break;
	case WM_ACTIVATE:
        if ((LOWORD(wParam) == WA_ACTIVE) && hListWnd) SetFocus(hListWnd);
		break;

    case WM_NOTIFY:
		{
			LPNMLISTVIEW lpNmLV;
			NMLVDISPINFO *lpNMLVDISP;
			LPNMLVKEYDOWN pnkd;

			lpNmLV = (LPNMLISTVIEW) lParam;
			lpNMLVDISP = (NMLVDISPINFO*) lParam;
			pnkd = (LPNMLVKEYDOWN) lParam;
			switch(lpNmLV->hdr.code)
			{
			case LVN_KEYDOWN:
				switch(pnkd->wVKey)
				{
				case VK_RETURN:
					Selected(hWnd, lpNmLV->hdr.hwndFrom);
					break;
				case VK_BACK:
					PostMessage(hWnd, WM_COMMAND, IDM_BACK, 0);
					break;
				case VK_F1:
					PostMessage(hWnd, WM_COMMAND, IDM_ABOUT, 0);
					break;
				case VK_F2:
					PostMessage(hWnd, WM_COMMAND, IDM_RENAME, 0);
					break;
				case VK_F5:
					Reload();
					break;
				case VK_DELETE:
					PostMessage(hWnd, WM_COMMAND, IDM_DELETE, 0);
					break;
				}
				if (GetKeyState(VK_CONTROL) < 0)
				{
					if (GetKeyState('A') < 0) PostMessage(hWnd, WM_COMMAND, IDM_ALLSELECT, 0);
					if (GetKeyState('C') < 0) PostMessage(hWnd, WM_COMMAND, IDM_COPY, 0);
					if (GetKeyState('X') < 0) PostMessage(hWnd, WM_COMMAND, IDM_CUT, 0);
					if (GetKeyState('V') < 0) PostMessage(hWnd, WM_COMMAND, IDM_PASTE, 0);
			//		else if (GetKeyState('B') < 0) PostMessage(hWnd, WM_COMMAND, IDM_BACK, 0);
			//		else if (GetKeyState('D') < 0) PostMessage(hWnd, WM_COMMAND, IDM_DELETE, 0);
			//		else if (GetKeyState('F') < 0) PostMessage(hWnd, WM_COMMAND, IDM_FORWARD, 0);
			//		else if (GetKeyState('O') < 0) PostMessage(hWnd, WM_COMMAND, IDM_UPLOAD, 0);
			//		else if (GetKeyState('R') < 0) PostMessage(hWnd, WM_COMMAND, IDM_RENAME, 0);
			//		else if (GetKeyState('S') < 0) PostMessage(hWnd, WM_COMMAND, IDM_DOWNLOAD, 0);
				}
				break;

			case LVN_BEGINLABELEDIT:
				return listview.IsParentFolder(lpNMLVDISP->item.iItem);
                
			case LVN_ENDLABELEDIT:
				{
					if (lpNMLVDISP->item.pszText)
					{
#if 0
    					char str1[MAX_PATH + SHORTFILELEN], str2[MAX_PATH + SHORTFILELEN];
                        ListView_GetItemText(lpNmLV->hdr.hwndFrom, lpNMLVDISP->item.iItem, COLUMN_NAME, str2, SHORTFILELEN);
						strcpy(str1, g_CurrentDir);
						strcat(str1, str2);
						strcpy(str2, g_CurrentDir);
						strcat(str2, lpNMLVDISP->item.pszText);
#endif
                        
                        char szOrigFilePathName[1024], szNewFilePathName[1024], szOrigFileName[MAX_PATH], szNewFileName[MAX_PATH];
                        DM_FILE_ATTRIBUTES dmfa;
        			    ListView_GetItemText(lpNmLV->hdr.hwndFrom, lpNMLVDISP->item.iItem, COLUMN_NAME, szOrigFileName, MAX_PATH);
                        strcpy(szNewFileName, lpNMLVDISP->item.pszText);
                        sprintf(szOrigFilePathName, "%s%s", g_CurrentDir, szOrigFileName);
                        sprintf(szNewFilePathName, "%s%s", g_CurrentDir, szNewFileName);

                        xbfu.GetFileAttributes(szOrigFilePathName, &dmfa);
                        if (dmfa.Attributes & FILE_ATTRIBUTE_READONLY)
                        {
                            bool fNoRename;
                            char szText[MAX_PATH], szCaption[200];
                            char szBuf[MAX_PATH];

                            if (dmfa.Attributes & FILE_ATTRIBUTE_DIRECTORY)
                            {
                                LoadString(hInst, IDS_CONFIRM_RENAME_RO_FOLDER_QUERY, szBuf, MAX_PATH);
                                LoadString(hInst, IDS_CONFIRM_RENAME_RO_FOLDER, szCaption, 200);
                                sprintf(szText, szBuf, szOrigFileName, szNewFileName);
                            }
                            else
                            {
                                LoadString(hInst, IDS_CONFIRM_RENAME_RO_FILE_QUERY, szBuf, MAX_PATH);
                                LoadString(hInst, IDS_CONFIRM_RENAME_RO_FILE, szCaption, 200);
                                sprintf(szText, szBuf, szOrigFileName, szNewFileName);
                            }
                            fNoRename = (MessageBox(g_hwnd, szText, szCaption, MB_YESNO) == IDNO);
                            if (fNoRename)
                                return FALSE;

                            // Remove the readonly bit so that we can rename the file
                            xbfu.RemoveAttribute(szOrigFilePathName, FILE_ATTRIBUTE_READONLY);
                        }
                        if (!xbfu.Ren(szOrigFilePathName, szNewFilePathName))
                        {
                            // Failed to rename the file (might be in use?)
                            char szText[MAX_PATH], szCaption[200];
                            LoadString(hInst, IDS_FAIL_RENAME, szText, MAX_PATH);
                            LoadString(hInst, IDS_FAIL_RENAME_CAPTION, szCaption, MAX_PATH);
                            MessageBox(g_hwnd, szText, szCaption, MB_ICONWARNING | MB_OK);
                            return FALSE;
                        }
                        if (dmfa.Attributes & FILE_ATTRIBUTE_READONLY)
                        {
                            // Restore the read-only attribute
                            xbfu.SetAttribute(szNewFilePathName, FILE_ATTRIBUTE_READONLY);
                        }

                        Reload();

                        // UNDONE-ERR: going...to...kill...something... If I don't reload at the end of the
                        // lvn_itemchanged below, then the file rename is all screwed up.  while
                        // ugly, this catches the bug, and that's the mental state I'm at.  Clean it up later.
                        fHack = true;

                        return TRUE;
					}
				}
                return TRUE;

            case LVN_BEGINDRAG:
                listview.BeginDrag();
                break;
                
          case LVN_COLUMNCLICK:
             // The user clicked one of the column headings. Sort by
             // this column. This function calls an application-defined
             // comparison callback function, ListViewCompareProc.
             listview.SortListView((LPARAM)(lpNmLV->iSubItem), true);
//             ListView_SortItems(lpNmLV->hdr.hwndFrom, ListViewCompareProc, (LPARAM)(lpNmLV->iSubItem));
             listview.Focus();
             break;

			case LVN_ITEMCHANGED:
				{
					char str[256] = "";
					int totalfolders, totalfiles, totalsize;

					listview.CheckSelectedFiles(&totalfolders, &totalfiles, &totalsize);
					if (totalfiles > 0 || totalfolders > 0)
					{
						wsprintf(str, "Selected ");
						if (totalfolders)
						{
							wsprintf(str, "%s%s folder", str, FormatNumber(totalfolders));
							if (totalfolders > 1) wsprintf(str, "%ss", str);
						}
						if (totalfiles)
						{
							if (totalfolders) wsprintf(str, "%s and ", str);
							wsprintf(str, "%s%s bytes", str, FormatNumber(totalsize));
							wsprintf(str, "%s in %s file", str, FormatNumber(totalfiles));
							if (totalfiles > 1) wsprintf(str, "%ss", str);
						}
					}
                    else
                    {
                        // Display disk free space
                        ULARGE_INTEGER uliFreeSpace;
                        char szBuf[100];
                        sprintf(szBuf, "%c:\\", g_CurrentDir[1]);
                        xbfu.GetDriveFreeSize(szBuf, &uliFreeSpace);
                        FormatSize(uliFreeSpace, szBuf, false);
                        wsprintf(str, "Disk free space: %s", szBuf);
                    }

					statusview.SetText(SELECTED_STATUS, str);
                    if (fHack)
                    {
                        fHack = false;
                        Reload();
                    }
				}
				break;
                
			case NM_RCLICK:
				{
                    // User right clicked - bring up property menu; which type depends on whether
                    // or not the user clicked on an icon or white space.  Further, clicking on
                    // a directory brings up different options; however for our purposes we consider
                    // them the exact same (if we want to add dir-specific options later, just check
                    // IsFolder(iItem))...

                    NMHDR *nmhdr = (NMHDR*)lParam;
                    POINT pt;
					HMENU menu, hmenuPopup;
                    char szName[MAX_PATH];
					POINT point;

                    GetCursorPos(&pt);
                    ScreenToClient(nmhdr->hwndFrom, &pt);

                    int iItem = listview.GetItemAtPoint(&pt);
                    ListView_GetItemText(listview.GetHwnd(), iItem, COLUMN_NAME, szName, MAX_PATH);
                    if (MyStrcmp(szName, ".."))
                    {
                        if (iItem == ITEM_NONE)
                        {
                            // Bring up non-object specific pop-up
					        menu = LoadMenu(hInst, "XBEXPLORER_POPUP");
                        }
                        else
                        {
                            // Bring up file popup
					        menu = LoadMenu(hInst, "XBEXPLORER_FILEPOPUP");
                        }

                        g_iPopupFileItem = iItem;

					    if (menu)
					    {
						    hmenuPopup = GetSubMenu(menu, 0);
//						    if (! history.GetRewindCount()) EnableMenuItem(menu, IDM_BACK, MF_GRAYED);
//						    if (! history.GetForwardCount()) EnableMenuItem(menu, IDM_FORWARD, MF_GRAYED);

                            if (listview.GetNumSelected() <= 1)
                            {
                                char szBuf[100];
                                if(listview.GetNumSelected() == 1) {
                                    LoadString(hInst, IDS_RENAME, szBuf, 100);
                                    AppendMenu(hmenuPopup, MF_STRING, IDM_RENAME, szBuf);
                                }
                                LoadString(hInst, IDS_PROPERTIES, szBuf, 100);
                                AppendMenu(hmenuPopup, MF_SEPARATOR, 0, NULL);
                                AppendMenu(hmenuPopup, MF_STRING, IDM_PROPERTIES, szBuf);
                            }
					    }
                    }
					CheckViewmodeMenu(menu);
					GetCursorPos(&point);
					TrackPopupMenu(hmenuPopup, TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, 0, hWnd, NULL);
					DestroyMenu(menu);
                }
				break;

			case NM_DBLCLK:
				Selected(hWnd, lpNmLV->hdr.hwndFrom);
				break;
                
			case TTN_NEEDTEXT:
				lptip = (LPTOOLTIPTEXT) lParam;
				lptip->hinst = hInst;
				lptip->lpszText = MAKEINTRESOURCE(lptip->hdr.idFrom);
				break;

			case RBN_CHILDSIZE:
				{
					RECT rect;
					GetListRect(hWnd, hStatusWnd, hToolWnd, &rect);
					listview.RedrawListView(hWnd, &rect);
				}
				break;
			}
		}
		break;
	case WM_MENUSELECT:
		if (HIWORD(wParam) == (MF_MOUSESELECT | MF_POPUP | MF_HILITE)) 
            CheckViewmodeMenu((HMENU) lParam);
		break;
	default:
		return(DefWindowProc(hWnd, uMsg, wParam, lParam));
	}
	return 0;
}

bool HandleCmdLine(char *szCmd)
{
    if (*szCmd == NULL)
        return true;

    if ((szCmd[1] == 'x' || szCmd[1] == 'X') && szCmd[3])
    {
        if(SUCCEEDED(DmSetXboxName(szCmd + 3)))
            return true;
    }

    // If here, then bad cmd line
    char szMsg[1000];
    sprintf(szMsg, "xbExplorer.exe.\n\nAllows browsing an Xbox " \
            "in a graphical environment.\r\n\r\nusage: xbExplorer [/x xboxname]\r\n"\
            "        /x    Specify Xbox to explore.");

    MessageBox(NULL, szMsg, "Invalid Command Line Option Specified", MB_ICONINFORMATION | MB_OK);
    return false;
}

int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmd, int nCmdShow)
{
	WNDCLASS wndclass;
	HANDLE mutexhandle;
	HWND hWnd;
	MSG msg;

	// Disable multiple instance
	mutexhandle = CreateMutex(NULL, TRUE, MUTEXOFCH3SCMPX);
	if (GetLastError()) msg.wParam = -1;
	else
	{
		RECT rect;
        
        OleInitialize(NULL); 

        // Handle command line arguments
        if (!HandleCmdLine(lpszCmd))
            return -1;
        
        // If we haven't yet registered the clipboard formats for transfering files to/from the shell,
        // then do so now.
        RegisterFormats();

        hInst = hInstance;
		wndclass.style = CS_HREDRAW | CS_VREDRAW;
		wndclass.lpfnWndProc = (WNDPROC) WndProc;
		wndclass.cbClsExtra = 0;
		wndclass.cbWndExtra = 0;
		wndclass.hInstance = hInstance;
		wndclass.hIcon = LoadIcon(hInstance, szResName);
		wndclass.hCursor = NULL;//LoadCursor(NULL, IDC_ARROW);
		wndclass.hbrBackground = (HBRUSH) (COLOR_APPWORKSPACE + 1);
		wndclass.lpszMenuName = szResName;
		wndclass.lpszClassName = szClassName;
		if (! RegisterClass(&wndclass)) return FALSE;

        // Fire up the xbox connection
        g_pxboxconn = new CXboxConnection();		

		Init(&rect);
		hWnd = CreateWindow(szClassName, szAppName, WS_OVERLAPPEDWINDOW, rect.left, rect.top,
                            rect.right, rect.bottom, NULL, NULL, hInstance, NULL);
		if (! hWnd) return FALSE;
		ShowWindow(hWnd, SW_SHOWDEFAULT);
        g_hwnd = hWnd;

		while(GetMessage(&msg, NULL, 0, 0))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}

        delete g_pxboxconn;
        
        OleUninitialize();
	}


	return msg.wParam;
}

int MyStricmp(const char *sz1, const char *sz2)
{
    // not defined in xbox libs
    return lstrcmpi(sz1, sz2);
}

int MyStrcmp(const char *sz1, const char *sz2)
{
    // not defined in xbox libs
    return lstrcmp(sz1, sz2);
}

char *MyStrdup(char *sz)
{
    // not defined in xbox libs
    char *szNew = (char *)malloc(MyStrlen(sz)+1);
    strcpy(szNew, sz);
    return szNew;
}

int MyStrlen(const char *sz)
{
    return _mbstrlen(sz);
}

char gs_szUtoA[1024];
char *WideToSingleByte(WCHAR *pwIn)
{
    char *szOut = gs_szUtoA;
    while (*pwIn)
    {
        *szOut++ = (char)(*pwIn++);
    }
    *szOut = '\0';
    return gs_szUtoA;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\ToolView.cpp ===
#include "stdafx.h"

#define CX_COMBOBOX 175
#define CX_TOOLBAR 300

TBBUTTON TOOLVIEW::tbb[N_TOOLS] = {
	{ 0, IDM_PARENTDIR, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0 },
	{ 1, IDM_REBOOT, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0 },
#ifdef FOURBUTTONS
	{ 2, IDM_TARGETMACHINE, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0 },
	{ 3, IDM_ABOUT, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0 },
#endif
};

const TBBUTTON TOOLVIEW::tb = {
	0, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0, 0
};

TOOLVIEW::TOOLVIEW()
{
	hToolWnd = NULL;
	hWndCB = hWndTB = NULL;
}

TOOLVIEW::~TOOLVIEW()
{
}

HWND TOOLVIEW::GethWnd()
{
	return hToolWnd;
}

HWND TOOLVIEW::CreateToolView( HWND hWnd )
{
	REBARINFO rbi;
	INITCOMMONCONTROLSEX icex;

	icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
	icex.dwICC = ICC_COOL_CLASSES | ICC_BAR_CLASSES;
	InitCommonControlsEx( &icex );
	hToolWnd = CreateWindowEx( WS_EX_TOOLWINDOW, REBARCLASSNAME, NULL, WS_BORDER | WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | RBS_VARHEIGHT | RBS_BANDBORDERS | CCS_NODIVIDER | CCS_NOPARENTALIGN/* | CCS_VERT(o[)*/, 0, 0, 0, 0, hWnd, (HMENU) ID_REBAR, hInst, NULL );
	if ( ! hToolWnd ) return NULL;
	rbi.cbSize = sizeof(REBARINFO);
	rbi.fMask = 0;
	rbi.himl = (HIMAGELIST) NULL;
	if ( ! SendMessage( hToolWnd, RB_SETBARINFO, 0, (LPARAM) &rbi ) ) return NULL;
	CreateComboBox( hToolWnd );
	CreateToolBar( hWnd );

	return hToolWnd;
}

HWND TOOLVIEW::RedrawToolView( HWND hWndParent )
{
	RECT rcl;

	GetClientRect( hWndParent, &rcl );
	SetWindowPos( hToolWnd, NULL, 0, 0, rcl.right - rcl.left, 100, SWP_NOZORDER | SWP_NOMOVE | SWP_SHOWWINDOW );
    return hToolWnd;
}

void TOOLVIEW::Refresh()
{
    SendMessage( hWndCB, CB_RESETCONTENT, 0, 0 );
	int iCurSel = InsertDriveNameToComboBox();
    SendMessage( hWndCB, CB_SETCURSEL, iCurSel, 0 );
}

void TOOLVIEW::Clear()
{
    SendMessage( hWndCB, CB_RESETCONTENT, 0, 0 );
}

void TOOLVIEW::CreateToolBar( HWND hWnd )
{
	InitCommonControls();
	hWndTB = CreateToolbarEx( hWnd, WS_CHILD | WS_VISIBLE | CCS_NOPARENTALIGN | CCS_NORESIZE | CCS_NODIVIDER | TBSTYLE_FLAT | TBSTYLE_WRAPABLE | TBSTYLE_TOOLTIPS, ID_TOOLBAR, N_TOOLS, hInst, ID_TOOLBAR, tbb, N_TOOLS, 0, 0, 0, 0, sizeof(TBBUTTON) );
	SendMessage( hWndTB, TB_INSERTBUTTON, 1, (LPARAM) &tb );
#ifdef FOURBUTTONS
	SendMessage( hWndTB, TB_INSERTBUTTON, 4, (LPARAM) &tb );
#endif
}

void TOOLVIEW::CreateComboBox( HWND hWnd )
{
	hWndCB = CreateWindow( TEXT( "COMBOBOX" ), NULL, WS_VISIBLE | WS_CHILD | WS_TABSTOP | WS_VSCROLL | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | CBS_AUTOHSCROLL | CBS_DROPDOWNLIST,
		0, 0, 100, 200, hWnd, (HMENU) ID_COMBOBOX, hInst, NULL );

	SendMessage( hWndCB, WM_SETFONT, (WPARAM) GetStockObject( DEFAULT_GUI_FONT ), MAKELPARAM( TRUE, 0 ) );
}

int TOOLVIEW::InsertDriveNameToComboBox()
{
	char szString[64];
    char szDrives[128];
	int i, iCurSel;
    DWORD cch = sizeof szDrives;

    if(!xbfu.GetDriveList(szDrives, &cch))
        szDrives[0] = 0;

	for( i = 0; szDrives[i]; i++ )
	{
        wsprintf(szString, "X%c:\\", toupper(szDrives[i]));
        if (szString[1] == g_CurrentDir[1])
            iCurSel = i;
		SendMessage( hWndCB, CB_ADDSTRING, 0, (LPARAM) szString );
	}

    return iCurSel;
}

void TOOLVIEW::InsertComboBox()
{
	REBARBANDINFO rbBand;
	RECT rc;
	int iCurSel = InsertDriveNameToComboBox();
	SendMessage( hWndCB, CB_SETCURSEL, iCurSel, 0 );

	if ( hWndCB )
	{
		GetWindowRect( hWndCB, &rc );
		rbBand.cbSize = sizeof(REBARBANDINFO);
		rbBand.hbmBack = NULL;
		rbBand.fStyle = RBBS_CHILDEDGE | RBBS_FIXEDBMP | RBBS_GRIPPERALWAYS;

		rbBand.fMask = RBBIM_TEXT | RBBIM_BACKGROUND | RBBIM_STYLE | RBBIM_CHILDSIZE | RBBIM_SIZE |RBBIM_CHILD | RBBIM_ID;
		rbBand.wID = ID_COMBOBOX;
		rbBand.lpText = TEXT( "Drive" );
		rbBand.cch = 2;
		rbBand.hwndChild = hWndCB;
		rbBand.cxMinChild = rc.right - rc.left + 10;
		rbBand.cyMinChild = rc.bottom - rc.top;
		rbBand.cx = CX_COMBOBOX;
		SendMessage( hToolWnd, RB_INSERTBAND, (WPARAM) -1, (LPARAM) &rbBand );
	}
}

void TOOLVIEW::InsertToolBar()
{
	REBARBANDINFO rbBand;
	RECT rc;
	DWORD dwBtnSize;

	if ( hWndTB )
	{
		GetWindowRect( hWndTB, &rc );
		dwBtnSize = SendMessage( hWndTB, TB_GETBUTTONSIZE, 0, 0 );
		rbBand.cbSize = sizeof(REBARBANDINFO);
		rbBand.hbmBack = NULL;
		rbBand.fStyle = RBBS_CHILDEDGE | RBBS_FIXEDBMP | RBBS_GRIPPERALWAYS;

		rbBand.fMask = RBBIM_BACKGROUND | RBBIM_STYLE | RBBIM_CHILDSIZE | RBBIM_SIZE | RBBIM_CHILD | RBBIM_ID;
		rbBand.wID = ID_TOOLBAR;
		rbBand.cch = 2;
		rbBand.hwndChild = hWndTB;
		rbBand.cxMinChild = rc.right - rc.left + 24;
		rbBand.cyMinChild = HIWORD( dwBtnSize );
		rbBand.cx = CX_TOOLBAR;
		SendMessage( hToolWnd, RB_INSERTBAND, (WPARAM) -1, (LPARAM) &rbBand );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\XBFU.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     xbfu.cpp
// Contents: Internal implementation of 'XBFU' functionality.  Talks directly to the Xbox.d
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#include "stdafx.h"

// UNDONE-ERR: What about multiple Xboxs? (Affects almost all functions)

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  XBFU::XBFU
// Purpose:   XBFU Constructor
// Arguments: UNDONE
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
XBFU::XBFU()
{
    m_cOpenedHandles = 0;
    m_fCannotConnect = false;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  XBFU::~XBFU
// Purpose:   XBFU Destructor
// Arguments: UNDONE
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
XBFU::~XBFU()
{
    // UNDONE-WARN:Check if there are any open handles left
    m_mappdmwdFindFile.clear();
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  XBFU::GetTarget
// Purpose:   UNDONE-WARN: Fill In
// Arguments: UNDONE
// Return:    'S_OK' if successful, Error code otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT XBFU::GetTarget(LPSTR sz, UINT ui)
{
    return DmGetXboxName(sz, (LPDWORD)&ui);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  XBFU::SetTarget
// Purpose:   UNDONE-WARN: Fill In
// Arguments: UNDONE
// Return:    'S_OK' if successful, Error code otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT XBFU::SetTarget(LPCSTR sz)
{
    return DmSetXboxName(sz);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  XBFU::IsDrive
// Purpose:   Determine if the specified drive is accessible to the user.
// Arguments: chDriveName       -- Name of the drive to check (ie 'C').
// Return:    'true' if accessible, 'false' otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool XBFU::IsDrive(char ch)
{
    bool fRet = false;
    HRESULT hr;
    g_pxboxconn->Before();

    char rgchDrives[26];
    DWORD cDrives = 26;

    // Get the drive list from the Xbox
    hr = DmGetDriveList(rgchDrives, &cDrives);
    if (hr != XBDM_NOERR)
    {
        if (hr == XBDM_CANNOTCONNECT)
        {
            // Mark global variable so that we know that we can't currently 
            // access the named xbox.  If this is happening during initialization
            // then the caller will handle informing the user that the xbox
            // can't be found.  Ideally we would enable this across all XBFU
            // functions and all references to the functions (to allow catching
            // if an xbox goes offline post-initialization); however, the effort
            // is not worth it considering the timeframe (after lockdown) and
            // the imminent deprecation of this app in favor of shellext.
            m_fCannotConnect = true;
        }
        goto done;
    }

    // Check if the specified drive is available
    fRet = strchr(rgchDrives, ch) ? true : false;

done:

    g_pxboxconn->After();
    return fRet;
}

bool XBFU::GetDriveList(LPSTR sz, LPDWORD pcch)
{
    HRESULT hr;
    g_pxboxconn->Before();
    hr = DmGetDriveList(sz, pcch);
    g_pxboxconn->After();
    return SUCCEEDED(hr);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  XBFU::FindFirstFile
// Purpose:   Finds the first file on the Xbox with the specified file attributes.  The caller should
//            pass the returned 'Find Handle' to subsequent calls to FindNextFile and FindClose.
// Arguments: szDir             -- The directory to search
//            pdmfa             -- File attributes of the first file.
//            fTargetXbox       -- 'true' if we're searching an Xbox, 'false' if it's a PC.
//            szTargetXbox      -- Name of the target xbox to search.
// Return:    'Find Handle' if successful, INVALID_HANDLE_VALUE otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HANDLE XBFU::FindFirstFile(LPCSTR szDir, PDM_FILE_ATTRIBUTES pdmfa, bool fTargetXbox, 
                           LPCSTR szTargetXbox)
{
    HANDLE hr = INVALID_HANDLE_VALUE;
    HRESULT hr2;
    g_pxboxconn->Before();

    if (fTargetXbox)
    {
        // Searching an Xbox...
        PDM_WALK_DIR pdmwd = NULL;

        // UNDONE-ERR: Not taking Xbox name into account.
        if ((hr2 = DmWalkDir(&pdmwd, szDir, pdmfa)) != XBDM_NOERR)
        {
            if (hr2 == XBDM_CANNOTCONNECT)
                m_fCannotConnect = true;

            // Didn't find any files.
            memset(pdmfa, 0, sizeof(DM_FILE_ATTRIBUTES));
            goto done;
        }

        m_cOpenedHandles++;
        m_mappdmwdFindFile.insert(MAPFINDFILE::value_type((HANDLE)m_cOpenedHandles, pdmwd));

	    // Return the handle to the file that we found
        hr = (HANDLE)m_cOpenedHandles;
    }
    else
    {
        // Searching the PC
        WIN32_FIND_DATA wfd;
        SetCurrentDirectory(szDir);
        HANDLE hfile = ::FindFirstFile("*.*", &wfd);
        if (hfile == INVALID_HANDLE_VALUE)
            goto done;

        if (!MyStrcmp(wfd.cFileName, ".") || !MyStrcmp(wfd.cFileName, ".."))
        {
            if (!FindNextFile(hfile, pdmfa, fTargetXbox))
            {
                FindClose(hfile, fTargetXbox);
                goto done;
            }
            hr = hfile;
            goto done;
        }
        strcpy(pdmfa->Name, wfd.cFileName);
        pdmfa->CreationTime = wfd.ftCreationTime;
        pdmfa->ChangeTime = wfd.ftLastAccessTime;
        pdmfa->SizeHigh = wfd.nFileSizeHigh;
        pdmfa->SizeLow = wfd.nFileSizeLow;
        pdmfa->Attributes = wfd.dwFileAttributes;
        hr = hfile;
    }

done:

    g_pxboxconn->After();
    return hr;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  XBFU::FindNextFile
// Purpose:   Finds the next file using the filter and directory stored in the specified Find Handle
// Arguments: hfind             -- The 'Find Handle' to search with.
//            pdmfa             -- Attributes of the next file found.
//            fTargetXbox       -- 'true' if we're searching an Xbox, 'false' if it's a PC.
// Return:    'true' if another file was found, 'false' otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool XBFU::FindNextFile(HANDLE hfind, PDM_FILE_ATTRIBUTES pdmfa, bool fTargetXbox)
{
    bool fRet = false;
    g_pxboxconn->Before();

    if (fTargetXbox)
    {
        // Searching an Xbox...

        // Find the File handle
        MAPFINDFILE::iterator iterFile = m_mappdmwdFindFile.find(hfind);

        // Verify that the specified find handle exists
        if (iterFile == m_mappdmwdFindFile.end())    
            goto done;

        // Find the next file
        if (DmWalkDir(&(*iterFile).second, NULL, pdmfa) != XBDM_NOERR)
        {
            // Didn't find a 'next' files.
            memset(pdmfa, 0, sizeof(DM_FILE_ATTRIBUTES));
            goto done;
        }

        fRet = true;
    }
    else
    {
        // Searching the PC

        WIN32_FIND_DATA wfd;
        if (::FindNextFile(hfind, &wfd) == false)
            goto done;
        if (!MyStrcmp(wfd.cFileName, ".") || !MyStrcmp(wfd.cFileName, ".."))
        {
            fRet = FindNextFile(hfind, pdmfa, fTargetXbox);
            goto done;
        }

        strcpy(pdmfa->Name, wfd.cFileName);
        pdmfa->CreationTime = wfd.ftCreationTime;
        pdmfa->ChangeTime = wfd.ftLastAccessTime;
        pdmfa->SizeHigh = wfd.nFileSizeHigh;
        pdmfa->SizeLow = wfd.nFileSizeLow;
        pdmfa->Attributes = wfd.dwFileAttributes;

        fRet = true;
    }
done:

    g_pxboxconn->After();
    return fRet;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  XBFU::FindClose
// Purpose:   Closes the specified Find Handle
// Arguments: hfind             -- The 'Find Handle' to close.
//            fTargetXbox       -- 'true' if we're searching an Xbox, 'false' if it's a PC.
// Return:    'true' if successful, 'false' otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool XBFU::FindClose(HANDLE hfind, bool fTargetXbox)
{
    bool fRet;
    g_pxboxconn->Before();

    if (fTargetXbox)
    {
        // Find the File handle
        MAPFINDFILE::iterator iterFile = m_mappdmwdFindFile.find(hfind);

        // Verify that the specified find handle exists
        if (iterFile == m_mappdmwdFindFile.end())    
        {
            fRet = false;
            goto done;
        }

        DmCloseDir((*iterFile).second);
    
        // Remove the handle from the list
        m_mappdmwdFindFile.erase(iterFile);

	    // Return that everything went fine.
	    fRet = true;
    }
    else
    {
        fRet = ::FindClose(hfind) ? true : false;
        SetCurrentDirectory("..");
    }

done:

    g_pxboxconn->After();
    return fRet;
}

HRESULT XBFU::GetDriveFreeSize(char *szDrive, ULARGE_INTEGER *puliSpace)
{
    HRESULT hr = E_FAIL;
    g_pxboxconn->Before();
    
    if (DmGetDiskFreeSpace(szDrive, puliSpace, NULL, NULL) != XBDM_NOERR)
        goto done;

    hr = S_OK;

done:
    g_pxboxconn->After();
    return hr;
}

char g_szDelFile[MAX_PATH];

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  XBFU::Del
// Purpose:   Deletes the specified file
// Arguments: szPathFileName    -- Complete file path and name of the file to delete
//            fIsDir            -- 'true' if the specified file is a directory.
// Return:    'true' if successful, 'false' otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool XBFU::Del(LPCSTR szPathFileName, bool *pfQuery, HWND hWnd)
{
    HRESULT hr = E_FAIL;

    int nChoice;
	bool fIsDir;
    DM_FILE_ATTRIBUTES dmfa;

    g_pxboxconn->Before();
    
    GetFileAttributes((char*)szPathFileName, &dmfa);
	fIsDir = dmfa.Attributes & FILE_ATTRIBUTE_DIRECTORY ? true : false;
   
    if (dmfa.Attributes & FILE_ATTRIBUTE_READONLY)
    {
        // Query the user if appropriate
        if (*pfQuery)
        {
            strcpy(g_szDelFile, strrchr(szPathFileName, '\\') + 1);
            if (fIsDir)
                nChoice = DialogBox(hInst, "DELFOL", hWnd, (DLGPROC) ConfirmDeleteFolderDlg);
            else
                nChoice = DialogBox(hInst, "DELFILE", hWnd, (DLGPROC) ConfirmDeleteFileDlg);

            switch (nChoice)
            {
            case IDC_YES:
                // Yep, delete it
                break;
            case IDC_YESALL:
                // Yep delete it, and stop asking
                *pfQuery = false;
                break;

            case IDC_NOPE:
                // User doesn't want to delete this file, but wants to delete others
                hr = XBDM_NOERR;
                goto done;

            case IDC_CANCEL:
                // User wants to stop deleting
                *pfQuery = false;
                goto done;
            }
        }

        // If here, then we want to delete it.  Remove the 'readonly' attrib
        dmfa.Attributes &= ~FILE_ATTRIBUTE_READONLY;
        SetFileAttributes((char*)szPathFileName, &dmfa);
    }

    if (fIsDir)
    {
        // Recursively remove the contents of dir
        DM_FILE_ATTRIBUTES dmfa;

        // Create the search string that will return us the list of all files and directories in
        // the current directory (on the source side).
        HANDLE hfind = FindFirstFile(szPathFileName, &dmfa, true, g_TargetXbox);
        if (hfind != INVALID_HANDLE_VALUE)
        {
            do
            {
                char szFile[MAX_PATH];

                wsprintf(szFile, "%s\\%s", szPathFileName, dmfa.Name);
                if (!Del(szFile, pfQuery, hWnd))
                    goto done;
            }
            while (FindNextFile(hfind, &dmfa, true));
        }

        // Now that everything is removed from the directory, delete the directory itself below.
    }

    // When here, it's either a file or an EMPTY directory.
    hr = DmDeleteFile(szPathFileName, dmfa.Attributes & FILE_ATTRIBUTE_DIRECTORY);

done:
    
    g_pxboxconn->After();

    return hr == XBDM_NOERR;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  XBFU::Md
// Purpose:   Creates a new directory
// Arguments: szDirName         -- Name of the directory to create.
// Return:    'true' if successful, 'false' otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool XBFU::Md(LPCSTR szDirName)
{
    g_pxboxconn->Before();
    HRESULT hr = DmMkdir(szDirName);
    
    g_pxboxconn->After();
    
    return hr == XBDM_NOERR;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  XBFU::Ren
// Purpose:   Renames the specified file.
// Arguments: szOrigName        -- File to rename (must be complete path).
//            szNewName         -- Name to rename the file to.
// Return:    'true' if successful, 'false' otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool XBFU::Ren(LPCSTR szOrigName, LPCSTR szNewName)
{
    g_pxboxconn->Before();
    HRESULT hr = DmRenameFile(szOrigName, szNewName);
    
    g_pxboxconn->After();
    
    return hr == XBDM_NOERR;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  XBFU::Reboot
// Purpose:   Reboots the Xbox.
// Arguments: UNDONE-WARN: Unknown.  Not used anywhere.
// Return:    'S_OK' if successful, Error code otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT XBFU::Reboot(bool f, LPCSTR sz)
{
    g_pxboxconn->Before();

    // Reboot the Xbox.
    DmReboot(DMBOOT_WARM);

    g_pxboxconn->After();

    // Return that everything went fine.
	return S_OK;
}


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  XBFU::SetFileAttributes
// Purpose:   Set file attributes for specified file
// Arguments: 
// Return:    Always return success (Raid #5430)
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT XBFU::SetFileAttributes(char *szFileName, DM_FILE_ATTRIBUTES *pdmfa, bool fXbox)
{
    g_pxboxconn->Before();

    if (!pdmfa->Attributes)
        pdmfa->Attributes = FILE_ATTRIBUTE_NORMAL;

    if (fXbox)
    {
        if (DmSetFileAttributes(szFileName, pdmfa) != XBDM_NOERR)
            goto done;
    }
    else
    {
        ::SetFileAttributes(szFileName, pdmfa->Attributes);
    }
        

done:

    g_pxboxconn->After();
    return S_OK;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  XBFU::GetNumFiles
// Purpose:   
// Arguments: 
// Return:    
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
int XBFU::GetNumFiles(char *szRoot)
{
    g_pxboxconn->Before();

    DM_FILE_ATTRIBUTES dmfa;
    int nFiles = 1; // ACcount for 'this' file
    
    // if this is a dir, then add the subfiles
    GetFileAttributes(szRoot, &dmfa);
    if (dmfa.Attributes & FILE_ATTRIBUTE_DIRECTORY)
    {
        HANDLE hfile = FindFirstFile(szRoot, &dmfa, true);
        if (hfile != INVALID_HANDLE_VALUE)
        {
            do
            {
                if (dmfa.Attributes & FILE_ATTRIBUTE_DIRECTORY)
                {
                    char szSub[MAX_PATH];
                    wsprintf(szSub, "%s\\%s", szRoot, dmfa.Name);
                    nFiles += GetNumFiles(szSub);
                }
                else
                    nFiles += 1;
            } while (FindNextFile(hfile, &dmfa, true));
        }
    }
    g_pxboxconn->After();
    return nFiles;
}

// If the dest file is a readonly file, then remove the readonly attribute now
bool XBFU::RemoveAttribute(const char *szDestPathFile, DWORD dwAttr, bool fXbox)
{
    DM_FILE_ATTRIBUTES dmfa;
    bool fRet = false;
    g_pxboxconn->Before();
    
    if (GetFileAttributes((char*)szDestPathFile, &dmfa, fXbox) != S_OK)
        goto done;

    dmfa.Attributes &= ~dwAttr;
    if (SetFileAttributes((char*)szDestPathFile, &dmfa, fXbox) != S_OK)
        goto done;

    fRet = true;
done:
    g_pxboxconn->After();
    return fRet;
}

// If the dest file is a readonly file, then remove the readonly attribute now
bool XBFU::SetAttribute(const char *szDestPathFile, DWORD dwAttr, bool fXbox)
{
    DM_FILE_ATTRIBUTES dmfa;
    bool fRet = false;
    g_pxboxconn->Before();
    
    if (GetFileAttributes((char*)szDestPathFile, &dmfa, fXbox) != S_OK)
        goto done;

    dmfa.Attributes |= dwAttr;
    if (SetFileAttributes((char*)szDestPathFile, &dmfa, fXbox) != S_OK)
        goto done;

    fRet = true;
done:
    g_pxboxconn->After();
    return fRet;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  XBFU::GetFileAttributes
// Purpose:   Get file attributes for specified file
// Arguments: 
// Return:    
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT XBFU::GetFileAttributes(char *szFileName, DM_FILE_ATTRIBUTES *pdmfa, bool fXbox)
{
    HRESULT hr;
    g_pxboxconn->Before();

    if (fXbox)
    {
        hr = DmGetFileAttributes(szFileName, pdmfa);
        if (hr != XBDM_NOERR)
        {
            hr = E_FAIL;
            goto done;
        }
    }
    else
    {
        WIN32_FILE_ATTRIBUTE_DATA wfad;

        GetFileAttributesEx(szFileName, GetFileExInfoStandard, &wfad);
        pdmfa->Attributes = wfad.dwFileAttributes;
        pdmfa->SizeLow = wfad.nFileSizeLow;
        pdmfa->SizeHigh = wfad.nFileSizeHigh;
        pdmfa->ChangeTime = wfad.ftLastAccessTime;
        pdmfa->CreationTime = wfad.ftCreationTime;
    }

    // NOTE: DmGetFileAttributes does not set Name...
    strcpy(pdmfa->Name, strrchr(szFileName, '\\') + 1);

    hr = S_OK;

done:

    g_pxboxconn->After();
    return hr;
}

void XBFU::DoFailMoveCopyMsg(bool fMove)
{
    char szText[1024], szCaption[200];

    g_progress.SetError();
    LoadString(hInst, IDS_FAILED_COPYMOVE_TEXT, szText, 1024);
    LoadString(hInst, IDS_FAILED_COPYMOVE_CAPTION, szCaption, 200);
    MessageBox(g_hwnd, szText, szCaption, MB_ICONEXCLAMATION | MB_OK);
}

#include <assert.h>

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  XBFU::CopyMove
// Purpose:   Copies or moves the specified file to the specified directory.
// Arguments: szSrcPathFile     -- Full path\name of the source file to copy.
//            szDestPathFile    -- Full path\name of the destination file.
//            pfQuery           -- 'true' if we should query the user on overwrite or read-only
//                                 file operations.  We set this to 'false' if the user clicks
//                                 'Yes to all' in the query dialog box.
//            fDestXbox         -- 'true' if the destination is on the Xbox.
//            fSrcXbox          -- 'false' if the destination is on the Xbox.
//            fRecursive        -- 'true' if we should recurse down into subdirectories.
// Notes:     - This function will only be called in the Xbox->Xbox and PC->XBox cases.  The
//              Xbox->PC case is handled separately through IStreams.
//            - This function is broken into 7 main parts:
//              1. Verify we CAN copy/move
//                  a. Verify sufficient harddisk space
//                  b. Handle the same-directory same-name copy/move case.
//                      - move == error dialog.  Copy == rename dest to "Copy of <source name>"
//                  c. Verify valid file names
//                      - length <= 42
//                  d. Verify the destination object is not in a child folder of the source object
//                      also, dropping folder a *onto* a.
//              2. Verify the user WANTS to do the copy/move (if *pfQuery == true)
//                  a. If the source object is read-only and this is a move, then ask if user wants
//                     to move the read-only object.
//                  b. If destination object already exists then ask if user wants to overwrite it
//                  -- If user clicks 'yes to all' in either of those, then set *pfQuery = true;
//              3. Remove destination object if it exists and is a file
//              4. Copy the object if it is a file
//              5. Copy Attributes from the source object to the dest object (readonly, etc)
//              6. Recurse into the object if it is a folder
//              7. Delete the source object if this is a move.
//
// Return:    'S_OK' if successful, Error code otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT XBFU::CopyMoveToXbox(LPCSTR szSrcPathFile, LPCSTR szDestPathFile, bool *pfQuery, 
                             bool fDestXbox, bool fSrcXbox, bool fRecursive, bool fMove, bool *pfSkipped)
{
    DM_FILE_ATTRIBUTES dmfaDestFile, dmfaSrcFile;
    ULARGE_INTEGER     uliSourceSize, uliDestFree;
    char               szBuf[MAX_PATH], szText[1024], szCaption[200];
    char               szDestPathFinal[MAX_PATH];
    bool               fDestExists;
    HRESULT            hr;
    int                nChoice;
    
    // Initialize the shared Xbox connection and cursor state.
    g_pxboxconn->Before();
    g_progress.ClearError();

    // Verify we're not getting called in the Xbox->PC case
    assert(!(fSrcXbox == true && fDestXbox == false));

    // Verify we were passed valid parameters
    if (!szSrcPathFile || !szDestPathFile || !pfQuery)
    {
        hr = E_INVALIDARG;
        goto done;
    }

	if (pfSkipped)
		*pfSkipped = false;

    // Get the attributes of the source file.  It must exist.
    hr = GetFileAttributes((char*)szSrcPathFile, &dmfaSrcFile, fSrcXbox);
    if (hr != S_OK)
    {
        // Failed to get the source file's attributes.
        DoFailMoveCopyMsg(fMove);
        hr = E_FAIL;
        goto done;
    }

    // Get the attributes of the destination file if it exists
    if (GetFileAttributes((char*)szDestPathFile, &dmfaDestFile) == S_OK)
        fDestExists = true;
    else
        fDestExists = false;

    // Store the name of the destination file separately.  We do this since we may rename it below.
    strcpy(szDestPathFinal, szDestPathFile);


    // ============== VERIFY WE CAN COPY/MOVE =====================================================

    // Verify sufficient harddisk space
    sprintf(szBuf, "%c:\\", szDestPathFinal[1]);
    if (GetDriveFreeSize(szBuf, &uliDestFree) != S_OK)
    {
        // Failed to get the destination drive's free space.
        DoFailMoveCopyMsg(fMove);
        hr = E_FAIL;
        goto done;
    }


    if (fDestExists)
    {
        // We'll be overwriting the destination file, so we should add it's size back in to
        // the destination free space to determine the final space usage.
        ULARGE_INTEGER uliDestFileSize;
        uliDestFileSize.LowPart = dmfaDestFile.SizeLow;
        uliDestFileSize.HighPart = dmfaDestFile.SizeHigh;
        uliDestFree.QuadPart += uliDestFileSize.QuadPart;
    }

    uliSourceSize.LowPart = dmfaSrcFile.SizeLow;
    uliSourceSize.HighPart = dmfaSrcFile.SizeHigh;

    // Need to special-case the folder case since their size shows up as '0' bytes,
    if (uliSourceSize.QuadPart == 0)
        uliSourceSize.QuadPart = 1;
    
    if (uliDestFree.QuadPart < uliSourceSize.QuadPart)
    {
        // Not enough disk space!
        LoadString(hInst, IDS_NOSPACE_TEXT, szText, 1024);
        LoadString(hInst, IDS_NOSPACE_CAPTION, szCaption, 200);
        g_progress.SetError();
        MessageBox(g_hwnd, szText, szCaption, MB_ICONEXCLAMATION | MB_OK);
        hr = ERROR_DISK_FULL;
        goto done;
    }

    // Take this opportunity to update the file progress bar now that we have the size of the file
    g_progress.SetFileInfo(strrchr(szSrcPathFile, '\\') + 1, uliSourceSize);

    // This code should only come into play when a file overwrites the exact same file.  At all
	// other times, the issue should be caught by the 'overwrite' code farther below.
    if (fDestExists && !MyStrcmp(szSrcPathFile, szDestPathFile))
    {
        if (fMove)
        {
            // User is not allowed to move the same file to 'itself'.
            LoadString(hInst, IDS_CANT_MOVE_SAME_NAME_TEXT, szText, 1024);
            LoadString(hInst, IDS_CANT_MOVE_SAME_NAME_CAPTION, szCaption, 200);
            sprintf(szBuf, szText, strrchr(szSrcPathFile, '\\') + 1);
            g_progress.SetError();
            MessageBox(g_hwnd, szBuf, szCaption, MB_ICONEXCLAMATION | MB_OK);
            hr = E_FAIL;
            goto done;
        }
        else
        {
            // Copying - rename the destination object to "copy (#) of <source name>".  We loop
            // through this until we find a dest filename that doesn't exist.
            int iTry = 0;

            // UNDONE-ERR: Because of the way that listview::paste works, modifying the name of
            // a directory introduces difficulties (in short: the paste dataobject contains a complete
            // list of all files to copy; therefore if we modify the name of a file, we need to somehow
            // track that fact so that subsequent copies into the 'expected' folder actually get
            // sent to the new folder 'copy of foo'.  Once that's resolved, remove following 
            // block and everything should be fine.
            if (dmfaSrcFile.Attributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                // User is not allowed to copy the same folder to 'itself'.
                LoadString(hInst, IDS_CANT_COPY_SAME_NAME_TEXT, szText, 1024);
                LoadString(hInst, IDS_CANT_COPY_SAME_NAME_CAPTION, szCaption, 200);
                sprintf(szBuf, szText, strrchr(szSrcPathFile, '\\') + 1);
                g_progress.SetError();
                MessageBox(g_hwnd, szBuf, szCaption, MB_ICONEXCLAMATION | MB_OK);
                hr = E_FAIL;
                goto done;
            }
            
            while (true)
            {
                DM_FILE_ATTRIBUTES dmfa;

                char *pszDestFile = strrchr(szDestPathFinal, '\\') + 1;
                if (iTry == 0)
                    sprintf(pszDestFile, "Copy of %s", strrchr(szSrcPathFile, '\\') + 1);
                else
                    sprintf(pszDestFile, "Copy (%d) of %s", iTry + 1, strrchr(szSrcPathFile, '\\') + 1);

                // Does new dest file exist?
                if (GetFileAttributes((char*)szDestPathFinal, &dmfa) == E_FAIL)
                    break;

                iTry++;
            }
            fDestExists = false;
        }
    }
    
    // Verify that the destination file name is of an acceptable length <= 42 chararacters)
    if (MyStrlen(strrchr(szDestPathFinal, '\\') + 1) > 42)
    {
        LoadString(hInst, IDS_FILENAME_TOO_LONG_TEXT, szText, 1024);
        LoadString(hInst, IDS_FILENAME_TOO_LONG_CAPTION, szCaption, 200);
        sprintf(szBuf, szText, strrchr(szDestPathFinal, '\\') + 1);
        g_progress.SetError();
        MessageBox(g_hwnd, szBuf, szCaption, MB_ICONEXCLAMATION | MB_OK);
        hr = E_FAIL;
        goto done;
    }
    
    // Verify that the destination object is not in a child folder of the source object
    if (memcmp(szSrcPathFile, szDestPathFinal, MyStrlen(szSrcPathFile)) == 0)
    {
        // Destination is in a subfolder of the source!
        LoadString(hInst, IDS_CANT_MOVE_SUBFOLDER_TEXT, szText, 1024);
        LoadString(hInst, IDS_CANT_MOVE_SUBFOLDER_CAPTION, szCaption, 200);
        sprintf(szBuf, szText, strrchr(szSrcPathFile, '\\') + 1);
        g_progress.SetError();
        MessageBox(g_hwnd, szBuf, szCaption, MB_ICONEXCLAMATION | MB_OK);
        hr = E_FAIL;
        goto done;
    }


    // ==== VERIFY THE USER WANTS TO DO THE COPY/MOVE =============================================

    // If the source object is read-only and this is a move, then ask if the user wants to move
    // the read-only object
    if (*pfQuery && fMove && dmfaSrcFile.Attributes & FILE_ATTRIBUTE_READONLY)
    {
        g_progress.SetError();
        strcpy(g_szDelFile, strrchr(szSrcPathFile, '\\') + 1); 
        if (dmfaSrcFile.Attributes & FILE_ATTRIBUTE_DIRECTORY)
            nChoice = DialogBox(hInst, "CONFIRM_RO_MOVE", g_hwnd, (DLGPROC) ConfirmMoveROFolderDlg);
        else
            nChoice = DialogBox(hInst, "CONFIRM_RO_MOVE", g_hwnd, (DLGPROC) ConfirmMoveROFileDlg);

        switch (nChoice)
        {
        case IDC_YES:
            // Yep, move it
            break;
        case IDC_YESALL:
            // Yep move it, and stop asking
            *pfQuery = false;
            break;

        case IDC_NOPE:
            // User doesn't want to move this file, but wants to move others
            hr = S_OK;
            goto done;

        case IDC_CANCEL:
            // User wants to stop moving.
            *pfQuery = false;
            hr = E_FAIL;
            goto done;
        }
    }
    
    // If the destination object already exists then ask if the user wants to overwrite it
    if (fDestExists && *pfQuery)
    {
        // Ask the user if they want to overwrite it.  Use a global var for the filename
        // string since we can't pass data into a dialog.
        g_progress.SetError();
        strcpy(g_szDelFile, strrchr(szDestPathFile, '\\') + 1);
        if (dmfaDestFile.Attributes & FILE_ATTRIBUTE_DIRECTORY)
            nChoice = DialogBox(hInst, "OVERWRITE", g_hwnd, (DLGPROC) ConfirmFolderOverwriteDlg);
        else
            nChoice = DialogBox(hInst, "OVERWRITE", g_hwnd, (DLGPROC) ConfirmFileOverwriteDlg);

        switch (nChoice)
        {
        case IDC_YES:
            // Yep, move it
            break;

        case IDC_YESALL:
            // Yep move it, and stop asking
            *pfQuery = false;
            break;

        case IDC_NOPE:
            // User doesn't want to move this file, but wants to move others
            hr = S_OK;
			if (pfSkipped)
				*pfSkipped = true;
            goto done;

        case IDC_CANCEL:
            // User wants to stop moving.
            *pfQuery = false;
            hr = E_FAIL;
            goto done;
        }
    }


    // ==== REMOVE DESTINATION OBJECT =============================================================
    
    // Remove the destination object if it exists and is a file
    if (fDestExists && !(dmfaDestFile.Attributes & FILE_ATTRIBUTE_DIRECTORY))
    {
        // Remove the Read-only attribute from the file if it's set
        RemoveAttribute(szDestPathFinal, FILE_ATTRIBUTE_READONLY, fDestXbox);

        // Delete the file.
        if (DmDeleteFile(szDestPathFinal, false) != XBDM_NOERR)
        {
            // Failed to delete the file.
            DoFailMoveCopyMsg(fMove);
            hr = E_FAIL;
            goto done;
        }
    }
    

    // ==== COPY OBJECT (IF FILE), CREATE DIR (IF FOLDER) =========================================
    
    if (dmfaSrcFile.Attributes & FILE_ATTRIBUTE_DIRECTORY)
    {
        // It's a folder.  We only need to create the directory if it doesn't already exist
        if (fDestExists)
        {
            // Remove the 'hidden' attribute in case it's set
            if (!RemoveAttribute(szDestPathFinal, FILE_ATTRIBUTE_HIDDEN, fDestXbox))
            {
                DoFailMoveCopyMsg(fMove);
                hr = E_FAIL;
                goto done;
            }
        }
        else
        {
            // Create the directory
            if (!Md(szDestPathFinal))
            {
                DoFailMoveCopyMsg(fMove);
                hr = E_FAIL;
                goto done;
            }
        }
    }
    else
    {
        // It's a file.  Copy from the source

        // Clear the error since the file copy could take a looooong time
        g_progress.ClearError();

        if (fSrcXbox)
        {
            // Xbox->Xbox copy
            // Note: I can't see a way to do a localized copy on the XBox, so we instead
            //       copy the file locally to the PC, and then copy it back out to the
            //       xbox under the new name.  Could add support to XboxDbg, s'pose...

            char szTempPath[MAX_PATH];
            char szTempPathFileName[MAX_PATH];

            // Create a temporary file name for the new file
            if (GetTempPath(MAX_PATH, szTempPath) == 0)
            {
                hr = E_FAIL;
                DoFailMoveCopyMsg(fMove);
                goto done;
            }

            if (GetTempFileName(szTempPath, "xbx", 0, szTempPathFileName) == 0)
            {
                hr = E_FAIL;
                DoFailMoveCopyMsg(fMove);
                goto done;
            }

            // Now that we have a valid name for our temporary file, copy the file from the Xbox
            // to the temporary file, and then copy it back out to the Xbox under the new name
            if (DmReceiveFile(szTempPathFileName, szSrcPathFile) != XBDM_NOERR)
            {
                hr = E_FAIL;
                DoFailMoveCopyMsg(fMove);
                goto done;
            }

            if (DmSendFile(szTempPathFileName, szDestPathFinal) != XBDM_NOERR)
            {
                hr = E_FAIL;
                DoFailMoveCopyMsg(fMove);
                goto done;
            }

            // Finally, delete our temporary file
            if (!DeleteFile(szTempPathFileName))
            {
                hr = E_FAIL;
                DoFailMoveCopyMsg(fMove);
                goto done;
            }
        }
        else
        {
            // PC->Xbox copy
            if (DmSendFile(szSrcPathFile, szDestPathFinal) != XBDM_NOERR)
            {
                hr = E_FAIL;
                DoFailMoveCopyMsg(fMove);
                goto done;
            }
        }
    }

    // Copy attributes to the new object
    if (SetFileAttributes((char*)szDestPathFinal, &dmfaSrcFile) != S_OK)
    {
        hr = E_FAIL;
        DoFailMoveCopyMsg(fMove);
        goto done;
    }


    // ==== RECURSE INTO OBJECT (IF FOLDER) =======================================================
    
    if (dmfaSrcFile.Attributes & FILE_ATTRIBUTE_DIRECTORY && fRecursive)
    {
        DM_FILE_ATTRIBUTES dmfa;
        
        // Create the search string that will return us the list of all files and directories in
        // the current directory (on the source side).
        HANDLE hfind = FindFirstFile(szSrcPathFile, &dmfa, fSrcXbox);
        if (hfind != INVALID_HANDLE_VALUE)
        {
            do
            {
                char szSourceSubDir[MAX_PATH];
                char szDestSubDir[MAX_PATH];

                wsprintf(szSourceSubDir, "%s\\%s", szSrcPathFile, dmfa.Name);
                wsprintf(szDestSubDir, "%s\\%s", szDestPathFile, dmfa.Name);
                HRESULT hr = CopyMoveToXbox(szSourceSubDir, szDestSubDir, pfQuery, fDestXbox,
                                            fSrcXbox, fRecursive, fMove);
                if (hr != S_OK)
                {
                    FindClose(hfind, fSrcXbox);
                    goto done;
                }
            }
            while (FindNextFile(hfind, &dmfa, fSrcXbox));
            FindClose(hfind, fSrcXbox);
        }
    }

    
    // ==== DELETE SOURCE OBJECT IF (MOVE) ========================================================

    // UNDONE-ERR: This should actually *completely* disappear once I'm handling 'paste succeeded'
    // in the data object handling on my end (in the Xbox->Xbox and Xbox->PC cases).
    if (fMove && fRecursive)
    {
        // Remove the Read-only attribute from the file if it's set
        if (!RemoveAttribute(szSrcPathFile, FILE_ATTRIBUTE_READONLY, fSrcXbox))
        {
            DoFailMoveCopyMsg(fMove);
            hr = E_FAIL;
            goto done;
        }

        // Delete the file.
        if (fSrcXbox)
        {
            // Xbox->Xbox move.  Delete the original file from the Xbox
            if (DmDeleteFile(szSrcPathFile, dmfaSrcFile.Attributes & FILE_ATTRIBUTE_DIRECTORY) != XBDM_NOERR)
            {
                // Failed to delete the file.
                DoFailMoveCopyMsg(fMove);
                hr = E_FAIL;
                goto done;
            }
        }
        else
        {
            // PC->Xbox move.  Delete the original file from the PC
            if (dmfaSrcFile.Attributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                if (!RemoveDirectory(szSrcPathFile))
                {
                    hr = E_FAIL;
                    goto done;
                }
            }
            else
            {
                if (!DeleteFile(szSrcPathFile))
                {
                    hr = E_FAIL;
                    goto done;
                }
            }
        }
    }

    // If here, then the file was successfully moved/copied.
    hr = S_OK;

done:

    g_pxboxconn->After();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\XBFU.h ===
//
//
// Xbox Target Box file utility
//
// 2000/12/8	YuichM		Release alpha version
// 2000/12/19-	Shinjich
//
//

#pragma warning(disable:4786)
#include <map>

using namespace std;

typedef map<HANDLE, PDM_WALK_DIR > MAPFINDFILE;

class XBFU
{
public:
	XBFU();
	~XBFU();

	HRESULT GetTarget( LPSTR, UINT );						// ^[Qbg̎擾
	HRESULT SetTarget( LPCSTR );							// ^[Qbg̐ݒ
	bool IsDrive( CHAR );									// hCu݂邩̃`FbNia...z) YES=TRUE

	HANDLE FindFirstFile( LPCSTR, PDM_FILE_ATTRIBUTES, bool fTargetXbox, LPCSTR = NULL );	// t@C
	bool FindNextFile( HANDLE, PDM_FILE_ATTRIBUTES, bool fTargetXbox );
	bool FindClose( HANDLE, bool fTargetXbox );

    HRESULT CopyMoveToXbox(LPCSTR szSrcPathFile, LPCSTR szDestPathFile, bool *pfQuery,
						   bool fDestXbox, bool fSrcXbox, bool fRecursive, bool fMove, bool *pfSkipped = NULL);

    bool Del(LPCSTR szPathFileName, bool *pfQuery, HWND hWnd);
	bool Md( LPCSTR );										// fBNg쐬
	bool Ren( LPCSTR, LPCSTR );								// t@CύX

	HRESULT Reboot( bool = FALSE, LPCSTR = NULL );			// ^[Qbgu[g
    HRESULT GetFileAttributes(char *szFileName, DM_FILE_ATTRIBUTES *pdmfa, bool fXbox = true);
    HRESULT SetFileAttributes(char *szFileName, DM_FILE_ATTRIBUTES *pdmfa, bool fXbox = true);
    int GetNumFiles(char *szRoot);
    bool RemoveAttribute(const char *szDestPathFile, DWORD dwAttr, bool fXbox = true);
    HRESULT GetDriveFreeSize(char *szDrive, ULARGE_INTEGER *puliSpace);
    bool SetAttribute(const char *szDestPathFile, DWORD dwAttr, bool fXbox = true);
    bool GetDriveList(LPSTR sz, LPDWORD pcch);
    bool FailedConnect()
    {
        bool fRet= m_fCannotConnect; m_fCannotConnect = false; return fRet;
    }
    void SetFailed() {m_fCannotConnect = true; }
private:
    void DoFailMoveCopyMsg(bool fMove);
    int m_cOpenedHandles;
    bool m_fCannotConnect;
    MAPFINDFILE m_mappdmwdFindFile;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbExplorer\xbExplorer.h ===
//#define JAPANESE

// Common settings
#define SHORTFILELEN MAX_PATH    //(8 + 1 + 3 + 1)

// User Messages
#define WM_STATUSTEXT WM_USER+16	// wParam = column num, lParam = (LPCTSTR) text

extern UINT g_suFileGroupDesc;
extern UINT g_suFileContents;
extern UINT g_suXboxObject, g_suXboxFiles, g_suPrefDropEffect;
extern UINT g_suPerfDropEffect;
extern UINT g_suPasteSucceeded;

extern LISTVIEW listview;
extern TOOLVIEW toolview;
extern HWND g_hwnd;
extern int g_iPopupFileItem;
extern XBFU xbfu;
extern HINSTANCE hInst;
extern char g_TargetXbox[256];
extern char g_CurrentDir[MAX_PATH];
extern BOOL splashscreen;

void CenterDialog( HWND );
extern char szAppName[];
extern HISTORY history;
extern char g_szDelFile[MAX_PATH];

// widebyte stuff
extern int MyStrcmp(const char *sz1, const char *sz2);
extern char *MyStrdup(char *sz);
extern int MyStricmp(const char *sz1, const char *sz2);
extern int MyStrlen(const char *sz);
extern char gs_szUtoA[1024];
char *WideToSingleByte(WCHAR *pwIn);


class CXboxConnection;
extern CXboxConnection *g_pxboxconn;

extern char *FormatBigNumber(ULONGLONG n);
extern char *FormatNumber(int n);
extern void FormatSize(ULARGE_INTEGER ulSize, char *szBuf, bool fBytes);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbformat\xbformat.cpp ===
/*
**
** xbformat
**
** Reformat drives on the Xbox
**
*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <xboxdbg.h>
#include "optn.hxx"
#include <xboxverp.h>

BOOL OPTH::FParseOption(char *&sz, char)
{
    return FALSE;
}

void OPTH::UsageFailure(void)
{
    fprintf(stderr, "xbformat version " VER_PRODUCTVERSION_STR "\n\n"
        "Reformats a FAT partition on the Xbox\n");
	fprintf(stderr, "\nusage: %s [/x xboxname] partition-number\n", m_szExe);
	exit(1);
}

int __cdecl main(int cArg, char **rgszArg)
{
    DWORD dwPartition;
    HRESULT hr;
    char szCmd[1024];

	/* Process arguments */
	OPTH opth(cArg, rgszArg);

	if(cArg < 1 || !sscanf(rgszArg[0], "%d", &dwPartition) || dwPartition == 0)
		opth.UsageFailure();

    sprintf(szCmd, "fmtfat partition=%d", dwPartition);
    hr = DmSendCommand(NULL, szCmd, NULL, NULL);
    if(FAILED(hr)) {
        fprintf(stderr, "error: error code 0x%08x\n", hr);
        exit(1);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbformat\optn.cpp ===
/*
 *
 * optn.cpp
 *
 * Option handling
 *
 */

#include <windows.h>
#include <xboxdbg.h>
#include <stdlib.h>
#include <stdio.h>
#include "optn.hxx"

OPTH::OPTH(int &cArg, char **&rgszArg, const char *szOptionChars)
{
	m_szExe = *rgszArg;
    const char *pchOptionMarker;
    char *szXboxEnv;

    /* Grab Xbox name from environment if it's there */
    szXboxEnv = getenv("XBOXIP");
    if(szXboxEnv && FAILED(DmSetXboxNameNoRegister(szXboxEnv))) {
	    fprintf(stderr, "error in Xbox name: %s\n", szXboxEnv);
        exit(1);
    }

	/* Process arguments */
	++rgszArg;
	while(--cArg && (pchOptionMarker = strchr(szOptionChars, **rgszArg))) {
		char *szArg = *rgszArg++;
		while(*++szArg) {
			switch(*szArg) {
			case 'x':
			case 'X':
				if(!--cArg)
					UsageFailure();
				if(FAILED(DmSetXboxName(*rgszArg++))) {
					fprintf(stderr, "error in Xbox name\n");
					exit(1);
				}
				break;
#if 0
			case '+':
				_asm int 3;
				break;
#endif
			default:
				if(!FParseOption(szArg, *pchOptionMarker))
					UsageFailure();
				break;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbflash\xbflash.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    xbflash.cpp

Abstract:

    This is internal tool used to flash the Xbox ROM image.  The tool sends
    the kernel image using debug channel.

--*/

#include "xbflashp.h"

VOID
XbFlashDisplayUsageAndExit(
    VOID
    )
/*++

Routine Description:

    This routine prints usage information about how to use the program and
    terminates the process.  The routine will not return.

Argument:

    None

Return Value:

    None, this routine will terminate the process

--*/
{
    fprintf(stderr,
        "\nUsage:\txbflash [-x name or IP [-y]] image\n\n"
        "\t-x\tIP address or name of Xbox\n"
        "\t-y\tUseful for batch file to suppress prompting\n"
        "\t\tTo prevent innocent Xbox from being flashed accidentally,\n"
        "\t\tthe parameter -y requires -x\n"
        "\timage\tValid Xbox kernel image, "
        "xbflash will not validate the image\n\n");
    exit(1);
}

VOID
XbFlashTranslateError(
    IN HRESULT Hr
    )
/*++

Routine Description:

    This routine translates HRESULT from DM APIs, prints to stardard error

Arguments:

    Hr - HRESULT returned vt various DM APIs

Return Value:

    None

--*/
{
    CHAR Buffer[512];

    DmTranslateError(Hr, Buffer, ARRAYSIZE(Buffer));
    fprintf(stderr, "%s\n", Buffer);
}

PCSTR
XbFlashFormatErrorMessage(
    IN DWORD Win32ErrorCode
    )
/*++

Routine Description:

    This routine formats Win32 error code to a message string.  It uses
    FormatMessage to search the system's message table resource(s) for
    the message definition.

    Note: this routine is not thread-safe.

Arguments:

    Win32ErrorCode - Win32 error code, usually returned from GetLastError

Return Value:

    Pointer to static formatted buffer

--*/
{
    static CHAR MsgBuf[256];

    FormatMessage(
        FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL, Win32ErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        MsgBuf, sizeof(MsgBuf), NULL);

    return MsgBuf;
}

PVOID
ReadKernelImage(
    IN  PCSTR FileName,
    OUT SIZE_T* ImageSize
    )
/*++

Routine Description:

    This routine allocates memory and read the content of file specified by
    the parameter FileName to allocated buffer.  The CRC32 of the image is
    also calculated and stored at the first 32-bit of buffer.  The actual
    content of image start after the CRC32.

Argument:

    FileName - Pointer to null-terminated ANSI string of file name

    ImageSize - Pointer to SIZE_T to retreive size of kernel image

Return Value:

    Buffer contains content of image or NULL if error occurred.  The buffer
    is allocated using LocalAlloc, the caller must free the buffer using
    LocalFree.

--*/
{
    SIZE_T FileSize;
    PDWORD ImageBuffer = NULL;
    DWORD BytesRead = 0;
    HANDLE hFile;

    hFile = CreateFile(FileName, GENERIC_READ, FILE_SHARE_READ, 0,
                OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

    if (hFile == INVALID_HANDLE_VALUE ) {
        fprintf(stderr, "Unable to open kernel image file: %s\n",
            XbFlashFormatErrorMessage(GetLastError()));
        return NULL;
    }

    FileSize = GetFileSize(hFile, 0 );

    if ((FileSize & (FileSize - 1)) != 0) {
        fprintf(stderr, "Invalid kernel image size\n");
        goto cleanup;
    }

    ImageBuffer = (PDWORD)LocalAlloc(LPTR, FileSize);

    if (!ImageBuffer) {
        fprintf(stderr, "Unable to allocate memory\n");
        goto cleanup;
    }

    ReadFile(hFile, ImageBuffer, FileSize, &BytesRead, NULL);

    if (BytesRead != FileSize) {
        fprintf(stderr, "Error reading kernel image file: %s\n",
            XbFlashFormatErrorMessage(GetLastError()));
        LocalFree(ImageBuffer);
        ImageBuffer = NULL;
    } else {
        *ImageSize = FileSize;
    }

cleanup:
    CloseHandle(hFile);
    return ImageBuffer;
}

HRESULT
XbFlashImage(
    IN PVOID ImageBuffer,
    IN SIZE_T ImageSize,
    IN BOOL IgnoreVersionChecking
    )
/*++

Routine Description:

    This routine sends request along with kernel image to debug monitor
    asking it to flash to flash ROM.

Argument:

    ImageBuffer - Pointer to memory buffer contains kernel image. The first
        DWORD of the buffer is CRC32 of the kernel image.

    ImageSize - Size of buffer containing kernel image

Return Value:

    HRESULT of operation

--*/
{
    HRESULT hr;
    CHAR szResp[256];
    CHAR szCmd[64];
    PDM_CONNECTION pdmc;
    DWORD cchResp, Crc;

    hr = DmOpenConnection(&pdmc);

    if (FAILED(hr)) {
        return hr;
    }

    Crc = Crc32(0xFFFFFFFF, ImageBuffer, ImageSize);
    sprintf(szCmd, "flash length=0x%x crc=0x%x ignoreversionchecking=0x%x",
        ImageSize, Crc, IgnoreVersionChecking);
    cchResp = ARRAYSIZE(szResp);

    hr = DmSendCommand(pdmc, szCmd, szResp, &cchResp);

    if (hr != XBDM_READYFORBIN) {
        fputs("Mismatch version of xbdm.dll on the specified Xbox\n", stderr);
        return XBDM_NOERR;
    }

    fprintf(stdout, "Sending image file...\n");
    hr = DmSendBinary(pdmc, ImageBuffer, ImageSize);

    if (FAILED(hr)) {
        XbFlashTranslateError(hr);
    } else {
        fprintf(stdout, "Flashing, this might take couple minutes...\n");

        cchResp = ARRAYSIZE(szResp);
        hr = DmReceiveStatusResponse(pdmc, szResp, &cchResp);
        fprintf(stdout, "%s\n", &szResp[5]);

        if (SUCCEEDED(hr)) {
            fprintf(stdout, "New kernel will be used in next cold reboot\n");
        }
    }

    DmCloseConnection(pdmc);

    return hr;
}

int __cdecl main(int argc, char *argv[])
{
    int  i;
    char *arg;
    HRESULT hr = S_OK;
    DWORD len;
    CHAR XboxName[256];
    BOOL fPrompt = TRUE;
    BOOL fFlash = TRUE;
    BOOL fIgnoreVersionChecking = FALSE;
    PCSTR pszFileName = NULL;
    PCSTR pszXboxName = NULL;
    PVOID ImageBuffer;
    SIZE_T ImageSize;

    //
    // Process and validate command lines
    //

    pszXboxName = getenv("XBOXIP");
    if (pszXboxName) {
        DmSetXboxNameNoRegister(pszXboxName);
        pszXboxName = NULL;
    }

    for (i=1; i<argc; i++) {
        arg = argv[i];
        if (*arg == '/' || *arg == '-') {
            arg++;
            if (*arg == 'x' || *arg == 'X') {
                pszXboxName = (++i < argc ? argv[i] : NULL);
            } else if (*arg == 'y' || *arg == 'Y') {
                fPrompt = FALSE;
            } else if (*arg == 'i' || *arg == 'I') {
                fIgnoreVersionChecking = TRUE;
            }
        } else if (!pszFileName) {
            pszFileName = arg;
        } else {
            XbFlashDisplayUsageAndExit();
        }
    }

    //
    // To prevent innocent Xbox from being flashed accidentally, the
    // parameter -y requires -x
    //

    if (!pszFileName || (!pszXboxName && !fPrompt)) {
        XbFlashDisplayUsageAndExit();
    }

    ImageBuffer = ReadKernelImage(pszFileName, &ImageSize);

    if (!ImageBuffer) {
        return 1;
    }

    //
    // Validate the Xbox machine name and prompt if necessary
    //

    if (pszXboxName) {
        hr = DmSetXboxName(pszXboxName);
    }

    if (SUCCEEDED(hr)) {
        len = ARRAYSIZE(XboxName);
        hr = DmGetXboxName(XboxName, &len);
    }

    if (SUCCEEDED(hr)) {
        fprintf(stdout, "\nFlash kernel image to '%s'\n", XboxName);
        if (fPrompt) {
            fprintf(stdout, "Continue? ");
            if (toupper(getchar()) != 'Y') {
                fFlash = FALSE;
            }
        }
        if (fFlash) {
            hr = XbFlashImage(ImageBuffer, ImageSize, fIgnoreVersionChecking);
        }
    }

    if (FAILED(hr)) {
        XbFlashTranslateError(hr);
    }

    LocalFree(ImageBuffer);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\account.cpp ===
/*****************************************************************************
 *
 *    account.cpp -
 *
 *
 *****************************************************************************/

#include "priv.h"
#include "account.h"
#include "passwordapi.h"
#include <richedit.h>
#include <regapix.h>

#define SZ_REGKEY_SEPARATOR                 TEXT("\\")

// Server Level Login Attributes
#define ATTRIB_NONE                         0x00000000
#define ATTRIB_LOGIN_ANONYMOUSLY            0x00000001
#define ATTRIB_SAVE_USERNAME                0x00000002
#define ATTRIB_SAVE_PASSWORD                0x00000004

#define ATTRIB_DEFAULT                      (ATTRIB_LOGIN_ANONYMOUSLY | ATTRIB_SAVE_USERNAME)



/*****************************************************************************\
    FUNCTION: _GetAccountKey

    DESCRIPTION: 
\*****************************************************************************/
HRESULT CAccounts::_GetAccountKey(LPCTSTR pszServer, LPTSTR pszKey, DWORD cchKeySize)
{
    HRESULT hr = S_OK;

    StrCpyN(pszKey, SZ_REGKEY_XBOXFOLDER_ACCOUNTS, cchKeySize);
    StrCatBuff(pszKey, pszServer, cchKeySize);

    return hr;
}


/*****************************************************************************\
    FUNCTION: _GetUserAccountKey

    DESCRIPTION: 
\*****************************************************************************/
HRESULT CAccounts::_GetUserAccountKey(LPCTSTR pszServer, LPCTSTR pszUserName, LPTSTR pszKey, DWORD cchKeySize)
{
    TCHAR szUserNameEscaped[MAX_PATH];
    HRESULT hr = _GetAccountKey(pszServer, pszKey, cchKeySize);

    EscapeString(pszUserName, szUserNameEscaped, ARRAYSIZE(szUserNameEscaped));
    StrCatBuff(pszKey, SZ_REGKEY_SEPARATOR, cchKeySize);
    StrCatBuff(pszKey, szUserNameEscaped, cchKeySize);

    return hr;
}


/*****************************************************************************\
    FUNCTION: GetUserName

    DESCRIPTION: 
\*****************************************************************************/
HRESULT CAccounts::GetUserName(LPCTSTR pszServer, LPTSTR pszUserName, DWORD cchUserName)
{
    HRESULT hr = E_FAIL;
    TCHAR szKey[MAXIMUM_SUB_KEY_LENGTH];
    DWORD dwType = REG_SZ;
    DWORD cbSize = cchUserName * sizeof(TCHAR);

    hr = _GetAccountKey(pszServer, szKey, ARRAYSIZE(szKey));
    if (EVAL(SUCCEEDED(hr)))
    {
        if (ERROR_SUCCESS != SHGetValue(HKEY_CURRENT_USER, szKey, SZ_REGVALUE_DEFAULT_USER, &dwType, pszUserName, &cbSize))
            hr = E_FAIL;
    }

    return hr;
}




/*****************************************************************************\
    FUNCTION: _LoadLoginAttributes

    DESCRIPTION: 
\*****************************************************************************/
HRESULT CAccounts::_LoadLoginAttributes(DWORD * pdwLoginAttribs)
{
    HRESULT hr = E_FAIL;
    TCHAR szKey[MAXIMUM_SUB_KEY_LENGTH];
    DWORD dwType = REG_DWORD;
    DWORD cbSize = sizeof(*pdwLoginAttribs);

    // TODO: Walk the tree so these are read from the correct place.
    ASSERT(pdwLoginAttribs);
    hr = _GetAccountKey(m_pszServer, szKey, ARRAYSIZE(szKey));
    if (EVAL(SUCCEEDED(hr)))
    {
        // Do we also want to check on a per user basis?
        if ((ERROR_SUCCESS != SHGetValue(HKEY_CURRENT_USER, szKey, SZ_REGKEY_LOGIN_ATTRIBS, &dwType, pdwLoginAttribs, &cbSize)) ||
            (ERROR_SUCCESS != SHGetValue(HKEY_CURRENT_USER, SZ_REGKEY_XBOXFOLDER_ACCOUNTS, SZ_REGKEY_LOGIN_ATTRIBS, &dwType, pdwLoginAttribs, &cbSize)))
        {
            hr = E_FAIL;
        }
    }

    return hr;
}




/*****************************************************************************\
    FUNCTION: _SaveLoginAttributes

    DESCRIPTION: 
\*****************************************************************************/
HRESULT CAccounts::_SaveLoginAttributes(LPCTSTR pszServer, DWORD dwLoginAttribs)
{
    HRESULT hr = E_FAIL;
    TCHAR szKey[MAXIMUM_SUB_KEY_LENGTH];

    // TODO: Walk the tree so these are saved to the correct place.
    hr = _GetAccountKey(pszServer, szKey, ARRAYSIZE(szKey));
    if (EVAL(SUCCEEDED(hr)))
    {
        if (!EVAL(ERROR_SUCCESS == SHSetValue(HKEY_CURRENT_USER, szKey, SZ_REGKEY_LOGIN_ATTRIBS, REG_DWORD, &dwLoginAttribs, sizeof(dwLoginAttribs))) ||
            !EVAL(ERROR_SUCCESS == SHSetValue(HKEY_CURRENT_USER, SZ_REGKEY_XBOXFOLDER_ACCOUNTS, SZ_REGKEY_LOGIN_ATTRIBS, REG_DWORD, &dwLoginAttribs, sizeof(dwLoginAttribs))))
        {
            hr = E_FAIL;
        }
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: GetPassword

    DESCRIPTION: 
        Update m_pszUser with pszUserName and get the password if we are allowed
    to.  pszPassword is optional.
\*****************************************************************************/
HRESULT CAccounts::GetPassword(LPCTSTR pszServer, LPCTSTR pszUserName, LPTSTR pszPassword, DWORD cchPassword)
{
    HRESULT hr = E_NOTIMPL;
    DWORD dwLogAttribs = 0;

    Str_SetPtr((LPTSTR *) &m_pszServer, pszServer);
    Str_SetPtr((LPTSTR *) &m_pszUser, pszUserName);
    _LoadLoginAttributes(&dwLogAttribs);
    hr = _LoadDefaultPassword((dwLogAttribs & ATTRIB_SAVE_PASSWORD));
    if (pszPassword)
    {
        pszPassword[0] = 0;  // Incase this password isn't stored yet.
        if (SUCCEEDED(hr))
            StrCpyN(pszPassword, m_pszPassword, cchPassword);
    }

    return hr;
}



/*****************************************************************************\
    FUNCTION: _GetPassword

    DESCRIPTION: 
        Always get a password even if persist is off.
\*****************************************************************************/
HRESULT CAccounts::_GetPassword(LPCTSTR pszServer, LPCTSTR pszUserName, LPTSTR pszPassword, DWORD cchPassword)
{
    HRESULT hr = E_NOTIMPL;

    pszPassword[0] = 0;  // Incase this password isn't stored yet.

#ifdef FEATURE_SAVE_PASSWORD
    TCHAR wzKey[MAX_URL_STRING];

    wnsprintfW(wzKey, ARRAYSIZE(wzKey), L"xbox://%ls@%ls", pszUserName, pszServer);
    hr = GetCachedCredentials(wzKey, pszPassword, cchPassword);
#endif // FEATURE_SAVE_PASSWORD

    return hr;
}



/*****************************************************************************\
    FUNCTION: _UserChangeSelect

    DESCRIPTION:
\*****************************************************************************/
HRESULT CAccounts::_UserChangeSelect(HWND hDlg, BOOL fSelectChange)
{
    HRESULT hr = S_OK;
    TCHAR szUser[INTERNET_MAX_USER_NAME_LENGTH];
    HWND hwndComboBox = GetDlgItem(hDlg, IDC_LOGINDLG_USERNAME);

    // SelectChange requires we get the text thru ComboBox_GetLBText because
    // it's not in GetWindowText yet.  KILLFOCUS requires we get it from
    // GetWindowText because nothing is selected.
    szUser[0] = 0;
    if (fSelectChange)
    {
        if (ARRAYSIZE(szUser) > ComboBox_GetLBTextLen(hwndComboBox, ComboBox_GetCurSel(hwndComboBox)))
            ComboBox_GetLBText(hwndComboBox, ComboBox_GetCurSel(hwndComboBox), szUser);
    }
    else
        GetWindowText(hwndComboBox, szUser, ARRAYSIZE(szUser));

    if (szUser[0])
    {
        GetPassword(m_pszServer, szUser, NULL, 0);
        SetWindowText(GetDlgItem(hDlg, IDC_LOGINDLG_PASSWORD_DLG1), m_pszPassword);
    }

    return hr;
}



/*****************************************************************************\
    FUNCTION: _SaveUserName

    DESCRIPTION:
\*****************************************************************************/
HRESULT CAccounts::_SaveUserName(HWND hDlg)
{
    HRESULT hr = S_OK;
    TCHAR szKey[MAXIMUM_SUB_KEY_LENGTH];
    TCHAR szUser[INTERNET_MAX_USER_NAME_LENGTH];

    GetWindowText(GetDlgItem(hDlg, IDC_LOGINDLG_USERNAME), szUser, ARRAYSIZE(szUser));
    Str_SetPtr((LPTSTR *) &m_pszUser, szUser);

    // Always save the user name
    hr = _GetAccountKey(m_pszServer, szKey, ARRAYSIZE(szKey));
    if (EVAL(SUCCEEDED(hr)))
    {
        if (!EVAL(ERROR_SUCCESS == SHSetValue(HKEY_CURRENT_USER, szKey, SZ_REGVALUE_DEFAULT_USER, REG_SZ, szUser, (lstrlen(szUser) + 1) * sizeof(TCHAR))))
            hr = E_FAIL;

        hr = _GetUserAccountKey(m_pszServer, m_pszUser, szKey, ARRAYSIZE(szKey));
        if (EVAL(SUCCEEDED(hr)))
            SHSetValue(HKEY_CURRENT_USER, szKey, TEXT(""), REG_SZ, TEXT(""), sizeof(TEXT("")));
    }

    return hr;
}



/*****************************************************************************\
    FUNCTION: _SavePassword

    DESCRIPTION:
\*****************************************************************************/
HRESULT CAccounts::_SavePassword(HWND hDlg, LPCTSTR pszUser, BOOL fPersist)
{
    HRESULT hr = S_OK;
    TCHAR szPassword[INTERNET_MAX_PASSWORD_LENGTH];
    TCHAR wzKey[MAX_URL_STRING];

    GetWindowText(GetDlgItem(hDlg, IDC_LOGINDLG_PASSWORD_DLG1), szPassword, ARRAYSIZE(szPassword));
    Str_SetPtr((LPTSTR *) &m_pszPassword, szPassword);

#ifdef FEATURE_SAVE_PASSWORD
    if (fPersist)
    {
        wnsprintfW(wzKey, ARRAYSIZE(wzKey), L"xbox://%ls@%ls", pszUser, m_pszServer);
        hr = SetCachedCredentials(wzKey, szPassword);
    }
#endif // FEATURE_SAVE_PASSWORD

    return hr;
}


/*****************************************************************************\
    FUNCTION: _SetLoginType

    DESCRIPTION:
\*****************************************************************************/
HRESULT CAccounts::_SetLoginType(HWND hDlg, BOOL fLoginAnnonymously)
{
    ////// The "Annonymous" section
    // Set the Radio Button
    CheckDlgButton(hDlg, IDC_LOGINDLG_ANONYMOUS_CBOX, (fLoginAnnonymously ? BST_CHECKED : BST_UNCHECKED));

    // Disable or Enable applicable items
    if (fLoginAnnonymously)
    {
        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_USERNAME), SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_USERNAME_ANON), SW_SHOW);

        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_PASSWORD_DLG1), SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_PASSWORD_DLG2), SW_SHOW);

        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_PASSWORD_LABEL_DLG1), SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_PASSWORD_LABEL_DLG2), SW_SHOW);

        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_NOTES_DLG1), SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_NOTES_DLG2), SW_SHOW);

        // Hide "Save Password" in Anonymous mode.
        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_SAVE_PASSWORD), SW_HIDE);
    }
    else
    {
        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_USERNAME), SW_SHOW);
        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_USERNAME_ANON), SW_HIDE);

        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_PASSWORD_DLG1), SW_SHOW);
        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_PASSWORD_DLG2), SW_HIDE);

        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_PASSWORD_LABEL_DLG1), SW_SHOW);
        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_PASSWORD_LABEL_DLG2), SW_HIDE);

        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_NOTES_DLG1), SW_SHOW);
        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_NOTES_DLG2), SW_HIDE);

        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_SAVE_PASSWORD), SW_SHOW);
    }

    if (fLoginAnnonymously) // Select all the text.
    {
        int iStart = 0;
        int iEnd = -1;

        SendMessage(GetDlgItem(hDlg, IDC_LOGINDLG_PASSWORD_DLG2), EM_GETSEL, (WPARAM) &iStart, (LPARAM) &iEnd);
    }

    SetFocus(GetDlgItem(hDlg, IDC_LOGINDLG_PASSWORD_DLG2));
    return S_OK;
}


/*****************************************************************************\
    FUNCTION: _PopulateUserNameDropDown

    DESCRIPTION:
\*****************************************************************************/
HRESULT CAccounts::_PopulateUserNameDropDown(HWND hDlg, LPCTSTR pszServer)
{
    HRESULT hr = S_OK;
    HWND hwndUserComboBox = GetDlgItem(hDlg, IDC_LOGINDLG_USERNAME);

    if (EVAL(hwndUserComboBox))
    {
        TCHAR szKey[MAXIMUM_SUB_KEY_LENGTH];
        TCHAR szDefaultUser[INTERNET_MAX_USER_NAME_LENGTH];

        szDefaultUser[0] = 0;
        hr = _GetAccountKey(pszServer, szKey, ARRAYSIZE(szKey));
        if (EVAL(SUCCEEDED(hr)))
        {
            HKEY hKey;

            SendMessage(hwndUserComboBox, CB_RESETCONTENT, 0, 0);      // Empty the contents.
            if (ERROR_SUCCESS == RegOpenKey(HKEY_CURRENT_USER, szKey, &hKey))
            {
                TCHAR szUser[INTERNET_MAX_USER_NAME_LENGTH];
                DWORD dwIndex = 0;

                while (ERROR_SUCCESS == RegEnumKey(hKey, dwIndex++, szUser, sizeof(szUser)))
                {
                    UnEscapeString(NULL, szUser, ARRAYSIZE(szUser));
                    SendMessage(hwndUserComboBox, CB_ADDSTRING, NULL, (LPARAM) szUser);
                }

                RegCloseKey(hKey);
            }

            SendMessage(hwndUserComboBox, CB_SETCURSEL, 0, 0);
        }

        if (!m_pszUser[0])
            GetUserName(pszServer, szDefaultUser, ARRAYSIZE(szDefaultUser));

        if (CB_ERR == SendMessage(hwndUserComboBox, CB_FINDSTRINGEXACT, 0, (LPARAM) (m_pszUser ? m_pszUser : szDefaultUser)))
            SendMessage(hwndUserComboBox, CB_ADDSTRING, NULL, (LPARAM) (m_pszUser ? m_pszUser : szDefaultUser));

        SetWindowText(hwndUserComboBox, (m_pszUser ? m_pszUser : szDefaultUser));
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: _LoadDefaultPassword

    DESCRIPTION:
\*****************************************************************************/
HRESULT CAccounts::_LoadDefaultPassword(BOOL fLoadPersisted)
{
    TCHAR szPassword[INTERNET_MAX_PASSWORD_LENGTH];
    HRESULT hr = S_FALSE;

    if (fLoadPersisted)
        hr = _GetPassword(m_pszServer, m_pszUser, szPassword, ARRAYSIZE(szPassword));
    else
        szPassword[0] = 0;

    Str_SetPtr((LPTSTR *) &m_pszPassword, szPassword);
    return hr;
}


/*****************************************************************************\
    FUNCTION: _LoadMessage

    DESCRIPTION:
\*****************************************************************************/
HRESULT CAccounts::_LoadMessage(HWND hDlg)
{
    // if it's allowed, we need to load the anonymous email.  This needs to be
    // be hard coded in English because that's how XBOX works.
    SetWindowText(GetDlgItem(hDlg, IDC_LOGINDLG_USERNAME_ANON), TEXT("Anonymous"));

    if (LOGINFLAGS_ANON_LOGINJUSTFAILED & m_dwLoginFlags)
    {
        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_MESSAGE_NORMAL), SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_MESSAGE_USERREJECT), SW_HIDE);
    }
    else if (LOGINFLAGS_USER_LOGINJUSTFAILED & m_dwLoginFlags)
    {
        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_MESSAGE_ANONREJECT), SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_MESSAGE_NORMAL), SW_HIDE);
    }
    else
    {
        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_MESSAGE_ANONREJECT), SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_MESSAGE_USERREJECT), SW_HIDE);
    }

    return S_OK;
}


/*****************************************************************************\
    FUNCTION: _LoadEMailName

    DESCRIPTION:
\*****************************************************************************/
HRESULT CAccounts::_LoadEMailName(HWND hDlg)
{
    TCHAR szEmailName[MAX_PATH];
    DWORD dwType = REG_SZ;
    DWORD cbSize = sizeof(szEmailName);

    if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, SZ_REGKEY_INTERNET_SETTINGS, SZ_REGKEY_EMAIL_NAME, &dwType, szEmailName, &cbSize))
        SetWindowText(GetDlgItem(hDlg, IDC_LOGINDLG_PASSWORD_DLG2), szEmailName);

    return S_OK;
}


/*****************************************************************************\
    FUNCTION: _SaveEMailName

    DESCRIPTION:
\*****************************************************************************/
HRESULT CAccounts::_SaveEMailName(HWND hDlg)
{
    HRESULT hr = E_FAIL;
    TCHAR szEmailName[MAX_PATH];

    if (GetWindowText(GetDlgItem(hDlg, IDC_LOGINDLG_PASSWORD_DLG2), szEmailName, ARRAYSIZE(szEmailName)))
    {
        if (ERROR_SUCCESS == SHSetValue(HKEY_CURRENT_USER, SZ_REGKEY_INTERNET_SETTINGS, SZ_REGKEY_EMAIL_NAME, REG_SZ, szEmailName, (lstrlen(szEmailName) + 1) * sizeof(TCHAR)))
            hr = S_OK;
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: _InitDialog

    DESCRIPTION:
\*****************************************************************************/
BOOL CAccounts::_InitDialog(HWND hDlg)
{
    DWORD dwLogAttribs = ATTRIB_SAVE_USERNAME;
    BOOL fSucceeded = SetProp(hDlg, SZ_ACCOUNT_PROP, this);
    ASSERT(fSucceeded);

    // Init the dialog controls
    _LoadMessage(hDlg);     // Load Message
    _LoadLoginAttributes(&dwLogAttribs);
    if (m_dwLoginFlags & LOGINFLAGS_ANON_ISDEFAULT) // Do we want to login anonymously?
        dwLogAttribs |= ATTRIB_LOGIN_ANONYMOUSLY;   // Yes.

    CheckDlgButton(hDlg, IDC_LOGINDLG_ANONYMOUS_CBOX, (m_dwLoginFlags & LOGINFLAGS_ANON_ISDEFAULT));
    SetWindowText(GetDlgItem(hDlg, IDC_LOGINDLG_XBOXSERVER), m_pszServer);

    _SetLoginType(hDlg, ATTRIB_LOGIN_ANONYMOUSLY & dwLogAttribs);

    _LoadEMailName(hDlg);
    _PopulateUserNameDropDown(hDlg, m_pszServer);
    _LoadDefaultPassword((dwLogAttribs & ATTRIB_SAVE_PASSWORD));
    SetWindowText(GetDlgItem(hDlg, IDC_LOGINDLG_PASSWORD_DLG1), m_pszPassword);

#ifdef FEATURE_SAVE_PASSWORD
    if (S_OK == InitCredentialPersist())
        CheckDlgButton(hDlg, IDC_LOGINDLG_SAVE_PASSWORD, (dwLogAttribs & ATTRIB_SAVE_PASSWORD));
    else
        EnableWindow(GetDlgItem(hDlg, IDC_LOGINDLG_SAVE_PASSWORD), FALSE);
#endif // FEATURE_SAVE_PASSWORD

    return TRUE;
}

/*****************************************************************************\
    FUNCTION: _SaveDialogData

    DESCRIPTION:
\*****************************************************************************/
BOOL CAccounts::_SaveDialogData(HWND hDlg)
{
    DWORD dwLogAttribs = ATTRIB_NONE;
    if (IsDlgButtonChecked(hDlg, IDC_LOGINDLG_ANONYMOUS_CBOX))
        m_dwLoginFlags |= LOGINFLAGS_ANON_ISDEFAULT;
    else
        m_dwLoginFlags &= ~LOGINFLAGS_ANON_ISDEFAULT;

    // Alway save user name
    dwLogAttribs |= ATTRIB_SAVE_USERNAME;

    _SaveUserName(hDlg);
#ifdef FEATURE_SAVE_PASSWORD
    if (IsDlgButtonChecked(hDlg, IDC_LOGINDLG_SAVE_PASSWORD))
        dwLogAttribs |= ATTRIB_SAVE_PASSWORD;

    if (!(m_dwLoginFlags & LOGINFLAGS_ANON_ISDEFAULT))
        _SavePassword(hDlg, m_pszUser, (dwLogAttribs & ATTRIB_SAVE_PASSWORD));
#endif // FEATURE_SAVE_PASSWORD

    _SaveLoginAttributes(m_pszServer, dwLogAttribs);

    // Init the dialog controls
    _SaveEMailName(hDlg);

    return TRUE;
}


/*****************************************************************************\
    FUNCTION: _OnCommand

    DESCRIPTION:
\*****************************************************************************/
LRESULT CAccounts::_OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    UINT idc = GET_WM_COMMAND_ID(wParam, lParam);

    switch (idc)
    {
    case IDOK:
        if (m_hDlg == hDlg)  // (IDOK)
        {
            _SaveDialogData(hDlg);
            EndDialog(hDlg, TRUE);
            lResult = 1;
        }
        break;

    case IDCANCEL:
        EndDialog(hDlg, FALSE);
        lResult = 1;
        break;

    case IDC_LOGINDLG_ANONYMOUS_CBOX:
        _SetLoginType(hDlg, IsDlgButtonChecked(hDlg, IDC_LOGINDLG_ANONYMOUS_CBOX));
        lResult = 1;
        break;

    case IDC_LOGINDLG_USERNAME:
        {
            UINT uCmd = GET_WM_COMMAND_CMD(wParam, lParam);

            switch (uCmd)
            {
            case CBN_SELCHANGE:
            case CBN_KILLFOCUS:
                _UserChangeSelect(hDlg, (CBN_SELCHANGE == uCmd));
                lResult = 1;
                break;
            }
        }
        break;
    }

    return lResult;
}


/*****************************************************************************\
    FUNCTION: _LoginDialogProc

    DESCRIPTION:
\*****************************************************************************/
INT_PTR CALLBACK CAccounts::_LoginDialogProc(HWND hDlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;

    switch (wm)
    {
    case WM_INITDIALOG:
        {
            CAccounts * pThis = (CAccounts *) lParam;
            pThis->m_hDlg = hDlg;
            lResult = pThis->_InitDialog(hDlg);
            break;
        }

    case WM_COMMAND:
        {
            CAccounts * pThis = (CAccounts *)GetProp(hDlg, SZ_ACCOUNT_PROP);

            if (EVAL(pThis))
                lResult = pThis->_OnCommand(hDlg, wParam, lParam);
            break;
        }
    }

    return lResult;
}


/*****************************************************************************\
    FUNCTION: GetAccountUrl

    DESCRIPTION:
\*****************************************************************************/
HRESULT CAccounts::DisplayLoginDialog(HWND hwnd, DWORD dwLoginFlags, LPCTSTR pszServer, LPTSTR pszUserName, DWORD cchUserNameSize, LPTSTR pszPassword, DWORD cchPasswordSize)
{
    HRESULT hr;

    ASSERT(hwnd && pszServer[0]);
    if (TEXT('\0') == pszUserName[0])
        hr = GetUserName(pszServer, pszUserName, cchUserNameSize);

    Str_SetPtr((LPTSTR *) &m_pszServer, pszServer);
    Str_SetPtr((LPTSTR *) &m_pszUser, pszUserName);
    Str_SetPtr((LPTSTR *) &m_pszPassword, pszPassword);

    m_dwLoginFlags = dwLoginFlags;
    if (DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(IDD_LOGINDLG), hwnd, _LoginDialogProc, (LPARAM)this))
    {
        StrCpyN(pszUserName, ((m_dwLoginFlags & LOGINFLAGS_ANON_ISDEFAULT) ? TEXT("") : m_pszUser), cchUserNameSize);
        StrCpyN(pszPassword, ((m_dwLoginFlags & LOGINFLAGS_ANON_ISDEFAULT) ? TEXT("") : m_pszPassword), cchPasswordSize);
        hr = S_OK;
    }
    else
        hr = S_FALSE;

    return hr;
}




/****************************************************\
    Constructor
\****************************************************/
CAccounts::CAccounts()
{
    DllAddRef();

    // NOTE: We may be put on the stack, so we will not
    //    automatically have our member variables inited.
    m_pszServer = 0;
    m_pszUser = 0;
    m_pszPassword = 0;

    LEAK_ADDREF(LEAK_CAccount);
}


/****************************************************\
    Destructor
\****************************************************/
CAccounts::~CAccounts()
{
    Str_SetPtr((LPTSTR *) &m_pszServer, NULL);
    Str_SetPtr((LPTSTR *) &m_pszUser, NULL);
    Str_SetPtr((LPTSTR *) &m_pszPassword, NULL);

    DllRelease();
    LEAK_DELREF(LEAK_CAccount);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbflash\xbflashp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    xbflashp.h

Abstract:

    This is a pre-compiled header file for xbflash

--*/

#include <io.h>
#include <stdio.h>
#include <conio.h>
#include <stdlib.h>

#include <windows.h>
#include <xboxdbg.h>

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)        (sizeof(a) / sizeof((a)[0]))
#endif

const unsigned long CrcTable32[ 256 ] = {
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,
    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,
    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,
    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,
    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,
    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,
    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,
    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,
    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,
    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
};

unsigned long
__inline
Crc32(
    unsigned long InitialCrc,
    const void *Buffer,
    unsigned long Bytes
    )
{
    unsigned long Crc = InitialCrc;
    const unsigned char *p = (unsigned char *)Buffer;
    unsigned long Count = Bytes;

    while ( Count-- ) {
        Crc = ( Crc >> 8 ) ^ CrcTable32[ ((unsigned char)(Crc)) ^ *p++ ];
    }

    return Crc;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\cobjsafe.h ===
#ifndef SAFEOBJ_H_
#define SAFEOBJ_H_

// Static functions of interest to others
HRESULT DefaultGetSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions);
HRESULT DefaultSetSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions);
HRESULT MakeSafeForScripting(IUnknown **punk); // returns TRUE if punk is safe for scripting

class CObjectSafety : public IObjectSafety
{
public:
    // IUnknown (we multiply inherit from IUnknown, disambiguate here)
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)() PURE;
    STDMETHOD_(ULONG, Release)() PURE;
    
    // IObjectSafety
    STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions);
    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions);
    
protected:
    DWORD           _dwSafetyOptions;   // IObjectSafety IID_IDispatch options

};
   
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\cobjsafe.cpp ===
#include "priv.h"
#include "comcat.h"
#include <hliface.h>
#include <imm.h>
#include <mshtml.h>
#include "cobjsafe.h"

// a default isafetyobject that we generally would use...  marks 
// deals with IDispatch 


HRESULT CObjectSafety::GetInterfaceSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
{
    if (IsEqualIID(riid, IID_IDispatch))
    {
        *pdwEnabledOptions = _dwSafetyOptions;
    }
    else
    {
        ::DefaultGetSafetyOptions(riid, pdwSupportedOptions, pdwEnabledOptions);
    }

    return S_OK;
}


HRESULT CObjectSafety::SetInterfaceSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
{
    if (dwOptionSetMask & ~(INTERFACESAFE_FOR_UNTRUSTED_CALLER |
                            INTERFACESAFE_FOR_UNTRUSTED_DATA))
    {
        return E_INVALIDARG;
    }

    if (IsEqualIID(riid, IID_IDispatch))
    {
        _dwSafetyOptions = (_dwSafetyOptions & ~dwOptionSetMask) |
                           (dwEnabledOptions & dwOptionSetMask);
        return S_OK;
    }
    else
    {
        return ::DefaultSetSafetyOptions(riid, dwOptionSetMask, dwEnabledOptions);
    }
}



// *** IObjectSafety
//
// A couple static functions called by sitemap (and webbrowser).
// These are static so anyone else in this dll who has an OC
// that's always safe can just call them.
//
// These functions say we are safe for these three interfaces we implement
//  IID_IDispatch
//  IID_IPersistStream
//  IID_IPersistPropertyBag
//
// The WebBrowser OC handles IDispatch differently.
//
HRESULT DefaultGetSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
{
    *pdwSupportedOptions = 0;
    *pdwEnabledOptions = 0;

    if (IsEqualIID(riid, IID_IDispatch) ||
        IsEqualIID(riid, IID_IPersistStream) ||
        IsEqualIID(riid, IID_IPersistStreamInit) ||
        IsEqualIID(riid, IID_IPersistPropertyBag) ||
        IsEqualIID(riid, IID_IPersistHistory))
    {
        *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA;
        *pdwEnabledOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA;
    }

    return S_OK;
}

HRESULT DefaultSetSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
{
    if (dwOptionSetMask & ~(INTERFACESAFE_FOR_UNTRUSTED_CALLER |
                            INTERFACESAFE_FOR_UNTRUSTED_DATA))
    {
        return E_INVALIDARG;
    }

    if (IsEqualIID(riid, IID_IDispatch) ||
        IsEqualIID(riid, IID_IPersistStream) ||
        IsEqualIID(riid, IID_IPersistStreamInit) ||
        IsEqualIID(riid, IID_IPersistHistory) ||
        IsEqualIID(riid, IID_IPersistPropertyBag))
    {
        return S_OK;
    }

    return E_FAIL;
}


// When CWebBrowserOC is in the safe for scripting mode, we can't give out
// anyone else's IDispatch that is not also safe for scripting.
// This function encapsulates the basic functionality needed by both
// MakeSafeScripting and MakeSafeForInitializing (which we don't use)
BOOL MakeSafeFor(
IUnknown *punk,                 // object to test for safety
REFCATID catid,                 // category of safety
REFIID riid,                    // interface on which safety is desired
DWORD dwXSetMask,               // options to set
DWORD dwXOptions                // options to make safe for
                                    // (either INTERFACESAFE_FOR_UNTRUSTED_CALLER or
                                    //  INTERFACESAFE_FOR_UNTRUSTED_DATA)
)
{
    HRESULT hres;

    // first try IObjectSafety
    IObjectSafety *posafe;
    if (SUCCEEDED(punk->QueryInterface(IID_IObjectSafety, (LPVOID*) &posafe)))
    {
        hres = posafe->SetInterfaceSafetyOptions(riid, dwXSetMask, dwXOptions);
        posafe->Release();

        if (SUCCEEDED(hres))
            return TRUE;
    }

    // check the registry for "safe for scripting" component category

    // we need the classid -- get it thru IPersist
    CLSID clsid;
    IPersist *ppersist;
    hres = punk->QueryInterface(IID_IPersist, (LPVOID*) &ppersist);
    if (SUCCEEDED(hres))
    {
        hres = ppersist->GetClassID(&clsid);
        ppersist->Release();
    }
    if (FAILED(hres))
    {
        TraceMsg(TF_ALWAYS, "shv MakeSafeForScripting - object doesn't have IPersist!");
        return FALSE;
    }

    // Create the category manager
    ICatInformation *pcatinfo;
    hres = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
                            NULL, CLSCTX_INPROC_SERVER,
                            IID_ICatInformation, (LPVOID*) &pcatinfo);
    if (FAILED(hres))
        return FALSE;

    // Ask if the object belongs to the specified category
    CATID rgcatid[1];
    rgcatid[0] = catid;

    hres = pcatinfo->IsClassOfCategories(clsid, 1, rgcatid, 0, NULL);
    pcatinfo->Release();

    return (hres==S_OK) ? TRUE : FALSE;;	
}

HRESULT MakeSafeForScripting(IUnknown** ppDisp)
{
    HRESULT hres = S_OK;

    if (!MakeSafeFor(*ppDisp, CATID_SafeForScripting, IID_IDispatch,
                       INTERFACESAFE_FOR_UNTRUSTED_CALLER,
                       INTERFACESAFE_FOR_UNTRUSTED_CALLER))
    {
        TraceMsg(TF_ALWAYS, "shv MakeSafeForScripting - IDispatch not safe");

        (*ppDisp)->Release();
        *ppDisp = NULL;
        hres = E_FAIL;
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\account.h ===
/*****************************************************************************
 *	account.h
 *****************************************************************************/

#ifndef _ACCOUNT_H
#define _ACCOUNT_H


/*****************************************************************************\
  CLASS: CAccounts
\*****************************************************************************/

#define LOGINFLAGS_DEFAULT                  0x00000000  // Default to Anonymous when dialog is displayed
#define LOGINFLAGS_ANON_ISDEFAULT           0x00000001  // Default to Anonymous when dialog is displayed
#define LOGINFLAGS_ANON_LOGINJUSTFAILED     0x00000002  // The attempt to login anonymously just failed
#define LOGINFLAGS_USER_LOGINJUSTFAILED     0x00000004  // The attempt to login as a user just failed


class CAccounts
{
public:
    CAccounts();
    ~CAccounts();

    // Public Member Functions
    HRESULT DisplayLoginDialog(HWND hwnd, DWORD dwLoginFlags, LPCTSTR pszServer, LPTSTR pszUserName, DWORD cchUserNameSize, LPTSTR pszPassword, DWORD cchPasswordSize);

    HRESULT GetUserName(LPCTSTR pszServer, LPTSTR pszUserName, DWORD cchUserName);
    HRESULT GetPassword(LPCTSTR pszServer, LPCTSTR pszUserName, LPTSTR pszPassword, DWORD cchPassword);

protected:
    // Private Member Functions
    HRESULT _GetAccountKey(LPCTSTR pszServer, LPTSTR pszKey, DWORD cchKeySize);
    HRESULT _GetUserAccountKey(LPCTSTR pszServer, LPCTSTR pszUserName, LPTSTR pszKey, DWORD cchKeySize);
    HRESULT _LoadLoginAttributes(DWORD * pdwLoginAttribs);
    HRESULT _SaveLoginAttributes(LPCTSTR pszServer, DWORD dwLoginAttribs);
    HRESULT _SetLoginType(HWND hDlg, BOOL fLoginAnnonymously);
    HRESULT _LoadEMailName(HWND hDlg);
    HRESULT _SaveEMailName(HWND hDlg);
    BOOL _SaveDialogData(HWND hDlg);
    HRESULT _LoadMessage(HWND hDlg);
    HRESULT _PopulateUserNameDropDown(HWND hDlg, LPCTSTR pszServer);
    HRESULT _LoadDefaultPassword(BOOL fLoadPersisted);
    HRESULT _SaveUserName(HWND hDlg);
    HRESULT _UserChangeSelect(HWND hDlg, BOOL fSelectChange);
    HRESULT _SavePassword(HWND hDlg, LPCTSTR pszUser, BOOL fPersist);
    HRESULT _GetPassword(LPCTSTR pszServer, LPCTSTR pszUserName, LPTSTR pszPassword, DWORD cchPassword);

    BOOL _InitDialog(HWND hdlg);
    LRESULT _OnCommand(HWND hdlg, WPARAM wParam, LPARAM lParam);

    static INT_PTR CALLBACK _LoginDialogProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam);

    // Private Variables Functions
    LPCTSTR             m_pszServer;        // What is the server name?
    LPCTSTR             m_pszUser;          // What is the user name?
    LPCTSTR             m_pszPassword;      // What is the password?
    UINT                m_uiMessageID;      // What is the String ID of the message for the dialog?
    BOOL                m_dwLoginFlags;     // How should we behave?
    HWND                m_hDlg;
};

#endif // _ACCOUNT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\cowsite.cpp ===
#include "priv.h"
#include "cowsite.h"

// no default implementation for now.
// so far all clients do way more than this (e.g. deferred initialization)
// in their SetSite's.
HRESULT CObjectWithSite::SetSite(IUnknown * punkSite)
{
    IUnknown_Set(&_punkSite, punkSite);
    return S_OK;
}

HRESULT CObjectWithSite::GetSite(REFIID riid, void **ppvSite)
{
    // e.g. iedisp.c!CIEFrameAutoProp::_SetValue calls us
    TraceMsg(DM_WARNING, "cows.gs: E_NOTIMPL");
    *ppvSite = NULL;
    return E_NOTIMPL;

#if 0 // here 'tis if we ever decide we need it...
    if (_punkSite)
        return _punkSite->QueryInterface(riid, ppvSite);

    *ppvSite = NULL;
    return E_FAIL;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\cowsite.h ===
#ifndef _COWSITE_H_
#define _COWSITE_H_

// this is a virtual class
// (since pretty much everyone overrides SetSite)

class CObjectWithSite : public IObjectWithSite
{
public:
    //*** IUnknown ****
    // (client must provide!)

    //*** IObjectWithSite ***
    virtual STDMETHODIMP SetSite(IUnknown *punkSite);
    virtual STDMETHODIMP GetSite(REFIID riid, void **ppvSite);

    ~CObjectWithSite() { ASSERT(!_punkSite); }
protected:
    IUnknown *   _punkSite;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\cookie.h ===
/*****************************************************************************
 *	cookies.h
 *****************************************************************************/

#ifndef _COOKIES_H
#define _COOKIES_H

class CCookieList;
CCookieList * CCookieList_Create(void);

/*****************************************************************************
 *
 *	CCookieList
 *
 *****************************************************************************/

class CCookieList
{
public:
    CCookieList();
    ~CCookieList(void);

    // Public Member Functions
    DWORD GetCookie(LPCTSTR pszString);
    HRESULT GetString(DWORD dwCookie, LPTSTR pszString, DWORD cchSize);

    friend CCookieList * CCookieList_Create(void) { return new CCookieList(); };

protected:
    // Private Member Variables
    HDPA                    m_hdpa;

    // Private Member Variables
    DWORD _Find(LPCTSTR pszString);
    static int _FreeStringEnum(LPVOID pString, LPVOID pData);
};

#endif // _COOKIES_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\codepage.h ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       codepage.h
//
//  Contents:   Codepage definitions
//
//----------------------------------------------------------------------------

#ifndef _CODEPAGE_H_
#define _CODEPAGE_H_

/*
 *  Code Page Default Values.
 */
enum CODEPAGE
{
    CP_UNDEFINED    = -1L,
    CP_DEFAULT      = CP_ACP, 
    CP_US_OEM       = 437L,
    CP_852          = 852L,
    CP_THAI         = 874L,
    CP_JPN_SJ       = 932L,
    CP_CHN_GB       = 936L,
    CP_KOR_5601     = 949L,
    CP_TWN          = 950L,
    CP_UCS_2        = 1200L,
    CP_UCS_2_BE     = 1201L,
    CP_1250         = 1250L,
    CP_1251         = 1251L,
    CP_1252         = 1252L,
    CP_1253         = 1253L,
    CP_1254         = 1254L,
    CP_1255         = 1255L,
    CP_1256         = 1256L,
    CP_1257         = 1257L,
    CP_1258         = 1258L,
    CP_20127        = 20127L,
    CP_KOI8R        = 20866L,
    CP_KOI8RU       = 21866L,
    CP_ISO_8859_1   = 28591L,
    CP_ISO_8859_2   = 28592L,
    CP_ISO_8859_3   = 28593L,
    CP_ISO_8859_9   = 28599L,

    CP_AUTO         = 50001L,

    CP_ISO_2022_JP   = 50220L,
    CP_ISO_2022_JP_ESC   = 50221L,
    CP_ISO_2022_JP_SIO   = 50222L,
    CP_ISO_2022_KR   = 50225L,
    CP_ISO_2022_TW   = 50226L,
    CP_ISO_2022_CH   = 50227L,

    CP_JP_AUTO      = 50932L,
    CP_CHS_AUTO     = 50936L,
    CP_KR_AUTO      = 50949L,
    CP_CHT_AUTO     = 50950L,

    CP_CYRILLIC_AUTO = 51251L,
    CP_GREEK_AUTO   = 51253L,
    CP_ARABIC_AUTO  = 51256L,

    CP_EUC_JP       = 51932L,
    CP_EUC_CH       = 51936L,
    CP_EUC_KR       = 51949L,
    CP_EUC_TW       = 51950L,

    CP_CHN_HZ       = 52936L,

    CP_UTF_7        = 65000L,
    CP_UTF_8        = 65001L
};

enum CP_STATE
{
    INVALID_CP      = 0,
    VALID_CP          = 1,
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\cookie.cpp ===
/*****************************************************************************
 *
 *      cookies.cpp - Take care of the status bar.
 *
 *****************************************************************************/

#include "priv.h"
#include "cookie.h"

int CCookieList::_FreeStringEnum(LPVOID pString, LPVOID pData)
{
    LPTSTR pszString = (LPTSTR) pString;
    Str_SetPtr(&pszString, NULL);

    return 1;
}

DWORD CCookieList::_Find(LPCTSTR pszString)
{
    DWORD dwCookie = -1;        // -1 means not found.
    DWORD dwIndex;
    DWORD dwSize = DPA_GetPtrCount(m_hdpa);

    for (dwIndex = 0; dwIndex < dwSize; dwIndex++)
    {
        LPCTSTR pszCurrent = (LPCTSTR) DPA_FastGetPtr(m_hdpa, dwIndex);
        if (pszCurrent && !StrCmp(pszCurrent, pszString))
        {
            dwCookie = dwIndex;
            break;          // Found, it's already in the list so recycle.
        }
    }

    return dwCookie;
}

DWORD CCookieList::GetCookie(LPCTSTR pszString)
{
    ENTERCRITICAL;
    DWORD dwCookie = -1;

    if (!EVAL(pszString))
        return -1;

    if (!m_hdpa)
        m_hdpa = DPA_Create(10);
    
    if (EVAL(m_hdpa))
    {
        dwCookie = _Find(pszString);
        // Did we not find it in the list?
        if (-1 == dwCookie)
        {
            LPTSTR pszCopy = NULL;

            dwCookie = DPA_GetPtrCount(m_hdpa);
            Str_SetPtr(&pszCopy, pszString);
            DPA_AppendPtr(m_hdpa, pszCopy);
        }
    }
    LEAVECRITICAL;

    return dwCookie;
}

HRESULT CCookieList::GetString(DWORD dwCookie, LPTSTR pszString, DWORD cchSize)
{
    ENTERCRITICAL;
    HRESULT hr = S_FALSE;

    if (m_hdpa &&
       (dwCookie < (DWORD)DPA_GetPtrCount(m_hdpa)))
    {
        LPCTSTR pszCurrent = (LPCTSTR) DPA_FastGetPtr(m_hdpa, dwCookie);

        StrCpyN(pszString, pszCurrent, cchSize);
        hr = S_OK;
    }

    LEAVECRITICAL;
    return hr;
}



/****************************************************\
    Constructor
\****************************************************/
CCookieList::CCookieList()
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_hdpa);

    LEAK_ADDREF(LEAK_CCookieList);
}


/****************************************************\
    Destructor
\****************************************************/
CCookieList::~CCookieList(void)
{
    ENTERCRITICAL;
    if (m_hdpa)
        DPA_DestroyCallback(m_hdpa, _FreeStringEnum, NULL);
    LEAVECRITICAL;

    ASSERTNONCRITICAL;

    DllRelease();
    LEAK_DELREF(LEAK_CCookieList);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\debug.cpp ===
// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include "priv.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "MSIEXBOX"
#define SZ_MODULE           "MSIEXBOX"
#define DECLARE_DEBUG

#include <ccstock.h>
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\dialogs.h ===
/*****************************************************************************\
    FILE: Dialogs.h

    DESCRIPTION:
        This file exists to display dialogs needed during XBOX operations.
\*****************************************************************************/
 
#ifndef _DIALOGS_H
#define _DIALOGS_H


#ifdef ADD_ABOUTBOX
HRESULT DisplayAboutBox(HWND hWnd);
#endif // ADD_ABOUTBOX
HRESULT BrowseForDir(HWND hwndParent, LPCTSTR pszTitle, LPCITEMIDLIST pidlDefaultSelect, LPITEMIDLIST * ppidlSelected);

/*****************************************************************************\
    Class: CDownloadDialog

    DESCRIPTION:
        Display the Downoad Dialog to select a directory to download into.
\*****************************************************************************/

class CDownloadDialog
{
public:
    CDownloadDialog();
    ~CDownloadDialog(void);

    // Public Member Functions
    HRESULT ShowDialog(HWND hwndOwner, LPTSTR pszDir, DWORD cchSize, DWORD * pdwDownloadType);

    static INT_PTR CALLBACK DownloadDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);

protected:
    // Private Member Variables
    HWND            m_hwnd; 
    LPTSTR          m_pszDir;
    DWORD           m_dwDownloadType;

    // Private Member Functions
    BOOL _DownloadDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
    BOOL _OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam);
    BOOL _InitDialog(HWND hDlg);
    HRESULT _DownloadButton(HWND hDlg);
    void _BrowseButton(HWND hDlg);
};


#endif // _DIALOGS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\dllload.h ===
#ifndef _DLLLOAD_H_
#define _DLLLOAD_H_

#include <wininet.h>
#include <winineti.h>

// MLANG.DLL
HRESULT ConvertINetMultiByteToUnicode(LPDWORD lpdwMode, DWORD dwEncoding, LPCSTR lpSrcStr, LPINT lpnMultiCharCount, LPWSTR lpDstStr, LPINT lpnWideCharCount);
HRESULT ConvertINetUnicodeToMultiByte(LPDWORD lpdwMode, DWORD dwEncoding, LPCWSTR lpSrcStr, LPINT lpnWideCharCount, LPSTR lpDstStr, LPINT lpnMultiCharCount);

HRESULT __stdcall _SHCreateShellFolderView(const SFV_CREATE* pcsfv, LPSHELLVIEW FAR* ppsv);
STDAPI _SHPathPrepareForWriteW(HWND hwnd, IUnknown *punkEnableModless, LPCWSTR pwzPath, DWORD dwFlags);


#endif // _DLLLOAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\dllload.cpp ===
#include "priv.h"
#include <wininet.h>

#pragma warning(disable:4229)  // No warnings when modifiers used on data

// Delay loading mechanism.  This allows you to write code as if you are
// calling implicitly linked APIs, and yet have these APIs really be
// explicitly linked.  You can reduce the initial number of DLLs that 
// are loaded (load on demand) using this technique.
//
// Use the following macros to indicate which APIs/DLLs are delay-linked
// and -loaded.
//
//      DELAY_LOAD
//      DELAY_LOAD_HRESULT
//      DELAY_LOAD_SAFEARRAY
//      DELAY_LOAD_UINT
//      DELAY_LOAD_INT
//      DELAY_LOAD_VOID
//
// Use these macros for APIs that are exported by ordinal only.
//
//      DELAY_LOAD_ORD
//      DELAY_LOAD_ORD_VOID     
//
// Use these macros for APIs that only exist on the integrated-shell
// installations (i.e., a new shell32 is on the system).
//
//      DELAY_LOAD_SHELL
//      DELAY_LOAD_SHELL_HRESULT
//      DELAY_LOAD_SHELL_VOID     
//
// 


/**********************************************************************/

void _GetProcFromDLL(HINSTANCE* phinst, LPCSTR pszDLL, FARPROC* ppfn, LPCSTR pszProc)
{
#ifdef DEBUG
    CHAR szProcD[MAX_PATH];
    if (HIWORD(pszProc)) {
        lstrcpynA(szProcD, pszProc, ARRAYSIZE(szProcD));
    } else {
        wnsprintfA(szProcD, ARRAYSIZE(szProcD), "(ordinal %d)", LOWORD(pszProc));
    }
#endif // DEBUG
    // If it's already loaded, return.
    if (*ppfn) {
    return;
    }

    if (*phinst == NULL) {
#ifdef DEBUG
    TraceMsg(TF_XBOX_DLLLOADING, "DLLLOAD: Loading %hs for the first time for %hs", pszDLL, szProcD);
    
/*
    if (g_dwBreakFlags & TF_XBOX_DLLLOAD_BREAK)
    {
        DebugBreak();
    }
*/
#endif // DEBUG
    *phinst = LoadLibraryA(pszDLL);
    if (*phinst == NULL) {
        return;
    }
    }

#ifdef DEBUG
    TraceMsg(TF_XBOX_DLLLOADING, "DLLLOAD: GetProc'ing %hs from %hs for the first time", pszDLL, szProcD);
#endif // DEBUG
    *ppfn = GetProcAddress(*phinst, pszProc);
}

/*----------------------------------------------------------
Purpose: Performs a loadlibrary on the DLL only if the machine
     has the integrated shell installation.

*/
void _SHGetProcFromDLL(HINSTANCE* phinst, LPCSTR pszDLL, FARPROC* ppfn, LPCSTR pszProc)
{
    _GetProcFromDLL(phinst, pszDLL, ppfn, pszProc);
}

#define DELAY_LOAD_MAP(_hinst, _dll, _ret, _fnpriv, _fn, _args, _nargs, _err) \
_ret __stdcall _fnpriv _args                \
{                                       \
    static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
    _GetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, #_fn); \
    if (_pfn##_fn)               \
    return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}

#define DELAY_MAP_HRESULT(_hinst, _dll, _fnpriv, _fn, _args, _nargs) DELAY_LOAD_MAP(_hinst, _dll, HRESULT, _fnpriv, _fn, _args, _nargs, E_FAIL)
#define DELAY_MAP_DWORD(_hinst, _dll, _fnpriv, _fn, _args, _nargs) DELAY_LOAD_MAP(_hinst, _dll, DWORD, _fnpriv, _fn, _args, _nargs, 0)


#define DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, _err)    DELAY_LOAD_MAP(_hinst, _dll, _ret, _fn, _fn, _args, _nargs, _err)

#define DELAY_LOAD(_hinst, _dll, _ret, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, 0)
#define DELAY_LOAD_HRESULT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, HRESULT, _fn, _args, _nargs, E_FAIL)
#define DELAY_LOAD_SAFEARRAY(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, SAFEARRAY *, _fn, _args, _nargs, NULL)
#define DELAY_LOAD_DWORD(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, DWORD, _fn, _args, _nargs, 0)
#define DELAY_LOAD_UINT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, UINT, _fn, _args, _nargs, 0)
#define DELAY_LOAD_INT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, INT, _fn, _args, _nargs, 0)

#define DELAY_LOAD_VOID(_hinst, _dll, _fn, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    _GetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, #_fn); \
    if (_pfn##_fn)              \
    _pfn##_fn _nargs;       \
    return;                     \
}

//
// For private entrypoints exported by ordinal.
// 

#define DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
    _GetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord);   \
    if (_pfn##_fn)               \
    return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}
    
#define DELAY_LOAD_ORD(_hinst, _dll, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, 0)
#define DELAY_LOAD_ORD_HRESULT(_hinst, _dll, _fn, _ord, _args, _nargs) DELAY_LOAD_ORD(_hinst, _dll, HRESULT, _fn, _ord, _args, _nargs)


#define DELAY_LOAD_ORD_VOID(_hinst, _dll, _fn, _ord, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    _GetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord);   \
    if (_pfn##_fn)              \
    _pfn##_fn _nargs;       \
    return;                     \
}


//
//  Private exports by ordinal for integrated-shell installs
//


#define DELAY_LOAD_SHELL_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
    _SHGetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord);   \
    if (_pfn##_fn)               \
    return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}
    
#define DELAY_LOAD_SHELL(_hinst, _dll, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_SHELL_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, 0)
#define DELAY_LOAD_SHELL_HRESULT(_hinst, _dll, _fn, _ord, _args, _nargs) DELAY_LOAD_SHELL_ERR(_hinst, _dll, HRESULT, _fn, _ord, _args, _nargs, E_FAIL)


#define DELAY_LOAD_SHELL_VOID(_hinst, _dll, _fn, _ord, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    _SHGetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord); \
    if (_pfn##_fn)              \
    _pfn##_fn _nargs;       \
    return;                     \
}



/**********************************************************************/
/**********************************************************************/


// --------- MLANG.DLL ---------------

HINSTANCE g_hinstMLANG = NULL;

DELAY_LOAD_HRESULT(g_hinstMLANG, MLANG.DLL, ConvertINetMultiByteToUnicode,
            (LPDWORD lpdwMode, DWORD dwEncoding, LPCSTR lpSrcStr, LPINT lpnMultiCharCount, LPWSTR lpDstStr, LPINT lpnWideCharCount),
            (lpdwMode, dwEncoding, lpSrcStr, lpnMultiCharCount, lpDstStr, lpnWideCharCount));

DELAY_LOAD_HRESULT(g_hinstMLANG, MLANG.DLL, ConvertINetUnicodeToMultiByte,
            (LPDWORD lpdwMode, DWORD dwEncoding, LPCWSTR lpSrcStr, LPINT lpnWideCharCount, LPSTR lpDstStr, LPINT lpnMultiCharCount),
            (lpdwMode, dwEncoding, lpSrcStr, lpnWideCharCount, lpDstStr, lpnMultiCharCount));

DELAY_LOAD_HRESULT(g_hinstMLANG, MLANG.DLL, LcidToRfc1766W,
            (LCID Locale, LPWSTR pszRfc1766, int nChar),
            (Locale, pszRfc1766, nChar));


// --------- MSHTML.DLL ---------------

HINSTANCE g_hinstMSHTML = NULL;

DELAY_LOAD_HRESULT(g_hinstMSHTML, MSHTML.DLL, ShowHTMLDialog,
            (HWND hwnd, IMoniker * pmk, VARIANT * pvarArgIn, LPWSTR pchOptions, VARIANT * pvarArgOut),
            (hwnd, pmk, pvarArgIn, pchOptions, pvarArgOut));


// --------- SHELL32.DLL ---------------

HINSTANCE g_hinstSHELL32 = NULL;

DELAY_LOAD_ORD_HRESULT(g_hinstSHELL32, SHELL32.DLL, _SHCreateShellFolderView, SHCreateShellFolderViewORD,
                 (const SFV_CREATE* pcsfv, LPSHELLVIEW FAR* ppsv),
                 (pcsfv, ppsv));

DELAY_MAP_HRESULT(g_hinstSHELL32, SHELL32.DLL, _SHPathPrepareForWriteW, SHPathPrepareForWriteW,
                 (HWND hwnd, IUnknown *punkEnableModless, LPCWSTR pwzPath, DWORD dwFlags),
                 (hwnd, punkEnableModless, pwzPath, dwFlags));


#pragma warning(default:4229)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\dllreg.cpp ===
// dllreg.cpp -- autmatic registration and unregistration
//
#include "priv.h"
#include "installwv.h"

#include <advpub.h>
#include <comcat.h>
#include <xbnmspc.h>


// helper macros

// ADVPACK will return E_UNEXPECTED if you try to uninstall (which does a registry restore)
// on an INF section that was never installed.  We uninstall sections that may never have
// been installed, so this MACRO will quiet these errors.
#define QuietInstallNoOp(hr)   ((E_UNEXPECTED == hr) ? S_OK : hr)


const CHAR  c_szIexploreKey[]         = "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE";

/*----------------------------------------------------------
Purpose: Queries the registry for the location of the path
         of Internet Explorer and returns it in pszBuf.

Returns: TRUE on success
         FALSE if path cannot be determined

Cond:    --
*/
BOOL
GetIEPath(
    OUT LPSTR pszBuf,
    IN  DWORD cchBuf)
{
    BOOL bRet = FALSE;
    HKEY hkey;

    *pszBuf = '\0';

    // Get the path of Internet Explorer 
    if (NO_ERROR != RegOpenKeyA(HKEY_LOCAL_MACHINE, c_szIexploreKey, &hkey))  
    {
    }
    else
    {
        DWORD cbBrowser;
        DWORD dwType;

        lstrcatA(pszBuf, "\"");

        cbBrowser = CbFromCchA(cchBuf - lstrlenA(" -nohome") - 4);
        if (NO_ERROR != RegQueryValueExA(hkey, "", NULL, &dwType, 
                                         (LPBYTE)&pszBuf[1], &cbBrowser))
        {
        }
        else
        {
            bRet = TRUE;
        }

        lstrcatA(pszBuf, "\"");

        RegCloseKey(hkey);
    }

    return bRet;
}


BOOL UnregisterTypeLibrary(const CLSID* piidLibrary)
{
    TCHAR szScratch[GUIDSTR_MAX];
    HKEY hk;
    BOOL fResult = FALSE;

    // convert the libid into a string.
    //
    SHStringFromGUID(*piidLibrary, szScratch, ARRAYSIZE(szScratch));

    if (RegOpenKey(HKEY_CLASSES_ROOT, TEXT("TypeLib"), &hk) == ERROR_SUCCESS) {
        fResult = RegDeleteKey(hk, szScratch);
        RegCloseKey(hk);
    }
    
    return fResult;
}



HRESULT XboxRegTypeLib(void)
{
    HRESULT hr = S_OK;
    ITypeLib *pTypeLib;
    DWORD   dwPathLen;
    TCHAR   szTmp[MAX_PATH];
#ifdef UNICODE
    WCHAR   *pwsz = szTmp; 
#else
    WCHAR   pwsz[MAX_PATH];
#endif

    // Load and register our type library.
    //
    dwPathLen = GetModuleFileName(HINST_THISDLL, szTmp, ARRAYSIZE(szTmp));
#ifndef UNICODE
    if (SHAnsiToUnicode(szTmp, pwsz, MAX_PATH)) 
#endif
    {
        hr = LoadTypeLib(pwsz, &pTypeLib);

        if (SUCCEEDED(hr))
        {
            // call the unregister type library as we had some old junk that
            // was registered by a previous version of OleAut32, which is now causing
            // the current version to not work on NT...
            UnregisterTypeLibrary(&LIBID_XBNMSPCLib);
            hr = RegisterTypeLib(pTypeLib, pwsz, NULL);

            if (FAILED(hr))
            {
                TraceMsg(TF_WARNING, "XBNMSPC: RegisterTypeLib failed (%x)", hr);
            }
            pTypeLib->Release();
        }
        else
        {
            TraceMsg(TF_WARNING, "XBNMSPC: LoadTypeLib failed (%x)", hr);
        }
    } 
#ifndef UNICODE
    else {
        hr = E_FAIL;
    }
#endif

    return hr;
}


/*----------------------------------------------------------
Purpose: Calls the ADVPACK entry-point which executes an inf
         file section.

Returns: 
Cond:    --
*/
HRESULT CallRegInstall(HINSTANCE hinstXBOX, LPSTR szSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");

        if (pfnri)
        {
            char szThisDLL[MAX_PATH];

            // Get the location of this DLL from the HINSTANCE
            if ( !EVAL(GetModuleFileNameA(hinstXBOX, szThisDLL, ARRAYSIZE(szThisDLL))) )
            {
                // Failed, just say "xbnmspc.dll"
                lstrcpyA(szThisDLL, "xbnmspc.dll");
            }

            STRENTRY seReg[] = {
                { "THISDLL", szThisDLL },

                // These two NT-specific entries must be at the end
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg) - 2, seReg };

            hr = pfnri(g_hinst, szSection, &stReg);
        }

        FreeLibrary(hinstAdvPack);
    }

    return hr;
}


STDAPI DllRegisterServer(void)
{
    HRESULT hrInternal;
    HRESULT hr;

    // Delete any old registration entries, then add the new ones.
    // Keep ADVPACK.DLL loaded across multiple calls to RegInstall.
    // (The inf engine doesn't guarantee DelReg/AddReg order, that's
    // why we explicitly unreg and reg here.)
    //
    HINSTANCE hinstXBOX = GetModuleHandle(TEXT("XBNMSPC.DLL"));
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));
    hr = CallRegInstall(hinstXBOX, "XboxNamespaceShellExtensionInstall");
    ASSERT(SUCCEEDED(hr));

    hrInternal = CallRegInstall(hinstXBOX, "XboxForceAssociations");
    if (SUCCEEDED(hr))
        EVAL(SUCCEEDED(hr = hrInternal));   // Propogate the error and assert.

    hrInternal = InstallWebViewFiles(hinstXBOX);
    if (SUCCEEDED(hr))
        EVAL(SUCCEEDED(hr = hrInternal));   // Propogate the error and assert.

    XboxRegTypeLib();

    if (hinstAdvPack)
        FreeLibrary(hinstAdvPack);

    return hr;
}

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;
    HINSTANCE hinstXBOX = GetModuleHandle(TEXT("XBNMSPC.DLL"));

    // UnInstall the registry values
    hr = CallRegInstall(hinstXBOX, "XboxShellExtensionUninstall");
    UnregisterTypeLibrary(&LIBID_XBNMSPCLib);

    return hr;
}


/*----------------------------------------------------------
Purpose: Install/uninstall user settings

Description: Note that this function has special error handling.
             The function will keep hrExternal with the worse error
             but will only stop executing util the internal error (hr)
             gets really bad.  This is because we need the external
             error to catch incorrectly authored INFs but the internal
             error to be robust in attempting to install other INF sections
             even if one doesn't make it.
*/
STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    return S_OK;    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\dspsprt.h ===
#ifndef __DSPSPRT_H__
#define __DSPSPRT_H__

// get ITypeInfo uuid/lcid out of shdocvw's type library
HRESULT xbnmspcGetTypeInfo(LCID lcid, UUID uuid, ITypeInfo **ppITypeInfo);

//
// Helper C++ class used to share code for the IDispatch implementations
//
// Inherit from this class passing this IDispatch's IID to the ctor
// 
class CImpIDispatch
{
    public:

        // We need access to the virtual QI -- define it PURE here
        virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) PURE;

    protected:
        CImpIDispatch(const IID * piid);
        ~CImpIDispatch(void);

        // For raising exceptions
        void Exception(WORD);

        // IDispatch members
        STDMETHODIMP GetTypeInfoCount(UINT *);
        STDMETHODIMP GetTypeInfo(UINT, LCID, ITypeInfo **);
        STDMETHODIMP GetIDsOfNames(REFIID, OLECHAR **, UINT, LCID, DISPID *);
        STDMETHODIMP Invoke(DISPID, REFIID, LCID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *);

    private:
        const IID *m_piid;
        IDispatch *m_pdisp;

        ITypeInfo *m_pITINeutral; // Cached Type information
};

#endif // __DSPSPRT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\dspsprt.cpp ===
#include "priv.h"
#include "dspsprt.h"
#include "xbnmspc.h"

#define TF_IDISPATCH 0


/*
 * CImpIDispatch::CImpIDispatch
 * CImpIDispatch::~CImpIDispatch
 *
 * Parameters (Constructor):
 *  piid    guid this IDispatch implementation is for
 *          we call QueryInterface to get the interface
 */

CImpIDispatch::CImpIDispatch(const IID * piid)
{
//    TraceMsg(TF_ALWAYS, "ctor CImpIDispatch %x", this);

    m_piid = piid;

    ASSERT(NULL==m_pITINeutral);
    ASSERT(NULL==m_pdisp);

    return;
}

CImpIDispatch::~CImpIDispatch(void)
{
//    TraceMsg(TF_ALWAYS, "dtor CImpIDispatch %x", this);

    if (m_pITINeutral)
    {
        m_pITINeutral->Release();
        m_pITINeutral = NULL;
    }
    return;
}





/*
 * CImpIDispatch::GetTypeInfoCount
 *
 * Purpose:
 *  Returns the number of type information (ITypeInfo) interfaces
 *  that the object provides (0 or 1).
 *
 * Parameters:
 *  pctInfo         UINT * to the location to receive
 *                  the count of interfaces.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error code.
 */

STDMETHODIMP CImpIDispatch::GetTypeInfoCount(UINT *pctInfo)
{
    //We implement GetTypeInfo so return 1
    *pctInfo=1;
    return NOERROR;
}


//
// helper function for pulling ITypeInfo out of our typelib
//
HRESULT XbnmspcGetTypeInfo(LCID lcid, UUID uuid, ITypeInfo **ppITypeInfo)
{
    HRESULT    hr;
    ITypeLib  *pITypeLib;

    // Just in case we can't find the type library anywhere
    *ppITypeInfo = NULL;

    /*
     * The type libraries are registered under 0 (neutral),
     * 7 (German), and 9 (English) with no specific sub-
     * language, which would make them 407 or 409 and such.
     * If you are sensitive to sub-languages, then use the
     * full LCID instead of just the LANGID as done here.
     */
    hr=LoadRegTypeLib(LIBID_XBNMSPCLib, 1, 0, PRIMARYLANGID(lcid), &pITypeLib);

    /*
     * If LoadRegTypeLib fails, try loading directly with
     * LoadTypeLib, which will register the library for us.
     * Note that there's no default case here because the
     * prior switch will have filtered lcid already.
     *
     * NOTE:  You should prepend your DIR registry key to the
     * .TLB name so you don't depend on it being it the PATH.
     * This sample will be updated later to reflect this.
     */
    if (FAILED(hr))
    {
        OLECHAR wszPath[MAX_PATH];
#ifdef UNICODE
        GetModuleFileName(HINST_THISDLL, wszPath, ARRAYSIZE(wszPath));
#else
        TCHAR szPath[MAX_PATH];
        GetModuleFileName(HINST_THISDLL, szPath, ARRAYSIZE(szPath));
        MultiByteToWideChar(CP_ACP, 0, szPath, -1, wszPath, ARRAYSIZE(wszPath));
#endif

        switch (PRIMARYLANGID(lcid))
        {
        case LANG_NEUTRAL:
        case LANG_ENGLISH:
            hr=LoadTypeLib(wszPath, &pITypeLib);
            break;
        }
    }

    if (SUCCEEDED(hr))
    {
        //Got the type lib, get type info for the interface we want
        hr=pITypeLib->GetTypeInfoOfGuid(uuid, ppITypeInfo);
        pITypeLib->Release();
    }

    return(hr);
}


/*
 * CImpIDispatch::GetTypeInfo
 *
 * Purpose:
 *  Retrieves type information for the automation interface.  This
 *  is used anywhere that the right ITypeInfo interface is needed
 *  for whatever LCID is applicable.  Specifically, this is used
 *  from within GetIDsOfNames and Invoke.
 *
 * Parameters:
 *  itInfo          UINT reserved.  Must be zero.
 *  lcid            LCID providing the locale for the type
 *                  information.  If the object does not support
 *                  localization, this is ignored.
 *  ppITypeInfo     ITypeInfo ** in which to store the ITypeInfo
 *                  interface for the object.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error code.
 */

STDMETHODIMP CImpIDispatch::GetTypeInfo(UINT itInfo, LCID lcid
    , ITypeInfo **ppITypeInfo)
{
    ITypeInfo **ppITI;

    *ppITypeInfo=NULL;

    if (0!=itInfo)
        return(TYPE_E_ELEMENTNOTFOUND);

#if 1
    // docs say we can ignore lcid if we support only one LCID
    // we don't have to return DISP_E_UNKNOWNLCID if we're *ignoring* it
    ppITI = &m_pITINeutral;
#else
    /*
     * Since we returned one from GetTypeInfoCount, this function
     * can be called for a specific locale.  We support English
     * and neutral (defaults to English) locales.  Anything
     * else is an error.
     *
     * After this switch statement, ppITI will point to the proper
     * member pITypeInfo. If *ppITI is NULL, we know we need to
     * load type information, retrieve the ITypeInfo we want, and
     * then store it in *ppITI.
     */
    switch (PRIMARYLANGID(lcid))
    {
    case LANG_NEUTRAL:
    case LANG_ENGLISH:
        ppITI=&m_pITINeutral;
        break;

    default:
        return(DISP_E_UNKNOWNLCID);
    }
#endif

    //Load a type lib if we don't have the information already.
    if (NULL==*ppITI)
    {
        HRESULT    hr;
        ITypeInfo *pITIDisp;

        hr = XbnmspcGetTypeInfo(lcid, *m_piid, &pITIDisp);

        if (SUCCEEDED(hr))
        {
            HRESULT hrT;
            HREFTYPE hrefType;

            // All our IDispatch implementations are DUAL. GetTypeInfoOfGuid
            // returns the ITypeInfo of the IDispatch-part only. We need to
            // find the ITypeInfo for the dual interface-part.
            //
            hrT = pITIDisp->GetRefTypeOfImplType(0xffffffff, &hrefType);
            if (SUCCEEDED(hrT))
            {
                hrT = pITIDisp->GetRefTypeInfo(hrefType, ppITI);
            }

            ASSERT(SUCCEEDED(hrT));
            if (FAILED(hrT))
            {
                // I suspect GetRefTypeOfImplType may fail if someone uses
                // CImpIDispatch on a non-dual interface. In this case the
                // ITypeInfo we got above is just fine to use.
                //
                *ppITI = pITIDisp;
            }
            else
            {
                pITIDisp->Release();
            }
        }

        if (FAILED(hr))
            return hr;
    }

    /*
     * Note:  the type library is still loaded since we have
     * an ITypeInfo from it.
     */

    (*ppITI)->AddRef();
    *ppITypeInfo=*ppITI;
    return NOERROR;
}


/*
 * CImpIDispatch::GetIDsOfNames
 *
 * Purpose:
 *  Converts text names into DISPIDs to pass to Invoke
 *
 * Parameters:
 *  riid            REFIID reserved.  Must be IID_NULL.
 *  rgszNames       OLECHAR ** pointing to the array of names to be
 *                  mapped.
 *  cNames          UINT number of names to be mapped.
 *  lcid            LCID of the locale.
 *  rgDispID        DISPID * caller allocated array containing IDs
 *                  corresponging to those names in rgszNames.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error code.
 */

STDMETHODIMP CImpIDispatch::GetIDsOfNames(REFIID riid
    , OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispID)
{
    HRESULT     hr;
    ITypeInfo  *pTI;

    if (IID_NULL!=riid)
        return(DISP_E_UNKNOWNINTERFACE);

    //Get the right ITypeInfo for lcid.
    hr=GetTypeInfo(0, lcid, &pTI);

    if (SUCCEEDED(hr))
    {
        hr=pTI->GetIDsOfNames(rgszNames, cNames, rgDispID);

        pTI->Release();
    }

#ifdef DEBUG
    char szParam[MAX_PATH] = "";
    if (cNames >= 1)
    {
        WideCharToMultiByte(CP_ACP, 0,
            *rgszNames, -1,
            szParam, ARRAYSIZE(szParam), NULL, NULL);
    }

    TraceMsg(TF_IDISPATCH, "CImpIDispatch::GetIDsOfNames(%s = %x) called hres(%x)",
            szParam, *rgDispID, hr);
#endif

    return hr;
}



/*
 * CImpIDispatch::Invoke
 *
 * Purpose:
 *  Calls a method in the dispatch interface or manipulates a
 *  property.
 *
 * Parameters:
 *  dispID          DISPID of the method or property of interest.
 *  riid            REFIID reserved, must be IID_NULL.
 *  lcid            LCID of the locale.
 *  wFlags          USHORT describing the context of the invocation.
 *  pDispParams     DISPPARAMS * to the array of arguments.
 *  pVarResult      VARIANT * in which to store the result.  Is
 *                  NULL if the caller is not interested.
 *  pExcepInfo      EXCEPINFO * to exception information.
 *  puArgErr        UINT * in which to store the index of an
 *                  invalid parameter if DISP_E_TYPEMISMATCH
 *                  is returned.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error code.
 */

STDMETHODIMP CImpIDispatch::Invoke(DISPID dispID, REFIID riid
    , LCID lcid, unsigned short wFlags, DISPPARAMS *pDispParams
    , VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
{
    ITypeInfo  *pTI;
    HRESULT hr;

    //riid is supposed to be IID_NULL always
    if (IID_NULL!=riid)
        return(DISP_E_UNKNOWNINTERFACE);

    // make sure we have an interface to hand off to Invoke
    if (NULL == m_pdisp)
    {
        hr=QueryInterface(*m_piid, (LPVOID*)&m_pdisp);
        
        if (!EVAL(SUCCEEDED(hr)))
            return hr;

        // don't hold a refcount on ourself
        m_pdisp->Release();
    }

    //Get the ITypeInfo for lcid
    hr=GetTypeInfo(0, lcid, &pTI);

    if (SUCCEEDED(hr))
    {
        //Clear exceptions
        SetErrorInfo(0L, NULL);

        //This is exactly what DispInvoke does--so skip the overhead.
        hr=pTI->Invoke(m_pdisp, dispID, wFlags
            , pDispParams, pVarResult, pExcepInfo, puArgErr);

        pTI->Release();
    }

    return hr;
}




/*
 * CImpIDispatch::Exception
 *
 * Purpose:
 *  Raises an exception for CImpIDispatch::Invoke from within
 *  ITypeInfo::Invoke using the CreateErrorInfo API and the
 *  ICreateErrorInfo interface.
 *
 *  Note that this method doesn't allow for deferred filling
 *  of an EXCEPINFO structure.
 *
 * Parameters:
 *  wException      WORD exception code.
 */

void CImpIDispatch::Exception(WORD wException)
{
#if 0 // nobody calls this
    ICreateErrorInfo   *pICreateErr;
    BOOL                fSuccess;
    LPTSTR              psz;
    LPOLESTR            pszHelp;
    UINT                idsSource;
    UINT                idsException;
    DWORD               dwHelpID;


    /*
     * Thread-safe exception handling means that we call
     * CreateErrorInfo which gives us an ICreateErrorInfo pointer
     * that we then use to set the error information (basically
     * to set the fields of an EXCEPINFO structure.  We then
     * call SetErrorInfo to attach this error to the current
     * thread.  ITypeInfo::Invoke will look for this when it
     * returns from whatever function was invokes by calling
     * GetErrorInfo.
     */

    //Not much we can do if this fails.
    if (FAILED(CreateErrorInfo(&pICreateErr)))
        return;

    psz=(LPTSTR)LocalAlloc(LPTR, 1024*sizeof(TCHAR));

    // psz is a buffer to do LoadString()s into -- if we didn't
    // get one then we won't get our error strings, so bail.
    if (NULL==psz)
    {
        pICreateErr->Release();
        return;
    }

    fSuccess=TRUE;

    // typically you'd do a switch here on all the exception ids wException
    // and fill in pszHelp, dwHelpID, idsSource, and idsException.
    // if you mapped the exception id to valid strings, the code
    // below will fill in the ICreateErr interface
    //
    switch (wException)
    {
    default:
        fSuccess = FALSE;
    }

    if (fSuccess)
    {
        HRESULT     hr;
        IErrorInfo *pIErr;

        /*
         * If you have a help file, call the functions
         * ICreateErrorInfo::SetHelpFile and
         * ICreateErrorInfo::SetHelpContext as well.  If you
         * set the help file to NULL the context is ignored.
         */
        pICreateErr->SetHelpFile(pszHelp);
        pICreateErr->SetHelpContext(dwHelpID);

#ifndef UNICODE
        OLECHAR     szTemp[256];

        LoadString(HINST_THISDLL, idsSource, psz, 256);
        MultiByteToWideChar(CP_ACP, 0, psz, -1, szTemp, 256);
        pICreateErr->SetSource(szTemp);

        LoadString(HINST_THISDLL, idsException, psz, 256);
        MultiByteToWideChar(CP_ACP, 0, psz, -1, szTemp, 256);
        pICreateErr->SetDescription(szTemp);
#else
        LoadString(HINST_THISDLL, idsSource, psz, 1024);
        pICreateErr->SetSource(psz);

        LoadString(HINST_THISDLL, idsException, psz, 1024);
        pICreateErr->SetDescription(psz);
#endif

        hr=pICreateErr->QueryInterface(IID_IErrorInfo
            , (LPVOID*)&pIErr);

        if (SUCCEEDED(hr))
        {
            SetErrorInfo(0L, pIErr);
            pIErr->Release();
        }
    }

    LocalFree(psz);

    //SetErrorInfo holds the object's IErrorInfo
    pICreateErr->Release();
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\dialogs.cpp ===
/*****************************************************************************\
    FILE: Dialogs.cpp

    DESCRIPTION:
        This file exists to display dialogs needed during XBOX operations.
\*****************************************************************************/

#include "priv.h"
#include <mshtmhst.h>
#include "dialogs.h"


#ifdef ADD_ABOUTBOX
/*****************************************************************************\
    FUNCTION: DisplayAboutBox

    DESCRIPTION:
        The about box is now an HTML dialog. It is sent a ~ (tilde) 
    delimited BSTR that has, in this order, version number, 
    person software is licensed to, company software is licensed to, and 
    whether 40, 56, or 128 bit ie is installed.
\*****************************************************************************/
HRESULT DisplayAboutBox(HWND hWnd)
{
    TCHAR szInfo[512];
    szInfo[0] = 0;

    SHAboutInfo(szInfo, ARRAYSIZE(szInfo));     // from shlwapi

    BSTR bstrVal = TCharSysAllocString(szInfo);
    if (bstrVal)
    {
        VARIANT var = {0};      // variant containing version and user info
        var.vt = VT_BSTR;
        var.bstrVal = bstrVal;

        IMoniker *pmk;
        if (SUCCEEDED(CreateURLMoniker(NULL, L"res://xbnmspc.dll/about.htm", &pmk)))
        {
            ShowHTMLDialog(hWnd, pmk, &var, NULL, NULL);
            pmk->Release();
        }

        SysFreeString(bstrVal);
    }

    return S_OK;
}
#endif // ADD_ABOUTBOX


// This function exists to see if the XBOX version of the Copy To Folder
// feature's target is valid.  The shell has "Copy To Folder" in the toolbar
// that accomplishes the copy by using Drag and Drop.  XBOX has it's own
// version of this feature in the context menu and file menu that doesn't
// use drag and drop.  This exists because the type of drag and drop
// that we need (CFSTR_FILECONTENTS) isn't correctly implemented on
// old shells and our implmentation is 3 times faster!!!  However,
// we only support file system targets so let's see if this is one
// of those.
BOOL IsValidXBOXCopyToFolderTarget(LPCITEMIDLIST pidl)
{
    BOOL fAllowed = FALSE;

    if (pidl)
    {
        TCHAR szPath[MAX_PATH];
    
        if (SHGetPathFromIDList((LPITEMIDLIST)pidl, szPath))
        {
            fAllowed = TRUE;
        }
    }

    return fAllowed;
}


int BrowseCallback(HWND hwnd, UINT msg, LPARAM lParam, LPARAM lpData)
{
    int nResult = 0;

    switch (msg)
    {
    case BFFM_INITIALIZED:
        if (lpData)   // Documentation says it will be NULL but other code does this.
        {
            // we passed ppidl as lpData so pass on just pidl
            // Notice I pass BFFM_SETSELECTIONA which would normally indicate ANSI.
            // I do this because Win95 requires it, but it doesn't matter because I'm
            // only passing a pidl
            SendMessage(hwnd, BFFM_SETSELECTIONA, FALSE, (LPARAM)((LPITEMIDLIST)lpData));
        }
        break;
// BUGBUG: NT #282886: Need to verify if the pass is supported. (A:\ with floppy inserted w/o cancel)

    case BFFM_SELCHANGED:
        // We need to make sure that the selected item is valid for us to
        // accept.  This is because the tree will contain items that don't
        // pass the filter (file sys only) because they have non-filtered
        // children.  We need to disable the OK button when this happens
        // to prevent getting
        SendMessage(hwnd, BFFM_ENABLEOK, 0, (LPARAM)IsValidXBOXCopyToFolderTarget((LPCITEMIDLIST) lParam));
        break;

    case BFFM_VALIDATEFAILEDA:
        AssertMsg(0, TEXT("How can we get this?  That's not the structure I sent them."));
        break;

    case BFFM_VALIDATEFAILEDW:
        // If we return zero, then we are saying it's OK.  We only want to do this with
        // file paths.
        nResult = !PathIsRoot((LPCWSTR) lParam);

        // Is this invalid?
        if (nResult)
        {
            TCHAR szErrorTitle[MAX_PATH];
            TCHAR szErrorMsg[MAX_PATH];

            // Yes, so we need to inform the user so they know why the dialog doesn't
            // close.
            EVAL(LoadString(HINST_THISDLL, IDS_HELP_XBNMSPCTITLE, szErrorTitle, ARRAYSIZE(szErrorTitle)));
            EVAL(LoadString(HINST_THISDLL, IDS_XBOXERR_BAD_DL_TARGET, szErrorMsg, ARRAYSIZE(szErrorMsg)));
            MessageBox(hwnd, szErrorMsg, szErrorTitle, (MB_OK | MB_ICONERROR));
        }

        break;
    }

    return nResult;
}


/*****************************************************************************\
    FUNCTION: BrowseForDir

    DESCRIPTION:
        Let the user browser for a directory on the local file system
    in order to chose a destination for the XBOX transfer.

    S_FALSE will be returned if the user cancelled the action.
\*****************************************************************************/
HRESULT BrowseForDir(HWND hwndParent, LPCTSTR pszTitle, LPCITEMIDLIST pidlDefaultSelect, LPITEMIDLIST * ppidlSelected)
{
    HRESULT hr = S_OK;

    if (ppidlSelected)
    {
        ASSERT(hwndParent);
        BROWSEINFO bi = {0};
        
        bi.hwndOwner = hwndParent;
        bi.lpszTitle = pszTitle;
        bi.lpfn = BrowseCallback;
        bi.lParam = (LPARAM) pidlDefaultSelect;
        bi.ulFlags = (BIF_RETURNONLYFSDIRS | BIF_RETURNFSANCESTORS | BIF_EDITBOX | BIF_USENEWUI | BIF_VALIDATE);

        *ppidlSelected = SHBrowseForFolder(&bi);
        if (!*ppidlSelected)
            hr = S_FALSE;
    }

    return hr;
}


/****************************************************\
    FUNCTION: ShowDialog

    DESCRIPTION:
\****************************************************/
HRESULT CDownloadDialog::ShowDialog(HWND hwndOwner, LPTSTR pszDir, DWORD cchSize, DWORD * pdwDownloadType)
{
    HRESULT hr = S_OK;

    if (DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(IDD_DOWNLOADDIALOG), hwndOwner, DownloadDialogProc, (LPARAM)this))
    {
        StrCpyN(pszDir, HANDLE_NULLSTR(m_pszDir), cchSize);
        *pdwDownloadType = m_dwDownloadType;
        hr = S_OK;
    }
    else
        hr = S_FALSE;

    return hr;
}


/****************************************************\
    FUNCTION: DownloadDialogProc

    DESCRIPTION:
\****************************************************/
INT_PTR CALLBACK CDownloadDialog::DownloadDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CDownloadDialog * ppd = (CDownloadDialog *)GetWindowLongPtr(hDlg, GWLP_USERDATA);

    if (WM_INITDIALOG == wMsg)
    {
        SetWindowLongPtr(hDlg, GWLP_USERDATA, lParam);
        ppd = (CDownloadDialog *)lParam;
    }

    if (ppd)
        return ppd->_DownloadDialogProc(hDlg, wMsg, wParam, lParam);

    return TRUE;
}


/****************************************************\
    FUNCTION: _DownloadDialogProc

    DESCRIPTION:
\****************************************************/
BOOL CDownloadDialog::_DownloadDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    switch (wMsg)
    {
    case WM_INITDIALOG:
        return _InitDialog(hDlg);

    case WM_COMMAND:
        return _OnCommand(hDlg, wParam, lParam);
    }

    return FALSE;
}


/****************************************************\
    FUNCTION: _OnCommand

    DESCRIPTION:
\****************************************************/
BOOL CDownloadDialog::_OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    UINT idc = GET_WM_COMMAND_ID(wParam, lParam);

    switch (idc)
    {
    case IDC_DOWNLOAD_BUTTON:
        if (SUCCEEDED(_DownloadButton(hDlg)))
            EndDialog(hDlg, TRUE);
        break;

    case IDCANCEL:
        EndDialog(hDlg, FALSE);
        break;

    case IDC_BROWSE_BUTTON:
        _BrowseButton(hDlg);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


/****************************************************\
    FUNCTION: _InitDialog

    DESCRIPTION:
\****************************************************/
BOOL CDownloadDialog::_InitDialog(HWND hDlg)
{
    HRESULT hr;
    TCHAR szDir[MAX_PATH] = TEXT("C:\\");    // If all else fails.
    DWORD cbSize = sizeof(szDir);

    // Set the Directory
    if ((ERROR_SUCCESS != SHGetValue(HKEY_CURRENT_USER, SZ_REGKEY_INTERNET_EXPLORER, SZ_REGVALUE_DOWNLOAD_DIR, NULL, szDir, &cbSize)) ||
        (!PathFileExists(szDir)))
    {
        LPITEMIDLIST pidlMyDocuments;
        // Create the default dir, which should be "My Documents"

        SHGetSpecialFolderLocation(hDlg, CSIDL_PERSONAL, &pidlMyDocuments);
        if (pidlMyDocuments)
        {
            SHGetPathFromIDList(pidlMyDocuments, szDir);
            ILFree(pidlMyDocuments);
        }
    }
    SetWindowText(GetDlgItem(hDlg, IDC_DOWNLOAD_DIR), szDir);

    // Set the Download Type
    cbSize = sizeof(m_dwDownloadType);
    m_dwDownloadType = FTP_TRANSFER_TYPE_UNKNOWN; // Default.
    SHGetValue(HKEY_CURRENT_USER, SZ_REGKEY_XBOXFOLDER, SZ_REGVALUE_DOWNLOAD_TYPE, NULL, &m_dwDownloadType, &cbSize);

    for (UINT idDownloadType = IDS_DL_TYPE_AUTOMATIC; idDownloadType <= IDS_DL_TYPE_BINARY; idDownloadType++)
    {
        LoadString(HINST_THISDLL, idDownloadType, szDir, ARRAYSIZE(szDir));
        SendMessage(GetDlgItem(hDlg, IDC_DOWNLOAD_AS_LIST), CB_ADDSTRING, NULL, (LPARAM) szDir);
    }
    SendMessage(GetDlgItem(hDlg, IDC_DOWNLOAD_AS_LIST), CB_SETCURSEL, (WPARAM) m_dwDownloadType, 0);
    hr = AutoCompleteFileSysInEditbox(GetDlgItem(hDlg, IDC_DOWNLOAD_DIR));
    ASSERT(SUCCEEDED(hr));

    return FALSE;
}


/****************************************************\
    FUNCTION: _DownloadButton

    DESCRIPTION:
\****************************************************/
HRESULT CDownloadDialog::_DownloadButton(HWND hDlg)
{
    HRESULT hr = S_OK;
    TCHAR szDirOriginal[MAX_PATH];    // If all else fails.
    TCHAR szDir[MAX_PATH];    // If all else fails.

    // Get the Directory
    GetWindowText(GetDlgItem(hDlg, IDC_DOWNLOAD_DIR), szDirOriginal, ARRAYSIZE(szDirOriginal));
    EVAL(ExpandEnvironmentStrings(szDirOriginal, szDir, ARRAYSIZE(szDir)));
    Str_SetPtr(&m_pszDir, szDir);
    SHSetValue(HKEY_CURRENT_USER, SZ_REGKEY_INTERNET_EXPLORER, SZ_REGVALUE_DOWNLOAD_DIR, REG_SZ, szDir, ARRAYSIZE(szDir));

    // Get the Download Type
    m_dwDownloadType = (DWORD)SendMessage(GetDlgItem(hDlg, IDC_DOWNLOAD_AS_LIST), CB_GETCURSEL, 0, 0);
    SHSetValue(HKEY_CURRENT_USER, SZ_REGKEY_XBOXFOLDER, SZ_REGVALUE_DOWNLOAD_TYPE, REG_DWORD, &m_dwDownloadType, sizeof(m_dwDownloadType));

    // Make sure this path is usable
    ASSERT(hDlg);

    if (S_OK == SHPathPrepareForWriteWrapW(hDlg, NULL, szDir, FO_COPY, SHPPFW_DEFAULT))
    {
        if (!PathIsRoot(szDir) && !PathFileExists(szDir))
        {
            TCHAR szErrorTitle[MAX_PATH];
            TCHAR szErrorMsg[MAX_PATH];
            TCHAR szErrorTemplate[MAX_PATH];

            hr = E_FAIL;    // Until we get a valid directory, we can't do the download.
            EVAL(LoadString(HINST_THISDLL, IDS_HELP_XBNMSPCTITLE, szErrorTitle, ARRAYSIZE(szErrorTitle)));
            EVAL(LoadString(HINST_THISDLL, IDS_XBOXERR_CREATEDIRPROMPT, szErrorTemplate, ARRAYSIZE(szErrorTemplate)));
            wnsprintf(szErrorMsg, ARRAYSIZE(szErrorMsg), szErrorTemplate, szDir);

            if (IDYES == MessageBox(hDlg, szErrorMsg, szErrorTitle, (MB_YESNO | MB_ICONQUESTION)))
            {
                if (CreateDirectory(szDir, NULL))
                    hr = S_OK;
                else
                {
                    EVAL(LoadString(HINST_THISDLL, IDS_XBOXERR_CREATEFAILED, szErrorMsg, ARRAYSIZE(szErrorMsg)));
                    MessageBox(hDlg, szErrorMsg, szErrorTitle, (MB_OK | MB_ICONERROR));
                }
            }
        }
    }

    return hr;
}


/****************************************************\
    FUNCTION: _BrowseButton

    DESCRIPTION:
\****************************************************/
void CDownloadDialog::_BrowseButton(HWND hDlg)
{
    TCHAR szDefaultDir[MAX_PATH];
    TCHAR szTitle[MAX_PATH];

    GetWindowText(GetDlgItem(hDlg, IDC_DOWNLOAD_DIR), szDefaultDir, ARRAYSIZE(szDefaultDir));

    EVAL(LoadString(HINST_THISDLL, IDS_DLG_DOWNLOAD_TITLE, szTitle, ARRAYSIZE(szTitle)));
    if (S_OK == BrowseForDir(hDlg, szTitle, NULL, NULL))
        SetWindowText(GetDlgItem(hDlg, IDC_DOWNLOAD_DIR), szDefaultDir);
}


/****************************************************\
    Constructor
\****************************************************/
CDownloadDialog::CDownloadDialog()
{
    // NOTE: This can go on the stack so it may not be zero inited.
    m_pszDir = NULL;
    m_hwnd = NULL;
}


/****************************************************\
    Destructor
\****************************************************/
CDownloadDialog::~CDownloadDialog()
{
    Str_SetPtr(&m_pszDir, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\installwv.cpp ===
// installwv.cpp : Installs a file from a resource

#include "priv.h"
#include "installwv.h"
#include "regstr.h"
#ifndef _WIN64
//#include <iert.h>
#endif

#define WINVER_KEY     "SOFTWARE\\Microsoft\\Windows\\CurrentVersion"
#define PROGFILES_KEY  "ProgramFilesDir"

#define IfFalseRet(val, hr) {if ((val) == 0) return (hr);}

HRESULT WriteResource(HANDLE hDestFile, HINSTANCE hResourceInst, HRSRC hRsrc)
{
    HGLOBAL hGlob;
    LPVOID  pTemp;
    ULONG   cbWritten;
    ULONG   cbResource;
    HRESULT hr = E_FAIL;

    // Load the resource
	hGlob = LoadResource(hResourceInst, hRsrc);
	if (EVAL(pTemp = LockResource(hGlob)))
    {
        // Write out the resource
        cbResource = SizeofResource(hResourceInst, hRsrc);
        if (EVAL(WriteFile(hDestFile, pTemp, cbResource, &cbWritten, NULL)))
            hr = S_OK;
    }

    return hr;
}

HRESULT GetInstallInfoFromResource(HINSTANCE hResourceInst, UINT uID, INSTALL_INFO *piiFile)
{
    TCHAR szEntry[MAX_PATH];
    HRESULT hr = E_FAIL;

    if (piiFile == NULL) 
        return E_INVALIDARG;

    // Get the string table entry
    piiFile->dwDestAttrib = FILE_ATTRIBUTE_HIDDEN;
    piiFile->szSource = NULL;
    piiFile->szDest = NULL;

    if (EVAL(LoadString(hResourceInst, uID, szEntry, ARRAYSIZE(szEntry))))    
    {
        // Are we at the end of the list (empty string)
        if (szEntry[0])
        {
            // No.
            piiFile->szSource = StrDup(szEntry);
            piiFile->szDest = StrDup(TEXT("Xbox.htt"));
            hr = S_OK;
        }
        else
            hr = E_FAIL;
    }

    return hr;
}

HRESULT InstallInfoFreeMembers(INSTALL_INFO *piiFile)
{
    if (piiFile) {
        if (piiFile->szSource) {
            LocalFree(piiFile->szSource);
            piiFile->szSource = NULL;
        }

        if (piiFile->szDest) {
            LocalFree(piiFile->szDest);
            piiFile->szDest = NULL;
        }
    }

    return S_OK;
}


HRESULT InstallFilesFromResourceID(HINSTANCE hResourceInst, 
                                   UINT uID,                                
                                   LPTSTR pszDestDir)
{
    HRESULT hr = S_OK;
    INSTALL_INFO iiFile;

    if (!EVAL(pszDestDir))
        return E_INVALIDARG;

    if (S_OK == GetInstallInfoFromResource(hResourceInst, uID, &iiFile))
    {
        hr = InstallFileFromResource(hResourceInst, &iiFile, pszDestDir);
        InstallInfoFreeMembers(&iiFile);

        uID += 1;
    }

    return hr;
}

HRESULT InstallFileFromResource(HINSTANCE hResourceInst, 
                                INSTALL_INFO *piiFile, 
                                LPTSTR pszDestDir)
{
    HRESULT hr = E_FAIL;
    HRSRC   hRsrc;
    LPTSTR  lpszExt;

    // Find the resource
    if (EVAL(hRsrc = FindResource(hResourceInst, piiFile->szSource, RT_HTML)))
    {
        // Create destination file
        if (PathIsDirectory(pszDestDir))
        {
            TCHAR   szDestPath[MAX_PATH];

            StrNCpy(szDestPath, pszDestDir, MAX_PATH);
            if (PathAppend(szDestPath, piiFile->szDest))
            {
                HANDLE  hDestFile;

                SetFileAttributes(szDestPath, FILE_ATTRIBUTE_NORMAL); // Make sure we can overwrite
                hDestFile = CreateFile(szDestPath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, piiFile->dwDestAttrib, NULL); 
                if (hDestFile != INVALID_HANDLE_VALUE) 
                {
                    // Write out the resource
                    hr = WriteResource(hDestFile, hResourceInst, hRsrc);
                    CloseHandle(hDestFile);

                    // Make sure the file attributes are set correctly.  Overwritting a file doesn't
                    // always update the attributes
                    SetFileAttributes(szDestPath, piiFile->dwDestAttrib);

                    if ((lpszExt = PathFindExtension(szDestPath)) && (StrCmpI(lpszExt, TEXT(".htt")) == 0))
                    {
                        hr = SHRegisterValidateTemplate(szDestPath, SHRVT_REGISTER);
                    }
                }
            }
        }
    }

    return hr;
}

HRESULT InstallWebViewFiles(HINSTANCE hInstResource)
{
    HRESULT hr = E_FAIL;
    TCHAR   szDestPath[MAX_PATH];

    // Set up %windir% path
    if (EVAL(SHGetSystemWindowsDirectory(szDestPath, ARRAYSIZE(szDestPath)) &&
             PathIsDirectory(szDestPath)))
    {
        // Install %windir%\web files
        if (EVAL(PathAppend(szDestPath, TEXT("Web"))))
        {
            if (PathIsDirectory(szDestPath) || CreateDirectory(szDestPath, NULL))
            {
                UINT idWebViewTemp = IDS_INSTALL_TEMPLATE;

                if (SHELL_VERSION_NT5 <= GetShellVersion())
                    idWebViewTemp = IDS_INSTALL_TEMPLATE_NT5;

                EVAL(SUCCEEDED(hr = InstallFilesFromResourceID(hInstResource, idWebViewTemp, szDestPath))); 
                EVAL(SetFileAttributes(szDestPath, FILE_ATTRIBUTE_SYSTEM));
            }
        }
    }
        
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\installwv.h ===
// installwv.h : Installs files from a resource
 
#ifndef __INSTALL_H_
#define __INSTALL_H_

typedef struct tagINSTALL_INFO {
    LPTSTR szSource;
    LPTSTR szDest;
    DWORD dwDestAttrib;
} INSTALL_INFO;

HRESULT InstallFileFromResource(HINSTANCE      hInstResource, 
                                INSTALL_INFO   *piiFile,
                                LPTSTR         pszDestDir);

HRESULT InstallWebViewFiles(HINSTANCE hInstResource);

#endif // __INSTALL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\encoding.cpp ===
/*****************************************************************************\
    FILE: encoding.cpp
    
    DESCRIPTION:
        Handle taking internet strings by detecting if they are UTF-8 encoded
    or DBCS and finding out what code page was used.
\*****************************************************************************/

#include "priv.h"
#include "util.h"
#include "xboxurl.h"
#include "statusbr.h"
#include <shdocvw.h>


/*****************************************************************************\
    CLASS: CMultiLanguageCache
\*****************************************************************************/


HRESULT CMultiLanguageCache::_Init(void)
{
    if (m_pml2)
        return S_OK;

    return CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage2, (void **) &m_pml2);
}


/*****************************************************************************\
    CLASS: CWireEncoding
\*****************************************************************************/
CWireEncoding::CWireEncoding(void)
{
    // We can go on the stack, so we may not be zero inited.
    m_nConfidence = 0;
    m_uiCodePage = CP_ACP;     // 
    m_dwMode = 0;

    m_fUseUTF8 = FALSE;
}


CWireEncoding::~CWireEncoding(void)
{
}


void CWireEncoding::_ImproveAccuracy(CMultiLanguageCache * pmlc, LPCWIRESTR pwStr, BOOL fUpdateCP, UINT * puiCodePath)
{
    DetectEncodingInfo dei = {0};
    INT nStructs = 1;
    INT cchSize = lstrlenA(pwStr);
    IMultiLanguage2 * pml2 = pmlc->GetIMultiLanguage2();

    // Assume we will use the normal code page.
    *puiCodePath = m_uiCodePage;
    if (S_OK == pml2->DetectInputCodepage(MLDETECTCP_8BIT, CP_AUTO, (LPWIRESTR)pwStr, &cchSize, &dei, (INT *)&nStructs))
    {
        // Is it UTF8 or just plain ansi(CP_20127)?
        if (((CP_UTF_8 == dei.nCodePage) || (CP_20127 == dei.nCodePage)) &&
            (dei.nConfidence > 70))
        {
            // Yes, so make sure the caller uses UTF8 to decode but don't update
            // the codepage.
            *puiCodePath = CP_UTF_8;
        }
        else
        {
            if (fUpdateCP && (dei.nConfidence > m_nConfidence))
            {
                m_uiCodePage = dei.nCodePage;
                m_nConfidence = dei.nConfidence;
            }
        }
    }
}


HRESULT CWireEncoding::WireBytesToUnicode(CMultiLanguageCache * pmlc, LPCWIRESTR pwStr, DWORD dwFlags, LPWSTR pwzDest, DWORD cchSize)
{
    HRESULT hr;

    // Optimize for the fast common case.
    if (Is7BitAnsi(pwStr))
    {
        pwzDest[0] = 0;
        SHAnsiToUnicodeCP(CP_UTF_8, pwStr, pwzDest, cchSize);
        hr = S_OK;
    }
    else
    {
#ifdef FEATURE_CP_AUTODETECT
        if (this)
        {
            CMultiLanguageCache mlcTemp;
            UINT cchSizeTemp = cchSize;
            UINT uiCodePageToUse;

            if (!pmlc)
                pmlc = &mlcTemp;

            if (!pmlc || !pmlc->GetIMultiLanguage2())
                return E_FAIL;

            IMultiLanguage2 * pml2 = pmlc->GetIMultiLanguage2();
            _ImproveAccuracy(pmlc, pwStr, (WIREENC_IMPROVE_ACCURACY & dwFlags), &uiCodePageToUse);
            if (CP_ACP == uiCodePageToUse)
                uiCodePageToUse = GetACP();

            UINT cchSrcSize = lstrlenA(pwStr) + 1; // The need to do the terminator also.
            hr = pml2->ConvertStringToUnicode(&m_dwMode, uiCodePageToUse, (LPWIRESTR)pwStr, &cchSrcSize, pwzDest, &cchSizeTemp);
            if (!(EVAL(S_OK == hr)))
                SHAnsiToUnicode(pwStr, pwzDest, cchSize);

        }
        else
#endif // FEATURE_CP_AUTODETECT
        {
            UINT uiCodePage = ((WIREENC_USE_UTF8 & dwFlags) ? CP_UTF_8 : CP_ACP);

            SHAnsiToUnicodeCP(uiCodePage, pwStr, pwzDest, cchSize);
        }
    }

    return hr;
}


HRESULT CWireEncoding::UnicodeToWireBytes(CMultiLanguageCache * pmlc, LPCWSTR pwzStr, DWORD dwFlags, LPWIRESTR pwDest, DWORD cchSize)
{
    HRESULT hr = S_OK;

#ifdef FEATURE_CP_AUTODETECT
    CMultiLanguageCache mlcTemp;
    DWORD dwCodePage = CP_UTF_8;
    DWORD dwModeTemp = 0;
    DWORD * pdwMode = &dwModeTemp;
    UINT cchSizeTemp = cchSize;

    // In some cases, we don't know the site, so we use this.
    // BUGBUG: Come back and force this to be set.
    if (this)
    {
        dwCodePage = m_uiCodePage;
        pdwMode = &m_dwMode;
    }

    if (!pmlc)
        pmlc = &mlcTemp;

    if (!pmlc)
        return E_FAIL;

    IMultiLanguage2 * pml2 = pmlc->GetIMultiLanguage2();
//    if (WIREENC_USE_UTF8 & dwFlags)
//        dwCodePage = CP_UTF_8;

    UINT cchSrcSize = lstrlenW(pwzStr) + 1; // The need to do the terminator also.
    if (CP_ACP == dwCodePage)
        dwCodePage = GetACP();

    hr = pml2->ConvertStringFromUnicode(pdwMode, dwCodePage, (LPWSTR) pwzStr, &cchSrcSize, pwDest, &cchSizeTemp);
    if (!(EVAL(S_OK == hr)))
        SHUnicodeToAnsi(pwzStr, pwDest, cchSize);

#else // FEATURE_CP_AUTODETECT
    UINT nCodePage = ((WIREENC_USE_UTF8 & dwFlags) ? CP_UTF_8 : CP_ACP);

    SHUnicodeToAnsiCP(nCodePage, pwzStr, pwDest, cchSize);
#endif // FEATURE_CP_AUTODETECT

    return hr;
}



HRESULT CWireEncoding::ReSetCodePages(CMultiLanguageCache * pmlc, CXboxPidlList * pXboxPidlList)
{
    CMultiLanguageCache mlcTemp;
    
    if (!pmlc)
        pmlc = &mlcTemp;
    
    if (!pmlc)
        return E_FAIL;

    // BUGBUG/TODO:
    return S_OK;
}


HRESULT CWireEncoding::CreateXboxItemID(CMultiLanguageCache * pmlc, LPXBOX_FIND_DATA pwfd, LPITEMIDLIST * ppidl)
{
    CMultiLanguageCache mlcTemp;
    WCHAR wzDisplayName[MAX_PATH];
    
    if (!pmlc)
        pmlc = &mlcTemp;

    WireBytesToUnicode(pmlc, pwfd->cFileName, (m_fUseUTF8 ? WIREENC_USE_UTF8 : WIREENC_NONE), wzDisplayName, ARRAYSIZE(wzDisplayName));
    return XboxItemID_CreateReal(pwfd, wzDisplayName, ppidl);
}


HRESULT CWireEncoding::ChangeXboxItemIDName(CMultiLanguageCache * pmlc, LPCITEMIDLIST pidlBefore, LPCWSTR pwzNewName, BOOL fUTF8, LPITEMIDLIST * ppidlAfter)
{
    CMultiLanguageCache mlcTemp;
    WIRECHAR wWireName[MAX_PATH];
    HRESULT hr;

    if (!pmlc)
        pmlc = &mlcTemp;

    hr = UnicodeToWireBytes(pmlc, pwzNewName, (fUTF8 ? WIREENC_USE_UTF8 : WIREENC_NONE), wWireName, ARRAYSIZE(wWireName));
    if (EVAL(SUCCEEDED(hr)))
        hr = XboxItemID_CreateWithNewName(pidlBefore, pwzNewName, wWireName, ppidlAfter);

    return hr;
}




BOOL SHIsUTF8Encoded(LPCWIRESTR pszIsUTF8)
{
    unsigned int len = lstrlenA(pszIsUTF8);
    LPCWIRESTR endbuf = pszIsUTF8 + len;
    unsigned char byte2mask = 0x00;
    unsigned char c;
    int trailing = 0;               // trailing (continuation) bytes to follow
                             
     while (pszIsUTF8 != endbuf)
     {
         c = *pszIsUTF8++;
         if (trailing)
         {
             if ((c & 0xC0) == 0x80)    // Does trailing byte follow UTF-8 format?
             {
                 if (byte2mask)     // Need to check 2nd byte for proper range?
                 {
                     if (c & byte2mask)      // Are appropriate bits set?
                         byte2mask=0x00;
                     else
                         return 0;

                     trailing--;
                 }
             }
             else
                 return FALSE;
         }
         else
         {
             if ((c & 0x80) == 0x00)
                 continue;         // valid 1 byte UTF-8
             else
             {
                 if ((c & 0xE0) == 0xC0) // valid 2 byte UTF-8
                 {
                    if (c & 0x1E)      // Is UTF-8 byte in proper range?
                    {
                        trailing =1;
                    }
                    else
                        return FALSE;
                 }
                 else
                 {
                     if ((c & 0xF0) == 0xE0)               // valid 3 byte UTF-8
                     {
                         if (!(c & 0x0F))                          // Is UTF-8 byte in proper range?
                            byte2mask=0x20;                    // If not set mask to check next byte
                         trailing = 2;
                     }
                     else
                     {
                         if ((c & 0xF8) == 0xF0)               // valid 4 byte UTF-8
                         {
                             if (!(c & 0x07))                          // Is UTF-8 byte in proper range?
                                byte2mask=0x30;                    // If not set mask to check next byte
                             trailing = 3;
                         }
                         else
                         {
                             if ((c & 0xFC) == 0xF8)               // valid 5 byte UTF-8
                             {
                                 if (!(c & 0x03))                          // Is UTF-8 byte in proper range?
                                    byte2mask=0x38;                    // If not set mask to check next byte

                                 trailing = 4;
                             }
                             else
                             {
                                 if ((c & 0xFE) == 0xFC)               // valid 6 byte UTF-8
                                 {
                                     if (!(c & 0x01))                          // Is UTF-8 byte in proper range?
                                        byte2mask=0x3C;                    // If not set mask to check next byte

                                     trailing = 5;
                                 }
                                 else
                                     return FALSE;
                             }
                         }
                     }
                 }
             }
         }
     }

     return (trailing == 0);
 }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\isf.h ===
/*****************************************************************************\
    FILE: isf.h

    DESCRIPTION:
        This is a base class that implements the default behavior of IShellFolder.
\*****************************************************************************/

#ifndef _DEFAULT_ISHELLFOLDER_H
#define _DEFAULT_ISHELLFOLDER_H

#include "cowsite.h"


/*****************************************************************************\
    CLASS: CBaseFolder

    DESCRIPTION:
        The stuff that tracks the state of a folder.

    The cBusy field tracks how many sub-objects have been created
    (e.g., IEnumIDList) which still contain references to this
    folder's identity.  You cannot change the folder's identity
    (via IPersistFolder::Initialize) while there are outstanding
    subobjects.

    The number of cBusy's never exceeds the number of cRef's, because
    each subobject that requires the folder identity must retain a
    reference to the folder itself.  That way, the folder won't be
    Release()d while the identity is still needed.

    Name Space description (for m_pidlComplete & m_nIDOffsetToOurNameSpaceRoot):
    The name space is provided by the shell to describe resources for the user.
    This class is a base implementation so users can create their own name space
    that is rooted in the shell's name space.  A PIDL is a list of ItemID, each of
    which represent one level in the name space.  The list provides a path thru
    the name space to a specific item.  Example:
    [Desktop][My Computer][C:\][Dir1][Dir2][File.htm][#goto_description_secion]
    [Desktop][The Internet][xbox://server/][Dir1][Dir2][file.txt]
    [Desktop][My Computer][PrivateNS lvl1][lvl2][lvl3]...
    (Public Name Space)   (Private Name Space)
    [GNS Level1][GNS Levl2][Pri LVL1][P LVL2][P LVL3]...

    In the example immediately above, this CBaseFolder can create a name space
    under "My Computer" that has 3 levels (lvl1, lvl2, lvl3).  An instance of this
    COM object will be positioned at one level of the sub name space (lvl1, lvl2, or lvl3).

    m_pidlComplete - is the list of ItemIDs from the base [Desktop] to the current location
                maybe lvl2.
    m_nIDOffsetToOurNameSpaceRoot - is the number of bytes of m_pidlComplete that you need
                to skip to get to the first ItemID in the private name space (which
                is the name space owned by this class).
\*****************************************************************************/

class CBaseFolder       : public IShellFolder2
                        , public IPersistFolder3
                        , public CObjectWithSite
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    
    // *** IShellFolder ***
    virtual STDMETHODIMP ParseDisplayName(HWND hwndOwner, LPBC pbcReserved, LPOLESTR lpszDisplayName,
                                            ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes);
    virtual STDMETHODIMP EnumObjects(HWND hwndOwner, DWORD grfFlags, LPENUMIDLIST * ppenumIDList);
    virtual STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbcReserved, REFIID riid, LPVOID * ppvOut);
    virtual STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbcReserved, REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    virtual STDMETHODIMP CreateViewObject(HWND hwndOwner, REFIID riid, LPVOID * ppvOut);
    virtual STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl, ULONG * rgfInOut);
    virtual STDMETHODIMP GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl, REFIID riid, UINT * prgfInOut, LPVOID * ppvOut);
    virtual STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName);
    virtual STDMETHODIMP SetNameOf(HWND hwndOwner, LPCITEMIDLIST pidl, LPCOLESTR lpszName, DWORD uFlags, LPITEMIDLIST * ppidlOut);

    // *** IShellFolder2 ***
    virtual STDMETHODIMP GetDefaultSearchGUID(GUID *pguid) {return E_NOTIMPL;};
    virtual STDMETHODIMP EnumSearches(IEnumExtraSearch **ppenum) {return E_NOTIMPL;};
    virtual STDMETHODIMP GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay) {return E_NOTIMPL;};
    virtual STDMETHODIMP GetDefaultColumnState(UINT iColumn, DWORD *pcsFlags) {return E_NOTIMPL;};
    virtual STDMETHODIMP GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv) {return E_NOTIMPL;};
    virtual STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *psd) {return E_NOTIMPL;};
    virtual STDMETHODIMP MapColumnToSCID(UINT iCol, SHCOLUMNID *pscid) {return E_NOTIMPL;};

    // *** IPersist ***
    virtual STDMETHODIMP GetClassID(LPCLSID lpClassID);

    // *** IPersistFolder ***
    virtual STDMETHODIMP Initialize(LPCITEMIDLIST pidl);
    
    // *** IPersistFolder2 ***
    virtual STDMETHODIMP GetCurFolder(LPITEMIDLIST *ppidl);

    // *** IPersistFolder3 ***
    virtual STDMETHODIMP InitializeEx(IBindCtx *pbc, LPCITEMIDLIST pidlRoot, const PERSIST_FOLDER_TARGET_INFO *ppfti);
    virtual STDMETHODIMP GetFolderTargetInfo(PERSIST_FOLDER_TARGET_INFO *ppfti);

public:
    CBaseFolder(LPCLSID pClassID);
    virtual ~CBaseFolder(void);

    // Public Member Functions
    virtual HRESULT _GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl, REFIID riid, UINT * prgfInOut, LPVOID * ppvOut, BOOL fFromCreateViewObject);
    virtual HRESULT _Initialize(LPCITEMIDLIST pidlRoot, LPCITEMIDLIST pidlAliasRoot, int nBytesToPrivate);
    virtual HRESULT _CreateShellView(HWND hwndOwner, void ** ppvObj) = 0;       // PURE
    virtual HRESULT _CreateShellView(HWND hwndOwner, void ** ppvObj, LONG lEvents, FOLDERVIEWMODE fvm, IShellFolderViewCB * psfvCallBack, 
                            LPCITEMIDLIST pidl, LPFNVIEWCALLBACK pfnCallback);

    LPCITEMIDLIST GetPublicTargetPidlReference(void) { return m_pidl;};
    LPITEMIDLIST GetPublicTargetPidlClone(void) { return ILClone(GetPublicTargetPidlReference());};
    LPCITEMIDLIST GetPublicRootPidlReference(void) { return (m_pidlRoot ? m_pidlRoot : m_pidl);};
    LPITEMIDLIST GetPublicRootPidlClone(void) { return ILClone(GetPublicRootPidlReference());};
    LPCITEMIDLIST GetPrivatePidlReference(void);
    LPITEMIDLIST GetPrivatePidlClone(void) { return ILClone(GetPrivatePidlReference());};
    LPITEMIDLIST GetPublicPidlRootIDClone(void);
    LPITEMIDLIST CreateFullPublicPidlFromRelative(LPCITEMIDLIST pidlPrivateSubPidl);
    LPITEMIDLIST CreateFullPrivatePidl(LPCITEMIDLIST pidlPrivateSubPidl);
    LPITEMIDLIST CreateFullPublicPidl(LPCITEMIDLIST pidlPrivatePidl);

    LPCITEMIDLIST GetFolderPidl(void) { return m_pidlRoot;};

protected:
    int                     m_cRef;

    int GetPidlByteOffset(void) { return m_nIDOffsetToPrivate;};

private:
    LPITEMIDLIST            m_pidl;                 // Public Pidl - Complete list of IDs from very base of NameSpace to this name space and into this name space to the point of being rooted.
    LPITEMIDLIST            m_pidlRoot;             // Pidl of Folder Shortcut.
    int                     m_nIDOffsetToPrivate;   // number of bytes from the start of m_pidlComplete to the first ItemID in our name space.
    LPCLSID                 m_pClassID;             // My CLSID
};

#endif // _DEFAULT_ISHELLFOLDER_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\isf.cpp ===
zz/*****************************************************************************\
    FILE:   isf.cpp

    DESCRIPTION:
        This is a base class that implements the default behavior of IShellFolder.
\*****************************************************************************/

#include "priv.h"
#include "isf.h"
#include <shlobj.h>



/*****************************************************************************\
    FUNCTION: IShellFolder::ParseDisplayName

    DESCRIPTION:
\*****************************************************************************/
HRESULT CBaseFolder::ParseDisplayName(HWND hwnd, LPBC pbcReserved, LPOLESTR pwszDisplayName,
                        ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes)
{
    if (pdwAttributes)
        *pdwAttributes = 0;

    if (ppidl)
        *ppidl = NULL;

    return E_NOTIMPL;
}

/*****************************************************************************\
    FUNCTION: IShellFolder::EnumObjects

    DESCRIPTION:
\*****************************************************************************/
HRESULT CBaseFolder::EnumObjects(HWND hwndOwner, DWORD grfFlags, IEnumIDList ** ppenumIDList)
{
    if (ppenumIDList)
        *ppenumIDList = NULL;

    return E_NOTIMPL;
}


/*****************************************************************************\
    FUNCTION: IShellFolder::BindToObject

    DESCRIPTION:
\*****************************************************************************/
HRESULT CBaseFolder::BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, LPVOID * ppvObj)
{
    if (ppvObj)
        *ppvObj = NULL;

    return E_NOTIMPL;
}


/*****************************************************************************\
     FUNCTION: IShellFolder::BindToStorage
 
    DESCRIPTION:
         This should be implemented so people can use the File.Open and File.SaveAs
    dialogs with this ShellFolder.
\*****************************************************************************/
HRESULT CBaseFolder::BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, LPVOID * ppvObj)
{
    if (ppvObj)
        *ppvObj = NULL;

    return E_NOTIMPL;
}


/*****************************************************************************\
     FUNCTION: IShellFolder::CompareIDs
 
    DESCRIPTION:
         This should be implemented so people can use the File.Open and File.SaveAs
    dialogs with this ShellFolder.
\*****************************************************************************/
HRESULT CBaseFolder::CompareIDs(LPARAM ici, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    return E_NOTIMPL;
}


/*****************************************************************************\
     FUNCTION: IShellFolder::CreateViewObject
 
    DESCRIPTION:
         This should be implemented so people can use the File.Open and File.SaveAs
    dialogs with this ShellFolder.
\*****************************************************************************/
HRESULT CBaseFolder::CreateViewObject(HWND hwndOwner, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hr = E_NOINTERFACE;

    *ppvObj = NULL;
    if (IsEqualIID(riid, IID_IShellView))
        hr = _CreateShellView(hwndOwner, ppvObj);
    else if (IsEqualIID(riid, IID_IContextMenu))
        hr = _GetUIObjectOf(hwndOwner, 0, NULL, riid, 0, ppvObj, TRUE);
    else
        hr = E_NOINTERFACE;

    return hr;
}


BOOL IsShellIntegration(void)
{
    BOOL fResult = FALSE;
    HINSTANCE hInst = LoadLibrary(TEXT("shell32.dll"));

    if (EVAL(hInst))
    {
        LPVOID pv = GetProcAddress(hInst, "DllGetVersion");
        if (pv)
            fResult = TRUE;
        FreeLibrary(hInst);
    }
    
    return fResult;
}

HRESULT CBaseFolder::_CreateShellView(HWND hwndOwner, void ** ppvObj, LONG lEvents, FOLDERVIEWMODE fvm, 
                                       IShellFolderViewCB * psfvCallBack, LPCITEMIDLIST pidl, LPFNVIEWCALLBACK pfnCallback)
{
    HRESULT hr;
    IShellFolder * psf;

    hr = this->QueryInterface(IID_IShellFolder, (LPVOID *) &psf);
    if (EVAL(SUCCEEDED(hr)))
    {
        SFV_CREATE sfvCreate =      // SHCreateShellFolderView struct
        {
                sizeof(SFV_CREATE),
                psf,            // psf
                NULL,           // psvOuter
                psfvCallBack    // psfvcb - (IShellFolderViewCB *)
        };

        // SHCreateShellFolderView isn't in the original shell.  We can't rely on the 
        // the Delayload code because it's exported by ordinal and the original
        // shell had a different exports by the same number.
        if (IsShellIntegration())
            hr = _SHCreateShellFolderView(&sfvCreate, (LPSHELLVIEW FAR*)ppvObj);
        else
            hr = E_FAIL;  // Force us to go into the next try.

        // If we aren't running on a machine with Shell Integration, SHCreateShellFolderView will fail.
        if (FAILED(hr))
        {
            CSFV csfv;

            csfv.cbSize = sizeof(csfv);
            csfv.pshf = psf;
            csfv.psvOuter = (IShellView *) psfvCallBack;      // Hack but it works...
            csfv.pidl = pidl;           // This is feed to SFVM_GETNOTIFY so it needs to be a pidlTarget.
            csfv.lEvents = lEvents;
            csfv.pfnCallback = pfnCallback;
            csfv.fvm = fvm;         // vs. FVM_ICON, ...

            hr = SHCreateShellFolderViewEx(&csfv, (LPSHELLVIEW FAR*)ppvObj);
            if (SUCCEEDED(hr))
                psfvCallBack->AddRef();     // We gave them a ref.
        }

        psf->Release();
    }

    return hr;
}


/*****************************************************************************\
     FUNCTION: IShellFolder::GetAttributesOf
 
    DESCRIPTION:
\*****************************************************************************/
HRESULT CBaseFolder::GetAttributesOf(UINT cpidl, LPCITEMIDLIST *apidl, ULONG *rgfInOut)
{
    return E_NOTIMPL;
}


/*****************************************************************************\
     FUNCTION: IShellFolder::GetUIObjectOf
 
    DESCRIPTION:
\*****************************************************************************/
HRESULT CBaseFolder::GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST rgpidl[],
                                REFIID riid, UINT * prgfInOut, LPVOID * ppvObj)
{
    return E_NOTIMPL;
}


/*****************************************************************************\
    DESCRIPTION:
\*****************************************************************************/
HRESULT CBaseFolder::_GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST rgpidl[],
                                REFIID riid, UINT * prgfInOut, LPVOID * ppvOut, BOOL fFromCreateViewObject)
{
    return GetUIObjectOf(hwndOwner, cidl, rgpidl, riid, prgfInOut, ppvOut);
}


/*****************************************************************************\
     FUNCTION: IShellFolder::GetDisplayNameOf
 
    DESCRIPTION:
\*****************************************************************************/
HRESULT CBaseFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD shgno, LPSTRRET pStrRet)
{
    return E_NOTIMPL;
}


/*****************************************************************************\
     FUNCTION: IShellFolder::SetNameOf
 
    DESCRIPTION:
\*****************************************************************************/
HRESULT CBaseFolder::SetNameOf(HWND hwndOwner, LPCITEMIDLIST pidl, LPCOLESTR pwszName,
                                DWORD dwReserved, LPITEMIDLIST *ppidlOut)
{
    return E_NOTIMPL;
}


//===========================
// *** IShellFolder2 Interface ***
//===========================

//===========================
// *** IPersist Interface ***
//===========================

/*****************************************************************************\
     FUNCTION: IPersist::GetClassID
 
    DESCRIPTION:
\*****************************************************************************/
HRESULT CBaseFolder::GetClassID(LPCLSID pClassID)
{
    HRESULT hr = E_INVALIDARG;

    if (EVAL(pClassID))
    {
        if (EVAL(m_pClassID))
        {
            *pClassID = *m_pClassID;
            hr = S_OK;
        }
        else
            hr = E_FAIL;
    }

    return hr;
}

//===========================
// *** IPersistFolder Interface ***
//===========================

/*****************************************************************************\
    DESCRIPTION:
\*****************************************************************************/
HRESULT CBaseFolder::Initialize(LPCITEMIDLIST pidl)
{
    ASSERT(!m_pidl);   // Don't reroot us.
    return _Initialize(pidl, NULL, ILGetSize(pidl) - sizeof(pidl->mkid.cb));
}

//===========================
// *** IPersistFolder2 Interface ***
//===========================

/*****************************************************************************\ 
    DESCRIPTION:
\*****************************************************************************/
HRESULT CBaseFolder::GetCurFolder(LPITEMIDLIST *ppidl)
{
    HRESULT hr = E_INVALIDARG;

    if (EVAL(ppidl))
    {
        hr = E_FAIL;

        if (m_pidlRoot)
        {
            *ppidl = ILClone(m_pidlRoot);
        }
        else if (EVAL(m_pidl))
        {
            *ppidl = GetPublicTargetPidlClone();
        }

        if (*ppidl)
            hr = S_OK;
    }

    return hr;
}

//===========================
// *** IPersistFolder3 Interface ***
//===========================
HRESULT GetPidlFromPersistFolderTargetInfo(const PERSIST_FOLDER_TARGET_INFO *ppfti, LPITEMIDLIST * ppidl, BOOL fFree)
{
    HRESULT hr = E_INVALIDARG;

    if (ppidl)
    {
        *ppidl = NULL;
        if (ppfti->pidlTargetFolder)
        {
            *ppidl = (fFree ? ppfti->pidlTargetFolder : ILClone(ppfti->pidlTargetFolder));
            if (*ppidl)
                hr = S_OK;
            else
                hr = E_OUTOFMEMORY;
        }
        else
        {
            if (ppfti->szTargetParsingName[0])
            {
                hr = IEParseDisplayNameWithBCW(CP_ACP, ppfti->szTargetParsingName, NULL, ppidl);
            }

            if (!*ppidl && (-1 != ppfti->csidl))
            {
                hr = SHGetSpecialFolderLocation(NULL, ppfti->csidl, ppidl);
            }
        }
    }
    
    return hr;
}


/*****************************************************************************\
    DESCRIPTION:
\*****************************************************************************/
HRESULT CBaseFolder::InitializeEx(IBindCtx *pbc, LPCITEMIDLIST pidlRoot, const PERSIST_FOLDER_TARGET_INFO *ppfti)
{
    HRESULT hr = E_INVALIDARG;

    if (EVAL(pidlRoot))
    {
        if (ppfti)
        {
            // We are a Folder Shortcut.
            LPITEMIDLIST pidlTarget;

            hr = GetPidlFromPersistFolderTargetInfo(ppfti, &pidlTarget, FALSE);  // Get the real root.           
            TraceMsg(TF_FOLDER_SHRTCUTS, "CBaseFolder::InitializeEx() this=%#08lx, pidlTarget=%#08lx, pidlRoot=%#08lx", this, pidlTarget, pidlRoot);

            AssertMsg((NULL != pidlTarget), TEXT("CBaseFolder::InitializeEx() We are useless without a pidlTarget so watch me go limp."));
            if (pidlTarget)
            {
                hr = _Initialize(pidlTarget, pidlRoot, m_nIDOffsetToPrivate);
                ILFree(pidlTarget);
            }
        }
        else
        {
            // We aren't a folder shortcut.
            hr = Initialize(pidlRoot);
        }
    }

    return hr;
}


HRESULT CBaseFolder::GetFolderTargetInfo(PERSIST_FOLDER_TARGET_INFO *ppfti)
{
    HRESULT hr = E_INVALIDARG;

    AssertMsg((NULL != ppfti), TEXT("CBaseFolder::GetFolderTargetInfo() Caller passed an invalid param."));
    if (ppfti)
    {
        ZeroMemory(ppfti, sizeof(*ppfti)); 

        ppfti->pidlTargetFolder = ILClone(m_pidlRoot);
        ppfti->dwAttributes = -1;
        ppfti->csidl = -1;
        hr = S_OK;
    }

    return hr;
}


LPCITEMIDLIST CBaseFolder::GetPrivatePidlReference(void)
{
    return _ILSkip(m_pidl, m_nIDOffsetToPrivate);
}

// This function always needs the InternetExplorer pidl.
LPITEMIDLIST CBaseFolder::GetPublicPidlRootIDClone(void)
{
    LPITEMIDLIST pidlFull = ILClone(m_pidl);
    LPITEMIDLIST pidlPrivStart = _ILSkip(pidlFull, m_nIDOffsetToPrivate);

    // Strip all Private ItemIDs
    while (!ILIsEmpty(pidlPrivStart))
        ILRemoveLastID(pidlPrivStart);

    return pidlFull;
}

LPITEMIDLIST CBaseFolder::CreateFullPrivatePidl(LPCITEMIDLIST pidlPrivateSubPidl)
{
    return ILCombine(GetPrivatePidlReference(), pidlPrivateSubPidl);
}

LPITEMIDLIST CBaseFolder::CreateFullPublicPidlFromRelative(LPCITEMIDLIST pidlPrivateSubPidl)
{
    return ILCombine(GetPublicRootPidlReference(), pidlPrivateSubPidl);
}

LPITEMIDLIST CBaseFolder::CreateFullPublicPidl(LPCITEMIDLIST pidlPrivatePidl)
{
    LPITEMIDLIST pidlRoot = GetPublicPidlRootIDClone();
    LPITEMIDLIST pidlResult = NULL;
    
    if (pidlRoot)
    {
        pidlResult = ILCombine(pidlRoot, pidlPrivatePidl);
        ILFree(pidlRoot);
    }

    return pidlResult;
}

HRESULT CBaseFolder::_Initialize(LPCITEMIDLIST pidlTarget, LPCITEMIDLIST pidlRoot, int nBytesToPrivate)
{
    HRESULT hr = E_INVALIDARG;

    if (pidlTarget)
    {
        ILFree(m_pidl);
        ILFree(m_pidlRoot);    
        m_pidl = ILClone(pidlTarget);
        m_pidlRoot = ILClone(pidlRoot); // This is the Folder Shortcut pidl.  We don't use it outselves.

        if (m_pidl)
        {
            m_nIDOffsetToPrivate = nBytesToPrivate;
            hr = S_OK;
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}


/****************************************************\
    Constructor
\****************************************************/
CBaseFolder::CBaseFolder(LPCLSID pClassID) : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_pidl);
    ASSERT(!m_nIDOffsetToPrivate);
    ASSERT(!m_pClassID);

    m_pClassID = pClassID;
    ASSERT(pClassID);
}


/****************************************************\
    Destructor
\****************************************************/
CBaseFolder::~CBaseFolder()
{
    Pidl_Set(&m_pidlRoot, NULL);    // Folder Shortcut pidl
    Pidl_Set(&m_pidl, NULL);
    DllRelease();
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CBaseFolder::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CBaseFolder::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CBaseFolder::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CBaseFolder, IShellFolder, IShellFolder2),
        QITABENTMULTI(CBaseFolder, IPersist, IPersistFolder),
        QITABENTMULTI(CBaseFolder, IPersist, IPersistFolder3),
        QITABENTMULTI(CBaseFolder, IPersistFolder, IPersistFolder3),
        QITABENTMULTI(CBaseFolder, IPersistFolder2, IPersistFolder3),
        QITABENT(CBaseFolder, IShellFolder2),
        QITABENT(CBaseFolder, IPersistFolder3),
        QITABENT(CBaseFolder, IObjectWithSite),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\ftppidl.cpp ===
/*****************************************************************************\
    xboxpidl.cpp - Pointers to Item ID Lists

    This is the only file that knows the internal format of our IDLs.
\*****************************************************************************/

#include "priv.h"
#include "xboxpidl.h"
#include "xboxurl.h"
#include "cookie.h"

#define NOT_INITIALIZED         10
DWORD g_fNoPasswordsInAddressBar = NOT_INITIALIZED;

#define SESSIONKEY      FILETIME

// Private XboxServerID Helpers
HRESULT XboxServerID_GetServer(LPCITEMIDLIST pidl, LPTSTR szServer, DWORD cchSize);
DWORD XboxItemID_GetTypeID(LPCITEMIDLIST pidl);

// v0 never went to customers but was used in NT5 before 1799       - Shipped in: Never.
// v1 This switch was to use password cookies for a security fix.   - Shipped in: Never.
// v2 this was done to not use the IDelegate's IMalloc for non-first ItemIDs  - Shipped in: Never (5/15/98)
// v3 add extra padding to ItemIDs so their dwType matches that of ServerIDs - Shipped in: IE5b1, IE5b2, NT5b2 (5/25/98)
// v4 add wzDisplayName to XboxItemID                                - Shipped in: IE5 RTM & NT5 b3  (11/16/98)

#define PIDL_VERSION_NUMBER_UPGRADE 3
#define PIDL_VERSION_NUMBER 4



#define     SIZE_ITEMID_SIZEFIELD        (sizeof(DWORD) + sizeof(WORD))
#define     SIZE_ITEMID_TERMINATOR       (sizeof(DWORD))


/****************************************************\
    IDType

    DESCRIPTION:
        These bits go into XBOXIDLIST.dwIDType and describe
    what type of pidl it is AND which areas of the
    data structure have been verified by getting the
    data directly from the server.
\****************************************************/

#define IDTYPE_ISVALID           0x00000001    // Set if TYPE is valid
#define IDTYPE_SERVER            (0x00000002 | IDTYPE_ISVALID)    // Server
#define IDTYPE_DIR               (0x00000004 | IDTYPE_ISVALID)    // Folder/Dir
#define IDTYPE_FILE              (0x00000008 | IDTYPE_ISVALID)    // File
#define IDTYPE_FILEORDIR         (0x00000010 | IDTYPE_ISVALID)    // File or Dir.  Wasn't specified.
#define IDTYPE_FRAGMENT          (0x00000020 | IDTYPE_ISVALID)    // File Fragment (i.e. foobar.htm#SECTION_3)

// These are bits that indicate
// For Server ItemIDs
#define IDVALID_PORT_NUM         0x00000100     // Was the port number specified
#define IDVALID_USERNAME         0x00000200     // Was the login name specified
#define IDVALID_PASSWORD         0x00000400     // Was the password specified
#define IDVALID_DLTYPE           0x00000800     // Download Type is specified.
#define IDVALID_DL_ASCII         0x00001000     // Download as ASCII if set, otherwise, download as BINARY.
#define IDVALID_HIDE_PASSWORD    0x00002000     // The Password entry is invalid so use the sessionkey to look it up.

#define VALID_SERVER_BITS (IDTYPE_ISVALID|IDTYPE_SERVER|IDVALID_PORT_NUM|IDVALID_USERNAME|IDVALID_PASSWORD|IDVALID_DLTYPE|IDVALID_DL_ASCII|IDVALID_HIDE_PASSWORD)
#define IS_VALID_SERVER_ITEMID(pItemId) (!(pItemId & ~VALID_SERVER_BITS))

// For Dir/File ItemIDs
#define IDVALID_FILESIZE         0x00010000     // Did we get the file size from the server?
#define IDVALID_MOD_DATE         0x00020000     // Did we get the modification date from the server?

#define VALID_DIRORFILE_BITS (IDTYPE_ISVALID|IDTYPE_DIR|IDTYPE_FILE|IDTYPE_FILEORDIR|IDTYPE_FRAGMENT|IDVALID_FILESIZE|IDVALID_MOD_DATE)
#define IS_VALID_DIRORFILE_ITEMID(pItemId) (!(pItemId & (~VALID_DIRORFILE_BITS & ~IDTYPE_ISVALID)))


#define IS_FRAGMENT(pXboxIDList)       (IDTYPE_ISVALID != (IDTYPE_FRAGMENT & pXboxIDList->dwIDType))

///////////////////////////////////////////////////////////
// XBOX Pidl Helper Functions 
///////////////////////////////////////////////////////////


/*****************************************************************************\
    FUNCTION: UrlGetAbstractPathFromPidl

    DESCRIPTION:
        pszUrlPath will be UNEscaped and in Wire Bytes.
\*****************************************************************************/
HRESULT UrlGetAbstractPathFromPidl(LPCITEMIDLIST pidl, BOOL fDirsOnly, BOOL fInWireBytes, void * pvPath, DWORD cchUrlPathSize)
{
    HRESULT hr = S_OK;
    LPWIRESTR pwWirePath = (LPWIRESTR) pvPath;
    LPWSTR pwzDisplayPath = (LPWSTR) pvPath;

    if (!EVAL(XboxPidl_IsValid(pidl)))
        return E_INVALIDARG;

    ASSERT(pvPath && (0 < cchUrlPathSize));
    ASSERT(IsValidPIDL(pidl));

    if (fInWireBytes)
    {
        pwWirePath[0] = '/';
        pwWirePath[1] = '\0'; // Make this path absolute.
    }
    else
    {
        pwzDisplayPath[0] = L'/';
        pwzDisplayPath[1] = L'\0'; // Make this path absolute.
    }

    if (!ILIsEmpty(pidl) && XboxID_IsServerItemID(pidl))       // If it's not a server, we are screwed.
        pidl = _ILNext(pidl);   // Skip past the Server Pidl.

    for (; !ILIsEmpty(pidl); pidl = _ILNext(pidl))
    {
        if (!fDirsOnly || XboxItemID_IsDirectory(pidl, TRUE) || !ILIsEmpty(_ILNext(pidl)))
        {
            if (!XboxItemID_IsFragment(pidl))
            {
                if (fInWireBytes)
                {
                    LPCWIRESTR pwWireName = XboxItemID_GetWireNameReference(pidl);

                    if (pwWireName)
                    {
                        // The caller should never need the URL Path escaped because
                        // that will happen when it's converted into an URL.
                        WirePathAppend(pwWirePath, cchUrlPathSize, pwWireName);
                    }
                }
                else
                {
                    LPCWSTR pwzDisplayName = XboxItemID_GetDisplayNameReference(pidl);

                    if (pwzDisplayName)
                    {
                        // The caller should never need the URL Path escaped because
                        // that will happen when it's converted into an URL.
                        DisplayPathAppend(pwzDisplayPath, cchUrlPathSize, pwzDisplayName);
                    }
                }
            }
        }

        if (SUCCEEDED(hr) && XboxItemID_IsDirectory(pidl, FALSE))
        {
            if (fInWireBytes)
                WirePathAppendSlash(pwWirePath, cchUrlPathSize); // Always make sure dirs end in '/'.
            else
                DisplayPathAppendSlash(pwzDisplayPath, cchUrlPathSize); // Always make sure dirs end in '/'.
        }
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: GetDisplayPathFromPidl

    DESCRIPTION:
        pwzDisplayPath will be UNEscaped and in display unicode.
\*****************************************************************************/
HRESULT GetDisplayPathFromPidl(LPCITEMIDLIST pidl, LPWSTR pwzDisplayPath, DWORD cchUrlPathSize, BOOL fDirsOnly)
{
    return UrlGetAbstractPathFromPidl(pidl, fDirsOnly, FALSE, (void *) pwzDisplayPath, cchUrlPathSize);
}


/*****************************************************************************\
    FUNCTION: GetWirePathFromPidl

    DESCRIPTION:
        pszUrlPath will be UNEscaped and in Wire Bytes.
\*****************************************************************************/
HRESULT GetWirePathFromPidl(LPCITEMIDLIST pidl, LPWIRESTR pwWirePath, DWORD cchUrlPathSize, BOOL fDirsOnly)
{
    return UrlGetAbstractPathFromPidl(pidl, fDirsOnly, TRUE, (void *) pwWirePath, cchUrlPathSize);
}


/*****************************************************************************\
    FUNCTION: UrlGetFileNameFromPidl

    DESCRIPTION:
        pszFileName will be filled with the file name if it exists.  If it doesn't,
    S_FALSE will be returned if the PIDL only points to a directory and not
    a file.
HRESULT UrlGetFileNameFromPidl(LPCITEMIDLIST pidl, LPTSTR pszFileName, DWORD cchSize)
{
    HRESULT hr = S_FALSE;

    if (!EVAL(XboxPidl_IsValid(pidl)))
        return E_INVALIDARG;

    ASSERT(pszFileName && (0 < cchSize));
    ASSERT(IsValidPIDL(pidl));
    pszFileName[0] = TEXT('\0');

    if (EVAL(XboxID_IsServerItemID(pidl)))       // If it's not a server, we are screwed.
        pidl = _ILNext(pidl);   // Skip past the Server Pidl.

    for (; !ILIsEmpty(pidl); pidl = _ILNext(pidl))
    {
        if (!XboxItemID_IsDirectory(pidl, FALSE))
        {
            // This isn't a directory, so the only time it's valid to not
            // be the last ItemID is if this is a file ItemID and the next
            // ItemID is a Fragment.
            ASSERT(ILIsEmpty(_ILNext(pidl)) || XboxItemID_IsFragment(_ILNext(pidl)));
            SHAnsiToTChar(XboxItemID_GetFileName(pidl), pszFileName, cchSize);
            hr = S_OK;
            break;
        }
    }

    return hr;
}
\*****************************************************************************/


#ifndef UNICODE
/*****************************************************************************\
    FUNCTION: UrlCreateFromPidlW

    DESCRIPTION:
        x.
\*****************************************************************************/
HRESULT UrlCreateFromPidlW(LPCITEMIDLIST pidl, DWORD shgno, LPWSTR pwzUrl, DWORD cchSize, DWORD dwFlags, BOOL fHidePassword)
{
    HRESULT hr;
    TCHAR szUrl[MAX_URL_STRING];

    hr = UrlCreateFromPidl(pidl, shgno, szUrl, ARRAYSIZE(szUrl), dwFlags, fHidePassword);
    if (SUCCEEDED(hr))
        SHTCharToUnicode(szUrl, pwzUrl, cchSize);

    return hr;
}

#else // UNICODE

/*****************************************************************************\
    FUNCTION: UrlCreateFromPidlA

    DESCRIPTION:
        x.
\*****************************************************************************/
HRESULT UrlCreateFromPidlA(LPCITEMIDLIST pidl, DWORD shgno, LPSTR pszUrl, DWORD cchSize, DWORD dwFlags, BOOL fHidePassword)
{
    HRESULT hr;
    TCHAR szUrl[MAX_URL_STRING];

    hr = UrlCreateFromPidl(pidl, shgno, szUrl, ARRAYSIZE(szUrl), dwFlags, fHidePassword);
    if (SUCCEEDED(hr))
        SHTCharToAnsi(szUrl, pszUrl, cchSize);

    return hr;
}

#endif // UNICODE


BOOL IncludePassword(void)
{
    if (NOT_INITIALIZED == g_fNoPasswordsInAddressBar)
        g_fNoPasswordsInAddressBar = !SHRegGetBoolUSValue(SZ_REGKEY_XBOXFOLDER, SZ_REGVALUE_PASSWDSIN_ADDRBAR, FALSE, TRUE);

    return g_fNoPasswordsInAddressBar;
}


HRESULT ParseUrlCreateFromPidl(LPCITEMIDLIST pidl, LPTSTR pszUrl, DWORD cchSize, DWORD dwFlags, BOOL fHidePassword)
{
    HRESULT hr = S_OK;
    TCHAR szServer[INTERNET_MAX_HOST_NAME_LENGTH];
    TCHAR szUrlPath[MAX_URL_STRING];
    TCHAR szUserName[INTERNET_MAX_USER_NAME_LENGTH];
    TCHAR szPassword[INTERNET_MAX_PASSWORD_LENGTH];
    TCHAR szFragment[MAX_PATH];
    TCHAR szDownloadType[MAX_PATH] = TEXT("");
    INTERNET_PORT ipPortNum = INTERNET_DEFAULT_FTP_PORT;

    if (ILIsEmpty(pidl))
    {
        ASSERT(0); // BUGBUG: Work around until we can figure out why CXboxFolder has ILIsEmpty(m_pidlHere).
        szServer[0] = szUrlPath[0] = szUserName[0] = szPassword[0] = TEXT('\0');
        hr = E_FAIL;
    }
    else
    {
        XboxPidl_GetServer(pidl, szServer, ARRAYSIZE(szServer));
        GetDisplayPathFromPidl(pidl, szUrlPath, ARRAYSIZE(szUrlPath), FALSE);
        XboxPidl_GetUserName(pidl, szUserName, ARRAYSIZE(szUserName));
        if (FAILED(XboxPidl_GetPassword(pidl, szPassword, ARRAYSIZE(szPassword), !fHidePassword)))
            szPassword[0] = 0;

        XboxPidl_GetFragment(pidl, szFragment, ARRAYSIZE(szPassword));
        XboxPidl_GetDownloadTypeStr(pidl, szDownloadType, ARRAYSIZE(szDownloadType));
        UrlPathAdd(szUrlPath, ARRAYSIZE(szUrlPath), szDownloadType);
        ipPortNum = XboxPidl_GetPortNum(pidl);
    }

    if (SUCCEEDED(hr))
    {
        TCHAR szUserNameEscaped[INTERNET_MAX_USER_NAME_LENGTH];

        szUserNameEscaped[0] = 0;
        if (szUserName[0])
            EscapeString(szUserName, szUserNameEscaped, ARRAYSIZE(szUserNameEscaped));

        hr = UrlCreateEx(szServer, NULL_FOR_EMPTYSTR(szUserNameEscaped), szPassword, szUrlPath, szFragment, ipPortNum, szDownloadType, pszUrl, cchSize, dwFlags);
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: GetFullPrettyName
    
    DESCRIPTION:
        The user wants a pretty name so these are the cases we need to worry
    about:
    URL:                                               Pretty Name:
    ----------------------------------                 ---------------------
    xbox://joe:psswd@serv/                              serv
    xbox://joe:psswd@serv/dir1/                         dir1 on serv
    xbox://joe:psswd@serv/dir1/dir2/                    dir2 on serv
    xbox://joe:psswd@serv/dir1/dir2/file.txt            file.txt on serv
\*****************************************************************************/
HRESULT GetFullPrettyName(LPCITEMIDLIST pidl, LPTSTR pszUrl, DWORD cchSize)
{
    HRESULT hr = S_OK;
    TCHAR szServer[INTERNET_MAX_HOST_NAME_LENGTH];

    XboxPidl_GetServer(pidl, szServer, ARRAYSIZE(szServer));
    // Is there anything after the ServerItemID?
    if (!ILIsEmpty(_ILNext(pidl)))
    {
        // Yes, so let's get the name of the last item and
        // make the string "<LastItemName> on <Server>".
        LPCWSTR pwzLastItem = XboxItemID_GetDisplayNameReference(ILFindLastID(pidl));
        LPTSTR pszStrArray[] = {szServer, (LPTSTR)pwzLastItem};
        TCHAR szTemplate[MAX_PATH];
        
        EVAL(LoadString(HINST_THISDLL, IDS_PRETTYNAMEFORMAT, szTemplate, ARRAYSIZE(szTemplate)));
        EVAL(FormatMessage((FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY), (LPVOID)szTemplate,
                            0, 0, pszUrl, cchSize, (va_list*)pszStrArray));
    }
    else
    {
        // No, so we are done.
        StrCpyN(pszUrl, szServer, cchSize);
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: UrlCreateFromPidl
    
    DESCRIPTION:
        Common worker that handles SHGDN_FORPARSING style GetDisplayNameOf's.

    Note! that since we do not support junctions (duh), we can
    safely walk down the pidl generating goop as we go, secure
    in the knowledge that we are in charge of every subpidl.

    _CHARSET_:  Since XBOX filenames are always in the ANSI character
    set, by RFC 1738, we can return ANSI display names without loss
    of fidelity.  In a general folder implementation, we should be
    using cStr to return display names, so that the UNICODE
    version of the shell extension can handle UNICODE names.
\*****************************************************************************/
HRESULT UrlCreateFromPidl(LPCITEMIDLIST pidl, DWORD shgno, LPTSTR pszUrl, DWORD cchSize, DWORD dwFlags, BOOL fHidePassword)
{
    HRESULT hr = S_OK;

    pszUrl[0] = 0;
    if (!EVAL(pidl) ||
        !EVAL(IsValidPIDL(pidl)) ||
        !XboxPidl_IsValid(pidl) ||
        !XboxID_IsServerItemID(pidl) ||
        !EVAL(pszUrl && (0 < cchSize)))
    {
        return E_INVALIDARG;
    }

    if (shgno & SHGDN_INFOLDER)
    {
        // shgno & SHGDN_INFOLDER ?
        LPCITEMIDLIST pidlLast = ILGetLastID(pidl);

        if (EVAL(pidlLast && !ILIsEmpty(pidlLast)))
        {
            hr = XboxPidl_GetDisplayName(pidlLast, pszUrl, cchSize);

            // Do they want to reparse it later?  If they do and it's
            // a server, we need to give out the scheme also.
            // (SHGDN_INFOLDER) = "ServerName"
            // (SHGDN_INFOLDER|SHGDN_FORPARSING) = "xbox://ServerName/"
            if ((shgno & SHGDN_FORPARSING) &&
                (XboxID_IsServerItemID(pidlLast)))
            {
                // Yes, so we need to add the server name.
                TCHAR szServerName[MAX_PATH];

                StrCpyN(szServerName, pszUrl, ARRAYSIZE(szServerName));
                wnsprintf(pszUrl, cchSize, TEXT("xbox://%s/"), szServerName);
            }
        }
        else
            hr = E_FAIL;
    }
    else
    {
        // Assume they want the full URL.
        if (!EVAL((shgno & SHGDN_FORPARSING) || 
               (shgno & SHGDN_FORADDRESSBAR) ||
               (shgno == SHGDN_NORMAL)))
        {
            TraceMsg(TF_ALWAYS, "UrlCreateFromPidl() shgno=%#08lx and I dont know what to do with that.", shgno);
        }

        if ((shgno & SHGDN_FORPARSING) || (shgno & SHGDN_FORADDRESSBAR))
        {
            hr = ParseUrlCreateFromPidl(pidl, pszUrl, cchSize, dwFlags, fHidePassword);
        }
        else
            hr = GetFullPrettyName(pidl, pszUrl, cchSize);
    }

//    TraceMsg(TF_XBOXURL_UTILS, "UrlCreateFromPidl() pszUrl=%ls, shgno=%#08lX", pszUrl, shgno);
    return hr;
}


/*****************************************************************************\
    FUNCTION: CreateXboxPidlFromDisplayPathHelper

    DESCRIPTION:
        The work done in CreateXboxPidlFromUrlPath requires a fair amount of
    stack space so we do most of the work in CreateXboxPidlFromDisplayPathHelper
    to prevent overflowing the stack.
\*****************************************************************************/
HRESULT CreateXboxPidlFromDisplayPathHelper(LPCWSTR pwzFullPath, CWireEncoding * pwe, ULONG *pcchEaten, LPITEMIDLIST * ppidl, BOOL fIsTypeKnown, BOOL fIsDir, LPITEMIDLIST * ppidlCurrentID, LPWSTR * ppwzRemaining)
{
    HRESULT hr = E_FAIL;
    LPITEMIDLIST pidl;
    WCHAR wzFirstItem[MAX_PATH];
    WIRECHAR wFirstWireItem[MAX_PATH];
    WCHAR wzRemaining[MAX_PATH];
    BOOL fIsCurrSegmentADir = FALSE;
    BOOL fIsCurrSegmentTypeKnown = fIsTypeKnown;
    BOOL fIsFragSeparator = FALSE;

    *ppwzRemaining = NULL;
    *ppidl = 0;

    if (pcchEaten)
        *pcchEaten = 0;     // The caller will parse the entire URL so we don't need to fill this in.

    if (L'/' == pwzFullPath[0])
        pwzFullPath = (LPWSTR) CharNextW(pwzFullPath);

    DisplayPathGetFirstSegment(pwzFullPath, wzFirstItem, ARRAYSIZE(wzFirstItem), NULL, wzRemaining, ARRAYSIZE(wzRemaining), &fIsCurrSegmentADir);
    // Is this the last segment?
    if (!wzRemaining[0])
    {
        // Yes, so if the caller knows the type of the last segment, use it now.
        if (fIsTypeKnown)
            fIsCurrSegmentADir = fIsDir;
    }
    else
    {
        // No, so we are assured that fIsDirCurrent is correct because it must have been followed
        // by a '/', or how could it be followed by another path segment?
        fIsCurrSegmentTypeKnown = TRUE;
        ASSERT(fIsCurrSegmentADir);
    }

    // NOTE: If the user entered "xbox://serv/Dir1/Dir2" fIsDir will be false for Dir2.
    //       It will be marked as ambigious. (TODO: Check for extension?)

    EVAL(SUCCEEDED(pwe->UnicodeToWireBytes(NULL, wzFirstItem, ((pwe && pwe->IsUTF8Supported()) ? WIREENC_USE_UTF8 : WIREENC_NONE), wFirstWireItem, ARRAYSIZE(wFirstWireItem))));
    hr = XboxItemID_CreateFake(wzFirstItem, wFirstWireItem, fIsCurrSegmentTypeKnown, !fIsCurrSegmentADir, FALSE, &pidl);
    ASSERT(IsValidPIDL(pidl));

    if (EVAL(SUCCEEDED(hr)))
    {
        if (wzRemaining[0])
        {
            Str_SetPtrW(ppwzRemaining, wzRemaining);
            *ppidlCurrentID = pidl;
        }
        else
            *ppidl = pidl;
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: CreateXboxPidlFromUrlPath

    DESCRIPTION:
        This function will be passed the 'Path' of the URL and will create
    each of the IDs for each path segment.  This will happen by creating an ID
    for the first path segment and then Combining that with the remaining
    IDs which are obtained by a recursive call.

    URL = "xbox://<UserName>:<Password>@<HostName>:<PortNum>/Dir1/Dir2/Dir3/file.txt[;Type=[a|b|d]]"
    Url Path = "Dir1/Dir2/Dir3/file.txt"

    pszFullPath - This URL will contain an URL Path (/Dir1/Dir2/MayBeFileOrDir).
    fIsTypeKnown - We can detect all directories w/o ambiguity because they end
                   end '/' except for the last directory.  fIsTypeKnown is used
                   if this information is known.  If TRUE, fIsDir will be used to
                   disambiguate the last item.  If FALSE, the last item will be marked
                   a directory if it doesn't have an extension.

    The incoming name is %-encoded, but if we see an illegal %-sequence,
    just leave the % alone.

    Note that we return E_FAIL when given an unparseable path,
    not E_INVALIDARG.
\*****************************************************************************/
HRESULT CreateXboxPidlFromDisplayPath(LPCWSTR pwzFullPath, CWireEncoding * pwe, ULONG *pcchEaten, LPITEMIDLIST * ppidl, BOOL fIsTypeKnown, BOOL fIsDir)
{
    HRESULT hr = E_FAIL;
    LPWSTR pwzRemaining = NULL;
    LPITEMIDLIST pidlCurrentID = NULL;

    hr = CreateXboxPidlFromDisplayPathHelper(pwzFullPath, pwe, pcchEaten, ppidl, fIsTypeKnown, fIsDir, &pidlCurrentID, &pwzRemaining);
    if (EVAL(SUCCEEDED(hr)) && pwzRemaining)
    {
        LPITEMIDLIST pidlSub;

        hr = CreateXboxPidlFromDisplayPath(pwzRemaining, pwe, pcchEaten, &pidlSub, fIsTypeKnown, fIsDir);
        if (EVAL(SUCCEEDED(hr)))
        {
            *ppidl = ILCombine(pidlCurrentID, pidlSub);
            hr = *ppidl ? S_OK : E_OUTOFMEMORY;
            ILFree(pidlSub);
        }

        ILFree(pidlCurrentID);
        Str_SetPtrW(&pwzRemaining, NULL);
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: CreateXboxPidlFromDisplayPathHelper

    DESCRIPTION:
        The work done in CreateXboxPidlFromUrlPath requires a fair amount of
    stack space so we do most of the work in CreateXboxPidlFromDisplayPathHelper
    to prevent overflowing the stack.
\*****************************************************************************/
HRESULT CreateXboxPidlFromXboxWirePathHelper(LPCWIRESTR pwXboxWirePath, CWireEncoding * pwe, ULONG *pcchEaten, LPITEMIDLIST * ppidl, BOOL fIsTypeKnown, BOOL fIsDir, LPITEMIDLIST * ppidlCurrentID, LPWIRESTR * ppwRemaining)
{
    HRESULT hr = E_FAIL;
    LPITEMIDLIST pidl;
    WIRECHAR wFirstItem[MAX_PATH];
    WCHAR wzFirstItemDisplayName[MAX_PATH];
    WIRECHAR wRemaining[MAX_PATH];
    BOOL fIsCurrSegmentADir = FALSE;
    BOOL fIsCurrSegmentTypeKnown = fIsTypeKnown;
    BOOL fIsFragSeparator = FALSE;

    *ppwRemaining = NULL;
    *ppidl = 0;

    if (pcchEaten)
        *pcchEaten = 0;     // The caller will parse the entire URL so we don't need to fill this in.

    if ('/' == pwXboxWirePath[0])
        pwXboxWirePath = (LPWIRESTR) CharNextA(pwXboxWirePath);

    WirePathGetFirstSegment(pwXboxWirePath, wFirstItem, ARRAYSIZE(wFirstItem), NULL, wRemaining, ARRAYSIZE(wRemaining), &fIsCurrSegmentADir);
    // Is this the last segment?
    if (!wRemaining[0])
    {
        // Yes, so if the caller knows the type of the last segment, use it now.
        if (fIsTypeKnown)
            fIsCurrSegmentADir = fIsDir;
    }
    else
    {
        // No, so we are assured that fIsDirCurrent is correct because it must have been followed
        // by a '/', or how could it be followed by another path segment?
        fIsCurrSegmentTypeKnown = TRUE;
        ASSERT(fIsCurrSegmentADir);
    }

    // NOTE: If the user entered "xbox://serv/Dir1/Dir2" fIsDir will be false for Dir2.
    //       It will be marked as ambigious. (TODO: Check for extension?)
    EVAL(SUCCEEDED(pwe->WireBytesToUnicode(NULL, wFirstItem, WIREENC_IMPROVE_ACCURACY, wzFirstItemDisplayName, ARRAYSIZE(wzFirstItemDisplayName))));
    hr = XboxItemID_CreateFake(wzFirstItemDisplayName, wFirstItem, fIsCurrSegmentTypeKnown, !fIsCurrSegmentADir, FALSE, &pidl);
    ASSERT(IsValidPIDL(pidl));

    if (EVAL(SUCCEEDED(hr)))
    {
        if (wRemaining[0])
        {
            Str_SetPtrA(ppwRemaining, wRemaining);
            *ppidlCurrentID = pidl;
        }
        else
            *ppidl = pidl;
    }

    return hr;
}


HRESULT CreateXboxPidlFromXboxWirePath(LPCWIRESTR pwXboxWirePath, CWireEncoding * pwe, ULONG *pcchEaten, LPITEMIDLIST * ppidl, BOOL fIsTypeKnown, BOOL fIsDir)
{
    HRESULT hr = E_FAIL;
    LPWIRESTR pwRemaining = NULL;
    LPITEMIDLIST pidlCurrentID = NULL;

    *ppidl = NULL;
    if (!pwXboxWirePath[0] || (0 == StrCmpA(pwXboxWirePath, SZ_URL_SLASHA)))
        return S_OK;

    hr = CreateXboxPidlFromXboxWirePathHelper(pwXboxWirePath, pwe, pcchEaten, ppidl, fIsTypeKnown, fIsDir, &pidlCurrentID, &pwRemaining);
    if (EVAL(SUCCEEDED(hr)) && pwRemaining)
    {
        LPITEMIDLIST pidlSub;

        hr = CreateXboxPidlFromXboxWirePath(pwRemaining, pwe, pcchEaten, &pidlSub, fIsTypeKnown, fIsDir);
        if (EVAL(SUCCEEDED(hr)))
        {
            *ppidl = ILCombine(pidlCurrentID, pidlSub);
            hr = *ppidl ? S_OK : E_OUTOFMEMORY;
            ILFree(pidlSub);
        }

        ILFree(pidlCurrentID);
        Str_SetPtrA(&pwRemaining, NULL);
    }

    return hr;
}


HRESULT CreateXboxPidlFromUrlPathAndPidl(LPCITEMIDLIST pidl, CWireEncoding * pwe, LPCWIRESTR pwXboxWirePath, LPITEMIDLIST * ppidl)
{
    HRESULT hr = E_FAIL;
    LPITEMIDLIST pidlNew = ILClone(pidl);

    if (pidlNew)
    {
        LPITEMIDLIST pidlLast = (LPITEMIDLIST) ILGetLastID(pidlNew);

        while (!XboxID_IsServerItemID(pidlLast))
        {
            pidlLast->mkid.cb = 0;  // Remove this ID.
            pidlLast = (LPITEMIDLIST) ILGetLastID(pidlNew);
        }

        LPITEMIDLIST pidlUrlPath = NULL;
        hr = CreateXboxPidlFromXboxWirePath(pwXboxWirePath, pwe, NULL, &pidlUrlPath, TRUE, TRUE);
        if (EVAL(SUCCEEDED(hr)))
        {
            *ppidl = ILCombine(pidlNew, pidlUrlPath);
        }

        if (pidlLast)
            ILFree(pidlLast);

        if (pidlUrlPath)
            ILFree(pidlUrlPath);
    }

    return hr;
}


/*****************************************************************************\
    CreateXboxPidlFromUrl

    The incoming name is %-encoded, but if we see an illegal %-sequence,
    just leave the % alone.

    Note that we return E_FAIL when given an unparseable path,
    not E_INVALIDARG.
\*****************************************************************************/
HRESULT CreateXboxPidlFromUrl(LPCTSTR pszUrl, CWireEncoding * pwe, ULONG *pcchEaten, LPITEMIDLIST * ppidl, IMalloc * pm, BOOL fHidePassword)
{
    return CreateXboxPidlFromUrlEx(pszUrl, pwe, pcchEaten, ppidl, pm, fHidePassword, FALSE, FALSE);
}


/*****************************************************************************\
    FUNCTION: CreateXboxPidlFromUrlEx

    DESCRIPTION:
    pszUrl - This URL will contain an URL Path (/Dir1/Dir2/MayBeFileOrDir).
    fIsTypeKnown - We can detect all directories w/o ambiguity because they end
                   end '/' except for the last directory.  fIsTypeKnown is used
                   if this information is known.  If TRUE, fIsDir will be used to
                   disambiguate the last item.  If FALSE, the last item will be marked
                   a directory if it doesn't have an extension.

    The incoming name is %-encoded, but if we see an illegal %-sequence,
    just leave the % alone.

    Note that we return E_FAIL when given an unparseable path,
    not E_INVALIDARG.
\*****************************************************************************/
HRESULT CreateXboxPidlFromUrlEx(LPCTSTR pszUrl, CWireEncoding * pwe, ULONG *pcchEaten, LPITEMIDLIST * ppidl, IMalloc * pm, BOOL fHidePassword, BOOL fIsTypeKnown, BOOL fIsDir)
{
    URL_COMPONENTS urlComps = {0};
    HRESULT hr = E_FAIL;

    // URL = "xbox://<UserName>:<Password>@<HostName>:<PortNum>/Dir1/Dir2/Dir3/file.txt[;Type=[a|b|d]]"
    TCHAR szServer[INTERNET_MAX_HOST_NAME_LENGTH];
    TCHAR szUrlPath[MAX_URL_STRING];
    TCHAR szExtraInfo[MAX_PATH];    // Includes Port Number and download type (ASCII, Binary, Detect)
    TCHAR szUserName[INTERNET_MAX_USER_NAME_LENGTH];
    TCHAR szPassword[INTERNET_MAX_PASSWORD_LENGTH];

    *ppidl = 0;

    urlComps.dwStructSize = sizeof(urlComps);
    urlComps.lpszHostName = szServer;
    urlComps.dwHostNameLength = ARRAYSIZE(szServer);
    urlComps.lpszUrlPath = szUrlPath;
    urlComps.dwUrlPathLength = ARRAYSIZE(szUrlPath);

    urlComps.lpszUserName = szUserName;
    urlComps.dwUserNameLength = ARRAYSIZE(szUserName);
    urlComps.lpszPassword = szPassword;
    urlComps.dwPasswordLength = ARRAYSIZE(szPassword);
    urlComps.lpszExtraInfo = szExtraInfo;
    urlComps.dwExtraInfoLength = ARRAYSIZE(szExtraInfo);

    BOOL fResult = XboxCrackUrl(pszUrl, 0, ICU_DECODE, &urlComps);
    if (fResult && (INTERNET_SCHEME_FTP == urlComps.nScheme))
    {
        LPITEMIDLIST pidl;
        DWORD dwDownloadType = 0;   // Indicate that it hasn't yet been specified.
        BOOL fASCII;

        ASSERT(INTERNET_SCHEME_FTP == urlComps.nScheme);
        // NOTE:
        //          If the user is trying to give an NT UserName/DomainName pair, a bug will be encountered.
        //          Url in AddressBand="xbox://DomainName\UserName:Password@ServerName/"
        //          Url passed to us="xbox://DomainName/UserName:Password@ServerName/"
        //          We need to detect this case and fix it because this will cause "DomainName" to become
        //          the server name and the rest will become the UrlPath.
        // ASSERT(!StrChr(szUrlPath, TEXT(':')) && !StrChr(szUrlPath, TEXT('@')));

        if (S_OK == UrlRemoveDownloadType(szUrlPath, NULL, &fASCII))
        {
            if (fASCII)
                dwDownloadType = (IDVALID_DLTYPE | IDVALID_DL_ASCII);
            else
                dwDownloadType = IDVALID_DLTYPE;
        }

        if (!szServer[0])
        {
            TraceMsg(TF_XBOXURL_UTILS, "CreateXboxPidlFromUrl() failed because szServer=%s", szServer);
            hr = E_FAIL;    // Bad URL so fail.
        }
        else
        {
            //TraceMsg(TF_XBOXURL_UTILS, "CreateXboxPidlFromUrl() szServer=%s, szUrlPath=%s, szUserName=%s, szPassword=%s", szServer, szUrlPath, szUserName, szPassword);
            hr = XboxServerID_Create(szServer, szUserName, szPassword, dwDownloadType, urlComps.nPort, &pidl, pm, fHidePassword);
            if (EVAL(SUCCEEDED(hr)))
            {
                ASSERT(IsValidPIDL(pidl));
                if (szUrlPath[0] && StrCmp(szUrlPath, SZ_URL_SLASH))
                {
                    LPITEMIDLIST pidlSub;

                    hr = CreateXboxPidlFromDisplayPath(szUrlPath, pwe, pcchEaten, &pidlSub, fIsTypeKnown, fIsDir);
                    if (EVAL(SUCCEEDED(hr)))
                    {
                        *ppidl = ILCombine(pidl, pidlSub);
                        if (szExtraInfo[0])
                        {
                            LPITEMIDLIST pidlFragment;
                            WIRECHAR wFragment[MAX_PATH];

                            // The code page is just whatever the user is using but oh well, I don't 
                            // care about fragments.
                            SHUnicodeToAnsi(szExtraInfo, wFragment, ARRAYSIZE(wFragment));
                            // There is a fragment, so we need to add it.
                            hr = XboxItemID_CreateFake(szExtraInfo, wFragment, TRUE, FALSE, TRUE, &pidlFragment);
                            if (EVAL(SUCCEEDED(hr)))
                            {
                                LPITEMIDLIST pidlPrevious = *ppidl;

                                *ppidl = ILCombine(pidlPrevious, pidlFragment);
                                ILFree(pidlPrevious);
                                ILFree(pidlFragment);
                            }
                        }

                        hr = *ppidl ? S_OK : E_OUTOFMEMORY;
                        ILFree(pidlSub);
                    }
                    ILFree(pidl);
                }
                else
                    *ppidl = pidl;

                if (SUCCEEDED(hr))
                {
                    ASSERT(IsValidPIDL(*ppidl));
                    if (pcchEaten)
                        *pcchEaten = lstrlen(pszUrl);      // TODO: Someday we can do this recursively.
                }
            }
        }
    }
    else
        TraceMsg(TF_XBOXURL_UTILS, "CreateXboxPidlFromUrl() failed XboxCrackUrl() because pszUrl=%s, fResult=%d, urlComps.nScheme=%d", pszUrl, fResult, urlComps.nScheme);

    //TraceMsg(TF_XBOXURL_UTILS, "CreateXboxPidlFromUrl() is returning, hr=%#08lx", hr);
    return hr;
}


/*****************************************************************************\
     FUNCTION: Win32FindDataFromPidl
 
    DESCRIPTION:
        Fill in the WIN32_FIND_DATA data structure from the info in the pidl.
\*****************************************************************************/
HRESULT Win32FindDataFromPidl(LPCITEMIDLIST pidl, LPWIN32_FIND_DATAW pwfd, BOOL fFullPath, BOOL fInDisplayFormat)
{
    HRESULT hr = E_INVALIDARG;
    LPCITEMIDLIST pidlLast = ILGetLastID(pidl);

    ASSERT(pwfd);
    if (!EVAL(XboxPidl_IsValid(pidl)))
        return E_INVALIDARG;

    // I don't want to lie when I pass out File Size and Date info.
    if ((IDVALID_FILESIZE | IDVALID_MOD_DATE) & XboxItemID_GetTypeID(pidlLast))
    {
        pwfd->nFileSizeLow = XboxItemID_GetFileSizeLo(pidlLast);
        pwfd->nFileSizeHigh = XboxItemID_GetFileSizeHi(pidlLast);
        pwfd->dwFileAttributes = XboxItemID_GetAttributes(pidlLast);

        // See the notes in priv.h on how time works.
        pwfd->ftCreationTime = XboxPidl_GetXBOXFileTime(pidlLast);
        pwfd->ftLastWriteTime = pwfd->ftCreationTime;
        pwfd->ftLastAccessTime = pwfd->ftCreationTime;

        if (fFullPath)
        {
            if (fInDisplayFormat)
                hr = GetDisplayPathFromPidl(pidl, pwfd->cFileName, ARRAYSIZE(pwfd->cFileName), FALSE);
            else
                hr = GetWirePathFromPidl(pidl, (LPWIRESTR)pwfd->cFileName, ARRAYSIZE(pwfd->cFileName), FALSE);
        }
        else
        { 
            hr = S_OK;
            if (fInDisplayFormat)
                StrCpyNW(pwfd->cFileName, XboxPidl_GetLastFileDisplayName(pidl), ARRAYSIZE(pwfd->cFileName));
            else
                StrCpyNA((LPWIRESTR)pwfd->cFileName, XboxPidl_GetLastItemWireName(pidl), ARRAYSIZE(pwfd->cFileName));
        }
    }

    return hr;
}






/****************************************************\
    XBOX Server ItemIDs
\****************************************************/

/****************************************************\
    XBOX PIDL Cooking functions
\****************************************************/

/*****************************************************************************\
    DATA STRUCTURE: XBOXIDLIST

    DESCRIPTION:
        What our private IDLIST looks like for a file, a dir, or a fragment.

    The bytes sent to an Xbox server or received from an XBOX server are
    wire bytes (could be UTF-8 or DBCS/MBCS) encoded.  We also store
    a unicode version that has already been converted after trying to guess
    the code page.

    Note that the use of any TCHAR inside an IDLIST is COMPLETELY WRONG!
    IDLISTs can be saved in a file and reloaded later.  If it were saved
    by an ANSI version of the shell extension but loaded by a UNICODE
    version, things would turn ugly real fast.
\*****************************************************************************/

/*****************************************************************************\
    XBOXSERVERIDLIST structure

    A typical full pidl looks like this:
    <Not Our ItemID> [Our ItemID]

    <The Internet>\[server,username,password,port#,downloadtype]\[subdir]\...\[file]

    The <The Internet> part is whatever the shell gives us in our
    CXboxFolder::_Initialize, telling us where in the namespace
    we are rooted.

    We are concerned only with the parts after the <The Internet> root,
    the offset to which is remembered in the CXboxFolder class
    in m_ibPidlRoot.  Ways of accessing various bits of
    information related to our full pidl are provided by our
    CXboxFolder implementation, qv.

    The first XBOX IDList entry describes the server.  The remaining
    entries describe objects (files or folders) on the server.
\*****************************************************************************/

typedef struct tagXBOXSERVERIDLIST
{
    DWORD dwIDType;                 // Server ItemID or Dir ItemID?  Which Bits are valid?
    DWORD dwVersion;                // version
    SESSIONKEY sessionKey;          // Session Key
    DWORD dwPasswordCookie;         // Password Cookie
    DWORD dwReserved1;              // for future use
    DWORD dwReserved2;              // for future use
    DWORD dwReserved3;              // for future use
    DWORD dwPortNumber;             // Port Number on server
    DWORD cchServerSize;            // StrLen of szServer
    CHAR szServer[INTERNET_MAX_HOST_NAME_LENGTH];        // Server
    DWORD cchUserNameSize;          // StrLen of szUserName
    CHAR szUserName[INTERNET_MAX_USER_NAME_LENGTH];      // User Name for Login
    DWORD cchPasswordSize;          // StrLen of szPassword
    CHAR szPassword[INTERNET_MAX_PASSWORD_LENGTH];      // Password for Login
} XBOXSERVERIDLIST;

typedef UNALIGNED XBOXSERVERIDLIST * LPXBOXSERVERIDLIST;


LPXBOXSERVERIDLIST XboxServerID_GetData(LPCITEMIDLIST pidl)
{
    LPXBOXSERVERIDLIST pXboxServerItemId = (LPXBOXSERVERIDLIST) ProtocolIdlInnerData(pidl);

    if (!XboxPidl_IsValid(pidl) || 
        !IS_VALID_SERVER_ITEMID(pXboxServerItemId->dwIDType)) // If any other bits are sit, it's invalid.
        pXboxServerItemId = NULL;

    return pXboxServerItemId;
}


LPXBOXSERVERIDLIST XboxServerID_GetDataSafe(LPCITEMIDLIST pidl)
{
    LPXBOXSERVERIDLIST pXboxServerItemId = NULL;
    
    if (EVAL(pidl) && !ILIsEmpty(pidl))
        pXboxServerItemId = (LPXBOXSERVERIDLIST) ProtocolIdlInnerData(pidl);

    return pXboxServerItemId;
}


BOOL XboxID_IsServerItemID(LPCITEMIDLIST pidl)
{
    LPXBOXSERVERIDLIST pXboxServerItemID = XboxServerID_GetDataSafe(pidl);
    BOOL fIsServerItemID = FALSE;

    if (pXboxServerItemID && IS_VALID_SERVER_ITEMID(pXboxServerItemID->dwIDType))
        fIsServerItemID = TRUE;

    return fIsServerItemID;
}


LPCITEMIDLIST XboxID_GetLastIDReferense(LPCITEMIDLIST pidl)
{
    LPCITEMIDLIST pidlCurrent = pidl;
    LPCITEMIDLIST pidlNext = pidl;

    if (!pidl || ILIsEmpty(pidl))
        return pidl;

    for (; !ILIsEmpty(pidlNext); pidl = _ILNext(pidl))
    {
        pidlCurrent = pidlNext;
        pidlNext = _ILNext(pidlNext);
    }

    return pidlCurrent;
}


CCookieList * g_pCookieList = NULL;

CCookieList * GetCookieList(void)
{
    ENTERCRITICAL;
    if (!g_pCookieList)
        g_pCookieList = new CCookieList();
    ASSERT(g_pCookieList);
    LEAVECRITICAL;

    return g_pCookieList;
}

SESSIONKEY g_SessionKey = {-1, -1};

HRESULT PurgeSessionKey(void)
{
    GetSystemTimeAsFileTime(&g_SessionKey);

    return S_OK;
}

SESSIONKEY GetSessionKey(void)
{    
    if (-1 == g_SessionKey.dwHighDateTime)
        PurgeSessionKey();
    
    return g_SessionKey;
}

BOOL AreSessionKeysEqual(SESSIONKEY sk1, SESSIONKEY sk2)
{
    if ((sk1.dwHighDateTime == sk2.dwHighDateTime) &&
        (sk1.dwLowDateTime == sk2.dwLowDateTime))
    {
        return TRUE;
    }

    return FALSE;
}

// This is used in order to make sure Alpha machines don't get DWORD mis-aligned.
#define LENGTH_AFTER_ALIGN(nLen, nAlignSize)        (((nLen) % (nAlignSize)) ? ((nLen) + ((nAlignSize) - ((nLen) % (nAlignSize)))) : (nLen))

/****************************************************\
    FUNCTION: XboxServerID_Create

    DESCRIPTION:
        Create a Xbox Server ItemID and fill it in.
\****************************************************/
HRESULT XboxServerID_Create(LPCTSTR pszServer, LPCTSTR pszUserName, LPCTSTR pszPassword, 
                     DWORD dwFlags, INTERNET_PORT ipPortNum, LPITEMIDLIST * ppidl, IMalloc *pm, BOOL fHidePassword)
{
    HRESULT hr;
    DWORD cb;
    LPITEMIDLIST pidl;
    LPXBOXSERVERIDLIST pXboxServerID = NULL;
    DWORD cchServerLen = lstrlen(pszServer);
    DWORD cchUserNameLen = lstrlen(pszUserName);
    DWORD cchPasswordLen = lstrlen(pszPassword);

    cchServerLen = LENGTH_AFTER_ALIGN(cchServerLen + 1, sizeof(DWORD));
    cchUserNameLen = LENGTH_AFTER_ALIGN(cchUserNameLen + 1, sizeof(DWORD));
    cchPasswordLen = LENGTH_AFTER_ALIGN(cchPasswordLen + 1, sizeof(DWORD));

    if (!(EVAL(ppidl) && pszServer[0]))
        return E_FAIL;

    // Set bits in dwFlags that are appropriate
    if (pszUserName[0])
        dwFlags |= IDVALID_USERNAME;

    if (pszPassword[0])
        dwFlags |= IDVALID_PASSWORD;

    // Find lenght of XBOXSERVERIDLIST struct without the MAX_PATH strings
    cb = (sizeof(*pXboxServerID) - sizeof(pXboxServerID->szServer) - sizeof(pXboxServerID->szUserName) - sizeof(pXboxServerID->szPassword));

    // Add the size of the strings.
    cb += (cchServerLen + cchUserNameLen + cchPasswordLen);

    ASSERT(0 == (cb % sizeof(DWORD)));  // Make sure it's DWORD aligned for Alpha machines.

    pidl = (LPITEMIDLIST) pm->Alloc(cb);
    if (pidl)
    {
        LPSTR pszNext;

        pXboxServerID = XboxServerID_GetDataSafe(pidl);
        pszNext = pXboxServerID->szServer;

        ZeroMemory(pXboxServerID, cb);
        pXboxServerID->dwIDType = (dwFlags | IDTYPE_ISVALID | IDTYPE_SERVER | IDVALID_PORT_NUM);
        ASSERT(IS_VALID_SERVER_ITEMID(pXboxServerID->dwIDType));

        pXboxServerID->dwVersion = PIDL_VERSION_NUMBER;
        pXboxServerID->sessionKey = GetSessionKey();
        pXboxServerID->dwPasswordCookie = -1;
        pXboxServerID->dwPortNumber = ipPortNum;

        pXboxServerID->cchServerSize = cchServerLen;
        SHTCharToAnsi(pszServer, pszNext, pXboxServerID->cchServerSize);

        pszNext += cchServerLen; // Advance to cchUserNameSize
        *((LPDWORD) pszNext) = cchUserNameLen;  // Fill in cchUserNameSize
        pszNext = (LPSTR)(((BYTE *) pszNext) + sizeof(DWORD)); // Advance to szUserName
        SHTCharToAnsi(pszUserName, pszNext, cchUserNameLen);  // Fill in szUserName

        if (fHidePassword)
        {
            pXboxServerID->dwIDType |= IDVALID_HIDE_PASSWORD;
            if (EVAL(GetCookieList()))
                pXboxServerID->dwPasswordCookie = GetCookieList()->GetCookie(pszPassword);

            ASSERT(-1 != pXboxServerID->dwPasswordCookie);
            pszPassword = TEXT("");
        }

//        TraceMsg(TF_XBOXURL_UTILS, "XboxServerID_Create(\"xbox://%s:%s@%s/\") dwIDType=%#80lx", pszUserName, pszPassword, pszServer, pXboxServerID->dwIDType);
        pszNext += cchUserNameLen; // Advance to cchPasswordLen
        *((LPDWORD) pszNext) = cchPasswordLen;  // Fill in cchPasswordLen
        pszNext = (LPSTR)(((BYTE *) pszNext) + sizeof(DWORD)); // Advance to szPassword
        SHTCharToAnsi(pszPassword, pszNext, cchPasswordLen);  // Fill in pszPassword
    }

    *ppidl = pidl;
    hr = pidl ? S_OK : E_OUTOFMEMORY;
    ASSERT(IsValidPIDL(*ppidl));

    return hr;
}


DWORD XboxServerID_GetTypeID(LPCITEMIDLIST pidl)
{
    LPXBOXSERVERIDLIST pXboxServerID = XboxServerID_GetData(pidl);

    ASSERT(XboxID_IsServerItemID(pidl));
    if (EVAL(pXboxServerID) && 
        EVAL(XboxPidl_IsValid(pidl)))
        return pXboxServerID->dwIDType;

    return 0;
}


HRESULT XboxServerID_GetServer(LPCITEMIDLIST pidl, LPTSTR pszServer, DWORD cchSize)
{
    HRESULT hr = S_OK;
    LPXBOXSERVERIDLIST pXboxServerID = XboxServerID_GetData(pidl);

    if (pXboxServerID)
        SHAnsiToTChar(pXboxServerID->szServer, pszServer, cchSize);
    else
        hr = E_FAIL;

    return hr;
}


BOOL XboxServerID_ServerStrCmp(LPCITEMIDLIST pidl, LPCTSTR pszServer)
{
    BOOL fMatch = FALSE;
    LPXBOXSERVERIDLIST pXboxServerID = XboxServerID_GetData(pidl);
#ifdef UNICODE
    CHAR szServerAnsi[MAX_PATH];

    SHUnicodeToAnsi(pszServer, szServerAnsi, ARRAYSIZE(szServerAnsi));
#endif // UNICODE

    if (pXboxServerID)
    {
#ifdef UNICODE
        fMatch = (0 == StrCmpA(pXboxServerID->szServer, szServerAnsi));
#else // UNICODE
        fMatch = (0 == StrCmpA(pXboxServerID->szServer, pszServer));
#endif // UNICODE
    }

    return fMatch;
}


HRESULT XboxServerID_GetUserName(LPCITEMIDLIST pidl, LPTSTR pszUserName, DWORD cchSize)
{
    HRESULT hr = E_FAIL;
    LPXBOXSERVERIDLIST pXboxServerID = XboxServerID_GetData(pidl);

    if (EVAL(pXboxServerID))
    {
        LPCSTR pszSourceUserName = pXboxServerID->szServer + pXboxServerID->cchServerSize + sizeof(DWORD);

        SHAnsiToTChar(pszSourceUserName, pszUserName, cchSize);
        hr = S_OK;
    }

    return hr;
}

HRESULT XboxServerID_GetPassword(LPCITEMIDLIST pidl, LPTSTR pszPassword, DWORD cchSize, BOOL fIncludingHiddenPassword)
{
    HRESULT hr = E_FAIL;
    LPXBOXSERVERIDLIST pXboxServerID = XboxServerID_GetData(pidl);

    pszPassword[0] = 0;
    if (EVAL(pXboxServerID))
    {
        // Was the password hidden?
        if (fIncludingHiddenPassword &&
            (IDVALID_HIDE_PASSWORD & pXboxServerID->dwIDType))
        {
            // Yes, so get it out of the cookie jar (list)
            if (EVAL(GetCookieList()) &&
                AreSessionKeysEqual(pXboxServerID->sessionKey, GetSessionKey()))
            {
                hr = GetCookieList()->GetString(pXboxServerID->dwPasswordCookie, pszPassword, cchSize);
            }
        }
        else
        {
            // No, so what's in the pidl is the real password.
            BYTE * pvSizeOfUserName = (BYTE *) (pXboxServerID->szServer + pXboxServerID->cchServerSize);
            DWORD dwSizeOfUserName = *(DWORD *) pvSizeOfUserName;
            LPCSTR pszSourcePassword = (LPCSTR) (pvSizeOfUserName + dwSizeOfUserName + 2*sizeof(DWORD));

            SHAnsiToTChar(pszSourcePassword, pszPassword, cchSize);
            hr = S_OK;
        }
    }

    return hr;
}

INTERNET_PORT XboxServerID_GetPortNum(LPCITEMIDLIST pidl)
{
    LPXBOXSERVERIDLIST pXboxServerID = XboxServerID_GetData(pidl);

    ASSERT(XboxID_IsServerItemID(pidl));
    if (EVAL(pXboxServerID))
        return (INTERNET_PORT)pXboxServerID->dwPortNumber;

    return INTERNET_DEFAULT_FTP_PORT;
}


HRESULT XboxServerID_SetHiddenPassword(LPITEMIDLIST pidl, LPCTSTR pszPassword)
{
    HRESULT hr = E_INVALIDARG;
    LPXBOXSERVERIDLIST pXboxServerID = XboxServerID_GetData(pidl);

    ASSERT(XboxID_IsServerItemID(pidl));
    if (EVAL(pXboxServerID))
    {
        pXboxServerID->sessionKey = GetSessionKey();
        pXboxServerID->dwIDType |= IDVALID_HIDE_PASSWORD;
        if (EVAL(GetCookieList()))
            pXboxServerID->dwPasswordCookie = GetCookieList()->GetCookie(pszPassword);
        hr = S_OK;
    }

    return hr;
}


HRESULT XboxServerID_GetStrRet(LPCITEMIDLIST pidl, LPSTRRET lpName)
{
    LPXBOXSERVERIDLIST pXboxServerID = XboxServerID_GetData(pidl);

    ASSERT(XboxID_IsServerItemID(pidl));
    if (pXboxServerID)
    {
        lpName->uType = STRRET_OFFSET;
        lpName->uOffset = (DWORD) (sizeof(XBOXSERVERIDLIST) - sizeof(pXboxServerID->szServer) + (LPBYTE)pXboxServerID - (LPBYTE)pidl);
    }
    else
    {
        lpName->uType = STRRET_CSTR;
        lpName->cStr[0] = '\0';
    }

    return S_OK;
}





/****************************************************\
    XBOX File/Dir ItemIDs
\****************************************************/

typedef struct tagXBOXIDLIST
{
    DWORD dwIDType;         // Server ItemID or Dir ItemID?  Which Bits are valid?
    DWORD dwAttributes;     // What are the file/dir attributes
    ULARGE_INTEGER uliFileSize;
    FILETIME ftModified;    // Stored in Local Time Zone. (XBOX Time)
    DWORD dwUNIXPermission; // UNIX CHMOD Permissions (0x00000777, 4=Read, 2=Write, 1=Exec, <Owner><Group><All>)
    DWORD dwReserved2;              // for future use
    WIRECHAR szWireName[MAX_PATH];          // Needs to go last.
    WCHAR wzDisplayName[MAX_PATH];  // Converted to unicode to be displayed in the UI.
} XBOXIDLIST;

typedef UNALIGNED XBOXIDLIST * LPXBOXIDLIST;

HRESULT XboxItemID_Alloc(LPXBOXIDLIST pfi, LPITEMIDLIST * ppidl);


typedef struct _XBOXIDLIST_WITHHEADER
{
    USHORT  cb;             // size
    XBOXIDLIST fidListData;
    USHORT  cbTerminator;   // size of next ID (Empty)
} XBOXIDLIST_WITHHEADER;



LPXBOXIDLIST XboxItemID_GetData(LPCITEMIDLIST pidl)
{
    BYTE * pbData = (BYTE *) pidl;

    pbData += SIZE_ITEMID_SIZEFIELD;      // Skip over the size.
    LPXBOXIDLIST pXboxItemId = (LPXBOXIDLIST) pbData;

    if (!EVAL(IS_VALID_DIRORFILE_ITEMID(pXboxItemId->dwIDType))) // If any other bits are sit, it's invalid.
        pXboxItemId = NULL;

    return pXboxItemId;
}

LPCWSTR XboxItemID_GetDisplayNameReference(LPCITEMIDLIST pidl)
{
    BYTE * pbData = (BYTE *) pidl;
    LPCWSTR pwzDisplayName = NULL;
    DWORD cbWireName;

    // Is the version OK?
//    if (PIDL_VERSION_NUMBER > XboxPidl_GetVersion(pidl))
//        return NULL;

    pbData += SIZE_ITEMID_SIZEFIELD;      // Skip over the size.
    LPXBOXIDLIST pXboxItemId = (LPXBOXIDLIST) pbData;

    cbWireName = LENGTH_AFTER_ALIGN((lstrlenA(pXboxItemId->szWireName) + 1), sizeof(DWORD));
    pwzDisplayName = (LPCWSTR) ((BYTE *)(&pXboxItemId->szWireName[0]) + cbWireName);

    if (!EVAL(IS_VALID_DIRORFILE_ITEMID(pXboxItemId->dwIDType))) // If any other bits are sit, it's invalid.
        pwzDisplayName = NULL;

    return pwzDisplayName;
}

DWORD XboxItemID_GetTypeID(LPCITEMIDLIST pidl)
{
    LPXBOXIDLIST pXboxItemId = XboxItemID_GetData(pidl);

    return (pXboxItemId ? pXboxItemId->dwIDType : 0);
}


void XboxItemID_SetTypeID(LPITEMIDLIST pidl, DWORD dwNewTypeID)
{
    LPXBOXIDLIST pXboxItemId = XboxItemID_GetData(pidl);
    ASSERT(pXboxItemId);
    pXboxItemId->dwIDType = dwNewTypeID;
}


/****************************************************\
    FUNCTION: XboxItemID_Alloc

    DESCRIPTION:
        We are passed a pointer to a XBOXIDLIST data
    structure and our goal is to create a ItemID from
    it.  This mainly includes making it only big enough
    for the current string(s).
\****************************************************/
HRESULT XboxItemID_Alloc(LPXBOXIDLIST pfi, LPITEMIDLIST * ppidl)
{
    HRESULT hr;
    WORD cbTotal;
    WORD cbDataFirst;
    WORD cbData;
    BYTE * pbMemory;
    DWORD cchSizeOfName = lstrlenA(pfi->szWireName);
    DWORD cchSizeOfDispName = lstrlenW(pfi->wzDisplayName);

    ASSERT(pfi && ppidl);

    // Find lenght of XBOXIDLIST struct if the szName member only needed enought room
    // for the string, not the full MAX_PATH.
    // Size EQUALS: (Everything in the struct) - (the 2 full statusly sized strings) + (the 2 packed strings + alignment)
    cbDataFirst = (WORD)((sizeof(*pfi) - sizeof(pfi->szWireName) - sizeof(pfi->wzDisplayName)) + LENGTH_AFTER_ALIGN(cchSizeOfName + 1, sizeof(DWORD)) - sizeof(DWORD));
    cbData = cbDataFirst + (WORD) LENGTH_AFTER_ALIGN((cchSizeOfDispName + 1) * sizeof(WCHAR), sizeof(DWORD));

    ASSERT((cbData % sizeof(DWORD)) == 0);  // Verify it's DWORD aligned.
    cbTotal = (SIZE_ITEMID_SIZEFIELD + cbData + SIZE_ITEMID_TERMINATOR);

    pbMemory = (BYTE *) CoTaskMemAlloc(cbTotal);
    if (EVAL(pbMemory))
    {
        USHORT * pIDSize = (USHORT *)pbMemory;
        BYTE * pbData = (pbMemory + SIZE_ITEMID_SIZEFIELD);        // the Data starts at the second DWORD.
        USHORT * pIDTerminator = (USHORT *)(pbMemory + SIZE_ITEMID_SIZEFIELD + cbData);

        pIDSize[0] = (cbTotal - SIZE_ITEMID_TERMINATOR);      // Set the size of the ItemID (including the next ItemID as terminator)
        ASSERT(cbData <= sizeof(*pfi)); // Don't let me copy too much.
        CopyMemory(pbData, pfi, cbDataFirst);
        CopyMemory((pbData + cbDataFirst), &(pfi->wzDisplayName), ((cchSizeOfDispName + 1) * sizeof(WCHAR)));
        pIDTerminator[0] = 0;  // Terminate the next ID.

//        TraceMsg(TF_XBOXURL_UTILS, "XboxItemID_Alloc(\"%ls\") dwIDType=%#08lx, dwAttributes=%#08lx", pfi->wzDisplayName, pfi->dwIDType, pfi->dwAttributes);
    }

    *ppidl = (LPITEMIDLIST) pbMemory;
    hr = pbMemory ? S_OK : E_OUTOFMEMORY;

    ASSERT(IsValidPIDL(*ppidl));
    ASSERT_POINTER_MATCHES_HRESULT(*ppidl, hr);

    return hr;
}


/*****************************************************************************\
    FUNCTION: XboxItemID_CreateReal

    DESCRIPTION:
        Cook up a pidl based on a WIN32_FIND_DATA.

    The cFileName field is itself MAX_PATH characters long,
    so its length cannot possibly exceed MAX_PATH...
\*****************************************************************************/
HRESULT XboxItemID_CreateReal(const LPXBOX_FIND_DATA pwfd, LPCWSTR pwzDisplayName, LPITEMIDLIST * ppidl)
{
    HRESULT hr;
    XBOXIDLIST fi = {0};

    // Fill in fi.
    fi.dwIDType = (IDTYPE_ISVALID | IDVALID_FILESIZE | IDVALID_MOD_DATE);
    fi.uliFileSize.LowPart = pwfd->nFileSizeLow;
    fi.uliFileSize.HighPart = pwfd->nFileSizeHigh;
    fi.ftModified = pwfd->ftLastWriteTime;
    fi.dwAttributes = pwfd->dwFileAttributes;
    fi.dwUNIXPermission = pwfd->dwReserved0;    // Set by WININET
    StrCpyNA(fi.szWireName, pwfd->cFileName, ARRAYSIZE(fi.szWireName));
    StrCpyN(fi.wzDisplayName, pwzDisplayName, ARRAYSIZE(fi.wzDisplayName));

    if (pwfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        fi.dwIDType |= IDTYPE_DIR;
    else
        fi.dwIDType |= IDTYPE_FILE;

    hr = XboxItemID_Alloc(&fi, ppidl);
    ASSERT(IsValidPIDL(*ppidl));

    return hr;
}


/****************************************************\
    FUNCTION: XboxItemID_CreateFake

    DESCRIPTION:
        Create a ItemID but we are only setting the
    name.  We don't know the true file attributes,
    file size, or modification date yet because
    we haven't touched the server yet.  If we did,
    we would use the returned WIN32_FIND_DATA struct
    to create the ItemID by using XboxItemID_CreateReal().
\****************************************************/
HRESULT XboxItemID_CreateFake(LPCWSTR pwzDisplayName, LPCWIRESTR pwWireName, BOOL fTypeKnown, BOOL fIsFile, BOOL fIsFragment, LPITEMIDLIST * ppidl)
{
    HRESULT hr;
    DWORD dwType = IDTYPE_ISVALID;
    XBOXIDLIST fi = {0};

    // Is it unknown?
    if (!fTypeKnown)
    {
        // HACK: We will assume everything w/o a file extension is a Dir
        //    and everything w/an extension is a file.
        fTypeKnown = TRUE;
        fIsFile = (0 != *PathFindExtension(pwzDisplayName)) ? TRUE : FALSE;
    }
    if (fTypeKnown)
    {
        if (fIsFile)
            dwType |= IDTYPE_FILE;
        else if (fIsFragment)
            dwType |= IDTYPE_FRAGMENT;
        else
            dwType |= IDTYPE_DIR;
    }
    else
    {
        // You need to know if it's a fragment because there is no
        // heuristic to find out.
        ASSERT(!fIsFragment);

        dwType |= IDTYPE_FILEORDIR;
    }

    fi.dwIDType = dwType;
    fi.dwAttributes = (fIsFile ? FILE_ATTRIBUTE_NORMAL : FILE_ATTRIBUTE_NORMAL|FILE_ATTRIBUTE_DIRECTORY);
    fi.uliFileSize.QuadPart = 0;
    StrCpyNW(fi.wzDisplayName, pwzDisplayName, ARRAYSIZE(fi.wzDisplayName));
    StrCpyNA(fi.szWireName, pwWireName, ARRAYSIZE(fi.szWireName));

    hr = XboxItemID_Alloc(&fi, ppidl);
    ASSERT(IsValidPIDL(*ppidl));
    ASSERT_POINTER_MATCHES_HRESULT(*ppidl, hr);

    return hr;
}


/*****************************************************************************\
    FUNCTION: XboxItemID_SetName

    DESCRIPTION:
        The user chose a new name for the Xbox file or dir (in unicode).  We
    now need to create the name in wire bytes and we will use the original
    wire byte name to decide how to do that (from pidl).
\*****************************************************************************/
HRESULT XboxItemID_CreateWithNewName(LPCITEMIDLIST pidl, LPCWSTR pwzDisplayName, LPCWIRESTR pwWireName, LPITEMIDLIST * ppidlOut)
{
    HRESULT hr;
    XBOXIDLIST fi;
    const XBOXIDLIST * pfi = XboxItemID_GetData(pidl);
    CWireEncoding cWireEncoding;

    CopyMemory(&fi, pfi, sizeof(XBOXIDLIST) - sizeof(fi.szWireName) - sizeof(fi.wzDisplayName));
    StrCpyNW(fi.wzDisplayName, pwzDisplayName, ARRAYSIZE(fi.wzDisplayName));
    StrCpyNA(fi.szWireName, pwWireName, ARRAYSIZE(fi.szWireName));

    hr = XboxItemID_Alloc(&fi, ppidlOut);
    ASSERT(IsValidPIDL(*ppidlOut));

    return hr;
}


HRESULT Private_GetFileInfo(SHFILEINFO *psfi, DWORD rgf, LPCTSTR pszName, DWORD dwFileAttributes)
{
    HRESULT hr = E_FAIL;

    if (SHGetFileInfo(pszName, dwFileAttributes, psfi, sizeof(*psfi), rgf | SHGFI_USEFILEATTRIBUTES))
        hr = S_OK;

    return hr;
}


/*****************************************************************************\
    FUNCTION: XboxPidl_GetFileInfo

    DESCRIPTION:
        _UNDOCUMENTED_:  We strip the Hidden and System bits so
    that SHGetFileInfo won't think that we're passing something
    that might be a junction.

    We also force the SHGFI_USEFILEATTRIBUTES bit to remind the shell
    that this isn't a file.
\*****************************************************************************/
HRESULT XboxPidl_GetFileInfo(LPCITEMIDLIST pidl, SHFILEINFO *psfi, DWORD rgf)
{
    HRESULT hr;
    TCHAR szDisplayName[MAX_PATH];

    psfi->iIcon = 0;
    psfi->hIcon = NULL;
    psfi->dwAttributes = 0;
    psfi->szDisplayName[0] = 0;
    psfi->szTypeName[0] = 0;

    ASSERT(IsValidPIDL(pidl));
    if (XboxID_IsServerItemID(pidl))
    {
        XboxServerID_GetServer(pidl, szDisplayName, ARRAYSIZE(szDisplayName));
        hr = Private_GetFileInfo(psfi, rgf, szDisplayName, FILE_ATTRIBUTE_DIRECTORY);
        if (psfi->hIcon)
            DestroyIcon(psfi->hIcon);

        psfi->hIcon = LoadIcon(HINST_THISDLL, MAKEINTRESOURCE(IDI_XBOXFOLDER));
        ASSERT(psfi->hIcon);

        // Now replace the type (szTypeName) with "XBOX Server" because
        // it could go in the Properties dialog
        EVAL(LoadString(HINST_THISDLL, IDS_ITEMTYPE_SERVER, psfi->szTypeName, ARRAYSIZE(psfi->szTypeName)));
    }
    else
    {
        LPXBOXIDLIST pfi = XboxItemID_GetData(pidl);
        XboxItemID_GetDisplayName(pidl, szDisplayName, ARRAYSIZE(szDisplayName));
        hr = Private_GetFileInfo(psfi, rgf, szDisplayName, (pfi->dwAttributes & ~(FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM)));
    }

    return hr;
}

HRESULT XboxPidl_GetFileType(LPCITEMIDLIST pidl, LPTSTR pszType, DWORD cchSize)
{
    SHFILEINFO sfi;
    HRESULT hr;

    ASSERT(IsValidPIDL(pidl));
    hr = XboxPidl_GetFileInfo(pidl, &sfi, SHGFI_TYPENAME);
    if (EVAL(SUCCEEDED(hr)))
    {
        StrCpyN(pszType, sfi.szTypeName, cchSize);
        if (sfi.hIcon)
            DestroyIcon(sfi.hIcon);
    }

    return hr;
}


HRESULT XboxPidl_GetFileTypeStrRet(LPCITEMIDLIST pidl, LPSTRRET pstr)
{
    WCHAR szType[MAX_URL_STRING];
    HRESULT hr;

    ASSERT(IsValidPIDL(pidl));
    hr = XboxPidl_GetFileType(pidl, szType, ARRAYSIZE(szType));
    if (EVAL(SUCCEEDED(hr)))
        StringToStrRetW(szType, pstr);

    return hr;
}


/*****************************************************************************\
    FUNCTION: _XboxItemID_CompareOneID

    DESCRIPTION:
        ici - attribute (column) to compare

    Note! that UNIX filenames are case-*sensitive*.

    We make two passes on the name.  If the names are different in other
    than case, we return the result of that comparison.  Otherwise,
    we return the result of a case-sensitive comparison.

    This algorithm ensures that the items sort themselves in a
    case-insensitive way, with ties broken by a case-sensitive
    comparison.  This makes Xbox folders act "mostly" like normal
    folders.

    _UNDOCUMENTED_: The documentation says that the ici parameter
    is undefined and must be zero.  In reality, it is the column
    number (defined by IShellView) for which the comparison is to
    be made.
\*****************************************************************************/
HRESULT _XboxItemID_CompareOneID(LPARAM ici, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, DWORD dwCompFlags)
{
    int iRc = 0;    // 0 means we don't know.
    HRESULT hr = S_OK;

    ASSERT(IsValidPIDL(pidl1));
    ASSERT(IsValidPIDL(pidl2));

    // Are they both the same type? (Both Dirs or both files?)
    if (!(dwCompFlags & FCMP_GROUPDIRS) || (!XboxPidl_IsDirectory(pidl1, FALSE) == !XboxPidl_IsDirectory(pidl2, FALSE)))
    {
        switch (ici & SHCIDS_COLUMNMASK)
        {
        case COL_NAME:
        {
            // Yes they are the same, so we will key off the name...
            WIRECHAR szName1[MAX_PATH];
            WIRECHAR szName2[MAX_PATH];

            szName1[0] = TEXT('\0');
            szName2[0] = TEXT('\0');

            XboxPidl_GetWireName(pidl1, szName1, ARRAYSIZE(szName1));
            XboxPidl_GetWireName(pidl2, szName2, ARRAYSIZE(szName2));

            iRc = StrCmpIA(szName1, szName2);
            if (0 == iRc)
            {
                if (!(dwCompFlags & FCMP_CASEINSENSE))
                    iRc = StrCmpA(szName1, szName2);

/*
                // They are the same name, so now lets check on the username
                // if they are Server IDs.
                if ((0 == iRc) && (XboxID_IsServerItemID(pidl1)))
                {
                    XboxPidl_GetUserName(pidl1, szName1, ARRAYSIZE(szName1));
                    XboxPidl_GetUserName(pidl2, szName2, ARRAYSIZE(szName2));
                    iRc = StrCmp(szName1, szName2);
                }
*/
            }
        }
        break;

        case COL_SIZE:
            if (XboxPidl_GetFileSize(pidl1) < XboxPidl_GetFileSize(pidl2))
                iRc = -1;
            else if (XboxPidl_GetFileSize(pidl1) > XboxPidl_GetFileSize(pidl2))
                iRc = +1;
            else
                iRc = 0;        // I don't know
            break;

        case COL_TYPE:
            if (!XboxID_IsServerItemID(pidl1) && !XboxID_IsServerItemID(pidl2))
            {
                TCHAR szType1[MAX_PATH];

                hr = XboxPidl_GetFileType(pidl1, szType1, ARRAYSIZE(szType1));
                if (EVAL(SUCCEEDED(hr)))
                {
                    TCHAR szType2[MAX_PATH];
                    hr = XboxPidl_GetFileType(pidl2, szType2, ARRAYSIZE(szType2));
                    if (EVAL(SUCCEEDED(hr)))
                        iRc = StrCmpI(szType1, szType2);
                }
            }
            break;

        case COL_MODIFIED:
        {
            FILETIME ft1 = XboxPidl_GetFileTime(pidl1);
            FILETIME ft2 = XboxPidl_GetFileTime(pidl2);
            iRc = CompareFileTime(&ft1, &ft2);
        }
            break;

        default:
            hr = E_NOTIMPL;
            break;
        }
    }
    else
    {
        // No they are different.  We want the Folder to always come first.
        // This doesn't seam right, but it forces folders to bubble to the top
        // in the most frequent case and it matches DefView's Behavior.
        if (XboxPidl_IsDirectory(pidl1, FALSE))
            iRc = -1;
        else
            iRc = 1;
    }

    if (EVAL(S_OK == hr))
        hr = HRESULT_FROM_SUCCESS_VALUE(iRc);   // encode the sort value in the return code.

    return hr;
}


/*****************************************************************************\
    FUNCTION: XboxItemID_CompareIDs
    
    DESCRIPTION:
        ici - attribute (column) to compare

    Note! that we rely on the fact that IShellFolders are
    uniform; we do not need to bind to the shell folder in
    order to compare its sub-itemids.

    _UNDOCUMENTED_: The documentation does not say whether or not
    complex pidls can be received.  In fact, they can.

    The reason why the shell asks you to handle complex pidls
    is that you can often short-circuit the comparison by walking
    the ID list directly.  (Formally speaking, you need to bind
    to each ID and then call yourself recursively.  But if your
    pidls are uniform, you can just use a loop like the one below.)
\*****************************************************************************/
HRESULT XboxItemID_CompareIDs(LPARAM ici, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, DWORD dwCompFlags)
{
    HRESULT hr;

    if (!pidl1 || ILIsEmpty(pidl1))
    {
        if (!pidl2 || ILIsEmpty(pidl2))
            hr = HRESULT_FROM_SUCCESS_VALUE(0);        // Both ID lists are empty
        else
            hr = HRESULT_FROM_SUCCESS_VALUE(-1);        // pidl1 is empty, pidl2 is nonempty
    }
    else
    {
        if (!pidl2 || ILIsEmpty(pidl2))
            hr = HRESULT_FROM_SUCCESS_VALUE(1);     // pidl1 is nonempty, pidl2 is empty
        else
        {
            ASSERT(IsValidPIDL(pidl1));
            ASSERT(IsValidPIDL(pidl2));
            hr = _XboxItemID_CompareOneID(ici, pidl1, pidl2, dwCompFlags);    // both are nonempty
        }
    }

    // If this level of ItemsIDs are equal, then we will compare the next
    // level of ItemIDs
    if ((hr == HRESULT_FROM_SUCCESS_VALUE(0)) && pidl1 && !ILIsEmpty(pidl1))
        hr = XboxItemID_CompareIDs(ici, _ILNext(pidl1), _ILNext(pidl2), dwCompFlags);

    return hr;
}


int XboxItemID_CompareIDsInt(LPARAM ici, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, DWORD dwCompFlags)
{
    HRESULT hr = XboxItemID_CompareIDs(ici, pidl1, pidl2, dwCompFlags);
    int nResult = (DWORD)(short)hr;

    return nResult;
}

DWORD XboxItemID_GetAttributes(LPCITEMIDLIST pidl)
{
    LPXBOXIDLIST pXboxIDList = XboxItemID_GetData(pidl);

    if (!EVAL(pXboxIDList))
        return NULL;

    return pXboxIDList->dwAttributes;
}

HRESULT XboxItemID_SetAttributes(LPCITEMIDLIST pidl, DWORD dwAttribs)
{
    LPXBOXIDLIST pXboxIDList = XboxItemID_GetData(pidl);

    if (!EVAL(pXboxIDList))
        return E_INVALIDARG;

    pXboxIDList->dwAttributes = dwAttribs;
    return S_OK;
}


DWORD XboxItemID_GetUNIXPermissions(LPCITEMIDLIST pidl)
{
    LPXBOXIDLIST pXboxIDList = XboxItemID_GetData(pidl);

    if (!EVAL(pXboxIDList))
        return NULL;

    return pXboxIDList->dwUNIXPermission;
}


HRESULT XboxItemID_SetUNIXPermissions(LPCITEMIDLIST pidl, DWORD dwUNIXPermission)
{
    LPXBOXIDLIST pXboxIDList = XboxItemID_GetData(pidl);

    if (!EVAL(pXboxIDList))
        return E_INVALIDARG;

    pXboxIDList->dwUNIXPermission = dwUNIXPermission;
    return S_OK;
}


ULONGLONG XboxItemID_GetFileSize(LPCITEMIDLIST pidl)
{
    LPXBOXIDLIST pXboxIDList = XboxItemID_GetData(pidl);

    if (!EVAL(pXboxIDList))
        return NULL;


    ASSERT(IsFlagSet(pXboxIDList->dwIDType, IDVALID_FILESIZE));
    return pXboxIDList->uliFileSize.QuadPart;
}

void XboxItemID_SetFileSize(LPCITEMIDLIST pidl, ULARGE_INTEGER uliFileSize)
{
    LPXBOXIDLIST pXboxIDList = XboxItemID_GetData(pidl);

    if (!EVAL(pXboxIDList))
        return;

    pXboxIDList->uliFileSize = uliFileSize;
    pXboxIDList->dwIDType |= IDVALID_FILESIZE;
}

DWORD XboxItemID_GetFileSizeLo(LPCITEMIDLIST pidl)
{
    LPXBOXIDLIST pXboxIDList = XboxItemID_GetData(pidl);

    if (!EVAL(pXboxIDList))
        return NULL;

    ASSERT(IsFlagSet(pXboxIDList->dwIDType, IDVALID_FILESIZE));
    return pXboxIDList->uliFileSize.LowPart;
}

DWORD XboxItemID_GetFileSizeHi(LPCITEMIDLIST pidl)
{
    LPXBOXIDLIST pXboxIDList = XboxItemID_GetData(pidl);

    if (!EVAL(pXboxIDList))
        return NULL;

    ASSERT(IsFlagSet(pXboxIDList->dwIDType, IDVALID_FILESIZE));
    return pXboxIDList->uliFileSize.HighPart;
}


// Return value is in Local Time Zone.
FILETIME XboxItemID_GetFileTime(LPCITEMIDLIST pidl)
{
    LPXBOXIDLIST pXboxIDList = XboxItemID_GetData(pidl);

    if (!EVAL(pXboxIDList))
    {
        FILETIME ftEmpty = {0};
        return ftEmpty;
    }

    ASSERT(IsFlagSet(pXboxIDList->dwIDType, IDVALID_MOD_DATE));
    return pXboxIDList->ftModified;
}


LPCWIRESTR XboxItemID_GetWireNameReference(LPCITEMIDLIST pidl)
{
    LPXBOXIDLIST pXboxIDList = XboxItemID_GetData(pidl);

    if (!EVAL(pXboxIDList) || IS_FRAGMENT(pXboxIDList))
        return NULL;

    return pXboxIDList->szWireName;
}


HRESULT XboxItemID_GetDisplayName(LPCITEMIDLIST pidl, LPWSTR pwzName, DWORD cchSize)
{
    HRESULT hr = S_OK;
    LPXBOXIDLIST pXboxIDList = XboxItemID_GetData(pidl);

    if (pXboxIDList && !IS_FRAGMENT(pXboxIDList))
    {
        // The display name wasn't stored in v3
        StrCpyN(pwzName, XboxItemID_GetDisplayNameReference(pidl), cchSize);
    }
    else 
    {
        pwzName[0] = TEXT('\0');
        hr = E_FAIL;
    }

    return hr;
}


HRESULT XboxItemID_GetWireName(LPCITEMIDLIST pidl, LPWIRESTR pszName, DWORD cchSize)
{
    HRESULT hr = S_OK;
    LPXBOXIDLIST pXboxIDList = XboxItemID_GetData(pidl);

    if (pXboxIDList && !IS_FRAGMENT(pXboxIDList))
        StrCpyNA(pszName, pXboxIDList->szWireName, cchSize);
    else 
    {
        pszName[0] = TEXT('\0');
        hr = E_FAIL;
    }

    return hr;
}


HRESULT XboxItemID_GetFragment(LPCITEMIDLIST pidl, LPWSTR pwzFragmentStr, DWORD cchSize)
{
    HRESULT hr = S_OK;
    LPXBOXIDLIST pXboxIDList = XboxItemID_GetData(pidl);

    if (pXboxIDList && IS_FRAGMENT(pXboxIDList))
        StrCpyNW(pwzFragmentStr, XboxItemID_GetDisplayNameReference(pidl), cchSize);
    else 
    {
        pwzFragmentStr[0] = TEXT('\0');
        hr = E_FAIL;
    }

    return hr;
}


BOOL XboxItemID_IsFragment(LPCITEMIDLIST pidl)
{
    BOOL fIsFrag = FALSE;
    LPXBOXIDLIST pXboxIDList = XboxItemID_GetData(pidl);

    if (pXboxIDList && IS_FRAGMENT(pXboxIDList))
        fIsFrag = TRUE;

    return fIsFrag;
}


// fileTime In UTC
void XboxItemID_SetFileTime(LPCITEMIDLIST pidl, FILETIME fileTime)
{
    FILETIME fileTimeLocal;
    LPXBOXIDLIST pXboxIDList = XboxItemID_GetData(pidl);

    if (!EVAL(pXboxIDList))
        return;

    FileTimeToLocalFileTime(&fileTime, &fileTimeLocal);
    pXboxIDList->ftModified = fileTimeLocal;
    pXboxIDList->dwIDType |= IDVALID_MOD_DATE;
}

BOOL XboxItemID_IsDirectory(LPCITEMIDLIST pidl, BOOL fAssumeDirForUnknown)
{
    LPXBOXIDLIST pXboxIDList = XboxItemID_GetData(pidl);

    if (!EVAL(pXboxIDList))
        return NULL;

    BOOL fIsDir = (IsFlagSet(pXboxIDList->dwIDType, IDTYPE_DIR));
    
    if (fAssumeDirForUnknown && (IDTYPE_FILEORDIR == pXboxIDList->dwIDType))
    {
//        TraceMsg(TF_XBOXURL_UTILS, "XboxItemID_IsDirectory() IDTYPE_FILEORDIR is set, so we assume %s", (fAssumeDirForUnknown ? TEXT("DIR") : TEXT("FILE")));
        fIsDir = TRUE;
    }
    else
    {
//        TraceMsg(TF_XBOXURL_UTILS, "XboxItemID_IsDirectory() It is known to be a %s", (fIsDir ? TEXT("DIR") : TEXT("FILE")));
    }

    return fIsDir;
}




/****************************************************\
    Functions to work on an entire XBOX PIDLs
\****************************************************/
#define SZ_ASCII_DOWNLOAD_TYPE       TEXT("a")
#define SZ_BINARY_DOWNLOAD_TYPE      TEXT("b")

HRESULT XboxPidl_GetDownloadTypeStr(LPCITEMIDLIST pidl, LPTSTR szDownloadType, DWORD cchTypeStrSize)
{
    HRESULT hr = S_FALSE;   // We may not have a type.
    DWORD dwTypeID = XboxServerID_GetTypeID(pidl);

    szDownloadType[0] = TEXT('\0');
    if (IDVALID_DLTYPE & dwTypeID)
    {
        hr = S_OK;
        StrCpyN(szDownloadType, SZ_XBOX_URL_TYPE, cchTypeStrSize);

        if (IDVALID_DL_ASCII & dwTypeID)
            StrCatBuff(szDownloadType, SZ_ASCII_DOWNLOAD_TYPE, cchTypeStrSize);
        else
            StrCatBuff(szDownloadType, SZ_BINARY_DOWNLOAD_TYPE, cchTypeStrSize);
    }

    return hr;
}

DWORD XboxPidl_GetDownloadType(LPCITEMIDLIST pidl)
{
    DWORD dwAttribs = FTP_TRANSFER_TYPE_UNKNOWN;
    DWORD dwTypeID = XboxServerID_GetTypeID(pidl);

    ASSERT(XboxID_IsServerItemID(pidl));
    if (IDVALID_DLTYPE & dwTypeID)
    {
        if (IDVALID_DL_ASCII & dwTypeID)
            dwAttribs = FTP_TRANSFER_TYPE_ASCII;
        else
            dwAttribs = FTP_TRANSFER_TYPE_BINARY;
    }

    return dwAttribs;
}


INTERNET_PORT XboxPidl_GetPortNum(LPCITEMIDLIST pidl)
{
    ASSERT(XboxID_IsServerItemID(pidl));

    return XboxServerID_GetPortNum(pidl);
}


BOOL XboxPidl_IsDirectory(LPCITEMIDLIST pidl, BOOL fAssumeDirForUnknown)
{
    BOOL fIsDir = FALSE;
    LPCITEMIDLIST pidlLast = ILGetLastID(pidl);

    if (!XboxID_IsServerItemID(pidlLast))
        fIsDir = XboxItemID_IsDirectory(pidlLast, fAssumeDirForUnknown);

    return fIsDir;
}


BOOL XboxPidl_IsAnonymous(LPCITEMIDLIST pidl)
{
    BOOL fIsAnonymous = TRUE;

    if (IDVALID_USERNAME & XboxServerID_GetTypeID(pidl))
        fIsAnonymous = FALSE;

    return fIsAnonymous;
}


HRESULT XboxPidl_GetServer(LPCITEMIDLIST pidl, LPTSTR pszServer, DWORD cchSize)
{
    if (!XboxID_IsServerItemID(pidl)) // Will fail if we are handed a non-server ID.
        return E_FAIL;

    return XboxServerID_GetServer(pidl, pszServer, cchSize);
}


BOOL XboxPidl_IsDNSServerName(LPCITEMIDLIST pidl)
{
    BOOL fIsDNSServer = FALSE;
    TCHAR szServer[INTERNET_MAX_HOST_NAME_LENGTH];

    if (EVAL(SUCCEEDED(XboxPidl_GetServer(pidl, szServer, ARRAYSIZE(szServer)))))
        fIsDNSServer = !IsIPAddressStr(szServer);

    return fIsDNSServer;
}


HRESULT XboxPidl_GetUserName(LPCITEMIDLIST pidl, LPTSTR pszUserName, DWORD cchSize)
{
    ASSERT(XboxID_IsServerItemID(pidl));
    return XboxServerID_GetUserName(pidl, pszUserName, cchSize);
}

HRESULT XboxPidl_GetPassword(LPCITEMIDLIST pidl, LPTSTR pszPassword, DWORD cchSize, BOOL fIncludingHiddenPassword)
{
    ASSERT(XboxID_IsServerItemID(pidl));
    return XboxServerID_GetPassword(pidl, pszPassword, cchSize, fIncludingHiddenPassword);
}


ULONGLONG XboxPidl_GetFileSize(LPCITEMIDLIST pidl)
{
    LPCITEMIDLIST pidlLast = ILGetLastID(pidl);
    ULONGLONG ullFileSize;
    ullFileSize = 0;

    if (!XboxID_IsServerItemID(pidlLast))
        ullFileSize = XboxItemID_GetFileSize(pidlLast);

    return ullFileSize;
}


HRESULT XboxPidl_SetFileSize(LPCITEMIDLIST pidl, DWORD dwSizeHigh, DWORD dwSizeLow)
{
    HRESULT hr = E_INVALIDARG;
    LPCITEMIDLIST pidlLast = ILGetLastID(pidl);

    if (!XboxID_IsServerItemID(pidlLast))
    {
        ULARGE_INTEGER uliFileSize;

        uliFileSize.HighPart = dwSizeHigh;
        uliFileSize.LowPart = dwSizeLow;
        XboxItemID_SetFileSize(pidlLast, uliFileSize);
        hr = S_OK;
    }

    return hr;
}

// Return value in UTC time.
FILETIME XboxPidl_GetFileTime(LPCITEMIDLIST pidl)
{
    FILETIME fileTimeXBOX = XboxPidl_GetXBOXFileTime(pidl);   // This is what servers will be.
    FILETIME fileTime;

    EVAL(LocalFileTimeToFileTime(&fileTimeXBOX, &fileTime));

    return fileTime;
}


// Return value is in Local Time Zone.
FILETIME XboxPidl_GetXBOXFileTime(LPCITEMIDLIST pidl)
{
    FILETIME fileTime = {0};   // This is what servers will be.

    if (!XboxID_IsServerItemID(pidl))
        fileTime = XboxItemID_GetFileTime(pidl);

    return fileTime;
}


HRESULT XboxPidl_GetDisplayName(LPCITEMIDLIST pidl, LPWSTR pwzName, DWORD cchSize)
{
    HRESULT hr = E_INVALIDARG;

    if (pidl)
    {
        if (XboxID_IsServerItemID(pidl))
            hr = XboxServerID_GetServer(pidl, pwzName, cchSize);
        else
            hr = XboxItemID_GetDisplayName(pidl, pwzName, cchSize);
    }

    return hr;
}


HRESULT XboxPidl_GetWireName(LPCITEMIDLIST pidl, LPWIRESTR pwName, DWORD cchSize)
{
    HRESULT hr = E_INVALIDARG;

    if (pidl)
    {
        if (XboxID_IsServerItemID(pidl))
        {
            WCHAR wzServerName[INTERNET_MAX_HOST_NAME_LENGTH];

            // It's a good thing Server Names need to be in US ANSI
            hr = XboxServerID_GetServer(pidl, wzServerName, ARRAYSIZE(wzServerName));
            SHUnicodeToAnsi(wzServerName, pwName, cchSize);
        }
        else
            hr = XboxItemID_GetWireName(pidl, pwName, cchSize);
    }

    return hr;
}


HRESULT XboxPidl_GetFragment(LPCITEMIDLIST pidl, LPTSTR pszFragment, DWORD cchSize)
{
    HRESULT hr = E_INVALIDARG;
    LPCITEMIDLIST pidlLast = ILGetLastID(pidl);

    if (!XboxID_IsServerItemID(pidlLast))
        hr = XboxItemID_GetFragment(pidlLast, pszFragment, cchSize);
    else
    {
        pszFragment[0] = 0;
    }

    return hr;
}


DWORD XboxPidl_GetAttributes(LPCITEMIDLIST pidl)
{
    DWORD dwAttribs = FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_TEMPORARY;
    LPCITEMIDLIST pidlLast = ILGetLastID(pidl);

    if (!XboxID_IsServerItemID(pidlLast))
        dwAttribs = XboxItemID_GetAttributes(pidlLast);
    else
        dwAttribs = FILE_ATTRIBUTE_DIRECTORY;

    return dwAttribs;
}


HRESULT XboxPidl_SetAttributes(LPCITEMIDLIST pidl, DWORD dwAttribs)
{
    HRESULT hr = E_INVALIDARG;
    LPCITEMIDLIST pidlLast = ILGetLastID(pidl);

    if (!XboxID_IsServerItemID(pidlLast))
        hr = XboxItemID_SetAttributes(pidlLast, dwAttribs);

    return hr;
}


// ftTimeDate In UTC
HRESULT XboxPidl_SetFileTime(LPCITEMIDLIST pidl, FILETIME ftTimeDate)
{
    HRESULT hr = E_INVALIDARG;
    LPCITEMIDLIST pidlLast = ILGetLastID(pidl);

    if (!XboxID_IsServerItemID(pidlLast))
    {
        XboxItemID_SetFileTime(pidlLast, ftTimeDate);
        hr = S_OK;
    }

    return hr;
}


/****************************************************\
    FUNCTION: XboxPidl_GetFileWireName

    DESCRIPTION:
        Get the file name.
\****************************************************/
LPCWIRESTR XboxPidl_GetFileWireName(LPCITEMIDLIST pidl)
{
    if (EVAL(!XboxID_IsServerItemID(pidl)) &&
        !XboxItemID_IsFragment(pidl))
    {
        return XboxItemID_GetWireNameReference(pidl);
    }

    return NULL;
}


/****************************************************\
    FUNCTION: XboxPidl_GetFileDisplayName

    DESCRIPTION:
        Get the file name.
\****************************************************/
LPCWSTR XboxPidl_GetFileDisplayName(LPCITEMIDLIST pidl)
{
    if (EVAL(!XboxID_IsServerItemID(pidl)) &&
        !XboxItemID_IsFragment(pidl))
    {
        return XboxItemID_GetDisplayNameReference(pidl);
    }

    return NULL;
}


/****************************************************\
    FUNCTION: XboxPidl_GetLastItemDisplayName

    DESCRIPTION:
        This will get the last item name, even if that
    last item is a fragment.
\****************************************************/
LPCWSTR XboxPidl_GetLastItemDisplayName(LPCITEMIDLIST pidl)
{
    LPCITEMIDLIST pidlLast = ILGetLastID(pidl);

    if (EVAL(!XboxID_IsServerItemID(pidlLast)))
        return XboxItemID_GetDisplayNameReference(pidlLast);

    return NULL;
}


/****************************************************\
    FUNCTION: XboxPidl_GetLastItemWireName

    DESCRIPTION:
        This will get the last item name, even if that
    last item is a fragment.
\****************************************************/
LPCWIRESTR XboxPidl_GetLastItemWireName(LPCITEMIDLIST pidl)
{
    LPCITEMIDLIST pidlLast = ILGetLastID(pidl);

    if (XboxItemID_IsFragment(pidlLast) && (pidlLast != pidl))
    {
        // Oops, we went to far.  Step back one.
        LPCITEMIDLIST pidlFrag = pidlLast;

        pidlLast = pidl;    // Start back at the beginning.
        while (!XboxItemID_IsEqual(_ILNext(pidlLast), pidlFrag))
        {
            if (ILIsEmpty(pidlLast))
                return NULL;    // Break infinite loop.

            pidlLast = _ILNext(pidlLast);
        }
    }

    return XboxPidl_GetFileWireName(pidlLast);
}


/****************************************************\
    FUNCTION: XboxPidl_GetLastFileDisplayName

    DESCRIPTION:
        This will get the last item name, even if that
    last item is a fragment.
\****************************************************/
LPCWSTR XboxPidl_GetLastFileDisplayName(LPCITEMIDLIST pidl)
{
    LPCITEMIDLIST pidlLast = ILGetLastID(pidl);

    if (XboxItemID_IsFragment(pidlLast) && (pidlLast != pidl))
    {
        // Oops, we went to far.  Step back one.
        LPCITEMIDLIST pidlFrag = pidlLast;

        pidlLast = pidl;    // Start back at the beginning.
        while (!XboxItemID_IsEqual(_ILNext(pidlLast), pidlFrag))
        {
            if (ILIsEmpty(pidlLast))
                return NULL;    // Break infinite loop.

            pidlLast = _ILNext(pidlLast);
        }
    }

    if (EVAL(!XboxID_IsServerItemID(pidlLast)))
        return XboxItemID_GetDisplayNameReference(pidlLast);

    return NULL;
}


/****************************************************\
    FUNCTION: XboxPidl_InsertVirtualRoot

    DESCRIPTION:
        This function will insert the virtual root path
    (pidlVirtualRoot) into pidlXboxPath.

    PARAMETERS:
        pidlVirtualRoot: Does not have a ServerID
        pidlXboxPath: Can have a ServerID
        *ppidl: Will be pidlVirtualRoot with item ItemIDs from
            pidlXboxPath behind it. (No ServerID)
\****************************************************/
HRESULT XboxPidl_InsertVirtualRoot(LPCITEMIDLIST pidlVirtualRoot, LPCITEMIDLIST pidlXboxPath, LPITEMIDLIST * ppidl)
{
    HRESULT hr = E_OUTOFMEMORY;

    if (XboxID_IsServerItemID(pidlXboxPath))
        pidlXboxPath = _ILNext(pidlXboxPath);

    *ppidl = ILCombine(pidlVirtualRoot, pidlXboxPath);
    if (*ppidl)
        hr = S_OK;

    return hr;
}


DWORD XboxPidl_GetVersion(LPCITEMIDLIST pidl)
{
    if (!EVAL(XboxID_IsServerItemID(pidl)))
        return 0;

    LPXBOXSERVERIDLIST pXboxServerItemId = (LPXBOXSERVERIDLIST) ProtocolIdlInnerData(pidl);
    return pXboxServerItemId->dwVersion;
}


BOOL XboxPidl_IsValid(LPCITEMIDLIST pidl)
{
    if (!EVAL(IsValidPIDL(pidl)))
        return FALSE;

    return TRUE;
}


BOOL XboxPidl_IsValidFull(LPCITEMIDLIST pidl)
{
    if (!EVAL(XboxID_IsServerItemID(pidl)))
        return FALSE;

    if (!EVAL(XboxPidl_IsValid(pidl)))
        return FALSE;

    // We consider anything older than PIDL_VERSION_NUMBER_UPGRADE
    // to be invalid.
    return ((PIDL_VERSION_NUMBER_UPGRADE - 1) < XboxPidl_GetVersion(pidl));
}


BOOL XboxPidl_IsValidRelative(LPCITEMIDLIST pidl)
{
    if (!EVAL(!XboxID_IsServerItemID(pidl)))
        return FALSE;       // This is a server item id which is not relative.

    return XboxPidl_IsValid(pidl);
}


LPITEMIDLIST ILCloneFirstItemID(LPITEMIDLIST pidl)
{
    LPITEMIDLIST pidlCopy = ILClone(pidl);

    if (pidlCopy && pidlCopy->mkid.cb)
    {
        LPITEMIDLIST pSecondID = (LPITEMIDLIST)_ILNext(pidlCopy);

        ASSERT(pSecondID);
        // Remove the last one
        pSecondID->mkid.cb = 0; // null-terminator
    }

    return pidlCopy;
}

BOOL XboxPidl_HasPath(LPCITEMIDLIST pidl)
{
    BOOL fResult = TRUE;
    
    if (!XboxPidl_IsValid(pidl) || !EVAL(XboxID_IsServerItemID(pidl)))
        return FALSE;

    if (!ILIsEmpty(pidl) && ILIsEmpty(_ILNext(pidl)))
        fResult = FALSE;

    return fResult;
}


HRESULT XboxPidl_SetFileItemType(LPITEMIDLIST pidl, BOOL fIsDir)
{
    LPCITEMIDLIST pidlLast = ILGetLastID(pidl);
    HRESULT hr = E_INVALIDARG;
        
    if (EVAL(XboxPidl_IsValid(pidl)) && EVAL(!XboxID_IsServerItemID(pidlLast)))
    {
        DWORD dwIDType = XboxItemID_GetTypeID(pidlLast);

        ClearFlag(dwIDType, (IDTYPE_FILEORDIR | IDTYPE_DIR | IDTYPE_FILE));
        SetFlag(dwIDType, (fIsDir ? IDTYPE_DIR : IDTYPE_FILE));
        XboxItemID_SetTypeID((LPITEMIDLIST) pidlLast, dwIDType);

        hr = S_OK;
    }

    return hr;
}


BOOL IsXboxPidlQuestionable(LPCITEMIDLIST pidl)
{
    BOOL fIsQuestionable = FALSE;
    LPCITEMIDLIST pidlLast = ILGetLastID(pidl);

    // Is it a Server Pidl? (All Server pidls aren't questionable)
    if (XboxPidl_IsValid(pidl) && !XboxID_IsServerItemID(pidlLast))
    {
        // No, so it might be questionable.

        // Does it have "File or Dir" bit set?
        if (IsFlagSet(XboxItemID_GetTypeID(pidlLast), IDTYPE_FILEORDIR))
            fIsQuestionable = TRUE;
    }
    
    return fIsQuestionable;
}


LPITEMIDLIST XboxCloneServerID(LPCITEMIDLIST pidl)
{
    LPITEMIDLIST pidlResult = NULL;

    if (EVAL(XboxID_IsServerItemID(pidl)))
    {
        pidlResult = ILClone(pidl);

        while (!ILIsEmpty(_ILNext(pidlResult)))
            ILRemoveLastID(pidlResult);
    }

    return pidlResult;
}


/*****************************************************************************\
    FUNCTION: XboxPidl_ReplacePath

    DESCRIPTION:
        This function will fill in *ppidlOut with a pidl that contains the
    XboxServerID from pidlServer and the XboxItemIDs from pidlXboxPath.
\*****************************************************************************/
HRESULT XboxPidl_ReplacePath(LPCITEMIDLIST pidlServer, LPCITEMIDLIST pidlXboxPath, LPITEMIDLIST * ppidlOut)
{
    HRESULT hr = E_INVALIDARG;

    *ppidlOut = NULL;
    if (EVAL(XboxID_IsServerItemID(pidlServer)))
    {
        LPITEMIDLIST pidlServerOnly = XboxCloneServerID(pidlServer);

        if (pidlServerOnly)
        {
            if (XboxID_IsServerItemID(pidlXboxPath))
                pidlXboxPath = _ILNext(pidlXboxPath);

            *ppidlOut = ILCombine(pidlServerOnly, pidlXboxPath);
            if (*ppidlOut)
                hr = S_OK;
            else
                hr = E_FAIL;

            ILFree(pidlServerOnly);
        }
    }

    ASSERT_POINTER_MATCHES_HRESULT(*ppidlOut, hr);
    return hr;
}


BOOL XboxItemID_IsEqual(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    // Don't repeat recursively.
    return (S_OK == _XboxItemID_CompareOneID(COL_NAME, pidl1, pidl2, FALSE));
}


BOOL XboxPidl_IsPathEqual(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    // This works recursively.
    return ((0 == XboxItemID_CompareIDsInt(COL_NAME, pidl1, pidl2, FCMP_NORMAL)) ? TRUE : FALSE);
}


// is pidlChild a child of pidlParent
BOOL XboxItemID_IsParent(LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidlChild)
{
    BOOL fIsChild = TRUE;

    if (pidlChild)
    {
        LPITEMIDLIST pidl1Iterate = (LPITEMIDLIST) pidlParent;
        LPITEMIDLIST pidl2Iterate = (LPITEMIDLIST) pidlChild;

        ASSERT(!XboxID_IsServerItemID(pidl1Iterate) && pidlParent && !XboxID_IsServerItemID(pidl2Iterate));

        // Let's see if pidl starts off with 
        while (fIsChild && pidl1Iterate && !ILIsEmpty(pidl1Iterate) &&
                pidl2Iterate && !ILIsEmpty(pidl2Iterate) && 
                XboxItemID_IsEqual(pidl1Iterate, pidl2Iterate))
        {
            fIsChild = XboxItemID_IsEqual(pidl1Iterate, pidl2Iterate);

            pidl1Iterate = _ILNext(pidl1Iterate);
            pidl2Iterate = _ILNext(pidl2Iterate);
        }

        if (!(ILIsEmpty(pidl1Iterate) && !ILIsEmpty(pidl2Iterate)))
            fIsChild = FALSE;
    }
    else
        fIsChild = FALSE;

    return fIsChild;
}


// is pidlChild a child of pidlParent, so all the itemIDs in
// pidlParent are in pidlChild, but pidlChild has more.
// This will return a pointer to those itemIDs.
LPCITEMIDLIST XboxItemID_FindDifference(LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidlChild)
{
    LPCITEMIDLIST pidlDiff = (LPITEMIDLIST) pidlChild;

    if (pidlChild)
    {
        LPITEMIDLIST pidl1Iterate = (LPITEMIDLIST) pidlParent;

        if (XboxID_IsServerItemID(pidl1Iterate))
            pidl1Iterate = _ILNext(pidl1Iterate);

        if (XboxID_IsServerItemID(pidlDiff))
            pidlDiff = _ILNext(pidlDiff);

        // Let's see if pidl starts off with 
        while (pidl1Iterate && !ILIsEmpty(pidl1Iterate) &&
                pidlDiff && !ILIsEmpty(pidlDiff) && 
                XboxItemID_IsEqual(pidl1Iterate, pidlDiff))
        {
            pidlDiff = _ILNext(pidlDiff);
            pidl1Iterate = _ILNext(pidl1Iterate);
        }
    }

    return pidlDiff;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\encoding.h ===
/*****************************************************************************\
    FILE: encoding.h
    
    DESCRIPTION:
        Handle taking internet strings by detecting if they are UTF-8 encoded
    or DBCS and finding out what code page was used.
\*****************************************************************************/

#ifndef _STRENCODE_H
#define _STRENCODE_H

#include <mlang.h>


// Turned off until MLANG can successfully detect short strings.
// TODO: We also need to fix xboxfolder when it doesn't have a pidl
//       but still needs the site's CWireEncoding state
//#define FEATURE_CP_AUTODETECT

// XBOX_FIND_DATA is different than WIN32_FIND_DATA because
// the .cFileName is in WIRECHAR instead of CHAR
#define XBOX_FIND_DATA      WIN32_FIND_DATAA
#define LPXBOX_FIND_DATA    LPWIN32_FIND_DATAA

// WIRESTR stands for WireBites which could be DBCS/MBCS or UTF-8
#define WIRECHAR      CHAR
#define LPCWIRESTR    LPCSTR
#define LPWIRESTR     LPSTR




BOOL SHIsUTF8Encoded(LPCWIRESTR pszIsUTF8);


/*****************************************************************************\
    CLASS: CMultiLanguageCache
    
    DESCRIPTION:
        We can't cache the IMultiLanguage2 * across threads, but we do need to
    cache it when we are in a loop because we don't want to keep calling
    CoCreateInstance.
\*****************************************************************************/
class CMultiLanguageCache
{
public:
    CMultiLanguageCache(void) {m_pml2 = NULL;};
    ~CMultiLanguageCache(void) {ATOMICRELEASE(m_pml2);};

    IMultiLanguage2 * GetIMultiLanguage2(void) {EVAL(SUCCEEDED(_Init())); return m_pml2;};

private:
    // Private member variables
    IMultiLanguage2 *       m_pml2;

    // Private member functions
    HRESULT _Init(void);
};


// dwFlags for WireBytesToUnicode() & UnicodeToWireBytes()
#define WIREENC_NONE                0x00000000  // None
#define WIREENC_USE_UTF8            0x00000001  // Prefer UTF-8 because this is a new file. For UnicodeToWireBytes() only.
#define WIREENC_IMPROVE_ACCURACY    0x00000002  // Detect the accuracy.  For WireBytesToUnicode() only.



#define DETECT_CONFIDENCE       75  // We want to be this confident.
/*****************************************************************************\
    CLASS: CWireEncoding
    
    DESCRIPTION:
    2.1.1 No Data Loss Support (UTF-8)
    Server: The server is required to support the FEAT XBOX command (rfc2389 http://www.cis.ohio-state.edu/htbin/rfc/rfc2389.html) and the "utf8" feature (http://w3.hethmon.com/xboxext/drafts/draft-ietf-xboxext-intl-Xbox-04.txt).   If the client sends the server the "utf8" command, the server then needs to accept  and return UTF-8 encoded filenames.  It's not known when IIS will support this but it won't be supported in the version that ships with Windows 2000.
    Network Client (wininet): Wininet needs to respect the unicode filepaths in the XboxGetFileEx() and XboxPutFileEx() APIs.  This won't be supported in IE 5.
     UI Client (xbnmspc): It's necessary to see if the server supports the "utf8" command via the FEAT command.  If the command is supported, it should be sent to the server and all future strings will be UTF-8 encoded.  This should be supported in IE 5 if there is enough time in the schedule.

    2.1.0 Data Loss Backward Compat (DBCS)
    xbnmspc will only support DBCS if and only if the code page on the client matches the server's code page and all Xbox directories and filenames used.  In future versions I may attempt to sniff the code page.

    IMultiLanguage2::DetectCodepage(MLDETECTCP_8BIT, 0, psz, NULL, &DetectEncodingInfo, ARRAYSIZE(DetectEncodingInfo))
    MLDETECTCP_8BIT, MLDETECTCP_DBCS, MLCONVCHARF_AUTODETECT
    DetectEncodingInfo.nCodePage (IMultiLanguage2::DetectCodepage)

    CP_1252: This is english/french/german and the most common.
    CP_JPN_SJ: Most common Japanese
    CP_CYRILLIC_AUTO = 51251L,
    CP_GREEK_AUTO   = 51253L,
    CP_ARABIC_AUTO  = 51256L,
    CP_1251         = 1251L: Lucian
\*****************************************************************************/
class CWireEncoding
{
public:
    CWireEncoding(void);
    ~CWireEncoding(void);

    HRESULT WireBytesToUnicode(CMultiLanguageCache * pmlc, LPCWIRESTR pwStr, DWORD dwFlags, LPWSTR pwzDest, DWORD cchSize);
    HRESULT UnicodeToWireBytes(CMultiLanguageCache * pmlc, LPCWSTR pwzStr, DWORD dwFlags, LPWIRESTR pwbDest, DWORD cchSize);

    HRESULT ReSetCodePages(CMultiLanguageCache * pmlc, CXboxPidlList * pXboxPidlList);
    HRESULT CreateXboxItemID(CMultiLanguageCache * pmlc, LPXBOX_FIND_DATA pwfd, LPITEMIDLIST * ppidl);
    HRESULT ChangeXboxItemIDName(CMultiLanguageCache * pmlc, LPCITEMIDLIST pidlBefore, LPCWSTR pwzNewName, BOOL fUTF8, LPITEMIDLIST * ppidlAfter);
    UINT GetCodePage(void) {return m_uiCodePage;};
    INT GetConfidence(void) {return m_nConfidence;};

    BOOL IsUTF8Supported(void) {return m_fUseUTF8;};
    void SetUTF8Support(BOOL fIsUTF8Supported) {m_fUseUTF8 = fIsUTF8Supported;};

private:
    // Private member variables
    INT                     m_nConfidence;      // How accurate is our guess at m_uiCodePage.
    UINT                    m_uiCodePage;       // The code page we guess this to be.
    DWORD                   m_dwMode;           // State used by IMultiLanguage2's ::ConvertStringFromUnicode
    BOOL                    m_fUseUTF8;         // 

    // Private member functions
    void _ImproveAccuracy(CMultiLanguageCache * pmlc, LPCWIRESTR pwStr, BOOL fUpdateCP, UINT * puiCodePath);
};


#endif // _STRENCODE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\isfvcb.cpp ===
/*****************************************************************************\
    FILE: isfvcb.cpp

    DESCRIPTION:
        This is a base class that implements the default behavior of 
    IShellFolderViewCallBack.  This allows default DefView implementation with this
    callback to override specific behavior.
\*****************************************************************************/

#include "priv.h"
#include "isfvcb.h"


//===========================
// *** IShellFolderViewCB Interface ***
//===========================

/*****************************************************************************\
    FUNCTION: _OnSetISFV

    DESCRIPTION:
        Same as ::SetSite();
\*****************************************************************************/
HRESULT CBaseFolderViewCB::_OnSetISFV(IShellFolderView * psfv)
{
    IUnknown_Set((IUnknown **) &m_psfv, (IUnknown *) psfv);
    return S_OK;
}

/*****************************************************************************\
    FUNCTION: IShellFolderViewCB::MessageSFVCB

    DESCRIPTION:
\*****************************************************************************/
#define NOTHANDLED(m) case m: hr = E_NOTIMPL; break

HRESULT CBaseFolderViewCB::MessageSFVCB(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = E_FAIL;

    switch (uMsg)
    {
    case DVM_GETDETAILSOF:
        hr = _OnGetDetailsOf((UINT)wParam, (PDETAILSINFO)lParam);
        break;

    case DVM_COLUMNCLICK:
        hr = _OnColumnClick((UINT)wParam);
        break;

    case DVM_MERGEMENU:
        hr = _OnMergeMenu((LPQCMINFO)lParam);
        break;

    case DVM_UNMERGEMENU:
        hr = _OnUnMergeMenu((HMENU)lParam);
        break;

    case DVM_INVOKECOMMAND:
        hr = _OnInvokeCommand((UINT)wParam);
        break;

    case DVM_GETHELPTEXT:
        hr = _OnGetHelpText(lParam, wParam);
        break;

    case SFVM_GETHELPTOPIC:
        hr = _OnGetHelpTopic((SFVM_HELPTOPIC_DATA *) lParam);
        break;

    case DVM_GETTOOLTIPTEXT:
        // TODO: Implement
        hr = E_NOTIMPL;
        break;

    case DVM_UPDATESTATUSBAR:
        // TODO: Implement
        hr = _OnUpdateStatusBar();
        break;

    case DVM_WINDOWCREATED:
        hr = _OnWindowCreated();
        break;

    case SFVM_BACKGROUNDENUMDONE:
        hr = _OnBackGroundEnumDone();
        break;

    case DVM_INITMENUPOPUP:
        hr = _OnInitMenuPopup((HMENU) lParam, (UINT) HIWORD(wParam), (UINT) LOWORD(wParam));
        break;

    case DVM_RELEASE:
    {
        CBaseFolderViewCB * pfv = (CBaseFolderViewCB *) lParam;
        if (pfv)
            hr = pfv->Release();
    }
    break;

    case DVM_DEFITEMCOUNT:
        hr = _OnDefItemCount((LPINT)lParam);
        break;

    case DVM_DIDDRAGDROP:
        hr = _OnDidDragDrop((DROPEFFECT)wParam, (IDataObject *)lParam);
        break;

    case DVM_REFRESH:
        hr = _OnRefresh((BOOL) wParam);
        break;

    case SFVM_ADDPROPERTYPAGES:
        hr = _OnAddPropertyPages((SFVM_PROPPAGE_DATA *)lParam);
        break;

    case DVM_BACKGROUNDENUM:
        //  WARNING!  If we return S_OK from DVM_BACKGROUNDENUM, we also
        //  are promising that we support free threading on our IEnumIDList
        //  interface!  This allows the shell to do enumeration on our
        //  IEnumIDList on a separate background thread.
        hr = S_OK;                    // Always enum in background
        break;

    case SFVM_DONTCUSTOMIZE:
        if (lParam)
            *((BOOL *) lParam) = FALSE;  // Yes, we are customizable.
        hr = S_OK;
        break;

    case SFVM_GETZONE:
        hr = _OnGetZone((DWORD *) lParam, wParam);
        break;

    case SFVM_GETPANE:
        hr = _OnGetPane((DWORD) wParam, (DWORD *)lParam);
        break;

    case SFVM_SETISFV:
        hr = _OnSetISFV((IShellFolderView *)lParam);
        break;

    case SFVM_GETNOTIFY:
        hr = _OnGetNotify((LPITEMIDLIST *) wParam, (LONG *) lParam);
        break;

    case SFVM_FSNOTIFY:
        hr = _OnFSNotify((LPITEMIDLIST *) wParam, (LONG *) lParam);
        break;

    case SFVM_QUERYFSNOTIFY:
        hr = _OnQueryFSNotify((SHChangeNotifyEntry *) lParam);
        // BUGBUG: Do we need to implement this? Maybe it will fix #173045
        break;

    case SFVM_SIZE:
        hr = _OnSize((LONG) wParam, (LONG) lParam);
        break;

    case SFVM_THISIDLIST:
        hr = _OnThisIDList((LPITEMIDLIST *) lParam);
        break;


    // We need to do the following BUGBUG/TODO
    // Do we want to implement these later?
    // SFVM_HWNDMAIN

    // Others that aren't currently handled.
    NOTHANDLED(DVM_GETBUTTONINFO);
    NOTHANDLED(DVM_GETBUTTONS);
    NOTHANDLED(DVM_SELCHANGE);
    NOTHANDLED(DVM_DRAWITEM);
    NOTHANDLED(DVM_MEASUREITEM);
    NOTHANDLED(DVM_EXITMENULOOP);
    NOTHANDLED(DVM_GETCCHMAX);
    NOTHANDLED(DVM_WINDOWDESTROY);
    NOTHANDLED(DVM_SETFOCUS);
    NOTHANDLED(DVM_KILLFOCUS);
    NOTHANDLED(DVM_QUERYCOPYHOOK);
    NOTHANDLED(DVM_NOTIFYCOPYHOOK);
    NOTHANDLED(DVM_DEFVIEWMODE);
#if 0
    NOTHANDLED(DVM_INSERTITEM);         // Too verbose
    NOTHANDLED(DVM_DELETEITEM);
#endif

    NOTHANDLED(DVM_GETWORKINGDIR);
    NOTHANDLED(DVM_GETCOLSAVESTREAM);
    NOTHANDLED(DVM_SELECTALL);
    NOTHANDLED(DVM_SUPPORTSIDENTIFY);
    NOTHANDLED(DVM_FOLDERISPARENT);
    default:
        hr = E_NOTIMPL;
        break;
    }

    return hr;
}



/****************************************************\
    Constructor
\****************************************************/
CBaseFolderViewCB::CBaseFolderViewCB() : m_cRef(1), m_dwSignature(c_dwSignature)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_psfv);

}


/****************************************************\
    Destructor
\****************************************************/
CBaseFolderViewCB::~CBaseFolderViewCB()
{
    m_dwSignature = 0;                  // Turn off _IShellFolderViewCallBack
    IUnknown_Set((IUnknown **)&m_psfv, NULL);
    DllRelease();
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CBaseFolderViewCB::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CBaseFolderViewCB::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

// {7982F251-C37A-11d1-9823-006097DF5BD4}
static const GUID CIID_PrivateThis = { 0x7982f251, 0xc37a, 0x11d1, { 0x98, 0x23, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4 } };

HRESULT CBaseFolderViewCB::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IShellFolderViewCB))
    {
        *ppvObj = SAFECAST(this, IShellFolderViewCB*);
    }
    else
    if (IsEqualIID(riid, IID_IObjectWithSite))
    {
        *ppvObj = SAFECAST(this, IObjectWithSite*);
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}


HRESULT CBaseFolderViewCB::_IShellFolderViewCallBack(IShellView * psvOuter, IShellFolder * psf, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    IShellFolderViewCB * psfvcb = NULL;
    HRESULT hr = E_FAIL;


    // Now this is a total hack.  I am bastardizing the pszOuter param to really be the this pointer that
    // is the IShellFolderViewCB interface of the CBaseFolderViewCB object.  I use the SFVM_WINDOWDESTROY event to
    // release the object but DefView calls us back with one more message before we completely go away
    // and that message is SFVM_SETISFV.  Everytime the SFVM_SETISFV is called with a NULL lParam, it's
    // equivalent to calling ::SetSite(NULL).  We can ignore this because we release the back pointer in our
    // destructor.
    if (((SFVM_SETISFV == uMsg) && !lParam) ||
        (SFVM_PRERELEASE == uMsg))
    {
        return S_OK;
    }

    // psvOuter is really our CBaseFolderViewCB.  Sniff around to make sure.
    // Note that this casting must exactly invert the casts that we do in
    // CBaseFolder::_CreateShellView.

    CBaseFolderViewCB *pbfvcb = (CBaseFolderViewCB *)(IShellFolderViewCB *)psvOuter;

    if (EVAL(!IsBadReadPtr(pbfvcb, sizeof(CBaseFolderViewCB))) &&
        EVAL(pbfvcb->m_dwSignature == c_dwSignature))
    {

        // psvOuter is really our CBaseFolderViewCB and let's make sure with this QI.
        hr = psvOuter->QueryInterface(IID_IShellFolderViewCB, (void **) &psfvcb);
        if (EVAL(psfvcb))
        {
            hr = psfvcb->MessageSFVCB(uMsg, wParam, lParam);

            if ((SFVM_WINDOWDESTROY == uMsg)) // (DVM_WINDOWDESTROY == SFVM_WINDOWDESTROY)
            {
                ASSERT(!lParam);    // Sometimes callers want this to be freed.
                psvOuter->Release();     // We are releasing the psvOuter that DefView is holding.  We shouldn't be called again.
            }

            psfvcb->Release();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\offline.h ===
/****************************************************\
    FILE: offline.h

    DESCRIPTION:
        Handle 'offline' status and Dial-up UI
\****************************************************/

#ifndef _OFFLINE_H
#define _OFFLINE_H


#ifdef FEATURE_OFFLINE
BOOL IsGlobalOffline(VOID);
VOID SetOffline(IN BOOL fOffline);
#endif // FEATURE_OFFLINE

HRESULT AssureNetConnection(HINTERNET hint, HWND hwndParent, LPCWSTR pwzServerName, LPCITEMIDLIST pidl, BOOL fShowUI);


#endif // _OFFLINE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\isfvcb.h ===
/*****************************************************************************\
    FILE: isfvcb.h

    DESCRIPTION:
        This is a base class that implements the default behavior of 
    IShellFolderViewCallBack.  This allows default DefView implementation with this
    callback to override specific behavior.
\*****************************************************************************/


#ifndef _CBASEFOLDERVIEWCB_H
#define _CBASEFOLDERVIEWCB_H



class CBaseFolderViewCB
                : public IShellFolderViewCB
                , public CObjectWithSite
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IShellFolderViewCB methods ***
    virtual STDMETHODIMP MessageSFVCB(UINT uMsg, WPARAM wParam, LPARAM lParam);

public:
    // Friend Functions
    static HRESULT _IShellFolderViewCallBack(IShellView * psvOuter, IShellFolder * psf, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

protected:
    // Private Member Variables
    int                     m_cRef;

    IShellFolderView *      m_psfv;                 // Our parent's IShellFolderView. (Same as _punkSite)
    DWORD                   m_dwSignature;

    enum { c_dwSignature = 0x43564642 }; // "BFVC" - BaseFolderViewCb

    // Private Member Functions
    CBaseFolderViewCB();
    virtual ~CBaseFolderViewCB();

    // We have implementations for these.
    virtual HRESULT _OnSetISFV(IShellFolderView * psfv);

    // The caller needs to provide implementations for these
    // or they will get default behavior.
    virtual HRESULT _OnWindowCreated(void) {return E_NOTIMPL;};
    virtual HRESULT _OnDefItemCount(LPINT pi) {return E_NOTIMPL;};
    virtual HRESULT _OnGetHelpText(LPARAM lParam, WPARAM wParam) {return E_NOTIMPL;};
    virtual HRESULT _OnGetHelpTopic(SFVM_HELPTOPIC_DATA * phtd) {return E_NOTIMPL;};
    virtual HRESULT _OnGetZone(DWORD * pdwZone, WPARAM wParam) {return E_NOTIMPL;};
    virtual HRESULT _OnGetPane(DWORD dwPaneID, DWORD * pdwPane) {return E_NOTIMPL;};
    virtual HRESULT _OnRefresh(BOOL fReload) {return E_NOTIMPL;};
    virtual HRESULT _OnDidDragDrop(DROPEFFECT de, IDataObject * pdto) {return E_NOTIMPL;};
    virtual HRESULT _OnGetDetailsOf(UINT ici, PDETAILSINFO pdi) {return E_NOTIMPL;};
    virtual HRESULT _OnInvokeCommand(UINT idc) {return E_NOTIMPL;};
    virtual HRESULT _OnMergeMenu(LPQCMINFO pqcm) {return E_NOTIMPL;};
    virtual HRESULT _OnUnMergeMenu(HMENU hMenu) {return E_NOTIMPL;};
    virtual HRESULT _OnColumnClick(UINT ici) {return E_NOTIMPL;};
    virtual HRESULT _OnGetNotify(LPITEMIDLIST * ppidl, LONG * lEvents) {return E_NOTIMPL;};
    virtual HRESULT _OnFSNotify(LPITEMIDLIST * ppidl, LONG * lEvents) {return E_NOTIMPL;};
    virtual HRESULT _OnQueryFSNotify(SHChangeNotifyEntry * pshcne) {return E_NOTIMPL;};
    virtual HRESULT _OnSize(LONG x, LONG y) {return E_NOTIMPL;};
    virtual HRESULT _OnUpdateStatusBar(void) {return E_NOTIMPL;};
    virtual HRESULT _OnThisIDList(LPITEMIDLIST * ppidl) {return E_NOTIMPL;};
    virtual HRESULT _OnAddPropertyPages(SFVM_PROPPAGE_DATA * pData) {return E_NOTIMPL;};
    virtual HRESULT _OnInitMenuPopup(HMENU hmenu, UINT idCmdFirst, UINT nIndex) {return E_NOTIMPL;};
    virtual HRESULT _OnBackGroundEnumDone(void) {return E_NOTIMPL;};
};

#endif // _CBASEFOLDERVIEWCB_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\newmenu.cpp ===
/*****************************************************************************\
    FILE: newmenu.cpp
    
    DESCRIPTION:
        The file supports the "New" menu to create new items on the XBOX server.
    This currently only supports Folders but hopefully it will support other
    items later.
\*****************************************************************************/

#include "priv.h"
#include "util.h"
#include "newmenu.h"

// This is used to surf the hwnds to find the one we need to
// hack because IShellView2::SelectAndPositionItem() isn't implemented
// on Browser Only.
#define DEFVIEW_CLASS_BROWSERONLYA       "SHELLDLL_DefView"


/////////////////////////////////////////////////////////////////////////
///////  Private helpers    /////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

LPITEMIDLIST DV_GetPIDL(HWND hwndLV, int i)
{
    LV_ITEM item;

    item.mask = LVIF_PARAM;
    item.iItem = i;
    item.iSubItem = 0;
    item.lParam = 0;
    if (i != -1)
    {
        ListView_GetItem(hwndLV, &item);
    }

    return (LPITEMIDLIST) item.lParam;
}


int DefView_FindItemHack(CXboxFolder * pff, HWND hwndListView, LPCITEMIDLIST pidl)
{
    int nIndex;
    int nItemsTotal;

    nItemsTotal = ListView_GetItemCount(hwndListView);
    for (nIndex = 0; nItemsTotal > nIndex; nIndex++)
    {
        HRESULT hres = ResultFromShort(-1);
        LPITEMIDLIST pidlT = DV_GetPIDL(hwndListView, nIndex);
        if (!pidlT)
            return -1;

        // BUGBUG: this passes 0 for the lParam
        hres = pff->CompareIDs(0, pidl, pidlT);

        ASSERT(SUCCEEDED(hres));
        if (FAILED(hres))
            return -1;

        if (ShortFromResult(hres) == 0)
        {
            return nIndex;
        }
    }

    return -1;  // not found
}


typedef struct tagFOLDERNAMECOMP
{
    BOOL *      pfFound;
    LPCWSTR     pszFolderName;
} FOLDERNAMECOMP;


/*****************************************************************************\
    FUNCTION: _ComparePidlAndFolderStr

    DESCRIPTION:
        Compare the pidl and folder name str.
\*****************************************************************************/
int _ComparePidlAndFolderStr(LPVOID pvPidl, LPVOID pvFolderNameComp)
{
    FOLDERNAMECOMP * pFolderNameComp = (FOLDERNAMECOMP *) pvFolderNameComp;
    LPCITEMIDLIST pidl = (LPCITEMIDLIST) pvPidl;
    WCHAR wzDisplayName[MAX_PATH];
    BOOL fContinue = TRUE;

    if (EVAL(SUCCEEDED(XboxPidl_GetDisplayName(pidl, wzDisplayName, ARRAYSIZE(wzDisplayName)))))
    {
        if (!StrCmpW(wzDisplayName, pFolderNameComp->pszFolderName))
        {
            *pFolderNameComp->pfFound = TRUE;
            fContinue = FALSE;
        }
    }

    return fContinue;   // Continue looking?
}


/*****************************************************************************\
    FUNCTION: _DoesFolderExist

    DESCRIPTION:
        Look thru all the items (files and folders) in this folder and see if
    any have the same name as pszFolderName.
\*****************************************************************************/
BOOL _DoesFolderExist(LPCWSTR pszFolderName, CXboxDir * pfd)
{
    BOOL fExist = FALSE;
    if (EVAL(pfd))
    {
        CXboxPidlList * pPidlList = pfd->GetHfpl();

        // This may fail, but the worst that will happen is that the new folder won't appear.
        // This happens when the cache is flushed.
        if (pPidlList)
        {
            FOLDERNAMECOMP folderNameComp = {&fExist, pszFolderName};

            pPidlList->Enum(_ComparePidlAndFolderStr, (LPVOID) &folderNameComp);
            pPidlList->Release();
        }
    }

    return fExist;
}


/*****************************************************************************\
    FUNCTION: _CreateNewFolderName

    DESCRIPTION:
        Create the name of a new folder.
\*****************************************************************************/
HRESULT _CreateNewFolderName(LPWSTR pszNewFolder, DWORD cchSize, CXboxDir * pfd)
{
    HRESULT hr = S_OK;
    int nTry = 1;
    WCHAR wzTemplate[MAX_PATH];

    wzTemplate[0] = 0;

    LoadStringW(HINST_THISDLL, IDS_NEW_FOLDER_FIRST, pszNewFolder, cchSize);
    while (_DoesFolderExist(pszNewFolder, pfd))
    {
        if (0 == wzTemplate[0])
            LoadStringW(HINST_THISDLL, IDS_NEW_FOLDER_TEMPLATE, wzTemplate, ARRAYSIZE(wzTemplate));

        nTry++; // Try the next number.
        wnsprintf(pszNewFolder, cchSize, wzTemplate, nTry);
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: _CreateNewFolder

    DESCRIPTION:
        Create the actual directory.
\*****************************************************************************/
HRESULT CreateNewFolderCB(HINTERNET hint, HINTPROCINFO * phpi, LPVOID pvFCFS, BOOL * pfReleaseHint)
{
    HRESULT hr = S_OK;
    XBOXCREATEFOLDERSTRUCT * pfcfs = (XBOXCREATEFOLDERSTRUCT *) pvFCFS;
    WIRECHAR wFilePath[MAX_PATH];
    CWireEncoding * pWireEncoding = phpi->pfd->GetXboxSite()->GetCWireEncoding();

    hr = pWireEncoding->UnicodeToWireBytes(NULL, pfcfs->pszNewFolderName, (phpi->pfd->IsUTF8Supported() ? WIREENC_USE_UTF8 : WIREENC_NONE), wFilePath, ARRAYSIZE(wFilePath));
    if (EVAL(SUCCEEDED(hr)))
    {
        hr = XboxCreateDirectoryWrap(hint, TRUE, wFilePath);
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidlNew;
            HINTERNET hIntFind;

            // For some reason, XboxFindFirstFile needs an '*' behind the name.
            StrCatA(wFilePath, SZ_ASTRICSA);

            hr = XboxFindFirstFilePidlWrap(hint, TRUE, NULL, pWireEncoding, wFilePath, &pidlNew, (INTERNET_NO_CALLBACK | INTERNET_FLAG_DONT_CACHE | INTERNET_FLAG_RESYNCHRONIZE | INTERNET_FLAG_RELOAD), 0, &hIntFind);
            if (EVAL(SUCCEEDED(hr)))
            {
                // Notify the folder of the new item so the Shell Folder updates.
                // PERF: I worry about doing a XboxFindFirstFile() being too expensive onto to get the date correct
                //       for SHChangeNotify().
                XboxChangeNotify(phpi->hwnd, SHCNE_MKDIR, pfcfs->pff, phpi->pfd, pidlNew, NULL, TRUE);

                ILFree(pidlNew);
                InternetCloseHandle(hIntFind);
            }
        }
    }

    return hr;
}




/////////////////////////////////////////////////////////////////////////
///////  DLL Wide Functions    /////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

HRESULT CreateNewFolder(HWND hwnd, CXboxFolder * pff, CXboxDir * pfd, IUnknown * punkSite, BOOL fPosition, POINT point)
{
    HRESULT hr = E_FAIL;
    CXboxDir * pfdTemp = NULL;

    if (!pfd)
        pfd = pfdTemp = pff->GetXboxDir();

    if (EVAL(pfd))
    {
        WCHAR wzNewFolderName[MAX_PATH];

        // 1. Check if "New Folder" exists.
        // 2. Cycle thru names until a unique name is found.
        hr = _CreateNewFolderName(wzNewFolderName, ARRAYSIZE(wzNewFolderName), pfd);
        if (EVAL(SUCCEEDED(hr) && pfd))
        {
            XBOXCREATEFOLDERSTRUCT fcfs = {wzNewFolderName, pff};

            // 3. Create a Directory with that name.
            hr = pfd->WithHint(NULL, hwnd, CreateNewFolderCB, (LPVOID) &fcfs, punkSite, pff);
            if (SUCCEEDED(hr))
            {
                WIRECHAR wNewFolderWireName[MAX_PATH];
                LPITEMIDLIST pidlFolder = NULL;
                CWireEncoding * pWireEncoding = pff->GetCWireEncoding();

                // Give me UTF-8 baby.
                EVAL(SUCCEEDED(pWireEncoding->UnicodeToWireBytes(NULL, wzNewFolderName, (pfd->IsUTF8Supported() ? WIREENC_USE_UTF8 : WIREENC_NONE), wNewFolderWireName, ARRAYSIZE(wNewFolderWireName))));
                if (EVAL(SUCCEEDED(XboxItemID_CreateFake(wzNewFolderName, wNewFolderWireName, TRUE, FALSE, FALSE, &pidlFolder))))
                {
                    // Is this browser only?
                    if (SHELL_VERSION_W95NT4 == GetShellVersion())
                    {
                        HWND hwndDefView = NULL;
                        // Yes, so we need to do this the hard way.
                
                        // 1. 
                        ShellFolderView_SetItemPos(hwnd, pidlFolder, point.x, point.y);
                        hwndDefView = FindWindowExA(hwnd, NULL, DEFVIEW_CLASS_BROWSERONLYA, NULL);

                        if (EVAL(hwndDefView))
                        {
                            HWND hwndListView = FindWindowExA(hwndDefView, NULL, WC_LISTVIEWA, NULL);

                            if (EVAL(hwndListView))
                            {
                                 int nIndex = DefView_FindItemHack(pff, hwndListView, pidlFolder);

                                 if (EVAL(-1 != nIndex))
                                    ListView_EditLabel(hwndListView, nIndex);
                            }
                        }
                    }
                    else
                    {
                        // No, so this won't be as hard.
                        IShellView2 * pShellView2 = NULL;

//                      ASSERT(punkSite);   // Can happen when invoked from Captionbar.
                        IUnknown_QueryService(punkSite, SID_DefView, IID_IShellView2, (void **)&pShellView2);
                        if (!pShellView2)
                        {
                            IDefViewFrame * pdvf = NULL;
                            IUnknown_QueryService(punkSite, SID_DefView, IID_IDefViewFrame, (void **)&pdvf);
                            if (pdvf)   // Can fail when invoked from caption bar.
                            {
                                EVAL(SUCCEEDED(pdvf->QueryInterface(IID_IShellView2, (void **) &pShellView2)));
                                pdvf->Release();
                            }
                        }

                        if (pShellView2)    // Can fail when invoked from the caption bar.  Oh well, cry me a river.
                        {
                            if (fPosition)  // BUGBUG: This looks wrong.  (Should be ! (?))
                                pShellView2->SelectAndPositionItem(pidlFolder, (SVSI_SELECT | SVSI_TRANSLATEPT | SVSI_EDIT), &point);
                            else
                                pShellView2->SelectItem(pidlFolder, (SVSI_EDIT | SVSI_SELECT));

                            pShellView2->Release();
                        }
                    }

                    ILFree(pidlFolder);
                }
            }
            else
            {
                // An error occured, so display UI.  Most often because access is denied.
                DisplayWininetError(hwnd, TRUE, HRESULT_CODE(hr), IDS_XBOXERR_TITLE_ERROR, IDS_XBOXERR_NEWFOLDER, IDS_XBOXERR_WININET, MB_OK, NULL);
                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
            }
        }

        if (pfdTemp)
            pfdTemp->Release();
    }


    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\mem.cpp ===
/*****************************************************************************
 *
 *	mem.cpp - Memory management
 *
 *	WARNING!  These do not go through OLE allocation.  Use these
 *	only for private allocation.
 *
 *****************************************************************************/

#include "priv.h"

/*****************************************************************************
 *
 *	ReallocCbPpv
 *
 *	Change the size of some zero-initialized memory.
 *
 *	This is the single place where all memory is allocated, resized,
 *	and freed.
 *
 *	If you realloc from a null pointer, memory is allocated.
 *	If you realloc to zero-size, memory is freed.
 *
 *	These semantics avoid boundary cases.  For example, it is no
 *	longer a problem trying to realloc something down to zero.
 *	You don't have to worry about special-casing an alloc of 0 bytes.
 *
 *	If an error is returned, the original pointer is UNCHANGED.
 *	This saves you from having to the double-switch around a realloc.
 *
 *****************************************************************************/

STDMETHODIMP ReallocCbPpv(UINT cb, LPVOID * ppvArg)
{
    HRESULT hres;
    LPVOID * ppv = ppvArg;
    HLOCAL hloc = *ppv;

    if (cb)
    {			    /* Alloc or realloc */
        if (hloc)
        {		    /* Realloc */
            HLOCAL h = LocalReAlloc(hloc, cb, LMEM_MOVEABLE+LMEM_ZEROINIT);
            hloc = h;
        }
        else
        {		/* Alloc */
            hloc = LocalAlloc(LPTR, cb);
        }
    	hres = hloc ? S_OK : E_OUTOFMEMORY;
    }
    else
    {                   /* Freeing */
        if (hloc)
        {
            LocalFree(hloc);
            hloc = 0;
            hres = S_OK;    /* All gone */
        }
        else
        {
            hres = S_OK;    /* Nothing to free */
        }
    }

    if (SUCCEEDED(hres))
    {
    	*ppv = hloc;
    }
    return hres;
}

/*****************************************************************************
 *
 *	AllocCbPpv
 *
 *	Simple wrapper that forces *ppvObj = 0 before calling Realloc.
 *
 *****************************************************************************/

STDMETHODIMP AllocCbPpv(UINT cb, LPVOID * ppv)
{
    *ppv = 0;
    return ReallocCbPpv(cb, ppv);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\newmenu.h ===
/*****************************************************************************\
    FILE: newmenu.h
    
    DESCRIPTION:
        The file supports the "New" menu to create new items on the XBOX server.
    This currently only supports Folders but hopefully it will support other
    items later.
\*****************************************************************************/

#ifndef _NEWMENU_H
#define _NEWMENU_H

// For CreateNewFolderCB:
// The following struct is used when recursively downloading
// files/dirs from the XBOX server after a "Download" verb.
typedef struct tagXBOXCREATEFOLDERSTRUCT
{
    LPCWSTR             pszNewFolderName;
    CXboxFolder *        pff;
} XBOXCREATEFOLDERSTRUCT;


// Public APIs (DLL wide)
HRESULT CreateNewFolder(HWND hwnd, CXboxFolder * pff, CXboxDir * pfd, IUnknown * punkSite, BOOL fPosition, POINT point);
HRESULT CreateNewFolderCB(HINTERNET hint, HINTPROCINFO * phpi, LPVOID pvFCFS, BOOL * pfReleaseHint);


#endif // _NEWMENU_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\olestuff.cpp ===
#include "priv.h"

#define  _NO_DBGMEMORY_REDEFINITION_
#include "dbgmem.h"


#ifdef DEBUG
extern "C" LONG g_cmem = 0;
extern DWORD g_TlsMem;

struct MEMINFO {
    HMODULE hmod;
    void*   pv;
    UINT    cb;
    UINT    nType;
    // DWORD   adwCaller[4];   // for future
    LPCSTR  pszFile;            // file where memory block was allocced
    INT_PTR     iLine;              // line where memory block was allocced
};

void add_to_memlist( HMODULE hmod, void *pv, unsigned int nSize, UINT nType, LPCSTR pszFile, const INT_PTR iLine )
{
    HDSA hdsa = (HDSA)TlsGetValue(g_TlsMem);

    if ((hdsa) && (pv)) {
        MEMINFO memi = { hmod, pv, nSize, nType, pszFile, iLine };

        if (DSA_AppendItem(hdsa, &memi) >=0) {
            InterlockedIncrement(&g_cmem);
        }
    }
}

void *  __cdecl operator new( size_t nSize, LPCSTR pszFile, const int iLine )
{
    LPVOID pv;
    // Zero init just to save some headaches
    pv = ((LPVOID)LocalAlloc(LPTR, nSize));

    TraceMsg(TF_XBOXALLOCS, "operator new() pv=%#08lx, size=%d, file=%s.", pv, nSize, pszFile);
    add_to_memlist( 0, pv, nSize, DBGMEM_OBJECT, pszFile, iLine );

    return pv;
}

void *  __cdecl operator new( size_t nSize )
{
    LPVOID pv;
    CREATE_CALLERS_ADDRESS;

    // Zero init just to save some headaches
    pv = ((LPVOID)LocalAlloc(LPTR, nSize));

    TraceMsg(TF_XBOXALLOCS, "operator new() pv=%#08lx, nSize=%u, caller=%#08lx.", pv, nSize, GET_CALLERS_ADDRESS);
    add_to_memlist( 0, pv, nSize, DBGMEM_UNKNOBJ, "UNKNOWN", (INT_PTR)GET_CALLERS_ADDRESS);

    return pv;
}

int _DSA_GetPtrIndex(HDSA hdsa, void* pv)
{
    for (int i=0; i<DSA_GetItemCount(hdsa); i++) {
        MEMINFO* pmemi = (MEMINFO*)DSA_GetItemPtr(hdsa, i);
        if (pmemi->pv == pv) {
            return i;
        }
    }

    return -1;
}

void remove_from_memlist(void *pv)
{
    HDSA hdsa = (HDSA)TlsGetValue(g_TlsMem);
    if (hdsa) {
        int index = _DSA_GetPtrIndex(hdsa, pv);
        if (index >=0) {
            DSA_DeleteItem(hdsa, index);
            InterlockedDecrement(&g_cmem);
        }
    }
}

static UINT g_uMemMove = 0;
UINT mem_thread_message()
{
    if ( !g_uMemMove )
        g_uMemMove = RegisterWindowMessage(TEXT("MSIEXBOX_ThreadMemTransfer"));

    return g_uMemMove;
}

void transfer_to_thread_memlist(DWORD dwThreadId, void *pv)
{
    UINT uMsg = mem_thread_message();

    HDSA hdsa = (HDSA)TlsGetValue(g_TlsMem);
    if ( hdsa )
    {
        int index = _DSA_GetPtrIndex( hdsa, pv );
        if ( index >= 0)
        {
            MEMINFO *pMemBlock = (MEMINFO*) DSA_GetItemPtr(hdsa, index);
            MEMINFO *pNewBlock = (MEMINFO*) LocalAlloc( LPTR, sizeof(MEMINFO ));
            if ( pNewBlock )
            {
                *pNewBlock = *pMemBlock;

                // post a message to the thread giving it the memblock
                PostThreadMessage( dwThreadId, uMsg, 0, (LPARAM) pNewBlock );
            }

            // remove from the current thread's list...
            DSA_DeleteItem( hdsa, index );
            InterlockedDecrement(&g_cmem);
        }
    }
}

void remove_from_thread_memlist( DWORD dwThreadId, LPVOID pv )
{
    UINT uMsg = mem_thread_message();

    PostThreadMessage( dwThreadId, uMsg, 1, (LPARAM) pv );
}

void received_for_thread_memlist( DWORD dwFlags, void * pData )
{
    MEMINFO * pMem = (MEMINFO *) pData;
    if ( pMem ){
        if ( dwFlags )
        {
            // we are being told to remove it from our thread list because it
            // is actually being freed on the other thread....
            remove_from_memlist( pData );
            return;
        }

        HDSA hdsa = (HDSA)TlsGetValue(g_TlsMem);

        if (hdsa) {
            if (DSA_AppendItem(hdsa, pMem) >=0) {
                InterlockedIncrement(&g_cmem);
            }
        }
        LocalFree( pMem );
    }
}

void  __cdecl operator delete(void *pv)
{
    if (pv) {
        remove_from_memlist(pv);

        TraceMsg(TF_XBOXALLOCS, "operator delete(%#08lx) size=%u.", pv, LocalSize((HLOCAL)pv));

        memset(pv, 0xfe, (UINT) LocalSize((HLOCAL)pv));
        LocalFree((HLOCAL)pv);
    }
}

extern "C" int __cdecl _purecall(void) {return 0;}

void _DumpMemLeak(DWORD wFlags)
{
    HDSA hdsa;
    if (wFlags & DML_END) {
        BOOL fLeaked = FALSE;
        hdsa = (HDSA)TlsGetValue(g_TlsMem);
        if (hdsa) {
            if (DSA_GetItemCount(hdsa))
            {
                // Let's always dump them.
                TraceMsg(TF_ALWAYS, "****************************************************");
                TraceMsg(TF_ALWAYS, "*    !!!!! WARNING : MEMORY LEAK DETECTED !!!!!    *");
                TraceMsg(TF_ALWAYS, "****************************************************");
                TraceMsg(TF_ALWAYS, "* For Object: address: Vtbl, ...Vtbl, _cRef        *");
                TraceMsg(TF_ALWAYS, "* For StrDup: address: 'text'                      *");
                TraceMsg(TF_ALWAYS, "* For Traced: address:                             *");
                TraceMsg(TF_ALWAYS, "* For Memory: address:                             *");
                TraceMsg(TF_ALWAYS, "****************************************************");
                {
                    for (int i=0; i<DSA_GetItemCount(hdsa); i++) {
                        MEMINFO* pmemi = (MEMINFO*)DSA_GetItemPtr(hdsa, i);
                        DWORD* pdw = (DWORD*)pmemi->pv;
                        switch( pmemi->nType ) {
                        case DBGMEM_STRDUP:
                            TraceMsg(TF_ALWAYS, "StrDup: %8x: \"%s\"\n\t\t size=%d (%hs, line %d)",
                                     pdw, pdw, pmemi->cb, PathFindFileNameA(pmemi->pszFile), pmemi->iLine);
                            break;

                        case DBGMEM_UNKNOBJ:
                        case DBGMEM_OBJECT:
                            {
                                if ( pmemi->cb >= 32 )
                                {
                                    TraceMsg(TF_ALWAYS, "Object: %8x: %8x %8x %8x %8x",
                                        pdw, pdw[0], pdw[1], pdw[2], pdw[3] );
                                }
                                else
                                {
                                    TraceMsg(TF_ALWAYS, "Object: %8x: Size<32 bytes. No Vtbl.", pdw );
                                }
                            }
                            break;

                        case DBGMEM_TRACED:
                            TraceMsg(TF_ALWAYS, "Traced: %8x:", pdw );
                            break;

                        case DBGMEM_MEMORY:
                        default:
                            TraceMsg(TF_ALWAYS, "Memory: %8x:", pdw );
                            break;
                        }
                        if ( pmemi->nType == DBGMEM_UNKNOBJ )
                        {
                            TraceMsg(TF_ALWAYS, "\t size=%d, created from %8x (return address)",
                                             pmemi->cb, pmemi->iLine);
                        }
                        else
                        {
                            TraceMsg(TF_ALWAYS, "\t size=%d  (%hs, line %d)",
                                             pmemi->cb, PathFindFileNameA(pmemi->pszFile), pmemi->iLine);
                        }


                    }
                }
                TraceMsg(TF_ALWAYS, "*************************************************");
                AssertMsg(0, TEXT("*** ALL MEMORY LEAK MUST BE FIXED BEFORE WE RELEASE ***"));
                fLeaked = TRUE;
            }

            DSA_Destroy(hdsa);
            TlsSetValue(g_TlsMem, NULL);
        }

        if (!fLeaked) {
            TraceMsg(TF_GENERAL, "Thread Terminated: -- No Memory Leak Detected for this thread --");
        }
    } else {
        hdsa = DSA_Create(SIZEOF(MEMINFO),8);
        TlsSetValue(g_TlsMem, (LPVOID)hdsa);
    }
}

void _XBOXDebugMemLeak(UINT wFlags, LPCTSTR pszFile, UINT iLine)
{
    LPCTSTR pszSuffix = (wFlags & DML_END) ? TEXT("END") : TEXT("BEGIN");

    switch(wFlags & DML_TYPE_MASK) {
    case DML_TYPE_MAIN:
        _DumpMemLeak(wFlags);
        if (g_cmem) {
            AssertMsg(0, TEXT("MAIN: %s, line %d: %d blocks of C++ objects left in memory. "),
                     PathFindFileName(pszFile), iLine, g_cmem);
        }
        break;

    case DML_TYPE_THREAD:
            _DumpMemLeak(wFlags);
        break;

    case DML_TYPE_NAVIGATE:
        TraceMsg(TF_ALWAYS, "NAVIGATEW_%s: %s, line %d: %d blocks of C++ objects in memory",
                     pszSuffix, PathFindFileName(pszFile), iLine, g_cmem);
        break;
    }
}


// LocalXXXXX functions
HLOCAL _TrcLocalAlloc(
    UINT uFlags,                            // flags used in LocalAlloc
    UINT uBytes,                            // number of bytes to be allocated
    LPCSTR pszFile,                         // file which allocced memory
    const int iLine                         // line which allocced memory
    )
{
    HLOCAL lpv = (HLOCAL) LocalAlloc( uFlags, uBytes );
    if ( lpv )
        add_to_memlist( 0, lpv, uBytes, DBGMEM_MEMORY, pszFile, iLine );

    return lpv;
}


LPTSTR  _TrcStrDup(
    LPTSTR lpSrch,                          // pointer to string to StrDup
    LPCSTR pszFile,                         // file which allocced memory
    const int iLine                         // line which allocced memory
    )
{
    UINT uBytes = 0;
    if ( lpSrch )
        uBytes = lstrlen( lpSrch ) + 1;

    LPTSTR lpstr = StrDup( lpSrch );
    if ( lpstr )
        add_to_memlist( 0, lpstr, uBytes, DBGMEM_STRDUP, pszFile, iLine );

    return lpstr;
}

HLOCAL _TrcLocalFree(
    HLOCAL hMem                             // memory to be freed
    )
{
    if ( hMem )
    {
        remove_from_memlist( hMem );
        memset( hMem, 0xfe, (UINT) LocalSize( hMem ));
    }
    return LocalFree( hMem );
}

void  register_intelli_dump(HMODULE hmod, const INTELLILEAKDUMPCBFUNCTIONS *pfns)
{
    // BUGBUG:: this is part way to integrating the leaks...
}

#else
#define CPP_FUNCTIONS
#include <crtfree.h>

void _XBOXDebugMemLeak(UINT wFlags, LPCTSTR pszFile, UINT iLine)
{
    // Do nothing in RETAIL.
}

#endif


BOOL GetLeakDetectionFunctionTable(LEAKDETECTFUNCS *pTable)
{


#ifdef DEBUG

    if(pTable)
    {
        pTable->pfnDumpMemLeak = _DumpMemLeak;
        pTable->pfnTrcLocalAlloc = _TrcLocalAlloc;

        pTable->pfnTrcLocalFree = _TrcLocalFree;

        pTable->pfnTrcStrDup = _TrcStrDup;

        pTable->pfnDumpMemLeak = _DumpMemLeak;
        pTable->pfnDebugMemLeak = _XBOXDebugMemLeak;
        pTable->pfnreceived_for_thread_memlist = received_for_thread_memlist;
        pTable->pfnremove_from_thread_memlist = remove_from_thread_memlist;
        pTable->pfnmem_thread_message = mem_thread_message;
        pTable->pfnremove_from_memlist = remove_from_memlist;
        pTable->pfnadd_to_memlist = add_to_memlist;
        pTable->pfnregister_hmod_intelli_dump = register_intelli_dump;


        return TRUE;
    }
    else
    {
        return FALSE;
    }
#else
    return FALSE;
#endif


}

// We export all the memory leak detection functions in the form of a table of
// pointers so that all other shell components can share in the same leak
// detection code





// -----------------------------------------------------------------------------

IMalloc* g_pmalloc = NULL;

HRESULT _InitMalloc(void)
{
    HRESULT hres = S_OK;
    ENTERCRITICAL;
    if (g_pmalloc == NULL)
        hres = CoGetMalloc(MEMCTX_TASK, &g_pmalloc);
    LEAVECRITICAL;
    return hres;
}

LPVOID OleAlloc(UINT cb)
{
    if (g_pmalloc == NULL)
        _InitMalloc();

    ASSERT(g_pmalloc);
    return g_pmalloc->Alloc(cb);
}

void   OleFree(LPVOID pb)
{
    if (g_pmalloc == NULL)
        _InitMalloc();

    ASSERT(g_pmalloc);
    g_pmalloc->Free(pb);
}

// Helper function
int _LoadStringW(HINSTANCE hinst, UINT id, LPWSTR wsz, UINT cchMax)
{
    char szT[512];
    if (LoadStringA(hinst, id, szT, ARRAYSIZE(szT)))
    {
        TraceMsg(0, "LoadStringW just loaded (%s)", szT);
        return SHAnsiToUnicode(szT, wsz, cchMax) - 1;    // -1 for terminator
    }
    else
    {
        TraceMsg(DM_TRACE, "sdv TR LoadStringW(%x) failed", id);
        wsz[0] = L'\0';
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\passwordapi.cpp ===
/*****************************************************************************\
    FILE: passwordapi.cpp
    
    DESCRIPTION:
        We want to store XBOX passwords in a secure API.  We will use the
    PStore APIs on WinNT and the PWL APIs on Win9x.  This code was taken
    from wininet.

    Copyright (c) 1998-1999  Microsoft Corporation
\*****************************************************************************/

#include "priv.h"
#include <pstore.h>
#include <passwordapi.h>

typedef HRESULT (*PFNPSTORECREATEINSTANCE)(IPStore**, PST_PROVIDERID*, VOID*, DWORD);

// Globals
#define SIZE_MAX_KEY_SIZE               2048    // For lookup key (In our case, URL w/user name & server, without password & path)
#define SIZE_MAX_VALUE_SIZE             2048    // For stored value (In our case the password)


// MPR.DLL exports used by top level API.
typedef DWORD (APIENTRY *PFWNETGETCACHEDPASSWORD)    (LPCSTR, WORD, LPCSTR, LPWORD, BYTE);
typedef DWORD (APIENTRY *PFWNETCACHEPASSWORD)        (LPCSTR, WORD, LPCSTR, WORD, BYTE, UINT);
typedef DWORD (APIENTRY *PFWNETREMOVECACHEDPASSWORD) (LPCSTR, WORD, BYTE);

// PWL related variables.
static HMODULE MhmodWNET                                        = NULL;
static PFWNETGETCACHEDPASSWORD g_pfWNetGetCachedPassword        = NULL;
static PFWNETCACHEPASSWORD g_pfWNetCachePassword                = NULL;
static PFWNETREMOVECACHEDPASSWORD g_pfWNetRemoveCachedPassword  = NULL;

// Pstore related variables.
static PFNPSTORECREATEINSTANCE s_pPStoreCreateInstance = NULL;

#define STR_XBOX_CACHE_CREDENTIALS                   L"MS IE XBOX Passwords";
#define PSTORE_MODULE                               TEXT("pstorec.dll")
#define WNETDLL_MODULE                              TEXT("mpr.dll")
#define WNETGETCACHEDPASS                           "WNetGetCachedPassword"
#define WNETCACHEPASS                               "WNetCachePassword"
#define WNETREMOVECACHEDPASS                        "WNetRemoveCachedPassword"

#define DISABLE_PASSWORD_CACHE        1


// PWL related defines.

// Password-cache-entry, this should be in PCACHE.
#define PCE_WWW_BASIC 0x13  

// TODO/BUGBUG: We should call FreeLibrary(PSTORE_MODULE) before our DLL unloads.


// Wininet uses this GUID for pstore:
// {5E7E8100-9138-11d1-945A-00C04FC308FF}
static const GUID GUID_PStoreType = 
{ 0x5e7e8100, 0x9138, 0x11d1, { 0x94, 0x5a, 0x0, 0xc0, 0x4f, 0xc3, 0x8, 0xff } };


// Private function prototypes.
// PWL private function prototypes.
DWORD PWLSetCachedCredentials(LPCSTR pszKey, DWORD cbKey, LPCSTR pszCred, DWORD cbCred);
DWORD PWLGetCachedCredentials(LPCSTR pszKey, DWORD cbKey, LPSTR cbCred, LPDWORD pcbCred);
DWORD PWLRemoveCachedCredentials(LPCSTR pszKey, DWORD cbKey);

BOOL LoadWNet(VOID);


// PStore private function prototypes.
DWORD PStoreSetCachedCredentials(LPCWSTR pszKey, LPCWSTR pszCred, DWORD cbCred, BOOL fRemove=FALSE);
DWORD PStoreGetCachedCredentials(LPCWSTR pszKey, LPWSTR pszCred, LPDWORD pcbCred);
DWORD PStoreRemoveCachedCredentials(LPCWSTR pszKey);

HRESULT CreatePStore(IPStore **ppIPStore);
STDAPI ReleasePStore(IPStore *pIPStore);

// *--------------------------- Top Level APIs ---------------------------------*



/****************************************************\
    FUNCTION: InitCredentialPersist

    DESCRIPTION:
        Try to init the cache.   

    PARAMETERS:
    Return Value:
        S_OK if it will work correctly.
        S_FASE if turned off by admin.
        HRESULT_FROM_WIN32(ERROR_PRODUCT_UNINSTALLED) if the password caching APIs aren't installed on NT.
\****************************************************/
HRESULT InitCredentialPersist(void)
{
    HRESULT hr = S_OK;
    DWORD dwDisable;
    DWORD cbSize = sizeof(dwDisable);

    // First check to see if persistence is disabled via registry.
    if ((ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, SZ_REGKEY_INTERNET_SETTINGS, SZ_REGVALUE_DISABLE_PASSWORD_CACHE, NULL, (void *)&dwDisable, &cbSize))
        && (dwDisable == DISABLE_PASSWORD_CACHE))
    {
        // Persistence disabled via registry.
        hr = S_FALSE;
    }

    if (S_OK == hr)
    {
        // We use PWL for Win95; this should be available.
        if (!IsOS(OS_NT))
        {
            // hr already equals S_OK and no more work is needed.
        }
        else
        {
            HINSTANCE hInstPStoreC = 0;

            // If is WinNT, check if PStore is installed. 
            hInstPStoreC = LoadLibrary(PSTORE_MODULE);
            if (!hInstPStoreC)
                hr = HRESULT_FROM_WIN32(ERROR_PRODUCT_UNINSTALLED);
            else
            {
                // Get CreatePStoreInstance function pointer.
                s_pPStoreCreateInstance = (PFNPSTORECREATEINSTANCE) GetProcAddress(hInstPStoreC, "PStoreCreateInstance");

                if (!s_pPStoreCreateInstance)
                    hr = HRESULT_FROM_WIN32(ERROR_PRODUCT_UNINSTALLED);
                else
                {
                    IPStore * pIPStore = NULL;

                    // Create an IPStore.
                    hr = CreatePStore(&pIPStore);
        
                    // We just did this to see if it worked, so
                    // the hr was set correctly.
                    if (pIPStore)
                        ReleasePStore(pIPStore);
                }
            }
        }
    }

    return hr;
}


/****************************************************\
    FUNCTION: SetCachedCredentials

    DESCRIPTION:

    PARAMETERS:
\****************************************************/
HRESULT SetCachedCredentials(LPCWSTR pwzKey, LPCWSTR pwzValue)
{
    // Check if credential persistence is available.
    HRESULT hr = InitCredentialPersist();

    if (S_OK == hr)
    {
        // Store credentials.
        if (!IsOS(OS_NT))
        {
            CHAR szKey[SIZE_MAX_KEY_SIZE];
            CHAR szValue[SIZE_MAX_VALUE_SIZE];

            ASSERT(lstrlenW(pwzKey) < ARRAYSIZE(szKey));
            ASSERT(lstrlenW(pwzValue) < ARRAYSIZE(szValue));
            SHUnicodeToAnsi(pwzKey, szKey, ARRAYSIZE(szKey));
            SHUnicodeToAnsi(pwzValue, szValue, ARRAYSIZE(szValue));
            DWORD cbKey = ((lstrlenA(szKey) + 1) * sizeof(szKey[0]));
            DWORD cbCred = ((lstrlenA(szValue) + 1) * sizeof(szValue[0]));

            // Store credentials using PWL.
            DWORD dwError = PWLSetCachedCredentials(szKey, cbKey, szValue, cbCred);
            hr = HRESULT_FROM_WIN32(dwError);
        }
        else
        {
            DWORD cbCred = ((lstrlenW(pwzValue) + 1) * sizeof(pwzValue[0]));

            // Store credentials using PStore.
            DWORD dwError = PStoreSetCachedCredentials(pwzKey, pwzValue, cbCred);
            hr = HRESULT_FROM_WIN32(dwError);
        }
    }

    return hr;
}


/****************************************************\
    FUNCTION: GetCachedCredentials

    DESCRIPTION:

    PARAMETERS:
\****************************************************/
HRESULT GetCachedCredentials(LPCWSTR pwzKey, LPWSTR pwzValue, DWORD cchSize)
{
    // Check if credential persistence is available.
    HRESULT hr = InitCredentialPersist();

    if (S_OK == hr)
    {
        // Store credentials.
        if (!IsOS(OS_NT))
        {
            CHAR szKey[SIZE_MAX_KEY_SIZE];
            CHAR szValue[SIZE_MAX_VALUE_SIZE];
            DWORD cchTempSize = ARRAYSIZE(szValue);

            ASSERT(lstrlenW(pwzKey) < ARRAYSIZE(szKey));
            ASSERT(cchSize < ARRAYSIZE(szValue));
            SHUnicodeToAnsi(pwzKey, szKey, ARRAYSIZE(szKey));
            DWORD cbKey = ((lstrlenA(szKey) + 1) * sizeof(szKey[0]));

            szValue[0];
            // Store credentials using PWL.
            DWORD dwError = PWLGetCachedCredentials(szKey, cbKey, szValue, &cchTempSize);
            hr = HRESULT_FROM_WIN32(dwError);
            SHAnsiToUnicode(szValue, pwzValue, cchSize);
        }
        else
        {
            cchSize++;  // Include terminator.
            cchSize *= sizeof(pwzValue[0]);

            pwzValue[0] = 0;
            // Store credentials using PStore.
            DWORD dwError = PStoreGetCachedCredentials(pwzKey, pwzValue, &cchSize);
            hr = HRESULT_FROM_WIN32(dwError);
        }

    }

    return hr;
}


/****************************************************\
    FUNCTION: RemoveCachedCredentials

    DESCRIPTION:

    PARAMETERS:
\****************************************************/
HRESULT RemoveCachedCredentials(LPCWSTR pwzKey)
{
    // Check if credential persistence is available.
    HRESULT hr = InitCredentialPersist();

    if (S_OK == hr)
    {
        // Store credentials.
        if (!IsOS(OS_NT))
        {
            CHAR szKey[SIZE_MAX_KEY_SIZE];
            ASSERT(lstrlenW(pwzKey) < ARRAYSIZE(szKey));
            SHUnicodeToAnsi(pwzKey, szKey, ARRAYSIZE(szKey));
            DWORD cbKey = (lstrlenA(szKey) * sizeof(szKey[0]));

            // Remove credentials from PWL.
            DWORD dwError = PWLRemoveCachedCredentials(szKey, cbKey);
            hr = HRESULT_FROM_WIN32(dwError);
        }
        else
        {
            // Remove credentials from PStore.
            DWORD dwError = PStoreRemoveCachedCredentials(pwzKey);
            hr = HRESULT_FROM_WIN32(dwError);
        }

    }

    return hr;
}


/*--------------------------- PWL Functions ---------------------------------*/



/*-----------------------------------------------------------------------------
  PWLSetCachedCredentials
  ---------------------------------------------------------------------------*/
DWORD PWLSetCachedCredentials(LPCSTR pszKey, DWORD cbKey, 
                              LPCSTR pszCred, DWORD cbCred)
{
    DWORD dwError;

    // Load WNet.
    if (!LoadWNet())
        return ERROR_INTERNET_INTERNAL_ERROR;
    
    // Store credentials.  
    dwError =  (*g_pfWNetCachePassword) (pszKey, (WORD) cbKey, pszCred, (WORD) cbCred, PCE_WWW_BASIC, 0); 

    return dwError;
}




/*-----------------------------------------------------------------------------
  PWLGetCachedCredentials
  ---------------------------------------------------------------------------*/
DWORD PWLGetCachedCredentials  (LPCSTR pszKey, DWORD cbKey, 
                                LPSTR pszCred, LPDWORD pcbCred)
{    
    DWORD dwError;

    // Load WNet.
    if (!LoadWNet())
        return ERROR_INTERNET_INTERNAL_ERROR;

    // Retrieve credentials.
    dwError = (*g_pfWNetGetCachedPassword) (pszKey, (WORD) cbKey, pszCred, 
                                          (LPWORD) pcbCred, PCE_WWW_BASIC);
    
    return dwError;
}



/*-----------------------------------------------------------------------------
  PWLRemoveCachedCredentials
  ---------------------------------------------------------------------------*/
DWORD PWLRemoveCachedCredentials  (LPCSTR pszKey, DWORD cbKey)
{
    DWORD dwError;

    // Load WNet.
    if (!LoadWNet())
        return ERROR_INTERNET_INTERNAL_ERROR;

    dwError = (*g_pfWNetRemoveCachedPassword) (pszKey, (WORD) cbKey, PCE_WWW_BASIC);

    return dwError;
}


// PWL utility functions.


/*-----------------------------------------------------------------------------
  LoadWNet
  ---------------------------------------------------------------------------*/
BOOL LoadWNet(VOID)
{
    BOOL fReturn;
    
    // MPR.DLL already loaded.
    if (MhmodWNET) 
    {
        fReturn = TRUE;
        goto quit;
    }

    // Load MPR.DLL
    MhmodWNET = LoadLibrary(WNETDLL_MODULE);
    
    // Fail if not loaded.
    if (MhmodWNET) 
    {
        fReturn = TRUE;
    }
    else
    {
        fReturn = FALSE;
        goto quit;
    }

    g_pfWNetGetCachedPassword    = (PFWNETGETCACHEDPASSWORD)    GetProcAddress(MhmodWNET, WNETGETCACHEDPASS);
    g_pfWNetCachePassword        = (PFWNETCACHEPASSWORD)        GetProcAddress(MhmodWNET, WNETCACHEPASS);
    g_pfWNetRemoveCachedPassword = (PFWNETREMOVECACHEDPASSWORD) GetProcAddress(MhmodWNET, WNETREMOVECACHEDPASS);

    // Ensure we have all function pointers.
    if (!(g_pfWNetGetCachedPassword 
          && g_pfWNetCachePassword
          && g_pfWNetRemoveCachedPassword))
    {
        fReturn = FALSE;
    }

quit:
    
    return fReturn;
}



/*------------------------- PStore Functions -------------------------------*/



/*-----------------------------------------------------------------------------
  PStoreSetCachedCredentials
  ---------------------------------------------------------------------------*/
DWORD PStoreSetCachedCredentials(LPCWSTR pszKey, LPCWSTR pszCred, DWORD cbCred, BOOL fRemove)
{
    ASSERT(s_pPStoreCreateInstance);

    HRESULT         hr;
    DWORD           dwError;
    
    PST_TYPEINFO    typeInfo;
    PST_PROMPTINFO  promptInfo = {0};

    GUID itemType    = GUID_PStoreType;
    GUID itemSubtype = GUID_NULL;

    IPStore *       pStore = NULL;
    
    // PST_TYPEINFO data.
    typeInfo.cbSize = sizeof(typeInfo);
    typeInfo.szDisplayName = STR_XBOX_CACHE_CREDENTIALS;

    // PST_PROMPTINFO data (no prompting desired).
    promptInfo.cbSize        = sizeof(promptInfo);
    promptInfo.dwPromptFlags = 0;
    promptInfo.hwndApp       = NULL;
    promptInfo.szPrompt      = NULL;

    // Create a PStore interface.
    hr = CreatePStore(&pStore);
    if (!SUCCEEDED(hr))
        goto quit;

    ASSERT(pStore != NULL);
               
    // Create a type in HKCU.
    hr = pStore->CreateType(PST_KEY_CURRENT_USER, &itemType, &typeInfo, 0);
    if (!((SUCCEEDED(hr)) || (hr == PST_E_TYPE_EXISTS)))
        goto quit;

    // Create subtype.
    hr = pStore->CreateSubtype(PST_KEY_CURRENT_USER, &itemType, 
                               &itemSubtype, &typeInfo, NULL, 0);

    if (!((SUCCEEDED(hr)) || (hr == PST_E_TYPE_EXISTS)))
        goto quit;
            
    // Valid credentials are written; No credentials imples
    // that the key and credentials are to be deleted.
    if (pszCred && cbCred && !fRemove)
    {
        // Write key and credentials to PStore.
        hr = pStore->WriteItem(PST_KEY_CURRENT_USER,
                               &itemType,
                               &itemSubtype,
                               pszKey,
                               cbCred,
                               (LPBYTE) pszCred,
                               &promptInfo,
                               PST_CF_NONE,
                               0);
    }
    else
    {
        // Delete key and credentials from PStore.
        hr = pStore->DeleteItem(PST_KEY_CURRENT_USER,
                                &itemType,
                                &itemSubtype,
                                pszKey,
                                &promptInfo,
                                0);

    }

quit:

    // Release the interface, convert error and return.
    ReleasePStore(pStore);
    
    if (SUCCEEDED(hr))
        dwError = ERROR_SUCCESS;
    else
        dwError = ERROR_INTERNET_INTERNAL_ERROR;

    return dwError;
}                                                                       


/*-----------------------------------------------------------------------------
  PStoreGetCachedCredentials
  ---------------------------------------------------------------------------*/
DWORD PStoreGetCachedCredentials(LPCWSTR pszKey, LPWSTR pszCred, LPDWORD pcbCred)
{
    ASSERT(s_pPStoreCreateInstance);

    HRESULT          hr ;
    DWORD            dwError;
    LPBYTE           pbData;

    PST_PROMPTINFO   promptInfo  = {0};

    GUID             itemType    = GUID_PStoreType;
    GUID             itemSubtype = GUID_NULL;

    IPStore*         pStore      = NULL;
    
    // PST_PROMPTINFO data (no prompting desired).
    promptInfo.cbSize        = sizeof(promptInfo);
    promptInfo.dwPromptFlags = 0;
    promptInfo.hwndApp       = NULL;
    promptInfo.szPrompt      = NULL;

    // Create a PStore interface.
    hr = CreatePStore(&pStore);
    if (!SUCCEEDED(hr))
        goto quit;

    ASSERT(pStore != NULL);

    // Read the credentials from PStore.
    hr = pStore->ReadItem(PST_KEY_CURRENT_USER,
                          &itemType,
                          &itemSubtype,
                          pszKey,
                          pcbCred,
                          (LPBYTE*) &pbData,
                          &promptInfo,
                          0);

    // Copy credentials and free buffer allocated by ReadItem.
    if (SUCCEEDED(hr))
    {
        memcpy(pszCred, pbData, *pcbCred);
        CoTaskMemFree(pbData);
        //hr = S_OK;
    }

quit:

    // Release the interface, convert error and return.
    ReleasePStore(pStore);

    if (SUCCEEDED(hr))
        dwError = ERROR_SUCCESS;
    else
        dwError = ERROR_INTERNET_INTERNAL_ERROR;
    
    return dwError;
}

/*-----------------------------------------------------------------------------
  PStoreRemoveCachedCredentials
  ---------------------------------------------------------------------------*/
DWORD PStoreRemoveCachedCredentials(LPCWSTR pszKey)
{
    // Pass in TRUE to remove credentials.
    return PStoreSetCachedCredentials(pszKey, NULL, 0, TRUE);
}

// PStore utility functions

/*-----------------------------------------------------------------------------
  CreatePStore
  ---------------------------------------------------------------------------*/
HRESULT CreatePStore(IPStore **ppIPStore)
{
    return s_pPStoreCreateInstance (ppIPStore, NULL, NULL, 0);
}


/*-----------------------------------------------------------------------------
  ReleasePStore
  ---------------------------------------------------------------------------*/
STDAPI ReleasePStore(IPStore *pIPStore)
{
    HRESULT hr;

    if (pIPStore)
    {
        pIPStore->Release();
        hr = S_OK;
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\offline.cpp ===
/****************************************************\
    FILE: offline.cpp

    DESCRIPTION:
        Handle 'offline' status and Dial-up UI
\****************************************************/

#include <wininet.h>
#include "priv.h"
#include "util.h"


#ifdef FEATURE_OFFLINE
/****************************************************\
    FUNCTION: IsGlobalOffline

    DESCRIPTION:
        Determines whether wininet is in global offline mode

    PARAMETERS:
        None

    RETURN VALUE:
        BOOL
            TRUE    - offline
            FALSE   - online
\****************************************************/
BOOL IsGlobalOffline(VOID)
{
    DWORD   dwState = 0, dwSize = sizeof(DWORD);
    BOOL    fRet = FALSE;

    if(InternetQueryOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &dwState, &dwSize))
    {
        if(dwState & INTERNET_STATE_DISCONNECTED_BY_USER)
            fRet = TRUE;
    }

    return fRet;
}


/****************************************************\
    FUNCTION: SetOffline

    DESCRIPTION:
        Sets wininet's offline mode

    PARAMETERS:
        fOffline - online or offline

    RETURN VALUE:
        None.
\****************************************************/
VOID SetOffline(IN BOOL fOffline)
{
    INTERNET_CONNECTED_INFO ci = {0};

    if(fOffline)
    {
        ci.dwConnectedState = INTERNET_STATE_DISCONNECTED_BY_USER;
        ci.dwFlags = ISO_FORCE_DISCONNECTED;
    }
    else
    {
        ci.dwConnectedState = INTERNET_STATE_CONNECTED;
    }

    InternetSetOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &ci, sizeof(ci));
}
#endif // FEATURE_OFFLINE


/****************************************************\
    FUNCTION: AssureNetConnection

    DESCRIPTION:
\****************************************************/
HRESULT AssureNetConnection(HINTERNET hint, HWND hwndParent, LPCWSTR pwzServerName, LPCITEMIDLIST pidl, BOOL fShowUI)
{
    HRESULT hr = S_OK;

#ifdef FEATURE_OFFLINE
    if (IsGlobalOffline())
    {
        // Assume we need to cancel the XBOX operation because we are offline.
        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);

        // Can we prompt to go online?
        if (fShowUI)
        {
            TCHAR szTitle[MAX_PATH];
            TCHAR szPromptMsg[MAX_PATH];

            EVAL(LoadString(HINST_THISDLL, IDS_XBOXERR_TITLE, szTitle, ARRAYSIZE(szTitle)));
            EVAL(LoadString(HINST_THISDLL, IDS_OFFLINE_PROMPTTOGOONLINE, szPromptMsg, ARRAYSIZE(szPromptMsg)));

            if (IDYES == MessageBox(hwndParent, szPromptMsg, szTitle, (MB_ICONQUESTION | MB_YESNO)))
            {
                SetOffline(FALSE);
                hr = S_OK;
            }
        }
    }
#endif // FEATURE_OFFLINE

#ifdef FEATURE_DIALER
    if (S_OK == hr)
    {
        TCHAR szUrl[MAX_URL_STRING];

        StrCpyN(szUrl, TEXT("xbox://"), ARRAYSIZE(szUrl));
        StrCatBuff(szUrl, pwzServerName, ARRAYSIZE(szUrl));

        // PERF: Does this value get cached?
        if (FALSE == InternetCheckConnection(szUrl, FLAG_ICC_FORCE_CONNECTION, 0)
            ||
#ifdef FEATURE_TEST_DIALER
        (IDNO == MessageBox(hwndParent, TEXT("TEST: Do you want to dial?"), TEXT("Test Dialer"), MB_YESNO))
#endif // FEATURE_TEST_DIALER
            )
        {
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
        }
    }
#endif // FEATURE_DIALER

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\proxycache.h ===
/*****************************************************************************\
    FILE: proxycache.h
    
    DESCRIPTION:
        XBOX Folder uses WININET which doesn't work thru CERN proxies.  In that
    case, we need to hand control of the XBOX URL back to the browser to do the
    old URLMON handling of it.  The problem is that testing for a CERN proxy
    blocking access is expensive.
\*****************************************************************************/

#ifndef _PROXYCACHE_H
#define _PROXYCACHE_H

// Public APIs (DLL wide)
BOOL ProxyCache_IsProxyBlocking(LPCITEMIDLIST pidl, BOOL * pfIsBlocking);
void ProxyCache_SetProxyBlocking(LPCITEMIDLIST pidl, BOOL fIsBlocking);

#endif // _PROXYCACHE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\security.h ===
/*****************************************************************************\
    FILE: security.h
\*****************************************************************************/

#ifndef _SECURITY_H
#define _SECURITY_H


BOOL ZoneCheckUrlAction(IUnknown * punkSite, DWORD dwAction, LPCTSTR pszUrl, DWORD dwFlags);
BOOL ZoneCheckPidlAction(IUnknown * punkSite, DWORD dwAction, LPCITEMIDLIST pidl, DWORD dwFlags);


#endif // _SECURITY_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\security.cpp ===
/*****************************************************************************\
    FILE: security.h
\*****************************************************************************/

#include "priv.h"
#include "util.h"
#include <imm.h>
#include <mshtml.h>

// /*
// Declared in \shell\lib\security.cpp and I should create a header for it.
STDAPI GetHTMLDoc2(IUnknown *punk, IHTMLDocument2 **ppHtmlDoc);

BOOL ProcessUrlAction(IUnknown * punkSite, LPCTSTR pszUrl, DWORD dwAction, DWORD dwFlags)
{
    BOOL fAllowed = FALSE;

    if (pszUrl) 
    {
        IInternetSecurityManager *pSecMgr;
        if (SUCCEEDED(CoCreateInstance(CLSID_InternetSecurityManager, 
                                       NULL, CLSCTX_INPROC_SERVER,
                                       IID_IInternetSecurityManager, 
                                       (void **)&pSecMgr))) 
        {
            WCHAR wzUrl[MAX_URL_STRING];
            DWORD dwZoneID = URLZONE_UNTRUSTED;
            DWORD dwPolicy = 0;
            DWORD dwContext = 0;

            IUnknown_SetSite(pSecMgr, punkSite);
            SHTCharToUnicode(pszUrl, wzUrl, ARRAYSIZE(wzUrl));
            if (S_OK == pSecMgr->ProcessUrlAction(wzUrl, dwAction, (BYTE *)&dwPolicy, sizeof(dwPolicy), (BYTE *)&dwContext, sizeof(dwContext), dwFlags, 0))
            {
                if (GetUrlPolicyPermissions(dwPolicy) == URLPOLICY_ALLOW)
                    fAllowed = TRUE;
            }
            IUnknown_SetSite(pSecMgr, NULL);
            pSecMgr->Release();
        }
    } 

    return fAllowed;
}


/*****************************************************************************\
    FUNCTION: SecurityZoneCheck
    
    PARAMETERS:
        punkSite: Site for QS, and enabling modal if UI needed.
        dwAction: verb to check. normally URLACTION_SHELL_VERB
        pidl: XBOX URL that we need to verify
        pszUrl: XBOX URL that we need to verify
        dwFlags: normally PUAF_DEFAULT | PUAF_WARN_IF_DENIED

    DESCRIPTION:
        Only pidl or pszUrl is passed.  This function will check if the verb
    (dwAction) is allowed in this zone.  Our first job is to find the zone which
    can be any of the following:
    1. Third party app that supports IInternetHostSecurityManager have a chance to disallow the action.
    2. Hosted in DefView w/WebView.  Zone of WebView can fail the action.
    3. Hosted in HTML FRAME.  Zone comes from trident can fail the action
    4. Hosted in DefView w/o WebView.  Zone comes from pidl or pszUrl and that can fail the action.
\*****************************************************************************/
BOOL ZoneCheckUrlAction(IUnknown * punkSite, DWORD dwAction, LPCTSTR pszUrl, DWORD dwFlags)
{
    BOOL IsSafe = TRUE; // Assume we will allow this.
    IInternetHostSecurityManager * pihsm;

    // What we want to do is allow this to happen only if the author of the HTML that hosts
    // the DefView is safe.  It's OK if they point to something unsafe, because they are
    // trusted.
    // 1. Third party app that supports IInternetHostSecurityManager have a chance to disallow the action.
    if (SUCCEEDED(IUnknown_QueryService(punkSite, IID_IInternetHostSecurityManager, IID_IInternetHostSecurityManager, (void**)&pihsm)))
    {
        if (S_OK != ZoneCheckHost(pihsm, dwAction, dwFlags))
        {
            // This zone is not OK or the user choose to not allow this to happen,
            // so cancel the operation.
            IsSafe = FALSE;    // Turn off functionality.
        }

        pihsm->Release();
    }

    // 1. Hosted in DefView w/WebView.  Zone of WebView can fail the action.
    if (IsSafe)
    {
        IOleCommandTarget * pct;

        if (SUCCEEDED(IUnknown_QueryService(punkSite, SID_DefView, IID_IOleCommandTarget, (void **)&pct)))
        {
            VARIANT vTemplatePath;
            vTemplatePath.vt = VT_EMPTY;
            if (pct->Exec(&CGID_DefView, DVCMDID_GETTEMPLATEDIRNAME, 0, NULL, &vTemplatePath) == S_OK)
            {
                if ((vTemplatePath.vt == VT_BSTR) && (S_OK != LocalZoneCheckPath(vTemplatePath.bstrVal)))
                    IsSafe = FALSE;

                // We were able to talk to the browser, so don't fall back on Trident because they may be
                // less secure.
                VariantClear(&vTemplatePath);
            }
            pct->Release();
        }
    }
    
    // 3. Hosted in HTML FRAME.  Zone comes from trident can fail the action
    if (IsSafe)
    {
        // Try to use the URL from the document to zone check 
        IHTMLDocument2 *pHtmlDoc;
        if (punkSite && SUCCEEDED(GetHTMLDoc2(punkSite, &pHtmlDoc)))
        {
            BSTR bstrPath;
            if (SUCCEEDED(pHtmlDoc->get_URL(&bstrPath)))
            {
                if (S_OK != ZoneCheckHost(pihsm, dwAction, dwFlags))
                {
                    // This zone is not OK or the user choose to not allow this to happen,
                    // so cancel the operation.
                    IsSafe = FALSE;    // Turn off functionality.
                }
                SysFreeString(bstrPath);
            }
            pHtmlDoc->Release();
        }
    }

    // 4. Hosted in DefView w/o WebView.  Zone comes from pidl or pszUrl and that can fail the action.
    if (IsSafe)
    {
        IsSafe = ProcessUrlAction(punkSite, pszUrl, dwAction, dwFlags);
    }

    return IsSafe;
}

//*/
BOOL ZoneCheckPidlAction(IUnknown * punkSite, DWORD dwAction, LPCITEMIDLIST pidl, DWORD dwFlags)
{
    TCHAR szUrl[MAX_URL_STRING];

    if (FAILED(UrlCreateFromPidl(pidl, SHGDN_FORPARSING, szUrl, ARRAYSIZE(szUrl), (ICU_ESCAPE | ICU_USERNAME), FALSE)))
        return FALSE;

    return ZoneCheckUrlAction(punkSite, dwAction, szUrl, dwFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\passwordapi.h ===
/*****************************************************************************\
    FILE: passwordapi.h
    
    DESCRIPTION:
        We want to store XBOX passwords in a secure API.  We will use the
    PStore APIs on WinNT and the PWL APIs on Win9x.  This code was taken
    from wininet.

    Copyright (c) 1998  Microsoft Corporation
\*****************************************************************************/

#ifndef _PASSWORDAPI_H
#define _PASSWORDAPI_H

#include "priv.h"
#include "util.h"


// ----------------Public function prototypes----------------------

// Determines availability of credential cache.
HRESULT InitCredentialPersist(void);

// Persist credentials (username/password).
HRESULT SetCachedCredentials(LPCWSTR pszKey, LPCWSTR pszValue);

// Get persisted credentials (username/password).
HRESULT GetCachedCredentials(LPCWSTR pszKey, LPWSTR pszValue, DWORD cchSize);

// Remove persisted credentials (username/password).
HRESULT RemoveCachedCredentials(LPCWSTR pszKey);

HRESULT InitCredentialPersist(void);


#endif // _PASSWORDAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\resource.h ===
// Resource IDs for XBOXFOLDR
//


// This means the control won't have a name.
#define IDC_UNUSED          -1


/*****************************************************************************
 *
 *      Icons
 *
 *****************************************************************************/

//#define IDI_XBOXSERVER       1               // Icon for an XBOX Server
#define IDI_XBOXSERVER       IDI_XBOXFOLDER   // Icon for an XBOX Server
#define IDI_XBOXFOLDER       2               // Icon for a closed folder on a XBOX Server
#define IDI_XBOXOPENFOLDER   3               // Icon for an open folder on a XBOX Server
#define IDI_XBOXMULTIDOC     4               // Icon for several Xbox items.
#define IDI_DELETEITEM      5               // Delete File
// 2 Holes
#define IDI_REPLACE         8               // File being overwritten
#define IDI_KEY             9               // Key icon for Login As dialog
//#define IDI_NETFOLDER       10              // Folder for Proxy Blocking dialog
#define IDI_NETFOLDER       IDI_XBOXFOLDER   // Folder for Proxy Blocking dialog

#define IDI_WRITE_ALLOWED   10              // This folder has write access 
#define IDI_WRITE_NOTALLOWED 11             // This folder does not have read access 

/*****************************************************************************
 *
 *      Menus
 *
 *****************************************************************************/

#define IDM_ITEMCONTEXT         1   // Context menu for items

#define IDM_M_FOLDERVERBS       0   // Verbs only for folders
#define IDM_M_FILEVERBS         1   // Verbs only for files
#define IDM_M_VERBS             2   // Verbs appropriate for all selected items (in addition to above)
#define IDM_M_SHAREDVERBS       3   // Verbs shared with defview (Common Shell verbs that aren't added in Context Menu)
#define IDM_M_BACKGROUNDVERBS   4   // Verbs for the background menu (only when nothing is selected)

#define IDM_M_BACKGROUND_POPUPMERGE     10   // Items that need to be merged with the current menu. (Arrange Items).

#define IDC_ITEM_OPEN           0   // &Open -- folders only
#define IDC_ITEM_EXPLORE        1   // &Explore -- folders only
#define IDC_ITEM_DOWNLOAD       2   // Do&wnload
#define IDC_ITEM_BKGNDPROP      3   // Properties for the background folder.
#define IDC_LOGIN_AS            4   // Login as...
#define IDC_ITEM_NEWFOLDER      5   // New Folder - Background Folder Only

#define IDC_ITEM_ABOUTSITE      6
#define IDC_ITEM_ABOUTXBOX       7

#define IDM_SHARED_EDIT_CUT     8
#define IDM_SHARED_EDIT_COPY    9
#define IDM_SHARED_EDIT_PASTE   10
#define IDM_SHARED_FILE_LINK    11
#define IDM_SHARED_FILE_DELETE  12
#define IDM_SHARED_FILE_RENAME  13
#define IDM_SHARED_FILE_PROP    14

#define IDC_ITEM_XBOXHELP        15

#define IDC_ITEM_MAX            16

/*****************************************************************************/

#define IDM_XBOXMERGE            2    /* Menu bar */

/*
 *  These are biased by SFVIDM_CLIENT_FIRST and can go up to 255.
 *  However, IDM_SORT_* uses 0x30 through 0x3F.
 */
#define IDM_PROPERTIESBG        20

#define IDM_ID_DEBUG            0x40    /* 0x40 through 0x60 */

/*****************************************************************************/

#define IDM_DROPCONTEXT         3   /* Context menu for nondefault d/d */

/*****************************************************************************/

#define IDM_FOLDERCONTEXT       4   /* Context menu for folder background */

#define IDM_FOLDER_NEW          0
#define IDM_FOLDER_PROP         1

/*****************************************************************************\
    Shared dialog IDs

    Use these deltas whenever you want to use XboxDlg_InitDlg to
    initialize a group of controls based on a list of pidls.

    NOTE!  These cannot be an enum because the resource compiler doesn't
    understand enums.
\*****************************************************************************/

#define DLGTEML_FILENAME            0       // Name of file(s)
#define DLGTEML_FILENAMEEDITABLE    1       // Editable filename
#define DLGTEML_FILEICON            2       // Icon for file(s)
#define DLGTEML_FILESIZE            3       // Size of file(s)
#define DLGTEML_FILETIME            4       // Modification time of file(s)
#define DLGTEML_FILETYPE            5       // Type description for file(s)
#define DLGTEML_LOCATION            6       // Location of folder
#define DLGTEML_COUNT               7       // Location of count
#define DLGTEML_MAX                 8

#define DLGTEML_LABEL               20      // The label for an item (DLGTEML_FILENAME) equals (DLGTEML_FILENAME+DLGTEML_LABEL)

/*****************************************************************************
 *
 *      Derived dialog IDs
 *
 *****************************************************************************/

#define IDC_ITEM                110
#define IDC_FILENAME            (IDC_ITEM + DLGTEML_FILENAME)
#define IDC_FILENAME_EDITABLE   (IDC_ITEM + DLGTEML_FILENAMEEDITABLE)
#define IDC_FILEICON            (IDC_ITEM + DLGTEML_FILEICON)
#define IDC_FILESIZE            (IDC_ITEM + DLGTEML_FILESIZE)
#define IDC_FILETIME            (IDC_ITEM + DLGTEML_FILETIME)
#define IDC_FILETYPE            (IDC_ITEM + DLGTEML_FILETYPE)
#define IDC_LOCATION            (IDC_ITEM + DLGTEML_LOCATION)
#define IDC_COUNT               (IDC_ITEM + DLGTEML_COUNT)

#define IDC_FILETIME_LABEL      (IDC_ITEM + DLGTEML_FILETIME + DLGTEML_LABEL)
#define IDC_FILESIZE_LABEL      (IDC_ITEM + DLGTEML_FILESIZE + DLGTEML_LABEL)

#define IDC_ITEM2               120
#define IDC_FILENAME2           (IDC_ITEM2 + DLGTEML_FILENAME)
#define IDC_FILENAME_EDITABLE2  (IDC_ITEM2 + DLGTEML_FILENAMEEDITABLE)
#define IDC_FILEICON2           (IDC_ITEM2 + DLGTEML_FILEICON)
#define IDC_FILESIZE2           (IDC_ITEM2 + DLGTEML_FILESIZE)
#define IDC_FILETIME2           (IDC_ITEM2 + DLGTEML_FILETIME)
#define IDC_FILETYPE2           (IDC_ITEM2 + DLGTEML_FILETYPE)
#define IDC_LOCATION2           (IDC_ITEM2 + DLGTEML_LOCATION)
#define IDC_COUNT2              (IDC_ITEM2 + DLGTEML_COUNT)

#define IDC_FILETIME2_LABEL     (IDC_ITEM2 + DLGTEML_FILETIME + DLGTEML_LABEL)
#define IDC_FILESIZE2_LABEL     (IDC_ITEM2 + DLGTEML_FILESIZE + DLGTEML_LABEL)

/*****************************************************************************
 *
 *      Dialogs (and dialog controls)
 *
 *****************************************************************************/

#define IDD_REPLACE             1       /* File being overwritten */

#define IDC_REPLACE_YES         IDYES   /* Overwrite it */
#define IDC_REPLACE_YESTOALL    32      /* Overwrite it and everything else */
#define IDC_REPLACE_NO          IDNO    /* Skip this file */
#define IDC_REPLACE_NOTOALL     33      /* Skip all files that conflict */
#define IDC_REPLACE_CANCEL      IDCANCEL /* Stop copying */

#define IDC_REPLACE_OLDFILE     35      /* Description of old file */
#define IDC_REPLACE_NEWFILE     37      /* Description of new file */
#define IDC_REPLACE_NEWICON     38      /* Icon of new file */

/*****************************************************************************/

#define IDD_DELETEFILE          2       /* File being deleted */
#define IDD_DELETEFOLDER        3       /* Folder being deleted */
#define IDD_DELETEMULTI         4       /* Files/Folders being deleted */

/*****************************************************************************/

#define IDD_FILEPROP            32
#define IDC_READONLY            7

// Some items in the Login Dialog are the same across all three dialogs,
// but some change.
// These are the items that are all the same.
#define IDD_LOGINDLG                        40
#define IDC_LOGINDLG_XBOXSERVER              (IDD_LOGINDLG + 1)
#define IDC_LOGINDLG_ANONYMOUS_CBOX         (IDD_LOGINDLG + 2)

// These are the items that are different.
#define IDC_LOGINDLG_USERNAME               (IDD_LOGINDLG + 3)
#define IDC_LOGINDLG_USERNAME_ANON          (IDD_LOGINDLG + 4)
#define IDC_LOGINDLG_MESSAGE_ANONREJECT     (IDD_LOGINDLG + 5)
#define IDC_LOGINDLG_MESSAGE_NORMAL         (IDD_LOGINDLG + 6)
#define IDC_LOGINDLG_MESSAGE_USERREJECT     (IDD_LOGINDLG + 7)
#define IDC_LOGINDLG_PASSWORD_DLG1          (IDD_LOGINDLG + 8)
#define IDC_LOGINDLG_PASSWORD_DLG2          (IDD_LOGINDLG + 9)
#define IDC_LOGINDLG_PASSWORD_LABEL_DLG1    (IDD_LOGINDLG + 10)
#define IDC_LOGINDLG_PASSWORD_LABEL_DLG2    (IDD_LOGINDLG + 11)
#define IDC_LOGINDLG_NOTES_DLG1             (IDD_LOGINDLG + 12)
#define IDC_LOGINDLG_NOTES_DLG2             (IDD_LOGINDLG + 13)
#define IDC_LOGINDLG_SAVE_PASSWORD          (IDD_LOGINDLG + 14)



#define IDD_MOTDDLG                         80
#define IDC_MOTDDLG_MESSAGE                 (IDD_MOTDDLG + 1)

#define IDD_DOWNLOADDIALOG                  90
#define IDC_DOWNLOAD_MESSAGE                (IDD_DOWNLOADDIALOG + 1)
#define IDC_DOWNLOAD_TITLE                  (IDD_DOWNLOADDIALOG + 2)
#define IDC_DOWNLOAD_DIR                    (IDD_DOWNLOADDIALOG + 3)
#define IDC_BROWSE_BUTTON                   (IDD_DOWNLOADDIALOG + 4)
#define IDC_DOWNLOAD_AS                     (IDD_DOWNLOADDIALOG + 5)
#define IDC_DOWNLOAD_AS_LIST                (IDD_DOWNLOADDIALOG + 6)
#define IDC_DOWNLOAD_BUTTON                 (IDD_DOWNLOADDIALOG + 7)

#define DLG_MOVECOPYPROGRESS                100
#define IDD_ANIMATE                         (DLG_MOVECOPYPROGRESS + 1)
#define IDD_NAME                            (DLG_MOVECOPYPROGRESS + 2)
#define IDD_TONAME                          (DLG_MOVECOPYPROGRESS + 3)
#define IDD_TIMEEST                         (DLG_MOVECOPYPROGRESS + 5)
#define IDD_PROBAR                          (DLG_MOVECOPYPROGRESS + 4)

#define IDD_PROXYDIALOG                     110
#define IDC_PROXY_MESSAGE                   (IDD_PROXYDIALOG + 0)

#define IDD_CHMOD                           140
#define IDC_CHMOD_OR                        (IDD_CHMOD + 0)
#define IDC_CHMOD_OW                        (IDD_CHMOD + 1)
#define IDC_CHMOD_OE                        (IDD_CHMOD + 2)
#define IDC_CHMOD_GR                        (IDD_CHMOD + 3)
#define IDC_CHMOD_GW                        (IDD_CHMOD + 4)
#define IDC_CHMOD_GE                        (IDD_CHMOD + 5)
#define IDC_CHMOD_AR                        (IDD_CHMOD + 6)
#define IDC_CHMOD_AW                        (IDD_CHMOD + 7)
#define IDC_CHMOD_AE                        (IDD_CHMOD + 8)

#define IDC_CHMOD_LABEL_EXECUTE             (IDD_CHMOD + 9)
#define IDC_CHMOD_LABEL_PERM                (IDD_CHMOD + 10)
#define IDC_CHMOD_LABEL_OWNER               (IDD_CHMOD + 11)
#define IDC_CHMOD_LABEL_GROUP               (IDD_CHMOD + 12)
#define IDC_CHMOD_LABEL_ALL                 (IDD_CHMOD + 13)
#define IDC_CHMOD_LABEL_READ                (IDD_CHMOD + 14)
#define IDC_CHMOD_LABEL_WRITE               (IDD_CHMOD + 15)
#define IDC_CHMOD_GROUPBOX                  (IDD_CHMOD + 16)

#define IDC_CHMOD_LAST                      (IDD_CHMOD + 16)
#define IDC_CHMOD_NOT_ALLOWED               (IDD_CHMOD + 17)


/*****************************************************************************
 *
 *      Column headings (for details view)
 *
 *****************************************************************************/

#define COL_NAME            0
#define COL_SIZE            1
#define COL_TYPE            2
#define COL_MODIFIED        3
#define COL_MAX             4

#define IDM_SORT_FIRST        0x0030
#define IDM_SORTBYNAME        (IDM_SORT_FIRST + 0x0000)
#define IDM_SORTBYSIZE        (IDM_SORT_FIRST + 0x0001)
#define IDM_SORTBYTYPE        (IDM_SORT_FIRST + 0x0002)
#define IDM_SORTBYDATE        (IDM_SORT_FIRST + 0x0003)

#define CONVERT_IDMID_TO_COLNAME(idc)      ((idc) - IDM_SORT_FIRST)

#if CONVERT_IDMID_TO_COLNAME(IDM_SORTBYNAME) != COL_NAME || \
    CONVERT_IDMID_TO_COLNAME(IDM_SORTBYSIZE) != COL_SIZE || \
    CONVERT_IDMID_TO_COLNAME(IDM_SORTBYTYPE) != COL_TYPE || \
    CONVERT_IDMID_TO_COLNAME(IDM_SORTBYDATE) != COL_MODIFIED
#error FSIDM_ and ici are out of sync.
#endif

/*****************************************************************************
 *
 *      Strings
 *
 *****************************************************************************/

/* 0 ... 31 reserved for help text for IDC_ITEM_XXX menu commands */
#define IDS_ITEM_HELP(idc)       (idc)

/* 32 .. 39 reserved for title text for iciXXX column indices */
#define IDS_HEADER_NAME(ici)    (32+ici)

/* 40 .. 47 reserved for help text for iciXXX column indices */
#define IDS_HEADER_HELP(ici)    (40+ici)

/* 64 .. 95 reserved for progress feedback */
#define IDS_EMPTY               64
#define IDS_CONNECTING          65
#define IDS_CHDIR               66
#define IDS_LS                  67
#define IDS_DELETING            68
#define IDS_RENAMING            69
#define IDS_GETFINDDATA         70
#define IDS_COPYING             71
#define IDS_DOWNLOADING         72
#define IDS_DL_SRC_DEST         73
#define IDS_COPY_TITLE          74
#define IDS_MOVE_TITLE          75
#define IDS_DELETE_TITLE        76
#define IDS_DOWNLOAD_TITLE      77
#define IDS_DL_TYPE_AUTOMATIC   78
#define IDS_DL_TYPE_ASCII       79
#define IDS_DL_TYPE_BINARY      80
#define IDS_DL_SRC_DIR          81


#define IDA_XBOXDOWNLOAD         0x100   // This matches IDA_DOWNLOAD (in shdocvw.dll)
#define IDA_XBOXUPLOAD           0x101   // FS->Xbox Animation (in xbnmspc.dll)
#define IDA_XBOXDELETE           0x102   // Xbox->Air (Hard Delete) (in xbnmspc.dll)

/* 256 onward are just random strings */
#define IDS_NUMBERK             256
#define IDS_NUMBERTB            257

#define IDS_HELP_XBNMSPCTITLE   258
#define IDS_HELP_ABOUTFOLDER    259
#define IDS_HELP_ABOUTBOX       260
#define IDS_HELP_WELCOMEMSGTITLE 261
#define IDS_PROP_SHEET_TITLE    262
#define IDS_PRETTYNAMEFORMAT    263
#define IDS_SEVERAL_SELECTED    264
#define IDS_ELLIPSES            265
#define IDS_NEW_FOLDER_FIRST    266
#define IDS_NEW_FOLDER_TEMPLATE 267

#define IDS_CANTSHUTDOWN        280
#define IDS_PROGRESS_CANCEL     282
#define IDS_NO_MESSAGEOFTHEDAY  285
#define IDS_ITEMTYPE_FOLDER     286
#define IDS_ITEMTYPE_SERVER     287
#define IDS_PROGRESS_UPLOADTIMECALC   288
#define IDS_PROGRESS_DELETETIMECALC   289
#define IDS_PROGRESS_DOWNLOADTIMECALC 290
#define IDS_OFFLINE_PROMPTTOGOONLINE  291
#define IDS_RECYCLE_IS_PERM_WARNING   292

// STATUS BAR Strings

// Status Bar Icon ToolTips
// These Text Strings are the tool tips for the icons.
#define IDS_BEGIN_SB_TOOLTIPS   300
#define IDS_WRITE_ALLOWED       300              // This folder has write access 
#define IDS_WRITE_NOTALLOWED    301              // This folder does not have read access 

// Progress Bar ToolTips
#define IDS_PROG_ZERO           330              // Zero percent.
#define IDS_PROG_NPERCENT       331              // n percent.
#define IDS_PROG_DONE           332              // 100 percent.

// Zones
#define IDS_ZONES_UNKNOWN       340              // Unknown Zone
#define IDS_ZONES_TOOLTIP       341              // Zone Status Bar Pane Tooltip

// User Status Bar Pane
#define IDS_USER_TEMPLATE       350              // "User: <UserName>"
#define IDS_USER_ANNONYMOUS     351               // <UserName> = "Annonymous"
#define IDS_USER_USERTOOLTIP    352              // Info on type of user log-in. (non-Annonymously)
#define IDS_USER_ANNONTOOLTIP   353              // Info on type of user log-in. (Annonymously)

// XBOX Errors
#define IDS_XBOXERR_TITLE            400              // Title for Messages.
#define IDS_XBOXERR_TITLE_ERROR      401              // Title for Error Messages.
#define IDS_XBOXERR_UNKNOWN          402              // Unknown error.
#define IDS_XBOXERR_WININET          403              // Prep Wininet Error
#define IDS_XBOXERR_WININET_CONTINUE 404          // Prep Wininet Error and ask if user wants to continue
#define IDS_XBOXERR_FILECOPY         405              // Error putting file on XBOX Server
#define IDS_XBOXERR_DIRCOPY          406              // Error Creating a directory on the XBOX Server
#define IDS_XBOXERR_FILERENAME       407              // Error renaming file on XBOX Server
#define IDS_XBOXERR_CHANGEDIR        408              // Error opening that folder on the XBOX Server
#define IDS_XBOXERR_DELETE           409              // Error deleting that folder or file on the XBOX Server
#define IDS_XBOXERR_OPENFOLDER       410              // Error opening that folder on the XBOX Server
#define IDS_XBOXERR_FOLDERENUM       411              // Error getting the rest of the file names in the folder on the XBOX Server
#define IDS_XBOXERR_NEWFOLDER        412              // Error create a new folder on the XBOX Server
#define IDS_XBOXERR_DROPFAIL         413              // Error dropping a file or folder.
#define IDS_XBOXERR_INVALIDXBOXNAME   414            // This file name isn't a valid XBOX File Name.  Maybe unicode.
#define IDS_XBOXERR_CREATEDIRPROMPT  415           // The directory doesn't exist, do you want to create it?
#define IDS_XBOXERR_CREATEFAILED     416              // Attempting to create the directory failed.
#define IDS_XBOXERR_GETDIRLISTING    417             // An error occured reading the contents of the folder
#define IDS_XBOXERR_DOWNLOADING      418             // Download failed
#define IDS_XBOXERR_RENAME_REPLACE   419           // A file with this name already exists.  Do you want to replace that file?
#define IDS_XBOXERR_RENAME_EXT_WRN   420           // If you change a filename extension, the file may become unusable.\n\nAre you sure you want to change it?
#define IDS_XBOXERR_RENAME_TITLE     421           // Rename title ("Rename")
#define IDS_XBOX_PROXY_WARNING       422           // The folder '%s' is currently read-only.\n\nThe proxy server to which you are connected will only enable...
#define IDS_XBOXERR_CHMOD            423           // An error occured changing the permissions on the file or folder on the XBOX Server.  Make sure you have permission to change this item.
#define IDS_XBOXERR_BAD_DL_TARGET    424           // Bad dir chosen in SHBrowseForFolder


// Login Dialog Message
#define IDS_LOGIN_LOGINAS           450              // 
#define IDS_LOGIN_SERVER            451              // 


// Dialog Strings
#define IDS_DLG_DOWNLOAD_TITLE      500              // Title for the 'Choose Download Directory' dialog.



#define IDS_INSTALL_TEMPLATE        700              // 
#define IDS_INSTALL_TEMPLATE_NT5    701              // 


// HTML dialog resources
#define RT_FILE                     2110


// BUGBUG - For some reason, I can't read \iedev\shell\shlwapi.w
#define IDC_MESSAGECHECKEX          0x1202
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\proxycache.cpp ===
/*****************************************************************************\
    FILE: proxycache.cpp
    
    DESCRIPTION:
        XBOX Folder uses WININET which doesn't work thru CERN proxies.  In that
    case, we need to hand control of the XBOX URL back to the browser to do the
    old URLMON handling of it.  The problem is that testing for a CERN proxy
    blocking access is expensive.
\*****************************************************************************/

#include "priv.h"
#include "util.h"

#define PROXY_CACHE_SIZE    15

typedef struct
{
    TCHAR szServerName[INTERNET_MAX_HOST_NAME_LENGTH];
    BOOL fIsBlocking;
} PROXYCACHEENTRY;

static int g_nLastIndex = 0;
static BOOL g_fInited = FALSE;
static TCHAR g_szProxyServer[MAX_URL_STRING] = {0};
static PROXYCACHEENTRY g_ProxyCache[PROXY_CACHE_SIZE];






/////////////////////////////////////////////////////////////////////////
///////  Private helpers    /////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

void ProxyCache_Init(void)
{
    g_nLastIndex = 0;

    for (int nIndex = 0; nIndex < ARRAYSIZE(g_ProxyCache); nIndex++)
    {
        g_ProxyCache[nIndex].fIsBlocking = FALSE;
        g_ProxyCache[nIndex].szServerName[0] = 0;
    }

    g_fInited = TRUE;
}


/****************************************************\
    FUNCTION: ProxyCache_WasProxyChanged

    DESCRIPTION:
        See if someone changed the proxy settings via
    the inetcpl.  This is important because it is
    frustration to find XBOX fails because of the proxy
    settings, fix the proxy settings, and then it still
    doesn't work because we cached the results.
\****************************************************/
BOOL ProxyCache_WasProxyChanged(void)
{
    BOOL fWasChanged = FALSE;
    TCHAR szCurrProxyServer[MAX_URL_STRING];
    DWORD cbSize = SIZEOF(szCurrProxyServer);

    // PERF: If I wanted to be really fast, I would cache the hkey
    //       so this would be faster.  But since my DLL can be loaded/unloaded
    //       serveral times in a process, I would leak each instance unless I
    //       released the hkey in DLL_PROCESS_DETACH
    if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, SZ_REGKEY_INTERNET_SETTINGS_LAN, SZ_REGVALUE_PROXY_SERVER, NULL, szCurrProxyServer, &cbSize))
    {
        // Is this the first time? (Is g_szProxyServer empty?)
        if (!g_szProxyServer[0])
            StrCpyN(g_szProxyServer, szCurrProxyServer, ARRAYSIZE(g_szProxyServer));

        // Did it change?
        if (StrCmp(szCurrProxyServer, g_szProxyServer))
            fWasChanged = TRUE;
    }

    return fWasChanged;
}



/////////////////////////////////////////////////////////////////////////
///////  APIs helpers    /////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////


/****************************************************\
    FUNCTION: ProxyCache_IsProxyBlocking

    DESCRIPTION:
        Look in the cache with the XBOX server in pidl
    and see if we have a cached value that indicates
    if it's blocked by the proxy.

    PARAMETERS:
        *pfIsBlocking - Is the proxy blocking.
        return - Is the value cached
\****************************************************/
BOOL ProxyCache_IsProxyBlocking(LPCITEMIDLIST pidl, BOOL * pfIsBlocking)
{
    BOOL fIsInCache = FALSE;

    if (ProxyCache_WasProxyChanged())
        ProxyCache_Init();  // Purge the results

    *pfIsBlocking = FALSE;  // Assume we don't know.
    if (!g_fInited)
    {
        ProxyCache_Init();
    }
    else
    {
        int nCount = ARRAYSIZE(g_ProxyCache);
        TCHAR szNewServer[INTERNET_MAX_HOST_NAME_LENGTH];

        // BUGBUG: Check if the proxy has changed.

        // Is this the same server we tried last time?  If so,
        // let's just cache the return value.
        XboxPidl_GetServer(pidl, szNewServer, ARRAYSIZE(szNewServer));
        for (int nIndex = g_nLastIndex; nCount && g_ProxyCache[nIndex].szServerName[0]; nCount--, nIndex--)
        {
            if (nIndex < 0)
                nIndex = (PROXY_CACHE_SIZE - 1);

            if (!StrCmp(szNewServer, g_ProxyCache[nIndex].szServerName))
            {
                // Yes, so bail.
                *pfIsBlocking = g_ProxyCache[nIndex].fIsBlocking;
                fIsInCache = TRUE;
                break;
            }
        }
    }

    return fIsInCache;
}


/****************************************************\
    FUNCTION: ProxyCache_SetProxyBlocking

    DESCRIPTION:

    PARAMETERS:
        *pfIsBlocking - Is the proxy blocking.
        return - Is the value cached
\****************************************************/
void ProxyCache_SetProxyBlocking(LPCITEMIDLIST pidl, BOOL fIsBlocking)
{
    TCHAR szNewServer[INTERNET_MAX_HOST_NAME_LENGTH];

    // Add it to the cache because our caller will hit the server to
    // verify and we can be ready for next time.
    g_nLastIndex++;
    if (g_nLastIndex >= PROXY_CACHE_SIZE)
        g_nLastIndex = 0;

    XboxPidl_GetServer(pidl, szNewServer, ARRAYSIZE(szNewServer));
    StrCpyN(g_ProxyCache[g_nLastIndex].szServerName, szNewServer, ARRAYSIZE(g_ProxyCache[g_nLastIndex].szServerName));
    g_ProxyCache[g_nLastIndex].fIsBlocking = fIsBlocking;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\priv.h ===
#ifndef _PRIV_H_
#define _PRIV_H_


/*****************************************************************************
 *
 *      Magic comments:
 *
 *      BUGBUG: Something that needs to be fixed before being released.
 *
 *      _UNDOCUMENTED_: Something that is not documented in the SDK.
 *
 *      _UNOBVIOUS_: Some unusual feature that isn't obvious from the
 *      documentation.  A candidate for a "Tips and Tricks" chapter.
 *
 *      _HACKHACK_: Something that is gross but necessary.
 *
 *      _CHARSET_: Character set issues.
 *
 *      Magic ifdefs:
 *
  *****************************************************************************/


/*****************************************************************************
 *
 *      Global Includes
 *
 *****************************************************************************/

#define WIN32_LEAN_AND_MEAN
#define NOIME
#define NOSERVICE

// This stuff must run on Win95
#define _WIN32_WINDOWS      0x0400

#ifndef WINVER
#define WINVER              0x0400
#endif // WINVER

#define _OLEAUT32_      // get DECLSPEC_IMPORT stuff right, we are defing these
#define _FSMENU_        // for DECLSPEC_IMPORT
#define _WINMM_         // for DECLSPEC_IMPORT in mmsystem.h
#define _SHDOCVW_       // for DECLSPEC_IMPORT in shlobj.h
#define _WINX32_        // get DECLSPEC_IMPORT stuff right for WININET API

#define _URLCACHEAPI_   // get DECLSPEC_IMPORT stuff right for wininet urlcache
#define STRICT

#define POST_IE5_BETA
#include <w95wraps.h>

#include <windows.h>

#ifdef  RC_INVOKED              /* Define some tags to speed up rc.exe */
#define __RPCNDR_H__            /* Don't need RPC network data representation */
#define __RPC_H__               /* Don't need RPC */
#include <oleidl.h>             /* Get the DROPEFFECT stuff */
#define _OLE2_H_                /* But none of the rest */
#define _WINDEF_
#define _WINBASE_
#define _WINGDI_
#define NONLS
#define _WINCON_
#define _WINREG_
#define _WINNETWK_
#define _INC_COMMCTRL
#define _INC_SHELLAPI
#define _SHSEMIP_H_             /* _UNDOCUMENTED_: Internal header */
#else // RC_INVOKED
#include <windowsx.h>
#endif // RC_INVOKED


#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */


#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */


#include "resource.h"

#define _FIX_ENABLEMODELESS_CONFLICT  // for shlobj.h
//WinInet need to be included BEFORE ShlObjp.h
#include <wininet.h>
#include <urlmon.h>
#include <shlobj.h>
#include <shlobjp.h>             // For IProgressDialog
#include <exdisp.h>
#include <objidl.h>

#include <shlwapi.h>
#include <shlwapip.h>

#include <shellapi.h>
#include <shlapip.h>

#include <shsemip.h>
#include <crtfree.h>

#include <ole2ver.h>
#include <olectl.h>
#include <shellp.h>
#include <commctrl.h>
#include <comctrlp.h>
#include <shdocvw.h>
#include <shguidp.h>
#include <shlguidp.h>
#include <isguids.h>
#include <shdguid.h>
#include <mimeinfo.h>
#include <hlguids.h>
#include <mshtmdid.h>
#include <dispex.h>     // IDispatchEx
#include <perhist.h>


#include <help.h>
#include <krnlcmn.h>    // GetProcessDword

#include <multimon.h>

#define DISALLOW_Assert             // Force to use ASSERT instead of Assert
#define DISALLOW_DebugMsg           // Force to use TraceMsg instead of DebugMsg
#include <debug.h>

#include <urlhist.h>

#include <regstr.h>     // for REGSTR_PATH_EXPLORE

#define USE_SYSTEM_URL_MONIKER
#include <urlmon.h>
//#include <winineti.h>    // Cache APIs & structures
#include <inetreg.h>

#define _INTSHCUT_    // get DECLSPEC_IMPORT stuff right for INTSHCUT.h
#include <intshcut.h>
#include <intshctp.h>

#include <propset.h>        // BUGBUG (scotth): remove this once OLE adds an official header

#define HLINK_NO_GUIDS
#include <hlink.h>
#include <hliface.h>
#include <docobj.h>
#include <ccstock.h>
#include <port32.h>
#include <prsht.h>
#include <inetcpl.h>

#include <commctrl.h>

#include "unithunk.h"

// Trace flags
#define TF_XBOXREF           0x00000100      // Dll Reference
#define TF_XBOXPERF          0x00000200      // Perf
#define TF_XBOXALLOCS        0x00000400      // Object Allocs
#define TF_XBOXDRAGDROP      0x00000800      // Drag and Drop
#define TF_XBOXLIST          0x00001000      // HDPA Wrapper
#define TF_XBOXISF           0x00002000      // IShellFolder
#define TF_XBOXQI            0x00004000      // QueryInterface
#define TF_XBOXSTATUSBAR     0x00008000      // Status Bar Spew
#define TF_XBOXOPERATION     0x00010000      // Xbox Operation (Put File, Get File, CreateDir, DeleteDir, ...)
#define TF_XBOXURL_UTILS     0x00020000      // Xbox Url Operations (Pidl->Url, Url->Pidl, ...)
#define TF_XBOX_DLLLOADING   0x00040000      // Loading Other DLLs
#define TF_XBOX_OTHER        0x00080000      // Misc.
#define TF_XBOX_IDENUM       0x00100000      // IDList Enum (IIDEnum).
#define TF_CHANGENOTIFY     0x00200000      // Change Notify
#define TF_PIDLLIST_DUMP    0x00400000      // Dump the contents in the Pidl List
#define TF_WININET_DEBUG    0x00800000      // Dump wininet calls
#define TF_BKGD_THREAD      0x01000000      // Background thread that caches wininet handles.
#define TF_FOLDER_SHRTCUTS  0x02000000      // Info about Folder Shortcuts.


/*****************************************************************************
 *
 *      Global Helper Macros/Typedefs
 *
 *****************************************************************************/

//////////////////////////// IE 5 vs IE 4 /////////////////////////////////
// These are functions that IE5 exposes (normally in shlwapi), but
// if we want to be compatible with IE4, we need to have our own copy.
// If we turn on USE_IE5_UTILS, we won't work with IE4's DLLs (like shlwapi).
//
// #define USE_IE5_UTILS
//////////////////////////// IE 5 vs IE 4 /////////////////////////////////



#ifdef OLD_HLIFACE
#define HLNF_OPENINNEWWINDOW HLBF_OPENINNEWWINDOW
#endif // OLD_HLIFACE

#define ISVISIBLE(hwnd)  ((GetWindowStyle(hwnd) & WS_VISIBLE) == WS_VISIBLE)

// shorthand
#ifndef ATOMICRELEASE
#define ATOMICRELEASET(p,type) { type* punkT=p; p=NULL; punkT->Release(); }

// doing this as a function instead of inline seems to be a size win.
//
#ifdef NOATOMICRELESEFUNC
#define ATOMICRELEASE(p) ATOMICRELEASET(p, IUnknown)
#else // NOATOMICRELESEFUNC

//////////////////////////// IE 5 vs IE 4 /////////////////////////////////
#ifndef USE_IE5_UTILS
#define ATOMICRELEASE(p)                XboxCopy_IUnknown_AtomicRelease((LPVOID*)&p)
void XboxCopy_IUnknown_AtomicRelease(LPVOID* ppunk);
#endif // USE_IE5_UTILS
//////////////////////////// IE 5 vs IE 4 /////////////////////////////////
#endif // NOATOMICRELESEFUNC

#endif // ATOMICRELEASE

#ifdef SAFERELEASE
#undef SAFERELEASE
#endif // SAFERELEASE
#define SAFERELEASE(p) ATOMICRELEASE(p)


#define IsInRange               InRange

// Include the automation definitions...
#include <exdisp.h>
#include <exdispid.h>
#include <shldispp.h>
#include <ocmm.h>
#include <mshtmhst.h>
#include <simpdata.h>
#include <htiface.h>
#include <objsafe.h>

//
// Neutral ANSI/UNICODE types and macros... 'cus Chicago seems to lack them
//

#ifdef  UNICODE
   typedef WCHAR TUCHAR, *PTUCHAR;

#else   /* UNICODE */

   typedef unsigned char TUCHAR, *PTUCHAR;
#endif /* UNICODE */



STDAPI_(void) DllAddRef(void);
STDAPI_(void) DllRelease(void);


#define CALLWNDPROC WNDPROC


extern HINSTANCE g_hinst;
#define HINST_THISDLL g_hinst


#include "idispids.h"


// Count of characters to count of bytes
//
#define CbFromCchW(cch)             ((cch)*sizeof(WCHAR))
#define CbFromCchA(cch)             ((cch)*sizeof(CHAR))
#ifdef UNICODE
#define CbFromCch                   CbFromCchW
#else  // UNICODE
#define CbFromCch                   CbFromCchA
#endif // UNICODE

// General flag macros
//
#define SetFlag(obj, f)             do {obj |= (f);} while (0)
#define ToggleFlag(obj, f)          do {obj ^= (f);} while (0)
#define ClearFlag(obj, f)           do {obj &= ~(f);} while (0)
#define IsFlagSet(obj, f)           (BOOL)(((obj) & (f)) == (f))
#define IsFlagClear(obj, f)         (BOOL)(((obj) & (f)) != (f))


#pragma intrinsic(memcmp, memcpy)


/*****************************************************************************
 *
 *      Baggage - Stuff I carry everywhere
 *
 *****************************************************************************/

#define BEGIN_CONST_DATA data_seg(".text", "CODE")
#define END_CONST_DATA data_seg(".data", "DATA")


// Convert an array name (A) to a generic count (c).
#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

#define pvByteIndexCb(pv, cb) ((LPVOID)((PBYTE)pv + (cb)))


#ifdef DEBUG
#define DEBUG_CODE(x)            x
#else // DEBUG
#define DEBUG_CODE(x)
#endif // DEBUG


#undef lstrcatnW

// #undef  lstrcpyW
// #define lstrcpyW            BUGBUG_BAD_lstrcpyW

#undef  lstrcpynW
#define lstrcpynW           BUGBUG_BAD_lstrcpynW

#undef  lstrcmpW
#define lstrcmpW            BUGBUG_BAD_lstrcmpW

#undef  lstrcmpiW
#define lstrcmpiW           BUGBUG_BAD_lstrcmpiW

#undef  lstrcatW
#define lstrcatW            BUGBUG_BAD_lstrcatW

#undef  lstrcatnW
#define lstrcatnW           BUGBUG_BAD_lstrcatnW

// Fix shell32 bugs:
#define ILCombine           ILCombineWrapper
#define ILClone             ILCloneWrapper
#define ILFree              ILFreeWrapper

LPITEMIDLIST ILCombineWrapper(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
LPITEMIDLIST ILCloneWrapper(LPCITEMIDLIST pidl);
void ILFreeWrapper(LPITEMIDLIST pidl);


/*****************************************************************************
 *
 *      Wrappers and other quickies
 *
 *****************************************************************************/

#define HRESULT_FROM_SUCCESS_VALUE(us) MAKE_HRESULT(SEVERITY_SUCCESS, 0, (USHORT)(us))

#define ILIsSimple(pidl) (ILIsEmpty(_ILNext(pidl)))

typedef DWORD DROPEFFECT;

#define ProtocolIdlInnerData(pidl)  ((LPVOID)&(((PDELEGATEITEMID)(pidl))->rgb[0]))
#define ProtocolIdlInnerDataSize  (sizeof(DELEGATEITEMID) - (sizeof(BYTE)*2))

/*****************************************************************************
 *
 *      Const globals:  Never change.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

extern char c_szSlash[];        /* "/" */

extern WORD c_wZero;            /* A word of zeros */

#pragma END_CONST_DATA

#define c_pidlNil               ((LPCITEMIDLIST)&c_wZero)       /* null pidl */
#define c_tszNil                ((LPCTSTR)&c_wZero)     /* null string */
#define c_szNil                 ((LPCSTR)&c_wZero)      /* null string */

/*****************************************************************************
 *
 *      Static globals:  Initialized at PROCESS_ATTACH and never modified.
 *
 *      WARNING! <shelldll\idlcomm.h> #define's various g_cf's, so we need
 *      to #undef them before we start partying on them again.
 *
 *****************************************************************************/

#undef g_cfFileDescriptor
#undef g_cfFileContents
#undef g_cfShellIDList
#undef g_cfFileNameMap
#undef g_cfPreferredDe

extern HINSTANCE                g_hinst;                    // My instance handle
extern CHAR                     g_szShell32[MAX_PATH];      // Full path to shell32.dll (must be ANSI)


// Detect "." or ".." as invalid files
#define IS_VALID_FILE(str)        (!(('.' == str[0]) && (('\0' == str[1]) || (('.' == str[1]) && ('\0' == str[2])))))

extern FORMATETC g_formatEtcOffsets;
extern FORMATETC g_formatPasteSucceeded;
extern FORMATETC g_dropTypes[];

extern CLIPFORMAT g_cfTargetCLSID;

// TODO: 
//     Create a DROP_XBOX clipboard format that will
//     give a source URL, a destination URL, and
//     a list of files that need to be moved or copied
//     from relative to the source URL to relative to
//     the destination URL.

enum DROPTYPES
{
    // File contents is inherently weird
    DROP_FCont = 0,     // File contents

    // Clipboard formats we offer from our DataObject
    DROP_FGDW,          // File Group DescriptorW 1
    DROP_FGDA,          // File Group DescriptorA 2
    DROP_IDList,        // ID List Array 3
    DROP_URL,           // Uniform Resource Locator 4
//    DROP_Offsets,       // Shell Object Offsets
    DROP_PrefDe,        // Preferred Drop Effect 5
    DROP_PerfDe,        // Performed Drop Effect 6
    DROP_XBOX_PRIVATE,   // Xbox Private Data - Flag to indicate Xbox was the drag source 7
    DROP_OLEPERSIST,        // Used by ole to realize that they should persist via IPersistStream across OleFlushClipboard calls.

    // Clipboard formats we query but do not offer
    DROP_Hdrop,         // File Drop
    DROP_FNMA,          // File Name Map (Ansi)
    DROP_FNMW           // File Name Map (Unicode)
};

#define DROP_OFFERMIN           DROP_FGDW
#define DROP_OFFERMAX           DROP_Hdrop
#define DROP_MAX                (DROP_FNMW+1)

/*****************************************************************************
 *
 *      Global state management.
 *
 *      DLL reference count, DLL critical section.
 *
 *****************************************************************************/

void DllAddRef(void);
void DllRelease(void);

#ifdef UNICODE
#define EMPTYSTR_FOR_NULL EMPTYSTR_FOR_NULLW
#else // UNICODE
#define EMPTYSTR_FOR_NULL EMPTYSTR_FOR_NULLA
#endif // UNICODE

#define NULL_FOR_EMPTYSTR(str)          (((str) && (str)[0]) ? str : NULL)
#define EMPTYSTR_FOR_NULLA(str)          ((str) ? (str) : "")
#define EMPTYSTR_FOR_NULLW(str)          ((str) ? (str) : L"")

typedef void (*LISTPROC)(UINT flm, LPVOID pv);

/*****************************************************************************
 *      Local Includes
 *****************************************************************************/


class CXboxFolder;
class CXboxPidl;
class CXboxSite;
class CXboxList;
class CXboxDir;
class CXboxPidlList;
class CXboxMenu;
class CXboxDrop;
class CXboxEidl;
class CXboxObj;
class CXboxProp;
class CXboxView;
class CXboxIcon;
class CStatusBar;


#define XBOX_SHCNE_EVENTS            (SHCNE_DISKEVENTS | SHCNE_ASSOCCHANGED | SHCNE_RMDIR | SHCNE_DELETE | SHCNE_MKDIR | SHCNE_CREATE | SHCNE_RENAMEFOLDER | SHCNE_RENAMEITEM | SHCNE_ATTRIBUTES)


typedef struct HINTPROCINFO {
    CXboxDir *   pfd;                    /* CXboxDir in which it's happening */
    HWND        hwnd;                   /* The window to use for UI */
    CStatusBar * psb;                   /* The status bar object. */
} HPI, *PHPI;

typedef HRESULT (*HINTPROC)(HINTERNET hint, PHPI phpi, LPVOID pv, BOOL * pfReleaseHint);

void GetCfBufA(UINT cf, PSTR psz, int cch);

// This is defined in WININET.CPP
typedef LPVOID HINTERNET;
typedef HGLOBAL HIDA;


typedef void (*DELAYEDACTIONPROC)(LPVOID);

typedef struct GLOBALTIMEOUTINFO GLOBALTIMEOUTINFO, * LPGLOBALTIMEOUTINFO;

struct GLOBALTIMEOUTINFO
{
    LPGLOBALTIMEOUTINFO     hgtiNext;
    LPGLOBALTIMEOUTINFO     hgtiPrev;
    LPGLOBALTIMEOUTINFO *   phgtiOwner;
    DWORD                   dwTrigger;
    DELAYEDACTIONPROC       pfn;        // Callback procedure
    LPVOID                  pvRef;      // Reference data for timer
};



#define INTERNET_MAX_PATH_LENGTH        2048
#define INTERNET_MAX_SCHEME_LENGTH      32          // longest protocol name length
#define MAX_URL_STRING                  (INTERNET_MAX_SCHEME_LENGTH \
                                        + sizeof("://") \
                                        + INTERNET_MAX_PATH_LENGTH)


#define LEAK_CXboxFolder                 0
#define LEAK_CXboxDir                    1
#define LEAK_CXboxSite                   2
#define LEAK_CXboxObj                    3
#define LEAK_CXboxEidl                   4
#define LEAK_CXboxDrop                   5
#define LEAK_CXboxList                   6
#define LEAK_CXboxStm                    7
#define LEAK_CAccount                   8
#define LEAK_CXboxFactory                9
#define LEAK_CXboxContextMenu            10
#define LEAK_CXboxEfe                    11
#define LEAK_CXboxGlob                   12
#define LEAK_CXboxIcon                   13
#define LEAK_CMallocItem                14
#define LEAK_CXboxPidlList               15
#define LEAK_CXboxProp                   16
#define LEAK_CStatusBar                 17
#define LEAK_CXboxView                   18
#define LEAK_CXboxWebView                19
#define LEAK_CCookieList                20
#define LEAK_CDropOperation             21


#ifdef DEBUG
typedef struct tagLEAKSTRUCT
{
    DWORD dwRef;
    CHAR szObject[MAX_PATH];
} LEAKSTRUCT;

extern LEAKSTRUCT g_LeakList[];
#define LEAK_ADDREF(dwIndex)    DEBUG_CODE(g_LeakList[dwIndex].dwRef++)
#define LEAK_DELREF(dwIndex)    DEBUG_CODE(g_LeakList[dwIndex].dwRef--)

#else // DEBUG
#define LEAK_ADDREF(dwIndex)    NULL
#define LEAK_DELREF(dwIndex)    NULL
#endif // DEBUG

/*****************************************************************************
 *
 *      xboxdhlp.cpp - DialogBox helpers
 *
 *****************************************************************************/

// Only update after 50k bytes were copied.
#define SIZE_PROGRESS_AFTERBYTES    50000

typedef struct tagPROGRESSINFO
{
    IProgressDialog * ppd;
    ULARGE_INTEGER uliBytesCompleted;
    ULARGE_INTEGER uliBytesTotal;
    DWORD dwCompletedInCurFile;
    DWORD dwLastDisplayed;              // We only display in chuncks of 50k, so what was the last chunk we displayed. Chunck #3 means between 100k and 150k.
    HINTERNET hint;                     // Used to cancel operation.
} PROGRESSINFO, * LPPROGRESSINFO;


typedef const BYTE *LPCBYTE;


typedef union FDI {
    struct {
        WORD    id;
        WORD    fdio;
    };
    DWORD dw;
} FDI, *PFDI;

typedef const FDI *PCFDI;

#define FDIO_ICON       0
#define FDIO_NAME       1
#define FDIO_TYPE       2
#define FDIO_LOCATION   3
#define FDIO_SIZE       4
#define FDIO_DATE       5
#define FDIO_COUNT      7
#define FDIO_CANMULTI   8

#define FDII_HFPL       0
#define FDII_WFDA       3

void XboxDlg_InitDlg(HWND hdlg, UINT id, CXboxFolder * pff, LPCVOID pv, UINT fdii);

#define FDI_FILEICON    { IDC_FILEICON, FDIO_ICON,      }
#define FDI_FILENAME    { IDC_FILENAME, FDIO_NAME,      }
#define FDI_FILETYPE    { IDC_FILETYPE, FDIO_TYPE,      }
#define FDI_LOCATION    { IDC_LOCATION, FDIO_LOCATION,  }
#define FDI_FILESIZE    { IDC_FILESIZE, FDIO_SIZE,      }
#define FDI_FILETIME    { IDC_FILETIME, FDIO_DATE,      }


#define imiTop          0
#define imiBottom       ((UINT)-1)

typedef void (*GLOBALTIMEOUTPROC)(LPVOID);


/*****************************************************************************\
   UNIX Chmod Bits
\*****************************************************************************/
#define UNIX_CHMOD_READ_OWNER               0x00000400
#define UNIX_CHMOD_WRITE_OWNER              0x00000200
#define UNIX_CHMOD_EXEC_OWNER               0x00000100
#define UNIX_CHMOD_READ_GROUP               0x00000040
#define UNIX_CHMOD_WRITE_GROUP              0x00000020
#define UNIX_CHMOD_EXEC_GROUP               0x00000010
#define UNIX_CHMOD_READ_ALL                 0x00000004
#define UNIX_CHMOD_WRITE_ALL                0x00000002
#define UNIX_CHMOD_EXEC_ALL                 0x00000001



/*****************************************************************************\
   STRINGS
\*****************************************************************************/
// BUGBUG: Fix the names
#define SZ_XBOXURLA                          "xbox://"
#define SZ_EMPTYA                           ""
#define SZ_MESSAGE_FILEA                    "MESSAGE.TXT"
#define SZ_ALL_FILESA                       "*.*"
#define SZ_URL_SLASHA                       "/"
#define SZ_XBOX_URL_TYPEA                    ";type="  // This is the section of the url that contains the download type.
#define SZ_ESCAPED_SPACEA                   "%20"
#define SZ_ESCAPED_SLASHA                   "%5c"
#define SZ_DOTA                             "."
#define SZ_ASTRICSA                         "*"
#define SZ_DOS_SLASHA                       "\\"
#define SZ_SPACEA                           " "
#define SZ_HASH_ENCODEDA                    "%23"

#define SZ_XBOXURLW                          L"xbox://"
#define SZ_EMPTYW                           L""
#define SZ_MESSAGE_FILEW                    L"MESSAGE.TXT"
#define SZ_ALL_FILESW                       L"*.*"
#define SZ_URL_SLASHW                       L"/"
#define SZ_XBOX_URL_TYPEW                    L";type="  // This is the section of the url that contains the download type.
#define SZ_ESCAPED_SPACEW                   L"%20"
#define SZ_ESCAPED_SLASHW                   L"%5c"
#define SZ_DOTW                             L"."
#define SZ_ASTRICSW                         L"*"
#define SZ_DOS_SLASHW                       L"\\"
#define SZ_SPACEW                           L" "
#define SZ_HASH_ENCODEDW                    L"%23"


#define SZ_XBOXURL                           TEXT(SZ_XBOXURLA)
#define SZ_EMPTY                            TEXT(SZ_EMPTYA)
#define SZ_MESSAGE_FILE                     TEXT(SZ_MESSAGE_FILEA)
#define SZ_ALL_FILES                        TEXT(SZ_ALL_FILESA)
#define SZ_URL_SLASH                        TEXT(SZ_URL_SLASHA)
#define SZ_XBOX_URL_TYPE                     TEXT(SZ_XBOX_URL_TYPEA)  // This is the section of the url that contains the download type.
#define SZ_ESCAPED_SPACE                    TEXT(SZ_ESCAPED_SPACEA)
#define SZ_ESCAPED_SLASH                    TEXT(SZ_ESCAPED_SLASHA)
#define SZ_DOT                              TEXT(SZ_DOTA)
#define SZ_ASTRICS                          TEXT(SZ_ASTRICSA)
#define SZ_DOS_SLASH                        TEXT(SZ_DOS_SLASHA)
#define SZ_SPACE                            TEXT(SZ_SPACEA)
#define SZ_HASH_ENCODED                     TEXT(SZ_HASH_ENCODEDA)

#define SZ_ANONYMOUS                        TEXT("anonymous")

#define CH_URL_SLASHA                       '\\'
#define CH_URL_URL_SLASHA                   '/'
#define CH_URL_LOGON_SEPARATORA             '@'
#define CH_URL_PASSWORD_SEPARATORA          ':'
#define CH_URL_TEMP_LOGON_SEPARATORA        '-'
#define CH_HASH_DECODEDA                    '#'

#define CH_URL_SLASHW                       L'\\'
#define CH_URL_URL_SLASHW                   L'/'
#define CH_URL_LOGON_SEPARATORW             L'@'
#define CH_URL_PASSWORD_SEPARATORW          L':'
#define CH_URL_TEMP_LOGON_SEPARATORW        L'-'
#define CH_HASH_DECODEDW                    L'#'

#define CH_URL_SLASH                        TEXT(CH_URL_SLASHA)
#define CH_URL_URL_SLASH                    TEXT(CH_URL_URL_SLASHA)
#define CH_URL_LOGON_SEPARATOR              TEXT(CH_URL_LOGON_SEPARATORA)
#define CH_URL_PASSWORD_SEPARATOR           TEXT(CH_URL_PASSWORD_SEPARATORA)
#define CH_URL_TEMP_LOGON_SEPARATOR         TEXT(CH_URL_TEMP_LOGON_SEPARATORA)
#define CH_HASH_DECODED                     TEXT(CH_HASH_DECODEDA)

// XBOX Commands
#define XBOX_CMD_SYSTEM                      "syst"
#define XBOX_CMD_SITE                        "site"
#define XBOX_CMD_SITE_HELP                   "site help"
#define XBOX_CMD_SITE_CHMOD_TEMPL            "site chmod %lx %s"
#define XBOX_CMD_FEAT                        "feat"
#define XBOX_CMD_UTF8                        "opts utf8 on"
#define XBOX_CMD_NO_OP                       "noop"

// UNIX Commands (Used via SITE XBOX command)
#define XBOX_UNIXCMD_CHMODA                  "chmod"

#define XBOX_SYST_VMS                        "VMS "


/*****************************************************************************\
   REG Keys and Values
\*****************************************************************************/
// XBOX Registry Keys
#define SZ_REGKEY_XBOXCLASS                  TEXT("Xbox")
#define SZ_REGKEY_MICROSOFTSOFTWARE         TEXT("Software\\Microsoft")
#define SZ_REGKEY_XBOXFOLDER                 TEXT("Software\\Microsoft\\Xbox")
#define SZ_REGKEY_XBOXFOLDER_ACCOUNTS        TEXT("Software\\Microsoft\\Xbox\\Accounts\\")
#define SZ_REGKEY_INTERNET_SETTINGS         TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings")
#define SZ_REGKEY_INTERNET_SETTINGS_LAN     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\LAN")
#define SZ_REGKEY_INTERNET_EXPLORER         TEXT("Software\\Microsoft\\Internet Explorer")


// XBOX Registry Values
#define SZ_REGVALUE_PASSWDSIN_ADDRBAR       TEXT("PasswordsInAddressBar")
#define SZ_REGVALUE_DOWNLOAD_DIR            TEXT("Download Directory")
#define SZ_REGVALUE_DOWNLOAD_TYPE           TEXT("Download Type")
#define SZ_REGVALUE_WARN_ABOUT_PROXY        TEXT("Warn About Proxy")
#define SZ_REGVALUE_DEFAULT_XBOX_CLIENT      TEXT("ShellFolder")
#define SZ_REGVALUE_PREVIOUS_XBOX_CLIENT     TEXT("Previous XBOX Client")
#define SZ_REGVALUE_PROXY_SERVER            TEXT("ProxyServer")
#define SZ_REGVALUE_URL_ENCODING            TEXT("UrlEncoding")
#define SZ_REGVALUE_DISABLE_PASSWORD_CACHE  TEXT("DisablePasswordCaching")


// XBOX Registry Data
#define SZ_REGDATA_IE_XBOX_CLIENT            TEXT("{9FA6C2C0-852C-4aed-8CEB-C8FFEABF7921}")

// Accounts
#define SZ_REGVALUE_DEFAULT_USER            TEXT("Default User")
#define SZ_REGVALUE_ACCOUNTNAME             TEXT("Name")
#define SZ_REGVALUE_PASSWORD                TEXT("Password")
#define SZ_ACCOUNT_PROP                     TEXT("CAccount_This")
#define SZ_REGKEY_LOGIN_ATTRIBS             TEXT("Login Attributes")
#define SZ_REGKEY_EMAIL_NAME                TEXT("EmailName")
#define SZ_REGKEY_USE_OLD_UI                TEXT("Use Web Based XBOX")


/*****************************************************************************\
   FEATURES
\*****************************************************************************/
// Features
//#define FEATURE_DIALER
//#define FEATURE_OFFLINE

// Feature Tests
#define FEATURE_TEST_OFFLINE
#define FEATURE_TEST_DIALER

#define FEATURE_SAVE_PASSWORD
//#define FEATURE_PASSIVE_MODE
#define FEATURE_CHANGE_PERMISSIONS  // UNIX CHMOD command

#ifdef FEATURE_PASSIVE_MODE
#define FEATURE_PASSIVE_ON_OR_OFF     INTERNET_FLAG_PASSIVE
#else // FEATURE_PASSIVE_MODE
#define FEATURE_PASSIVE_ON_OR_OFF     0
#endif // FEATURE_PASSIVE_MODE

// #define FEATURE_XBOX_TO_XBOX_COPY
#define FEATURE_CUT_MOVE
//  #define ADD_ABOUTBOX


/*****************************************************************************\
   UNIQUE IDENTIFIERS
\*****************************************************************************/
// CLSIDs/IIDs Private to xbnmspc.dll
// WARNING: Never move these CLSID/IID definitions outside of the DLL.
//
// {9FA6C2C3-852C-4aed-8CEB-C8FFEABF7921}
extern const GUID CLSID_XboxDataObject;
// {A11501B3-6EA4-11d2-B679-006097DF5BD4}
extern const GUID IID_CXboxFolder;


/*****************************************************************************\
   Local Includes
\*****************************************************************************/

class CXboxFolder;
class CXboxSite;
class CXboxStm;

#include "codepage.h"
#include "encoding.h"
#include "dllload.h"
#include "xboxdir.h"
#include "xboxlist.h"
#include "xboxpidl.h"
#include "ftppidl.h"
#include "xboxinet.h"
#include "xboxpl.h"
#include "util.h"
#include "xboxapi.h"



/*****************************************************************************
 *      Object Constructors
 *****************************************************************************/

HRESULT CXboxFactory_Create(REFCLSID rclsid, REFIID riid, LPVOID * ppvObj);
HRESULT CXboxMenu_Create(CXboxFolder * pff, CXboxPidlList * pflHfpl, HWND hwnd, REFIID riid, LPVOID * ppvObj, BOOL fFromCreateViewObject);
HRESULT CXboxMenu_Create(CXboxFolder * pff, CXboxPidlList * pflHfpl, HWND hwnd, BOOL fFromCreateViewObject, CXboxMenu ** ppfm);
HRESULT CXboxDrop_Create(CXboxFolder * pff, HWND hwnd, CXboxDrop ** ppfm);
HRESULT CXboxEfe_Create(DWORD dwSize, FORMATETC rgfe[], STGMEDIUM rgstg[], CXboxObj * pfo, IEnumFORMATETC ** ppenum);
HRESULT CXboxEidl_Create(CXboxDir * pfd, CXboxFolder * pff, HWND hwndOwner, DWORD shcontf, IEnumIDList ** ppenum);
HRESULT CXboxFolder_Create(REFIID riid, LPVOID * ppvObj);
HRESULT CXboxInstaller_Create(REFIID riid, LPVOID * ppvObj);
IUnknown * CXboxGlob_Create(HGLOBAL hglob);
CXboxGlob * CXboxGlob_CreateStr(LPCTSTR pszStr);
HRESULT CXboxIcon_Create(CXboxFolder * pff, CXboxPidlList * pflHfpl, REFIID riid, LPVOID * ppv);
HRESULT CXboxIcon_Create(CXboxFolder * pff, CXboxPidlList * pflHfpl, CXboxIcon ** ppfm);
HRESULT CXboxList_Create(int cpvInit, PFNDPAENUMCALLBACK pfn, UINT nGrow, CXboxList ** ppfl);
HRESULT CXboxObj_Create(CXboxFolder * pff, CXboxPidlList * pflHfpl, REFIID riid, LPVOID * ppvObj);
HRESULT CXboxObj_Create(CXboxFolder * pff, CXboxPidlList * pflHfpl, CXboxObj ** ppfo);
HRESULT CXboxObj_Create(REFIID riid, void ** ppvObj);
HRESULT CXboxProp_Create(CXboxPidlList * pflHfpl, CXboxFolder * pff, HWND hwnd, CXboxProp ** ppfp);
HRESULT CXboxStm_Create(CXboxDir * pfd, LPCITEMIDLIST pidl, DWORD dwAccess, CXboxStm ** ppstream, ULARGE_INTEGER uliComplete, ULARGE_INTEGER uliTotal, IProgressDialog * ppd, BOOL fClosePrgDlg);
HRESULT CXboxView_Create(CXboxFolder * pff, HWND hwndOwner, CXboxView ** ppfv);
HRESULT CXboxSite_Create(LPCSTR pszSite, CXboxSite ** ppfs);
HRESULT CXboxPidlList_Create(int cpidl, LPCITEMIDLIST rgpidl[], CXboxPidlList ** ppfl);



void TriggerDelayedAction(LPGLOBALTIMEOUTINFO * phgti);
STDMETHODIMP SetDelayedAction(DELAYEDACTIONPROC pfn, LPVOID pvRef, LPGLOBALTIMEOUTINFO * phgti);
HRESULT PurgeDelayedActions(void);
BOOL AreOutstandingDelayedActions(void);

UINT XboxConfirmDeleteDialog(HWND hwnd, CXboxPidlList * pflHfpl, CXboxFolder * pff);
UINT XboxConfirmReplaceDialog(HWND hwnd, LPWIN32_FIND_DATA pwfdLocal, LPXBOX_FIND_DATA pwfdRemote, int cobj, CXboxFolder * pff);
UINT XboxConfirmReplaceDialog(HWND hwnd, LPXBOX_FIND_DATA pwfdLocal, LPWIN32_FIND_DATA pwfdRemote, int cobj, CXboxFolder * pff);

CXboxView * GetCXboxViewFromDefViewSite(IUnknown * punkSite);

/*****************************************************************************\
    XBOX Notes and Issues

    Time/Date Stamps on XBOX Files:
        There are two issues, the date on the server isn't time zone independent,
    and XBOX/Wininet only do LastWriteTime (not CreationTime & LastAccessedTime).
    1. Corrdinated Universal Time (UTC) is the format to use to store time in
       a time zone indepndent manner.  Time displayed to the user then gets
       converted at the last moment so it's correct wrt the time zone.  FindFirstFile()
       does fill in the WIN32_FIND_DATA structure with UTC time, but wininet doesn't.
       This means that this XBOX code can't do the UTC->LocalTime convertion when
       displaying the date/time.
    2. Only the modified date is sent via XBOX.  Oh well, not to sever.

    Threading Issues:
        XBOX can be called from several threads:
    1. Main UI Thread: CXboxFolder, ....
    2. Folder Contents Enum: CXboxFolder, IEnumIDList, CXboxDir, CXboxSite.
    2. AutoComplete Enum: CXboxFolder, IEnumIDList, CXboxDir, CXboxSite.
    BUGBUG/TODO: Go thru all of the code and make sure it's thread safe
                 and add asserts to assert which classes are single threaded
                 and which need to be thread safe.

    PERF:
        1. We only cache an XBOX session (InternetConnect()) for 10 seconds.  We should
           increase this to 50sec to 90 or maybe 120sec. This is currently done because
           we need to force the session to close down early when we are going to shutdown
           the process or try to unload our dll.
        2. Our Tree Walker code for recusrive operations (upload, download, delete) (in xboxpl.cpp)
           calls XboxGetCurrentDirectory() and XboxSetCurrentDirectory() too often. To fix
           this, we need to verify we don't recurse into SOFTLINK directories because
           this is what requires the XboxGetCurrentDirectory.  This also could cause a
           recursion death bug and infinite loop.  We would then create
           ::_CacheChangeDir() and ::_CommitChangeDir() so the could remain
           simple but we would cache several Change Directories.
        3. If the desktop or desktop toolbars have XBOX Shortcuts, the icon is
           extracted in such a way that we hit the net.  This figgen sucks!!!
           Fix this, even if this mean hacking.
\*****************************************************************************/


// WARNING: Don't put any #defines or typedefs after the includes or they won't be recognized.

#endif // _PRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\unithunk.h ===
/*****************************************************************************\
    FILE: unithunk.h
\*****************************************************************************/

#ifndef _UNICODE_THUNK_WRAPPERS_H
#define _UNICODE_THUNK_WRAPPERS_H



// BUGBUG: Nuke after IE5 beta 1.
#define POST_IE5_BETA

// NOTES:
//    CharPrevW and lstrcpyW doesn't appear to be used in our code.
//
// The .map file will show that we link to MessageBoxW and GetNumberFormatW but
// that is okay because we only use it on NT.

//////////////////////////// IE 5 vs IE 4 /////////////////////////////////
// These are functions that IE5 exposes (normally in shlwapi), but
// if we want to be compatible with IE4, we need to have our own copy.
// If we turn on USE_IE5_UTILS, we won't work with IE4's DLLs (like shlwapi).
#ifndef USE_IE5_UTILS
#define IUnknown_Set                    UnicWrapper_IUnknown_Set
#define SHWaitForSendMessageThread      UnicWrapper_SHWaitForSendMessageThread
#define AutoCompleteFileSysInEditbox    UnicWrapper_AutoCompleteFileSysInEditbox

void            UnicWrapper_IUnknown_Set(IUnknown ** ppunk, IUnknown * punk);
DWORD UnicWrapper_SHWaitForSendMessageThread(HANDLE hThread, DWORD dwTimeout);
HRESULT AutoCompleteFileSysInEditbox(HWND hwndEdit);

#endif // USE_IE5_UTILS
//////////////////////////// IE 5 vs IE 4 /////////////////////////////////


#endif // _UNICODE_THUNK_WRAPPERS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\statusbr.h ===
/*****************************************************************************
 *	statusbr.h
 *****************************************************************************/

#ifndef _STATUSBAR_H
#define _STATUSBAR_H

#include <urlmon.h>

CStatusBar * CStatusBar_Create(HWND hwndStatus);

#define MAX_NUM_ZONES_ICONS         12

enum ICON_TODISPLAY
{
    ITD_WriteAllowed = 0,
    ITD_WriteNotAllowed,
    ITD_MAX
};

enum ICON_SLOT
{
    ISLOT_WritePermission = 0,
    ISLOT_MAX
};

#define STATUS_PANE_STATUS      0
#define STATUS_PANE_USERNAME    1
#define STATUS_PANE_ZONE        2
// #define STATUS_PANE_WRITEICON   4


/*****************************************************************************
 *
 *	CStatusBar
 *
 *****************************************************************************/

class CStatusBar
{
public:
    CStatusBar(HWND hwndStatus);
    ~CStatusBar(void);

    // Public Member Functions
    void SetStatusMessage(UINT nMessageID, LPCTSTR pszExtra);

    void SetUserName(LPCTSTR pszUserName, BOOL fAnnonymous);
    void SetFolderAttribute(BOOL fWriteAllowed);
    void UpdateZonesPane(LPCTSTR pszUrl);
    HRESULT Resize(LONG x, LONG y);

    friend CStatusBar * CStatusBar_Create(HWND hwndStatus) { return new CStatusBar(hwndStatus); };

protected:
    // Private Member Variables
    BOOL                    m_fInited : 1;
    BOOL                    m_fWriteAllowed : 1;

    HWND                    m_hwndStatus;                   // HWND for entire bar
    IInternetSecurityManager *  m_pism;
    IInternetZoneManager *  m_pizm;
    HICON                   m_arhiconZones[MAX_NUM_ZONES_ICONS];
    long                    m_lCurrentZone;
    HICON                   m_arhiconGeneral[ITD_MAX];

    LPTSTR                  m_pszUserName;
    LPTSTR                  m_pszUserNameTT;


    // Private Member Variables
    HRESULT _InitStatusBar(void);
    HRESULT _SetParts(void);

    HRESULT _SetIconAndTip(ICON_SLOT nIconSlot, ICON_TODISPLAY nIconToDisplay, LPCTSTR pszTip);
    HRESULT _LoadZoneInfo(LPCTSTR pszUrl);
    HRESULT _SetZone(void);
    void _SetUserParts(void);
    void _CacheZonesIcons(void);
};

#endif // _STATUSBAR_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\statusbr.cpp ===
/*****************************************************************************
 *
 *      statusbr.cpp - Take care of the status bar.
 *
 *****************************************************************************/

#include "priv.h"
#include "statusbr.h"

// HACKHACK: 
//      \nt\public\sdk\inc\multimon.h overrides the normal GetSystemMetrics() with
//      xGetSystemMetrics().  The problem is that you can't link because you need to
//      have at least one file in your project that #defines COMPILE_MULTIMON_STUBS
//      so that these stub override functions will get implemented.
#define COMPILE_MULTIMON_STUBS
#include "multimon.h"


#define PANE_WIDTH_USERNAME     125
#define STATUS_PANES            3


//////////////////////////////////////////////////////////////////
//  General Text Pane
//////////////////////////////////////////////////////////////////

void CStatusBar::SetStatusMessage(UINT nMessageID, LPCTSTR pszExtra)
{
    if (NULL == this)
        return;

    _InitStatusBar();       // This is a NO-OP if it's already inited.

    ASSERTNONCRITICAL;
    if (m_hwndStatus)
    {
        TCHAR szMsg[256] = TEXT("%s");
        TCHAR szBuf[1024];

        if (nMessageID)
            LoadString(g_hinst, nMessageID, szMsg, ARRAYSIZE(szMsg));
        wnsprintf(szBuf, ARRAYSIZE(szBuf), szMsg, pszExtra);

//        TraceMsg(TF_XBOXSTATUSBAR, "CStatusBar::SetStatusMessage() Message=%s", szBuf);
        SendMessage(m_hwndStatus, SB_SETTEXT, STATUS_PANE_STATUS, (LPARAM)szBuf);
        SendMessage(m_hwndStatus, SB_SETTIPTEXT, STATUS_PANE_STATUS, (LPARAM)szBuf);
        UpdateWindow(m_hwndStatus);
    }
}


//////////////////////////////////////////////////////////////////
//  User Name Pane
//////////////////////////////////////////////////////////////////

void CStatusBar::SetUserName(LPCTSTR pszUserName, BOOL fAnnonymous)
{
    TCHAR szTipText[MAX_PATH];
    TCHAR szStrTemplate[MAX_PATH];

    _InitStatusBar();       // This is a NO-OP if it's already inited.
    //TraceMsg(TF_XBOXSTATUSBAR, "CStatusBar::SetUserName(pszUserName=%s, fAnnonymous=%d)", pszUserName, fAnnonymous);

    ASSERT(pszUserName);
    LoadString(HINST_THISDLL, IDS_USER_TEMPLATE, szStrTemplate, ARRAYSIZE(szStrTemplate));

    if (fAnnonymous)
    {
        TCHAR szAnnonymousName[MAX_PATH];

        LoadString(HINST_THISDLL, IDS_USER_ANNONYMOUS, szAnnonymousName, ARRAYSIZE(szAnnonymousName));
        wnsprintf(szTipText, ARRAYSIZE(szTipText), szStrTemplate, szAnnonymousName);
    }
    else
        wnsprintf(szTipText, ARRAYSIZE(szTipText), szStrTemplate, pszUserName);
        

    Str_SetPtr(&m_pszUserName, szTipText);

    LoadString(HINST_THISDLL, (fAnnonymous ? IDS_USER_ANNONTOOLTIP : IDS_USER_USERTOOLTIP), szStrTemplate, ARRAYSIZE(szStrTemplate));
    wnsprintf(szTipText, ARRAYSIZE(szTipText), szStrTemplate, pszUserName);
    Str_SetPtr(&m_pszUserNameTT, szTipText);
    _SetUserParts();
}


void CStatusBar::_SetUserParts(void)
{
    SendMessage(m_hwndStatus, SB_SETTEXT, STATUS_PANE_USERNAME, (LPARAM)(m_pszUserName ? m_pszUserName : TEXT("")));
    SendMessage(m_hwndStatus, SB_SETTIPTEXT, STATUS_PANE_USERNAME, (LPARAM)(m_pszUserNameTT ? m_pszUserNameTT : TEXT("")));
}


//////////////////////////////////////////////////////////////////
//  Icons Panes (Read, Write, ...)
//////////////////////////////////////////////////////////////////

#define GET_RESID_FROM_PERMISSION(nType, nAllowed)  (IDS_BEGIN_SB_TOOLTIPS + nType + (nAllowed ? 0 : 1))

void CStatusBar::SetFolderAttribute(BOOL fWriteAllowed)
{
    TCHAR szToolTip[MAX_PATH];

    _InitStatusBar();       // This is a NO-OP if it's already inited.

    m_fWriteAllowed = fWriteAllowed;
    LoadString(HINST_THISDLL, GET_RESID_FROM_PERMISSION(ITD_WriteAllowed, fWriteAllowed), szToolTip, ARRAYSIZE(szToolTip));
    _SetIconAndTip(ISLOT_WritePermission, fWriteAllowed ? ITD_WriteAllowed : ITD_WriteNotAllowed, szToolTip);
}

HRESULT CStatusBar::_SetIconAndTip(ICON_SLOT nIconSlot, ICON_TODISPLAY nIconToDisplay, LPCTSTR pszTip)
{
    /*
    if (EVAL(m_hwndStatus))
    {
        if (!m_arhiconGeneral[nIconToDisplay])
        {
            m_arhiconGeneral[nIconToDisplay] = (HICON)LoadImage(HINST_THISDLL, MAKEINTRESOURCE(nIconToDisplay + IDI_WRITE_ALLOWED), 
                IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), 0);
        }

        SendMessage(m_hwndStatus, SB_SETICON, STATUS_PANE_WRITEICON, (LPARAM)m_arhiconGeneral[nIconToDisplay]);
        SendMessage(m_hwndStatus, SB_SETTIPTEXT, STATUS_PANE_WRITEICON, (LPARAM)pszTip);
    }
*/
    return S_OK;
}


//////////////////////////////////////////////////////////////////
//  Zones Pane
//////////////////////////////////////////////////////////////////

void CStatusBar::UpdateZonesPane(LPCTSTR pszUrl)
{
    _InitStatusBar();       // This is a NO-OP if it's already inited.
    if (EVAL(SUCCEEDED(_LoadZoneInfo(pszUrl))))
        EVAL(SUCCEEDED(_SetZone()));
}

HRESULT CStatusBar::_LoadZoneInfo(LPCTSTR pszUrl)
{
    m_lCurrentZone = ZONE_UNKNOWN;
    if (!m_pism)
        CoCreateInstance(CLSID_InternetSecurityManager, NULL, CLSCTX_INPROC_SERVER, IID_IInternetSecurityManager, (void **)&m_pism);

    if (m_pism)
    {
        WCHAR wzUrl[MAX_URL_STRING];

        SHTCharToUnicode(pszUrl, wzUrl, ARRAYSIZE(wzUrl));
        m_pism->MapUrlToZone(wzUrl, (DWORD*)&m_lCurrentZone, 0);
    }        

    return S_OK;
}

HRESULT CStatusBar::_SetZone(void)
{
    ZONEATTRIBUTES za = {SIZEOF(za)};
    HICON hIcon = NULL;
            
    if (!m_arhiconZones[0])
        _CacheZonesIcons();
            
    if (m_pizm && (m_lCurrentZone != ZONE_UNKNOWN))
    {
        m_pizm->GetZoneAttributes(m_lCurrentZone, &za);
        hIcon = m_arhiconZones[m_lCurrentZone];
    }
    else
        _LoadStringW(HINST_THISDLL, IDS_ZONES_UNKNOWN, za.szDisplayName, ARRAYSIZE(za.szDisplayName));
    
    SendMessage(m_hwndStatus, SB_SETTEXTW, STATUS_PANE_ZONE, (LPARAM)za.szDisplayName);
    SendMessage(m_hwndStatus, SB_SETTIPTEXTW, STATUS_PANE_ZONE, (LPARAM)za.szDisplayName);
    SendMessage(m_hwndStatus, SB_SETICON, STATUS_PANE_ZONE, (LPARAM)hIcon);
    return S_OK;
}

void CStatusBar::_CacheZonesIcons(void)
{
    DWORD dwZoneCount = 0;

    if (!m_pizm)
        CoCreateInstance(CLSID_InternetZoneManager, NULL, CLSCTX_INPROC_SERVER, IID_IInternetZoneManager, (void **)&m_pizm);
    
    if (EVAL(m_pizm))
    {
        DWORD dwZoneEnum;

        if (EVAL(SUCCEEDED(m_pizm->CreateZoneEnumerator(&dwZoneEnum, &dwZoneCount, 0))))
        {
            for (int nIndex=0; (DWORD)nIndex < dwZoneCount; nIndex++)
            {
                DWORD           dwZone;
                ZONEATTRIBUTES  za = {sizeof(ZONEATTRIBUTES)};
                WORD            iIcon=0;
                HICON           hIcon = NULL;

                m_pizm->GetZoneAt(dwZoneEnum, nIndex, &dwZone);

                // get the zone attributes for this zone
                m_pizm->GetZoneAttributes(dwZone, &za);

                // Zone icons are in two formats.
                // wininet.dll#1200 where 1200 is the res id.
                // or foo.ico directly pointing to an icon file.
                // search for the '#'
                LPWSTR pwsz = StrChrW(za.szIconPath, TEXTW('#'));

                if (pwsz)
                {
                    TCHAR           szIconPath[MAX_PATH];        
                    // if we found it, then we have the foo.dll#00001200 format
                    pwsz[0] = TEXTW('\0');
                    SHUnicodeToTChar(za.szIconPath, szIconPath, ARRAYSIZE(szIconPath));
                    iIcon = (WORD)StrToIntW(pwsz+1);
                    ExtractIconEx(szIconPath,(INT)(-1*iIcon), NULL, &hIcon, 1 );
                }
                else
                    hIcon = (HICON)ExtractAssociatedIconExW(HINST_THISDLL, za.szIconPath, (LPWORD)&iIcon, &iIcon);
                    
                if (nIndex < MAX_NUM_ZONES_ICONS)
                     m_arhiconZones[nIndex] = hIcon;
            }
            m_pizm->DestroyZoneEnumerator(dwZoneEnum);
        }
    }    
}


HRESULT CStatusBar::Resize(LONG x, LONG y)
{
    return _SetParts();
}


//////////////////////////////////////////////////////////////////
//  General Functions
//////////////////////////////////////////////////////////////////

HRESULT CStatusBar::_InitStatusBar(void)
{
    HRESULT hr = S_OK;

    // Only reformat the StatusBar if we haven't yet, or
    // if someone formatted it away from us. (@!%*#)
    if ((!m_fInited) ||
        (STATUS_PANES != SendMessage(m_hwndStatus, SB_GETPARTS, 0, 0L)))
    {
        m_fInited = TRUE;
        hr = _SetParts();
    }

    return hr;
}


HRESULT CStatusBar::_SetParts(void)
{
    HRESULT hr = S_OK;
    RECT rc;

    ASSERTNONCRITICAL;

#ifdef OLD_STYLE_STATUSBAR
    SendMessage(hwnd, SB_SETTEXT, 1 | SBT_NOBORDERS, 0);
#else // OLD_STYLE_STATUSBAR

    GetClientRect(m_hwndStatus, &rc);
    const UINT cxZone = ZoneComputePaneSize(m_hwndStatus);
    const UINT cxUserName = PANE_WIDTH_USERNAME;

    INT nStatusBarWidth = rc.right - rc.left;                             
    INT arnRtEdge[STATUS_PANES] = {1};
    INT nIconPaneWidth = GetSystemMetrics(SM_CXSMICON) + (GetSystemMetrics(SM_CXEDGE) * 4);
    INT nWidthReqd = cxZone + cxUserName + (nIconPaneWidth * 1);

    arnRtEdge[STATUS_PANE_STATUS] = max(1, nStatusBarWidth - nWidthReqd);

    nWidthReqd -= cxUserName;
    arnRtEdge[STATUS_PANE_USERNAME] = max(1, nStatusBarWidth - nWidthReqd);

    /*
    nWidthReqd -= (nIconPaneWidth);
    arnRtEdge[STATUS_PANE_WRITEICON] = max(1, nStatusBarWidth - nWidthReqd);
    */

    arnRtEdge[STATUS_PANE_ZONE] = -1;

    LRESULT nParts = 0;
    nParts = SendMessage(m_hwndStatus, SB_GETPARTS, 0, 0L);
    if (nParts != STATUS_PANES)
    {
        for ( int n = 0; n < nParts; n++)
        {
            SendMessage(m_hwndStatus, SB_SETTEXT, n, NULL);
            SendMessage(m_hwndStatus, SB_SETICON, n, NULL);
        }
        SendMessage(m_hwndStatus, SB_SETPARTS, 0, 0L);
    }

    SendMessage(m_hwndStatus, SB_SETPARTS, STATUS_PANES, (LPARAM)arnRtEdge);

    SendMessage(m_hwndStatus, SB_GETRECT, 1, (LPARAM)&rc);
    InflateRect(&rc, -GetSystemMetrics(SM_CXEDGE), -GetSystemMetrics(SM_CYEDGE));

    SendMessage(m_hwndStatus, SB_SETTEXT, 1, (LPARAM)SZ_EMPTY);
    SendMessage(m_hwndStatus, SB_SETMINHEIGHT, GetSystemMetrics(SM_CYSMICON) + GetSystemMetrics(SM_CYBORDER) * 2, 0L);
    _SetZone();
    _SetUserParts();

#endif // OLD_STYLE_STATUSBAR
    return hr;
}


/****************************************************\
    Constructor
\****************************************************/
CStatusBar::CStatusBar(HWND hwndStatus)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_pism);
    ASSERT(!m_pizm);
    ASSERT(!m_pszUserName);
    ASSERT(!m_pszUserNameTT);

    m_hwndStatus = hwndStatus;
    m_lCurrentZone = ZONE_UNKNOWN;

    LEAK_ADDREF(LEAK_CStatusBar);
}


/****************************************************\
    Destructor
\****************************************************/
CStatusBar::~CStatusBar(void)
{
    int nIndex;

    IUnknown_Set((IUnknown **) &m_pism, NULL);
    IUnknown_Set((IUnknown **) &m_pizm, NULL);

    Str_SetPtr(&m_pszUserName, NULL);
    Str_SetPtr(&m_pszUserNameTT, NULL);

    for (nIndex = 0; nIndex < MAX_NUM_ZONES_ICONS; nIndex++)
    {
        if (m_arhiconZones[nIndex])
            DestroyIcon(m_arhiconZones[nIndex]);
    }

    for (nIndex = 0; nIndex < ITD_MAX; nIndex++)
    {
        if (m_arhiconGeneral[nIndex])
            DestroyIcon(m_arhiconGeneral[nIndex]);
    }

    ASSERTNONCRITICAL;
    SendMessage(m_hwndStatus, SB_SETTEXT, 1 | SBT_NOBORDERS, 0);

    DllRelease();
    LEAK_DELREF(LEAK_CStatusBar);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\util.h ===
/*****************************************************************************\
    FILE: util.cpp

    DESCRIPTION:
        Shared stuff that operates on all classes.
\*****************************************************************************/

#ifndef _UTIL_H
#define _UTIL_H

#include "encoding.h"
#include "xboxfldr.h"
#include "xboxdir.h"
#include "xboxsite.h"
#include "xboxlist.h"
#include "xboxefe.h"
#include "xboxglob.h"
#include "xboxcm.h"
#include "xboxstm.h"
#include "dllload.h"
#include "security.h"

// BUGBUG: Don't ship with these on
#define WININET_DEBUG_FLAGS_XBOXFINDFIRSTFILE            (INTERNET_FLAG_DONT_CACHE | INTERNET_FLAG_RESYNCHRONIZE | INTERNET_FLAG_RELOAD)

// Don't ship with this on.  Only for BryanSt's debugging
//#define DEBUG_WININET_BREAKS

#define DOES_POINTER_MATCHES_HRESULT(pointer, hr)         ((pointer && SUCCEEDED(hr)) || (!pointer && FAILED(hr)))
#define ASSERT_POINTER_MATCHES_HRESULT(pointer, hr)       ASSERT(DOES_POINTER_MATCHES_HRESULT((pointer), hr))
#define EVAL_POINTER_MATCHES_HRESULT(pointer, hr)         EVAL(DOES_POINTER_MATCHES_HRESULT((pointer), hr)

extern "C" void *_ReturnAddress();

#pragma intrinsic(_ReturnAddress)

#ifdef DEBUG    // DEBUG - DEBUG - DEBUG - DEBUG - DEBUG - DEBUG - DEBUG - DEBUG - DEBUG - DEBUG
#define CREATE_CALLERS_ADDRESS
#define GET_CALLERS_ADDRESS        _ReturnAddress()

#ifdef DEBUG_WININET_BREAKS
#define WININET_ASSERT(val)         ASSERT(val)
#endif // DEBUG_WININET_BREAKS

void TraceMsgWithCurrentDir(DWORD dwTFOperation, LPCSTR pszMessage, HINTERNET hint);
void DebugStartWatch(void);
DWORD DebugStopWatch(void);
#else // DEBUG - DEBUG - DEBUG - DEBUG - DEBUG - DEBUG - DEBUG - DEBUG - DEBUG - DEBUG
#define CREATE_CALLERS_ADDRESS     NULL;
#define GET_CALLERS_ADDRESS        0x00000000

#define TraceMsgWithCurrentDir(dwTFOperation, pszMessage, hint)         NULL;
#define DebugStartWatch()                                               NULL;
#define DebugStopWatch()                                                0
#endif  // DEBUG - DEBUG - DEBUG - DEBUG - DEBUG - DEBUG - DEBUG - DEBUG - DEBUG - DEBUG

#ifndef WININET_ASSERT
#define WININET_ASSERT(val)         NULL
#endif // DEBUG_WININET_BREAKS





#define ChooseWindow(hwnd1, hwnd2)           (hwnd1 ? hwnd1 : hwnd2)
typedef BOOL (*HGLOBWITHPROC)(LPVOID pv, LPVOID pvRef, LPCVOID pvParam2, BOOL fUnicode);

int SHMessageBox(HWND hwnd, LPCTSTR pszMessage, UINT uMessageID, UINT uTitleID, UINT uType);
//HRESULT ShellExecXboxUrl(LPCTSTR pszUrl);
//HRESULT ShellExecXboxPidl(LPCITEMIDLIST pidl);


// SHChangeNotify() wrappers that will update our cache of the XBOX server contents before
//   calling SHChangeNotify().  This will make sure DefView still has valid dates when it
//   converts the pidl passed to SHChangeNotify() to a display name and then has us turn
//   it back into a pidl via ::ParseDisplayName().  DefView does this to
void XboxChangeNotify(HWND hwnd, LONG wEventId, CXboxFolder * pff, CXboxDir * pfd, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, BOOL fTopLevel);

BOOL IsLegacyChangeNotifyNeeded(LONG wEventId);
HRESULT ForceDefViewRefresh(HWND hwnd, LPCITEMIDLIST pidl);


#define HANDLE_NULLSTR(str)         (str ? str : SZ_EMPTY)
#define HANDLE_NULLSTRA(str)         (str ? str : "")

// Allocation Helper Funcitions
void            IUnknown_Set(IMalloc ** ppm, IMalloc * pm);
void            IUnknown_Set(CXboxFolder ** ppff, CXboxFolder * pff);
void            IUnknown_Set(CXboxDir ** ppfd, CXboxDir * pfd);
void            IUnknown_Set(CXboxSite ** ppfs, CXboxSite * pfs);
void            IUnknown_Set(CXboxList ** ppfl, CXboxList * pfl);
void            IUnknown_Set(CXboxPidlList ** ppflpidl, CXboxPidlList * pflpidl);
void            IUnknown_Set(CXboxEfe ** ppfefe, CXboxEfe * pfefe);
void            IUnknown_Set(CXboxGlob ** ppfg, CXboxGlob * pfg);
void            IUnknown_Set(CXboxMenu ** ppfcm, CXboxMenu * pfcm);
void            IUnknown_Set(CXboxStm ** ppfstm, CXboxStm * pfstm);

HRESULT IUnknown_PidlNavigate(IUnknown * punk, LPCITEMIDLIST pidl, BOOL fHistoryEntry);
//HRESULT IUnknown_UrlNavigate(IUnknown * punk, LPCTSTR pszUrl);
DWORD StrListLength(LPCTSTR ppszStrList);

#ifdef UNICODE
#define TCharSysAllocString(psz)    SysAllocString(psz)
#define Str_StrAndThunk             Str_StrAndThunkW
#else
extern BSTR AllocBStrFromString(LPCTSTR);
#define TCharSysAllocString(psz)    AllocBStrFromString(psz)
#define Str_StrAndThunk             Str_StrAndThunkA
#endif

HRESULT Str_StrAndThunkW(LPTSTR * ppszOut, LPCWSTR pwzIn, BOOL fStringList);
HRESULT Str_StrAndThunkA(LPTSTR * ppszOut, LPCSTR pszIn, BOOL fStringList);

DWORD   GetUrlSchemeA(LPCSTR psz);
DWORD   GetUrlSchemeW(LPCWSTR pwz);


DWORD Misc_SfgaoFromFileAttributes(DWORD dwFAFLFlags);
HRESULT Misc_StringFromFileTime(LPTSTR pszDateTime, DWORD cchSize, LPFILETIME pft, DWORD flType);
HRESULT Misc_CreateHglob(SIZE_T cb, LPVOID pv, HGLOBAL *phglob);
int _HIDA_Create_Tally(LPVOID pvPidl, LPVOID pv);
int _HIDA_Create_AddIdl(LPVOID pvPidl, LPVOID pv);
BOOL _Misc_HIDA_Init(LPCVOID hida, LPCVOID pv, BOOL fUnicode);
HIDA Misc_HIDA_Create(LPCITEMIDLIST pidlFolder, CXboxPidlList * pflHfpl);
BOOL _Misc_HFGD_Init(LPVOID pv, LPVOID pvHFPL, BOOL fUnicode);
HGLOBAL Misc_HFGD_Create(CXboxPidlList * pflHfpl, LPCITEMIDLIST pidlItem, BOOL fUnicode);
UINT AddToPopupMenu(HMENU hmenuDst, UINT idMenuToAdd, UINT idSubMenuIndex, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
UINT MergeInToPopupMenu(HMENU hmenuDst, UINT idMenuToMerge, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
HMENU GetMenuFromID(HMENU hmenu, UINT idm);
UINT MergeMenuHierarchy(HMENU hmenuDst, HMENU hmenuSrc, UINT idcMin, UINT idcMax);
HRESULT Misc_CopyPidl(LPCITEMIDLIST pidl, LPITEMIDLIST * ppidlOut);
HRESULT Misc_CloneHglobal(HGLOBAL hglob, HGLOBAL *phglob);
HRESULT Misc_DeleteHfpl(CXboxFolder * pff, HWND hwnd, CXboxPidlList * pflHfpl);
HWND Misc_FindStatusBar(HWND hwndOwner);
void GetCfBufA(UINT cf, LPSTR psz, int cch);
HGLOBAL AllocHGlob(UINT cb, HGLOBWITHPROC pfn, LPVOID pvRef, LPCVOID pvParam2, BOOL fUnicode);
LPITEMIDLIST GetPidlFromXboxFolderAndPidlList(CXboxFolder * pff, CXboxPidlList * pflHfpl);
HRESULT XboxSafeCreateDirectory(HWND hwnd, HINTERNET hint, CMultiLanguageCache * pmlc, CXboxFolder * pff, CXboxDir * pfd, IProgressDialog * ppd, LPCWSTR pwzXboxPath, BOOL fRoot);
BOOL IsValidXboxAnsiFileName(LPCTSTR pszString);


enum SHELL_VERSION
{
    SHELL_VERSION_UNKNOWN        = 0,
    SHELL_VERSION_W95NT4,
    SHELL_VERSION_IE4,
    SHELL_VERSION_NT5,
};

SHELL_VERSION GetShellVersion(void);
DWORD GetShdocvwVersion(void);
BOOL ShouldSkipDropFormat(int nIndex);
HWND GetProgressHWnd(IProgressDialog * ppd, HWND hwndDefault);

void XboxProgressInternetStatusCB(IN HINTERNET hInternet, IN DWORD_PTR pdwContext, IN DWORD dwInternetStatus, IN LPVOID lpwStatusInfo, IN DWORD dwStatusInfoLen);


// In xboxresp.cpp
CXboxGlob * GetXboxResponse(CWireEncoding * pwe);
LPITEMIDLIST SHILCreateFromPathWrapper(LPCTSTR pszPath);
HRESULT _SetStatusBarZone(CStatusBar * psb, CXboxSite * pfs);
HRESULT CreateFromToStr(LPWSTR pwzStrOut, DWORD cchSize, ...);

int _LoadStringW(HINSTANCE hinst, UINT id, LPWSTR wsz, UINT cchMax);        // Implemented in olestuff.cpp
void SetWindowBits(HWND hWnd, int iWhich, DWORD dwBits, DWORD dwValue);
int DisplayWininetError(HWND hwnd, BOOL fAssertOnNULLHWND, DWORD dwError, UINT idTitleStr, UINT idBaseErrorStr, UINT idDetailsStr, UINT nMsgBoxType, IProgressDialog * ppd);
int DisplayWininetErrorEx(HWND hwnd, BOOL fAssertOnNULLHWND, DWORD dwError, UINT idTitleStr, UINT idBaseErrorStr, UINT idDetailsStr, UINT nMsgBoxType, IProgressDialog * ppd, LPCWSTR pwzDetails);
void ShowEnableWindow(HWND hwnd, BOOL fHide);

HRESULT RemoveCharsFromString(LPTSTR pszLocToRemove, DWORD cchSizeToRemove);
HRESULT RemoveCharsFromStringA(LPSTR pszLocToRemove, DWORD cchSizeToRemove);
HRESULT CharReplaceWithStrA(LPSTR pszLocToInsert, DWORD cchSize, DWORD cchChars, LPSTR pszStrToInsert);
HRESULT CharReplaceWithStrW(LPWSTR pszLocToInsert, DWORD cchSize, DWORD cchChars, LPWSTR pszStrToInsert);

HRESULT EscapeString(LPCTSTR pszStrToEscape, LPTSTR pszEscapedStr, DWORD cchSize);
HRESULT UnEscapeString(LPCTSTR pszStrToUnEscape, LPTSTR pszUnEscapedStr, DWORD cchSize);

HRESULT DisplayBlockingProxyDialog(LPCITEMIDLIST pidl, HWND hwnd);
HRESULT CopyStgMediumWrap(const STGMEDIUM * pcstgmedSrc, STGMEDIUM * pstgmedDest);
HRESULT SHBindToIDList(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
STDAPI StringToStrRetW(LPCWSTR pwzString, STRRET *pstrret);
HRESULT LoginAsViaFolder(HWND hwnd, CXboxFolder * pff, IUnknown * punkSite);
HRESULT LoginAs(HWND hwnd, CXboxFolder * pff, CXboxDir * pfd, IUnknown * punkSite);
void InitComctlForNaviteFonts(void);
CXboxPidlList * CreateRelativePidlList(CXboxFolder * pff, CXboxPidlList * pPidlListFull);


LPCITEMIDLIST ILGetLastID(LPCITEMIDLIST pidl);
LPCITEMIDLIST ILGetLastNonFragID(LPCITEMIDLIST pidl);
IProgressDialog * CProgressDialog_CreateInstance(UINT idTitle, UINT idAnimation);
HRESULT AddXBOXPropertyPages(LPFNADDPROPSHEETPAGE pfnAddPropSheetPage, LPARAM lParam, HINSTANCE * phinstInetCpl, IUnknown * punkSite);
BOOL Is7BitAnsi(LPCWIRESTR pwByteStr);
HRESULT SHPathPrepareForWriteWrapW(HWND hwnd, IUnknown *punkEnableModless, LPCWSTR pwzPath, UINT wFunc, DWORD dwFlags);

STDAPI DataObj_SetPreferredEffect(IDataObject *pdtobj, DWORD dwEffect);
STDAPI DataObj_SetPasteSucceeded(IDataObject *pdtobj, DWORD dwEffect);
STDAPI DataObj_GetDWORD(IDataObject *pdtobj, UINT cf, DWORD *pdwOut);
STDAPI DataObj_GetDropTarget(IDataObject *pdtobj, CLSID *pclsid);

#define     DEBUG_LEGACY_PROGRESS   0


EXTERN_C void _XBOXDebugMemLeak(UINT wFlags, LPCTSTR pszFile, UINT iLine);
#define XBOXDebugMemLeak(wFlags)  _XBOXDebugMemLeak(wFlags, TEXT(__FILE__), __LINE__)


#endif // _UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\view.h ===
/*****************************************************************************\
    FILE: view.h

    DESCRIPTION:
        This is our ShellView which implements XBOX specific behavior.  We get
    the default DefView implementation and then use IShellFolderViewCB to 
    override behavior specific to us.
\*****************************************************************************/

#ifndef _XBOXVIEW_H
#define _XBOXVIEW_H

#include "isfvcb.h"
#include "statusbr.h"
#include "xbnmspc.h"
#include "dspsprt.h"


CXboxView * GetCXboxViewFromDefViewSite(IUnknown * punkSite);
CStatusBar * GetCStatusBarFromDefViewSite(IUnknown * punkSite);
HRESULT XboxView_SetRedirectPidl(IUnknown * punkSite, LPCITEMIDLIST pidl);


class CXboxView
                : public CBaseFolderViewCB
                , public IXboxWebView
                , public CImpIDispatch
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) {return CBaseFolderViewCB::AddRef();};
    virtual STDMETHODIMP_(ULONG) Release(void) {return CBaseFolderViewCB::Release();};

    // *** IDispatch methods ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo * * pptinfo);
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR * * rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid);
    virtual STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr);
    
    // *** IXboxWebView methods ***
    virtual STDMETHODIMP get_Server(BSTR * pbstr);
    virtual STDMETHODIMP get_Directory(BSTR * pbstr);
    virtual STDMETHODIMP get_UserName(BSTR * pbstr);
    virtual STDMETHODIMP get_PasswordLength(long * plLength);
    virtual STDMETHODIMP get_EmailAddress(BSTR * pbstr);
    virtual STDMETHODIMP put_EmailAddress(BSTR bstr);
    virtual STDMETHODIMP get_CurrentLoginAnonymous(VARIANT_BOOL * pfAnonymousLogin);
    virtual STDMETHODIMP get_MessageOfTheDay(BSTR * pbstr);
    virtual STDMETHODIMP LoginAnonymously(void);
    virtual STDMETHODIMP LoginWithPassword(BSTR bUserName, BSTR bPassword);
    virtual STDMETHODIMP LoginWithoutPassword(BSTR bUserName);
    virtual STDMETHODIMP InvokeHelp(void) {return _OnInvokeXboxHelp(m_hwndOwner);};

    // *** CXboxViewPriv methods ***
    BOOL IsForegroundThread(void);
    CStatusBar * GetStatusBar(void) { return m_psb; };
    HRESULT SetRedirectPidl(LPCITEMIDLIST pidlRedirect);

public:
    // Public Member Functions
    static HRESULT DummyHintCallback(HWND hwnd, CXboxFolder * pff, HINTERNET hint, LPVOID pv1, LPVOID pv2);

    // Friend Functions
    friend HRESULT CXboxView_Create(CXboxFolder * pff, HWND hwndOwner, REFIID riid, LPVOID * ppv);

protected:
    // Private Member Variables
    HWND                    m_hwndOwner;            // The owner window
    HWND                    m_hwndStatusBar;        // The Status Bar window
    CXboxFolder *            m_pff;                  // The owner Folder
    LPGLOBALTIMEOUTINFO     m_hgtiWelcome;          // The timeout for the welcome message
    CStatusBar *            m_psb;                  // The timeout for the welcome message
    HINSTANCE               m_hinstInetCpl;         // HANDLE to Internet Control panel for View.Options.
    RECT                    m_rcPrev;               // Previous size so we know when to ignore resizes.
    UINT                    m_idMergedMenus;        // Where did I start merging menus?
    UINT                    m_nMenuItemsAdded;      // How many menu items did I had?
    LPITEMIDLIST            m_pidlRedirect;         // We want to redirect to this pidl. See the comments in _OnBackGroundEnumDone().
    UINT                    m_nThreadID;            // What is the main thread?

    // Private Member Functions
    CXboxView(CXboxFolder * pff, HWND hwndOwner);
    ~CXboxView();

    void _InitStatusBar(void);
    void _ShowMotd(void);
    HRESULT _OnInvokeXboxHelp(HWND hwnd);
    HRESULT _LoginWithPassword(LPCTSTR pszUserName, LPCTSTR pszPassword);

    virtual HRESULT _OnWindowCreated(void);
    virtual HRESULT _OnDefItemCount(LPINT pi);
    virtual HRESULT _OnGetHelpText(LPARAM lParam, WPARAM wParam);
    virtual HRESULT _OnGetZone(DWORD * pdwZone, WPARAM wParam);
    virtual HRESULT _OnGetPane(DWORD dwPaneID, DWORD * pdwPane);
    virtual HRESULT _OnRefresh(BOOL fReload);
    virtual HRESULT _OnDidDragDrop(DROPEFFECT de, IDataObject * pdto);
    virtual HRESULT _OnGetDetailsOf(UINT ici, PDETAILSINFO pdi);
    virtual HRESULT _OnInvokeCommand(UINT idc);
    virtual HRESULT _OnMergeMenu(LPQCMINFO pqcm);
    virtual HRESULT _OnUnMergeMenu(HMENU hMenu);
    virtual HRESULT _OnColumnClick(UINT ici);
    virtual HRESULT _OnGetNotify(LPITEMIDLIST * ppidl, LONG * lEvents);
    virtual HRESULT _OnSize(LONG x, LONG y);
    virtual HRESULT _OnUpdateStatusBar(void);
    virtual HRESULT _OnThisIDList(LPITEMIDLIST * ppidl);
    virtual HRESULT _OnAddPropertyPages(SFVM_PROPPAGE_DATA * pData);
    virtual HRESULT _OnInitMenuPopup(HMENU hmenu, UINT idCmdFirst, UINT nIndex);
    virtual HRESULT _OnGetHelpTopic(SFVM_HELPTOPIC_DATA * phtd);
    virtual HRESULT _OnBackGroundEnumDone(void);

    HRESULT _OnInvokeLoginAs(HWND hwndOwner);
    HRESULT _OnInvokeNewFolder(HWND hwndOwner);

    void _ShowMotdPsf(HWND hwndOwner);

private:
    static INT_PTR CALLBACK _MOTDDialogProc(HWND hDlg, UINT wm, WPARAM wParam, LPARAM lParam);
};

#endif // _XBOXVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\util.cpp ===
/*****************************************************************************\
    FILE: util.cpp
    
    DESCRIPTION:
        Shared stuff that operates on all classes.
\*****************************************************************************/

#include "priv.h"
#include "util.h"
#include "xboxurl.h"
#include "view.h"
#include "statusbr.h"
#include <shdocvw.h>

HINSTANCE g_hinst;              /* My instance handle */
CHAR g_szShell32[MAX_PATH];     /* Full path to shell32.dll (must be ANSI) */

DWORD GetOSVer(void);

#ifdef DEBUG
DWORD g_TLSliStopWatchStartHi = 0;
DWORD g_TLSliStopWatchStartLo = 0;
LARGE_INTEGER g_liStopWatchFreq = {0};
#endif // DEBUG

// Shell32.dll v3 (original Win95/WinNT) has so many bugs when it receives
// an IDataObject with FILEGROUPDESCRIPTOR that it doesn't make sense to allow
// users to drag from XBOX with FILEGROUPDESCRIPTOR on these early shell machines.
// This #define turns this on off.
//#define BROWSERONLY_DRAGGING        1

const VARIANT c_vaEmpty = {0};
#define PVAREMPTY ((VARIANT*)&c_vaEmpty)

//////////////////////////// IE 5 vs IE 4 /////////////////////////////////
// These are functions that IE5 exposes (normally in shlwapi), but
// if we want to be compatible with IE4, we need to have our own copy.s
// If we turn on USE_IE5_UTILS, we won't work with IE4's DLLs (like shlwapi).
//
#ifndef USE_IE5_UTILS
void UnicWrapper_IUnknown_Set(IUnknown ** ppunk, IUnknown * punk)
{
    ENTERCRITICAL;

    if (*ppunk)
        (*ppunk)->Release();

    *ppunk = punk;
    if (punk)
        punk->AddRef();

    LEAVECRITICAL;
}

void UnicWrapper_IUnknown_AtomicRelease(void ** ppunk)
{
    if (ppunk && *ppunk) {
        IUnknown* punk = *(IUnknown**)ppunk;
        *ppunk = NULL;
        punk->Release();
    }
}


DWORD UnicWrapper_SHWaitForSendMessageThread(HANDLE hThread, DWORD dwTimeout)
{
    MSG msg;
    DWORD dwRet;
    DWORD dwEnd = GetTickCount() + dwTimeout;

    // We will attempt to wait up to dwTimeout for the thread to
    // terminate
    do
    {
        dwRet = MsgWaitForMultipleObjects(1, &hThread, FALSE,
                dwTimeout, QS_SENDMESSAGE);
        if (dwRet == WAIT_OBJECT_0 ||
            dwRet == WAIT_FAILED)
        {
            // The thread must have exited, so we are happy
            break;
        }

        if (dwRet == WAIT_TIMEOUT)
        {
            // The thread is taking too long to finish, so just
            // return and let the caller kill it
            break;
        }

        // There must be a pending SendMessage from either the
        // thread we are killing or some other thread/process besides
        // this one.  Do a PeekMessage to process the pending
        // SendMessage and try waiting again
        PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);

        if (dwTimeout != INFINITE)
            dwTimeout = dwEnd - GetTickCount();
    }
    while((dwTimeout == INFINITE) || ((long)dwTimeout > 0));

    return(dwRet);
}


/****************************************************\
    FUNCTION: UnicWrapper_AutoCompleteFileSysInEditbox

    DESCRIPTION:
        This function will have AutoComplete take over
    an editbox to help autocomplete DOS paths.
\****************************************************/
HRESULT UnicWrapper_AutoCompleteFileSysInEditbox(HWND hwndEdit)
{
    HRESULT hr;
    IUnknown * punkACLISF;

    hr = CoCreateInstance(CLSID_ACListISF, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (void **)&punkACLISF);
    if (EVAL(SUCCEEDED(hr)))
    {
        IAutoComplete * pac;

        // Create the AutoComplete Object
        hr = CoCreateInstance(CLSID_AutoComplete, NULL, CLSCTX_INPROC_SERVER, IID_IAutoComplete, (void **)&pac);
        if (EVAL(SUCCEEDED(hr)))
        {
            hr = pac->Init(hwndEdit, punkACLISF, NULL, NULL);
            pac->Release();
        }

        punkACLISF->Release();
    }

    return hr;
}


#endif // USE_IE5_UTILS
//////////////////////////// IE 5 vs IE 4 /////////////////////////////////


void IUnknown_Set(IMalloc ** ppm, IMalloc * pm)
{
    ENTERCRITICAL;

    if (*ppm)
        (*ppm)->Release();
    
    *ppm = pm;

    if (pm)
        pm->AddRef();

    LEAVECRITICAL;
}

// TODO: This is a remnent of using C++ in stead of real COM
void IUnknown_Set(CXboxFolder ** ppff, CXboxFolder * pff)
{
    ENTERCRITICAL;

    if (*ppff)
        (*ppff)->Release();
    
    *ppff = pff;

    if (pff)
        pff->AddRef();

    LEAVECRITICAL;
}

void IUnknown_Set(CXboxDir ** ppfd, CXboxDir * pfd)
{
    ENTERCRITICAL;

    if (*ppfd)
        (*ppfd)->Release();
    
    *ppfd = pfd;

    if (pfd)
        pfd->AddRef();

    LEAVECRITICAL;
}

void IUnknown_Set(CXboxSite ** ppfs, CXboxSite * pfs)
{
    ENTERCRITICAL;

    if (*ppfs)
        (*ppfs)->Release();
    
    *ppfs = pfs;

    if (pfs)
        pfs->AddRef();

    LEAVECRITICAL;
}

void IUnknown_Set(CXboxList ** ppfl, CXboxList * pfl)
{
    ENTERCRITICAL;

    if (*ppfl)
        (*ppfl)->Release();
    
    *ppfl = pfl;

    if (pfl)
        pfl->AddRef();

    LEAVECRITICAL;
}

void IUnknown_Set(CXboxPidlList ** ppflpidl, CXboxPidlList * pflpidl)
{
    ENTERCRITICAL;

    if (*ppflpidl)
        (*ppflpidl)->Release();
    
    *ppflpidl = pflpidl;

    if (pflpidl)
        pflpidl->AddRef();

    LEAVECRITICAL;
}

void IUnknown_Set(CXboxEfe ** ppfefe, CXboxEfe * pfefe)
{
    ENTERCRITICAL;

    if (*ppfefe)
        (*ppfefe)->Release();
    
    *ppfefe = pfefe;

    if (pfefe)
        pfefe->AddRef();

    LEAVECRITICAL;
}

void IUnknown_Set(CXboxGlob ** ppfg, CXboxGlob * pfg)
{
    ENTERCRITICAL;

    if (*ppfg)
        (*ppfg)->Release();
    
    *ppfg = pfg;

    if (pfg)
        pfg->AddRef();

    LEAVECRITICAL;
}


void IUnknown_Set(CXboxMenu ** ppfcm, CXboxMenu * pfcm)
{
    ENTERCRITICAL;

    if (*ppfcm)
        (*ppfcm)->Release();
    
    *ppfcm = pfcm;

    if (pfcm)
        pfcm->AddRef();

    LEAVECRITICAL;
}


void IUnknown_Set(CXboxStm ** ppfstm, CXboxStm * pfstm)
{
    ENTERCRITICAL;

    if (*ppfstm)
        (*ppfstm)->Release();
    
    *ppfstm = pfstm;

    if (pfstm)
        pfstm->AddRef();

    LEAVECRITICAL;
}


#undef ILCombine
// Fix Shell32 bug
LPITEMIDLIST ILCombineWrapper(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    if (!pidl1)
        return ILClone(pidl2);

    if (!pidl2)
        return ILClone(pidl1);

    return ILCombine(pidl1, pidl2);
}


#undef ILClone
// Fix Shell32 bug
LPITEMIDLIST ILCloneWrapper(LPCITEMIDLIST pidl)
{
    if (!pidl)
        return NULL;

    return ILClone(pidl);
}


#undef ILFree
// Fix Shell32 bug
void ILFreeWrapper(LPITEMIDLIST pidl)
{
    if (pidl)
        ILFree(pidl);
}


// BUGBUG: Don't ship with this on.
//#define DEBUG_LEGACY

BOOL IsLegacyChangeNotifyNeeded(LONG wEventId)
{
#ifdef DEBUG_LEGACY
    return TRUE;
#endif // DEBUG_LEGACY

    // The only version that doesn't support IDelegateFolder pidls is
    // shell32 v3 (w/o IE4 Shell Intergrated)
    BOOL fResult = (SHELL_VERSION_W95NT4 == GetShellVersion());
    
    return fResult;
}



/*****************************************************************************\
    FUNCTION: LegacyChangeNotify

    DESCRIPTION:
        Browser only can't read IDelegateFolder pidls (our Pidls), so we need
    to use this function instead of SHChangeNotify that will use hacks to
    get DefView's ListView to update by using 
    SHShellFolderView_Message(HWND hwnd, UINT uMsg, LPARAM lParam).

    These are the messages to use.
    SFVM_ADDOBJECT (SHCNE_CREATE & SHCNE_MKDIR),
    SFVM_UPDATEOBJECT (SHCNE_RENAMEFOLDER, SHCNE_RENAMEITEM, SHCNE_ATTRIBUTES), or SFVM_REFRESHOBJECT(),
    SFVM_REMOVEOBJECT (SHCNE_RMDIR & SHCNE_DELETE).
\*****************************************************************************/
HRESULT LegacyChangeNotify(HWND hwnd, LONG wEventId, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    if (EVAL(hwnd))       // We can't talk to the window w/o this.
    {
        switch(wEventId)
        {
        case SHCNE_CREATE:
        case SHCNE_MKDIR:
        {
            // BUGBUG: If the item alread exists, it will create a new duplicate name.
            //         We need to skip this if it exists.
            LPCITEMIDLIST pidlRelative = ILGetLastID(pidl1);
            // For some lame reason, SFVM_ADDOBJECT frees the pidl we give them.
            EVAL(SHShellFolderView_Message(hwnd, SFVM_ADDOBJECT, (LPARAM) ILClone(pidlRelative)));
            break;
        }
        case SHCNE_RMDIR:
        case SHCNE_DELETE:
        {
            LPCITEMIDLIST pidlRelative = ILGetLastID(pidl1);
            EVAL(SHShellFolderView_Message(hwnd, SFVM_REMOVEOBJECT, (LPARAM) pidlRelative));
            break;
        }
        case SHCNE_RENAMEFOLDER:
        case SHCNE_RENAMEITEM:
        case SHCNE_ATTRIBUTES:
        {
            LPCITEMIDLIST pidlArray[2];
            
            pidlArray[0] = ILGetLastID(pidl1);
            pidlArray[1] = ILClone(ILGetLastID(pidl2));
            EVAL(SHShellFolderView_Message(hwnd, SFVM_UPDATEOBJECT, (LPARAM) pidlArray));
            break;
        }
        }
    }

    return S_OK;
}


/*****************************************************************************\
    FUNCTION: XboxChangeNotify

    Convert the relative pidls into absolute pidls, then hand onwards
    to SHChangeNotify.  If we can't do the notification, tough.

    Issuing a change notify also invalidates the name-cache, because
    we know that something happened to the directory.

    If we wanted to be clever, we could edit the name-cache on the
    fly, but that would entail allocating a new name-cache, initializing
    it with the edited directory contents, then setting it as the new
    cache.  (We can't edit the name-cache in place because somebody
    might still be holding a reference to it.)  And all this work needs
    to be done under the critical section, so that nobody else tries
    to do the same thing simultaneously.  What's more, the only thing
    that this helps is the case where the user opens two views on
    the same folder from within the same process, which not a very
    common scenario.  Summary: It's just not worth it.

    Note that this must be done at the CXboxFolder level and not at the
    CXboxDir level, because CXboxDir doesn't know where we are rooted.
    (We might have several instances, each rooted at different places.)

    _UNDOCUMENTED_: The pidl1 and pidl2 parameters to SHChangeNotify
    are not documented.  It is also not mentioned (although it becomes
    obvious once you realize it) that the pidls passed to SHChangeNotify
    must be absolute.
\*****************************************************************************/
void XboxChangeNotify(HWND hwnd, LONG wEventId, CXboxFolder * pff, CXboxDir * pfd, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, BOOL fTopLevel)
{
    ASSERT(pfd && IsValidPIDL(pidl1));
    ASSERT(!pidl2 || IsValidPIDL(pidl2));

    // Update our local cache because SHChangeNotify will come back in later and
    // want to create a pidl from a DisplayName and will then use that pidls
    // time/date.  This is done because the shell is trying to create a 'full'
    // pidl.
    switch (wEventId)
    {
    case SHCNE_CREATE:
    case SHCNE_MKDIR:
        TraceMsg(TF_CHANGENOTIFY, ((wEventId == SHCNE_CREATE) ? "XboxChangeNotify(SHCNE_CREATE), Name=%ls" : "XboxChangeNotify(SHCNE_MKDIR), Name=%s"), XboxPidl_GetFileDisplayName(pidl1));
        EVAL(SUCCEEDED(pfd->AddItem(pidl1)));
        break;
    case SHCNE_RMDIR:
    case SHCNE_DELETE:
        TraceMsg(TF_CHANGENOTIFY, "XboxChangeNotify(SHCNE_DELETE), Name=%ls", XboxPidl_GetLastFileDisplayName(pidl1));
        pfd->DeletePidl(pidl1); // This may fail if we never populated that cache.
        break;
    case SHCNE_RENAMEFOLDER:
    {
        CXboxDir * pfdSubFolder = pfd->GetSubXboxDir(NULL, pidl1, TRUE);
        
        if (EVAL(pfdSubFolder))
        {
            LPITEMIDLIST pidlDest = pfd->GetSubPidl(NULL, pidl2, TRUE);

            if (EVAL(pidlDest))
            {
                EVAL(SUCCEEDED(pfdSubFolder->ChangeFolderName(pidlDest)));
                ILFree(pidlDest);
            }
            pfdSubFolder->Release();
        }
    }
    // break; Fall Thru so we change the pidl also.
    case SHCNE_RENAMEITEM:
    case SHCNE_ATTRIBUTES:
        TraceMsg(TF_CHANGENOTIFY, "XboxChangeNotify(SHCNE_RENAMEITEM), Name1=%ls, Name2=%ls", XboxPidl_GetLastFileDisplayName(pidl1), XboxPidl_GetLastFileDisplayName(pidl2));
        EVAL(SUCCEEDED(pfd->ReplacePidl(pidl1, pidl2)));
        break;
    }

    pidl1 = pfd->GetSubPidl(pff, pidl1, TRUE);
    if (EVAL(pidl1))
    {
        if ((pidl2 == NULL) || (EVAL(pidl2 = pfd->GetSubPidl(pff, pidl2, TRUE))) != 0)
        {
            // LRESULT SHShellFolderView_Message(HWND hwnd, UINT uMsg, LPARAM lParam)

            // Are we on something (browser only) that can't read
            // IDelegateFolder pidls (our Pidls)?
            if (IsLegacyChangeNotifyNeeded(wEventId))  // BUGBUG
            {
                // Yes, so SHChangeNotify won't work.  Use a work around.
                if (fTopLevel)  // Only top level changes are appropriate.
                    LegacyChangeNotify(hwnd, wEventId, pidl1, pidl2);
            }
            else
                SHChangeNotify(wEventId, (SHCNF_IDLIST | SHCNF_FLUSH), pidl1, pidl2);

            ILFree((LPITEMIDLIST)pidl2);
        }
        ILFree((LPITEMIDLIST)pidl1);
    }
}




/**************************************************************\
    FUNCTION: EscapeString

    DESCRIPTION:
\**************************************************************/
HRESULT EscapeString(LPCTSTR pszStrToEscape, LPTSTR pszEscapedStr, DWORD cchSize)
{
    LPCTSTR pszCopy = NULL;

    if (!pszStrToEscape)
    {
        Str_SetPtr((LPTSTR *) &pszCopy, pszEscapedStr);  // NULL pszStrToEscape means do pszEscapedStr in place.
        pszStrToEscape = pszCopy;
    }

    pszEscapedStr[0] = 0;
    if (pszStrToEscape[0])
        UrlEscape(pszStrToEscape, pszEscapedStr, &cchSize, URL_ESCAPE_SEGMENT_ONLY);

    Str_SetPtr((LPTSTR *) &pszCopy, NULL);  // NULL pszStrToEscape means do pszEscapedStr in place.
    return S_OK;
}


/**************************************************************\
    FUNCTION: UnEscapeString

    DESCRIPTION:
\**************************************************************/
HRESULT UnEscapeString(LPCTSTR pszStrToUnEscape, LPTSTR pszUnEscapedStr, DWORD cchSize)
{
    LPCTSTR pszCopy = NULL;

    if (!pszStrToUnEscape)
    {
        Str_SetPtr((LPTSTR *) &pszCopy, pszUnEscapedStr);  // NULL pszStrToEscape means do pszEscapedStr in place.
        pszStrToUnEscape = pszCopy;
    }

    pszUnEscapedStr[0] = 0;
    UrlUnescape((LPTSTR)pszStrToUnEscape, pszUnEscapedStr, &cchSize, URL_ESCAPE_SEGMENT_ONLY);
    
    Str_SetPtr((LPTSTR *) &pszCopy, NULL);  // NULL pszStrToEscape means do pszEscapedStr in place.
    return S_OK;
}


/**************************************************************\
    Since wininet errors are often very generic, this function
    will generate error message of this format:

    "An error occurred while attempted to do x and it could not
     be completed.
     
    Details:
    <Wininet error that may be specific or generic>"
\**************************************************************/
int DisplayWininetErrorEx(HWND hwnd, BOOL fAssertOnNULLHWND, DWORD dwError, UINT idTitleStr, UINT idBaseErrorStr, UINT idDetailsStr, UINT nMsgBoxType, IProgressDialog * ppd, LPCWSTR pwzDetails)
{
    TCHAR szErrMessage[MAX_PATH*3];
    TCHAR szTitle[MAX_PATH];
    BOOL fIsWininetError = ((dwError >= INTERNET_ERROR_BASE) && (dwError <= INTERNET_ERROR_LAST));
    HMODULE hmod = (fIsWininetError ? GetModuleHandle(TEXT("WININET")) : NULL);
    UINT uiType = (IDS_XBOXERR_GETDIRLISTING == idBaseErrorStr) ? MB_ICONINFORMATION : MB_ICONERROR;
    
    if (ppd)
    {
        // If we have a progress dialog, we want to close it down
        // because we will display an error message and the progress
        // dialog in the background looks really dumb.
        ppd->StopProgressDialog();
    }

    // Default message if FormatMessage doesn't recognize hres
    LoadString(HINST_THISDLL, idBaseErrorStr, szErrMessage, ARRAYSIZE(szErrMessage));
    LoadString(HINST_THISDLL, idTitleStr, szTitle, ARRAYSIZE(szTitle));

    // Yes we did, so display the error.
    WCHAR szDetails[MAX_URL_STRING*2];
    TCHAR szPromptTemplate[MAX_PATH];
    TCHAR szBuffer[MAX_PATH*4];

    LoadString(HINST_THISDLL, idDetailsStr, szPromptTemplate, ARRAYSIZE(szPromptTemplate));

    // Can wininet give us extended error messages?
    // UNIX servers cancel the connection if the disk or quote is full
    // but the return a value that explains that to the user.
    if ((ERROR_INTERNET_EXTENDED_ERROR == dwError) || 
        (ERROR_INTERNET_CONNECTION_ABORTED == dwError))
    {
        if (!pwzDetails)
        {
            // BUGBUG/TODO: Strip the XBOX Spec #s from the err msg.
            // StripResponseHeaders(pszMOTD);
            if (FAILED(InternetGetLastResponseInfoDisplayWrap(TRUE, &dwError, szDetails, ARRAYSIZE(szDetails))))
                szDetails[0] = 0;

            pwzDetails = (LPCWSTR) szDetails;
        }
    }
    else
    {
        if (fIsWininetError)
            FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, (LPCVOID)hmod, dwError, 0, szDetails, ARRAYSIZE(szDetails), NULL);
        else
            FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, (LPCVOID)hmod, dwError, 0, szDetails, ARRAYSIZE(szDetails), NULL);

        pwzDetails = (LPCWSTR) szDetails;
    }

    wnsprintf(szBuffer, ARRAYSIZE(szBuffer), szPromptTemplate, pwzDetails);
    StrCatBuff(szErrMessage, szBuffer, ARRAYSIZE(szErrMessage));

    return MessageBox(hwnd, szErrMessage, szTitle, (uiType | nMsgBoxType));
}


int DisplayWininetError(HWND hwnd, BOOL fAssertOnNULLHWND, DWORD dwError, UINT idTitleStr, UINT idBaseErrorStr, UINT idDetailsStr, UINT nMsgBoxType, IProgressDialog * ppd)
{
    if (hwnd)   // Only display if HWND exists.
        return DisplayWininetErrorEx(hwnd, fAssertOnNULLHWND, dwError, idTitleStr, idBaseErrorStr, idDetailsStr, nMsgBoxType, ppd, NULL);
    else
    {
        if (fAssertOnNULLHWND)
        {
//            ASSERT(hwnd);
        }

        TraceMsg(TF_ALWAYS, "DisplayWininetError() no HWND so no Error.");
    }

    return IDCANCEL;
}

#define CCH_SIZE_ERROR_MESSAGE  6*1024
HRESULT XboxSafeCreateDirectory(HWND hwnd, HINTERNET hint, CMultiLanguageCache * pmlc, CXboxFolder * pff, CXboxDir * pfd, IProgressDialog * ppd, LPCWSTR pwzXboxPath, BOOL fRoot)
{
    XBOX_FIND_DATA wfd;
    HRESULT hr = S_OK;
    WIRECHAR wXboxPath[MAX_PATH];
    CWireEncoding * pwe = pfd->GetXboxSite()->GetCWireEncoding();
    
    if (SUCCEEDED(pwe->UnicodeToWireBytes(NULL, pwzXboxPath, (pfd->IsUTF8Supported() ? WIREENC_USE_UTF8 : WIREENC_NONE), wXboxPath, ARRAYSIZE(wXboxPath))))
    {
        hr = XboxCreateDirectoryWrap(hint, TRUE, wXboxPath);

        // PERF NOTE: It is faster to just try to create the directory and then ignore
        //       error return values that indicate that they failed to create because it
        //       already exists.  The problem I worry about is that there is some XBOX server
        //       impl somewhere that will return the same error as failed to create because
        //       of access violation and we don't or can't return an error value.
        if (FAILED(hr)
// BUGBUG: IE #30208: Currently broken in wininet.        
//         I want to test the attribute flags but for some reason the FILE_ATTRIBUTE_DIRECTORY bit
//         is also set for files!!!! (!@(*#!!!)
//          || !(FILE_ATTRIBUTE_DIRECTORY & wfd.dwFileAttributes)
                )
        {
            // Maybe if failed because it already exists, which is fine by me.

            // First save off the error msg in case we need it for the err dlg later.
            CHAR szErrorMsg[CCH_SIZE_ERROR_MESSAGE];
            WCHAR wzErrorMsg[CCH_SIZE_ERROR_MESSAGE];
            DWORD cchSize = ARRAYSIZE(szErrorMsg);
            InternetGetLastResponseInfoWrap(TRUE, NULL, szErrorMsg, &cchSize);
            HRESULT hrOrig = hr;

            pwe->WireBytesToUnicode(NULL, szErrorMsg, WIREENC_NONE, wzErrorMsg, ARRAYSIZE(wzErrorMsg));
            // Does it already exist?
            hr = XboxDoesFileExist(hint, TRUE, wXboxPath, &wfd, (INTERNET_NO_CALLBACK | INTERNET_FLAG_DONT_CACHE | INTERNET_FLAG_RESYNCHRONIZE | INTERNET_FLAG_RELOAD));

            // It's okay if we failed to create the directory because a -DIRECTORY- already exists
            // because we'll just use that directory.  However, it a file with that name exists, 
            // then we need the err msg.
            if ((S_OK != hr) || !(FILE_ATTRIBUTE_DIRECTORY & wfd.dwFileAttributes))
            {
                // No, so it was a real error, now display the error message with the original
                // server response.
                DisplayWininetErrorEx(hwnd, TRUE, HRESULT_CODE(hrOrig), IDS_XBOXERR_TITLE_ERROR, IDS_XBOXERR_DIRCOPY, IDS_XBOXERR_WININET, MB_OK, ppd, wzErrorMsg);
                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
            }
        }

        // Was it created successfully?
        if (SUCCEEDED(hr))
        {
            // Yes, so fire the change notify.
            LPITEMIDLIST pidlNewDir;
            FILETIME ftUTC;
            XBOX_FIND_DATA wfd;

            GetSystemTimeAsFileTime(&ftUTC);   // UTC
            FileTimeToLocalFileTime(&ftUTC, &wfd.ftCreationTime);   // Need Local Time because XBOX is stupid and won't work in the cross time zones case.

            // For some reason, XboxFindFirstFile needs an '*' behind the name.
            StrCpyNA(wfd.cFileName, wXboxPath, ARRAYSIZE(wfd.cFileName));
            wfd.dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;
            wfd.ftLastWriteTime = wfd.ftCreationTime;
            wfd.ftLastAccessTime = wfd.ftCreationTime;
            wfd.nFileSizeLow = 0;
            wfd.nFileSizeHigh = 0;
            wfd.dwReserved0 = 0;
            wfd.dwReserved1 = 0;
            wfd.cAlternateFileName[0] = 0;

            hr = XboxItemID_CreateReal(&wfd, pwzXboxPath, &pidlNewDir);
            if (SUCCEEDED(hr))   // May happen on weird character set problems.
            {
                // Notify the folder of the new item so the Shell Folder updates.
                // PERF: Note that we should give SHChangeNotify() the information (time/date)
                //       from the local file system which may be different than on the server.
                //       But I don't think it's worth the perf to hit the server for the info.
                XboxChangeNotify(hwnd, SHCNE_MKDIR, pff, pfd, pidlNewDir, NULL, fRoot);
                ILFree(pidlNewDir);
            }
        }

    }

    return hr;
}


HWND GetProgressHWnd(IProgressDialog * ppd, HWND hwndDefault)
{
    if (ppd)
    {
        HWND hwndProgress = NULL;

        IUnknown_GetWindow(ppd, &hwndProgress);
        if (hwndProgress)
            hwndDefault = hwndProgress;
    }

    return hwndDefault;
}


// Returns FALSE if out of memory
int SHMessageBox(HWND hwnd, LPCTSTR pszMessage, UINT uMessageID, UINT uTitleID, UINT uType)
{
    int nResult = IDCANCEL;
    TCHAR szMessage[MAX_PATH];
    TCHAR szTitle[MAX_PATH];

    if (LoadString(HINST_THISDLL, uTitleID, szTitle, ARRAYSIZE(szTitle)) &&
        (pszMessage || 
         (uMessageID && LoadString(HINST_THISDLL, uMessageID, szMessage, ARRAYSIZE(szMessage)))))
    {
        nResult = MessageBox(hwnd, pszMessage ? pszMessage : szMessage, szTitle, uType);
    }

    return nResult;
}


DWORD GetOSVer(void)
{
    OSVERSIONINFOA osVerInfoA;

    osVerInfoA.dwOSVersionInfoSize = sizeof(osVerInfoA);
    if (!GetVersionExA(&osVerInfoA))
        return VER_PLATFORM_WIN32_WINDOWS;   // Default to this.
    
    return osVerInfoA.dwPlatformId;
}


LPITEMIDLIST SHILCreateFromPathWrapper(LPCTSTR pszPath)
{
    LPITEMIDLIST pidl;

    if (VER_PLATFORM_WIN32_NT == GetOSVer())
    {
        WCHAR wzPath[MAX_PATH];

        SHTCharToUnicode(pszPath, wzPath, ARRAYSIZE(wzPath));
        SHILCreateFromPath((LPCTSTR)wzPath, &pidl, NULL);
    }
    else
    {
        CHAR szPath[MAX_PATH];

        SHTCharToAnsi(pszPath, szPath, ARRAYSIZE(szPath));
        SHILCreateFromPath((LPCTSTR)szPath, &pidl, NULL);
    }

    return pidl;
}


LPCITEMIDLIST ILGetLastID(LPCITEMIDLIST pidlIn)
{
    LPITEMIDLIST pidl = (LPITEMIDLIST) pidlIn;

    while (!ILIsEmpty(_ILNext(pidl)))
        pidl = _ILNext(pidl);

    return pidl;
}


LPCITEMIDLIST ILGetLastNonFragID(LPCITEMIDLIST pidlIn)
{
    LPITEMIDLIST pidl = (LPITEMIDLIST) pidlIn;

    while (!ILIsEmpty(_ILNext(pidl)) && !XboxItemID_IsFragment(_ILNext(pidl)))
        pidl = _ILNext(pidl);

    return pidl;
}



SAFEARRAY * MakeSafeArrayFromData(LPCBYTE pData,DWORD cbData)
{
    SAFEARRAY * psa;

    if (!pData || 0 == cbData)
        return NULL;  // nothing to do

    // create a one-dimensional safe array
    psa = SafeArrayCreateVector(VT_UI1,0,cbData);
    ASSERT(psa);

    if (psa) {
        // copy data into the area in safe array reserved for data
        // Note we party directly on the pointer instead of using locking/
        // unlocking functions.  Since we just created this and no one
        // else could possibly know about it or be using it, this is OK.

        ASSERT(psa->pvData);
        memcpy(psa->pvData,pData,cbData);
    }

    return psa;
}


//
// PARAMETER:
//    pvar - Allocated by caller and filled in by this function.
//    pidl - Allocated by caller and caller needs to free.
//
// This function will take the PIDL parameter and COPY it
// into the Variant data structure.  This allows the pidl
// to be freed and the pvar to be used later, however, it
// is necessary to call VariantClear(pvar) to free memory
// that this function allocates.

BOOL InitVariantFromIDList(VARIANT* pvar, LPCITEMIDLIST pidl)
{
    UINT cb = ILGetSize(pidl);
    SAFEARRAY* psa = MakeSafeArrayFromData((LPCBYTE)pidl, cb);
    if (psa) {
        ASSERT(psa->cDims == 1);
        // ASSERT(psa->cbElements == cb);
        ASSERT(ILGetSize((LPCITEMIDLIST)psa->pvData)==cb);
        VariantInit(pvar);
        pvar->vt = VT_ARRAY|VT_UI1;
        pvar->parray = psa;
        return TRUE;
    }

    return FALSE;
}



BSTR BStrFromStr(LPCTSTR pszStr)
{
    BSTR bStr = NULL;

#ifdef UNICODE
    bStr = SysAllocString(pszStr);

#else // UNICODE
    DWORD cchSize = (lstrlen(pszStr) + 2);
    bStr = SysAllocStringLen(NULL, cchSize);
    if (EVAL(bStr))
        SHAnsiToUnicode(pszStr, bStr, cchSize);

#endif // UNICODE

    return bStr;
}


HRESULT IUnknown_IWebBrowserNavigate2(IUnknown * punk, LPCITEMIDLIST pidl, BOOL fHistoryEntry)
{
    HRESULT hr = E_FAIL;
    IWebBrowser2 * pwb2;

    // punk will be NULL on Browser Only installs because the old
    // shell32 doesn't do ::SetSite().
    IUnknown_QueryService(punk, SID_SWebBrowserApp, IID_IWebBrowser2, (LPVOID *) &pwb2);
    if (pwb2)
    {
        VARIANT varThePidl;

        if (InitVariantFromIDList(&varThePidl, pidl))
        {
            VARIANT varFlags;
            VARIANT * pvarFlags = PVAREMPTY;

            if (!fHistoryEntry)
            {
                varFlags.vt = VT_I4;
                varFlags.lVal = navNoHistory;
                pvarFlags = &varFlags;
            }

            hr = pwb2->Navigate2(&varThePidl, pvarFlags, PVAREMPTY, PVAREMPTY, PVAREMPTY);
            VariantClear(&varThePidl);
        }
        pwb2->Release();
    }
    else
    {
        IShellBrowser * psb;

        // Maybe we are in comdlg32.
        hr = IUnknown_QueryService(punk, SID_SCommDlgBrowser, IID_IShellBrowser, (LPVOID *) &psb);
        if (SUCCEEDED(hr))
        {
            CXboxView * pfv = GetCXboxViewFromDefViewSite(punk);

            AssertMsg((NULL != pfv), TEXT("IUnknown_IWebBrowserNavigate2() defview gave us our IShellFolderViewCB so it needs to support this interface."));
            if (pfv)
            {
                // Are we on the forground thread?
                if (pfv->IsForegroundThread())
                {
                    // Yes, so this will be easy.  This is the case
                    // where "Login As..." was chosen from the background context menu item.
                    hr = psb->BrowseObject(pidl, 0);
                }
                else
                {
                    // No, so this is the case where we failed to login with the original
                    // UserName/Password and we will try again with the corrected Username/Password.

                    // Okay, we are talking to the ComDlg code but we don't want to use
                    // IShellBrowse::BrowseObject() because we are on a background thread. (NT #297732)
                    // Therefore, we want to have the IShellFolderViewCB (CXboxView) cause
                    // the redirect on the forground thread.  Let's inform
                    // CXboxView now to do this.
                    hr = pfv->SetRedirectPidl(pidl);
                }

                pfv->Release();
            }
            
            AssertMsg(SUCCEEDED(hr), TEXT("IUnknown_IWebBrowserNavigate2() defview needs to support QS(SID_ShellFolderViewCB) on all platforms that hit this point"));
            psb->Release();
        }
    }

    return hr;
}


HRESULT IUnknown_PidlNavigate(IUnknown * punk, LPCITEMIDLIST pidl, BOOL fHistoryEntry)
{
    HRESULT hrOle = SHCoInitialize();
    HRESULT hr = IUnknown_IWebBrowserNavigate2(punk, pidl, fHistoryEntry);

    // Try a pre-NT5 work around.
    // punk will be NULL on Browser Only installs because the old
    // shell32 doesn't do ::SetSite().
    if (FAILED(hr))
    {
        IWebBrowserApp * pauto = NULL;
        
        hr = SHGetIDispatchForFolder(pidl, &pauto);
        if (EVAL(pauto))
        {
            hr = IUnknown_IWebBrowserNavigate2(pauto, pidl, fHistoryEntry);
            ASSERT(SUCCEEDED(hr));
            pauto->Release();
        }
    }

    ASSERT(SUCCEEDED(hrOle));
    SHCoUninitialize(hrOle);
    return hr;
}


/*****************************************************************************\

    HIDACREATEINFO

    Structure that collects all information needed when building
    an ID List Array.

\*****************************************************************************/

typedef struct tagHIDACREATEINFO
{
    HIDA hida;            /* The HIDA being built */
    UINT ipidl;            /* Who we are */
    UINT ib;            /* Where we are */
    UINT cb;            /* Where we're going */
    UINT cpidl;            /* How many we're doing */
    LPCITEMIDLIST pidlFolder;        /* The parent all these LPITEMIDLISTs live in */
    CXboxPidlList * pflHfpl;            /* The pidl list holding all the kids */
} HIDACREATEINFO, * LPHIDACREATEINFO;

#define pidaPhci(phci) ((LPIDA)(phci)->hida)    /* no need to lock */


/*****************************************************************************\
    Misc_SfgaoFromFileAttributes

    AIGH!

    UNIX and Win32 semantics on file permissions are different.

    On UNIX, the ability to rename or delete a file depends on
    your permissions on the parent folder.

    On Win32, the ability to rename or delete a file depends on
    your permissions on the file itself.

    Note that there is no such thing as "deny-read" attributes
    on Win32...  I wonder how WinINet handles that...

    I'm going to hope that WinINet does the proper handling of this,
    so I'll just proceed with Win32 semantics... I'm probably assuming too much...
\*****************************************************************************/
DWORD Misc_SfgaoFromFileAttributes(DWORD dwFAFLFlags)
{
    DWORD sfgao = SFGAO_CANLINK;    // You can always link

    sfgao |= SFGAO_HASPROPSHEET;    // You can always view properties

    sfgao |= SFGAO_CANCOPY;        // Deny-read?  No such thing! (Yet)

    if (dwFAFLFlags & FILE_ATTRIBUTE_READONLY)
    {        /* Can't delete it, sorry */
#ifdef _SOMEDAY_ASK_FRANCISH_WHAT_THIS_IS
        if (SHELL_VERSION_NT5 == GetShellVersion())
            sfgao |= SFGAO_READONLY;
#endif
    }
    else
    {
        sfgao |= (SFGAO_CANRENAME | SFGAO_CANDELETE);
#ifdef FEATURE_CUT_MOVE
        sfgao |= SFGAO_CANMOVE;
#endif // FEATURE_CUT_MOVE
    }

    if (dwFAFLFlags & FILE_ATTRIBUTE_DIRECTORY)
    {
        //Since XBOX connections are expensive, assume SFGAO_HASSUBFOLDER
        sfgao |= SFGAO_DROPTARGET | SFGAO_FOLDER | SFGAO_HASSUBFOLDER;
    }
    else
    {
        // We always return the
        // SFGAO_BROWSABLE because we always want to do the navigation
        // using our IShellFolder::CreateViewObject().  In the case of
        // files, the CreateViewObject() that we create is for URLMON
        // which will do the download.  This is especially true for
        // Folder Shortcuts.
        sfgao |= SFGAO_BROWSABLE;
    }

    return sfgao;
}

/*****************************************************************************\
    FUNCTION: Misc_StringFromFileTime

    DESCRIPTION:
        Get the date followed by the time.  flType can be DATE_SHORTDATE
    (for defview's details list) or DATE_LONGDATE for the property sheet.
\*****************************************************************************/
HRESULT Misc_StringFromFileTime(LPTSTR pszDateTime, DWORD cchSize, LPFILETIME pft, DWORD flType)
{
    if (EVAL(pft && pft->dwHighDateTime))
    {
        SHFormatDateTime(pft, &flType, pszDateTime, cchSize);
    }
    else
        pszDateTime[0] = 0;

    return S_OK;
}


LPITEMIDLIST GetPidlFromXboxFolderAndPidlList(CXboxFolder * pff, CXboxPidlList * pflHfpl)
{
    LPCITEMIDLIST pidlBase = pff->GetPrivatePidlReference();
    LPCITEMIDLIST pidlRelative = ((0 == pflHfpl->GetCount()) ? c_pidlNil : pflHfpl->GetPidl(0));

    return ILCombine(pidlBase, pidlRelative);
}


IProgressDialog * CProgressDialog_CreateInstance(UINT idTitle, UINT idAnimation)
{
    IProgressDialog * ppd = NULL;
    
    if (EVAL(SUCCEEDED(CoCreateInstance(CLSID_ProgressDialog, NULL, CLSCTX_INPROC_SERVER, IID_IProgressDialog, (void **)&ppd))))
    {
        WCHAR wzTitle[MAX_PATH];

        if (EVAL(LoadStringW(HINST_THISDLL, idTitle, wzTitle, ARRAYSIZE(wzTitle))))
            EVAL(SUCCEEDED(ppd->SetTitle(wzTitle)));

        EVAL(SUCCEEDED(ppd->SetAnimation(HINST_THISDLL, idAnimation)));
    }

    return ppd;
}


BOOL_PTR CALLBACK ProxyDlgWarningWndProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (uMsg == WM_INITDIALOG)
    {
        LPCTSTR pszUrl = (LPCTSTR)lParam;
        TCHAR szMessage[MAX_PATH*3];
        TCHAR szTemplate[MAX_PATH*3];

        ASSERT(pszUrl);

        EVAL(LoadString(HINST_THISDLL, IDS_XBOX_PROXY_WARNING, szTemplate, ARRAYSIZE(szTemplate)));
        wnsprintf(szMessage, ARRAYSIZE(szMessage), szTemplate, pszUrl);
        EVAL(SetWindowText(GetDlgItem(hDlg, IDC_PROXY_MESSAGE), szMessage));
    }

    return FALSE;
}


/*****************************************************************************\
    FUNCTION:   DisplayBlockingProxyDialog

    DESCRIPTION:
        Inform user that their CERN style proxy is blocking real XBOX access so
    they can do something about it.

    Inform the user so they can: 
    A) Change proxies,
    B) Annoy their administrator to install real proxies,
    C) Install Remote WinSock themselves,
    D) or settle for their sorry situation in life and use the
       limited CERN proxy support and dream about the abilitity
       to rename, delete, and upload.

    This will be a no-op if the user clicks "Don't display this
    message again" check box.
\*****************************************************************************/
HRESULT DisplayBlockingProxyDialog(LPCITEMIDLIST pidl, HWND hwnd)
{
    // Did the IBindCtx provide information to allow us to do UI?
    if (hwnd)
    {
        TCHAR szUrl[MAX_PATH];

        UrlCreateFromPidl(pidl, SHGDN_FORPARSING, szUrl, ARRAYSIZE(szUrl), 0, TRUE);

        // Make it modal while the dialog is being displayed.
//        IUnknown_EnableModless(punkSite, FALSE);
        SHMessageBoxCheckEx(hwnd, HINST_THISDLL, MAKEINTRESOURCE(IDD_PROXYDIALOG), ProxyDlgWarningWndProc, (LPVOID) szUrl, IDOK, SZ_REGVALUE_WARN_ABOUT_PROXY);
//        IUnknown_EnableModless(punkSite, TRUE);
    }

    return S_OK;
}


HRESULT CreateFromToStr(LPWSTR pwzStrOut, DWORD cchSize, ...)
{
    CHAR szStatusText[MAX_PATH];
    CHAR szTemplate[MAX_PATH];
    va_list vaParamList;
    
    va_start(vaParamList, cchSize);
    // Generate the string "From <SrcXboxUrlDir> to <DestFileDir>" status string
    EVAL(LoadStringA(HINST_THISDLL, IDS_DL_SRC_DEST, szTemplate, ARRAYSIZE(szTemplate)));
    if (EVAL(FormatMessageA(FORMAT_MESSAGE_FROM_STRING, szTemplate, 0, 0, szStatusText, ARRAYSIZE(szStatusText), &vaParamList)))
        SHAnsiToUnicode(szStatusText, pwzStrOut, cchSize);

    va_end(vaParamList);
    return S_OK;
}

/****************************************************\
    FUNCTION: XboxProgressInternetStatusCB

    DESCRIPTION: 
        This function is exists to be called back during
    long XBOX operations so we can update the progress
    dialog during XboxPutFile or XboxGetFile.

    A pointer to our PROGRESSINFO struct is passed in
    dwContext.
\****************************************************/
void XboxProgressInternetStatusCB(IN HINTERNET hInternet, IN DWORD_PTR pdwContext, IN DWORD dwInternetStatus, IN LPVOID lpwStatusInfo, IN DWORD dwStatusInfoLen)
{
    LPPROGRESSINFO pProgInfo = (LPPROGRESSINFO) pdwContext;
    if (EVAL(pProgInfo))
    {
        switch (dwInternetStatus)
        {
        case INTERNET_STATUS_RESPONSE_RECEIVED:
        case INTERNET_STATUS_REQUEST_SENT:
            if (EVAL(lpwStatusInfo && (sizeof(DWORD) == dwStatusInfoLen)
                && pProgInfo))
            {
                if (pProgInfo->hint && pProgInfo->ppd->HasUserCancelled())
                {
                    EVAL(InternetCloseHandle(pProgInfo->hint));
                    pProgInfo->hint = NULL;
                }

                pProgInfo->dwCompletedInCurFile += *(LPDWORD)lpwStatusInfo;

                // Has a big enough chunck of the file completed that we need
                // to update the progress?  We only want to update the progress
                // every SIZE_PROGRESS_AFTERBYTES (50k) chunck.
                if (pProgInfo->dwLastDisplayed < (pProgInfo->dwCompletedInCurFile / SIZE_PROGRESS_AFTERBYTES))
                {
                    ULARGE_INTEGER uliBytesCompleted;

                    pProgInfo->dwLastDisplayed = (pProgInfo->dwCompletedInCurFile / SIZE_PROGRESS_AFTERBYTES);

                    uliBytesCompleted.HighPart = 0;
                    uliBytesCompleted.LowPart = pProgInfo->dwCompletedInCurFile;
                    uliBytesCompleted.QuadPart += pProgInfo->uliBytesCompleted.QuadPart;

                    if (pProgInfo->ppd)
                        EVAL(SUCCEEDED(pProgInfo->ppd->SetProgress64(uliBytesCompleted.QuadPart, pProgInfo->uliBytesTotal.QuadPart)));
                }
            }
            break;
        }
    }
}


/*****************************************************************************\
    Misc_CreateHglob

    Allocate an hglobal of the indicated size, initialized from the
    specified buffer.
\*****************************************************************************/
HRESULT Misc_CreateHglob(SIZE_T cb, LPVOID pv, HGLOBAL *phglob)
{
    HRESULT hres = E_OUTOFMEMORY;

    *phglob = 0;            // Rules are rules
    if (cb)
    {
        *phglob = (HGLOBAL) LocalAlloc(LPTR, cb);
        if (phglob)
        {
            hres = S_OK;
            CopyMemory(*phglob, pv, cb);
        }
    }
    else
        hres = E_INVALIDARG;    // Can't clone a discardable block

    return hres;
}


/*****************************************************************************\
    _HIDA_Create_Tally

    Worker function for HIDA_Create which tallies up the total size.
\*****************************************************************************/
int _HIDA_Create_Tally(LPVOID pvPidl, LPVOID pv)
{
    LPCITEMIDLIST pidl = (LPCITEMIDLIST) pvPidl;
    UINT *pcb = (UINT *) pv;
    int nContinue = (pv ? TRUE : FALSE);

    *pcb += ILGetSize(pidl);
    return nContinue;
}


/*****************************************************************************\
    _HIDA_Create_AddIdl

    Worker function for HIDA_Create which appends another ID List
    to the growing HIDA.
\*****************************************************************************/
int _HIDA_Create_AddIdl(LPVOID pvPidl, LPVOID pv)
{
    LPCITEMIDLIST pidl = (LPCITEMIDLIST) pvPidl;
    LPHIDACREATEINFO phci = (LPHIDACREATEINFO) pv;
    UINT cb = ILGetSize(pidl);

    pidaPhci(phci)->aoffset[phci->ipidl++] = phci->ib;
    CopyMemory(pvByteIndexCb(pidaPhci(phci), phci->ib), pidl, cb);
    phci->ib += cb;

    return phci ? TRUE : FALSE;
}


/*****************************************************************************\
    _Misc_HIDA_Init

    Once we've allocated the memory for a HIDA, fill it with stuff.
\*****************************************************************************/
BOOL _Misc_HIDA_Init(LPVOID hida, LPVOID pv, LPCVOID pvParam2, BOOL fUnicode)
{
    LPHIDACREATEINFO phci = (LPHIDACREATEINFO) pv;

    phci->hida = hida;
    pidaPhci(phci)->cidl = phci->cpidl;
    phci->ipidl = 0;

    phci->pflHfpl->TraceDump(_ILNext(phci->pidlFolder), TEXT("_Misc_HIDA_Init() TraceDump Before"));

    _HIDA_Create_AddIdl((LPVOID) phci->pidlFolder, (LPVOID) phci);
    phci->pflHfpl->Enum(_HIDA_Create_AddIdl, (LPVOID) phci);

    phci->pflHfpl->TraceDump(_ILNext(phci->pidlFolder), TEXT("_Misc_HIDA_Init() TraceDump After"));

    return 1;
}


/*****************************************************************************\
    HIDA_Create

    Swiped from idlist.c in the shell because they didn't    ;Internal
    export it.                        ;Internal
\*****************************************************************************/
HIDA Misc_HIDA_Create(LPCITEMIDLIST pidlFolder, CXboxPidlList * pflHfpl)
{
    HIDACREATEINFO hci;
    LPHIDACREATEINFO phci = &hci;
    HIDA hida;

    pflHfpl->TraceDump(_ILNext(pidlFolder), TEXT("Misc_HIDA_Create() TraceDump Before"));
    phci->pidlFolder = pidlFolder;
    phci->pflHfpl = pflHfpl;
    phci->cpidl = pflHfpl->GetCount();
    phci->ib = sizeof(CIDA) + sizeof(UINT) * phci->cpidl;
    phci->cb = phci->ib + ILGetSize(pidlFolder);

    pflHfpl->Enum(_HIDA_Create_Tally, (LPVOID) &phci->cb);

    hida = AllocHGlob(phci->cb, _Misc_HIDA_Init, phci, NULL, FALSE);
    pflHfpl->TraceDump(_ILNext(pidlFolder), TEXT("Misc_HIDA_Create() TraceDump Before"));

    return hida;
}


typedef struct tagURL_FILEGROUP
{
    LPFILEGROUPDESCRIPTORA   pfgdA;
    LPFILEGROUPDESCRIPTORW   pfgdW;
    LPCITEMIDLIST            pidlParent;
} URL_FILEGROUP;

/*****************************************************************************\
    Misc_HFGD_Create

    Build a file group descriptor based on an pflHfpl.

    CXboxObj::_DelayRender_FGD() did the recursive walk to expand the list 
    of pidls, so we don't have to.
\*****************************************************************************/
#define cbFgdCfdW(cfd) FIELD_OFFSET(FILEGROUPDESCRIPTORW, fgd[cfd])
#define cbFgdCfdA(cfd) FIELD_OFFSET(FILEGROUPDESCRIPTORA, fgd[cfd])

int _Misc_HFGD_Create(LPVOID pvPidl, LPVOID pv)
{
    BOOL fSucceeded = TRUE;
    URL_FILEGROUP * pUrlFileGroup = (URL_FILEGROUP *) pv;
    LPCITEMIDLIST pidlFull = (LPCITEMIDLIST) pvPidl;
    LPCITEMIDLIST pidl;

    LPFILEGROUPDESCRIPTORA pfgdA = pUrlFileGroup->pfgdA;
    LPFILEGROUPDESCRIPTORW pfgdW = pUrlFileGroup->pfgdW;
    LPFILEDESCRIPTORA pfdA = (pfgdA ? &pfgdA->fgd[pfgdA->cItems++] : NULL);
    LPFILEDESCRIPTORW pfdW = (pfgdW ? &pfgdW->fgd[pfgdW->cItems++] : NULL);

    pidl = ILGetLastID(pidlFull);
    if (pfdA)
    {
#if !DEBUG_LEGACY_PROGRESS
        pfdA->dwFlags = (FD_ATTRIBUTES | FD_FILESIZE | FD_CREATETIME | FD_ACCESSTIME | FD_WRITESTIME | FD_PROGRESSUI);
#else // !DEBUG_LEGACY_PROGRESS
        pfdA->dwFlags = (FD_ATTRIBUTES | FD_FILESIZE | FD_CREATETIME | FD_ACCESSTIME | FD_WRITESTIME);
#endif // !DEBUG_LEGACY_PROGRESS
        pfdA->dwFileAttributes = XboxItemID_GetAttributes(pidl);
        pfdA->nFileSizeLow = XboxItemID_GetFileSizeLo(pidl);
        pfdA->nFileSizeHigh = XboxItemID_GetFileSizeHi(pidl);

        // This sucks but all WIN32_FIND_DATA want to be stored in TimeZone independent
        // ways, except for WININET's XBOX.  Also note that we only store Modified
        // time and use if for everything because of another UNIX/Wininet issue.
        // See priv.h on more XBOX Time/Date issues.
        pfdA->ftCreationTime = XboxPidl_GetFileTime(ILFindLastID(pidl));
        pfdA->ftLastWriteTime = pfdA->ftCreationTime;
        pfdA->ftLastAccessTime = pfdA->ftCreationTime;
    }
    else
    {
#if !DEBUG_LEGACY_PROGRESS
        pfdW->dwFlags = (FD_ATTRIBUTES | FD_FILESIZE | FD_CREATETIME | FD_ACCESSTIME | FD_WRITESTIME | FD_PROGRESSUI);
#else // !DEBUG_LEGACY_PROGRESS
        pfdW->dwFlags = (FD_ATTRIBUTES | FD_FILESIZE | FD_CREATETIME | FD_ACCESSTIME | FD_WRITESTIME);
#endif // !DEBUG_LEGACY_PROGRESS
        pfdW->dwFileAttributes = XboxItemID_GetAttributes(pidl);
        pfdW->nFileSizeLow = XboxItemID_GetFileSizeLo(pidl);
        pfdW->nFileSizeHigh = XboxItemID_GetFileSizeHi(pidl);

        // This sucks but all WIN32_FIND_DATA want to be stored in TimeZone independent
        // ways, except for WININET's XBOX.  Also note that we only store Modified
        // time and use if for everything because of another UNIX/Wininet issue.
        // See priv.h on more XBOX Time/Date issues.
        pfdW->ftCreationTime = XboxPidl_GetFileTime(ILFindLastID(pidl));
        pfdW->ftLastWriteTime = pfdW->ftCreationTime;
        pfdW->ftLastAccessTime = pfdW->ftCreationTime;
    }

    LPCITEMIDLIST pidlDiff = XboxItemID_FindDifference(pUrlFileGroup->pidlParent, pidlFull);

    if (pfdA)
    {
        GetWirePathFromPidl(pidlDiff, pfdA->cFileName, ARRAYSIZE(pfdA->cFileName), FALSE);
        UrlPathRemoveSlashA(pfdA->cFileName);
        UrlPathRemoveFrontSlashA(pfdA->cFileName);
        UrlPathToFilePathA(pfdA->cFileName);
    }
    else
    {
        GetDisplayPathFromPidl(pidlDiff, pfdW->cFileName, ARRAYSIZE(pfdW->cFileName), FALSE);
        UrlPathRemoveSlashW(pfdW->cFileName);
        UrlPathRemoveFrontSlashW(pfdW->cFileName);
        UrlPathToFilePathW(pfdW->cFileName);
    }

    TraceMsg(TF_XBOXURL_UTILS, "_Misc_HFGD_Create() pfd(A/W)->dwFileAttributes=%#08lX", (pfdW ? pfdW->dwFileAttributes : pfdA->dwFileAttributes));

    return fSucceeded;
}


BOOL _Misc_HFGD_Init(LPVOID pv, LPVOID pvHFPL, LPCVOID pvParam2, BOOL fUnicode)
{
    CXboxPidlList * pflHfpl = (CXboxPidlList *) pvHFPL;
    URL_FILEGROUP urlFG = {0};

    urlFG.pidlParent = (LPCITEMIDLIST) pvParam2;
    if (fUnicode)
        urlFG.pfgdW = (LPFILEGROUPDESCRIPTORW) pv;
    else
        urlFG.pfgdA = (LPFILEGROUPDESCRIPTORA) pv;

    TraceMsg(TF_PIDLLIST_DUMP, "_Misc_HFGD_Init() TraceDump Before");
    pflHfpl->TraceDump(NULL, TEXT("_Misc_HFGD_Init() TraceDump before"));

    pflHfpl->Enum(_Misc_HFGD_Create, (LPVOID) &urlFG);

    pflHfpl->TraceDump(NULL, TEXT("_Misc_HFGD_Init() TraceDump after"));

    return 1;
}


HGLOBAL Misc_HFGD_Create(CXboxPidlList * pflHfpl, LPCITEMIDLIST pidlItem, BOOL fUnicode)
{
    DWORD dwCount = pflHfpl->GetCount();
    DWORD cbAllocSize = (fUnicode ? cbFgdCfdW(dwCount) : cbFgdCfdA(dwCount));

    return AllocHGlob(cbAllocSize, _Misc_HFGD_Init, pflHfpl, (LPCVOID) pidlItem, fUnicode);
}


// Returns the submenu of the given menu and ID.  Returns NULL if there
// is no submenu
int _MergePopupMenus(HMENU hmDest, HMENU hmSource, int idCmdFirst, int idCmdLast)
{
    int i, idFinal = idCmdFirst;

    for (i = GetMenuItemCount(hmSource) - 1; i >= 0; --i)
    {
        MENUITEMINFO mii;

        mii.cbSize = SIZEOF(mii);
        mii.fMask = MIIM_ID|MIIM_SUBMENU;
        mii.cch = 0;     // just in case

        if (EVAL(GetMenuItemInfo(hmSource, i, TRUE, &mii)))
        {
            HMENU hmDestSub = GetMenuFromID(hmDest, mii.wID);
            if (hmDestSub)
            {
                int idTemp = Shell_MergeMenus(hmDestSub, mii.hSubMenu, (UINT)0, idCmdFirst, idCmdLast, MM_ADDSEPARATOR | MM_SUBMENUSHAVEIDS);

                if (idFinal < idTemp)
                    idFinal = idTemp;
            }
        }
    }

    return idFinal;
}


/*****************************************************************************\
    FUNCTION: AddToPopupMenu

    DESCRIPTION:
      Swiped from utils.c in RNAUI, in turn swiped from the    ;Internal
      shell.                            ;Internal
                                  ;Internal
      Takes a destination menu and a (menu id, submenu index) pair,
      and inserts the items from the (menu id, submenu index) at location
      imi in the destination menu, with a separator, returning the number
      of items added.  (imi = index to menu item)
  
      Returns the first the number of items added.
  
      hmenuDst        - destination menu
      idMenuToAdd        - menu resource identifier
      idSubMenuIndex    - submenu from menu resource to act as template
      indexMenu        - location at which menu items should be inserted
      idCmdFirst        - first available menu identifier
      idCmdLast       - first unavailable menu identifier
      uFlags            - flags for Shell_MergeMenus
\*****************************************************************************/
#define FLAGS_MENUMERGE                 (MM_SUBMENUSHAVEIDS | MM_DONTREMOVESEPS)

UINT AddToPopupMenu(HMENU hmenuDst, UINT idMenuToAdd, UINT idSubMenuIndex, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    UINT nLastItem = 0;

    HMENU hmenuSrc = LoadMenu(g_hinst, MAKEINTRESOURCE(idMenuToAdd));
    if (hmenuSrc)
    {
        nLastItem = Shell_MergeMenus(hmenuDst, GetSubMenu(hmenuSrc, idSubMenuIndex), indexMenu, idCmdFirst, idCmdLast, (uFlags | FLAGS_MENUMERGE));
        DestroyMenu(hmenuSrc);
    }

    return nLastItem;
}


UINT MergeInToPopupMenu(HMENU hmenuDst, UINT idMenuToMerge, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    UINT nLastItem = 0;

    HMENU hmenuSrc = LoadMenu(g_hinst, MAKEINTRESOURCE(idMenuToMerge));
    if (hmenuSrc)
    {
        nLastItem = _MergePopupMenus(hmenuDst, hmenuSrc, idCmdFirst, idCmdLast);
        DestroyMenu(hmenuSrc);
    }

    return nLastItem;
}


/*****************************************************************************\

    GetMenuFromID

    Swiped from defviewx.c in the shell.            ;Internal
                                ;Internal
    Given an actual menu and a menu identifier which corresponds
    to a submenu, return the submenu handle.

    hmenu - source menu
    idm   - menu identifier

\*****************************************************************************/
HMENU GetMenuFromID(HMENU hmenu, UINT idm)
{
    HMENU hmenuRet = NULL;
    if (!hmenu)
        return NULL;

    MENUITEMINFO mii;
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_SUBMENU;
    mii.cch = 0;             // just in case
    mii.hSubMenu = 0;        // in case GetMenuItemInfo fails

    if (GetMenuItemInfo(hmenu, idm, 0, &mii))
        hmenuRet = mii.hSubMenu;

    return hmenuRet;
}


/*****************************************************************************\
    MergeMenuHierarchy

    Swiped from defcm.c in the shell.            ;Internal
                                ;Internal
    Given an actual menu (hmenuDst), iterate over its submenus
    and merge corresponding submenus whose IDs match the IDs of
    actuals.

    hmenuDst - menu being adjusted
    hmenuSrc - template menu
    idcMin     - first available index
    idcMax     - first unavailable index
\*****************************************************************************/
UINT MergeMenuHierarchy(HMENU hmenuDst, HMENU hmenuSrc, UINT idcMin, UINT idcMax)
{
    int imi;
    UINT idcMaxUsed = idcMin;

    imi = GetMenuItemCount(hmenuSrc);
    while (--imi >= 0)
    {
        UINT idcT;
        MENUITEMINFO mii;

        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_ID|MIIM_SUBMENU;
        mii.cch = 0;     /* just in case */

        if (GetMenuItemInfo(hmenuSrc, imi, 1, &mii))
        {
            idcT = Shell_MergeMenus(GetMenuFromID(hmenuDst, mii.wID),
                mii.hSubMenu, (UINT)0, idcMin, idcMax,
                MM_ADDSEPARATOR | MM_SUBMENUSHAVEIDS);
            idcMaxUsed = max(idcMaxUsed, idcT);
        }
    }

    return idcMaxUsed;
}


HRESULT _SetStatusBarZone(CStatusBar * psb, CXboxSite * pfs)
{
    if (EVAL(psb && pfs))
    {
        LPITEMIDLIST pidl = pfs->GetPidl();

        if (pidl)
        {
            TCHAR szUrl[MAX_URL_STRING];

            UrlCreateFromPidl(pidl, SHGDN_FORPARSING, szUrl, ARRAYSIZE(szUrl), 0, TRUE);
            psb->UpdateZonesPane(szUrl);
            ILFree(pidl);
        }
    }

    return S_OK;
}


/*****************************************************************************\

    Misc_CopyPidl

    I wrote this on my own, and discovered months later    ;Internal
    that this is the same as SHILClone...            ;Internal
                                ;Internal
\*****************************************************************************/
HRESULT Misc_CopyPidl(LPCITEMIDLIST pidl, LPITEMIDLIST * ppidlOut)
{
    *ppidlOut = ILClone(pidl);
    return *ppidlOut ? S_OK : E_OUTOFMEMORY;
}


/*****************************************************************************\

    Misc_CloneHglobal

\*****************************************************************************/
HRESULT Misc_CloneHglobal(HGLOBAL hglob, HGLOBAL *phglob)
{
    LPVOID pv;
    HRESULT hres;

    ASSERT(hglob);
    *phglob = 0;            /* Rules are rules */
    pv = GlobalLock(hglob);
    if (EVAL(pv))
    {
        hres = Misc_CreateHglob(GlobalSize(hglob), pv, phglob);
        GlobalUnlock(hglob);
    }
    else
    {                /* Not a valid global handle */
        hres = E_INVALIDARG;
    }
    return hres;
}


#define XBOX_PROPPAGES_FROM_INETCPL          (INET_PAGE_SECURITY | INET_PAGE_CONTENT | INET_PAGE_CONNECTION)

HRESULT AddXBOXPropertyPages(LPFNADDPROPSHEETPAGE pfnAddPropSheetPage, LPARAM lParam, HINSTANCE * phinstInetCpl, IUnknown * punkSite)
{
    HRESULT hr = E_FAIL;

    if (NULL == *phinstInetCpl)
        *phinstInetCpl = LoadLibrary(TEXT("inetcpl.cpl"));

    // First add the pages from the Internet Control Panel.
    if (EVAL(*phinstInetCpl))
    {
        PFNADDINTERNETPROPERTYSHEETSEX pfnAddSheet = (PFNADDINTERNETPROPERTYSHEETSEX)GetProcAddress(*phinstInetCpl, STR_ADDINTERNETPROPSHEETSEX);
        if (EVAL(pfnAddSheet))
        {
            IEPROPPAGEINFO iepi = {0};

            iepi.cbSize = sizeof(iepi);
            iepi.dwFlags = (DWORD)-1;       // all pages

            hr = pfnAddSheet(pfnAddPropSheetPage, lParam, 0, 0, &iepi);
        }
        // Don't FreeLibrary here, otherwise PropertyPage will GP-fault!
    }

    ASSERT(SUCCEEDED(hr));

    if (((LPPROPSHEETHEADER)lParam)->nPages > 0)
        return hr;
    else
        return S_FALSE;

}


#if 0
/*****************************************************************************\

    Misc_SetDataDword

\*****************************************************************************/
HRESULT Misc_SetDataDword(IDataObject *pdto, FORMATETC *pfe, DWORD dw)
{
    HRESULT hres;
    HGLOBAL hglob;

    hres = Misc_CreateHglob(sizeof(dw), &dw, &hglob);
    if (SUCCEEDED(hres))
    {
        STGMEDIUM stg = { TYMED_HGLOBAL, hglob, 0 };
        hres = pdto->SetData(&fe, &stg, 1);

        if (!(EVAL(SUCCEEDED(hres))))
            GlobalFree(hglob);
    }
    else
        hres = E_OUTOFMEMORY;

    return hres;
}
#endif


CXboxPidlList * CreateRelativePidlList(CXboxFolder * pff, CXboxPidlList * pPidlListFull)
{
    int nSize = pPidlListFull->GetCount();
    CXboxPidlList * pPidlListNew = NULL;

    if (nSize > 0)
    {
        LPCITEMIDLIST pidlFirst = pff->GetPrivatePidlReference();
        int nCount = 0;

        while (!ILIsEmpty(pidlFirst))
        {
            pidlFirst = _ILNext(pidlFirst);
            nCount++;
        }

        if (nSize > 0)
        {
            for (int nIndex = 0; nIndex < nSize; nIndex++)
            {
                int nLeft = nCount;
                LPITEMIDLIST pidl = pPidlListFull->GetPidl(nIndex);

                while (nLeft--)
                    pidl = _ILNext(pidl);

                AssertMsg((pidl ? TRUE : FALSE), TEXT("CreateRelativePidlList() pPidlListFull->GetPidl() should never fail because we got the size and no mem allocation is needed."));
                if (0 == nIndex)
                {
                    CXboxPidlList_Create(1, (LPCITEMIDLIST *)&pidl, &pPidlListNew);
                    if (!pPidlListNew)
                        break;
                }
                else
                {
                    // We only want to add top level nodes.
                    // xbox://s/d1/d2/         <- Root of copy.
                    // xbox://s/d1/d2/d3a/     <- First Top Level Item
                    // xbox://s/d1/d2/d3a/f1   <- Skip non-top level items
                    // xbox://s/d1/d2/d3b/     <- Second Top Level Item
                    if (pidl && !ILIsEmpty(pidl) && ILIsEmpty(_ILNext(pidl)))
                        pPidlListNew->InsertSorted(pidl);
                }
            }
        }
    }

    return pPidlListNew;
}


#define SZ_VERB_DELETEA             "delete"
/*****************************************************************************\
    FUNCTION: Misc_DeleteHfpl

    DESCRIPTION:
        Delete the objects described by a pflHfpl.
\*****************************************************************************/
HRESULT Misc_DeleteHfpl(CXboxFolder * pff, HWND hwnd, CXboxPidlList * pflHfpl)
{
    IContextMenu * pcm;
    HRESULT hr = pff->GetUIObjectOfHfpl(hwnd, pflHfpl, IID_IContextMenu, (LPVOID *)&pcm, FALSE);

    if (EVAL(SUCCEEDED(hr)))
    {
        CMINVOKECOMMANDINFO ici = {
            sizeof(ici),            // cbSize
            CMIC_MASK_FLAG_NO_UI,    // fMask
            hwnd,                    // hwnd
            SZ_VERB_DELETEA,        // lpVerb
            0,                        // lpParameters
            0,                        // lpDirectory
            0,                        // nShow
            0,                        // dwHotKey
            0,                        // hIcon
        };
        hr = pcm->InvokeCommand(&ici);
        pcm->Release();
    }
    else
    {
        // Couldn't delete source; oh well.  Don't need UI.
        // BUGBUG -- Actually, maybe we ought to do UI after all.
    }

    return hr;
}

/*****************************************************************************\

    Misc_FindStatusBar

    Get the status bar from a browser window.

    _UNDOCUMENTED_: The following quirks are not documented.

    Note that we need to be very paranoid about the way GetControlWindow
    works.  Some people (Desktop) properly return error if the window
    does not exist.  Others (Explorer) return S_OK when the window
    does not exist, but they kindly set *lphwndOut = 0.  Still others
    (Find File) return S_OK but leave *lphwndOut unchanged!

    In order to work with all these bozos, we must manually set hwnd = 0
    before calling, and continue only if GetControlWindow returns success
    *and* the outgoing hwnd is nonzero.

    Furthermore, the documentation for GetControlWindow says that we
    have to check the window class before trusting the hwnd.

\*****************************************************************************/

#pragma BEGIN_CONST_DATA

TCHAR c_tszStatusBarClass[] = STATUSCLASSNAME;

#pragma END_CONST_DATA

HWND Misc_FindStatusBar(HWND hwndOwner)
{
    HWND hwnd = 0;    // Must preinit in case GetControlWindow fails

    if (EVAL(hwndOwner))
    {
        IShellBrowser * psb = FileCabinet_GetIShellBrowser(hwndOwner);

        if (EVAL(psb))
        {
            if (SUCCEEDED(psb->GetControlWindow(FCW_STATUS, &hwnd)) && hwnd) // This won't work when hosted in an IFRAME
            {
                //  Make sure it really is a status bar...
                TCHAR tszClass[ARRAYSIZE(c_tszStatusBarClass)+1];

                if (GetClassName(hwnd, tszClass, ARRAYSIZE(tszClass)) &&
                    !StrCmpI(tszClass, c_tszStatusBarClass))
                {
                    // We have a winner
                }
                else
                    hwnd = 0;        // False positive
            }
        }
    }

    return hwnd;
}

#ifdef DEBUG
void TraceMsgWithCurrentDir(DWORD dwTFOperation, LPCSTR pszMessage, HINTERNET hint)
{
    // For debugging...
    TCHAR szCurrentDir[MAX_PATH];
    DWORD cchDebugSize = ARRAYSIZE(szCurrentDir);

    DEBUG_CODE(DebugStartWatch());
    // PERF: Status FtpGetCurrentDirectory/XboxSetCurrentDirectory() takes
    //  180-280ms on Ftp.microsoft.com on average.
    //  500-2000ms on xbox://Ftp.tu-clausthal.de/ on average
    //  0-10ms on xbox://shapitst/ on average
    EVAL(FtpGetCurrentDirectory(hint, szCurrentDir, &cchDebugSize));
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "TraceMsgWithCurrentDir() XboxGetCurrentDirectory() returned %ls and took %lu milliseconds", szCurrentDir, DebugStopWatch()));
    TraceMsg(dwTFOperation, pszMessage, szCurrentDir);
}


void DebugStartWatch(void)
{
    LARGE_INTEGER liStopWatchStart;
    
    liStopWatchStart.HighPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartHi));
    liStopWatchStart.LowPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartLo));

    ASSERT(!liStopWatchStart.QuadPart); // If you hit this, then the stopwatch is nested.
    QueryPerformanceFrequency(&g_liStopWatchFreq);
    QueryPerformanceCounter(&liStopWatchStart);

    TlsSetValue(g_TLSliStopWatchStartHi, (LPVOID) liStopWatchStart.HighPart);
    TlsSetValue(g_TLSliStopWatchStartLo, (LPVOID) liStopWatchStart.LowPart);
}

DWORD DebugStopWatch(void)
{
    LARGE_INTEGER liDiff;
    LARGE_INTEGER liStopWatchStart;
    
    QueryPerformanceCounter(&liDiff);
    liStopWatchStart.HighPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartHi));
    liStopWatchStart.LowPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartLo));
    liDiff.QuadPart -= liStopWatchStart.QuadPart;

    ASSERT(0 != g_liStopWatchFreq.QuadPart);    // I don't like to fault with div 0.
    DWORD dwTime = (DWORD)((liDiff.QuadPart * 1000) / g_liStopWatchFreq.QuadPart);
    
    TlsSetValue(g_TLSliStopWatchStartHi, (LPVOID) 0);
    TlsSetValue(g_TLSliStopWatchStartLo, (LPVOID) 0);

    return dwTime;
}
#endif // DEBUG


/*****************************************************************************\

    GetCfBuf

    Convert a clipboard format name to something stringable.

\*****************************************************************************/
void GetCfBufA(UINT cf, LPSTR pszOut, int cchOut)
{
    if (!GetClipboardFormatNameA(cf, pszOut, cchOut))
       wnsprintfA(pszOut, cchOut, "[%04x]", cf);
}

/*****************************************************************************\

    AllocHGlob

    Allocate a moveable HGLOBAL of the requested size, lock it, then call
    the callback.  On return, unlock it and get out.

    Returns the allocated HGLOBAL, or 0.

\*****************************************************************************/

HGLOBAL AllocHGlob(UINT cb, HGLOBWITHPROC pfn, LPVOID pvRef, LPCVOID pvParam2, BOOL fUnicode)
{
    HGLOBAL hglob = GlobalAlloc(GHND, cb);
    if (hglob)
    {
        LPVOID pv = GlobalLock(hglob);
        if (pv)
        {
            BOOL fRc = pfn(pv, pvRef, pvParam2, fUnicode);
            GlobalUnlock(hglob);
            if (!fRc)
            {
                GlobalFree(hglob);
                hglob = 0;
            }
        }
        else
        {
            GlobalFree(hglob);
            hglob = 0;
        }
    }

    return hglob;
}


SHELL_VERSION g_ShellVersion = SHELL_VERSION_UNKNOWN;
#define SHELL_VERSION_FOR_WIN95_AND_NT4     4


SHELL_VERSION GetShellVersion(void)
{
    if (SHELL_VERSION_UNKNOWN == g_ShellVersion)
    {
        g_ShellVersion = SHELL_VERSION_W95NT4;
        HINSTANCE hInst = LoadLibrary(TEXT("shell32.dll"));

        if (EVAL(hInst))
        {
            DLLGETVERSIONPROC pfnDllGetVersion = (DLLGETVERSIONPROC) GetProcAddress(hInst, "DllGetVersion");

            if (pfnDllGetVersion)
            {
                DLLVERSIONINFO dllVersionInfo;

                g_ShellVersion = SHELL_VERSION_IE4;      // Assume this.
                dllVersionInfo.cbSize = sizeof(dllVersionInfo);
                if (SUCCEEDED(pfnDllGetVersion(&dllVersionInfo)))
                {
                    if (SHELL_VERSION_FOR_WIN95_AND_NT4 < dllVersionInfo.dwMajorVersion)
                        g_ShellVersion = SHELL_VERSION_NT5;      // Assume this.
                }
            }
            FreeLibrary(hInst);
        }
    }
    
    return g_ShellVersion;
}

DWORD GetShdocvwVersion(void)
{
    static DWORD majorVersion=0;  // cache for perf

    if (majorVersion)
        return majorVersion;
    
    HINSTANCE hInst = LoadLibrary(TEXT("shdocvw.dll"));
    if (EVAL(hInst))
    {
        DLLGETVERSIONPROC pfnDllGetVersion = (DLLGETVERSIONPROC) GetProcAddress(hInst, "DllGetVersion");

        if (pfnDllGetVersion)
        {
            DLLVERSIONINFO dllVersionInfo;

            dllVersionInfo.cbSize = sizeof(dllVersionInfo);
            if (SUCCEEDED(pfnDllGetVersion(&dllVersionInfo)))
            {
                majorVersion = dllVersionInfo.dwMajorVersion;
            }
        }

        FreeLibrary(hInst);
    }

    return majorVersion;
}


BOOL ShouldSkipDropFormat(int nIndex)
{
    // Allow DROP_IDList or repositioning items withing
    // Xbox windows won't work.
/*
    // We want to skip DROP_IDList on Win95 and WinNT4's shell
    // because it will cause the old shell to only offer DROPEFFECT_LINK
    // so download isn't available.
    if (((DROP_IDList == nIndex)) &&
        (SHELL_VERSION_W95NT4 == GetShellVersion()))
    {
        return TRUE;
    }
*/

#ifndef BROWSERONLY_DRAGGING
    if (((DROP_FGDW == nIndex) || (DROP_FGDA == nIndex)) &&
        (SHELL_VERSION_NT5 != GetShellVersion()))
    {
        return TRUE;
    }
#endif // BROWSERONLY_DRAGGING

    return FALSE;
}


void SetWindowBits(HWND hWnd, int iWhich, DWORD dwBits, DWORD dwValue)
{
    DWORD dwStyle;
    DWORD dwNewStyle;

    dwStyle = GetWindowLong(hWnd, iWhich);
    dwNewStyle = ( dwStyle & ~dwBits ) | (dwValue & dwBits);
    if (dwStyle != dwNewStyle) {
        SetWindowLong(hWnd, iWhich, dwNewStyle);
    }
}


void InitComctlForNaviteFonts(void)
{
    // hinst is ignored because we set it at our LibMain()
    INITCOMMONCONTROLSEX icex = {0};

    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC  = ICC_USEREX_CLASSES|ICC_NATIVEFNTCTL_CLASS;
    InitCommonControlsEx(&icex);
}


BOOL DoesUrlContainNTDomainName(LPCTSTR pszUrl)
{
    BOOL fResult = FALSE;
    LPCTSTR pszPointer = pszUrl;

    if (lstrlen(pszPointer) > ARRAYSIZE(SZ_XBOXURL))
    {
        pszPointer += ARRAYSIZE(SZ_XBOXURL); // Skip past the scheme.
        pszPointer = StrChr(pszPointer, CH_URL_SLASH);
        if (pszPointer)
        {
            pszPointer = StrChr(CharNext(pszPointer), CH_URL_PASSWORD_SEPARATOR);
            if (pszPointer)
            {
                pszPointer = StrChr(CharNext(pszPointer), CH_URL_LOGON_SEPARATOR);
                if (pszPointer)
                    fResult = TRUE;
            }
        }
    }

    return fResult;
}


HRESULT CharReplaceWithStrW(LPWSTR pszLocToInsert, DWORD cchSize, DWORD cchChars, LPWSTR pszStrToInsert)
{
    WCHAR szTemp[MAX_URL_STRING];

    StrCpyNW(szTemp, pszLocToInsert, ARRAYSIZE(szTemp));

    pszLocToInsert[0] = 0; // Terminate String here to kill char.
    StrCatBuffW(pszLocToInsert, pszStrToInsert, cchSize);
    StrCatBuffW(pszLocToInsert, &szTemp[cchChars], cchSize);

    return S_OK;
}


HRESULT CharReplaceWithStrA(LPSTR pszLocToInsert, DWORD cchSize, DWORD cchChars, LPSTR pszStrToInsert)
{
    CHAR szTemp[MAX_URL_STRING];

    StrCpyNA(szTemp, pszLocToInsert, ARRAYSIZE(szTemp));

    pszLocToInsert[0] = 0; // Terminate String here to kill char.
    StrCatBuffA(pszLocToInsert, pszStrToInsert, cchSize);
    StrCatBuffA(pszLocToInsert, &szTemp[cchChars], cchSize);

    return S_OK;
}


HRESULT RemoveCharsFromString(LPTSTR pszLocToRemove, DWORD cchSizeToRemove)
{
    LPTSTR pszRest = &pszLocToRemove[cchSizeToRemove];

    MoveMemory((LPVOID) pszLocToRemove, (LPVOID) pszRest, (lstrlen(pszRest) + 1) * sizeof(TCHAR));
    return S_OK;
}


HRESULT RemoveCharsFromStringA(LPSTR pszLocToRemove, DWORD cchSizeToRemove)
{
    LPSTR pszRest = &pszLocToRemove[cchSizeToRemove];

    MoveMemory((LPVOID) pszLocToRemove, (LPVOID) pszRest, (lstrlenA(pszRest) + 1) * sizeof(CHAR));
    return S_OK;
}


// Helper function to convert Ansi string to allocated BSTR
#ifndef UNICODE
BSTR AllocBStrFromString(LPCTSTR psz)
{
    OLECHAR wsz[INFOTIPSIZE];  // assumes INFOTIPSIZE number of chars max

    SHAnsiToUnicode(psz, wsz, ARRAYSIZE(wsz));
    return SysAllocString(wsz);

}
#endif // UNICODE


/****************************************************\
    FUNCTION: StrListLength

    DESCRIPTION:
\****************************************************/
DWORD StrListLength(LPCTSTR ppszStrList)
{
    LPTSTR pszStr = (LPTSTR) ppszStrList;
    DWORD cchLength = 0;

    while (pszStr[0])
    {
        pszStr += (lstrlen(pszStr) + 1);
        cchLength++;
    }

    return cchLength;
}


/****************************************************\
    FUNCTION: CalcStrListSizeA

    DESCRIPTION:
\****************************************************/
DWORD CalcStrListSizeA(LPCSTR ppszStrList)
{
    LPSTR pszStr = (LPSTR) ppszStrList;
    DWORD cchSize = 1;

    while (pszStr[0])
    {
        DWORD cchSizeCurr = lstrlenA(pszStr) + 1;

        cchSize += cchSizeCurr;
        pszStr += cchSizeCurr;
    }

    return cchSize;
}


/****************************************************\
    FUNCTION: CalcStrListSizeW

    DESCRIPTION:
\****************************************************/
DWORD CalcStrListSizeW(LPCWSTR ppwzStrList)
{
    LPWSTR pwzStr = (LPWSTR) ppwzStrList;
    DWORD cchSize = 1;

    while (pwzStr[0])
    {
        DWORD cchSizeCurr = lstrlenW(pwzStr) + 1;

        cchSize += cchSizeCurr;
        pwzStr += cchSizeCurr;
    }

    return cchSize;
}


/****************************************************\
    FUNCTION: AnsiToUnicodeStrList

    DESCRIPTION:
\****************************************************/
void AnsiToUnicodeStrList(LPCSTR ppszStrListIn, LPCWSTR ppwzStrListOut, DWORD cchSize)
{
    LPWSTR pwzStrOut = (LPWSTR) ppwzStrListOut;
    LPSTR pszStrIn = (LPSTR) ppszStrListIn;

    while (pszStrIn[0])
    {
        SHAnsiToUnicode(pszStrIn, pwzStrOut, lstrlenA(pszStrIn) + 2);

        pszStrIn += lstrlenA(pszStrIn) + 1;
        pwzStrOut += lstrlenW(pwzStrOut) + 1;
    }

    pwzStrOut[0] = L'\0';
}


/****************************************************\
    FUNCTION: UnicodeToAnsiStrList

    DESCRIPTION:
\****************************************************/
void UnicodeToAnsiStrList(LPCWSTR ppwzStrListIn, LPCSTR ppszStrListOut, DWORD cchSize)
{
    LPSTR pszStrOut = (LPSTR) ppszStrListOut;
    LPWSTR pwzStrIn = (LPWSTR) ppwzStrListIn;

    while (pwzStrIn[0])
    {
        SHUnicodeToAnsi(pwzStrIn, pszStrOut, lstrlenW(pwzStrIn) + 2);

        pwzStrIn += lstrlenW(pwzStrIn) + 1;
        pszStrOut += lstrlenA(pszStrOut) + 1;
    }

    pszStrOut[0] = '\0';
}


/****************************************************\
    FUNCTION: Str_StrAndThunkA

    DESCRIPTION:
\****************************************************/
HRESULT Str_StrAndThunkA(LPTSTR * ppszOut, LPCSTR pszIn, BOOL fStringList)
{
#ifdef UNICODE
    if (!fStringList)
    {
        DWORD cchSize = (lstrlenA(pszIn) + 2);
        LPWSTR pwzBuffer = (LPWSTR) LocalAlloc(LPTR, cchSize * SIZEOF(WCHAR));

        if (!pwzBuffer)
            return E_OUTOFMEMORY;

        SHAnsiToUnicode(pszIn, pwzBuffer, cchSize);
        Str_SetPtrW(ppszOut, pwzBuffer);
    }
    else
    {
        DWORD cchSize = CalcStrListSizeA(pszIn);
        Str_SetPtrW(ppszOut, NULL); // Free

        *ppszOut = (LPTSTR) LocalAlloc(LPTR, cchSize * sizeof(WCHAR));
        if (*ppszOut)
            AnsiToUnicodeStrList(pszIn, *ppszOut, cchSize);
    }

#else // UNICODE

    if (!fStringList)
    {
        // No thunking needed.
        Str_SetPtrA(ppszOut, pszIn);
    }
    else
    {
        DWORD cchSize = CalcStrListSizeA(pszIn);
        Str_SetPtrA(ppszOut, NULL); // Free

        *ppszOut = (LPTSTR) LocalAlloc(LPTR, cchSize * sizeof(CHAR));
        if (*ppszOut)
            CopyMemory(*ppszOut, pszIn, cchSize * sizeof(CHAR));
    }
#endif // UNICODE

    return S_OK;
}


BOOL IsValidXboxAnsiFileName(LPCTSTR pszString)
{
#ifdef UNICODE
    // TODO:
#endif // UNICODE
    return TRUE;
}


/****************************************************\
    FUNCTION: Str_StrAndThunkW

    DESCRIPTION:
\****************************************************/
HRESULT Str_StrAndThunkW(LPTSTR * ppszOut, LPCWSTR pwzIn, BOOL fStringList)
{
#ifdef UNICODE
    if (!fStringList)
    {
        // No thunking needed.
        Str_SetPtrW(ppszOut, pwzIn);
    }
    else
    {
        DWORD cchSize = CalcStrListSizeW(pwzIn);
        Str_SetPtrW(ppszOut, NULL); // Free

        *ppszOut = (LPTSTR) LocalAlloc(LPTR, cchSize * sizeof(WCHAR));
        if (*ppszOut)
            CopyMemory(*ppszOut, pwzIn, cchSize * sizeof(WCHAR));
    }

#else // UNICODE

    if (!fStringList)
    {
        DWORD cchSize = (lstrlenW(pwzIn) + 2);
        LPSTR pszBuffer = (LPSTR) LocalAlloc(LPTR, cchSize * SIZEOF(CHAR));

        if (!pszBuffer)
            return E_OUTOFMEMORY;

        SHUnicodeToAnsi(pwzIn, pszBuffer, cchSize);
        Str_SetPtrA(ppszOut, pszBuffer);
    }
    else
    {
        DWORD cchSize = CalcStrListSizeW(pwzIn);
        Str_SetPtrA(ppszOut, NULL); // Free

        *ppszOut = (LPTSTR) LocalAlloc(LPTR, cchSize * sizeof(CHAR));
        if (*ppszOut)
            UnicodeToAnsiStrList(pwzIn, *ppszOut, cchSize * sizeof(CHAR));
    }
#endif // UNICODE

    return S_OK;
}


#ifndef UNICODE
// TruncateString
//
// purpose: cut a string at the given length in dbcs safe manner.
//          the string may be truncated at cch-2 if the sz[cch] points
//          to a lead byte that would result in cutting in the middle
//          of double byte character.
//
// update: made it faster for sbcs environment (5/26/97)
//         now returns adjusted cch            (6/20/97)
//
void  TruncateString(char *sz, int cchBufferSize)
{
    if (!sz || cchBufferSize <= 0) return;

    int cch = cchBufferSize - 1; // get index position to NULL out
    
    LPSTR psz = &sz[cch];
    
    while (psz >sz)
    {
        psz--;
        if (!IsDBCSLeadByte(*psz))
        {
            // Found non-leadbyte for the first time.
            // This is either a trail byte of double byte char
            // or a single byte character we've first seen.
            // Thus, the next pointer must be at either of a leadbyte
            // or &sz[cch]
            psz++;
            break;
        }
    }
    if (((&sz[cch] - psz) & 1) && cch > 0)
    {
        // we're truncating the string in the middle of dbcs
        cch--;
    }
    sz[cch] = '\0';
    return;
}

#endif // UNICODE



HRESULT CopyStgMediumWrap(const STGMEDIUM * pcstgmedSrc, STGMEDIUM * pstgmedDest)
{
    HRESULT hr = CopyStgMedium(pcstgmedSrc, pstgmedDest);

    // if pstgmedDest->pUnkForElease is NULL,
    //  then we need to free hglobal because we own freeing the memory.
    //  else someone else owns the lifetime of the memory and releasing
    //  pUnkForElease is the way to indicate that we won't use it anymore.
    //
    // The problem is that urlmon's CopyStgMedium() ERRouniously copies the
    // pUnkForElease param in addition to cloning the memory.  This means
    // that we own freeing the memory but the pointer being non-NULL would
    // indicate that we don't own freeing the memory.

    // ASSERT(NULL == pstgmedDest->pUnkForElease);
    pstgmedDest->pUnkForRelease = NULL;

    return hr;
}


HRESULT SHBindToIDList(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    IShellFolder * psf;
    HRESULT hr = SHGetDesktopFolder(&psf);

    if (EVAL(SUCCEEDED(hr)))
    {
        hr = psf->BindToObject(pidl, pbc, riid, ppv);
        psf->Release();
    }

    return hr;
}


STDAPI DataObj_SetGlobal(IDataObject *pdtobj, UINT cf, HGLOBAL hGlobal)
{
    FORMATETC fmte = {(CLIPFORMAT) cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM medium;

    medium.tymed = TYMED_HGLOBAL;
    medium.hGlobal = hGlobal;
    medium.pUnkForRelease = NULL;

    // give the data object ownership of ths
    return pdtobj->SetData(&fmte, &medium, TRUE);
}


STDAPI DataObj_SetDWORD(IDataObject *pdtobj, UINT cf, DWORD dw)
{
    HRESULT hr = E_OUTOFMEMORY;
    DWORD *pdw = (DWORD *)GlobalAlloc(GPTR, sizeof(DWORD));
    if (pdw)
    {
        *pdw = dw;
        hr = DataObj_SetGlobal(pdtobj, cf, pdw);

        if (FAILED(hr))
            GlobalFree((HGLOBAL)pdw);
    }

    return hr;
}


STDAPI DataObj_GetDWORD(IDataObject *pdtobj, UINT cf, DWORD *pdwOut)
{
    STGMEDIUM medium;
    FORMATETC fmte = {(CLIPFORMAT) cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    HRESULT hr = pdtobj->GetData(&fmte, &medium);
    if (SUCCEEDED(hr))
    {
        DWORD *pdw = (DWORD *)GlobalLock(medium.hGlobal);
        if (pdw)
        {
            *pdwOut = *pdw;
            GlobalUnlock(medium.hGlobal);
        }
        else
        {
            hr = E_UNEXPECTED;
        }

        ReleaseStgMedium(&medium);
    }

    return hr;
}


STDAPI DataObj_GetDropTarget(IDataObject *pdtobj, CLSID *pclsid)
{
    STGMEDIUM medium;
    FORMATETC fmte = {(CLIPFORMAT) g_cfTargetCLSID, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    HRESULT hr = pdtobj->GetData(&fmte, &medium);
    if (SUCCEEDED(hr))
    {
        CLSID *pdw = (CLSID *)GlobalLock(medium.hGlobal);
        if (pdw)
        {
            *pclsid = *pdw;
            GlobalUnlock(medium.hGlobal);
        }
        else
        {
            hr = E_UNEXPECTED;
        }
        ReleaseStgMedium(&medium);
    }
    return hr;
}


STDAPI DataObj_SetPreferredEffect(IDataObject *pdtobj, DWORD dwEffect)
{
    return DataObj_SetDWORD(pdtobj, g_dropTypes[DROP_PrefDe].cfFormat, dwEffect);
}


STDAPI DataObj_SetPasteSucceeded(IDataObject *pdtobj, DWORD dwEffect)
{
    return DataObj_SetDWORD(pdtobj, g_formatPasteSucceeded.cfFormat, dwEffect);
}




/****************************************************\
    FUNCTION: ShowEnableWindow

    DESCRIPTION:
        If you don't want a window to be visible or
    usable by the user, you need to call both
    ShowWindow(SW_HIDE) and EnableWindow(FALSE) or
    the window may be hidden but still accessible via
    the keyboard.
\****************************************************/
void ShowEnableWindow(HWND hwnd, BOOL fShow)
{
    ShowWindow(hwnd, (fShow ? SW_SHOW : SW_HIDE));
    EnableWindow(hwnd, fShow);
}


STDAPI StringToStrRetW(LPCWSTR pwzString, STRRET *pstrret)
{
    HRESULT hr = SHStrDupW(pwzString, &pstrret->pOleStr);
    if (SUCCEEDED(hr))
    {
        pstrret->uType = STRRET_WSTR;
    }
    return hr;
}


#define BIT_8_SET       0x80

BOOL Is7BitAnsi(LPCWIRESTR pwByteStr)
{
    BOOL fIs7BitAnsi = TRUE;

    if (pwByteStr)
    {
        while (pwByteStr[0]) 
        {
            if (BIT_8_SET & pwByteStr[0])
            {
                fIs7BitAnsi = FALSE;
                break;
            }

            pwByteStr++;
        }
    }

    return fIs7BitAnsi;
}


HRESULT LoginAs(HWND hwnd, CXboxFolder * pff, CXboxDir * pfd, IUnknown * punkSite)
{
    HRESULT hr = E_FAIL;
    CXboxSite * pfs = pfd->GetXboxSite();

    ASSERT(hwnd && pff);
    if (EVAL(pfs))
    {
        CAccounts cAccounts;
        TCHAR szServer[INTERNET_MAX_HOST_NAME_LENGTH];
        TCHAR szUser[INTERNET_MAX_USER_NAME_LENGTH];
        TCHAR szPassword[INTERNET_MAX_PASSWORD_LENGTH];
        LPCITEMIDLIST pidlPrevious = pfd->GetPidlReference();

        pfs->GetServer(szServer, ARRAYSIZE(szServer));
        pfs->GetUser(szUser, ARRAYSIZE(szUser));
        pfs->GetPassword(szPassword, ARRAYSIZE(szPassword));

        hr = cAccounts.DisplayLoginDialog(hwnd, LOGINFLAGS_DEFAULT, szServer, szUser, ARRAYSIZE(szUser), szPassword, ARRAYSIZE(szPassword));
        if (S_OK == hr)
        {
            LPITEMIDLIST pidlNew;

            ASSERT(pff->GetItemAllocatorDirect());
            hr = PidlReplaceUserPassword(pidlPrevious, &pidlNew, pff->GetItemAllocatorDirect(), szUser, szPassword);
            if (EVAL(SUCCEEDED(hr)))
            {
                CXboxSite * pfs;
                LPITEMIDLIST pidlRedirect;

                // We need to update the password in the site to redirect to the correct or new one.
                if (EVAL(SUCCEEDED(PidlReplaceUserPassword(pidlNew, &pidlRedirect, pff->GetItemAllocatorDirect(), szUser, TEXT(""))) &&
                         SUCCEEDED(SiteCache_PidlLookup(pidlRedirect, TRUE, pff->GetItemAllocatorDirect(), &pfs))))
                {
                    EVAL(SUCCEEDED(pfs->SetRedirPassword(szPassword)));
                    pfs->Release();
                    ILFree(pidlRedirect);
                }

                // pidl is a full private pidl.  pidlFull will be a full public pidl because
                // that's what the browser needs to get back from the root of THE public
                // name space back to and into us.
                LPITEMIDLIST pidlFull = pff->CreateFullPublicPidl(pidlNew);
                if (pidlFull)
                {
                    hr = IUnknown_PidlNavigate(punkSite, pidlFull, TRUE);
                    ILFree(pidlFull);
                }
                else
                    hr = E_FAIL;

                ILFree(pidlNew);
            }
        }
    }

    return hr;
}



HRESULT LoginAsViaFolder(HWND hwnd, CXboxFolder * pff, IUnknown * punkSite)
{
    HRESULT hr = E_FAIL;
    CXboxDir * pfd = pff->GetXboxDir();

    if (EVAL(pfd))
    {
        hr = LoginAs(hwnd, pff, pfd, punkSite);
        pfd->Release();
    }

    return hr;
}


#define PATH_IS_DRIVE(wzPath)      (-1 != PathGetDriveNumberW(wzPath))

HRESULT SHPathPrepareForWriteWrapW(HWND hwnd, IUnknown *punkEnableModless, LPCWSTR pwzPath, UINT wFunc, DWORD dwFlags)
{
    HRESULT hr;

    if (SHELL_VERSION_NT5 == GetShellVersion())
    {
        // NT5's version of the API is better.
        hr = _SHPathPrepareForWriteW(hwnd, punkEnableModless, pwzPath, dwFlags);
    }
    else
    {
        if (PATH_IS_DRIVE(pwzPath))
        {
            hr = (SHCheckDiskForMediaW(hwnd, punkEnableModless, pwzPath, wFunc) ? S_OK : E_FAIL);
        }
        else
        {
            if (PathIsUNCW(pwzPath))
            {
                hr = (PathFileExistsW(pwzPath) ? S_OK : E_FAIL);
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xbox.cpp ===
/*****************************************************************************
 *
 *        xbox.cpp - XBOX folder bookkeeping
 *
 *****************************************************************************/

#include "priv.h"
#include "xboxinet.h"
#include "xboxsite.h"
#include "xboxlist.h"
#include "xbnmspc.h"
#include "cookie.h"

extern CXboxList * g_XboxSiteCache;
extern DWORD g_dwOpenConnections;

/*****************************************************************************
 *
 *    Dynamic Globals.  There should be as few of these as possible.
 *
 *    All access to dynamic globals must be thread-safe.
 *
 *****************************************************************************/

ULONG g_cRef = 0;            /* Global reference count */
CRITICAL_SECTION g_csDll;    /* The shared critical section */


extern HANDLE g_hthWorker;             // Background worker thread

#ifdef DEBUG
DWORD g_TlsMem = 0xffffffff;
extern DWORD g_TLSliStopWatchStartHi;
extern DWORD g_TLSliStopWatchStartLo;

LEAKSTRUCT g_LeakList[] =
{
    {0, "CXboxFolder"},
    {0, "CXboxDir"},
    {0, "CXboxSite"},
    {0, "CXboxObj"},
    {0, "CXboxEidl"},
    {0, "CXboxDrop"},
    {0, "CXboxList"},
    {0, "CXboxStm"},
    {0, "CAccount"},
    {0, "CXboxFactory"},
    {0, "CXboxContextMenu"},
    {0, "CXboxEfe"},
    {0, "CXboxGlob"},
    {0, "CXboxIcon"},
    {0, "CMallocItem"},
    {0, "CXboxPidlList"},
    {0, "CXboxProp"},
    {0, "CStatusBar"},
    {0, "CXboxView"},
    {0, "CXboxWebView"},
    {0, "CCookieList"},
    {0, "CDropOperation"}
};
#endif // DEBUG

ULONG g_cRef_CXboxView = 0;  // Needed to determine when to purge cache.

/*****************************************************************************
 *
 *    DllAddRef / DllRelease
 *
 *    Maintain the DLL reference count.
 *
 *****************************************************************************/

void DllAddRef(void)
{
    CREATE_CALLERS_ADDRESS;         // For debug spew.

    InterlockedIncrement((LPLONG)&g_cRef);
    TraceMsg(TF_XBOXREF, "DllAddRef() g_cRef=%d, called from=%#08lx.", g_cRef, GET_CALLERS_ADDRESS);
}

void DllRelease(void)
{
    CREATE_CALLERS_ADDRESS;         // For debug spew.

    TraceMsg(TF_XBOXREF, "DllRelease() g_cRef=%d, called from=%#08lx.", g_cRef-1, GET_CALLERS_ADDRESS);
    InterlockedDecrement((LPLONG)&g_cRef);
}

/*****************************************************************************
 *
 *    DllGetClassObject
 *
 *    OLE entry point.  Produces an IClassFactory for the indicated GUID.
 *
 *    The artificial refcount inside DllGetClassObject helps to
 *    avoid the race condition described in DllCanUnloadNow.  It's
 *    not perfect, but it makes the race window much smaller.
 *
 *****************************************************************************/

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hres;

    DllAddRef();
    if (IsEqualIID(rclsid, CLSID_XboxFolder) ||
        IsEqualIID(rclsid, CLSID_XboxWebView) ||
        IsEqualIID(rclsid, CLSID_XboxDataObject))
    {
        hres = CXboxFactory_Create(rclsid, riid, ppvObj);
    }
    else
    {
        *ppvObj = NULL;
        hres = CLASS_E_CLASSNOTAVAILABLE;
    }

    DllRelease();
    return hres;
}

/*****************************************************************************
 *
 *    DllCanUnloadNow
 *
 *    OLE entry point.  Fail iff there are outstanding refs.
 *
 *    There is an unavoidable race condition between DllCanUnloadNow
 *    and the creation of a new IClassFactory:  Between the time we
 *    return from DllCanUnloadNow() and the caller inspects the value,
 *    another thread in the same process may decide to call
 *    DllGetClassObject, thus suddenly creating an object in this DLL
 *    when there previously was none.
 *
 *    It is the caller's responsibility to prepare for this possibility;
 *    there is nothing we can do about it.
 *
 *****************************************************************************/

STDMETHODIMP DllCanUnloadNow(void)
{
    HRESULT hres;

    ENTERCRITICALNOASSERT;

    // Purge Cache if there aren't any XboxViews open.
    if ((0 == g_cRef_CXboxView))
    {
        // Since no views are open, we want to try to purge
        // the Delayed Actions so we can closed down the background
        // thread.  Is it running?
        if (AreOutstandingDelayedActions())
        {
            LEAVECRITICALNOASSERT;
            PurgeDelayedActions();  // Try to close it down.
            ENTERCRITICALNOASSERT;
        }

        if (!AreOutstandingDelayedActions())    // Did it close down?
        {
            // We need to purge the session key because we lost the password
            // redirects in the CXboxSites.  So we would login but later fail
            // when we try to fish out the password when falling back to
            // URLMON/shdocfl for file downloads. (NT #362108)
            PurgeSessionKey();
            CXboxPunkList_Purge(&g_XboxSiteCache);    // Yes so purge the cache...
        }
    }

    hres = g_cRef ? S_FALSE : S_OK;
    TraceMsg(TF_XBOX_DLLLOADING, "DllCanUnloadNow() DllRefs=%d, returning hres=%#08lx. (S_OK means yes)", g_cRef, hres);

    LEAVECRITICALNOASSERT;

    return hres;
}


void CheckForLeaks(BOOL fForce)
{
#ifdef DEBUG
    DWORD dwLeakCount = 0;

    if (fForce)
    {
        // Let's free our stuff so we can make sure not to leak it.
        // This is done more to force our selves to be w/o leaks
        // than anything else.
        DllCanUnloadNow();
    }

    for (int nIndex = 0; nIndex < ARRAYSIZE(g_LeakList); nIndex++)
        dwLeakCount += g_LeakList[nIndex].dwRef;

    if ((!g_XboxSiteCache || fForce) && (dwLeakCount || g_dwOpenConnections || g_cRef))
    {
        TraceMsg(TF_ALWAYS, "***********************************************");
        TraceMsg(TF_ALWAYS, "* LEAK  -  LEAK  -  LEAK  -  LEAK  -  LEAK    *");
        TraceMsg(TF_ALWAYS, "*                                             *");
        TraceMsg(TF_ALWAYS, "* WARNING: The XBOX Shell Extension Leaked     *");
        TraceMsg(TF_ALWAYS, "*          one or more objects                *");
        TraceMsg(TF_ALWAYS, "***********************************************");
        TraceMsg(TF_ALWAYS, "*                                             *");
        for (int nIndex = 0; nIndex < ARRAYSIZE(g_LeakList); nIndex++)
        {
            if (g_LeakList[nIndex].dwRef)
                TraceMsg(TF_ALWAYS, "* %hs, Leaked=%d                          *", g_LeakList[nIndex].szObject, g_LeakList[nIndex].dwRef);
        }
        TraceMsg(TF_ALWAYS, "*                                             *");
        TraceMsg(TF_ALWAYS, "* Open Wininet Connections=%d                  *", g_dwOpenConnections);
        TraceMsg(TF_ALWAYS, "* DLL Refs=%d                                  *", g_cRef);
        TraceMsg(TF_ALWAYS, "*                                             *");
        TraceMsg(TF_ALWAYS, "***********************************************");
        ASSERT(0);
    }

#endif // DEBUG
}


// Globals to free. 
extern CCookieList * g_pCookieList;

/*****************************************************************************
 *
 *    Entry32
 *
 *    DLL entry point.
 *
 *    BUGBUG -- On a thread detach, must check if the thread owns any
 *    global timeouts.  If so, we must transfer the timeout to another
 *    thread or something.
 *
 *****************************************************************************/
STDAPI_(BOOL) DllEntry(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
    // This is called in two situations, FreeLibrary() is called and lpReserved is
    // NULL, or the process is shutting down and lpReserved is not NULL.
    BOOL fIsProcessShuttingDown = (lpReserved ? TRUE : FALSE);

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        InitializeCriticalSection(&g_csDll);
#ifdef DEBUG
        g_TlsMem = TlsAlloc();
        g_TLSliStopWatchStartHi = TlsAlloc();
        g_TLSliStopWatchStartLo = TlsAlloc();
#endif

        // Don't put it under #ifdef DEBUG
        CcshellGetDebugFlags();
        DisableThreadLibraryCalls(hinst);

        g_hthWorker = NULL;

        g_hinst = hinst;
        g_formatEtcOffsets.cfFormat         = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_SHELLIDLISTOFFSET);
        g_formatPasteSucceeded.cfFormat     = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_PASTESUCCEEDED);
        g_cfTargetCLSID                     = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_TARGETCLSID);

        g_dropTypes[DROP_FCont].cfFormat    = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_FILECONTENTS);
        g_dropTypes[DROP_FGDW].cfFormat     = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_FILEDESCRIPTORW);
        g_dropTypes[DROP_FGDA].cfFormat     = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_FILEDESCRIPTORA);
        g_dropTypes[DROP_IDList].cfFormat   = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_SHELLIDLIST);
        g_dropTypes[DROP_FNMA].cfFormat     = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_FILENAMEMAPA);
        g_dropTypes[DROP_FNMW].cfFormat     = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_FILENAMEMAPW);
        g_dropTypes[DROP_PrefDe].cfFormat   = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_PREFERREDDROPEFFECT);
        g_dropTypes[DROP_PerfDe].cfFormat   = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_PERFORMEDDROPEFFECT);
        g_dropTypes[DROP_XBOX_PRIVATE].cfFormat = (CLIPFORMAT)RegisterClipboardFormat(TEXT("XboxPrivateData"));
        g_dropTypes[DROP_URL].cfFormat      = (CLIPFORMAT)RegisterClipboardFormat(TEXT("UniformResourceLocator"));
        g_dropTypes[DROP_OLEPERSIST].cfFormat       = (CLIPFORMAT)RegisterClipboardFormat(TEXT("OleClipboardPersistOnFlush"));

        GetModuleFileNameA(GetModuleHandle(TEXT("SHELL32")), g_szShell32, ARRAYSIZE(g_szShell32));

        if (FAILED(CXboxSite_Init()))
            return 0;

        break;

    case DLL_PROCESS_DETACH:
    {
        CCookieList * pCookieList = (CCookieList *) InterlockedExchangePointer((void **) &g_pCookieList, NULL);
        if (pCookieList)
            delete pCookieList;

        // Yes, so we need to make sure all of the CXboxView's have closed down
        // or it's really bad to purge the XBOX cache of XBOX Servers (CXboxSite) and
        // their directories (CXboxDir).
        ASSERT(0 == g_cRef_CXboxView);

        // Now force the Delayed Actions to happen now instead of waiting.
        PurgeDelayedActions();

        CheckForLeaks(fIsProcessShuttingDown);

        UnloadWininet();
        DeleteCriticalSection(&g_csDll);
#ifdef DEBUG
        if (g_TLSliStopWatchStartHi)
        {
            TlsFree(g_TLSliStopWatchStartHi);
            g_TLSliStopWatchStartHi = NULL;
        }
        if (g_TLSliStopWatchStartLo)
        {
            TlsFree(g_TLSliStopWatchStartLo);
            g_TLSliStopWatchStartLo = NULL;
        }
#endif
    }
    break;
    }
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxcm.h ===
/*****************************************************************************
 *    xboxcm.h
 *****************************************************************************/

#ifndef _XBOXCONTEXTMENU_H
#define _XBOXCONTEXTMENU_H

#include "xboxdrop.h"


typedef HRESULT (*INVOKEPROC)(CXboxMenu * pfcm, LPCMINVOKECOMMANDINFO pici, LPCTSTR pszCmd, LPCITEMIDLIST pidl);

typedef struct {            /* enum invoke info */
    CXboxMenu * pfcm;
    LPCMINVOKECOMMANDINFO pici;
    HRESULT hres;
    INVOKEPROC pfn;
    LPCTSTR ptszCmd;
} EII, *PEII;




/*****************************************************************************
 *
 *    CXboxMenu
 *
 *
 *****************************************************************************/

class CXboxMenu          : public IContextMenu
                        , public CObjectWithSite
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    
    // *** IContextMenu ***
    virtual STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    virtual STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);
    virtual STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uType, UINT * pwReserved, LPSTR pszName, UINT cchMax);

public:
    CXboxMenu();
    ~CXboxMenu(void);

    // Public Member Variables
    DWORD                   m_sfgao;        // Shell attributes of objects
    CXboxPidlList *          m_pflHfpl;      // Where I live             // BUGBUG: Come back and see if we want to change this.
    CXboxFolder *            m_pff;          // CXboxFolder in which our pidls live
    CXboxDir *               m_pfd;          // XboxDir in which our pidls live
    HWND                    m_hwnd;         // Owner window for UI
    POINT                   m_ptNewItem;    // Points where the context menu was invoked.  Used to later position a new folder.
    DWORD                   m_uFlags;       // Flags used in ::QueryContextMenu() to determine if the menu was invoked by the file menu.
    BOOL                    m_fBackground;  // Is this a forground or background context menu?

    // Friend Functions
    friend HRESULT CXboxMenu_Create(CXboxFolder * pff, CXboxPidlList * pflHfpl, HWND hwnd, REFIID riid, LPVOID * ppvObj);
    friend HRESULT CXboxMenu_Create(CXboxFolder * pff, CXboxPidlList * pflHfpl, HWND hwnd, CXboxMenu ** ppfm);

    static DWORD CALLBACK _DownloadDialogThreadProc(LPVOID pvThis) { return ((CXboxMenu *) pvThis)->_DownloadDialogThreadProc(); };

protected:
    int                     m_cRef;

    LPTSTR                  m_pszDownloadDir;         // Download Directory
    DWORD                   m_dwDownloadType;         // Download Directory

    // Private Member Functions
    int _RemoveContextMenuItems(HMENU hmenu, UINT idCmdFirst, DWORD sfgao);
    int _InvokeOne(LPCITEMIDLIST pidl, PEII peii);
    HRESULT _InvokeDelete(LPCMINVOKECOMMANDINFO pici);
    HRESULT _InvokeRename(LPCMINVOKECOMMANDINFO pici);
    HRESULT _InvokeCutCopy(UINT_PTR id, LPCMINVOKECOMMANDINFO pici);
    HRESULT _DoDrop(IDropTarget * pdt, IDataObject * pdto);
    HRESULT _InvokePaste(LPCMINVOKECOMMANDINFO pici);
    HRESULT _InvokeDownloadVerb(LPCMINVOKECOMMANDINFO pici);
    HRESULT _InvokeDeleteVerb(LPCMINVOKECOMMANDINFO pici);
    HRESULT _InvokeLoginAsVerb(LPCMINVOKECOMMANDINFO pici);
    HRESULT _InvokeNewFolderVerb(LPCMINVOKECOMMANDINFO pici);
    HRESULT _AddToRecentDocs(LPCITEMIDLIST pidl);
    CStatusBar * _GetStatusBar(void);
    DWORD _DownloadDialogThreadProc(void);
    DWORD _DownloadThreadProc(void);
    BOOL _AreAllFolders(CXboxPidlList * pflHfpl);
    LPITEMIDLIST GetSoftLinkDestination(LPCITEMIDLIST pidlToSoftLink);

    static HRESULT _SoftLinkDestCB(HINTERNET hint, HINTPROCINFO * phpi, LPVOID pvsldcbs, BOOL * pfReleaseHint);
    static int _InvokeOneCB(LPVOID pvPidl, LPVOID pv);
    static HRESULT _ApplyOne(CXboxMenu * pfcm, LPCMINVOKECOMMANDINFO pici, LPCTSTR ptszCmd, LPCITEMIDLIST pidl);
    static DWORD CALLBACK DownloadThreadProc(LPVOID pvThis) { return ((CXboxMenu *) pvThis)->_DownloadThreadProc(); };
    STDMETHODIMP _EnumInvoke(LPCMINVOKECOMMANDINFO pici, INVOKEPROC pfn, LPCTSTR ptszCmd);

private:
    BOOL _ContainsForgroundItems(void);
    BOOL _IsCallerCaptionBar(UINT indexMenu, UINT uFlags);
};

#endif // _XBOXCONTEXTMENU_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxcm.cpp ===
/*****************************************************************************\
    FILE:  xboxcm.cpp - IContextMenu interface
\*****************************************************************************/

#include "priv.h"
#include "xboxcm.h"
#include "util.h"
#include "xboxprop.h"
#include "xboxurl.h"
#include "dialogs.h"
#include "statusbr.h"
#include "newmenu.h"
#include "view.h"
#include "resource.h"



/*****************************************************************************\
 *
 *    VERBINFO, c_rgvi
 *
 *    Information about which capabilities correspond to which verbs.
 *
 *    If the item ID is in the range 0 ... IDC_ITEM_MAX, then it is
 *    relative to the base address.
 *
\*****************************************************************************/

#pragma BEGIN_CONST_DATA

#define     CMDSTR_LOGINASA          "Login As"

// BUGBUG -- split into two arrays, cobbled together into a structure

struct VERBINFO
{
    UINT  idc;
    DWORD sfgao;
    LPCTSTR ptszCmd;
} c_rgvi[] = {
/* If you edit anything below this comment, make sure to update below */
    {    IDM_SHARED_EDIT_COPY,    SFGAO_CANCOPY,        TEXT("copy"),     },
#ifdef FEATURE_CUT_MOVE
    {    IDM_SHARED_EDIT_CUT,    SFGAO_CANMOVE,        TEXT("cut"),    },
#endif // FEATURE_CUT_MOVE
    {    IDM_SHARED_FILE_LINK,    SFGAO_CANLINK,        TEXT("link"),     },
    {    IDM_SHARED_FILE_RENAME,    SFGAO_CANRENAME,    TEXT("rename"),    },
    {    IDM_SHARED_FILE_DELETE,    SFGAO_CANDELETE,    TEXT("delete"),    },
    {    IDM_SHARED_FILE_PROP,    SFGAO_HASPROPSHEET,    TEXT("properties"), },
    {    IDM_SHARED_EDIT_PASTE,    SFGAO_DROPTARGET,    TEXT("paste"),    },
/* CVI_NONREQ is the number of items in c_rgvi up to this point */
/* The following entries must be in IDC_ITEM_* order */
    {    IDC_ITEM_OPEN,        SFGAO_FOLDER,        TEXT("open"),    },
    {    IDC_ITEM_EXPLORE,    SFGAO_FOLDER,        TEXT("explore"),},
    {    IDC_ITEM_DOWNLOAD,    SFGAO_CANCOPY,        TEXT("download"),},
    {    IDC_ITEM_BKGNDPROP,    0,                    TEXT("backgroundproperties"),},
    {    IDC_LOGIN_AS,        0,                    TEXT(CMDSTR_LOGINASA),},
    {    IDC_ITEM_NEWFOLDER,    0,                    CMDSTR_NEWFOLDER,},
/* The preceding entries must be in IDC_ITEM_* order */
/* If you edit anything above this comment, make sure to update below */
};

#ifdef FEATURE_CUT_MOVE
#define CVI_NONREQ   7        /* See remarks above */
#else // FEATURE_CUT_MOVE
#define CVI_NONREQ   6        /* See remarks above */
#endif // FEATURE_CUT_MOVE
#define IVI_REQ        CVI_NONREQ    /* First required verb */
#define IVI_MAX        ARRAYSIZE(c_rgvi)    /* One past last value index */

#pragma END_CONST_DATA



/*****************************************************************************\
    FUNCTION:   _RemoveContextMenuItems
 
    Remove context menu items based on attribute flags.
  
      If we have a drop target, ping it to see if the object on the
      clipboard is pasteable.  If not, then disable Paste.  (Shell UI
      says that you don't remove Paste, merely disable it.)
    
    Return the number of items removed.
\*****************************************************************************/
int CXboxMenu::_RemoveContextMenuItems(HMENU hmenu, UINT idCmdFirst, DWORD sfgao)
{
    int ivi;
    int nItemRemoved = 0;

    for (ivi = 0; ivi < CVI_NONREQ; ivi++)
    {
        if (!(sfgao & c_rgvi[ivi].sfgao))
        {
            EnableMenuItem(hmenu, (c_rgvi[ivi].idc + idCmdFirst), MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
            nItemRemoved++;
        }
    }

    // See if the clipboard format is supported
    if (sfgao & SFGAO_DROPTARGET)
    {
        IDataObject *pdto;
        DWORD grflEffects = 0;        // Clipboard not available

        if (EVAL(SUCCEEDED(OleGetClipboard(&pdto))))
        {
            CXboxDrop * pfdrop;
            
            if (SUCCEEDED(CXboxDrop_Create(m_pff, m_hwnd, &pfdrop)))
            {
                grflEffects = pfdrop->GetEffectsAvail(pdto);
                pfdrop->Release();
            }
            pdto->Release();
        }

        if (!(grflEffects & (DROPEFFECT_COPY | DROPEFFECT_MOVE)))
        {
            EnableMenuItem(hmenu, (IDM_SHARED_EDIT_PASTE + idCmdFirst),
                       MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
            nItemRemoved++;
        }
#ifdef _SOMEDAY_PASTESHORTCUT
        if (!(grflEffects & DROPEFFECT_LINK))
        {
            EnableMenuItem(hmenu, (IDM_SHARED_EDIT_PASTE_SHORTCUT + idCmdFirst),
                       MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
            nItemRemoved++;
        }
#endif
    }

    return nItemRemoved;
}


/*****************************************************************************\
    FUNCTION: _AddToRecentDocs

    DESCRIPTION:
        This method will add the item to the Recent Docs MRU.  The pidl parameter
    is a fully qualified pidl all the way to the root of the public shell name space
    (desktop).
\*****************************************************************************/
HRESULT CXboxMenu::_AddToRecentDocs(LPCITEMIDLIST pidl)
{
    // We may want to filter on verb.
    SHAddToRecentDocs(SHARD_PIDL, (LPCVOID) pidl);

    return S_OK;
}


typedef struct
{
    LPCWIRESTR pwSoftLink;
    LPWIRESTR pwXboxPath;
    DWORD cchSize;
} SOFTLINKDESTCBSTRUCT;

HRESULT CXboxMenu::_SoftLinkDestCB(HINTERNET hint, HINTPROCINFO * phpi, LPVOID pvsldcbs, BOOL * pfReleaseHint)
{
    HRESULT hr = S_OK;
    WIRECHAR wFrom[MAX_PATH];
    SOFTLINKDESTCBSTRUCT * psldcbs = (SOFTLINKDESTCBSTRUCT *) pvsldcbs;
    DWORD cchSize = ARRAYSIZE(wFrom);

    // Normally, I hate hard coding the buffer size, but passing structs to callbacks is such a pain
    // and this won't change.
    hr = XboxGetCurrentDirectoryWrap(hint, TRUE, wFrom, cchSize);
    if (SUCCEEDED(hr))
    {
        hr = XboxSetCurrentDirectoryWrap(hint, TRUE, psldcbs->pwSoftLink);
        if (SUCCEEDED(hr))
        {
            hr = XboxGetCurrentDirectoryWrap(hint, TRUE, psldcbs->pwXboxPath, psldcbs->cchSize);
            if (SUCCEEDED(hr))
            {
                // BUGBUG: Do we need to return?
                hr = XboxSetCurrentDirectoryWrap(hint, TRUE, wFrom);
            }
        }
    }

    return hr;
}


LPITEMIDLIST CXboxMenu::GetSoftLinkDestination(LPCITEMIDLIST pidlToSoftLink)
{
    LPITEMIDLIST pidlToDest = NULL;
    WIRECHAR wSoftLinkName[MAX_PATH];
    WIRECHAR wXboxPath[MAX_PATH];
    SOFTLINKDESTCBSTRUCT sldcbs = {wSoftLinkName, wXboxPath, ARRAYSIZE(wXboxPath)};

    StrCpyNA(wSoftLinkName, XboxPidl_GetLastItemWireName(pidlToSoftLink), ARRAYSIZE(wSoftLinkName));
    StrCpyNA(wXboxPath, XboxPidl_GetLastItemWireName(pidlToSoftLink), ARRAYSIZE(wXboxPath));

    // NULL hwnd because I don't want UI.
    if (EVAL(SUCCEEDED(m_pfd->WithHint(NULL, NULL, _SoftLinkDestCB, (LPVOID) &sldcbs, _punkSite, m_pff))))
    {
        EVAL(SUCCEEDED(CreateXboxPidlFromUrlPathAndPidl(pidlToSoftLink, m_pff->GetCWireEncoding(), wXboxPath, &pidlToDest)));
    }

    return pidlToDest;
}


// Someday maybe add: (SEE_MASK_UNICODE | SEE_MASK_FLAG_TITLE)
#define SEE_MASK_SHARED (SEE_MASK_FLAG_NO_UI | SEE_MASK_HOTKEY | SEE_MASK_NO_CONSOLE)

#define FILEATTRIB_DIRSOFTLINK (FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_REPARSE_POINT)

/*****************************************************************************\
    FUNCTION: _ApplyOne

    DESCRIPTION:
        This function will ShellExec() the pidl.  
        
    SECURITY ISSUES:
        We don't need to worry about the 'Open' verb on folders because that
    is always safe.  The 'Open' verb on files is safe because we later
    redirect the functionality to the original URLMON Xbox support which
    goes through code download.  This displays dialogs, checks certs, and
    does all the zones checking and admin policies.
\*****************************************************************************/
HRESULT CXboxMenu::_ApplyOne(CXboxMenu * pfcm, LPCMINVOKECOMMANDINFO pici, LPCTSTR pszCmd, LPCITEMIDLIST pidl)
{
    HRESULT hr;
    SHELLEXECUTEINFO sei;
    LPITEMIDLIST pidlFullPriv = pfcm->m_pff->CreateFullPrivatePidl(pidl);

    ZeroMemory(&sei, sizeof(sei));
    sei.cbSize = sizeof(sei);

    LPITEMIDLIST pidlFullPub = NULL;

    // TODO/BUGBUG: It would be nice to see if the pidl is a SoftLink (XboxPidl_IsSoftLink)
    //     and if so, step into the directory, get the directory path and then create
    //     a pidl from that path so we end up showing the user the real destination
    //     of the softlink.
    if (FILEATTRIB_DIRSOFTLINK == (FILEATTRIB_DIRSOFTLINK & XboxPidl_GetAttributes(pidlFullPriv)))
    {
        LPITEMIDLIST pidlNew = pfcm->GetSoftLinkDestination(pidlFullPriv);

        // Switch pidls if it worked, otherwise, using the original pidl isn't that bad, so it
        // will be the fall back case if things don't work out.
        if (pidlNew)
        {
            ILFree(pidlFullPriv);
            pidlFullPriv = pidlNew;
        }

        pidlFullPub = pfcm->m_pff->CreateFullPublicPidl(pidlFullPriv);
    }
    else
    {
        // Yes, so we need to use it in the pidl we pass to ShellExecute.
        pidlFullPub = ILCombine(pfcm->m_pff->GetPublicRootPidlReference(), pidl);
    }

    // Titles are excluded because there is no lpTitle in the sei.
    // Unicode is excluded because we don't do UNICODE; in fact,
    // we filter it out up front!
    ASSERT(SEE_MASK_FLAG_NO_UI == CMIC_MASK_FLAG_NO_UI);
    ASSERT(SEE_MASK_HOTKEY == CMIC_MASK_HOTKEY);
    ASSERT(SEE_MASK_NO_CONSOLE == CMIC_MASK_NO_CONSOLE);

    sei.fMask |= SEE_MASK_IDLIST | (pici->fMask & SEE_MASK_SHARED);
    sei.hwnd = pici->hwnd;
    sei.nShow = pici->nShow;
    sei.dwHotKey = pici->dwHotKey;
    sei.hIcon = pici->hIcon;
    sei.lpIDList = (void *) pidlFullPub;

    if (EVAL(sei.lpIDList))
    {
        TCHAR szParameters[MAX_URL_STRING];
        TCHAR szDirectory[MAX_PATH];

        if (pici->lpParameters)
            SHAnsiToTChar(pici->lpParameters, szParameters, ARRAYSIZE(szParameters));

        if (pici->lpDirectory)
            SHAnsiToTChar(pici->lpDirectory, szDirectory, ARRAYSIZE(szDirectory));

        sei.lpVerb = pszCmd;
        sei.lpParameters = (pici->lpParameters ? szParameters : NULL);
        sei.lpDirectory = (pici->lpDirectory ? szDirectory : NULL);
        if (EVAL(ShellExecuteEx(&sei)))
        {
            // Yes, so we need to use it in the pidl we pass to ShellExecute.
            LPITEMIDLIST pidlFullPubTarget = ILCombine(pfcm->m_pff->GetPublicTargetPidlReference(), pidl);

            if (pidlFullPubTarget)
            {
                EVAL(SUCCEEDED(pfcm->_AddToRecentDocs(pidlFullPubTarget)));        // We don't care if AddToRecent works or not.
                ILFree(pidlFullPubTarget);
                hr = S_OK;
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
        hr = E_OUTOFMEMORY;

    if (pidlFullPub)
        ILFree(pidlFullPub);

    if (pidlFullPriv)
        ILFree(pidlFullPriv);

    return hr;
}





/*****************************************************************************\
 *
 *    _InvokeOneCB
 *
 *    Invoke the command on the single pidl.
 *
\*****************************************************************************/

int CXboxMenu::_InvokeOneCB(LPVOID pvPidl, LPVOID pv)
{
    LPCITEMIDLIST pidl = (LPCITEMIDLIST) pvPidl;
    PEII peii = (PEII) pv;

    ASSERT(peii && peii->pfcm);
    return peii->pfcm->_InvokeOne(pidl, peii);
}

int CXboxMenu::_InvokeOne(LPCITEMIDLIST pidl, PEII peii)
{
    ASSERT(ILIsSimple(pidl));

    if (GetAsyncKeyState(VK_ESCAPE) >= 0)
    {
        if (EVAL(SUCCEEDED(peii->hres)))
            peii->hres = peii->pfn(peii->pfcm, peii->pici, peii->ptszCmd, pidl);
    }
    else
        peii->hres = HRESULT_FROM_WIN32(ERROR_CANCELLED);

    return SUCCEEDED(peii->hres);
}





/*****************************************************************************\
 *
 *    _EnumInvoke
 *
 * Invoke the command on each object in the list, assuming that
 * permissions are properly set.  (We need to check the permissions
 * in case somebody randomly threw the verb at us.)
 *
\*****************************************************************************/

STDMETHODIMP CXboxMenu::_EnumInvoke(LPCMINVOKECOMMANDINFO pici, INVOKEPROC pfn, LPCTSTR pszCmd)
{
    EII eii;
    eii.pfcm = this;
    eii.pici = pici;
    eii.pfn = pfn;
    eii.ptszCmd = pszCmd;
    eii.hres = S_OK;

    if (m_pflHfpl->GetCount())
        m_pflHfpl->Enum(_InvokeOneCB, (LPVOID) &eii);
    else
        _InvokeOne(c_pidlNil, &eii);

    return eii.hres;
}





/*****************************************************************************\
 *
 * _InvokeRename
 *
 * Rename the object to the indicated name.
 *
 *  The rename verb should have been enabled only if the pidl list
 *  is singleton.  Of course, that doesn't prevent some random bozo
 *  from throwing the word "rename" at us from out of the blue, so
 *  we need to remain on guard.
 *
 * _UNOBVIOUS_:  If the user does an in-place rename, we don't get
 *  a "rename" command invoked against our context menu.  Instead,
 *  the shell goes straight for the SetNameOf method in the ShellFolder.
 *  Which means that we cannot put UI in the context menu (which is the
 *  obvious place for it, because it has a CMIC_MASK_FLAG_NO_UI bit);
 *  we must put it into SetNameOf, which is annoying because it means
 *  there is no way to programmatically perform a SetNameOf without UI.
 *
 *  _SOMEDAY_
 *  We fix this unobvious-ness by passing the CMIC_MASK_FLAG_NO_UI bit
 *  through to our SetNameOf backdoor, so you can programmatically
 *  rename a file without UI by going through the IContextMenu.
 *
\*****************************************************************************/

HRESULT CXboxMenu::_InvokeRename(LPCMINVOKECOMMANDINFO pici)
{
    HRESULT hr;

    if (EVAL((m_sfgao & SFGAO_CANRENAME) && m_pfd))
    {
        ASSERT(m_pflHfpl->GetCount() == 1);
        if (EVAL(pici->lpParameters))
        {
            TCHAR szParams[MAX_URL_STRING];

            ASSERT(pici->hwnd);
            SHAnsiToTChar(pici->lpParameters, szParams, ARRAYSIZE(szParams));
            hr = m_pfd->SetNameOf(m_pff, pici->hwnd, m_pflHfpl->GetPidl(0), szParams, SHGDN_INFOLDER, 0);
        }
        else
            hr = E_INVALIDARG;    // Arguments required
    }
    else
        hr = E_ACCESSDENIED;        // Can't rename this

    return hr;
}


/*****************************************************************************\
 *    _InvokeCutCopy
 *
 *    Cut or copy the selection to the OLE clipboard.  No big deal.
 *
 *    Note that GetUIObjectOfHfpl(IID_IDataObject) will fail if we
 *    are talking about ourself.  Maybe it shouldn't but it does today.
\*****************************************************************************/
HRESULT CXboxMenu::_InvokeCutCopy(UINT_PTR id, LPCMINVOKECOMMANDINFO pici)
{
    IDataObject * pdo;
    HRESULT hr;

    hr = m_pff->GetUIObjectOfHfpl(pici->hwnd, m_pflHfpl, IID_IDataObject, (LPVOID *)&pdo, m_fBackground);
    if (EVAL(SUCCEEDED(hr)))
    {
        DWORD dwEffect = ((DFM_CMD_COPY == id) ? DROPEFFECT_COPY : DROPEFFECT_MOVE);

        EVAL(SUCCEEDED(DataObj_SetPreferredEffect(pdo, dwEffect)));

        ShellFolderView_SetPoints(m_hwnd, pdo);
        hr = OleSetClipboard(pdo);    // Will do its own AddRef
        ShellFolderView_SetClipboard(m_hwnd, id);
        
        if (pdo)
            pdo->Release();
    }
    else
        ASSERT(0);         // BUGBUG -- error UI 

    return hr;
}

/*****************************************************************************\
    FUNCTION: _DoDrop

    DESCRIPTION:
        The user just did a Paste on XBOX so we want to do the operation.
    We will use our Drag & Drop code to carry out the operation.  We don't
    currently support optimized XBOX operations but a lot could be done if
    we did.

    First we need to find out if the caller did "Cut" or "Copy" to create
    the IDataObject.  We can find out by asking the IDataObject for the
    CFSTR_PREFERREDDROPEFFECT.
\*****************************************************************************/
HRESULT CXboxMenu::_DoDrop(IDropTarget * pdt, IDataObject * pdo)
{
    POINTL pt = {0, 0};
    DWORD dwEffect = DROPEFFECT_COPY;   // Default
    HRESULT hr = DataObj_GetDWORD(pdo, g_dropTypes[DROP_PrefDe].cfFormat, &dwEffect);

#ifndef FEATURE_CUT_MOVE    
    dwEffect = DROPEFFECT_COPY;     // Forcibly remove the MOVE effect
#endif // FEATURE_CUT_MOVE

    hr = pdt->DragEnter(pdo, MK_LBUTTON, pt, &dwEffect);
    if (EVAL(SUCCEEDED(hr)) && dwEffect)
    {
#ifndef FEATURE_CUT_MOVE    
        dwEffect = DROPEFFECT_COPY;     // Forcibly remove the MOVE effect
#endif // FEATURE_CUT_MOVE
        hr = pdt->Drop(pdo, MK_LBUTTON, pt, &dwEffect);
    }
    else
        pdt->DragLeave();

    return hr;
}

/*****************************************************************************\
 *
 *    _InvokePaste
 *
 *    Copy from the OLE clipboard into the selcted folder (which might
 *    be ourselves).
 *
\*****************************************************************************/

HRESULT CXboxMenu::_InvokePaste(LPCMINVOKECOMMANDINFO pici)
{
    HRESULT hres = E_FAIL;

    if (EVAL(m_sfgao & SFGAO_DROPTARGET))
    {
        IDataObject *pdto;
        hres = OleGetClipboard(&pdto);
        if (EVAL(SUCCEEDED(hres)))
        {
            IDropTarget *pdt;
            hres = m_pff->GetUIObjectOfHfpl(pici->hwnd, m_pflHfpl, IID_IDropTarget, (LPVOID *)&pdt, m_fBackground);
            if (EVAL(SUCCEEDED(hres)))
            {
                hres = _DoDrop(pdt, pdto);
                if (pdt)
                    pdt->Release();
            }
            else
            {
                // BUGBUG -- error UI
            }
            if (pdto)
                pdto->Release();
        }
        else
        {
            // BUGBUG -- error UI
        }
    }
    else
    {
        // BUGBUG -- error UI
    }

    return hres;
}


//===========================
// *** IContextMenu Interface ***
//===========================


/*****************************************************************************\
    FUNCTION: _ContainsForgroundItems
  
    DESCRIPTION:
        We want to know if the user selected items in the view and then invoked
    some menu (Context Menu, File Menu, CaptionBar icon menu, etc.).  Normally
    this is as simple as seeing if (0 == m_pflHfpl->GetCount()).  However,
    there is one other nasty case where (1 == m_pflHfpl->GetCount()) and
    the user still didn't select anything.  This case happens when the user
    is at the root of a XBOX share and the CaptionBar menu is dropped down.
    In that case, the single pidl is the pidl to the xbox root.
\*****************************************************************************/
BOOL CXboxMenu::_ContainsForgroundItems(void)
{
    BOOL fIsForground = (0 != m_pflHfpl->GetCount());

    if (fIsForground && (1 == m_pflHfpl->GetCount()))
    {
        LPITEMIDLIST pidl = m_pflHfpl->GetPidl(0);

        if (XboxID_IsServerItemID(pidl) && ILIsEmpty(_ILNext(pidl)))
        {
            if (!m_pfd)
            {
                CXboxSite * pfs;

                // In this strange case, our m_pfd is NULL, so we need
                // to create it from pidl.
                if (EVAL(SUCCEEDED(SiteCache_PidlLookup(pidl, FALSE, m_pff->GetItemAllocatorDirect(), &pfs))))
                {
                    EVAL(SUCCEEDED(pfs->GetXboxDir(pidl, &m_pfd)));
                    pfs->Release();
                }
            }
            fIsForground = FALSE;
        }
    }

    return fIsForground;
}


BOOL CXboxMenu::_IsCallerCaptionBar(UINT indexMenu, UINT uFlags)
{
    BOOL fFromCaptionBar;

    if ((0 == uFlags) && (1 == indexMenu))
        fFromCaptionBar = TRUE;
    else
        fFromCaptionBar = FALSE;

    return fFromCaptionBar;
}


/*****************************************************************************\
    FUNCTION: IContextMenu::QueryContextMenu
  
    DESCRIPTION:
        Given an existing context menu hmenu, insert new context menu
    items at location indexMenu (indexMenu = index to menu indexMenu), returning the
    number of menu items added.

    The incoming flags control how much goop we add to the menu.
    It is important not to add "Delete", "Rename", etc., to context
    menus that come from shortcuts, else the user gets hit with
    two "Delete" verbs, one to delete the object from the XBOX site,
    and the other to delete the shortcut.  How confusing...

    hmenu     - destination menu
    indexMenu - location at which menu items should be inserted
    idCmdFirst - first available menu identifier
    idCmdLast - first unavailable menu identifier

    _UNDOCUMENTED_:  The "shared" menu items are not documented.
    Particularly gruesome, because the "shared" menu items are the
    only way to get Rename, Delete, etc. to work.  You can't roll
    your own, because those magics are handled partly in the
    enclosing shell view.

    _UNOBVIOUS_:  The context menu for the folder itself is
    extremely squirly.  It's not like a normal context menu.
    Rather, you add the "New" verb, and any custom verbs, but
    none of the standard folder verbs.

    PARAMS:
        Often, we need to key off strange parameter heiristicts to
    determine who our caller is so we don't enable certain items.
    "Rename" from the from CaptionBar is one example.  Here are what
    we are passed in the different situations:

    CaptionBar:
        QCM(hmenu, 1, idCmdFirst, idCmdLast, 0) m_pflHfpl contains 1
    FileMenu w/1 Selected:
        QCM(hmenu, 0, idCmdFirst, idCmdLast, CMF_DVFILE | CMF_NODEFAULT) m_pflHfpl contains 1
    0 Items Selected:
        QCM(hmenu, -1, idCmdFirst, idCmdLast, 0) m_pflHfpl contains 0
    1 Items Selected:
        QCM(hmenu, 0, idCmdFirst, idCmdLast, CMF_CANRENAME) m_pflHfpl contains 1
    2 Items Selected:
        QCM(hmenu, 0, idCmdFirst, idCmdLast, CMF_CANRENAME) m_pflHfpl contains 2
\*****************************************************************************/
HRESULT CXboxMenu::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    HRESULT hr = S_OK;

    //  HACK: I assume that they are querying during a WM_INITMENUPOPUP or equivelant
    GetCursorPos(&m_ptNewItem);
    m_uFlags = uFlags;

    if (!m_fBackground)
    {
        BOOL fAllFolders = m_pflHfpl->AreAllFolders();

        //  _UNDOCUMENTED_: CMF_DVFILE is not a documented flag.
        if (!(uFlags & (CMF_DVFILE | CMF_VERBSONLY)))
        {
            DWORD sfgao = m_sfgao;

            // We don't support Delete or Rename from the Caption Bar
            if (_IsCallerCaptionBar(indexMenu, uFlags))
                sfgao &= ~(SFGAO_CANDELETE | SFGAO_CANRENAME); // Clear these two.

            //  Not on the "File" menu, and not from a shortcut.
            //  Add the "Delete", "Rename", etc. stuff, then go
            //  enable/disable them as needed.
            AddToPopupMenu(hmenu, IDM_ITEMCONTEXT, IDM_M_SHAREDVERBS, indexMenu, idCmdFirst, idCmdLast, MM_ADDSEPARATOR);
            _RemoveContextMenuItems(hmenu, idCmdFirst, sfgao);
        }

        // Add Download if there is anything inside.
        // The assertion makes sure that idCmdLast is set properly.
        ASSERT(IDC_ITEM_DOWNLOAD > IDC_ITEM_OPEN);
        if (!_IsCallerCaptionBar(indexMenu, uFlags))
        {
            // Don't add "Copy To Folder" in the caption bar because it doesn't work for the root of
            // an xbox server.  We aren't going to support it in subdirectories.
            AddToPopupMenu(hmenu, IDM_ITEMCONTEXT, IDM_M_VERBS, indexMenu, idCmdFirst, idCmdLast, MM_ADDSEPARATOR);
        }
        
        if (!(uFlags & CMF_NODEFAULT))
            SetMenuDefaultItem(hmenu, IDC_ITEM_DOWNLOAD + idCmdFirst, MM_ADDSEPARATOR);

        AddToPopupMenu(hmenu, IDM_ITEMCONTEXT, (fAllFolders ? IDM_M_FOLDERVERBS : IDM_M_FILEVERBS), indexMenu, idCmdFirst, 
                        idCmdLast, (_IsCallerCaptionBar(indexMenu, uFlags) ? 0 : MM_ADDSEPARATOR));
        if (fAllFolders && (SHELL_VERSION_W95NT4 == GetShellVersion()))
        {
            // On shell32 v3 (Win95 & NT4) I remove the 'Explore' verb because the shell has bugs
            // that aren't fixable are easy to fix.
            EVAL(DeleteMenu(hmenu, (IDC_ITEM_EXPLORE + idCmdFirst), MF_BYCOMMAND));
            TraceMsg(TF_XBOXOPERATION, "QueryContextMenu() Removing 'Explorer' because it's shell v3");
            SetMenuDefaultItem(hmenu, idCmdFirst + IDC_ITEM_OPEN, 0);
        }
        else if (!(uFlags & CMF_NODEFAULT))
            SetMenuDefaultItem(hmenu, idCmdFirst + (((uFlags & CMF_EXPLORE) && fAllFolders)? IDC_ITEM_EXPLORE : IDC_ITEM_OPEN), 0);
    }
    else
    {                // Folder background menu
        AddToPopupMenu(hmenu, IDM_ITEMCONTEXT, IDM_M_BACKGROUNDVERBS, indexMenu, idCmdFirst, idCmdLast, MM_ADDSEPARATOR);
        // Did the menu come from the file menu?
        if (CMF_DVFILE == (CMF_DVFILE & uFlags))
        {
            // Yes, then we want to delete the "Properties" background menu item because one
            // was already merged in for the selected files.  The other Properties will
            // be there but grayed out if nothing was selected.
            EVAL(DeleteMenu(hmenu, (IDC_ITEM_BKGNDPROP + idCmdFirst), MF_BYCOMMAND));
        }

        MergeInToPopupMenu(hmenu, IDM_M_BACKGROUND_POPUPMERGE, indexMenu, idCmdFirst, idCmdLast, MM_ADDSEPARATOR);
    }

    if (EVAL(SUCCEEDED(hr)))
        hr = ResultFromShort(IDC_ITEM_MAX);

    _SHPrettyMenu(hmenu);
    return hr;
}

/*****************************************************************************\
 *
 *    IContextMenu::GetCommandString
 *
 *    Somebody wants to convert a command id into a string of some sort.
 *
\*****************************************************************************/

HRESULT CXboxMenu::GetCommandString(UINT_PTR idCmd, UINT uFlags, UINT *pwRsv, LPSTR pszName, UINT cchMax)
{
    HRESULT hr = E_FAIL;
    BOOL fUnicode = FALSE;

    if (idCmd < IDC_ITEM_MAX)
    {
        switch (uFlags)
        {
        case GCS_HELPTEXTW:
            fUnicode = TRUE;
            // Fall thru...
        case GCS_HELPTEXTA:
            GetHelpText:
            if (EVAL(cchMax))
            {
                BOOL fResult;
                pszName[0] = '\0';
                 
                if (fUnicode)
                    fResult = LoadStringW(HINST_THISDLL, IDS_ITEM_HELP((UINT)idCmd), (LPWSTR)pszName, cchMax);
                else
                    fResult = LoadStringA(HINST_THISDLL, IDS_ITEM_HELP((UINT)idCmd), pszName, cchMax);
                if (EVAL(fResult))
                    hr = S_OK;
                else
                    hr = E_INVALIDARG;
            }
            else
                hr = E_INVALIDARG;
        break;

        case GCS_VALIDATEW:
        case GCS_VALIDATEA:
            hr = S_OK;
            break;

        case GCS_VERBW:
            fUnicode = TRUE;
            // Fall thru...
        case GCS_VERBA:
        {
            int ivi;
            for (ivi = 0; ivi < IVI_MAX; ivi++)
            {
                if (c_rgvi[ivi].idc == idCmd)
                {
                    if (fUnicode)
                        SHTCharToUnicode(c_rgvi[ivi].ptszCmd, (LPWSTR)pszName, cchMax);
                    else
                        SHTCharToAnsi(c_rgvi[ivi].ptszCmd, pszName, cchMax);

                    hr = S_OK;
                    break;
                }
            }

            if (!EVAL(ivi < IVI_MAX))
                hr = E_INVALIDARG;
            break;
        }

        default:
            hr = E_NOTIMPL;
            break;
        }
    }
    else
    {
        //  _UNOBVIOUS_:  Another place where PASTE rears its ugly head.
        //  We must generate the help text for it ourselves, even though
        //  the menu item "sort of" belongs to the shell.
        if ((idCmd == SHARED_EDIT_PASTE) &&
            ((uFlags == GCS_HELPTEXTW) || (uFlags == GCS_HELPTEXTA)))
        {
            goto GetHelpText;
        }

        hr = E_INVALIDARG;
    }

    return hr;
}


HRESULT UpdateDeleteProgressStr(IProgressDialog * ppd, LPCTSTR pszFileName)
{
    HRESULT hr = E_FAIL;
    TCHAR szTemplate[MAX_PATH];

    if (EVAL(LoadString(HINST_THISDLL, IDS_DELETING, szTemplate, ARRAYSIZE(szTemplate))))
    {
        TCHAR szStatusStr[MAX_PATH];
        WCHAR wzStatusStr[MAX_PATH];

        wnsprintf(szStatusStr, ARRAYSIZE(szStatusStr), szTemplate, pszFileName);
        SHTCharToUnicode(szStatusStr, wzStatusStr, ARRAYSIZE(wzStatusStr));
        EVAL(SUCCEEDED(hr = ppd->SetLine(2, wzStatusStr, FALSE, NULL)));
    }

    return hr;
}


HRESULT XboxChangeNotifyDirPatch(HWND hwnd, LONG wEventId, CXboxFolder * pff, LPCITEMIDLIST pidlFull, LPCITEMIDLIST pidl2, BOOL fTopLevel)
{
    HRESULT hr = S_OK;
    LPITEMIDLIST pidlParent = ILClone(pidlFull);

    if (pidlParent)
    {
        ILRemoveLastID(pidlParent);
        CXboxDir * pfd = pff->GetXboxDirFromPidl(pidlParent);
    
        if (pfd)
        {
            XboxChangeNotify(hwnd, wEventId, pff, pfd, ILFindLastID(pidlFull), pidl2, fTopLevel);
            pfd->Release();
        }

        ILFree(pidlParent);
    }

    return hr;
}


// The following struct is used when recursively downloading
// files/dirs from the XBOX server after a "Download" verb.
typedef struct tagDELETESTRUCT
{
    LPCITEMIDLIST           pidlRoot;          // Base URL of the Download Source
    CXboxFolder *            pff;               // Allocator to create temp pidls.
    IMalloc *               pm;                // Allocator to create temp pidls.
    LPCMINVOKECOMMANDINFO   pdoi;              // Our call.
    HWND                    hwnd;              // HWND for UI
    CStatusBar *            psb;               // Used to display info during the delete
    IProgressDialog *       ppd;               // Used to display progress during the delete.
    DWORD                   dwTotalFiles;      // How many files are there to delete total.
    DWORD                   dwDeletedFiles;    // How many files have already been deleted.
    BOOL                    fInDeletePass;     // Are we in the 'Count Files to Delete' or 'Delete Files' pass?
} DELETESTRUCT;

/*****************************************************************************\
     FUNCTION: DeleteItemCB
 
    DESCRIPTION:
        This function will download the specified item and it's contents if it
    is a directory.
\*****************************************************************************/
HRESULT _DeleteItemPrep(HINTERNET hint, LPCITEMIDLIST pidlFull, BOOL fIsTopLevel, DELETESTRUCT * pDelete)
{
    HRESULT hr = S_OK;

    if (pDelete->ppd && pDelete->ppd->HasUserCancelled())
        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);

    if (SUCCEEDED(hr))  // May have been cancelled
    {
        DWORD dwError = 0;

        if (pDelete->fInDeletePass && pDelete->psb)
            pDelete->psb->SetStatusMessage(IDS_DELETING, XboxPidl_GetLastFileDisplayName(pidlFull));

        if (pDelete->fInDeletePass && pDelete->ppd)
            EVAL(SUCCEEDED(UpdateDeleteProgressStr(pDelete->ppd, XboxPidl_GetLastFileDisplayName(pidlFull))));

        // Is this a dir/folder that we need to recurse into? OR
        // Is this a SoftLink?
        if ((FILE_ATTRIBUTE_DIRECTORY & XboxPidl_GetAttributes(pidlFull)) ||
            (0 == XboxPidl_GetAttributes(pidlFull)))
        {
            // This is the head of the recursion.  We will do nothing now and we will
            // wait to delete the dir in the recursion tail because we need to wait
            // until all the files are gone.

            // Don't delete softlinks because of the recursion problem.
        }
        else
        {
            if (pDelete->fInDeletePass)
            {
                if (pDelete->ppd)
                    EVAL(SUCCEEDED(pDelete->ppd->SetProgress(pDelete->dwDeletedFiles, pDelete->dwTotalFiles)));

                // Contemplate adding a callback function in order to feed the status bar.
                hr = XboxDeleteFileWrap(hint, TRUE, XboxPidl_GetLastItemWireName(pidlFull));
                if (FAILED(hr))
                {
                    // We need to display the error now while the extended error info is still valid.
                    // This is because as we walk out of the resursive call, we will be calling
                    // XboxSetCurrentDirectory() which will wipe clean the extended error msg.
                    if (FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr))
                    {
                        DisplayWininetError(pDelete->hwnd, TRUE, HRESULT_CODE(hr), IDS_XBOXERR_TITLE_ERROR, IDS_XBOXERR_DELETE, IDS_XBOXERR_WININET, MB_OK, pDelete->ppd);
                        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);  // Wrong permissions
                    }
                }
                else
                    XboxChangeNotifyDirPatch(pDelete->hwnd, SHCNE_DELETE, pDelete->pff, pidlFull, NULL, fIsTopLevel);

                pDelete->dwDeletedFiles++;
                TraceMsg(TF_XBOXOPERATION, "DeleteItemCB() XboxDeleteFileA() returned dwError=%#08lx.  File=%s", dwError, XboxPidl_GetLastFileDisplayName(pidlFull));
            }
            else
                pDelete->dwTotalFiles++;
        }
    }

    return hr;
}

HRESULT _DeleteItemCleanUp(HRESULT hr, DELETESTRUCT * pDelete)
{
    if (pDelete->ppd && pDelete->ppd->HasUserCancelled())
        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);

    if (pDelete->fInDeletePass) // Only display errors and fire ChangeNotify if in Delete pass.
    {
        if ((FAILED(hr)) && (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr))
        {
            int nResult = DisplayWininetError(pDelete->hwnd, TRUE, HRESULT_CODE(hr), IDS_XBOXERR_TITLE_ERROR, IDS_XBOXERR_DELETE, IDS_XBOXERR_WININET, MB_OK, pDelete->ppd);
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);   // Don't display any more error dialogs.
        }
    }

    return hr;
}


HRESULT XboxRemoveDirectoryWithCN(HWND hwnd, HINTERNET hint, CXboxFolder * pff, LPCITEMIDLIST pidlFull, BOOL fIsTopLevel)
{
    HRESULT hr = S_OK;

    hr = XboxRemoveDirectoryWrap(hint, TRUE, XboxPidl_GetLastItemWireName(pidlFull));
    if (SUCCEEDED(hr))
    {
        hr = XboxChangeNotifyDirPatch(hwnd, SHCNE_RMDIR, pff, pidlFull, NULL, fIsTopLevel);
        TraceMsg(TF_WININET_DEBUG, "XboxRemoveDirectoryWithCN() XboxRemoveDirectory(%hs) returned %#08lx", XboxPidl_GetLastItemWireName(pidlFull), hr);
    }

    return hr;
}


INT ILCountItemIDs(LPCITEMIDLIST pidl)
{
    INT nCount = 0;

    if (pidl)
    {
        while (!ILIsEmpty(pidl))
        {
            pidl = _ILNext(pidl);
            nCount++;
        }
    }

    return nCount;
}


/*****************************************************************************\
     FUNCTION: _IsTopLevel
 
    DESCRIPTION:
\*****************************************************************************/
BOOL _IsTopLevel(LPCITEMIDLIST pidlRoot, LPCITEMIDLIST pidlCurrent)
{
    INT nRoot = ILCountItemIDs(pidlRoot);
    INT nCurrent = ILCountItemIDs(pidlCurrent);

    // It is the root if nCurrent has no more than 1 more than nRoot
    return (((nRoot + 1) >= nCurrent) ? TRUE : FALSE);
}


/*****************************************************************************\
     FUNCTION: DeleteItemCB
 
    DESCRIPTION:
        This function will download the specified item and it's contents if it
    is a directory.  Since this is in the line of recursion, we need to have the
    stack be as small as possible.  Therefore, we call _DeleteItemPrep() to use
    as much stack as needed to do the majority of the work and the clean up the
    stack before we do the recursion.  The only information we need from it is
    pszUrlPath which we put on the stack and heap and clean up our selves.
\*****************************************************************************/
HRESULT DeleteItemCB(LPVOID pvFuncCB, HINTERNET hint, LPCITEMIDLIST pidlFull, BOOL * pfValidhinst, LPVOID pvData)
{
    DELETESTRUCT * pDelete = (DELETESTRUCT *) pvData;
    BOOL fIsTopLevel = _IsTopLevel(pDelete->pidlRoot, pidlFull);
    HRESULT hr = _DeleteItemPrep(hint, pidlFull, fIsTopLevel, pDelete);

    if (SUCCEEDED(hr) && (FILE_ATTRIBUTE_DIRECTORY & XboxPidl_GetAttributes(pidlFull)))
    {
        hr = EnumFolder((LPFNPROCESSITEMCB) pvFuncCB, hint, pidlFull, pDelete->pff->GetCWireEncoding(), pfValidhinst, pvData);
        if (SUCCEEDED(hr))
        {
            if (pDelete->fInDeletePass)
            {
                hr = XboxRemoveDirectoryWithCN(pDelete->hwnd, hint, pDelete->pff, pidlFull, fIsTopLevel);
//                TraceMsg(TF_XBOXOPERATION, "DeleteItemCB() XboxRemoveDirectoryA() returned hr=%#08lx.", hr);
                pDelete->dwDeletedFiles++;
            }
            else
                pDelete->dwTotalFiles++;
        }
    }

    hr = _DeleteItemCleanUp(hr, pDelete);
    return hr;
}



/*****************************************************************************\
    FUNCTION: _InvokeLoginAsVerb

    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxMenu::_InvokeLoginAsVerb(LPCMINVOKECOMMANDINFO pici)
{
    HRESULT hr = E_FAIL;

    if (EVAL(m_pfd))
        hr = LoginAs(pici->hwnd, m_pff, m_pfd, _punkSite);

    return hr;
}



/*****************************************************************************\
    FUNCTION: _InvokeNewFolderVerb

    DESCRIPTION:
        The user just selected "New Folder", so we need to create a new folder.
\*****************************************************************************/
HRESULT CXboxMenu::_InvokeNewFolderVerb(LPCMINVOKECOMMANDINFO pici)
{
    HRESULT hr = E_FAIL;

    if (m_pfd)
        hr = CreateNewFolder(m_hwnd, m_pff, m_pfd, _punkSite, (m_uFlags & CMF_DVFILE), m_ptNewItem);

    return hr;
}


/*****************************************************************************\
    FUNCTION: _InvokeDeleteVerb

    DESCRIPTION:
        The user just selected file(s) and/or folder(s) and selected the
    "download" verb.  We need to:
    1. Display UI to ask the user for the destination directory.
    2. Download each item (pidl) into that directory.
\*****************************************************************************/
HRESULT CXboxMenu::_InvokeDeleteVerb(LPCMINVOKECOMMANDINFO pici)
{
    HRESULT hr = S_OK;

    if (EVAL(m_pfd))
    {
        if (m_sfgao & SFGAO_CANDELETE)
        {
            if (!(pici->fMask & CMIC_MASK_FLAG_NO_UI))
            {
                ASSERT(pici->hwnd);
                switch (XboxConfirmDeleteDialog(ChooseWindow(pici->hwnd, m_hwnd), m_pflHfpl, m_pff))
                {
                case IDC_REPLACE_YES:
                    hr = S_OK;
                    break;

                default:                
                    // FALLTHROUGH
                case IDC_REPLACE_CANCEL:
                    hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);       // Cancel all copies.
                    break;

                case IDC_REPLACE_NO:
                    hr = S_FALSE;
                    break;
                }
            }
            else
                hr = S_OK;

            if (hr == S_OK)
            {
                CStatusBar * psb = _GetStatusBar();
                IProgressDialog * ppd = CProgressDialog_CreateInstance(IDS_DELETE_TITLE, IDA_XBOXDELETE);
                LPITEMIDLIST pidlRoot = ILClone(m_pfd->GetPidlReference());
                DELETESTRUCT delStruct = {pidlRoot, m_pff, m_pff->m_pm, pici, ChooseWindow(pici->hwnd, m_hwnd), psb, ppd, 0, 0, FALSE};

                if (EVAL(SUCCEEDED(hr)))
                {
                    HINTERNET hint;

                    m_pfd->GetHint(NULL, NULL, &hint, _punkSite, m_pff);
                    if (EVAL(hint))
                    {
                        HCURSOR hCursorOld = SetCursor(LoadCursor(NULL, IDC_WAIT));

                        if (EVAL(ppd))
                        {
                            WCHAR wzProgressDialogStr[MAX_PATH];
                            HWND hwndParent = NULL;

                            // BUGBUG: DefView (defview.cpp CDefView::QueryInterface()) doesn't support IOleWindow so our
                            //         progress dialog isn't correctly parented.

                            // If the caller was nice enough to SetSite() with their punk, I will be nice enough to make
                            // their window may progress dialog's parent window.
                            IUnknown_GetWindow(_punkSite, &hwndParent);
                            if (!hwndParent)
                                hwndParent = m_hwnd;

                            // Normally we always want UI, but in one case we don't.  If the
                            // user does a DROPEFFECT_MOVE, it really is a DROPEFFECT_COPY
                            // and then a IContextMenu::InvokeCommand(SZ_VERB_DELETEA).
                            // The progress was done in the copy thread and isn't needed
                            // in the delete thread.
//                            ASSERT(hwndParent);

                            // We give a NULL punkEnableModless because we don't want to go modal.
                            EVAL(SUCCEEDED(ppd->StartProgressDialog(hwndParent, NULL, PROGDLG_AUTOTIME, NULL)));
                            // Tell the user we are calculating how long it will take.
                            if (EVAL(LoadStringW(HINST_THISDLL, IDS_PROGRESS_DELETETIMECALC, wzProgressDialogStr, ARRAYSIZE(wzProgressDialogStr))))
                                EVAL(SUCCEEDED(ppd->SetLine(2, wzProgressDialogStr, FALSE, NULL)));
                        }

                        // Tell the user we are calculating how long it will take.
                        hr = m_pflHfpl->RecursiveEnum(pidlRoot, DeleteItemCB, hint, (LPVOID) &delStruct);
                        if (ppd)
                        {
                            // Reset because RecursiveEnum(DeleteItemCB) can take a long time and the estimated time
                            // is based on the time between ::StartProgressDialog() and the first
                            // ::SetProgress() call.
                            EVAL(SUCCEEDED(ppd->Timer(PDTIMER_RESET, NULL)));
                        }

                        delStruct.fInDeletePass = TRUE;
                        if (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr)  // This is the only error we care about.
                        {
                            m_pflHfpl->UseCachedDirListings(TRUE);    // Get the perf advantage now because we just updated the cache a few lines up.
                            hr = m_pflHfpl->RecursiveEnum(pidlRoot, DeleteItemCB, hint, (LPVOID) &delStruct);
                        }

                        if (FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr))
                        {
                            DisplayWininetError(pici->hwnd, TRUE, HRESULT_CODE(hr), IDS_XBOXERR_TITLE_ERROR, IDS_XBOXERR_DELETE, IDS_XBOXERR_WININET, MB_OK, ppd);
                            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);  // Wrong permissions
                        }

                        if (psb)
                            psb->SetStatusMessage(IDS_EMPTY, NULL);
                        if (ppd)
                        {
                            ppd->StopProgressDialog();
                            ppd->Release();
                        }

                        ILFree(pidlRoot);
                        SetCursor(hCursorOld);  // Restore old cursor.
                    }

                    m_pfd->ReleaseHint(hint);
                }
            }
        }
        else
        {
            DisplayWininetError(pici->hwnd, TRUE, ResultFromScode(E_ACCESSDENIED), IDS_XBOXERR_TITLE_ERROR, IDS_XBOXERR_DELETE, IDS_XBOXERR_WININET, MB_OK, NULL);
            hr = E_ACCESSDENIED;  // Wrong permissions
        }
    }

    return hr;
}




/*****************************************************************************\
    FUNCTION: _GetStatusBar

    DESCRIPTION:
\*****************************************************************************/
CStatusBar * CXboxMenu::_GetStatusBar(void)
{
    return GetCStatusBarFromDefViewSite(_punkSite);
}


/*****************************************************************************\
     FUNCTION: FileSizeCountItemCB
 
    DESCRIPTION:
        This function will download the specified item and it's contents if it
    is a directory.
\*****************************************************************************/
HRESULT FileSizeCountItemCB(LPVOID pvFuncCB, HINTERNET hint, LPCITEMIDLIST pidlFull, BOOL * pfValidhinst, LPVOID pvData)
{
    PROGRESSINFO * pProgInfo = (PROGRESSINFO *) pvData;
    HRESULT hr = S_OK;

    if (pProgInfo->ppd && pProgInfo->ppd->HasUserCancelled())
        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);

    if (SUCCEEDED(hr))
    {
        // Is this a dir/folder that we need to recurse into?
        if (FILE_ATTRIBUTE_DIRECTORY & XboxPidl_GetAttributes(pidlFull))
            hr = EnumFolder((LPFNPROCESSITEMCB) pvFuncCB, hint, pidlFull, NULL, pfValidhinst, pvData);
        else
            pProgInfo->uliBytesTotal.QuadPart += XboxPidl_GetFileSize(pidlFull);
    }

    return hr;
}


HRESULT UpdateDownloadProgress(PROGRESSINFO * pProgInfo, LPCITEMIDLIST pidlFull, LPCWSTR pwzTo, LPCWSTR pwzFileName)
{
    HRESULT hr;
    WCHAR wzTemplate[MAX_PATH];
    WCHAR wzStatusText[MAX_PATH];
    WCHAR wzFrom[MAX_PATH];
    LPITEMIDLIST pidlParent = ILClone(pidlFull);

    if (pidlParent)
    {
        ILRemoveLastID(pidlParent);
        XboxPidl_GetDisplayName(pidlParent, wzFrom, ARRAYSIZE(wzFrom));
        ILFree(pidlParent);
    }

    // Give the directories some weight because the user may be copying tons of empty directories.
    EVAL(SUCCEEDED(pProgInfo->ppd->SetProgress64(pProgInfo->uliBytesCompleted.QuadPart, pProgInfo->uliBytesTotal.QuadPart)));

    // Generate the string "Downloading <FileName>..." status string
    EVAL(LoadStringW(HINST_THISDLL, IDS_DOWNLOADING, wzTemplate, ARRAYSIZE(wzTemplate)));
    wnsprintfW(wzStatusText, ARRAYSIZE(wzStatusText), wzTemplate, pwzFileName);
    EVAL(SUCCEEDED(pProgInfo->ppd->SetLine(1, wzStatusText, FALSE, NULL)));

    // Generate the string "From <SrcXboxUrlDir> to <DestFileDir>" status string
    if (EVAL(SUCCEEDED(hr = CreateFromToStr(wzStatusText, ARRAYSIZE(wzStatusText), wzFrom, pwzTo))))
        EVAL(SUCCEEDED(hr = pProgInfo->ppd->SetLine(2, wzStatusText, FALSE, NULL)));    // Line one is the file being copied.

    return hr;
}


/*****************************************************************************\
    ConfirmDownloadReplace

    Callback procedure that checks if this file really ought to be
    copied.

    Returns S_OK if the file should be copied.
    Returns S_FALSE if the file should not be copied.

    - If the user cancelled, then say S_FALSE from now on.
    - If the user said Yes to All, then say S_OK.
    - If there is no conflict, then say S_OK.
    - If the user said No to All, then say S_FALSE.
    - Else, ask the user what to do.

    Note that the order of the tests above means that if you say
    "Yes to All", then we don't waste our time doing overwrite checks.

    _GROSS_:  NOTE! that we don't try to uniquify the name, because
    WinINet doesn't support the STOU (store unique) command, and
    there is no way to know what filenames are valid on the server.
\*****************************************************************************/
HRESULT ConfirmDownloadReplace(LPCWSTR pwzDestPath, LPCITEMIDLIST pidlSrcXbox, OPS * pOps, HWND hwnd, CXboxFolder * pff, CXboxDir * pfd, int nObjs, BOOL * pfDeleteRequired)
{
    HRESULT hr = S_OK;

    ASSERT(hwnd);
    *pfDeleteRequired = FALSE;
    if (*pOps == opsCancel)
        hr = S_FALSE;
    else if (*pOps == opsYesToAll)
    {
        *pfDeleteRequired = PathFileExistsW(pwzDestPath);
        hr = S_OK;
    }
    else 
    {
        if (PathFileExistsW(pwzDestPath))
        {
            // It exists, so worry.
            if (*pOps == opsNoToAll)
                hr = S_FALSE;
            else
            {
                XBOX_FIND_DATA wfdSrc;
                WIN32_FIND_DATA wfdDest;
                HANDLE hfindDest;
                FILETIME ftUTC;

                *pfDeleteRequired = TRUE;
                hfindDest = FindFirstFileW(pwzDestPath, &wfdDest);

                ftUTC = wfdDest.ftLastWriteTime;
                FileTimeToLocalFileTime(&ftUTC, &wfdDest.ftLastWriteTime);   // UTC->LocalTime
                EVAL(S_OK == Win32FindDataFromPidl(pidlSrcXbox, (LPWIN32_FIND_DATA)&wfdSrc, FALSE, FALSE));
                if (EVAL(hfindDest != INVALID_HANDLE_VALUE))
                {
                    // BUGBUG/TODO: Do we need to set modal?
                    switch (XboxConfirmReplaceDialog(hwnd, &wfdSrc, &wfdDest, nObjs, pff))
                    {
                    case IDC_REPLACE_YESTOALL:
                        *pOps = opsYesToAll;
                        // FALLTHROUGH

                    case IDC_REPLACE_YES:
                        hr = S_OK;
                        break;

                    case IDC_REPLACE_NOTOALL:
                        *pOps = opsNoToAll;
                        // FALLTHROUGH

                    case IDC_REPLACE_NO:
                        hr = S_FALSE;
                        break;

                    default:
                        ASSERT(0);        // Huh?
                        // FALLTHROUGH

                    case IDC_REPLACE_CANCEL:
                        *pOps = opsCancel;
                        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                        break;
                    }
                    FindClose(hfindDest);
                }
            }
        }
    }

    return hr;
}


// The following struct is used when recursively downloading
// files/dirs from the XBOX server after a "Download" verb.
typedef struct tagDOWNLOADSTRUCT
{
    LPCWSTR             pwzDestRootPath;    // Dir on FileSys of the Download Destination
    LPCITEMIDLIST       pidlRoot;           // Base URL of the Download Source
    DWORD               dwInternetFlags;    // Binary, ASCII, AutoDetect?
    HWND                hwndParent;         // hwnd for Confirm UI
    OPS                 ops;                // Do we cancel?
    CXboxFolder *        pff;
    CXboxDir *           pfd;

    // Progress
    PROGRESSINFO        progInfo;
} DOWNLOADSTRUCT;


/*****************************************************************************\
     FUNCTION: _CalcDestName
 
    DESCRIPTION:
        This recursive function starts at pwzDestDir as the dest FS path and
    pidlRoot as the src xbox path.  We need to construct pwzDestPath which
    is the current path.  This will be done by adding the relative path
    (pidlFull - pidlRoot) to pwzDestDir.  pidlFull can point to either a file
    or a directory.
 
    PARAMETERS: (Example. "C:\dir1\dir2\dir3\file.txt")
         pwzDestParentPath: "C:\dir1\dir2\dir3"
         pwzDestDir: "C:\dir1\dir2\dir3\file.txt"
         pwzDestFileName: "file.txt"

    Example. "C:\dir1\dir2\dir3\"
         pwzDestParentPath: "C:\dir1\dir2"
         pwzDestDir: "C:\dir1\dir2\dir3"
         pwzDestFileName: "dir3"
\*****************************************************************************/
HRESULT _CalcDestName(LPCWSTR pwzDestDir, LPCITEMIDLIST pidlRoot, LPCITEMIDLIST pidlFull, LPWSTR pwzDestParentPath, DWORD cchDestParentPathSize,
                      LPWSTR pwzDestPath, DWORD cchDestPathSize, LPWSTR pwzDestFileName, DWORD cchDestFileNameSize)
{
    HRESULT hr = S_OK;
    WCHAR wzXboxPathTemp[MAX_PATH];
    WCHAR wzFSPathTemp[MAX_PATH];
    LPITEMIDLIST pidlRootIterate = (LPITEMIDLIST) pidlRoot;    // I promise to iterate only
    LPITEMIDLIST pidlFullIterate = (LPITEMIDLIST) pidlFull;    // I promise to iterate only

    // This one is easy.
    StrCpyNW(pwzDestFileName, XboxPidl_GetLastFileDisplayName(pidlFull), cchDestFileNameSize);  // The dest filename is easy.

    // Let's find the relative path between pidlRoot and pidlFull.
    while (!ILIsEmpty(pidlRootIterate) && !ILIsEmpty(pidlFullIterate) && XboxItemID_IsEqual(pidlRootIterate, pidlFullIterate))
    {
        pidlFullIterate = _ILNext(pidlFullIterate);
        pidlRootIterate = _ILNext(pidlRootIterate);
    }

    ASSERT(ILIsEmpty(pidlRootIterate) && !ILIsEmpty(pidlFullIterate));  // Asure pidlFull is a superset of pidlRoot
    LPITEMIDLIST pidlParent = ILClone(pidlFullIterate);

    if (pidlParent)
    {
        ILRemoveLastID(pidlParent); // Remove the item that will be created (file or dir)

        GetDisplayPathFromPidl(pidlParent, wzXboxPathTemp, ARRAYSIZE(wzXboxPathTemp), TRUE);   // Full path w/o last item.
        StrCpyNW(pwzDestParentPath, pwzDestDir, cchDestParentPathSize);  // Put the base dest.
        UrlPathToFilePath(wzXboxPathTemp, wzFSPathTemp, ARRAYSIZE(wzFSPathTemp));
        if (!PathAppendW(pwzDestParentPath, wzFSPathTemp))
            hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);    // Path too long, probably.

        ILFree(pidlParent);
    }

    if (SUCCEEDED(hr))
    {
        GetDisplayPathFromPidl(pidlFullIterate, wzXboxPathTemp, ARRAYSIZE(wzFSPathTemp), FALSE);   // Full Path including item.
        StrCpyNW(pwzDestPath, pwzDestDir, cchDestParentPathSize);  // Put the base dest.
        UrlPathToFilePath(wzXboxPathTemp, wzFSPathTemp, ARRAYSIZE(wzFSPathTemp));
        if (!PathAppendW(pwzDestPath, wzFSPathTemp))
            hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);    // Path too long, probably.
    }

    return hr;
}


// This defines the size of a directory measured by the amount of time it would take compared to a file.
#define VIRTUAL_DIR_SIZE        1000        // about 1k.

/*****************************************************************************\
     FUNCTION: DownloadItemStackPig
 
    DESCRIPTION:
        This function will download the specified item and it's contents if it
    is a directory.
\*****************************************************************************/
HRESULT DownloadItemStackPig(HINTERNET hint, LPCITEMIDLIST pidlFull, BOOL * pfValidhinst, DOWNLOADSTRUCT * pDownLoad, CXboxDir ** ppfd)
{
    HRESULT hr;
    WCHAR wzDestParentPath[MAX_PATH];       // If item is "C:\dir1\dir2copy\", the this is "C:\dir1"
    WCHAR wzDestPath[MAX_PATH];             // This is "C:\dir1\dir2copy\"
    WCHAR wzDestFileName[MAX_PATH];         // This is "dir2copy"

    hr = _CalcDestName(pDownLoad->pwzDestRootPath, pDownLoad->pidlRoot, pidlFull, wzDestParentPath, ARRAYSIZE(wzDestParentPath), wzDestPath, ARRAYSIZE(wzDestPath), wzDestFileName, ARRAYSIZE(wzDestFileName));
    if (SUCCEEDED(hr))
    {
        if (pDownLoad->progInfo.ppd)
            EVAL(SUCCEEDED(UpdateDownloadProgress(&(pDownLoad->progInfo), pidlFull, wzDestParentPath, wzDestFileName)));

        if (pDownLoad->progInfo.ppd && pDownLoad->progInfo.ppd->HasUserCancelled())
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
        else
        {
            // Is this a dir/folder that we need to recurse into?
            if (FILE_ATTRIBUTE_DIRECTORY & XboxPidl_GetAttributes(pidlFull))
            {
                // Yes, so let's go...

                if (EVAL((PathFileExistsW(wzDestPath) && PathIsDirectoryW(wzDestPath)) ||
                            CreateDirectoryW(wzDestPath, NULL)))
                {
                    EVAL(SetFileAttributes(wzDestPath, XboxPidl_GetAttributes(pidlFull)));
                    hr = pDownLoad->pfd->GetXboxSite()->GetXboxDir(pidlFull, ppfd);
                    if (!EVAL(SUCCEEDED(hr)))
                        TraceMsg(TF_ERROR, "DownloadItemStackPig() GetXboxDir failed hr=%#08lx", hr);
                }
                else
                {
                    hr = E_FAIL;
                    TraceMsg(TF_ERROR, "DownloadItemStackPig() CreateDirectory or PathFileExists failed hr=%#08lx", hr);
                }
            }
            else
            {
                BOOL fDeleteRequired;
                ULARGE_INTEGER uliFileSize;

                pDownLoad->progInfo.dwCompletedInCurFile = 0;
                pDownLoad->progInfo.dwLastDisplayed = 0;

                hr = ConfirmDownloadReplace(wzDestPath, pidlFull, &(pDownLoad->ops), GetProgressHWnd(pDownLoad->progInfo.ppd, pDownLoad->hwndParent), pDownLoad->pff, pDownLoad->pfd, 1, &fDeleteRequired);
                if (S_OK == hr)
                {
                    if (fDeleteRequired)
                    {
                        if (!DeleteFileW(wzDestPath))
                            hr = HRESULT_FROM_WIN32(GetLastError());
                    }

                    // Don't copy the file if it's a SoftLink because of the possible
                    // recursion case.
                    if (EVAL(SUCCEEDED(hr)) && (0 != XboxPidl_GetAttributes(pidlFull)))
                    {
                        // Contemplate adding a callback function in order to feed the status bar.
                        hr = XboxGetFileExPidlWrap(hint, TRUE, pidlFull, wzDestPath, TRUE, XboxPidl_GetAttributes(pidlFull), pDownLoad->dwInternetFlags, (DWORD_PTR)&(pDownLoad->progInfo));
                        if (FAILED(hr))
                        {
                            if (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr)
                            {
                                // We need to display the error now while the extended error info is still valid.
                                // This is because as we walk out of the resursive call, we will be calling
                                // XboxSetCurrentDirectory() which will wipe clean the extended error msg.
                                DisplayWininetError(pDownLoad->hwndParent, TRUE, HRESULT_CODE(hr), IDS_XBOXERR_TITLE_ERROR, IDS_XBOXERR_DOWNLOADING, IDS_XBOXERR_WININET, MB_OK, pDownLoad->progInfo.ppd);
                                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);   // Don't display any more error dialogs.
                            }
                        }
                        else
                        {
                            // The docs imply that (FILE_SHARE_READ | FILE_SHARE_WRITE) means that other callers need both, but
                            // I want them to be able to use either.
                            HANDLE hFile = CreateFileW(wzDestPath, GENERIC_WRITE, (FILE_SHARE_READ | FILE_SHARE_WRITE), NULL, OPEN_EXISTING, XboxPidl_GetAttributes(pidlFull), NULL);

                            // XboxGetFile() won't set the time/date correctly, so we will.
                            if (EVAL(INVALID_HANDLE_VALUE != hFile))
                            {
                                FILETIME ftLastWriteTime = XboxPidl_GetFileTime(ILFindLastID(pidlFull));

                                // Since the file time on the disk is stored in a time zone independent way (UTC)
                                // we have a problem because XBOX WIN32_FIND_DATA is in the local time zone.  So we
                                // need to convert the XBOX local time to UTC when we set the file.
                                // Note that we are using an optimization that uses the fact that XBOX always
                                // has the same time for LastAccessTime, LastWriteTime, and CreationTime.
    //                                ASSERT(pwfd->ftCreationTime.dwLowDateTime = pwfd->ftLastAccessTime.dwLowDateTime = pwfd->ftLastWriteTime.dwLowDateTime);
    //                                ASSERT(pwfd->ftCreationTime.dwHighDateTime = pwfd->ftLastAccessTime.dwHighDateTime = pwfd->ftLastWriteTime.dwHighDateTime);

                                // priv.h has notes on how time works.
                                SetFileTime(hFile, &ftLastWriteTime, &ftLastWriteTime, &ftLastWriteTime);
                                CloseHandle(hFile);
                            }
                            SHChangeNotify(SHCNE_CREATE, SHCNF_PATH, wzDestPath, NULL);
                        }
                    }
                }

                uliFileSize.QuadPart = XboxPidl_GetFileSize(pidlFull);
                pDownLoad->progInfo.uliBytesCompleted.QuadPart += uliFileSize.QuadPart;
            }
        }
    }

    if (pfValidhinst)
        *pfValidhinst = (pDownLoad->progInfo.hint ? TRUE : FALSE);

    return hr;
}


/*****************************************************************************\
     FUNCTION: DownloadItemCB
 
    DESCRIPTION:
        This function will download the specified item and it's contents if it
    is a directory.
\*****************************************************************************/
HRESULT DownloadItemCB(LPVOID pvFuncCB, HINTERNET hint, LPCITEMIDLIST pidlFull, BOOL * pfValidhinst, LPVOID pvData)
{
    DOWNLOADSTRUCT * pDownLoad = (DOWNLOADSTRUCT *) pvData;
    LPFNPROCESSITEMCB pfnProcessItemCB = (LPFNPROCESSITEMCB) pvFuncCB;
    CXboxDir * pfdNew = NULL;
    HRESULT hr = DownloadItemStackPig(hint, pidlFull, pfValidhinst, pDownLoad, &pfdNew);

    if (SUCCEEDED(hr) && pfdNew)    // pfdNew Maybe NULL if cancelled
    {
        CXboxDir * pfdOriginal = pDownLoad->pfd;

        pDownLoad->pfd = pfdNew;
        hr = EnumFolder(pfnProcessItemCB, hint, pidlFull, pDownLoad->pff->GetCWireEncoding(), pfValidhinst, pvData);
        pDownLoad->pfd = pfdOriginal;

        pfdNew->Release();
    }

    return hr;
}


// BUGBUG/TODO: First, make this work on pidls that Bind to IStorages.
//              Second, nuke the CDownloadDialog code.
HRESULT ShowDownloadDialog(HWND hwnd, LPTSTR pszPath, DWORD cchSize)
{
    TCHAR szMessage[MAX_URL_STRING];
    HRESULT hr;
    LPITEMIDLIST pidlDefault = NULL;
    LPITEMIDLIST pidlFolder = NULL;
    HKEY hkey = NULL;
    IStream * pstrm = NULL;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, SZ_REGKEY_MICROSOFTSOFTWARE, 0, (KEY_READ | KEY_WRITE), &hkey))
    {
        pstrm = SHOpenRegStream(hkey, SZ_REGKEY_XBOXCLASS, SZ_REGVALUE_DOWNLOAD_DIR, STGM_READWRITE);
        if (pstrm)
            ILLoadFromStream(pstrm, &pidlDefault);  // Will return (NULL == pidlDefault) if the reg value is empty.
    }

    if (!pidlDefault && (SHELL_VERSION_W95NT4 == GetShellVersion()))   // If reg key is empty.
        pidlDefault = SHCloneSpecialIDList(NULL, CSIDL_PERSONAL, TRUE);

    EVAL(LoadString(HINST_THISDLL, IDS_DLG_DOWNLOAD_TITLE, szMessage, ARRAYSIZE(szMessage)));
    hr = BrowseForDir(hwnd, szMessage, pidlDefault, &pidlFolder);
    if (pstrm)
    {
        // Do we want to save the new pidl?
        if (S_OK == hr)
        {
            LARGE_INTEGER li = {0};
            ULARGE_INTEGER uli = {0};

            // rewind the stream to the beginning so that when we
            // add a new pidl it does not get appended to the first one
            pstrm->Seek(li, STREAM_SEEK_SET, &uli);
            ILSaveToStream(pstrm, pidlFolder);
        }

        pstrm->Release();
    }

    if (S_OK == hr)
    {
        ASSERT(cchSize >= MAX_PATH);        // This is an assumption SHGetPathFromIDList makes.
        hr = (SHGetPathFromIDList(pidlFolder, pszPath) ? S_OK : E_FAIL);
    }

    if (hkey)
        RegCloseKey(hkey);

    if (pidlDefault)
        ILFree(pidlDefault);

    if (pidlFolder)
        ILFree(pidlFolder);

    return hr;
}


/*****************************************************************************\
    FUNCTION: _InvokeDownloadVerb

    DESCRIPTION:
        The user just selected file(s) and/or folder(s) and selected the
    "download" verb.  We need to:
    1. Display UI to ask the user for the destination directory.
    2. Download each item (pidl) into that directory.
\*****************************************************************************/
HRESULT CXboxMenu::_InvokeDownloadVerb(LPCMINVOKECOMMANDINFO pici)
{
    if (ZoneCheckPidlAction(_punkSite, URLACTION_SHELL_FILE_DOWNLOAD, m_pff->GetPrivatePidlReference(), (PUAF_DEFAULT | PUAF_WARN_IF_DENIED)))
    {
        TCHAR szDestDir[MAX_PATH];
//      DWORD dwDownloadType;
        HRESULT hr = ShowDownloadDialog(pici->hwnd, szDestDir, ARRAYSIZE(szDestDir));

        if (S_OK == hr)
        {
            HANDLE hThread;

            while (m_pszDownloadDir)
                Sleep(0);   // Wait until the other thread is done.

            Str_SetPtr(&m_pszDownloadDir, szDestDir);
//          m_dwDownloadType = dwDownloadType;

            AddRef();       // The thread will hold a ref.
            DWORD dwHack;   // Win95 fails CreateThread() if pdwThreadID is NULL.
            hThread = CreateThread(NULL, 0, CXboxMenu::DownloadThreadProc, this, 0, &dwHack);
            if (!hThread)
            {
                // Failed to create the thread.
                Release();       // The thread will hold a ref.
                Str_SetPtr(&m_pszDownloadDir, NULL);        // Clear this value so other thread an use it.
            }
            else
                Sleep(100);   // Give the thread a second to copy the variables.
        }
    }

    return S_OK;
}


/*****************************************************************************\
    FUNCTION: _DownloadThreadProc

    DESCRIPTION:
\*****************************************************************************/
DWORD CXboxMenu::_DownloadThreadProc(void)
{
    if (EVAL(m_pfd))
    {
        TCHAR szUrl[MAX_URL_STRING];
        WCHAR wzDestDir[MAX_PATH];
        HINTERNET hint;
        LPITEMIDLIST pidlRoot = ILClone(m_pfd->GetPidlReference());
        DOWNLOADSTRUCT downloadStruct = {wzDestDir, pidlRoot, m_dwDownloadType, m_hwnd, opsPrompt, m_pff, m_pfd, 0, 0, 0, 0, 0};
        CXboxPidlList * pflHfpl = NULL;      // We need a copy because the caller may select other files and execute a verb during the download.
        HRESULT hrOleInit = SHCoInitialize();
        HRESULT hr = HRESULT_FROM_WIN32(ERROR_INTERNET_CANNOT_CONNECT);

        IUnknown_Set(&pflHfpl, m_pflHfpl);
        StrCpyNW(wzDestDir, m_pszDownloadDir, ARRAYSIZE(wzDestDir));
        Str_SetPtr(&m_pszDownloadDir, NULL);        // Clear this value so other thread an use it.
        
        m_pfd->GetHint(NULL, NULL, &hint, _punkSite, m_pff);
        if (hint)
        {
            BOOL fReleaseHint = TRUE;

            // BUGBUG: Do we need to pass punkEnableModless?
            // Is the disk ready? (Floppy, CD, net share)
            if (SUCCEEDED(SHPathPrepareForWriteWrapW(m_hwnd, NULL, wzDestDir, FO_COPY, SHPPFW_DEFAULT)))    // Check and prompt if necessary.
            {
                hr = UrlCreateFromPidl(pidlRoot, SHGDN_FORPARSING, szUrl, ARRAYSIZE(szUrl), ICU_ESCAPE | ICU_USERNAME, FALSE);
                if (EVAL(SUCCEEDED(hr)))
                {
                    PROGRESSINFO progInfo;
                    progInfo.uliBytesCompleted.QuadPart = 0;
                    progInfo.uliBytesTotal.QuadPart = 0;

                    downloadStruct.progInfo.hint = hint;
                    downloadStruct.progInfo.ppd = CProgressDialog_CreateInstance(IDS_COPY_TITLE, IDA_XBOXDOWNLOAD);
                    if (downloadStruct.progInfo.ppd)
                    {
                        HWND hwndParent = NULL;
                        WCHAR wzProgressDialogStr[MAX_PATH];

                        // If the caller was nice enough to SetSite() with their punk, I will be nice enough to make
                        // their window may progress dialog's parent window.
                        IUnknown_GetWindow(_punkSite, &hwndParent);
                        if (!hwndParent)
                            hwndParent = m_hwnd;

                        // We give a NULL punkEnableModless because we don't want to go modal.
                        downloadStruct.progInfo.ppd->StartProgressDialog(hwndParent, NULL, PROGDLG_AUTOTIME, NULL);
                        // Tell the user we are calculating how long it will take.
                        if (EVAL(LoadStringW(HINST_THISDLL, IDS_PROGRESS_DOWNLOADTIMECALC, wzProgressDialogStr, ARRAYSIZE(wzProgressDialogStr))))
                            EVAL(SUCCEEDED(downloadStruct.progInfo.ppd->SetLine(2, wzProgressDialogStr, FALSE, NULL)));
                        InternetSetStatusCallbackWrap(hint, TRUE, XboxProgressInternetStatusCB);
                        progInfo.ppd = downloadStruct.progInfo.ppd;
                    }

                    hr = pflHfpl->RecursiveEnum(pidlRoot, FileSizeCountItemCB, hint, (LPVOID) &progInfo);
                    if (downloadStruct.progInfo.ppd)
                    {
                        // Reset because RecursiveEnum(FileSizeCountItemCB) can take a long time and the estimated time
                        // is based on the time between ::StartProgressDialog() and the first
                        // ::SetProgress() call.
                        EVAL(SUCCEEDED(downloadStruct.progInfo.ppd->Timer(PDTIMER_RESET, NULL)));
                    }

                    if (SUCCEEDED(hr))
                    {
                        downloadStruct.progInfo.uliBytesCompleted.QuadPart = progInfo.uliBytesCompleted.QuadPart;
                        downloadStruct.progInfo.uliBytesTotal.QuadPart = progInfo.uliBytesTotal.QuadPart;

                        pflHfpl->UseCachedDirListings(TRUE);    // Get the perf advantage now because we just updated the cache a few lines up.
                        hr = pflHfpl->RecursiveEnum(pidlRoot, DownloadItemCB, hint, (LPVOID) &downloadStruct);
                    }
                    if (downloadStruct.progInfo.ppd)
                    {
                        EVAL(SUCCEEDED(downloadStruct.progInfo.ppd->StopProgressDialog()));
                        downloadStruct.progInfo.ppd->Release();
                    }

                    if (!downloadStruct.progInfo.hint)
                        fReleaseHint = FALSE;
                }
            }
            else
                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);   // Err msg already displayed

            if (fReleaseHint)
                m_pfd->ReleaseHint(hint);
        }

        if (FAILED(hr) && (hr != HRESULT_FROM_WIN32(ERROR_CANCELLED)))
        {
            int nResult = DisplayWininetError(m_hwnd, TRUE, HRESULT_CODE(hr), IDS_XBOXERR_TITLE_ERROR, IDS_XBOXERR_DOWNLOADING, IDS_XBOXERR_WININET, MB_OK, NULL);
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);   // Don't display any more error dialogs.
        }
        ILFree(pidlRoot);
        IUnknown_Set(&pflHfpl, NULL);
        SHCoUninitialize(hrOleInit);
    }

    Release();  // This thread is holding a ref.
    return 0;
}


HRESULT CXboxMenu::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    UINT idc;
    HRESULT hres = E_FAIL;

    if (pici->cbSize < sizeof(*pici))
        return E_INVALIDARG;

    if (HIWORD(pici->lpVerb))
    {
        int ivi;
        idc = (UINT)-1;
        for (ivi = 0; ivi < IVI_MAX; ivi++)
        {
            TCHAR szVerb[MAX_PATH];

            SHAnsiToTChar(pici->lpVerb, szVerb, ARRAYSIZE(szVerb));
            if (!StrCmpI(c_rgvi[ivi].ptszCmd, szVerb))
            {
                // Yes, the command is equal to the verb str, so this is the one.
                idc = c_rgvi[ivi].idc;
                break;
            }
        }
    }
    else
        idc = LOWORD(pici->lpVerb);

    switch (idc)
    {
    case IDC_ITEM_NEWFOLDER:
        hres = _InvokeNewFolderVerb(pici);
    break;

    case IDC_LOGIN_AS:
        hres = _InvokeLoginAsVerb(pici);
    break;

    case IDC_ITEM_OPEN:
    case IDC_ITEM_EXPLORE:
        hres = _EnumInvoke(pici, _ApplyOne, c_rgvi[IVI_REQ + idc].ptszCmd);
    break;

    case IDC_ITEM_DOWNLOAD:
        hres = _InvokeDownloadVerb(pici);
    break;

    case IDM_SHARED_FILE_DELETE:        // SFVIDM_FILE_DELETE
        hres = _InvokeDeleteVerb(pici);
        break;

    case IDM_SHARED_FILE_RENAME:        // SFVIDM_FILE_RENAME
        hres = _InvokeRename(pici);
        break;

    case IDM_SHARED_EDIT_COPY:          // SFVIDM_EDIT_COPY
        hres = _InvokeCutCopy(DFM_CMD_COPY, pici);
        break;

    case IDM_SHARED_EDIT_CUT:           // SFVIDM_EDIT_CUT
        hres = _InvokeCutCopy(DFM_CMD_MOVE, pici);
        break;

    //  _UNOBVIOUS_:  Yes, this is not a typo.  You might think I
    //  should have written SFVIDM_EDIT_PASTE, but you would be wrong.
    case SHARED_EDIT_PASTE:
        //  What's more annoying is that I also have to list
        //  IDM_SHARED_EDIT_PASTE, as a hack, because the "convert a
        //  name to an ID" loop above will cook up IDM_SHARED_EDIT_PASTE
        //  as the matching ID.
    case IDM_SHARED_EDIT_PASTE:
        hres = _InvokePaste(pici);
        break;

    case IDC_ITEM_BKGNDPROP:     // Properties for the background folder.
    case IDM_SHARED_FILE_PROP:   // Same as SFVIDM_FILE_PROPERTIES
        TraceMsg(TF_XBOX_OTHER, "Properties!");
        hres = CXboxProp_DoProp(m_pflHfpl, m_pff, m_hwnd);
        break;

    case IDM_SORTBYNAME:
    case IDM_SORTBYSIZE:
    case IDM_SORTBYTYPE:
    case IDM_SORTBYDATE:
        ASSERT(m_hwnd);
        ShellFolderView_ReArrange(m_hwnd, CONVERT_IDMID_TO_COLNAME(idc));
        hres = S_OK;
        break;

    default:
        TraceMsg(TF_XBOX_OTHER, "InvokeCommand");
        hres = E_INVALIDARG;
        break;
    }

    return hres;
}


/*****************************************************************************
 *
 *    CXboxMenu_Create
 *
\*****************************************************************************/

HRESULT CXboxMenu_Create(CXboxFolder * pff, CXboxPidlList * pflHfpl, HWND hwnd, REFIID riid, LPVOID * ppvObj, BOOL fFromCreateViewObject)
{
    HRESULT hr;
    CXboxMenu * pfm;

    *ppvObj = NULL;

    hr = CXboxMenu_Create(pff, pflHfpl, hwnd, fFromCreateViewObject, &pfm);
    if (EVAL(SUCCEEDED(hr)))
    {
        hr = pfm->QueryInterface(riid, ppvObj);
        pfm->Release();
    }

    ASSERT_POINTER_MATCHES_HRESULT(*ppvObj, hr);
    return hr;
}


/**********************************************************************\
    FUNCTION: GetXboxDirFromXboxFolder

    DESCRIPTION:
        If an Xbox folder is opened to an Xbox server root (xbox://wired/),
    and the user clicks on the icon in the caption bar, pff will have an
    empty pidl.  This will cause us to return NULL.
\**********************************************************************/
CXboxDir * GetXboxDirFromXboxFolder(CXboxFolder * pff, CXboxPidlList * pflHfpl)
{
    LPCITEMIDLIST pidl = pff->GetPrivatePidlReference();
    if (!pidl || ILIsEmpty(pidl))
        return NULL;

    return pff->GetXboxDirFromPidl(pidl);
}


BOOL CanRenameAndDelete(CXboxFolder * pff, CXboxPidlList * pidlList, DWORD * pdwSFGAO)
{
    BOOL fResult = TRUE;

    //  If talking about yourself, you can't delete or rename.
    //  (Rename isn't allowed because SetNameOf doesn't like "self".)
    if (pidlList->GetCount() == 0)
        fResult = FALSE;
    else if (pidlList->GetCount() == 1)
    {
        LPITEMIDLIST pidl = GetPidlFromXboxFolderAndPidlList(pff, pidlList);

        // We can't rename or delete XBOX servers, so check to see if it is one.
        if (XboxID_IsServerItemID(XboxID_GetLastIDReferense(pidl)))
            fResult = FALSE;
        ILFree(pidl);
    }

    return fResult;
}

/*****************************************************************************
 *
 *    CXboxMenu_Create
 *
\*****************************************************************************/
HRESULT CXboxMenu_Create(CXboxFolder * pff, CXboxPidlList * pidlList, HWND hwnd, BOOL fFromCreateViewObject, CXboxMenu ** ppfcm)
{
    HRESULT hr = E_FAIL;
    // It's ok if this is NULL
    CXboxDir * pfd = GetXboxDirFromXboxFolder(pff, pidlList);

    ASSERT(ppfcm);
    *ppfcm = new CXboxMenu();
    if (EVAL(*ppfcm))
    {
        //  We must AddRef the moment we copy them, else
        //  Finalize will get extremely upset.
        //
        //  NOTE! that we rely on the fact that GetAttributesOf
        //  will barf on complex pidls!
        (*ppfcm)->m_pff = pff;
        if (pff)
            pff->AddRef();

        IUnknown_Set(&(*ppfcm)->m_pflHfpl, pidlList);
        IUnknown_Set(&(*ppfcm)->m_pfd, pfd);
        (*ppfcm)->m_sfgao = SFGAO_CAPABILITYMASK | SFGAO_FOLDER;
        (*ppfcm)->m_hwnd = hwnd;
        (*ppfcm)->m_fBackground = fFromCreateViewObject;

        if (!CanRenameAndDelete(pff, pidlList, &((*ppfcm)->m_sfgao)))
            (*ppfcm)->m_sfgao &= ~(SFGAO_CANDELETE | SFGAO_CANRENAME);  // Clear those two bits.

        LPCITEMIDLIST * ppidl = (*ppfcm)->m_pflHfpl->GetPidlList();
        if (ppidl)
        {
            hr = (*ppfcm)->m_pff->GetAttributesOf((*ppfcm)->m_pflHfpl->GetCount(), 
                                        ppidl, &(*ppfcm)->m_sfgao);
            (*ppfcm)->m_pflHfpl->FreePidlList(ppidl);
        }

        if (!(EVAL(SUCCEEDED(hr))))
            IUnknown_Set(ppfcm, NULL);    // Unable to get attributes
    }
    else
        hr = E_OUTOFMEMORY;

    if (pfd)
        pfd->Release();

    ASSERT_POINTER_MATCHES_HRESULT(*ppfcm, hr);
    return hr;
}



/****************************************************\
    Constructor
\****************************************************/
CXboxMenu::CXboxMenu() : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_pflHfpl);
    ASSERT(!m_pff);
    ASSERT(!m_pfd);
    ASSERT(!m_sfgao);
    ASSERT(!m_hwnd);

    LEAK_ADDREF(LEAK_CXboxContextMenu);
}


/****************************************************\
    Destructor
\****************************************************/
CXboxMenu::~CXboxMenu()
{
    IUnknown_Set(&m_pflHfpl, NULL);
    IUnknown_Set(&m_pff, NULL);
    IUnknown_Set(&m_pfd, NULL);
    IUnknown_Set(&_punkSite, NULL);

    DllRelease();
    LEAK_DELREF(LEAK_CXboxContextMenu);
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CXboxMenu::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CXboxMenu::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CXboxMenu::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IContextMenu))
    {
        *ppvObj = SAFECAST(this, IContextMenu*);
    }
    else if (IsEqualIID(riid, IID_IObjectWithSite))
    {
        *ppvObj = SAFECAST(this, IObjectWithSite*);
    }
    else
    {
        TraceMsg(TF_XBOXQI, "CXboxMenu::QueryInterface() failed.");
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxapi.cpp ===
/*****************************************************************************\
    FILE: xboxapi.cpp

***
*** We will change this file to wrap the DmXXX methods exported by
*** xboxdbg.dll instead of the Xbox methods exported by wininet .
***
    DESCRIPTION:
        This file contains functions to perform the following 2 things:

    1. WININET WRAPPERS: Wininet APIs have either wierd bugs or bugs that come thru the APIs
    from the server.  It's also important to keep track of the perf impact
    of each call.  These wrappers solve these problems.

    2. XBOX STRs to PIDLs: These wrappers will take Xbox filenames and file paths
    that come in from the server and turn them into pidls.  These pidls contain
    both a unicode display string and the filename/path in wire bytes for future
    server requests.
\*****************************************************************************/

#include "priv.h"
#include "util.h"
#include "encoding.h"
#include "xboxapi.h"


///////////////////////////////////////////////////////////////////////////////////////////
// 1. WININET WRAPPERS: Wininet APIs have either wierd bugs or bugs that come thru the APIs
// from the server.  It's also important to keep track of the perf impact
// of each call.  These wrappers solve these problems.
///////////////////////////////////////////////////////////////////////////////////////////
/*****************************************************************************\
    FUNCTION: XboxSetCurrentDirectoryWrap

    DESCRIPTION:

    PERF Notes:
    [Direct Net Connection]
        To: shapitst <Down the Hall>: 1ms
        To: rigel.cyberpass.net <San Diego, CA>: 140ms - 200ms
        To: Xbox.rz.uni-frankfurt.de <Germany>: 570ms - 2496ms
\*****************************************************************************/
HRESULT XboxSetCurrentDirectoryWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCWIRESTR pwXboxPath)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    // WARNING: XboxSetCurrentDirectory() may fail if it's not really a directory.
    // PERF: Status XboxGetCurrentDirectory/XboxSetCurrentDirectory() takes
    //  180-280ms on Xbox.microsoft.com on average.
    //  500-2000ms on xbox://Xbox.tu-clausthal.de/ on average
    //  0-10ms on xbox://shapitst/ on average
    DEBUG_CODE(DebugStartWatch());
    if (!FtpSetCurrentDirectoryA(hConnect, pwXboxPath))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "XboxSetCurrentDirectory(%#08lx, \"%hs\") returned %u. Time=%lums", hConnect, pwXboxPath, dwError, DebugStopWatch()));

    if (fAssertOnFailure)
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: XboxGetCurrentDirectoryWrap

    DESCRIPTION:

    PERF Notes:
    These are for short directory listings.  Long listings can take 3-10x.
    [Direct Net Connection]
        To: shapitst <Down the Hall>: 1ms - 4ms
        To: rigel.cyberpass.net <San Diego, CA>: 132ms - 213ms
        To: Xbox.rz.uni-frankfurt.de <Germany>: 507ms - 2012ms
\*****************************************************************************/
HRESULT XboxGetCurrentDirectoryWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPWIRESTR pwXboxPath, DWORD cchCurrentDirectory)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    // PERF: Status XboxGetCurrentDirectory/XboxSetCurrentDirectory() takes
    //  180-280ms on Xbox.microsoft.com on average.
    //  500-2000ms on xbox://Xbox.tu-clausthal.de/ on average
    //  0-10ms on xbox://shapitst/ on average
    DEBUG_CODE(DebugStartWatch());
    if (!FtpGetCurrentDirectoryA(hConnect, pwXboxPath, &cchCurrentDirectory))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "XboxGetCurrentDirectoryA(%#08lx, \"%hs\") returned %u. Time=%lums", hConnect, pwXboxPath, dwError, DebugStopWatch()));

    if (fAssertOnFailure)
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: XboxGetFileExWrap

    DESCRIPTION:

    PERF Notes:   (*** Depends on file size ***)
    [Direct Net Connection]
        To: shapitst <Down the Hall>: 100ms - 1,000ms+
        To: rigel.cyberpass.net <San Diego, CA>: 1210ms - 1610ms
        To: Xbox.rz.uni-frankfurt.de <Germany>: ???????
\*****************************************************************************/
HRESULT XboxGetFileExWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCWIRESTR pwXboxPath/*Src*/, LPCWSTR pwzFilePath/*Dest*/, BOOL fFailIfExists,
                       DWORD dwFlagsAndAttributes, DWORD dwFlags, DWORD_PTR dwContext)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    if (!FtpGetFileEx(hConnect, pwXboxPath, pwzFilePath, fFailIfExists, dwFlagsAndAttributes, dwFlags, dwContext))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
        if (HRESULT_FROM_WIN32(ERROR_INTERNET_OPERATION_CANCELLED) == hr)
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
    }
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "XboxGetFileEx(%#08lx, \"%hs\", \"%ls\") returned %u. Time=%lums", hConnect, pwXboxPath, pwzFilePath, dwError, DebugStopWatch()));

    if (fAssertOnFailure)
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: XboxPutFileExWrap

    DESCRIPTION:

    PERF Notes:   (*** Depends on file size ***)
    [Direct Net Connection]
        To: shapitst <Down the Hall>: 194ms - 400ms+
        To: rigel.cyberpass.net <San Diego, CA>: 1662ms - 8454ms
        To: Xbox.rz.uni-frankfurt.de <Germany>: ???????
\*****************************************************************************/
HRESULT XboxPutFileExWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCWSTR pwzFilePath/*Src*/, LPCWIRESTR pwXboxPath/*Dest*/, DWORD dwFlags, DWORD_PTR dwContext)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    if (!FtpPutFileEx(hConnect, pwzFilePath, pwXboxPath, dwFlags, dwContext))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "XboxPutFileEx(%#08lx, \"%ls\", \"%hs\") returned %u. Time=%lums", hConnect, pwzFilePath, pwXboxPath, dwError, DebugStopWatch()));

    if (fAssertOnFailure)
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: XboxDeleteFileWrap

    DESCRIPTION:

    PERF Notes:
    [Direct Net Connection]
        To: shapitst <Down the Hall>: 4ms (22ms once in a while)
        To: rigel.cyberpass.net <San Diego, CA>: 175ms - 291ms
        To: Xbox.rz.uni-frankfurt.de <Germany>: ???????
\*****************************************************************************/
HRESULT XboxDeleteFileWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCWIRESTR pwXboxFileName)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    if (!FtpDeleteFileA(hConnect, pwXboxFileName))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "XboxDeleteFile(%#08lx, \"%hs\") returned %u. Time=%lums", hConnect, pwXboxFileName, dwError, DebugStopWatch()));

    if (fAssertOnFailure)
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: XboxRenameFileWrap

    DESCRIPTION:

    PERF Notes:
    [Direct Net Connection]
        To: shapitst <Down the Hall>: 4ms
        To: rigel.cyberpass.net <San Diego, CA>: 329ms - 446ms
        To: Xbox.rz.uni-frankfurt.de <Germany>: ???????
\*****************************************************************************/
HRESULT XboxRenameFileWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCWIRESTR pwXboxFileNameExisting, LPCWIRESTR pwXboxFileNameNew)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    if (!FtpRenameFileA(hConnect, pwXboxFileNameExisting, pwXboxFileNameNew))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "XboxRenameFile(%#08lx, \"%hs\", \"%hs\") returned %u. Time=%lums", hConnect, pwXboxFileNameExisting, pwXboxFileNameNew, dwError, DebugStopWatch()));

    if (fAssertOnFailure)
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: XboxOpenFileWrap

    DESCRIPTION:

    PERF Notes:
    [Direct Net Connection]
        To: shapitst <Down the Hall>: 2ms
        To: rigel.cyberpass.net <San Diego, CA>: 757ms - 817ms
        To: Xbox.rz.uni-frankfurt.de <Germany>: 2112ms - 10026ms
\*****************************************************************************/
HRESULT XboxOpenFileWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCWIRESTR pwXboxFileName, DWORD dwAccess, DWORD dwFlags, DWORD_PTR dwContext, HINTERNET * phFileHandle)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    *phFileHandle = FtpOpenFileA(hConnect, pwXboxFileName, dwAccess, dwFlags, dwContext);
    if (!*phFileHandle)
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "XboxOpenFile(%#08lx, \"%hs\") returned %u. Time=%lums", hConnect, pwXboxFileName, dwError, DebugStopWatch()));

    if (fAssertOnFailure)
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: XboxCreateDirectoryWrap

    DESCRIPTION:

    PERF Notes:
    [Direct Net Connection]
        To: shapitst <Down the Hall>: 3ms
        To: rigel.cyberpass.net <San Diego, CA>: 210ms - 350ms
        To: Xbox.rz.uni-frankfurt.de <Germany>: ???????
\*****************************************************************************/
HRESULT XboxCreateDirectoryWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCWIRESTR pwXboxPath)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    if (!FtpCreateDirectoryA(hConnect, pwXboxPath))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "XboxCreateDirectoryA(%#08lx, \"%hs\") returned %u. Time=%lums", hConnect, pwXboxPath, dwError, DebugStopWatch()));

    if (fAssertOnFailure)
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: XboxRemoveDirectoryWrap

    DESCRIPTION:

    PERF Notes:
    [Direct Net Connection]
        To: shapitst <Down the Hall>: 2ms
        To: rigel.cyberpass.net <San Diego, CA>: 157ms - 227ms
        To: Xbox.rz.uni-frankfurt.de <Germany>: ???????
\*****************************************************************************/
HRESULT XboxRemoveDirectoryWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCWIRESTR pwXboxPath)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    if (!FtpRemoveDirectoryA(hConnect, pwXboxPath))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "XboxRemoveDirectory(%#08lx, \"%hs\") returned %u. Time=%lums", hConnect, pwXboxPath, dwError, DebugStopWatch()));

    if (fAssertOnFailure)
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: XboxFindFirstFileWrap

    DESCRIPTION:

    PERF Notes:
    [Direct Net Connection]
        To: shapitst <Down the Hall>: 166ms - 189ms
        To: rigel.cyberpass.net <San Diego, CA>: 550ms - 815ms
        To: Xbox.rz.uni-frankfurt.de <Germany>: 1925ms - 11,390ms
\*****************************************************************************/
HRESULT XboxFindFirstFileWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCWIRESTR pwFilterStr, LPXBOX_FIND_DATA pwfd, DWORD dwINetFlags, DWORD_PTR dwContext, HINTERNET * phFindHandle)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(StrCpyNA(pwfd->cFileName, "<Not Found>", ARRAYSIZE(pwfd->cFileName)));
    ASSERT(phFindHandle);
    DEBUG_CODE(DebugStartWatch());
    //    _UNDOCUMENTED_: If you pass NULL as the second argument, it's the
    //    same as passing TEXT("*.*"), but much faster.
    // PERF: Status
    // XboxFindFirstFile() takes 500-700ms on Xbox.microsoft.com on average.
    //                    takes 2-10 secs on xbox://Xbox.tu-clausthal.de/ on average
    //                    takes 150-250 secs on xbox://shapitst/ on average
    *phFindHandle = FtpFindFirstFileA(hConnect, pwFilterStr, pwfd, dwINetFlags, dwContext);
    if (!*phFindHandle)
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "XboxFindFirstFile(\"%hs\")==\"%hs\" atrb=%#08lx, hr=%#08lx, Time=%lums", EMPTYSTR_FOR_NULLA(pwFilterStr), pwfd->cFileName, pwfd->dwFileAttributes, hr, DebugStopWatch()));

    if (fAssertOnFailure)
    {
//      This fails in normal cases when we are checking if files exist.
//        WININET_ASSERT(SUCCEEDED(hr));
    }

    ASSERT_POINTER_MATCHES_HRESULT(*phFindHandle, hr);
    return hr;
}


// Do not localize this because it's always returned from the server in english.g
#define SZ_FINDFIRSTFILE_FAILURESTR     ": No such file or directory"

/**************************************************************\
    FUNCTION: XboxDoesFileExist

    DESCRIPTION:
        IE #34868 is the fact that some XBOX servers erronous
    results on find requests:
    [The file does not exist in the following cases]
    Request: "foo.txt" result: SUCCEEDED & "foo.txt: No such file or directory"
    Request: "foo bat.txt" result: SUCCEEDED & "foo: No such file or directory"
\**************************************************************/
HRESULT XboxDoesFileExist(HINTERNET hConnect, BOOL fAssertOnFailure, LPCWIRESTR pwFilterStr, LPXBOX_FIND_DATA pwfd, DWORD dwINetFlags)
{
    XBOX_FIND_DATA wfd;
    HINTERNET hIntFind;
    HRESULT hr;

    if (!pwfd)      // pwfd is optional
        pwfd = &wfd;

    // Some servers like "xbox://wired/" will fail to find "BVTBaby.gif" even
    // though it exists.  It will find it if "BVTBaby.gif*" is used.
    // Wininet should fix this or implement this hack but they probably won't.
    WIRECHAR wFilterStr[MAX_PATH];

    StrCpyNA(wFilterStr, pwFilterStr, ARRAYSIZE(wFilterStr));
    // WININET BUGBUG: Wininet won't find "BVTBaby.gif" on an IIS server (xbox://wired/)
    // unless it has an "*" behind it.  So add one if it doesn't exist.
    if ('*' != wFilterStr[lstrlenA(wFilterStr) - 1])
    {
        // We need to add it.
        StrCatBuffA(wFilterStr, "*", ARRAYSIZE(wFilterStr));
    }

    hr = XboxFindFirstFileWrap(hConnect, fAssertOnFailure, wFilterStr, pwfd, dwINetFlags, 0, &hIntFind);
    if (S_OK == hr)
    {
        do
        {
            // is it an exact match?
            // #248535: Make sure we get what we asked for.  Either WININET or
            //     some weird XBOX servers are screwing up.  If we ask for
            //     foobar.gif as the filter string, sometimes we get back
            //     ".".
            if (!StrCmpIA(pwfd->cFileName, pwFilterStr))
            {
                // Yes it "Should"
                hr = S_OK;
                break;
            }
            else
            {
                // However, wininet will return TRUE but the display name will be "One: No such file or directory"
                // if the file name is "One Two.htm"
                // This is a work around for bug #34868 because UNIX servers sometimes return success
                // and a file name of "thefile.txt: No such file or directory"
                if ((lstrlenA(pwfd->cFileName) > (ARRAYSIZE(SZ_FINDFIRSTFILE_FAILURESTR) - 1)) && 
                    !StrCmpA(&(pwfd->cFileName[lstrlenA(pwfd->cFileName) - (ARRAYSIZE(SZ_FINDFIRSTFILE_FAILURESTR) - 1)]), SZ_FINDFIRSTFILE_FAILURESTR))
                {
                    hr = S_OK;
                    break;
                }
                else
                    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            }

            // Next...
            hr = InternetFindNextFileWrap(hIntFind, TRUE, pwfd);
        }
        while (S_OK == hr);

        InternetCloseHandle(hIntFind);
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: XboxCommandWrap

    DESCRIPTION:

    PERF Notes:
    [Direct Net Connection]
        To: shapitst <Down the Hall>: 1ms - 12ms
        To: rigel.cyberpass.net <San Diego, CA>: 133ms - 184ms
        To: Xbox.rz.uni-frankfurt.de <Germany>: 1711ms - 2000ms
\*****************************************************************************/
HRESULT XboxCommandWrap(HINTERNET hConnect, BOOL fAssertOnFailure, BOOL fExpectResponse, DWORD dwFlags, LPCWIRESTR pszCommand,
                       DWORD_PTR dwContext, HINTERNET *phXboxCommand)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    if (!FtpCommandA(hConnect, fExpectResponse, dwFlags, pszCommand, dwContext, phXboxCommand))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "XboxCommand(%#08lx, \"%hs\") returned %u. Time=%lums", hConnect, pszCommand, dwError, DebugStopWatch()));

    if (fAssertOnFailure)
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }

    return hr;
}


/*** TODO

INTERNETAPI
DWORD
WINAPI
XboxGetFileSize(
    IN HINTERNET hFile,
    OUT LPDWORD lpdwFileSizeHigh OPTIONAL
    );
******/



/*****************************************************************************\
    FUNCTION: InternetOpenWrap

    DESCRIPTION:

    PERF Notes:
    [Direct Net Connection]
        Destination not applicable. 677-907ms
\*****************************************************************************/
HRESULT InternetOpenWrap(BOOL fAssertOnFailure, LPCTSTR pszAgent, DWORD dwAccessType, LPCTSTR pszProxy, LPCTSTR pszProxyBypass, DWORD dwFlags, HINTERNET * phFileHandle)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    *phFileHandle = InternetOpen(pszAgent, dwAccessType, pszProxy, pszProxyBypass, dwFlags);
    if (!*phFileHandle)
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "InternetOpen(\"%ls\") returned %u. Time=%lums", pszAgent, dwError, DebugStopWatch()));

    if (fAssertOnFailure)
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }

    return hr;
}


HRESULT InternetCloseHandleWrap(HINTERNET hInternet, BOOL fAssertOnFailure)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    if (!InternetCloseHandle(hInternet))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "InternetCloseHandle(%#08lx) returned %u. Time=%lums", hInternet, dwError, DebugStopWatch()));

    if (fAssertOnFailure)
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: InternetConnectWrap

    DESCRIPTION:

    PERF Notes:
    [Direct Net Connection]
        To: shapitst <Down the Hall>: 144ms - 250ms (Min: 2; Max: 1,667ms)
        To: rigel.cyberpass.net <San Diego, CA>: 717ms - 1006ms
        To: Xbox.rz.uni-frankfurt.de <Germany>: 2609ms - 14,012ms

    COMMON ERROR VALUES:
        These are the return values in these different cases:
    ERROR_INTERNET_NAME_NOT_RESOLVED: No Proxy & DNS Lookup failed.
    ERROR_INTERNET_CANNOT_CONNECT: Some Auth Proxies and Netscape's Web/Auth Proxy
    ERROR_INTERNET_NAME_NOT_RESOLVED: Web Proxy
    ERROR_INTERNET_TIMEOUT: Invalid or Web Proxy blocked IP Address
    ERROR_INTERNET_INCORRECT_PASSWORD: IIS & UNIX, UserName may not exist or password for the user may be incorrect on.
    ERROR_INTERNET_LOGIN_FAILURE: Too many Users on IIS.
    ERROR_INTERNET_INCORRECT_USER_NAME: I haven't seen it.
    ERROR_INTERNET_EXTENDED_ERROR: yahoo.com exists, but Xbox.yahoo.com doesn't.
\*****************************************************************************/
HRESULT InternetConnectWrap(HINTERNET hInternet, BOOL fAssertOnFailure, LPCTSTR pszServerName, INTERNET_PORT nServerPort,
                            LPCTSTR pszUserName, LPCTSTR pszPassword, DWORD dwService, DWORD dwFlags, DWORD_PTR dwContext, HINTERNET * phFileHandle)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    // Call BryanSt if this assert fires.
    // Did the user turn off XBOX Folders?
    // If so, don't connect.  This will fix NT #406423 where the user turned
    // of XBOX Folders because they have a firewall (CISCO filtering Router)
    // that will kill packets in such a way the caller (WinSock/Wininet) needs
    // to wait for a timeout.  During this timeout, the browser will hang causing
    // the user to think it crashed.
    AssertMsg(!SHRegGetBoolUSValue(SZ_REGKEY_XBOXFOLDER, SZ_REGKEY_USE_OLD_UI, FALSE, FALSE), TEXT("BUG: We can't hit this code or we will hang the browser for 45 seconds if the user is using a certain kind of proxy. Call BryanSt."));

    DEBUG_CODE(DebugStartWatch());
    *phFileHandle = InternetConnect(hInternet, pszServerName, nServerPort, pszUserName, pszPassword, dwService, dwFlags | FEATURE_PASSIVE_ON_OR_OFF, dwContext);
    if (!*phFileHandle)
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "InternetConnect(%#08lx, \"%ls\", \"%ls\", \"%ls\") returned %u. Time=%lums", hInternet, pszServerName, EMPTYSTR_FOR_NULL(pszUserName), EMPTYSTR_FOR_NULL(pszPassword), dwError, DebugStopWatch()));

    if (fAssertOnFailure)
    {
        // ERROR_INTERNET_NAME_NOT_RESOLVED happens when we are blocked by the
        // proxy.
        WININET_ASSERT(SUCCEEDED(hr) ||
            (HRESULT_FROM_WIN32(ERROR_INTERNET_NAME_NOT_RESOLVED) == hr) ||
            (HRESULT_FROM_WIN32(ERROR_INTERNET_LOGIN_FAILURE) == hr) ||
            (HRESULT_FROM_WIN32(ERROR_INTERNET_INCORRECT_PASSWORD) == hr) ||
            (HRESULT_FROM_WIN32(ERROR_INTERNET_INCORRECT_USER_NAME) == hr));
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: InternetOpenUrlWrap

    DESCRIPTION:

    PERF Notes:
    [Direct Net Connection]
        To: shapitst <Down the Hall>: 29ms
        To: rigel.cyberpass.net <San Diego, CA>: ???????
        To: Xbox.rz.uni-frankfurt.de <Germany>: ???????
\*****************************************************************************/
HRESULT InternetOpenUrlWrap(HINTERNET hInternet, BOOL fAssertOnFailure, LPCTSTR pszUrl, LPCTSTR pszHeaders, DWORD dwHeadersLength, DWORD dwFlags, DWORD_PTR dwContext, HINTERNET * phFileHandle)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    *phFileHandle = InternetOpenUrl(hInternet, pszUrl, pszHeaders, dwHeadersLength, dwFlags | FEATURE_PASSIVE_ON_OR_OFF, dwContext);
    if (!*phFileHandle)
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "InternetOpenUrl(%#08lx, \"%ls\") returned %u. Time=%lums", hInternet, pszUrl, dwError, DebugStopWatch()));

    if (fAssertOnFailure)
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }

    return hr;
}


HRESULT InternetReadFileWrap(HINTERNET hFile, BOOL fAssertOnFailure, LPVOID pvBuffer, DWORD dwNumberOfBytesToRead, LPDWORD pdwNumberOfBytesRead)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

//    DEBUG_CODE(DebugStartWatch());
    if (!InternetReadFile(hFile, pvBuffer, dwNumberOfBytesToRead, pdwNumberOfBytesRead))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
//    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "InternetReadFile(%#08lx, ToRead=%d, Read=%d) returned %u. Time=%lums", hFile, dwNumberOfBytesToRead, (pdwNumberOfBytesRead ? *pdwNumberOfBytesRead : -1), dwError, DebugStopWatch()));

    if (fAssertOnFailure)
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }

    return hr;
}


HRESULT InternetWriteFileWrap(HINTERNET hFile, BOOL fAssertOnFailure, LPCVOID pvBuffer, DWORD dwNumberOfBytesToWrite, LPDWORD pdwNumberOfBytesWritten)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

//    DEBUG_CODE(DebugStartWatch());
    if (!InternetWriteFile(hFile, pvBuffer, dwNumberOfBytesToWrite, pdwNumberOfBytesWritten))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
//    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "InternetWriteFile(%#08lx, ToWrite=%d, Writen=%d) returned %u. Time=%lums", hFile, dwNumberOfBytesToWrite, (pdwNumberOfBytesWritten ? *pdwNumberOfBytesWritten : -1), dwError, DebugStopWatch()));

    if (fAssertOnFailure)
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: InternetGetLastResponseInfoWrap

    DESCRIPTION:

    PERF Notes:
        Always takes 0 (zero) ms because it doesn't have to hit the net.
\*****************************************************************************/
HRESULT InternetGetLastResponseInfoWrap(BOOL fAssertOnFailure, LPDWORD pdwError, LPWIRESTR pwBuffer, LPDWORD pdwBufferLength)
{
    HRESULT hr = S_OK;
    DWORD dwDummyError;

    if (!pdwError)
        pdwError = &dwDummyError;

    if (pwBuffer)
        pwBuffer[0] = 0;

    DEBUG_CODE(DebugStartWatch());
    InternetGetLastResponseInfoA(pdwError, pwBuffer, pdwBufferLength);

    if (pwBuffer)
    {
        DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "InternetGetLastResponseInfo(\"%hs\") took %lu milliseconds", pwBuffer, DebugStopWatch()));
    }
    else
    {
        DEBUG_CODE(DebugStopWatch());
    }

    if (fAssertOnFailure)
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }

    return hr;
}


HRESULT InternetGetLastResponseInfoDisplayWrap(BOOL fAssertOnFailure, LPDWORD pdwError, LPWSTR pwzBuffer, DWORD cchBufferSize)
{
    LPWIRESTR pwWireResponse;
    DWORD dwError = 0;
    DWORD cchResponse = 0;
    HRESULT hr = InternetGetLastResponseInfoWrap(TRUE, &dwError, NULL, &cchResponse);

    cchResponse++;                /* +1 for the terminating 0 */
    pwWireResponse = (LPWIRESTR)LocalAlloc(LPTR, cchResponse * sizeof(WIRECHAR));
    if (pwWireResponse)
    {
        hr = InternetGetLastResponseInfoWrap(TRUE, &dwError, pwWireResponse, &cchResponse);
        if (SUCCEEDED(hr))
        {
            CWireEncoding cWireEncoding;

            hr = cWireEncoding.WireBytesToUnicode(NULL, pwWireResponse, WIREENC_IMPROVE_ACCURACY, pwzBuffer, cchBufferSize);
        }

        LocalFree(pwWireResponse);
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}


INTERNET_STATUS_CALLBACK InternetSetStatusCallbackWrap(HINTERNET hInternet, BOOL fAssertOnFailure, INTERNET_STATUS_CALLBACK pfnInternetCallback)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;
    INTERNET_STATUS_CALLBACK pfnCallBack;

    DEBUG_CODE(DebugStartWatch());
    pfnCallBack = InternetSetStatusCallback(hInternet, pfnInternetCallback);
    if (!pfnCallBack)
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "InternetSetStatusCallback(%#08lx) returned %u. Time=%lums", hInternet, dwError, DebugStopWatch()));

    if (fAssertOnFailure)
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }

    return pfnCallBack;
}


HRESULT InternetCheckConnectionWrap(BOOL fAssertOnFailure, LPCTSTR pszUrl, DWORD dwFlags, DWORD dwReserved)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    if (!InternetCheckConnection(pszUrl, dwFlags, dwReserved))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "InternetCheckConnection(\"%ls\") returned %u. Time=%lums", pszUrl, dwError, DebugStopWatch()));

    if (fAssertOnFailure)
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }

    return hr;
}

//#define FEATURE_OFFLINE

HRESULT InternetAttemptConnectWrap(BOOL fAssertOnFailure, DWORD dwReserved)
{
    HRESULT hr = S_OK;

#ifdef FEATURE_OFFLINE
    DEBUG_CODE(DebugStartWatch());

    hr = HRESULT_FROM_WIN32(InternetAttemptConnect(dwReserved));
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "InternetAttemptConnect() returned hr=%#08lx. Time=%lums", hr, DebugStopWatch()));

    if (fAssertOnFailure)
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }
#endif // FEATURE_OFFLINE

    return hr;
}



/*****************************************************************************\
    FUNCTION: InternetFindNextFileWrap

    DESCRIPTION:

    PERF Notes:
        Always takes 0 (zero) ms because all the work is done in XboxFindFirstFile()
\*****************************************************************************/
HRESULT InternetFindNextFileWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPXBOX_FIND_DATA pwfd)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(StrCpyNA(pwfd->cFileName, "<Not Found>", ARRAYSIZE(pwfd->cFileName)));
    DEBUG_CODE(DebugStartWatch());
    // BUGBUG: Bug #206068
    //       We need to treat dwFileAttributes = 0x00000000 as a directory
    //       link.  We can do this by XboxChangeDirectory() into it, call XboxGetDirectory(),
    //       and then creating a pidl with UrlPath and navigating to it w/o creating history entry if needed.
    //       This will solve the problem that going to xbox://Xbox.cdrom.com/pub/ and clicking
    //       on any of the soft links will change into that directory and update the address
    //       bar to show the real destination directory.

    // PERF: The perf of this function normally is nothing because the enum of the entire directory
    //       is done in the XboxFindFirstFile().  It will also cache the results.
    if (!InternetFindNextFileA(hConnect, pwfd))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "InternetFindNextFile(%#08lx)==\"%hs\", atrbs=%#08lx, hr=%#08lx, Time=%lums", 
        hConnect, pwfd->cFileName, pwfd->dwFileAttributes, hr, DebugStopWatch()));

    if (fAssertOnFailure && (HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES) != hr))
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }

    return hr;
}





///////////////////////////////////////////////////////////////////////////////////////////
// 2. XBOX STRs to PIDLs: These wrappers will take Xbox filenames and file paths
// that come in from the server and turn them into pidls.  These pidls contain
// both a unicode display string and the filename/path in wire bytes for future
// server requests.
///////////////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************\
    FUNCTION: XboxSetCurrentDirectoryPidlWrap

    DESCRIPTION:
        Change the current directory to the one specified.

    PARAMETERS:
        pidlXboxPath: If this is NULL, then go to "\".
\*****************************************************************************/
HRESULT XboxSetCurrentDirectoryPidlWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCITEMIDLIST pidlXboxPath, BOOL fAbsolute, BOOL fOnlyDirs)
{
    WIRECHAR wXboxPath[MAX_PATH];
    LPWIRESTR pwXboxPath = wXboxPath;
    HRESULT hr = S_OK;
    
    // If pidlXboxPath is NULL, then go to "\".
    if (pidlXboxPath)
    {
        hr = GetWirePathFromPidl(pidlXboxPath, wXboxPath, ARRAYSIZE(wXboxPath), fOnlyDirs);
        if (!fAbsolute)
            pwXboxPath++;    // Skip past the starting '\'
    }
    else
        StrCpyNA(wXboxPath, SZ_URL_SLASHA, ARRAYSIZE(wXboxPath));

    if (SUCCEEDED(hr))
        hr = XboxSetCurrentDirectoryWrap(hConnect, fAssertOnFailure, pwXboxPath); 

    return hr;
}

HRESULT XboxGetCurrentDirectoryPidlWrap(HINTERNET hConnect, BOOL fAssertOnFailure, CWireEncoding * pwe, LPITEMIDLIST * ppidlXboxPath)
{
    WIRECHAR wXboxPath[MAX_PATH];
    HRESULT hr = XboxGetCurrentDirectoryWrap(hConnect, fAssertOnFailure, wXboxPath, ARRAYSIZE(wXboxPath));

    *ppidlXboxPath = NULL;
    if (SUCCEEDED(hr))
        hr = CreateXboxPidlFromXboxWirePath(wXboxPath, pwe, NULL, ppidlXboxPath, TRUE, TRUE);

    return hr;
}

HRESULT XboxFindFirstFilePidlWrap(HINTERNET hConnect, BOOL fAssertOnFailure, CMultiLanguageCache * pmlc,
        CWireEncoding * pwe, LPCWIRESTR pwFilterStr, LPITEMIDLIST * ppidlXboxItem, DWORD dwINetFlags, DWORD_PTR dwContext, HINTERNET * phFindHandle)
{
    XBOX_FIND_DATA wfd;

    *phFindHandle = NULL;
    HRESULT hr = XboxFindFirstFileWrap(hConnect, fAssertOnFailure, pwFilterStr, &wfd, dwINetFlags, dwContext, phFindHandle);
    
    *ppidlXboxItem = NULL;

    if (SUCCEEDED(hr))
    {
        // Skip "." and ".." entries.
        if (!(wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) || IS_VALID_FILE(wfd.cFileName))
            hr = pwe->CreateXboxItemID(pmlc, &wfd, ppidlXboxItem);
        else
            hr = InternetFindNextFilePidlWrap(*phFindHandle, fAssertOnFailure, pmlc, pwe, ppidlXboxItem);

        if (FAILED(hr) && *phFindHandle)
        {
            InternetCloseHandle(*phFindHandle);
            *phFindHandle = NULL;
        }
    }

    return hr;
}


HRESULT InternetFindNextFilePidlWrap(HINTERNET hConnect, BOOL fAssertOnFailure, CMultiLanguageCache * pmlc, CWireEncoding * pwe, LPITEMIDLIST * ppidlXboxItem)
{
    XBOX_FIND_DATA wfd;
    HRESULT hr = InternetFindNextFileWrap(hConnect, fAssertOnFailure, &wfd);
    
    *ppidlXboxItem = NULL;

    if (SUCCEEDED(hr))
    {
        ASSERT(pmlc);   // We use this often enought that this might as well exist.
        // Skip "." and ".." entries.
        if (!(wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) || IS_VALID_FILE(wfd.cFileName))
            hr = pwe->CreateXboxItemID(pmlc, &wfd, ppidlXboxItem);
        else
            hr = InternetFindNextFilePidlWrap(hConnect, fAssertOnFailure, pmlc, pwe, ppidlXboxItem);
    }

    return hr;
}

HRESULT XboxRenameFilePidlWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCITEMIDLIST pidlExisting, LPCITEMIDLIST pidlNew)
{
    return XboxRenameFileWrap(hConnect, fAssertOnFailure, XboxPidl_GetLastItemWireName(pidlExisting), XboxPidl_GetLastItemWireName(pidlNew));
}


HRESULT XboxGetFileExPidlWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCITEMIDLIST pidlXboxPath/*Src*/, LPCWSTR pwzFilePath/*Dest*/, BOOL fFailIfExists,
                       DWORD dwFlagsAndAttributes, DWORD dwFlags, DWORD_PTR dwContext)
{
    return XboxGetFileExWrap(hConnect, fAssertOnFailure, XboxPidl_GetLastItemWireName(pidlXboxPath), pwzFilePath, fFailIfExists, dwFlagsAndAttributes, dwFlags, dwContext);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxdhlp.cpp ===
/*****************************************************************************\
    FILE: xboxdhlp.cpppp
    
    DESCRIPTION:
        Replace strings in a dialog template with attributes about an XBOX
    item (Xbox server, Xbox dir, or Xbox file).
\*****************************************************************************/

#include "priv.h"
#include "xboxurl.h"
#include "xboxdhlp.h"

#define SZ_WSPRINTFSTR_S            TEXT("%s")
#define SZ_WSPRINTFSTR_U            TEXT("%u")



class CSizeHolder
{
public:
    BOOL IsAllFolders(void) {return m_fAllFolders;};
    void FoundNonFolder(void) {m_fAllFolders = FALSE;};

    HRESULT GetError(void) {return m_hr;};
    void SetError(HRESULT hr) {m_hr = hr;};

    void AddSize(ULONGLONG ullSizeToAdd) { m_ullTotalSize += ullSizeToAdd;};
    ULONGLONG GetTotalSize(void) {return m_ullTotalSize;};

    CSizeHolder() {m_ullTotalSize = 0; m_fAllFolders = TRUE; m_hr = S_OK;};
    ~CSizeHolder() {};

private:
    BOOL    m_fAllFolders;
    HRESULT m_hr;
    ULONGLONG   m_ullTotalSize;
};



HRESULT CXboxDialogTemplate::_ReinsertDlgText(HWND hwnd, LPCVOID pv, LPCTSTR ptszFormat)
{
    TCHAR szDlgTemplate[256];
    TCHAR szFinalString[1024];            // wnsprintf maxes at 1024
    
    GetWindowText(hwnd, szDlgTemplate, ARRAYSIZE(szDlgTemplate));
    wnsprintf(szFinalString, ARRAYSIZE(szFinalString), szDlgTemplate, pv);
    
    // Are they the same?
    if (!StrCmp(szDlgTemplate, szFinalString))
        wnsprintf(szFinalString, ARRAYSIZE(szFinalString), ptszFormat, pv); // Yes
    
    SetWindowText(hwnd, szFinalString);
    return S_OK;
}


/*****************************************************************************\
    FUNCTION: _ReplaceIcon
    
    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxDialogTemplate::_ReplaceIcon(HWND hwnd, HICON hicon)
{
    if (hicon)
    {
        hicon = (HICON)SendMessage(hwnd, STM_SETICON, (WPARAM)hicon, 0L);
        if (hicon)
            DestroyIcon(hicon);
    }
    return S_OK;
}

/*****************************************************************************\
    FUNCTION: _InitIcon
    
    DESCRIPTION:
        _HACKHACK_  We go straight to CXboxIcon to get the pxi
    instead of going through CXboxFolder.  Same effect, but
    saves some memory allocations.  What's more important,
    we don't necessarily have a psf to play with, so we really
    have no choice.

    Yes, it's gross.
\*****************************************************************************/
HRESULT CXboxDialogTemplate::_InitIcon(HWND hwnd, CXboxFolder * pff, CXboxPidlList * pflHfpl)
{
    IExtractIcon * pxi;
    HRESULT hr;
    
    if (pflHfpl && pflHfpl->GetCount() == 1)
    {
        SHFILEINFO sfi;
        hr = XboxPidl_GetFileInfo(pflHfpl->GetPidl(0), &sfi, SHGFI_ICON | SHGFI_LARGEICON);
        if (SUCCEEDED(hr))
            hr = _ReplaceIcon(hwnd, sfi.hIcon);
    }
    else
    {
        hr = CXboxIcon_Create(pff, pflHfpl, IID_IExtractIcon, (LPVOID *)&pxi);
        if (EVAL(SUCCEEDED(hr)))
        {
            TCHAR szPath[MAX_PATH];
            int i;
            UINT ui;
            
            hr = pxi->GetIconLocation(0, szPath, ARRAYSIZE(szPath), &i, &ui);
            if (EVAL(SUCCEEDED(hr)))
            {
                CHAR szPathAnsi[MAX_PATH];
                
                SHTCharToAnsi(szPath, szPathAnsi, ARRAYSIZE(szPathAnsi));
                hr = _ReplaceIcon(hwnd, ExtractIconA(g_hinst, szPathAnsi, i));
            }
            
            ASSERT(pxi);
            pxi->Release();
        }
    }
    
    return hr;
}


void GetItemName(CXboxFolder * pff, CXboxPidlList * pflHfpl, LPWSTR pwzName, DWORD cchSize)
{
    // Are multiple items selected?
    if (1 < pflHfpl->GetCount())
        LoadString(HINST_THISDLL, IDS_SEVERAL_SELECTED, pwzName, cchSize);
    else
    {
        LPCITEMIDLIST pidl;
    
        if (0 == pflHfpl->GetCount())
            pidl = XboxID_GetLastIDReferense(pff->GetPrivatePidlReference());
        else
            pidl = XboxID_GetLastIDReferense(pflHfpl->GetPidl(0));

        if (EVAL(pidl))
            XboxPidl_GetDisplayName(pidl, pwzName, cchSize);
    }
}


BOOL CanEditName(CXboxFolder * pff, CXboxPidlList * pflHfpl)
{
    int nNumItems = pflHfpl->GetCount();
    BOOL fCanRename = TRUE;

    // we can edit except for multiply selected items
    if (2 <= nNumItems)
        fCanRename = FALSE;
    else
    {
        // If they chose the background properties for a server,
        // we won't let the change the server name.
        if (0 == nNumItems)
        {
            LPCITEMIDLIST pidlFolder = pff->GetPrivatePidlReference();

            if (pidlFolder && (ILIsEmpty(pidlFolder) || (ILIsEmpty(_ILNext(pidlFolder)))))
            {
                fCanRename = FALSE;
            }
        }
        else if (1 == nNumItems)
        {
            // Now I'm worried that pflHfpl->GetPidl(0) is a PIDL pointing to
            // an XBOX Server.
            LPCITEMIDLIST pidl = pflHfpl->GetPidl(0);

            if (pidl && !ILIsEmpty(pidl) &&
                XboxID_IsServerItemID(pidl) && ILIsEmpty(_ILNext(pidl)))
            {
                fCanRename = FALSE;
            }
        }
    }

    return fCanRename;
}


/*****************************************************************************\
    FUNCTION: _InitName
    
    DESCRIPTION:
        Get the name of the object in the pflHfpl.  If there is more than one
    thing, use ellipses.
\*****************************************************************************/
HRESULT CXboxDialogTemplate::_InitName(HWND hwnd, CXboxFolder * pff, CXboxPidlList * pflHfpl)
{
    HRESULT hr = S_OK;
    WCHAR wzName[MAX_PATH];

    GetItemName(pff, pflHfpl, wzName, ARRAYSIZE(wzName));
    hr = _ReinsertDlgText(hwnd, wzName, SZ_WSPRINTFSTR_S);
    // We only use the static filename when more than one item is selected
    // because that is the case that we can't do a rename.  Are there
    // multiple items selected?
    if (m_fEditable && CanEditName(pff, pflHfpl))
    {
        // Hide because we will use IDC_FILENAME_EDITABLE instead.
        ShowEnableWindow(hwnd, FALSE);
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: _InitNameEditable
    
    DESCRIPTION:
        Get the name of the object in the pflHfpl.  If there is more than one
    thing, use ellipses.
\*****************************************************************************/
HRESULT CXboxDialogTemplate::_InitNameEditable(HWND hwnd, CXboxFolder * pff, CXboxPidlList * pflHfpl)
{
    HRESULT hr = S_OK;
    TCHAR szName[MAX_PATH];

    GetItemName(pff, pflHfpl, szName, ARRAYSIZE(szName));
    hr = _ReinsertDlgText(hwnd, szName, SZ_WSPRINTFSTR_S);

    // We only use the static filename when more than one item is selected
    // because that is the case that we can't do a rename.  Are there
    // multiple items selected?
    if (!m_fEditable || !CanEditName(pff, pflHfpl))
    {
        // Hide because we will use IDC_FILENAME_EDITABLE instead.
        ShowEnableWindow(hwnd, FALSE);
    }

    return hr;
}


void GetNameFromPidlList(CXboxFolder * pff, CXboxPidlList * pflHfpl, LPWSTR pwzName, DWORD cchSize)
{
    LPCITEMIDLIST pidl;
    
    if (0 == pflHfpl->GetCount())
        pidl = XboxID_GetLastIDReferense(pff->GetPrivatePidlReference());
    else
        pidl = XboxID_GetLastIDReferense(pflHfpl->GetPidl(0));

    if (EVAL(pidl))
        StrCpyNW(pwzName, XboxPidl_GetLastItemDisplayName(pidl), cchSize);
}


/*****************************************************************************\
    FUNCTION: _InitType
    
    DESCRIPTION:
        Get the type of the pidls identified by pflHfpl.
\*****************************************************************************/
HRESULT CXboxDialogTemplate::_InitType(HWND hwnd, CXboxFolder * pff, CXboxPidlList * pflHfpl)
{
    TCHAR szType[MAX_URL_STRING];
    
    szType[0] = 0;
    switch (pflHfpl->GetCount())
    {
    case 0:
        {
            // Find out if it's a folder or an Xbox server root.
            LPCITEMIDLIST pidl = XboxID_GetLastIDReferense(pff->GetPrivatePidlReference());
            if (EVAL(pidl))
                LoadString(HINST_THISDLL, (XboxID_IsServerItemID(pidl) ? IDS_ITEMTYPE_SERVER : IDS_ITEMTYPE_FOLDER), szType, ARRAYSIZE(szType));
        }
        break;
        
    case 1:
        // Just one item is selected, so get it's type.
        XboxPidl_GetFileType(pflHfpl->GetPidl(0), szType, ARRAYSIZE(szType));
        break;
        
    default:
        // Display "Several Selected" because they can span 1 type.
        LoadString(HINST_THISDLL, IDS_SEVERAL_SELECTED, szType, ARRAYSIZE(szType));
        break;
    }
    
    return _ReinsertDlgText(hwnd, szType, SZ_WSPRINTFSTR_S);
}


/*****************************************************************************\
    FUNCTION: _InitLocation
    
    DESCRIPTION:
        Get the name of the folder identified by pidl.
\*****************************************************************************/
HRESULT CXboxDialogTemplate::_InitLocation(HWND hwnd, CXboxFolder * pff, CXboxPidlList * pidlList)
{
    HRESULT hr = E_FAIL;
    TCHAR szUrl[MAX_PATH];
    LPITEMIDLIST pidl = GetPidlFromXboxFolderAndPidlList(pff, pidlList);

    ASSERT(pidlList && pff);
    if (EVAL(pidl))
    {
        // If more than one items are selected, then we only want to
        // show the common location.
        if (1 < pidlList->GetCount())
            ILRemoveLastID(pidl);
        hr = UrlCreateFromPidl(pidl, SHGDN_FORADDRESSBAR, szUrl, ARRAYSIZE(szUrl), 0, TRUE);
        if (SUCCEEDED(hr))
        {
            hr = _ReinsertDlgText(hwnd, szUrl, SZ_WSPRINTFSTR_S);
        }
        ILFree(pidl);
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: _InitSizeTally
    
    DESCRIPTION:
        Total up the size of each file referred to in the pidl.
\*****************************************************************************/
int CXboxDialogTemplate::_InitSizeTally(LPVOID pvPidl, LPVOID pvSizeHolder)
{
    BOOL fSuccess = TRUE;
    LPCITEMIDLIST pidl = (LPCITEMIDLIST) pvPidl;
    CSizeHolder * pSizeHolder = (CSizeHolder *) pvSizeHolder;

    // Did we get a valid size and is pSizeHolder still valid?
    if (SUCCEEDED(pSizeHolder->GetError()))
    {
        // Yes, so keep accumulating if it's a file.
        if (!XboxID_IsServerItemID(pidl) && !XboxItemID_IsDirectory(pidl, FALSE))
        {
            ULARGE_INTEGER uliPidlFileSize;
            uliPidlFileSize.QuadPart = XboxItemID_GetFileSize(pidl);

            pSizeHolder->AddSize(uliPidlFileSize.QuadPart);
            pSizeHolder->FoundNonFolder();  // Show that at least one was a file.
            if (!uliPidlFileSize.QuadPart)
                fSuccess = FALSE;
        }
    }
    else
    {
        pSizeHolder->SetError(E_FAIL);
        fSuccess = FALSE;
    }

    return fSuccess;
}

#define MAX_FILE_SIZE           64

HRESULT GetFileSizeFromULargeInteger(ULARGE_INTEGER uliSize, LPTSTR pszSizeStr, DWORD cchSize)
{
    WCHAR wzSizeStr[MAX_FILE_SIZE];
    LONGLONG llSize = (LONGLONG) uliSize.QuadPart;

    if (StrFormatByteSizeW(llSize, wzSizeStr, ARRAYSIZE(wzSizeStr)))
        SHUnicodeToTChar(wzSizeStr, pszSizeStr, cchSize);
    else
    {
        CHAR szStrStrA[MAX_FILE_SIZE];

        StrFormatByteSizeA(uliSize.LowPart, szStrStrA, ARRAYSIZE(szStrStrA));
        SHAnsiToTChar(szStrStrA, pszSizeStr, cchSize);
    }

    return S_OK;
}


/*****************************************************************************\
    FUNCTION: _InitSize
    
    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxDialogTemplate::_InitSize(HWND hwnd, HWND hwndLabel, CXboxFolder * pff, CXboxPidlList * pflHfpl)
{
    HRESULT hr;
    TCHAR szSizeStr[MAX_FILE_SIZE];
    CSizeHolder sizeHolder;

    szSizeStr[0] = 0;
    // GetCount maybe 0 if we are doing the background folder.
    if (0 < pflHfpl->GetCount())
    {
        pflHfpl->Enum(CXboxDialogTemplate::_InitSizeTally, (LPVOID) &sizeHolder);
        if (EVAL(SUCCEEDED(sizeHolder.GetError())))
        {
            // Are there files sizes to display?
            if (!sizeHolder.IsAllFolders())
            {
                TCHAR szBytesStr[MAX_FILE_SIZE];
                TCHAR szBytesStrFormatted[MAX_FILE_SIZE];
                TCHAR szCondencedSizeStr[MAX_FILE_SIZE];
                ULARGE_INTEGER uliTotal;
                uliTotal.QuadPart = sizeHolder.GetTotalSize();

                NUMBERFMT numfmt = {0, 0, 3, TEXT(""), TEXT(","), 0};

                EVAL(SUCCEEDED(GetFileSizeFromULargeInteger(uliTotal, szCondencedSizeStr, ARRAYSIZE(szCondencedSizeStr))));
                // BUGBUG: How do we wsprintf 64 bits?
                wnsprintf(szBytesStr, ARRAYSIZE(szBytesStr), TEXT("%u"), (DWORD)uliTotal.LowPart);
                GetNumberFormat(LOCALE_USER_DEFAULT, 0, szBytesStr, &numfmt, szBytesStrFormatted, ARRAYSIZE(szBytesStrFormatted));
                wnsprintf(szSizeStr, ARRAYSIZE(szSizeStr), TEXT("%s (%s bytes)"), szCondencedSizeStr, szBytesStrFormatted);
            }
        }
    }

    if (szSizeStr[0])
    {
        hr = _ReinsertDlgText(hwnd, szSizeStr, SZ_WSPRINTFSTR_S);
    }
    else
    {
        // If more than one item was selected...
        // remove both the label and the value.
        ShowEnableWindow(hwnd, FALSE);
        if (hwndLabel)
            ShowEnableWindow(hwndLabel, FALSE);

        hr = S_OK;
    }

    return hr;
}

// WINVER 0x0500 definition
#ifndef WS_EX_LAYOUTRTL
#define WS_EX_LAYOUTRTL     0x00400000L // Right to left mirroring
#endif


/*****************************************************************************\
    FUNCTION: _InitTime
    
    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxDialogTemplate::_InitTime(HWND hwnd, HWND hwndLabel, CXboxFolder * pff, CXboxPidlList * pflHfpl)
{
    TCHAR szDateTime[MAX_PATH];
    HRESULT hr = E_FAIL;
    DWORD dwFlags = FDTF_SHORTTIME | FDTF_LONGDATE;
    LCID locale = GetUserDefaultLCID();

    if ((PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_ARABIC)
        || (PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_HEBREW))
        {
            DWORD dwExStyle = GetWindowLong(hwnd, GWL_EXSTYLE);

            if ((BOOLIFY(dwExStyle & WS_EX_RTLREADING)) != (BOOLIFY(dwExStyle & WS_EX_LAYOUTRTL)))
                dwFlags |= FDTF_RTLDATE;
            else
                dwFlags |= FDTF_LTRDATE;
         }      
    
    switch (pflHfpl->GetCount())
    {
    // one item was selected so get the time for that item.
    case 1:
        if (!XboxID_IsServerItemID(pflHfpl->GetPidl(0)))
        {
            FILETIME ftLastModified = XboxPidl_GetXBOXFileTime(pflHfpl->GetPidl(0));
            Misc_StringFromFileTime(szDateTime, ARRAYSIZE(szDateTime), &ftLastModified, dwFlags);
            hr = S_OK;
        }
        break;

    // zero items selected means get the properties for the background folder
    case 0:
    {
        LPCITEMIDLIST pidl = XboxID_GetLastIDReferense(pff->GetPrivatePidlReference());
    
        // The user will get 'N/A' for the 'Server' folder. (i.e. xbox://ohserv/)
        if (EVAL(pidl) && !XboxID_IsServerItemID(pidl))
        {
            FILETIME ftLastModified = XboxPidl_GetXBOXFileTime(pidl);
            Misc_StringFromFileTime(szDateTime, ARRAYSIZE(szDateTime), &ftLastModified, dwFlags);
            hr = S_OK;
        }
        // Don't free pidl because we have a pointer to someone else's copy.
    }
    }

    if (SUCCEEDED(hr))
    {
        hr = _ReinsertDlgText(hwnd, szDateTime, SZ_WSPRINTFSTR_S);
    }
    else
    {
        // If more than one item was selected...
        // remove both the label and the value.
        ShowEnableWindow(hwnd, FALSE);
        if (hwndLabel)
            ShowEnableWindow(hwndLabel, FALSE);

        hr = S_OK;
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: _InitCount
    
    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxDialogTemplate::_InitCount(HWND hwnd, CXboxFolder * pff, CXboxPidlList * pflHfpl)
{
    return _ReinsertDlgText(hwnd, (LPVOID)pflHfpl->GetCount(), SZ_WSPRINTFSTR_U);
}


/*****************************************************************************\
    FUNCTION: InitDialog
    
    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxDialogTemplate::InitDialog(HWND hDlg, BOOL fEditable, UINT id, CXboxFolder * pff, CXboxPidlList * pPidlList)
{
    HRESULT hr = S_OK;
    int nDlgTemlItem;

    m_fEditable = fEditable;
    for (nDlgTemlItem = 0; nDlgTemlItem < DLGTEML_MAX; nDlgTemlItem++)
    {
        HRESULT hrTemp = S_OK;

        HWND hwnd = GetDlgItem(hDlg, id + nDlgTemlItem);
        HWND hwndLabel = GetDlgItem(hDlg, id + nDlgTemlItem + DLGTEML_LABEL);
        if (hwnd)
        {
            switch (nDlgTemlItem)
            {
            case DLGTEML_FILENAME:          hrTemp = _InitName(hwnd, pff, pPidlList); break;
            case DLGTEML_FILENAMEEDITABLE:  hrTemp = _InitNameEditable(hwnd, pff, pPidlList); break;
            case DLGTEML_FILEICON:          hrTemp = _InitIcon(hwnd, pff, pPidlList); break;
            case DLGTEML_FILESIZE:          hrTemp = _InitSize(hwnd, hwndLabel, pff, pPidlList); break;
            case DLGTEML_FILETIME:          hrTemp = _InitTime(hwnd, hwndLabel, pff, pPidlList); break;
            case DLGTEML_FILETYPE:          hrTemp = _InitType(hwnd, pff, pPidlList); break;
            case DLGTEML_LOCATION:          hrTemp = _InitLocation(hwnd, pff, pPidlList); break;
            case DLGTEML_COUNT:             hrTemp = _InitCount(hwnd, pff, pPidlList); break;
            default:
                ASSERT(0);  // What are you thinking?
                break;
            }
        }

        if (EVAL(SUCCEEDED(hr)))
            hr = hrTemp;        // Propogate out the worst error.
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: OnClose
    
    DESCRIPTION:
\*****************************************************************************/
BOOL CXboxDialogTemplate::OnClose(HWND hdlg, HWND hwndBrowser, CXboxFolder * pff, CXboxPidlList * pPidlList)
{
    BOOL fCanClose = TRUE;

    // If the IDC_FILENAME_EDITABLE field is showing, then the user may have done
    // a rename.  Check if that happened and if so, do it now.
    if (IsWindowVisible(GetDlgItem(hdlg, IDC_FILENAME_EDITABLE)))
    {
        WCHAR wzOldName[MAX_PATH];
        WCHAR wzNewName[MAX_PATH];

        GetNameFromPidlList(pff, pPidlList, wzOldName, ARRAYSIZE(wzOldName));
        EVAL(GetWindowTextW(GetDlgItem(hdlg, IDC_FILENAME_EDITABLE), wzNewName, ARRAYSIZE(wzNewName)));

        // Was the name changed?
        if (StrCmpW(wzOldName, wzNewName))
        {
            // Yes, so change it.
            IShellFolder * psfParent = NULL;
            CXboxFolder * pffParent = pff;
            LPCITEMIDLIST pidlItem;

            if (0 == pPidlList->GetCount())
            {
                // We use pidlTarget mainly because we want to assure that the
                // ChangeNotifies are fired with pidlTarget.
                LPITEMIDLIST pidlParent = pff->GetPublicTargetPidlClone();

                if (pidlParent)
                {
                    ILRemoveLastID(pidlParent);
                    pidlItem = XboxID_GetLastIDReferense(pff->GetPrivatePidlReference());
                    IEBindToObject(pidlParent, &psfParent); 
                    ILFree(pidlParent);
                }
            }
            else
            {
                pidlItem = XboxID_GetLastIDReferense(pPidlList->GetPidl(0));
                EVAL(SUCCEEDED(pff->QueryInterface(IID_IShellFolder, (void **) &psfParent)));
            }

            if (EVAL(psfParent))
            {
                if (EVAL(pidlItem))
                    fCanClose = ((S_OK == psfParent->SetNameOf(hwndBrowser, pidlItem, wzNewName, NULL, NULL)) ? TRUE : FALSE);

                psfParent->Release();
            }
        }
    }

    return fCanClose;
}


BOOL CXboxDialogTemplate::HasNameChanged(HWND hdlg, CXboxFolder * pff, CXboxPidlList * pPidlList)
{
    BOOL fNameChanged = FALSE;

    // If the IDC_FILENAME_EDITABLE field is showing, then the user may have done
    // a rename.  Check if that happened and if so, do it now.
    if (IsWindowVisible(GetDlgItem(hdlg, IDC_FILENAME_EDITABLE)))
    {
        TCHAR szOldName[MAX_PATH];
        TCHAR szNewName[MAX_PATH];

        GetNameFromPidlList(pff, pPidlList, szOldName, ARRAYSIZE(szOldName));
        EVAL(GetWindowText(GetDlgItem(hdlg, IDC_FILENAME_EDITABLE), szNewName, ARRAYSIZE(szNewName)));

        // Was the name changed?
        if (StrCmp(szOldName, szNewName))
        {
            // Yes, so change it.
            fNameChanged = TRUE;
        }
    }

    return fNameChanged;
}


HRESULT CXboxDialogTemplate::InitDialogWithFindData(HWND hDlg, UINT id, CXboxFolder * pff, const XBOX_FIND_DATA * pwfd, LPCWIRESTR pwWirePath, LPCWSTR pwzDisplayPath)
{
    XBOX_FIND_DATA wfd = *pwfd;
    LPITEMIDLIST pidl;
    HRESULT hr;
    
    ASSERT(pwfd);

    StrCpyNA(wfd.cFileName, pwWirePath, ARRAYSIZE(wfd.cFileName));
    hr = XboxItemID_CreateReal(&wfd, pwzDisplayPath, &pidl);
    if (EVAL(SUCCEEDED(hr)))
    {
        CXboxPidlList * pfpl = NULL;
        
        hr = CXboxPidlList_Create(1, (LPCITEMIDLIST *) &pidl, &pfpl);
        if (EVAL(SUCCEEDED(hr)))
        {
            hr = InitDialog(hDlg, FALSE, id, pff, pfpl);
            pfpl->Release();
        }

        ILFree(pidl);
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxcf.cpp ===
/*****************************************************************************
 *
 *    xboxcf.cpp - IClassFactory interface
 *
 *****************************************************************************/

#include "priv.h"
#include "xbwebvw.h"
#include "xbnmspc.h"


/*****************************************************************************
 *
 *    CXboxFactory
 *
 *
 *****************************************************************************/

class CXboxFactory : public IClassFactory
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    
    // *** IClassFactory ***
    virtual STDMETHODIMP CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObject);
    virtual STDMETHODIMP LockServer(BOOL fLock);

public:
    CXboxFactory(REFCLSID rclsid);
    ~CXboxFactory(void);

    // Friend Functions
    friend HRESULT CXboxFactory_Create(REFCLSID rclsid, REFIID riid, LPVOID * ppvObj);

protected:
    int                     m_cRef;
    CLSID                   m_rclsid;
};



/*****************************************************************************
 *    IClassFactory::CreateInstance
 *****************************************************************************/

HRESULT CXboxFactory::CreateInstance(IUnknown * punkOuter, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hres = ResultFromScode(REGDB_E_CLASSNOTREG);

    if (!punkOuter)
    {
        if (IsEqualIID(m_rclsid, CLSID_XboxFolder))
            hres = CXboxFolder_Create(riid, ppvObj);
        else if (IsEqualIID(m_rclsid, CLSID_XboxWebView))
            hres = CXboxWebView_Create(riid, ppvObj);
        else if (IsEqualIID(m_rclsid, CLSID_XboxDataObject))
            hres = CXboxObj_Create(riid, ppvObj);
        else
            ASSERT(0);  // What are you looking for?
    }
    else
    {        // Does anybody support aggregation any more?
        hres = ResultFromScode(CLASS_E_NOAGGREGATION);
    }

    return hres;
}

/*****************************************************************************
 *
 *    IClassFactory::LockServer
 *
 *    What a stupid function.  Locking the server is identical to
 *    creating an object and not releasing it until you want to unlock
 *    the server.
 *
 *****************************************************************************/

HRESULT CXboxFactory::LockServer(BOOL fLock)
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();

    return S_OK;
}

/*****************************************************************************
 *
 *    CXboxFactory_Create
 *
 *****************************************************************************/

HRESULT CXboxFactory_Create(REFCLSID rclsid, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hres;

    if (GetShdocvwVersion() < 5)
    {
        // Check if we are running under older IE's and fail so that
        // side by side IE4, IE5 can work
        hres = ResultFromScode(E_NOINTERFACE);
    }
    else if (IsEqualIID(riid, IID_IClassFactory))
    {
        *ppvObj = (LPVOID) new CXboxFactory(rclsid);
        hres = (*ppvObj) ? S_OK : E_OUTOFMEMORY;
    }
    else
        hres = ResultFromScode(E_NOINTERFACE);

    return hres;
}





/****************************************************\
    Constructor
\****************************************************/
CXboxFactory::CXboxFactory(REFCLSID rclsid) : m_cRef(1)
{
    m_rclsid = rclsid;
    DllAddRef();
    LEAK_ADDREF(LEAK_CXboxFactory);
}


/****************************************************\
    Destructor
\****************************************************/
CXboxFactory::~CXboxFactory()
{
    DllRelease();
    LEAK_DELREF(LEAK_CXboxFactory);
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CXboxFactory::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CXboxFactory::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CXboxFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
    {
        *ppvObj = SAFECAST(this, IClassFactory *);
    }
    else
    {
        TraceMsg(TF_XBOXQI, "CXboxFactory::QueryInterface() failed.");
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\view.cpp ===
/*****************************************************************************\
    FILE: view.cpp

    DESCRIPTION:
        This is our ShellView which implements XBOX specific behavior.  We get
    the default DefView implementation and then use IShellFolderViewCB to 
    override behavior specific to us.
\*****************************************************************************/

#include "priv.h"
#include "view.h"
#include "xboxobj.h"
#include "statusbr.h"
#include "dialogs.h"
#include <inetcpl.h>
#include <htmlhelp.h>
#include "newmenu.h"


extern ULONG g_cRef_CXboxView;

// {FBDB45F0-DBF8-11d2-BB9B-006097DF5BD4}   Private to xbnmspc.dll, NEVER EVER use outside of this DLL
const GUID IID_CXboxViewPrivThis = { 0xfbdb45f0, 0xdbf8, 0x11d2, { 0xbb, 0x9b, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4 } };


/*****************************************************************************
 *
 *      COLINFO, c_rgci
 *
 *      Column information for DVM_GETDETAILSOF.
 *
 *****************************************************************************/

const struct COLINFO {
    UINT cchCol;
    UINT uiFmt;
} c_rgci[] = {
    {   30, LVCFMT_LEFT },
    {   10, LVCFMT_RIGHT },
    {   20, LVCFMT_LEFT },
    {   20, LVCFMT_LEFT },
};


BOOL CXboxView::IsForegroundThread(void)
{
    return (GetCurrentThreadId() == m_nThreadID);
}


/*****************************************************************************\
    FUNCTION: _MOTDDialogProc

    DESCRIPTION:
\*****************************************************************************/
INT_PTR CALLBACK CXboxView::_MOTDDialogProc(HWND hDlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = FALSE;

    switch (wm)
    {
    case WM_INITDIALOG:
        {
            CXboxView * pThis = (CXboxView *) lParam;
            CXboxGlob * pfg = pThis->m_pff->GetSiteMotd();

            if (EVAL(pfg))
            {
                // TODO: NT #250018. Format the message and make it look pretty.
                //       so it doesn't have the XBOX status numbers.  We may also
                //       want to filter only the message that comes thru with
                //       status numbers 230
                EVAL(SetWindowText(GetDlgItem(hDlg, IDC_MOTDDLG_MESSAGE), pfg->GetHGlobAsTCHAR()));
                pfg->Release();
            }

        }
        break;

    case WM_COMMAND:
        if ((IDOK == GET_WM_COMMAND_ID(wParam, lParam)) ||
            (IDCANCEL == GET_WM_COMMAND_ID(wParam, lParam)))
            EndDialog(hDlg, TRUE);
        break;
    }

    return lResult;
}


/*****************************************************************************
 *
 *      _ShowMotdPsf
 *
 *      Show the motd for a particular psf.
 *
 *****************************************************************************/
void CXboxView::_ShowMotdPsf(HWND hwndOwner)
{
    DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(IDD_MOTDDLG), hwndOwner, _MOTDDialogProc, (LPARAM)this);
}

/*****************************************************************************
 *
 *      _ShowMotd
 *
 *      When Explorer finally goes idle, this procedure will be called,
 *      and we will show the XBOX site's (new) motd.
 *
 *****************************************************************************/
void CXboxView::_ShowMotd(void)
{
    m_hgtiWelcome = 0;

    if (EVAL(m_pff))
        _ShowMotdPsf(m_hwndOwner);
    else
    {
        // We got cancelled prematurely
    }
}

/*****************************************************************************
 *
 *      _OnGetDetailsOf
 *
 *      ici     - column for which information is requested
 *      pdi     -> DETAILSINFO
 *
 *      If pdi->pidl is 0, then we are asking for information about
 *      what columns to display.  If pdi->pidl is nonzero, then we
 *      are asking for particular information about the specified pidl.
 *
 *      _UNDOCUMENTED_: This callback and the DETAILSINFO structure
 *      are not documented.  Nor is the quirk about pdi->pidl as
 *      noted above.
 *
 *****************************************************************************/
#define MAX_SIZE_STR        30

HRESULT CXboxView::_OnGetDetailsOf(UINT ici, PDETAILSINFO pdi)
{
    HRESULT hr;

    if (ici < COL_MAX)
    {
        pdi->str.uType = STRRET_CSTR;
        pdi->str.cStr[0] = '\0';

        if (pdi->pidl)
        {
            switch (ici)
            {
            case COL_NAME:
                {
                    WCHAR wzDisplayName[MAX_PATH];
                    hr = XboxItemID_GetDisplayName(pdi->pidl, wzDisplayName, ARRAYSIZE(wzDisplayName));
                    if (EVAL(SUCCEEDED(hr)))
                        StringToStrRetW(wzDisplayName, &pdi->str);
                }
                break;

            case COL_SIZE:
                //  (Directories don't get a size.  Shell rules.)
                if (!XboxPidl_IsDirectory(pdi->pidl, TRUE))
                {
                    LONGLONG llSize = (LONGLONG) XboxItemID_GetFileSize(pdi->pidl);
                    WCHAR wzSizeStr[MAX_SIZE_STR];

                    if (StrFormatByteSizeW(llSize, wzSizeStr, ARRAYSIZE(wzSizeStr)))
                        SHUnicodeToAnsi(wzSizeStr, pdi->str.cStr, ARRAYSIZE(pdi->str.cStr));
                    else
                        StrFormatByteSizeA(XboxItemID_GetFileSizeLo(pdi->pidl), pdi->str.cStr, ARRAYSIZE(pdi->str.cStr));
                }
                hr = S_OK;
            break;

            case COL_TYPE:
                hr = XboxPidl_GetFileTypeStrRet(pdi->pidl, &pdi->str);
                break;

            case COL_MODIFIED:
                {
                    TCHAR szDateTime[MAX_PATH];
                    FILETIME ftLastModified = XboxPidl_GetXBOXFileTime(pdi->pidl);
                    DWORD dwFlags = FDTF_SHORTDATE | FDTF_SHORTTIME;
                    switch (pdi->fmt)
                    {
                        case LVCFMT_LEFT_TO_RIGHT :
                            dwFlags |= FDTF_LTRDATE;
                        break;

                        case LVCFMT_RIGHT_TO_LEFT :
                            dwFlags |= FDTF_RTLDATE;
                        break;
                    }
                    Misc_StringFromFileTime(szDateTime, ARRAYSIZE(szDateTime), &ftLastModified, dwFlags);
                    hr = StringToStrRetW(szDateTime, &pdi->str);
                }
                break;
            }

        }
        else
        {
            WCHAR wzColumnLable[MAX_PATH];

            pdi->fmt = c_rgci[ici].uiFmt;
            pdi->cxChar = c_rgci[ici].cchCol;

            EVAL(LoadStringW(HINST_THISDLL, IDS_HEADER_NAME(ici), wzColumnLable, ARRAYSIZE(wzColumnLable)));
            hr = StringToStrRetW(wzColumnLable, &pdi->str);
        }
    }
    else
        hr = E_NOTIMPL;

    return hr;
}


/*****************************************************************************\
    FUNCTION: _OnColumnClick

    DESCRIPTION:
      _UNDOCUMENTED_: This callback and its parameters are not documented.
      _UNDOCUMENTED_: ShellFolderView_ReArrange is not documented.

    PARAMETERS:
      hwnd    - view window
      ici     - column that was clicked
\*****************************************************************************/
HRESULT CXboxView::_OnColumnClick(UINT ici)
{
    ShellFolderView_ReArrange(m_hwndOwner, ici);

    return S_OK;
}


HRESULT CXboxView::_OnAddPropertyPages(SFVM_PROPPAGE_DATA * pData)
{
    return AddXBOXPropertyPages(pData->pfn, pData->lParam, &m_hinstInetCpl, m_psfv);
}


/*****************************************************************************\
    FUNCTION: _OnInitMenuPopup

    DESCRIPTION:
        We use IContextMenu::QueryContectMenu() to merge background items into
    the File menu.  This doesn't work on browser only because it's not supported
    so we would like to see if this works.

    PARAMETERS:
\*****************************************************************************/
HRESULT CXboxView::_OnInitMenuPopup(HMENU hmenu, UINT idCmdFirst, UINT nIndex)
{
    return S_OK;
}


/*****************************************************************************\
    FUNCTION: _OnMergeMenu

    DESCRIPTION:
      _UNDOCUMENTED_: This callback and its parameters are not documented.
      _UNDOCUMENTED_: Nothing about menu merging is documented.

    PARAMETERS:
      pqcm    - QueryContextMenu info
\*****************************************************************************/
HRESULT CXboxView::_OnMergeMenu(LPQCMINFO pqcm)
{
    HRESULT hr;
    HMENU hmenu = LoadMenu(HINST_THISDLL, MAKEINTRESOURCE(IDM_XBOXMERGE));

    if (SHELL_VERSION_W95NT4 != GetShellVersion())
    {
        // We prefer to add "New" and "Login As" via
        // IContextMenu::QueryContextMenu() but it wasn't implemented
        // in browser only.  The IDM_XBOXMERGE menu contains a second
        // copy for the browser only case so we need to remove them
        // if it's not browser only.
        EVAL(DeleteMenu(hmenu, FCIDM_MENU_FILE, MF_BYCOMMAND));
    }

    if (SHELL_VERSION_IE4 < GetShellVersion())
    {
        // Remove "Help.XBOX Help" because we will have that work done
        // in "Help.Help Topics" on NT5 and after.  We don't do this for
        // earlier versions of shell32 because shell32 in NT5 is the 
        // first version to support "HtmlHelp" over WinHelp.  This is
        // needed because XBOX's help is stored in IE's HTML Help files.
        EVAL(DeleteMenu(hmenu, IDC_ITEM_XBOXHELP, MF_BYCOMMAND));
    }

    if (hmenu)
    {
        MergeMenuHierarchy(pqcm->hmenu, hmenu, pqcm->idCmdFirst, pqcm->idCmdLast);
        m_idMergedMenus = pqcm->idCmdFirst;
        m_nMenuItemsAdded = GetMenuItemCount(hmenu);
        DestroyMenu(hmenu);

        // Remove duplicate items. (Browser Only)
        _SHPrettyMenu(pqcm->hmenu);
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    // NT #267081, some other people (IE) will reformat the StatusBar during the
    // asynch navigation.  I take this event (MergeMenus) and reformat the
    // status bar if necessary.
    _InitStatusBar();

    return hr;
}


/*****************************************************************************\
    FUNCTION: UnMergeMenu

    DESCRIPTION:

    PARAMETERS:
\*****************************************************************************/
HRESULT UnMergeMenu(HMENU hMenu, UINT idOffset, HMENU hMenuTemplate)
{
    HRESULT hr = S_OK;
    UINT nIndex;
    UINT nEnd = GetMenuItemCount(hMenuTemplate);

    for (nIndex = 0; nIndex < nEnd; nIndex++)
    {
        UINT idToDelete = GetMenuItemID(hMenuTemplate, nIndex);

        if (-1 != idToDelete)
            DeleteMenu(hMenu, (idToDelete + idOffset), MF_BYPOSITION);
        else
        {
            // It may be a submenu, so we may need to recurse.
            MENUITEMINFO mii;

            mii.cbSize = sizeof(mii);
            mii.fMask = MIIM_SUBMENU;
            mii.cch = 0;     // just in case

            if (GetMenuItemInfo(hMenuTemplate, nIndex, TRUE, &mii) && mii.hSubMenu)
            {
                // It is a sub menu, so delete those items also.
                hr = UnMergeMenu(hMenu, idOffset, mii.hSubMenu);
            }
        }
    }

    return hr;
}


HRESULT CXboxView::_OnUnMergeMenu(HMENU hMenu)
{
    HRESULT hr = S_OK;

    // Did I merge anything?
    if (m_idMergedMenus && m_nMenuItemsAdded)
    {
        HMENU hMenuXBOX = LoadMenu(HINST_THISDLL, MAKEINTRESOURCE(IDM_XBOXMERGE));

        if (hMenuXBOX)
        {
            hr = UnMergeMenu(hMenu, m_idMergedMenus, hMenuXBOX);
            DestroyMenu(hMenuXBOX);
        }

        m_idMergedMenus = 0;
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: _OnInvokeLoginAs

    DESCRIPTION:

    PARAMETERS:
\*****************************************************************************/
HRESULT CXboxView::_OnInvokeLoginAs(HWND hwndOwner)
{
    ASSERT(m_pff);
    return LoginAsViaFolder(hwndOwner, m_pff, m_psfv);
}


/*****************************************************************************\
    FUNCTION: _OnInvokeNewFolder

    DESCRIPTION:

    PARAMETERS:
\*****************************************************************************/
HRESULT CXboxView::_OnInvokeNewFolder(HWND hwndOwner)
{
    POINT pt = {0,0};

    return CreateNewFolder(hwndOwner, m_pff, NULL, m_psfv, FALSE, pt);
}


/*****************************************************************************\
    FUNCTION: _OnInvokeCommand

    DESCRIPTION:
    _UNDOCUMENTED_: This callback and its parameters are not documented.
    _UNDOCUMENTED_: ShellFolderView_ReArrange is not documented.

    PARAMETERS:
    idc     - Command being invoked
\*****************************************************************************/
HRESULT CXboxView::_OnInvokeCommand(UINT idc)
{
    HRESULT hr = S_OK;

    switch (idc)
    {
    case IDM_SORTBYNAME:
    case IDM_SORTBYSIZE:
    case IDM_SORTBYTYPE:
    case IDM_SORTBYDATE:
        ShellFolderView_ReArrange(m_hwndOwner, CONVERT_IDMID_TO_COLNAME(idc));
        break;

    case IDC_ITEM_ABOUTSITE:
        _ShowMotdPsf(m_hwndOwner);
        break;

    case IDC_ITEM_XBOXHELP:
        _OnInvokeXboxHelp(m_hwndOwner);
        break;

    case IDC_LOGIN_AS:
        _OnInvokeLoginAs(m_hwndOwner);
        break;

    case IDC_ITEM_NEWFOLDER:
        _OnInvokeNewFolder(m_hwndOwner);
        break;

#ifdef ADD_ABOUTBOX
    case IDC_ITEM_ABOUTXBOX:
        hr = DisplayAboutBox(m_hwndOwner);
        break;
#endif // ADD_ABOUTBOX

    default:
        ASSERT(0);
        hr = E_NOTIMPL;
        break;
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: _OnGetHelpText

    DESCRIPTION:
        The shell want's the Help Text but they want it in their format (Ansi
    vs. Unicode).
\*****************************************************************************/
HRESULT CXboxView::_OnGetHelpText(LPARAM lParam, WPARAM wParam)
{
    HRESULT hres = E_FAIL;
    UINT uiID = IDS_ITEM_HELP(LOWORD(wParam));
    TCHAR szHelpText[MAX_PATH];
    LPWSTR pwzHelpTextOut = (LPWSTR) lParam;    // Only one of these is correct and fUnicodeShell indicates which one.
    LPSTR pszHelpTextOut = (LPSTR) lParam;

    pwzHelpTextOut[0] = L'\0';   // Terminate string. (Ok if it's ANSI)

    szHelpText[0] = TEXT('\0');
    // This will fail for some items that the shell will provide for us.
    // These include View.ArrangeIcon.AutoArrange.
    // BUGBUG: This currently doesn't work for everything in the View.ArrangeIcon
    //         menu except AutoArrange because uiID is 30-33, 
    //         not 40-43 (IDS_HEADER_HELP(COL_NAME) - IDS_HEADER_HELP(COL_MODIFIED)).
    //         This will require changing the resource IDs but that will screw up
    //         the localizers and require changing IDS_HEADER_NAME().
    if (LoadString(HINST_THISDLL, uiID, szHelpText, ARRAYSIZE(szHelpText)))
    {
        HMODULE hMod = GetModuleHandle(TEXT("shell32.dll"));

        if (hMod)
        {
            BOOL fUnicodeShell = (NULL != GetProcAddress(hMod, "WOWShellExecute"));

            // NOTE: This sucks, but DVM_GETHELPTEXT will want a UNICODE string if we are running
            //       on NT and an Ansi string if we are running on Win95.  Let's thunk it to what
            //       they want.

            if (fUnicodeShell)
                SHTCharToUnicode(szHelpText, pwzHelpTextOut, HIWORD(wParam));
            else
                SHTCharToAnsi(szHelpText, pszHelpTextOut, HIWORD(wParam));

            hres = S_OK;
        }
    }

    return hres;
}


#define         SZ_HELPTOPIC_FILEA        "iexplore.chm > iedefault"
#define         SZ_HELPTOPIC_XBOXSECTIONA  "xbox_over.htm"
#define         SZ_HELPTOPIC_FILEW         L"iexplore.chm"
#define         SZ_HELPTOPIC_XBOXSECTIONW   L"xbox_over.htm"

/*****************************************************************************\
    FUNCTION: _OnInvokeXboxHelp

    DESCRIPTION:
        The wants Help specific to XBOX.
\*****************************************************************************/
HRESULT CXboxView::_OnInvokeXboxHelp(HWND hwnd)
{
    HRESULT hr = E_INVALIDARG;
    uCLSSPEC ucs;
    QUERYCONTEXT qc = { 0 };

    ucs.tyspec = TYSPEC_CLSID;
    ucs.tagged_union.clsid = CLSID_IEHelp;

//    ASSERT(m_hwndOwner && m_psfv);        // Not available on browser only
    IUnknown_EnableModless((IUnknown *)m_psfv, FALSE);
    hr = FaultInIEFeature(m_hwndOwner, &ucs, &qc, FIEF_FLAG_FORCE_JITUI);
    IUnknown_EnableModless((IUnknown *)m_psfv, TRUE);

    HtmlHelpA(NULL, SZ_HELPTOPIC_FILEA, HH_HELP_FINDER, (DWORD_PTR) SZ_HELPTOPIC_XBOXSECTIONA);
    return hr;
}


/*****************************************************************************\
    FUNCTION: _OnGetHelpTopic

    DESCRIPTION:
        Remove "Help.XBOX Help" because we will have that work done
    in "Help.Help Topics" on NT5 and after.  We don't do this for
    earlier versions of shell32 because shell32 in NT5 is the 
    first version to support "HtmlHelp" over WinHelp.  This is
    needed because XBOX's help is stored in IE's HTML Help files.
\*****************************************************************************/
HRESULT CXboxView::_OnGetHelpTopic(SFVM_HELPTOPIC_DATA * phtd)
{
    HRESULT hr = E_NOTIMPL;

    // Remove "Help.XBOX Help" because we will have that work done
    // in "Help.Help Topics" on NT5 and after.  We don't do this for
    // earlier versions of shell32 because shell32 in NT5 is the 
    // first version to support "HtmlHelp" over WinHelp.  This is
    // needed because XBOX's help is stored in IE's HTML Help files.
    if (SHELL_VERSION_IE4 < GetShellVersion())
    {
        StrCpyNW(phtd->wszHelpFile, SZ_HELPTOPIC_FILEW, ARRAYSIZE(phtd->wszHelpFile));
        StrCpyNW(phtd->wszHelpTopic, SZ_HELPTOPIC_XBOXSECTIONW, ARRAYSIZE(phtd->wszHelpTopic));
        hr = S_OK;
    }

    return hr;
}

/*****************************************************************************\
    FUNCTION: _OnGetZone

    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxView::_OnGetZone(DWORD * pdwZone, WPARAM wParam)
{
    HRESULT hr = E_INVALIDARG;
    DWORD dwZone = URLZONE_INTERNET;    // Default
    LPCITEMIDLIST pidl = m_pff->GetPrivatePidlReference();
    
    if (pidl)
    {
        WCHAR wzUrl[MAX_URL_STRING];

        // NT #277100: This may fail if TweakUI is installed because
        //             they abuse us.
        hr = UrlCreateFromPidlW(pidl, SHGDN_FORPARSING, wzUrl, ARRAYSIZE(wzUrl), ICU_ESCAPE | ICU_USERNAME, FALSE);
        if (SUCCEEDED(hr))
        {
            IInternetSecurityManager * pism;

            if (EVAL(SUCCEEDED(CoCreateInstance(CLSID_InternetSecurityManager, NULL, CLSCTX_INPROC_SERVER, 
                                IID_IInternetSecurityManager, (void **) &pism))))
            {
                pism->MapUrlToZone(wzUrl, &dwZone, 0);
                pism->Release();
            }
        }
    }
    
    if (pdwZone)
    {
        *pdwZone = dwZone;
        hr = S_OK;
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: _OnGetPane

    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxView::_OnGetPane(DWORD dwPaneID, DWORD * pdwPane)
{
    HRESULT hr = E_INVALIDARG;
    DWORD dwPane = PANE_NONE;    // Default unknown

    switch (dwPaneID)
    {
        case PANE_NAVIGATION:
            dwPane = STATUS_PANE_STATUS;
            break;
        case PANE_ZONE:
            dwPane = STATUS_PANE_ZONE;
            break;
        default:
            break;
    }

    if (pdwPane)
    {
        *pdwPane = dwPane;
        hr = S_OK;
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: _OnRefresh

    DESCRIPTION:
        We need to purge the cache and force our selves to hit the server again.
\*****************************************************************************/
HRESULT CXboxView::_OnRefresh(BOOL fReload)
{
    if (EVAL(m_pff) && fReload)
        m_pff->InvalidateCache();

    return S_OK;
}


/*****************************************************************************\
    FUNCTION: _OnBackGroundEnumDone

    DESCRIPTION:
        Our enum happens on the background.  Sometimes we decide that we want
    to do a redirect during the enumeration because the UserName/Password
    didn't allow access to the server but the user provided a pair that does.
    Since we can't access the ComDlgBrowser's IShellBrowser::BrowseObject()
    on the background, we need to call it on the forground.  In order to do
    that, we need an event that happens on the forground.  Well this is that
    even baby.
\*****************************************************************************/
HRESULT CXboxView::_OnBackGroundEnumDone(void)
{
    HRESULT hr = S_OK;

    if (m_pidlRedirect)
    {
        LPITEMIDLIST pidlRedirect = NULL;

        ENTERCRITICAL;
        if (m_pidlRedirect)
        {
            pidlRedirect = m_pidlRedirect;
            m_pidlRedirect = NULL;
        }
        LEAVECRITICAL;

        if (pidlRedirect)
        {
            IShellBrowser * psb;
            hr = IUnknown_QueryService(_punkSite, SID_SCommDlgBrowser, IID_IShellBrowser, (LPVOID *) &psb);
            if (SUCCEEDED(hr))
            {
                hr = psb->BrowseObject(pidlRedirect, 0);
            
                AssertMsg(SUCCEEDED(hr), TEXT("CXboxView::_OnBackGroundEnumDone() defview needs to support QS(SID_ShellFolderViewCB) on all platforms that hit this point"));
                psb->Release();
            }

            ILFree(pidlRedirect);
        }
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: _OnGetNotify

    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxView::_OnGetNotify(LPITEMIDLIST * ppidl, LONG * lEvents)
{
    if (EVAL(lEvents))
        *lEvents = XBOX_SHCNE_EVENTS;

    if (EVAL(ppidl))
    {
        // Normally I would use pidlRoot to get ChangeNotify messages but since
        // that doesn't work, it's necessary to broadcast ChangeNotify messages
        // using pidlTarget and receive them using pidlTarget. This is the later
        // case.
        if (EVAL(m_pff))
            *ppidl = (LPITEMIDLIST) m_pff->GetPublicTargetPidlReference();
        else
            *ppidl = NULL;
    }

    return S_OK;
}


/*****************************************************************************\
    FUNCTION: _OnSize

    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxView::_OnSize(LONG x, LONG y)
{
    RECT rcCurrent;
    HRESULT hr = S_OK;

    ASSERT(m_hwndOwner);
    GetWindowRect(m_hwndOwner, &rcCurrent);

    // Has the size really changed?
    if ((m_rcPrev.bottom != rcCurrent.bottom) ||
        (m_rcPrev.top != rcCurrent.top) ||
        (m_rcPrev.left != rcCurrent.left) ||
        (m_rcPrev.right != rcCurrent.right))
    {
        // yes, so update the StatusBar.
        if (m_psb)
            hr = m_psb->Resize(x, y);
        m_rcPrev = rcCurrent;
    }
    else
    {
        // No, so ignore it because we may stomp on some other
        // active view. (Because we get this message even after
        // another view took over the brower).

        // I don't care about resizing to zero.
        // I don't think the user will ever need it and it casues
        // bug #198695 where the addressband goes blank.  This is because
        // defview will call us thru each of the two places:
        // 1) CXboxFolder::CreateViewObject() (Old URL)
        // 2) CDefView::CreateViewWindow2()->CXboxView::_OnSize() (Old URL)
        // 3) DV_UpdateStatusBar()->CXboxView::_OnUpdateStatusBar() (New URL)
        // 4) ReleaseWindowLV()->WndSize()->CXboxView::_OnSize() (Old URL)
        // #4 makes us update the URL and replace #3 which is valid.
    }
    
    return hr;
}


/*****************************************************************************\
    FUNCTION: _OnThisIDList

    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxView::_OnThisIDList(LPITEMIDLIST * ppidl)
{
    HRESULT hr = S_FALSE;

    if (EVAL(ppidl))
    {
        *ppidl = ILClone(m_pff->GetPublicRootPidlReference());
        hr = S_OK;
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: _OnUpdateStatusBar

    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxView::_OnUpdateStatusBar(void)
{
    HRESULT hr = S_FALSE;
    LPCITEMIDLIST pidl = m_pff->GetPrivatePidlReference();

    if (EVAL(pidl))
    {
        TCHAR szUserName[INTERNET_MAX_USER_NAME_LENGTH];
        BOOL fAnnonymousLogin = TRUE;

        hr = XboxPidl_GetUserName(pidl, szUserName, ARRAYSIZE(szUserName));
        if (SUCCEEDED(hr) && szUserName[0])
            fAnnonymousLogin = FALSE;

        if (m_psb)
        {
            // Even if the above call fails, we set the user name to clear out
            // any old invalid values.
            m_psb->SetUserName(szUserName, fAnnonymousLogin);
        }

        EVAL(SUCCEEDED(_SetStatusBarZone(m_psb, m_pff->m_pfs)));
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: SetRedirectPidl

    DESCRIPTION:
        See the comments in _OnBackGroundEnumDone().
\*****************************************************************************/
HRESULT CXboxView::SetRedirectPidl(LPCITEMIDLIST pidlRedirect)
{
    ENTERCRITICAL;
    Pidl_Set(&m_pidlRedirect, pidlRedirect);
    LEAVECRITICAL;
    return S_OK;
}


/*****************************************************************************\
    FUNCTION: DummyHintCallback

    DESCRIPTION:
        Doesn't do anything; simply forces the connection to be established
    and the motd to be obtained.
\*****************************************************************************/
HRESULT CXboxView::DummyHintCallback(HWND hwnd, CXboxFolder * pff, HINTERNET hint, LPVOID pv1, LPVOID pv2)
{
    return S_OK;
}


/*****************************************************************************\
    FUNCTION: _InitStatusBar

    DESCRIPTION:
        Obtains and initializes the status bar window.
    It is not an error if the viewer does not provide a status bar.
\*****************************************************************************/
void CXboxView::_InitStatusBar(void)
{
    if (m_psb)
        m_psb->SetStatusMessage(IDS_EMPTY, 0);
}


/*****************************************************************************\
    FUNCTION: _OnWindowCreated (from shell32.IShellView)

    DESCRIPTION:
        When the window is created, we get the motd.  Very soon thereafter,
    DefView is going to ask for the IEnumIDList, which will now be
    in the cache.  (GROSS!  Screws up background enumeration!)

    Do this only if we don't already have a motd.
\*****************************************************************************/
HRESULT CXboxView::_OnWindowCreated(void)
{
    HRESULT hr = S_FALSE;

#ifdef _SOMEDAY_FIGURE_OUT_MOTD
/** Currently Turned off
    CXboxDir * pfd = m_pff->GetXboxDir();

    if (EVAL(pfd))
    {
        if (!CXboxDir_IsRoot(pfd))
        {
            CXboxSite * pfs = pfd->GetXboxSite();

            ASSERT(pfs);
            if (!pfs->QueryMotd())
            {
#ifdef HACKHACK_WHAT_THE_HELL       // Gotta clean this
                // This forcdes a connexn to see if there is a motd
                pfd->WithHint(&m_psb, hwndOwner, DummyHintCallback, NULL);
#endif
            }
            if (pfs->QueryNewMotd())
            {
                //  If we can't set the timeout, tough.  All that
                //  happens is you don't get to see the motd.  Boo hoo.
#pragma message("BUGBUG -- This is busted!")
                SetDelayedAction(ShowMotd, pfv, &pfv->m_hgtiWelcome);
            }
            hr = S_FALSE;
        }
        pfd->Release();
    }
***/
#endif /* SOMEDAY_FIGURE_OUT_MOTD */

    return hr;
}


/*****************************************************************************\
    FUNCTION: _OnDefItemCount (from shell32.IShellView)

    DESCRIPTION:
        _UNDOCUMENTED_: This callback and its parameters are not documented.

    Called to advise the browser of how many items we might have.  This
    allows preliminary UI to appear while we are busy enumerating
    the contents.
\*****************************************************************************/
HRESULT CXboxView::_OnDefItemCount(LPINT pi)
{
    *pi = 20;
    return S_OK;
}


/*****************************************************************************\
    FUNCTION: _OnDidDragDrop

    DESCRIPTION:
        Called to advise the browser that somebody did a drag/drop operation
    on objects in the folder.  If the effect was DROPEFFECT_MOVE, then
    we delete the source, if we aren't still doing the copy asynch on a
    background thread.

    RETURN VALUES:
        S_OK: We take responsibility of deleting the files which we can
              do here in the synch case, or in IAsynchOperation::EndOperation()
              in the asynch case.
        S_FALSE: We didn't do the delete but it's OK for the caller to do it.
                 so the caller needs to display UI and then delete via
                 IContextMenu->InvokeCommand(-delete-).
\*****************************************************************************/
HRESULT CXboxView::_OnDidDragDrop(DROPEFFECT de, IDataObject * pdo)
{
    HRESULT hr = S_OK;

    if (DROPEFFECT_MOVE == de)
    {
        IAsyncOperation * pao;

        hr = pdo->QueryInterface(IID_IAsyncOperation, (void **) &pao);
        if (SUCCEEDED(hr))
        {
            BOOL fInAsyncOp = TRUE;

            hr = pao->InOperation(&fInAsyncOp);
            hr = S_OK;  // Don't have caller do the delete.
            if (FALSE == fInAsyncOp)
            {
#ifdef FEATURE_CUT_MOVE
                CLSID clsid;
                BOOL fDoDelete = TRUE;
                CXboxObj * pfo = (CXboxObj *) pdo;

                // Is the destination the recycle bin?
                if (SUCCEEDED(DataObj_GetDropTarget(pdo, &clsid)) &&
                    IsEqualCLSID(clsid, CLSID_RecycleBin))
                {
                    // Yes, so we need to first inform the user that drops to the
                    // Recycle bin are perminate deletes and the user can't undo
                    // the operation.
                    if (IDYES != SHMessageBox(m_hwndOwner, NULL, IDS_RECYCLE_IS_PERM_WARNING, IDS_XBOXERR_TITLE, (MB_ICONQUESTION | MB_YESNO)))
                        fDoDelete = FALSE;
                }

                // We didn't do the operation aynch so we need to DELETE the
                // files now to complete the MOVE operation (MOVE=Copy + Delete).
                if (fDoDelete)
                {
                    Misc_DeleteHfpl(m_pff, m_hwndOwner, pfo->GetHfpl());    // Will fail on permission denied.
                }

#else // FEATURE_CUT_MOVE
                hr = S_FALSE;   // Have parent do the delete.
#endif //FEATURE_CUT_MOVE
            }

            pao->Release();
        }
        else
            hr = S_OK;  // Don't have caller delete.  IAsyncOperation::EndOperation() will.
    }

    return hr;
}



//===========================
// *** IXboxWebView Interface ***
//===========================

/*****************************************************************************\
    FUNCTION: IXboxWebView::get_MessageOfTheDay

    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxView::get_MessageOfTheDay(BSTR * pbstr)
{
    HRESULT hr = S_FALSE;

    if (EVAL(pbstr))
    {
        *pbstr = NULL;

        if (EVAL(m_pff))
        {
            TCHAR szDefault[MAX_PATH];
            LPCTSTR pszMOTD = szDefault;
            CXboxGlob * pfg = m_pff->GetSiteMotd();

            szDefault[0] = 0;
            if (pfg)
                pszMOTD = pfg->GetHGlobAsTCHAR();

            // if we were not able to get the message of the day
            // from CXboxFolder or it was empty, display "None"
            if ((pszMOTD == szDefault) || (!pszMOTD[0]))
            {
                pszMOTD = szDefault;
                LoadString(HINST_THISDLL, IDS_NO_MESSAGEOFTHEDAY, szDefault, ARRAYSIZE(szDefault));
            }

            *pbstr = TCharSysAllocString(pszMOTD);

            if (pfg)
                pfg->Release();

            hr = S_OK;
        }
    }
    else
        hr = E_INVALIDARG;

    ASSERT_POINTER_MATCHES_HRESULT(*pbstr, hr);
    return hr;
}


/*****************************************************************************\
    FUNCTION: IXboxWebView::get_Server

    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxView::get_Server(BSTR * pbstr)
{
    HRESULT hr = S_FALSE;

    if (EVAL(pbstr))
    {
        *pbstr = NULL;

        if (EVAL(m_pff))
        {
            TCHAR szServer[INTERNET_MAX_HOST_NAME_LENGTH];

            if (SUCCEEDED(XboxPidl_GetServer(m_pff->GetPrivatePidlReference(), szServer, ARRAYSIZE(szServer))))
            {
                *pbstr = TCharSysAllocString(szServer);
                if (*pbstr)
                    hr = S_OK;
            }
        }
    }
    else
        hr = E_INVALIDARG;

//    ASSERT_POINTER_MATCHES_HRESULT(*pbstr, hr);
    return hr;
}


/*****************************************************************************\
    FUNCTION: IXboxWebView::get_Directory

    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxView::get_Directory(BSTR * pbstr)
{
    HRESULT hr = S_FALSE;

    if (EVAL(pbstr))
    {
        *pbstr = NULL;

        if (EVAL(m_pff))
        {
            TCHAR szUrlPath[INTERNET_MAX_PATH_LENGTH];

            if (EVAL(SUCCEEDED(GetDisplayPathFromPidl(m_pff->GetPrivatePidlReference(), szUrlPath, ARRAYSIZE(szUrlPath), FALSE))))
            {
                *pbstr = TCharSysAllocString(szUrlPath);
                if (*pbstr)
                    hr = S_OK;
            }
        }
    }
    else
        hr = E_INVALIDARG;

    ASSERT_POINTER_MATCHES_HRESULT(*pbstr, hr);
    return hr;
}


/*****************************************************************************\
    FUNCTION: IXboxWebView::get_UserName

    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxView::get_UserName(BSTR * pbstr)
{
    HRESULT hr = S_FALSE;

    if (EVAL(pbstr))
    {
        *pbstr = NULL;

        if (EVAL(m_pff))
        {
            TCHAR szUserName[INTERNET_MAX_USER_NAME_LENGTH];

            if (EVAL(SUCCEEDED(XboxPidl_GetUserName(m_pff->GetPrivatePidlReference(), szUserName, ARRAYSIZE(szUserName)))))
            {
                *pbstr = TCharSysAllocString((0 != szUserName[0]) ? szUserName : SZ_ANONYMOUS);
                if (*pbstr)
                    hr = S_OK;
            }
        }
    }
    else
        hr = E_INVALIDARG;

    ASSERT_POINTER_MATCHES_HRESULT(*pbstr, hr);
    return hr;
}


/*****************************************************************************\
    FUNCTION: IXboxWebView::get_PasswordLength

    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxView::get_PasswordLength(long * plLength)
{
    HRESULT hr = S_FALSE;

    if (EVAL(plLength))
    {
        TCHAR szPassword[INTERNET_MAX_PASSWORD_LENGTH];

        *plLength = 0;
        if (SUCCEEDED(XboxPidl_GetPassword(m_pff->GetPrivatePidlReference(), szPassword, ARRAYSIZE(szPassword), FALSE)))
        {
            *plLength = lstrlen(szPassword);
            hr = S_OK;
        }
    }
    else
        hr = E_INVALIDARG;

    ASSERT_POINTER_MATCHES_HRESULT(*plLength, hr);
    return hr;
}


/*****************************************************************************\
    FUNCTION: IXboxWebView::get_EmailAddress

    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxView::get_EmailAddress(BSTR * pbstr)
{
    HRESULT hr = S_OK;

    if (EVAL(pbstr))
    {
        TCHAR szEmailName[MAX_PATH];
        DWORD dwType = REG_SZ;
        DWORD cbSize = sizeof(szEmailName);

        if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, SZ_REGKEY_INTERNET_SETTINGS, SZ_REGKEY_EMAIL_NAME, &dwType, szEmailName, &cbSize))
            *pbstr = TCharSysAllocString(szEmailName);
        else
        {
            hr = S_FALSE;
            *pbstr = NULL;
        }
    }
    else
        hr = E_INVALIDARG;

    return hr;
}


/*****************************************************************************\
    FUNCTION: IXboxWebView::put_EmailAddress

    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxView::put_EmailAddress(BSTR bstr)
{
    HRESULT hr = S_OK;

    if (EVAL(bstr))
    {
        TCHAR szEmailName[MAX_PATH];

        SHUnicodeToTChar(bstr, szEmailName, ARRAYSIZE(szEmailName));
        if (ERROR_SUCCESS != SHSetValue(HKEY_CURRENT_USER, SZ_REGKEY_INTERNET_SETTINGS, SZ_REGKEY_EMAIL_NAME, REG_SZ, szEmailName, sizeof(szEmailName)))
            hr = S_FALSE;
    }
    else
        hr = E_INVALIDARG;

    return hr;
}


/*****************************************************************************\
    FUNCTION: IXboxWebView::get_CurrentLoginAnonymous

    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxView::get_CurrentLoginAnonymous(VARIANT_BOOL * pfAnonymousLogin)
{
    HRESULT hr = S_OK;

    if (EVAL(pfAnonymousLogin))
    {
        TCHAR szUserName[INTERNET_MAX_USER_NAME_LENGTH];

        if (EVAL(m_pff) &&
            SUCCEEDED(XboxPidl_GetUserName(m_pff->GetPrivatePidlReference(), szUserName, ARRAYSIZE(szUserName))) &&
            szUserName[0] && (0 != StrCmpI(szUserName, TEXT("anonymous"))))
        {
            *pfAnonymousLogin = VARIANT_FALSE;
        }
        else
            *pfAnonymousLogin = VARIANT_TRUE;
    }
    else
        hr = E_INVALIDARG;

    return hr;
}


/*****************************************************************************\
    FUNCTION: IXboxWebView::LoginAnonymously

    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxView::LoginAnonymously(void)
{
    return _LoginWithPassword(NULL, NULL);
}


/*****************************************************************************\
    FUNCTION: IXboxWebView::LoginWithPassword

    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxView::LoginWithPassword(BSTR bUserName, BSTR bPassword)
{
    HRESULT hr = S_OK;
    TCHAR szUserName[INTERNET_MAX_USER_NAME_LENGTH];
    TCHAR szPassword[INTERNET_MAX_PASSWORD_LENGTH];

    SHUnicodeToTChar(bUserName, szUserName, ARRAYSIZE(szUserName));
    SHUnicodeToTChar(bPassword, szPassword, ARRAYSIZE(szPassword));
    return _LoginWithPassword(szUserName, szPassword);
}


/*****************************************************************************\
    FUNCTION: IXboxWebView::LoginWithoutPassword

    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxView::LoginWithoutPassword(BSTR bUserName)
{
    HRESULT hr = S_FALSE;
    TCHAR szUserName[INTERNET_MAX_USER_NAME_LENGTH];
    TCHAR szPassword[INTERNET_MAX_PASSWORD_LENGTH];

    SHUnicodeToTChar(bUserName, szUserName, ARRAYSIZE(szUserName));
    if (SUCCEEDED(XboxPidl_GetPassword(m_pff->GetPrivatePidlReference(), szPassword, ARRAYSIZE(szPassword), TRUE)))
        hr = _LoginWithPassword(szUserName, szPassword);

    return hr;
    
}


HRESULT CXboxView::_LoginWithPassword(LPCTSTR pszUserName, LPCTSTR pszPassword)
{
    HRESULT hr = S_OK;
    LPITEMIDLIST pidlUser;

    hr = PidlReplaceUserPassword(m_pff->GetPrivatePidlReference(), &pidlUser, m_pff->GetItemAllocatorDirect(), pszUserName, pszPassword);
    if (EVAL(SUCCEEDED(hr)))
    {
        LPITEMIDLIST pidlFull = m_pff->CreateFullPublicPidl(pidlUser);
        if (pidlFull)
        {
            hr = IUnknown_PidlNavigate(m_psfv, pidlFull, TRUE);
            ASSERT(SUCCEEDED(hr));
            ILFree(pidlFull);
        }

        ILFree(pidlUser);
    }

    if (FAILED(hr))
        hr = S_FALSE;   // Automation interfaces don't like failure returns.

    return hr;
}


//===========================
// *** IDispatch Interface ***
//===========================

// BUGBUG: Cane we nuke this?

STDMETHODIMP CXboxView::GetTypeInfoCount(UINT * pctinfo)
{ 
    return CImpIDispatch::GetTypeInfoCount(pctinfo); 
}

STDMETHODIMP CXboxView::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo * * pptinfo)
{ 
    return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); 
}

STDMETHODIMP CXboxView::GetIDsOfNames(REFIID riid, OLECHAR * * rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid)
{ 
    return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); 
}

STDMETHODIMP CXboxView::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
{
    return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
}


/*****************************************************************************
 *
 *	CXboxView_Create
 *
 *	Creates a brand new enumerator based on an Xbox site.
 *
 *****************************************************************************/
HRESULT CXboxView_Create(CXboxFolder * pff, HWND hwndOwner, REFIID riid, LPVOID * ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CXboxView * pfv = new CXboxView(pff, hwndOwner);

    if (EVAL(pfv))
    {
        hr = pfv->QueryInterface(riid, ppv);
        pfv->Release();
    }

    ASSERT_POINTER_MATCHES_HRESULT(*ppv, hr);
    return hr;
}



/****************************************************\
    Constructor
\****************************************************/
CXboxView::CXboxView(CXboxFolder * pff, HWND hwndOwner) : CImpIDispatch(&LIBID_XBNMSPCLib)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_hwndOwner);
    ASSERT(!m_hwndStatusBar);
    ASSERT(!m_pff);
    ASSERT(!m_hgtiWelcome);
    
    m_nThreadID = GetCurrentThreadId();
    if (hwndOwner)
    {
        m_hwndOwner = hwndOwner;
        m_hwndStatusBar = Misc_FindStatusBar(hwndOwner);
        m_psb = CStatusBar_Create(m_hwndStatusBar);
        _InitStatusBar();
    }

    m_rcPrev.top = m_rcPrev.bottom = m_rcPrev.right = m_rcPrev.left = -1;
    IUnknown_Set(&m_pff, pff);

    LEAK_ADDREF(LEAK_CXboxView);
    g_cRef_CXboxView++;  // Needed to determine when to purge cache.
}


/****************************************************\
    Destructor
\****************************************************/
/*****************************************************************************
 *
 *      XboxView_OnRelease (from shell32.IShellView)
 *
 *      When the view is released, clean up various stuff.
 *
 *      BUGBUG -- (Note that there is a race here, because this->hwndOwner
 *      doesn't get zero'd out on the OnWindowDestroy because the shell
 *      doesn't give us a pdvsci...)
 *
 *      We release the psf before triggering the timeout, which is a
 *      signal to the trigger not to do anything.
 *
 *      _UNDOCUMENTED_: This callback and its parameters are not documented.
 *
 *****************************************************************************/
CXboxView::~CXboxView()
{
    IUnknown_Set(&m_pff, NULL);

    // BUGBUG -- should be a cancel, not a trigger
    TriggerDelayedAction(&m_hgtiWelcome);   /* Kick out the old one */

    SetRedirectPidl(NULL);
    if (m_psb)
        delete m_psb;

    if (m_hinstInetCpl)
        FreeLibrary(m_hinstInetCpl);

    DllRelease();
    LEAK_DELREF(LEAK_CXboxView);
    g_cRef_CXboxView--;  // Needed to determine when to purge cache.
}


//===========================
// *** IUnknown Interface ***
//===========================

HRESULT CXboxView::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = SAFECAST(this, IDispatch *);
    }
    else if (IsEqualIID(riid, IID_IXboxWebView))
    {
        *ppvObj = SAFECAST(this, IXboxWebView *);
    }
    else if (IsEqualIID(riid, IID_CXboxViewPrivThis))
    {
        *ppvObj = (void *)this;
    }
    else
        return CBaseFolderViewCB::QueryInterface(riid, ppvObj);

    AddRef();
    return S_OK;
}


CXboxView * GetCXboxViewFromDefViewSite(IUnknown * punkSite)
{
    CXboxView * pfv = NULL;
    IShellFolderViewCB * psfvcb = NULL;

    // This fails on Browser Only
    IUnknown_QueryService(punkSite, SID_ShellFolderViewCB, IID_IShellFolderViewCB, (LPVOID *) &psfvcb);
    if (psfvcb)
    {
        psfvcb->QueryInterface(IID_CXboxViewPrivThis, (void **) &pfv);
        psfvcb->Release();
    }

    return pfv;
}


CStatusBar * GetCStatusBarFromDefViewSite(IUnknown * punkSite)
{
    CStatusBar * psb = NULL;
    CXboxView * pfv = GetCXboxViewFromDefViewSite(punkSite);

    if (pfv)
    {
        psb = pfv->GetStatusBar();
        pfv->Release();
    }

    return psb;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxapi.h ===
/*****************************************************************************\
    FILE: xboxapi.h

    DESCRIPTION:
        This file contains functions to perform the following 2 things:

    1. WININET WRAPPERS: Wininet APIs have either wierd bugs or bugs that come thru the APIs
    from the server.  It's also important to keep track of the perf impact
    of each call.  These wrappers solve these problems.

    2. XBOX STRs to PIDLs: These wrappers will take Xbox filenames and file paths
    that come in from the server and turn them into pidls.  These pidls contain
    both a unicode display string and the filename/path in wire bytes for future
    server requests.
\*****************************************************************************/


///////////////////////////////////////////////////////////////////////////////////////////
// 1. WININET WRAPPERS: Wininet APIs have either wierd bugs or bugs that come thru the APIs
// from the server.  It's also important to keep track of the perf impact
// of each call.  These wrappers solve these problems.
///////////////////////////////////////////////////////////////////////////////////////////
HRESULT XboxSetCurrentDirectoryWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCWIRESTR pwXboxPath);
HRESULT XboxGetCurrentDirectoryWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPWIRESTR pwXboxPath, DWORD cchSize);
HRESULT XboxGetFileExWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCWIRESTR pwXboxPath/*Src*/, LPCWSTR pwzFilePath/*Dest*/, BOOL fFailIfExists,
                       DWORD dwFlagsAndAttributes, DWORD dwFlags, DWORD_PTR dwContext);
HRESULT XboxPutFileExWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCWSTR pwzFilePath/*Src*/, LPCWIRESTR pwXboxPath/*Dest*/, DWORD dwFlags, DWORD_PTR dwContext);
HRESULT XboxDeleteFileWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCWIRESTR pwXboxFileName);
HRESULT XboxRenameFileWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCWIRESTR pwXboxFileNameExisting, LPCWIRESTR pwXboxFileNameNew);
HRESULT XboxOpenFileWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCWIRESTR pwXboxFileName, DWORD dwAccess, DWORD dwFlags, DWORD_PTR dwContext, HINTERNET * phFileHandle);
HRESULT XboxCreateDirectoryWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCWIRESTR pwXboxPath);
HRESULT XboxRemoveDirectoryWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCWIRESTR pwXboxPath);
HRESULT XboxCommandWrap(HINTERNET hConnect, BOOL fAssertOnFailure, BOOL fExpectResponse, DWORD dwFlags, LPCWIRESTR pszCommand, DWORD_PTR dwContext, HINTERNET *phXboxCommand);

HRESULT XboxDoesFileExist(HINTERNET hConnect, BOOL fAssertOnFailure, LPCWIRESTR pwFilterStr, LPXBOX_FIND_DATA pwfd, DWORD dwINetFlags);

HRESULT InternetOpenWrap(BOOL fAssertOnFailure, LPCTSTR pszAgent, DWORD dwAccessType, LPCTSTR pszProxy, LPCTSTR pszProxyBypass, DWORD dwFlags, HINTERNET * phFileHandle);
HRESULT InternetCloseHandleWrap(HINTERNET hInternet, BOOL fAssertOnFailure);
HRESULT InternetConnectWrap(HINTERNET hInternet, BOOL fAssertOnFailure, LPCTSTR pszServerName, INTERNET_PORT nServerPort,
                            LPCTSTR pszUserName, LPCTSTR pszPassword, DWORD dwService, DWORD dwFlags, DWORD_PTR dwContext, HINTERNET * phFileHandle);
HRESULT InternetOpenUrlWrap(HINTERNET hInternet, BOOL fAssertOnFailure, LPCTSTR pszUrl, LPCTSTR pszHeaders, DWORD dwHeadersLength, DWORD dwFlags, DWORD_PTR dwContext, HINTERNET * phFileHandle);
HRESULT InternetReadFileWrap(HINTERNET hFile, BOOL fAssertOnFailure, LPVOID pvBuffer, DWORD dwNumberOfBytesToRead, LPDWORD pdwNumberOfBytesRead);
HRESULT InternetWriteFileWrap(HINTERNET hFile, BOOL fAssertOnFailure, LPCVOID pvBuffer, DWORD dwNumberOfBytesToWrite, LPDWORD pdwNumberOfBytesWritten);
HRESULT InternetFindNextFileWrap(HINTERNET hFind, BOOL fAssertOnFailure, LPVOID pvFindData);
HRESULT InternetGetLastResponseInfoWrap(BOOL fAssertOnFailure, LPDWORD pdwError, LPWIRESTR pwBuffer, LPDWORD pdwBufferLength);
HRESULT InternetGetLastResponseInfoDisplayWrap(BOOL fAssertOnFailure, LPDWORD pdwError, LPWSTR pwzBuffer, DWORD cchBufferSize);
INTERNET_STATUS_CALLBACK InternetSetStatusCallbackWrap(HINTERNET hInternet, BOOL fAssertOnFailure, INTERNET_STATUS_CALLBACK pfnInternetCallback);
HRESULT InternetCheckConnectionWrap(BOOL fAssertOnFailure, LPCTSTR pszUrl, DWORD dwFlags, DWORD dwReserved);
HRESULT InternetAttemptConnectWrap(BOOL fAssertOnFailure, DWORD dwReserved);
HRESULT InternetFindNextFileWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPXBOX_FIND_DATA pwfd);


///////////////////////////////////////////////////////////////////////////////////////////
// 2. XBOX STRs to PIDLs: These wrappers will take Xbox filenames and file paths
// that come in from the server and turn them into pidls.  These pidls contain
// both a unicode display string and the filename/path in wire bytes for future
// server requests.
///////////////////////////////////////////////////////////////////////////////////////////

HRESULT XboxSetCurrentDirectoryPidlWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCITEMIDLIST pidlXboxPath, BOOL fAbsolute, BOOL fOnlyDirs);
HRESULT XboxGetCurrentDirectoryPidlWrap(HINTERNET hConnect, BOOL fAssertOnFailure, CWireEncoding * pwe, LPITEMIDLIST * ppidlXboxPath);
HRESULT XboxFindFirstFilePidlWrap(HINTERNET hConnect, BOOL fAssertOnFailure, CMultiLanguageCache * pmlc, CWireEncoding * pwe,
        LPCWIRESTR pwFilterStr, LPITEMIDLIST * ppidlXboxItem, DWORD dwINetFlags, DWORD_PTR dwContext, HINTERNET * phFindHandle);
HRESULT InternetFindNextFilePidlWrap(HINTERNET hConnect, BOOL fAssertOnFailure, CMultiLanguageCache * pmlc, CWireEncoding * pwe, LPITEMIDLIST * ppidlXboxItem);
HRESULT XboxRenameFilePidlWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCITEMIDLIST pidlExisting, LPCITEMIDLIST pidlNew);
HRESULT XboxGetFileExPidlWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCITEMIDLIST pidlXboxPath/*Src*/, LPCWSTR pwzFilePath/*Dest*/, BOOL fFailIfExists,
                       DWORD dwFlagsAndAttributes, DWORD dwFlags, DWORD_PTR dwContext);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxdhlp.h ===
/*****************************************************************************\
    FILE: xboxdhlp.h

    DESCRIPTION:
        Dialog box helper.  This class will fill in the parts of the dialog
    that pertain to the XBOX information
\*****************************************************************************/

#ifndef _XBOXDIALOGTEMPLATE_H
#define _XBOXDIALOGTEMPLATE_H


/*****************************************************************************\
    CLASS: CXboxDialogTemplate

    DESCRIPTION:
        Dialog box helper.  This class will fill in the parts of the dialog
    that pertain to the XBOX information
\*****************************************************************************/
class CXboxDialogTemplate
{
public:
    HRESULT InitDialog(HWND hdlg, BOOL fEditable, UINT id, CXboxFolder * pff, CXboxPidlList * pfpl);
    HRESULT InitDialogWithFindData(HWND hDlg, UINT id, CXboxFolder * pff, const XBOX_FIND_DATA * pwfd, LPCWIRESTR pwWirePath, LPCWSTR pwzDisplayPath);
    BOOL OnClose(HWND hdlg, HWND hwndBrowser, CXboxFolder * pff, CXboxPidlList * pfpl);
    BOOL HasNameChanged(HWND hdlg, CXboxFolder * pff, CXboxPidlList * pPidlList);

    static int _InitSizeTally(LPVOID pvPidl, LPVOID pvSizeHolder);

private:
    HRESULT _ReinsertDlgText(HWND hwnd, LPCVOID pv, LPCTSTR ptszFormat);
    HRESULT _ReplaceIcon(HWND hwnd, HICON hicon);
    HRESULT _InitIcon(HWND hwnd, CXboxFolder * pff, CXboxPidlList * pflHfpl);
    HRESULT _InitNameEditable(HWND hwnd, CXboxFolder * pff, CXboxPidlList * pflHfpl);
    HRESULT _InitName(HWND hwnd, CXboxFolder * pff, CXboxPidlList * pflHfpl);
    HRESULT _InitType(HWND hwnd, CXboxFolder * pff, CXboxPidlList * pflHfpl);
    HRESULT _InitLocation(HWND hwnd, CXboxFolder * pff, CXboxPidlList * pflHfpl);
    HRESULT _InitSize(HWND hwnd, HWND hwndLabel, CXboxFolder * pff, CXboxPidlList * pflHfpl);
    HRESULT _InitTime(HWND hwnd, HWND hwndLabel, CXboxFolder * pff, CXboxPidlList * pflHfpl);
    HRESULT _InitCount(HWND hwnd, CXboxFolder * pff, CXboxPidlList * pflHfpl);

    BOOL m_fEditable;
};



#endif // _XBOXDIALOGTEMPLATE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxdir.cpp ===
/*****************************************************************************\
    FILE: xboxdir.cpp

    DESCRIPTION:
        Internal object that manages a single XBOX directory

    The idea is that each XboxSite maintains a linked list of the
    XboxDir's that it owns.  Gets and Releases are done through the
    XboxSite.  Each XboxDir retains a non-refcounted pointer back
    to the XboxSite that owns it.

    The reason this is necessary is that there might be multiple
    IShellFolder's all looking at the same physical directory.  Since
    enumerations are expensive, we cache the enumeration information
    here, so that each IShellFolder client can use the information.

    This also lets us hold the motd, so that multiple clients can
    query for the motd without constantly pinging the site.
\*****************************************************************************/


#include "priv.h"
#include "xboxdir.h"
#include "xboxsite.h"
#include "xboxpidl.h"
#include "xboxurl.h"
#include "xboxpidl.h"
#include "statusbr.h"


/*****************************************************************************\
    FUNCTION: GetDisplayPath

    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxDir::GetDisplayPath(LPWSTR pwzDisplayPath, DWORD cchSize)
{
    return GetDisplayPathFromPidl(m_pidlXboxDir, pwzDisplayPath, cchSize, FALSE);
}


/*****************************************************************************\
    FUNCTION: CollectMotd

    DESCRIPTION:
        An InternetConnect has just completed.  Get the motd and cache it.

    hint - the connected handle, possibly 0 if error
\*****************************************************************************/
void CXboxDir::CollectMotd(HINTERNET hint)
{
    CXboxGlob * pfg = GetXboxResponse(GetXboxSite()->GetCWireEncoding());

    if (m_pfgMotd)
        m_pfgMotd->Release();

    m_pfgMotd = pfg;  // m_pfgMotd will take pfg's ref.
}


/*****************************************************************************\
    FUNCTION: CollectMotd

    DESCRIPTION:
        Shove a value into the cached list.
\*****************************************************************************/
void CXboxDir::SetCache(CXboxPidlList * pflHfpl)
{
    IUnknown_Set(&m_pflHfpl, pflHfpl);

    // If we are flushing the cache, then flush the Ratings info also.
    // This way the user can reenter the parent password if wanted.
    if (!pflHfpl && m_pfs)
        m_pfs->FlushRatingsInfo();
}


/*****************************************************************************\
    FUNCTION: CollectMotd

    DESCRIPTION:
        Get the value out of the cache.
\*****************************************************************************/
CXboxPidlList * CXboxDir::GetHfpl(void)
{
    CXboxPidlList * pfl;
    
    pfl = m_pflHfpl;
    if (pfl)
        pfl->AddRef();

    return pfl;
}


/*****************************************************************************\
    FUNCTION: CollectMotd

    DESCRIPTION:
        Get the XBOX site associated with a directory.
    This doesn't AddRef the return value.
\*****************************************************************************/
CXboxSite * CXboxDir::GetXboxSite(void)
{
    return m_pfs;
}


CXboxDir * CXboxDir::GetSubXboxDir(CXboxFolder * pff, LPCITEMIDLIST pidl, BOOL fPublic)
{
    CXboxDir * pfd = NULL;

    if (EVAL(pidl))
    {
        LPITEMIDLIST pidlChild = GetSubPidl(pff, pidl, fPublic);
        
        if (EVAL(pidlChild))
        {
            m_pfs->GetXboxDir(pidlChild, &pfd);
            ILFree(pidlChild);
        }
    }

    return pfd;
}


LPITEMIDLIST CXboxDir::GetSubPidl(CXboxFolder * pff, LPCITEMIDLIST pidlRelative, BOOL fPublic)
{
    LPITEMIDLIST pidlRoot = ((fPublic && pff) ? pff->GetPublicPidlRootIDClone() : NULL);
    LPITEMIDLIST pidlPublic = ILCombine(pidlRoot, m_pidl);
    LPITEMIDLIST pidlFull = NULL;

    if (pidlPublic)
    {
        pidlFull = ILCombine(pidlPublic, pidlRelative);
        ILFree(pidlPublic);
    }

    ILFree(pidlRoot);
    return pidlFull;
}


HRESULT CXboxDir::AddItem(LPCITEMIDLIST pidl)
{
    if (!m_pflHfpl)
        return S_OK;

#ifdef DEBUG
#if 0
    WCHAR wzDisplayPath[MAX_PATH];

    EVAL(SUCCEEDED(GetDisplayPathFromPidl(m_pidlXboxDir, wzDisplayPath, ARRAYSIZE(wzDisplayPath), FALSE)));

    TraceMsg(TF_ALWAYS, "CXboxDir::AddItem() Dir=\"%ls\", Item=\"%ls\".", wzDisplayPath, XboxPidl_GetFileDisplayName(pidl));
#endif // 0
#endif // DEBUG

    return m_pflHfpl->InsertSorted(pidl);
}


/*****************************************************************************\
    FUNCTION: CollectMotd

    DESCRIPTION:
        Get a HINTERNET for this directory.
\*****************************************************************************/
HRESULT CXboxDir::GetHint(HWND hwnd, CStatusBar * psb, HINTERNET * phint, IUnknown * punkSite, CXboxFolder * pff)
{
    HRESULT hr = m_pfs->GetHint(hwnd, m_pidlXboxDir, psb, phint, punkSite, pff);

    return hr;
}


/*****************************************************************************\
    FUNCTION: CollectMotd

    DESCRIPTION:
        Give a HINTERNET back to the XboxSite.
\*****************************************************************************/
void CXboxDir::ReleaseHint(HINTERNET hint)
{
    ASSERT(!hint || m_pfs); // If we have a hint to release, we need to call ::ReleaseHint()
    if (m_pfs)
        m_pfs->ReleaseHint(m_pidlXboxDir, hint);
}


/*****************************************************************************\
    FUNCTION: CollectMotd

    DESCRIPTION:
        Perform an operation with a temporary internet handle which is
    already connected to the site and resides in the correct directory.
\*****************************************************************************/
STDMETHODIMP CXboxDir::WithHint(CStatusBar * psb, HWND hwnd, HINTPROC hp, LPCVOID pv, IUnknown * punkSite, CXboxFolder * pff)
{
    HRESULT hr = E_FAIL;

    // Did the user turn off XBOX Folders?
    // If so, don't connect.  This will fix NT #406423 where the user turned
    // of XBOX Folders because they have a firewall (CISCO filtering Router)
    // that will kill packets in such a way the caller (WinSock/Wininet) needs
    // to wait for a timeout.  During this timeout, the browser will hang causing
    // the user to think it crashed.
    if (!SHRegGetBoolUSValue(SZ_REGKEY_XBOXFOLDER, SZ_REGKEY_USE_OLD_UI, FALSE, FALSE))
    {
        HINTERNET hint;
        HINTPROCINFO hpi;

        ASSERTNONCRITICAL;        // Cannot do psb (CStatusBar *) with the crst
        ASSERT(m_pfs);
        hpi.pfd = this;
        hpi.hwnd = hwnd;
        hpi.psb = psb;

        hr = GetHint(hwnd, psb, &hint, punkSite, pff);
        if (SUCCEEDED(hr)) // Ok if fails
        {
            BOOL fReleaseHint = TRUE;

            if (hp)
                hr = hp(hint, &hpi, (LPVOID)pv, &fReleaseHint);

            if (fReleaseHint)
                ReleaseHint(hint);
        }
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: _SetNameOfCB

    DESCRIPTION:
        If we were able to rename the file, return the output pidl.
    Also tell anybody who cares that this LPITEMIDLIST needs to be refreshed.

    The "A" emphasizes that the filename is received in ANSI.

    _UNDOCUMENTED_: The documentation on SetNameOf's treatment of
    the source pidl is random.  It seems to suggest that the source
    pidl is ILFree'd by SetNameOf, but it isn't.
\*****************************************************************************/
HRESULT CXboxDir::_SetNameOfCB(HINTERNET hint, HINTPROCINFO * phpi, LPVOID pv, BOOL * pfReleaseHint)
{
    LPSETNAMEOFINFO psnoi = (LPSETNAMEOFINFO) pv;

    if (phpi->psb)
        phpi->psb->SetStatusMessage(IDS_RENAMING, XboxPidl_GetLastItemDisplayName(psnoi->pidlOld));

    // Remember, XBOX filenames are always in the ANSI character set
    return XboxRenameFilePidlWrap(hint, TRUE, psnoi->pidlOld, psnoi->pidlNew);
}


BOOL CXboxDir::_DoesItemExist(HWND hwnd, CXboxFolder * pff, LPCITEMIDLIST pidl)
{
    XBOX_FIND_DATA wfd;
    HRESULT hr = GetFindData(hwnd, XboxPidl_GetLastItemWireName(pidl), &wfd, pff);

    return ((S_OK == hr) ? TRUE : FALSE);
}


BOOL CXboxDir::_ConfirmReplaceWithRename(HWND hwnd)
{
    TCHAR szTitle[MAX_PATH];
    TCHAR szMessage[MAX_PATH];

    EVAL(LoadString(HINST_THISDLL, IDS_XBOXERR_TITLE, szTitle, ARRAYSIZE(szTitle)));
    EVAL(LoadString(HINST_THISDLL, IDS_XBOXERR_RENAME_REPLACE, szMessage, ARRAYSIZE(szMessage)));

    return ((IDYES == MessageBox(hwnd, szMessage, szTitle, (MB_ICONQUESTION | MB_YESNO))) ? TRUE : FALSE);
}


HRESULT CXboxDir::SetNameOf(CXboxFolder * pff, HWND hwndOwner, LPCITEMIDLIST pidl,
           LPCWSTR pwzName, DWORD dwReserved, LPITEMIDLIST *ppidlOut)
{
    HRESULT hr = S_OK;
    SETNAMEOFINFO snoi;
    CWireEncoding cWireEncoding;

    ASSERT(pff);

    if (!pwzName)
        return E_FAIL;

    snoi.pidlOld = pidl;
    cWireEncoding.ChangeXboxItemIDName(NULL, pidl, pwzName, IsUTF8Supported(), (LPITEMIDLIST *) &snoi.pidlNew);

    if (snoi.pidlNew)
    {
#ifdef FEATURE_REPLACE_IN_RENAME
        // Disable this feature because we don't ever do the delete and there is no
        // way for us to have wininet do the delete for us.

        // Does it already exist?  We don't care if we don't have an hwnd because
        // we can't ask the user to replace so we will just go ahead.
        if (hwndOwner && _DoesItemExist(hwndOwner, pff, snoi.pidlNew))
        {
            // Yes, so let's make sure it's OK with the user to replace it.
            hr = (_ConfirmReplaceWithRename(hwndOwner) ? S_OK : HRESULT_FROM_WIN32(ERROR_CANCELLED));
            bugbug; // Delete the dest file so we will succeed with the rename.
        }
#endif FEATURE_REPLACE_IN_RENAME

        if (S_OK == hr)
        {
            hr = WithHint(NULL, hwndOwner, _SetNameOfCB, (LPVOID) &snoi, NULL, pff);
            if (SUCCEEDED(hr))  // Will fail if use didn't have permission to rename
            {
                // WARNING: The date/time stamp on the server may be different than what we give to SHChangeNotify()
                //          but this is probably reasonable for perf reasons.
                XboxChangeNotify(hwndOwner, XboxPidl_DirChoose(pidl, SHCNE_RENAMEFOLDER, SHCNE_RENAMEITEM), pff, this, pidl, snoi.pidlNew, TRUE);

                if (ppidlOut)
                    *ppidlOut = ILClone(snoi.pidlNew);
            }
        }

        ILFree((LPITEMIDLIST) snoi.pidlNew);
    }

    return hr;
}


LPCITEMIDLIST CXboxDir::GetPidlFromWireName(LPCWIRESTR pwWireName)
{
    LPITEMIDLIST pidlToFind = NULL;
    LPITEMIDLIST pidlTemp;
    WCHAR wzDisplayName[MAX_PATH];
    
    // This isn't valid because the code page could be wrong, but we don't care
    // because it's not used in the search for the pidl, the pwWireName is.
    SHAnsiToUnicode(pwWireName, wzDisplayName, ARRAYSIZE(wzDisplayName));
    if (m_pflHfpl && EVAL(SUCCEEDED(XboxItemID_CreateFake(wzDisplayName, pwWireName, FALSE, FALSE, FALSE, &pidlTemp))))
    {
        // PERF: log 2 (sizeof(m_pflHfpl))
        pidlToFind = m_pflHfpl->FindPidl(pidlTemp, FALSE);
        // We will try again and this time allow for the case to not match
        if (!pidlToFind)
            pidlToFind = m_pflHfpl->FindPidl(pidlTemp, TRUE);
        ILFree(pidlTemp);
    }

    return pidlToFind;
}


LPCITEMIDLIST CXboxDir::GetPidlFromDisplayName(LPCWSTR pwzDisplayName)
{
    WIRECHAR wWireName[MAX_PATH];
    CWireEncoding * pwe = GetXboxSite()->GetCWireEncoding();

    EVAL(SUCCEEDED(pwe->UnicodeToWireBytes(NULL, pwzDisplayName, (IsUTF8Supported() ? WIREENC_USE_UTF8 : WIREENC_NONE), wWireName, ARRAYSIZE(wWireName))));
    return GetPidlFromWireName(wWireName);
}


/*****************************************************************************\
    FUNCTION: IsRoot

    DESCRIPTION:
        Returns FALSE if we are at the "XBOX Folder" root level, not
    inside an actual XBOX site.y
\*****************************************************************************/
BOOL CXboxDir::IsRoot(void)
{
    return ILIsEmpty(m_pidl);
}


typedef struct tagGETFINDDATAINFO
{
    LPCWIRESTR pwWireName;
    LPXBOX_FIND_DATA pwfd;
} GETFINDDATAINFO, * LPGETFINDDATAINFO;

HRESULT CXboxDir::_GetFindData(HINTERNET hint, HINTPROCINFO * phpi, LPVOID pv, BOOL * pfReleaseHint)
{
    LPGETFINDDATAINFO pgfdi = (LPGETFINDDATAINFO) pv;
    HRESULT hr = S_FALSE;

    // Remember, XBOX filenames are always in the ANSI character set
    // PERF: Status
    hr = XboxDoesFileExist(hint, TRUE, pgfdi->pwWireName, pgfdi->pwfd, INTERNET_NO_CALLBACK);
    if (SUCCEEDED(hr))
    {
        if (!StrCmpIA(pgfdi->pwfd->cFileName, pgfdi->pwWireName))
            hr = S_OK;        // The are equal.
        else if (!StrCmpA(pgfdi->pwfd->cFileName, SZ_DOTA))
        {
            //    Coincidence of coincidences:  If we found a ".",
            //  then the wfd already contains the description of
            //  the directory!  In other words, the wfd contains
            //  the correct information after all, save for the name.
            //  Aren't we lucky.
            //
            //  And if it isn't dot, then it's some directory with
            //  unknown attributes (so we'll use whatever's lying around).
            //  Just make sure it's a directory.
            pgfdi->pwfd->dwFileAttributes |= FILE_ATTRIBUTE_DIRECTORY;
            StrCpyNA(pgfdi->pwfd->cFileName, pgfdi->pwWireName, ARRAYSIZE(pgfdi->pwfd->cFileName));
            hr = S_OK;
        }
    }
    else
    {
#ifndef DEBUG
        // Don't display an error msg because some callers will call when they
        // know the file may not exist.  This is the case for ConfirmCopy().
        hr = S_FALSE;
#endif // DEBUG
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: GetFindData

    DESCRIPTION:
        Get the WIN32_FIND_DATA for a file, given by name.

    This is done as part of drag/drop to allow for an overwrite prompt.

    BUGBUG -- This is all a gross hack because the STAT command
    isn't supported by WinINet (as XboxGetFileAttributes).

    Not that it'd help, because Xbox.microsoft.com is OUT OF SPEC
    with regard to the STAT command.  (The first line of the output
    isn't terminated correctly, causing the client to hang.)

    Furthermore, UNIX Xbox servers implement STAT incorrectly, too,
    rendering STAT no more useful than LIST.

    HACKHACK -- There is a bug in WinINet where doing a FindFirst
    on a name which happens to be a directory returns the contents
    of the directory instead of the attributes of the directory itself.
    (This is actually a failing of most XBOX implementation, because
    they just use /bin/ls for directory listings.)

    So we compare the name that comes back against the name we ask
    for.  If they are different, then it's a folder.  We'll compare
    in a case-insensitive manner because we don't know whether the
    server is case-sensitive or not.

    Note that we can get faked out if a directory contains a file
    which has the same name as the directory.  There is nothing we
    can do about that.  Fortunately, UNIX servers always return "."
    as the first file in a subdirectory, so 99% of the time, we'll
    do the right thing.
\*****************************************************************************/
HRESULT CXboxDir::GetFindData(HWND hwnd, LPCWIRESTR pwWireName, LPXBOX_FIND_DATA pwfd, CXboxFolder * pff)
{
    GETFINDDATAINFO gfdi = {pwWireName, pwfd};
    HRESULT hr = WithHint(NULL, hwnd, _GetFindData, &gfdi, NULL, pff);

    return hr;
}


/*****************************************************************************\
    FUNCTION: GetFindDataForDisplayPath

    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxDir::GetFindDataForDisplayPath(HWND hwnd, LPCWSTR pwzDisplayPath, LPXBOX_FIND_DATA pwfd, CXboxFolder * pff)
{
    CWireEncoding * pwe = GetXboxSite()->GetCWireEncoding();
    WIRECHAR wWirePath[MAX_PATH];

    EVAL(SUCCEEDED(pwe->UnicodeToWireBytes(NULL, pwzDisplayPath, (IsUTF8Supported() ? WIREENC_USE_UTF8 : WIREENC_NONE), wWirePath, ARRAYSIZE(wWirePath))));
    return GetFindData(hwnd, wWirePath, pwfd, pff);
}


/*****************************************************************************\
    FUNCTION: GetNameOf

    DESCRIPTION:
        Common worker that handles SHGDN_FORPARSING style GetDisplayNameOf's.

    Note! that since we do not support junctions (duh), we can
    safely walk down the pidl generating goop as we go, secure
    in the knowledge that we are in charge of every subpidl.

    _CHARSET_:  Since XBOX filenames are always in the ANSI character
    set, by RFC 1738, we can return ANSI display names without loss
    of fidelity.  In a general folder implementation, we should be
    using cStr to return display names, so that the UNICODE
    version of the shell extension can handle UNICODE names.
\*****************************************************************************/
HRESULT CXboxDir::GetNameOf(LPCITEMIDLIST pidl, DWORD shgno, LPSTRRET pstr)
{
    LPITEMIDLIST pidlFull = ILCombine(m_pidl, pidl);
    HRESULT hr = E_FAIL;

    if (pidlFull)
    {
        hr = StrRetFromXboxPidl(pstr, shgno, pidlFull);
        ILFree(pidlFull);
    }

    return hr;
}

/*****************************************************************************\
      FUNCTION: ChangeFolderName

      DESCRIPTION:
        A rename happened on this folder so update the szDir and m_pidl

      PARAMETERS:
        pidlXboxPath
\*****************************************************************************/
HRESULT CXboxDir::ChangeFolderName(LPCITEMIDLIST pidlXboxPath)
{
    HRESULT hr = E_FAIL;
    LPITEMIDLIST pidlNewXboxPath = NULL;

    EVAL(SUCCEEDED(m_pfs->FlushSubDirs(m_pidlXboxDir)));
    hr = XboxPidl_ReplacePath(m_pidl, pidlXboxPath, &pidlNewXboxPath);
    _SetXboxDir(m_pfs, this, pidlXboxPath);
    if (EVAL(SUCCEEDED(hr)))
    {
        Pidl_Set(&m_pidl, pidlNewXboxPath);
        ILFree(pidlNewXboxPath);
    }

    return hr;
}


/*****************************************************************************\
      FUNCTION: _CompareDirs

      DESCRIPTION:
        Check if the indicated pfd is already rooted at the indicated pidl.
\*****************************************************************************/
int CALLBACK _CompareDirs(LPVOID pvPidl, LPVOID pvXboxDir, LPARAM lParam)
{
    LPCITEMIDLIST pidl = (LPCITEMIDLIST) pvPidl;
    CXboxDir * pfd = (CXboxDir *) pvXboxDir;

    return XboxItemID_CompareIDsInt(COL_NAME, pfd->m_pidl, pidl, FCMP_NORMAL);
}


HRESULT CXboxDir::_SetXboxDir(CXboxSite * pfs, CXboxDir * pfd, LPCITEMIDLIST pidl)
{
    if (XboxID_IsServerItemID(pidl))
        pidl = _ILNext(pidl);

    // We don't want pfd->m_pidlXboxDir to include the virtual root.
    if (pfd->GetXboxSite()->HasVirtualRoot())
    {
        LPITEMIDLIST pidlIterate = (LPITEMIDLIST) pidl;
        LPITEMIDLIST pidlVRootIterate = (LPITEMIDLIST) pfd->GetXboxSite()->GetVirtualRootReference();

        ASSERT(!XboxID_IsServerItemID(pidl) && !XboxID_IsServerItemID(pidlVRootIterate));
        // Let's see if pidl starts off with 
        while (!ILIsEmpty(pidlVRootIterate) && !ILIsEmpty(pidlIterate) && 
                XboxItemID_IsEqual(pidlVRootIterate, pidlIterate))
        {
            pidlVRootIterate = _ILNext(pidlVRootIterate);
            pidlIterate = _ILNext(pidlIterate);
        }

        if (ILIsEmpty(pidlVRootIterate))
            pidl = (LPCITEMIDLIST)pidlIterate;

    }

    Pidl_Set(&pfd->m_pidlXboxDir, pidl);
    return S_OK;
}


/*****************************************************************************\
      FUNCTION: CXboxDir_Create

      DESCRIPTION:
        Create a brand new XboxDir structure.
\*****************************************************************************/
HRESULT CXboxDir_Create(CXboxSite * pfs, LPCITEMIDLIST pidl, CXboxDir ** ppfd)
{
    CXboxDir * pfd = new CXboxDir();
    HRESULT hr = E_OUTOFMEMORY;

    ASSERT(pfs);
    if (EVAL(pfd))
    {
        // WARNING: No ref held because it's a back pointer.
        //          This requires that the parent (CXboxSite) always
        //          out live this object.
        pfd->m_pfs = pfs;

        Pidl_Set(&pfd->m_pidl, pidl);
        if (EVAL(pfd->m_pidl))
            hr = pfd->_SetXboxDir(pfs, pfd, pidl);
        else
            IUnknown_Set(&pfd, NULL);
    }

    *ppfd = pfd;
    ASSERT(*ppfd ? SUCCEEDED(hr) : FAILED(hr));

    return hr;
}


/****************************************************\
    Constructor
\****************************************************/
CXboxDir::CXboxDir() : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_pfs);
    ASSERT(!m_pflHfpl);
    ASSERT(!m_pfgMotd);
    ASSERT(!m_pidl);

    LEAK_ADDREF(LEAK_CXboxDir);
}


/****************************************************\
    Destructor
\****************************************************/
CXboxDir::~CXboxDir()
{
    // WARNING: m_pfs is a back pointer that doesn't have a ref.
    // m_pfs)

    IUnknown_Set(&m_pflHfpl, NULL);
    IUnknown_Set(&m_pfgMotd, NULL);
    
    if (m_pidl)         // Win95's Shell32.dll crashes with ILFree(NULL)
        ILFree(m_pidl);

    DllRelease();
    LEAK_DELREF(LEAK_CXboxDir);
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CXboxDir::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CXboxDir::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CXboxDir::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, IUnknown*);
    }
    else
    {
        TraceMsg(TF_XBOXQI, "CXboxDir::QueryInterface() failed.");
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxdrop.h ===
/*****************************************************************************\
    FILE: xboxdrop.h - IDropTarget interface

    Remarks:

    Note that you cannot create a shortcut on an XBOX site.  Although
    there's nothing technically preventing it, it's not done because
    the shortcut won't be of much use on an XBOX site.  (It points to
    your local machine, which doesn't help much for people not on the
    same network!)

    If you really want to put a shortcut file on an XBOX site, create
    it on the desktop, then drag the shortcut onto the XBOX site.

    The default verb for XBOX sites is always "Copy".  This is true
    even if an intra-site drag-drop is being done.

    DESCRIPTION:
        DefView will cache the IDropTarget pointer (CXboxDrop) for a shell extension.
    When it calls CXboxDrop::Drop(), the work needs to be done on a background
    thread in order to not block the UI thread.  The problem is that if the user
    does another drag to the same Xbox Window, CXboxDrop::Drop() will be called again.
    For this reasons, CXboxDrop::Drop() cannot have any state after it returns.
    In order to accomplish this with the asynch background thread, we have
    CXboxDrop::Drop() call CDropOperation_Create(), and then CDropOperation->DoOperation().
    And then it will orphan (call Release()) the CDropOperation.  The CDropOperation
    will then destroy itself when the copy is finishes.  This enables subsequent calls
    to CXboxDrop::Drop() to spawn separate CDropOperation objects so each can maintain
    the state for that specifc operation and CXboxDrop remains stateless.
\*****************************************************************************/

#ifndef _XBOXDROP_H
#define _XBOXDROP_H

#include "util.h"

typedef enum OPS
{                           // Overwrite prompt status
    opsPrompt,              // Prompt each collision
    opsYesToAll,            // Overwrite unconditionally
    opsNoToAll,             // Never overwrite
    opsCancel,              // Stop the operation
} OPS;

#define COHDI_FILESIZE_COUNT            5
#define COHDI_COPY_FILES                6

typedef struct tagCOPYONEHDROPINFO
{
    CXboxFolder * pff;
    LPCWSTR pszFSSource;
    LPCWSTR pszXboxDest;
    LPCWSTR pszDir;
    DWORD dwOperation;                  // COHDI_FILESIZE_COUNT, COHDI_COPY_FILES, etc.
    OPS ops;
    BOOL fIsRoot;
    CMultiLanguageCache * pmlc;
    LPITEMIDLIST pidlServer;
    BOOL fFireChangeNotify;     // Don't fire change notify on BrowserOnly when replacing a file.
    PROGRESSINFO progInfo;
} COPYONEHDROPINFO, * LPCOPYONEHDROPINFO;

typedef HRESULT (*STREAMCOPYPROC)(IStream * pstm, DWORD dwFlags, DWORD dwFileSizeHigh, DWORD dwFileSizeLow, LPVOID pv, ULARGE_INTEGER *pqw);

#ifdef UNICODE
#define _EnumOneHdrop          _EnumOneHdropW
#else // UNICODE
#define _EnumOneHdrop          _EnumOneHdropA
#endif // UNICODE


/*****************************************************************************\

    CXboxDrop

    de and pde are rather gnarly.

    pde is where the output drop effect is kept.  A drop handler
    can force the effect to be DROPEFFECT_COPY if it encounters a
    situation that indicates that the source shouldn't be deleted.
    (E.g., if a file is not copied due to an illegal file name.)

    de is where the current effect is kept.  A drop handler
    should consult de to decide whether or not the source
    should be deleted.  (Used by the HDROP handler, because it is
    the drop target's responsibility to delete the source of an
    HDROP if applicable.)

    You should read from de and write to *pde.  Don't
    write to de or read from *pde.

    The overwrite prompting state tells us how to handle
    the case where an incoming file collides with an existing file.

    DESCRIPTION:
        DefView will cache the IDropTarget pointer (CXboxDrop) for a shell extension.
    When it calls CXboxDrop::Drop(), the work needs to be done on a background
    thread in order to not block the UI thread.  The problem is that if the user
    does another drag to the same Xbox Window, CXboxDrop::Drop() will be called again.
    For this reasons, CXboxDrop::Drop() cannot have any state after it returns.
    In order to accomplish this with the asynch background thread, we have
    CXboxDrop::Drop() call CDropOperation_Create(), and then CDropOperation->DoOperation().
    And then it will orphan (call Release()) the CDropOperation.  The CDropOperation
    will then destroy itself when the copy is finishes.  This enables subsequent calls
    to CXboxDrop::Drop() to spawn separate CDropOperation objects so each can maintain
    the state for that specifc operation and CXboxDrop remains stateless.
\*****************************************************************************/
class CXboxDrop          : public IDropTarget
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    
    // *** IDropTarget ***
    virtual STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragLeave(void);
    virtual STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

public:
    CXboxDrop();
    ~CXboxDrop(void);

    // Public Member Functions
    DWORD GetEffectsAvail(IDataObject * pdto);
    STDMETHODIMP EnumHdrop(HGLOBAL hdrop, HGLOBAL hmap, BOOL fCopy);

    static HRESULT _CopyHglobal(IStream * pstm, DWORD dwFlags, DWORD dwFileSizeHigh, DWORD dwFileSizeLow, LPVOID pvSrc, ULARGE_INTEGER *pqw);
    static HRESULT CopyStream(IStream * pstm, DWORD dwFlags, DWORD dwFileSizeHigh, DWORD dwFileSizeLow, LPVOID pvSrc, ULARGE_INTEGER *pqw);
    

    // Friend Functions
    friend HRESULT CXboxDrop_Create(CXboxFolder * pff, HWND hwnd, CXboxDrop ** ppfm);

protected:
    // Protected Member Variables
    int                     m_cRef;

    CXboxFolder *            m_pff;          // The owner
    CXboxDir *               m_pfd;          // The XboxDir of the owner
    HWND                    m_hwnd;         // The window being drug over

    DWORD                   m_grfks;        // Last grfKeyState seen
    DWORD                   m_grfksAvail;   // Effects available
    DROPEFFECT              m_de;           // Effect being performed
    DROPEFFECT *            m_pde;          // Output effect
    OPS                     m_ops;          // Overwrite prompting state
    int                     m_cobj;         // Number of objects being dropped

    // Private Member Functions
    HRESULT SetEffect(DROPEFFECT * pde);
    HRESULT _InvokePaste(LPCMINVOKECOMMANDINFO pici);
    BOOL _HasData(IDataObject * pdto, FORMATETC * pformatetc) { return (S_OK == pdto->QueryGetData(pformatetc)); };
    DROPEFFECT GetEffect(POINTL pt);
    HRESULT CopyStorage(LPCTSTR pszFile, IStorage * pstgIn);
    HRESULT CopyHdrop(IDataObject * pdto, STGMEDIUM *psm);
    HRESULT CopyAsStream(LPCTSTR pszName, DWORD dwFileAttributes, DWORD dwFlags, DWORD dwFileSizeHigh, DWORD dwFileSizeLow, STREAMCOPYPROC pfn, LPVOID pv);
    HRESULT CopyFCont(LPCTSTR pszName, DWORD dwFileAttributes, DWORD dwFlags, DWORD dwFileSizeHigh, DWORD dwFileSizeLow, STGMEDIUM *psm);
    HRESULT CopyFGD(IDataObject * pdto, STGMEDIUM *psm, BOOL fUnicode);
    HRESULT _Copy(IDataObject * pdto);
    HRESULT _CopyOneHdrop(LPCTSTR pszFSSource, LPCTSTR pszXboxDest, IProgressDialog * ppd);

    HRESULT _StartBackgroundInteration(void);
    HRESULT _DoCountIteration(void);
    HRESULT _GetFSSourcePaths(HGLOBAL hdrop, BOOL * pfAnsi);
    HRESULT _GetXboxDestPaths(HGLOBAL hmap, BOOL fAnsi);

private:
    // Private Member Variables
    LPCTSTR                 m_pszzFSSource;         // Paths
    LPCTSTR                 m_pszzXboxDest;              // Map


    HRESULT _CalcSizeOneHdrop(LPCWSTR pszFSSource, LPCWSTR pszXboxDest, IProgressDialog * ppd);
    HRESULT _GetFileDescriptor(LONG nIndex, LPFILEGROUPDESCRIPTORW pfgdW, LPFILEGROUPDESCRIPTORA pfgdA, BOOL fUnicode, LPFILEDESCRIPTOR pfd);
    HRESULT _CreateFGDDirectory(LPFILEDESCRIPTOR pfd);
    BOOL _IsXBOXOperationAllowed(IDataObject * pdto);
    CXboxDir * _GetRelativePidl(LPCWSTR pszFullPath, DWORD dwFileAttributes, DWORD dwFileSizeHigh, DWORD dwFileSizeLow, LPITEMIDLIST * ppidl);
};

#endif // _XBOXDROP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxdir.h ===
/*****************************************************************************
 *	xboxdir.h
 *****************************************************************************/

#ifndef _XBOXDIR_H
#define _XBOXDIR_H

#include "xboxsite.h"
#include "xboxfldr.h"
#include "xboxlist.h"
#include "xboxglob.h"
#include "xboxpl.h"


typedef struct tagSETNAMEOFINFO
{
    LPCITEMIDLIST pidlOld;
    LPCITEMIDLIST pidlNew;
} SETNAMEOFINFO, * LPSETNAMEOFINFO;

int CALLBACK _CompareDirs(LPVOID pvPidl, LPVOID pvXboxDir, LPARAM lParam);

/*****************************************************************************\
    CLASS: CXboxDir

    DESCRIPTION:
        This class is the cache of a directory on some server.  m_pfs identifies
    the server.

    BUGBUG: PERF - PERF - PERF - PERF
        This directory contains the folder contents in the form of a list of
    pidls (m_pflHfpl).  We need to keep them in order based on name so that
    way looking up and changing is fast because of all the work we need to do
    with change notify.  Also, when we go to parse a display name, we look here
    first, so that needs to be fast.
\*****************************************************************************/

class CXboxDir           : public IUnknown
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);


public:
    CXboxDir();
    ~CXboxDir(void);

    // Public Member Functions
    void CollectMotd(HINTERNET hint);
    void SetCache(CXboxPidlList * pflHfpl);
    CXboxPidlList * GetHfpl(void);
    HRESULT GetHint(HWND hwnd, CStatusBar * psb, HINTERNET * phint, IUnknown * punkSite, CXboxFolder * pff);
    void ReleaseHint(HINTERNET hint);
    STDMETHODIMP WithHint(CStatusBar * psb, HWND hwnd, HINTPROC hp, LPCVOID pv, IUnknown * punkSite, CXboxFolder * pff);
    HRESULT SetNameOf(CXboxFolder * pff, HWND hwndOwner, LPCITEMIDLIST pidl, LPCTSTR pszName, DWORD dwReserved, LPITEMIDLIST *ppidlOut);
    BOOL IsRoot(void);
    BOOL IsCHMODSupported(void) {return m_pfs->IsCHMODSupported();};
    BOOL IsUTF8Supported(void) {return m_pfs->IsUTF8Supported();};
    HRESULT GetFindDataForDisplayPath(HWND hwnd, LPCWSTR pwzDisplayPath, LPXBOX_FIND_DATA pwfd, CXboxFolder * pff);
    HRESULT GetFindData(HWND hwnd, LPCWIRESTR pwWireName, LPXBOX_FIND_DATA pwfd, CXboxFolder * pff);
    HRESULT GetNameOf(LPCITEMIDLIST pidl, DWORD shgno, LPSTRRET pstr);
//    HRESULT DisambiguatePidl(LPCITEMIDLIST pidl);
    CXboxSite * GetXboxSite(void);
    CXboxDir * GetSubXboxDir(CXboxFolder * pff, LPCITEMIDLIST pidl, BOOL fPublic);
    HRESULT GetDisplayPath(LPTSTR pszUrlPath, DWORD cchSize);

    LPCITEMIDLIST GetPathPidlReference(void) { return m_pidlXboxDir;};
    LPCITEMIDLIST GetPidlReference(void) { return m_pidl;};
    LPCITEMIDLIST GetPidlFromWireName(LPCWIRESTR pwWireName);
    LPCITEMIDLIST GetPidlFromDisplayName(LPCWSTR pwzDisplayName);
    LPITEMIDLIST GetSubPidl(CXboxFolder * pff, LPCITEMIDLIST pidlRelative, BOOL fPublic);
    HRESULT AddItem(LPCITEMIDLIST pidl);
    HRESULT ChangeFolderName(LPCITEMIDLIST pidlXboxPath);
    HRESULT ReplacePidl(LPCITEMIDLIST pidlSrc, LPCITEMIDLIST pidlDest) { if (!m_pflHfpl) return S_OK; return m_pflHfpl->ReplacePidl(pidlSrc, pidlDest); };
    HRESULT DeletePidl(LPCITEMIDLIST pidl) { if (!m_pflHfpl) return S_OK; return m_pflHfpl->CompareAndDeletePidl(pidl); };

    static HRESULT _SetNameOfCB(HINTERNET hint, HINTPROCINFO * phpi, LPVOID pv, BOOL * pfReleaseHint);
    static HRESULT _GetFindData(HINTERNET hint0, HINTPROCINFO * phpi, LPVOID pv, BOOL * pfReleaseHint);


    // Friend Functions
    friend HRESULT CXboxDir_Create(CXboxSite * pfs, LPCITEMIDLIST pidl, CXboxDir ** ppfd);

    friend int CALLBACK _CompareDirs(LPVOID pvPidl, LPVOID pvXboxDir, LPARAM lParam);


protected:
    int                     m_cRef;

    CXboxSite *              m_pfs;          // The XBOX site I belong to. (WARNING: No Ref Held)
    CXboxPidlList *          m_pflHfpl;      // The items inside this directory
    CXboxGlob *              m_pfgMotd;      // The message of the day
    LPITEMIDLIST            m_pidlXboxDir;   // Name of subdirectory w/o Virtual Root and decoded. Doesn't include Server ID
    LPITEMIDLIST            m_pidl;         // Where we live.  May include the virtual root

    BOOL _DoesItemExist(HWND hwnd, CXboxFolder * pff, LPCITEMIDLIST pidl);
    BOOL _ConfirmReplaceWithRename(HWND hwnd);
    HRESULT _SetXboxDir(CXboxSite * pfs, CXboxDir * pfd, LPCITEMIDLIST pidl);
};

#endif // _XBOXDIR_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxefe.cpp ===
/*****************************************************************************
 *
 *    xboxefe.cpp - IEnumFORMATETC interface
 *
 *****************************************************************************/

#include "priv.h"
#include "xboxefe.h"
#include "xboxobj.h"


/*****************************************************************************
 *    CXboxEfe::_NextOne
 *****************************************************************************/

HRESULT CXboxEfe::_NextOne(FORMATETC * pfetc)
{
    HRESULT hr = S_FALSE;

    while (ShouldSkipDropFormat(m_dwIndex))
        m_dwIndex++;

    ASSERT(m_hdsaFormatEtc);
    if (m_dwIndex < (DWORD) DSA_GetItemCount(m_hdsaFormatEtc))
    {
        DSA_GetItem(m_hdsaFormatEtc, m_dwIndex, (LPVOID) pfetc);
        m_dwIndex++;         // We are off to the next one
        hr = S_OK;
    }

    if ((S_OK != hr) && m_pfo)
    {
        // We finished looking thru the types supported by the IDataObject.
        // Now look for other items inserted by IDataObject::SetData()
        if (m_dwExtraIndex < (DWORD) DSA_GetItemCount(m_pfo->m_hdsaSetData))
        {
            FORMATETC_STGMEDIUM fs;

            DSA_GetItem(m_pfo->m_hdsaSetData, m_dwExtraIndex, (LPVOID) &fs);
            *pfetc = fs.formatEtc;
            m_dwExtraIndex++;         // We are off to the next one
            hr = S_OK;
        }
    }
    return hr;
}


//===========================
// *** IEnumFORMATETC Interface ***
//===========================

/*****************************************************************************
 *
 *    IEnumFORMATETC::Next
 *
 *    Creates a brand new enumerator based on an existing one.
 *
 *
 *    OLE random documentation of the day:  IEnumXXX::Next.
 *
 *    rgelt - Receives an array of size celt (or larger).
 *
 *    "Receives an array"?  No, it doesn't receive an array.
 *    It *is* an array.  The array receives *elements*.
 *
 *    "Or larger"?  Does this mean I can return more than the caller
 *    asked for?  No, of course not, because the caller didn't allocate
 *    enough memory to hold that many return values.
 *
 *    No semantics are assigned to the possibility of celt = 0.
 *    Since I am a mathematician, I treat it as vacuous success.
 *
 *    pcelt is documented as an INOUT parameter, but no semantics
 *    are assigned to its input value.
 *
 *    The dox don't say that you are allowed to return *pcelt < celt
 *    for reasons other than "no more elements", but the shell does
 *    it everywhere, so maybe it's legal...
 *
 *****************************************************************************/

HRESULT CXboxEfe::Next(ULONG celt, FORMATETC * rgelt, ULONG *pceltFetched)
{
    HRESULT hres = S_FALSE;
    DWORD dwIndex;

    // Do they want more and do we have more to give?
    for (dwIndex = 0; dwIndex < celt; dwIndex++)
    {
        if (S_FALSE == _NextOne(&rgelt[dwIndex]))        // Yes, so give away...
            break;

        ASSERT(NULL == rgelt[dwIndex].ptd); // We don't do this correctly.
#ifdef DEBUG
        char szName[MAX_PATH];
        GetCfBufA(rgelt[dwIndex].cfFormat, szName, ARRAYSIZE(szName));
        //TraceMsg(TF_XBOX_IDENUM, "CXboxEfe::Next() - Returning %hs", szName);
#endif // DEBUG
    }

    if (pceltFetched)
        *pceltFetched = dwIndex;

    // Were we able to give any?
    if ((0 != dwIndex) || (0 == celt))
        hres = S_OK;

    return hres;
}


/*****************************************************************************
 *    IEnumFORMATETC::Skip
 *****************************************************************************/

HRESULT CXboxEfe::Skip(ULONG celt)
{
    m_dwIndex += celt;

    return S_OK;
}


/*****************************************************************************
 *    IEnumFORMATETC::Reset
 *****************************************************************************/

HRESULT CXboxEfe::Reset(void)
{
    m_dwIndex = 0;
    return S_OK;
}


/*****************************************************************************
 *
 *    IEnumFORMATETC::Clone
 *
 *    Creates a brand new enumerator based on an existing one.
 *
 *****************************************************************************/

HRESULT CXboxEfe::Clone(IEnumFORMATETC **ppenum)
{
    return CXboxEfe_Create((DWORD) DSA_GetItemCount(m_hdsaFormatEtc), m_hdsaFormatEtc, m_dwIndex, m_pfo, ppenum);
}


/*****************************************************************************
 *
 *    CXboxEfe_Create
 *
 *    Creates a brand new enumerator based on a list of possibilities.
 *
 *    Note that we are EVIL and know about CFSTR_FILECONTENTS here:
 *    A FORMATETC of FileContents is always valid.  This is important,
 *    because CXboxObj doesn't actually have a STGMEDIUM for file contents.
 *    (Due to lindex weirdness.)
 *
 *****************************************************************************/

HRESULT CXboxEfe_Create(DWORD dwSize, FORMATETC rgfe[], STGMEDIUM rgstg[], CXboxObj * pfo, CXboxEfe ** ppfefe)
{
    CXboxEfe * pfefe;
    HRESULT hres = E_OUTOFMEMORY;

    pfefe = *ppfefe = new CXboxEfe(dwSize, rgfe, rgstg, pfo);
    if (EVAL(pfefe))
    {
        if (!pfefe->m_hdsaFormatEtc)
            pfefe->Release();
        else
            hres = S_OK;
    }

    if (FAILED(hres) && pfefe)
        IUnknown_Set(ppfefe, NULL);

    return hres;
}


/*****************************************************************************
 *
 *    CXboxEfe_Create
 *
 *    Creates a brand new enumerator based on a list of possibilities.
 *
 *    Note that we are EVIL and know about CFSTR_FILECONTENTS here:
 *    A FORMATETC of FileContents is always valid.  This is important,
 *    because CXboxObj doesn't actually have a STGMEDIUM for file contents.
 *    (Due to lindex weirdness.)
 *
 *****************************************************************************/

HRESULT CXboxEfe_Create(DWORD dwSize, FORMATETC rgfe[], STGMEDIUM rgstg[], CXboxObj * pfo, IEnumFORMATETC ** ppenum)
{
    CXboxEfe * pfefe;
    HRESULT hres = CXboxEfe_Create(dwSize, rgfe, rgstg, pfo, &pfefe);

    if (EVAL(pfefe))
    {
        hres = pfefe->QueryInterface(IID_IEnumFORMATETC, (LPVOID *) ppenum);
        pfefe->Release();
    }

    return hres;
}


/*****************************************************************************
 *
 *    CXboxEfe_Create
 *****************************************************************************/

HRESULT CXboxEfe_Create(DWORD dwSize, HDSA m_hdsaFormatEtc, DWORD dwIndex, CXboxObj * pfo, IEnumFORMATETC ** ppenum)
{
    CXboxEfe * pfefe;
    HRESULT hres = E_OUTOFMEMORY;

    pfefe = new CXboxEfe(dwSize, m_hdsaFormatEtc, pfo, dwIndex);
    if (EVAL(pfefe))
    {
        hres = pfefe->QueryInterface(IID_IEnumFORMATETC, (LPVOID *) ppenum);
        pfefe->Release();
    }

    return hres;
}


/****************************************************\
    Constructor
\****************************************************/
CXboxEfe::CXboxEfe(DWORD dwSize, FORMATETC rgfe[], STGMEDIUM rgstg[], CXboxObj * pfo) : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_dwIndex);
    ASSERT(!m_hdsaFormatEtc);
    ASSERT(!m_pfo);

    m_hdsaFormatEtc = DSA_Create(sizeof(rgfe[0]), 10);
    if (EVAL(m_hdsaFormatEtc))
    {
        DWORD dwIndex;

        for (dwIndex = 0; dwIndex < dwSize; dwIndex++)
        {
#ifdef    DEBUG
            char szNameDebug[MAX_PATH];
            GetCfBufA(rgfe[dwIndex].cfFormat, szNameDebug, ARRAYSIZE(szNameDebug));
#endif // DEBUG
    
            if (rgfe[dwIndex].tymed == TYMED_ISTREAM ||
                (rgstg && rgfe[dwIndex].tymed == rgstg[dwIndex].tymed))
            {
#ifdef DEBUG
                //TraceMsg(TF_XBOX_IDENUM, "CXboxEfe() Keeping %hs", szNameDebug);
#endif // DEBUG
                DSA_SetItem(m_hdsaFormatEtc, dwIndex, &rgfe[dwIndex]);
            }
            else
            {
#ifdef DEBUG
                //TraceMsg(TF_XBOX_IDENUM, "CXboxEfe() Ignoring %hs", szNameDebug);
#endif // DEBUG
            }
        }
    }

    if (pfo)
    {
        m_pfo = pfo;
        m_pfo->AddRef();
    }

    LEAK_ADDREF(LEAK_CXboxEfe);
}


/****************************************************\
    Constructor
\****************************************************/
CXboxEfe::CXboxEfe(DWORD dwSize, HDSA hdsaFormatEtc, CXboxObj * pfo, DWORD dwIndex) : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_dwIndex);
    ASSERT(!m_hdsaFormatEtc);
    ASSERT(!m_pfo);

    ASSERT(hdsaFormatEtc);
    m_hdsaFormatEtc = DSA_Create(sizeof(FORMATETC), 10);
    if (EVAL(m_hdsaFormatEtc))
    {
        // BUGBUG: What do we do with dwIndex param?
        for (dwIndex = 0; dwIndex < (DWORD) DSA_GetItemCount(hdsaFormatEtc); dwIndex++)
        {
            DSA_SetItem(m_hdsaFormatEtc, dwIndex, DSA_GetItemPtr(hdsaFormatEtc, dwIndex));
        }
    }

    if (pfo)
    {
        m_pfo = pfo;
        m_pfo->AddRef();
    }


    LEAK_ADDREF(LEAK_CXboxEfe);
}


/****************************************************\
    Destructor
\****************************************************/
CXboxEfe::~CXboxEfe()
{
    DSA_Destroy(m_hdsaFormatEtc);

    if (m_pfo)
        m_pfo->Release();

    DllRelease();
    LEAK_DELREF(LEAK_CXboxEfe);
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CXboxEfe::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CXboxEfe::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CXboxEfe::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IEnumFORMATETC))
    {
        *ppvObj = SAFECAST(this, IEnumFORMATETC*);
    }
    else
    {
        TraceMsg(TF_XBOXQI, "CXboxEfe::QueryInterface() failed.");
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxdlg.cpp ===
/*****************************************************************************\
     xboxdlg.cpp - Confirm Dialog box stuff
\*****************************************************************************/

#include "priv.h"
#include "xboxdhlp.h"

/*****************************************************************************\
      PFDI
  
      The fields in the fdi are as follows:
  
      pfdd -> dialog descriptor
      pszLocal -> ASCIIZ: Name of local file being replaced.
      pwfdRemote -> Description of remote file.
      cobj = number of objects affected
  
      The dialog template should have the following controls:
  
      IDC_REPLACE_YES        - The "Yes" button
      IDC_REPLACE_YESTOALL    - The "Yes to all" button
      IDC_REPLACE_NO        - The "No" button
      IDC_REPLACE_CANCEL    - The "Cancel" button
  
      Of these buttons, IDC_REPLACE_YES and IDC_REPLACE_NO are mandatory.
      If the "Yes to all" and "Cancel" buttons are available, the caller
      should set the fCanMulti flag in the fdd, in which case the extra
      buttons will be removed if cobj = 1.
  
      IDC_FILENAME        - A string with a '%hs' replacement field.
  
      The '%hs' will be replaced by the name passed in the pwfdRemote.
  
      IDC_REPLACE_OLDFILE    - A string which will be rewritten
      IDC_REPLACE_OLDICON    - An icon placeholder
  
      The string will be replaced by a description taken from pwfdRemote.
      The icon will be an icon for the file.
  
      IDC_REPLACE_NEWFILE    - A string which will be rewritten
      IDC_REPLACE_NEWICON    - An icon placeholder
  
      The string will be replaced by a description taken from pszLocal.
      The icon will be an icon for the file.
\*****************************************************************************/

class CXboxConfirmDialog
{
public:
    CXboxConfirmDialog(CXboxFolder * pff);
    ~CXboxConfirmDialog();

    InitDialog();
    UINT Display(HWND hwnd, LPCVOID pvLocal, LPCWIRESTR pwLocalWirePath, LPCWSTR pwzLocalDisplayPath, UINT fdiiLocal,
                LPCVOID pvRemote, LPCWIRESTR pwRemoteWirePath, LPCWSTR pwzRemoteDisplayPath, UINT fdiiRemote, int cobj, BOOL fAllowCancel, DWORD dwItem);
    static INT_PTR CALLBACK _XboxConfirmDialogProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam);
    static BOOL _OnCommand(HWND hdlg, WPARAM wParam, LPARAM lParam);

private:
    LPCVOID             m_pvLocal;      // The local file in question
    UINT                m_fdiiLocal;
    LPCVOID             m_pvRemote;     // The remote file in question
    UINT                m_fdiiRemote;
    int                 m_cobj;         // Number of objects affected
    BOOL                m_fAllowCancel : 1;
    CXboxFolder *        m_pff;
    DWORD               m_dwItem;
    LPWIRESTR           m_pwLocalWirePath;
    LPWSTR              m_pwzLocalDisplayPath;
    LPWIRESTR           m_pwRemoteWirePath;
    LPWSTR              m_pwzRemoteDisplayPath;

    BOOL _OnInitDialog(HWND hDlg);
};


CXboxConfirmDialog::CXboxConfirmDialog(CXboxFolder * pff)
{
    m_pff = pff;
    m_pwLocalWirePath = NULL;
    m_pwzLocalDisplayPath = NULL;
    m_pwRemoteWirePath = NULL;
    m_pwzRemoteDisplayPath = NULL;
}


CXboxConfirmDialog::~CXboxConfirmDialog()
{
    Str_SetPtrA(&m_pwLocalWirePath, NULL);
    Str_SetPtrW(&m_pwzLocalDisplayPath, NULL);
    Str_SetPtrA(&m_pwRemoteWirePath, NULL);
    Str_SetPtrW(&m_pwzRemoteDisplayPath, NULL);
}


/*****************************************************************************\
    _XboxDlg_OnInitDialog
\*****************************************************************************/
BOOL CXboxConfirmDialog::_OnInitDialog(HWND hDlg)
{
    CXboxDialogTemplate xboxDialogTemplate;
    if (m_fdiiLocal == FDII_WFDA)
        EVAL(SUCCEEDED(xboxDialogTemplate.InitDialogWithFindData(hDlg, IDC_ITEM, m_pff, (const XBOX_FIND_DATA *) m_pvLocal, m_pwLocalWirePath, m_pwzLocalDisplayPath)));
    else
        EVAL(SUCCEEDED(xboxDialogTemplate.InitDialog(hDlg, FALSE, IDC_ITEM , m_pff, (CXboxPidlList *) m_pvLocal)));

    if (m_fdiiLocal == FDII_WFDA)
        EVAL(SUCCEEDED(xboxDialogTemplate.InitDialogWithFindData(hDlg, IDC_ITEM2, m_pff, (const XBOX_FIND_DATA *) m_pvRemote, m_pwRemoteWirePath, m_pwzRemoteDisplayPath)));
    else
        EVAL(SUCCEEDED(xboxDialogTemplate.InitDialog(hDlg, FALSE, IDC_ITEM2 , m_pff, (CXboxPidlList *) m_pvRemote)));

    return 1;
}

/*****************************************************************************\
    _XboxDlg_OnCommand
\*****************************************************************************/
BOOL CXboxConfirmDialog::_OnCommand(HWND hdlg, WPARAM wParam, LPARAM lParam)
{
    UINT idc = GET_WM_COMMAND_ID(wParam, lParam);

    switch (idc)
    {
    case IDC_REPLACE_YES:
    case IDC_REPLACE_YESTOALL:
        EndDialog(hdlg, idc);
        return 1;

    case IDC_REPLACE_NOTOALL:
        EndDialog(hdlg, IDC_REPLACE_NOTOALL);
        return 1;

    case IDC_REPLACE_CANCEL:
        EndDialog(hdlg, IDC_REPLACE_CANCEL);
        return 1;

        //    _UNOBVIOUS_:  Shift+No means "No to all", just like the shell.
    case IDC_REPLACE_NO:
        EndDialog(hdlg, GetKeyState(VK_SHIFT) < 0 ? IDC_REPLACE_NOTOALL : IDC_REPLACE_NO);
        return 1;
    }
    return 0;                // Not handled
}


/*****************************************************************************\
    _XboxDlg_DlgProc
\*****************************************************************************/
INT_PTR CXboxConfirmDialog::_XboxConfirmDialogProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    switch (wm)
    {
    case WM_INITDIALOG:
        return ((CXboxConfirmDialog *)lParam)->_OnInitDialog(hdlg);

    case WM_COMMAND:
        return CXboxConfirmDialog::_OnCommand(hdlg, wParam, lParam);
    }

    return 0;
}


UINT CXboxConfirmDialog::Display(HWND hwnd, LPCVOID pvLocal, LPCWIRESTR pwLocalWirePath, LPCWSTR pwzLocalDisplayPath, UINT fdiiLocal,
                LPCVOID pvRemote, LPCWIRESTR pwRemoteWirePath, LPCWSTR pwzRemoteDisplayPath, UINT fdiiRemote, int cobj, BOOL fAllowCancel, DWORD dwItem)
{
    m_pvLocal = pvLocal;
    m_fdiiLocal = fdiiLocal;
    m_pvRemote = pvRemote;
    m_fdiiRemote = fdiiRemote;
    m_cobj = cobj;
    m_fAllowCancel = fAllowCancel;
    m_dwItem = dwItem;

    Str_SetPtrA(&m_pwLocalWirePath, pwLocalWirePath);
    Str_SetPtrW(&m_pwzLocalDisplayPath, pwzLocalDisplayPath);
    Str_SetPtrA(&m_pwRemoteWirePath, pwRemoteWirePath);
    Str_SetPtrW(&m_pwzRemoteDisplayPath, pwzRemoteDisplayPath);

    return (UINT) DialogBoxParam(g_hinst, MAKEINTRESOURCE(dwItem), hwnd, CXboxConfirmDialog::_XboxConfirmDialogProc, (LPARAM)this);
}




/*****************************************************************************\
     XboxDlg_ConfirmReplace
\*****************************************************************************/
UINT XboxConfirmReplaceDialog(HWND hwnd, LPXBOX_FIND_DATA pwfdLocal, LPWIN32_FIND_DATA pwfdRemote,
                           int cobj, CXboxFolder * pff)
{
    CXboxConfirmDialog confirmDialog(pff);
    BOOL fAllowCancel = ((cobj > 1) ? 1 : 0);
    WCHAR wzLocalDisplayPath[MAX_PATH];
    WIRECHAR wRemoteWirePath[MAX_PATH];
    CWireEncoding * pWireEncoding = pff->GetCWireEncoding();

    EVAL(SUCCEEDED(pWireEncoding->WireBytesToUnicode(NULL, pwfdLocal->cFileName, (pff->IsUTF8Supported() ? WIREENC_USE_UTF8 : WIREENC_NONE), wzLocalDisplayPath, ARRAYSIZE(wzLocalDisplayPath))));
    EVAL(SUCCEEDED(pWireEncoding->UnicodeToWireBytes(NULL, pwfdRemote->cFileName, (pff->IsUTF8Supported() ? WIREENC_USE_UTF8 : WIREENC_NONE), wRemoteWirePath, ARRAYSIZE(wRemoteWirePath))));

    return confirmDialog.Display(hwnd, (LPCVOID) pwfdLocal, pwfdLocal->cFileName, wzLocalDisplayPath, FDII_WFDA,
            pwfdRemote, wRemoteWirePath, pwfdRemote->cFileName, FDII_WFDA, cobj, fAllowCancel, IDD_REPLACE);
}


/*****************************************************************************\
     XboxDlg_ConfirmReplace
\*****************************************************************************/
UINT XboxConfirmReplaceDialog(HWND hwnd, LPWIN32_FIND_DATA pwfdLocal, LPXBOX_FIND_DATA pwfdRemote,
                           int cobj, CXboxFolder * pff)
{
    CXboxConfirmDialog confirmDialog(pff);
    BOOL fAllowCancel = ((cobj > 1) ? 1 : 0);
    WIRECHAR wzLocalWirePath[MAX_PATH];
    WCHAR wRemoteDisplayPath[MAX_PATH];
    CWireEncoding * pWireEncoding = pff->GetCWireEncoding();

    EVAL(SUCCEEDED(pWireEncoding->UnicodeToWireBytes(NULL, pwfdLocal->cFileName, (pff->IsUTF8Supported() ? WIREENC_USE_UTF8 : WIREENC_NONE), wzLocalWirePath, ARRAYSIZE(wzLocalWirePath))));
    EVAL(SUCCEEDED(pWireEncoding->WireBytesToUnicode(NULL, pwfdRemote->cFileName, (pff->IsUTF8Supported() ? WIREENC_USE_UTF8 : WIREENC_NONE), wRemoteDisplayPath, ARRAYSIZE(wRemoteDisplayPath))));

    return confirmDialog.Display(hwnd, (LPCVOID) pwfdLocal, wzLocalWirePath, pwfdLocal->cFileName, FDII_WFDA,
            pwfdRemote, pwfdRemote->cFileName, wRemoteDisplayPath, FDII_WFDA, cobj, fAllowCancel, IDD_REPLACE);
}


/*****************************************************************************\
      XboxDlg_ConfirmDelete
\*****************************************************************************/
UINT XboxConfirmDeleteDialog(HWND hwnd, CXboxPidlList * pflHfpl, CXboxFolder * pff)
{
    CXboxConfirmDialog confirmDialog(pff);
    UINT id;

    if (pflHfpl->GetCount() > 1)
        id = IDD_DELETEMULTI;
    else
    {
        if (XboxPidl_IsDirectory(pflHfpl->GetPidl(0), TRUE))
            id = IDD_DELETEFOLDER;
        else
            id = IDD_DELETEFILE;
    }

    return confirmDialog.Display(hwnd, (LPCVOID) pflHfpl, NULL, NULL, FDII_HFPL, 0, 0, NULL, NULL, NULL, FALSE, id);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxdrop.cpp ===
/*****************************************************************************\
    FILE: xboxdrop.cpp - IDropTarget interface

    Remarks:

    Note that you cannot create a shortcut on an XBOX site.  Although
    there's nothing technically preventing it, it's not done because
    the shortcut won't be of much use on an XBOX site.  (It points to
    your local machine, which doesn't help much for people not on the
    same network!)

    If you really want to put a shortcut file on an XBOX site, create
    it on the desktop, then drag the shortcut onto the XBOX site.

    The default verb for XBOX sites is always "Copy".  This is true
    even if an intra-site drag-drop is being done.

    DESCRIPTION:
        DefView will cache the IDropTarget pointer (CXboxDrop) for a shell extension.
    When it calls CXboxDrop::Drop(), the work needs to be done on a background
    thread in order to not block the UI thread.  The problem is that if the user
    does another drag to the same Xbox Window, CXboxDrop::Drop() will be called again.
    For this reasons, CXboxDrop::Drop() cannot have any state after it returns.
    In order to accomplish this with the asynch background thread, we have
    CXboxDrop::Drop() call CDropOperation_Create(), and then CDropOperation->DoOperation().
    And then it will orphan (call Release()) the CDropOperation.  The CDropOperation
    will then destroy itself when the copy is finishes.  This enables subsequent calls
    to CXboxDrop::Drop() to spawn separate CDropOperation objects so each can maintain
    the state for that specifc operation and CXboxDrop remains stateless.
\*****************************************************************************/

#include "priv.h"
#include "xboxdrop.h"
#include "xboxurl.h"
#include "statusbr.h"
#include "newmenu.h"

class CDropOperation;
HRESULT CDropOperation_Create(CXboxFolder * pff, HWND hwnd, LPCTSTR pszzFSSource, LPCTSTR pszzXboxDest, CDropOperation ** ppfdt, DROPEFFECT de, OPS ops, int cobj);
HRESULT ConfirmCopy(LPCWSTR pszLocal, LPCWSTR pszXboxName, OPS * pOps, HWND hwnd, CXboxFolder * pff, CXboxDir * pfd, DROPEFFECT * pde, int nObjs, BOOL * pfFireChangeNotify);


// Declared because of recusion
HRESULT XboxCopyDirectory(HINTERNET hint, HINTPROCINFO * phpi, LPCOPYONEHDROPINFO pcohi);
HRESULT XboxCopyFile(HINTERNET hint, HINTPROCINFO * phpi, LPCOPYONEHDROPINFO pcohi);


HRESULT UpdateCopyFileName(LPCOPYONEHDROPINFO pcohi)
{
    HRESULT hr = S_OK;
    static WCHAR wzCopyTemplate[MAX_PATH] = L"";
    WCHAR wzLine1[MAX_PATH];

    if (!wzCopyTemplate[0])
        LoadStringW(HINST_THISDLL, IDS_COPYING, wzCopyTemplate, ARRAYSIZE(wzCopyTemplate));

    wnsprintfW(wzLine1, ARRAYSIZE(wzLine1), wzCopyTemplate, pcohi->pszXboxDest);

    EVAL(SUCCEEDED(pcohi->progInfo.ppd->SetLine(1, wzLine1, FALSE, NULL)));

    return hr;
}


HRESULT UpdateSrcDestDirs(LPCOPYONEHDROPINFO pcohi)
{
    HRESULT hr = S_OK;
    WCHAR wzFrom[MAX_PATH];
    WCHAR wzStatusStr[MAX_PATH];

    StrCpyN(wzFrom, pcohi->pszFSSource, ARRAYSIZE(wzFrom));
    PathRemoveFileSpecW(wzFrom);

    if (EVAL(SUCCEEDED(hr = CreateFromToStr(wzStatusStr, ARRAYSIZE(wzStatusStr), wzFrom, pcohi->pszDir))))
        EVAL(SUCCEEDED(hr = pcohi->progInfo.ppd->SetLine(2, wzStatusStr, FALSE, NULL)));    // Line one is the file being copied.

    return hr;
}


HRESULT DeleteOneFileCB(HINTERNET hint, HINTPROCINFO * phpi, LPVOID pv, BOOL * pfReleaseHint)
{
    LPCOPYONEHDROPINFO pcohi = (LPCOPYONEHDROPINFO) pv;
    WIRECHAR wXboxPath[MAX_PATH];

    phpi->pfd->GetXboxSite()->GetCWireEncoding()->UnicodeToWireBytes(pcohi->pmlc, pcohi->pszXboxDest, (phpi->pfd->IsUTF8Supported() ? WIREENC_USE_UTF8 : WIREENC_NONE), wXboxPath, ARRAYSIZE(wXboxPath));
    return XboxDeleteFileWrap(hint, TRUE, wXboxPath);
}


HRESULT UpdateProgressDialogStr(LPCOPYONEHDROPINFO pcohi)
{
    EVAL(SUCCEEDED(UpdateCopyFileName(pcohi)));
    EVAL(SUCCEEDED(UpdateSrcDestDirs(pcohi)));
    return S_OK;
}


/*****************************************************************************\
    CopyFileSysItem

    This function may cause recursion.
\*****************************************************************************/
HRESULT CopyFileSysItem(HINTERNET hint, HINTPROCINFO * phpi, LPCOPYONEHDROPINFO pcohi)
{
    HRESULT hr = S_OK;

    // Check if the user canceled.
    if (pcohi->progInfo.ppd)
    {
        if (pcohi->progInfo.ppd->HasUserCancelled())
            return HRESULT_FROM_WIN32(ERROR_CANCELLED);

        if (pcohi->dwOperation != COHDI_FILESIZE_COUNT)
            UpdateProgressDialogStr(pcohi);
    }

    if (PathIsDirectory(pcohi->pszFSSource))
    {
        hr = XboxCopyDirectory(hint, phpi, pcohi);

        if (SUCCEEDED(hr) && (pcohi->dwOperation != COHDI_FILESIZE_COUNT))
        {
            /*
            WIN32_FIND_DATA wfd;
            HANDLE handle = FindFirstFile(pcohi->pszFSSource, &wfd);

            // BUGBUG: The date is wrong doing it this way, but it's faster.  We should
            //         find out if XboxCreateDirectory always stamps the directory with
            //         the current date, and then update wfd with the current time/date.
            //         This will simulate the server entry w/o the perf hit.
            if (handle != INVALID_HANDLE_VALUE)
            {
                // If we are the root, then we need to notify the shell that
                // a folder was created so the view needs to be updated.
                // We fire the XboxChangeNotify() call for SHCNE_MKDIR in XboxCreateDirectoryWithCN().
                // XboxChangeNotify(SHCNE_MKDIR) is fired in XboxCreateDirectoryWithCN
                FindClose(handle);
            }
            */
        }
    }
    else
        hr = XboxCopyFile(hint, phpi, pcohi);

    return hr;
}


HRESULT XboxCopyItem(HINTERNET hint, HINTPROCINFO * phpi, LPCOPYONEHDROPINFO pcohi, LPWIN32_FIND_DATA pwfd, LPCWIRESTR pwCurrentDir)
{
    HRESULT hr = S_OK;
    TCHAR szFrom[MAX_PATH];
    WCHAR wzDestDir[MAX_PATH];
    TCHAR szServer[INTERNET_MAX_HOST_NAME_LENGTH];
    COPYONEHDROPINFO cohi = {pcohi->pff, szFrom, pwfd->cFileName, wzDestDir, pcohi->dwOperation, pcohi->ops, FALSE, pcohi->pmlc, pcohi->pidlServer, pcohi->fFireChangeNotify, NULL};
    CXboxDir * pfd = phpi->pfd;
    BOOL fSkipCurrentFile = FALSE;
    CWireEncoding * pwe = phpi->pfd->GetXboxSite()->GetCWireEncoding();

    cohi.progInfo.ppd = pcohi->progInfo.ppd;
    cohi.progInfo.hint = pcohi->progInfo.hint;
    cohi.progInfo.uliBytesCompleted.QuadPart = pcohi->progInfo.uliBytesCompleted.QuadPart;
    cohi.progInfo.uliBytesTotal.QuadPart = pcohi->progInfo.uliBytesTotal.QuadPart;

    EVAL(SUCCEEDED(pwe->WireBytesToUnicode(pcohi->pmlc, pwCurrentDir, (pfd->IsUTF8Supported() ? WIREENC_USE_UTF8 : WIREENC_NONE), wzDestDir, ARRAYSIZE(wzDestDir))));
    DisplayPathAppend(wzDestDir, ARRAYSIZE(wzDestDir), pcohi->pszXboxDest);

    if (EVAL(SUCCEEDED(pfd->GetXboxSite()->GetServer(szServer, ARRAYSIZE(szServer)))) &&
        SUCCEEDED(pfd->GetXboxSite()->GetXboxDir(szServer, wzDestDir, &(phpi->pfd))))
    {
        ASSERT(phpi->hwnd);
        // Make sure the user thinks it's ok to replace.  We don't care about replacing directories
        if ((pcohi->dwOperation != COHDI_FILESIZE_COUNT) &&
            !(FILE_ATTRIBUTE_DIRECTORY & pwfd->dwFileAttributes))
        {
            TCHAR szSourceFile[MAX_PATH];

            StrCpyN(szSourceFile, pcohi->pszFSSource, ARRAYSIZE(szSourceFile));
            if (PathAppend(szSourceFile, pwfd->cFileName))
            {
                // PERF: We should do the Confirm copy only if the upload fails because it's
                //       so costly.
                hr = ConfirmCopy(szSourceFile, pwfd->cFileName, &(cohi.ops), phpi->hwnd, pcohi->pff, phpi->pfd, NULL, 1, &cohi.fFireChangeNotify);
                if (S_FALSE == hr)
                {
                    // S_FALSE from ConfirmCopy() means doen't replace this specific file, but continue
                    // copying.  We need to return S_OK or we will cancel copying all the files.
                    fSkipCurrentFile = TRUE;
                    hr = S_OK;
                }
            }
            else
                hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);    // Path too long, probably.
        }

        if (!fSkipCurrentFile && (S_OK == hr) && IS_VALID_FILE(pwfd->cFileName))
        {
            StrCpyN(szFrom, pcohi->pszFSSource, ARRAYSIZE(szFrom));     // Set the source directory.
            // Specify the file/dir in that directory to copy.
            if (PathAppend(szFrom, pwfd->cFileName))
            {
                // 5. Call CopyFileSysItem() to get it copied (maybe recursively)
                //TraceMsg(TF_XBOXOPERATION, "XboxCopyDirectory() calling CopyFileSysItem(From=%s. To=%s)", szFrom, pwfd->cFileName);
                hr = CopyFileSysItem(hint, phpi, &cohi);
                if (FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr) &&
                    (pcohi->dwOperation != COHDI_FILESIZE_COUNT))
                {
                    int nResult = DisplayWininetError(phpi->hwnd, TRUE, HRESULT_CODE(hr), IDS_XBOXERR_TITLE_ERROR, IDS_XBOXERR_FILECOPY, IDS_XBOXERR_WININET, MB_OK, pcohi->progInfo.ppd);
                    hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                }
            }
            else
                hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);    // Path too long, probably.
        }


        pcohi->progInfo.hint = cohi.progInfo.hint;    // Maybe the user cancelled.
        pcohi->progInfo.uliBytesCompleted.QuadPart = cohi.progInfo.uliBytesCompleted.QuadPart;
        pcohi->progInfo.uliBytesTotal.QuadPart = cohi.progInfo.uliBytesTotal.QuadPart;
        pcohi->ops = cohi.ops;
        phpi->pfd->Release();
    }

    phpi->pfd = pfd;
    return hr;
}

HRESULT _XboxSetCurrentDirectory(HINTERNET hint, HINTPROCINFO * phpi, LPCWSTR pwzXboxPath)
{
    HRESULT hr;
    WIRECHAR wXboxPath[MAX_PATH];
    CWireEncoding * pwe = phpi->pfd->GetXboxSite()->GetCWireEncoding();

    hr = pwe->UnicodeToWireBytes(NULL, pwzXboxPath, (phpi->pfd->IsUTF8Supported() ? WIREENC_USE_UTF8 : WIREENC_NONE), wXboxPath, ARRAYSIZE(wXboxPath));
    if (SUCCEEDED(hr))
        hr = XboxSetCurrentDirectoryWrap(hint, TRUE, wXboxPath);

    return hr;
}

/*****************************************************************************\
     XboxCopyDirectory
 
    DESCRIPTION:
        This function will need to copy all the items in the directory to the
    XBOX server if the item is a folder, it will need to recurse.

    Recursion algorithm:
    // 1. Create Directory
    // 2. Get Current Directory (To save for later).
    // 3. Change Directory Into new Directory.
    // 4. Find Next item (file/dir) in file system
    // 5. Call CopyFileSysItem() to get it copied (maybe recursively)
    // 6. Go to Step 4 if there are any left.
    // 7. Go back to original directory (Step 2)
\*****************************************************************************/
HRESULT XboxCopyDirectory(HINTERNET hint, HINTPROCINFO * phpi, LPCOPYONEHDROPINFO pcohi)
{
    HRESULT hr = S_OK;

    if (phpi->psb && (pcohi->dwOperation != COHDI_FILESIZE_COUNT))
        phpi->psb->SetStatusMessage(IDS_COPYING, pcohi->pszFSSource);

    //TraceMsg(TF_XBOXOPERATION, "XboxCopyDirectory() calling XboxCreateDirectoryA(%s)", pcohi->pszFSSource);

    // Create the directories on the first pass when we calculate file sizes.
    // We then skip creating them on the copy pass.
    if (pcohi->dwOperation == COHDI_FILESIZE_COUNT)
    {
        hr = XboxSafeCreateDirectory(phpi->hwnd, hint, pcohi->pmlc, pcohi->pff, phpi->pfd, pcohi->progInfo.ppd, pcohi->pszXboxDest, pcohi->fIsRoot);
    }

    // 1. Create Directory
    if (SUCCEEDED(hr))
    {
        WIRECHAR wCurrentDir[MAX_PATH];

        hr = XboxGetCurrentDirectoryWrap(hint, TRUE, wCurrentDir, ARRAYSIZE(wCurrentDir));
        if (EVAL(SUCCEEDED(hr)))
        {
            // NOTE: At this point, pcohi->pszFSSource is the DIRECTORY on the local
            //       file system that is being copied.
            hr = _XboxSetCurrentDirectory(hint, phpi, pcohi->pszXboxDest);
            if (SUCCEEDED(hr))
            {
                WCHAR szSearchStr[MAX_PATH*2];
                WIN32_FIND_DATA wfd;
                HANDLE handle = NULL;

                StrCpyN(szSearchStr, pcohi->pszFSSource, ARRAYSIZE(szSearchStr));
                // We need to copy the entire directory.
                if (PathAppend(szSearchStr, SZ_ALL_FILES))
                {
                    // 4. Find Next item (file/dir) in file system
                    handle = FindFirstFile(szSearchStr, &wfd);
                    if (handle != INVALID_HANDLE_VALUE)
                    {
                        do
                        {
                            //TraceMsg(TF_WININET_DEBUG, "FindFirstFileNext() returned %s", wfd.cFileName);
                            hr = XboxCopyItem(hint, phpi, pcohi, &wfd, wCurrentDir);

                            // 6. Check if the user canceled.
                            if ((pcohi->progInfo.ppd) && (pcohi->progInfo.ppd->HasUserCancelled()))
                            {
                                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                                break;
                            }

                            // 7. Repeat if there are any left and it wasn't cancelled (S_FALSE)
                        }
                        while ((S_OK == hr) && FindNextFile(handle, &wfd));

                        FindClose(handle);
                    }
                }
                else
                    hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);    // Path too long, probably.
            }

            // 7. Go back to original directory (from Step 2)
            // The only time we don't want to return to the original directory is if
            // the hinst was freed in an wininet callback function.  We may cache the hinst
            // so we need the directory to be valid later.
            if (pcohi->progInfo.hint)
            {
                EVAL(SUCCEEDED(XboxSetCurrentDirectoryWrap(hint, TRUE, wCurrentDir)));
            }
        }
    }
    else
    {
        if (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr)
        {
            DisplayWininetError(phpi->hwnd, TRUE, HRESULT_CODE(hr), IDS_XBOXERR_TITLE_ERROR, IDS_XBOXERR_DIRCOPY, IDS_XBOXERR_WININET, MB_OK, pcohi->progInfo.ppd);
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
        }
    }

    return hr;
}


HRESULT UpdateCopyProgressInfo(IProgressDialog * ppd, LPCTSTR pszFileName)
{
    HRESULT hr = E_FAIL;
    TCHAR szTemplate[MAX_PATH];

    if (EVAL(LoadString(HINST_THISDLL, IDS_COPYING, szTemplate, ARRAYSIZE(szTemplate))))
    {
        TCHAR szStatusStr[MAX_PATH];
        WCHAR wzStatusStr[MAX_PATH];

        wnsprintf(szStatusStr, ARRAYSIZE(szStatusStr), szTemplate, pszFileName);
        SHTCharToUnicode(szStatusStr, wzStatusStr, ARRAYSIZE(wzStatusStr));
        EVAL(SUCCEEDED(hr = ppd->SetLine(1, wzStatusStr, FALSE, NULL)));
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: _FireChangeNotify

    DESCRIPTION:
        asd
\*****************************************************************************/
HRESULT _FireChangeNotify(HINTPROCINFO * phpi, LPCOPYONEHDROPINFO pcohi)
{
    HRESULT hr = S_OK;
    WIN32_FIND_DATA wfd;
    HANDLE handle = FindFirstFile(pcohi->pszFSSource, &wfd);

    TraceMsg(TF_WININET_DEBUG, "_FireChangeNotify() XboxPutFileEx(%s -> %s) succeeded", pcohi->pszFSSource, pcohi->pszXboxDest);
    if (handle != INVALID_HANDLE_VALUE)
    {
        ULARGE_INTEGER uliFileSize;
        XBOX_FIND_DATA ffd;
        CWireEncoding * pwe = pcohi->pff->GetCWireEncoding();

        uliFileSize.LowPart = wfd.nFileSizeLow;
        uliFileSize.HighPart = wfd.nFileSizeHigh;
        pcohi->progInfo.uliBytesCompleted.QuadPart += uliFileSize.QuadPart;

        hr = pwe->UnicodeToWireBytes(pcohi->pmlc, wfd.cFileName, (phpi->pfd->IsUTF8Supported() ? WIREENC_USE_UTF8 : WIREENC_NONE), ffd.cFileName, ARRAYSIZE(ffd.cFileName));
        if (EVAL(SUCCEEDED(hr)))
        {
            LPITEMIDLIST pidlXboxFile;
            SYSTEMTIME st;
            FILETIME ftUTC;

            ffd.dwFileAttributes = wfd.dwFileAttributes;
            ffd.dwReserved0 = wfd.dwReserved0;
            ffd.dwReserved1 = wfd.dwReserved1;
            ffd.nFileSizeHigh = wfd.nFileSizeHigh;
            ffd.nFileSizeLow = wfd.nFileSizeLow;

            // wfd.ft*Time is in UTF and XboxItemID_CreateReal wants
            // it in LocalTime, so we need to convert here.
            GetSystemTime(&st);
            SystemTimeToFileTime(&st, &ftUTC);
            FileTimeToLocalFileTime(&ftUTC, &ffd.ftLastWriteTime);   // UTC->LocalTime
            ffd.ftCreationTime = ffd.ftLastWriteTime;
            ffd.ftLastAccessTime = ffd.ftLastWriteTime;

            hr = XboxItemID_CreateReal(&ffd, pcohi->pszXboxDest, &pidlXboxFile);
            if (SUCCEEDED(hr))
            {
                // Note that we created the mapped name
                // PERF: Note that we give the time/date stamp to SHChangeNotify that comes from the source
                //       file, not from the XBOX server, so it may be inforrect.  However, it's perf prohibitive
                //       to do the right thing.
                XboxChangeNotify(phpi->hwnd, SHCNE_CREATE, pcohi->pff, phpi->pfd, pidlXboxFile, NULL, pcohi->fIsRoot);
                ILFree(pidlXboxFile);
            }
        }

        FindClose(handle);
    }

    return hr;
}


#define CCH_SIZE_ERROR_MESSAGE  6*1024

/*****************************************************************************\
    XboxCopyFile

    Callback procedure that copies a single hdrop / map.
    Should I try to make the name unique in case of collision?
    Naah, just prompt, but! no way to tell if destination is case-sensitive...
\*****************************************************************************/
HRESULT XboxCopyFile(HINTERNET hint, HINTPROCINFO * phpi, LPCOPYONEHDROPINFO pcohi)
{
    HRESULT hr = S_OK;

    if (pcohi->dwOperation != COHDI_FILESIZE_COUNT)
    {
        WIRECHAR wWireName[MAX_PATH];

        EVAL(SUCCEEDED(pcohi->pff->GetCWireEncoding()->UnicodeToWireBytes(pcohi->pmlc, pcohi->pszXboxDest, (pcohi->pff->IsUTF8Supported() ? WIREENC_USE_UTF8 : WIREENC_NONE), wWireName, ARRAYSIZE(wWireName))));

        if (phpi->psb)
            phpi->psb->SetStatusMessage(IDS_COPYING, pcohi->pszFSSource);

        if (pcohi->progInfo.ppd)
        {
            EVAL(SUCCEEDED(UpdateCopyProgressInfo(pcohi->progInfo.ppd, pcohi->pszXboxDest)));
            EVAL(SUCCEEDED(pcohi->progInfo.ppd->SetProgress64(pcohi->progInfo.uliBytesCompleted.QuadPart, pcohi->progInfo.uliBytesTotal.QuadPart)));
        }

        pcohi->progInfo.dwCompletedInCurFile = 0;
        pcohi->progInfo.dwLastDisplayed = 0;

        // BUGBUG: We need to pass the XBOX_TRANSFER_TYPE (_ASCII vs. _BINARY)
        hr = XboxPutFileExWrap(hint, TRUE, pcohi->pszFSSource, wWireName, FTP_TRANSFER_TYPE_UNKNOWN, (DWORD_PTR)&(pcohi->progInfo));
        if (SUCCEEDED(hr))
        {
            // We don't fire change notify on browser only if we
            // are replacing a file because ChangeNotify really
            // just hacks ListView and doen't know how to handle
            // duplicates (file replace).
            if (pcohi->fFireChangeNotify)
                hr = _FireChangeNotify(phpi, pcohi);
        }
        else
        {
            if (HRESULT_FROM_WIN32(ERROR_INTERNET_OPERATION_CANCELLED) == hr)
            {
                // Clean up the file.
                EVAL(SUCCEEDED(phpi->pfd->WithHint(NULL, phpi->hwnd, DeleteOneFileCB, pcohi, NULL, pcohi->pff)));
                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
            }
            else
            {
                // We still want to delete the file, but we need to save the error message
                // so the dialog is correct.
                CHAR szErrorMsg[CCH_SIZE_ERROR_MESSAGE];
                WCHAR wzErrorMsg[CCH_SIZE_ERROR_MESSAGE];
                DWORD cchSize = ARRAYSIZE(szErrorMsg);
                InternetGetLastResponseInfoWrap(TRUE, NULL, szErrorMsg, &cchSize);
                HRESULT hrOrig = hr;
                CWireEncoding * pwe = phpi->pfd->GetXboxSite()->GetCWireEncoding();

                pwe->WireBytesToUnicode(NULL, szErrorMsg, WIREENC_NONE, wzErrorMsg, ARRAYSIZE(wzErrorMsg));
                // Does it already exist?  This may fail.
                SUCCEEDED(phpi->pfd->WithHint(NULL, phpi->hwnd, DeleteOneFileCB, pcohi, NULL, pcohi->pff));

                // No, so it was a real error, now display the error message with the original
                // server response.
                DisplayWininetErrorEx(phpi->hwnd, TRUE, HRESULT_CODE(hrOrig), IDS_XBOXERR_TITLE_ERROR, IDS_XBOXERR_FILECOPY, IDS_XBOXERR_WININET, MB_OK, pcohi->progInfo.ppd, wzErrorMsg);
                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
            }
        }
    }
    else
    {
        // Just get the file size.   
        WIN32_FIND_DATA wfd;
        HANDLE handle = FindFirstFile(pcohi->pszFSSource, &wfd);

        if (handle && (handle != INVALID_HANDLE_VALUE))
        {
            ULARGE_INTEGER uliFileSize;
            uliFileSize.LowPart = wfd.nFileSizeLow;
            uliFileSize.HighPart = wfd.nFileSizeHigh;
            pcohi->progInfo.uliBytesTotal.QuadPart += uliFileSize.QuadPart;
            FindClose(handle);
        }
    }

    //TraceMsg(TF_XBOXOPERATION, "XboxPutFileA(From=%ls, To=%s) hr=%#08lX", pcohi->pszFSSource, pcohi->pszXboxDest, hr);
    return hr;
}


/*****************************************************************************\
    _EnumOneHdropW

    Handle one hdrop and corresponding filemap.

    This is annoying because we need to convert from UNICODE to ANSI.
\*****************************************************************************/
#define OleStrToStrA(a, b) OleStrToStrN(a, ARRAYSIZE(a), b, -1)

HRESULT _EnumOneHdropW(LPCWSTR * ppwzzFSSources, LPCWSTR * ppwzzXboxDest, LPTSTR pszFSSourceOut, DWORD cchFSSourceOut, LPTSTR pszXboxDestOut, DWORD cchXboxDestOut)
{
    HRESULT hres;
    int cwch;

    if (*ppwzzFSSources && (*ppwzzFSSources)[0])
    {
        cwch = SHUnicodeToTChar(*ppwzzFSSources, pszFSSourceOut, cchFSSourceOut);
        if (EVAL(cwch))
        {
            *ppwzzFSSources += cwch;
            if (EVAL((*ppwzzXboxDest)[0]))
            {
                cwch = SHUnicodeToTChar(*ppwzzXboxDest, pszXboxDestOut, cchXboxDestOut);
                if (EVAL(cwch))
                {
                    *ppwzzXboxDest += cwch;
                    hres = S_OK;    // Both strings converted okay
                }
                else
                    hres = E_UNEXPECTED; // File name too long
            }
            else
                hres = E_UNEXPECTED;    // Premature EOF in map
        }
        else
            hres = E_UNEXPECTED;    // File name too long
    }
    else
        hres = S_FALSE;            // End of buffer

    return hres;
}


/*****************************************************************************\
    _EnumOneHdropA

    Handle one hdrop and corresponding filemap.
\*****************************************************************************/
HRESULT _EnumOneHdropA(LPCSTR * ppszzFSSource, LPCSTR * ppszzXboxDest, LPTSTR pszFSSourceOut, DWORD cchFSSourceOut, LPTSTR pszXboxDestOut, DWORD cchXboxDestOut)
{
    HRESULT hres;

    if ((*ppszzFSSource)[0])
    {
        SHAnsiToTChar(*ppszzFSSource, pszFSSourceOut, cchFSSourceOut);
        *ppszzFSSource += lstrlenA(*ppszzFSSource) + 1;
        if (EVAL((*ppszzXboxDest)[0]))
        {
            SHAnsiToTChar(*ppszzXboxDest, pszXboxDestOut, cchXboxDestOut);
            *ppszzXboxDest += lstrlenA(*ppszzXboxDest) + 1;
            hres = S_OK;        // No problemo
        }
        else
            hres = E_UNEXPECTED;    // Premature EOF in map
    }
    else
        hres = S_FALSE;            // No more files

    return hres;
}


/*****************************************************************************\
    ConfirmCopy

    Callback procedure that checks if this file really ought to be
    copied.

    Returns S_OK if the file should be copied.
    Returns S_FALSE if the file should not be copied.

    - If the user cancelled, then say S_FALSE from now on.
    - If the user said Yes to All, then say S_OK.
    - If there is no conflict, then say S_OK.
    - If the user said No to All, then say S_FALSE.
    - Else, ask the user what to do.

    Note that the order of the tests above means that if you say
    "Yes to All", then we don't waste our time doing overwrite checks.

    _GROSS_:  NOTE! that we don't try to uniquify the name, because
    WinINet doesn't support the STOU (store unique) command, and
    there is no way to know what filenames are valid on the server.
\*****************************************************************************/
HRESULT ConfirmCopy(LPCWSTR pszLocal, LPCWSTR pszXboxName, OPS * pOps, HWND hwnd, CXboxFolder * pff, CXboxDir * pfd, DROPEFFECT * pde, int nObjs, BOOL * pfFireChangeNotify)
{
    HRESULT hr = S_OK;

    *pfFireChangeNotify = TRUE;
    if (*pOps == opsCancel)
        hr = S_FALSE;
    else 
    {
        HANDLE hfind;
        WIN32_FIND_DATA wfdSrc;
        hfind = FindFirstFile(pszLocal, &wfdSrc);
        if (hfind != INVALID_HANDLE_VALUE)
        {
            FindClose(hfind);

            // Is it a file?  We don't care about confirming the replacement
            // of directories.
            if (!(FILE_ATTRIBUTE_DIRECTORY & wfdSrc.dwFileAttributes))
            {
                XBOX_FIND_DATA wfd;
                hr = pfd->GetFindDataForDisplayPath(hwnd, pszXboxName, &wfd, pff);
                if (*pOps == opsYesToAll)
                {
                    // If the file exists (S_OK) and it's browser only, 
                    // then don't fire the change notify.
                    if ((S_OK == hr) && (SHELL_VERSION_NT5 != GetShellVersion()))
                        *pfFireChangeNotify = FALSE;

                    hr = S_OK;
                }
                else
                {
                    switch (hr)
                    {
                    case S_OK:            // File exists; worry
                        if (*pOps == opsNoToAll)
                            hr = S_FALSE;
                        else
                        {
                            FILETIME ftUTC = wfdSrc.ftLastWriteTime;
    
                            FileTimeToLocalFileTime(&ftUTC, &wfdSrc.ftLastWriteTime);   // UTC->LocalTime
                            // BUGBUG/TODO: Do we need to set modal?
                            switch (XboxConfirmReplaceDialog(hwnd, &wfdSrc, &wfd, nObjs, pff))
                            {
                            case IDC_REPLACE_YESTOALL:
                                *pOps = opsYesToAll;
                                // FALLTHROUGH

                            case IDC_REPLACE_YES:
                                // pre-NT5 doesn't work 
                                if (SHELL_VERSION_NT5 != GetShellVersion())
                                    *pfFireChangeNotify = FALSE;

                                hr = S_OK;
                                break;

                            case IDC_REPLACE_NOTOALL:
                                *pOps = opsNoToAll;
                                // FALLTHROUGH

                            case IDC_REPLACE_NO:
                                hr = S_FALSE;
                                break;

                            default:
                                ASSERT(0);        // Huh?
                                // FALLTHROUGH

                            case IDC_REPLACE_CANCEL:
                                if (pde)
                                    *pde = 0;

                                *pOps = opsCancel;
                                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                                break;
                            }
                        }
                        break;

                    case S_FALSE:
                    default:
                        // Assume the file doesn't exist; no problemo
                        hr = S_OK;
                        break;
                    }
                }
            }
        }
        else
        {                   // File doesn't exist
            hr = S_OK;    // The open will raise the error
        }

    }

    //TraceMsg(TF_XBOXDRAGDROP, "ConfirmCopy(%s) -> %08x", pszXboxName, hr);
    return hr;
}




/*****************************************************************************\
    CLASS: CDropOperation

    DESCRIPTION:
        DefView will cache the IDropTarget pointer (CXboxDrop) for a shell extension.
    When it calls CXboxDrop::Drop(), the work needs to be done on a background
    thread in order to not block the UI thread.  The problem is that if the user
    does another drag to the same Xbox Window, CXboxDrop::Drop() will be called again.
    For this reasons, CXboxDrop::Drop() cannot have any state after it returns.
    In order to accomplish this with the asynch background thread, we have
    CXboxDrop::Drop() call CDropOperation_Create(), and then CDropOperation->DoOperation().
    And then it will orphan (call Release()) the CDropOperation.  The CDropOperation
    will then destroy itself when the copy is finishes.  This enables subsequent calls
    to CXboxDrop::Drop() to spawn separate CDropOperation objects so each can maintain
    the state for that specifc operation and CXboxDrop remains stateless.
\*****************************************************************************/
class CDropOperation          : public IUnknown
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

public:
    CDropOperation();
    ~CDropOperation(void);

    // Public Member Functions
    HRESULT DoOperation(BOOL fAsync);

    static HRESULT CopyCB(HINTERNET hint, HINTPROCINFO * phpi, LPVOID pv, BOOL * pfReleaseHint);

    // Friend Functions
    friend HRESULT CDropOperation_Create(CXboxFolder * pff, HWND hwnd, LPCTSTR pszzFSSource, LPCTSTR pszzXboxDest, CDropOperation ** ppfdt, DROPEFFECT de, OPS ops, int cobj);

protected:
    // Protected Member Variables
    int                     m_cRef;

    CXboxFolder *            m_pff;          // The owner
    CXboxDir *               m_pfd;          // The XboxDir of the owner
    HWND                    m_hwnd;         // The window being drug over

    DROPEFFECT              m_de;           // Effect being performed
    OPS                     m_ops;          // Overwrite prompting state
    int                     m_cobj;         // Number of objects being dropped
    ULARGE_INTEGER          m_uliBytesCompleted;
    ULARGE_INTEGER          m_uliBytesTotal;


    // Private Member Functions
    HRESULT _ConfirmCopy(LPCWSTR pszLocal, LPCWSTR psz, BOOL * pfFireChangeNotify);
    HRESULT _CalcSizeOneHdrop(LPCWSTR pszFSSource, LPCWSTR pszXboxDest, IProgressDialog * ppd);
    HRESULT _ThreadProcCB(void);
    HRESULT _CopyOneHdrop(LPCWSTR pszFSSource, LPCWSTR pszXboxDest);

    HRESULT _StartBackgroundInteration(void);
    HRESULT _DoCopyIteration(void);
    HRESULT _CalcUploadProgress(void);

private:
    // Private Member Variables
    IProgressDialog *       m_ppd;
    LPCWSTR                 m_pszzFSSource;            // Paths
    LPCWSTR                 m_pszzXboxDest;              // Map
    CMultiLanguageCache     m_mlc;          // Cache for fast str thunking.

    static DWORD CALLBACK _ThreadProc(LPVOID pThis) {return ((CDropOperation *)pThis)->_ThreadProcCB();};
};


HRESULT CDropOperation_Create(CXboxFolder * pff, HWND hwnd, LPCTSTR pszzFSSource, LPCTSTR pszzXboxDest, CDropOperation ** ppfdt, 
                              DROPEFFECT de, OPS ops, int cobj)
{
    HRESULT hr = E_OUTOFMEMORY;
    CDropOperation * pfdt = new CDropOperation();
    *ppfdt = pfdt;

    if (pfdt)
    {
        pfdt->m_hwnd = hwnd;

        // Copy the CXboxFolder * value
        pfdt->m_pff = pff;
        if (pff)
            pff->AddRef();

        // Copy the CXboxDir * value
        ASSERT(!pfdt->m_pfd);
        pfdt->m_pfd = pff->GetXboxDir();
        ASSERT(pfdt->m_pfd);

        ASSERT(!pfdt->m_pszzFSSource);
        pfdt->m_pszzFSSource = pszzFSSource;

        ASSERT(!pfdt->m_pszzXboxDest);
        pfdt->m_pszzXboxDest = pszzXboxDest;

        pfdt->m_de = de;           // Effect being performed
        pfdt->m_ops = ops;          // Overwrite prompting state
        pfdt->m_cobj = cobj;         // Number of objects being dropped

        hr = S_OK;
    }

    ASSERT_POINTER_MATCHES_HRESULT(*ppfdt, hr);
    return hr;
}


/****************************************************\
    Constructor
\****************************************************/
CDropOperation::CDropOperation() : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_pff);
    ASSERT(!m_pfd);
    ASSERT(!m_hwnd);
    ASSERT(!m_cobj);

    LEAK_ADDREF(LEAK_CDropOperation);
}


/****************************************************\
    Destructor
\****************************************************/
CDropOperation::~CDropOperation()
{
    // use ATOMICRELEASE
    IUnknown_Set(&m_pff, NULL);
    IUnknown_Set(&m_pfd, NULL);
    IUnknown_Set((IUnknown **)&m_ppd, NULL);
    Str_SetPtr((LPTSTR *) &m_pszzFSSource, NULL);
    Str_SetPtr((LPTSTR *) &m_pszzXboxDest, NULL);

    DllRelease();
    LEAK_DELREF(LEAK_CDropOperation);
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CDropOperation::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CDropOperation::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CDropOperation::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, IUnknown*);
    }
    else
    {
        TraceMsg(TF_XBOXQI, "CDropOperation::QueryInterface() failed.");
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}




/****************************************************\
    FUNCTION: _ThreadProcCB

    DESCRIPTION:
\****************************************************/
HRESULT CDropOperation::_ThreadProcCB(void)
{
    HRESULT hr;
    HRESULT hrOleInit = SHCoInitialize();
    
    // WARNING: Init OLE if you plan to do COM.
    m_ppd = CProgressDialog_CreateInstance(IDS_COPY_TITLE, IDA_XBOXUPLOAD);
    if (EVAL(m_ppd))
    {
        ASSERT(m_hwnd);
        // We give a NULL punkEnableModless because we don't want to go modal.
        EVAL(SUCCEEDED(m_ppd->StartProgressDialog(m_hwnd, NULL, PROGDLG_AUTOTIME, NULL)));
    }

    hr = _CalcUploadProgress();
    // Did we succeed creating the directories and counting the
    // size we need to copy?
    if (SUCCEEDED(hr))
    {
        if (m_ppd)
        {
            EVAL(SUCCEEDED(m_ppd->SetProgress64(m_uliBytesCompleted.QuadPart, m_uliBytesTotal.QuadPart)));

            // Reset because _CalcUploadProgress() can take a long time and the estimated time
            // is based on the time between ::StartProgressDialog() and the first
            // ::SetProgress() call.
            EVAL(SUCCEEDED(m_ppd->Timer(PDTIMER_RESET, NULL)));
        }

        hr = _DoCopyIteration();
    }

    if (m_ppd)
    {
        EVAL(SUCCEEDED(m_ppd->StopProgressDialog()));
        ATOMICRELEASE(m_ppd);
    }

    SHCoUninitialize(hrOleInit);
    Release();
    return hr;
}


HRESULT CDropOperation::DoOperation(BOOL fAsync)
{
    HRESULT hr = S_OK;

    AddRef();
    if (fAsync)
    {
        HANDLE hThread;
        DWORD dwThreadId;

        hThread = CreateThread(NULL, 0, CDropOperation::_ThreadProc, this, 0, &dwThreadId);
        if (hThread)
            CloseHandle(hThread);
        else
        {
            TraceMsg(TF_ERROR, "CDropOperation::DoOperation() CreateThread() failed and GetLastError()=%lu.", GetLastError());
            Release();
        }
    }
    else
        hr = _ThreadProcCB();

    return hr;
}



/****************************************************\
    FUNCTION: _CalcUploadProgress

    DESCRIPTION:
\****************************************************/
HRESULT CDropOperation::_CalcUploadProgress(void)
{
    HRESULT hr = S_OK;
    LPCWSTR pszzFSSource = m_pszzFSSource;
    LPCWSTR pszzXboxDest = m_pszzXboxDest;
    WCHAR wzProgressDialogStr[MAX_PATH];

    m_uliBytesCompleted.QuadPart = 0;
    m_uliBytesTotal.QuadPart = 0;
    
    // Tell the user we are calculating how long it will take.
    if (EVAL(LoadStringW(HINST_THISDLL, IDS_PROGRESS_UPLOADTIMECALC, wzProgressDialogStr, ARRAYSIZE(wzProgressDialogStr))))
        EVAL(SUCCEEDED(m_ppd->SetLine(2, wzProgressDialogStr, FALSE, NULL)));

    while (S_OK == hr)
    {
        WCHAR szFSSource[MAX_PATH];
        WCHAR szXboxDest[MAX_PATH];

        hr = _EnumOneHdrop(&pszzFSSource, &pszzXboxDest, szFSSource, ARRAYSIZE(szFSSource), szXboxDest, ARRAYSIZE(szXboxDest));
        if (S_OK == hr)
            hr = _CalcSizeOneHdrop(szFSSource, szXboxDest, m_ppd);
    }

    if (FAILED(hr))
        TraceMsg(TF_ALWAYS, "CDropOperation::_CalcUploadProgress() Calculating the upload time failed, but oh well.");

    return hr;
}


HRESULT CDropOperation::_CalcSizeOneHdrop(LPCWSTR pszFSSource, LPCWSTR pszXboxDest, IProgressDialog * ppd)
{
    HRESULT hr;
    WCHAR wzTo[MAX_PATH];

    EVAL(SUCCEEDED(m_pfd->GetDisplayPath(wzTo, ARRAYSIZE(wzTo))));
    pszXboxDest = PathFindFileName(pszXboxDest);

    COPYONEHDROPINFO cohi = {0};

    cohi.pff = m_pff;
    cohi.pszFSSource = pszFSSource;
    cohi.pszXboxDest = pszXboxDest;
    cohi.pszDir = wzTo;
    cohi.dwOperation = COHDI_FILESIZE_COUNT;
    cohi.ops = opsPrompt;
    cohi.fIsRoot = TRUE;
    cohi.pmlc = &m_mlc;
    cohi.pidlServer = XboxCloneServerID(m_pff->GetPrivatePidlReference());
    cohi.progInfo.ppd = ppd;
    cohi.fFireChangeNotify = TRUE;

    cohi.progInfo.uliBytesCompleted.QuadPart = m_uliBytesCompleted.QuadPart;
    cohi.progInfo.uliBytesTotal.QuadPart = m_uliBytesTotal.QuadPart;

    hr = m_pfd->WithHint(NULL, m_hwnd, CopyCB, &cohi, NULL, m_pff);
    if (SUCCEEDED(hr))
    {
        m_uliBytesCompleted = cohi.progInfo.uliBytesCompleted;
        m_uliBytesTotal = cohi.progInfo.uliBytesTotal;
    }

    ILFree(cohi.pidlServer);
    return hr;
}


/****************************************************\
    FUNCTION: CDropOperation

    DESCRIPTION:
\****************************************************/
HRESULT CDropOperation::_DoCopyIteration()
{
    HRESULT hr = S_OK;
    LPCTSTR pszzFSSource = m_pszzFSSource;
    LPCTSTR pszzXboxDest = m_pszzXboxDest;

    m_ops = opsPrompt;
    while (S_OK == hr)
    {
        WCHAR szFSSource[MAX_PATH];
        WCHAR szXboxDest[MAX_PATH];

        hr = _EnumOneHdrop(&pszzFSSource, &pszzXboxDest, szFSSource, ARRAYSIZE(szFSSource), szXboxDest, ARRAYSIZE(szXboxDest));
        if (S_OK == hr)
        {
            szFSSource[lstrlenW(szFSSource)+1] = 0;   // Double terminate for SHFileOperation(Delete) in move case
            hr = _CopyOneHdrop(szFSSource, szXboxDest);
            if (EVAL(m_ppd))
                EVAL(SUCCEEDED(m_ppd->SetProgress64(m_uliBytesCompleted.QuadPart, m_uliBytesTotal.QuadPart)));

            // Did we fail to copy the file?
            if (FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr))
            {
                if (!IsValidXboxAnsiFileName(szFSSource) || !IsValidXboxAnsiFileName(szXboxDest))
                    int nResult = DisplayWininetError(m_hwnd, TRUE, HRESULT_CODE(hr), IDS_XBOXERR_TITLE_ERROR, IDS_XBOXERR_INVALIDXBOXNAME, IDS_XBOXERR_WININET, MB_OK, m_ppd);
                else
                    int nResult = DisplayWininetError(m_hwnd, TRUE, HRESULT_CODE(hr), IDS_XBOXERR_TITLE_ERROR, IDS_XBOXERR_FILECOPY, IDS_XBOXERR_WININET, MB_OK, m_ppd);
                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
            }
            if (S_FALSE == hr)
            {
                // _CopyOneHdrop() returning S_FALSE means we hit the end of the iteration,
                // in this case, _ConfirmCopy() only meant to skip this one file, so
                // change to S_OK to continue with the rest of the files.
                hr = S_OK;
            }
        }
    }

    Str_SetPtr((LPTSTR *) &m_pszzFSSource, NULL);
    Str_SetPtr((LPTSTR *) &m_pszzXboxDest, NULL);

    return hr;
}


HRESULT CDropOperation::_ConfirmCopy(LPCWSTR pszLocal, LPCWSTR pszXboxName, BOOL * pfFireChangeNotify)
{
    return ConfirmCopy(pszLocal, pszXboxName, &m_ops, m_hwnd, m_pff, m_pfd, NULL, m_cobj, pfFireChangeNotify);
}


/*****************************************************************************\
    CopyCB

    Callback procedure that copies a single hdrop / map.
\*****************************************************************************/
HRESULT CDropOperation::CopyCB(HINTERNET hint, HINTPROCINFO * phpi, LPVOID pv, BOOL * pfReleaseHint)
{
    LPCOPYONEHDROPINFO pcohi = (LPCOPYONEHDROPINFO) pv;
    pcohi->progInfo.hint = hint;
    HRESULT hr;

    InternetSetStatusCallbackWrap(hint, TRUE, XboxProgressInternetStatusCB);
    hr = CopyFileSysItem(hint, phpi, pcohi);
    if (!pcohi->progInfo.hint)
        *pfReleaseHint = FALSE;     // We had to close hint to get the cancel.

    return hr;
}


HRESULT CDropOperation::_CopyOneHdrop(LPCWSTR pszFSSource, LPCWSTR pszXboxDest)
{
    HRESULT hr;
    BOOL fFireChangeNotify = TRUE;

    pszXboxDest = PathFindFileName(pszXboxDest);

    hr = _ConfirmCopy(pszFSSource, pszXboxDest, &fFireChangeNotify);
    if (S_OK == hr)
    {
        WCHAR wzTo[MAX_PATH];
        COPYONEHDROPINFO cohi = {0};

        cohi.pff = m_pff;
        cohi.pszFSSource = pszFSSource;
        cohi.pszXboxDest = pszXboxDest;
        cohi.pszDir = wzTo;
        cohi.dwOperation = COHDI_COPY_FILES;
        cohi.ops = m_ops;
        cohi.fIsRoot = TRUE;
        cohi.pmlc = &m_mlc;
        cohi.pidlServer = XboxCloneServerID(m_pff->GetPrivatePidlReference());
        cohi.fFireChangeNotify = fFireChangeNotify;
        cohi.progInfo.ppd = m_ppd;

        cohi.progInfo.uliBytesCompleted.QuadPart = m_uliBytesCompleted.QuadPart;
        cohi.progInfo.uliBytesTotal.QuadPart = m_uliBytesTotal.QuadPart;
        EVAL(SUCCEEDED(m_pfd->GetDisplayPath(wzTo, ARRAYSIZE(wzTo))));

        // TODO: have CopyCB also update the dialog.
        hr = m_pfd->WithHint(NULL, m_hwnd, CopyCB, &cohi, NULL, m_pff);

        if (SUCCEEDED(hr) && (m_de == DROPEFFECT_MOVE))
        {
            //  We delete the file with SHFileOperation to keep the
            //  disk free space statistics up to date.
            //
            //  BUGBUG -- If coming from a file name map, maybe it's
            //  being dragged from the recycle bin, in which case, doing
            //  an FO_DELETE will put it back in!
            SHFILEOPSTRUCT sfo = {0};
            
            sfo.hwnd = NULL,                // No HWND so NO UI.
            sfo.wFunc  = FO_DELETE;
            sfo.pFrom  = pszFSSource;       // Multiple files in list.
            sfo.fFlags = (FOF_SILENT | FOF_NOCONFIRMATION /*| FOF_MULTIDESTFILES*/);  // No HWND so NO UI.

            int nResult = SHFileOperation(&sfo);
            if (0 != nResult)
                TraceMsg(TF_ALWAYS, "In CDropOperation::_CopyOneHdrop() and caller wanted MOVE but we couldn't delete the files after the copy.");
        }
        m_uliBytesCompleted = cohi.progInfo.uliBytesCompleted;
        m_uliBytesTotal = cohi.progInfo.uliBytesTotal;
        m_ops = cohi.ops;
    }
    else
    {
        if (S_FALSE == hr)
        {
            // _CopyOneHdrop() returning S_FALSE means we hit the end of the iteration,
            // in this case, _ConfirmCopy() only meant to skip this one file, so
            // change to S_OK to continue with the rest of the files.
            hr = S_OK;
        }
    }

    return hr;
}


/*****************************************************************************
    FUNCTION: SetEffect

    DESCRIPTION:
        Set the appropriate drop effect feedback.

    In the absence of keyboard modifiers, use CTRL (copy), unless
    DROPEFFECT_COPY is not available, in which case we use SHIFT (move).

    If anything else is set, then panic out to DROPEFFECT_NONE.

    Note that we do *not* use g_cfPreferredDe.  The only things
    we support are DROPEFFECT_COPY and DROPEFFECT_MOVE, and we always prefer DROPEFFECT_COPY.

    BUGBUG -- ignoring g_cfPreferredDe messes up cut/paste, though.
 *****************************************************************************/

HRESULT CXboxDrop::SetEffect(DROPEFFECT * pde)
{
    DWORD de;            // Preferred drop effect

    // Don't even think about effects that we don't support
    *pde &= m_grfksAvail;

    switch (m_grfks & (MK_SHIFT | MK_CONTROL))
    {
    case 0:            // No modifier, use COPY if possible
        if (*pde & DROPEFFECT_COPY)
        {
    case MK_CONTROL:
            de = DROPEFFECT_COPY;
        }
        else
        {
    case MK_SHIFT:
            de = DROPEFFECT_MOVE;
        }
        break;

    default:
        de = 0;
        break;        // Cannot link
    }
    *pde &= de;

    TraceMsg(TF_XBOXDRAGDROP, "CXboxDrop::SetEffect(DROPEFFECT=%08x) m_grfksAvail=%08x", *pde, m_grfksAvail);
    return S_OK;
}


BOOL CXboxDrop::_IsXBOXOperationAllowed(IDataObject * pdto)
{
#ifdef FEATURE_XBOX_TO_XBOX_COPY
    BOOL fIsXBOXOperationAllowed = TRUE;

    // There are a few things we don't allow.
    // Is the Drop XBOX Location the same
    // folder that the dragged items are already in?
    if (0)
    {
        // TODO:
    }
    
    return fIsXBOXOperationAllowed;
#else // FEATURE_XBOX_TO_XBOX_COPY

    // Disallow all XBOX Operations
    return !_HasData(pdto, &g_dropTypes[DROP_XBOX_PRIVATE]);
#endif // FEATURE_XBOX_TO_XBOX_COPY
}


/*****************************************************************************\
    GetEffectsAvail

    Look at the object to see what drop effects are available.

    If we have a file group descriptor or an HDROP,
    then file contents are available.  (We assume that if you have
    a FGD, then a Contents isn't far behind.)

    In a perfect world, we would also validate the contents of
    each file in the group descriptor, to ensure that the contents
    are droppable.  We skimp on that because it's too expensive.
\*****************************************************************************/
DWORD CXboxDrop::GetEffectsAvail(IDataObject * pdto)
{
    DWORD grfksAvail = 0;

    // Is this from an Xbox Shell Extension?
    if (_IsXBOXOperationAllowed(pdto))
    {
        // No or it's allowed, then we will accept it.  We reject everything
        // else because we can't do Xbox1->Xbox2 copying without
        // using the local machine as a temp location. (Xbox1->Local->Xbox2)

        if (_HasData(pdto, &g_dropTypes[DROP_Hdrop]) ||
            _HasData(pdto, &g_dropTypes[DROP_FGDW]) ||
            _HasData(pdto, &g_dropTypes[DROP_FGDA]))
        {
            TraceMsg(TF_XBOXDRAGDROP, "CXboxDrop::GetEffectsAvail() SUCCEEDED");
            grfksAvail = DROPEFFECT_COPY + DROPEFFECT_MOVE;
        }
        else
        {
            TraceMsg(TF_XBOXDRAGDROP, "CXboxDrop::GetEffectsAvail() FAILED");
#ifdef DEBUG
            STGMEDIUM sm;
            HRESULT hres = pdto->GetData(&g_dropTypes[DROP_URL], &sm);
            if (SUCCEEDED(hres))
            {
                TraceMsg(TF_XBOXDRAGDROP, "CXboxDrop::GetEffectsAvail(%08x) URL: %hs", pdto, GlobalLock(sm.hGlobal));
                GlobalUnlock(sm.hGlobal);
                ReleaseStgMedium(&sm);
            }
            else
            {
                TraceMsg(TF_XBOXDRAGDROP, "CXboxDrop::GetEffectsAvail(%08x) No URL", pdto);
            }
#endif // DEBUG
        }
    }

    return grfksAvail;
}


/*****************************************************************************\
    GetEffect

    Return the drop effect to use.

    If this is a nondefault drag/drop, then put up a menu.  Else,
    just go with the default.

    m_de = default effect
    m_pde -> possible effects (and receives result)
\*****************************************************************************/
DROPEFFECT CXboxDrop::GetEffect(POINTL pt)
{
    TraceMsg(TF_XBOXDRAGDROP, "CXboxDrop::GetEffect() m_de=%08x. m_grfks=%08x", m_de, m_grfks);

    if (m_de && (m_grfks & MK_RBUTTON))
    {
        HMENU hmenuMain = LoadMenu(g_hinst, MAKEINTRESOURCE(IDM_DROPCONTEXT));
        HMENU hmenu = GetSubMenu(hmenuMain, 0);
        DROPEFFECT de;

        ASSERT(*m_pde & m_de);
        SetMenuDefaultItem(hmenu, m_de, 0);
        if (!(*m_pde & DROPEFFECT_COPY))
            DeleteMenu(hmenu, DROPEFFECT_COPY, MF_BYCOMMAND);

        if (!(*m_pde & DROPEFFECT_MOVE))
            DeleteMenu(hmenu, DROPEFFECT_MOVE, MF_BYCOMMAND);

        // _UNOBVIOUS_:  Defview is incestuous with itself.
        // If the drop target originated from Shell32.dll, then
        // it leaves the image of the dropped object on the screen
        // while the menu is up, which is nice.  Otherwise, it removes
        // the image of the dropped object before the drop target
        // receives its IDropTarget::Drop.
        // Which means that outside shell extensions can't take
        // advantage of the "pretty drop UI" feature.

        // _UNOBVIOUS_:  Have to force foregroundness, else the input
        // gets screwed up.
        if (m_hwnd)
            SetForegroundWindow(m_hwnd);

        de = TrackPopupMenuEx(hmenu,
                      TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_VERTICAL |
                      TPM_LEFTALIGN | TPM_TOPALIGN, pt.x, pt.y,
                      m_hwnd, 0);

        DestroyMenu(hmenuMain);
        m_de = de;
    }
    *m_pde = m_de;

    TraceMsg(TF_XBOXDRAGDROP, "CXboxDrop::GetEffect(%08x) -> %08x", this, m_de);
    return m_de;
}


/****************************************************\
    FUNCTION: _StartBackgroundInteration

    DESCRIPTION:
\****************************************************/
HRESULT CXboxDrop::_StartBackgroundInteration(void)
{
    CDropOperation * pDropOperation;
    HRESULT hr = CDropOperation_Create(m_pff, m_hwnd, m_pszzFSSource, m_pszzXboxDest, &pDropOperation, m_de, m_ops, m_cobj);
    
    // Did it succeed?
    if (EVAL(SUCCEEDED(hr)))
    {
        // Yes, so NULL out m_pszzFSSource, m_pszzXboxDest because we gave them our copies.
        //  Ugly but allocation is uglier.
        m_pszzFSSource = NULL;
        m_pszzXboxDest = NULL;

        EVAL(SUCCEEDED(hr = pDropOperation->DoOperation(TRUE)));
        pDropOperation->Release();
    }

    return hr;
}


/****************************************************\
    FUNCTION: _DoCountIteration

    DESCRIPTION:
\****************************************************/
HRESULT CXboxDrop::_DoCountIteration(void)
{
    HRESULT hr = S_OK;
    LPCTSTR pszzFSSource = m_pszzFSSource;
    LPCTSTR pszzXboxDest = m_pszzXboxDest;

    while (S_OK == hr)
    {
        TCHAR szFSSource[MAX_PATH];
        TCHAR szXboxDest[MAX_PATH];

        hr = _EnumOneHdrop(&pszzFSSource, &pszzXboxDest, szFSSource, ARRAYSIZE(szFSSource), szXboxDest, ARRAYSIZE(szXboxDest));
        if (S_OK == hr)
            m_cobj++;
    }

    if (hr == S_FALSE)
        hr = S_OK;        // Enumerated to completion

    return hr;
}


/****************************************************\
    FUNCTION: _GetFSSourcePaths

    DESCRIPTION:
\****************************************************/
HRESULT CXboxDrop::_GetFSSourcePaths(HGLOBAL hdrop, BOOL * pfAnsi)
{
    LPDROPFILES pdrop = (LPDROPFILES) GlobalLock(hdrop);
    HRESULT hr = E_INVALIDARG;

    *pfAnsi = TRUE;
    if (EVAL(pdrop))
    {
        //  Now to decide whether it is an old-style drop or a new-style
        // drop.  And if it's a new-style drop, to get the character set.
        if (LOWORD(pdrop->pFiles) == sizeof(DROPFILES16))
        {
            // Old style
            Str_StrAndThunkA((LPTSTR *) &m_pszzFSSource, (LPCSTR) pvByteIndexCb(pdrop, LOWORD(pdrop->pFiles)), TRUE);
        }
        else
        {
            if (pdrop->fWide)
            {
                Str_StrAndThunkW((LPTSTR *) &m_pszzFSSource, (LPCWSTR) pvByteIndexCb(pdrop, pdrop->pFiles), TRUE);
                *pfAnsi = FALSE;
            }
            else
                Str_StrAndThunkA((LPTSTR *) &m_pszzFSSource, (LPCSTR) pvByteIndexCb(pdrop, pdrop->pFiles), TRUE);
        }
        GlobalUnlock(pdrop);
        hr = S_OK;
    }

    return hr;
}


/****************************************************\
    FUNCTION: _GetXboxDestPaths

    DESCRIPTION:
\****************************************************/
HRESULT CXboxDrop::_GetXboxDestPaths(HGLOBAL hmap, BOOL fAnsi)
{
    HRESULT hr = E_INVALIDARG;
    LPVOID pmap = NULL;

    //  If we can't get a map, then just use the source file names.
    ASSERT(!m_pszzXboxDest);
    if (hmap)
    {
        pmap = GlobalLock(hmap);

        if (pmap)
        {
            if (fAnsi)
                Str_StrAndThunkA((LPTSTR *) &m_pszzXboxDest, (LPCSTR) pmap, TRUE);
            else
                Str_StrAndThunkW((LPTSTR *) &m_pszzXboxDest, (LPCWSTR) pmap, TRUE);

            GlobalUnlock(pmap);
        }
    }

    if (!m_pszzXboxDest)
    {
        // Just copy the Paths
        Str_StrAndThunk((LPTSTR *) &m_pszzXboxDest, m_pszzFSSource, TRUE);
    }

    if (m_pszzXboxDest)
        hr = S_OK;

    return hr;
}



/*****************************************************************************\
    CopyHdrop

    Copy an HDROP data object.

    Note also that when we use HDROP, we must also consult the
    FileNameMap otherwise dragging out of the recycle bin directly
    into an XBOX folder will create files with the wrong name!

    Note further that the returned effect of an HDROP is always
    DROPEFFECT_COPY, because we will do the work of deleting the
    source files when finished.
\*****************************************************************************/
HRESULT CXboxDrop::CopyHdrop(IDataObject * pdto, STGMEDIUM *psm)
{
    BOOL fAnsi;
    HRESULT hr = _GetFSSourcePaths(psm->hGlobal, &fAnsi);

    if (EVAL(SUCCEEDED(hr)))
    {
        STGMEDIUM sm;

        // ZIP fails this.
        // Get the File name map, too, if one exists
        if (fAnsi)
            hr = pdto->GetData(&g_dropTypes[DROP_FNMA], &sm);
        else
            hr = pdto->GetData(&g_dropTypes[DROP_FNMW], &sm);

        if (FAILED(hr))       // Failure is ok
            sm.hGlobal = 0;

        hr = _GetXboxDestPaths(sm.hGlobal, fAnsi);
        if (EVAL(SUCCEEDED(hr)))
        {
            *m_pde = DROPEFFECT_COPY;
            // Count up how many things there are in the hdrop,
            // so that our confirmation dialog knows what the deal is.
            // We can ignore the error; it'll show up again when we copy.
            m_cobj = 0;
            hr = _DoCountIteration();
            ASSERT(SUCCEEDED(hr));
            TraceMsg(TF_XBOXDRAGDROP, "CXboxDrop_CopyHdrop: %d file(s)", m_cobj);

            //  Now walk the lists with the appropriate enumerator.
            hr = _StartBackgroundInteration();
            ASSERT(SUCCEEDED(hr));
        }
        if (sm.hGlobal)
            ReleaseStgMedium(&sm);
    }

    return hr;
}


/*****************************************************************************\
    _CopyHglobal

    Copy a file contents received as an hglobal.

    If a FD_FILESIZE is provided, use it.  Otherwise, just use the size
    of the hglobal.
\*****************************************************************************/
HRESULT CXboxDrop::_CopyHglobal(IStream * pstm, DWORD dwFlags, DWORD dwFileSizeHigh, DWORD dwFileSizeLow, LPVOID pvSrc, ULARGE_INTEGER *pqw)
{
    LPVOID pv;
    HGLOBAL hglob = pvSrc;
    HRESULT hres;

    pqw->HighPart = 0;
    pv = GlobalLock(hglob);
    if (EVAL(pv))
    {
        UINT cb = (UINT) GlobalSize(hglob);
        if (dwFlags & FD_FILESIZE)
        {
            if (cb > dwFileSizeLow)
                cb = dwFileSizeHigh;
        }
        hres = pstm->Write(pv, cb, &pqw->LowPart);
        if (SUCCEEDED(hres))
        {
            if (pqw->LowPart != cb)
                hres = STG_E_MEDIUMFULL;
        }
        GlobalUnlock(pv);
    }
    else
        hres = E_INVALIDARG;

    return hres;
}


/*****************************************************************************
    FUNCTION: _GetRelativePidl

    DESCRIPTION:
        pszFullPath may come in this format: "dir1\dir2\dir3\file.txt".  We
    need to create *ppidl such that it will contain 4 itemIDs in this case and
    the last one (file.txt) will have the correct attributes and file size.
\*****************************************************************************/
CXboxDir * CXboxDrop::_GetRelativePidl(LPCWSTR pszFullPath, DWORD dwFileAttributes, DWORD dwFileSizeHigh, DWORD dwFileSizeLow, LPITEMIDLIST * ppidl)
{
    HRESULT hr = S_OK;
    WCHAR szFullPath[MAX_PATH];
    LPWSTR pszFileName;
    LPITEMIDLIST pidlFull;
    CXboxDir * pfd = m_pfd;  // Assume the Dir to create isn't in a subdir.

    // Find the File Name
    StrCpyNW(szFullPath, pszFullPath, ARRAYSIZE(szFullPath));   // Make a copy because the caller's is read only.
    pszFileName = PathFindFileName(szFullPath);                 // Find where the file begins.
    FilePathToUrlPathW(szFullPath);                             // Convert from "dir1\dir2\file.txt" to "dir1/dir2/file.txt"

    *ppidl = NULL;
    hr = CreateXboxPidlFromDisplayPath(szFullPath, m_pff->GetCWireEncoding(), NULL, &pidlFull, TRUE, FALSE);
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidlFile = ILFindLastID(pidlFull);
        SYSTEMTIME st;
        FILETIME ft;

        GetSystemTime(&st);
        SystemTimeToFileTime(&st, &ft);
        XboxPidl_SetAttributes(pidlFile, dwFileAttributes);
        XboxPidl_SetFileSize(pidlFile, dwFileSizeHigh, dwFileSizeLow);
        XboxItemID_SetFileTime(pidlFile, ft);

        // Is the file in a subdir?
        if (!ILIsEmpty(pidlFull) && !ILIsEmpty(_ILNext(pidlFull)))
        {
            // Yes, so generate a CXboxDir to the subdir.
            LPITEMIDLIST pidlPath = ILClone(pidlFull);

            if (pidlPath)
            {
                ILRemoveLastID(pidlPath);
                pfd = m_pfd->GetSubXboxDir(m_pff, pidlPath, FALSE);
                ILFree(pidlPath);
            }
        }

        if (pfd)
            *ppidl = ILClone(pidlFile);
        ILFree(pidlFull);
    }

    return pfd;
}


/*****************************************************************************
    FUNCTION: CopyAsStream

    DESCRIPTION:
        Copy a file contents received as a <mumble> to a stream.
\*****************************************************************************/
HRESULT CXboxDrop::CopyAsStream(LPCWSTR pszName, DWORD dwFileAttributes, DWORD dwFlags, DWORD dwFileSizeHigh, DWORD dwFileSizeLow, STREAMCOPYPROC pfn, LPVOID pv)
{
    BOOL fFireChangeNotify;
    HRESULT hr = ConfirmCopy(pszName, pszName, &m_ops, m_hwnd, m_pff, m_pfd, m_pde, m_cobj, &fFireChangeNotify);

    if (EVAL(SUCCEEDED(hr)))
    {
        LPITEMIDLIST pidlRelative;
        CXboxDir * pfd = _GetRelativePidl(pszName, dwFileAttributes, dwFileSizeHigh, dwFileSizeLow, &pidlRelative);

        if (EVAL(pfd))
        {
            LPITEMIDLIST pidlFull = ILCombine(pfd->GetPidlReference(), pidlRelative);

            if (pidlFull)
            {
                IStream * pstm;
                ULARGE_INTEGER uliTemp = {0};

                hr = CXboxStm_Create(pfd, pidlFull, GENERIC_WRITE, &pstm, uliTemp, uliTemp, NULL, FALSE);
                if (SUCCEEDED(hr))
                {
                    ULARGE_INTEGER uli = {dwFileSizeLow, dwFileSizeHigh};

                    hr = pfn(pstm, dwFlags, dwFileSizeHigh, dwFileSizeLow, pv, &uli);
                    if (SUCCEEDED(hr))
                    {
                        // Only fire change notify if we didn't replace a file on 
                        // browser only. (Because we hack the defview and it doesn't
                        // check for duplicates)
                        if (fFireChangeNotify)
                        {
                            XboxPidl_SetFileSize(pidlRelative, uli.HighPart, uli.LowPart);

                            // This time date stamp may be incorrect.
                            XboxChangeNotify(m_hwnd, SHCNE_CREATE, m_pff, pfd, pidlRelative, NULL, TRUE);
                        }
                    }
                    else
                    {
                        ASSERT(0);      // BUGBUG - Is there an orphaned file we need to delete?
                        DisplayWininetError(m_hwnd, TRUE, HRESULT_CODE(hr), IDS_XBOXERR_TITLE_ERROR, IDS_XBOXERR_DROPFAIL, IDS_XBOXERR_WININET, MB_OK, NULL);
                        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                    }

                    pstm->Release();
                }
                else
                {
                    DisplayWininetError(m_hwnd, TRUE, HRESULT_CODE(hr), IDS_XBOXERR_TITLE_ERROR, IDS_XBOXERR_DROPFAIL, IDS_XBOXERR_WININET, MB_OK, NULL);
                    hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                }

                ILFree(pidlFull);
            }
            else
                hr = E_OUTOFMEMORY;

            if (pfd != m_pfd)
                pfd->Release();

            ILFree(pidlRelative);
        }
        else
            hr = E_FAIL;
    }
    else
    {
        // BUGBUG -- need to stat the file to generate a local WFDA
        // BUGBUG -- check the return value and do something
        ASSERT(0);      // Handle appropriately.
    }

    return hr;
}


/*****************************************************************************\
    CopyStream

    Copy a file contents received as a stream.
    We ignore the file size in the fgd.
\*****************************************************************************/
HRESULT CXboxDrop::CopyStream(IStream * pstm, DWORD dwFlags, DWORD dwFileSizeHigh, DWORD dwFileSizeLow, LPVOID pvSrc, ULARGE_INTEGER *pqw)
{
    IStream * pstmSrc = (IStream *) pvSrc;
    ULARGE_INTEGER qwMax = {0xFFFFFFFF, 0xFFFFFFFF};
    HRESULT hres;

    hres = pstmSrc->CopyTo(pstm, qwMax, 0, pqw);
    ASSERT(SUCCEEDED(hres));

    return hres;
}


/*****************************************************************************\
    FUNCTION: CXboxDrop::CopyStorage

    DESCRIPTION:
        Copy a file contents provided as an IStorage.  Gack.
    We have to do this only because Exchange is a moron.

    Since there is no way to tell OLE to create a .doc file
    into an existing stream, we need to create the .doc file
    on disk, and then copy the file into the stream, then delete
    the .doc file.

    Note that CDropOperation::DoOperation() (_CopyOneHdrop) will do the ConfirmCopy
    and the XboxDropNotifyCreate(), too!  However, we want to fake
    it out and fool it into thinking we are doing a DROPEFFECT_COPY,
    so that it doesn't delete the "source" file.  *We* will delete
    the source file, because we created it.  (No need to tell the
    shell about disk size changes that don't affect it.)
\*****************************************************************************/
HRESULT CXboxDrop::CopyStorage(LPCWSTR pszFile, IStorage * pstgIn)
{
    IStorage * pstgOut;
    HRESULT hr = StgCreateDocfile(0, (STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_CREATE), 0, &pstgOut);

    if (EVAL(SUCCEEDED(hr)))
    {
        STATSTG stat;
        hr = pstgOut->Stat(&stat, STATFLAG_DEFAULT);
        if (EVAL(SUCCEEDED(hr)))
        {
            TCHAR szFSSource[MAX_PATH+3];
            TCHAR szXboxDest[MAX_PATH+3];

            SHUnicodeToTChar(stat.pwcsName, szFSSource, ARRAYSIZE(szFSSource));
            StrCpyN(szXboxDest, pszFile, ARRAYSIZE(szXboxDest));
            szFSSource[lstrlen(szFSSource)+1] = 0;    // Add the termination of the list of strings.
            szXboxDest[lstrlen(szXboxDest)+1] = 0;    // Add the termination of the list of strings.

            hr = pstgIn->CopyTo(0, 0, 0, pstgOut);
            pstgOut->Commit(STGC_OVERWRITE);
            pstgOut->Release();     // Must release before copying
            pstgOut = NULL;
            if (EVAL(SUCCEEDED(hr)))
            {
                DROPEFFECT deTrue = m_de;
                m_de = DROPEFFECT_COPY;
                CDropOperation * pDropOperation;
                hr = CDropOperation_Create(m_pff, m_hwnd, szFSSource, szXboxDest, &pDropOperation, m_de, m_ops, m_ops);
    
                // Did it succeed?
                if (EVAL(SUCCEEDED(hr)))
                {
                    // Do the operation asynchroniously because the caller may call
                    // this over an over.
                    EVAL(SUCCEEDED(hr = pDropOperation->DoOperation(FALSE)));
                    pDropOperation->Release();
                }

                // Did an error occure and no UI has been displayed yet?
                if (FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr))
                {
                    DisplayWininetError(m_hwnd, TRUE, HRESULT_CODE(hr), IDS_XBOXERR_TITLE_ERROR, IDS_XBOXERR_FILECOPY, IDS_XBOXERR_WININET, MB_OK, NULL);
                }

                m_de = deTrue;

                DeleteFile(szFSSource);
            }
            else
                DisplayWininetError(m_hwnd, TRUE, HRESULT_CODE(hr), IDS_XBOXERR_TITLE_ERROR, IDS_XBOXERR_DROPFAIL, IDS_XBOXERR_WININET, MB_OK, NULL);

            SHFree(stat.pwcsName);
        }
        else
            DisplayWininetError(m_hwnd, TRUE, HRESULT_CODE(hr), IDS_XBOXERR_TITLE_ERROR, IDS_XBOXERR_DROPFAIL, IDS_XBOXERR_WININET, MB_OK, NULL);
    }
    else
        DisplayWininetError(m_hwnd, TRUE, HRESULT_CODE(hr), IDS_XBOXERR_TITLE_ERROR, IDS_XBOXERR_DROPFAIL, IDS_XBOXERR_WININET, MB_OK, NULL);

    return hr;
}


/*****************************************************************************\
    CopyFCont

    Copy a file contents.
\*****************************************************************************/
HRESULT CXboxDrop::CopyFCont(LPCWSTR pszName, DWORD dwFileAttributes, DWORD dwFlags, DWORD dwFileSizeHigh, DWORD dwFileSizeLow, STGMEDIUM *psm)
{
    HRESULT hres;

    switch (psm->tymed)
    {
    case TYMED_HGLOBAL:
        hres = CopyAsStream(pszName, dwFileAttributes, dwFlags, dwFileSizeHigh, dwFileSizeLow, _CopyHglobal, psm->hGlobal);
        break;

    case TYMED_ISTREAM:
        hres = CopyAsStream(pszName, dwFileAttributes, dwFlags, dwFileSizeHigh, dwFileSizeLow, CopyStream, psm->pstm);
        break;

    case TYMED_ISTORAGE:        // Stupid Exchange
        hres = CopyStorage(pszName, psm->pstg);
        break;

    default:
        ASSERT(0);
        // Shouldn't have gotten this - BUGBUG -- UI?
        hres = E_INVALIDARG;
        break;
    }

    return hres;
}


HRESULT CXboxDrop::_GetFileDescriptor(LONG nIndex, LPFILEGROUPDESCRIPTORW pfgdW, LPFILEGROUPDESCRIPTORA pfgdA, BOOL fUnicode, LPFILEDESCRIPTOR pfd)
{
    if (fUnicode)
    {
        LPFILEDESCRIPTORW pfdW = &pfgdW->fgd[nIndex];
    
        CopyMemory(pfd, pfdW, (sizeof(*pfdW) - sizeof(pfdW->cFileName)));   // Copy Everything except the name.
        SHUnicodeToTChar(pfdW->cFileName, pfd->cFileName, ARRAYSIZE(pfd->cFileName));
    }
    else
    {
        LPFILEDESCRIPTORA pfdA = &pfgdA->fgd[nIndex];
        
        CopyMemory(pfd, pfdA, (sizeof(*pfdA) - sizeof(pfdA->cFileName)));   // Copy Everything except the name.
        SHAnsiToTChar(pfdA->cFileName, pfd->cFileName, ARRAYSIZE(pfd->cFileName));
    }

    return S_OK;
}


HRESULT CXboxDrop::_CreateFGDDirectory(LPFILEDESCRIPTOR pFileDesc)
{
    HRESULT hr = S_OK;
    WCHAR szDirName[MAX_PATH];
    LPTSTR pszDirToCreate = PathFindFileName(pFileDesc->cFileName);
    XBOXCREATEFOLDERSTRUCT fcfs = {szDirName, m_pff};
    CXboxDir * pfd = m_pfd;  // Assume the Dir to create isn't in a subdir.

    SHTCharToUnicode(pszDirToCreate, szDirName, ARRAYSIZE(szDirName));
    pszDirToCreate[0] = 0;  // Separate Dir to create from SubDir where to create it.

    // Is the dir to create in subdir?
    if (pFileDesc->cFileName[0])
    {
        // Yes, so let's get that CXboxDir pointer so WithHint below will get us there.
        LPITEMIDLIST pidlPath;
        
        FilePathToUrlPathW(pFileDesc->cFileName);
        hr = CreateXboxPidlFromDisplayPath(pFileDesc->cFileName, m_pff->GetCWireEncoding(), NULL, &pidlPath, TRUE, TRUE);
        if (SUCCEEDED(hr))
        {
            pfd = m_pfd->GetSubXboxDir(m_pff, pidlPath, FALSE);
            ILFree(pidlPath);
        }
    }
    
    if (SUCCEEDED(hr))
    {
        hr = pfd->WithHint(NULL, m_hwnd, CreateNewFolderCB, (LPVOID) &fcfs, NULL, m_pff);
        if (SUCCEEDED(hr))
        {
        }
        else
        {
            // TODO: Display error UI?
        }
    }

    if (m_pfd != pfd)
    {
        // We allocated pfd, so now let's free it.
        pfd->Release();
    }

    return hr;
}


/*****************************************************************************\
    CopyFGD

    Copy a file group descriptor.

    File group descriptors are used to source gizmos that are file-like
    but aren't stored on disk as such.  E.g., an embedded file in a
    mail message, a GIF image in a web page, an OLE scrap, or a file
    on a remote XBOX site.

    _UNOBVIOUS_:  If you do a GetData on TYMED_HGLOBAL | TYMED_ISTREAM,
    Exchange will nonetheless give you a TYMED_ISTORAGE even though
    you didn't ask for it.  So we need to support IStorage in order
    to make Exchange look less broken.  (Maybe I shouldn't cover for
    them.  Or maybe I should send them a bill.)
\*****************************************************************************/
HRESULT CXboxDrop::CopyFGD(IDataObject * pdto, STGMEDIUM *psm, BOOL fUnicode)
{
    LPFILEGROUPDESCRIPTORA pfgdA = NULL;
    LPFILEGROUPDESCRIPTORW pfgdW = NULL;
    HRESULT hr = E_INVALIDARG;

    // WARNING:
    //      shell32.dll from Win95, WinNT 4, IE 3, IE 4, and IE 4.01 have
    //      a bug that cause recursive file download not to work for
    //      subdirectories on WinNT unless we implement FILEGROUPDESCRIPTORW.

    if (fUnicode)
        pfgdW = (LPFILEGROUPDESCRIPTORW) GlobalLock((LPFILEGROUPDESCRIPTORW *) psm->hGlobal);
    else
        pfgdA = (LPFILEGROUPDESCRIPTORA) GlobalLock((FILEGROUPDESCRIPTORA *) psm->hGlobal);

    if (EVAL(pfgdA || pfgdW))
    {
        FORMATETC fe = {g_dropTypes[DROP_FCont].cfFormat, 0, DVASPECT_CONTENT, 0, (TYMED_ISTREAM | TYMED_HGLOBAL | TYMED_ISTORAGE)};
        
        // Stupid Exchange
        DWORD dwSize = m_cobj = (pfgdW ? pfgdW->cItems : pfgdA->cItems);

        TraceMsg(TF_XBOXDRAGDROP, "CXboxDrop::CopyFGD: %d files", m_cobj);
        hr = S_OK;        // Watch out for vacuous null case

        for (; ((UINT)fe.lindex < dwSize); fe.lindex++)
        {
            FILEDESCRIPTOR fileDescriptor = {0};

            if (EVAL(SUCCEEDED(_GetFileDescriptor(fe.lindex, pfgdW, pfgdA, fUnicode, &fileDescriptor))))
            {
                // Is this a folder?
                if ((FD_ATTRIBUTES & fileDescriptor.dwFlags) &&
                    FILE_ATTRIBUTE_DIRECTORY & fileDescriptor.dwFileAttributes)
                {
                    // Yes, so let's create it.  We currently don't copy folder
                    // info. (ACLs or other attributes)
                    hr = _CreateFGDDirectory(&fileDescriptor);
                }
                else
                {
                    // No, so it's a file.  Let's get the stream and then upload that to the XBOX server.
                    STGMEDIUM sm;
                    
                    hr = pdto->GetData(&fe, &sm);
                    if (SUCCEEDED(hr))
                    {

                        hr = CopyFCont(fileDescriptor.cFileName, fileDescriptor.dwFileAttributes, fileDescriptor.dwFlags, fileDescriptor.nFileSizeHigh, fileDescriptor.nFileSizeLow, &sm);
                        ReleaseStgMedium(&sm);
                        if (FAILED(hr))
                        {
                            break;
                        }
                    }
                    else
                    {
                        ASSERT(0);
                        break;
                    }
                }
            }
        }

        if (pfgdW)
            GlobalUnlock(pfgdW);
        if (pfgdA)
            GlobalUnlock(pfgdA);
    }

    return hr;
}


/*****************************************************************************\
    _Copy

    Copy the data object into the shell folder.

    HDROPs are preferred, because we can use XboxPutFile to shove
    them onto the XBOX site without getting our hands dirty.

    Failing that, we use FileGroupDescriptor, which lets us
    get at pseudo-files.

    Note also that if you use HDROP, you need to support FileNameMap
    otherwise dragging out of the recycle bin directly into an XBOX
    folder will create files with the wrong name!

    BUGBUG -- Ask FrancisH how to handle the multi-drag case + move.
    If a single file is cancelled, should I return DROPEFFECT_NONE?
\*****************************************************************************/
HRESULT CXboxDrop::_Copy(IDataObject * pdto)
{
    STGMEDIUM sm;
    HRESULT hr;

    if (SUCCEEDED(hr = pdto->GetData(&g_dropTypes[DROP_Hdrop], &sm)))
    {
        hr = CopyHdrop(pdto, &sm);
        ReleaseStgMedium(&sm);
    }
    else
    {
        BOOL fSupportsUnicode = SUCCEEDED(hr = pdto->GetData(&g_dropTypes[DROP_FGDW], &sm));

        if (fSupportsUnicode || EVAL(SUCCEEDED(hr = pdto->GetData(&g_dropTypes[DROP_FGDA], &sm))))
        {
            hr = CopyFGD(pdto, &sm, fSupportsUnicode);
            ReleaseStgMedium(&sm);
        }
    }

    // Normally we would set the PASTESUCCEEDED info back into 
    // the IDataObject but we don't because we do an optimized
    // MOVE by doing a DELETE after the COPY operation.
    // We do this because we do the operation on a background thread
    // in order to be asynch and we don't want to extend the lifetime
    // of the IDataObject that long.  Therefore we push
    // DROPEFFECT_COPY back into the caller to tell them that
    // we did an optimized move and to not delete the items.
    //
    // TODO: We need to test the CopyFGD() code above and
    //       maybe use PasteSucceeded(DROPEFFECT_MOVE) in
    //       that case.
    if (SUCCEEDED(hr) && (m_de == DROPEFFECT_MOVE))
    {
        // Always set "Copy" because we did an optimized move
        // because we deleted the files our selfs.
        DataObj_SetPasteSucceeded(pdto, DROPEFFECT_COPY);
    }

    return hr;
}

//===========================
// *** IDropTarget Interface ***
//===========================

/*****************************************************************************

    IDropTarget::DragEnter

 *****************************************************************************/
HRESULT CXboxDrop::DragEnter(IDataObject * pdto, DWORD grfKeyState, POINTL pt, DROPEFFECT * pde)
{
    HRESULT hr;

    m_grfks = grfKeyState;    // Remember last key state
    m_grfksAvail = GetEffectsAvail(pdto);

    hr = SetEffect(pde);
    ASSERT(SUCCEEDED(hr));

    TraceMsg(TF_XBOXDRAGDROP, "CXboxDrop::DragEnter(grfKeyState=%08x, DROPEFFECT=%08x) m_grfks=%08x. m_grfksAvail=%08x hres=%#08lx", grfKeyState, *pde, m_grfks, m_grfksAvail, hr);

    return hr;
}

/*****************************************************************************

    IDropTarget::DragOver

 *****************************************************************************/

HRESULT CXboxDrop::DragOver(DWORD grfKeyState, POINTL pt, DROPEFFECT * pde)
{
    HRESULT hr;

    m_grfks = grfKeyState;    // Remember last key state
    hr = SetEffect(pde);
    ASSERT(SUCCEEDED(hr));

    TraceMsg(TF_XBOXDRAGDROP, "CXboxDrop::DragOver(grfKeyState=%08x, DROPEFFECT=%08x) m_grfks=%08x. SetEffect() returned hres=%#08lx", grfKeyState, *pde, m_grfks, hr);

    return hr;
}


/*****************************************************************************

    IDropTarget::DragLeave

 *****************************************************************************/

HRESULT CXboxDrop::DragLeave(void)
{
    TraceMsg(TF_XBOXDRAGDROP, "CXboxDrop::DragLeave() ");

    return S_OK;
}


/*****************************************************************************\
    IDropTarget::Drop 

    Note that the incoming pdto is not necessarily the same as the
    one we saw on DragEnter.  OLE will first give us a "preliminary"
    data object to play with, but on the drop, it will give us a
    fully marshalled object.

    Fortunately, we don't care, because we didn't cache the object.

    Note that we don't pass the real pde to SetEffect, because
    we don't want to lose the list of all possible effects before
    GetEffect uses it.
\*****************************************************************************/
HRESULT CXboxDrop::Drop(IDataObject * pdo, DWORD grfKeyState, POINTL pt, DROPEFFECT * pde)
{
    HRESULT hr;

    m_ops = opsPrompt;        // Start out in prompt mode
    m_grfksAvail = GetEffectsAvail(pdo);
    
    m_pde = pde;
    m_de = *pde;

    hr = SetEffect(&m_de);
    TraceMsg(TF_XBOXDRAGDROP, "CXboxDrop::Drop(grfKeyState=%08x, DROPEFFECT=%08x) m_grfksAvail=%08x. m_de=%08x. SetEffect() returned hres=%#08lx", grfKeyState, *pde, m_grfksAvail, m_de, hr);

    if (EVAL(SUCCEEDED(hr)))
    {
        if (GetEffect(pt))
        {
            hr = _Copy(pdo);
        }
        else
            hr = S_FALSE;   // Indicate cancel.
    }

    if (!(SUCCEEDED(hr)))
    {
        // Error message already has been displayed.
        *pde = 0;
    }

    return hr;
}


/*****************************************************************************\
    CXboxDrop_Create
\*****************************************************************************/
HRESULT CXboxDrop_Create(CXboxFolder * pff, HWND hwnd, CXboxDrop ** ppfdt)
{
    HRESULT hres = E_OUTOFMEMORY;
    CXboxDrop * pfdt = new CXboxDrop();
    *ppfdt = pfdt;

    if (EVAL(pfdt))
    {
        pfdt->m_hwnd = hwnd;

        // Copy the CXboxFolder * value
        pfdt->m_pff = pff;
        if (pff)
            pff->AddRef();

        // Copy the CXboxDir * value
        ASSERT(!pfdt->m_pfd);
        pfdt->m_pfd = pff->GetXboxDir();
        hres = pfdt->m_pfd ? S_OK : E_FAIL;
        if (FAILED(hres))   // Will fail if the caller is CXboxMenu::_RemoveContextMenuItems() and it's OK.
            ATOMICRELEASE(*ppfdt);
    }

    ASSERT_POINTER_MATCHES_HRESULT(*ppfdt, hres);
    return hres;
}


/****************************************************\
    Constructor
\****************************************************/
CXboxDrop::CXboxDrop() : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_pff);
    ASSERT(!m_pfd);
    ASSERT(!m_hwnd);
    ASSERT(!m_grfks);
    ASSERT(!m_grfksAvail);
    ASSERT(!m_pde);
    ASSERT(!m_cobj);

    LEAK_ADDREF(LEAK_CXboxDrop);
}


/****************************************************\
    Destructor
\****************************************************/
CXboxDrop::~CXboxDrop()
{
    IUnknown_Set(&m_pff, NULL);
    IUnknown_Set(&m_pfd, NULL);

    DllRelease();
    LEAK_DELREF(LEAK_CXboxDrop);
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CXboxDrop::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CXboxDrop::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CXboxDrop::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IDropTarget))
    {
        *ppvObj = SAFECAST(this, IDropTarget*);
    }
    else
    {
        TraceMsg(TF_XBOXQI, "CXboxDrop::QueryInterface() failed.");
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxefe.h ===
/*****************************************************************************\
    FILE: xboxefe.h
\*****************************************************************************/

#ifndef _XBOXEFE_H
#define _XBOXEFE_H


/*****************************************************************************\
    CLASS: CXboxEfe

    DESCRIPTION:
        The stuff that tracks the state of an enumeration.
\*****************************************************************************/

class CXboxEfe           : public IEnumFORMATETC
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    
    // *** IEnumFORMATETC ***
    virtual STDMETHODIMP Next(ULONG celt, FORMATETC * rgelt, ULONG *pceltFetched);
    virtual STDMETHODIMP Skip(ULONG celt);
    virtual STDMETHODIMP Reset(void);
    virtual STDMETHODIMP Clone(IEnumFORMATETC **ppenum);

public:
    // Friend Functions
    friend HRESULT CXboxEfe_Create(DWORD dwSize, FORMATETC rgfe[], STGMEDIUM rgstg[], CXboxObj * pfo, IEnumFORMATETC ** ppenum);

protected:
    // Private Member Variables
    int                     m_cRef;

    DWORD                   m_dwIndex;           // Current Item in the m_hdsaFormatEtc list
    DWORD                   m_dwExtraIndex;      // Current Item in the m_pfo->m_hdsaSetData list
    HDSA                    m_hdsaFormatEtc;     // pointer to the array 
    CXboxObj *               m_pfo;               // pointer to the parent IDataObject impl that has the list of extra data from ::SetData.


    CXboxEfe(DWORD dwSize, FORMATETC rgfe[], STGMEDIUM rgstg[], CXboxObj * pfo);
    CXboxEfe(DWORD dwSize, HDSA hdsaFormatEtc, CXboxObj * pfo, DWORD dwIndex);
    ~CXboxEfe(void);

    // Public Member Functions
    HRESULT _NextOne(FORMATETC * pfetc);

    
    // Friend Functions
    friend HRESULT CXboxEfe_Create(DWORD dwSize, HDSA m_hdsaFormatEtc, DWORD dwIndex, CXboxObj * pfo, IEnumFORMATETC ** ppenum);
    friend HRESULT CXboxEfe_Create(DWORD dwSize, FORMATETC rgfe[], STGMEDIUM rgstg[], CXboxObj * pfo, CXboxEfe ** ppfefe);
};

#endif // _XBOXEFE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxeidl.cpp ===
/*****************************************************************************
 *
 *    xboxeidl.cpp - IEnumIDList interface
 *
 *    XboxNameCache
 *
 *    Enumerating an XBOX site is an expensive operation, because
 *    it can entail dialing the phone, connecting to an ISP, then
 *    connecting to the site, logging in, cd'ing to the appropriate
 *    location, pumping over an "ls" command, parsing the result,
 *    then closing the connection.
 *
 *    So we cache the results of an enumeration inside a pidl list.
 *    If the user does a REFRESH, then we toss the list and create
 *    a new one.
 *
 *    NOTE! that the WinINet API does not allow a FindFirst to be
 *    interrupted.  In other words, once you do an XboxFindFirst,
 *    you must read the directory to completion and close the
 *    handle before you can do anything else to the site.
 *
 *    As a result, we cannot use lazy evaluation on the enumerated
 *    contents.  (Not that it helps any, because WinINet will just
 *    do an "ls", parse the output, and then hand the items back
 *    one element at a time via XboxFindNext.  You may as well suck them
 *    all down the moment they're ready.)
 *
\*****************************************************************************/

#include "priv.h"
#include "xboxeidl.h"
#include "view.h"
#include "util.h"


/*****************************************************************************
 *
 *    We actually cache the result of the enumeration in the parent
 *    XboxDir, because XBOX enumeration is very expensive.
 *
 *    Since DVM_REFRESH forces us to re-enumerate, but we might have
 *    outstanding IEnumIDList's, we need to treat the object cache
 *    as yet another object that needs to be refcounted.
 *
 *****************************************************************************/


/*****************************************************************************
 *    _fFilter
 *
 *    Decides whether the file attributes agree with the filter criteria.
 *
 *    If hiddens are excluded, then exclude hiddens.  (Duh.)
 *
 *    Else, include or exclude based on folder/nonfolder-ness.
 *
 *    Let's look at that expression in slow motion.
 *
 *    "The attributes pass the filter if both...
 *        (1) it passes the INCLUDEHIDDEN criterion, and
 *        (2) it passes the FOLDERS/NONFOLDERS criterion.
 *
 *    The INCLUDEHIDDEN criterion is passed if FILE_ATTRIBUTE_HIDDEN
 *    implies SHCONTF_INCLUDEHIDDEN.
 *
 *    The FOLDERS/NONFOLDERS criterion is passed if the appropriate bit
 *    is set in the shcontf, based on the actual type of the file."
 *****************************************************************************/
BOOL CXboxEidl::_fFilter(DWORD shcontf, DWORD dwFAFLFlags)
{
    BOOL fResult = FALSE;

    if (shcontf & SHCONTF_FOLDERS)
        fResult |= dwFAFLFlags & FILE_ATTRIBUTE_DIRECTORY;

    if (shcontf & SHCONTF_NONFOLDERS)
        fResult |= !(dwFAFLFlags & FILE_ATTRIBUTE_DIRECTORY);

    if ((dwFAFLFlags & FILE_ATTRIBUTE_HIDDEN) && !(shcontf & SHCONTF_INCLUDEHIDDEN))
        fResult = FALSE;

    return fResult;
}


/*****************************************************************************\
 *    _AddFindDataToPidlList
 *
 *    Add information in a WIN32_FIND_DATA to the cache.
 *    Except that dot and dotdot don't go in.
\*****************************************************************************/
HRESULT CXboxEidl::_AddFindDataToPidlList(LPCITEMIDLIST pidl)
{
    HRESULT hr = E_FAIL;

    if (EVAL(m_pflHfpl))
    {
        ASSERT(IsValidPIDL(pidl));
        hr = m_pflHfpl->InsertSorted(pidl);
    }
    
    return hr;
}


/*****************************************************************************\
    FUNCTION: _HandleSoftLinks

    DESCRIPTION:
        A softlink is a file on an UNIX server that reference another file or
    directory.  We can detect these by the fact that (pwfd->dwFileAttribes == 0).
    If that is true, we have some work to do.  First we find out if it's a file
    or a directory by trying to ChangeCurrentWorking directories into it.  If we
    can we turn the dwFileAttributes from 0 to (FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_REPARSE_POINT).
    If it's just a softlink to a file, then we change it to
    (FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_REPARSE_POINT).  We later use the
    FILE_ATTRIBUTE_REPARSE_POINT attribute to put the shortcut overlay on it to
    que the user.

    RETURN VALUE:
        HRESULT - If FAILED() is returned, the item will not be added to the
                  list view.
\*****************************************************************************/
HRESULT CXboxEidl::_HandleSoftLinks(HINTERNET hint, LPITEMIDLIST pidl, LPWIRESTR pwCurrentDir, DWORD cchSize)
{
    HRESULT hr = S_OK;

    // Is it a softlink? It just came in off the wire and wininet returns 0 (zero)
    // for softlinks.  This function will determine if it's a SoftLink to a file
    // or a directory and then set FILE_ATTRIBUTE_REPARSE_POINT or
    // (FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_REPARSE_POINT) respectively.
    if (0 == XboxPidl_GetAttributes(pidl))
    {
        LPCWIRESTR pwWireFileName = XboxPidl_GetFileWireName(pidl);

        // Yes, so I will need to attempt to CD into that directory to test if it's a directory.
        // I need to get back because ".." won't work.  I will cache the return so I don't keep
        // getting it if there is a directory full of them.

        // Did we get the current directory yet?  This is the bread crums so I can
        // find my way back.
        if (!pwCurrentDir[0])
            EVAL(SUCCEEDED(XboxGetCurrentDirectoryWrap(hint, TRUE, pwCurrentDir, cchSize)));

        // Yes, so is it a directory?
        if (SUCCEEDED(XboxSetCurrentDirectoryPidlWrap(hint, TRUE, pidl, FALSE, FALSE)))  // Relative CD
        {
            // Does it have a virtual root?
            if (m_pfd->GetXboxSite()->HasVirtualRoot())
            {
                LPCITEMIDLIST pidlVirtualRoot = m_pfd->GetXboxSite()->GetVirtualRootReference();
                LPITEMIDLIST pidlSoftLinkDest = NULL;
                CWireEncoding * pwe = m_pfd->GetXboxSite()->GetCWireEncoding();

                // Yes, so we need to make sure this dir softlink doesn't point
                // outside of the virtual root, or it would cause invalid XBOX URLs.
                // File SoftLinks are fine because the old XBOX Code abuses XBOX URLs.
                // I'm just not ready to drop my morals just yet.
                if (EVAL(SUCCEEDED(XboxGetCurrentDirectoryPidlWrap(hint, TRUE, pwe, &pidlSoftLinkDest))))
                {
                    if (!XboxItemID_IsParent(pidlVirtualRoot, pidlSoftLinkDest))
                    {
                        // This is a Softlink or HardLink to a directory outside of the virtual root.
                        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);  // Skip this one.
                    }

                    ILFree(pidlSoftLinkDest);
                }
            }

            // Return to where we came from.
            //TraceMsg(TF_WININET_DEBUG, "_HandleSoftLinks XboxSetCurrentDirectory(%hs) worked", pwWireFileName);
            EVAL(SUCCEEDED(XboxSetCurrentDirectoryWrap(hint, TRUE, pwCurrentDir)));  // Absolute CD
            XboxPidl_SetAttributes(pidl, (FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_REPARSE_POINT));
            XboxPidl_SetFileItemType(pidl, TRUE);
        }
        else    // No, it's one of those files w/o extensions.
        {
            TraceMsg(TF_WININET_DEBUG, "_HandleSoftLinks XboxSetCurrentDirectory(%s) failed", pwWireFileName);
            XboxPidl_SetAttributes(pidl, (FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_REPARSE_POINT));
            XboxPidl_SetFileItemType(pidl, FALSE);
        }
    }

    return hr;
}


/*****************************************************************************\
 *    CXboxEidl::_PopulateItem
 *
 *    Fill a cache with stuff.
 *
 *    BUGBUG -- EEK!  Some Xbox servers (e.g., Xbox.funet.fi) run with ls -F!
 *    This means that things get "*" appended to them if they are executable.
\*****************************************************************************/
HRESULT CXboxEidl::_PopulateItem(HINTERNET hint0, HINTPROCINFO * phpi)
{
    HRESULT hr = S_OK;
    HINTERNET hint;
    LPITEMIDLIST pidl;
    CMultiLanguageCache cmlc;
    CWireEncoding * pwe = m_pfd->GetXboxSite()->GetCWireEncoding();

    if (phpi->psb)
    {
        phpi->psb->SetStatusMessage(IDS_LS, NULL);
        EVAL(SUCCEEDED(_SetStatusBarZone(phpi->psb, phpi->pfd->GetXboxSite())));
    }

    hr = XboxFindFirstFilePidlWrap(hint0, TRUE, &cmlc, pwe, NULL, &pidl, 
                (INTERNET_NO_CALLBACK | INTERNET_FLAG_DONT_CACHE | INTERNET_FLAG_RESYNCHRONIZE | INTERNET_FLAG_RELOAD), NULL, &hint);
    if (hint)
    {
        WIRECHAR wCurrentDir[MAX_PATH];   // Used for _HandleSoftLinks().

        wCurrentDir[0] = 0;
        if (EVAL(m_pff))
        {
            // It would be better to CoCreateInstance the History object by using
            // shell32!_SHCoCreateInstance() because it doesn't require COM.
            // If any more bugs are found, see if it's exported in Win95 and use it.           
            if (FAILED(m_hrOleInited))
            {
                // Win95's background enum thread doesn't call CoInitialize() so this AddToUrlHistory will fail.
                // We init it ourselves.
                m_hrOleInited = SHCoInitialize();
            }
            m_pff->AddToUrlHistory(m_pfd->GetPidlReference());
        }

        //TraceMsg(TF_XBOX_OTHER, "CXboxEidl::_PopulateItem() adding Name=%s", wCurrentDir);
        if (pidl && SUCCEEDED(_HandleSoftLinks(hint0, pidl, wCurrentDir, ARRAYSIZE(wCurrentDir))))
            hr = _AddFindDataToPidlList(pidl);

        ILFree(pidl);
        while (SUCCEEDED(hr))
        {
            hr = InternetFindNextFilePidlWrap(hint, TRUE, &cmlc, pwe, &pidl);
            if (SUCCEEDED(hr))
            {
                //TraceMsg(TF_XBOX_OTHER, "CXboxEidl::_PopulateItem() adding Name=%hs", XboxPidl_GetLastItemWireName(pidl));
                // We may decide to not add it for some reasons.
                if (SUCCEEDED(_HandleSoftLinks(hint0, pidl, wCurrentDir, ARRAYSIZE(wCurrentDir))))
                    hr = _AddFindDataToPidlList(pidl);

                ILFree(pidl);
            }
            else
            {
                // We failed to get the next file.
                if (HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES) != hr)
                {
                    DisplayWininetError(phpi->hwnd, TRUE, HRESULT_CODE(hr), IDS_XBOXERR_TITLE_ERROR, IDS_XBOXERR_FOLDERENUM, IDS_XBOXERR_WININET, MB_OK, NULL);
                    hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);       // Clean error to indicate we already displayed the error and don't need to do it later.
                }
                else
                    hr = S_OK;        // That's fine if there aren't any more files to get

                break;    // We are done here.
            }
        }

        EVAL(SUCCEEDED(pwe->ReSetCodePages(&cmlc, m_pflHfpl)));
        InternetCloseHandle(hint);
    }
    else
    {
        // This will happen in two cases.
        // 1. The folder is empty. (GetLastError() == ERROR_NO_MORE_FILES)
        // 2. The user doesn't have enough access to view the folder. (GetLastError() == ERROR_INTERNET_EXTENDED_ERROR)
        if (HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES) != hr)
        {
            DisplayWininetError(phpi->hwnd, TRUE, HRESULT_CODE(hr), IDS_XBOXERR_TITLE_ERROR, IDS_XBOXERR_OPENFOLDER, IDS_XBOXERR_WININET, MB_OK, NULL);
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);       // Clean error to indicate we already displayed the error and don't need to do it later.
            WININET_ASSERT(SUCCEEDED(hr));
        }
        else
            hr = S_OK;

        TraceMsg(TF_XBOX_IDENUM, "CXboxEnum_New() - Can't opendir. hres=%#08lx.", hr);
    }

    if (phpi->psb)
        phpi->psb->SetStatusMessage(IDS_EMPTY, NULL);

    return hr;
}


/*****************************************************************************\
 *    CXboxEidl::_Init
\*****************************************************************************/
HRESULT CXboxEidl::_Init(void)
{
    HRESULT hr = S_FALSE;
    
    ASSERT(m_pfd);
    IUnknown_Set(&m_pflHfpl, NULL);
    m_pflHfpl = m_pfd->GetHfpl();       // Use cached copy if it exists.

    if (m_pflHfpl)
    {
        // We will just use the previous copy because we already have the contents.
        // TODO: Maybe we want to purge the results if a certain amount of time as ellapsed.
        m_fInited = TRUE;
        hr = S_OK;
    }
    else if (!m_pfd->GetXboxSite()->IsSiteBlockedByRatings(m_hwndOwner))
    {
        CXboxPidlList_Create(0, NULL, &m_pflHfpl);
        if (EVAL(m_pflHfpl))
        {
            CStatusBar * psb = GetCStatusBarFromDefViewSite(_punkSite);

            ASSERT(!m_pfd->IsRoot());
            //TraceMsg(TF_ALWAYS, "CXboxEidl::_Init() and enumerating");
            hr = m_pfd->WithHint(psb, m_hwndOwner, CXboxEidl::_PopulateItemCB, this, _punkSite, m_pff);
            if (SUCCEEDED(hr))
            {
                m_pfd->SetCache(m_pflHfpl);
                m_fInited = TRUE;
                hr = S_OK;
            }
            else
                IUnknown_Set(&m_pflHfpl, NULL);
        }
    }

    return hr;
}


/*****************************************************************************
 *    CXboxEidl::_NextOne
 *****************************************************************************/
LPITEMIDLIST CXboxEidl::_NextOne(DWORD * pdwIndex)
{
    LPITEMIDLIST pidl = NULL;
    LPITEMIDLIST pidlResult = NULL;

    if (m_pflHfpl)
    {
        while ((*pdwIndex < (DWORD) m_pflHfpl->GetCount()) && (pidl = m_pflHfpl->GetPidl(*pdwIndex)))
        {
            ASSERT(IsValidPIDL(pidl));
            (*pdwIndex)++;

            if (_fFilter(m_shcontf, XboxPidl_GetAttributes(pidl)))
            {
                pidlResult = ILClone(pidl);
                break;  // We don't need to search any more.
            }
        }
    }

    return pidlResult;
}


//===========================
// *** IEnumIDList Interface ***
//===========================

/*****************************************************************************
 *
 *    IEnumIDList::Next
 *
 *    Creates a brand new enumerator based on an existing one.
 *
 *
 *    OLE random documentation of the day:  IEnumXXX::Next.
 *
 *    rgelt - Receives an array of size celt (or larger).
 *
 *    "Receives an array"?  No, it doesn't receive an array.
 *    It *is* an array.  The array receives *elements*.
 *
 *    "Or larger"?  Does this mean I can return more than the caller
 *    asked for?  No, of course not, because the caller didn't allocate
 *    enough memory to hold that many return values.
 *
 *    No semantics are assigned to the possibility of celt = 0.
 *    Since I am a mathematician, I treat it as vacuous success.
 *
 *    pcelt is documented as an INOUT parameter, but no semantics
 *    are assigned to its input value.
 *
 *    The dox don't say that you are allowed to return *pcelt < celt
 *    for reasons other than "no more elements", but the shell does
 *    it everywhere, so maybe it's legal...
 *
 *****************************************************************************/
HRESULT CXboxEidl::Next(ULONG celt, LPITEMIDLIST * rgelt, ULONG *pceltFetched)
{
    HRESULT hr = S_OK;
    LPITEMIDLIST pidl = NULL;
    DWORD dwIndex;
    // The shell on pre-NT5 enums us w/o ole initialized which causes problems
    // when we call CoCreateInstance().  This happens in the thunking code
    // of encode.cpp when thunking strings.
    HRESULT hrOleInit = SHOleInitialize(0);

    if (m_fDead)
        return E_FAIL;

    if (!m_fInited)
    {
        hr = _Init();
        if (FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr))
        {
            // Did we need to redirect because of a new password or username?
            if (HRESULT_FROM_WIN32(ERROR_NETWORK_ACCESS_DENIED) == hr)
            {
                m_fDead = TRUE;
                hr = E_FAIL;
            }
            else if (!m_fErrorDisplayed)
            {
                DisplayWininetError(m_hwndOwner, FALSE, HRESULT_CODE(hr), IDS_XBOXERR_TITLE_ERROR, IDS_XBOXERR_GETDIRLISTING, IDS_XBOXERR_WININET, MB_OK, NULL);
                m_fErrorDisplayed = TRUE;
            }
        }
    }

    if (S_OK == hr)
    {
        // Do they want more and do we have more to give?
        for (dwIndex = 0; (dwIndex < celt) && (pidl = _NextOne(&m_nIndex)); dwIndex++)
            rgelt[dwIndex] = pidl;  // Yes, so give away...

        if (pceltFetched)
            *pceltFetched = dwIndex;

        // Were we able to give any?
        if (0 == dwIndex)
            hr = S_FALSE;
    }

    SHOleUninitialize(hrOleInit);
    return hr;
}


/*****************************************************************************
 *    IEnumIDList::Skip
 *****************************************************************************/

HRESULT CXboxEidl::Skip(ULONG celt)
{
    m_nIndex += celt;

    return S_OK;
}


/*****************************************************************************
 *    IEnumIDList::Reset
 *****************************************************************************/

HRESULT CXboxEidl::Reset(void)
{
    m_fErrorDisplayed = FALSE;
    if (!m_fInited)
        _Init();

    m_nIndex = 0;
    return S_OK;
}


/*****************************************************************************\
 *    IEnumIDList::Clone
 *
 *    Creates a brand new enumerator based on an existing one.
\*****************************************************************************/
HRESULT CXboxEidl::Clone(IEnumIDList **ppenum)
{
    return CXboxEidl_Create(m_pfd, m_pff, m_hwndOwner, m_shcontf, m_nIndex, ppenum);
}


/*****************************************************************************\
 *    CXboxEidl_Create
 *
 *    Creates a brand new enumerator based on an Xbox site.
\*****************************************************************************/
HRESULT CXboxEidl_Create(CXboxDir * pfd, CXboxFolder * pff, HWND hwndOwner, DWORD shcontf, IEnumIDList ** ppenum)
{
    CXboxEidl * pfe;
    HRESULT hres = CXboxEidl_Create(pfd, pff, hwndOwner, shcontf, &pfe);

    *ppenum = NULL;
    if (EVAL(pfe))
    {
        hres = pfe->QueryInterface(IID_IEnumIDList, (LPVOID *) ppenum);
        pfe->Release();
    }

    return hres;
}


/*****************************************************************************
 *
 *    CXboxEidl_Create
 *
 *    Creates a brand new enumerator based on an Xbox site.
 *
 *****************************************************************************/

HRESULT CXboxEidl_Create(CXboxDir * pfd, CXboxFolder * pff, HWND hwndOwner, DWORD shcontf, CXboxEidl ** ppfe)
{
    CXboxEidl * pfe = new CXboxEidl();
    HRESULT hr = E_OUTOFMEMORY;

    ASSERT(pfd && pff && ppfe);
    *ppfe = pfe;
    if (EVAL(pfe))
    {
        ATOMICRELEASE(pfe->m_pm);
        pfe->m_pm = pff->GetIMalloc();

        IUnknown_Set(&pfe->m_pff, pff);
        IUnknown_Set(&pfe->m_pfd, pfd);
        pfe->m_pflHfpl = pfd->GetHfpl();

        pfe->m_shcontf = shcontf;
        pfe->m_hwndOwner = hwndOwner;

    }

    return hr;
}


/*****************************************************************************\
 *    CXboxEidl_Create
 *
 *    Creates a brand new enumerator based on an Xbox site.
\*****************************************************************************/
HRESULT CXboxEidl_Create(CXboxDir * pfd, CXboxFolder * pff, HWND hwndOwner, DWORD shcontf, DWORD dwIndex, IEnumIDList ** ppenum)
{
    CXboxEidl * pfe;
    HRESULT hres = CXboxEidl_Create(pfd, pff, hwndOwner, shcontf, &pfe);

    if (EVAL(SUCCEEDED(hres)))
    {
        pfe->m_nIndex = dwIndex;

        hres = pfe->QueryInterface(IID_IEnumIDList, (LPVOID *) ppenum);
        ASSERT(SUCCEEDED(hres));

        pfe->Release();
    }

    return hres;
}


/****************************************************\
    Constructor
\****************************************************/
CXboxEidl::CXboxEidl() : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_fInited);
    ASSERT(!m_nIndex);
    ASSERT(!m_shcontf);
    ASSERT(!m_pflHfpl);
    ASSERT(!m_pfd);
    ASSERT(!m_pm);
    ASSERT(!m_hwndOwner);
    ASSERT(!m_fInited);
    ASSERT(!m_fDead);

    m_hrOleInited = E_FAIL;
    LEAK_ADDREF(LEAK_CXboxEidl);
}


/****************************************************\
    Destructor
\****************************************************/
CXboxEidl::~CXboxEidl()
{
    IUnknown_Set(&m_pflHfpl, NULL);
    IUnknown_Set(&m_pm, NULL);
    IUnknown_Set(&m_pfd, NULL);
    IUnknown_Set(&m_pff, NULL);

    DllRelease();
    LEAK_DELREF(LEAK_CXboxEidl);
    SHCoUninitialize(m_hrOleInited);
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CXboxEidl::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CXboxEidl::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CXboxEidl::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IEnumIDList))
    {
        *ppvObj = SAFECAST(this, IEnumIDList*);
    }
    else if (IsEqualIID(riid, IID_IObjectWithSite))
    {
        *ppvObj = SAFECAST(this, IObjectWithSite*);
    }
    else
    {
        TraceMsg(TF_XBOXQI, "CXboxEidl::QueryInterface() failed.");
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxfldr.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    xboxfldr.cpp

Abstract:

    Implementation of CXboxFolder.  This code was originally taken of from CFtpFolder; however,
    the changes will be numerous.  The FTP code relied a lot on wininet services that
    don't do what we need.  Fortunately, much of the shell extension API has been publically
    documented since the FTP code was written.   This will help a lot.

History:

    Mitchell S. Dernis (mitchd) 2-Feb-2001 - begin modifications for Xbox

Environment:

    Windows 2000 (or higher) shell exentions DLL

Original File Header Comments (from FTP code):
    
    _UNDOCUMENTED_:  The shell violates Apartment model threading
    when doing background enumeration, so even though this DLL is
    marked as Apartment model, IShellFolder and IEnumIDList must
    be written with the free threading model with respect to anything
    that IEnumIDList can do in the background.
 
    This means that you'll see lots of ENTER_CRITICAL() and
    LEAVE_CRITICAL() calls when your brain would say, "I don't
    need to do that because I'm Apartment-model."  I'll try to
    point them out as they occur; look for the marker _MT_.
 
    CAUTION!  Internally, our property sheet handler also invokes
    methods on CXboxFolder on the wrong thread, so it's not just the
    shell that is weird.

--*/

#include "priv.h"
#include "xboxfldr.h"
#include "xboxurl.h"
#include "xboxpidl.h"
#include "xboxicon.h"
#include "view.h"
#include "proxycache.h"
#include <idhidden.h>

#define FEATURE_SOFTLINK_SHORTCUT_ICONOVERLAY

// {A11501B3-6EA4-11d2-B679-006097DF5BD4}   Private to xbnmspc.dll
const GUID IID_CXboxFolder = { 0xa11501b3, 0x6ea4, 0x11d2, { 0xb6, 0x79, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4 } };


/*****************************************************************************
 *
 *    More const statics.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

WORD c_wZero = 0;        /* As promised in xboxview.h */

/*
 *  String separator used when building relative names.
 */
char c_szSlash[] = "/";


#pragma END_CONST_DATA


HRESULT CXboxFolder::AddToUrlHistory(LPCITEMIDLIST pidl)
{
    /*    
    HRESULT hr = UrlCreateFromPidlW(pidl, SHGDN_FORPARSING, wzUrl, ARRAYSIZE(wzUrl), (ICU_ESCAPE | ICU_USERNAME), TRUE);

    // BUGBUG This is used across threads, so make it thread safe.    
    if (EVAL(SUCCEEDED(hr)))
        EVAL(SUCCEEDED(hr = _AddToUrlHistory(wzUrl)));

    if (!m_puhs)
        hr = CoCreateInstance(CLSID_CUrlHistory, NULL, CLSCTX_INPROC_SERVER, IID_IUrlHistoryStg, (void **)&m_puhs);

    if (EVAL(m_puhs))
        EVAL(SUCCEEDED(hr = m_puhs->AddUrl(pwzUrl, pwzUrl, 0)));

    return hr;*/
    return E_NOTIMPL;
}


CWireEncoding * CXboxFolder::GetCWireEncoding(void)
{
    // GetXboxDir() may return NULL when we aren't rooted in an XBOX server.
    CXboxDir * pfd = GetXboxDir();
    CWireEncoding * pwe = NULL;

    if (pfd)
    {
        pwe = pfd->GetXboxSite()->GetCWireEncoding();
        pfd->Release();
    }

    return pwe;
}

/*****************************************************************************
 *
 *    InvalidateCache
 *
 *    Invalidate the pflHfpl cache in the corresponding XboxDir.
 *
 *    _MT_:  Note that the background enumerator calls this, so it must be
 *    multithread-safe.
 *
 *****************************************************************************/

void CXboxFolder::InvalidateCache(void)
{
    CXboxDir * pfd = GetXboxDir();

    if (EVAL(pfd))
    {
        // Should have created one on the GetHint()
        pfd->SetCache(0);
        pfd->Release();
    }
}


HRESULT CXboxFolder::_InitXboxSite(void)
{
    HRESULT hr = S_OK;

    if (!m_pfs)         // If we don't already got one...
    {
        ENTERCRITICAL;
        if (!m_pfs)            // Did it get created while we were waiting
        {
            if (EVAL(GetPrivatePidlReference()))
                hr = SiteCache_PidlLookup(GetPrivatePidlReference(), TRUE, m_pm, &m_pfs);
            else
            {
                // Not initialized
                TraceMsg(TF_XBOXISF, "CXboxFolder_GetXboxDir(%08x) NOT INITED", this);
                hr = E_FAIL;
            }
        }

        LEAVECRITICAL;
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: GetXboxDir

    DESCRIPTION:
        Say where our dir info is.

    We allocate the pfd only if somebody actually needs it, because
    Explorer does a lot of ILCompare's when you open a new folder,
    each of which creates a new IShellFolder for the sole purpose
    of calling CompareIDs.  We don't want to go through all the
    hubbub of creating an XboxDir and XboxSite when we don't need one.

    _MT_:  Note that the background enumerator calls this, so it must be
    multithread-safe.  In such case, however, the IShellFolder is
    marked cBusy, so we don't have to worry about the this->pfd
    getting wiped out behind our back by a change of identity.
\*****************************************************************************/
CXboxDir * CXboxFolder::GetXboxDir(void)
{
    HRESULT hres = S_OK;
    CXboxDir * pfd = NULL;

    _InitXboxSite(); // Okay if it fails.
    if (m_pfs)
        hres = m_pfs->GetXboxDir(GetPrivatePidlReference(), &pfd);

    return pfd;
}



CXboxDir * CXboxFolder::GetXboxDirFromPidl(LPCITEMIDLIST pidl)
{
    HRESULT hres = S_OK;
    CXboxDir * pfd = NULL;
    CXboxSite * pfs = NULL;

    hres = SiteCache_PidlLookup(pidl, FALSE, m_pm, &pfs);
    if (pfs)
    {
        hres = pfs->GetXboxDir(pidl, &pfd);
        pfs->Release();
    }

    return pfd;
}


CXboxDir * CXboxFolder::GetXboxDirFromUrl(LPCTSTR pszUrl)
{
    LPITEMIDLIST pidl;
    CXboxDir * pfd = NULL;

    if (EVAL(SUCCEEDED(CreateXboxPidlFromUrl(pszUrl, GetCWireEncoding(), NULL, &pidl, m_pm, FALSE))))
    {
        _InitXboxSite(); // Okay if it fails.
        m_pfs->GetXboxDir(pidl, &pfd);
        ILFree(pidl);
    }

    return pfd;
}


/*****************************************************************************\
 *    GetItemAllocator
 *
 *    Return today's pidl allocator.
\*****************************************************************************/
HRESULT CXboxFolder::GetItemAllocator(IMalloc **ppm)
{
    HRESULT hr = E_FAIL;

    *ppm = NULL;
    if (EVAL(m_pm))
    {
        IUnknown_Set(ppm, m_pm);
        hr = S_OK;
    }
    else
        TraceMsg(TF_XBOXISF, "CXboxFolder_GetItemAllocator(%08x) NOT INITED", this);

    return hr;
}


/*****************************************************************************\
    FUNCTION: GetUIObjectOfHfpl

    DESCRIPTION:
        _UNDOCUMENTED_:  Nowhere is there a list of interfaces
    that "should be" supported.  You just have to add lots of
    squirties and see what interfaces are asked for.

      _UNDOCUMENTED_:  Nowhere is it mentioned that passing
    cidl = 0 (or the various other weird variants) means to
    get a UI object on the folder itself.

    _UNDOCUMENTED_:  It is not mentioned whether the folder should
    be expected to handle cidl != 1 when asked for an IExtractIcon.
    I code defensively and handle the situation properly.

    IExtractIcon(0) extracts the icon for the folder itself.
    IExtractIcon(1) extracts the icon for the indicated pidl.
    IExtractIcon(n) extracts a generic "multi-document" icon.

    IContextMenu(0) produces a context menu for the folder itself.
        (Not used by the shell, but used by ourselves internally.)
    IContextMenu(n) produces a context menu for the multi-selection.

    IDataObject(0) ?? doesn't do anything
    IDataObject(n) produces a data object for the multi-selection.

    IDropTarget(0) produces a droptarget for the folder itself.
        (Not used by the shell, but used by ourselves internally.)
    IDropTarget(1) produces a droptarget for the single item.

    IShellView(0) ?? doesn't do anything
    IShellView(1) produces a shellview for the single item.
        (Nobody tries this yet, but I'm ready for it.)
\*****************************************************************************/
HRESULT CXboxFolder::GetUIObjectOfHfpl(HWND hwndOwner, CXboxPidlList * pflHfpl, REFIID riid, LPVOID * ppvObj, BOOL fFromCreateViewObject)
{
    HRESULT hr = E_INVALIDARG;

    if (IsEqualIID(riid, IID_IExtractIconA) ||
        IsEqualIID(riid, IID_IExtractIconW) ||
        IsEqualIID(riid, IID_IQueryInfo))
    {
        hr = CXboxIcon_Create(this, pflHfpl, riid, ppvObj);
        //TraceMsg(TF_XBOXISF, "CXboxFolder::GetUIObjectOfHfpl() CXboxIcon_Create() hr=%#08lx", hr);
        ASSERT(SUCCEEDED(hr));
    }
    else if (IsEqualIID(riid, IID_IContextMenu))
    {
        hr = CXboxMenu_Create(this, pflHfpl, hwndOwner, riid, ppvObj, fFromCreateViewObject);
        TraceMsg(TF_XBOXISF, "CXboxFolder::GetUIObjectOfHfpl() CXboxMenu_Create() hr=%#08lx", hr);
        ASSERT(SUCCEEDED(hr));
    }
    else if (IsEqualIID(riid, IID_IDataObject))
    {
        hr = CXboxObj_Create(this, pflHfpl, riid, ppvObj);
        TraceMsg(TF_XBOXISF, "CXboxFolder::GetUIObjectOfHfpl() CXboxObj_Create() hr=%#08lx", hr);
        ASSERT(SUCCEEDED(hr));
    }
    else if (IsEqualIID(riid, IID_IDropTarget))
    {
        // This will fail when someone gets a property sheet on an XBOX PIDL Shortcut
        // that has a file as the destination.
        hr = CreateSubViewObject(hwndOwner, pflHfpl, riid, ppvObj);
        TraceMsg(TF_XBOXISF, "CXboxFolder::GetUIObjectOfHfpl() CreateSubViewObject() hr=%#08lx", hr);
    }
    else if (IsEqualIID(riid, IID_IShellView))
    {
        ASSERT(0);  // Shouldn't happen
    }
    else if (IsEqualIID(riid, IID_IQueryAssociations))
    {
        IQueryAssociations * pqa;
        
        hr = AssocCreate(CLSID_QueryAssociations, IID_IQueryAssociations, (void **)&pqa);
        if (SUCCEEDED(hr))
        {
            hr = pqa->Init(0, L"Folder", NULL, NULL);

            if (SUCCEEDED(hr))
                *ppvObj = (void *)pqa;
            else
                pqa->Release();
        }
    }
    else
    {
        //TraceMsg(TF_XBOXISF, "CXboxFolder::GetUIObjectOfHfpl() E_NOINTERFACE");
        hr = E_NOINTERFACE;
    }

    if (FAILED(hr))
        *ppvObj = NULL;

    ASSERT_POINTER_MATCHES_HRESULT(*ppvObj, hr);
    return hr;
}


static const LPCTSTR pszBadAppArray[] = {TEXT("aol.exe"), TEXT("waol.exe"), TEXT("msnviewr.exe"), TEXT("cs3.exe"), TEXT("msdev.exe")};

/*****************************************************************************\
    FUNCTION: IsAppXBOXCompatible

    DESCRIPTION:
        Some apps (WebOC hosts) fail to navigate to XBOX directories.
    We check the app here and see if it's one of those incompatible apps.

    I don't worry about perf because we can do the work only once and cache
    the result because our globals will be re-inited for each process.

    GOOD:
    ========================================================================
    iexplore.exe:   Good of course.
    explorer.exe:   Good of course.
    msdev.exe (v6): The HTML help works but folder navigations happen in
                    a new window.  I don't care because the same happens in
                    the shell (File System case).
    <Default Case>: These are apps built with VB's WebOC that work fine, but
                    they also have the open in new folder behavior.

    BAD and UGLY:
    ========================================================================
    msdev.exe (v5): You can navigate their Moniker help to XBOX which will
                    cause a hang.
    [MSN] (msnviewr.exe): For some reason MSN calls IPersistFolder::Initialize with an invalid value.
           Navigating to the folder works but launching other folders cause them
           to appear in their own window and they immediately close.  This was
           on browser only so it may be because internet delegate folders aren't
           supported.

    [aol]: (waol.exe) This doesn't work either.
    cs3.exe (CompuServ): ????
    [ATT WorldNet]: ????
    [Protigy]: ????
    [SNAP]: ????
\*****************************************************************************/
BOOL IsAppXBOXCompatible(void)
{
    static BOOL s_fIsAppCompatible;
    static BOOL s_fIsResultCached = FALSE;
//
    if (!s_fIsResultCached)
    {
        TCHAR szAppPath[MAX_PATH];

        s_fIsAppCompatible = TRUE;  // Assume all Web OC Hosts are fine...

        if (EVAL(GetModuleFileName(NULL, szAppPath, ARRAYSIZE(szAppPath))))
        {
            int nIndex;
            LPTSTR pszAppFileName = PathFindFileName(szAppPath);

            for (nIndex = 0; nIndex < ARRAYSIZE(pszBadAppArray); nIndex++)
            {
                if (!StrCmpI(pszAppFileName, pszBadAppArray[nIndex]))
                {
                    // This one is bad/
                    s_fIsAppCompatible = FALSE;
                    break;
                }
            }
        }

        s_fIsResultCached = TRUE;
    }

    return s_fIsAppCompatible;
}


/*****************************************************************************\
    FUNCTION: CreateSubViewObject

    DESCRIPTION:
        Somebody is asking for a UI object of a subobject, which is
    better handled by the subobject than by the parent.

    Bind to the subobject and get the requested UI object thence.

    If the pidl list is empty, then we are talking about ourselves again.
\*****************************************************************************/
HRESULT CXboxFolder::CreateSubViewObject(HWND hwndOwner, CXboxPidlList * pflHfpl, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hr = E_INVALIDARG;
    DWORD dwItemsSelected = pflHfpl->GetCount();
    IShellFolder * psf = NULL;

    if (EVAL(ppvObj))             // I wouldn't be surprised if
        *ppvObj = NULL;            // somebody relied on this

    if (1 == dwItemsSelected)
    {
        LPITEMIDLIST pidl = pflHfpl->GetPidl(0);    // This doesn't clone the pidl so we don't need to free it.
        if (EVAL(pidl))
            hr = BindToObject(pidl, 0, IID_IShellFolder, (LPVOID *)&psf);
    }
    else if (EVAL(0 == dwItemsSelected))
        hr = this->QueryInterface(IID_IShellFolder, (void **) &psf);

    ASSERT_POINTER_MATCHES_HRESULT(psf, hr);
    if (EVAL(SUCCEEDED(hr)))
    {
        // CreateViewObject will AddRef the psfT if it wants it
        hr = psf->CreateViewObject(hwndOwner, riid, ppvObj);
    }
    
    ASSERT_POINTER_MATCHES_HRESULT(*ppvObj, hr);
    ATOMICRELEASE(psf);
    return  hr;
}



/*****************************************************************************\
      GetSiteMotd
\*****************************************************************************/

CXboxGlob * CXboxFolder::GetSiteMotd(void)
{
    CXboxGlob * pGlob = NULL;

    _InitXboxSite(); // Okay if it fails.
    if (m_pfs)
        pGlob = m_pfs->GetMotd();

    return pGlob;
}


HRESULT CXboxFolder::_Initialize(LPCITEMIDLIST pidlTarget, LPCITEMIDLIST pidlRoot, int nBytesToPrivate)
{
    IUnknown_Set(&m_pfs, NULL);
    return CBaseFolder::_Initialize(pidlTarget, pidlRoot, nBytesToPrivate);
}


// Sometimes the user will enter incorrect information without knowing.
// We would catch this if we verified everything that was entered, but
// we don't, we just take it on faith until we do the IEnumIDList.
// This is great for perf but sucks for catching these kinds of things.
// An example of this is the user using the File.Open dialog and going to
// "xbox://myserver/dir/".  They then enter "xbox://myserver/dir/file.txt"
// which will try to parse relative but it's an absolute path.
HRESULT CXboxFolder::_FilterBadInput(LPCTSTR pszUrl, LPITEMIDLIST * ppidl)
{
    HRESULT hr = S_OK;

    // If pidlPrivate isn't empty, then we aren't at the
    // root, so reject any urls that are absolute (i.e. have
    // ftp: scheme).
    if (!IsRoot() && (URL_SCHEME_FTP == GetUrlScheme(pszUrl)))
        hr = E_FAIL;
    // More may come here...

    if (FAILED(hr) && *ppidl)
        Pidl_Set(ppidl, NULL);

    return hr;
}


/*****************************************************************************\
    FUNCTION: _ForPopulateAndEnum

    DESCRIPTION:
        This function exists to detect the following case and if it's true,
    populate the cache (pfd) and return the pidl from that cache in ppidl.

     There is one last thing we need to try, we need to detect if:
    1) the URL has an URL path, and 
    2) the last item in the path doesn't have an extension and doesn't
       end in a slash ('/') to indicate it's a directory.
    If this case is true, we then need to find out if it is a directory
    or file by hitting the server.  This is needed because by the time
    we bind, it's too late to fall back to the other thing (IEnumIDList).
    The one thing we might need to be careful about is AutoComplete because
    they may call :: ParseDisplayName() for every character a user types.
    This won't be so bad because it's on a background thread, asynch, and
    the first enum within a segment will cause the cache to be populated
    within a that segment so subsequent enums will be fast.  The problem
    it that it's not uncommon for users to enter between 2 and 5 segments,
    and there would be 1 enum per segment.
\*****************************************************************************/
HRESULT CXboxFolder::_ForPopulateAndEnum(CXboxDir * pfd, LPCITEMIDLIST pidlBaseDir, LPCTSTR pszUrl, LPCWIRESTR pwLastDir, LPITEMIDLIST * ppidl)
{
    HRESULT hr = E_FAIL;

    *ppidl = NULL;
    // We only care if the URL Path isn't empty AND it doesn't end in a '/' AND
    // it doesn't have an extension.
    if (!ILIsEmpty(pfd->GetPathPidlReference()) && (0 == *PathFindExtensionA(pwLastDir)))
    {
        IEnumIDList * penumIDList;

        // NULL hwnd needs to suppress all UI.
        hr = CXboxEidl_Create(pfd, this, NULL, (SHCONTF_FOLDERS | SHCONTF_NONFOLDERS | SHCONTF_INCLUDEHIDDEN), &penumIDList);
        if (EVAL(SUCCEEDED(hr)))
        {
            hr = penumIDList->Reset();
            ASSERT(SUCCEEDED(hr));
            // We are working off of the assumption that calling Reset will force it to hit the server and pull down all of the contents.

            LPITEMIDLIST pidlFromCache = (LPITEMIDLIST) pfd->GetPidlFromWireName(pwLastDir);
            if (pidlFromCache)
            {
                // It was found, this means that it exists now in the cache after we
                // forced it to be populated.
                *ppidl = ILCombine(pidlBaseDir, pidlFromCache);
                ILFree(pidlFromCache);
            }
            else
                hr = E_FAIL;

            penumIDList->Release();
        }
    }

    return hr;
}


HRESULT CXboxFolder::_GetCachedPidlFromDisplayName(LPCTSTR pszDisplayName, LPITEMIDLIST * ppidl)
{
    HRESULT hr = E_FAIL;
    if (ppidl)
    {
        CXboxDir * pfd = GetXboxDir();

        if (pfd)
        {
            // We may have a pointer but the cache may still be empty, as in case NT #353324
            CXboxPidlList * pfl = pfd->GetHfpl();
            if (pfl)
            {
                // Yes, so we will continue to use the cache.  Now let's get rid of that
                // temp pointer.
                pfl->Release();
            }
            else
            {
                // No we don't have it cashed, so pretend the pfd was returned NULL.
                pfd->Release();
                pfd = NULL;
            }
        }

        *ppidl = NULL;
        if (!pfd)
        {
            LPITEMIDLIST pidlBaseDir;

            hr = CreateXboxPidlFromUrl(pszDisplayName, GetCWireEncoding(), NULL, &pidlBaseDir, m_pm, FALSE);
            if (SUCCEEDED(hr))  // May fail because of AutoComplete.
            {
                // If it's not pointing to just a server, then we can enum the contents and
                // find out if it's is a file or directory.
                if (!ILIsEmpty(pidlBaseDir) && !XboxID_IsServerItemID(ILFindLastID(pidlBaseDir)))
                {
                    CXboxSite * pfs;
            
                    hr = SiteCache_PidlLookup(pidlBaseDir, TRUE, m_pm, &pfs);
                    if (EVAL(SUCCEEDED(hr)))
                    {
                        LPCWIRESTR pwLastDirName;

                        // If we are using a hidden password, then ::GetDisplayNameOf() hands out
                        // these "xbox://user@server/dir/" URLs and the password is hidden.  If
                        // :: ParseDisplayName() is given one of these URLs and we are currently in
                        // that server w/that user name, then :: ParseDisplayNameOf() needs to hand
                        // out a pidl with the correct hidden password cookie.
                        //
                        // Is pidlNav the same as GetPublicRootPidlReference() except pidlNav doesn't
                        // have a password.  The same means that the servers match, and the user names
                        // match.
                        EVAL(SUCCEEDED(pfs->UpdateHiddenPassword(pidlBaseDir)));

                        // This is sneaky because pwLastDirName will point into them itemID
                        // that will be removed.  The memory won't really be removed, it will
                        // just have the size set to zero.
                        pwLastDirName = XboxPidl_GetLastItemWireName(pidlBaseDir);

                        ILRemoveLastID(pidlBaseDir);
                        pfs->GetXboxDir(pidlBaseDir, &pfd);

                        if (pfd)
                        {
                            LPITEMIDLIST pidlFromCache = (LPITEMIDLIST) pfd->GetPidlFromWireName(pwLastDirName);
                            if (pidlFromCache)
                            {
                                // It was found, this means we were probably in xbox://serverX/Dir1/
                                // and the user entered something from that directory or another directory
                                // taht we have alread displayed to the user and it's in our cache.
                                *ppidl = ILCombine(pidlBaseDir, pidlFromCache);
                                ILFree(pidlFromCache);
                                hr = S_OK;
                            }
                            else
                            {
                                // There is one last thing we need to try, we need to detect if:
                                // 1) the URL has an URL path, and 
                                // 2) the last item in the path doesn't have an extension and doesn't
                                //    end in a slash ('/') to indicate it's a directory.
                                // If this case is true, we then need to find out if it is a directory
                                // or file by hitting the server.  This is needed because by the time
                                // we bind, it's too late to fall back to the other thing (IEnumIDList).
                                // The one thing we might need to be careful about is AutoComplete because
                                // they may call :: ParseDisplayName() for every character a user types.
                                // This won't be so bad because it's on a background thread, asynch, and
                                // the first enum within a segment will cause the cache to be populated
                                // within a that segment so subsequent enums will be fast.  The problem
                                // it that it's not uncommon for users to enter between 2 and 5 segments,
                                // and there would be 1 enum per segment.
                                hr = _ForPopulateAndEnum(pfd, pidlBaseDir, pszDisplayName, pwLastDirName, ppidl);
                            }


                            pfd->Release();
                        }
                        else
                            hr = E_FAIL;

                        pfs->Release();
                    }
                    else
                        hr = E_FAIL;
                }
                else
                    hr = E_FAIL;

                ILFree(pidlBaseDir);
            }
        }
        else
        {
            //    Create a new enumeration object for the caller.
            // PERF: log 2 (sizeof(m_pflHfpl))
            *ppidl = (LPITEMIDLIST) pfd->GetPidlFromDisplayName(pszDisplayName);
            if (*ppidl)
            {
                hr = S_OK;
            }
            else
            {
                // If we got here, the cache for this directory is populated.
                // So if the name doesn't match, then either:
                // 1) it doesn't exist,
                // 2) the cache is out of date, or
                // 3) it's multilevel, (like "dir1\dir2\dir3") or
                // 4) It's a weird parsing token that our parent parse should have remoted, like "..", ".", "\", etc.
                // We will assome our parent parse takes care of #4, and #2 isn't true.

                // Is this multilevel? (Case #3)
                if (!StrChr(pszDisplayName, TEXT('/')))
                {
                    // No, so reject it and don't let our caller blindly accept it.
                    hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                }
            }

            pfd->Release();
        }
    }

    return hr;
}


HRESULT CXboxFolder::_GetBindCtx(IBindCtx ** ppbc)
{
    HRESULT hr = CreateBindCtx(NULL, ppbc);

    if (SUCCEEDED(hr))	// Can fail with out of memory
    {
        hr = (*ppbc)->RegisterObjectParam(STR_SKIP_BINDING_CLSID, SAFECAST(this, IShellIcon *));    // We want IUnknown, not IShellIcon, but this is to disambigiuate.
    }

    return hr;
}





/*****************************************************************************\
    FUNCTION:   _IsValidPidlParameter

    DESCRIPTION:
        If this IShellFolder is rooted within our name space, then the pidl needs
    to be a valid relative pidl.  If we are rooted at the base of our name space,
    then it needs to be a full pidl.
\*****************************************************************************/
BOOL CXboxFolder::_IsValidPidlParameter(LPCITEMIDLIST pidl)
{
    BOOL fResult = TRUE;

    if (IsRoot())
        fResult = XboxPidl_IsValidFull(pidl);
    else
        fResult = XboxPidl_IsValidRelative(pidl);

    return fResult;
}


/*****************************************************************************\
    FUNCTION: IShellFolder::_BindToObject

    DESCRIPTION:
        We are now sure that we want to handle the support, so check what they
    want.
\*****************************************************************************/
HRESULT CXboxFolder::_BindToObject(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlFull, IBindCtx * pbc, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);   // Indicate we want the old functionality to kick in.

    if (IsEqualIID(riid, IID_IShellFolder) || IsEqualIID(riid, IID_IShellFolder2))
    {
        LPITEMIDLIST pidlTarget = ILCombine(GetPublicTargetPidlReference(), pidl);
        LPITEMIDLIST pidlRoot = (GetFolderPidl() ? ILCombine(GetFolderPidl(), pidl) : NULL);

        //  There's no point trying to verify that it's folders all
        //  the way down, because it's the caller's job not to combine
        //  pidls randomly.  Furthermore, they might not actually be marked
        //  as folders if we got them via ParseDisplayName.

        // NOTE: Binding will succeed even if the pidl isn't valid on the
        //       server.  In the future we may want to verify now so we
        //       don't hand out a IEnumIDList that won't work.  Currently,
        //       IEnumIDList will fail and cause a renavigation if it can
        //       connect to the server in a different way (different username
        //       password pair).  It would be better to do a redirect because
        //       the renavigation causes the bad entry in the navigation stack.
        //       We can't verify the item exists on the server if we have a WebProxy
        //       installed.

        hr = CXboxFolder_Create(pidlTarget, pidlRoot, GetPidlByteOffset(), riid, ppvObj);
        //TraceMsg(TF_FOLDER_SHRTCUTS, "CXboxFolder::_BindToObject() creating an XBOX IShellFolder psf=%#08lx, pidlTarget=%#08lx, pidlRoot=%#08lx", *ppvObj, pidlTarget, pidlRoot);
        if (EVAL(SUCCEEDED(hr)))
        {
            IUnknown * punk = (IUnknown *) *ppvObj;
            IDelegateFolder * pdf;

            hr = punk->QueryInterface(IID_IDelegateFolder, (LPVOID *) &pdf);
            if (EVAL(SUCCEEDED(hr)))
            {
                if (EVAL(SUCCEEDED(hr)))
                    hr = pdf->SetItemAlloc(m_pm);
                pdf->Release();
            }
        }

        ILFree(pidlTarget);
        ILFree(pidlRoot);
        //TraceMsg(TF_XBOXISF, "CXboxFolder::BindToObject() IID_IShellFolder hr=%#08lx", hr);
    }
    else if (IsEqualIID(riid, IID_IMoniker))
    {
        hr = _PidlToMoniker(pidlFull, (IMoniker **) ppvObj);
    }
    else if (IsEqualIID(riid, IID_CXboxFolder))
    {
        IShellFolder * psf;

        // Nothing like a little recursion to keep the code clean.
        // The fact that we use IID_IShellFolder guarantees the breaking
        // of the recursion.
        hr = BindToObject(pidl, pbc, IID_IShellFolder, (void **) &psf);
        if (EVAL(SUCCEEDED(hr)))
        {
            hr = psf->QueryInterface(riid, ppvObj);
            psf->Release();
        }
    }
    else
    {
        TraceMsg(TF_XBOXISF, "CXboxFolder::BindToObject() unsupported interface hr=E_NOINTERFACE");
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }

    return hr;
}


BOOL CXboxFolder::IsUTF8Supported(void)
{
    if (EVAL(m_pfs))
        return m_pfs->IsUTF8Supported();

    return FALSE;
}

/*****************************************************************************\
     FUNCTION: IShellFolder::_PidlToMoniker
 
    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxFolder::_PidlToMoniker(LPCITEMIDLIST pidl, IMoniker ** ppmk)
{
    HRESULT hr = E_INVALIDARG;

    *ppmk = NULL;
    if (EVAL(pidl))
    {
        /*
        IBindCtx * pbc;
        hr = _GetBindCtx(&pbc);
        if (SUCCEEDED(hr))
        {
            hr = CreateURLMoniker(NULL, , ppmk);
            pbc->Release();
        }*/
    }

    ASSERT_POINTER_MATCHES_HRESULT(*ppmk, hr);
    return hr;
}


HRESULT CXboxFolder::_CreateShellView(HWND hwndOwner, void ** ppvObj)
{
    IShellFolderViewCB * psfvCallBack;

    HRESULT hr = CXboxView_Create(this, hwndOwner, IID_IShellFolderViewCB, (LPVOID *) &psfvCallBack);
    if (EVAL(SUCCEEDED(hr)))
    {
        // GetPublicTargetPidlReference() is used because it's passed to SFVM_GETNOTIFY
        // to synch ChangeNotify messages.
        hr = CBaseFolder::_CreateShellView(hwndOwner, ppvObj, XBOX_SHCNE_EVENTS, 
                        FVM_DETAILS, psfvCallBack, GetPublicTargetPidlReference(), CBaseFolderViewCB::_IShellFolderViewCallBack);
        psfvCallBack->Release();
    }

    ASSERT_POINTER_MATCHES_HRESULT(*ppvObj, hr);
    return hr;
}

HKEY ClassKeyFromExtension(LPCWIRESTR pszExt)
{
    HKEY hkey = NULL;
    WIRECHAR szProgID[MAX_PATH];
    DWORD cbProgID = sizeof(szProgID);

    if (ERROR_SUCCESS == SHGetValueA(HKEY_CLASSES_ROOT, pszExt, NULL, NULL, (void *)szProgID, &cbProgID))
    {
        // the entension points to a ProgID, use that.
        RegOpenKeyA(HKEY_CLASSES_ROOT, szProgID, &hkey);
    }
    else
    {
        // No ProgID, use the extension as the program ID.
        RegOpenKeyA(HKEY_CLASSES_ROOT, pszExt, &hkey);
    }

    return hkey;
}

#define SZ_REGVALUE_DOCOBJECT            TEXT("DocObject")
#define SZ_REGVALUE_BROWSEINPLACE        TEXT("BrowseInPlace")

BOOL _IsDocObjViewerInstalled(LPCITEMIDLIST pidl)
{
    BOOL fResult = FALSE;

    // Return FALSE if it's just pointing to an XBOX server.
    if (!XboxID_IsServerItemID(ILFindLastID(pidl)))
    {
        LPCWIRESTR pwWireFileName = XboxPidl_GetLastItemWireName(pidl);
        LPCWIRESTR pszExt = PathFindExtensionA(pwWireFileName);

        if (pszExt)
        {
            HKEY hkey = ClassKeyFromExtension(pszExt);
            if (hkey)
            {
                if ((ERROR_SUCCESS == RegQueryValue(hkey, SZ_REGVALUE_DOCOBJECT, 0, NULL)) ||
                    (ERROR_SUCCESS == RegQueryValue(hkey, SZ_REGVALUE_BROWSEINPLACE, 0, NULL)))
                {
                    fResult = TRUE;
                }

                RegCloseKey(hkey);
            }
        }
    }

    return fResult;
}


ULONG XboxGetAttributesOf(LPCITEMIDLIST pidl)
{
    ASSERT(IsValidPIDL(pidl));

    DWORD dwAttributes = XboxPidl_GetAttributes(pidl);   // Get File based attributes.
    ULONG rgfInOut = Misc_SfgaoFromFileAttributes(dwAttributes); // Turn them into IShellFolder attributes.
    return rgfInOut;
}





//===========================
// *** IShellFolder2 Interface ***
//===========================

STDAPI InitVariantFromBuffer(VARIANT *pvar, const void *pv, UINT cb)
{
    HRESULT hres;
    SAFEARRAY *psa = SafeArrayCreateVector(VT_UI1, 0, cb);   // create a one-dimensional safe array
    if (psa) 
    {
        memcpy(psa->pvData, pv, cb);

        memset(pvar, 0, sizeof(*pvar));  // VariantInit()
        pvar->vt = VT_ARRAY | VT_UI1;
        pvar->parray = psa;
        hres = S_OK;
    }
    else
        hres = E_OUTOFMEMORY;
    return hres;
}


/*****************************************************************************\
    FUNCTION: IShellFolder2::GetDetailsEx

    DESCRIPTION:
        This function will be called when the caller wants detailed info about
    and item.  SHGetDataFromIDList() is one such caller and that is commonly
    called by the Shell Object model when using CSDFldrItem::get_Size(LONG *pul)
    and other such APIs.
\*****************************************************************************/
HRESULT CXboxFolder::GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv)
{
    HRESULT hr = S_OK;

    if (IsEqualGUID(pscid->fmtid, FMTID_ShellDetails) && (PID_FINDDATA == pscid->pid))
    {
        WIN32_FIND_DATAW wfd;

        // I can handle this.
        LPITEMIDLIST pidlFull = CreateFullPrivatePidl(pidl);

        if (pidlFull)
        {
            hr = Win32FindDataFromPidl(pidlFull, &wfd, TRUE, TRUE);
            ILFree(pidlFull);
        }

        if (SUCCEEDED(hr))
        {
            hr = InitVariantFromBuffer(pv, (PVOID)&wfd, sizeof(wfd));
        }
    }
    else
        hr = CBaseFolder::GetDetailsEx(pidl, pscid, pv);

    return hr;
}



//===========================
// *** IShellFolder Interface ***
//===========================

HRESULT CXboxFolder::ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pwszDisplayName,
                        ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes)
/*++
    
    IPersistFolder::Initialize

    Routine Description:
        
        Called to get a PIDL for a name the user typed into an address bar of whatever
        browser they were using.


    Arguments:
        
        hwnd              - [in] handle of the window requesting the parsing - not sure who would want it -
                            the FTP extension doesn't seem to use it - could be useful when showing an error
        pbc               - [in] according to MSDN (10/00) this optional - the FTP extension doesn't use it -
                            not sure what it is good for
        pwszDisplayName   - [in] the name the user typed in
        pchEaten          - [out] number of characters that were parsed - the CXboxFolder does all or none
        ppidl             - [out] the pidl obtained from pwszDisplayName
        pdwAttributes     - [in\out] on in options for how we parse - whether we go over the wire to check if
                            the name is valid - what info the caller wants - on out various attributes of the item,
                            can it be copied, deleted, moved, how to display, file or folder, etc.
        
--*/

{
    HRESULT hr = S_OK;
    
    //Initialize the output parameters
    *ppidl = NULL;
    if (pchEaten) *pchEaten = 0;

    //Regardless of the pdwAttributes the first step
    //is to parse the string and get a PIDL.  Once we
    //have
    CXboxPidl pidlOut;
    hr = pidlOut.InitWithDisplayName(m_pidl, pwszDisplayName);
    if(SUCCEEDED(hr))
    {
        //We should now have a conforming PIDL, but we have no idea, if it
        //represent a valid xbox.
        if(pchEaten) *pchEaten = wcslen(pwszDisplayName);

        if(pdwAttributes)
        // If the dwAttributes is non-NULL
        // then we may actually need to try to validate the 
        // PIDL, including figuring out if the Xbox exists,
        // if the path exists, whether it is a file or folder,
        // etc.
        {
            ASSERT(FALSE && "Need to implement this case.");
        }
        
        LPITEMIDLIST temp = pidlOut.GetPidl();
        USHORT cb = (USHORT)CXboxPidl::GetPidlSize(temp);
        *ppidl = (LPITEMIDLIST) m_pm->Alloc(cb);
        memcpy(*ppidl, temp, cb);
        if(NULL == *ppidl)
        {
            hr = E_FAIL;
        }
    }
    return hr;

    /*
    *ppidl = NULL;
    if (pchEaten)
        *pchEaten = 0;

    // PERF: log 2 (sizeof(m_pflHfpl))
    hr = _GetCachedPidlFromDisplayName(pwszDisplayName, ppidl); 
    if (FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr))
    {
        // Are we are rooted within an XBOX Server?
        if (IsRoot())
        {
            // No, so parse the entire thing

            // There is only one case where we want to hide the password,
            // and that is when the user entered it into the "Login"
            // dialog.  Since we entering it into the dialog will cause a
            // redirect to an URL with that password in it, we need to determie
            // if we are being called during this redirect.  If so,
            // the password just came from the Login dialog and we need to hide it.

            // This will work for fully qualified Xbox URLs
            hr = CreateXboxPidlFromUrl(pwszDisplayName, GetCWireEncoding(), pchEaten, ppidl, m_pm, FALSE);
            if (SUCCEEDED(hr))
            {
                CXboxSite * pfs;

                hr = SiteCache_PidlLookup(*ppidl, TRUE, m_pm, &pfs);
                if (EVAL(SUCCEEDED(hr)))
                {
                    // If we are using a hidden password, then ::GetDisplayNameOf() hands out
                    // these "xbox://user@server/dir/" URLs and the password is hidden.  If
                    // ::ParseDisplayName() is given one of these URLs and we are currently in
                    // that server w/that user name, then ::ParseDisplayNameOf() needs to hand
                    // out a pidl with the correct hidden password cookie.
                    //
                    // Is pidlNav the same as GetPublicPidlReference() except pidlNav doesn't
                    // have a password.  The same means that the servers match, and the user names
                    // match.
                    EVAL(SUCCEEDED(pfs->UpdateHiddenPassword(*ppidl)));
                    pfs->Release();
                }
            }
        }
        else
        {
            // Yes, so do a relative parse

            // Sometimes the user will enter incorrect information without knowing.
            // We would catch this if we verified everything that was entered, but
            // we don't, we just take it on faith until we do the IEnumIDList.
            // This is great for perf but sucks for catching these kinds of things.
            // An example of this is the user using the File.Open dialog and going to
            // "xbox://myserver/dir/".  They then enter "xbox://myserver/dir/file.txt"
            // which will try to parse relative but it's an absolute path.
            hr = _FilterBadInput(pwszDisplayName, ppidl);
            if (SUCCEEDED(hr))
            {
                CXboxDir * pfd = GetXboxDir();
                hr = CreateXboxPidlFromDisplayPath(pwszDisplayName, pfd->GetXboxSite()->GetCWireEncoding(), pchEaten, ppidl, FALSE, FALSE);
                pfd->Release();
            }
        }
    }

    if (SUCCEEDED(hr) && pdwAttributes)
    {
        hr = GetAttributesOf(1, (LPCITEMIDLIST *) ppidl, pdwAttributes);
        if (FAILED(hr))
            ILFree(*ppidl);
    }

#ifdef DEBUG
    TCHAR szUrlDebug[MAX_URL_STRING];
    
    szUrlDebug[0] = 0;
    if (*ppidl)
        UrlCreateFromPidl(*ppidl, SHGDN_FORPARSING, szUrlDebug, ARRAYSIZE(szUrlDebug), ICU_USERNAME, FALSE);

    TraceMsg(TF_XBOXISF, "CXboxFolder::ParseDisplayName(%ls) CreateXboxPidlFromUrl() returned hres=%#08lx %ls", pwszDisplayName, hr, szUrlDebug);
    ASSERT(FAILED(hr) || IsValidPIDL(*ppidl));
#endif // DEBUG

    ASSERT_POINTER_MATCHES_HRESULT(*ppidl, hr);
    return hr;
    */
}

IMalloc * CXboxFolder::GetIMalloc(void)
{
    IMalloc * pm = NULL;

    IUnknown_Set(&pm, m_pm);
    ASSERT(pm);
    return pm;
}


/*****************************************************************************\
    FUNCTION: IShellFolder::EnumObjects

    DESCRIPTION:
        Design subtlety: If we couldn't create an enumeration on the server,
    succeed, but return an enumerator that shows no objects.

    This is necessary so that our IShellView callback can put
    up error UI.  If we failed the create, the shell would
    destroy the view without giving us a chance to say what's
    up.

    It's also important for write-only directories like /incoming,
    so that the user can drag files into the directory without
    necessarily being able to drag files out.
\*****************************************************************************/
HRESULT CXboxFolder::EnumObjects(HWND hwndOwner, DWORD grfFlags, IEnumIDList ** ppenumIDList)
{
    HRESULT hres = E_FAIL;
    CXboxDir * pfd = GetXboxDir();

    // This will happen if some TARD tries to just CoCreateInstance our
    // Name Space extension and see what contents we have.  TweakUI
    // is an example of one such abuser.  Since we can only populate
    // our contents after we navigate to a XBOX server, we are empty.
    *ppenumIDList = NULL;
    if (pfd)
    {
        //    Create a new enumeration object for the caller.
        ASSERT(m_pm);
        hres = CXboxEidl_Create(pfd, this, hwndOwner, grfFlags, ppenumIDList);
        TraceMsg(TF_XBOXISF, "CXboxFolder::EnumObjects() CXboxEidl_Create() returned hres=%#08lx", hres);

        if (!EVAL(SUCCEEDED(hres)))
        {
            ASSERT(*ppenumIDList);            // We failed, so free what we have.
        }

        pfd->Release();
    }

    ASSERT_POINTER_MATCHES_HRESULT(*ppenumIDList, hres);
    return hres;
}

/*****************************************************************************\
    FUNCTION: IShellFolder:: BindToObject

    DESCRIPTION:
        First thing we need to do, is see if we want to over ride the default
    IE XBOX support.  If we do, we call otherwise, we just fallback to the old
    support.  We want the new UI if: a) it's a directory, b) the web proxy doesn't
    block us, and c) the user didn't turn us off.

    PERF/TODO:
        OrderItem_GetSystemImageListIndexFromCache (\shell\lib\dpastuff.cpp)
    uses riid=IShellFolder when trying to find out the icon.  We don't want
    to hit the net in that case, so force them to pass a pbc to indicate skipping
    the net in that case.
\*****************************************************************************/
HRESULT CXboxFolder::BindToObject(LPCITEMIDLIST pidl, IBindCtx * pbc, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);   // Indicate we want the old functionality to kick in.

    if (ppvObj)
        *ppvObj = NULL;

    if (!pidl || ILIsEmpty(pidl) || !_IsValidPidlParameter(pidl))
    {
        // Caller, are you smoking crack?  What's the idea of passing
        // an empty pidl. (Comdlg32 is known to do this)
        hr = E_INVALIDARG;
    }
    else
    {
        BOOL fDisplayProxyFallBackDlg = FALSE;
        LPITEMIDLIST pidlFull = CreateFullPrivatePidl(pidl);

        // We need to handle it.
        hr = _BindToObject(pidl, pidlFull, pbc, riid, ppvObj);

        // Maybe we still need to handle it if 
        ASSERT(HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr);
        ILFree(pidlFull);
    }

    ASSERT_POINTER_MATCHES_HRESULT(*ppvObj, hr);
    return hr;
}


/*****************************************************************************\
     FUNCTION: IShellFolder::BindToStorage
 
    DESCRIPTION:
         We need to implement this so the user can Open and Save files in
    the standard Open Dialog and Save Dialog.
\*****************************************************************************/
HRESULT CXboxFolder::BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hr = E_INVALIDARG;

    if (!EVAL(_IsValidPidlParameter(pidl)))
        return E_INVALIDARG;

    *ppvObj = 0;
    if (EVAL(pidl))
    {
        IMoniker * pmk;

        hr = _PidlToMoniker(pidl, &pmk);
        if (SUCCEEDED(hr))
        {
            hr =  pmk->BindToStorage(pbc, NULL, riid, ppvObj);
            pmk->Release();
        }
    }

    ASSERT_POINTER_MATCHES_HRESULT(*ppvObj, hr);
    TraceMsg(TF_XBOXISF, "CXboxFolder::BindToStorage() hr=%#08lx", hr);
    return hr;
}


/*****************************************************************************\
    FUNCTION: IShellFolder::CompareIDs

    DESCRIPTION:
        ici - column on which to sort.  Note! that we rely on the fact that
    IShellFolders are uniform; we do not need to bind to the shell folder in
    order to compare its sub-itemids.

    _UNDOCUMENTED_: The documentation does not say whether or not
    complex pidls can be received.  In fact, they can.
\*****************************************************************************/
HRESULT CXboxFolder::CompareIDs(LPARAM ici, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    ASSERT(IsValidPIDL(pidl1));
    ASSERT(IsValidPIDL(pidl2));

    return XboxItemID_CompareIDs(ici, pidl1, pidl2, FCMP_GROUPDIRS);
}


HRESULT CXboxFolder::_CreateViewObject(HWND hwndOwner, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hr = E_FAIL;
    CXboxDir * pfd = GetXboxDir();

    *ppvObj = NULL;            // Explorer relies on this
    //TraceMsg(TF_XBOXISF, "CXboxObj::CreateViewObject() ");
    if (pfd)
    {
        if (IsEqualIID(riid, IID_IDropTarget))
        {
            //  Don't create a drop target for the root XBOX folder.
            if (IsRoot())
                hr = E_NOINTERFACE;
            else
            {
                CXboxDrop * pfm;
                hr = CXboxDrop_Create(this, hwndOwner, &pfm);
                if (EVAL(SUCCEEDED(hr)))
                {
                    hr = pfm->QueryInterface(riid, ppvObj);
                    pfm->Release();
                }
            }
        }
        else
            hr = E_NOINTERFACE;

        // TODO: IID_IShellDetails
        pfd->Release();
    }
    else
        hr = E_FAIL;            // Can't do that yet - Never _Initialize'd

    ASSERT_POINTER_MATCHES_HRESULT(*ppvObj, hr);
    if (FAILED(hr))
        hr = CBaseFolder::CreateViewObject(hwndOwner, riid, ppvObj);

    return hr;
}

/*****************************************************************************\
    FUNCTION: IShellFolder:: CreateViewObject

    DESCRIPTION:
    _UNDOCUMENTED_: This entire method is not documented.

    _UNDOCUMENTED_: It is not documented that you need to
    provide an IDropTarget object if you want the view to
    act as a drop target.

    IDropTarget produces a droptarget for the folder itself.

    
    _UNOBVIOUS_:  Not obvious that this is how the shell gets
    a context menu for the folder itself.  (You might think it
    comes from GetUIObjectOf...)

    IContextMenu produces a context menu for the folder itself.
    This is important for supporting things like New and Paste.

    IShellDetails (undocumented) is the direct interface to
    GetDetailsOf and ColumnClick, which is now obsolete, replaced
    by the DVM_GETDETAILSOF and DVM_COLUMNCLICK notifications.

    _UNDOCUMENTED_: SHCreateShellFolderViewEx is not documented.

    Yes, it's annoying how some things are handled by CreateViewObject
    and some things are handled by GetUIObjectOf(cpidl = 0), so we
    keep having to forward the requests back and forth.  Particularly
    annoying because the shell actually comes through both ways.

    For example, if the user drags something onto a folder,
    it does a CreateViewObject(IDropTarget), because it might not
    be able to bind to the parent to get the IDropTarget (if the
    folder is the root of a namespace).

    But if you drag an object onto a subfolder of a folder, the shell
    asks for a GetUIObjectOf(pidl, IDropTarget) so it can talk to
    the drop target of the subobject.  It does this to allow the
    shell folder to create a quick IDropTarget without necessarily
    binding to the subobject first.

    We don't do any such optimization, so GetUIObjectOf() simply
    binds to the subfolder and uses CreateViewObject().


    If the IShellFolder doesn't have an XboxSite (typically because it
    has not been IPersistFolder::Initialize'd), then fail any attempt
    to create a view object.
\*****************************************************************************/
HRESULT CXboxFolder::CreateViewObject(HWND hwndOwner, REFIID riid, LPVOID * ppvObj)
{
    IShellFolder *pShellFolder;
    HRESULT hr;
    
    hr = QueryInterface(IID_IShellFolder, (LPVOID *)&pShellFolder);
    if(SUCCEEDED(hr))
    {
        SFV_CREATE sfvCreate;
        sfvCreate.cbSize = sizeof(SFV_CREATE);
        sfvCreate.pshf = pShellFolder;
        sfvCreate.psvOuter = NULL;  // Add an outer, if we want to add an interface to the web view.
        sfvCreate.psfvcb = NULL; // Add a callback later, as the features start taking shape.
        hr = SHCreateShellFolderView(&sfvCreate, (LPSHELLVIEW FAR*)ppvObj);
        //The default shell view should have done its own AddRef.
        pShellFolder->Release();
    }
    return hr;
}


/*****************************************************************************\
    FUNCTION: IShellFolder::GetAttributesOf

    DESCRIPTION:
        If we are given cpidl = 0, then we are being asked for attributes
    on the folder itself.  But note that some people pass slightly
    confused versions of cpidl = 0, as noted in the comment block below.

    If the SFGAO_VALIDATE bit is set with cpidl = 0, then the view
    object is warning us that it is about to refresh, so we should
    throw away any cached information.

    NOTE!  xboxcm.cpp relies heavily on the fact that this routine will
    fail when given complex pidls.  (This allows xboxcm.cpp to assume
    that all the pidls are directly in the affected folder.)

    _UNDOCUMENTED_: The documentation does not say whether or not
    complex pidls can be received.  I don't know whether or not
    they can, so I'll code defensively and watch out for them.

    BUGBUG: Does a server need to return SFGAO_HASSUBFOLDER?

\*****************************************************************************/
HRESULT CXboxFolder::GetAttributesOf(UINT cpidl, LPCITEMIDLIST *apidl, ULONG *rgfInOut)
{
    HRESULT hr;
    DWORD dwMask = *rgfInOut;

    //    _UNDOCUMENTED_:
    //    Some stupid people pass cpidl = 1 but ILIsEmpty(apidl[0]),
    //    intending to pass cpidl = 0.  While we're being distracted
    //    by stupid people, may as well catch apidl[0] == 0 also...
    //    Oh, and defview sometimes passes cpidl = 1 but apidl == 0...
    if (cpidl > 0 && apidl && apidl[0])
    {
        UINT ipidl;

        //  Can't multi-rename because there's nowhere to pass the new names.
        //  Can't multi-paste since you don't know where it really goes.
        if (cpidl > 1)
        {
            *rgfInOut &= ~SFGAO_CANRENAME;
            *rgfInOut &= ~SFGAO_DROPTARGET;
        }
        hr = S_OK;
        for (ipidl = 0; ipidl < cpidl; ipidl++)
        {
            // This maybe a fully qualified pidl or relative pidl
            LPITEMIDLIST pidlFull;

            if (ILIsSimple(apidl[ipidl]))
                pidlFull = CreateFullPrivatePidl(apidl[0]);
            else
                pidlFull = (LPITEMIDLIST) apidl[0];

            *rgfInOut &= XboxGetAttributesOf(pidlFull);


            if (apidl[0] != pidlFull)
                ILFree(pidlFull);       // We alloced it so we free it.
        }
    }
    else
    {
        // At top-level, SFGAO_DROPTARGET is also disabled
        if (IsRoot())
            *rgfInOut &= ~SFGAO_DROPTARGET;

        *rgfInOut &= ~(SFGAO_GHOSTED | SFGAO_LINK | SFGAO_READONLY |
                   SFGAO_SHARE | SFGAO_REMOVABLE);

        if (*rgfInOut & SFGAO_VALIDATE)
            InvalidateCache();      // About to refresh...

        hr = S_OK;
    }

    // We can create a moniker for anything, a file or a folder.
    *rgfInOut |= (SFGAO_CANMONIKER & dwMask);

//    TraceMsg(TF_XBOXISF, "CXboxFolder::GetAttributesOf() *rgfInOut=%#08lx, hr=%#08lx", *rgfInOut, hr);
    return hr;
}


/*****************************************************************************\
    DESCRIPTION:
        Creates an pflHfpl and asks CXboxFolder_GetUIObjectOfHfpl (qv)
    to do the real work.

    Note that we always release the pflHfpl.  If GetUIObjectOfHfpl
    needs to keep the pflHfpl, it will do its own AddRef().
\*****************************************************************************/
HRESULT CXboxFolder::GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST rgpidl[],
                                REFIID riid, UINT * prgfInOut, LPVOID * ppvObj)
{
     return _GetUIObjectOf(hwndOwner, cidl, rgpidl, riid, prgfInOut, ppvObj, FALSE);
}


/*****************************************************************************\
    DESCRIPTION:
        Creates an pflHfpl and asks CXboxFolder_GetUIObjectOfHfpl (qv)
    to do the real work.

    Note that we always release the pflHfpl.  If GetUIObjectOfHfpl
    needs to keep the pflHfpl, it will do its own AddRef().
\*****************************************************************************/
HRESULT CXboxFolder::_GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST rgpidl[],
                                REFIID riid, UINT * prgfInOut, LPVOID * ppvObj, BOOL fFromCreateViewObject)
{
    CXboxPidlList * pflHfpl = NULL;
    HRESULT hr = E_FAIL;
    LPITEMIDLIST pidlFull;
    
    if (rgpidl)
        pidlFull = CreateFullPrivatePidl(rgpidl[0]);
    else
        pidlFull = GetPrivatePidlClone();
    
    if (ppvObj)
        *ppvObj = NULL;

    // Is the proxy blocking us?  If yes, don't do anything
    // because we don't want our Context Menu to appear for the
    // original XBOX UI.
    // It's not blocking so go ahead.
    hr = CXboxPidlList_Create(cidl, rgpidl, &pflHfpl);
    if (EVAL(SUCCEEDED(hr)))
    {
        _InitXboxSite(); // GetUIObjectOfHfpl() will later need m_pfs. 
        hr = GetUIObjectOfHfpl(hwndOwner, pflHfpl, riid, ppvObj, fFromCreateViewObject);
        pflHfpl->Release();
    }

    if (pidlFull)
        ILFree(pidlFull);

//    TraceMsg(TF_XBOXISF, "CXboxFolder::GetUIObjectOf() hres=%#08lx", hr);
    ASSERT_POINTER_MATCHES_HRESULT(*ppvObj, hr);
    return hr;
}


/*****************************************************************************\
    FUNCTION: IShellFolder::GetDisplayNameOf

    DESCRIPTION:
        Note! that since we do not support junctions (duh), we can
    safely walk down the pidl generating goop as we go, secure
    in the knowledge that we are in charge of every subpidl.

    XBOX UNICODE ISSUE:
        The XBOX spec (RFC 959 (?)) says that XBOX uses 8-bit BYTEs as
    names.  If the 8th bit is zero, these are treated as ANSI.
    But it's not specified what the 8th bit means when it's set?
    Some lame XBOX clients have been pushing DBCS/MBCS up using the 8th bit
    but this incurs data loss because the code page is lost and cross
    code page strings are not supported.  For that reason, a combination
    of UTF-8 (by default) should be used and fall back to DBCS with
    code page guessing (maybe need UI to guess code page).

    We need to use WININET BYTE APIs (BYTE means ANSI with an ambiguous 8th bit).
    We then need to store those bytes in our cache (CXboxDir).  When we display
    these strings in UI, we need to convert them to unicode and guess weather
    it's UTF-8 or DBCS encoded.
\*****************************************************************************/
HRESULT CXboxFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD shgno, LPSTRRET pStrRet)
{
    HRESULT hr = E_FAIL;

    // It's invalid for someone to pass us an empty pidl, but some retards do.
    // (comdlg32\GetPathFromLocation)  Reject it now.
    if (ILIsEmpty(pidl) || !EVAL(_IsValidPidlParameter(pidl)))
        return E_INVALIDARG;

    LPITEMIDLIST pidlFull = CreateFullPrivatePidl(pidl);
    if (EVAL(pidlFull))
    {
        ASSERT(IsValidPIDL(pidlFull));

        hr = StrRetFromXboxPidl(pStrRet, shgno, pidlFull);
        ILFree(pidlFull);
    }

//    TraceMsg(TF_XBOXISF, "CXboxFolder::GetDisplayNameOf() szName=%hs, hres=%#08lx", pStrRet->cStr, hr);
    return hr;
}


/*****************************************************************************\
    FUNCTION: IShellFolder::SetNameOf

    DESCRIPTION:
        The real work is done by SetNameOf.
\*****************************************************************************/
HRESULT CXboxFolder::SetNameOf(HWND hwndOwner, LPCITEMIDLIST pidl, LPCOLESTR pwszName,
                                DWORD dwReserved, LPITEMIDLIST *ppidlOut)
{
    HRESULT hr = S_FALSE;
    CXboxDir * pfd = GetXboxDir();
    TCHAR szPath[MAX_PATH];
    BOOL fContinueToRename = TRUE;

    if (!EVAL(_IsValidPidlParameter(pidl)))
        return E_INVALIDARG;

    ASSERT(IsValidPIDL(pidl));
    SHUnicodeToTChar(pwszName, szPath, ARRAYSIZE(szPath));

    // Does the new item not have an extension and this isn't a directory?
    if (0 == PathFindExtension(szPath)[0] && !XboxPidl_IsDirectory(pidl, FALSE))
    {
        LPCWIRESTR pszFileName = XboxPidl_GetLastItemWireName(pidl);
        // Yes, then we are scared that they may be loosing an extension.

        // Did the original name have an extension?
        if (pszFileName && PathFindExtensionA(pszFileName)[0])
        {
            // Yes, so now we are scared they may loose it and not be able
            // to find the src app.  Ask the user if they really want to do this
            // rename if that will mean the file will no longer have an extension.

            // Hey browser, can I display UI?
            if (EVAL(hwndOwner))
            {
                // Hay browser, cover me, I'm going to do UI.
                IUnknown_EnableModless(_punkSite, FALSE);

                TCHAR szTitle[MAX_PATH];
                TCHAR szReplaceMsg[MAX_PATH*4];

                EVAL(LoadString(HINST_THISDLL, IDS_XBOXERR_RENAME_TITLE, szTitle, ARRAYSIZE(szTitle)));
                EVAL(LoadString(HINST_THISDLL, IDS_XBOXERR_RENAME_EXT_WRN, szReplaceMsg, ARRAYSIZE(szReplaceMsg)));
                if (IDNO == MessageBox(hwndOwner, szReplaceMsg, szTitle, (MB_YESNO | MB_ICONEXCLAMATION)))
                    fContinueToRename = FALSE;  // Cancel the rename.

                IUnknown_EnableModless(_punkSite, TRUE);
            }
        }
    }

    if (fContinueToRename)
    {
        if (EVAL(pfd))
        {
            hr = pfd->SetNameOf(this, hwndOwner, pidl, szPath, dwReserved, ppidlOut);
            if (FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr) && hwndOwner)
            {
                DisplayWininetError(hwndOwner, TRUE, HRESULT_CODE(hr), IDS_XBOXERR_TITLE_ERROR, IDS_XBOXERR_FILERENAME, IDS_XBOXERR_WININET, MB_OK, NULL);
            }
        }

        TraceMsg(TF_XBOXISF, "CXboxFolder::SetNameOf(%ls) hres=%#08lx", pwszName, hr);
        //        shell32.dll in IE4 (maybe earlier also) will infinitely call
        //    CXboxFolder::SetNameOf() over and over if it returns FAILED(hr);
        if (FAILED(hr))
            hr = S_FALSE;
    }

    if (ppidlOut)
    {
        ASSERT_POINTER_MATCHES_HRESULT(*ppidlOut, hr);
    }

    if (pfd)
        pfd->Release();

    return hr;
}


//=====================================
// *** IPersistFolder Interface ***
//=====================================

HRESULT CXboxFolder::Initialize(LPCITEMIDLIST pidl)
/*++
    
    IPersistFolder::Initialize

    Routine Description:
        
        This is called when the shell creates a new "root".  When an xbox folder
        creates a sub-folder, it uses a private create method.

    Arguments:
        
        pidl - absolute pidl to our root.  We simply cache this so we know
               how to create absolute pidls from our relative ones.
        
    Comments:
        
          It appears (from the FTP code) that IPersistFolder may be recycled by calling
          Initialize on it.  MSDN is mute on this point.  So here we code for that
          possibility.  We can check later to determine if it is necessary.
--*/
{
    HRESULT hr = E_OUTOFMEMORY;

    ASSERT(IsValidPIDL(pidl));
    
    // Clean up if object is being recycled.
    if(m_pidlRoot)
    {
        TraceMsg(TF_XBOXISF, "CXboxFolder::Initialize() called to recycle");
        delete m_pidlRoot;
        m_pidlRoot = NULL;
        delete m_pidl;
        m_pidl = NULL;
    }

    //Allocate and initialize the m_pidl and m_pidlRoot
    m_pidlRoot = new CXboxPidl();
    m_pidl = new CXboxPidl();
    if(m_pidlRoot && m_pidl)
    {
        hr = m_pidlRoot->InitWithPidl(pidl, CXboxPidl::GetPidlSize(pidl));
        if(SUCCEEDED(hr))
        {
            hr = m_pidl->InitAsRoot();
        }
        if(FAILED(hr))
        {
            delete m_pidlRoot;
            delete m_pidl;
        }
    }
    
    return hr;
}


//===========================
// *** IShellIcon Interface ***
//===========================

/*****************************************************************************\
    FUNCTION: IShellIcon::GetIconOf

    DESCRIPTION:
        Get the system icon imagelist index for a pidl.  Subtlety - If we are
    enumerating children of the root, their icon is a computer.

    _UNDOCUMENTED_: Undocumented method in undocumented interface.
\*****************************************************************************/
HRESULT CXboxFolder::GetIconOf(LPCITEMIDLIST pidl, UINT gil, LPINT pnIcon)
{
    HRESULT hr = S_OK;

    if (!EVAL(_IsValidPidlParameter(pidl)))
        return E_INVALIDARG;

    // BUGBUG: Fix this to get custom icons for DefView ListView
    *pnIcon = GetXboxIcon(gil, IsRoot());

    ASSERT(IsValidPIDL(pidl));
    if (EVAL(!IsRoot()))    // GetXboxIcon() is wrong so either fix it or verify we never try to use it.
    {
        SHFILEINFO sfi;
        hr = XboxPidl_GetFileInfo(pidl, &sfi, SHGFI_SYSICONINDEX |
                    ((gil & GIL_OPENICON) ? SHGFI_OPENICON : 0));

        if (SUCCEEDED(hr))
        {
            *pnIcon = sfi.iIcon;
            if (sfi.hIcon)
                DestroyIcon(sfi.hIcon);
        }
    }

//    TraceMsg(TF_XBOXISF, "CXboxFolder::GetIconOf() hres=%#08lx", hr);
    return hr;
}



//===========================
// *** IShellIconOverlay Interface ***
//===========================
HRESULT CXboxFolder::GetOverlayIndexHelper(LPCITEMIDLIST pidl, int * pIndex, DWORD dwFlags)
{
    HRESULT hr = E_FAIL;

    *pIndex = 0;
    // Is this a soft link? (Meaning it won't have a windows link
    // extension (.lnk, .url, ...) but we still want the shortcut cue.
    if (pidl && XboxPidl_IsSoftLink(pidl))
    {
        if (!m_psiom)
            EVAL(SUCCEEDED(hr = CoCreateInstance(CLSID_CFSIconOverlayManager, NULL, CLSCTX_INPROC_SERVER, IID_IShellIconOverlayManager, (void **)&m_psiom)));

        if (EVAL(m_psiom))
        {
            hr = m_psiom->GetReservedOverlayInfo(L"", XboxPidl_GetAttributes(pidl), pIndex, dwFlags, SIOM_RESERVED_LINK);
        }
    }

    return hr;
}


//===========================
// *** IDelegateFolder Interface ***
//===========================
/*****************************************************************************\
    FUNCTION: IDelegateFolder::SetItemAlloc

    DESCRIPTION:
        Gives us the pidl allocator.
\*****************************************************************************/
HRESULT CXboxFolder::SetItemAlloc(IMalloc *pm)
{
    IUnknown_Set(&m_pm, pm);

//    TraceMsg(TF_XBOXISF, "CXboxFolder::SetItemAlloc(IMalloc *pm=%#08lx) hres=%#08lx", pm, S_OK);
    return S_OK;
}


//===========================
// *** IBrowserFrameOptions Interface ***
//===========================
/*****************************************************************************\
    DESCRIPTION:
        Tell the browser/host what behaviors we want.  This lets the caller
    know when we want to act like the shell, the browser, or even unique.
\*****************************************************************************/
HRESULT CXboxFolder::GetFrameOptions(IN BROWSERFRAMEOPTIONS dwMask, OUT BROWSERFRAMEOPTIONS * pdwOptions)
{
    // This function is called in the follow situations:
    // xbox://bryanst/ (w/ & w/o folder shortcut)
    // xbox://bryanst/default.htm (w/ & w/o folder shortcut)
    // xbox://bryanst/notes.txt (w/ & w/o folder shortcut)
    // xbox://bryanst/resume.doc (w/ & w/o folder shortcut)
    // xbox://bryanst/ (w/ & w/o folder shortcut)
    // xbox://bryanst/ (w/ & w/o folder shortcut)
    // xbox://bryanst/ (w/ & w/o folder shortcut)
    HRESULT hr = E_INVALIDARG;

    if (pdwOptions)
    {
        // We want both "Internet Options" and "Folder Options".
        *pdwOptions = dwMask & (BFO_BOTH_OPTIONS | BFO_BROWSE_NO_IN_NEW_PROCESS |
                                BFO_NO_REOPEN_NEXT_RESTART |
                                BFO_ENABLE_HYPERLINK_TRACKING | BFO_USE_IE_LOGOBANDING |
                                BFO_ADD_IE_TOCAPTIONBAR | BFO_USE_DIALUP_REF);
        hr = S_OK;
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: CXboxFolder_Create

    DESCRIPTION:
        This factory method uses new to create C++, and then
        QI to get the proper interface.
\*****************************************************************************/
HRESULT CXboxFolder_Create(REFIID riid, LPVOID * ppvObj)
{
    HRESULT hres = E_OUTOFMEMORY;
    CXboxFolder * pXboxFolder = new CXboxFolder();

    *ppvObj = NULL;
    if (EVAL(pXboxFolder))
    {
        hres = pXboxFolder->QueryInterface(riid, ppvObj);
        pXboxFolder->Release();
    }

    ASSERT_POINTER_MATCHES_HRESULT(*ppvObj, hres);
    return hres;
}


/*****************************************************************************\
    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxFolder_Create(LPCITEMIDLIST pidlTarget, LPCITEMIDLIST pidlRoot, int ib, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hr = S_OK;
    CXboxFolder * pff = new CXboxFolder();

    ASSERT(IsValidPIDL(pidlTarget));
    ASSERT(!pidlRoot || IsValidPIDL(pidlRoot));

    *ppvObj = NULL;
    if (!EVAL(pff))
        return E_OUTOFMEMORY;
    else
    {
        hr = pff->_Initialize(pidlTarget, pidlRoot, ib);
        if (EVAL(SUCCEEDED(hr)))
            hr = pff->QueryInterface(riid, ppvObj);

        pff->Release();
    }

    ASSERT_POINTER_MATCHES_HRESULT(*ppvObj, hr);
    return hr;
}


/****************************************************\
    Constructor
\****************************************************/
CXboxFolder::CXboxFolder() : CBaseFolder((LPCLSID) &CLSID_XboxFolder)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_pfs);
    ASSERT(!m_pm);
    ASSERT(!m_puhs);
    ASSERT(!m_psiom);

    // Needed because we need to call CoCreateInstance() on Browser Only.
    LEAK_ADDREF(LEAK_CXboxFolder);
}


/****************************************************\
    Destructor
\****************************************************/
CXboxFolder::~CXboxFolder()
{
    ATOMICRELEASE(m_pfs);
    ATOMICRELEASE(m_pm);
    ATOMICRELEASE(m_puhs);
    ATOMICRELEASE(m_psiom);

    if (m_hinstInetCpl)
        FreeLibrary(m_hinstInetCpl);

    DllRelease();
    LEAK_DELREF(LEAK_CXboxFolder);
}


//===========================
// *** IUnknown Interface ***
//===========================

HRESULT CXboxFolder::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IShellIcon))
    {
        *ppvObj = SAFECAST(this, IShellIcon*);
    }
//  This causes all icons to use my custom Xbox folder icon, so I will do this when that is fixed.
#ifdef FEATURE_SOFTLINK_SHORTCUT_ICONOVERLAY
    else if (IsEqualIID(riid, IID_IShellIconOverlay))
    {
        *ppvObj = SAFECAST(this, IShellIconOverlay*);
    }
#endif // FEATURE_SOFTLINK_SHORTCUT_ICONOVERLAY
    else if (IsEqualIID(riid, IID_IPersistFolder))
    {
        *ppvObj = SAFECAST(this, IPersistFolder*);
    }
    else if (IsEqualIID(riid, IID_IDelegateFolder))
    {
        *ppvObj = SAFECAST(this, IDelegateFolder*);
    }
    else if (IsEqualIID(riid, IID_IObjectWithSite))
    {
        *ppvObj = SAFECAST(this, IObjectWithSite*);
    }
    else if (IsEqualIID(riid, IID_IPersistFolder2))
    {
        *ppvObj = SAFECAST(this, IPersistFolder2*);
    }
    else if (IsEqualIID(riid, IID_IShellPropSheetExt))
    {
        *ppvObj = SAFECAST(this, IShellPropSheetExt*);
    }
    else if (IsEqualIID(riid, IID_IBrowserFrameOptions))
    {
        *ppvObj = SAFECAST(this, IBrowserFrameOptions*);
    }
    else if (IsEqualIID(riid, IID_CXboxFolder))
    {
        // Only valid if caller lives in xbnmspc.dll
        *ppvObj = (void *)this;
    }
    else
        return CBaseFolder::QueryInterface(riid, ppvObj);

    AddRef();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxgto.cpp ===
/*****************************************************************************
 *
 *    xboxgto.cpp - Global timeouts
 *
 *    Global timeouts are managed by a separate worker thread, whose job
 *    it is to hang around and perform delayed actions on request.
 *
 *    All requests are for XBOX_SESSION_TIME_OUT milliseconds.  If nothing happens
 *    for an additional XBOX_SESSION_TIME_OUT milliseconds, the worker thread is
 *    terminated.
 *
 *****************************************************************************/

#include "priv.h"
#include "dbgmem.h"
#include "util.h"

#define MS_PER_SECOND               1000
#define SECONDS_PER_MINUTE          60
#define XBOX_SESSION_TIME_OUT        (10 * SECONDS_PER_MINUTE * MS_PER_SECOND)    // Survive 10 minutes in cache


BOOL g_fBackgroundThreadStarted; // Has the background thread started?
HANDLE g_hthWorker;             // Background worker thread
HANDLE g_hFlushDelayedActionsEvent = NULL; // Do we want to flush the delayed actions?

/*****************************************************************************
 *
 *    Global Timeout Info
 *
 *    We must allocate separate information to track timeouts.  Stashing
 *    the information into a buffer provided by the caller opens race
 *    conditions, if the caller frees the memory before we are ready.
 *
 *    dwTrigger is 0 if the timeout is being dispatched.  This avoids
 *    race conditions where one thread triggers a timeout manually
 *    while it is in progress.
 *
 *****************************************************************************/

struct GLOBALTIMEOUTINFO g_gti = { // Anchor of global timeout info list
    &g_gti,
    &g_gti,
    0, 0, 0
};



/*****************************************************************************
 *    TriggerDelayedAction
 *
 *    Unlink the node and dispatch the timeout procedure.
 *****************************************************************************/
void TriggerDelayedAction(LPGLOBALTIMEOUTINFO * phgti)
{
    LPGLOBALTIMEOUTINFO hgti = *phgti;

    *phgti = NULL;
    if (hgti)
    {
        ENTERCRITICAL;
        if (hgti->dwTrigger)
        {
            // Unlink the node
            hgti->hgtiPrev->hgtiNext = hgti->hgtiNext;
            hgti->hgtiNext->hgtiPrev = hgti->hgtiPrev;

            hgti->dwTrigger = 0;

            // Do the callback
            if (hgti->pfn)
                hgti->pfn(hgti->pvRef);
            LEAVECRITICAL;

            TraceMsg(TF_BKGD_THREAD, "TriggerDelayedAction(%#08lx) Freeing=%#08lx", phgti, hgti);
            DEBUG_CODE(memset(hgti, 0xFE, (UINT) LocalSize((HLOCAL)hgti)));

            LocalFree((LPVOID) hgti);
        }
        else
        {
            LEAVECRITICAL;
        }
    }
}


/*****************************************************************************
 *    XboxDelayedActionWorkerThread
 *
 *    This is the procedure that runs on the worker thread.  It waits
 *    for something to do, and if enough time elapses with nothing
 *    to do, it terminates.
 *
 *    Be extremely mindful of race conditions.  They are oft subtle
 *    and quick to anger.
 *****************************************************************************/
DWORD XboxDelayedActionWorkerThread(LPVOID pv)
{
    XBOXDebugMemLeak(DML_TYPE_THREAD | DML_BEGIN);

    // Tell the caller we started so they can continue.
    g_fBackgroundThreadStarted = TRUE;
    for (;;) 
    {
        DWORD msWait;

        // Determine how long we need to wait.  The critical section
        // is necessary to ensure we don't collide with SetDelayedAction.
        ENTERCRITICAL;
        if (g_gti.hgtiNext == &g_gti)
        {
            // Queue is empty
            msWait = XBOX_SESSION_TIME_OUT;
        }
        else
        {
            msWait = g_gti.hgtiNext->dwTrigger - GetTickCount();
        }
        LEAVECRITICAL;

        //  If a new delayed action gets added, no matter, because
        //  we will wake up from the sleep before the delayed action
        //  is due.
        ASSERTNONCRITICAL;
        if ((int)msWait > 0)
        {
            TraceMsg(TF_BKGD_THREAD, "XboxDelayedActionWorkerThread: Sleep(%d)", msWait);
            WaitForMultipleObjects(1, &g_hFlushDelayedActionsEvent, FALSE, msWait);
            TraceMsg(TF_BKGD_THREAD, "XboxDelayedActionWorkerThread: Sleep finished");
        }
        ENTERCRITICALNOASSERT;
        if ((g_gti.hgtiNext != &g_gti) && g_gti.hgtiNext && (g_gti.hgtiNext->phgtiOwner))
        {    // Queue has work
#pragma message("$$ BUGBUG -- Race condition")
            LEAVECRITICAL;
            TraceMsg(TF_BKGD_THREAD, "XboxDelayedActionWorkerThread: Dispatching");
            TriggerDelayedAction(g_gti.hgtiNext->phgtiOwner);
        }
        else
        {
            CloseHandle(InterlockedExchangePointer(&g_hthWorker, NULL));
            CloseHandle(InterlockedExchangePointer(&g_hFlushDelayedActionsEvent, NULL));
            LEAVECRITICALNOASSERT;
            TraceMsg(TF_BKGD_THREAD, "XboxDelayedActionWorkerThread: ExitThread");
            ExitThread(0);
        }
    }

    AssertMsg(0, TEXT("XboxDelayedActionWorkerThread() We should never get here or we are exiting the for loop incorrectly."));
    XBOXDebugMemLeak(DML_TYPE_THREAD | DML_END);
    return 0;
}


/*****************************************************************************
 *    SetDelayedAction
 *
 *    If there is a previous action, it is triggered.  (Not cancelled.)
 *
 *    In principle, we could've allocated into a private pointer, then
 *    stuffed the pointer in at the last minute, avoiding the need to
 *    take the critical section so aggressively.  But that would tend
 *    to open race conditions in the callers.  BUGBUG -- So?  I should
 *    fix the bugs instead of hacking around them like this.
 *****************************************************************************/
STDMETHODIMP SetDelayedAction(DELAYEDACTIONPROC pfn, LPVOID pvRef, LPGLOBALTIMEOUTINFO * phgti)
{
    TriggerDelayedAction(phgti);
    ENTERCRITICAL;
    if (!g_hthWorker)
    {
        DWORD dwThid;

        g_hFlushDelayedActionsEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (g_hFlushDelayedActionsEvent)
        {
            g_fBackgroundThreadStarted = FALSE;
            g_hthWorker = CreateThread(0, 0, XboxDelayedActionWorkerThread, 0, 0, &dwThid);
            if (g_hthWorker)
            {
                // We need to wait until the thread starts up
                // before we return. Otherwise, we may return to the
                // caller and they may free our COM object
                // which will unload our DLL.  The thread won't
                // start if we are in PROCESS_DLL_DETACH and we
                // spin waiting for them to start and stop.
                TraceMsg(TF_BKGD_THREAD, "SetDelayedAction: Thread created, waiting for it to start.");
                while (FALSE == g_fBackgroundThreadStarted)
                    Sleep(0);
                TraceMsg(TF_BKGD_THREAD, "SetDelayedAction: Thread started.");
            }
            else
            {
                CloseHandle(g_hFlushDelayedActionsEvent);
                g_hFlushDelayedActionsEvent = NULL;
            }
        }
    }

    if (g_hthWorker && EVAL(*phgti = (LPGLOBALTIMEOUTINFO) LocalAlloc(LPTR, sizeof(GLOBALTIMEOUTINFO))))
    {
        LPGLOBALTIMEOUTINFO hgti = *phgti;

        // Insert the node at the end (i.e., before the head)
        hgti->hgtiPrev = g_gti.hgtiPrev;
        g_gti.hgtiPrev->hgtiNext = hgti;

        g_gti.hgtiPrev = hgti;
        hgti->hgtiNext = &g_gti;

        // The "|1" ensures that dwTrigger is not zero
        hgti->dwTrigger = (GetTickCount() + XBOX_SESSION_TIME_OUT) | 1;

        hgti->pfn = pfn;
        hgti->pvRef = pvRef;
        hgti->phgtiOwner = phgti;

        //  Note that there is no need to signal the worker thread that
        //  there is new work to do, because he will always wake up on
        //  his own before the requisite time has elapsed.
        //
        //  This optimization relies on the fact that the worker thread
        //  idle time is less than or equal to our delayed action time.
        LEAVECRITICAL;
    }
    else
    {
        // Unable to create worker thread or alloc memory
        LEAVECRITICAL;
    }
    return S_OK;
}


HRESULT PurgeDelayedActions(void)
{
    HRESULT hr = E_FAIL;

    if (g_hFlushDelayedActionsEvent)
    {
        LPGLOBALTIMEOUTINFO hgti = g_gti.hgtiNext;

        // We need to set all the times to zero so all waiting
        // items will not be delayed.
        ENTERCRITICAL;
        while (hgti != &g_gti)
        {
            hgti->dwTrigger = (GetTickCount() - 3);    // Don't Delay...
            hgti = hgti->hgtiNext;  // Next...
        }
        LEAVECRITICAL;

        if (SetEvent(g_hFlushDelayedActionsEvent))
        {
            // We can't be in a critical section or our background
            // thread can't come alive.
            ASSERTNONCRITICAL;

            TraceMsg(TF_BKGD_THREAD, "PurgeDelayedActions: Waiting for thread to stop.");
            // Now just wait for the thread to finish.  Someone may kill
            // the thread so let's make sure we don't keep sleeping
            // if the thread died.
            while (g_hthWorker && (WAIT_TIMEOUT == WaitForSingleObject(g_hthWorker, 0)))
                Sleep(0);

            TraceMsg(TF_BKGD_THREAD, "PurgeDelayedActions: Thread stopped.");
            // Sleep 0.1 seconds in order to give enough time for caller
            // to call CloseHandle(), LEAVECRITICAL, ExitThread(0).
            // I would much prefer to call WaitForSingleObject() on
            // the thread handle but I can't do that in PROCESS_DLL_DETACH.
            Sleep(100);
            hr = S_OK;
        }
    }

    return hr;
}


BOOL AreOutstandingDelayedActions(void)
{
    return (g_gti.hgtiNext != &g_gti);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxglob.h ===
/*****************************************************************************
 *
 *	xboxglob.h - HGLOBAL babysitting
 *
 *	Included from xboxview.h
 *
 *****************************************************************************/

#ifndef _XBOXGLOB_H
#define _XBOXGLOB_H

/*****************************************************************************
 *
 *	This is the generic IUnknown wrapper that GlobalFree's its
 *	charge when released.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *	CXboxGlob
 *
 *	CXboxGlob is used as the punkForRelease when we hand a shared HGLOBAL
 *	out to somebody else.  We can't simply use the DataObject itself,
 *	because that would result in havoc if the DataObject itself decided
 *	to free the HGLOBAL while there were still outstanding references to it.
 *
 *	It's also used when we need a refcounted string.  Just put the
 *	string into the hglob and have fun.
 *
 *****************************************************************************/

class CXboxGlob          : public IUnknown
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

public:
    CXboxGlob();
    ~CXboxGlob(void);


    // Public Member Functions
    HRESULT SetHGlob(HGLOBAL hglob) {m_hglob = hglob; return S_OK;};
    HGLOBAL GetHGlob(void) {return m_hglob;};
    LPCTSTR GetHGlobAsTCHAR(void) {return (LPCTSTR) m_hglob;};


    // Friend Functions
    friend IUnknown * CXboxGlob_Create(HGLOBAL hglob);
    friend CXboxGlob * CXboxGlob_CreateStr(LPCTSTR pszStr);

protected:
    // Private Member Variables
    int m_cRef;

    HGLOBAL                 m_hglob;		// The HGLOBAL we are babysitting
};

#endif // _XBOXGLOB_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxicon.cpp ===
/*****************************************************************************
 *
 *    xboxicon.cpp - IExtractIcon interface
 *
 *****************************************************************************/

#include "priv.h"
#include "xboxicon.h"
#include "xboxurl.h"




INT GetXboxIcon(UINT uFlags, BOOL fIsRoot)
{
    INT nIcon = (uFlags & GIL_OPENICON) ? IDI_XBOXOPENFOLDER : IDI_XBOXFOLDER;

    if (fIsRoot)
        nIcon = IDI_XBOXSERVER;      // This is an XBOX Server Icon.

    return nIcon;
}



#ifndef UNICODE
#define PathFindExtensionA PathFindExtension
#endif

//===========================
// *** IExtractIconA Interface ***
//===========================

/*****************************************************************************\
    FUNCTION: GetIconLocation

    DESCRIPTION:
        Get the icon location from the registry.

    _UNDOCUMENTED_:  Not mentioned is that if you return GIL_NOTFILENAME,
    you should take steps to ensure uniqueness of the non-filename
    return value, to avoid colliding with non-filenames from other
    shell extensions.

    _UNDOCUMENTED_:  The inability of SHGetFileInfo to work properly
    on "magic internal" cached association icons like "*23" is not
    documented.  As a result of this "feature", the SHGFI_ICONLOCATION
    flag is useless.


    Actually, we can still use SHGetFileInfo; we'll use the shell's own
    feature against it.  We'll do a SHGFI_SYSICONINDEX and return that
    as the icon index, with "*" as the GIL_NOTFILENAME.


    _BUGBUG_: We don't handle the cases where we ought to use
    GIL_SIMULATEDOC.
\*****************************************************************************/
HRESULT CXboxIcon::GetIconLocation(UINT uFlags, LPSTR szIconFile, UINT cchMax, int *piIndex, UINT *pwFlags)
{
    static CHAR szXbnmspc[MAX_PATH] = "";

    if (0 == szXbnmspc[0])
        GetModuleFileNameA(HINST_THISDLL, szXbnmspc, ARRAYSIZE(szXbnmspc));

    // NOTE: This is negative because it's a resource index.
    *piIndex = (0 - GetXboxIcon(uFlags, m_nRoot));

    if (pwFlags)
        *pwFlags = GIL_PERCLASS; //(uFlags & GIL_OPENICON);

    StrCpyNA(szIconFile, szXbnmspc, cchMax);

    return S_OK;
}


//===========================
// *** IExtractIconW Interface ***
//===========================
HRESULT CXboxIcon::GetIconLocation(UINT uFlags, LPWSTR wzIconFile, UINT cchMax, int *piIndex, UINT *pwFlags)
{
    HRESULT hres;
    CHAR szIconFile[MAX_PATH];

    ASSERT_SINGLE_THREADED;
    hres = GetIconLocation(uFlags, szIconFile, ARRAYSIZE(szIconFile), piIndex, pwFlags);
    if (EVAL(SUCCEEDED(hres)))
        SHAnsiToUnicode(szIconFile, wzIconFile, cchMax);

    return hres;
}


//===========================
// *** IQueryInfo Interface ***
//===========================
HRESULT CXboxIcon::GetInfoTip(DWORD dwFlags, WCHAR **ppwszTip)
{
    ASSERT_SINGLE_THREADED;
    if (ppwszTip)       // The shell is stupid and doesn't check the return value.
        *ppwszTip = NULL;

//        SHStrDupW(L"", ppwszTip);

    return E_NOTIMPL;

/**************
    // This InfoTip will appear when the user hovers over an item in defview.
    // We don't want to support this now because it isn't needed and looks different
    // than the shell.

    HRESULT hr = E_FAIL;
    LPITEMIDLIST pidl;

    if (!ppwszTip)
        return E_INVALIDARG;

    *ppwszTip = NULL;
    if (m_pflHfpl && (pidl = m_pflHfpl->GetPidl(0)))
    {
        WCHAR wzToolTip[MAX_URL_STRING];

        hr = XboxPidl_GetDisplayName(pidl, wzItemName, ARRAYSIZE(wzItemName));
        if (EVAL(SUCCEEDED(hr)))
            hr = SHStrDupW(wzToolTip, ppwszTip);
    }

    return hr;
***********/
}

HRESULT CXboxIcon::GetInfoFlags(DWORD *pdwFlags)
{
    *pdwFlags = 0;
    return S_OK;
}




/*****************************************************************************
 *    CXboxIcon_Create
 *
 *    We just stash away the pflHfpl; the real work happens on the
 *    GetIconLocation call.
 *
 *    _HACKHACK_: psf = 0 if we are being called by the property sheet code.
 *****************************************************************************/
HRESULT CXboxIcon_Create(CXboxFolder * pff, CXboxPidlList * pflHfpl, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hres;
    CXboxIcon * pfi;

    *ppvObj = NULL;

    hres = CXboxIcon_Create(pff, pflHfpl, &pfi);
    if (EVAL(SUCCEEDED(hres)))
    {
        hres = pfi->QueryInterface(riid, ppvObj);
        pfi->Release();
    }

    return hres;
}


/*****************************************************************************
 *    CXboxIcon_Create
 *
 *    We just stash away the m_pflHfpl; the real work happens on the
 *    GetIconLocation call.
 *
 *    _HACKHACK_: psf = 0 if we are being called by the property sheet code.
 *****************************************************************************/
HRESULT CXboxIcon_Create(CXboxFolder * pff, CXboxPidlList * pflHfpl, CXboxIcon ** ppfi)
{
    HRESULT hres= E_OUTOFMEMORY;

    *ppfi = new CXboxIcon();
    if (EVAL(*ppfi))
    {
        IUnknown_Set(&(*ppfi)->m_pflHfpl, pflHfpl);
        if (pff && pff->IsRoot())
        {
            (*ppfi)->m_nRoot++;
        }
        hres = S_OK;
    }

    return hres;
}


/****************************************************\
    Constructor
\****************************************************/
CXboxIcon::CXboxIcon() : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_pflHfpl);
    ASSERT(!m_nRoot);

    INIT_SINGLE_THREADED_ASSERT;
    LEAK_ADDREF(LEAK_CXboxIcon);
}


/****************************************************\
    Destructor
\****************************************************/
CXboxIcon::~CXboxIcon()
{
    ATOMICRELEASE(m_pflHfpl);

    DllRelease();
    LEAK_DELREF(LEAK_CXboxIcon);
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CXboxIcon::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CXboxIcon::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CXboxIcon::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CXboxIcon, IExtractIconW),
        QITABENT(CXboxIcon, IExtractIconA),
        QITABENT(CXboxIcon, IQueryInfo),
        { 0 },
    };
    
    return QISearch(this, qit, riid, ppvObj);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxglob.cpp ===
/**************************************************************\
    FILE: xboxglob.cpp

    DESCRIPTION:
        Refcounted HGLOBAL.
\**************************************************************/

#include "priv.h"
#include "xboxglob.h"


/****************************************************\
    Constructor
\****************************************************/
CXboxGlob::CXboxGlob() : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_hglob);

    LEAK_ADDREF(LEAK_CXboxGlob);
}


/****************************************************\
    Destructor
\****************************************************/
CXboxGlob::~CXboxGlob()
{
    if (m_hglob)
        GlobalFree(m_hglob);

    DllRelease();
    LEAK_DELREF(LEAK_CXboxGlob);
}


//===========================
// *** IUnknown Interface ***
ULONG CXboxGlob::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CXboxGlob::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CXboxGlob::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, IUnknown*);
    }
    else
    {
        TraceMsg(TF_XBOXQI, "CXboxGlob::QueryInterface() failed.");
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}



/****************************************************\
    FUNCTION: CXboxGlob_Create
  
    DESCRIPTION:
        This function will create an instance of the
    CXboxGlob object.
\****************************************************/
IUnknown * CXboxGlob_Create(HGLOBAL hglob)
{
    IUnknown * punk = NULL;
    CXboxGlob * pfg = new CXboxGlob();

    if (pfg)
    {
        pfg->m_hglob = hglob;
        pfg->QueryInterface(IID_IUnknown, (LPVOID *)&punk);
        pfg->Release();
    }

    return punk;
}



/****************************************************\
    FUNCTION: CXboxGlob_CreateStr
  
    DESCRIPTION:
        This function will create an instance of the
    CXboxGlob object.
\****************************************************/
CXboxGlob * CXboxGlob_CreateStr(LPCTSTR pszStr)
{
    CXboxGlob * pfg = new CXboxGlob();

    if (EVAL(pfg))
        pfg->m_hglob = (HGLOBAL) pszStr;

    return pfg;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxeidl.h ===
/*****************************************************************************
 *	xboxeidl.h
 *****************************************************************************/

#ifndef _XBOXEIDL_H
#define _XBOXEIDL_H

#include "cowsite.h"


/*****************************************************************************
 *
 *	CXboxEidl
 *
 *	The stuff that tracks the state of an enumeration.
 *
 *****************************************************************************/

class CXboxEidl          : public IEnumIDList
                        , public CObjectWithSite
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    
    // *** IEnumIDList ***
    virtual STDMETHODIMP Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    virtual STDMETHODIMP Skip(ULONG celt);
    virtual STDMETHODIMP Reset(void);
    virtual STDMETHODIMP Clone(IEnumIDList **ppenum);

public:
    CXboxEidl();
    ~CXboxEidl(void);

    // Friend Functions
    friend HRESULT CXboxEidl_Create(CXboxDir * pfd, CXboxFolder * pff, HWND hwndOwner, DWORD shcontf, IEnumIDList ** ppenum);

protected:
    // Private Member Variables

    int                     m_cRef;
    BITBOOL                 m_fInited : 1;      // Have we been inited?
    BITBOOL                 m_fDead : 1;        // Is this enumerator dead because we had to do a redirect (because password was needed or was invalid).
    BITBOOL                 m_fErrorDisplayed : 1; // Only show one error per enum.  This is how we keep track.
    DWORD                   m_nIndex;           // Current Item in the list
    DWORD                   m_shcontf;          // Filter flags
    CXboxPidlList *          m_pflHfpl;          // Where the cache lives
    CXboxDir *               m_pfd;              // My XboxDir
    CXboxFolder *            m_pff;              // My XboxDir
    IMalloc *               m_pm;               // Today's itemid allocator
    HWND                    m_hwndOwner;        // My UI window
    HRESULT                 m_hrOleInited;      // We need to Init Ole because of Win95's Shell32 doesn't do that on the background enum thread.
// BUGBUG -- someday  int m_cHiddenFiles;


    // Public Member Functions
    BOOL _fFilter(DWORD shcontf, DWORD dwFAFLFlags);
    HRESULT _Init(void);
    LPITEMIDLIST _NextOne(DWORD * pdwIndex);
    HRESULT _PopulateItem(HINTERNET hint0, HINTPROCINFO * phpi);
    HRESULT _AddFindDataToPidlList(LPCITEMIDLIST pidl);
    HRESULT _HandleSoftLinks(HINTERNET hint, LPITEMIDLIST pidl, LPWIRESTR pwCurrentDir, DWORD cchSize);
    BOOL _IsNavigationItem(LPWIN32_FIND_DATA pwfd);
    static HRESULT _PopulateItemCB(HINTERNET hint0, HINTPROCINFO * phpi, LPVOID pvCXboxEidl, BOOL * pfReleaseHint) {return ((CXboxEidl *)pvCXboxEidl)->_PopulateItem(hint0, phpi);};

    
    // Friend Functions
    friend HRESULT CXboxEidl_Create(CXboxDir * pfd, CXboxFolder * pff, HWND hwndOwner, DWORD shcontf, CXboxEidl ** ppfe);
    friend HRESULT CXboxEidl_Create(CXboxDir * pfd, CXboxFolder * pff, HWND hwndOwner, DWORD shcontf, DWORD dwIndex, IEnumIDList ** ppenum);
};

#endif // _XBOXEIDL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxfldr.h ===
/*****************************************************************************\
    FILE: xboxfldr.h

    DESCRIPTION:
        This class inherits from CBaseFolder for a base ShellFolder implementation
    of IShellFolder and overrides methods to give Xbox Specific features.
\*****************************************************************************/

#ifndef _XBOXFOLDER_H
#define _XBOXFOLDER_H

#include "isf.h"
#include "xboxdir.h"
#include "xboxsite.h"
#include "xboxlist.h"
#include "xboxglob.h"
#include "ftppidl.h"
#include "xboxpidl.h"
#include "cowsite.h"
#include "util.h"

class CXboxDir;
class CXboxSite;


/*****************************************************************************\
     CXboxFolder
 
     The stuff that tracks the state of a folder.
 
     The cBusy field tracks how many sub-objects have been created
     (e.g., IEnumIDList) which still contain references to this
     folder's identity.  You cannot change the folder's identity
     (via IPersistFolder::Initialize) while there are outstanding
     subobjects.
 
     The number of cBusy's never exceeds the number of cRef's, because
     each subobject that requires the folder identity must retain a
     reference to the folder itself.  That way, the folder won't be
     Release()d while the identity is still needed.
\*****************************************************************************/

class CXboxFolder  : public CBaseFolder
                   , public IShellIcon
                   , public IShellIconOverlay
                   , public IDelegateFolder
                   , public IShellPropSheetExt
                   , public IBrowserFrameOptions
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) {return CBaseFolder::AddRef();};
    virtual STDMETHODIMP_(ULONG) Release(void) {return CBaseFolder::Release();};
    
    // *** IShellFolder ***
    virtual STDMETHODIMP ParseDisplayName(HWND hwndOwner, LPBC pbcReserved, LPOLESTR lpszDisplayName,
                                            ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes);
    virtual STDMETHODIMP EnumObjects(HWND hwndOwner, DWORD grfFlags, LPENUMIDLIST * ppenumIDList);
    virtual STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbcReserved, REFIID riid, LPVOID * ppvOut);
    virtual STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbcReserved, REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    virtual STDMETHODIMP CreateViewObject(HWND hwndOwner, REFIID riid, LPVOID * ppvOut);
    virtual STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl, ULONG * rgfInOut);
    virtual STDMETHODIMP GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl, REFIID riid, UINT * prgfInOut, LPVOID * ppvOut);
    virtual STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName);
    virtual STDMETHODIMP SetNameOf(HWND hwndOwner, LPCITEMIDLIST pidl, LPCOLESTR lpszName, DWORD uFlags, LPITEMIDLIST * ppidlOut);
    
    // *** IShellFolder2 ***
    virtual STDMETHODIMP GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv);

    // *** IPersistFolder ***
    virtual STDMETHODIMP Initialize(LPCITEMIDLIST pidl);        // Override default behavior

    // *** IShellIcon ***
    virtual STDMETHODIMP GetIconOf(LPCITEMIDLIST pidl, UINT flags, LPINT lpIconIndex);

    // *** IShellIconOverlay ***
    virtual STDMETHODIMP GetOverlayIndex(LPCITEMIDLIST pidl, int * pIndex) {return GetOverlayIndexHelper(pidl, pIndex, SIOM_OVERLAYINDEX);};
    virtual STDMETHODIMP GetOverlayIconIndex(LPCITEMIDLIST pidl, int * pIconIndex) {return GetOverlayIndexHelper(pidl, pIconIndex, SIOM_ICONINDEX);};

    // *** IDelegateFolder ***
    virtual STDMETHODIMP SetItemAlloc(IMalloc *pm);

    // *** IShellPropSheetExt ***
    virtual STDMETHODIMP AddPages(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam) {return AddXBOXPropertyPages(pfnAddPage, lParam, &m_hinstInetCpl, _punkSite);};
    virtual STDMETHODIMP ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE pfnReplaceWith, LPARAM lParam) {return E_NOTIMPL;};

    // *** IBrowserFrameOptions ***
    virtual STDMETHODIMP GetFrameOptions(IN BROWSERFRAMEOPTIONS dwMask, OUT BROWSERFRAMEOPTIONS * pdwOptions);


public:
    CXboxFolder();
    ~CXboxFolder(void);

    // Public Member Functions
    void InvalidateCache(void);
    CXboxDir * GetXboxDir(void);
    CXboxDir * GetXboxDirFromPidl(LPCITEMIDLIST pidl);
    CXboxDir * GetXboxDirFromUrl(LPCTSTR pszUrl);

    BOOL IsRoot(void) { return ILIsEmpty(GetPrivatePidlReference()); };
    BOOL IsUTF8Supported(void);
    BOOL _IsValidPidlParameter(LPCITEMIDLIST pidl);
    HRESULT GetItemAllocator(IMalloc **ppm);
    IMalloc * GetItemAllocatorDirect(void) {ASSERT(m_pm); return m_pm;};
    HRESULT GetUIObjectOfHfpl(HWND hwndOwner, CXboxPidlList * pflHfpl, REFIID riid, LPVOID * ppvObj, BOOL fFromCreateViewObject);
    HRESULT CreateSubViewObject(HWND hwndOwner, CXboxPidlList * pflHfpl, REFIID riid, LPVOID * ppvObj);
    HRESULT _PidlToMoniker(LPCITEMIDLIST pidl, IMoniker ** ppmk);
    HRESULT _CreateShellView(HWND hwndOwner, void ** ppvObj);
    CXboxGlob * GetSiteMotd(void);
    CWireEncoding * GetCWireEncoding(void);
    HRESULT _InitXboxSite(void);
    IMalloc * GetIMalloc(void);
    HRESULT _Initialize(LPCITEMIDLIST pidlTarget, LPCITEMIDLIST pidlRoot, int nBytesToPrivate);
    HRESULT _BindToObject_OriginalXboxSupport(LPCITEMIDLIST pidl, REFIID riid, LPVOID * ppvObj);
    HRESULT _FilterBadInput(LPCTSTR pszUrl, LPITEMIDLIST * ppidl);
    HRESULT _BindToObject(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlFull, IBindCtx * pbc, REFIID riid, LPVOID * ppvObj);
//    HRESULT AddToUrlHistory(LPCTSTR pszUrl);
    HRESULT AddToUrlHistory(LPCITEMIDLIST pidl);
    HRESULT AddToUrlHistory(void) {return AddToUrlHistory(this->GetPrivatePidlReference());};
    HRESULT GetOverlayIndexHelper(LPCITEMIDLIST pidl, int * pIndex, DWORD dwFlags);
    HRESULT _GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl, REFIID riid, UINT * prgfInOut, LPVOID * ppvOut, BOOL fFromCreateViewObject);

    static HRESULT FolderCompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
    {
        return XboxItemID_CompareIDs(lParam, pidl1, pidl2, FCMP_GROUPDIRS);
    };

    // Public Member Variables
    CXboxSite *             m_pfs;
    IMalloc *               m_pm;           // today's itemid allocator
    IUrlHistoryStg *        m_puhs;         // Used to add to the history list.
    HINSTANCE               m_hinstInetCpl; // HANDLE to Internet Control panel for View.Options.
    IShellIconOverlayManager * m_psiom;     // Used to get default icon overlays like shortcut cue.

    // Friend Functions
    friend HRESULT CXboxFolder_Create(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, int ib, REFIID riid, LPVOID * ppvObj);
    friend HRESULT CXboxFolder_Create(REFIID riid, LPVOID * ppvObj);

protected:
    HRESULT _CreateViewObject(HWND hwndOwner, REFIID riid, LPVOID * ppvObj);
    HRESULT _AddToUrlHistory(LPCWSTR pwzUrl);
    HRESULT _GetCachedPidlFromDisplayName(LPCTSTR pszDisplayName, LPITEMIDLIST * ppidl);
    HRESULT _ForPopulateAndEnum(CXboxDir * pfd, LPCITEMIDLIST pidlBaseDir, LPCTSTR pszUrl, LPCWIRESTR pwLastDir, LPITEMIDLIST * ppidl);
    HRESULT _InitLegacyShellFolder(IShellFolder * psfLegacy, LPCITEMIDLIST pidlInit);
	HRESULT _GetBindCtx(IBindCtx ** ppbc);
private:
    
    CXboxPidl *m_pidlRoot; //The absolute PIDL to Xbox root, we don't know or care how to parse it.
    CXboxPidl *m_pidl;     //The PIDL from Xbox root to this instance.

};

#endif // _XBOXFOLDER_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxicon.h ===
/*****************************************************************************
 *    xboxicon.h
 *****************************************************************************/

#ifndef _XBOXICON_H
#define _XBOXICON_H


INT GetXboxIcon(UINT uFlags, BOOL fIsRoot);

/*****************************************************************************
    CXboxIcon

    The stuff that tells the shell which icon to use.
    Just plain annoying.  No real work is happening.
    Fortunately, the shell does most of the real work.

    Again, note that the szName is a plain char and not a TCHAR,
    because UNIX filenames are always ASCII.

    Extract() returning S_FALSE means "Could you do it for me?  Thanks."
 *****************************************************************************/

class CXboxIcon          : public IExtractIconW
                        , public IExtractIconA
                        , public IQueryInfo
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    
    // *** IExtractIconA ***
    virtual STDMETHODIMP GetIconLocation(UINT uFlags, LPSTR szIconFile, UINT cchMax, int * piIndex, UINT * pwFlags);
    virtual STDMETHODIMP Extract(LPCSTR pszFile, UINT nIconIndex, HICON * phiconLarge, HICON * phiconSmall, UINT nIconSize) {return S_FALSE;};
    
    // *** IExtractIconW ***
    virtual STDMETHODIMP GetIconLocation(UINT uFlags, LPWSTR szIconFile, UINT cchMax, int * piIndex, UINT * pwFlags);
    virtual STDMETHODIMP Extract(LPCWSTR pszFile, UINT nIconIndex, HICON * phiconLarge, HICON * phiconSmall, UINT nIconSize) {return S_FALSE;};

    // *** IQueryInfo ***
    virtual STDMETHODIMP GetInfoTip(DWORD dwFlags, WCHAR **ppwszTip);
    virtual STDMETHODIMP GetInfoFlags(DWORD *pdwFlags);


public:
    CXboxIcon();
    ~CXboxIcon(void);
    // Friend Functions
    friend HRESULT CXboxIcon_Create(CXboxFolder * pff, CXboxPidlList * pflHfpl, REFIID riid, LPVOID * ppv);
    friend HRESULT CXboxIcon_Create(CXboxFolder * pff, CXboxPidlList * pflHfpl, CXboxIcon ** ppfm);

protected:
    // Private Member Variables
    int                     m_cRef;

    CXboxPidlList *          m_pflHfpl;      // XboxDir in which our pidls live
    int                     m_nRoot;        // Gross HACKHACK (see CXboxIcon_Create)
    SINGLE_THREADED_MEMBER_VARIABLE;

    // Private Member Functions
    int ParseIconLocation(LPSTR pszIconFile);
    void GetDefaultIcon(LPSTR szIconFile, UINT cchMax, HKEY hk);
    HRESULT GetIconLocHkey(LPSTR szIconFile, UINT cchMax, LPINT pi, HKEY hk);
};

#endif // _XBOXICON_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxinet.h ===
/*****************************************************************************
 *
 *	 xboxinit.h - Wrapper for WININET stuff
 *
 *****************************************************************************/

#ifndef _XBOXINET_H
#define _XBOXINET_H


HINTERNET GetWininetSessionHandle(void);
void UnloadWininet(void);


#endif // _XBOXINET_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxmi.cpp ===
/*****************************************************************************
 *
 *	xboxmi.cpp - IMalloc interface for allocing pidls
 *
 *****************************************************************************/

#include "priv.h"
#include "xboxmi.h"


/*****************************************************************************
 *	IMalloc::Alloc
 *****************************************************************************/

LPVOID CMallocItem::Alloc(ULONG cbSize)
{
    WORD cbActualSize = sizeof(DELEGATEITEMID) - 1 + cbSize;
    PDELEGATEITEMID pidl = (PDELEGATEITEMID)SHAlloc(cbActualSize + 2);

    if (pidl)
    {
        pidl->cbSize = cbActualSize;
        pidl->wOuter = 0x6646;          // "Ff"
        pidl->cbInner = (WORD)cbSize;
        *(WORD *)&(((BYTE *)pidl)[cbActualSize]) = 0;
    }

    return pidl;
}

/*****************************************************************************
 *	IMalloc::Realloc
 *****************************************************************************/

LPVOID CMallocItem::Realloc(LPVOID pv, ULONG cb)
{
    return NULL;
}

/*****************************************************************************
 *	IMalloc::Free
 *****************************************************************************/

void CMallocItem::Free(LPVOID pv)
{
    SHFree(pv);
}

/*****************************************************************************
 *	IMalloc::GetSize
 *****************************************************************************/

ULONG CMallocItem::GetSize(LPVOID pv)
{
    return (ULONG)-1;
}

/*****************************************************************************
 *	IMalloc::DidAlloc
 *****************************************************************************/

int CMallocItem::DidAlloc(LPVOID pv)
{
    return -1;
}

/*****************************************************************************
 *	IMalloc::HeapMinimize
 *****************************************************************************/

void CMallocItem::HeapMinimize(void)
{
    NULL;
}


/*****************************************************************************
 *	CMallocItem_Create
 *****************************************************************************/

HRESULT CMallocItem_Create(IMalloc ** ppm)
{
    HRESULT hres = E_OUTOFMEMORY;
    CMallocItem * pmi = new CMallocItem();

    if (pmi)
    {
        hres = pmi->QueryInterface(IID_IMalloc, (LPVOID *) ppm);
        pmi->Release();
    }

    return hres;
}


/****************************************************\
    Constructor
\****************************************************/
CMallocItem::CMallocItem() : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    LEAK_ADDREF(LEAK_CMallocItem);
}


/****************************************************\
    Destructor
\****************************************************/
CMallocItem::~CMallocItem()
{
    DllRelease();
    LEAK_DELREF(LEAK_CMallocItem);
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CMallocItem::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CMallocItem::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CMallocItem::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IMalloc))
    {
        *ppvObj = SAFECAST(this, IMalloc *);
    }
    else
    {
        TraceMsg(TF_XBOXQI, "CMallocItem::QueryInterface() failed.");
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxlist.h ===
/*****************************************************************************
 *	xboxlist.h
 *****************************************************************************/

#ifndef _XBOXLIST_H
#define _XBOXLIST_H

#include "util.h"


#define FLM_ADDED           0
#define FLM_FINALIZE        1



/*****************************************************************************
 *
 *	CXboxList
 *
 *****************************************************************************/

class CXboxList          : public IUnknown
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

public:
    CXboxList(PFNDPAENUMCALLBACK fncDestroy);
    ~CXboxList(void);

    // Public Member Functions
    HRESULT AppendItem(LPVOID pv);
    HRESULT InsertSorted(LPVOID pv, PFNDPACOMPARE pfnCompare, LPARAM lParam);
    LPVOID GetItemPtr(int nIndex)   { return DPA_GetPtr(m_hdpa, nIndex); };
    LPVOID Find(PFNDPACOMPARE pfn, LPCVOID pv);
    void Enum(PFNDPAENUMCALLBACK pfn, LPVOID pv) { DPA_EnumCallback(m_hdpa, pfn, pv); };
    void SetItemPtr(int nIndex, LPVOID pv)   { DPA_SetPtr(m_hdpa, nIndex, pv); };
    void DeleteItemPtr(LPVOID pv);
    void DeletePtrByIndex(int nIndex) {DPA_DeletePtr(m_hdpa, nIndex);};
    int GetCount(void)              { return DPA_GetPtrCount(m_hdpa); };
    int SortedSearch(LPVOID pv, PFNDPACOMPARE pfnCompare, LPARAM lParam, UINT options);


    // Friend Functions
    friend HRESULT CXboxList_Create(int cpvInit, PFNDPAENUMCALLBACK pfn, UINT nGrow, CXboxList ** ppfl);

protected:
    // Private Member Variables
    int                     m_cRef;

    HDPA                    m_hdpa;
    PFNDPAENUMCALLBACK      m_pfnDestroy;
};

#endif // _XBOXLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxmi.h ===
/*****************************************************************************
 *	xboxmi.h
 *****************************************************************************/

#ifndef _XBOXMALLOCITEM_H
#define _XBOXMALLOCITEM_H



/*****************************************************************************
 *
 *	CMallocItem
 *
 *	Really nothing doing.
 *
 *****************************************************************************/

class CMallocItem       : public IMalloc
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    
    // *** IMalloc ***
    virtual STDMETHODIMP_(LPVOID) Alloc(ULONG cb);
    virtual STDMETHODIMP_(LPVOID) Realloc(LPVOID pv, ULONG cb);
    virtual STDMETHODIMP_(void) Free(LPVOID pv);
    virtual STDMETHODIMP_(ULONG) GetSize(LPVOID pv);
    virtual STDMETHODIMP_(int) DidAlloc(LPVOID pv);
    virtual STDMETHODIMP_(void) HeapMinimize();

public:
    CMallocItem();
    ~CMallocItem(void);

    // Friend Functions
    friend HRESULT CMallocItem_Create(IMalloc ** ppm);

protected:
    int                     m_cRef;
};

#endif // _XBOXMALLOCITEM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxobj.cpp ===
/*****************************************************************************
 *
 *    xboxobj.cpp - IDataObject interface
 *
 *****************************************************************************/

#include "priv.h"
#include "xboxobj.h"
#include "xboxurl.h"
#include <shlwapi.h>


// CLSIDs
// {9FA6C2C3-852C-4aed-8CEB-C8FFEABF7921}
const GUID CLSID_XboxDataObject = { 0x9FA6C2C3, 0x852C, 0x4aed, 0x8c, 0xeb, 0xc8, 0xff, 0xea, 0xbf, 0x79, 0x21 };


/*****************************************************************************
 *
 *    g_dropTypes conveniently mirrors our FORMATETCs.
 *
 *    Hardly coincidence, of course.  Enum_Fe did the real work.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *    Preinitialized global data.
 *
 *****************************************************************************/
FORMATETC g_formatEtcOffsets;
FORMATETC g_formatPasteSucceeded;
CLIPFORMAT g_cfTargetCLSID;

FORMATETC g_dropTypes[] =
{
    { 0, 0, DVASPECT_CONTENT, -1, TYMED_ISTREAM },  // DROP_FCont
    { 0, 0, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },  // DROP_FGDW
    { 0, 0, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },  // DROP_FGDA
    { 0, 0, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },  // DROP_IDList
    { 0, 0, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },  // DROP_URL
//    { 0, 0, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },  // DROP_Offsets
    { 0, 0, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },  // DROP_PrefDe
    { 0, 0, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },  // DROP_PerfDe
    { 0, 0, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },  // DROP_XBOX_PRIVATE
    { 0, 0, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },  // DROP_OLEPERSIST - see _RenderOlePersist() for desc.
    { CF_HDROP, 0, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },  // DROP_Hdrop
    { 0, 0, DVASPECT_CONTENT, -1, TYMED_HGLOBAL }, // DROP_FNMA
    { 0, 0, DVASPECT_CONTENT, -1, TYMED_HGLOBAL }  // DROP_FNMW
};



/*****************************************************************************\
    GLOBAL: c_stgInit

    DESCRIPTION:
        Mostly straightforward.  The only major weirdness is that cfURL
    is delay-rendered iff the m_pflHfpl contains only one object.  Otherwise,
    cfURL is not supported.  (URLs can refer to only one object at a time.)
\*****************************************************************************/
STGMEDIUM c_stgInit[] =
{
    { 0, 0, 0 },  // DROP_FCont
    { TYMED_HGLOBAL, 0, 0 },    // DROP_FGDW - delay-rendered
    { TYMED_HGLOBAL, 0, 0 },    // DROP_FGDA - delay-rendered
    { TYMED_HGLOBAL, 0, 0 },    // DROP_IDList - delay-rendered
    { 0, 0, 0 },                // DROP_URL - opt delay-rendered
//    { 0, 0, 0 },                // DROP_Offsets
    { TYMED_HGLOBAL, 0, 0 },    // DROP_PrefDe - delay-rendered
    { 0, 0, 0 },                // DROP_PerfDe
    { TYMED_HGLOBAL, 0, 0 },    // DROP_XBOX_PRIVATE
    { TYMED_HGLOBAL, 0, 0 },    // DROP_OLEPERSIST - see _RenderOlePersist() for desc.
    { 0, 0, 0 },                // DROP_Hdrop
    { 0, 0, 0 },                // DROP_FNMA
    { 0, 0, 0 }                 // DROP_FNMW
};



/*****************************************************************************\
    FUNCTION: TraceMsgWithFormatEtc

    DESCRIPTION:
\*****************************************************************************/
void TraceMsgWithFormat(DWORD dwFlags, LPCSTR pszBefore, LPFORMATETC pFormatEtc, LPCSTR pszAfter, HRESULT hr)
{
#ifdef DEBUG
    TCHAR szFormatName[MAX_PATH];
    TCHAR szMedium[MAX_PATH];

    szFormatName[0] = 0;
    szMedium[0] = 0;
    if (pFormatEtc)
    {
        // This may fail if it's a basic format.
        if (!GetClipboardFormatName(pFormatEtc->cfFormat, szFormatName, ARRAYSIZE(szFormatName)))
            wnsprintf(szFormatName, ARRAYSIZE(szFormatName), TEXT("Pre-defined=%d"), pFormatEtc->cfFormat);

        switch (pFormatEtc->tymed)
        {
        case TYMED_HGLOBAL: StrCpyN(szMedium, TEXT("HGLOBAL"), ARRAYSIZE(szMedium)); break;
        case TYMED_FILE: StrCpyN(szMedium, TEXT("File"), ARRAYSIZE(szMedium)); break;
        case TYMED_GDI: StrCpyN(szMedium, TEXT("GDI"), ARRAYSIZE(szMedium)); break;
        case TYMED_MFPICT: StrCpyN(szMedium, TEXT("MFPICT"), ARRAYSIZE(szMedium)); break;
        case TYMED_ENHMF: StrCpyN(szMedium, TEXT("ENHMF"), ARRAYSIZE(szMedium)); break;
        case TYMED_ISTORAGE: StrCpyN(szMedium, TEXT("ISTORAGE"), ARRAYSIZE(szMedium)); break;
        case TYMED_ISTREAM: StrCpyN(szMedium, TEXT("ISTREAM"), ARRAYSIZE(szMedium)); break;
        }
    }
    else
    {
        szMedium[0] = 0;
    }

    TraceMsg(dwFlags, "%hs [FRMTETC: %ls, lndx: %d, %ls] hr=%#08lx, %hs", pszBefore, szFormatName, pFormatEtc->lindex, szMedium, hr, pszAfter);
#endif // DEBUG
}


/*****************************************************************************\
    FUNCTION: _IsLindexOkay
 
   DESCRIPTION:
    If ife != DROP_FCont, then pfeWant->lindex must be -1.
 
    If ife == DROP_FCont, then pfeWant->lindex must be in the range
    0 ... m_pflHfpl->GetCount() - 1
\*****************************************************************************/
BOOL CXboxObj::_IsLindexOkay(int ife, FORMATETC *pfeWant)
{
    BOOL fResult;

    if (ife != DROP_FCont)
        fResult = pfeWant->lindex == -1;
    else
        fResult = (LONG)pfeWant->lindex < m_pflHfpl->GetCount();

    return fResult;
}


/*****************************************************************************\
    FUNCTION: _FindData

    DESCRIPTION:
        Locate our FORMATETC/STGMEDIUM given a FORMATETC from somebody else.
    On success, stores the index found into *piOut.
 
    We do not allow clients to change the TYMED of a FORMATETC, so
    in fact checking the TYMED is what we want, even on a SetData.
\*****************************************************************************/
HRESULT CXboxObj::_FindData(FORMATETC *pfe, PINT piOut)
{
    int nIndex;
    HRESULT hres = DV_E_FORMATETC;

    *piOut = 0;
    for (nIndex = DROP_FCont; nIndex < DROP_OFFERMAX; nIndex++)
    {
        ASSERT(0 == (g_dropTypes[nIndex]).ptd);
        ASSERT(g_dropTypes[nIndex].dwAspect == DVASPECT_CONTENT);

        if ((pfe->cfFormat == g_dropTypes[nIndex].cfFormat) && !ShouldSkipDropFormat(nIndex))
        {
            if (EVAL(g_dropTypes[nIndex].ptd == NULL))
            {
                if (EVAL(pfe->dwAspect == DVASPECT_CONTENT))
                {
                    if (EVAL(g_dropTypes[nIndex].tymed & pfe->tymed))
                    {
                        if (EVAL(_IsLindexOkay(nIndex, pfe)))
                        {
                            *piOut = nIndex;
                            hres = S_OK;
                        }
                        else
                            hres = DV_E_LINDEX;
                    }
                    else
                        hres = DV_E_TYMED;
                }
                else
                    hres = DV_E_DVASPECT;
            }
            else
                hres = DV_E_DVTARGETDEVICE;
            break;
        }
    }

    return hres;
}


/*****************************************************************************\
    FUNCTION: _FindDataForGet
 
    DESCRIPTION:
        Locate our FORMATETC/STGMEDIUM given a FORMATETC from somebody else.
    On success, stores the index found into *piOut.  Unlike _FindData, we will
    fail the call if the data object doesn't currently have the clipboard format.
    (Delayed render counts as "currently having it".  What we are filtering out
    are formats for which GetData will necessarily fail.)
\*****************************************************************************/
HRESULT CXboxObj::_FindDataForGet(FORMATETC *pfe, PINT piOut)
{
    HRESULT hr = _FindData(pfe, piOut);

    // TODO: g_cfHIDA should return an array of pidls for each folder.
    //       If we do this, the caller will support creating Shortcuts
    //       (LNK files) that point to these pidls.  We may want to do 
    //       that later.

    if (SUCCEEDED(hr))
    {
        if (*piOut != DROP_FCont)
        {
            if (m_stgCache[*piOut].tymed)
            {
                // Do we have data at all?
                // (possibly delay-rendered)
            }
            else
                hr = DV_E_FORMATETC;        // I guess not
        }
        else
        {
            // File contents always okay
        }
    }

#ifdef DEBUG
    if (FAILED(hr))
    {
        //TraceMsg(TF_XBOXDRAGDROP, "CXboxObj::_FindDataForGet(FORMATETC.cfFormat=%d) Failed.", pfe->cfFormat);
        *piOut = 0xBAADF00D;
    }
#endif

    return hr;
}


// The following are used to enumerate sub directories when creating a list of pidls for
// a directory download (Xbox->FileSys).
typedef struct tagGENPIDLLIST
{
    CXboxPidlList *      ppidlList;
    IMalloc *           pm;
    IProgressDialog *   ppd;
    CWireEncoding *     pwe;
} GENPIDLLIST;


/*****************************************************************************\
     FUNCTION: ProcessItemCB
 
    DESCRIPTION:
        This function will add the specified pidl to the list.  It will then
    detect if it's a folder and if so, will call EnumFolder() to recursively
    enum it's contents and call ProcessItemCB() for each one.
 
    PARAMETERS:
\*****************************************************************************/
HRESULT ProcessItemCB(LPVOID pvFuncCB, HINTERNET hint, LPCITEMIDLIST pidlFull, BOOL * pfValidhinst, LPVOID pvData)
{
    GENPIDLLIST * pGenPidlList = (GENPIDLLIST *) pvData;
    HRESULT hr = S_OK;

    // Does the user want to cancel?
    if (pGenPidlList->ppd && pGenPidlList->ppd->HasUserCancelled())
    {
        EVAL(SUCCEEDED(pGenPidlList->ppd->StopProgressDialog()));
        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
    }

    if (SUCCEEDED(hr))
    {
        // No, don't cancel so continue...

        // Add everything except SoftLinks.
        // This is because dir SoftLinks may cause infinite recurion.
        // Someday, we may want to upload a shortcut but
        // that's too much work for now.
        if (0 != XboxPidl_GetAttributes(pidlFull))
        {
            // We exist to do this:
            pGenPidlList->ppidlList->InsertSorted(pidlFull);
        }

        // Is this a dir/folder that we need to recurse into?
        if (SUCCEEDED(hr) && (FILE_ATTRIBUTE_DIRECTORY & XboxPidl_GetAttributes(pidlFull)))
        {
            hr = EnumFolder((LPFNPROCESSITEMCB) pvFuncCB, hint, pidlFull, pGenPidlList->pwe, pfValidhinst, pvData);
        }
    }

    return hr;
}


/*****************************************************************************\
     FUNCTION: _ExpandPidlListRecursively
 
    DESCRIPTION:
        This function will take the pidl list (ppidlListSrc) and call into it
    to enumerate.  It will provide ProcessItemCB as the callback function.
    This function will help it create a new CXboxPidlList which will not only
    contain the pidls in a base folder, but also all the pidls in any subfolders
    that are in the original list.

    Delay-render a file group descriptor.
\*****************************************************************************/
CXboxPidlList * CXboxObj::_ExpandPidlListRecursively(CXboxPidlList * ppidlListSrc)
{
    GENPIDLLIST pep = {0};

    pep.ppidlList = NULL;
    pep.ppd = m_ppd;
    pep.pwe = m_pff->GetCWireEncoding();
    if (SUCCEEDED(CXboxPidlList_Create(0, NULL, &pep.ppidlList)))
    {
        m_pff->GetItemAllocator(&pep.pm);

        if (EVAL(m_pfd) && EVAL(pep.pm))
        {
            HINTERNET hint;

            if (SUCCEEDED(m_pfd->GetHint(NULL, NULL, &hint, NULL, m_pff)))
            {
                LPITEMIDLIST pidlRoot = ILClone(m_pfd->GetPidlReference());

                if (EVAL(pidlRoot))
                {
                    HRESULT hr = ppidlListSrc->RecursiveEnum(pidlRoot, ProcessItemCB, hint, (LPVOID) &pep);
                   
                    if (m_ppd)
                        EVAL(SUCCEEDED(m_ppd->StopProgressDialog()));

                    if (FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr) && !m_fErrAlreadyDisplayed)
                    {
                        pep.ppidlList->Release();
                        pep.ppidlList = NULL;

                        // Oh, I want a real hwnd, but where or where can I get one?
                        DisplayWininetErrorEx(NULL, TRUE, HRESULT_CODE(hr), IDS_XBOXERR_TITLE_ERROR, IDS_XBOXERR_DROPFAIL, IDS_XBOXERR_WININET, MB_OK, NULL, NULL);
                        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);  // Wrong permissions

                        // We need to suppress subsequent error dlgs from this location
                        // because callers like to ask for FILEGROUPDESCRIPTORA and
                        // if that fails, ask for FILEGROUPDESCRIPTORW and we don't
                        // want an error dialog for each.
                        m_fErrAlreadyDisplayed = TRUE;
                    }

                    ILFree(pidlRoot);
                }

                m_pfd->ReleaseHint(hint);
                pep.pm->Release();
            }
        }
    }

    return pep.ppidlList;
}


/*****************************************************************************\
    FUNCTION: _DelayRender_FGD

    DESCRIPTION:
        Delay-render a file group descriptor
\*****************************************************************************/
HGLOBAL CXboxObj::_DelayRender_FGD(BOOL fUnicode)
{
    HGLOBAL hGlobal = NULL;
    
    if (m_fCheckSecurity &&
        ZoneCheckPidlAction(SAFECAST(this, IInternetSecurityMgrSite *), URLACTION_SHELL_FILE_DOWNLOAD, m_pff->GetPrivatePidlReference(), (PUAF_DEFAULT | PUAF_WARN_IF_DENIED)))
    {
        m_pflHfpl->TraceDump(m_pff->GetPrivatePidlReference(), TEXT("_DelayRender_FGD() TraceDump before"));
        CXboxPidlList * pPidlList;
    
        if (!m_fFGDRendered)
        {
            pPidlList = _ExpandPidlListRecursively(m_pflHfpl);
            if (pPidlList)
            {
                // We succeeded so now it's expanded.
                m_fFGDRendered = TRUE;
            }
        }
        else
        {
            m_pflHfpl->AddRef();
            pPidlList = m_pflHfpl;
        }

        if (pPidlList)
        {
            hGlobal = Misc_HFGD_Create(pPidlList, m_pff->GetPrivatePidlReference(), fUnicode);
            IUnknown_Set(&m_pflHfpl, pPidlList);
            m_pflHfpl->TraceDump(m_pff->GetPrivatePidlReference(), TEXT("_DelayRender_FGD() TraceDump after"));
            pPidlList->Release();
        }
    }
    else
    {
        // Suppress future UI.  We don't need to check any more
        // because our pidl won't change.  We could not pass PUAF_WARN_IF_DENIED
        // but that won't suppress the UI in the prompt case. (Only admins can
        // turn on the prompt case).
        m_fCheckSecurity = FALSE;
    }

    return hGlobal;
}


/*****************************************************************************\
    FUNCTION: _DelayRender_IDList

    DESCRIPTION:
        Delay-render an ID List Array (HIDA)
\*****************************************************************************/
HRESULT CXboxObj::_DelayRender_IDList(STGMEDIUM * pStgMedium)
{
    pStgMedium->hGlobal = Misc_HIDA_Create(m_pff->GetPublicRootPidlReference(), m_pflHfpl);

    ASSERT(pStgMedium->hGlobal);
    return S_OK;
}


/*****************************************************************************\
    FUNCTION: _DelayRender_URL

    DESCRIPTION:
        The caller wants an URL in an Ansi String
\*****************************************************************************/
HRESULT CXboxObj::_DelayRender_URL(STGMEDIUM * pStgMedium)
{
    LPSTR pszUrl = NULL;
    LPITEMIDLIST pidlFull = NULL;
    LPITEMIDLIST pidl = m_pflHfpl->GetPidl(0);

    ASSERT(pidl);   // We need this
    // Sometimes m_pflHfpl->GetPidl(0) is fully qualified and
    // sometimes it's not.
    if (!XboxID_IsServerItemID(pidl))
    {
        pidlFull = ILCombine(m_pfd->GetPidlReference(), pidl);
        pidl = pidlFull;
    }

    ASSERT(m_pflHfpl->GetCount() == 1); // How do we give them more than 1 URL?
    if (pidl)
    {
        TCHAR szUrl[MAX_URL_STRING];

        if (EVAL(SUCCEEDED(UrlCreateFromPidl(pidl, SHGDN_FORADDRESSBAR, szUrl, ARRAYSIZE(szUrl), (ICU_ESCAPE | ICU_USERNAME), TRUE))))
        {
            DWORD cchSize = (lstrlen(szUrl) + 1);

            pszUrl = (LPSTR) LocalAlloc(LPTR, (cchSize * sizeof(CHAR)));
            if (EVAL(pszUrl))
                SHTCharToAnsi(szUrl, pszUrl, cchSize);
        }

        ILFree(pidlFull);
    }

    pStgMedium->hGlobal = (HGLOBAL) pszUrl;
    return S_OK;
}



#pragma BEGIN_CONST_DATA

DROPEFFECT c_deCopyLink = DROPEFFECT_COPY | DROPEFFECT_LINK;
DROPEFFECT c_deLink     =          DROPEFFECT_LINK;

#pragma END_CONST_DATA
/*****************************************************************************\
    FUNCTION: _DelayRender_PrefDe

    DESCRIPTION:
        Delay-render a preferred drop effect.
 
    The preferred drop effect is DROPEFFECT_COPY (with DROPEFFECT_LINK as fallback),
    unless you are dragging an XBOX site, in which case it's just DROPEFFECT_LINK.
 
    DROPEFFECT_MOVE is never preferred.  We can do it; it just isn't preferred.
 
    BUGBUG/NOTES: About DROPEFFECT_MOVE
    We cannot support Move on platforms before NT5 because of a Recycle Bin bug
    were it would clain to have succeeded with the copy but it actually didn't
    copy anything.  On NT5, the Recycle Bin drop target will call pDataObject->SetData()
    with a data type of "Dropped On" and the data being the CLSID of the drop
    target in addition to really copying the files to the recycle bin.  This will 
    let us delete the files knowing they are in the recycle bin.
\*****************************************************************************/
HRESULT CXboxObj::_DelayRender_PrefDe(STGMEDIUM * pStgMedium)
{
    DROPEFFECT * pde;

    if (!m_pfd->IsRoot())
        pde = &c_deCopyLink;
    else
        pde = &c_deLink;

    return Misc_CreateHglob(sizeof(*pde), pde, &pStgMedium->hGlobal);
}


/*****************************************************************************\
    FUNCTION: _RenderOlePersist

    DESCRIPTION:
        When the copy source goes away (the process shuts down), it calls
    OleFlushClipboard.  OLE will then copy our data, release us, and then
    give out our data later.  This works for most things except for:
    1. When lindex needs to very.  This doesn't work because ole doesn't know
       how to ask us how may lindexs they need to copy.
    2. If this object has a private interface OLE doesn't know about.  For us,
       it's IAsyncOperation.

   To get around this problem, we want OLE to recreate us when some possible
   paste target calls OleGetClipboard.  We want OLE to call OleLoadFromStream()
   to have us CoCreated and reload our persisted data via IPersistStream.
   OLE doesn't want to do this by default or they may have backward compat
   problems so they want a sign from the heavens, or at least from us, that
   we will work.  They ping our "OleClipboardPersistOnFlush" clipboard format
   to ask this.
\*****************************************************************************/
HRESULT CXboxObj::_RenderOlePersist(STGMEDIUM * pStgMedium)
{
    // The actual cookie value is opaque to the outside world.  Since
    // we don't use it either, we just leave it at zero in case we use
    // it in the future.  It's mere existence will cause OLE to do the
    // use our IPersistStream, which is what we want.
    DWORD dwCookie = 0;
    return Misc_CreateHglob(sizeof(dwCookie), &dwCookie, &pStgMedium->hGlobal);
}


/*****************************************************************************\
    FUNCTION: _RenderFGD

    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxObj::_RenderFGD(int nIndex, STGMEDIUM * pStgMedium)
{
    HRESULT hr = _DoProgressForLegacySystemsPre();

    if (SUCCEEDED(hr))
        pStgMedium->hGlobal = _DelayRender_FGD((DROP_FGDW == nIndex) ? TRUE : FALSE);

    if (!pStgMedium->hGlobal)
        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);    // Probably failed because of Zones check.

    return hr;
}


/*****************************************************************************\
    FUNCTION: _ForceRender

    DESCRIPTION:
        We previously delayed rendering the data for perf reasons.  This function
    was called, so we now need to render the data.
\*****************************************************************************/
HRESULT CXboxObj::_ForceRender(int nIndex)
{
    HRESULT hr = S_OK;

    // We only support HGLOBALs here, but the caller may be valid
    // to ask for something we don't support or an extended data.
    //    ASSERT((m_stgCache[nIndex].tymed) == TYMED_HGLOBAL);

    if (!m_stgCache[nIndex].hGlobal)
    {
        STGMEDIUM medium = {TYMED_HGLOBAL, 0, NULL};

        switch (nIndex)
        {
        case DROP_FCont:
            ASSERT(0);
            break;
        case DROP_FGDW:
        case DROP_FGDA:
            hr = _RenderFGD(nIndex, &medium);
            break;
        case DROP_IDList:
            hr = _DelayRender_IDList(&medium);
            break;
/* Nuke
        case DROP_Offsets:
            ASSERT(0);
//            hglob = _DelayRender_Offsets();
            break;
*/
        case DROP_PrefDe:
            hr = _DelayRender_PrefDe(&medium);
            break;
        case DROP_PerfDe:
            ASSERT(0);
//            hglob = _DelayRender_PerfDe();
            break;
        case DROP_XBOX_PRIVATE:
            hr = DV_E_FORMATETC;
            break;
        case DROP_OLEPERSIST:
            hr = _RenderOlePersist(&medium);
            break;
        case DROP_Hdrop:
            ASSERT(0);
//            hglob = _DelayRender_Hdrop();
            break;
        case DROP_FNMA:
            ASSERT(0);
//            hglob = _DelayRender_FNM();
            break;
        case DROP_FNMW:
            ASSERT(0);
//            hglob = _DelayRender_FNM();
            break;
        case DROP_URL:
            hr = _DelayRender_URL(&medium);
            break;
        default:
            ASSERT(0);      // Should never hit.
            break;
        }

        if (medium.hGlobal)  // Will fail if the Zones Security Check Fails.
        {
            m_stgCache[nIndex].pUnkForRelease = NULL;
            m_stgCache[nIndex].hGlobal = medium.hGlobal;
        }
        else
        {
            if (S_OK == hr)
                hr = E_OUTOFMEMORY;
        }
    }

    if (FAILED(hr))
        TraceMsg(TF_XBOXDRAGDROP, "CXboxObj::_ForceRender() FAILED. hres=%#08lx", hr);

    return hr;
}


/*****************************************************************************\
    FUNCTION: _DoProgressForLegacySystemsPre

    DESCRIPTION:
        Shell's pre-NT5 didn't do progress on the File Contents drop, so we
    will do it here.  This function will display a progress dialog while we
    walk the server and expand the pidls that are needed to be copied.
    Later, 
\*****************************************************************************/
HRESULT CXboxObj::_DoProgressForLegacySystemsPre(void)
{
    HRESULT hr = S_OK;

    if (DEBUG_LEGACY_PROGRESS || (SHELL_VERSION_NT5 > GetShellVersion()))
    {
        TraceMsg(TF_ALWAYS, "CXboxObj::_DoProgressForLegacySystemsPre() going to do the Legacy dialogs.");

        // Do we need to initialize the list?
        if (!m_ppd && (-1 == m_nStartIndex))
        {
            // Yes, so create the create the dialog and find the sizes of the list.
            if (m_ppd)
                _CloseProgressDialog();

            m_uliCompleted.QuadPart = 0;
            m_uliTotal.QuadPart = 0;
            m_ppd = CProgressDialog_CreateInstance(IDS_COPY_TITLE, IDA_XBOXDOWNLOAD);
            if (EVAL(m_ppd))
            {
                WCHAR wzProgressDialogStr[MAX_PATH];

                // Tell the user we are calculating how long it will take.
                if (EVAL(LoadStringW(HINST_THISDLL, IDS_PROGRESS_DOWNLOADTIMECALC, wzProgressDialogStr, ARRAYSIZE(wzProgressDialogStr))))
                    EVAL(SUCCEEDED(m_ppd->SetLine(2, wzProgressDialogStr, FALSE, NULL)));

                // We give a NULL punkEnableModless because we don't want to go modal.
                EVAL(SUCCEEDED(m_ppd->StartProgressDialog(NULL, NULL, PROGDLG_AUTOTIME, NULL)));
           }
        }
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: _DoProgressForLegacySystemsStart

    DESCRIPTION:
        Shell's pre-NT5 didn't do progress on the File Contents drop, so we
    will do it here.  Only return FAILED(hr) if IProgressDialog::HasUserCancelled().
\*****************************************************************************/
HRESULT CXboxObj::_DoProgressForLegacySystemsStart(LPCITEMIDLIST pidl, int nIndex)
{
    HRESULT hr = S_OK;

    if (DEBUG_LEGACY_PROGRESS || (SHELL_VERSION_NT5 > GetShellVersion()))
    {
        TraceMsg(TF_ALWAYS, "CXboxObj::_DoProgressForLegacySystemsStart() going to do the Legacy dialogs.");

        // Do we need to initialize the list?
        if (-1 == m_nStartIndex)
            hr = _SetProgressDialogValues(nIndex);   // Yes, so do so.

        if (EVAL(m_ppd))
        {
            WCHAR wzTemplate[MAX_PATH];
            WCHAR wzPath[MAX_PATH];
            WCHAR wzStatusText[MAX_PATH];
            LPITEMIDLIST pidlBase = (LPITEMIDLIST) pidl;

            EVAL(SUCCEEDED(m_ppd->StartProgressDialog(NULL, NULL, PROGDLG_AUTOTIME, NULL)));

            // Generate the string "Downloading <FileName>..." status string
            EVAL(LoadStringW(HINST_THISDLL, IDS_DOWNLOADING, wzTemplate, ARRAYSIZE(wzTemplate)));
            wnsprintfW(wzStatusText, ARRAYSIZE(wzStatusText), wzTemplate, XboxPidl_GetLastItemDisplayName(pidl));
            EVAL(SUCCEEDED(m_ppd->SetLine(1, wzStatusText, FALSE, NULL)));

            if (XboxPidl_IsDirectory(pidl, FALSE))
            {
                pidlBase = ILClone(pidl);
                ILRemoveLastID(pidlBase);
            }

            // Generate the string "From <SrcFileDir>" status string
            GetDisplayPathFromPidl(pidlBase, wzPath, ARRAYSIZE(wzPath), TRUE);
            EVAL(LoadStringW(HINST_THISDLL, IDS_DL_SRC_DIR, wzTemplate, ARRAYSIZE(wzTemplate)));
            wnsprintfW(wzStatusText, ARRAYSIZE(wzStatusText), wzTemplate, wzPath);
            EVAL(SUCCEEDED(m_ppd->SetLine(2, wzStatusText, FALSE, NULL)));

            EVAL(SUCCEEDED(m_ppd->SetProgress64(m_uliCompleted.QuadPart, m_uliTotal.QuadPart)));
            TraceMsg(TF_ALWAYS, "CXboxObj::_DoProgressForLegacySystemsStart() SetProgress64(%#08lx, %#08lx)", m_uliCompleted.LowPart, m_uliTotal.LowPart);
            if (m_ppd->HasUserCancelled())
                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);

            if (pidlBase != pidl)   // Did we allocated it?
                ILFree(pidlBase);
        }
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: _DoProgressForLegacySystemsPost

    DESCRIPTION:
        Shell's pre-NT5 didn't do progress on the File Contents drop, so we
    will do it here.  Only return FAILED(hr) if IProgressDialog::HasUserCancelled().
\*****************************************************************************/
HRESULT CXboxObj::_DoProgressForLegacySystemsPost(LPCITEMIDLIST pidl, BOOL fLast)
{
    HRESULT hr = S_OK;

    if ((DEBUG_LEGACY_PROGRESS || (SHELL_VERSION_NT5 > GetShellVersion())) && EVAL(m_ppd))
    {
        if (pidl)
        {
            // Add the file size to the Completed.
            m_uliCompleted.QuadPart += XboxPidl_GetFileSize(pidl);
        }

        TraceMsg(TF_ALWAYS, "CXboxObj::_DoProgressForLegacySystemsPost() Closing DLG");

        if (fLast)
            IUnknown_Set((IUnknown **)&m_ppd, NULL);    // The stream will close the dialog and release it.
    }

    return hr;
}


HRESULT CXboxObj::_SetProgressDialogValues(int nIndex)
{
    HRESULT hr = S_OK;

    m_nStartIndex = nIndex;
    if (EVAL(m_ppd))
    {
        // Calculate m_nEndIndex
        while (nIndex < m_pflHfpl->GetCount())
        {
            if (!XboxPidl_IsDirectory(m_pflHfpl->GetPidl(nIndex), FALSE))
                m_nEndIndex = nIndex;
            nIndex++;
        }

        for (nIndex = 0; nIndex < m_pflHfpl->GetCount(); nIndex++)
        {
            LPCITEMIDLIST pidl = m_pflHfpl->GetPidl(nIndex);
            m_uliTotal.QuadPart += XboxPidl_GetFileSize(pidl);
        }

        // Reset because the above for loop can take a long time and the estimated time
        // is based on the time between ::StartProgressDialog() and the first
        // ::SetProgress() call.
        EVAL(SUCCEEDED(m_ppd->Timer(PDTIMER_RESET, NULL)));
   }

    return hr;
}


HRESULT CXboxObj::_CloseProgressDialog(void)
{
    m_nStartIndex = -1; // Indicate we haven't inited yet.
    if (m_ppd)
    {
        EVAL(SUCCEEDED(m_ppd->StopProgressDialog()));
        IUnknown_Set((IUnknown **)&m_ppd, NULL);
    }
    return S_OK;
}


HRESULT CXboxObj::_RefThread(void)
{
    if (NULL == m_punkThreadRef)
    {
        // This is valid to fail from some hosts who won't go away,
        // so they don't need to support ref counting threads.
        SHGetThreadRef(&m_punkThreadRef);
    }

    return S_OK;
}


HRESULT CXboxObj::_RenderFileContents(LPFORMATETC pfe, LPSTGMEDIUM pstg)
{
    HRESULT hr = E_INVALIDARG;

    // callers have a bad habit of asking for lindex == -1 because
    // that means 'all' data.  But how can you hand out one IStream* for
    // all files?
    if (-1 != pfe->lindex)
    {
        LPITEMIDLIST pidl = m_pflHfpl->GetPidl(pfe->lindex);
        //    FileContents are always regenerated afresh.
        pstg->pUnkForRelease = 0;
        pstg->tymed = TYMED_ISTREAM;

        if (EVAL(pidl))
        {
            hr = _DoProgressForLegacySystemsStart(pidl, pfe->lindex);
            if (SUCCEEDED(hr))
            {
                // Is it a directory?
                if (XboxPidl_IsDirectory(pidl, FALSE))
                {
                    // Yes, so pack the name and attributes
                    hr = DV_E_LINDEX;
                    AssertMsg(0, TEXT("Someone is asking for a FILECONTENTs for a directory item."));
                }
                else
                {
                    // No, so give them the stream.
                    
                    // shell32 v5 will display progress dialogs, but we need to
                    // display progress dialogs for shell32 v3 or v4.  We do this
                    // by creating the progress dialog when the caller asks for the
                    // first stream.  We then need to find out when they call for
                    // the last stream and then hand off the IProgressDialog to the
                    // CXboxStm.  The CXboxStm will then close down the dialog when the
                    // caller closes it.
                    hr = CXboxStm_Create(m_pfd, pidl, GENERIC_READ, &pstg->pstm, m_uliCompleted, m_uliTotal, m_ppd, (pfe->lindex == m_nEndIndex));
                    EVAL(SUCCEEDED(_DoProgressForLegacySystemsPost(pidl, (pfe->lindex == m_nEndIndex))));
                }
            }
            else
            {
                // The user may have cancelled
                ASSERT(HRESULT_FROM_WIN32(ERROR_CANCELLED) == hr);
            }
        }

        if (FAILED(hr))
            _CloseProgressDialog();
    }

    //TraceMsg(TF_XBOXDRAGDROP, "CXboxObj::GetData() CXboxStm_Create() returned hr=%#08lx", hr);
    return hr;
}


/*****************************************************************************\
    FUNCTION: IsEqualFORMATETC
  
    DESCRIPTION:
        The two fields of a FORMATETC that need to match to be equivalent are:
    cfFormat and lindex.
\*****************************************************************************/
BOOL IsEqualFORMATETC(FORMATETC * pfe1, FORMATETC * pfe2)
{
    BOOL fIsEqual = FALSE;

    if ((pfe1->cfFormat == pfe2->cfFormat) && (pfe1->lindex == pfe2->lindex))
    {
        fIsEqual = TRUE;
    }

    return fIsEqual;
}


/*****************************************************************************\
      FUNCTION: _FreeExtraData
  
      DESCRIPTION:
\*****************************************************************************/
int CXboxObj::_DSA_FreeCB(LPVOID pvItem, LPVOID pvlparam)
{
    FORMATETC_STGMEDIUM * pfs = (FORMATETC_STGMEDIUM *) pvItem;

    if (EVAL(pfs))
        ReleaseStgMedium(&(pfs->medium));

    return 1;
}


/*****************************************************************************\
      FUNCTION: _FindSetDataIndex
  
      DESCRIPTION:
\*****************************************************************************/
int CXboxObj::_FindExtraDataIndex(FORMATETC *pfe)
{
    int nIndex;

    for (nIndex = (DSA_GetItemCount(m_hdsaSetData) - 1); nIndex >= 0; nIndex--)
    {
        FORMATETC_STGMEDIUM * pfs = (FORMATETC_STGMEDIUM *) DSA_GetItemPtr(m_hdsaSetData, nIndex);

        if (IsEqualFORMATETC(pfe, &pfs->formatEtc))
        {
            return nIndex;
        }
    }

    return -1;
}


/*****************************************************************************\
      FUNCTION: _SetExtraData
  
      DESCRIPTION:
        We don't render the data, but we will carry it because someone may need
      or want it.  This is the case with the drag source's defview pushing in
      the icon points via CFSTR_SHELLIDLISTOFFSET for the drop target.
\*****************************************************************************/
HRESULT CXboxObj::_SetExtraData(FORMATETC *pfe, STGMEDIUM *pstg, BOOL fRelease)
{
    HRESULT hr;
    int nIndex = _FindExtraDataIndex(pfe);

    // Do we already have someone's copy?
    if (-1 == nIndex)
    {
        FORMATETC_STGMEDIUM fs;

        fs.formatEtc = *pfe;

        // If there is a pointer, copy the data because we can't maintain the lifetime
        // of the pointer.
        if (fs.formatEtc.ptd)
        {
            fs.dvTargetDevice = *(pfe->ptd);
            fs.formatEtc.ptd = &fs.dvTargetDevice;
        }

        hr = CopyStgMediumWrap(pstg, &fs.medium);
        if (EVAL(SUCCEEDED(hr)))
        {
            // No, so just append it to the end.
            DSA_AppendItem(m_hdsaSetData, &fs);
        }
    }
    else
    {
        FORMATETC_STGMEDIUM fs;

        DSA_GetItem(m_hdsaSetData, nIndex, &fs);
        // Free the previous guy.
        ReleaseStgMedium(&fs.medium);

        // Yes, so Replace it.
        hr = CopyStgMediumWrap(pstg, &fs.medium);
        if (EVAL(SUCCEEDED(hr)))
        {
            // Replace the data.
            DSA_SetItem(m_hdsaSetData, nIndex, &fs);
        }
    }

    return hr;
}


typedef struct
{
    DWORD dwVersion;
    DWORD dwExtraSize;   // After pidl list
    BOOL fFGDRendered;
    DWORD dwReserved1;
    DWORD dwReserved2;
} XBOXDATAOBJ_PERSISTSTRUCT;


/*****************************************************************************\
    FUNCTION: FormatEtcSaveToStream

    DESCRIPTION:
\*****************************************************************************/
HRESULT FormatEtcSaveToStream(IStream *pStm, FORMATETC * pFormatEtc)
{
    HRESULT hr = E_INVALIDARG;

    if (pStm)
    {
        // We don't support ptd because where would the allocation be
        // on the load?
        if (EVAL(NULL == pFormatEtc->ptd))
        {
            WCHAR szFormatName[MAX_PATH];

            if (EVAL(GetClipboardFormatNameW(pFormatEtc->cfFormat, szFormatName, ARRAYSIZE(szFormatName))))
            {
                DWORD cbFormatNameSize = ((lstrlenW(szFormatName) + 1) * sizeof(szFormatName[0]));

                hr = pStm->Write(pFormatEtc, SIZEOF(*pFormatEtc), NULL);
                if (EVAL(SUCCEEDED(hr)))
                {
                    hr = pStm->Write(&cbFormatNameSize, SIZEOF(cbFormatNameSize), NULL);
                    if (EVAL(SUCCEEDED(hr)))
                    {
                        hr = pStm->Write(szFormatName, cbFormatNameSize, NULL);
                    }
                }
            }
            else
                hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: FormatEtcLoadFromStream

    DESCRIPTION:
\*****************************************************************************/
HRESULT FormatEtcLoadFromStream(IStream *pStm, FORMATETC * pFormatEtc)
{
    HRESULT hr = E_INVALIDARG;

    if (pStm)
    {
        hr = pStm->Read(pFormatEtc, SIZEOF(*pFormatEtc), NULL);
        ASSERT(NULL == pFormatEtc->ptd);    // We don't support this.

        if (EVAL(SUCCEEDED(hr)))
        {
            DWORD cbFormatNameSize;

            hr = pStm->Read(&cbFormatNameSize, SIZEOF(cbFormatNameSize), NULL);
            if (EVAL(SUCCEEDED(hr)))
            {
                WCHAR szFormatName[MAX_PATH];

                hr = pStm->Read(szFormatName, cbFormatNameSize, NULL);
                if (EVAL(SUCCEEDED(hr)))
                {
                    pFormatEtc->cfFormat = (CLIPFORMAT)RegisterClipboardFormatW(szFormatName);
                }
            }
        }
        else
            hr = HRESULT_FROM_WIN32(GetLastError());

    }

    return hr;
}


typedef struct
{
    DWORD dwVersion;
    DWORD dwExtraSize;               // After this struct
    DWORD dwTymed;              // What type of data is stored?
    BOOL fUnkForRelease;        // Did we save the object after this?
    DWORD dwReserved1;          //
    DWORD dwReserved2;          //
} STGMEDIUM_PERSISTSTRUCT;

/*****************************************************************************\
    FUNCTION: StgMediumSaveToStream

    DESCRIPTION:
\*****************************************************************************/
HRESULT StgMediumSaveToStream(IStream *pStm, STGMEDIUM * pMedium)
{
    HRESULT hr = E_INVALIDARG;

    if (pStm)
    {
        STGMEDIUM_PERSISTSTRUCT smps = {0};

        smps.dwVersion = 1;
        smps.dwTymed = pMedium->tymed;

        switch (pMedium->tymed)
        {
        case TYMED_HGLOBAL:
        {
            IStream * pstmHGlobal;

            hr = CreateStreamOnHGlobal(pMedium->hGlobal, FALSE, &pstmHGlobal);
            if (EVAL(SUCCEEDED(hr)))
            {
                STATSTG statStg;

                hr = pstmHGlobal->Stat(&statStg, STATFLAG_NONAME);
                if (EVAL(SUCCEEDED(hr)))
                {
                    ASSERT(!statStg.cbSize.HighPart);
                    smps.dwExtraSize = statStg.cbSize.LowPart;
                    hr = pStm->Write(&smps, SIZEOF(smps), NULL);
                    if (EVAL(SUCCEEDED(hr)))
                        hr = pstmHGlobal->CopyTo(pStm, statStg.cbSize, NULL, NULL);
                }

                pstmHGlobal->Release();
            }
        }
        break;

        case TYMED_FILE:
            smps.dwExtraSize = ((lstrlenW(pMedium->lpszFileName) + 1) * sizeof(WCHAR));

            hr = pStm->Write(&smps, SIZEOF(smps), NULL);
            if (EVAL(SUCCEEDED(hr)))
            {
                hr = pStm->Write(pMedium->lpszFileName, smps.dwExtraSize, NULL);
                ASSERT(SUCCEEDED(hr));
            }
            break;

        case TYMED_GDI:
        case TYMED_MFPICT:
        case TYMED_ENHMF:
        case TYMED_ISTORAGE:
        case TYMED_ISTREAM:
        default:
            ASSERT(0);  // What are you doing?  Impl this if you need it.
            hr = E_NOTIMPL;
            break;
        }
    }

    return hr;
}


LPWSTR OLESTRAlloc(DWORD cchSize)
{
    return (LPWSTR) new WCHAR [cchSize + 1];
}


/*****************************************************************************\
    FUNCTION: StgMediumLoadFromStream

    DESCRIPTION:
\*****************************************************************************/
HRESULT StgMediumLoadFromStream(IStream *pStm, STGMEDIUM * pMedium)
{
    HRESULT hr = E_INVALIDARG;

    if (pStm && pMedium)
    {
        STGMEDIUM_PERSISTSTRUCT smps;

        pMedium->pUnkForRelease = NULL;
        hr = pStm->Read(&smps, SIZEOF(smps), NULL);
        if (EVAL(SUCCEEDED(hr)))
        {
            pMedium->tymed = smps.dwTymed;
            ASSERT(!pMedium->pUnkForRelease);

            switch (pMedium->tymed)
            {
            case TYMED_HGLOBAL:
            {
                IStream * pstmTemp;
                hr = CreateStreamOnHGlobal(NULL, FALSE, &pstmTemp);
                if (EVAL(SUCCEEDED(hr)))
                {
                    ULARGE_INTEGER uli = {0};

                    uli.LowPart = smps.dwExtraSize;
                    hr = pStm->CopyTo(pstmTemp, uli, NULL, NULL);
                    if (EVAL(SUCCEEDED(hr)))
                    {
                        hr = GetHGlobalFromStream(pstmTemp, &pMedium->hGlobal);
                    }

                    pstmTemp->Release();
                }
            }
            break;

            case TYMED_FILE:
                pMedium->lpszFileName = OLESTRAlloc(smps.dwExtraSize / sizeof(WCHAR));
                if (pMedium->lpszFileName)
                    hr = pStm->Read(pMedium->lpszFileName, smps.dwExtraSize, NULL);
                else
                    hr = E_OUTOFMEMORY;
                break;

            case TYMED_GDI:
            case TYMED_MFPICT:
            case TYMED_ENHMF:
            case TYMED_ISTORAGE:
            case TYMED_ISTREAM:
            default:
                ASSERT(0);  // What are you doing?  Impl this if you need it.
                // Some future version must have done the save, so skip the
                // data so we don't leave unread data.
                if (0 != smps.dwExtraSize)
                {
                    LARGE_INTEGER li = {0};

                    li.LowPart = smps.dwExtraSize;
                    EVAL(SUCCEEDED(pStm->Seek(li, STREAM_SEEK_CUR, NULL)));
                }
                hr = E_NOTIMPL;
                break;
            }
        }
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: FORMATETC_STGMEDIUMSaveToStream

    DESCRIPTION:
\*****************************************************************************/
HRESULT FORMATETC_STGMEDIUMSaveToStream(IStream *pStm, FORMATETC_STGMEDIUM * pfdops)
{
    HRESULT hr = E_INVALIDARG;

    if (pStm)
    {
        hr = FormatEtcSaveToStream(pStm, &pfdops->formatEtc);
        if (EVAL(SUCCEEDED(hr)))
            hr = StgMediumSaveToStream(pStm, &pfdops->medium);
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: FORMATETC_STGMEDIUMLoadFromStream

    DESCRIPTION:
\*****************************************************************************/
HRESULT FORMATETC_STGMEDIUMLoadFromStream(IStream *pStm, FORMATETC_STGMEDIUM * pfdops)
{
    HRESULT hr = E_INVALIDARG;

    if (pStm)
    {
        hr = FormatEtcLoadFromStream(pStm, &pfdops->formatEtc);
        if (EVAL(SUCCEEDED(hr)))
            hr = StgMediumLoadFromStream(pStm, &pfdops->medium);
    }

    return hr;
}



/////////////////////////////////
////// IAsynchDataObject Impl
/////////////////////////////////


/*****************************************************************************\
    FUNCTION: IAsyncOperation::GetAsyncMode

    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxObj::GetAsyncMode(BOOL * pfIsOpAsync)
{
    *pfIsOpAsync = TRUE;
    return S_OK;
}
  

/*****************************************************************************\
    FUNCTION: IAsyncOperation::StartOperation

    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxObj::StartOperation(IBindCtx * pbcReserved)
{
    ASSERT(!pbcReserved);
    m_fDidAsynchStart = TRUE;

    return S_OK;
}
  

/*****************************************************************************\
    FUNCTION: IAsyncOperation::InOperation

    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxObj::InOperation(BOOL * pfInAsyncOp)
{
    if (m_fDidAsynchStart)
        *pfInAsyncOp = TRUE;
    else
        *pfInAsyncOp = FALSE;

    return S_OK;
}
  

/*****************************************************************************\
    FUNCTION: IAsyncOperation::EndOperation

    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxObj::EndOperation(HRESULT hResult, IBindCtx * pbcReserved, DWORD dwEffects)
{
    if (SUCCEEDED(hResult) &&
        (DROPEFFECT_MOVE == dwEffects))
    {
        CXboxPidlList * pPidlListNew = CreateRelativePidlList(m_pff, m_pflHfpl);

        if (pPidlListNew)
        {
            Misc_DeleteHfpl(m_pff, GetDesktopWindow(), pPidlListNew);
            pPidlListNew->Release();
        }
    }
 
    m_fDidAsynchStart = FALSE;
    return S_OK;
}
  


/////////////////////////////////
////// IPersistStream Impl
/////////////////////////////////


/*****************************************************************************\
    FUNCTION: IPersistStream::Load

    DESCRIPTION:
        See IPersistStream::Save() for the layout of the stream.
\*****************************************************************************/
HRESULT CXboxObj::Load(IStream *pStm)
{
    HRESULT hr = E_INVALIDARG;

    if (pStm)
    {
        XBOXDATAOBJ_PERSISTSTRUCT fdoss;
        DWORD dwNumPidls;
        DWORD dwNumStgMedium;

        hr = pStm->Read(&fdoss, SIZEOF(fdoss), NULL);   // #1
        // If we rev the version, read it now (fdoss.dwVersion)

        if (EVAL(SUCCEEDED(hr)))
        {
            LPITEMIDLIST pidl = NULL;       // ILLoadFromStream frees the param

            ASSERT(!m_pff);
            m_fFGDRendered = fdoss.fFGDRendered;

            hr = ILLoadFromStream(pStm, &pidl); // #2
            if (EVAL(SUCCEEDED(hr)))
            {
                hr = SHBindToIDList(pidl, NULL, IID_CXboxFolder, (void **)&m_pff);
                if (EVAL(SUCCEEDED(hr)))
                    m_pfd = m_pff->GetXboxDir();

                ASSERT(m_pfd);
                ILFree(pidl);
            }
        }

        if (EVAL(SUCCEEDED(hr)))
        {
            hr = pStm->Read(&dwNumPidls, SIZEOF(dwNumPidls), NULL);  // #3
            if (EVAL(SUCCEEDED(hr)))
                hr = CXboxPidlList_Create(0, NULL, &m_pflHfpl);
        }

        if (EVAL(SUCCEEDED(hr)))
        {
            for (int nIndex = 0; (nIndex < (int)dwNumPidls) && SUCCEEDED(hr); nIndex++)
            {
                LPITEMIDLIST pidl = NULL;       // ILLoadFromStream frees the param

                hr = ILLoadFromStream(pStm, &pidl); // #4
                if (EVAL(SUCCEEDED(hr)))
                {
                    hr = m_pflHfpl->InsertSorted(pidl);
                    ILFree(pidl);
                }
            }
        }

        if (EVAL(SUCCEEDED(hr)))
            hr = pStm->Read(&dwNumStgMedium, SIZEOF(dwNumStgMedium), NULL);  // #5

        if (EVAL(SUCCEEDED(hr)))
        {
            for (int nIndex = 0; (nIndex < (int)dwNumStgMedium) && SUCCEEDED(hr); nIndex++)
            {
                FORMATETC_STGMEDIUM fs;

                hr = FORMATETC_STGMEDIUMLoadFromStream(pStm, &fs);   // #6
                if (EVAL(SUCCEEDED(hr)))
                    DSA_AppendItem(m_hdsaSetData, &fs);
            }
        }

        if (EVAL(SUCCEEDED(hr)))
        {
            // We may be reading a version newer than us, so skip their data.
            if (0 != fdoss.dwExtraSize)
            {
                LARGE_INTEGER li = {0};
                
                li.LowPart = fdoss.dwExtraSize;
                hr = pStm->Seek(li, STREAM_SEEK_CUR, NULL);
            }
        }
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: IPersistStream::Save

    DESCRIPTION:
        The stream will be layed out in the following way:

    Version 1:
        1. XBOXDATAOBJ_PERSISTSTRUCT - Constant sized data.
        <PidlList BEGIN>
            2. PIDL pidl - Pidl for m_pff.  It will be a public pidl (fully qualified
                        from the shell root)
            3. DWORD dwNumPidls - Number of pidls coming.
            4. PIDL pidl(n) - Pidl in slot (n) of m_pflHfpl
        <PidlList END>
        5. DWORD dwNumStgMedium - Number of FORMATETC_STGMEDIUMs coming
        6. FORMATETC_STGMEDIUM fmtstg(n) - dwNumStgMedium FORMATETC_STGMEDIUMs.
\*****************************************************************************/
HRESULT CXboxObj::Save(IStream *pStm, BOOL fClearDirty)
{
    HRESULT hr = E_INVALIDARG;

    if (pStm)
    {
        XBOXDATAOBJ_PERSISTSTRUCT fdoss = {0};
        DWORD dwNumPidls = m_pflHfpl->GetCount();
        DWORD dwNumStgMedium = DSA_GetItemCount(m_hdsaSetData);

        fdoss.dwVersion = 1;
        fdoss.fFGDRendered = m_fFGDRendered;
        hr = pStm->Write(&fdoss, SIZEOF(fdoss), NULL);  // #1
        if (EVAL(SUCCEEDED(hr)))
        {
            ASSERT(m_pff);
            hr = ILSaveToStream(pStm, m_pff->GetPublicRootPidlReference()); // #2
        }

        if (EVAL(SUCCEEDED(hr)))
            hr = pStm->Write(&dwNumPidls, SIZEOF(dwNumPidls), NULL);  // #3

        if (EVAL(SUCCEEDED(hr)))
        {
            for (int nIndex = 0; (nIndex < (int)dwNumPidls) && SUCCEEDED(hr); nIndex++)
            {
                LPITEMIDLIST pidlCur = m_pflHfpl->GetPidl(nIndex);

                ASSERT(pidlCur);
                hr = ILSaveToStream(pStm, pidlCur); // #4
            }
        }

        if (EVAL(SUCCEEDED(hr)))
            hr = pStm->Write(&dwNumStgMedium, SIZEOF(dwNumStgMedium), NULL);  // #5

        if (EVAL(SUCCEEDED(hr)))
        {
            for (int nIndex = 0; (nIndex < (int)dwNumStgMedium) && SUCCEEDED(hr); nIndex++)
            {
                FORMATETC_STGMEDIUM fs;

                DSA_GetItem(m_hdsaSetData, nIndex, &fs);

                hr = FORMATETC_STGMEDIUMSaveToStream(pStm, &fs);   // #6
            }
        }

    }

    return hr;
}


#define MAX_STREAM_SIZE    (500 * 1024) // 500k
/*****************************************************************************\
    FUNCTION: IPersistStream::GetSizeMax

    DESCRIPTION:
        Now this is tough.  I can't calculate the real value because I don't know
    how big the hglobals are going to be for the user provided data.  I will
    assume everything fits in
\*****************************************************************************/
HRESULT CXboxObj::GetSizeMax(ULARGE_INTEGER * pcbSize)
{
    if (pcbSize)
    {
        pcbSize->HighPart = 0;
        pcbSize->LowPart = MAX_STREAM_SIZE;
    }
    
    return E_NOTIMPL;
}


/////////////////////////////////
////// IDataObject Impl
/////////////////////////////////

/*****************************************************************************\
    FUNCTION: IDataObject::GetData

    DESCRIPTION:
        Render the data in the requested format and put it into the
    STGMEDIUM structure.
\*****************************************************************************/
HRESULT CXboxObj::GetData(LPFORMATETC pfe, LPSTGMEDIUM pstg)
{
    int ife;
    HRESULT hr;

    hr = _FindDataForGet(pfe, &ife);
    if (SUCCEEDED(hr))
    {
        if (ife == DROP_FCont)
            hr = _RenderFileContents(pfe, pstg);
        else
        {
            hr = _ForceRender(ife);
            if (SUCCEEDED(hr))  // May not succeed for security reasons.
            {
                ASSERT(m_stgCache[ife].hGlobal);

                // It's possible to use the hacking STGMEDIUM.pUnkForRelease to give away
                // pointers to our data, but we then need massive amounts of code to babysite
                // the lifetime of those pointers.  This becomes more work when ::SetData() can
                // replace that data, so we just take the hit of the memcpy for less code.
                hr = CopyStgMediumWrap(&m_stgCache[ife], pstg);
                ASSERT(SUCCEEDED(hr));
                ASSERT(NULL == pstg->pUnkForRelease);
                //TraceMsg(TF_XBOXDRAGDROP, "CXboxObj::GetData() pstg->hGlobal=%#08lx. pstg->pUnkForRelease=%#08lx.", pstg->hGlobal, pstg->pUnkForRelease);
            }
        }

        TraceMsgWithFormat(TF_XBOXDRAGDROP, "CXboxObj::GetData()", pfe, "Format in static list", hr);
    }
    else
    {
        int nIndex = _FindExtraDataIndex(pfe);

        if (-1 == nIndex)
            hr = E_FAIL;
        else
        {
            FORMATETC_STGMEDIUM fs;

            DSA_GetItem(m_hdsaSetData, nIndex, &fs);
            hr = CopyStgMediumWrap(&fs.medium, pstg);
        }

        TraceMsgWithFormat(TF_XBOXDRAGDROP, "CXboxObj::GetData()", pfe, "Looking in dyn list", hr);
    }

    return hr;
}


/*****************************************************************************\
    IDataObject::GetDataHere

    Render the data in the requested format and put it into the
    object provided by the caller.
\*****************************************************************************/
HRESULT CXboxObj::GetDataHere(FORMATETC *pfe, STGMEDIUM *pstg)
{
    TraceMsg(TF_XBOXDRAGDROP, "CXboxObj::GetDataHere() pfe->cfFormat=%d.", pfe->cfFormat);
    return E_NOTIMPL;
}



/*****************************************************************************\
    FUNCTION: IDataObject::QueryGetData

    DESCRIPTION:
       Indicate whether we could provide data in the requested format.
\*****************************************************************************/
HRESULT CXboxObj::QueryGetData(FORMATETC *pfe)
{
    int ife;
    HRESULT hr = _FindDataForGet(pfe, &ife);
    
    if (FAILED(hr))
    {
        // If it wasn't one of the types we offer, see if it was given to us via
        // IDataObject::SetData().
        int nIndex = _FindExtraDataIndex(pfe);

        if (-1 != nIndex)
            hr = S_OK;
    }

    TraceMsgWithFormat(TF_XBOXDRAGDROP, "CXboxObj::QueryGetData()", pfe, "", hr);
    return hr;
}


/*****************************************************************************\
      FUNCTION: IDataObject::GetCanonicalFormatEtc
  
      DESCRIPTION:
      Our data are not sensitive to device-specific renderings,
      so we do what the book tells us to do.
 
      Or we *try* to do what the book tells us to do.
 
      OLE random documentation of the day:
      IDataObject::GetCanonicalFormatEtc.
 
      Turns out that the man page contradicts itself within sentences:
 
         DATA_S_SAMEFORMATETC - The FORMATETC structures are the same
                    and NULL is returned in pfeOut.
 
         If the data object never provides device-specific renderings,
         the implementation of IDataObject::GetCanonicalFormatEtc
         simply copies the input FORMATETC to the output FORMATETC,
         stores a null in the ptd field, and returns DATA_S_SAMEFORMATETC.
 
      And it turns out that the shell doesn't do *either* of these things.
      It just returns DATA_S_SAMEFORMATETC and doesn't touch pfeOut.
 
      The book is even more confused.  Under pfeOut, it says
 
         The value is NULL if the method returns DATA_S_SAMEFORMATETC.
 
      This makes no sense.  The caller provides the value of pfeOut.
      How can the caller possibly know that the method is going to return
      DATA_S_SAMEFORMATETC before it calls it?  If you expect the
      method to write "pfeOut = 0" before returning, you're nuts.  That
      communicates nothing to the caller.
 
      I'll just do what the shell does.
\*****************************************************************************/
HRESULT CXboxObj::GetCanonicalFormatEtc(FORMATETC *pfeIn, FORMATETC *pfeOut)
{
    return DATA_S_SAMEFORMATETC;
}


/*****************************************************************************\
      FUNCTION: IDataObject::SetData
  
      DESCRIPTION:
      We let people change TYMED_HGLOBAL gizmos, but nothing else.
  
      We need to do a careful two-step when replacing the HGLOBAL.
      If the user gave us a plain HGLOBAL without a pUnkForRelease,
      we need to invent our own pUnkForRelease to track it.  But we
      don't want to release the old STGMEDIUM until we're sure we
      can accept the new one.
  
      fRelease == 0 makes life doubly interesting, because we also
      have to clone the HGLOBAL (and remember to free the clone on the
      error path).
  
      _SOMEDAY_/TODO -- Need to support PerformedDropEffect so we can
      clean up stuff on a cut/paste.
\*****************************************************************************/
HRESULT CXboxObj::SetData(FORMATETC *pfe, STGMEDIUM *pstg, BOOL fRelease)
{
    int ife;
    HRESULT hr;

    hr = _FindData(pfe, &ife);
    if (SUCCEEDED(hr))
    {
        if (ife == DROP_FCont)
        {
            TraceMsg(TF_XBOXDRAGDROP, "CXboxObj::SetData(FORMATETC.cfFormat=%d) ife == DROP_FCont", pfe->cfFormat);
            hr = DV_E_FORMATETC;
        }
        else
        {
            ASSERT(g_dropTypes[ife].tymed == TYMED_HGLOBAL);
            ASSERT(pstg->tymed == TYMED_HGLOBAL);
            if (EVAL(pstg->hGlobal))
            {
                STGMEDIUM stg = {0};

                hr = CopyStgMediumWrap(pstg, &stg);
                if (EVAL(SUCCEEDED(hr)))
                {
                    ReleaseStgMedium(&m_stgCache[ife]);
                    m_stgCache[ife] = stg;
                }
            }
            else
            {            // Tried to SetData a _DelayRender
                hr = DV_E_STGMEDIUM;    // You idiot you
            }
        }

        TraceMsgWithFormat(TF_XBOXDRAGDROP, "CXboxObj::SetData()", pfe, "in static list", hr);
    }
    else
    {
        hr = _SetExtraData(pfe, pstg, fRelease);
        TraceMsgWithFormat(TF_XBOXDRAGDROP, "CXboxObj::SetData()", pfe, "in dyn list", hr);
    }

    return hr;
}


/*****************************************************************************\
      FUNCTION: IDataObject::EnumFormatEtc
  
      DESCRIPTION:
        _UNDOCUMENTED_:  If you drag something from a DefView, it will
      check the data object to see if it has a hida.  If so, then it
      will cook up a CFSTR_SHELLIDLISTOFFSET *for you* and SetData
      the information into the data object.  So in order to get
      position-aware drag/drop working, you must allow DefView to change
      your CFSTR_SHELLIDLISTOFFSET.
 
     We allow all FORMATETCs to be modified except for FileContents.
\*****************************************************************************/
HRESULT CXboxObj::EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppenum)
{
    HRESULT hres;

    switch (dwDirection)
    {
    case DATADIR_GET:
        hres = CXboxEfe_Create(DROP_OFFERMAX - DROP_FCont, &g_dropTypes[DROP_FCont],
                   &m_stgCache[DROP_FCont], this, ppenum);
        TraceMsg(TF_XBOXDRAGDROP, "CXboxObj::EnumFormatEtc(DATADIR_GET) CXboxEfe_Create() returned hres=%#08lx", hres);
        break;

    case DATADIR_SET:
        hres = CXboxEfe_Create(DROP_OFFERMAX - DROP_OFFERMIN, &g_dropTypes[DROP_OFFERMIN],
                   &m_stgCache[DROP_OFFERMIN], NULL, ppenum);
        TraceMsg(TF_XBOXDRAGDROP, "CXboxObj::EnumFormatEtc(DATADIR_SET) CXboxEfe_Create() returned hres=%#08lx", hres);
        break;

    default:
        ASSERT(0);
        hres = E_NOTIMPL;
        break;
    }

    return hres;
}


/*****************************************************************************\
      FUNCTION: IDataObject::DAdvise
  
      DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxObj::DAdvise(FORMATETC *pfe, DWORD advfl, IAdviseSink *padv, DWORD *pdwConnection)
{
    return OLE_E_ADVISENOTSUPPORTED;
}


/*****************************************************************************\
      FUNCTION: IDataObject::DUnadvise
  
      DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxObj::DUnadvise(DWORD dwConnection)
{
    return OLE_E_ADVISENOTSUPPORTED;
}


/*****************************************************************************\
      FUNCTION: IDataObject::EnumDAdvise
  
      DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxObj::EnumDAdvise(IEnumSTATDATA **ppeadv)
{
    return OLE_E_ADVISENOTSUPPORTED;
}


/*****************************************************************************\
      FUNCTION: CXboxObj_Create
  
      DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxObj_Create(CXboxFolder * pff, CXboxPidlList * pflHfpl, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hres;
    CXboxObj * pfo;

    *ppvObj = NULL;

    hres = CXboxObj_Create(pff, pflHfpl, &pfo);
    if (EVAL(SUCCEEDED(hres)))
    {
        pfo->QueryInterface(riid, ppvObj);
        pfo->Release();
    }

     return hres;
}


/*****************************************************************************\
      FUNCTION: CXboxObj_Create
  
      DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxObj_Create(CXboxFolder * pff, CXboxPidlList * pflHfpl, CXboxObj ** ppfo)
{
    HRESULT hres = S_OK;

    if (EVAL(pflHfpl->GetCount()))
    {
        *ppfo = new CXboxObj();

        if (EVAL(*ppfo))
        {
            CXboxObj * pfo = *ppfo;
            pfo->m_pfd = pff->GetXboxDir();

            if (EVAL(pfo->m_pfd))
            {
                pfo->m_pff = pff;
                if (pff)
                    pff->AddRef();

                IUnknown_Set(&pfo->m_pflHfpl, pflHfpl);
                
                if (pfo->m_pflHfpl->GetCount() == 1)
                {
                    pfo->m_stgCache[DROP_URL].tymed = TYMED_HGLOBAL;
                }
            }
            else
            {
                hres = E_FAIL;
                (*ppfo)->Release();
                *ppfo = NULL;
            }
        }
        else
            hres = E_OUTOFMEMORY;

    }
    else
    {
        *ppfo = NULL;
        hres = E_INVALIDARG;        /* Trying to get UI object of nil? */
    }

    return hres;
}


/*****************************************************************************\
    FUNCTION: CXboxObj_Create

    DESCRIPTION:
        This will be called by the Class Factory when the IDataObject gets
    persisted and then wants to be recreated in a new process. (Happens
    after the original thread/process calls OleFlushClipboard.
\*****************************************************************************/
HRESULT CXboxObj_Create(REFIID riid, void ** ppvObj)
{
    HRESULT hr = E_OUTOFMEMORY;
    CXboxObj * pfo = new CXboxObj();

    *ppvObj = NULL;
    if (pfo)
    {
        hr = pfo->QueryInterface(riid, ppvObj);
        pfo->Release();
    }

     return hr;
}

#define SETDATA_GROWSIZE        3

/****************************************************\
    Constructor
\****************************************************/
CXboxObj::CXboxObj() : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_pff);
    ASSERT(!m_pfd);
    ASSERT(!m_pflHfpl);
    ASSERT(!m_fDidAsynchStart);

    // NT #245306: If the user drags files from an XBOX window (Thread 1)
    //    to a shell window (Thread 2), the shell window will do
    //    the drop on a background thread (thread 3).  Since the
    //    UI thread is no longer blocked, the user can now close
    //    the window.  The problem is that OLE is using Thread 2
    //    for marshalling.  In order to solve this problem, we
    //    ref count the thread for items that rely on it.
    //    This include XBOX, normal Download, and other things
    //    in the future.
//    SHIncrementThreadModelessCount();

    m_nStartIndex = -1; // -1 means we don't know the start.
    m_fFGDRendered = FALSE;
    m_fCheckSecurity = TRUE;      // We need to keep checking.

    m_hdsaSetData = DSA_Create(sizeof(FORMATETC_STGMEDIUM), SETDATA_GROWSIZE);

    for (int nIndex = 0; nIndex < ARRAYSIZE(c_stgInit); nIndex++)
    {
        ASSERT(nIndex < ARRAYSIZE(m_stgCache));
        m_stgCache[nIndex] = c_stgInit[nIndex];
    }

    _RefThread();
    // The receiver may use us in the background, so make sure that our thread
    // doesn't go away.
    LEAK_ADDREF(LEAK_CXboxObj);
}


/****************************************************\
    Destructor
\****************************************************/
CXboxObj::~CXboxObj()
{
    int ife;

    _CloseProgressDialog();
    for (ife = DROP_OFFERMIN; ife < DROP_OFFERMAX; ife++)
    {
        ReleaseStgMedium(&m_stgCache[ife]);
    }

    if (m_ppd)
        m_ppd->StopProgressDialog();

    IUnknown_Set((IUnknown **)&m_ppd, NULL);
    IUnknown_Set(&m_pff, NULL);
    IUnknown_Set(&m_pfd, NULL);
    IUnknown_Set(&m_pflHfpl, NULL);

    DSA_DestroyCallback(m_hdsaSetData, &_DSA_FreeCB, NULL);

    // NT #245306: If the user drags files from an XBOX window (Thread 1)
    //    to a shell window (Thread 2), the shell window will do
    //    the drop on a background thread (thread 3).  Since the
    //    UI thread is no longer blocked, the user can now close
    //    the window.  The problem is that OLE is using Thread 2
    //    for marshalling.  In order to solve this problem, we
    //    ref count the thread for items that rely on it.
    //    This include XBOX, normal Download, and other things
    //    in the future.
    ATOMICRELEASE(m_punkThreadRef);

    DllRelease();
    LEAK_DELREF(LEAK_CXboxObj);
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CXboxObj::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CXboxObj::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}


HRESULT CXboxObj::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CXboxObj, IDataObject),
        QITABENT(CXboxObj, IInternetSecurityMgrSite),
        QITABENT(CXboxObj, IPersist),
        QITABENT(CXboxObj, IPersistStream),
        QITABENT(CXboxObj, IAsyncOperation),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxlist.cpp ===
/*****************************************************************************\
    CXboxList.cpp - Internal list manager

    It is the caller's responsibility to manage any needed serialization.
\*****************************************************************************/

#include "priv.h"
#include "xboxlist.h"


/*****************************************************************************\
    FUNCTION: CXboxList::DeleteItemPtr

    Remove the element "pv" from the array.
\*****************************************************************************/

void CXboxList::DeleteItemPtr(LPVOID pv)
{
    int nIndex;

    ASSERT(m_hdpa);
    nIndex = DPA_GetPtrIndex(m_hdpa, pv);
    TraceMsg(TF_XBOXLIST, "CXboxList::DeleteItemPtr(pv=%#08lx) this=%#08lx, nIndex=%d", pv, this, nIndex);

    if (-1 != nIndex)
        DPA_DeletePtr(m_hdpa, nIndex);
}


/*****************************************************************************\
    FUNCTION: AppendItem

    Add a new pv to the growing array.
\*****************************************************************************/
HRESULT CXboxList::AppendItem(LPVOID pv)
{
    ASSERT(m_hdpa);
    DPA_AppendPtr(m_hdpa, pv);
    //TraceMsg(TF_XBOXLIST, "CXboxList::AppendItem(pv=%#08lx) this=%#08lx", pv, this);

    return S_OK;
}


/*****************************************************************************\
    FUNCTION: InsertSorted

    Add a new pv to the growing array.
\*****************************************************************************/
HRESULT CXboxList::InsertSorted(LPVOID pv, PFNDPACOMPARE pfnCompare, LPARAM lParam)
{
    ASSERT(m_hdpa);
    DPA_SortedInsertPtr(m_hdpa, pv, 0, pfnCompare, lParam, DPAS_INSERTBEFORE, pv);

    return S_OK;
}


/*****************************************************************************\
    FUNCTION: SortedSearch

    DESCRIPTION:
        Search thru the list for the item.
\*****************************************************************************/
int CXboxList::SortedSearch(LPVOID pv, PFNDPACOMPARE pfnCompare, LPARAM lParam, UINT options)
{
    return DPA_Search(m_hdpa, pv, 0, pfnCompare, lParam, options);
}


/*****************************************************************************\
    FUNCTION: Find

    Call back once for each item in the pv list.  Stops when the
    callback returns 0, returning the item that triggered the match.

    The callback typically returns the result of a comparison function.
\*****************************************************************************/
LPVOID CXboxList::Find(PFNDPACOMPARE pfn, LPCVOID pv)
{
    LPVOID pvoid = NULL;
    int nIndex;

    nIndex = DPA_Search(m_hdpa, (LPVOID) pv, 0, pfn, NULL, 0);

    if (-1 != nIndex)
        pvoid = DPA_GetPtr(m_hdpa, nIndex);

    //TraceMsg(TF_XBOXLIST, "CXboxList::Find(pfn=%#08lx; pv=%#08lx) this=%#08lx, nIndex=%d, result=%#08lx", pfn, pv, this, nIndex, pvoid);

    return pvoid;
}

/*****************************************************************************\
    CXboxList_Create

    Start up a new pv list, with a recommended initial size and other
    callback info.
\*****************************************************************************/
HRESULT CXboxList_Create(int cpvInit, PFNDPAENUMCALLBACK pfn, UINT nGrow, CXboxList ** ppfl)
{
    HRESULT hres = E_OUTOFMEMORY;
    CXboxList * pfl = new CXboxList(pfn);
    *ppfl = pfl;

    if (pfl)
    {
        pfl->m_hdpa = DPA_Create(nGrow);
       //CXboxList_Create(pfn=%#08lx) this=%#08lx, cpvInit=%d, nGrow=%d", pfn, pfl, cpvInit, nGrow);

        if (EVAL(pfl->m_hdpa))
            hres = S_OK;
        else
        {
            pfl->Release();
            *ppfl = NULL;
        }
    }

    return hres;
}


/****************************************************\
    Constructor
\****************************************************/
CXboxList::CXboxList(PFNDPAENUMCALLBACK pfnDestroy) : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_hdpa);

    m_pfnDestroy = pfnDestroy;
    LEAK_ADDREF(LEAK_CXboxList);
}


/****************************************************\
    Destructor
\****************************************************/
CXboxList::~CXboxList()
{
    //TraceMsg(TF_XBOXLIST, "CXboxList::~CXboxList() this=%#08lx", this);
    if (m_pfnDestroy)
        DPA_DestroyCallback(m_hdpa, m_pfnDestroy, NULL);
    else
        DPA_Destroy(m_hdpa);

    DllRelease();
    LEAK_DELREF(LEAK_CXboxList);
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CXboxList::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CXboxList::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CXboxList::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, IUnknown *);
    }
    else
    {
        TraceMsg(TF_XBOXQI, "CXboxList::QueryInterface() failed.");
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxinet.cpp ===
/*****************************************************************************
 *
 *   xboxinit.cpp - Interfacing to WinINet
 *
 *****************************************************************************/

#include "priv.h"
#include "xboxinet.h"

#define SHInterlockedCompareExchangePointer SHInterlockedCompareExchange


/*****************************************************************************
 *
 *    Const strings for our Wininet stuff.
 *
 *****************************************************************************/

HINSTANCE g_hinstWininet = NULL;    /* The DLL handle */
HINTERNET g_hint = NULL;        /* Shared internet anchor handle */

#define SZ_WININET_AGENT TEXT("Microsoft(r) Windows(tm) XBOX Folder")


/*****************************************************************************\
    FUNCTION: InitWininet
\*****************************************************************************/
void InitWininet(void)
{
    // You can't use a critical section around LoadLibrary().
    ASSERTNONCRITICAL;

    if (!g_hinstWininet)
    {
        HINSTANCE hinstTemp = LoadLibrary(TEXT("WININET.DLL"));

        if (EVAL(hinstTemp))
        {
            // Can we successfully put it here?
            if (SHInterlockedCompareExchangePointer((void **)&g_hinstWininet, hinstTemp, NULL))
            {
                // No, someone else beat us there.
                ASSERT(g_hinstWininet);
                FreeLibrary(hinstTemp);
            }
        }
    }

    if (EVAL(g_hinstWininet))
    {
        if (!g_hint)
        {
            HINTERNET hinternetTemp;

            EVAL(SUCCEEDED(InternetOpenWrap(TRUE, SZ_WININET_AGENT, PRE_CONFIG_INTERNET_ACCESS, 0, 0, 0, &hinternetTemp)));
            if (EVAL(hinternetTemp))
            {
                // Can we successfully put it here?
                if (SHInterlockedCompareExchangePointer((void **)&g_hint, hinternetTemp, NULL))
                {
                    // No, someone else beat us there.
                    ASSERT(g_hint);
                    InternetCloseHandle(hinternetTemp);
                }
            }
        }
    }
}


/*****************************************************************************\
    FUNCTION: UnloadWininet
\*****************************************************************************/
void UnloadWininet(void)
{
    // You can't use a critical section around FreeLibrary() (I think).
    ASSERTNONCRITICAL;

    if (g_hint)
    {
        HINTERNET hinternetTemp = InterlockedExchangePointer(&g_hint, NULL);

        if (hinternetTemp)
        {
            InternetCloseHandle(hinternetTemp);
        }
    }

/************************
//  BUGBUG: I want to unload wininet, I really do.  But this function is called
//          during process un-attach and it's better to leak wininet than to
//          call FreeLibrary() during process unattach.

    if (g_hinstWininet)
    {
        HINSTANCE hinstTemp = (HINSTANCE)InterlockedExchangePointer((void **) &g_hinstWininet, NULL);

        if (hinstTemp)
        {
            FreeLibrary(hinstTemp);
        }
    }
*********************/
}

/*****************************************************************************\
 *    hintShared
 *
 *    Obtain the shared internet handle that we use for all our stuff.
 *    We load WinINet only on demand, so that quick things will be quick.
 *    If this procedure fails, the reason can be obtained via GetLastError().
 *    (Note that this assumes that we always try to InitWininet().)
\*****************************************************************************/
HINTERNET GetWininetSessionHandle(void)
{
    //    Avoid taking the critical section unless you really need to.
    if (!g_hint)
    {
        InitWininet();
        ASSERT(g_hint);
    }
    return g_hint;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxobj.h ===
/*****************************************************************************\
    FILE: xboxobj.h
\*****************************************************************************/

#ifndef _XBOXOBJ_H
#define _XBOXOBJ_H

#include "xboxefe.h"


typedef struct
{
    DVTARGETDEVICE dvTargetDevice;
    FORMATETC formatEtc;
    STGMEDIUM medium;
} FORMATETC_STGMEDIUM;


/*****************************************************************************\
    CLASS: CXboxObj

    Careful!  The elements of m_stgCache are rather weird due to delayed
    rendering.  If m_stgCache[].tymed == TYMED_HGLOBAL but
    m_stgCache[].hGlobal == 0, then the FORMATETC exists in the DataObject,
    but hasn't been rendered yet.

    It will be rendered when you call CXboxObj::_ForceRender().

    This weirdness with delayed rendering means that you have to be
    careful when you try to access the gizmo.

    1. Before trying to use the gizmo, use CXboxObj::_ForceRender().
    2. When trying to free the gizmo, use CXboxObj::_ReleasePstg().

    Yet another weirdness with m_stgCache is that all hGlobal's have a
    special babysitter pUnkForRelease.  This is important so that
    interactions between CXboxObj::GetData and CXboxObj::SetData are isolated.

    (If you were lazy and used the CXboxObj itself as the pUnkForRelease,
    then you'd run into trouble if somebody tried to SetData into the
    data object, which overwrites an hGlobal you had previously given away.)

    m_nStartIndex/m_nEndIndex: We give out a list of FILEDESCRIPTORS in the
    FILEGROUPDESCRIPTOR.  If the directory attribute is set, the caller will
    just create the directory.  If it's a file, it will call IDataObject::GetData()
    with DROP_FCont.  We would like to display progress on the old shell because
    it normally doesn't display progress until NT5.  We need to decide when to start
    and stop.  We set m_nStartIndex to -1 to indicate that we don't know.  When we
    get a DROP_FCont call, we then calculate the first and the last.  We will then
    display the progress dialog until the caller has either called the last one or
    errored out.

    The data is kept in two places.  The data we offer and render is in m_stgCache.
    The data we will carry is stored in m_hdsaSetData.
\*****************************************************************************/
class CXboxObj           : public IDataObject
                        , public IPersistStream
                        , public IInternetSecurityMgrSite
                        , public IAsyncOperation
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    
    // *** IDataObject ***
    virtual STDMETHODIMP GetData(FORMATETC *pfmtetcIn, STGMEDIUM *pstgmed);
    virtual STDMETHODIMP GetDataHere(FORMATETC *pfmtetc, STGMEDIUM *pstgpmed);
    virtual STDMETHODIMP QueryGetData(FORMATETC *pfmtetc);
    virtual STDMETHODIMP GetCanonicalFormatEtc(FORMATETC *pfmtetcIn, FORMATETC *pfmtetcOut);
    virtual STDMETHODIMP SetData(FORMATETC *pfmtetc, STGMEDIUM *pstgmed, BOOL bRelease);
    virtual STDMETHODIMP EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppienumFormatEtc);
    virtual STDMETHODIMP DAdvise(FORMATETC *pfmtetc, DWORD dwAdviseFlags, IAdviseSink * piadvsink, DWORD * pdwConnection);
    virtual STDMETHODIMP DUnadvise(DWORD dwConnection);
    virtual STDMETHODIMP EnumDAdvise(IEnumSTATDATA **ppienumStatData);
    
    // *** IPersist ***
    virtual STDMETHODIMP GetClassID(CLSID *pClassID){ *pClassID = CLSID_XboxDataObject; return S_OK; }
    
    // *** IPersistStream ***
    virtual STDMETHODIMP IsDirty(void) {return S_OK;}       // Indicate that we are dirty and ::Save() needs to be called.
    virtual STDMETHODIMP Load(IStream *pStm);
    virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty);
    virtual STDMETHODIMP GetSizeMax(ULARGE_INTEGER * pcbSize);

    // *** IInternetSecurityMgrSite ***
    virtual STDMETHODIMP GetWindow(HWND * phwnd) { if (phwnd) *phwnd = NULL; return S_OK; };
    virtual STDMETHODIMP EnableModeless(BOOL fEnable) {return E_NOTIMPL;};

    // *** IAsyncOperation methods ***
    virtual STDMETHODIMP SetAsyncMode(BOOL fDoOpAsync) {return E_NOTIMPL;};
    virtual STDMETHODIMP GetAsyncMode(BOOL * pfIsOpAsync);
    virtual STDMETHODIMP StartOperation(IBindCtx * pbcReserved);
    virtual STDMETHODIMP InOperation(BOOL * pfInAsyncOp);
    virtual STDMETHODIMP EndOperation(HRESULT hResult, IBindCtx * pbcReserved, DWORD dwEffects);

public:
    CXboxObj();
    ~CXboxObj(void);

    // Public Member Functions
    static int _DSA_FreeCB(LPVOID pvItem, LPVOID pvlparam);
    CXboxPidlList * GetHfpl() { return m_pflHfpl;};

    // Friend Functions
    friend HRESULT CXboxObj_Create(CXboxFolder * pff, CXboxPidlList * pflHfpl, REFIID riid, LPVOID * ppvObj);
    friend HRESULT CXboxObj_Create(CXboxFolder * pff, CXboxPidlList * pflHfpl, CXboxObj ** ppfo);
    friend HRESULT CXboxObj_Create(REFIID riid, void ** ppvObj);
    friend class CXboxEfe;

protected:
    // Private Member Variables
    int                     m_cRef;

    CXboxFolder *            m_pff;          // My dad
    CXboxDir *               m_pfd;          // My dad's home
    CXboxPidlList *          m_pflHfpl;      // List/Array of pidls
    STGMEDIUM               m_stgCache[DROP_MAX];
    HDSA                    m_hdsaSetData;  // Array of SetData.  Each item is a FORMATETC_STGMEDIUM.

    // Members for Progress on Legacy systems.
    IProgressDialog *       m_ppd;
    ULARGE_INTEGER          m_uliCompleted;
    ULARGE_INTEGER          m_uliTotal;
    int                     m_nStartIndex;  // Commented above in CLASS: CXboxObj
    int                     m_nEndIndex;    // Commented above in CLASS: CXboxObj
    BOOL                    m_fFGDRendered; // Did we expand m_pflHfpl?
    BOOL                    m_fCheckSecurity;  // TRUE means check security and display UI.  FALSE means it's unsafe and cancel w/o UI because it was already shown..
    BOOL                    m_fDidAsynchStart; // Did the IDropTarget call IAsynchDataObject::StartOperation() to start the copy? (To show he supports it)
    BOOL                    m_fErrAlreadyDisplayed; // Did was already display the error?
    IUnknown *              m_punkThreadRef; // Don't allow the browser closing to cancel our drag/drop operation.

    // Private Member Functions
    void _CheckStg(void);
    BOOL _IsLindexOkay(int ife, FORMATETC *pfeWant);
    HRESULT _FindData(FORMATETC *pfe, PINT piOut);
    HRESULT _FindDataForGet(FORMATETC *pfe, PINT piOut);
    HGLOBAL _DelayRender_FGD(BOOL fUnicode);
    HRESULT _DelayRender_IDList(STGMEDIUM * pStgMedium);
    HRESULT _DelayRender_URL(STGMEDIUM * pStgMedium);
    HRESULT _DelayRender_PrefDe(STGMEDIUM * pStgMedium);
    HRESULT _RenderOlePersist(STGMEDIUM * pStgMedium);
    HRESULT _RenderFGD(int nIndex, STGMEDIUM * pStgMedium);
    HRESULT _ForceRender(int ife);
    HRESULT _RefThread(void);
    CXboxPidlList * _ExpandPidlListRecursively(CXboxPidlList * ppidlListSrc);

    int _FindExtraDataIndex(FORMATETC *pfe);
    HRESULT _SetExtraData(FORMATETC *pfe, STGMEDIUM *pstg, BOOL fRelease);
    HRESULT _RenderFileContents(LPFORMATETC pfe, LPSTGMEDIUM pstg);

    HRESULT _DoProgressForLegacySystemsPre(void);
    HRESULT _DoProgressForLegacySystemsStart(LPCITEMIDLIST pidl, int nIndex);
    HRESULT _DoProgressForLegacySystemsPost(LPCITEMIDLIST pidl, BOOL fLast);
    HRESULT _SetProgressDialogValues(int nIndex);
    HRESULT _CloseProgressDialog(void);
};

#endif // _XBOXOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxpl.cpp ===
/*****************************************************************************
 *
 *    xboxpl.cpp - XBOX LPITEMIDLIST List object
 *
 *****************************************************************************/

#include "priv.h"
#include "xboxpl.h"
#include "xboxurl.h"

typedef struct tagINETENUM
{
    HINTERNET               hint;
    BOOL *                  pfValidhinst;
    LPVOID                  pvData;
    LPFNPROCESSITEMCB       pfnProcessItemCB;
    LPCITEMIDLIST           pidlRoot;
    HRESULT                 hr;
} INETENUM;


/*****************************************************************************\
     FUNCTION: RecursiveEnum
 
    DESCRIPTION:
        This function will pack the parameters needed during the enum.
\*****************************************************************************/
HRESULT CXboxPidlList::RecursiveEnum(LPCITEMIDLIST pidlRoot, LPFNPROCESSITEMCB pfnProcessItemCB, HINTERNET hint, LPVOID pvData)
{
    INETENUM inetEnum = {hint, NULL, pvData, pfnProcessItemCB, pidlRoot, S_OK};

    Enum(RecursiveProcessPidl, (LPVOID) &inetEnum);

    return inetEnum.hr;
}


// lParam can be: 0 == do a case sensitive search.  1 == do a case insensitive search.
int CXboxPidlList::ComparePidlName(LPVOID pvPidl1, LPVOID pvPidl2, LPARAM lParam)
{
    DWORD dwFlags = FCMP_NORMAL;

    if (lParam)
        dwFlags |= FCMP_CASEINSENSE;

    // return < 0 for pvPidl1 before pvPidl2.
    // return == 0 for pvPidl1 equals pvPidl2.
    // return > 0 for pvPidl1 after pvPidl2.
    return XboxItemID_CompareIDsInt(COL_NAME, (LPCITEMIDLIST)pvPidl1, (LPCITEMIDLIST)pvPidl2, dwFlags);
}


HRESULT CXboxPidlList::InsertSorted(LPCITEMIDLIST pidl)
{
    m_pfl->InsertSorted(ILClone(pidl), CXboxPidlList::ComparePidlName, FALSE /*Case Insensitive*/);
    return S_OK;
};


int CXboxPidlList::FindPidlIndex(LPCITEMIDLIST pidlToFind, BOOL fCaseInsensitive)
{
    return m_pfl->SortedSearch((LPVOID) pidlToFind, CXboxPidlList::ComparePidlName, (LPARAM)fCaseInsensitive, DPAS_SORTED);
}


LPITEMIDLIST CXboxPidlList::FindPidl(LPCITEMIDLIST pidlToFind, BOOL fCaseInsensitive)
{
    LPITEMIDLIST pidlFound = NULL;
    int nIndex = FindPidlIndex(pidlToFind, fCaseInsensitive);

    if (-1 != nIndex)
    {
        pidlFound = ILClone(GetPidl(nIndex));
    }

    return pidlFound;
}


HRESULT CXboxPidlList::CompareAndDeletePidl(LPCITEMIDLIST pidlToDelete)
{
    HRESULT hr = S_FALSE;
    int nIndex = FindPidlIndex(pidlToDelete, FALSE /*Case Insensitive*/);

    if (-1 != nIndex)
    {
        LPITEMIDLIST pidlCurrent = GetPidl((UINT)nIndex);
        if (EVAL(pidlCurrent))
        {
            ASSERT(0 == XboxItemID_CompareIDsInt(COL_NAME, pidlCurrent, pidlToDelete, FCMP_NORMAL));
            m_pfl->DeletePtrByIndex(nIndex);
            ILFree(pidlCurrent);    // Deallocate the memory
            hr = S_OK;  // Found and deleted.
        }
    }

    return hr;
}


void CXboxPidlList::Delete(int nIndex)
{
    LPITEMIDLIST pidlToDelete = GetPidl(nIndex);

    ILFree(pidlToDelete);   // Free the memory.
    m_pfl->DeletePtrByIndex(nIndex);
}


HRESULT CXboxPidlList::ReplacePidl(LPCITEMIDLIST pidlSrc, LPCITEMIDLIST pidlDest)
{
    HRESULT hr = S_FALSE;
    int nIndex = FindPidlIndex(pidlSrc, FALSE);

    if (-1 != nIndex)
    {
        LPITEMIDLIST pidlCurrent = GetPidl((UINT)nIndex);
        if (EVAL(pidlCurrent))
        {
            ASSERT(0 == XboxItemID_CompareIDsInt(COL_NAME, pidlCurrent, pidlSrc, FCMP_NORMAL));
            ILFree(pidlCurrent);    // Deallocate the memory
            m_pfl->DeletePtrByIndex(nIndex);
            InsertSorted(pidlDest);         // This function does the ILClone()
            hr = S_OK;  // Found and deleted.
        }
    }

    return hr;
}

void CXboxPidlList::AssertSorted(void)
{
#ifdef DEBUG
    // For perf reasons, we need to keep this list in order.
    // This is mainly because parse display name looks thru
    // the list, so we want that to be fast.
    for (int nIndex = (GetCount() - 2); (nIndex >= 0); nIndex--)
    {
        LPITEMIDLIST pidl1 = GetPidl((UINT)nIndex);
        LPITEMIDLIST pidl2 = GetPidl((UINT)nIndex + 1);

        // Assert that pidl1 comes before pidl2.
        if (!EVAL(0 >= XboxItemID_CompareIDsInt(COL_NAME, pidl1, pidl2, FCMP_NORMAL)))
        {
            TCHAR szPidl1[MAX_PATH];
            TCHAR szPidl2[MAX_PATH];

            if (XboxID_IsServerItemID(pidl1))
                XboxPidl_GetServer(pidl1, szPidl1, ARRAYSIZE(szPidl1));
            else
                XboxPidl_GetDisplayName(pidl1, szPidl1, ARRAYSIZE(szPidl1));

            if (XboxID_IsServerItemID(pidl2))
                XboxPidl_GetServer(pidl2, szPidl2, ARRAYSIZE(szPidl2));
            else
                XboxPidl_GetDisplayName(pidl2, szPidl2, ARRAYSIZE(szPidl2));

            TraceMsg(TF_ERROR, "CXboxPidlList::AssertSorted() '%s' & '%s' where found out of order", szPidl1, szPidl2);
        }
        // We do NOT need to free pidl1 or pidl2 because we get a pointer to someone else's copy.
    }

#endif // DEBUG
}


void CXboxPidlList::TraceDump(LPCITEMIDLIST pidl, LPCTSTR pszCaller)
{
#ifdef DEBUG
/*
    TCHAR szUrl[MAX_URL_STRING];

    UrlCreateFromPidl(pidl, SHGDN_FORPARSING, szUrl, ARRAYSIZE(szUrl), ICU_USERNAME, FALSE);
    TraceMsg(TF_PIDLLIST_DUMP, "CXboxPidlList::TraceDump() root is '%s', called from '%s'", szUrl, pszCaller);

    // Let's look at the contents.
    for (int nIndex = (GetCount() - 1); (nIndex >= 0); nIndex--)
    {
        LPITEMIDLIST pidlFull = ILCombine(pidl, GetPidl((UINT)nIndex));

        if (pidlFull)
        {
            UrlCreateFromPidl(pidlFull, SHGDN_FORPARSING, szUrl, ARRAYSIZE(szUrl), ICU_USERNAME, FALSE);
            TraceMsg(TF_PIDLLIST_DUMP, "CXboxPidlList::TraceDump() Index=%d, url=%s", nIndex, szUrl);
            ILFree(pidlFull);
        }
    }
*/
#endif // DEBUG
}

void CXboxPidlList::UseCachedDirListings(BOOL fUseCachedDirListings)
{
    // Normally we do two passes in the tree walker code.  The first
    // pass is to count up the time required to do the download. We
    // normally force WININET to not use cached results because someone
    // else could have changed the contents on the server.
    // On the second pass, we normally do the work (upload, download, delete)
    // and we want to use the cached results to get the perf advantage
    // and the results shouldn't be more than a minute out of date.

    if (fUseCachedDirListings)
        m_dwInetFlags = INTERNET_NO_CALLBACK;
    else
        m_dwInetFlags = (INTERNET_NO_CALLBACK | INTERNET_FLAG_RESYNCHRONIZE | INTERNET_FLAG_RELOAD);
}

BOOL CXboxPidlList::AreAllFolders(void)
{
    BOOL fAllFolder = TRUE;

    for (int nIndex = (GetCount() - 1); fAllFolder && (nIndex >= 0); nIndex--)
    {
        LPITEMIDLIST pidl = GetPidl((UINT)nIndex);
        if (EVAL(pidl))
            fAllFolder = XboxPidl_IsDirectory(pidl, TRUE);

        // We do NOT need to free pidl because we get a pointer to someone else's copy.
    }

    return fAllFolder;
}


BOOL CXboxPidlList::AreAllFiles(void)
{
    BOOL fAllFiles = TRUE;

    for (int nIndex = (GetCount() - 1); fAllFiles && (nIndex >= 0); nIndex--)
    {
        LPITEMIDLIST pidl = GetPidl((UINT)nIndex);
        if (EVAL(pidl))
            fAllFiles = !XboxPidl_IsDirectory(pidl, TRUE);

        // We do NOT need to free pidl because we get a pointer to someone else's copy.
    }

    return fAllFiles;
}


/*****************************************************************************
 *
 *    CXboxPidlList::_Fill
 *
 *    Fill a list with an array.
 *
 *    The elements in the array are copied rather than stolen.
 *
 *****************************************************************************/

HRESULT CXboxPidlList::_Fill(int cpidl, LPCITEMIDLIST rgpidl[])
{
    HRESULT hres = S_OK;

    for (int ipidl = 0; (ipidl < cpidl) && SUCCEEDED(hres); ipidl++)
    {
        ASSERT(IsValidPIDL(rgpidl[ipidl]));
        hres = InsertSorted(rgpidl[ipidl]);
    }

    return hres;
}


/*****************************************************************************
 *
 *    CXboxPidlList::GetPidlList
 *
 *****************************************************************************/

LPCITEMIDLIST * CXboxPidlList::GetPidlList(void)
{
    LPITEMIDLIST * ppidl;

    ppidl = (LPITEMIDLIST *) LocalAlloc(LPTR, sizeof(LPITEMIDLIST) * GetCount());
    if (ppidl)
    {
        int nIndex;

        for (nIndex = 0; nIndex < GetCount(); nIndex++)
        {
            // Later we can make this user ILClone() if we want to be able to wack on the
            // pidl list while this list is being used.
            ppidl[nIndex] = GetPidl(nIndex);
        }
    }

    return (LPCITEMIDLIST *) ppidl;
}


/*****************************************************************************
 *
 *    CXboxPidlList::FreePidlList
 *
 *****************************************************************************/

void CXboxPidlList::FreePidlList(LPCITEMIDLIST * ppidl)
{
    LocalFree(ppidl);
}


/*****************************************************************************
 *
 *    CXboxPidlList_Create
 *
 *    Start up a new pv list, with a recommended initial size and other
 *    callback info.
 *
 *****************************************************************************/

HRESULT CXboxPidlList_Create(int cpidl, LPCITEMIDLIST rgpidl[], CXboxPidlList ** ppflpidl)
{
    HRESULT hres = E_OUTOFMEMORY;
    CXboxPidlList * pflpidl;
    *ppflpidl = pflpidl = new CXboxPidlList();

    if (pflpidl)
    {
        hres = pflpidl->_Fill(cpidl, rgpidl);

        if (!EVAL(SUCCEEDED(hres)))
        {
            ASSERT(pflpidl->GetCount() == 0);
            IUnknown_Set(ppflpidl, NULL);
        }
    }

    return hres;
}


int CALLBACK PidlListDestroyCallback(LPVOID p, LPVOID pData)
{
    ILFree((LPITEMIDLIST) p);
    return 1;
}


/****************************************************\
    Constructor
\****************************************************/
CXboxPidlList::CXboxPidlList() : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_pfl);
    
    CXboxList_Create(100, PidlListDestroyCallback, 100, &m_pfl);
    ASSERT(m_pfl);      // This sucks
    UseCachedDirListings(FALSE);

    LEAK_ADDREF(LEAK_CXboxPidlList);
}


/****************************************************\
    Destructor
\****************************************************/
CXboxPidlList::~CXboxPidlList()
{
    AssertSorted();
    if (m_pfl)
        m_pfl->Release();

    DllRelease();
    LEAK_DELREF(LEAK_CXboxPidlList);
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CXboxPidlList::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CXboxPidlList::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CXboxPidlList::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, IUnknown *);
    }
    else
    {
        TraceMsg(TF_XBOXQI, "CXboxPidlList::QueryInterface() failed.");
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}


////////////////////////////////////////////////////////////////////
// Pild List Enum Helpers
////////////////////////////////////////////////////////////////////

/*****************************************************************************\
     FUNCTION: RecursiveProcessPidl
 
    DESCRIPTION:
        This function will will be called for each item in the initial Pidl List
    (before the recursion occurs).  This is a wrapper because the first list is
    a list of pidls.  The subsequent lists are of WIN32_FIND_DATA types.
\*****************************************************************************/
int RecursiveProcessPidl(LPVOID pvPidl, LPVOID pvInetEnum)
{
    LPCITEMIDLIST pidl = (LPCITEMIDLIST) pvPidl;
    INETENUM * pInetEnum = (INETENUM *) pvInetEnum;
    LPITEMIDLIST pidlFull = ILCombine(pInetEnum->pidlRoot, pidl);

    if (EVAL(pidlFull))
    {
        pInetEnum->hr = pInetEnum->pfnProcessItemCB((LPVOID) pInetEnum->pfnProcessItemCB, pInetEnum->hint, pidlFull, pInetEnum->pfValidhinst, pInetEnum->pvData);
        ILFree(pidlFull);
    }

    return (SUCCEEDED(pInetEnum->hr) ? TRUE : FALSE);
}


/*****************************************************************************\
     FUNCTION: _EnumFolderPrep
 
    DESCRIPTION:
        This function will step into the pszDir directory and enum all of it's
    contents.  For each item, it will call the callback function provided (pfnProcessItemCB).
    That callback function can then call EnumFolder() again (recursively) if
    there is a subfolder.

    NOTE:
        This function needs to first find all the items and then in a second
    loop call the callback function.  This is because the WININET XBOX APIs
    only allow one enum to occur at a time, which may not happen if half way through
    enuming one dir, a recursive call starts enuming a sub dir.
\*****************************************************************************/
HRESULT _EnumFolderPrep(HINTERNET hint, LPCITEMIDLIST pidlFull, CXboxPidlList * pPidlList, CWireEncoding * pwe, LPITEMIDLIST * ppidlCurrXboxPath)
{
    HRESULT hr = S_OK;

    // 1. Get Current Directory (To restore later).
    hr = XboxGetCurrentDirectoryPidlWrap(hint, TRUE, pwe, ppidlCurrXboxPath);
    if (EVAL(SUCCEEDED(hr)))
    {
        CMultiLanguageCache cmlc;
        CWireEncoding we;

        if (!pwe)
            pwe = &we;

        // It's important that this is a relative CD.
        // 2. Change Directory Into the subdirectory.   
        hr = XboxSetCurrentDirectoryWrap(hint, TRUE, XboxPidl_GetLastItemWireName(pidlFull));
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidlItem;
            HINTERNET hInetFind = NULL;

            hr = XboxFindFirstFilePidlWrap(hint, TRUE, &cmlc, pwe, NULL, &pidlItem, pPidlList->m_dwInetFlags, NULL, &hInetFind);
            if (hInetFind)
            {
                do
                {
                    LPCWIRESTR pwireStr = XboxPidl_GetLastItemWireName(pidlFull);
                    if (IS_VALID_FILE(pwireStr))
                    {
                        // Store entire pidl (containing WIN32_FIND_DATA) so we can get
                        // the attributes and other info later.  Seeing if it's a dir
                        // is one need...
                        pPidlList->InsertSorted(pidlItem);
                    }

                    ILFree(pidlItem);
                    hr = InternetFindNextFilePidlWrap(hInetFind, TRUE, &cmlc, pwe, &pidlItem);
                }
                while (SUCCEEDED(hr));
            
                ILFree(pidlItem);
                InternetCloseHandle(hInetFind);
            }

            if (ERROR_NO_MORE_FILES == HRESULT_CODE(hr))
                hr = S_OK;
        }

        EVAL(SUCCEEDED(pwe->ReSetCodePages(&cmlc, pPidlList)));
    }

    return hr;
}


/*****************************************************************************\
     FUNCTION: _GetPathDifference
 
    DESCRIPTION:
        This function will step into the pszDir directory and enum all of it's
    contents.  For each item, it will call the callback function provided (pfnProcessItemCB).
    That callback function can then call EnumFolder() again (recursively) if
    there is a subfolder.

    NOTE:
        This function needs to first find all the items and then in a second
    loop call the callback function.  This is because the WININET XBOX APIs
    only allow one enum to occur at a time, which may not happen if half way through
    enuming one dir, a recursive call starts enuming a sub dir.

    PARAMETERS:
        pszBaseUrl - This needs to be escaped.
        pszDir - This needs to be escaped.
        *ppszUrlPathDiff - This will be UnEscaped.
\*****************************************************************************/
void _GetPathDifference(LPCTSTR pszBaseUrl, LPCTSTR pszDir, LPTSTR * ppszUrlPathDiff)
{
    TCHAR szUrlPathDiff[MAX_URL_STRING];
    TCHAR szFullUrl[MAX_URL_STRING];
    DWORD cchSize = ARRAYSIZE(szFullUrl);

    // This is needed for this case:
    // pszBaseUrl="xbox://server/subdir1/", pszDir="/subdir1/subdir2/file.txt"
    // So, szUrlPathDiff="subdir2/file.txt" instead of pszDir
    //
    // ICU_NO_ENCODE is needed because Download Dlg may have paths with
    // spaces that can't be escaped.
    InternetCombineUrl(pszBaseUrl, pszDir, szFullUrl, &cchSize, ICU_NO_ENCODE);
    UrlGetDifference(pszBaseUrl, szFullUrl, szUrlPathDiff, ARRAYSIZE(szUrlPathDiff));

    // We will now use szFullUrl to store the UnEscaped version since these buffers
    // are so large.
    UnEscapeString(szUrlPathDiff, szFullUrl, ARRAYSIZE(szFullUrl));
    Str_SetPtr(ppszUrlPathDiff, szFullUrl);
}


/*****************************************************************************\
     FUNCTION: EnumFolder
 
    DESCRIPTION:
        This function will step into the pszDir directory and enum all of it's
    contents.  For each item, it will call the callback function provided (pfnProcessItemCB).
    That callback function can then call EnumFolder() again (recursively) if
    there is a subfolder.

    PARAMETERS:
        (pszBaseUrl=xbox://server/dir1/, pszDir=dir2, DirToEnum=xbox://server/dir1/dir2/)
        pszDir - This is the directory we are enumerating. (dir2)  It is relative to pszBaseUrl.
        hint - The current working directory will be set to pszBaseUrl.  _EnumFolderPrep will make it go into pszDir.

    NOTE:
        This function needs to first find all the items and then in a second
    loop call the callback function.  This is because the WININET XBOX APIs
    only allow one enum to occur at a time, which may not happen if half way through
    enuming one dir, a recursive call starts enuming a sub dir.
\*****************************************************************************/
HRESULT EnumFolder(LPFNPROCESSITEMCB pfnProcessItemCB, HINTERNET hint, LPCITEMIDLIST pidlFull, CWireEncoding * pwe, BOOL * pfValidhinst, LPVOID pvData)
{
    CXboxPidlList * pPidlList;
    BOOL fValidhinst = TRUE;

    HRESULT hr = CXboxPidlList_Create(0, &pidlFull, &pPidlList);
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidlCurrXboxPath = NULL;

        hr = _EnumFolderPrep(hint, pidlFull, pPidlList, pwe, &pidlCurrXboxPath);
        if (SUCCEEDED(hr))
        {
            hr = S_OK;
            // 4. Process each file name, which may be recursive.
            // This loop and the while loop above need to be
            // separated because it's not possible to create
            // more than one XBOX Find File handle based on the
            // same session.
            for (int nIndex = 0; SUCCEEDED(hr) && (nIndex < pPidlList->GetCount()); nIndex++)
            {
                LPITEMIDLIST pidlNewFull = ILCombine(pidlFull, pPidlList->GetPidl(nIndex));

                hr = pfnProcessItemCB(pfnProcessItemCB, hint, pidlNewFull, &fValidhinst, pvData);
                ILFree(pidlNewFull);
            }

            // 5. Go back to original directory (from Step 2)
            // The only time we don't want to return to the original directory is if
            // the hinst was freed in an wininet callback function.  We may cache the hinst
            // so we need the directory to be valid later.
            if (fValidhinst)
            {
                if (SUCCEEDED(hr))
                {
                    // We still want to reset the directory but we don't want to over write
                    // the original error message.
                    hr = XboxSetCurrentDirectoryPidlWrap(hint, TRUE, pidlCurrXboxPath, TRUE, TRUE);
                }
            }

            Pidl_Set(&pidlCurrXboxPath, NULL);
        }

        pPidlList->Release();
    }

    if (pfValidhinst)
        *pfValidhinst = fValidhinst;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxpidl.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    xboxpidl.h

Abstract:

    Declares class to manage PIDL's for the Xbox Development Kit
    namespace extension.

Environment:

    Windows 2000 and Later 
    User Mode

Revision History:
    
    02-05-2000 : created

--*/
#ifndef _XBOXPIDL_H
#define _XBOXPIDL_H


//-----------------------------------------------------------------------
// AdvancePtr cleans up the really ugly casting necessary to walk arrays
// of variable lengths structures, such as pidls.  Being a template, it
// works with any type of structure.
//-----------------------------------------------------------------------
template <class T>
inline T *AdvancePtr(T *pT, ULONG cb)
{
    return (T *)(((ULONG_PTR)pT) + cb);
}

//-----------------------------------------------------------------------------------
//  class CXboxPidl
//
//    Can be initialized as the Xbox root, as a random opaque pidl, or
//    with a display name relative to another CXboxPidl object.
//
//    The instance can then return a the friendly display name, or a name suitable
//    for use with the xboxdbg.dll API to access the hardware.
//
//    CXboxPidl never talks to the hardware itself and has no way of verifing
//    PIDLs other than by syntax.
//
//    The class also has a number of static members that are useful for parsing PIDL's
//    in general.
//     
//-----------------------------------------------------------------------------------
class CXboxPidl
{
  public:
    //c'tor
    CXboxPidl() : 
        m_dwFirstXboxIdOffset(0),
        m_Pidl(NULL),
        m_usItemType(0)
        {RefClass();} //default c'tor
    //d'tor
    ~CXboxPidl();
    
    //Initialization Routines (didn't use c'tors or assignment operators, because these
    //can fail.)
    HRESULT InitAsRoot();
    HRESULT InitWithPidl(LPCITEMIDLIST pidl, DWORD dwXboxIdOffset);
    HRESULT InitWithDisplayName(CXboxPidl *pidl, LPCOLESTR pwszDisplayName);
    
    //The assignment operator doesn't require prior initialization
    CXboxPidl& operator=(const CXboxPidl& rhs);  //assign from CXboxPidl
    
    //Append a PIDL onto the end.    
    HRESULT Append(const CXboxPidl& rhs); //concatenation with another PIDL
    
    //gets a copy of the real PIDL
    LPITEMIDLIST  GetPidl() const; //Makes a copy of the PIDL. The caller owns it.

    //get information from PIDL (The signature is designed to mesh with IShellFolder
    //GetDisplayNameOf), the flags are the same flags.
    HRESULT GetDisplayName(DWORD uFlags, LPSTRRET lpName) const;

    // get information necessary to communicate with an Xbox
    HRESULT GetXboxName(LPSTR pMachineName, DWORD *pdwLength);
    HRESULT GetXboxFilePath(LPSTR pFilePath, DWORD *pdwLength);
    
    //get size of the current pidl
    inline ULONG GetPidlSize() const {return GetPidlSize(m_Pidl);}

  private:

    // Used internally, to check that the generated PIDL was valid
    bool IsValid() const;
    USHORT GetItemIdType() const {return m_usItemType;}

    //The data associated with a PIDL
    DWORD m_dwFirstXboxIdOffset;
    LPITEMIDLIST m_Pidl;
    USHORT m_usItemType;
    
    //Static Members, includes some PIDL helper
    //functions that are not Xbox specific
  
  public:
    static ULONG GetPidlSize(LPCITEMIDLIST pidl);
    inline static LPCITEMIDLIST GetNextItemId(LPCITEMIDLIST pidl);
    inline static LPITEMIDLIST GetNextItemId(LPITEMIDLIST pidl);
    static LPCITEMIDLIST GetLastItemId(LPCITEMIDLIST pidl);
    static LPITEMIDLIST CopyFirstItemId(LPCITEMIDLIST pidl);
    static ULONG   RefClass()
                   { 
                     LONG refCount = InterlockedIncrement(&sm_lClassReference);
                     if(1==refCount) InitClass(); //possible sync bug
                     return refCount;
                   }
    static ULONG DerefClass()
                 {
                     LONG refCount = InterlockedDecrement(&sm_lClassReference);
                     if(0==refCount) DestroyClass();
                     return refCount;
                 }
  private:
      
    static HRESULT PreprocessDisplayName(
                    LPCOLESTR pwszDisplayName,
                    LPSTR     pszBuffer,
                    DWORD    *pdwLength,
                    DWORD    *pdwTokenCount,
                    BOOL     *pfAbsolute);

    static HRESULT InitClass();
    static void DestroyClass();
    static IMalloc *sm_pMalloc;
    static LONG    sm_lClassReference;

  private:
    CXboxPidl(const CXboxPidl&);  //copy constructor is private to prevent its
                                  //inadvertant use

};

#endif // _XBOXPIDL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxpl.h ===
/*****************************************************************************
 *	xboxpl.h
 *****************************************************************************/

#ifndef _XBOXPIDLLIST_H
#define _XBOXPIDLLIST_H


#include "xboxlist.h"

typedef HRESULT (CALLBACK *LPFNPROCESSITEMCB)(LPVOID pfnProcessItemCB, HINTERNET hint, LPCITEMIDLIST pidlFull, BOOL * pfValidhinst, LPVOID pvData);

HRESULT EnumFolder(LPFNPROCESSITEMCB pfnProcessItemCB, HINTERNET hint, LPCITEMIDLIST pidlFull, CWireEncoding * pwe, BOOL * pfValidhinst, LPVOID pvData);
int RecursiveProcessPidl(LPVOID pvPidl, LPVOID pvInetEnum);


/*****************************************************************************
 *
 *	CXboxPidlList
 *
 *****************************************************************************/

class CXboxPidlList      : public IUnknown
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

public:
    CXboxPidlList();
    ~CXboxPidlList(void);

    // Public Member Functions
    HRESULT CompareAndDeletePidl(LPCITEMIDLIST pidl);
    HRESULT ReplacePidl(LPCITEMIDLIST pidlSrc, LPCITEMIDLIST pidlDest);
    HRESULT InsertSorted(LPCITEMIDLIST pidl);
    HRESULT RecursiveEnum(LPCITEMIDLIST pidlRoot, LPFNPROCESSITEMCB pfnProcessItemCB, HINTERNET hint, LPVOID pvData);
    void Enum(PFNDPAENUMCALLBACK pfn, LPVOID pv) { m_pfl->Enum(pfn, pv); };
    void DeletePidl(LPITEMIDLIST pidl) { m_pfl->DeleteItemPtr((LPVOID) pidl);  ILFree(pidl); };
    void Delete(int nIndex);
    int GetCount(void)  { return m_pfl->GetCount(); };
    int FindPidlIndex(LPCITEMIDLIST pidlToFind, BOOL fCaseInsensitive);
    LPITEMIDLIST GetPidl(UINT ipv) { return (LPITEMIDLIST) m_pfl->GetItemPtr(ipv); };   // TODO: Rename GetPidlReference()
    LPITEMIDLIST FindPidl(LPCITEMIDLIST pidlToFind, BOOL fCaseInsensitive);
    BOOL AreAllFolders(void);
    BOOL AreAllFiles(void);

    LPCITEMIDLIST * GetPidlList(void);
    void FreePidlList(LPCITEMIDLIST * ppidl);
    void TraceDump(LPCITEMIDLIST pidl, LPCTSTR pszCaller);

    void UseCachedDirListings(BOOL fUseCachedDirListings);

    // Friend Functions
    static int CXboxPidlList::ComparePidlName(LPVOID pvPidl1, LPVOID pvPidl2, LPARAM lParam);
    friend HRESULT CXboxPidlList_Create(int cpidl, LPCITEMIDLIST rgpidl[], CXboxPidlList ** ppfl);
    friend HRESULT _EnumFolderPrep(HINTERNET hint, LPCITEMIDLIST pidlFull, CXboxPidlList * pPidlList, CWireEncoding * pwe, LPITEMIDLIST * ppidlCurrXboxPath);

protected:
    // Private Member Variables
    int                     m_cRef;

    CXboxList *              m_pfl;
    CWireEncoding *         m_pwe;          // We don't hold a ref, so we assume the object will outlive us.
    DWORD                   m_dwInetFlags;  // What flags do we want to set for enumeration?

    // Private Member Functions
    HRESULT _Fill(int cpidl, LPCITEMIDLIST rgpidl[]);
    void AssertSorted(void);
};


#endif // _XBOXPIDLLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxpf.cpp ===
/*****************************************************************************
 *
 *	xboxpf.cpp - Progress Feedback
 *
 *****************************************************************************/

#include "priv.h"

/*****************************************************************************
 *
 *	HPF - Handle to progress feedback
 *
 *	Shhh...  Don't tell anyone, but it's just a window handle.
 *
 *	It's the handle of the status bar window to use.  We use the
 *	second part (part number one, since they start at zero) to display
 *	connection feedback.
 *
 *	We don't use SIMPLE mode, because DefView uses SIMPLE mode to display
 *	menu feedback.
 *
 *****************************************************************************/

#define hwndNil	

/*****************************************************************************
 *
 *	XboxPf_Begin
 *
 *****************************************************************************/

HPF XboxPf_Begin(HWND hwndOwner)
{
    HWND hwnd;
    ASSERTNONCRITICAL;
    hwnd = Misc_FindStatusBar(hwndOwner);
    if (hwnd)
    {
	    SendMessage(hwnd, SB_SETTEXT, 1 | SBT_NOBORDERS, 0);
    }
    return (HPF)hwnd;
}

/*****************************************************************************
 *
 *	XboxPf_Status
 *
 *	ids = string to display in status bar
 *	ptsz = optional insert
 *
 *****************************************************************************/

void XboxPf_Status(HPF hpf, UINT ids, LPCTSTR pszParameters)
{
    HWND hwnd = (HWND)hpf;

    ASSERTNONCRITICAL;
    if (EVAL(hwnd))
    {
	    TCHAR szMsgTemplate[256];
	    TCHAR szMessage[1024];

	    LoadString(g_hinst, ids, szMsgTemplate, ARRAYSIZE(szMsgTemplate));
	    wnsprintf(szMessage, ARRAYSIZE(szMessage), szMsgTemplate, pszParameters);
	    SendMessage(hwnd, SB_SETTEXT, 1 | SBT_NOBORDERS, (LPARAM)szMessage);
	    UpdateWindow(hwnd);
    }
}

/*****************************************************************************
 *
 *	XboxPf_End
 *
 *****************************************************************************/

void XboxPf_End(HPF hpf)
{
    HWND hwnd;
    ASSERTNONCRITICAL;
    hwnd = (HWND)hpf;
    if (hwnd)
    {
	    SendMessage(hwnd, SB_SETTEXT, 1 | SBT_NOBORDERS, 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxprop.h ===
/*****************************************************************************
 *	xboxprop.h
 *****************************************************************************/

#ifndef _XBOXPROP_H
#define _XBOXPROP_H

#include "xboxdhlp.h"
#include "xboxpl.h"

HRESULT CXboxProp_DoProp(CXboxPidlList * pflHfpl, CXboxFolder * pff, HWND hwnd);


// BUGBUG/TODO: Add Change UNIX Permissions feature
// This is done by sending the command "SITE CHMOD <permissions> <filename>"
// We can probably test permissions by using CHMOD or something to test it.

/*****************************************************************************
 *
 *	CXboxProp
 *
 *	NOTE! that we use the IShellFolder on the wrong thread!
 *
 *	Take careful note that all the CXboxFolder methods we call
 *	are thread-safe.
 *
 *****************************************************************************/

class CXboxProp          : public IUnknown
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    
public:
    CXboxProp();
    ~CXboxProp(void);

    // Friend Functions
    friend HRESULT CXboxProp_Create(CXboxPidlList * pflHfpl, CXboxFolder * pff, HWND hwnd, CXboxProp ** ppfp);
    static HRESULT _CommitCHMOD_CB(HINTERNET hint, HINTPROCINFO * phpi, LPVOID pv, BOOL * pfReleaseHint);
    static DWORD _PropertySheetThreadProc(LPVOID pvCXboxProp) {return ((CXboxProp *) pvCXboxProp)->_PropertySheetThread(); };

protected:
    // Public Member Variables
    int                     m_cRef;

    CXboxFolder *            m_pff;          // Folder that owns the pidls
    CXboxPidlList *          m_pflHfpl;      // 
    HWND                    m_hwnd;         // browser window for UI and Legacy ChangeNotify
    CXboxDialogTemplate      m_xboxDialogTemplate;
    BOOL                    m_fChangeModeSupported;
    DWORD                   m_dwNewPermissions;

    
    // Public Member Functions
    BOOL OnInitDialog(HWND hdlg);
    BOOL OnClose(HWND hDlg);
    DWORD _PropertySheetThread(void);
    void _HideCHMOD_UI(HWND hDlg);
    HRESULT _SetCHMOD_UI(HWND hDlg);
    DWORD _GetCHMOD_UI(HWND hDlg);
    DWORD _GetUnixPermissions(void);
    HRESULT _CommitCHMOD(HINTERNET hint, HINTPROCINFO * phpi, BOOL * pfReleaseHint);
    INT_PTR _SetWhiteBGCtlColor(HWND hDlg, HDC hdc, HWND hwndCtl);

    static INT_PTR DlgProc(HWND hdlg, UINT wm, WPARAM wp, LPARAM lp);
};

DWORD DoProp_OnThread(LPVOID pv);


#endif // _XBOXPROP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxpidl.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    xboxpidl.cpp

Abstract:

    Implementation of CXboxPidl class

Environment:

    Windows 2000 and Later 
    User Mode

Revision History:
    
    02-05-2000 : created

--*/

#include "priv.h"

//------------------------------------------------------------
// Definitions for display names
//------------------------------------------------------------
const WCHAR  XboxNameSpaceString[] = L"xbox://";
const size_t XboxNameSpaceStringCount = ((sizeof(XboxNameSpaceString)/ sizeof(WCHAR))-1);
#define MAX_XBOX_PATH 512

//------------------------------------------------------------
// Definitions of the internal format for Xbox PIDLs
//------------------------------------------------------------
#include <PSHPACK1.H>
typedef struct _XBOX_ITEMID
{
    USHORT cb;
    USHORT usItemType;
    CHAR   szItemData[1];
} XBOX_ITEMID, *PXBOX_ITEMID;
#include <POPPACK.H>
#define XBOX_ITEMTYPE_NOTXBOX   (0)
#define XBOX_ITEMTYPE_ROOT      (1)
#define XBOX_ITEMTYPE_MACHINE   (2)
#define XBOX_ITEMTYPE_VOLUME    (3)
#define XBOX_ITEMTYPE_FILEORDIR (4)


//------------------------------------------------------------
// Declare and Initialize static members of CXboxPidl
//------------------------------------------------------------
IMalloc *CXboxPidl::sm_pMalloc = NULL;
LONG    CXboxPidl::sm_lClassReference = 0;

HRESULT CXboxPidl::InitClass()
{
  ASSERT(NULL==sm_pMalloc);
  HRESULT hr = SHGetMalloc(&sm_pMalloc);
  ASSERT(SUCCEEDED(hr));
  return hr;
}
void CXboxPidl::DestroyClass()
{
  ASSERT(sm_pMalloc);
  sm_pMalloc->Release();
  sm_pMalloc = NULL;
}


//------------------------------------------------------------
// Destructor
//------------------------------------------------------------
CXboxPidl::~CXboxPidl()
/*++
    Destorys a PIDL.  Releases instance reference count on the class.
--*/
{
    DerefClass();
    if(m_Pidl)
    {
        sm_pMalloc->Free(m_Pidl);
        m_Pidl = NULL;
    }
}


HRESULT CXboxPidl::InitAsRoot()
/*++
    Routine Description:
        Initializes a CXboxPidl to point to the Xbox root.

  Return Value:
        S_OK - on success
        E_OUTOFMEMORY - the only possible failure now.
--*/
{
    //Assume that the class was successfully initialized
    ASSERT(sm_pMalloc);

    //Don't use this to reinit, only to init.
    ASSERT(NULL == m_Pidl);
    
    // Our root PIDL is fixed size
    ULONG cb = sizeof(XBOX_ITEMID) + 1;
    
    // Allocate memory for the root.
    m_Pidl = (LPITEMIDLIST) sm_pMalloc->Alloc(cb);
    if(NULL==m_Pidl) return E_OUTOFMEMORY;
    
    //Fill out the root item ID
    m_dwFirstXboxIdOffset = 0;
    PXBOX_ITEMID pRootItemId = (PXBOX_ITEMID)m_Pidl;
    pRootItemId->cb = sizeof(XBOX_ITEMID) - 1;
    pRootItemId->usItemType = XBOX_ITEMTYPE_ROOT;

    //Fill out the item type
    m_usItemType = XBOX_ITEMTYPE_ROOT;

    //Null Terminate the list
    AdvancePtr(pRootItemId,pRootItemId->cb)->cb = 0;
    return S_OK;
}

HRESULT CXboxPidl::InitWithPidl(LPCITEMIDLIST pidl, DWORD dwXboxIdOffset)
/*++
  Routine Description:
    Initializes an CXboxPidl with an existing pidl.

  Arguments:
    
    pidl           - pidl to initialize with.

    dwXboxIdOffset - offset to first ITEMID that is part of the Xbox namespace

  Return Value:
        S_OK - on success
        E_OUTOFMEMORY - the only possible failure now.
        
--*/
{
    //Assume that the class was successfully initialized
    ASSERT(sm_pMalloc);

    //Don't use this to reinit, only to init.
    ASSERT(NULL == m_Pidl);
    
    // Get the size
    ULONG cb = GetPidlSize(pidl);
    
    // Allocate memory for the pidl
    m_Pidl = (LPITEMIDLIST) sm_pMalloc->Alloc(cb);
    if(NULL==m_Pidl) return E_OUTOFMEMORY;

    //copy the parent pidl
    memcpy(m_Pidl, pidl, cb);

    //Set the offset to the xbox portion
    m_dwFirstXboxIdOffset = dwXboxIdOffset;

    //figure out the item type
    m_usItemType = XBOX_ITEMTYPE_NOTXBOX;
    PXBOX_ITEMID pXboxItemId = (PXBOX_ITEMID) AdvancePtr(m_Pidl, cb-2);
    while(pXboxItemId->cb)
    {
        m_usItemType = pXboxItemId->usItemType;
        pXboxItemId = AdvancePtr(pXboxItemId, pXboxItemId->cb);
    }
        
    return S_OK;
}

HRESULT CXboxPidl::InitWithDisplayName(CXboxPidl *pidlParent, LPCOLESTR pwszDisplayName)
/*++
  Routine Description:
    Initializes an CXboxPidl with a display name.

  Arguments:
    
    pidl            - pidl of the parent folder from the Xbox root.                      
    pwszDisplayName - Xbox path used to initialize pidl.

  Return Value:
        S_OK - on success
        E_OUTOFMEMORY - the only possible failure now.
  
  Comments:
    Whether or not the PIDL is absolute or relative is determine by whether the
    name starts with "xbox://"
        
--*/
{
   CHAR         pszBuffer[MAX_XBOX_PATH];
   DWORD        dwLength = MAX_XBOX_PATH;
   PXBOX_ITEMID pXboxItemIdList = NULL;
   DWORD        dwTokenCount;
   BOOL         fAbsolute;
   USHORT       cbPidl;
   USHORT       usLastItemIdType;
   HRESULT      hr;

   //Assume that the class was successfully initialized
   ASSERT(sm_pMalloc);

   //Don't use this to reinit, only to init.
   ASSERT(NULL == m_Pidl);
      
   // Preprocess the display name.
   //   1) Converts to MBCS.
   //   2) Throw out "xbox://" portion if present and set fAbsolute appropriately.
   //   3) Tokenize the items separating them with '\0'
   //   4) Count number of tokens (a.k.a. directories) 
   //   5) Return the new length.
   //
   //   hr will be failure if any of the characters are invalid
   hr = PreprocessDisplayName(pwszDisplayName, pszBuffer, &dwLength, &dwTokenCount, &fAbsolute);
   if(FAILED(hr))
   {
       return hr;
   }
   
   //each token requires an XBOX_ITEMID (which has space for the cb, the item type, and NULL termination
   //of the string), plus one character per character, + a two byte termination.
   cbPidl = (USHORT)(dwTokenCount * sizeof(XBOX_ITEMID) + dwLength + 2);

   if(fAbsolute)
   {
       // absolute path: prepend it with a root

       cbPidl += (sizeof(XBOX_ITEMID)-1);
       m_Pidl = (LPITEMIDLIST)
                (pXboxItemIdList = (PXBOX_ITEMID) sm_pMalloc->Alloc(cbPidl));
       if(pXboxItemIdList)
       {
           usLastItemIdType =
           pXboxItemIdList->usItemType = XBOX_ITEMTYPE_ROOT;
           pXboxItemIdList->cb = (sizeof(XBOX_ITEMID)-1);
           pXboxItemIdList = AdvancePtr(pXboxItemIdList, pXboxItemIdList->cb);
       }
   } else
   {
      // relative path: prepend it with a the pidl passed in
      
      // Get the parent pidl size sans termination
      USHORT cbPidlParent = (USHORT)(pidlParent->GetPidlSize() - 2); 
      cbPidl += cbPidlParent;
      m_Pidl = (LPITEMIDLIST)
               (pXboxItemIdList = (PXBOX_ITEMID)sm_pMalloc->Alloc(cbPidl));
      if(pXboxItemIdList)
      {
          memcpy(pXboxItemIdList, pidlParent->m_Pidl, cbPidlParent);
          usLastItemIdType = pidlParent->GetItemIdType();
          pXboxItemIdList = AdvancePtr(pXboxItemIdList, cbPidlParent);
      }
   }
  
   // Fail here if we didn't manage to allocate a pidl
   if(!pXboxItemIdList)
   {
      return E_OUTOFMEMORY;
   }

   //
   //   If we got here:
   //       m_Pidl is unterminated:
   //       pxboxItemIdList points to the next byte to write in m_Pidl
   //       pszBuffer should parse relative to m_Pidl
   //       usLastItemIdType contains the type of the last item in m_Pidl
   //
   USHORT cbItem;
   CHAR  *pszPos = pszBuffer;
   for(USHORT i=0; i < dwTokenCount; i++)
   {
       // Increment the item ID type, unless we are already at the file/folder
       // level
       if(XBOX_ITEMTYPE_FILEORDIR != usLastItemIdType) usLastItemIdType++;
       //assign the item id type
       pXboxItemIdList->usItemType =  usLastItemIdType;
       //copy the string - including the null
       cbItem = 0;
       do{
         pXboxItemIdList->szItemData[cbItem++] = *pszPos++;
       } while(*pszPos);
       // Add the XBOX_ITEMID structure to the cbItem
       cbItem += (sizeof(XBOX_ITEMID)-1); //the -1 is for the character is because one character
                                          //of the string is already in XBOX_ITEMID structure
       pXboxItemIdList->cb = cbItem;
       pXboxItemIdList = AdvancePtr(pXboxItemIdList, cbItem);
   }
   //   Terminate the PIDL
   pXboxItemIdList->cb = 0;

   // m_Pidl should now conform to syntax.
   return S_OK;
}

CXboxPidl& CXboxPidl::operator=(const CXboxPidl& rhs)
{
    //Only perform the copy if the rhs and lhs are different
    if(&rhs != this)
    {
        if(rhs.m_Pidl)
        {
            
            ULONG cb = rhs.GetPidlSize();
            //If we do not have a PIDL yet, then allocate one.
            if(!m_Pidl)
            {
                m_Pidl = (LPITEMIDLIST) sm_pMalloc->Alloc(cb);
            } else
            // realloc iff it is not big enough
            {
                if(cb > sm_pMalloc->GetSize(m_Pidl))
                {
                  //realloc can fail.  If it does, it does not free
                  //the original memory.  Hence,
                  //  "m_Pidl = (LPITEMIDLIST)m_pMalloc->Realloc(m_Pidl, cb);"
                  // could leak memory, so we need to write the next several lines
                  // of code.
                  void *reallocMemory = sm_pMalloc->Realloc(m_Pidl, cb);
                  if(reallocMemory)
                  {
                    if(reallocMemory)
                    {
                      m_Pidl = (LPITEMIDLIST)reallocMemory;
                    } else
                    {
                      sm_pMalloc->Free(m_Pidl);
                      m_Pidl = NULL;
                    }
                  }
                }
            }
            //
            //  After all that is possible that we don't have any memory
            //
            if(m_Pidl)
            {
                memcpy(m_Pidl, rhs.m_Pidl, cb);
                rhs.m_dwFirstXboxIdOffset;
            }
        } else if(m_Pidl)
        // if copying a blank PIDL, just make sure we are blank
        {
            sm_pMalloc->Free(m_Pidl);        
            m_Pidl = NULL;
        }
    }
    // In all cases, return a reference to ourselves.
    return *this;
}

HRESULT CXboxPidl::Append(const CXboxPidl& rhs)
{
    //appending a PIDL to itself is guaranteed to generate
    //a bad PIDL
    if(&rhs != this) return E_INVALIDARG;

    //If we are not initialized yet, then call our
    //assignment operator.  If we are still unitialized
    //fail.
    if(!m_Pidl)
    {
        *this = rhs;
        if(!m_Pidl)
        {
            return E_FAIL;
        }
        return S_OK;
    }
    
    //
    //  If the rhs is NULL just return success
    //
    if(!rhs.m_Pidl) return S_OK;

    //
    //  Xbox PIDLs do not support junctions so
    //  so the resulting PIDL better not end up
    //  with a section of non-Xbox PIDLs under
    //  Xbox PIDLs.
    //
    if( 
        rhs.m_dwFirstXboxIdOffset &&
        (m_dwFirstXboxIdOffset !=  GetPidlSize())
    )
    {
        return E_INVALIDARG;
    }

    //
    //  We will also check after the fact that the
    //  resulting PIDL is legal.
    //
    ULONG cbThis, cbRhs, cbTotal;
    cbThis = GetPidlSize() - 2; //subtract the NULL off cbThis, since it won't be preserved.
    cbRhs = rhs.GetPidlSize();
    cbTotal = cbThis + cbRhs;
    
    //
    //  Allocate memory if necessary to append.
    //
    if(cbTotal > sm_pMalloc->GetSize(m_Pidl))
    {
      //realloc can fail.  We will simply abort the append
      //in that case.
      void *reallocMemory = sm_pMalloc->Realloc(m_Pidl, cbTotal);
      if(reallocMemory)
      {
        if(reallocMemory)
        {
          m_Pidl = (LPITEMIDLIST)reallocMemory;
        } else
        {
          return E_OUTOFMEMORY;
        }
      }
    }
    
    //
    //  There is now enough memory, so lets just append
    //
    LPITEMIDLIST pidlAppendPoint = AdvancePtr(m_Pidl, cbThis);
    memcpy(pidlAppendPoint, rhs.m_Pidl, cbRhs); 
  
    //
    //  Now validate the PDL
    //
    if(!IsValid())
    {
        //reterminate at the append point - don't worry about trying to reshrink
        //the buffer, it is not a big deal.
        pidlAppendPoint->mkid.cb = 0;
        return E_INVALIDARG;
    }

    return S_OK;
} 


//gets a copy of the real PIDL
LPITEMIDLIST  CXboxPidl::GetPidl() const
{
    LPITEMIDLIST pidlResult = NULL;
    //Assume that the class was successfully initialized
    ASSERT(sm_pMalloc);

    // There had better be a PIDL to get.
    if(m_Pidl)
    {
        // Get the size
        ULONG cb = GetPidlSize();
        // Allocate memory for the pidl
        pidlResult = (LPITEMIDLIST) sm_pMalloc->Alloc(cb);
        if(pidlResult)
        {
            //copy pidl to the result
            memcpy(pidlResult, m_Pidl, cb);        
        }
    }
    return pidlResult;
}

HRESULT CXboxPidl::GetDisplayName(DWORD uFlags, LPSTRRET lpName) const
/*++
    Routine Description:
        The implementation of IShellFolder::GetDisplayNameOf uses this method
        to extract a name from a fully qualified name.

    Arguments:
        uFlags - same flags passed to IShellFolder::GetDisplayNameOf see MSDN
        lpName - structure for returning the display name

    Comments:
        1) The parsing names and the display are the same.
        2) For relative paths we use the cStr member of the return path.
           Otherwise, the path could exceed MAX_PATH due to the addition of the
           local path to the machine name.
        3) For now at least, do not strip the extension from edit and display names.
        
--*/
{
    
    PXBOX_ITEMID pXboxItemIdList;
    PCHAR   pWritePosition = lpName->cStr;
    size_t  strLength = 0;
    lpName->uType = STRRET_CSTR;

    //If in folder is request, skip everything accept the last PIDL
    if(uFlags&SHGDN_INFOLDER)
    {
        //skip to the end.
        pXboxItemIdList = (PXBOX_ITEMID)GetLastItemId(m_Pidl);
    } else
    {
        pXboxItemIdList = (PXBOX_ITEMID)AdvancePtr(m_Pidl, m_dwFirstXboxIdOffset);
    }

    //walk the whole path.
    while(pXboxItemIdList->cb)
    {   
        //BUGBUG: For now assume that "xbox://<machinename>/" will not push over MAX_PATH
        //Eventually we can fix this, by checking if this item would do it.  If it would
        //then we copy cStr into an OLESTR allocate with pMalloc, and continue
        //writing to cStr at the beginning, then before we returning we paste cStr onto
        //the end of the OLESTR and return the OLESTR instead of the cStr.  BUT DO THAT
        //LATER
        switch(pXboxItemIdList->usItemType)
        {
            case XBOX_ITEMTYPE_ROOT:
              // If the name is for parsing prepend "xbox://"
              if(uFlags&SHGDN_FORPARSING)
              {
                strcpy(pWritePosition, "xbox://");
                strLength += sizeof("xbox://")-1;
                pWritePosition = AdvancePtr(pWritePosition, sizeof("xbox://")-1);
              } 
              //
              // There is one case that we need to include the root in the display
              // or edit name.  That is when the root is the only Pidl in the item list:
              // i.e. this item is the root
              else if(XBOX_ITEMTYPE_ROOT == m_usItemType)
              {
                strcpy(pWritePosition, "Xboxes");
                strLength += sizeof("Xboxes")-1;
                pWritePosition = AdvancePtr(pWritePosition, sizeof("Xboxes")-1);
              }
              pXboxItemIdList = AdvancePtr(pXboxItemIdList, pXboxItemIdList->cb);
              break; 
              //The next three all work the same, they just copy the text
              //from the PIDL
            case XBOX_ITEMTYPE_MACHINE:
            case XBOX_ITEMTYPE_VOLUME:
            case XBOX_ITEMTYPE_FILEORDIR:
              *pWritePosition++ = '\\';
              memcpy(
                  pWritePosition,
                  pXboxItemIdList->szItemData,
                  pXboxItemIdList->cb - sizeof(XBOX_ITEMID) + 1 //Copy the NULL termination too.
                  );
              //Advance the pointer without the NULL terminator
              pWritePosition += (pXboxItemIdList->cb - sizeof(XBOX_ITEMID)); 
              //Increment the bytes written for the '\\' and the item text
              strLength += (pXboxItemIdList->cb - sizeof(XBOX_ITEMID) + 1);
              //Move on to next item in PIDL
              pXboxItemIdList = AdvancePtr(pXboxItemIdList, pXboxItemIdList->cb);
              break; 
        }
    }

    //At this time, this cannot fail.
    return S_OK;
}

// get information necessary to communicate with an Xbox
HRESULT CXboxPidl::GetXboxName(LPSTR pMachineName, DWORD *pdwLength)
{
    //Get the first Xbox item
    PXBOX_ITEMID pXboxItemIdList;
    pXboxItemIdList = (PXBOX_ITEMID)AdvancePtr(m_Pidl, m_dwFirstXboxIdOffset);
    if(!pXboxItemIdList->cb) return E_FAIL;

    while(XBOX_ITEMTYPE_MACHINE != pXboxItemIdList->usItemType)
    {
        pXboxItemIdList = (PXBOX_ITEMID)AdvancePtr(m_Pidl, pXboxItemIdList->cb);
        if(!pXboxItemIdList->cb) return E_FAIL;
    }
    
    //Check that the buffer is large enough.
    if(*pdwLength < (pXboxItemIdList->cb - sizeof(XBOX_ITEMID) + 1))
    {
       return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    *pdwLength = (pXboxItemIdList->cb - sizeof(XBOX_ITEMID) + 1);
    memcpy(pMachineName, pXboxItemIdList->szItemData, *pdwLength);

    return S_OK;
}
HRESULT CXboxPidl::GetXboxFilePath(LPSTR pFilePath, DWORD *pdwLength)
{
    return E_NOTIMPL;
}

HRESULT
CXboxPidl::PreprocessDisplayName(
    LPCOLESTR pwszDisplayName,
    LPSTR     pszBuffer,
    DWORD    *pdwLength,
    DWORD    *pdwTokenCount,
    BOOL     *pfAbsolute
)
/*++
  Routine Description:
    Converts display names into something we can start
    to parse.
--*/
{
   LPSTR pszStr;
   DWORD dwLength;
   
   *pdwTokenCount = 0;
   
   //
   // Determine whether the display name is absolute or relative.
   //
   if(0==_wcsnicmp(pwszDisplayName, XboxNameSpaceString, XboxNameSpaceStringCount))
   // absolute path
   {
       pwszDisplayName += XboxNameSpaceStringCount; //skip the "xbox://" part
       *pfAbsolute = TRUE; //this is an absolute path
   } else
   // relative path
   {
       *pfAbsolute = FALSE;
   }

   //Make sure there is a string after "xbox://"
   if(L'\0' == *pwszDisplayName)
   {
        return 0;
   } 

   // if the first character is '/' or '\' strip it off
   if( (L'\\' == *pwszDisplayName) || (L'/' == *pwszDisplayName) )
   {
       pwszDisplayName++;
   }

   // Run it through WideCharToMultiByte to do the initial conversion
   dwLength = WideCharToMultiByte(
                    CP_OEMCP,
                    0,
                    pwszDisplayName,
                    -1,
                    pszBuffer,
                    *pdwLength,
                    NULL,
                    NULL
                    );

   if(0 == dwLength)
   {
      *pdwLength = 0;
      return HRESULT_FROM_WIN32(GetLastError());
   }

   // There is at least one token
   *pdwTokenCount = 1;
   
   //Now walk through it ourselves looking for '\' and '/' 
   //convert to '\0', and count them, don't count it though
   //if it is the last character.
   pszStr = pszBuffer;
   while(*pszStr)
   {
       if( ('\\' == *pszStr) || ('/' == *pszStr) )
       {
         *pszStr++ = '\0';
         if('\0' == *pszStr)
         {
             dwLength--; //truncate the length by one.
             break;
         }
         // Two token delimiter in a row is a syntax
         // error.
         if( ('\\' == *pszStr) || ('/' == *pszStr) )
         {
            return HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
         }
         *pdwTokenCount++;
       }
       pszStr++;
   }
   *pdwLength = dwLength;
   return S_OK;
}


/***********************************************************
 * IsValid() performs two checks:
 *
 * 1) Has this been initialized so that it contains
 *    any PIDL at all.
 *
 * 2) Are the hierarchy contraints met, namely:
 *
 *    NON-XBOX\ROOT\VOLUME\[DIR[\DIR]\]FILE
 *
 *              XBOX:// 
 ***********************************************************/
bool CXboxPidl::IsValid() const
{
    if(!m_Pidl) return false;
    // Skip the non-Xbox part
    USHORT usPrevItemType = XBOX_ITEMTYPE_NOTXBOX;
    PXBOX_ITEMID pXboxItemId = (PXBOX_ITEMID) AdvancePtr(m_Pidl, m_dwFirstXboxIdOffset);
    while(pXboxItemId->cb)
    {
        switch(usPrevItemType)
        {
            case XBOX_ITEMTYPE_NOTXBOX:
                if( m_dwFirstXboxIdOffset &&
                   (XBOX_ITEMTYPE_ROOT != pXboxItemId->usItemType)
                  ) return false;
            case XBOX_ITEMTYPE_ROOT:
                if(XBOX_ITEMTYPE_MACHINE != pXboxItemId->usItemType)
                    return false;
            case XBOX_ITEMTYPE_MACHINE:
                if(XBOX_ITEMTYPE_VOLUME != pXboxItemId->usItemType)
                    return false;
            case XBOX_ITEMTYPE_VOLUME: 
            case XBOX_ITEMTYPE_FILEORDIR:
                if(XBOX_ITEMTYPE_FILEORDIR != pXboxItemId->usItemType)
                    return false;
        }
        usPrevItemType = pXboxItemId->usItemType;
        pXboxItemId = AdvancePtr(pXboxItemId, pXboxItemId->cb);
    }
    return true;
}


/*****************************
 Walk a Pidl to get its length
*****************************/
ULONG CXboxPidl::GetPidlSize(LPCITEMIDLIST pidl)
{
    if(!pidl) return 0;
    ULONG    cbItemList = 2; //We know there are two bytes on the end
    USHORT   cbItem = pidl->mkid.cb;
    while(cbItem)
    {
        pidl = AdvancePtr(pidl, cbItem);
        cbItemList += cbItem;
        cbItem = pidl->mkid.cb;
    }
    return cbItemList;
}

LPCITEMIDLIST CXboxPidl::GetNextItemId(LPCITEMIDLIST pidl)
{
    pidl = AdvancePtr(pidl, pidl->mkid.cb);
    return pidl->mkid.cb ? pidl : NULL;
}

LPITEMIDLIST CXboxPidl::GetNextItemId(LPITEMIDLIST pidl)
{
    pidl = AdvancePtr(pidl, pidl->mkid.cb);
    return pidl->mkid.cb ? pidl : NULL;
}

LPCITEMIDLIST CXboxPidl::GetLastItemId(LPCITEMIDLIST pidl)
{
    LPCITEMIDLIST pidlPrevious;
    do
    {
        pidlPrevious = pidl;
        pidl = GetNextItemId(pidl);
    } while(pidl);
    return pidlPrevious;
}

LPITEMIDLIST CXboxPidl::CopyFirstItemId(LPCITEMIDLIST pidl)
{
    ULONG cbCopy = pidl->mkid.cb + 2;
    LPITEMIDLIST pidlLast;
    LPITEMIDLIST pidlCopy = (LPITEMIDLIST) sm_pMalloc->Alloc(cbCopy);
    if(pidlCopy)
    {
        memcpy(pidlCopy, pidl, pidl->mkid.cb);
        pidlLast = GetNextItemId(pidlCopy);
        pidlLast->mkid.cb = 0;
    }
    return pidlCopy;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxprop.cpp ===
/*****************************************************************************\
 *
 *    xboxprop.cpp - Property sheets
 *
\*****************************************************************************/

#include "priv.h"
#include "xboxprop.h"
#include "dbgmem.h"
#include "util.h"
#include "resource.h"


void CXboxProp::_HideCHMOD_UI(HWND hDlg)
{
    // Now, so hide the UI.
    for (int nIndex = IDD_CHMOD; nIndex <= IDC_CHMOD_LAST; nIndex++)
        ShowEnableWindow(GetDlgItem(hDlg, nIndex), FALSE);
}


DWORD CXboxProp::_GetUnixPermissions(void)
{
    LPCITEMIDLIST pidl = m_pflHfpl->GetPidl(0);     // They don't give us a ref.

    return XboxItemID_GetUNIXPermissions(ILGetLastID(pidl));
}


static const DWORD c_dwUnixPermissionArray[] = {UNIX_CHMOD_READ_OWNER, UNIX_CHMOD_WRITE_OWNER, UNIX_CHMOD_EXEC_OWNER,
                                                UNIX_CHMOD_READ_GROUP, UNIX_CHMOD_WRITE_GROUP, UNIX_CHMOD_EXEC_GROUP,
                                                UNIX_CHMOD_READ_ALL, UNIX_CHMOD_WRITE_ALL, UNIX_CHMOD_EXEC_ALL};

// BUGBUG: If we need to set focus rects for the check boxes, we can steal code from:
//         \\rastaman\ntwin\src\shell\security\aclui\chklist.cpp

HRESULT CXboxProp::_SetCHMOD_UI(HWND hDlg)
{
    DWORD dwUnixPermissions = _GetUnixPermissions();

    for (int nIndex = 0; nIndex < ARRAYSIZE(c_dwUnixPermissionArray); nIndex++)
    {
        // Is this permission set?
        CheckDlgButton(hDlg, (IDD_CHMOD + nIndex), (dwUnixPermissions & c_dwUnixPermissionArray[nIndex]));
    }

    return S_OK;
}


DWORD CXboxProp::_GetCHMOD_UI(HWND hDlg)
{
    DWORD dwUnixPermissions = 0;

    for (int nIndex = 0; nIndex < ARRAYSIZE(c_dwUnixPermissionArray); nIndex++)
    {
        // Is it checked in the UI?
        if (IsDlgButtonChecked(hDlg, (IDD_CHMOD + nIndex)))
        {
            // Yes, so set the big.
            dwUnixPermissions |= c_dwUnixPermissionArray[nIndex];
        }
    }

    return dwUnixPermissions;
}


/*****************************************************************************\
    FUNCTION: _SetCHMOD_CB

    DESCRIPTION:
        If we were able to rename the file, return the output pidl.
    Also tell anybody who cares that this LPITEMIDLIST needs to be refreshed.

    The "A" emphasizes that the filename is received in ANSI.

    _UNDOCUMENTED_: The documentation on SetNameOf's treatment of
    the source pidl is random.  It seems to suggest that the source
    pidl is ILFree'd by SetNameOf, but it isn't.
\*****************************************************************************/
HRESULT CXboxProp::_CommitCHMOD(HINTERNET hint, HINTPROCINFO * phpi, BOOL * pfReleaseHint)
{
    HRESULT hr;
    HINTERNET hintResponse;
    WIRECHAR wXboxCommand[MAX_PATH];
    LPCITEMIDLIST pidl = m_pflHfpl->GetPidl(0);     // They don't give us a ref.

    // 1. Create "SITE chmod <m_dwNewPermissions> <filename>" string
    wnsprintfA(wXboxCommand, ARRAYSIZE(wXboxCommand), XBOX_CMD_SITE_CHMOD_TEMPL, m_dwNewPermissions, XboxPidl_GetLastItemWireName(pidl));

    hr = XboxCommandWrap(hint, FALSE, FALSE, FTP_TRANSFER_TYPE_ASCII, wXboxCommand, NULL, &hintResponse);
    if (SUCCEEDED(hr))
    {
        // Update the pidl with the new Permissions so our cache isn't out of date.
        CXboxDir * pfd = m_pff->GetXboxDir();

        XboxItemID_SetUNIXPermissions(pidl, m_dwNewPermissions);
        if (pfd)
        {
            pfd->ReplacePidl(pidl, pidl);
            XboxChangeNotify(m_hwnd, XboxPidl_DirChoose(pidl, SHCNE_RENAMEFOLDER, SHCNE_RENAMEITEM), m_pff, pfd, pidl, pidl, TRUE);
            pfd->Release();
        }

        InternetCloseHandleWrap(hintResponse, TRUE);
    }
    else
    {
        DisplayWininetError(m_hwnd, TRUE, HRESULT_CODE(hr), IDS_XBOXERR_TITLE_ERROR, IDS_XBOXERR_CHMOD, IDS_XBOXERR_WININET, MB_OK, NULL);
        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
    }
    return hr;
}


HRESULT CXboxProp::_CommitCHMOD_CB(HINTERNET hint, HINTPROCINFO * phpi, LPVOID pvData, BOOL * pfReleaseHint)
{
    CXboxProp * pfp = (CXboxProp *) pvData;

    return pfp->_CommitCHMOD(hint, phpi, pfReleaseHint);
}


/*****************************************************************************\
    FUNCTION: OnInitDialog

    DESCRIPTION: 
        Fill the dialog with cool stuff.
\*****************************************************************************/
BOOL CXboxProp::OnInitDialog(HWND hDlg)
{
    EVAL(SUCCEEDED(m_xboxDialogTemplate.InitDialog(hDlg, TRUE, IDC_ITEM, m_pff, m_pflHfpl)));

    m_fChangeModeSupported = FALSE; // Default to false

#ifdef FEATURE_CHANGE_PERMISSIONS
    // Is the correct number of items selected to possibly enable the CHMOD feature?
    if (1 == m_pflHfpl->GetCount())
    {
        // Yes, now the question is, is it supported by the server?
        CXboxDir * pfd = m_pff->GetXboxDir();

        if (pfd)
        {
            // Does the server support it?
            m_fChangeModeSupported = pfd->IsCHMODSupported();
            if (m_fChangeModeSupported)
            {
                // Yes, so hide the "Not supported by server" string.
                ShowEnableWindow(GetDlgItem(hDlg, IDC_CHMOD_NOT_ALLOWED), FALSE);
                _SetCHMOD_UI(hDlg); // Update the checkboxes with what's available.
            }
            else
            {
                // No, so hide the CHMOD UI.  The warning that it's not supported by
                // the server is already visible.
                _HideCHMOD_UI(hDlg);
            }

            pfd->Release();
        }
        else
        {
            // No, so hide the CHMOD UI.  This happens on the property sheet for
            // the server.
            _HideCHMOD_UI(hDlg);

            // Also remove the server not supported warning.
            ShowEnableWindow(GetDlgItem(hDlg, IDC_CHMOD_NOT_ALLOWED), FALSE);
        }
    }
    else
    {
        // No, so just remove that UI.
        _HideCHMOD_UI(hDlg);

        // Also remove the server not supported warning.
        ShowEnableWindow(GetDlgItem(hDlg, IDC_CHMOD_NOT_ALLOWED), FALSE);

        // Maybe we need a message saying, "Can't do this with this many items selected"
    }
#endif // FEATURE_CHANGE_PERMISSIONS

    return 1;
}


/*****************************************************************************\
    FUNCTION: OnClose

    DESCRIPTION: 
\*****************************************************************************/
BOOL CXboxProp::OnClose(HWND hDlg)
{
    BOOL fResult = TRUE;

#ifdef FEATURE_CHANGE_PERMISSIONS
    // Did m_xboxDialogTemplate.OnClose() finish all the work it needed in order
    // to close?  This work currently changes the filename.  If so, we
    // will then want to try to apply the UNIX Permission changes if any where
    // made.
    if (m_fChangeModeSupported)
    {
        // Now we need to apply the CHMOD.
        // TODO:
        DWORD dwCurPermissions = _GetUnixPermissions();
        m_dwNewPermissions = _GetCHMOD_UI(hDlg);

        // Did the user change the permissions
        if (dwCurPermissions != m_dwNewPermissions)
        {
            CXboxDir * pfd = m_pff->GetXboxDir();

            if (pfd)
            {
                // Yes, so commit those changes to the server.
                if (FAILED(pfd->WithHint(NULL, m_hwnd, _CommitCHMOD_CB, (LPVOID) this, NULL, m_pff)))
                {
                    EVAL(SUCCEEDED(_SetCHMOD_UI(hDlg)));
                    fResult = FALSE;
                }

                pfd->Release();
            }
        }
    }
#endif // FEATURE_CHANGE_PERMISSIONS

    if (fResult)
        m_xboxDialogTemplate.OnClose(hDlg, m_hwnd, m_pff, m_pflHfpl);

    return fResult;
}


#ifdef FEATURE_CHANGE_PERMISSIONS
INT_PTR CXboxProp::_SetWhiteBGCtlColor(HWND hDlg, HDC hdc, HWND hwndCtl)
{
    INT_PTR fResult = 0;

    if ((hwndCtl == GetDlgItem(hDlg, IDC_CHMOD_GROUPBOX)) ||
        (hwndCtl == GetDlgItem(hDlg, IDC_CHMOD_LABEL_OWNER)) ||
        (hwndCtl == GetDlgItem(hDlg, IDC_CHMOD_LABEL_GROUP)) ||
        (hwndCtl == GetDlgItem(hDlg, IDC_CHMOD_LABEL_ALL)) ||
        (hwndCtl == GetDlgItem(hDlg, IDC_CHMOD_OR)) ||
        (hwndCtl == GetDlgItem(hDlg, IDC_CHMOD_OW)) ||
        (hwndCtl == GetDlgItem(hDlg, IDC_CHMOD_OE)) ||
        (hwndCtl == GetDlgItem(hDlg, IDC_CHMOD_GR)) ||
        (hwndCtl == GetDlgItem(hDlg, IDC_CHMOD_GW)) ||
        (hwndCtl == GetDlgItem(hDlg, IDC_CHMOD_GE)) ||
        (hwndCtl == GetDlgItem(hDlg, IDC_CHMOD_AR)) ||
        (hwndCtl == GetDlgItem(hDlg, IDC_CHMOD_AW)) ||
        (hwndCtl == GetDlgItem(hDlg, IDC_CHMOD_AE)))
    {
        SetBkColor(hdc, GetSysColor(COLOR_WINDOW));
        SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));

        fResult = (INT_PTR)GetSysColorBrush(COLOR_WINDOW);
    }

    return fResult;
}
#endif // FEATURE_CHANGE_PERMISSIONS


/*****************************************************************************\
 *    DlgProc
\*****************************************************************************/
INT_PTR CXboxProp::DlgProc(HWND hDlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    INT_PTR fResult = 0;   // not Handled
    CXboxProp * pfp = (CXboxProp *)GetWindowLongPtr(hDlg, GWLP_USERDATA);

    switch (wm)
    {
    case WM_INITDIALOG:
    {
        LPPROPSHEETPAGE ppsp = (LPPROPSHEETPAGE) lParam;
        pfp =  (CXboxProp *)ppsp->lParam;
        SetWindowLongPtr(hDlg, GWLP_USERDATA, (LPARAM)pfp);

        ASSERT(pfp);
        fResult = pfp->OnInitDialog(hDlg);
    }
    break;

    case WM_NOTIFY:
        if (lParam)
        {
            switch (((NMHDR *)lParam)->code) 
            {
                case PSN_APPLY:
                    if (pfp->OnClose(hDlg))
                    {
                        fResult = FALSE;    // Tell comctl32 I'm happy
                    }
                    else
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
                        fResult = TRUE;    // Tell comctl32 to look at the error code and don't close.
                    }
                break;
                
                case PSN_TRANSLATEACCELERATOR:
                    if (pfp->m_xboxDialogTemplate.HasNameChanged(hDlg, pfp->m_pff, pfp->m_pflHfpl))
                        PropSheet_Changed(GetParent(hDlg), hDlg);
                    break;
            }
        }
        break;
#ifdef FEATURE_CHANGE_PERMISSIONS
    case WM_CTLCOLORSTATIC:
    case WM_CTLCOLOREDIT:
        fResult = pfp->_SetWhiteBGCtlColor(hDlg, (HDC)wParam, (HWND)lParam);
        break;
#endif // FEATURE_CHANGE_PERMISSIONS
    }

    return fResult;
}


/*****************************************************************************\
 *    DoProp_OnThread
 *
 *    Display a property sheet on the current thread.
 *
 *    WARNING!  VIOLATION OF OLE REFERENCE STUFF!
 *
 *    The PFP that comes in must be Release()d when we're done.
 *
 *    The reason is that the caller has "given us" the reference;
 *    we now own it and are responsible for releasing it.
\*****************************************************************************/
DWORD CXboxProp::_PropertySheetThread(void)
{
    HRESULT hrOleInit;
    PROPSHEETHEADER psh;
    PROPSHEETPAGE psp;
    TCHAR szTitle[MAX_PATH];

    XBOXDebugMemLeak(DML_TYPE_THREAD | DML_BEGIN);
    hrOleInit = SHOleInitialize(0);
    ASSERT(SUCCEEDED(hrOleInit));

    // This will allow the dialog to work with items outside of the font.
    // So Date, Name, and URL can be in the correct font even through
    // it's not supported by the DLL's font.
    InitComctlForNaviteFonts();
    LoadString(HINST_THISDLL, IDS_PROP_SHEET_TITLE, szTitle, ARRAYSIZE(szTitle));

    // psh.hwndParent being NULL or valid will determine if the property
    // sheet appears in the taskbar.  We do want it there to be consistent
    // with the shell.
    //
    // BUGBUG: Comctl32's property sheet code will make this act modal by
    //         disabling the parent window (m_hwnd).  We need to fix this
    //         (#202885) by creating a dummy window and using that as the
    //         parent.

    psh.hwndParent = SHCreateWorkerWindow(NULL, m_hwnd, 0, 0, NULL, NULL);
    psh.dwSize = sizeof(psh);
    psh.dwFlags = (PSH_PROPTITLE | PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW | PSH_NOCONTEXTHELP);
    psh.hInstance = g_hinst;
    psh.pszCaption = szTitle;
    psh.nPages = 1;
    psh.nStartPage = 0;
    psh.ppsp = &psp;

    psp.dwSize = sizeof(psp);
    psp.dwFlags = PSP_DEFAULT;
    psp.hInstance = g_hinst;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_FILEPROP);
    psp.pfnDlgProc = CXboxProp::DlgProc;
    psp.lParam = (LPARAM)this;

    PropertySheet(&psh);

    this->Release();
    XBOXDebugMemLeak(DML_TYPE_THREAD | DML_END);

    SHOleUninitialize(hrOleInit);
    return 0;
}


/*****************************************************************************\
 *    CXboxProp_DoProp
 *
 *    Display a property sheet with stuff in it.
\*****************************************************************************/
HRESULT CXboxProp_DoProp(CXboxPidlList * pflHfpl, CXboxFolder * pff, HWND hwnd)
{
    CXboxProp * pfp;
    HRESULT hres = CXboxProp_Create(pflHfpl, pff, hwnd, &pfp);

    if (EVAL(SUCCEEDED(hres)))
    {
        HANDLE hThread;
        DWORD id;

        hThread = CreateThread(0, 0, CXboxProp::_PropertySheetThreadProc, (LPVOID) pfp, 0, &id);
        if (EVAL(hThread))
        {
            // It will release it self if the thread was created.
            CloseHandle(hThread);
            hres = S_OK;
        }
        else
        {
            pfp->Release();
            hres = E_UNEXPECTED;
        }
    }

    return hres;
}


/*****************************************************************************\
 *    CXboxProp_Create
 *
 *    Display a property sheet with stuff in it.
\*****************************************************************************/
HRESULT CXboxProp_Create(CXboxPidlList * pflHfpl, CXboxFolder * pff, HWND hwnd, CXboxProp ** ppfp)
{
    HRESULT hr = E_OUTOFMEMORY;
    CXboxProp * pfp;

    pfp = *ppfp = new CXboxProp();
    if (EVAL(pfp))
    {
        pfp->m_pff = pff;
        if (pff)
            pff->AddRef();

        pfp->m_pflHfpl = pflHfpl;
        if (pflHfpl)
            pflHfpl->AddRef();

        pfp->m_hwnd = hwnd;

        hr = S_OK;
    }

    return hr;
}



/****************************************************\
    Constructor
\****************************************************/
CXboxProp::CXboxProp() : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_pff);
    ASSERT(!m_hwnd);

    LEAK_ADDREF(LEAK_CXboxProp);
}


/****************************************************\
    Destructor
\****************************************************/
CXboxProp::~CXboxProp()
{
    IUnknown_Set(&m_pff, NULL);
    IUnknown_Set(&m_pflHfpl, NULL);

    DllRelease();
    LEAK_DELREF(LEAK_CXboxProp);
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CXboxProp::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CXboxProp::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CXboxProp::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, IUnknown *);
    }
    else
    {
        TraceMsg(TF_XBOXQI, "CXboxProp::QueryInterface() failed.");
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxstm.h ===
/*****************************************************************************
 *	xboxstm.h
 *****************************************************************************/

#ifndef _XBOXSTREAM_H
#define _XBOXSTREAM_H

typedef HRESULT (*STMIO)(HINTERNET hinst, BOOL fAssertOnFailure, LPVOID pvBuffer, DWORD dwNumberOfBytesToWrite, LPDWORD pdwNumberOfBytesWritten);

/*****************************************************************************
 *
 *	CXboxStm
 *
 *
 *****************************************************************************/

class CXboxStm           : public IStream
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    
    // *** IStream ***
    virtual STDMETHODIMP Read(void *pv, ULONG cb, ULONG *pcbRead);
    virtual STDMETHODIMP Write(const void *pv, ULONG cb, ULONG *pcbWritten);
    virtual STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition) { return(E_NOTIMPL); };
    virtual STDMETHODIMP SetSize(ULARGE_INTEGER libNewSize) { return(E_NOTIMPL); };
    virtual STDMETHODIMP CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    virtual STDMETHODIMP Commit(DWORD grfCommitFlags);
    virtual STDMETHODIMP Revert(void) { return(E_NOTIMPL); };
    virtual STDMETHODIMP LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    virtual STDMETHODIMP UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    virtual STDMETHODIMP Stat(STATSTG *pstatstg, DWORD grfStatFlag);
    virtual STDMETHODIMP Clone(IStream **ppstm) { return(E_NOTIMPL); };


public:
    CXboxStm();
    ~CXboxStm(void);

    // Public Member Functions
    HRESULT ReadOrWrite(LPVOID pv, ULONG cb, ULONG * pcb, DWORD dwAccess, STMIO io, HRESULT hresFail);


    // Friend Functions
    friend HRESULT CXboxStm_Create(CXboxDir * pfd, LPCITEMIDLIST pidl, DWORD dwAccess, IStream ** ppstream, ULARGE_INTEGER uliComplete, ULARGE_INTEGER uliTotal, IProgressDialog * ppd, BOOL fClosePrgDlg);

protected:
    // Private Member Variables
    int                     m_cRef;

    HINTERNET               m_hint;             //
    DWORD                   m_dwAccessType;     //
    CXboxDir *               m_pfd;              //
    HINTERNET               m_hintSession;      //
    LPITEMIDLIST            m_pidl;             //
    IProgressDialog *       m_ppd;              //
    ULARGE_INTEGER          m_uliComplete;      //
    ULARGE_INTEGER          m_uliTotal;         //
    BOOL                    m_fClosePrgDlg;     // Do we want to close the progress dialog after we finish copying this stream?
    ULONG                   m_ulBytesSinceProgressUpdate;     // When was the last time I displayed progress?
    LPITEMIDLIST            m_pidlOriginalXboxPath;    // We need to return the current directory for this handle to this location when we are done.
};

#endif // _XBOXSTREAM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxsite.cpp ===
/*****************************************************************************\
 *    xboxsite.cpp - Internal object that manages a single XBOX site
\*****************************************************************************/

#include "priv.h"
#include "xboxsite.h"
#include "xboxinet.h"
#include "xboxurl.h"
#include "statusbr.h"
#include "offline.h"
#include <ratings.h>
#include <wininet.h>
#include <dbgmem.h>

#ifdef DEBUG
DWORD g_dwOpenConnections = 0;      // Ref Counting Open Connections
#endif // DEBUG

/*****************************************************************************\
 *    CXboxSite
 *
 *    EEK!  RFC 1738 is really scary.  XBOX sites don't necessarily
 *    start you at the root, and RFC1738 says that xbox://foo/bar asks
 *    for the file bar in the DEFAULT directory, not the root!
\*****************************************************************************/
CXboxList * g_XboxSiteCache = NULL;                /* The list of all open XBOX sites */


void CXboxSite::FlushHint(void)
{
    HINTERNET hint = m_hint;

    m_hint = NULL;
    if (hint)
    {
        // Our caller needs to be holding the critical section
        // while we modify m_hint
        ASSERTCRITICAL;

        InternetCloseHandle(hint);
//        DEBUG_CODE(g_dwOpenConnections--;);
    }
}


void CXboxSite::FlushHintCritial(void)
{
    ASSERTNONCRITICAL;

    ENTERCRITICAL;
    FlushHint();
    LEAVECRITICAL;
}


void CXboxSite::FlushHintCB(LPVOID pvXboxSite)
{
    CXboxSite * pfs = (CXboxSite *) pvXboxSite;

    if (pfs)
    {
        pfs->FlushHint();
        pfs->Release();
    }
}


/*****************************************************************************\
 *    An InternetConnect has just completed.  Get the motd and cache it.
 *
 *    hint - the connected handle, possibly 0 if error
\*****************************************************************************/
void CXboxSite::CollectMotd(HINTERNET hint)
{
    CXboxGlob * pfg = GetXboxResponse(&m_cwe);
    remove_from_memlist(pfg);   // We will probably free this on a separate thread.

    ENTERCRITICAL;
    m_fMotd = m_pfgMotd ? TRUE : FALSE;            // We have a motd

    IUnknown_Set(&m_pfgMotd, NULL);
    m_pfgMotd = pfg;

    LEAVECRITICAL;
}


/*****************************************************************************\
    FUNCTION: ReleaseHint

    DESCRIPTION:
        An XboxDir client is finished with a handle to the XBOX site.
    Put it into the cache, and throw away what used to be there.

    We always keep the most recent handle, because that reduces the
    likelihood that the server will close the connection due to extended
    inactivity.

    The critical section around this entire procedure is important,
    else we open up all sorts of really ugly race conditions.  E.g.,
    the timeout might trigger before we're finished initializing it.
    Or somebody might ask for the handle before we're ready.
\*****************************************************************************/
void CXboxSite::ReleaseHint(LPCITEMIDLIST pidlXboxPath, HINTERNET hint)
{
    ENTERCRITICAL;

    TriggerDelayedAction(&m_hgti);    // Kick out the old one

    _SetPidl(pidlXboxPath);
    m_hint = hint;

    if (EVAL(SUCCEEDED(SetDelayedAction(FlushHintCB, (LPVOID) this, &m_hgti))))
        AddRef();   // We just gave away a ref.
    else
        FlushHint();    // Oh well, can't cache it

    LEAVECRITICAL;
}


// NT #362108: We need to set the redirect password for the CXboxSite that
// contains the server, the user name, but a blank password to be redirected
// to the CXboxSite that does have the correct password.  This way, if a user
// logs in and doesn't save the password in the URL or the secure cache, we
// then put it in the in memory password cache so it stays valid for that
// "browser" session (defined by process lifetime).  We then need to redirect
// future navigations that go to that 
HRESULT CXboxSite::_SetRedirPassword(LPCTSTR pszServer, INTERNET_PORT ipPortNum, LPCTSTR pszUser, LPCTSTR pszPassword, LPCITEMIDLIST pidlXboxPath, LPCTSTR pszFragment)
{
    TCHAR szUrl[MAX_URL_STRING];
    HRESULT hr;

    hr = UrlCreate(pszServer, pszUser, TEXT(""), TEXT(""), pszFragment, ipPortNum, NULL, szUrl, ARRAYSIZE(szUrl));
    if (EVAL(SUCCEEDED(hr)))
    {
        LPITEMIDLIST pidlServer;

        hr = CreateXboxPidlFromUrl(szUrl, GetCWireEncoding(), NULL, &pidlServer, m_pm, TRUE);
        if (EVAL(SUCCEEDED(hr)))
        {
            LPITEMIDLIST pidl = ILCombine(pidlServer, pidlXboxPath);

            if (pidl)
            {
                CXboxSite * pfsDest = NULL;

                // The user name has changed so we need to update the
                // CXboxSite with the new user name also.
                hr = SiteCache_PidlLookup(pidl, FALSE, m_pm, &pfsDest);
                if (EVAL(SUCCEEDED(hr)))
                {
                    pfsDest->SetRedirPassword(pszPassword);
                    pfsDest->Release();
                }

                ILFree(pidl);
            }

            ILFree(pidlServer);
        }
    }

    return hr;
}

HRESULT CXboxSite::_RedirectAndUpdate(LPCTSTR pszServer, INTERNET_PORT ipPortNum, LPCTSTR pszUser, LPCTSTR pszPassword, LPCITEMIDLIST pidlXboxPath, LPCTSTR pszFragment, IUnknown * punkSite, CXboxFolder * pff)
{
    TCHAR szUrl[MAX_URL_STRING];
    TCHAR szUser[INTERNET_MAX_USER_NAME_LENGTH];
    HRESULT hr;

    StrCpyN(szUser, pszUser, ARRAYSIZE(szUser));    // Copy because of possible reentrancy
    EscapeString(NULL, szUser, ARRAYSIZE(szUser));
    hr = UrlCreate(pszServer, szUser, pszPassword, TEXT(""), pszFragment, ipPortNum, NULL, szUrl, ARRAYSIZE(szUrl));
    if (EVAL(SUCCEEDED(hr) && pff))
    {
        LPITEMIDLIST pidlServer;

        hr = CreateXboxPidlFromUrl(szUrl, GetCWireEncoding(), NULL, &pidlServer, m_pm, TRUE);
        if (EVAL(SUCCEEDED(hr)))
        {
            LPITEMIDLIST pidl = ILCombine(pidlServer, pidlXboxPath);

            if (pidl)
            {
                // If the user changed the password, we need to setup a redirect so
                // they can return later. (NT #362108)
                if (m_pszUser && !StrCmp(m_pszUser, szUser) && StrCmp(m_pszPassword, pszPassword))
                {
                    _SetRedirPassword(pszServer, ipPortNum, szUser, pszPassword, pidlXboxPath, pszFragment);
                }

                // If the user name changed, set a redirect.
                if (!m_pszUser || StrCmp(m_pszUser, szUser))
                {
                    CXboxSite * pfsDest = NULL;

                    // The user name has changed so we need to update the
                    // CXboxSite with the new user name also.
                    hr = SiteCache_PidlLookup(pidl, FALSE, m_pm, &pfsDest);
                    if (EVAL(SUCCEEDED(hr)))
                    {
                        pfsDest->SetRedirPassword(pszPassword);
                        pfsDest->Release();
                    }
                }

                hr = _Redirect(pidl, punkSite, pff);
                ILFree(pidl);
            }

            ILFree(pidlServer);
        }
    }

    return hr;
}


HRESULT CXboxSite::_Redirect(LPITEMIDLIST pidl, IUnknown * punkSite, CXboxFolder * pff)
{
    LPITEMIDLIST pidlFull = pff->CreateFullPublicPidl(pidl);
    HRESULT hr = E_INVALIDARG;

    if (EVAL(pidlFull))
    {
        hr = IUnknown_PidlNavigate(punkSite, pidlFull, FALSE);

        ASSERT(SUCCEEDED(hr));
        ILFree(pidlFull);
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: _SetDirectory

    DESCRIPTION:
        When the caller wants a handle to the server, they often want a different
    directory than what's in the cache.  This function needs to change into
    the new directory.
\*****************************************************************************/
HRESULT CXboxSite::_SetDirectory(HINTERNET hint, HWND hwnd, LPCITEMIDLIST pidlNewDir, CStatusBar * psb, int * pnTriesLeft)
{
    HRESULT hr = S_OK;

    if (pidlNewDir && XboxID_IsServerItemID(pidlNewDir))
        pidlNewDir = _ILNext(pidlNewDir);   // Skip the server.

    ASSERT(m_pidl);
    // NT #300889: I would like to cache the dir but sometimes it gets
    //             out of wack and m_pidl doesn't match the HINTERNET's
    //             cwd.  PERF: This could be fixed in the future but
    //             this perf tweak isn't work the work now (small gain).
//  if (m_pidl && !XboxPidl_IsPathEqual(_ILNext(m_pidl), pidlNewDir))
    {
        LPITEMIDLIST pidlWithVirtualRoot;

        if (psb)
        {
            WCHAR wzDisplayPath[MAX_PATH];  // For Statusbar.
            
            if (pidlNewDir && SUCCEEDED(GetDisplayPathFromPidl(pidlNewDir, wzDisplayPath, ARRAYSIZE(wzDisplayPath), TRUE)))
                psb->SetStatusMessage(IDS_CHDIR, wzDisplayPath);
            else
                psb->SetStatusMessage(IDS_CHDIR, L"\\");
        }

        hr = PidlInsertVirtualRoot(pidlNewDir, &pidlWithVirtualRoot);
        if (EVAL(SUCCEEDED(hr)))
        {
            hr = XboxSetCurrentDirectoryPidlWrap(hint, TRUE, pidlWithVirtualRoot, TRUE, TRUE);
            if (SUCCEEDED(hr))  // Ok if failed. (No Access?)
            {
                hr = _SetPidl(pidlNewDir);
            }
            else
            {

                ReleaseHint(NULL, hint); // Nowhere
                if (hr == HRESULT_FROM_WIN32(ERROR_FTP_DROPPED))
                    FlushHintCritial(); // Don't cache dead hint
                else
                {
                    DisplayWininetError(hwnd, TRUE, HRESULT_CODE(hr), IDS_XBOXERR_TITLE_ERROR, IDS_XBOXERR_CHANGEDIR, IDS_XBOXERR_WININET, MB_OK, NULL);
                    *pnTriesLeft = 0;   // Make sure we don't keep display UI.
                    hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                }

                hint = 0;
            }

            ILFree(pidlWithVirtualRoot);
        }

        if (psb)
            psb->SetStatusMessage(IDS_EMPTY, 0);
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: _LoginToTheServer

    DESCRIPTION:
        We want an HINTERNET to do some XBOX operation but we don't have one
    cached.  So, login to create it.

    WARNING: This function will be called in a critical section and needs to 
             return in one.  However, it may leave the critical section for a
             while.
\*****************************************************************************/
HRESULT CXboxSite::_LoginToTheServer(HWND hwnd, HINTERNET hintDll, HINTERNET * phint, LPCITEMIDLIST pidlXboxPath, CStatusBar * psb, IUnknown * punkSite, CXboxFolder * pff)
{
    HRESULT hr = S_OK;

    ASSERTCRITICAL;
    BOOL fKeepTryingToLogin = FALSE;
    BOOL fTryOldPassword = TRUE;

    LEAVECRITICALNOASSERT;
    TCHAR szUser[INTERNET_MAX_USER_NAME_LENGTH];
    TCHAR szPassword[INTERNET_MAX_PASSWORD_LENGTH];

    StrCpyN(szUser, m_pszUser, ARRAYSIZE(szUser));
    StrCpyN(szPassword, m_pszPassword, ARRAYSIZE(szPassword));

    ASSERT(m_pszServer);
    if (psb)
        psb->SetStatusMessage(IDS_CONNECTING, m_pszServer);

    do
    {
        hr = InternetConnectWrap(hintDll, TRUE, HANDLE_NULLSTR(m_pszServer), m_ipPortNum, NULL_FOR_EMPTYSTR(szUser), NULL_FOR_EMPTYSTR(szPassword), INTERNET_SERVICE_FTP, 0, 0, phint);
        if (*phint)
            fKeepTryingToLogin = FALSE; // Move up.
        else
        {
            BOOL fSkipLoginDialog = FALSE;

            // Display Login dialog to get new user name/password to try again or cancel login.
            // fKeepTryingToLogin = TRUE if Dialog said [LOGIN].
            if (((ERROR_INTERNET_LOGIN_FAILURE == HRESULT_CODE(hr)) ||
                (ERROR_INTERNET_INCORRECT_USER_NAME == HRESULT_CODE(hr)) ||
                (ERROR_INTERNET_INCORRECT_PASSWORD == HRESULT_CODE(hr))) && hwnd)
            {
                BOOL fIsAnonymous = (!szUser[0] || !StrCmpI(szUser, TEXT("anonymous")) ? TRUE : FALSE);
                DWORD dwLoginFlags = (fIsAnonymous ? LOGINFLAGS_ANON_LOGINJUSTFAILED : LOGINFLAGS_USER_LOGINJUSTFAILED);

                if (fTryOldPassword)
                {
                    hr = m_cAccount.GetUserName(HANDLE_NULLSTR(m_pszServer), szUser, ARRAYSIZE(szUser));
                    if (S_OK == hr)
                    {
                        hr = m_cAccount.GetPassword(HANDLE_NULLSTR(m_pszServer), szUser, szPassword, ARRAYSIZE(szPassword));
                        if (S_OK == hr)
                        {
                            fKeepTryingToLogin = TRUE;
                            fSkipLoginDialog = TRUE;
                        }
                    }
                }
            
                if (!fSkipLoginDialog)
                {
                    // If the user tried to log in anonymously and failed, we want to try
                    // logging in with a password.  If the user tried logging in with a password
                    // and failed, we want to keep trying to log in with a password.
                    // 
                    // DisplayLoginDialog returns S_OK for OK pressed, S_FALSE for Cancel button, and
                    //       FAILED() for something is really messed up.
                    hr = m_cAccount.DisplayLoginDialog(hwnd, dwLoginFlags, HANDLE_NULLSTR(m_pszServer),
                                szUser, ARRAYSIZE(szUser), szPassword, ARRAYSIZE(szPassword));
                }

                // S_FALSE means the user cancelled out of the Login dialog.
                // We need to turn this into an error value so the caller,
                // CXboxDir::WithHint() won't call the callback.
                if (S_FALSE == hr)
                    hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);

                fKeepTryingToLogin = (SUCCEEDED(hr) ? TRUE : FALSE);
                if (fKeepTryingToLogin)
                {
                    // We need to set the cancelled error so we don't display the
                    // error message after this.
                    hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                }

                fTryOldPassword = FALSE;
            }
            else
                fKeepTryingToLogin = FALSE;
        }
    }
    while (fKeepTryingToLogin);

    if (!*phint)
    {
        ASSERT(2 != HRESULT_CODE(hr));        // error 2 = wininet not configured


#ifdef DEBUG
        // Gee, I wonder why I couldn't connect, let's find out.
        TCHAR szBuff[1500];
        InternetGetLastResponseInfoDisplayWrap(FALSE, NULL, szBuff, ARRAYSIZE(szBuff));
        // This may happen if the server has too many connections.  We may want to sniff
        // for this and offer to keep trying.  These are the response from the various
        // XBOX Servers in this case:
        // IIS v5: 421 Too many people are connected.  Please come back when the server is less busy.
        // UNIX: ???
#endif // DEBUG
    }
    // Was a different login name or password needed in order to login successfully?
    else
    {
        LPITEMIDLIST pidlVirtualDir;

        CollectMotd(*phint);
        _QueryServerFeatures(*phint);
        // Ref Count the open connections.
//                  DEBUG_CODE(g_dwOpenConnections++;);

        // Is it a VMS Server?
        if (m_fIsServerVMS)
        {
            // Yes, so skip getting pidlVirtualDir because wininet gives us
            // garbage for XboxGetCurrentDirectoryA().
        }
        else
        {
            // NOTE: If the connection isn't annonymous, the server may put the user
            //   into a sub directory called a virtual root.  We need to squirel that
            //   directory away because it may be needed when going into sub directories
            //   relative to this virtual root.
            //     Example: xbox://user1:password@server/ puts you into /users/user1/
            //     Then: xbox://user1:password@server/dir1 really should be /users/user1/dir1/
            hr = XboxGetCurrentDirectoryPidlWrap(*phint, TRUE, GetCWireEncoding(), &pidlVirtualDir);
            if (SUCCEEDED(hr))
            {
                // Are we rooted at '/'? (Meaning no virtual root)
                Pidl_Set(&m_pidlVirtualDir, pidlVirtualDir);
                ILFree(pidlVirtualDir);
            }
        }

        //DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "CXboxSite::GetHint() XboxGetCurrentDirectory() returned %#08lx", hr));
        if (StrCmp(HANDLE_NULLSTR(m_pszUser), szUser) || StrCmp(HANDLE_NULLSTR(m_pszPassword), szPassword))
        {
            // Yes, so redirect so the AddressBand and User Status Bar pane update.
            // We normally log in with m_pidl because normally we login with
            // a default directory ('\') and then change directories to the final location.
            // we do this so isolate access denied to the server and access denied to the
            // directory.
            //
            // We pass pidlXboxPath instead in this case because it will tell the browser
            // to re-direct and we won't get a chance to do the ChangeDir later.

            Str_SetPtr(&m_pszRedirPassword, szPassword);

            _RedirectAndUpdate(m_pszServer, m_ipPortNum, szUser, szPassword, pidlXboxPath, m_pszFragment, punkSite, pff);
            hr = HRESULT_FROM_WIN32(ERROR_NETWORK_ACCESS_DENIED);
        }
    }

    // Can we assume annonymous logins don't use virtual roots?
    ASSERT(FAILED(hr) || (m_pidlVirtualDir && szUser[0]) || !(m_pidlVirtualDir && szUser[0]));

    if (psb)
        psb->SetStatusMessage(IDS_EMPTY, NULL);
    ENTERCRITICALNOASSERT;

    // The directory is empty.
    _SetPidl(NULL);

    return hr;
}


/*****************************************************************************\
    FUNCTION: GetHint

    DESCRIPTION:
        An IShellFolder client wants a handle to the XBOX site.
    Pull it from the cache if possible.

    The caller should have marked the IShellFolder as busy.

    EEK!  RFC 1738 is really scary.  XBOX sites don't necessarily
    start you at the root, and RFC1738 says that xbox://foo/bar asks
    for the file bar in the DEFAULT directory, not the root!
\*****************************************************************************/
HRESULT CXboxSite::GetHint(HWND hwnd, LPCITEMIDLIST pidlXboxPath, CStatusBar * psb, HINTERNET * phint, IUnknown * punkSite, CXboxFolder * pff)
{
    HINTERNET hint = NULL;
    HINTERNET hintDll = GetWininetSessionHandle();
    HRESULT hr = S_OK;

    if (!hintDll)
    {
        // No point in retrying if we can't init Wininet
        hr = HRESULT_FROM_WIN32(GetLastError());    // Save error code
    }
    else
    {
        int cTriesLeft = 1; // This is a feature that would be cool to implement.
        hr = AssureNetConnection(NULL, hwnd, m_pszServer, NULL, TRUE);

        if (ILIsEmpty(pidlXboxPath))
            pidlXboxPath = NULL;

        if (SUCCEEDED(hr))
        {
            // BUGBUG -- I don't remember exactly what the CS is protecting
            ASSERTNONCRITICAL;
            ENTERCRITICALNOASSERT;

            do
            {
                BOOL fReuseExistingConnection = FALSE;
                hr = E_FAIL;    // We don't have our hint yet...

                ASSERTCRITICAL;
                hint = (HINTERNET) InterlockedExchangePointer(&m_hint, 0);
                if (hint)
                {
                    HINTERNET hintResponse;

                    TriggerDelayedAction(&m_hgti);      // Nothing will happen
                    fReuseExistingConnection = TRUE;    // We will need to change it for the current user.

                    // We want (S_OK == hr) if our login session is still good.  Else, we want to
                    // re-login.
                    hr = XboxCommandWrap(hint, FALSE, FALSE, FTP_TRANSFER_TYPE_ASCII, XBOX_CMD_NO_OP, NULL, &hintResponse);
                    if (SUCCEEDED(hr))
                    {
                        TraceMsg(TF_XBOXOPERATION, "CXboxSite::GetHint() We are going to use a cached HINTERNET.");
                        InternetCloseHandleWrap(hintResponse, TRUE);
                    }
                    else
                    {
                        TraceMsg(TF_XBOXOPERATION, "CXboxSite::GetHint() Can't used cached HINTERNET because server didn't respond to NOOP.");
                        InternetCloseHandleWrap(hint, TRUE);
                    }
                }
                
                if (FAILED(hr))
                {
                    hr = _LoginToTheServer(hwnd, hintDll, &hint, pidlXboxPath, psb, punkSite, pff);
                    TraceMsg(TF_XBOXOPERATION, "CXboxSite::GetHint() We had to login because we didn't have a cached HINTERNET.");
                }

                ASSERTCRITICAL;
                // BUGBUG -- is it safe to do this outside the crst?
                LEAVECRITICALNOASSERT;

                // Do we need to CD into a specific directory?  Yes, if...
                // 1. We succeeded above, AND
                // 2. We are already using a connection so the dir may be incorrect, OR
                // 3. We need a non-default dir.
                if (SUCCEEDED(hr) && (fReuseExistingConnection || pidlXboxPath))   // pidlXboxPath may be NULL.
                    hr = _SetDirectory(hint, hwnd, pidlXboxPath, psb, &cTriesLeft);

                ENTERCRITICALNOASSERT;
                ASSERTCRITICAL;
            }
            while (hr == HRESULT_FROM_WIN32(ERROR_FTP_DROPPED) && --cTriesLeft);

            LEAVECRITICALNOASSERT;
        }
    }

    *phint = hint;
    return hr;
}


HRESULT CXboxSite::_CheckToEnableCHMOD(LPCWIRESTR pwResponse)
{
    HRESULT hr = S_FALSE;
    // TODO: We should probably be more restictive in how we parse the
    //       response.  We should probably verify there is some kind of
    //       white space before and after the command.
    LPCWIRESTR pwCommand = StrStrIA(pwResponse, XBOX_UNIXCMD_CHMODA);

    // Does this XBOX server support the "SITE CHMOD" command?
    if (pwCommand)
    {
        // Yes, so we may want to use it later.
        m_fIsCHMODSupported = TRUE;

        // We can later respond with:
        // "SITE chmod xyz FileName.txt"
        // x is for Owner, (4=Read, 2=Write, 1=Execute)
        // y is for Owner, (4=Read, 2=Write, 1=Execute)
        // z is for Owner, (4=Read, 2=Write, 1=Execute)
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: _QueryServerFeatures

    DESCRIPTION:
        Find out what the server is and isn't capable of.  Information we could
    use:
        SITE: Find out OS specific commands that may be useful.  "chmod" is one
              of them.
        HELP SITE: Find out what the OS supports.
        SYST: Find out the OS type.
        NOOP: See if the connection is still alive.
        MLST: Unambiguous Directory listing with dates in UTC.
        MLSD: 
        FEAT: Features supported. UTF8 is the one we care about. 

    Response to "SITE HELP" for these servers:
        UNIX Type: L8 Version: BSD-199506
        UNIX Type: L8
           UMASK   CHMOD   GROUP   NEWER   INDEX   ALIAS   GROUPS 
           IDLE    HELP    GPASS   MINFO   EXEC    CDPATH 

        Windows_NT version 4.0
           CKM DIRSTYLE HELP STATS    
\*****************************************************************************/
HRESULT CXboxSite::_QueryServerFeatures(HINTERNET hint)
{
    HRESULT hr = E_FAIL;
    HINTERNET hintResponse;

    // Can we turn on 'UTF8' encoding?
    if (SUCCEEDED(XboxCommandWrap(hint, FALSE, FALSE, FTP_TRANSFER_TYPE_ASCII, XBOX_CMD_UTF8, NULL, &hintResponse)))
    {
        m_fInUTF8Mode = TRUE;
        m_cwe.SetUTF8Support(TRUE);
        TraceMsg(TF_XBOX_OTHER, "_QueryServerFeatures() in UTF8 Mode");

        InternetCloseHandleWrap(hintResponse, TRUE);
    }
    else
    {
        TraceMsg(TF_XBOX_OTHER, "_QueryServerFeatures() NOT in UTF8 Mode");
        m_fInUTF8Mode = FALSE;
    }

    if (!m_fFeaturesQueried)
    {
        // Is type of server software is running?  We want to know if we are running
        // on VMS, because in that case we want to fall back to HTML view (URLMON).
        // This is because the wininet guys don't want to support it.
        if (SUCCEEDED(XboxCommandWrap(hint, FALSE, FALSE, FTP_TRANSFER_TYPE_ASCII, XBOX_CMD_SYSTEM, NULL, &hintResponse)))
        {
            DWORD dwError;
            WIRECHAR wResponse[MAX_URL_STRING];
            DWORD cchSize = ARRAYSIZE(wResponse);

            if (SUCCEEDED(InternetGetLastResponseInfoWrap(TRUE, &dwError, wResponse, &cchSize)))
            {
                // Is this a VMS server?
                if (StrStrIA(wResponse, XBOX_SYST_VMS))
                    m_fIsServerVMS = TRUE;

                TraceMsg(TF_XBOX_OTHER, "_QueryServerFeatures() SYSTM returned %hs.", wResponse);
            }

            InternetCloseHandleWrap(hintResponse, TRUE);
        }


#ifdef FEATURE_CHANGE_PERMISSIONS
        // Is the server capable of supporting the UNIX "chmod" command
        // to change permissions on the file?
        if (SUCCEEDED(XboxCommandWrap(hint, FALSE, FALSE, FTP_TRANSFER_TYPE_ASCII, XBOX_CMD_SITE_HELP, NULL, &hintResponse)))
        {
            DWORD dwError;
            WIRECHAR wResponse[MAX_URL_STRING];
            DWORD cchSize = ARRAYSIZE(wResponse);

            if (SUCCEEDED(InternetGetLastResponseInfoWrap(TRUE, &dwError, wResponse, &cchSize)))
            {
                _CheckToEnableCHMOD(wResponse);
//                TraceMsg(TF_XBOX_OTHER, "_QueryServerFeatures() SITE HELP returned success");
            }

            InternetCloseHandleWrap(hintResponse, TRUE);
        }
#endif // FEATURE_CHANGE_PERMISSIONS

/*
        // Is the server capable of supporting the UNIX "chmod" command
        // to change permissions on the file?
        if (SUCCEEDED(XboxCommandWrap(hint, FALSE, FALSE, FTP_TRANSFER_TYPE_ASCII, XBOX_CMD_SITE, NULL, &hintResponse)))
        {
            DWORD dwError;
            WIRECHAR wResponse[MAX_URL_STRING];
            DWORD cchSize = ARRAYSIZE(wResponse);

            if (SUCCEEDED(InternetGetLastResponseInfoWrap(TRUE, &dwError, wResponse, &cchSize)))
            {
                TraceMsg(TF_XBOX_OTHER, "_QueryServerFeatures() SITE returned succeess");
            }

            InternetCloseHandleWrap(hintResponse, TRUE);
        }
*/
    
        m_fFeaturesQueried = TRUE;
    }

    return S_OK;    // This shouldn't fail.
}


LPITEMIDLIST CXboxSite::GetPidl(void)
{
    return ILClone(m_pidl);
}


/*****************************************************************************\
    FUNCTION: _SetPidl

    DESCRIPTION:
        m_pidl contains the ServerID and the ItemIDs making up the path of where
    m_hint is currently located.  This function will take a new path in pidlXboxPath
    and update m_pidl so it still has the server.
\*****************************************************************************/
HRESULT CXboxSite::_SetPidl(LPCITEMIDLIST pidlXboxPath)
{
    HRESULT hr = E_FAIL;
    LPITEMIDLIST pidlServer = XboxCloneServerID(m_pidl);

    if (pidlServer)
    {
        LPITEMIDLIST pidlNew = ILCombine(pidlServer, pidlXboxPath);

        if (pidlNew)
        {
            ILFree(m_pidl);
            m_pidl = pidlNew;

            hr = S_OK;
        }

        ILFree(pidlServer);
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: QueryMotd

    DESCRIPTION:
        Determine whether there is a motd at all.
\*****************************************************************************/
BOOL CXboxSite::QueryMotd(void)
{
    return m_fMotd;
}


HRESULT CXboxSite::GetVirtualRoot(LPITEMIDLIST * ppidl)
{
    HRESULT hr = S_FALSE;
    *ppidl = NULL;

    if (m_pidlVirtualDir)
    {
        *ppidl = ILClone(m_pidlVirtualDir);
        hr = S_OK;
    }

    return S_OK;
}


HRESULT CXboxSite::PidlInsertVirtualRoot(LPCITEMIDLIST pidlXboxPath, LPITEMIDLIST * ppidl)
{
    HRESULT hr = S_OK;

    if (!m_pidlVirtualDir)
        *ppidl = ILClone(pidlXboxPath);
    else
    {
        LPITEMIDLIST pidlTemp = NULL;

        if (pidlXboxPath && XboxID_IsServerItemID(pidlXboxPath))
        {
            pidlTemp = XboxCloneServerID(pidlXboxPath);
            pidlXboxPath = _ILNext(pidlXboxPath);
        }

        LPITEMIDLIST pidlWithVRoot = ILCombine(pidlTemp, m_pidlVirtualDir);
        if (pidlWithVRoot)
        {
            *ppidl = ILCombine(pidlWithVRoot, pidlXboxPath);
            ILFree(pidlWithVRoot);
        }
        
        ILFree(pidlTemp);
    }

    return S_OK;
}


BOOL CXboxSite::HasVirtualRoot(void)
{
    return (m_pidlVirtualDir ? TRUE : FALSE);
}


/*****************************************************************************\
      GetMotd
  
      Returns the HFGLOB that babysits the motd.  The refcount has been
      incremented.
\*****************************************************************************/
CXboxGlob * CXboxSite::GetMotd(void)
{
    if (m_pfgMotd)
        m_pfgMotd->AddRef();

    return m_pfgMotd;
}


/*****************************************************************************\
      GetCXboxList
  
      Return the CXboxList * that remembers which folders live in this CXboxSite *.
  
      WARNING!  The caller must own the critical section when calling
      this routine, because the returned CXboxList * is not refcounted!
\*****************************************************************************/
CXboxList * CXboxSite::GetCXboxList(void)
{
    return m_XboxDirList;
}


/*****************************************************************************\
      _CompareSites
  
      Callback during SiteCache_PrivSearch to see if the site is already in the
      list.
\*****************************************************************************/
int CALLBACK _CompareSites(LPVOID pvStrSite, LPVOID pvXboxSite, LPARAM lParam)
{
    CXboxSite * pfs = (CXboxSite *) pvXboxSite;
    LPCTSTR pszLookupStrNew = (LPCTSTR) pvStrSite;
    LPCTSTR pszLookupStr = (pfs->m_pszLookupStr ? pfs->m_pszLookupStr : TEXT(""));

    ASSERT(pszLookupStr && pszLookupStr);
    return StrCmpI(pszLookupStr, pszLookupStrNew);
}


/*****************************************************************************\
    FUNCTION: SiteCache_PrivSearch

    DESCRIPTION:
        We cache information about an XBOX Server to prevent hitting the net all
    the time.  This state is stored in CXboxSite objects and we use 'lookup strings'
    to find them.  This is what makes one server different from another.  Since
    we store password state in a CXboxSite object, we need to have one per
    user/password combo.
\*****************************************************************************/
HRESULT SiteCache_PrivSearch(LPCTSTR pszLookup, LPCITEMIDLIST pidl, IMalloc * pm, CXboxSite ** ppfs)
{
    CXboxSite * pfs = NULL;
    HRESULT hr = S_OK;

    ENTERCRITICAL;

    // CXboxSite_Init() can fail in low memory
    if (SUCCEEDED(CXboxSite_Init()))
    {
        pfs = (CXboxSite *) g_XboxSiteCache->Find(_CompareSites, (LPVOID)pszLookup);   // Add CXboxSite:: ?
        if (!pfs)
        {
            //  We need to hold the critical section while setting up
            //  the new CXboxSite structure, lest somebody else come in
            //  and try to create the same CXboxSite while we are busy.
            hr = CXboxSite_Create(pidl, pszLookup, pm, &pfs);
            if (EVAL(SUCCEEDED(hr)))
            {
                hr = g_XboxSiteCache->AppendItem(pfs);
                if (!(EVAL(SUCCEEDED(hr))))
                    IUnknown_Set(&pfs, NULL);
            }
        }
    }

    LEAVECRITICAL;
    *ppfs = pfs;
    if (pfs)
        pfs->AddRef();

    ASSERT_POINTER_MATCHES_HRESULT(*ppfs, hr);
    return hr;
}



/*****************************************************************************\
    FUNCTION: SiteCache_PidlLookupPrivHelper

    DESCRIPTION:
        We cache information about an XBOX Server to prevent hitting the net all
    the time.  This state is stored in CXboxSite objects and we use 'lookup strings'
    to find them.  This is what makes one server different from another.  Since
    we store password state in a CXboxSite object, we need to have one per
    user/password combo.
    
        SiteCache_PidlLookup() does the high level work of deciding if we want
    to do a password redirect.  This function just wraps the creating of the
    lookup string and the fetching of the site.
\*****************************************************************************/
HRESULT SiteCache_PidlLookupPrivHelper(LPCITEMIDLIST pidl, IMalloc * pm, CXboxSite ** ppfs)
{
    HRESULT hr = E_FAIL;
    TCHAR szLookup[MAX_PATH];

    *ppfs = NULL;
    hr = PidlGenerateSiteLookupStr(pidl, szLookup, ARRAYSIZE(szLookup));
    // May fail w/Outofmemory

    if (SUCCEEDED(hr))
        hr = SiteCache_PrivSearch((pidl ? szLookup : TEXT('\0')), pidl, pm, ppfs);

    ASSERT_POINTER_MATCHES_HRESULT(*ppfs, hr);
    return hr;
}


/*****************************************************************************\
    FUNCTION: SiteCache_PidlLookupPrivHelper

    DESCRIPTION:
        We cache information about an XBOX Server to prevent hitting the net all
    the time.  This state is stored in CXboxSite objects and we use 'lookup strings'
    to find them.  This is what makes one server different from another.  Since
    we store password state in a CXboxSite object, we need to have one per
    user/password combo.
\*****************************************************************************/
HRESULT SiteCache_PidlLookup(LPCITEMIDLIST pidl, BOOL fPasswordRedir, IMalloc * pm, CXboxSite ** ppfs)
{
    HRESULT hr = E_FAIL;

    if (pidl && !ILIsEmpty(pidl))
    {
        hr = SiteCache_PidlLookupPrivHelper(pidl, pm, ppfs);

        // Okay, we found a site but we may need to redirect to another site
        // because the password is wrong.  This happens if a user goes to
        // ServerA w/UserA and PasswordA but PasswordA is invalid.  So,
        // PasswordB is entered and the navigation completes successfully.
        // Now either the navigation occurs again with PasswordA or w/o
        // a password (because the addrbar removes it), then we need to
        // look it up again and get it.
        if (SUCCEEDED(hr) && (*ppfs)->m_pszRedirPassword && fPasswordRedir)
        {
            LPITEMIDLIST pidlNew;   // with new (redirected) password

            if (XboxPidl_IsAnonymous(pidl))
            {
                pidlNew = ILClone(pidl);
                if (!pidlNew)
                    hr = E_OUTOFMEMORY;
            }
            else
            {
                // We need to redirect to get that CXboxSite.
                hr = PidlReplaceUserPassword(pidl, &pidlNew, pm, NULL, (*ppfs)->m_pszRedirPassword);
            }

            (*ppfs)->Release();
            *ppfs = NULL;
            if (SUCCEEDED(hr))
            {
                hr = SiteCache_PidlLookupPrivHelper(pidlNew, pm, ppfs);
                ILFree(pidlNew);
            }
        }
    }

    ASSERT_POINTER_MATCHES_HRESULT(*ppfs, hr);
    return hr;
}


/*****************************************************************************\
     FUNCTION: UpdateHiddenPassword

     DESCRIPTION:
        Since our IShellFolder::GetDisplayNameOf() will hide the password in some
     cases, we need to 'patch' display names that come thru our
     IShellFolder::GetDisplayName().  If a display name is coming in, we will
     see if the CXboxSite has a m_pszRedirPassword.  If it did, then the user entered
     a password via the 'Login As...' dialog in place of the empty password,
     which made it hidden.  If this is the case, we then have IShellFolder::ParseDisplayName()
     patch back in the password.
\*****************************************************************************/
HRESULT CXboxSite::UpdateHiddenPassword(LPITEMIDLIST pidl)
{
    HRESULT hr = S_FALSE;
    TCHAR szUserName[INTERNET_MAX_USER_NAME_LENGTH];
    TCHAR szPassword[INTERNET_MAX_PASSWORD_LENGTH];

    // Is it a candidate to a password to be inserted?
    if (m_pszPassword && 
        EVAL(SUCCEEDED(XboxPidl_GetUserName(pidl, szUserName, ARRAYSIZE(szUserName)))) &&
        szUserName[0] &&
        SUCCEEDED(XboxPidl_GetPassword(pidl, szPassword, ARRAYSIZE(szPassword), TRUE)) &&
        !szPassword[0]) 
    {
        // Yes...
        hr = XboxServerID_SetHiddenPassword(pidl, m_pszPassword);
    }

    return hr;
}


/*****************************************************************************\
     CXboxSite::GetXboxDir
\*****************************************************************************/
HRESULT CXboxSite::GetXboxDir(LPCTSTR pszServer, LPCWSTR pszUrlPath, CXboxDir ** ppfd)
{
    HRESULT hr = S_OK;
    TCHAR szUrl[MAX_URL_STRING];

    *ppfd = NULL;
    hr = UrlCreate(pszServer, NULL, NULL, pszUrlPath, NULL, INTERNET_DEFAULT_FTP_PORT, NULL, szUrl, ARRAYSIZE(szUrl));
    if (EVAL(SUCCEEDED(hr)))
    {
        LPITEMIDLIST pidl;

        // We know this is a path.
        hr = CreateXboxPidlFromUrlEx(szUrl, GetCWireEncoding(), NULL, &pidl, m_pm, FALSE, TRUE, TRUE);
        if (EVAL(SUCCEEDED(hr)))
        {
            hr = GetXboxDir(pidl, ppfd);
            ILFree(pidl);
        }
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: GetXboxDir

    DESCRIPTION:
        Obtain the XboxDir structure for an XBOX site, creating one if
    necessary.  It is the caller's responsibility to Release the
    XboxDir when finished.
\*****************************************************************************/
HRESULT CXboxSite::GetXboxDir(LPCITEMIDLIST pidl, CXboxDir ** ppfd)
{
    HRESULT hr = S_OK;
    CXboxDir * pfd = NULL;

    ENTERCRITICAL;
    ASSERT(ppfd && m_XboxDirList);

    pfd = (CXboxDir *) m_XboxDirList->Find(_CompareDirs, (LPVOID) pidl);
    if (!pfd)
    {
        // We need to hold the critical section while setting up
        // the new XboxDir structure, lest somebody else come in
        // and try to create the same XboxDir while we are busy.
        hr = CXboxDir_Create(this, pidl, &pfd);
        if (EVAL(SUCCEEDED(hr)))
        {
            // NOTE: REF-COUNTING
            //      Note that CXboxDir has a pointer (m_pfs) to a CXboxSite.
            //      We just added a back pointer in CXboxSite's list of CXboxDir(s),
            //      so it's necessary for that back pointer to not have a ref.
            //      This will not be a problem because the back pointers will
            //      always be valid because: 1) CXboxDir's destructor removes the backpointer,
            //      and 2) CXboxDir holds a ref on CXboxSite, so it won't go away until
            //      all the CXboxDir(s) are good and ready.  -BryanSt
            hr = m_XboxDirList->AppendItem(pfd);
            if (FAILED(hr))
                IUnknown_Set(&pfd, NULL);
        }
    }
    LEAVECRITICAL;

    *ppfd = pfd;
    if (pfd)
        pfd->AddRef();

    return hr;
}


/*****************************************************************************\
    FUNCTION: FlushSubDirs

    DESCRIPTION:
        Every subdir of pidl is no longer valid so flush them.  This is done
    because the parent dir may have changed names so they are invalid.

    PARAMETERS:
        pidl: Path of ItemIDs (no-ServerID) that includes the full path w/o
              the virtual root.  This matches CXboxDir::m_pidlXboxDir
\*****************************************************************************/
HRESULT CXboxSite::FlushSubDirs(LPCITEMIDLIST pidl)
{
    HRESULT hr = S_OK;
    CXboxDir * pfd = NULL;
    int nIndex;

    ENTERCRITICAL;

    // Count down so deleting items won't screw up the indicies.
    for (nIndex = (m_XboxDirList->GetCount() - 1); nIndex >= 0; nIndex--)
    {
        pfd = (CXboxDir *) m_XboxDirList->GetItemPtr(nIndex);
        if (pfd)
        {
            // Is this a child?
            if (XboxItemID_IsParent(pidl, pfd->GetPathPidlReference()))
            {
                // Yes, pfd is a child of pidl so delete it.
                m_XboxDirList->DeletePtrByIndex(nIndex);
                pfd->Release();
            }
        }
    }
    LEAVECRITICAL;

    return hr;
}


BOOL CXboxSite::IsSiteBlockedByRatings(HWND hwndDialogOwner)
{
    if (!m_fRatingsChecked)
    {
        void * pvRatingDetails = NULL;
        TCHAR szUrl[MAX_URL_STRING];
        CHAR szUrlAnsi[MAX_URL_STRING];
        HRESULT hr = S_OK;  // Assume allowed (in case no ratings)

        EVAL(SUCCEEDED(UrlCreateFromPidlW(m_pidl, SHGDN_FORPARSING, szUrl, ARRAYSIZE(szUrl), (ICU_ESCAPE | ICU_USERNAME), FALSE)));
        SHTCharToAnsi(szUrl, szUrlAnsi, ARRAYSIZE(szUrlAnsi));

        if (IS_RATINGS_ENABLED())
        {
            // S_OK - Allowed, S_FALSE - Not Allowed, FAILED() - not rated.
            hr = RatingCheckUserAccess(NULL, szUrlAnsi, NULL, NULL, 0, &pvRatingDetails);
            if (S_OK != hr)    // Does user want to override with parent password in dialog?
                hr = RatingAccessDeniedDialog2(hwndDialogOwner, NULL, pvRatingDetails);

            if (pvRatingDetails)
                RatingFreeDetails(pvRatingDetails);
        }

        if (S_OK == hr)     // It's off by default.
            m_fRatingsAllow = TRUE;

        m_fRatingsChecked = TRUE;
    }

    return !m_fRatingsAllow;
}


/*****************************************************************************\
      CXboxSite_Init
  
      Initialize the global list of XBOX sites.
  
      Note that the DLL refcount is decremented after this is created,
      so that this internal list doesn't prevent us from unloading.
\*****************************************************************************/
HRESULT CXboxSite_Init(void)
{
    HRESULT hr = S_OK;

    if (!g_XboxSiteCache)
        hr = CXboxList_Create(10, NULL, 10, &g_XboxSiteCache);

    return hr;
}


/*****************************************************************************\
      XboxSitePurge_CallBack
  
      Purge the global list of XBOX sites.
\*****************************************************************************/
int XboxSitePurge_CallBack(LPVOID pvPunk, LPVOID pv)
{
    IUnknown * punk = (IUnknown *) pvPunk;

    if (punk)
        punk->Release();

    return 1;
}


/*****************************************************************************\
      CXboxPunkList_Purge
  
      Purge the global list of XBOX sites.
\*****************************************************************************/
HRESULT CXboxPunkList_Purge(CXboxList ** pfl)
{
    TraceMsg(TF_XBOX_DLLLOADING, "CXboxPunkList_Purge() Purging our cache.");
    if (*pfl)
    {
        (*pfl)->Enum(XboxSitePurge_CallBack, NULL);
        IUnknown_Set(pfl, NULL);
    }

    return S_OK;
}


/*****************************************************************************\
      CXboxSite_Create
  
      Create a brand new CXboxSite given a name.
\*****************************************************************************/
HRESULT CXboxSite_Create(LPCITEMIDLIST pidl, LPCTSTR pszLookupStr, IMalloc * pm, CXboxSite ** ppfs)
{
    CXboxSite * pfs = new CXboxSite();
    HRESULT hr = E_OUTOFMEMORY;

    ASSERT(pidl && pszLookupStr && ppfs);
    *ppfs = NULL;
    if (EVAL(pfs))
    {
        Str_SetPtr(&pfs->m_pszLookupStr, pszLookupStr);

        IUnknown_Set((IUnknown **) &(pfs->m_pm), pm);
        hr = CXboxList_Create(10, NULL, 10, &pfs->m_XboxDirList);
        if (EVAL(SUCCEEDED(hr)))
        {
            // Did someone give us an empty URL?
            if (EVAL(pidl) && EVAL(XboxPidl_IsValid(pidl)))
            {
                TCHAR szServer[INTERNET_MAX_HOST_NAME_LENGTH];
                TCHAR szUser[INTERNET_MAX_USER_NAME_LENGTH];
                TCHAR szPassword[INTERNET_MAX_PASSWORD_LENGTH];
                TCHAR szFragment[INTERNET_MAX_PASSWORD_LENGTH];

                EVAL(SUCCEEDED(XboxPidl_GetServer(pidl, szServer, ARRAYSIZE(szServer))));
                Str_SetPtr(&pfs->m_pszServer, szServer);

                Pidl_Set(&pfs->m_pidl, pidl);

                EVAL(SUCCEEDED(XboxPidl_GetUserName(pidl, szUser, ARRAYSIZE(szUser))));
                Str_SetPtr(&pfs->m_pszUser, szUser);
                
                if (FAILED(XboxPidl_GetPassword(pidl, szPassword, ARRAYSIZE(szPassword), TRUE)))
                {
                       // Password expired
                    szPassword[0] = 0;
                }

                Str_SetPtr(&pfs->m_pszPassword, szPassword);
                XboxPidl_GetFragment(pidl, szFragment, ARRAYSIZE(szFragment));
                Str_SetPtr(&pfs->m_pszFragment, szFragment);

                pfs->m_ipPortNum = XboxPidl_GetPortNum(pidl);

                switch (XboxPidl_GetDownloadType(pidl))
                {
                case FTP_TRANSFER_TYPE_UNKNOWN:
                    pfs->m_fDLTypeSpecified = FALSE;
                    pfs->m_fASCIIDownload = FALSE;
                    break;
                case FTP_TRANSFER_TYPE_ASCII:
                    pfs->m_fDLTypeSpecified = TRUE;
                    pfs->m_fASCIIDownload = TRUE;
                    break;
                case FTP_TRANSFER_TYPE_BINARY:
                    pfs->m_fDLTypeSpecified = TRUE;
                    pfs->m_fASCIIDownload = FALSE;
                    break;
                default:
                    ASSERT(0);
                }
            }
            else
            {
                Str_SetPtr(&pfs->m_pszServer, NULL);
                Str_SetPtr(&pfs->m_pszUser, NULL);
                Str_SetPtr(&pfs->m_pszPassword, NULL);
                Str_SetPtr(&pfs->m_pszFragment, NULL);

                Pidl_Set(&pfs->m_pidl, NULL);
                pfs->m_fDLTypeSpecified = FALSE;
            }
            *ppfs = pfs;
        }
        else
        {
            hr = E_FAIL;
            pfs->Release();
        }
    }

    return hr;
}



/****************************************************\
    Constructor
\****************************************************/
CXboxSite::CXboxSite() : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_pszServer);
    ASSERT(!m_pidl);
    ASSERT(!m_pszUser);
    ASSERT(!m_pszPassword);
    ASSERT(!m_pszFragment);
    ASSERT(!m_pszLookupStr);
    ASSERT(!m_pidlVirtualDir);

    ASSERT(!m_fMotd);
    ASSERT(!m_hint);
    ASSERT(!m_hgti);
    ASSERT(!m_XboxDirList);
    ASSERT(!m_fRatingsChecked);
    ASSERT(!m_fRatingsAllow);

    LEAK_ADDREF(LEAK_CXboxSite);
}


/****************************************************\
    Destructor
\****************************************************/
CXboxSite::~CXboxSite()
{
    FlushHint();        // Frees m_hgti

    Str_SetPtr(&m_pszServer, NULL);
    Str_SetPtr(&m_pszUser, NULL);
    Str_SetPtr(&m_pszPassword, NULL);
    Str_SetPtr(&m_pszFragment, NULL);
    Str_SetPtr(&m_pszLookupStr, NULL);
    Str_SetPtr(&m_pszRedirPassword, NULL);

    Pidl_Set(&m_pidlVirtualDir, NULL);
    Pidl_Set(&m_pidl, NULL);

    IUnknown_Set(&m_pfgMotd, NULL);

    ASSERTCRITICAL;

    CXboxPunkList_Purge(&m_XboxDirList);

    TriggerDelayedAction(&m_hgti);    // Out goes the cached handle
    ASSERT(m_hint == 0);        // Make sure he's gone
    ATOMICRELEASE(m_pm);

    DllRelease();
    LEAK_DELREF(LEAK_CXboxSite);
}


//===========================
// *** IUnknown Interface ***
ULONG CXboxSite::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CXboxSite::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}


HRESULT CXboxSite::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, IUnknown*);
    }
    else
    {
        TraceMsg(TF_XBOXQI, "CXboxSite::QueryInterface() failed.");
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxsite.h ===
/*****************************************************************************
 *    xboxsite.h
 *****************************************************************************/

#ifndef _XBOXSITE_H
#define _XBOXSITE_H

#include "xboxfldr.h"
#include "xboxlist.h"
#include "xboxinet.h"
#include "xboxurl.h"
#include "account.h"
#include "util.h"

HRESULT SiteCache_PidlLookup(LPCITEMIDLIST pidl, BOOL fPasswordRedir, IMalloc * pm, CXboxSite ** ppfs);


int CALLBACK _CompareSites(LPVOID pvStrSite, LPVOID pvXboxSite, LPARAM lParam);
HRESULT CXboxPunkList_Purge(CXboxList ** pfl);

/*****************************************************************************
 *    CXboxSite
 *****************************************************************************/

class CXboxSite              : public IUnknown
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

public:
    CXboxSite();
    ~CXboxSite();

    // Public Member Functions
    void CollectMotd(HINTERNET hint);
    void ReleaseHint(LPCITEMIDLIST pidlXboxPath, HINTERNET hint);
    HRESULT GetHint(HWND hwnd, LPCITEMIDLIST pidlXboxPath, CStatusBar * psb, HINTERNET * phint, IUnknown * punkSite, CXboxFolder * pff);
    BOOL QueryMotd(void);
    BOOL IsServerVMS(void) {return m_fIsServerVMS;};
    BOOL HasVirtualRoot(void);
    CXboxGlob * GetMotd(void);
    CXboxList * GetCXboxList(void);
    CWireEncoding * GetCWireEncoding(void) {return &m_cwe;};
    HRESULT GetXboxDir(LPCITEMIDLIST pidl, CXboxDir ** ppfd);
    HRESULT GetXboxDir(LPCTSTR pszUrlPath, CXboxDir ** ppfd) {return GetXboxDir(m_pszServer, pszUrlPath, ppfd);};
    HRESULT GetXboxDir(LPCTSTR pszServer, LPCTSTR pszUrlPath, CXboxDir ** ppfd);

    HRESULT GetVirtualRoot(LPITEMIDLIST * ppidl);
    HRESULT PidlInsertVirtualRoot(LPCITEMIDLIST pidlXboxPath, LPITEMIDLIST * ppidl);
    LPCITEMIDLIST GetVirtualRootReference(void) {return (LPCITEMIDLIST) m_pidlVirtualDir;};

    HRESULT GetServer(LPTSTR pszServer, DWORD cchSize) { StrCpyN(pszServer, HANDLE_NULLSTR(m_pszServer), cchSize); return S_OK; };
    HRESULT GetUser(LPTSTR pszUser, DWORD cchSize) { StrCpyN(pszUser, HANDLE_NULLSTR(m_pszUser), cchSize); return S_OK; };
    HRESULT GetPassword(LPTSTR pszPassword, DWORD cchSize) { StrCpyN(pszPassword, HANDLE_NULLSTR(m_pszPassword), cchSize); return S_OK; };
    HRESULT UpdateHiddenPassword(LPITEMIDLIST pidl);
    HRESULT SetRedirPassword(LPCTSTR pszPassword) {Str_SetPtr(&m_pszRedirPassword, pszPassword); return S_OK;};
    HRESULT FlushSubDirs(LPCITEMIDLIST pidl);

    LPITEMIDLIST GetPidl(void);

    BOOL IsCHMODSupported(void) {return m_fIsCHMODSupported;};
    BOOL IsUTF8Supported(void) {return m_fInUTF8Mode;};
    BOOL IsSiteBlockedByRatings(HWND hwndDialogOwner);
    void FlushRatingsInfo(void) {m_fRatingsChecked = m_fRatingsAllow = FALSE;};

    static void FlushHintCB(LPVOID pvXboxSite);


    // Friend Functions
    friend HRESULT CXboxSite_Create(LPCITEMIDLIST pidl, LPCTSTR pszLookupStr, IMalloc * pm, CXboxSite ** ppfs);
    friend HRESULT SiteCache_PidlLookup(LPCITEMIDLIST pidl, BOOL fPasswordRedir, IMalloc * pm, CXboxSite ** ppfs);

    friend int CALLBACK _CompareSites(LPVOID pvStrSite, LPVOID pvXboxSite, LPARAM lParam);
    friend class CXboxView;


protected:
    // Private Member Variables
    int m_cRef;

    BOOL            m_fMotd;            // There is a Motd at all
    BOOL            m_fNewMotd;         // Motd has changed
    HINTERNET       m_hint;             // Session for this site
    LPGLOBALTIMEOUTINFO m_hgti;         // Timeout for the session handle
    CXboxList *     m_XboxDirList;      // List of XboxDir's attached to me. (No Ref Held)
    CXboxGlob *     m_pfgMotd;          //
    IMalloc *       m_pm;               // Used for creating full pidls if needed.

    LPTSTR          m_pszServer;        // Server name
    LPITEMIDLIST    m_pidl;             // What Xbox dir is hint in? (Not including the virtual root) (Does begin with ServerID)
    LPTSTR          m_pszUser;          // 0 or "" means "anonymous"
    LPTSTR          m_pszPassword;      // User's Password
    LPTSTR          m_pszFragment;      // URL fragment
    LPITEMIDLIST    m_pidlVirtualDir;   // Our rooted directory on the server.
    LPTSTR          m_pszRedirPassword; // What was the password if it was changed?
    LPTSTR          m_pszLookupStr;     // Str to lookup.
    INTERNET_PORT   m_ipPortNum;        // The port number
    BOOL            m_fDLTypeSpecified; // Did the user specify a Download Type to use? (ASCII vs. Binary)
    BOOL            m_fASCIIDownload;   // If specified, was it ASCII? (Else, Binary)
    CAccounts       m_cAccount;
    BOOL            m_fRatingsChecked;  // Did I check ratings yet?
    BOOL            m_fRatingsAllow;    // Does ratings allow access to this site?
    BOOL            m_fFeaturesQueried; // 
    BOOL            m_fInUTF8Mode;      // Did a success value come back from the 'UTF8' command?
    BOOL            m_fIsCHMODSupported;// Is the CHMOD UNIX command supported via the 'SITE CHMOD' XBOX Command?
    BOOL            m_fIsServerVMS;     // Is this a VMS server?

    CWireEncoding   m_cwe;              // What codepage and confidence in that codepage of the MOTD and filenames?

    // Protected Member Functions
    HRESULT _RedirectAndUpdate(LPCTSTR pszServer, INTERNET_PORT ipPortNum, LPCTSTR pszUser, LPCTSTR pszPassword, LPCITEMIDLIST pidlXboxPath, LPCTSTR pszFragment, IUnknown * punkSite, CXboxFolder * pff);
    HRESULT _Redirect(LPITEMIDLIST pidl, IUnknown * punkSite, CXboxFolder * pff);
    HRESULT _SetDirectory(HINTERNET hint, HWND hwnd, LPCITEMIDLIST pidlNewDir, CStatusBar * psb, int * pnTriesLeft);

private:
    // Private Member Functions
    HRESULT _SetPidl(LPCITEMIDLIST pidlXboxPath);
    HRESULT _QueryServerFeatures(HINTERNET hint);
    HRESULT _CheckToEnableCHMOD(LPCWIRESTR pwResponse);
    HRESULT _LoginToTheServer(HWND hwnd, HINTERNET hintDll, HINTERNET * phint, LPCITEMIDLIST pidlXboxPath, CStatusBar * psb, IUnknown * punkSite, CXboxFolder * pff);
    HRESULT _SetRedirPassword(LPCTSTR pszServer, INTERNET_PORT ipPortNum, LPCTSTR pszUser, LPCTSTR pszPassword, LPCITEMIDLIST pidlXboxPath, LPCTSTR pszFragment);

    void FlushHint(void);
    void FlushHintCritial(void);

    // Private Friend Functions
    friend HRESULT SiteCache_PrivSearch(LPCTSTR pszLookup, LPCITEMIDLIST pidl, IMalloc * pm, CXboxSite ** ppfs);
};



HRESULT CXboxSite_Init(void);
HRESULT CXboxSite_Create(LPCITEMIDLIST pidl, LPCTSTR pszLookupStr, IMalloc * pm, CXboxSite ** ppfs);


#endif // _XBOXSITE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxstm.cpp ===
/*****************************************************************************
 *
 *    xboxstm.cpp - IStream interface
 *
 *****************************************************************************/

#include "priv.h"
#include "xboxstm.h"
#include "xboxurl.h"

#define     UPDATE_PROGRESS_EVERY       (10*1024)       // Update progress every 10k

/*****************************************************************************
 *    CXboxStm::ReadOrWrite
 *****************************************************************************/
HRESULT CXboxStm::ReadOrWrite(LPVOID pv, ULONG cb, ULONG * pcb, DWORD dwAccess, STMIO io, HRESULT hresFail)
{
    HRESULT hr = STG_E_ACCESSDENIED;

    if (EVAL(m_dwAccessType & dwAccess))
    {
        ULONG cbOut;
        if (!pcb)
            pcb = &cbOut;

        hr = io(m_hint, TRUE, pv, cb, pcb);
        if (SUCCEEDED(hr) && m_ppd)
        {
            m_uliComplete.QuadPart += cb;
            m_ulBytesSinceProgressUpdate += cb;
            if (m_ulBytesSinceProgressUpdate > UPDATE_PROGRESS_EVERY)
            {
                m_ulBytesSinceProgressUpdate = 0;
                EVAL(SUCCEEDED(m_ppd->SetProgress64(m_uliComplete.QuadPart, m_uliTotal.QuadPart)));
            }

            if (TRUE == m_ppd->HasUserCancelled())
                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
        }
    }

    return hr;
}


//===========================
// *** IStream Interface ***
//===========================

/*****************************************************************************
 *    IStream::Read
 *****************************************************************************/
HRESULT CXboxStm::Read(LPVOID pv, ULONG cb, PULONG pcb)
{
    return ReadOrWrite(pv, cb, pcb, GENERIC_READ, InternetReadFileWrap, S_FALSE);
}


/*****************************************************************************
 *    IStream::Write
 *****************************************************************************/
HRESULT CXboxStm::Write(LPCVOID pv, ULONG cb, PULONG pcb)
{
    return ReadOrWrite((LPVOID)pv, cb, pcb, GENERIC_WRITE, (STMIO) InternetWriteFileWrap, STG_E_WRITEFAULT);
}


/*****************************************************************************
 *    IStream::CopyTo
 *
 *    _UNOBVIOUS_:  Implementing CopyTo is mandatory for drag/drop to work.
 *****************************************************************************/
#define SIZE_STREAM_COPY_BUFFER     (1024*16)        // 16k is the perfect size for 

HRESULT CXboxStm::CopyTo(IStream * pstmDest, ULARGE_INTEGER cbToCopy, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
{
    HRESULT hr = E_FAIL;
    IStream * pstmSrc;

    if (EVAL(SUCCEEDED(hr = QueryInterface(IID_IStream, (LPVOID *) &pstmSrc))))
    {
        ULARGE_INTEGER uliTotalIn;
        ULARGE_INTEGER uliTotalOut;
        uliTotalIn.QuadPart = uliTotalOut.QuadPart = 0;
        BYTE buffer[SIZE_STREAM_COPY_BUFFER];

        for (;;)
        {
            // Very unusual loop control
            ULONG cbIn = 0;        // In case pstmSrc forgets to

            //    No matter how you write this, the compiler emits horrid code.
            ULONG cb = (ULONG)min(SIZE_STREAM_COPY_BUFFER, cbToCopy.LowPart);
            hr = pstmSrc->Read(buffer, cb, &cbIn);
            uliTotalIn.QuadPart += cbIn;
            if (SUCCEEDED(hr) && cbIn)
            {
                ULARGE_INTEGER uliOut;    // In case pstmDest forgets to
                uliOut.QuadPart = 0;

                hr = pstmDest->Write(buffer, cbIn, &(uliOut.LowPart));
                uliTotalOut.QuadPart += uliOut.QuadPart;
                if (EVAL(SUCCEEDED(hr) && uliOut.QuadPart))
                {
                    // Onward
                }
                else
                {
                    break;        // Error or medium full
                }
            }
            else
            {
                break;            // Error or EOF reached
            }
        }

        if (pcbRead)
            pcbRead->QuadPart = uliTotalIn.QuadPart;

        if (pcbWritten)
            pcbWritten->QuadPart = uliTotalOut.QuadPart;

        pstmSrc->Release();
    }

    return hr;
}


/*****************************************************************************
 *    IStream::Commit
 *
 *    NOTE: WinINet doesn't really implement this, so I just do my best
 *****************************************************************************/
HRESULT CXboxStm::Commit(DWORD grfCommitFlags)
{
    return S_OK;
}


/*****************************************************************************
 *    IStream::LockRegion
 *
 *    You can't lock an Xbox stream.
 *****************************************************************************/
HRESULT CXboxStm::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    return STG_E_INVALIDFUNCTION;
}


/*****************************************************************************
 *    IStream::UnlockRegion
 *
 *    You can't unlock an Xbox stream because you can't lock one...
 *****************************************************************************/
HRESULT CXboxStm::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    return STG_E_INVALIDFUNCTION;
}


/*****************************************************************************
 *    IStream::Stat
 *
 *    We fill in what we can.
 *
 *    As the pwcsName, we put the URL that the stream represents, and
 *    install ourselves as the clsid.
 *****************************************************************************/
HRESULT CXboxStm::Stat(STATSTG *pstat, DWORD grfStatFlag)
{
    HRESULT hr;

    ZeroMemory(pstat, sizeof(*pstat));
    pstat->type = STGTY_STREAM;

    pstat->mtime = XboxPidl_GetFileTime(ILFindLastID(m_pidl));
    pstat->cbSize.QuadPart = XboxItemID_GetFileSize(m_pidl);

    pstat->grfMode |= STGM_SHARE_EXCLUSIVE | STGM_DIRECT;
    if (m_dwAccessType & GENERIC_READ)
        pstat->grfMode |= STGM_READ;

    if (m_dwAccessType & GENERIC_WRITE)
        pstat->grfMode |= STGM_WRITE;

    if (grfStatFlag & STATFLAG_NONAME)
        hr = S_OK;
    else
    {
        DWORD cchSize = (lstrlenW(XboxPidl_GetLastFileDisplayName(m_pidl)) + 1);

        pstat->pwcsName = (LPWSTR) SHAlloc(cchSize * sizeof(WCHAR));
        if (pstat->pwcsName)
        {
            StrCpyNW(pstat->pwcsName, XboxPidl_GetLastFileDisplayName(m_pidl), cchSize);
            hr = S_OK;
        }
        else
            hr = STG_E_INSUFFICIENTMEMORY;    // N.B., not E_OUTOFMEMORY
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION:   CXboxStm_Create

    DESCRIPTION:
        The caller will display errors, so don't do that here.
\*****************************************************************************/
HRESULT CXboxStm_Create(CXboxDir * pfd, LPCITEMIDLIST pidl, DWORD dwAccess, IStream ** ppstream, ULARGE_INTEGER uliComplete, ULARGE_INTEGER uliTotal, IProgressDialog * ppd, BOOL fClosePrgDlg)
{
    CXboxStm * pfstm = new CXboxStm();
    HRESULT hr = E_OUTOFMEMORY;
    DWORD dwError = ERROR_SUCCESS;

    *ppstream = NULL;
    if (pfstm)
    {
        Pidl_Set(&(pfstm->m_pidl), pidl);
        ASSERT(pfstm->m_pidl);
        pfstm->m_dwAccessType = dwAccess;
        IUnknown_Set(&pfstm->m_pfd, pfd);
        IUnknown_Set((IUnknown **)&pfstm->m_ppd, (IUnknown *)ppd);
        pfstm->m_uliComplete = uliComplete;
        pfstm->m_uliTotal = uliTotal;
        pfstm->m_fClosePrgDlg = fClosePrgDlg;

        //      GetHint() is going to want to spew status into the Status Bar
        //   But how do we get the hwnd?  This is an architectural question that
        //   we need to solve for all Shell Extensions.  The answer is to not use
        //   the progress bar in the status bar but a Progress Dialog.  But it's
        //   the responsibility of the caller to do that.
        HWND hwnd = NULL;

        hr = pfd->GetHint(hwnd, NULL, &pfstm->m_hintSession, NULL, NULL);
        if (EVAL(SUCCEEDED(hr)))
        {
            LPITEMIDLIST pidlVirtualRoot;

            hr = pfd->GetXboxSite()->GetVirtualRoot(&pidlVirtualRoot);
            if (EVAL(SUCCEEDED(hr)))
            {
                LPITEMIDLIST pidlOriginalXboxPath;
                CWireEncoding * pwe = pfd->GetXboxSite()->GetCWireEncoding();

                hr = XboxGetCurrentDirectoryPidlWrap(pfstm->m_hintSession, TRUE, pwe, &pidlOriginalXboxPath);
                if (SUCCEEDED(hr))
                {
                    LPITEMIDLIST pidlWithVirtualRoot;

                    hr = XboxPidl_InsertVirtualRoot(pidlVirtualRoot, pidl, &pidlWithVirtualRoot);
                    if (SUCCEEDED(hr))
                    {
                        hr = XboxSetCurrentDirectoryPidlWrap(pfstm->m_hintSession, TRUE, pidlWithVirtualRoot, TRUE, TRUE);
                        if (SUCCEEDED(hr))
                        {
                            DWORD dwDownloadType = XboxPidl_GetDownloadType(pidl);

                            // PERF: I bet we would be faster if we delayed the open until
                            //       the first ::Read(), ::Write(), or ::CopyToStream() call.
                            Pidl_Set(&pfstm->m_pidlOriginalXboxPath, pidlOriginalXboxPath);
                            hr = XboxOpenFileWrap(pfstm->m_hintSession, TRUE, XboxPidl_GetLastItemWireName(pidl), pfstm->m_dwAccessType, dwDownloadType, 0, &pfstm->m_hint);
                        }

                        ILFree(pidlWithVirtualRoot);
                    }

                    ILFree(pidlOriginalXboxPath);
                }

                ILFree(pidlVirtualRoot);
            }
        }

        if (SUCCEEDED(hr))
            hr = pfstm->QueryInterface(IID_IStream, (LPVOID *) ppstream);

        pfstm->Release();
    }

    return hr;
}




/****************************************************\
    Constructor
\****************************************************/
CXboxStm::CXboxStm() : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_hint);
    ASSERT(!m_dwAccessType);
    ASSERT(!m_pfd);
    ASSERT(!m_hintSession);
    ASSERT(!m_pidl);
    ASSERT(!m_ppd);

    LEAK_ADDREF(LEAK_CXboxStm);
}


/****************************************************\
    Destructor
\****************************************************/
CXboxStm::~CXboxStm()
{
    if (m_hint)
    {
        InternetCloseHandle(m_hint);
    }

    // This COM object works like this:
    // 1. The constructor opens a handle to the server and
    //    Changes directory into the dir we are going to work in.
    // 2. The original dir is saved (m_pidlOriginalXboxPath) in order to be restored later
    //    because we cache the internet handle for perf and to keep our place on the server.
    // 3. The caller of this COM object can then copy data.
    // 4. We then Change directory to the original dir here before we close the internet handle.s
    if (m_pidlOriginalXboxPath && EVAL(m_hintSession))
    {
        EVAL(SUCCEEDED(XboxSetCurrentDirectoryPidlWrap(m_hintSession, TRUE, m_pidlOriginalXboxPath, TRUE, TRUE)));
        Pidl_Set(&m_pidlOriginalXboxPath, NULL);
    }

    if (m_hintSession)
        m_pfd->ReleaseHint(m_hintSession);

    ATOMICRELEASE(m_pfd);

    if (m_ppd && m_fClosePrgDlg)
        EVAL(SUCCEEDED(m_ppd->StopProgressDialog()));
    ATOMICRELEASE(m_ppd);

    ILFree(m_pidl);
    ILFree(m_pidlOriginalXboxPath);

    DllRelease();
    LEAK_DELREF(LEAK_CXboxStm);
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CXboxStm::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CXboxStm::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CXboxStm::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IStream))
    {
        *ppvObj = SAFECAST(this, IStream*);
    }
    else
    {
        TraceMsg(TF_XBOXQI, "CXboxStm::QueryInterface() failed.");
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxurl.h ===
/*****************************************************************************
 *
 *	xboxurl.h - Creating, encoding, and decoding URLs
 *
 *****************************************************************************/

#ifndef _XBOXURL_H
#define _XBOXURL_H


///////////////////////////////////////////////////////////////////////
// URL Path Functions (Obsolete?)
///////////////////////////////////////////////////////////////////////
// URL Path Wacking
HRESULT UrlPathRemoveSlashW(LPWSTR pszUrlPath);
HRESULT UrlPathRemoveSlashA(LPSTR pszUrlPath);
HRESULT UrlPathRemoveFrontSlashW(LPWSTR pszUrlPath);
HRESULT UrlPathRemoveFrontSlashA(LPSTR pszUrlPath);
HRESULT UrlPathToFilePathW(LPWSTR pszPath);
HRESULT UrlPathToFilePathA(LPSTR pszPath);
HRESULT FilePathToUrlPathW(LPWSTR pszPath);
HRESULT FilePathToUrlPathA(LPSTR pszPath);

#ifdef UNICODE
#define UrlPathRemoveSlash          UrlPathRemoveSlashW
#define UrlPathRemoveFrontSlash     UrlPathRemoveFrontSlashW
#else // UNICODE
#define UrlPathRemoveSlash          UrlPathRemoveSlashA
#define UrlPathRemoveFrontSlash     UrlPathRemoveFrontSlashA
#endif // UNICODE

HRESULT UrlGetDifference(LPCTSTR pszBaseUrl, LPCTSTR pszSuperUrl, LPTSTR pszPathDiff, DWORD cchSize);
HRESULT UrlPathAdd(LPTSTR pszUrl, DWORD cchUrlSize, LPCTSTR pszSegment);
HRESULT UrlPathToFilePath(LPCTSTR pszSourceUrlPath, LPTSTR pszDestFilePath, DWORD cchSize);
HRESULT UrlRemoveDownloadType(LPTSTR pszUrlPath, BOOL * pfTypeSpecified, BOOL * pfType);
HRESULT UrlReplaceUserPassword(LPTSTR pszUrlPath, DWORD cchSize, LPCTSTR pszUserName, LPCTSTR pszPassword);
HRESULT PidlReplaceUserPassword(LPCITEMIDLIST pidlIn, LPITEMIDLIST * ppidlOut, IMalloc * pm, LPCTSTR pszUserName, LPCTSTR pszPassword);
//HRESULT UrlPathAppendSlash(LPTSTR pszUrlPath);
//HRESULT UrlPathGetLastSegment(LPCTSTR pszUrl, LPTSTR pszSegment, DWORD cchSegSize);
//HRESULT UrlPathRemoveLastSegment(LPTSTR pszUrl);
//HRESULT UrlGetPath(LPCTSTR pszUrl, DWORD dwFlags, LPTSTR pszUrlPath, DWORD cchUrlPathSize);
//HRESULT UrlPathAppend(LPTSTR pszUrl, DWORD cchUrlSize, LPCTSTR pszSegment);
//HRESULT UrlReplaceUrlPath(LPTSTR pszUrl, DWORD cchSize, LPCTSTR pszUrlPath);
//HRESULT PidlReplaceUrlPath(LPCITEMIDLIST pidlIn, LPITEMIDLIST * ppidlOut, IMalloc * pm, LPCTSTR pszUrlPath);


///////////////////////////////////////////////////////////////////////
// Wire Path Functions (UTF-8 or DBCS/MBCS)
///////////////////////////////////////////////////////////////////////
HRESULT WirePathAppend(LPWIRESTR pwWirePath, DWORD cchUrlSize, LPCWIRESTR pwWireSegment);
HRESULT WirePathAppendSlash(LPWIRESTR pwWirePath, DWORD cchWirePathSize);
HRESULT WirePathGetFirstSegment(LPCWIRESTR pwXboxWirePath, LPWIRESTR wFirstItem, DWORD cchFirstItemSize, BOOL * pfWasFragSeparator, LPWIRESTR wRemaining, DWORD cchRemainingSize, BOOL * pfIsDir);


///////////////////////////////////////////////////////////////////////
// Display Path Functions (Unicode)
///////////////////////////////////////////////////////////////////////
HRESULT DisplayPathAppend(LPWSTR pwzDisplayPath, DWORD cchUrlSize, LPCWSTR pwzDisplaySegment);
HRESULT DisplayPathAppendSlash(LPWSTR pwzDisplayPath, DWORD cchSize);
HRESULT DisplayPathGetFirstSegment(LPCWSTR pwzFullPath, LPWSTR pwzFirstItem, DWORD cchFirstItemSize, BOOL * pfWasFragSeparator, LPWSTR pwzRemaining, DWORD cchRemainingSize, BOOL * pfIsDir);




// Other Functions
//HRESULT UrlCreateFromFindData(LPCTSTR pszBaseUrl, const LPWIN32_FIND_DATA pwfd, LPTSTR pszFullUrl, DWORD cchFullUrlSize);
HRESULT UrlCreate(LPCTSTR pszServer, LPCTSTR pszUser, LPCTSTR pszPassword, LPCTSTR pszUrlPath, LPCTSTR pszFragment, INTERNET_PORT ipPortNum, LPCTSTR pszDownloadType, LPTSTR pszUrl, DWORD cchSize);
HRESULT UrlCreateEx(LPCTSTR pszServer, LPCTSTR pszUser, LPCTSTR pszPassword, LPCTSTR pszUrlPath, LPCTSTR pszFragment, INTERNET_PORT ipPortNum, LPCTSTR pszDownloadType, LPTSTR pszUrl, DWORD cchSize, DWORD dwFlags);
HRESULT StrRetFromXboxPidl(LPSTRRET pStrRet, DWORD shgno, LPCITEMIDLIST pidl);
HRESULT PidlGenerateSiteLookupStr(LPCITEMIDLIST pidl, LPTSTR pszLookupStr, DWORD cchSize);
BOOL IsIPAddressStr(LPTSTR pszServer);
BOOL IsEmptyUrlPath(LPCTSTR pszUrlPath);

BOOL XboxCrackUrl(
    IN LPCTSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN OUT LPURL_COMPONENTS lpUrlComponents
    );

#endif // _XBOXURL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxresp.cpp ===
/*****************************************************************************
 *
 *    xboxresp.cpp - Parsing XBOX responses
 *
 *****************************************************************************/

#include "priv.h"


/*****************************************************************************\
    FUNCTION: FindEndOfStrOrLine

    DESCRIPTION:
        Find the end of the line ('\n') or the end of the string ('\0').
\*****************************************************************************/
LPWIRESTR FindEndOfStrOrLine(LPWIRESTR pszString)
{
    while (*pszString != '\0')
    {
        if (('\n' == pszString[0]))
        {
            while (('\n' == pszString[0]))
               pszString++;

            break;
        }
        pszString++;
    }

    return pszString;
}


/*****************************************************************************\
    FUNCTION: FindFirstMajorResponse

    DESCRIPTION:
\*****************************************************************************/
LPWIRESTR FindFirstMajorResponse(LPWIRESTR pszResponse)
{
    while ((pszResponse[0]) && ('-' != pszResponse[3]))
        pszResponse = FindEndOfStrOrLine(pszResponse);

    return pszResponse;
}


/*****************************************************************************\
    FUNCTION: GetNextResponseSection

    DESCRIPTION:
\*****************************************************************************/
LPWIRESTR GetNextResponseSection(LPWIRESTR pszCompleteResponse, LPWIRESTR * ppszResponseStart)
{
    LPWIRESTR pszNextResponse = NULL;

    // There may be a few minor responses.  Skip over them...
    pszCompleteResponse = FindFirstMajorResponse(pszCompleteResponse);

    // Were we never able to fine a major response?
    if (!pszCompleteResponse[0])
        return NULL;    // No, so return failure.

    // We are off to find the next major response.
    //    We should be looking at a response code.
    ASSERT('-' == pszCompleteResponse[3]);

    // Slop saves us here
    //    Extended response.  Copy until we see the match.
    //  As we copy, we also clean up the lines, removing
    //  the random punctuation servers prepend to continuations.
    //
    //  wu-Xbox prepends the extended response code to each line:
    //
    //  230-Welcome to Xbox.foo.com.  Please read the rules
    //  230-and regulations in the file RULES.
    //  230 Guest login ok, access restrictions apply.
    //
    //  Microsoft Internet Information Server prepends a space:
    //
    //  230-This is Xbox.microsoft.com.  See the index.txt file
    //   in the root directory for more information.
    //  230 Anonymous user logged in as anonymous.
    //
    WIRECHAR szResponseNumber[5];            // example: "230-"
    WIRECHAR szResponseEnd[5];                // example: "230 "
    StrCpyNA(szResponseNumber, pszCompleteResponse, ARRAYSIZE(szResponseNumber));
    ASSERT(4 == lstrlenA(szResponseNumber));
    StrCpyNA(szResponseEnd, szResponseNumber, ARRAYSIZE(szResponseEnd));
    szResponseEnd[3] = ' ';

    pszNextResponse = pszCompleteResponse;
    *ppszResponseStart = pszCompleteResponse;
    do
    {
        //  Skip past the header.
        if (!StrCmpNA(szResponseNumber, pszNextResponse, 4))
            pszNextResponse += 4;    // wu-Xbox
        else if ((pszNextResponse[0] == ' ') && (!StrCmpNA(szResponseNumber, &pszNextResponse[1], 4)))
            pszNextResponse += 5;    // Xbox.microsoft.com
        else if (pszNextResponse[0] == ' ')
            pszNextResponse++;    // IIS

        //  Skip the rest of the line.
        pszNextResponse = FindEndOfStrOrLine(pszNextResponse);
    }
    while (pszNextResponse[0] && StrCmpNA(pszNextResponse, szResponseEnd, 4));
        /* Now gobble the trailer */

    if ('\0' == pszNextResponse[0])
        pszNextResponse = NULL;     // We are at the end.

    return pszNextResponse;
}


/*****************************************************************************\
    FUNCTION: StripResponseHeaders

    DESCRIPTION:
\*****************************************************************************/
void StripResponseHeaders(LPWIRESTR pszResponse)
{
    //    We should be looking at a response code.
    if ((3 < lstrlenA(pszResponse)) && (pszResponse[3] == '-'))
    {
        LPWIRESTR pszIterator = pszResponse;
        WIRECHAR szResponseNumber[5];            // example: "230-"
        WIRECHAR szResponseEnd[5];                // example: "230 "
        BOOL fFirstPass = TRUE;

        StrCpyNA(szResponseNumber, pszResponse, ARRAYSIZE(szResponseNumber));
        ASSERT(4 == lstrlenA(szResponseNumber));
        StrCpyNA(szResponseEnd, szResponseNumber, ARRAYSIZE(szResponseEnd));
        szResponseEnd[3] = ' ';

        do
        {
            //  Skip past the header.
            if (!StrCmpNA(szResponseNumber, pszIterator, 4))
                RemoveCharsFromStringA(pszIterator, 3);    // wu-Xbox
            else if ((pszIterator[0] == ' ') && (!StrCmpNA(szResponseNumber, &pszIterator[1], 4)))
                RemoveCharsFromStringA(pszIterator, 4);    // Xbox.microsoft.com
            else if (pszIterator[0] == ' ')
                NULL;    // IIS

            if (fFirstPass)
            {
                fFirstPass = FALSE;
                RemoveCharsFromStringA(pszIterator, 1);    // IIS
            }
            else
                pszIterator[0] = ' ';    // Make that new line a space.

            //  Skip the rest of the line.
            pszIterator = FindEndOfStrOrLine(pszIterator);
        }
        while (pszIterator[0] && StrCmpNA(pszIterator, szResponseEnd, 4));
        
        RemoveCharsFromStringA(pszIterator, 4);         // Now gobble the trailer
    }
}


/*****************************************************************************\
    FUNCTION: GetMOTDMessage

    DESCRIPTION:
\*****************************************************************************/
LPWIRESTR GetMOTDMessage(LPWIRESTR pwResponse, DWORD cchResponse)
{
    LPWIRESTR pszMOTD = NULL;
    LPWIRESTR pszLast = &pwResponse[lstrlenA(pwResponse)];
    LPWIRESTR pszNext = pwResponse;
    LPWIRESTR pszEnd = NULL;

    while (pszNext = GetNextResponseSection(pszNext, &pszLast))
        pszEnd = pszNext;

    if (pszEnd)
        pszEnd[0] = '\0';   // Terminate it so we don't get the minor responses after our response.
    pszMOTD = (LPWIRESTR) GlobalAlloc(GPTR, (lstrlenA(pszLast) + 1) * sizeof(WIRECHAR));
    if (EVAL(pszMOTD))
    {
        StrCpyA(pszMOTD, pszLast);
        StripResponseHeaders(pszMOTD);
    }

    return pszMOTD;
}


/*****************************************************************************\
    FUNCTION: GetXboxResponse

    DESCRIPTION:
        Get the MOTD from the Response
\*****************************************************************************/
CXboxGlob * GetXboxResponse(CWireEncoding * pwe)
{
    CXboxGlob * pfg = NULL;
    DWORD cchResponse = 0;
    LPWIRESTR pwWireResponse;
    DWORD dwError;

    InternetGetLastResponseInfoWrap(TRUE, &dwError, NULL, &cchResponse);
    cchResponse++;                /* +1 for the terminating 0 */

    pwWireResponse = (LPWIRESTR)LocalAlloc(LPTR, cchResponse * sizeof(WIRECHAR));
    if (EVAL(pwWireResponse))
    {
        if (SUCCEEDED(InternetGetLastResponseInfoWrap(TRUE, &dwError, pwWireResponse, &cchResponse)))
        {
            LPWIRESTR pwMOTD = GetMOTDMessage(pwWireResponse, cchResponse);
            if (pwMOTD)
            {
                LPWSTR pwzDisplayMOTD;
                DWORD cchSize = (lstrlenA(pwMOTD) + 1);

                pwzDisplayMOTD = (LPWSTR)GlobalAlloc(LPTR, cchSize * sizeof(WCHAR));
                if (pwzDisplayMOTD)
                {
                    pwe->WireBytesToUnicode(NULL, pwMOTD, WIREENC_IMPROVE_ACCURACY, pwzDisplayMOTD, cchSize);

                    pfg = CXboxGlob_CreateStr(pwzDisplayMOTD);
                    if (!(EVAL(pfg)))
                        GlobalFree(pwzDisplayMOTD);    // Couldn't track message
                }

                GlobalFree(pwMOTD);
            }
        }
        LocalFree(pwWireResponse);
    }

    return pfg;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxwith.cpp ===
/*****************************************************************************
 *
 *	xboxwith.cpp - "With" procedures
 *
 *****************************************************************************/

#include "priv.h"

/*****************************************************************************
 *
 *	With_Hglob
 *
 *	Allocate a moveable HGLOBAL of the requested size, lock it, then call
 *	the callback.  On return, unlock it and get out.
 *
 *	Returns the allocated HGLOBAL, or 0.
 *
 *****************************************************************************/

HGLOBAL With_Hglob(UINT cb, HGLOBWITHPROC pfn, LPVOID pvRef)
{
    HGLOBAL hglob = GlobalAlloc(GHND, cb);
    if (hglob)
    {
	    LPVOID pv = GlobalLock(hglob);
	    if (pv)
        {
	        BOOL fRc = pfn(pv, pvRef);
	        GlobalUnlock(hglob);
	        if (!fRc)
            {
		        GlobalFree(hglob);
		        hglob = 0;
	        }
	    }
        else
        {
	        GlobalFree(hglob);
	        hglob = 0;
	    }
    }

    return hglob;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xboxurl.cpp ===
/*****************************************************************************
 *
 *    xboxurl.cpp - Creating, encoding, and decoding URLs
 *
 *****************************************************************************/

#include "priv.h"
#include "xboxurl.h"
//#include "tchar.h"


///////////////////////////////////////////////////////////////////////
// URL Path Functions (Obsolete?)
///////////////////////////////////////////////////////////////////////

/*****************************************************************************\
    FUNCTION: Xbox Crack URL, pre and post process URL so that xbox may replace
    ftp.
\*****************************************************************************/
BOOL XboxCrackUrl(
    IN LPCTSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN OUT LPURL_COMPONENTS lpUrlComponents
    )
{
    BOOL fResult;
    LPTSTR szFtp = (LPTSTR)(lpszUrl+1);
    szFtp[0]=TEXT('f');
    szFtp[1]=TEXT('t');
    szFtp[2]=TEXT('p');
    fResult = InternetCrackUrl(szFtp, dwUrlLength, dwFlags, lpUrlComponents);
    szFtp[-1]=TEXT('x');
    szFtp[0]=TEXT('b');
    szFtp[1]=TEXT('o');
    szFtp[2]=TEXT('x');
    return fResult;
}

/*****************************************************************************\
    FUNCTION: UrlGetPath

    DESCRIPTION:
        pszUrlPath will NOT include the fragment if there is any.
\*****************************************************************************/
HRESULT UrlGetDifference(LPCTSTR pszBaseUrl, LPCTSTR pszSuperUrl, LPTSTR pszPathDiff, DWORD cchSize)
{
    HRESULT hr = E_INVALIDARG;

    pszPathDiff[0] = TEXT('\0');
    if ((lstrlen(pszBaseUrl) <= lstrlen(pszSuperUrl)) &&
        !StrCmpN(pszBaseUrl, pszSuperUrl, lstrlen(pszBaseUrl) - 1))
    {
        LPTSTR pszDelta = (LPTSTR) &pszSuperUrl[lstrlen(pszBaseUrl)];

        if (TEXT('/') == pszDelta[0])
            pszDelta = CharNext(pszDelta);  // Skip past this.
        
        StrCpyN(pszPathDiff, pszDelta, cchSize);
        hr = S_OK;
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: UrlGetPath

    DESCRIPTION:
        pszUrlPath will NOT include the fragment if there is any.
\*****************************************************************************/
HRESULT UrlPathToFilePath(LPCTSTR pszSourceUrlPath, LPTSTR pszDestFilePath, DWORD cchSize)
{
    HRESULT hr = E_INVALIDARG;
    LPTSTR pszSeparator;

    // Is the source and destination the differnt?
    if (pszSourceUrlPath != pszDestFilePath)
    {
        // Yes, so we need to fill the dest before we start modifying it.
        StrCpyN(pszDestFilePath, pszSourceUrlPath, cchSize);
    }

    while (pszSeparator = StrChr(pszDestFilePath, TEXT('/')))
        pszSeparator[0] = TEXT('\\');

    // Some idiots use "Test%20File.txt" when "%20" is really in the file name.
//    ASSERT(!StrChr(pszDestFilePath, TEXT('%'))); // Assert it doesn't contain '%' or it probably has escaped url stuff.
    return hr;
}


/*****************************************************************************\
    FUNCTION: UrlGetPath

    DESCRIPTION:
        pszUrlPath will NOT include the fragment if there is any.
HRESULT UrlGetPath(LPCTSTR pszUrl, DWORD dwFlags, LPTSTR pszUrlPath, DWORD cchUrlPathSize)
{
    HRESULT hr = S_OK;
    URL_COMPONENTS urlComps = {sizeof(URL_COMPONENTS), NULL, 0, INTERNET_SCHEME_XBOX, NULL, 0,
                                0, NULL, 0, NULL, 0, pszUrlPath, cchUrlPathSize, NULL, 0};

    hr = XboxCrackUrl(pszUrl, 0, ICU_DECODE, &urlComps) ? S_OK : E_FAIL;
    return hr;
}
\*****************************************************************************/


/*****************************************************************************\
    FUNCTION: UrlPathAppendSlash

    DESCRIPTION:
HRESULT UrlPathAppendSlash(LPTSTR pszUrlPath)
{
    LPTSTR pszEndOfPath = &pszUrlPath[lstrlen(pszUrlPath) - 1];

    // Is it missing a backslash?
    if ((pszEndOfPath >= pszUrlPath) && TEXT('/') != pszEndOfPath[0])
        StrCat(pszEndOfPath, SZ_URL_SLASH);    // Yes, so add it.

    return S_OK;
}
\*****************************************************************************/


/*****************************************************************************\
    FUNCTION: UrlPathRemoveSlashW

    DESCRIPTION:
\*****************************************************************************/
HRESULT UrlPathRemoveSlashW(LPWSTR pszUrlPath)
{
    LPWSTR pszEndOfPath = &pszUrlPath[lstrlenW(pszUrlPath) - 1];

    // Is it missing a backslash?
    if ((pszEndOfPath >= pszUrlPath) && (CH_URL_URL_SLASHW == pszEndOfPath[0]))
        pszEndOfPath[0] = 0;    // Yes, so remove it.

    return S_OK;
}


/*****************************************************************************\
    FUNCTION: UrlPathRemoveSlashA

    DESCRIPTION:
\*****************************************************************************/
HRESULT UrlPathRemoveSlashA(LPSTR pszUrlPath)
{
    LPSTR pszEndOfPath = &pszUrlPath[lstrlenA(pszUrlPath) - 1];

    // Is it missing a backslash?
    if ((pszEndOfPath >= pszUrlPath) && (CH_URL_URL_SLASHA == pszEndOfPath[0]))
        pszEndOfPath[0] = 0;    // Yes, so remove it.

    return S_OK;
}


/*****************************************************************************\
    FUNCTION: UrlPathRemoveFrontSlashW

    DESCRIPTION:
\*****************************************************************************/
HRESULT UrlPathRemoveFrontSlashW(LPWSTR pszUrlPath)
{
    if (pszUrlPath && (CH_URL_URL_SLASHW == pszUrlPath[0]))
        return CharReplaceWithStrW(pszUrlPath, lstrlen(pszUrlPath), 1, SZ_EMPTYW);
    else
        return S_OK;
}


/*****************************************************************************\
    FUNCTION: UrlPathRemoveFrontSlashA

    DESCRIPTION:
\*****************************************************************************/
HRESULT UrlPathRemoveFrontSlashA(LPSTR pszUrlPath)
{
    if (pszUrlPath && (CH_URL_URL_SLASHA == pszUrlPath[0]))
        return CharReplaceWithStrA(pszUrlPath, lstrlenA(pszUrlPath), 1, SZ_EMPTYA);
    else
        return S_OK;
}


/*****************************************************************************\
    FUNCTION: UrlPathToFilePathW

    DESCRIPTION:
\*****************************************************************************/
HRESULT UrlPathToFilePathW(LPWSTR pszPath)
{
    while (pszPath = StrChrW(pszPath, CH_URL_URL_SLASHW))
        pszPath[0] = CH_URL_SLASHW;

    return S_OK;
}


/*****************************************************************************\
    FUNCTION: UrlPathToFilePathA

    DESCRIPTION:
\*****************************************************************************/
HRESULT UrlPathToFilePathA(LPSTR pszPath)
{
    while (pszPath = StrChrA(pszPath, CH_URL_URL_SLASHA))
        pszPath[0] = CH_URL_SLASHA;

    return S_OK;
}


/*****************************************************************************\
    FUNCTION: FilePathToUrlPathW

    DESCRIPTION:
\*****************************************************************************/
HRESULT FilePathToUrlPathW(LPWSTR pszPath)
{
    while (pszPath = StrChrW(pszPath, CH_URL_SLASHW))
        pszPath[0] = CH_URL_URL_SLASHW;

    return S_OK;
}


/*****************************************************************************\
    FUNCTION: FilePathToUrlPathA

    DESCRIPTION:
\*****************************************************************************/
HRESULT FilePathToUrlPathA(LPSTR pszPath)
{
    while (pszPath = StrChrA(pszPath, CH_URL_SLASHA))
        pszPath[0] = CH_URL_URL_SLASHA;

    return S_OK;
}


/*****************************************************************************\
    FUNCTION: UrlPathAdd

    DESCRIPTION:
        ...
\*****************************************************************************/
HRESULT UrlPathAdd(LPTSTR pszUrl, DWORD cchUrlSize, LPCTSTR pszSegment)
{
    // If the segment starts with a slash, skip it.
    if (TEXT('/') == pszSegment[0])
        pszSegment = CharNext(pszSegment);

    StrCatBuff(pszUrl, pszSegment, cchUrlSize);

    return S_OK;
}


/*****************************************************************************\
    FUNCTION: UrlPathAppend

    DESCRIPTION:
        ...
HRESULT UrlPathAppend(LPTSTR pszUrl, DWORD cchUrlSize, LPCTSTR pszSegment)
{
    if (!EVAL(pszSegment))
        return E_INVALIDARG;

    UrlPathAppendSlash(pszUrl); // Make sure the base url ends in a '/'. Note it may be "xbox://".

    return UrlPathAdd(pszUrl, cchUrlSize, pszSegment);
}
\*****************************************************************************/


/*****************************************************************************\
     StrRetFromXboxPidl
\*****************************************************************************/
HRESULT StrRetFromXboxPidl(LPSTRRET pStrRet, DWORD shgno, LPCITEMIDLIST pidl)
{
    HRESULT hr = S_OK;
    TCHAR szUrl[MAX_URL_STRING];

    szUrl[0] = 0;
    hr = UrlCreateFromPidl(pidl, shgno, szUrl, ARRAYSIZE(szUrl), ICU_ESCAPE | ICU_USERNAME, TRUE);
    if (SUCCEEDED(hr))
    {
        // Will it fit into STRRET.cStr?
        if (lstrlen(szUrl) < ARRAYSIZE(pStrRet->cStr))
        {
            // Yes, so there it goes...
            pStrRet->uType = STRRET_CSTR;
            SHTCharToAnsi(szUrl, pStrRet->cStr, ARRAYSIZE(pStrRet->cStr));
        }
        else
        {
            // No, so we will need to allocate it
            LPWSTR pwzAllocedStr = NULL;
            UINT cch = lstrlen(szUrl) + 1;

            pwzAllocedStr = (LPWSTR) SHAlloc(CbFromCchW(cch));
            pStrRet->uType = STRRET_WSTR;
            pStrRet->pOleStr = pwzAllocedStr;
            if (pwzAllocedStr)
                SHTCharToUnicode(szUrl, pwzAllocedStr, cch);
            else
                hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


/*****************************************************************************\
     FUNCTION: UrlCreateFromFindData
 
    DESCRIPTION:
        This function will use a base url and a path from Find Data to create
    a fully qualified URL.

    PARAMETERS:
        pszBaseUrl - This needs to be Escaped.
        pwfd->cFileName - This needs to be UNEscaped.
        pszFullUrl - This will to be Escaped.
HRESULT UrlCreateFromFindData(LPCTSTR pszBaseUrl, const LPWIN32_FIND_DATA pwfd, LPTSTR pszFullUrl, DWORD cchFullUrlSize)
{
    TCHAR szBaseUrl[MAX_URL_STRING];
    HRESULT hr = E_FAIL;
    TCHAR szLastItemEscaped[MAX_PATH];
    TCHAR szLastItem[MAX_PATH];
    LPCTSTR pszLastItem = pwfd->cFileName;

    StrCpyN(szBaseUrl, pszBaseUrl, ARRAYSIZE(szBaseUrl));
    UrlPathAppendSlash(szBaseUrl);

    if (CH_URL_URL_SLASH == pszLastItem[0])
        pszLastItem++;  // Don't let pwfd->cFileName replace the existing Url Path 

    StrCpyN(szLastItem, pszLastItem, ARRAYSIZE(szLastItem));
    if (CH_URL_URL_SLASH == szLastItem[lstrlen(szLastItem)-1])
        szLastItem[lstrlen(szLastItem)-1] = 0;  // Remove the last slash because it's escaped

    if (EVAL(SUCCEEDED(EscapeString(szLastItem, szLastItemEscaped, ARRAYSIZE(szLastItemEscaped)))))
    {
        DWORD cchSize = cchFullUrlSize;

        if (EVAL(InternetCombineUrl(szBaseUrl, szLastItemEscaped, pszFullUrl, &cchSize, ICU_NO_ENCODE)))
        {
            hr = S_OK;

            // Is it a directory?
            if (FILE_ATTRIBUTE_DIRECTORY & pwfd->dwFileAttributes)
            {
                // Yes, so make sure it has a trailing slash to disambiguate it from
                // a file.
                UrlPathAppendSlash(pszFullUrl);
            }
        }
    }

    return hr;
}
\*****************************************************************************/


/*****************************************************************************\
    FUNCTION: GetLastSegment

    DESCRIPTION:
\*****************************************************************************/
LPTSTR GetLastSegment(LPCTSTR pszUrl)
{
    LPTSTR pszLastSeg = (LPTSTR) pszUrl;
    LPTSTR pszNextPossibleSeg;

    while (pszNextPossibleSeg = StrChr(pszLastSeg, TEXT('/')))
    {
        if (TEXT('\0') != CharNext(pszNextPossibleSeg))
            pszLastSeg = CharNext(pszNextPossibleSeg);
        else
            break;  // We are done.
    }

    if (TEXT('/') == pszLastSeg[0])
        pszLastSeg = CharNext(pszLastSeg);

    return pszLastSeg;
}


/*****************************************************************************\
    FUNCTION: UrlPathGetLastSegment

    DESCRIPTION:
HRESULT UrlPathGetLastSegment(LPCTSTR pszUrl, LPTSTR pszSegment, DWORD cchSegSize)
{
    HRESULT hr = S_FALSE;
    TCHAR szTemp[MAX_URL_STRING];
    LPTSTR pszLastSeg;

    StrCpyN(szTemp, pszUrl, ARRAYSIZE(szTemp));
    UrlPathRemoveSlash(szTemp);
    pszLastSeg = GetLastSegment(szTemp);
    StrCpyN(pszSegment, pszLastSeg, cchSegSize);

    return hr;
}
\*****************************************************************************/


/*****************************************************************************\
    FUNCTION: UrlPathRemoveLastSegment

    DESCRIPTION:
HRESULT UrlPathRemoveLastSegment(LPTSTR pszUrl)
{
    HRESULT hr = S_FALSE;
    LPTSTR pszLastSeg;

    UrlPathRemoveSlash(pszUrl);
    pszLastSeg = GetLastSegment(pszUrl);

    pszLastSeg[0] = TEXT('\0');

    return hr;
}
\*****************************************************************************/


/*****************************************************************************\
    FUNCTION: UrlRemoveDownloadType

    DESCRIPTION:
\*****************************************************************************/
HRESULT UrlRemoveDownloadType(LPTSTR pszUrlPath, BOOL * pfTypeSpecified, BOOL * pfType)
{
    HRESULT hr = S_FALSE;   // Specified? (Not yet)
    LPTSTR pszDownloadType;

    if (pfTypeSpecified)
        *pfTypeSpecified = TRUE;

    // Did the user specify a download type. szPath="Dir1/Dir2/file.txt;type=a".
    // TODO: Search Recursively because each segment in the path can have a 
    //       type.
    //       Example Url="xbox://server/Dir1;type=a/Dir2;type=a/File.txt;type=b
    if (pszDownloadType = StrStrI(pszUrlPath, SZ_XBOX_URL_TYPE))
    {
        TCHAR chType;

        if (pfTypeSpecified)
            *pfTypeSpecified = TRUE;

        pszDownloadType[0] = TEXT('\0');   // Terminate pszUrlPath and remove this junk.
        chType = pszDownloadType[ARRAYSIZE(SZ_XBOX_URL_TYPE) - 1];

        if (pfType)
        {
            if ((TEXT('a') == chType) || (TEXT('A') == chType))
                *pfType = TRUE;
            else
                *pfType = TRUE;
        }

        hr = S_OK;
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: IsIPAddressStr

    DESCRIPTION:
    This function exists to detect an IP Address server name ("124.42.3.53") vs.
    a DNS domain name ("foobar", or "Xbox.foobar.com").  I current accept more than
    4 segments because of 6-bit IP address. (BUGBUG: Valid?)

    TODO: To be thurough, I should probably made sure each segment is
          smaller than 256.
\*****************************************************************************/
BOOL IsIPAddressStr(LPTSTR pszServer)
{
    BOOL fIsIPAddressStr = TRUE;
    LPTSTR pszCurrentChar = pszServer;
    int nDigits = 0;
    int nSegments = 1;

    while (fIsIPAddressStr && pszCurrentChar[0])
    {
        if (TEXT('.') == pszCurrentChar[0])
        {
            nSegments++;
            if ((0 == nDigits) || (4 < nDigits))
                fIsIPAddressStr = FALSE;    // it started with a '.', ie, ".xxxxx"

            nDigits = 0;
        }

        nDigits++;
        if (nDigits > 4)
            fIsIPAddressStr = FALSE;    // To many digits, ie "12345.xxxx"

        if (((TEXT('0') > pszCurrentChar[0]) || (TEXT('9') < pszCurrentChar[0])) &&
            (TEXT('.') != pszCurrentChar[0]))
        {
            fIsIPAddressStr = FALSE;    // it's outside of the 0-9 range.
        }

        pszCurrentChar++;   // Next character.
    }

    if (nSegments != 4)
        fIsIPAddressStr = FALSE;    // Needs to have at least 4 segments ("1.2.3.4", "1.2.3.4.5")

    return fIsIPAddressStr;
}


/*****************************************************************************\
    FUNCTION: PidlGenerateSiteLookupStr

    DESCRIPTION:
    Sample Input: "xbox://user:password@Xbox.server.com:69/Dir1/Dir2/File.txt"
    Sample Output: "xbox://user:password@Xbox.server.com:69/"

    This is used to keep track of unique servers for CXboxSite.  A CXboxSite needs
    to be created for each unique site, which includes different users that are
    logged onto the same site because of rooted directories.
\*****************************************************************************/
HRESULT PidlGenerateSiteLookupStr(LPCITEMIDLIST pidl, LPTSTR pszLookupStr, DWORD cchSize)
{
    HRESULT hr = E_FAIL;

    // Some strange clients pass in non-Server IDs, like comdlg.
    if (XboxID_IsServerItemID(pidl))
    {
        LPITEMIDLIST pidlServer = XboxCloneServerID(pidl);
        
        if (pidlServer)
        {
            hr = UrlCreateFromPidlW(pidlServer, SHGDN_FORPARSING, pszLookupStr, cchSize, (ICU_ESCAPE | ICU_USERNAME), FALSE);
            ILFree(pidlServer);
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}

/*
HRESULT PidlReplaceUrlPath(LPCITEMIDLIST pidlIn, LPITEMIDLIST * ppidlOut, IMalloc * pm, LPCTSTR pszUrlPath)
{
    HRESULT hr;
    TCHAR szUrl[MAX_URL_STRING];

    *ppidlOut = NULL;
    hr = UrlCreateFromPidl(pidlIn, SHGDN_FORPARSING, szUrl, ARRAYSIZE(szUrl), ICU_ESCAPE, FALSE);
    if (SUCCEEDED(hr))
    {
        hr = UrlReplaceUrlPath(szUrl, ARRAYSIZE(szUrl), pszUrlPath);
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidlWithPath;

            hr = CreateXboxPidlFromUrlEx(szUrl, NULL, &pidlWithPath, pm, FALSE, TRUE, XboxPidl_IsDirectory(pidlIn, TRUE));
            if (EVAL(SUCCEEDED(hr)))
            {
                LPITEMIDLIST pidlServer = ILClone(pidlIn);

                if (pidlServer)
                {
                    if (_ILNext(pidlServer))
                        _ILNext(pidlServer)->mkid.cb = 0;     // We need the first original itemID because it contains the password information.

                    *ppidlOut = ILCombine(pidlServer, _ILNext(pidlWithPath));  // Original ServerID, plus the itemIDs from the new dest.
                    ILFree(pidlServer);
                }

                ILFree(pidlWithPath);
            }
            
        }
    }

    return hr;
}

// BUGBUG: pszUrlPath won't work with fragments
HRESULT UrlReplaceUrlPath(LPTSTR pszUrl, DWORD cchSize, LPCTSTR pszUrlPath)
{
    HRESULT hr = E_FAIL;
    URL_COMPONENTS urlComps = {0};
    TCHAR szServer[INTERNET_MAX_HOST_NAME_LENGTH];
    TCHAR szUserName[INTERNET_MAX_USER_NAME_LENGTH];
    TCHAR szPassword[INTERNET_MAX_PASSWORD_LENGTH];
    TCHAR szExtraInfo[MAX_PATH];    // Includes Port Number and download type (ASCII, Binary, Detect)
    INTERNET_PORT ipPortNum = INTERNET_DEFAULT_XBOX_PORT;
    BOOL fResult;

    urlComps.dwStructSize = sizeof(urlComps);
    urlComps.lpszHostName = szServer;
    urlComps.dwHostNameLength = ARRAYSIZE(szServer);
    urlComps.lpszUrlPath = NULL;
    urlComps.dwUrlPathLength = 0;

    urlComps.lpszUserName = szUserName;
    urlComps.dwUserNameLength = ARRAYSIZE(szUserName);
    urlComps.lpszPassword = szPassword;
    urlComps.dwPasswordLength = ARRAYSIZE(szPassword);
    urlComps.lpszExtraInfo = szExtraInfo;
    urlComps.dwExtraInfoLength = ARRAYSIZE(szExtraInfo);

    fResult = XboxCrackUrl(pszUrl, 0, ICU_DECODE, &urlComps);
    if (fResult)
    {
        urlComps.dwStructSize = sizeof(urlComps);
        urlComps.lpszUrlPath = (LPTSTR)pszUrlPath;
        urlComps.dwUrlPathLength = (pszUrlPath ? lstrlen(pszUrlPath) : 0);

        fResult = InternetCreateUrl(&urlComps, (ICU_ESCAPE | ICU_USERNAME), pszUrl, &cchSize);
        if (fResult)
        {
            hr = S_OK;
        }
    }

    return hr;
}
*/


HRESULT PidlReplaceUserPassword(LPCITEMIDLIST pidlIn, LPITEMIDLIST * ppidlOut, IMalloc * pm, LPCTSTR pszUserName, LPCTSTR pszPassword)
{
    TCHAR szServer[INTERNET_MAX_HOST_NAME_LENGTH];
    TCHAR szUserName[INTERNET_MAX_USER_NAME_LENGTH];
    HRESULT hr = XboxPidl_GetServer(pidlIn, szServer, ARRAYSIZE(szServer));

    if (!pszUserName)   // May be NULL.
    {
        pszUserName = szUserName;
        EVAL(SUCCEEDED(XboxPidl_GetUserName(pidlIn, szUserName, ARRAYSIZE(szUserName))));
    }

    *ppidlOut = NULL;
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidlServer;

        hr = XboxServerID_Create(szServer, pszUserName, pszPassword, XboxServerID_GetTypeID(pidlIn), XboxServerID_GetPortNum(pidlIn), &pidlServer, pm, TRUE);
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidlXboxPath = _ILNext(pidlIn);

            *ppidlOut = ILCombine(pidlServer, pidlXboxPath);
            ILFree(pidlServer);
        }
    }

    return hr;
}


HRESULT UrlReplaceUserPassword(LPTSTR pszUrlPath, DWORD cchSize, LPCTSTR pszUserName, LPCTSTR pszPassword)
{
    HRESULT hr = E_FAIL;
    URL_COMPONENTS urlComps = {0};
    TCHAR szServer[INTERNET_MAX_HOST_NAME_LENGTH];
    TCHAR szUrlPath[MAX_URL_STRING];
    TCHAR szUserName[INTERNET_MAX_USER_NAME_LENGTH];
    TCHAR szPassword[INTERNET_MAX_PASSWORD_LENGTH];
    TCHAR szExtraInfo[MAX_PATH];    // Includes Port Number and download type (ASCII, Binary, Detect)
    BOOL fResult;

    urlComps.dwStructSize = sizeof(urlComps);
    urlComps.lpszHostName = szServer;
    urlComps.dwHostNameLength = ARRAYSIZE(szServer);
    urlComps.lpszUrlPath = szUrlPath;
    urlComps.dwUrlPathLength = ARRAYSIZE(szUrlPath);
    urlComps.lpszExtraInfo = szExtraInfo;
    urlComps.dwExtraInfoLength = ARRAYSIZE(szExtraInfo);

    urlComps.lpszUserName = szUserName;
    urlComps.dwUserNameLength = ARRAYSIZE(szUserName);
    urlComps.lpszPassword = szPassword;
    urlComps.dwPasswordLength = ARRAYSIZE(szPassword);

    fResult = XboxCrackUrl(pszUrlPath, 0, ICU_DECODE, &urlComps);
    if (fResult)
    {
        urlComps.dwStructSize = sizeof(urlComps);
        urlComps.lpszHostName = szServer;

        urlComps.lpszUserName = (LPTSTR)(pszUserName ? pszUserName : szUserName);
        urlComps.dwUserNameLength = (pszUserName ? lstrlen(pszUserName) : lstrlen(szUserName));
        urlComps.lpszPassword = (LPTSTR)pszPassword;    // It may be valid for caller to pass NULL
        urlComps.dwPasswordLength = (pszPassword ? lstrlen(pszPassword) : 0);
        urlComps.lpszExtraInfo = szExtraInfo;
        urlComps.dwExtraInfoLength = ARRAYSIZE(szExtraInfo);

        fResult = InternetCreateUrl(&urlComps, (ICU_ESCAPE | ICU_USERNAME), pszUrlPath, &cchSize);
        if (fResult)
        {
            hr = S_OK;
        }
    }

    return hr;
}


// InternetCreateUrlW() will write into pszUrl but won't terminate the string.
// This is hard to detect because half the time the place where the terminator should
// go may coincidentally contain a terminator.  This code forces the bug to happen.
#define TEST_FOR_INTERNETCREATEURL_BUG      1
#define INTERNETCREATEURL_BUG_WORKAROUND     1

HRESULT UrlCreateEx(LPCTSTR pszServer, LPCTSTR pszUser, LPCTSTR pszPassword, LPCTSTR pszUrlPath, LPCTSTR pszFragment, INTERNET_PORT ipPortNum, LPCTSTR pszDownloadType, LPTSTR pszUrl, DWORD cchSize, DWORD dwFlags)
{
    HRESULT hr = E_FAIL;
    DWORD cchSizeCopy = cchSize;

#if DEBUG && TEST_FOR_INTERNETCREATEURL_BUG
    LPTSTR pszDebugStr = pszUrl;
    for (DWORD dwIndex = (cchSize - 2); dwIndex; dwIndex--)
    {
#ifndef INTERNETCREATEURL_BUG_WORKAROUND
        pszDebugStr[0] = -1;         // This will force a buffer w/o terminators.
#else // INTERNETCREATEURL_BUG_WORKAROUND
        pszDebugStr[0] = 0;         // This will work around the bug.
#endif // INTERNETCREATEURL_BUG_WORKAROUND
        pszDebugStr++;
    }
#endif // DEBUG && TEST_FOR_INTERNETCREATEURL_BUG

    URL_COMPONENTS urlComp = {sizeof(URL_COMPONENTS), NULL, 0, INTERNET_SCHEME_FTP, (LPTSTR) pszServer, 0,
                              ipPortNum, (LPTSTR) NULL_FOR_EMPTYSTR(pszUser), 0, (LPTSTR) NULL_FOR_EMPTYSTR(pszPassword), 0,
                              (LPTSTR) pszUrlPath, 0, (LPTSTR) NULL, 0};
    
    if (EVAL(InternetCreateUrl(&urlComp, dwFlags | ICU_USERNAME, pszUrl, &cchSizeCopy)))
    {
        hr = S_OK;
        if (pszFragment)
            StrCatBuff(pszUrl, pszFragment, cchSize);
    }

#if DEBUG && TEST_FOR_INTERNETCREATEURL_BUG
#ifdef INTERNETCREATEURL_BUG_WORKAROUND
    // Make sure we hit a terminator and not a -1, which should never happen in URL strings.
    for (pszDebugStr = pszUrl; pszDebugStr[0]; pszDebugStr++)
        ASSERT(-1 != pszDebugStr[0]);
#endif // INTERNETCREATEURL_BUG_WORKAROUND
#endif // DEBUG && TEST_FOR_INTERNETCREATEURL_BUG

    return hr;
}


HRESULT UrlCreate(LPCTSTR pszServer, LPCTSTR pszUser, LPCTSTR pszPassword, LPCTSTR pszUrlPath, LPCTSTR pszFragment, INTERNET_PORT ipPortNum, LPCTSTR pszDownloadType, LPTSTR pszUrl, DWORD cchSize)
{
    return UrlCreateEx(pszServer, pszUser, pszPassword, pszUrlPath, pszFragment, ipPortNum, pszDownloadType, pszUrl, cchSize, ICU_ESCAPE);
}


BOOL IsEmptyUrlPath(LPCTSTR pszUrlPath)
{
    BOOL fResult = FALSE;

    if (!pszUrlPath ||
        !pszUrlPath[0] ||
        (((TEXT('/') == pszUrlPath[0]) && (!pszUrlPath[1]))))
    {
        fResult = TRUE;
    }

    return fResult;
}



///////////////////////////////////////////////////////////////////////
// Wire Path Functions (UTF-8 or DBCS/MBCS)
///////////////////////////////////////////////////////////////////////
/*****************************************************************************\
    FUNCTION: WirePathAdd

    DESCRIPTION:
        ...
\*****************************************************************************/
HRESULT WirePathAdd(LPWIRESTR pwWirePath, DWORD cchUrlSize, LPCWIRESTR pwWireSegment)
{
    // If the segment starts with a slash, skip it.
    if ('/' == pwWireSegment[0])
        pwWireSegment = CharNextA(pwWireSegment);

    StrCatBuffA(pwWirePath, pwWireSegment, cchUrlSize);
    return S_OK;
}


/*****************************************************************************\
    FUNCTION: WirePathAppendSlash

    DESCRIPTION:
\*****************************************************************************/
HRESULT WirePathAppendSlash(LPWIRESTR pwWirePath, DWORD cchWirePathSize)
{
    HRESULT hr = E_FAIL;
    DWORD cchSize = lstrlenA(pwWirePath);

    // Is there enough room?
    if (cchSize < (cchWirePathSize - 1))
    {
        LPWIRESTR pwEndOfPath = &pwWirePath[cchSize - 1];

        // Is it missing a backslash?
        if ((pwEndOfPath >= pwWirePath) && '/' != pwEndOfPath[0])
            StrCatA(pwEndOfPath, SZ_URL_SLASHA);    // Yes, so add it.

        hr = S_OK;
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: WirePathAppend

    DESCRIPTION:
        ...
\*****************************************************************************/
HRESULT WirePathAppend(LPWIRESTR pwWirePath, DWORD cchUrlSize, LPCWIRESTR pwWireSegment)
{
    if (!EVAL(pwWireSegment))
        return E_INVALIDARG;

    WirePathAppendSlash(pwWirePath, cchUrlSize); // Make sure the base url ends in a '/'. Note it may be "xbox://".
    return WirePathAdd(pwWirePath, cchUrlSize, pwWireSegment);
}


/*****************************************************************************\
    FUNCTION: UrlGetFirstPathSegment

    PARAMETERS:
    [IN]  pszFullPath - "Dir1\Dir2\Dir3"
    [OUT] szFirstItem - "Dir1"              [OPTIONAL]
    [OUT] szRemaining - "Dir2\Dir3"         [OPTIONAL]
\*****************************************************************************/
HRESULT WirePathGetFirstSegment(LPCWIRESTR pwXboxWirePath, LPWIRESTR wFirstItem, DWORD cchFirstItemSize, BOOL * pfWasFragSeparator, LPWIRESTR wRemaining, DWORD cchRemainingSize, BOOL * pfIsDir)
{
    HRESULT hr = S_OK;
    LPCWIRESTR pwSegEnding = StrChrA(pwXboxWirePath, CH_URL_URL_SLASH);

    if (pfIsDir)
        *pfIsDir = FALSE;

    ASSERT((CH_URL_URL_SLASHA != pwXboxWirePath[0]));    // You will probably not get what you want.
    if (pwSegEnding)
    {
        if (wFirstItem)
        {
            DWORD cchSize = (DWORD) (pwSegEnding - pwXboxWirePath + 1);
            StrCpyNA(wFirstItem, pwXboxWirePath, (cchSize <= cchFirstItemSize) ? cchSize : cchFirstItemSize);
        }

        if (pfIsDir && (CH_URL_URL_SLASHA == pwSegEnding[0]))
            *pfIsDir = TRUE;    // Tell them that it is a directory.

        if (wRemaining)
            StrCpyNA(wRemaining, CharNextA(pwSegEnding), cchRemainingSize);

        if (0 == pwSegEnding[1])
            hr = S_FALSE;   // End of the line.
    }
    else
    {
        if (wFirstItem)
            StrCpyNA(wFirstItem, pwXboxWirePath, cchFirstItemSize);    // pszFullPath contains only one segment 

        if (wRemaining)
            wRemaining[0] = 0;
        hr = S_FALSE;       // Indicate that there aren't any more directories left.
    }

    return hr;
}




///////////////////////////////////////////////////////////////////////
// Display Path Functions (Unicode)
///////////////////////////////////////////////////////////////////////
/*****************************************************************************\
    FUNCTION: DisplayPathAdd

    DESCRIPTION:
        ...
\*****************************************************************************/
HRESULT DisplayPathAdd(LPWSTR pwzUrl, DWORD cchUrlSize, LPCWSTR pwzSegment)
{
    // If the segment starts with a slash, skip it.
    if (L'/' == pwzSegment[0])
        pwzSegment = CharNext(pwzSegment);

    StrCatBuffW(pwzUrl, pwzSegment, cchUrlSize);
    return S_OK;
}


/*****************************************************************************\
    FUNCTION: DisplayPathAppendSlash

    DESCRIPTION:
\*****************************************************************************/
HRESULT DisplayPathAppendSlash(LPWSTR pwzDisplayPath, DWORD cchSize)
{
    DWORD cchCurrentSize = lstrlenW(pwzDisplayPath);
    HRESULT hr = CO_E_PATHTOOLONG;

    if (cchCurrentSize < (cchSize - 2))
    {
        LPWSTR pwzEndOfPath = &pwzDisplayPath[cchCurrentSize - 1];

        // Is it missing a backslash?
        if ((pwzEndOfPath >= pwzDisplayPath) && TEXT('/') != pwzEndOfPath[0])
            StrCatBuff(pwzEndOfPath, SZ_URL_SLASH, (cchCurrentSize + 2));    // Yes, so add it.

        hr = S_OK;
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: DisplayPathAppend

    DESCRIPTION:
        ...
\*****************************************************************************/
HRESULT DisplayPathAppend(LPWSTR pwzDisplayPath, DWORD cchUrlSize, LPCWSTR pwzDisplaySegment)
{
    if (!EVAL(pwzDisplaySegment))
        return E_INVALIDARG;

    DisplayPathAppendSlash(pwzDisplayPath, cchUrlSize); // Make sure the base url ends in a '/'. Note it may be "xbox://".
    return DisplayPathAdd(pwzDisplayPath, cchUrlSize, pwzDisplaySegment);
}


/*****************************************************************************\
    FUNCTION: DisplayPathGetFirstSegment

    PARAMETERS:
    [IN]  pszFullPath - "Dir1\Dir2\Dir3"
    [OUT] szFirstItem - "Dir1"              [OPTIONAL]
    [OUT] szRemaining - "Dir2\Dir3"         [OPTIONAL]
\*****************************************************************************/
HRESULT DisplayPathGetFirstSegment(LPCWSTR pwzFullPath, LPWSTR pwzFirstItem, DWORD cchFirstItemSize, BOOL * pfWasFragSeparator, LPWSTR pwzRemaining, DWORD cchRemainingSize, BOOL * pfIsDir)
{
    HRESULT hr = S_OK;
    LPWSTR pwzSegEnding = StrChrW(pwzFullPath, CH_URL_URL_SLASH);

    if (pfIsDir)
        *pfIsDir = FALSE;

    // This will happen if the user enters an incorrect URL, like "xbox://wired//"
    //  ASSERT((CH_URL_URL_SLASHW != pwzFullPath[0]));    // You will probably not get what you want.
    if (pwzSegEnding)
    {
        if (pwzFirstItem)
        {
            DWORD cchSize = (DWORD) (pwzSegEnding - pwzFullPath + 1);
            StrCpyNW(pwzFirstItem, pwzFullPath, (cchSize <= cchFirstItemSize) ? cchSize : cchFirstItemSize);
        }

        if (pfIsDir && (CH_URL_URL_SLASHW == pwzSegEnding[0]))
            *pfIsDir = TRUE;    // Tell them that it is a directory.

        if (pwzRemaining)
            StrCpyNW(pwzRemaining, CharNextW(pwzSegEnding), cchRemainingSize);

        if (0 == pwzSegEnding[1])
            hr = S_FALSE;   // End of the line.
    }
    else
    {
        if (pwzFirstItem)
            StrCpyNW(pwzFirstItem, pwzFullPath, cchFirstItemSize);    // pszFullPath contains only one segment 

        if (pwzRemaining)
            pwzRemaining[0] = 0;
        hr = S_FALSE;       // Indicate that there aren't any more directories left.
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\asuggest.h ===
#ifndef _ASUGGEST_H_
#define _ASUGGEST_H_

// Private interface used between shdocvw and browseui. Currently needed
//  only for Intelliforms

// IID_IAutoCompleteDropDown in shguidp.h

#undef  INTERFACE
#define INTERFACE   IAutoCompleteDropDown

DECLARE_INTERFACE_(IAutoCompleteDropDown, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IAutoCompleteDropDown methods ***
    STDMETHOD(GetDropDownStatus)(THIS_ DWORD *pdwFlags, LPWSTR *ppwszString) PURE;
    STDMETHOD(ResetEnumerator)(THIS) PURE;
};

//
//  Flags for IAutoCompleteDropDown::GetDropDownStatus
//
#define ACDD_VISIBLE        0x0001

#endif // _ASUGGEST_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\apwizhlp.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1994
*
*  TITLE:	APWIZHLP.H
*
*  VERSION:	1.0
*
*  AUTHOR:	RAL
*
*  DATE:	11/8/94
*
*  Help IDs for Add/Remove Programs.
*  NOTE:  These IDs are reserved in the HELP.H file.  The IDs refer to entries
*	  in the main windows help file.
*
*******************************************************************************/


#ifndef _INC_APWIZHLP
#define _INC_APWIZHLP

//  Net install page
#define IDH_APPWIZ_NETINSTALL_INSTRUCT	5600
#define IDH_APPWIZ_NETINSTALL_LIST	5601
#define IDH_APPWIZ_NETINTALLL_BUTTON	5602

// Install/Uninstall Page
#define IDH_APPWIZ_DISKINSTALL_INSTRUCT 5610
#define IDH_APPWIZ_DISKINTALLL_BUTTON	5611
#define IDH_APPWIZ_UNINSTALL_INSTRUCT	5612
#define IDH_APPWIZ_UNINSTALL_LIST	5613
#define IDH_APPWIZ_UNINSTALL_BUTTON	5614

// Windows Setup page
#define IDH_APPWIZ_WINSETUP_INSTRUCT	5620
#define IDH_APPWIZ_WINSETUP_LIST	5621

// Startup Disk page
#define IDH_APPWIZ_STARTDISK_INSTRUCT	5630
#define IDH_APPWIZ_STARTDISK_BUTTON	5631

#endif // _INC_APWIZHLP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xbwebvw.h ===
/*****************************************************************************\
    FILE: xbwebvw.h

    DESCRIPTION:
        This file exists so WebView can automate the Xbox Shell Extension and get
    information like the MessageOfTheDay.
\*****************************************************************************/

#ifndef _XBOXWEBVIEW_H_
#define _XBOXWEBVIEW_H_

#include "dspsprt.h"
#include "cowsite.h"
#include "cobjsafe.h"
#include "xbnmspc.h"

HRESULT CXboxWebView_Create(REFIID riid, void **ppvObj);

/*****************************************************************************\
    CLASS: CXboxWebView

    DESCRIPTION:
        This file exists so WebView can automate the Xbox Shell Extension and get
    information like the MessageOfTheDay.
\*****************************************************************************/

class CXboxWebView 
                :  public CImpIDispatch
                ,  public CObjectWithSite
                ,  public CObjectSafety
                ,  public IXboxWebView
{    

public:
    // *** IUnknown methods ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IDispatch methods ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo * * pptinfo);
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR * * rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid);
    virtual STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr);

    // *** IXboxWebView ***
    virtual STDMETHODIMP get_Server(BSTR * pbstr);
    virtual STDMETHODIMP get_Directory(BSTR * pbstr);
    virtual STDMETHODIMP get_UserName(BSTR * pbstr);
    virtual STDMETHODIMP get_PasswordLength(long * plLength);
    virtual STDMETHODIMP get_EmailAddress(BSTR * pbstr);
    virtual STDMETHODIMP put_EmailAddress(BSTR bstr);
    virtual STDMETHODIMP get_CurrentLoginAnonymous(VARIANT_BOOL * pfAnonymousLogin);
    virtual STDMETHODIMP get_MessageOfTheDay(BSTR * pbstr);
    virtual STDMETHODIMP LoginAnonymously(void);
    virtual STDMETHODIMP LoginWithPassword(BSTR bUserName, BSTR bPassword);
    virtual STDMETHODIMP LoginWithoutPassword(BSTR bUserName);
    virtual STDMETHODIMP InvokeHelp(void);

public:
    // Friend Functions
    friend HRESULT CXboxWebView_Create(REFIID riid, void **ppvObj);

private:
    // Private Member Variables
    int                     m_cRef;

    // Private Member Functions
    CXboxWebView();
    ~CXboxWebView();

    HRESULT _GetIXboxWebView(IXboxWebView ** ppfwb);
};


#endif // _XBOXWEBVIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\brfcasep.h ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: brfcasep.h
//
//  Internal header shared between SHELL232 and SYNCUI
//
// History:
//  01-27-94 ScottH     Copied from brfcase.h
//
//---------------------------------------------------------------------------

#ifndef _BRFCASEP_H_
#define _BRFCASEP_H_

//===========================================================================
//
// IBriefcaseStg Interface
//
//  This is a private interface for use between the shell and the briefcase.
//
//  This interface is used by the Shell's IShellFolder implementation
// when it is bound to a folder that is (in) a briefcase.  The IShellView
// of the particular folder binds to this interface to open the briefcase
// database storage and optionally make modifications.  File-objects that
// are added to a folder in a briefcase are not added to the storage
// database until IBriefcaseStg::AddObject is called.  Keep in mind the
// difference between IBriefcaseStg and IShellFolder.  IBriefcaseStg
// simply provides access to the briefcase storage database--the file-system
// objects are only affected upon subsequent reconciliation using
// IBriefcaseStg::UpdateObject, unless otherwise noted.
//
//
// [Member functions]
//
//
// IBriefcaseStg::Initialize(pszFolder, hwndOwner)
//
//   Initializes the interface by specifying the folder for this storage
//   instance.  If the folder does not exist somewhere in a briefcase
//   storage hierarchy, then a briefcase database is created for this
//   folder.
//
// IBriefcaseStg::AddObject(pdtobj, pszFolderEx, uFlags, hwndOwner)
//
//   Adds a file-object(s) to the briefcase storage.  This function also
//   performs an update of the specific files to immediately make them
//   up-to-date.
//
//   Typically pdtobj refers to a file-object(s) outside the
//   briefcase.  Calling this function implies adding the object(s) to
//   the briefcase storage database in the folder that was specified by
//   IBriefcaseStg::Initialize().  This rule holds unless pszFolderEx is
//   non-NULL, in which case pdtobj is sync-associated to pszFolderEx
//   instead.
//
//   AddObject() returns NOERROR if the object(s) were added.  S_FALSE
//   is returned if the caller should handle the action (eg, moving
//   files from folder-to-folder within the briefcase).
//
// IBriefcaseStg::ReleaseObject(pdtobj, hwndOwner)
//
//   Releases a file-object(s) from the briefcase storage database.  This
//   does not delete the file from the file-system.
//
// IBriefcaseStg::UpdateObject(pdtobj, hwndOwner)
//
//   Performs a file-synchronization update to pdtobj.  If pdtobj refers to
//   the root of a briefcase storage hierarchy, the entire storage is updated.
//
// IBriefcaseStg::UpdateOnEvent(uEvent, hwndOwner)
//
//   Performs a complete update of the briefcase storage based on the
//   indicated event.  The event ordinals may be:
//
//      UOE_CONFIGCHANGED       Indicates a PnP DBT_CONFIGCHANGED message wants
//                              to be processed.  This occurs when a machine
//                              hot-docks.
//
//      UOE_QUERYCHANGECONFIG   Indicates a PnP DBT_QUERYCHANGECONFIG message
//                              wants to be processed.  This occurs when a
//                              machine is about to hot-undock.
//
// IBriefcaseStg::GetExtraInfo(pszName, uInfo, wParam, lParam)
//
//   Gets some specified extra info from the briefcase storage.  The
//   info is determined by uInfo, which is one of GEI_* values.
//
// IBriefcaseStg::Notify(pszPath, lEvent, puFlags, hwndOwner)
//
//   Sends a notify event to the briefcase storage, so it can mark
//   cached items stale.  If lEvent is NOE_RENAME, pszPath must be a double
//   null-terminated string, where the first is the old pathname, and the
//   second is the new pathname.  *puFlags is filled with flags pertaining
//   to what the member function did.  NF_REDRAWWINDOW means the window
//   needs to be redrawn.  NF_ITEMMARKED means the cached item in the
//   briefcase storage associated with pszPath was marked stale.
//
// IBriefcaseStg::GetRootOf(pszBuffer, cbBuffer)
//
//   Queries the briefcase storage for the root of the briefcase storage
//   hierarchy.
//
// IBriefcaseStg::FindFirst(pszBuffer, cbBuffer)
//
//   Finds the root of the first briefcase storage on the system.  The
//   buffer is filled with the fully qualified pathname.  This function
//   returns S_OK if a briefcase was found.  S_FALSE is returned to end
//   enumeration.
//
// IBriefcaseStg::FindNext(pszBuffer, cbBuffer)
//
//   Finds the root of the next briefcase storage on the system.  The
//   buffer is filled with the fully qualified pathname.  This function
//   returns S_OK if a briefcase was found.  S_FALSE is returned to end
//   enumeration.
//
//
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IBriefcaseStg

DECLARE_INTERFACE_(IBriefcaseStg, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IBriefcaseStg methods ***
    STDMETHOD(Initialize) (THIS_ LPCTSTR pszFolder, HWND hwnd) PURE;
    STDMETHOD(AddObject) (THIS_ LPDATAOBJECT lpdobj, LPCTSTR pszFolderEx, UINT uFlags, HWND hwnd) PURE;
    STDMETHOD(ReleaseObject) (THIS_ LPDATAOBJECT lpdobj, HWND hwnd) PURE;
    STDMETHOD(UpdateObject) (THIS_ LPDATAOBJECT lpdobj, HWND hwnd) PURE;
    STDMETHOD(UpdateOnEvent) (THIS_ UINT uEvent, HWND hwnd) PURE;
    STDMETHOD(GetExtraInfo) (THIS_ LPCTSTR pszName, UINT uInfo, WPARAM wParam, LPARAM lParam) PURE;
    STDMETHOD(Notify) (THIS_ LPCTSTR pszPath, LONG lEvent, UINT * puFlags, HWND hwndOwner) PURE;
    STDMETHOD(FindFirst) (THIS_ LPTSTR pszPath, int cchMax) PURE;
    STDMETHOD(FindNext) (THIS_ LPTSTR pszPath, int cchMax) PURE;
};

// Events for UpdateOnEvent member function
#define UOE_CONFIGCHANGED       1
#define UOE_QUERYCHANGECONFIG   2

// Flags for AddObject
#define AOF_DEFAULT             0x0000
#define AOF_UPDATEONREPLACE     0x0001
#define AOF_FILTERPROMPT        0x0002

// Notify events
#define NOE_RENAME              1L
#define NOE_RENAMEFOLDER        2L
#define NOE_CREATE              3L
#define NOE_CREATEFOLDER        4L
#define NOE_DELETE              5L
#define NOE_DELETEFOLDER        6L
#define NOE_DIRTY               7L
#define NOE_DIRTYFOLDER         8L
#define NOE_DIRTYALL            9L

// Flags that are returned by Notify member function
#define NF_REDRAWWINDOW     0x0001
#define NF_ITEMMARKED       0x0002

// Flags for GetExtraInfo                wParam        lParam
#define GEI_ROOT            1       //   cchBuf         pszBuf
#define GEI_ORIGIN          2       //   cchBuf         pszBuf
#define GEI_STATUS          3       //   cchBuf         pszBuf
#define GEI_DELAYHANDLE     4       //     --           phandle
#define GEI_DATABASENAME    5       //   cchBuf         pszBuf

typedef IBriefcaseStg FAR*   LPBRIEFCASESTG;

// Special briefcase object struct
//
typedef struct _BriefObj
    {
    UINT    cbSize;             // size of allocated struct
    UINT    ibFileList;         // offset of file list in struct
    UINT    ibBriefPath;        // offset of briefcase path in struct
    UINT    cItems;             // count of file-system objects
    UINT    cbListSize;         // size of file list
    TCHAR   data[1];            // data
    } BriefObj, * PBRIEFOBJ;

// Helper macros for briefcase object struct
#define BOBriefcasePath(pbo)    ((LPTSTR)((LPBYTE)(pbo) + (pbo)->ibBriefPath))
#define BOFileList(pbo)         ((LPTSTR)((LPBYTE)(pbo) + (pbo)->ibFileList))
#define BOFileCount(pbo)        ((pbo)->cItems)
#define BOFileListSize(pbo)     ((pbo)->cbListSize)

// Clipboard format for above struct
//
#define CFSTR_BRIEFOBJECT  TEXT("Briefcase File Object")

#endif // _BRFCASEP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\browseui.h ===
// #include <shlobj.h> or <shellapi.h> before this to get the right
// BROWSEUIAPI macro definitions.
#ifdef BROWSEUIAPI

#ifndef _BROWSEUI_H_
#define _BROWSEUI_H_

#include <iethread.h>

BROWSEUIAPI SHOpenNewFrame(LPITEMIDLIST pidlNew, ITravelLog *ptl, DWORD dwBrowserIndex, UINT uFlags);

BROWSEUIAPI_(BOOL) SHOpenFolderWindow(IETHREADPARAM* pieiIn);
BROWSEUIAPI_(BOOL) SHParseIECommandLine(LPCWSTR * ppszCmdLine, IETHREADPARAM * piei);
BROWSEUIAPI_(IETHREADPARAM*) SHCreateIETHREADPARAM(LPCWSTR pszCmdLineIn, int nCmdShowIn, ITravelLog *ptlIn, IEFreeThreadedHandShake* piehsIn);
BROWSEUIAPI_(IETHREADPARAM*) SHCloneIETHREADPARAM(IETHREADPARAM* pieiIn);
BROWSEUIAPI_(void) SHDestroyIETHREADPARAM(IETHREADPARAM* piei);
BROWSEUIAPI_(BOOL) SHCreateFromDesktop(PNEWFOLDERINFO pfi);

// Exported from browseui, but also in shell\lib\brutil.cpp -- why?
STDAPI SHPidlFromDataObject(IDataObject *pdtobj, LPITEMIDLIST *ppidl, LPWSTR pszDisplayNameW, DWORD cchDisplayName);

//
// The following four apis are exported for use by the channel oc (shdocvw).
// If the channel oc is moved into browseui these protoypes can be removed.
//
BROWSEUIAPI_(LPITEMIDLIST) Channel_GetFolderPidl(void);
BROWSEUIAPI_(IDeskBand *) ChannelBand_Create(LPCITEMIDLIST pidlDefault);
BROWSEUIAPI_(void) Channels_SetBandInfoSFB(IUnknown* punkBand);
BROWSEUIAPI IUnknown_SetBandInfoSFB(IUnknown *punkBand, BANDINFOSFB *pbi);

//
// Exported to support IE4 channel quick launch button.
//
BROWSEUIAPI_(HRESULT) Channel_QuickLaunch(void);

// NOTE: this export is new to IE5, so it can move to browseui
// along with the rest of this proxy desktop code
BROWSEUIAPI_(BOOL) SHOnCWMCommandLine(LPARAM lParam);

BROWSEUIAPI_(void) SHCreateSavedWindows(void);

BROWSEUIAPI SHCreateBandForPidl(LPCITEMIDLIST pidl, IUnknown** ppunk, BOOL fAllowBrowserBand);
// hack hack, make this a com object with initializer
BROWSEUIAPI_(IDropTarget*) DropTargetWrap_CreateInstance(IDropTarget* pdtPrimary, IDropTarget* pdtSecondary, HWND hwnd, IDropTarget* pdt3);

BROWSEUIAPI_(DWORD) IDataObject_GetDeskBandState(IDataObject *pdtobj);

//-------------------------------------------------------------------------
//
// Default folder settings
//
//  Make sure to keep INIT_DEFFOLDERSETTINGS in sync.
//
//  dwDefRevCount is used to make sure that "set as settings for all new
//  folders" works.  When settings are loaded from the cache, we check
//  the dwDefRevCount.  If it's different from the one stored as the
//  global settings then it means that somebody changed the global settings
//  since we saved our settings, so we chuck our settings and use the
//  global settings.

typedef struct {
    BOOL bDefStatusBar : 1;     // win95
    BOOL bDefToolBarSingle : 1; // win95
    BOOL bDefToolBarMulti : 1;  // win95
    BOOL bUseVID : 1;           // nash.1

    UINT uDefViewMode;          // win95
    UINT fFlags;                // nash.0 - additional flags that get or'ed in
    SHELLVIEWID vid;            // nash.1

    DWORD dwStructVersion;      // nash.2
    DWORD dwDefRevCount;        // nash.3 - Rev count of the default folder settings
} DEFFOLDERSETTINGS;

#define DFS_NASH_VER 3
#define DFS_VID_Default VID_WebView

//
//  This macro is used to initialize the default `default folder settings'.
//
#define INIT_DEFFOLDERSETTINGS                          \
    {                                                   \
        TRUE,           /* bDefStatusBar        */      \
        TRUE,           /* bDefToolBarSingle    */      \
        FALSE,          /* bDefToolBarMulti     */      \
        TRUE,           /* bUseVID              */      \
        FVM_ICON,       /* uDefViewMode         */      \
        0,              /* fFlags               */      \
        { 0, 0, 0, { 0, 0,  0,  0,  0,  0,  0,  0 } }, /* vid                  */      \
        DFS_NASH_VER,   /* dwStructVersion      */      \
        0,              /* dwDefRevCount        */      \
    }                                                   \

#undef  INTERFACE
#define INTERFACE   IGlobalFolderSettings

DECLARE_INTERFACE_(IGlobalFolderSettings, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IGlobalFolderSettings methods ***
    STDMETHOD(Get)(THIS_ DEFFOLDERSETTINGS *pdfs, int cbDfs) PURE;
    STDMETHOD(Set)(THIS_ const DEFFOLDERSETTINGS *pdfs, int cbDfs, UINT flags) PURE;
};

//
//  Flags for IGlobalFolderSettings::Set
//
#define GFSS_SETASDEFAULT   0x0001  // These settings become default
#define GFSS_VALID          0x0001  // Logical-or of all valid flags

// BUGBUG these two are TEMPORARILY exported for the favorites to shdocvw split
BROWSEUIAPI_(HRESULT) SHGetNavigateTarget(IShellFolder *psf, LPCITEMIDLIST pidl, LPITEMIDLIST *ppidl, DWORD *pdwAttribs);
BROWSEUIAPI_(BOOL)    GetInfoTip(IShellFolder* psf, LPCITEMIDLIST pidl, LPTSTR pszText, int cchTextMax);

#endif // _BROWSEUI_H_

#endif // BROWSEUIAPI
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\brutil.h ===
#ifndef _BRUTIL_H_
#define _BRUTIL_H_

#include <shldispp.h>

STDAPI_(BOOL) IsBrowseNewProcess();
STDAPI_(BOOL) IsBrowseNewProcessAndExplorer();
STDAPI IENavigateIEProcess(LPCTSTR pszPath, BOOL fIsInternetShortcut);
STDAPI NavFrameWithFile(LPCTSTR pszPath, IUnknown *punk);
STDAPI GetPathForItem(IShellFolder *psf, LPCITEMIDLIST pidl, LPTSTR pszPath, DWORD *pdwAttrib);
STDAPI EditBox_TranslateAcceleratorST(LPMSG lpmsg);
STDAPI _CLSIDFromExtension(LPCTSTR pszExt, CLSID *pclsid);
STDAPI GetLinkTargetIDList(LPCTSTR pszPath, LPTSTR pszTarget, DWORD cchTarget, LPITEMIDLIST *ppidl);
STDAPI_(void) PathToDisplayNameW(LPCTSTR pszPath, LPTSTR pszDisplayName, UINT cchDisplayName);
STDAPI_(void) PathToDisplayNameA(LPSTR pszPathA, LPSTR pszDisplayNameA, int cchDisplayName);
STDAPI DataObj_GetNameFromFileDescriptor(IDataObject *pdtobj, LPWSTR pszDisplayName, UINT cch);
STDAPI SHPidlFromDataObject2(IDataObject *pdtobj, LPITEMIDLIST * ppidl);
STDAPI SHPidlFromDataObject(IDataObject *pdtobj, LPITEMIDLIST *ppidl, LPWSTR pszDisplayNameW, DWORD cchDisplayName);
STDAPI_(LRESULT) SendShellIEBroadcastMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, UINT uTimeout);
STDAPI IEBindToParentFolder(LPCITEMIDLIST pidl, IShellFolder** ppsfParent, LPCITEMIDLIST *ppidlChild);
STDAPI GetDataObjectForPidl(LPCITEMIDLIST pidl, IDataObject ** ppdtobj);
STDAPI_(BOOL) ILIsFileSysFolder(LPCITEMIDLIST pidl);
STDAPI SHTitleFromPidl(LPCITEMIDLIST pidl, LPTSTR psz, DWORD cch, BOOL fFullPath);
STDAPI_(BOOL) IsBrowserFrameOptionsSet(IN IShellFolder * psf, IN BROWSERFRAMEOPTIONS dwMask);
STDAPI_(BOOL) IsBrowserFrameOptionsPidlSet(IN LPCITEMIDLIST pidl, IN BROWSERFRAMEOPTIONS dwMask);
STDAPI GetBrowserFrameOptions(IN IUnknown *punk, IN BROWSERFRAMEOPTIONS dwMask, OUT BROWSERFRAMEOPTIONS * pdwOptions);
STDAPI GetBrowserFrameOptionsPidl(IN LPCITEMIDLIST pidl, IN BROWSERFRAMEOPTIONS dwMask, OUT BROWSERFRAMEOPTIONS * pdwOptions);
STDAPI_(BOOL) IsFTPFolder(IShellFolder * psf);

// non-munging menu operations to work around the menu munging code
// in the shlwapi wrappers. for more info see the comment in the brutil.cpp.

STDAPI_(HMENU)  LoadMenu_PrivateNoMungeW(HINSTANCE hInstance, LPCWSTR lpMenuName);
STDAPI_(BOOL)   InsertMenu_PrivateNoMungeW(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem);
STDAPI_(HMENU)  LoadMenuPopup_PrivateNoMungeW(UINT id);

//encode any incoming %1 so that people can't spoof our domain security code
HRESULT WrapSpecialUrl(BSTR * pbstrUrl);
HRESULT WrapSpecialUrlFlat(LPWSTR pszUrl, DWORD cchUrl);
BOOL IsSpecialUrl(LPCWSTR pchURL);

//
//      GetUIVersion()
//
//  returns the version of shell32
//  3 == win95 gold / NT4
//  4 == IE4 Integ / win98
//  5 == win2k
//

STDAPI_(UINT) GetUIVersion();

#endif // _BRUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\dll\xbwebvw.cpp ===
/*****************************************************************************\
    FILE: xbwebvw.h

    DESCRIPTION:
        This file exists so WebView can automate the Xbox Shell Extension and get
    information like the MessageOfTheDay.
\*****************************************************************************/

#include "priv.h"
#include "xbwebvw.h"
#include "xbnmspc.h"
#include <shlguid.h>

//===========================
// *** IDispatch Interface ***
//===========================

// BUGBUG: Cane we nuke this?

STDMETHODIMP CXboxWebView::GetTypeInfoCount(UINT * pctinfo)
{ 
    return CImpIDispatch::GetTypeInfoCount(pctinfo); 
}

STDMETHODIMP CXboxWebView::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo * * pptinfo)
{ 
    return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); 
}

STDMETHODIMP CXboxWebView::GetIDsOfNames(REFIID riid, OLECHAR * * rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid)
{ 
    return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); 
}

STDMETHODIMP CXboxWebView::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
{
    return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
}



//===========================
// *** IXboxWebView Interface ***
//===========================

/*****************************************************************************\
    FUNCTION: _GetIXboxWebView

    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxWebView::_GetIXboxWebView(IXboxWebView ** ppfwb)
{
    IShellFolderViewCB * psfvcb = NULL;
    HRESULT hr = S_FALSE;

    ASSERT(_punkSite);
    if (EVAL(ppfwb))
        *ppfwb = NULL;

    IUnknown_QueryService(_punkSite, SID_ShellFolderViewCB, IID_IShellFolderViewCB, (LPVOID *) &psfvcb);
    // IE4's shell32 doesn't support QS(SID_ShellFolderViewCB, IID_IShellFolderViewCB), so we need to
    // QS(SID_ShellFolderViewCB, IShellFolderView) and then use IShellFolderView::SetCallback()
    if (!psfvcb)
    {
        IDefViewFrame * pdvf = NULL;

        IUnknown_QueryService(_punkSite, SID_DefView, IID_IDefViewFrame, (LPVOID *) &pdvf);
        if (EVAL(pdvf))
        {
            IShellFolderView * psfv = NULL;

            pdvf->QueryInterface(IID_IShellFolderView, (LPVOID *) &psfv);
            if (EVAL(psfv))
            {
                if (EVAL(SUCCEEDED(psfv->SetCallback(NULL, &psfvcb))))
                {
                    IShellFolderViewCB * psfvcbTemp = NULL;

                    if (SUCCEEDED(psfv->SetCallback(psfvcb, &psfvcbTemp)) && psfvcbTemp)
                    {
                        // We should get NULL back but if not, release the ref instead of leaking.
                        psfvcbTemp->Release();
                    }
                }

                psfv->Release();
            }

            pdvf->Release();
        }
    }
    
    if (EVAL(psfvcb))
    {
        if (EVAL(SUCCEEDED(psfvcb->QueryInterface(IID_IXboxWebView, (LPVOID *) ppfwb))))
            hr = S_OK;

        psfvcb->Release();
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: IXboxWebView::get_MessageOfTheDay

    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxWebView::get_MessageOfTheDay(BSTR * pbstr)
{
    IXboxWebView * pfwb;
    HRESULT hr = _GetIXboxWebView(&pfwb);

    if (EVAL(S_OK == hr))
    {
        ASSERT(pfwb);
        hr = pfwb->get_MessageOfTheDay(pbstr);
        pfwb->Release();
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: IXboxWebView::get_UserName

    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxWebView::get_UserName(BSTR * pbstr)
{
    IXboxWebView * pfwb;
    HRESULT hr = _GetIXboxWebView(&pfwb);

    if (EVAL(S_OK == hr))
    {
        ASSERT(pfwb);
        hr = pfwb->get_UserName(pbstr);
        pfwb->Release();
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: IXboxWebView::get_Server

    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxWebView::get_Server(BSTR * pbstr)
{
    IXboxWebView * pfwb;
    HRESULT hr = _GetIXboxWebView(&pfwb);

    if (EVAL(S_OK == hr))
    {
        ASSERT(pfwb);
        hr = pfwb->get_Server(pbstr);
        pfwb->Release();
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: IXboxWebView::get_Directory

    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxWebView::get_Directory(BSTR * pbstr)
{
    IXboxWebView * pfwb;
    HRESULT hr = _GetIXboxWebView(&pfwb);

    if (EVAL(S_OK == hr))
    {
        ASSERT(pfwb);
        hr = pfwb->get_Directory(pbstr);
        pfwb->Release();
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: IXboxWebView::get_PasswordLength

    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxWebView::get_PasswordLength(long * plLength)
{
    IXboxWebView * pfwb;
    HRESULT hr = _GetIXboxWebView(&pfwb);

    if (EVAL(S_OK == hr))
    {
        ASSERT(pfwb);
        hr = pfwb->get_PasswordLength(plLength);
        pfwb->Release();
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: IXboxWebView::get_EmailAddress

    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxWebView::get_EmailAddress(BSTR * pbstr)
{
    IXboxWebView * pfwb;
    HRESULT hr = _GetIXboxWebView(&pfwb);

    if (EVAL(S_OK == hr))
    {
        ASSERT(pfwb);
        hr = pfwb->get_EmailAddress(pbstr);
        pfwb->Release();
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: IXboxWebView::put_EmailAddress

    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxWebView::put_EmailAddress(BSTR bstr)
{
    IXboxWebView * pfwb;
    HRESULT hr = _GetIXboxWebView(&pfwb);

    if (EVAL(S_OK == hr))
    {
        ASSERT(pfwb);
        hr = pfwb->put_EmailAddress(bstr);
        pfwb->Release();
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: IXboxWebView::get_CurrentLoginAnonymous

    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxWebView::get_CurrentLoginAnonymous(VARIANT_BOOL * pfAnonymousLogin)
{
    IXboxWebView * pfwb;
    HRESULT hr = _GetIXboxWebView(&pfwb);

    if (EVAL(S_OK == hr))
    {
        ASSERT(pfwb);
        hr = pfwb->get_CurrentLoginAnonymous(pfAnonymousLogin);
        pfwb->Release();
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: IXboxWebView::LoginAnonymously

    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxWebView::LoginAnonymously(void)
{
    IXboxWebView * pfwb;
    HRESULT hr = _GetIXboxWebView(&pfwb);

    if (EVAL(S_OK == hr))
    {
        ASSERT(pfwb);
        hr = pfwb->LoginAnonymously();
        pfwb->Release();
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: IXboxWebView::LoginWithPassword

    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxWebView::LoginWithPassword(BSTR bUserName, BSTR bPassword)
{
    IXboxWebView * pfwb;
    HRESULT hr = _GetIXboxWebView(&pfwb);

    if (EVAL(S_OK == hr))
    {
        ASSERT(pfwb);
        hr = pfwb->LoginWithPassword(bUserName, bPassword);
        pfwb->Release();
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: IXboxWebView::LoginWithoutPassword

    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxWebView::LoginWithoutPassword(BSTR bUserName)
{
    IXboxWebView * pfwb;
    HRESULT hr = _GetIXboxWebView(&pfwb);

    if (EVAL(S_OK == hr))
    {
        ASSERT(pfwb);
        hr = pfwb->LoginWithoutPassword(bUserName);
        pfwb->Release();
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: IXboxWebView::InvokeHelp

    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxWebView::InvokeHelp(void)
{
    IXboxWebView * pfwb;
    HRESULT hr = _GetIXboxWebView(&pfwb);

    if (EVAL(S_OK == hr))
    {
        ASSERT(pfwb);
        hr = pfwb->InvokeHelp();
        pfwb->Release();
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: CXboxWebView_Create

    DESCRIPTION:
\*****************************************************************************/
HRESULT CXboxWebView_Create(REFIID riid, LPVOID * ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CXboxWebView * pfwv = new CXboxWebView();

    if (EVAL(pfwv))
    {
        hr = pfwv->QueryInterface(riid, ppv);
        pfwv->Release();
    }

    return hr;
}



/****************************************************\
    Constructor
\****************************************************/
CXboxWebView::CXboxWebView() : m_cRef(1), CImpIDispatch(&IID_IXboxWebView)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.

    LEAK_ADDREF(LEAK_CXboxWebView);
}


/****************************************************\
    Destructor
\****************************************************/
/*****************************************************************************
 *
 *      XboxView_OnRelease (from shell32.IShellView)
 *
 *      When the view is released, clean up various stuff.
 *
 *      BUGBUG -- (Note that there is a race here, because this->hwndOwner
 *      doesn't get zero'd out on the OnWindowDestroy because the shell
 *      doesn't give us a pdvsci...)
 *
 *      We release the psf before triggering the timeout, which is a
 *      signal to the trigger not to do anything.
 *
 *      _UNDOCUMENTED_: This callback and its parameters are not documented.
 *
 *****************************************************************************/
CXboxWebView::~CXboxWebView()
{
    DllRelease();
    LEAK_DELREF(LEAK_CXboxWebView);
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CXboxWebView::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CXboxWebView::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CXboxWebView::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CXboxWebView, IObjectWithSite),
        QITABENT(CXboxWebView, IDispatch),
        QITABENT(CXboxWebView, IObjectWithSite),
        QITABENT(CXboxWebView, IObjectSafety),
        QITABENT(CXboxWebView, IXboxWebView),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\ccstock2.h ===
//
// addendum to ccstock.h:
//   this file has function prototypes that require shlobj.h.
//   ccstock.h does not have that requirement (and can not,
//   since comctl32 includes ccstock but not shlobj).
//
#ifndef __CCSTOCK2_H__
#define __CCSTOCK2_H__


STDAPI_(LPITEMIDLIST) IDA_ILClone(LPIDA pida, UINT i);


#endif __CCSTOCK2_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\caggunk.h ===
#ifndef _CAGGUNK_H
#define _CAGGUNK_H

class CAggregatedUnknown  : public IUnknown
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    
protected:
    virtual ~CAggregatedUnknown(); // so that subclasses get deleted right
    CAggregatedUnknown(IUnknown *punkAgg);

    // This is the IUnknown that subclasses returns from their CreateInstance func
    IUnknown* _GetInner() { return &_unkInner; }

    // A couple helper functions for subclasses to cache their aggregator's
    // (or their own) interfaces.
    void _ReleaseOuterInterface(IUnknown** ppunk);
    HRESULT _QueryOuterInterface(REFIID riid, void ** ppvOut);

    // Do non-cached QIs off this IUnknown
    IUnknown* _GetOuter() { return _punkAgg; }

    // Allow "delayed aggregation"
    void _SetOuter(IUnknown* punk) { _punkAgg = punk; }

    // This is the QueryInterface the aggregator implements
    virtual HRESULT v_InternalQueryInterface(REFIID riid, void **ppvObj) = 0;

    virtual BOOL v_HandleDelete(PLONG pcRef) { return FALSE; };
    
private:

    // Get a non-refcounted pointer to the canonical IUnknown of the
    // controlling unknown.  Used by _QueryOuterInterface and
    // _ReleaseOuterInterface.
    IUnknown *_GetCanonicalOuter(void);

    // Embed default IUnknown handler
    class CUnkInner : public IUnknown
    {
    public:
        virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
        virtual STDMETHODIMP_(ULONG) AddRef(void) ;
        virtual STDMETHODIMP_(ULONG) Release(void);

        CUnkInner() { _cRef = 1; }
    private:
        LONG _cRef;
    };
    friend class CUnkInner;
    CUnkInner _unkInner;
    IUnknown* _punkAgg; // points to _unkInner or aggregating IUnknown

};

#define RELEASEOUTERINTERFACE(p) _ReleaseOuterInterface((IUnknown**)((void **)&p))

#endif // _CAGGUNK_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\cfdefs.h ===
#ifndef _STATIC_CLASS_FACTORY_
#define _STATIC_CLASS_FACTORY_

#define VERSION_2 2 // so we don't get confused by too many integers
#define VERSION_1 1
#define VERSION_0 0
#define COCREATEONLY NULL,NULL,VERSION_0,0,0 // piid,piidEvents,lVersion,dwOleMiscFlags,dwClassFactFlags
#define COCREATEONLY_NOFLAGS NULL,NULL,VERSION_0,0 // piid,piidEvents,lVersion,dwOleMiscFlags

/*
 * Class Factory Implementation for C++ without CTRStartup required.
 */

#ifdef __cplusplus

#ifdef UNIX

#define STDMETHODX  STDMETHOD
#define STDMETHODX_ STDMETHOD_

#define DECLARE_CLASS_FACTORY(cf)                                \
   class cf: public IClassFactory                                \
   {                                                             \
     public:                                                     \
       STDMETHODX (QueryInterface)(REFIID, void **);             \
       STDMETHODX_(ULONG, AddRef)();                             \
       STDMETHODX_(ULONG, Release)();                            \
                                                                 \
       STDMETHODX (CreateInstance)(IUnknown *, REFIID, void **); \
       STDMETHODX (LockServer)(BOOL);                            \
   }                                                             \


#else  // UNIX

#define STDMETHODX(fn)      HRESULT STDMETHODCALLTYPE fn
#define STDMETHODX_(ret,fn) ret STDMETHODCALLTYPE fn

#define DECLARE_CLASS_FACTORY(cf)                                \
   class cf                                                      \
   {                                                             \
     public:                                                     \
       IClassFactory *vtable;                                    \
       STDMETHODX (QueryInterface)(REFIID, void **);             \
       STDMETHODX_(ULONG, AddRef)();                             \
       STDMETHODX_(ULONG, Release)();                            \
                                                                 \
       STDMETHODX (CreateInstance)(IUnknown *, REFIID, void **); \
       STDMETHODX (LockServer)(BOOL);                            \
   }                                                             \

#endif // UNIX


DECLARE_CLASS_FACTORY( CClassFactory );


struct IClassFactoryVtbl
{
    // IUnknown
    HRESULT (STDMETHODCALLTYPE CClassFactory::*QueryInterface)(REFIID riid, void ** ppvObj);
    ULONG (STDMETHODCALLTYPE CClassFactory::*AddRef)();
    ULONG (STDMETHODCALLTYPE CClassFactory::*Release)();
    
    // IClassFactory
    HRESULT (STDMETHODCALLTYPE CClassFactory::*CreateInstance)(IUnknown *pUnkOuter, REFIID riid, void ** ppvObject);
    HRESULT (STDMETHODCALLTYPE CClassFactory::*LockServer)(BOOL);
};

typedef struct IClassFactoryVtbl IClassFactoryVtbl;

//
// class CObjectInfo
//

class CObjectInfo;
typedef CObjectInfo* LPOBJECTINFO;
typedef CObjectInfo const* LPCOBJECTINFO;
typedef HRESULT (*LPFNCREATEOBJINSTANCE)(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);

class CObjectInfo : public CClassFactory                               
{                                                                      
public:                                                                
    CLSID const* pclsid;
    LPFNCREATEOBJINSTANCE pfnCreateInstance;

    // for OCs and automation objects:
    IID const* piid;
    IID const* piidEvents;
    long lVersion;
    DWORD dwOleMiscFlags;
    DWORD dwClassFactFlags;

    CObjectInfo(CLSID const* pclsidin, LPFNCREATEOBJINSTANCE pfnCreatein,  IID const* piidIn, IID const* piidEventsIn, long lVersionIn,  DWORD dwOleMiscFlagsIn,  DWORD dwClassFactFlagsIn);

};

const IClassFactoryVtbl c_CFVtbl = {
    CClassFactory::QueryInterface,  CClassFactory::AddRef, CClassFactory::Release,
    CClassFactory::CreateInstance,
    CClassFactory::LockServer
};

//
// CLASS FACTORY TABLE STUFF
//

typedef struct tagOBJECTINFO
{
    void *cf;
    CLSID const* pclsid;
    LPFNCREATEOBJINSTANCE pfnCreateInstance;

    // for OCs and automation objects:
    IID const* piid;
    IID const* piidEvents;
    long lVersion;
    DWORD dwOleMiscFlags;
    DWORD dwClassFactFlags;
} OBJECTINFO;


#ifdef UNIX


#define CF_TABLE_BEGIN(cfTable) const CObjectInfo cfTable[] = { 
#define CF_TABLE_ENTRY         CObjectInfo
#define CF_TABLE_ENTRY_NOFLAGS CObjectInfo
#define CF_TABLE_ENTRY_ALL     CObjectInfo
#define CF_TABLE_END(cfTable)  \
    CF_TABLE_ENTRY(NULL, NULL, COCREATEONLY) };
#define GET_ICLASSFACTORY(ptr) ((IClassFactory *)ptr)

#else // UNIX

#define CF_TABLE_BEGIN(cfTable) const OBJECTINFO cfTable##_tble[] = { 
#define CF_TABLE_ENTRY(p1, p2, p3) { (void *)&c_CFVtbl, p1, p2, p3 }
#define CF_TABLE_ENTRY_NOFLAGS(p1, p2, p3, p4) { (void *)&c_CFVtbl, p1, p2, p3, p4 }
#define CF_TABLE_ENTRY_ALL(p1, p2, p3, p4, p5, p6, p7) { (void *)&c_CFVtbl, p1, p2, p3, p4 , p5, p6, p7}
#define CF_TABLE_END(cfTable)                                         \
    CF_TABLE_ENTRY(NULL, NULL, COCREATEONLY) }; \
    const CObjectInfo *cfTable = (const CObjectInfo *)cfTable##_tble;
#define GET_ICLASSFACTORY(ptr) ((IClassFactory *)&ptr->vtable)

#endif // UNIX

#define DECLARE_CF_TABLE(cfTable) extern const CObjectInfo *cfTable;

#endif // __cplusplus


#endif // _STATIC_CLASS_FACTORY_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\cnctnpt.h ===
#ifndef __CNCTNPT_H__
#define __CNCTNPT_H__

//
//  WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
//
//  This class is shared between DLLs, and DLLs that use it have already
//  shipped as part of IE4 (specifically, shell32).  This means that
//  any changes you make must be done EXTREMELY CAREFULLY and TESTED
//  FOR INTEROPERABILITY WITH IE4!  For one thing, you have to make sure
//  that none of your changes alter the vtbl used by IE4's shell32.
//
//  If you change CIE4ConnectionPoint, you must build SHDOC401 and
//  test it on IE4!
//
//  WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
//

//
//  First, the class as it was defined in IE4.  All virtual functions
//  must be be listed in exactly the same order as they were in IE4.
//  Fortunately, no cross-component users mucked with the member
//  variables.
//
//  Change any of these at your own risk.
//
class CIE4ConnectionPoint : public IConnectionPoint {

public:
    // IUnknown methods
    //
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) PURE;
    virtual STDMETHODIMP_(ULONG) AddRef(void) PURE;
    virtual STDMETHODIMP_(ULONG) Release(void) PURE;

    // IConnectionPoint methods
    //
    virtual STDMETHODIMP GetConnectionInterface(IID FAR* pIID) PURE;
    virtual STDMETHODIMP GetConnectionPointContainer(IConnectionPointContainer FAR* FAR* ppCPC) PURE;
    virtual STDMETHODIMP Advise(LPUNKNOWN pUnkSink, DWORD FAR* pdwCookie) PURE;
    virtual STDMETHODIMP Unadvise(DWORD dwCookie) PURE;
    virtual STDMETHODIMP EnumConnections(LPENUMCONNECTIONS FAR* ppEnum) PURE;

    // This is how you actually fire the events
    // Those called by shell32 are virtual
    // (Renamed to DoInvokeIE4)
    virtual HRESULT DoInvokeIE4(LPBOOL pf, LPVOID *ppv, DISPID dispid, DISPPARAMS *pdispparams) PURE;

    // This helper function does work that callers of DoInvoke often need done
    virtual HRESULT DoInvokePIDLIE4(DISPID dispid, LPCITEMIDLIST pidl, BOOL fCanCancel) PURE;

};

//
// CConnectionPoint is an implementation of a conection point.
// To get the rest of the implementation, you also have to include
// lib\cnctnpt.cpp in your project.
//
// Embed an instance of CConnectionPoint in an object that needs to
// implement a connectionpoint and call SetOwner to initialize it.
//
// Fire events to anyone connected to this connectionpoint via DoInvoke
// or DoOnChanged.  External clients should use the shlwapi functions
// like IConnectionPoint_Invoke or IConnectionPoint_OnChanged.
//

class CConnectionPoint : public CIE4ConnectionPoint {
    friend class CConnectionPointEnum;

public:
    // IUnknown methods
    //
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void)
        { return m_punk->AddRef(); }
    virtual STDMETHODIMP_(ULONG) Release(void)
        { return m_punk->Release(); }

    // IConnectionPoint methods
    //
    virtual STDMETHODIMP GetConnectionInterface(IID * pIID);
    virtual STDMETHODIMP GetConnectionPointContainer(IConnectionPointContainer ** ppCPC);
    virtual STDMETHODIMP Advise(LPUNKNOWN pUnkSink, DWORD * pdwCookie);
    virtual STDMETHODIMP Unadvise(DWORD dwCookie);
    virtual STDMETHODIMP EnumConnections(LPENUMCONNECTIONS * ppEnum);

    // CIE4ConnectionPoint methods - called by IE4's shell32
    virtual HRESULT DoInvokeIE4(LPBOOL pf, LPVOID *ppv, DISPID dispid, DISPPARAMS *pdispparams);

    // DoInvokePidlIE4 is strange in that shell32 linked to it but never
    // actually called it.  This makes the implementation particularly simple.
    virtual HRESULT DoInvokePIDLIE4(DISPID dispid, LPCITEMIDLIST pidl, BOOL fCanCancel)
    { return E_NOTIMPL; }

public:
    // Additional helper methods

    // Performs a basic DISPID Invoke on the object
    inline HRESULT InvokeDispid(DISPID dispid) {
        return IConnectionPoint_SimpleInvoke(this, dispid, NULL);
    }

    // Performs an OnChanged on the object
    inline HRESULT OnChanged(DISPID dispid) {
        return IConnectionPoint_OnChanged(this, dispid);
    }

    // A couple functions to setup and destroy this subclass object
    ~CConnectionPoint(); // not virtual: nobody inherits from this class

    //
    //  The containing object must call SetOwner to initialize the
    //  connection point.
    //
    //  punk - The IUnknown of the object this ConnectionPoint is
    //         embedded in; it will be treated as the connection
    //         point container.
    //
    //  piid - The IID that the sinks are expected to support.
    //         If you call DoInvoke, then it must be derived from
    //         IID_IDispatch.  If you call DoOnChanged, then it must
    //         be exactly &IID_IPropertyNotifySink.
    //
    void SetOwner(IUnknown* punk, const IID* piid)
        {
            // Validate the special requirement on the piid parameter.
            if (*piid == IID_IPropertyNotifySink)
            {
                ASSERT(piid == &IID_IPropertyNotifySink);
            }

            // don't AddRef -- we're a member variable of the object punk points to
            m_punk = punk;
            m_piid = piid;
        }

    // The underline version is inline
    BOOL _HasSinks() { return (BOOL)m_cSinks; }

    // We are empty if there are no sinks
    BOOL IsEmpty() { return !_HasSinks(); }

    HRESULT UnadviseAll(void);

    // A lot of people need to convert a CConnectionPoint into an
    // IConnectionPoint.  We used to be multiply inherited, hence the
    // need for this member, but that's gone now.
    IConnectionPoint *CastToIConnectionPoint()
        { return SAFECAST(this, IConnectionPoint*); }

private:
    IUnknown **m_rgSinks;
    int m_cSinks;
    int m_cSinksAlloc;

    IUnknown *m_punk;   // IUnknown of object containing us
    const IID *m_piid;  // IID of this connection point
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\chanmgrp.h ===
//
// Private channel manager include file.
//

#undef  INTERFACE
#define INTERFACE   IChannelMgrPriv

DECLARE_INTERFACE_(IChannelMgrPriv, IUnknown)
{
    typedef enum _tagCHANNELFOLDERLOCATION { CF_CHANNEL, CF_SOFTWAREUPDATE } CHANNELFOLDERLOCATION;

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IChannelMgrPriv ***
    STDMETHOD(GetBaseChannelPath) (THIS_ LPSTR pszPath, int cch) PURE;
    STDMETHOD(InvalidateCdfCache) (THIS) PURE;
    STDMETHOD(PreUpdateChannelImage) (THIS_ LPCSTR pszPath, LPSTR pszHashItem,
                                      int* piIndex, UINT* puFlags,
                                      int* piImageIndex) PURE;
    STDMETHOD(UpdateChannelImage) (THIS_ LPCWSTR pszHashItem, int iIndex,
                                   UINT uFlags, int iImageIndex) PURE;
    STDMETHOD(GetChannelFolderPath) (THIS_ LPSTR pszPath, int cch, CHANNELFOLDERLOCATION cflChannel) PURE;
    STDMETHOD(GetChannelFolder) (THIS_ LPITEMIDLIST* ppidl, CHANNELFOLDERLOCATION cflChannel) PURE;
    STDMETHOD(DownloadMinCDF) (THIS_ HWND hwnd, LPCWSTR pwszURL, LPWSTR pwszTitle, 
                               DWORD cchTitle, SUBSCRIPTIONINFO *pSubInfo, BOOL *pfIsSoftware) PURE;
    STDMETHOD(ShowChannel) (THIS_ IWebBrowser2 *pWebBrowser2, LPWSTR pwszURL, HWND hwnd) PURE;
    STDMETHOD(IsChannelInstalled) (THIS_ LPCWSTR pwszURL) PURE;
    STDMETHOD(IsChannelPreinstalled) (THIS_ LPCWSTR pwszURL, BSTR * bstrFile) PURE;
    STDMETHOD(RemovePreinstalledMapping) (THIS_ LPCWSTR pwszURL) PURE;
    STDMETHOD(SetupPreinstalledMapping) (THIS_ LPCWSTR pwszURL, LPCWSTR pwszFile) PURE;

    // WARNING!  BEFORE CALLING THE AddAndSubscribe METHOD YOU MUST DETECT
    // THE CDFVIEW VERSION BECAUSE IE 4.00 WILL CRASH IF YOU TRY
    // TO CALL IT

    //  pSubscriptionMgr can be NULL
    STDMETHOD(AddAndSubscribe) (THIS_ HWND hwnd, LPCWSTR pwszURL, 
                                ISubscriptionMgr *pSubscriptionMgr) PURE;
};

#undef  INTERFACE
#define INTERFACE   IChannelMgrPriv2
DECLARE_INTERFACE_(IChannelMgrPriv2, IChannelMgrPriv)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IChannelMgrPriv ***
    STDMETHOD(GetBaseChannelPath) (THIS_ LPSTR pszPath, int cch) PURE;
    STDMETHOD(InvalidateCdfCache) (THIS) PURE;
    STDMETHOD(PreUpdateChannelImage) (THIS_ LPCSTR pszPath, LPSTR pszHashItem,
                                      int* piIndex, UINT* puFlags,
                                      int* piImageIndex) PURE;
    STDMETHOD(UpdateChannelImage) (THIS_ LPCWSTR pszHashItem, int iIndex,
                                   UINT uFlags, int iImageIndex) PURE;
    STDMETHOD(GetChannelFolderPath) (THIS_ LPSTR pszPath, int cch, CHANNELFOLDERLOCATION cflChannel) PURE;
    STDMETHOD(GetChannelFolder) (THIS_ LPITEMIDLIST* ppidl, CHANNELFOLDERLOCATION cflChannel) PURE;
    STDMETHOD(DownloadMinCDF) (THIS_ HWND hwnd, LPCWSTR pwszURL, LPWSTR pwszTitle, 
                               DWORD cchTitle, SUBSCRIPTIONINFO *pSubInfo, BOOL *pfIsSoftware) PURE;
    STDMETHOD(ShowChannel) (THIS_ IWebBrowser2 *pWebBrowser2, LPWSTR pwszURL, HWND hwnd) PURE;
    STDMETHOD(IsChannelInstalled) (THIS_ LPCWSTR pwszURL) PURE;
    STDMETHOD(IsChannelPreinstalled) (THIS_ LPCWSTR pwszURL, BSTR * bstrFile) PURE;
    STDMETHOD(RemovePreinstalledMapping) (THIS_ LPCWSTR pwszURL) PURE;
    STDMETHOD(SetupPreinstalledMapping) (THIS_ LPCWSTR pwszURL, LPCWSTR pwszFile) PURE;

    // WARNING!  BEFORE CALLING THE AddAndSubscribe METHOD YOU MUST DETECT
    // THE CDFVIEW VERSION BECAUSE IE 4.00 WILL CRASH IF YOU TRY
    // TO CALL IT

    //  pSubscriptionMgr can be NULL
    STDMETHOD(AddAndSubscribe) (THIS_ HWND hwnd, LPCWSTR pwszURL, 
                                ISubscriptionMgr *pSubscriptionMgr) PURE;

    // *** IChannelMgrPriv2 ***
    STDMETHOD(WriteScreenSaverURL) (THIS_ LPCWSTR pwszURL, LPCWSTR pwszScreenSaverURL) PURE;
    STDMETHOD(RefreshScreenSaverURLs) (THIS) PURE;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\crtfree.h ===
//
// Code to help free modules from the bondage and tyranny of CRT libraries
//
// Include this header in a single component and #define DECL_CRTFREE.
// (CPP_FUNCTIONS is the old name.)
//


#if defined(__cplusplus) && (defined(CPP_FUNCTIONS) || defined(DECL_CRTFREE))

#ifndef UNIX
void *  __cdecl operator new(size_t nSize)
    {
    // Zero init just to save some headaches
    return((LPVOID)LocalAlloc(LPTR, nSize));
    }


void  __cdecl operator delete(void *pv)
    {
    LocalFree((HLOCAL)pv);
    }
#endif

extern "C" int __cdecl _purecall(void) 
    {
#ifdef ASSERT_MSG
    ASSERT_MSG(0, "purecall() hit");
#endif
    return 0;
    }

#endif  // DECL_CRTFREE


#ifdef __cplusplus
extern "C" {
#endif

#if defined(DEFINE_FLOAT_STUFF)
// If you aren't using any floating-point CRT functions and you know
// you aren't performing any float conversions or arithmetic, yet the
// linker wants these symbols declared, then define DEFINE_FLOAT_STUFF.
//
// Warning: declaring these symbols in a component that needs floating
// point support from the CRT will produce undefined results.  (You will
// need fp support from the CRT if you simply perform fp arithmetic.)

int _fltused = 0;
void __cdecl _fpmath(void) { }
#endif

#ifdef __cplusplus
};
#endif

//
// This file should be included in a global component header
// to use the following
//

#ifndef __CRTFREE_H_
#define __CRTFREE_H_

#ifdef __cplusplus

#ifndef _M_PPC
#pragma intrinsic(memcpy)
#pragma intrinsic(memcmp)
#pragma intrinsic(memset)
#endif

#endif

#endif  // __CRTFREE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\ccstock.h ===
//
// CCSHELL stock definition and declaration header
//


#ifndef __CCSTOCK_H__
#define __CCSTOCK_H__

#ifndef RC_INVOKED

// NT and Win95 environments set warnings differently.  This makes
// our project consistent across environments.

#pragma warning(3:4101)   // Unreferenced local variable

//
// Sugar-coating
//

#define PUBLIC
#define PRIVATE
#define IN
#define OUT
#define BLOCK

#ifndef DECLARE_STANDARD_TYPES

/*
 * For a type "FOO", define the standard derived types PFOO, CFOO, and PCFOO.
 */

#define DECLARE_STANDARD_TYPES(type)      typedef type *P##type; \
                                          typedef const type C##type; \
                                          typedef const type *PC##type;

#endif

#ifndef DECLARE_STANDARD_TYPES_U

/*
 * For a type "FOO", define the standard derived UNALIGNED types PFOO, CFOO, and PCFOO.
 *  WINNT: RISC boxes care about ALIGNED, intel does not.
 */

#define DECLARE_STANDARD_TYPES_U(type)    typedef UNALIGNED type *P##type; \
                                          typedef UNALIGNED const type C##type; \
                                          typedef UNALIGNED const type *PC##type;

#endif

// For string constants that are always wide
#define __TEXTW(x)    L##x
#define TEXTW(x)      __TEXTW(x)

//
// Count of characters to count of bytes
//
#define CbFromCchW(cch)             ((cch)*sizeof(WCHAR))
#define CbFromCchA(cch)             ((cch)*sizeof(CHAR))
#ifdef UNICODE
#define CbFromCch                   CbFromCchW
#else  // UNICODE
#define CbFromCch                   CbFromCchA
#endif // UNICODE

//
// General flag macros
//
#define SetFlag(obj, f)             do {obj |= (f);} while (0)
#define ToggleFlag(obj, f)          do {obj ^= (f);} while (0)
#define ClearFlag(obj, f)           do {obj &= ~(f);} while (0)
#define IsFlagSet(obj, f)           (BOOL)(((obj) & (f)) == (f))
#define IsFlagClear(obj, f)         (BOOL)(((obj) & (f)) != (f))

//
// String macros
//
#define IsSzEqual(sz1, sz2)         (BOOL)(lstrcmpi(sz1, sz2) == 0)
#define IsSzEqualC(sz1, sz2)        (BOOL)(lstrcmp(sz1, sz2) == 0)

#define lstrnicmpA(sz1, sz2, cch)           StrCmpNIA(sz1, sz2, cch)
#define lstrnicmpW(sz1, sz2, cch)           StrCmpNIW(sz1, sz2, cch)
#define lstrncmpA(sz1, sz2, cch)            StrCmpNA(sz1, sz2, cch)
#define lstrncmpW(sz1, sz2, cch)            StrCmpNW(sz1, sz2, cch)

//
// lstrcatnA and lstrcatnW are #defined here to StrCatBuff which is implemented
// in shlwapi. We do this here (and not in shlwapi.h or shlwapip.h) in case the
// kernel guys ever decided to implement this.
//
#define lstrcatnA(sz1, sz2, cchBuffSize)    StrCatBuffA(sz1, sz2, cchBuffSize)
#define lstrcatnW(sz1, sz2, cchBuffSize)    StrCatBuffW(sz1, sz2, cchBuffSize)
#ifdef UNICODE
#define lstrcatn lstrcatnW
#else
#define lstrcatn lstrcatnA
#endif // UNICODE

#ifdef UNICODE
#define lstrnicmp       lstrnicmpW
#define lstrncmp        lstrncmpW
#else
#define lstrnicmp       lstrnicmpA
#define lstrncmp        lstrncmpA
#endif

#ifndef SIZEOF
#define SIZEOF(a)                   sizeof(a)
#endif

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))
#endif
#define SIZECHARS(sz)               (sizeof(sz)/sizeof(sz[0]))

#define InRange(id, idFirst, idLast)      ((UINT)((id)-(idFirst)) <= (UINT)((idLast)-(idFirst)))
#define IsInRange                   InRange

#define ZeroInit(pv, cb)            (memset((pv), 0, (cb)))

// ATOMICRELEASE
//
#ifndef ATOMICRELEASE
#ifdef __cplusplus
#define ATOMICRELEASET(p, type) { if(p) { type* punkT=p; p=NULL; punkT->Release();} }
#else
#define ATOMICRELEASET(p, type) { if(p) { type* punkT=p; p=NULL; punkT->lpVtbl->Release(punkT);} }
#endif

// doing this as a function instead of inline seems to be a size win.
//
#ifdef NOATOMICRELESEFUNC
#define ATOMICRELEASE(p) ATOMICRELEASET(p, IUnknown)
#else
#define ATOMICRELEASE(p) IUnknown_AtomicRelease((void **)&p)
#endif
#endif //ATOMICRELEASE

//
//  IID_PPV_ARG(IType, ppType) 
//      IType is the type of pType
//      ppType is the variable of type IType that will be filled
//
//      RESULTS in:  IID_IType, ppvType
//      will create a compiler error if wrong level of indirection is used.
//
//  macro for QueryInterface and related functions
//  that require a IID and a (void **)
//  this will insure that the cast is safe and appropriate on C++
//
#ifdef __cplusplus
#define IID_PPV_ARG(IType, ppType) IID_##IType, reinterpret_cast<void**>(static_cast<IType**>(ppType))
#else
#define IID_PPV_ARG(IType, ppType) &IID_##IType, (void**)(ppType))
#endif

//
//  Helper macro for managing weak pointers to inner interfaces.
//  (It's the weak version of ATOMICRELEASE.)
//
//  The extra cast to (void **) is to keep C++ from doing strange
//  inheritance games when all I want to do is change the type.
//
#ifndef RELEASEINNERINTERFACE
#define RELEASEINNERINTERFACE(pOuter, p) \
        SHReleaseInnerInterface(pOuter, (IUnknown**)(void **)&(p))
#endif // RELEASEINNERINTERFACE

// For checking window charsets
#ifdef UNICODE
#define IsWindowTchar               IsWindowUnicode
#else  // !UNICODE
#define IsWindowTchar               !IsWindowUnicode
#endif // UNICODE

#ifdef DEBUG
// This macro is especially useful for cleaner looking code in
// declarations or for single lines.  For example, instead of:
//
//   {
//       DWORD dwRet;
//   #ifdef DEBUG
//       DWORD dwDebugOnlyVariable;
//   #endif
//
//       ....
//   }
//
// You can type:
//
//   {
//       DWORD dwRet;
//       DEBUG_CODE( DWORD dwDebugOnlyVariable; )
//
//       ....
//   }

#define DEBUG_CODE(x)               x
#else
#define DEBUG_CODE(x)

#endif  // DEBUG


//
// SAFECAST(obj, type)
//
// This macro is extremely useful for enforcing strong typechecking on other
// macros.  It generates no code.
//
// Simply insert this macro at the beginning of an expression list for
// each parameter that must be typechecked.  For example, for the
// definition of MYMAX(x, y), where x and y absolutely must be integers,
// use:
//
//   #define MYMAX(x, y)    (SAFECAST(x, int), SAFECAST(y, int), ((x) > (y) ? (x) : (y)))
//
//
#define SAFECAST(_obj, _type) (((_type)(_obj)==(_obj)?0:0), (_type)(_obj))


//
// Bitfields don't get along too well with bools,
// so here's an easy way to convert them:
//
#define BOOLIFY(expr)           (!!(expr))


// BUGBUG (scotth): we should probably make this a 'bool', but be careful
// because the Alpha compiler might not recognize it yet.  Talk to AndyP.

// This isn't a BOOL because BOOL is signed and the compiler produces 
// sloppy code when testing for a single bit.

typedef DWORD   BITBOOL;


//
// DESTROY_OBJ_WITH_HANDLE(h, fn)
//
// Kind of like ATOMICRELEASE for handles.  Checks for NULL and assigns
// NULL when it's done.  You supply the destructor function.
//
#define DESTROY_OBJ_WITH_HANDLE(h, fn) { if (h) { fn(h); (h) = NULL; } }


// STOCKLIB util functions

// IsOS(): returns TRUE/FALSE if the platform is the indicated OS.

#ifndef OS_WINDOWS
#define OS_WINDOWS      0           // windows vs. NT
#define OS_NT           1           // windows vs. NT
#define OS_WIN95        2           // Win95 or greater
#define OS_NT4          3           // NT4 or greater
#define OS_NT5          4           // NT5 or greater
#define OS_MEMPHIS      5           // Win98 or greater
#define OS_MEMPHIS_GOLD 6           // Win98 Gold
#endif

STDAPI_(BOOL) staticIsOS(DWORD dwOS);

#include <pshpack2.h>
typedef struct tagDLGTEMPLATEEX
{
    WORD    wDlgVer;
    WORD    wSignature;
    DWORD   dwHelpID;
    DWORD   dwExStyle;
    DWORD   dwStyle;
    WORD    cDlgItems;
    short   x;
    short   y;
    short   cx;
    short   cy;
}   DLGTEMPLATEEX, *LPDLGTEMPLATEEX;
#include <poppack.h>

//
// round macro that rounds a to the next multiple of b.
//
#ifndef ROUNDUP
#define ROUNDUP(a,b)    ((((a)+(b)-1)/(b))*(b))
#endif

#define ROUND_TO_CLUSTER ROUNDUP

//
// macro that sees if a give char is an number
//
#define ISDIGIT(c)  ((c) >= TEXT('0') && (c) <= TEXT('9'))

//
// inline that does PathIsDotOrDotDot
//
__inline BOOL PathIsDotOrDotDotW(LPCWSTR pszPath)
{
    return ((pszPath[0] == L'.') && 
            ((pszPath[1] == L'\0') || ((pszPath[1] == L'.') && (pszPath[2] == L'\0'))));
}

__inline BOOL PathIsDotOrDotDotA(LPCSTR pszPath)
{
    return ((pszPath[0] == '.') && 
            ((pszPath[1] == '\0') || ((pszPath[1] == '.') && (pszPath[2] == '\0'))));
}

#ifdef UNICODE
#define PathIsDotOrDotDot PathIsDotOrDotDotW
#else
#define PathIsDotOrDotDot PathIsDotOrDotDotA
#endif

//
//  FILETIME helpers
//
#define FILETIMEtoInt64(ft) (*(unsigned __int64 *)&(ft))
//
//  FAT and NTFS use different values for "unknown date".
//
//  The FAT "unknown date" is January 1 1980 LOCAL TIME.
//  The NTFS "unknown date" is January 1 1601 GMT.
//
//  This LOCAL/GMT discrepancy is annoying.
//
#define FT_FAT_UNKNOWNLOCAL    ((unsigned __int64)0x01A8E79FE1D58000)
#define FT_NTFS_UNKNOWNGMT     ((unsigned __int64)0x0000000000000000)

//
//  FT_ONEDAY is the number of FILETIME units in a day.
//
//      10,000,000 FILETIME units per second *
//      3600 seconds per hour *
//      24 hours per day.
//
#define FT_ONEDAY              ((unsigned __int64)10000000 * 3600 * 24)


//
//
//  WindowLong accessor macros and other Win64 niceness
//

__inline void * GetWindowPtr(HWND hWnd, int nIndex) {
    return (void *)GetWindowLongPtr(hWnd, nIndex);
}

__inline void * SetWindowPtr(HWND hWnd, int nIndex, void * p) {
    return (void *)SetWindowLongPtr(hWnd, nIndex, (LONG_PTR)p);
}

//***   GetWindowLong0 -- 'fast' GetWindowLong (and GetWindowLongPtr)
// DESCRIPTION
//  what's up w/ this?  it's all about perf.  GetWindowLong has 'A' and 'W'
//  versions.  however 99% of the time they do the same thing (the other
//  0.1% has to do w/ setting the WndProc and having to go thru a thunk).
//  but we still need wrappers for the general case.  but most of the time
//  we're just doing a GWL(0), e.g. on entry to a wndproc to get our private
//  data.  so by having a special version of that, we save going thru the
//  wrapper (which was costing us 1-3% of our profile).
// NOTES
//  note that we call the 'A' version since that's guaranteed to exist on
// all platforms.
__inline LONG GetWindowLong0(HWND hWnd) {
    return GetWindowLongA(hWnd, 0);
}
__inline LONG SetWindowLong0(HWND hWnd, LONG l) {
    return SetWindowLongA(hWnd, 0, l);
}
__inline void * GetWindowPtr0(HWND hWnd) {
    return (void *)GetWindowLongPtrA(hWnd, 0);
}
__inline void * SetWindowPtr0(HWND hWnd, void * p) {
    return (void *)SetWindowLongPtrA(hWnd, 0, (LONG_PTR)p);
}


#define IS_WM_CONTEXTMENU_KEYBOARD(lParam) ((DWORD)(lParam) == 0xFFFFFFFF)

//
//  CharUpperChar - Convert a single character to uppercase
//
__inline WCHAR CharUpperCharW(WCHAR c)
{
    return (WCHAR)(DWORD_PTR)CharUpperW((LPWSTR)(DWORD_PTR)(c));
}

__inline CHAR CharUpperCharA(CHAR c)
{
    return (CHAR)(DWORD_PTR)CharUpperA((LPSTR)(DWORD_PTR)(c));
}

#ifdef UNICODE
#define CharUpperChar       CharUpperCharW
#else
#define CharUpperChar       CharUpperCharA
#endif

//
//  ShrinkProcessWorkingSet - Use this to stay Sundown-happy.
//
#define ShrinkWorkingSet() \
        SetProcessWorkingSetSize(GetCurrentProcess(), (SIZE_T) -1, (SIZE_T) -1)

//
//  COM Initialization.
//
//  Usage:
//
//      HRESULT hrInit = SHCoInitialize();
//      ... do COM stuff ...
//      SHCoUninitialize(hrInit);
//
//  Notice:  Continue doing COM stuff even if SHCoInitialize fails.
//  It might fail if somebody else already CoInit'd with different
//  flags, but we don't want to barf under those conditions.
//

STDAPI SHCoInitialize(void);
#define SHCoUninitialize(hr) if (SUCCEEDED(hr)) CoUninitialize()


//
//  OLE Initialization.
//
//  Usage:
//
//      HRESULT hrInit = SHOleInitialize(pMalloc);
//      ... do COM stuff ...
//      SHOleUninitialize(hrInit);
//

#define SHOleInitialize(pMalloc) OleInitialize(pMalloc)

#define SHOleUninitialize(hr)   if (SUCCEEDED(hr))  OleUninitialize()

//
//  MACRO HACK - Since not all clients of ccstock.h include shlobj.h first,
//  we need to use the long form of LP[C]ITEMIDLIST.  Since nobody remembers
//  this little quirk, to avoid future build breaks, redefine the symbols
//  to their long forms.
//
#define LPCITEMIDLIST const UNALIGNED struct _ITEMIDLIST *
#define  LPITEMIDLIST       UNALIGNED struct _ITEMIDLIST *

//
//  Name Parsing generic across the shell
//
//  Usage:
//
//      HRESULT SHGetNameAndFlags()
//          wrapper to bind to the folder and do a GetDisplayName()
//
STDAPI SHGetNameAndFlagsA(LPCITEMIDLIST pidl, DWORD dwFlags, LPSTR pszName, UINT cchName, DWORD *pdwAttribs);
STDAPI SHGetNameAndFlagsW(LPCITEMIDLIST pidl, DWORD dwFlags, LPWSTR pszName, UINT cchName, DWORD *pdwAttribs);

STDAPI SHBindToObject(struct IShellFolder *psf, REFIID riid, LPCITEMIDLIST pidl, void **ppv);
STDAPI SHGetUIObjectFromFullPIDL(LPCITEMIDLIST pidl, HWND hwnd, REFIID riid, void **ppv);

#define SHGetAttributesOf(pidl, prgfInOut) SHGetNameAndFlags(pidl, 0, NULL, 0, prgfInOut)

STDAPI_(DWORD) GetUrlSchemeW(LPCWSTR pszUrl);
STDAPI_(DWORD) GetUrlSchemeA(LPCSTR pszUrl);
STDAPI_(void) SHRemoveURLTurd(LPTSTR pszUrl);

#ifdef UNICODE
#define SHGetNameAndFlags       SHGetNameAndFlagsW
#define GetUrlScheme            GetUrlSchemeW
#else
#define SHGetNameAndFlags       SHGetNameAndFlagsA
#define GetUrlScheme            GetUrlSchemeA
#endif

// SHBindToIDListParent(LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPCITEMIDLIST *ppidlLast)
//
// Given a pidl, you can get an interface pointer (as specified by riid) of the pidl's parent folder (in ppv)
// If ppidlLast is non-NULL, you can also get the pidl of the last item.
//
STDAPI SHBindToIDListParent(LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPCITEMIDLIST *ppidlLast);

//
// SHBindToFolderIDListParent
//
//  Same as SHBindToIDListParent, except you also specify which root to use.
//
STDAPI SHBindToFolderIDListParent(struct IShellFolder *psfRoot, LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPCITEMIDLIST *ppidlLast);

//  clones the parent of the pidl
STDAPI_(LPITEMIDLIST) ILCloneParent(LPCITEMIDLIST pidl);

STDAPI SHGetIDListFromUnk(IUnknown *punk, LPITEMIDLIST *ppidl);

STDAPI_(BOOL) ILIsRooted(LPCITEMIDLIST pidl);
STDAPI_(LPCITEMIDLIST) ILRootedFindIDList(LPCITEMIDLIST pidl);
STDAPI_(BOOL) ILRootedGetClsid(LPCITEMIDLIST pidl, CLSID *clsid);
STDAPI_(LPITEMIDLIST) ILRootedCreateIDList(CLSID *pclsid, LPCITEMIDLIST pidl);
STDAPI_(int) ILRootedCompare(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
#define ILIsEqualRoot(pidl1, pidl2) (0 == ILRootedCompare(pidl1, pidl2))

STDAPI_(BOOL) SHChangeMenuWasSentByMe(LPVOID self, LPCITEMIDLIST pidlNotify);
STDAPI_(void) SHSendChangeMenuNotify(LPVOID self, DWORD shcnee, DWORD shcnf, LPCITEMIDLIST pidl2);

STDAPI_(BOOL) Pidl_Set(LPITEMIDLIST* ppidl, LPCITEMIDLIST pidl);

STDAPI GetHTMLDoc2(IUnknown *punk, struct IHTMLDocument2 **ppHtmlDoc);
STDAPI LocalZoneCheck(IUnknown *punkSite);
STDAPI LocalZoneCheckPath(LPCWSTR pszUrl);

//
//  DLL version helper macros
//
//  To add DllGetVersion support to your DLL, do this:
//
//  1. foo.c
//
//      DLLVER_SINGLEBINARY(VER_PRODUCTVERSION_DW, VER_PRODUCTBUILD_QFE);
//
//  or
//
//      DLLVER_DUALBINARY(VER_PRODUCTVERSION_DW, VER_PRODUCTBUILD_QFE);
//
//  depending on whether you are a single-binary or dual-binary component.
//
//  2. foo.src:
//
//      DllGetVersion = CCDllGetVersion             ULTRAPRIVATE
//
//  3. sources:
//
//      LINKLIBS = $(LINKLIBS) $(CCSHELL_DIR)\lib\$(O)\stocklib.lib
//

#define PRODUCTVER_GETMAJOR(ver)    (((ver) & 0xFF000000) >> 24)
#define PRODUCTVER_GETMINOR(ver)    (((ver) & 0x00FF0000) >> 16)
#define PRODUCTVER_GETBUILD(ver)    (((ver) & 0x0000FFFF) >>  0)

#define MAKEDLLVERULL_PRODUCTVERQFE(ver, qfe)               \
        MAKEDLLVERULL(PRODUCTVER_GETMAJOR(ver),             \
                      PRODUCTVER_GETMINOR(ver),             \
                      PRODUCTVER_GETBUILD(ver), qfe)

#define MAKE_DLLVER_STRUCT(ver, plat, qfe)                  \
EXTERN_C const DLLVERSIONINFO2 c_dllver = {                 \
  {                                 /* DLLVERSIONINFO    */ \
    0,                              /* cbSize            */ \
    PRODUCTVER_GETMAJOR(ver),       /* dwMajorVersion    */ \
    PRODUCTVER_GETMINOR(ver),       /* dwMinorVersion    */ \
    PRODUCTVER_GETBUILD(ver),       /* dwBuildNumber     */ \
    plat,                           /* dwPlatformID      */ \
  },                                                        \
    0,                              /* dwFlags           */ \
    MAKEDLLVERULL_PRODUCTVERQFE(ver, qfe), /* ullVersion */ \
}

#define DLLVER_9xBINARY(ver, qfe)                           \
        MAKE_DLLVER_STRUCT(ver, DLLVER_PLATFORM_WINDOWS, qfe)

#define DLLVER_NTBINARY(ver, qfe)                           \
        MAKE_DLLVER_STRUCT(ver, DLLVER_PLATFORM_NT, qfe)

#define DLLVER_SINGLEBINARY     DLLVER_9xBINARY

#ifdef WINNT
#define DLLVER_DUALBINARY       DLLVER_NTBINARY
#else
#define DLLVER_DUALBINARY       DLLVER_9xBINARY
#endif

STDAPI CCDllGetVersion(struct _DLLVERSIONINFO * pinfo);

//
// Mirroring-Support APIs (astracted in \shell\lib\stock5\rtlmir.cpp)
//
#ifdef __cplusplus
extern "C" {
#endif

extern BOOL g_bMirroredOS;

void EditBiDiDLGTemplate(LPDLGTEMPLATE pdt, DWORD dwFlags, PWORD pwIgnoreList, int cIgnore);
#define   EBDT_NOMIRROR        0x00000001
#define   EBDT_FLIP            0x00000002

#ifdef USE_MIRRORING

BOOL  IsBiDiLocalizedSystem( void );
BOOL  IsBiDiLocalizedSystemEx( LANGID *pLangID );
BOOL  Mirror_IsEnabledOS( void );
LANGID Mirror_GetUserDefaultUILanguage( void );
BOOL Mirror_IsUILanguageInstalled( LANGID langId );
BOOL CALLBACK Mirror_EnumUILanguagesProc(LPTSTR lpUILanguageString, LONG_PTR lParam);
BOOL  Mirror_IsWindowMirroredRTL( HWND hWnd );
DWORD Mirror_IsDCMirroredRTL( HDC hdc );
DWORD Mirror_MirrorDC( HDC hdc );
BOOL  Mirror_MirrorProcessRTL( void );
DWORD Mirror_GetLayout( HDC hdc );
DWORD Mirror_SetLayout( HDC hdc , DWORD dwLayout );
BOOL Mirror_GetProcessDefaultLayout( DWORD *pdwDefaultLayout );
BOOL Mirror_IsProcessRTL( void );
extern const DWORD dwNoMirrorBitmap;
extern const DWORD dwExStyleRTLMirrorWnd;
extern const DWORD dwExStyleNoInheritLayout;
extern const DWORD dwPreserveBitmap;
//
// 'g_bMirroredOS' is defined in each component which will use the
//  mirroring APIs. I decided to put it here, in order to make sure
//  each component has validated that the OS supports the mirroring
//  APIs before calling them.
//

#define GET_BIDI_LOCALIZED_SYSTEM_LANGID(pLangID) \
                                        IsBiDiLocalizedSystemEx(pLangID)
#define IS_BIDI_LOCALIZED_SYSTEM()      IsBiDiLocalizedSystem()
#define IS_MIRRORING_ENABLED()          Mirror_IsEnabledOS()
#define IS_WINDOW_RTL_MIRRORED(hwnd)    (g_bMirroredOS && Mirror_IsWindowMirroredRTL(hwnd))
#define IS_DC_RTL_MIRRORED(hdc)         (g_bMirroredOS && Mirror_IsDCMirroredRTL(hdc))
#define GET_PROCESS_DEF_LAYOUT(pdwl)    (g_bMirroredOS && Mirror_GetProcessDefaultLayout(pdwl))
#define IS_PROCESS_RTL_MIRRORED()       (g_bMirroredOS && Mirror_IsProcessRTL())
#define SET_DC_RTL_MIRRORED(hdc)        Mirror_MirrorDC(hdc)
#define SET_DC_LAYOUT(hdc,dwl)          Mirror_SetLayout(hdc,dwl)
#define SET_PROCESS_RTL_LAYOUT()        Mirror_MirrorProcessRTL()
#define GET_DC_LAYOUT(hdc)              Mirror_GetLayout(hdc) 
#define DONTMIRRORBITMAP                dwNoMirrorBitmap
#define RTL_MIRRORED_WINDOW             dwExStyleRTLMirrorWnd
#define RTL_NOINHERITLAYOUT             dwExStyleNoInheritLayout
#define LAYOUT_PRESERVEBITMAP           dwPreserveBitmap

#else

#define GET_BIDI_LOCALIZED_SYSTEM_LANGID(pLangID) \
                                        FALSE
#define IS_BIDI_LOCALIZED_SYSTEM()      FALSE
#define IS_MIRRORING_ENABLED()          FALSE
#define IS_WINDOW_RTL_MIRRORED(hwnd)    FALSE
#define IS_DC_RTL_MIRRORED(hdc)         FALSE
#define GET_PROCESS_DEF_LAYOUT(pdwl)    FALSE
#define IS_PROCESS_RTL_MIRRORED()       FALSE
#define SET_DC_RTL_MIRRORED(hdc)        
#define SET_DC_LAYOUT(hdc,dwl)
#define SET_PROCESS_DEFAULT_LAYOUT() 
#define GET_DC_LAYOUT(hdc)              0L

#define DONTMIRRORBITMAP                0L
#define RTL_MIRRORED_WINDOW             0L
#define LAYOUT_PRESERVEBITMAP           0L
#define RTL_NOINHERITLAYOUT             0L

#endif  // USE_MIRRROING

BOOL IsBiDiLocalizedWin95( BOOL bArabicOnly );


//
//====== Dynamic array functions  ================================================
//

//------------------------------------------------------------------------
// Dynamic key array
//
typedef struct _DKA * HDKA;     // hdka

HDKA   DKA_CreateA(HKEY hkey, LPCSTR pszSubKey, LPCSTR pszFirst, LPCSTR pszDefOrder, BOOL fDefault);
HDKA   DKA_CreateW(HKEY hkey, LPCWSTR pszSubKey, LPCWSTR pszFirst, LPCWSTR pszDefOrder, BOOL fDefault);

int    DKA_GetItemCount(HDKA hdka);

LPCSTR  DKA_GetKeyA(HDKA hdka, int iItem);
LPCWSTR DKA_GetKeyW(HDKA hdka, int iItem);

LONG   DKA_QueryValueA(HDKA hdka, int iItem, LPSTR szValue, LONG  * pcb);
LONG   DKA_QueryValueW(HDKA hdka, int iItem, LPWSTR szValue, LONG  * pcb);

DWORD  DKA_QueryOtherValueA(HDKA pdka, int iItem, LPCSTR pszName, LPSTR pszValue, LONG * pcb);
DWORD  DKA_QueryOtherValueW(HDKA pdka, int iItem, LPCWSTR pszName, LPWSTR pszValue, LONG * pcb);

void   DKA_Destroy(HDKA hdka);

#ifdef UNICODE
#define DKA_Create          DKA_CreateW
#define DKA_GetKey          DKA_GetKeyW
#define DKA_QueryValue      DKA_QueryValueW
#define DKA_QueryOtherValue DKA_QueryOtherValueW
#else
#define DKA_Create          DKA_CreateA
#define DKA_GetKey          DKA_GetKeyA
#define DKA_QueryValue      DKA_QueryValueA
#define DKA_QueryOtherValue DKA_QueryOtherValueA
#endif

//------------------------------------------------------------------------
// Dynamic class array
//
typedef struct _DCA * HDCA;     // hdca

HDCA DCA_Create();
void DCA_Destroy(HDCA hdca);
int  DCA_GetItemCount(HDCA hdca);
BOOL DCA_AddItem(HDCA hdca, REFCLSID rclsid);
const CLSID * DCA_GetItem(HDCA hdca, int i);

void DCA_AddItemsFromKeyA(HDCA hdca, HKEY hkey, LPCSTR pszSubKey);
void DCA_AddItemsFromKeyW(HDCA hdca, HKEY hkey, LPCWSTR pszSubKey);

#ifdef UNICODE
#define DCA_AddItemsFromKey     DCA_AddItemsFromKeyW
#else
#define DCA_AddItemsFromKey     DCA_AddItemsFromKeyA
#endif 

STDAPI DCA_CreateInstance(HDCA hdca, int iItem, REFIID riid, void ** ppv);


#ifdef __cplusplus
};
#endif

#endif // RC_INVOKED

//------------------------------------------------------------------------
// Random helpful functions
//------------------------------------------------------------------------
//
#define EDGE_LEFT       0x00000001
#define EDGE_RIGHT      0x00000002
#define EDGE_TOP        0x00000004
#define EDGE_BOTTOM     0x00000008

STDAPI_(DWORD) SHIsButtonObscured(HWND hwnd, PRECT prc, INT_PTR i);
STDAPI_(void) _SHPrettyMenu(HMENU hm);
STDAPI_(BOOL) _SHIsMenuSeparator(HMENU hm, int i);
STDAPI_(BOOL) _SHIsMenuSeparator2(HMENU hm, int i, BOOL *pbIsNamed);
STDAPI_(BYTE) SHBtnStateFromRestriction(DWORD dwRest, BYTE fsState);
STDAPI_(BOOL) SHIsDisplayable(LPCWSTR pwszName, BOOL fRunOnFE, BOOL fRunOnNT5);

STDAPI_(BOOL) SetWindowZorder(HWND hwnd, HWND hwndInsertAfter);
STDAPI_(BOOL) SHForceWindowZorder(HWND hwnd, HWND hwndInsertAfter);

STDAPI_(void) EnableOKButtonFromString(HWND hDlg, LPTSTR pszText);
STDAPI_(void) EnableOKButtonFromID(HWND hDlg, int id);

//  maybe this should be moved to shlwapi??
enum {
    OBJCOMPATF_OTNEEDSSFCACHE          = 0x00000001,
    OBJCOMPATF_NO_WEBVIEW              = 0x00000002,
    OBJCOMPATF_UNBINDABLE              = 0x00000004,
    OBJCOMPATF_PINDLL                  = 0x00000008,
    OBJCOMPATF_NEEDSFILESYSANCESTOR    = 0x00000010,
    OBJCOMPATF_NOTAFILESYSTEM          = 0x00000020,
    OBJCOMPATF_CTXMENU_NOVERBS         = 0x00000040,
    OBJCOMPATF_CTXMENU_LIMITEDQI       = 0x00000080,
    OBJCOMPATF_COCREATESHELLFOLDERONLY = 0x00000100,
} ;

typedef DWORD OBJCOMPATFLAGS;

STDAPI_(OBJCOMPATFLAGS) SHGetObjectCompatFlags(IUnknown *punk, const CLSID *pclsid);
STDAPI_(OBJCOMPATFLAGS) SHGetObjectCompatFlagsFromIDList(LPCITEMIDLIST pidl);

//------------------------------------------------------------------------

////////////////
//
//  Critical section stuff
//
//  Helper macros that give nice debug support
//
EXTERN_C CRITICAL_SECTION g_csDll;
#ifdef DEBUG
EXTERN_C UINT g_CriticalSectionCount;
EXTERN_C DWORD g_CriticalSectionOwner;
EXTERN_C void Dll_EnterCriticalSection(CRITICAL_SECTION*);
EXTERN_C void Dll_LeaveCriticalSection(CRITICAL_SECTION*);
#if defined(__cplusplus) && defined(AssertMsg)
class DEBUGCRITICAL {
protected:
    BOOL fClosed;
public:
    DEBUGCRITICAL() {fClosed = FALSE;};
    void Leave() {fClosed = TRUE;};
    ~DEBUGCRITICAL() 
    {
        AssertMsg(fClosed, TEXT("you left scope while holding the critical section"));
    }
};
#define ENTERCRITICAL DEBUGCRITICAL debug_crit; Dll_EnterCriticalSection(&g_csDll)
#define LEAVECRITICAL debug_crit.Leave(); Dll_LeaveCriticalSection(&g_csDll)
#define ENTERCRITICALNOASSERT Dll_EnterCriticalSection(&g_csDll)
#define LEAVECRITICALNOASSERT Dll_LeaveCriticalSection(&g_csDll)
#else // __cplusplus
#define ENTERCRITICAL Dll_EnterCriticalSection(&g_csDll)
#define LEAVECRITICAL Dll_LeaveCriticalSection(&g_csDll)
#define ENTERCRITICALNOASSERT Dll_EnterCriticalSection(&g_csDll)
#define LEAVECRITICALNOASSERT Dll_LeaveCriticalSection(&g_csDll)
#endif // __cplusplus
#define ASSERTCRITICAL ASSERT(g_CriticalSectionCount > 0 && GetCurrentThreadId() == g_CriticalSectionOwner)
#define ASSERTNONCRITICAL ASSERT(GetCurrentThreadId() != g_CriticalSectionOwner)
#else // DEBUG
#define ENTERCRITICAL EnterCriticalSection(&g_csDll)
#define LEAVECRITICAL LeaveCriticalSection(&g_csDll)
#define ENTERCRITICALNOASSERT EnterCriticalSection(&g_csDll)
#define LEAVECRITICALNOASSERT LeaveCriticalSection(&g_csDll)
#define ASSERTCRITICAL 
#define ASSERTNONCRITICAL
#endif // DEBUG


//
//  END OF MACRO HACK
//
#undef LPITEMIDLIST
#undef LPCITEMIDLIST

#endif // __CCSTOCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\deballoc.h ===
#if 0
#pragma message("### Building FULL_DEBUG version ###")
#undef LocalAlloc
#undef LocalReAlloc
#undef LocalFree
#define LocalAlloc      DebugLocalAlloc
#define LocalReAlloc    DebugLocalReAlloc
#define LocalFree       DebugLocalFree

#ifdef __cplusplus
extern "C" {
#endif

HLOCAL WINAPI DebugLocalAlloc(UINT uFlags, UINT uBytes);
HLOCAL WINAPI DebugLocalReAlloc(HLOCAL hMem, UINT uBytes, UINT uFlags);
HLOCAL WINAPI DebugLocalFree( HLOCAL hMem );

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\deballoc.c ===
//====================================================================
// Debugging memory problems.
//====================================================================

#undef LocalAlloc
#undef LocalReAlloc	
#undef LocalFree

#define CBALLOCEXTRA		(sizeof(LPARAM)+sizeof(UINT))
#define HMEM2PTR(hMem,i)	(((BYTE*)hMem)+i)

void _StoreSigniture(HLOCAL hMem, UINT uByte, LPARAM lParam)
{
    if (hMem)
    {
        SIZE_T uSize = LocalSize(hMem);
        ASSERT(uSize>=uByte+CBALLOCEXTRA);
        *(UINT*)HMEM2PTR(hMem, uSize-sizeof(UINT)) = uByte;
        *(LPARAM*)HMEM2PTR(hMem, uByte) = lParam;
    }
}

UINT _ValidateLocalMem(HLOCAL hMem, LPARAM lParam, LPCSTR pszText)
{
    UINT uByte = 0;
    if (hMem)
    {
        SIZE_T uSize = LocalSize(hMem);
        if (uSize)
        {
            LPARAM lParamStored;
            uByte = *(UINT*)HMEM2PTR(hMem, uSize-sizeof(UINT));
            AssertMsg(uByte+CBALLOCEXTRA <= uSize,
                      TEXT("cm ASSERT! Bogus uByte %d (%s for %x)"),
                      uByte, pszText, hMem);
            lParamStored = *(LPARAM*)HMEM2PTR(hMem, uByte);
            AssertMsg(lParamStored==lParam, TEXT("cm ASSERT! Bad Signiture %x (%s for %x)"),
                      lParamStored, pszText, hMem);
        }
        else
        {
            AssertMsg(0, TEXT("cm ASSERT! LocalSize is zero (%s for %x)"),
                      pszText, hMem);
        }
    }
    return uByte;
}

HLOCAL WINAPI DebugLocalAlloc(UINT uFlags, UINT uBytes)
{
    HLOCAL hMem = LocalAlloc(uFlags, uBytes+CBALLOCEXTRA);
    _StoreSigniture(hMem, uBytes, (LPARAM)hMem);
    return hMem;
}

HLOCAL WINAPI DebugLocalReAlloc(HLOCAL hMem, UINT uBytes, UINT uFlags)
{
    HLOCAL hNew;
    _ValidateLocalMem(hMem, (LPARAM)hMem, "LocalReAlloc");
    hNew = LocalReAlloc(hMem, uBytes+CBALLOCEXTRA, uFlags);
    _StoreSigniture(hNew, uBytes, (LPARAM)hNew);
    return hNew;
}

HLOCAL WINAPI DebugLocalFree( HLOCAL hMem )
{
    UINT uBytes = _ValidateLocalMem(hMem, (LPARAM)hMem, "LocalFree");
    if (uBytes)
    {
        _StoreSigniture(hMem, uBytes, (LPARAM)0xDDDDDDDDL);
    }
    else
    {
        AssertMsg(0, TEXT("cm ASSERT! LocalFree _ValidateLocalMem returned 0 for %x"), hMem);
    }
    return LocalFree(hMem);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\dbgmem.h ===
/* Copyright 1996 Microsoft */

#ifndef _DBGMEMORY_
#define _DBGMEMORY_

#ifdef DEBUG

#define DBGMEM_MEMORY   0x00
#define DBGMEM_STRDUP   0x01
#define DBGMEM_OBJECT   0x02
#define DBGMEM_TRACED   0x04
#define DBGMEM_UNKNOBJ  0x08

#endif // DEBUG


#define     DML_TYPE_MAIN            0
#define     DML_TYPE_THREAD          1
#define     DML_TYPE_FRAME           2
#define     DML_TYPE_DOWNLOAD        3
#define     DML_TYPE_NAVIGATE        4
#define     DML_TYPE_MASK   0x0000000f
#define     DML_BEGIN       0x00000000
#define     DML_END         0x80000000

#ifdef DEBUG

EXTERN_C BOOL g_bUseNewLeakDetection;

STDAPI_(void) MemLeakInit(UINT wFlags, LPCTSTR pszFile, UINT iLine);
#define DebugMemLeak(wFlags)  MemLeakInit(wFlags, TEXT(__FILE__), __LINE__)

// shdocvw memory leak tracker...
// void _DumpMemLeak( DWORD dwFlags ); // call DebugMemLeak instead!

// stuff used to move memory ownership from one thread to another
STDAPI_(void) remove_from_thread_memlist( DWORD dwThreadId, LPVOID pv );
STDAPI_(void) transfer_to_thread_memlist( DWORD dwThread, LPVOID pv );
STDAPI_(UINT) mem_thread_message( void );
STDAPI_(void) received_for_thread_memlist( DWORD dwFlags, void * pData );
#else
#define DebugMemLeak(wFlags)  (0)
#endif

typedef struct _leakmeminfo {
    HMODULE hmod;               // which dll was it allocated from...
    void*   pv;
    UINT    cb;
    UINT    nType;
    // DWORD   adwCaller[4];   // for future
    LPCSTR  pszFile;            // file where memory block was allocced
    INT_PTR iLine;              // line where memory block was allocced
} LEAKMEMINFO, *PLEAKMEMINFO;

typedef struct _IntelliLeakDumpCBFunctions
{
    void (STDMETHODCALLTYPE *pfnDumpLeakedMemory)(PLEAKMEMINFO pmeminfo);
    LPWSTR (STDMETHODCALLTYPE *pfnGetLeakSymbolicName)(PLEAKMEMINFO pmeminfo, LPWSTR pwszBuf, int cchBuf);
} INTELLILEAKDUMPCBFUNCTIONS;

typedef struct _LeakDetectFunctions
{

    HLOCAL (STDMETHODCALLTYPE * pfnTrcLocalAlloc)(UINT uFlags,
                               UINT uBytes,  
                               LPCSTR pszFile,  
                               const int iLine );

    HLOCAL (STDMETHODCALLTYPE * pfnTrcLocalFree )(HLOCAL hMem );

    LPTSTR (STDMETHODCALLTYPE * pfnTrcStrDup )(LPTSTR lpSrch,
                            LPCSTR pszFile,
                            const int iLine);

    void  (STDMETHODCALLTYPE * pfnDumpMemLeak )(DWORD wFlags);
    void  (STDMETHODCALLTYPE * pfnDebugMemLeak)(UINT wFlags, LPCTSTR pszFile, UINT iLine);
    void  (STDMETHODCALLTYPE * pfnreceived_for_thread_memlist)( DWORD dwFlags, void * pData );
    void  (STDMETHODCALLTYPE * pfnremove_from_thread_memlist )( DWORD dwThreadId, LPVOID pv );
    UINT  (STDMETHODCALLTYPE * pfnmem_thread_message )();
    void  (STDMETHODCALLTYPE * pfnremove_from_memlist )(void *pv);
    void  (STDMETHODCALLTYPE * pfnadd_to_memlist )(HMODULE hmod, void *pv, unsigned int nSize, UINT nType, LPCSTR pszFile, const INT_PTR iLine );
    void  (STDMETHODCALLTYPE * pfnregister_hmod_intelli_dump)(HMODULE hmod, const INTELLILEAKDUMPCBFUNCTIONS*pildf);

} LEAKDETECTFUNCS;

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif

STDAPI_(BOOL) GetLeakDetectionFunctionTable(LEAKDETECTFUNCS *pTable);
#ifdef __cplusplus
}

#endif  /* __cplusplus */

#ifdef DEBUG

// use the macros below
STDAPI_(HLOCAL) _TrcLocalAlloc(
    UINT uFlags,                            // flags used in LocalAlloc
    UINT uBytes,                            // number of bytes to be allocated
    LPCSTR pszFile,                         // file which allocced memory
    const int iLine                         // line which allocced memory
    );

STDAPI_(LPTSTR)  _TrcStrDup(
    LPTSTR lpSrch,                          // pointer to string to StrDup
    LPCSTR pszFile,                         // file which allocced memory
    const int   iLine                       // line which allocced memory
    );

STDAPI_(HLOCAL) _TrcLocalFree(
    HLOCAL hMem                             // memory to be freed
    );

STDAPI_(void) add_to_memlist(
    HMODULE hmod,                           // for secondary memory allocators...
    void *pv,                               // pointer to memory block
    unsigned int nSize,                     // size of memory block
    unsigned int nType,                     // what the possible use of the memory is
    LPCSTR pszFile,                         // file name
    const INT_PTR iLine                     // line number
    );

STDAPI_(void) remove_from_memlist(
    void *pv                                // pointer to memory block
    );

STDAPI_(void) register_intelli_dump(
    HMODULE hmod, 
    const INTELLILEAKDUMPCBFUNCTIONS *pfns
    );

#ifndef _NO_DBGMEMORY_REDEFINITION_

#ifdef __cplusplus
extern void* __cdecl operator new( size_t nSize, LPCSTR pszFile, const int iLine );
#define new new( __FILE__, __LINE__ )
#endif

#endif // _NO_DBGMEMORY_REDEFINITIONS

// use these macros
#define TrcLocalAlloc( _uFlags, _uBytes )   \
    _TrcLocalAlloc( _uFlags, _uBytes, __FILE__, __LINE__ )

#define TrcStrDup( _pSrc )   \
    _TrcStrDup( (LPTSTR)_pSrc, (LPCSTR)__FILE__, (const int)__LINE__ )

#define TrcLocalFree( _hMem )   \
    _TrcLocalFree( _hMem )

#define DbgAddToMemList( _pv ) \
{                              \
    if ( _pv )                 \
        add_to_memlist( 0, _pv, (UINT)LocalSize( _pv ), DBGMEM_TRACED, __FILE__, __LINE__ ); \
}

#define DbgRemoveFromMemList( _pv ) \
    remove_from_memlist( _pv )

#else // DEBUG

#define add_to_memlist(p)       (0)
#define remove_from_memlist(p)  (0)
#define remove_from_thread_memlist(p,v) (0)

#define TrcLocalAlloc( _uFlags, _uBytes )   \
    LocalAlloc( _uFlags, _uBytes )

#define TrcStrDup( _pSrc )   \
    StrDup( _pSrc )

#define TrcLocalFree( _hMem )   \
    LocalFree( _hMem )

#define DbgAddToMemList( _pv )      // NOP
#define DbgRemoveFromMemList( _pv ) // NOP

#endif // DEBUG

#endif // _DBGMEMORY_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\desktray.h ===
#ifndef _DESKTRAY_H_
#define _DESKTRAY_H_

#undef  INTERFACE
#define INTERFACE   IDeskTray

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

DECLARE_INTERFACE_(IDeskTray, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDeskTray methods ***
    STDMETHOD_(UINT, AppBarGetState)(THIS) PURE;
    STDMETHOD(GetTrayWindow)(THIS_ HWND* phwndTray) PURE;
    STDMETHOD(SetDesktopWindow)(THIS_ HWND hwndDesktop) PURE;

    // WARNING!  BEFORE CALLING THE SetVar METHOD YOU MUST DETECT
    // THE EXPLORER VERSION BECAUSE IE 4.00 WILL CRASH IF YOU TRY
    // TO CALL IT

    STDMETHOD(SetVar)(THIS_ int var, DWORD value) PURE;
};

#define SVTRAY_EXITEXPLORER     0   // g_fExitExplorer

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif // _DESKTRAY_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\debug.h ===
//====== Assertion/Debug output APIs =================================

#include <platform.h> // for __endexcept

#if defined(DECLARE_DEBUG) && defined(DEBUG)

//
// Declare module-specific debug strings
//
//   When including this header in your private header file, do not
//   define DECLARE_DEBUG.  But do define DECLARE_DEBUG in one of the
//   source files in your project, and then include this header file.
//
//   You may also define the following:
//
//      SZ_DEBUGINI     - the .ini file used to set debug flags
//      SZ_DEBUGSECTION - the section in the .ini file specific to
//                        the module component.
//      SZ_MODULE       - ansi version of the name of your module.
//
//

// (These are deliberately CHAR)
EXTERN_C const CHAR FAR c_szCcshellIniFile[] = SZ_DEBUGINI;
EXTERN_C const CHAR FAR c_szCcshellIniSecDebug[] = SZ_DEBUGSECTION;

EXTERN_C const WCHAR FAR c_wszTrace[] = L"t " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR FAR c_wszErrorDbg[] = L"err " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR FAR c_wszWarningDbg[] = L"wn " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR FAR c_wszAssertMsg[] = TEXTW(SZ_MODULE) L"  Assert: ";
EXTERN_C const WCHAR FAR c_wszAssertFailed[] = TEXTW(SZ_MODULE) L"  Assert %ls, line %d: (%ls)\r\n";
EXTERN_C const WCHAR FAR c_wszRip[] = TEXTW(SZ_MODULE) L"  RIP in %s at %s, line %d: (%s)\r\n";
EXTERN_C const WCHAR FAR c_wszRipNoFn[] = TEXTW(SZ_MODULE) L"  RIP at %s, line %d: (%s)\r\n";

// (These are deliberately CHAR)
EXTERN_C const CHAR  FAR c_szTrace[] = "t " SZ_MODULE "  ";
EXTERN_C const CHAR  FAR c_szErrorDbg[] = "err " SZ_MODULE "  ";
EXTERN_C const CHAR  FAR c_szWarningDbg[] = "wn " SZ_MODULE "  ";
EXTERN_C const CHAR  FAR c_szAssertMsg[] = SZ_MODULE "  Assert: ";
EXTERN_C const CHAR  FAR c_szAssertFailed[] = SZ_MODULE "  Assert %s, line %d: (%s)\r\n";
EXTERN_C const CHAR  FAR c_szRip[] = SZ_MODULE "  RIP in %s at %s, line %d: (%s)\r\n";
EXTERN_C const CHAR  FAR c_szRipNoFn[] = SZ_MODULE "  RIP at %s, line %d: (%s)\r\n";
EXTERN_C const CHAR  FAR c_szRipMsg[] = SZ_MODULE "  RIP: ";

#endif  // DECLARE_DEBUG && DEBUG

#if defined(DECLARE_DEBUG) && defined(PRODUCT_PROF)
EXTERN_C const CHAR FAR c_szCcshellIniFile[] = SZ_DEBUGINI;
EXTERN_C const CHAR FAR c_szCcshellIniSecDebug[] = SZ_DEBUGSECTION;
#endif



#ifdef __cplusplus
extern "C" {
#endif

#if !defined(DECLARE_DEBUG)

//
// Debug macros and validation code
//

#if !defined(UNIX) || (defined(UNIX) && !defined(NOSHELLDEBUG))

// Undefine the macros that we define in case some other header
// might have tried defining these commonly-named macros.
#undef Assert
#undef AssertE
#undef AssertMsg
#undef AssertStrLen
#undef DebugMsg
#undef FullDebugMsg
#undef ASSERT
#undef EVAL
#undef ASSERTMSG            // catch people's typos
#undef DBEXEC

#ifdef _ATL_NO_DEBUG_CRT
#undef _ASSERTE             // we substitute this ATL macro
#endif

#endif // !UNIX


// Access these globals to determine which debug flags are set.
// These globals are modified by CcshellGetDebugFlags(), which
// reads an .ini file and sets the appropriate flags.
//
//   g_dwDumpFlags  - bits are application specific.  Typically 
//                    used for dumping structures.
//   g_dwBreakFlags - uses BF_* flags.  The remaining bits are
//                    application specific.  Used to determine
//                    when to break into the debugger.
//   g_dwTraceFlags - uses TF_* flags.  The remaining bits are
//                    application specific.  Used to display
//                    debug trace messages.
//   g_dwFuncTraceFlags - bits are application specific.  When
//                    TF_FUNC is set, CcshellFuncMsg uses this
//                    value to determine which function traces
//                    to display.
//   g_dwProtoype   - bits are application specific.  Use it for
//                    anything.
//   g_dwProfileCAP - bits are application specific. Used to
//                    control ICECAP profiling. 
//

extern DWORD g_dwDumpFlags;
extern DWORD g_dwBreakFlags;
extern DWORD g_dwTraceFlags;
#ifdef DEBUG
extern DWORD g_dwPrototype;
#else
#define g_dwPrototype   0
#endif
extern DWORD g_dwFuncTraceFlags;

#if defined(DEBUG) || defined(PRODUCT_PROF)
BOOL CcshellGetDebugFlags(void);
#else
#define CcshellGetDebugFlags()  0
#endif

// Break flags for g_dwBreakFlags
#define BF_ASSERT           0x00000001      // Break on assertions
#define BF_ONAPIENTER       0x00000002      // Break on entering an API
#define BF_ONERRORMSG       0x00000004      // Break on TF_ERROR
#define BF_ONWARNMSG        0x00000008      // Break on TF_WARNING
#define BF_THR              0x00000100      // Break when THR() receives a failure
#define BF_RIP              0x00000200      // Break on RIPs

// Trace flags for g_dwTraceFlags
#define TF_ALWAYS           0xFFFFFFFF
#define TF_NEVER            0x00000000
#define TF_WARNING          0x00000001
#define TF_ERROR            0x00000002
#define TF_GENERAL          0x00000004      // Standard messages
#define TF_FUNC             0x00000008      // Trace function calls
#define TF_ATL              0x00000008      // Since TF_FUNC is so-little used, I'm overloading this bit
// (Upper 28 bits reserved for custom use per-module)

// Old, archaic debug flags.  
// BUGBUG (scotth): the following flags will be phased out over time.
#ifdef DM_TRACE
#undef DM_TRACE
#undef DM_WARNING
#undef DM_ERROR
#endif
#define DM_TRACE            TF_GENERAL      // OBSOLETE Trace messages
#define DM_WARNING          TF_WARNING      // OBSOLETE Warning
#define DM_ERROR            TF_ERROR        // OBSOLETE Error


// Use this macro to declare message text that will be placed
// in the CODE segment (useful if DS is getting full)
//
// Ex: DEBUGTEXT(szMsg, "Invalid whatever: %d");
//
#define DEBUGTEXT(sz, msg)      /* ;Internal */ \
    static const TCHAR sz[] = msg


#ifndef NOSHELLDEBUG    // Others have own versions of these.

#ifdef DEBUG

#ifdef _X86_
// Use int 3 so we stop immediately in the source
#define DEBUG_BREAK        do { _try { _asm int 3 } _except (EXCEPTION_EXECUTE_HANDLER) {;} } while (0)
#else
#define DEBUG_BREAK        do { _try { DebugBreak(); } _except (EXCEPTION_EXECUTE_HANDLER) {;} __endexcept } while (0)
#endif

// Prototypes for debug functions

void CcshellStackEnter(void);
void CcshellStackLeave(void);

void CDECL CcshellFuncMsgW(DWORD mask, LPCSTR pszMsg, ...);
void CDECL CcshellFuncMsgA(DWORD mask, LPCSTR pszMsg, ...);

void CDECL _AssertMsgA(BOOL f, LPCSTR pszMsg, ...);
void CDECL _AssertMsgW(BOOL f, LPCWSTR pszMsg, ...);

void _AssertStrLenA(LPCSTR pszStr, int iLen);
void _AssertStrLenW(LPCWSTR pwzStr, int iLen);

#ifdef UNICODE
#define CcshellFuncMsg          CcshellFuncMsgW
#define CcshellAssertMsg        CcshellAssertMsgW
#define _AssertMsg              _AssertMsgW
#define _AssertStrLen           _AssertStrLenW
#else
#define CcshellFuncMsg          CcshellFuncMsgA
#define CcshellAssertMsg        CcshellAssertMsgA
#define _AssertMsg              _AssertMsgA
#define _AssertStrLen           _AssertStrLenA
#endif

#endif // DEBUG



// ASSERT(f)
//
//   Generates a "Assert file.c, line x (eval)" message if f is NOT true.
//
//   Use ASSERT() to check for logic invariance.  These are typically considered
//   fatal problems, and falls into the 'this should never ever happen' 
//   category.
//
//   Do *not* use ASSERT() to verify successful API calls if the APIs can 
//   legitimately fail due to low resources.  For example, LocalAlloc can 
//   legally fail, so you shouldn't assert that it will never fail.
//
//   The BF_ASSERT bit in g_dwBreakFlags governs whether the function 
//   performs a DebugBreak().
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       spew and break
//      Full debug builds:  spew and break
//
#ifdef DEBUG

BOOL CcshellAssertFailedA(LPCSTR szFile, int line, LPCSTR pszEval, BOOL bBreakInside);
BOOL CcshellAssertFailedW(LPCWSTR szFile, int line, LPCWSTR pwszEval, BOOL bBreakInside);
#ifdef UNICODE
#define CcshellAssertFailed     CcshellAssertFailedW
#else
#define CcshellAssertFailed     CcshellAssertFailedA
#endif

#define ASSERT(f)                                 \
    {                                             \
        DEBUGTEXT(szFile, TEXT(__FILE__));              \
        if (!(f) && CcshellAssertFailed(szFile, __LINE__, TEXT(#f), FALSE)) \
            DEBUG_BREAK;       \
    }

// The old Win95 code used to use "Assert()".  We discourage the use
// of this macro now because it is not msdev-friendly.
#ifdef DISALLOW_Assert
#define Assert(f)        Dont_use_Assert___Use_ASSERT
#else
#define Assert(f)           ASSERT(f)
#endif

#else  // DEBUG

#define ASSERT(f)
#define Assert(f)

#endif // DEBUG



// ASSERTMSG(f, szFmt, args...)
//
//   Behaves like ASSERT, except it prints the wsprintf-formatted message
//   instead of the file and line number.
//
//   The sz parameter is always ANSI; AssertMsg correctly converts it
//   to unicode if necessary.  This is so you don't have to wrap your
//   debug strings with TEXT().
//
//   The BF_ASSERT bit in g_dwBreakFlags governs whether the function 
//   performs a DebugBreak().
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       spew and break
//      Full debug builds:  spew and break
//
#ifdef DEBUG

void CDECL CcshellAssertMsgW(BOOL bAssert, LPCSTR pszMsg, ...);
void CDECL CcshellAssertMsgA(BOOL bAssert, LPCSTR pszMsg, ...);
#ifdef UNICODE
#define CcshellAssertMsg        CcshellAssertMsgW
#else
#define CcshellAssertMsg        CcshellAssertMsgA
#endif

#define ASSERTMSG           CcshellAssertMsg

#else  // DEBUG

#define ASSERTMSG       1 ? (void)0 : (void)

#endif // DEBUG



// EVAL(f)
//
//   Behaves like ASSERT().  Evaluates the expression (f).  The expression 
//   is always evaluated, even in retail builds.  But the macro only asserts 
//   in the debug build.  This macro may be used on logical expressions, eg:
//
//          if (EVAL(exp))
//              // do something
//
//   Do *not* use EVAL() to verify successful API calls if the APIs can 
//   legitimately fail due to low resources.  For example, LocalAlloc can 
//   legally fail, so you shouldn't assert that it will never fail.
//
//   The BF_ASSERT bit in g_dwBreakFlags governs whether the function 
//   performs a DebugBreak().
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       spew and break
//      Full debug builds:  spew and break
//
#ifdef DEBUG

#define EVAL(exp)   \
    ((exp) || (CcshellAssertFailed(TEXT(__FILE__), __LINE__, TEXT(#exp), TRUE), 0))

#else  // DEBUG

#define EVAL(exp)       ((exp) != 0)

#endif // DEBUG



// RIP(f)
// 
//   Generates a "RIP at file.c, line x (eval)" message if f is NOT true.
//   
//   Use RIP() to perform parameter validation, especially when you
//   know the function or method may be called by a 3rd party app.
//   Typically, RIPs are used to indicate the caller passed in an invalid 
//   parameter, so the problem is really not in the code itself.
//
//   Do *not* use RIP() to verify successful API calls if the APIs can 
//   legitimately fail due to low resources.  For example, LocalAlloc can 
//   legally fail, so you shouldn't assert that it will never fail.
//
//   RIP performs a debugbreak only in the following processes:
//
//      explore.exe
//      iexplore.exe
//      rundll32.exe
//      welcome.exe
//
//   In any other process, this just spews the debug message, but doesn't stop.
//   
//   Setting the BF_RIP bit in g_dwBreakFlags will cause the macro to perform 
//   a DebugBreak() even in non-shell processes.
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       spew (other processes), spew and break (shell processes)
//      Full debug builds:  spew (other processes), spew and break (shell processes)
//
#ifdef DEBUG

BOOL CcshellRipA(LPCSTR pszFile, int line, LPCSTR pszEval, BOOL bBreakInside);
BOOL CcshellRipW(LPCWSTR pszFile, int line, LPCWSTR pwszEval, BOOL bBreakInside);
BOOL CDECL CcshellRipMsgA(BOOL bRip, LPCSTR pszMsg, ...);
BOOL CDECL CcshellRipMsgW(BOOL bRip, LPCSTR pszMsg, ...);


#ifdef UNICODE
#define CcshellRip      CcshellRipW
#define CcshellRipMsg   CcshellRipMsgW
#else
#define CcshellRip      CcshellRipA
#define CcshellRipMsg   CcshellRipMsgA
#endif

#define RIP(f)                                                                                              \
    {                                                                                                       \
        DEBUGTEXT(szFile, TEXT(__FILE__));                                                                  \
        if (!(f) && CcshellRip(szFile, __LINE__, TEXT(#f), FALSE))                                          \
        {                                                                                                   \
            DEBUG_BREAK;                                                                                    \
        }                                                                                                   \
    }                                                                                                       \

#define RIPMSG          CcshellRipMsg

#else  // DEBUG

#define RIP(f)
#define RIPMSG          1 ? (void)0 : (void)

#endif // DEBUG



// TraceMsg(dwMask, sz, args...) 
//
//   Generate wsprintf-formatted message using the specified trace dwMask.
//   dwMask may be one of the predefined bits:
//
//      TF_ERROR    - display "err <MODULE>  <string>"
//      TF_WARNING  - display "wn  <MODULE>  <string>"
//      TF_GENERAL  - display "t   <MODULE>  <string>"
//      TF_ALWAYS   - display "t   <MODULE>  <string>" regardless of g_dwTraceFlags.
//
//   or it may be a custom bit (any of the upper 28 bits).
//
//   The g_dwTraceFlags global governs whether the message is displayed (based
//   upon the dwMask parameter).
//
//   The sz parameter is always ANSI; TraceMsg correctly converts it
//   to unicode if necessary.  This is so you don't have to wrap your
//   debug strings with TEXT().
//
//   In addition to squirting the trace message, you may optionally cause
//   the trace message to stop if you need to trace down the source of
//   an error.  The BF_ONERRORMSG and BF_ONWARNMSG bits may be set in
//   g_dwBreakFlags to make TraceMsg stop when a TF_ERROR or TF_WARNING
//   message is displayed.  But typically these bits are disabled.
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       only TF_ALWAYS and TF_ERROR messages spew
//      Full debug builds:  spew
//
#ifdef DEBUG

void CDECL CcshellDebugMsgW(DWORD mask, LPCSTR pszMsg, ...);
void CDECL CcshellDebugMsgA(DWORD mask, LPCSTR pszMsg, ...);
void CDECL _DebugMsgA(DWORD flag, LPCSTR psz, ...);
void CDECL _DebugMsgW(DWORD flag, LPCWSTR psz, ...);
#ifdef UNICODE
#define CcshellDebugMsg         CcshellDebugMsgW
#define _DebugMsg               _DebugMsgW
#else
#define CcshellDebugMsg         CcshellDebugMsgA
#define _DebugMsg               _DebugMsgA
#endif

#define TraceMsgW           CcshellDebugMsgW
#define TraceMsgA           CcshellDebugMsgA
#define TraceMsg            CcshellDebugMsg

// Use TraceMsg instead of DebugMsg.  DebugMsg is obsolete.
#ifdef DISALLOW_DebugMsg
#define DebugMsg            Dont_use_DebugMsg___Use_TraceMsg
#else
#define DebugMsg            _DebugMsg
#endif

#else  // DEBUG

#define TraceMsgA       1 ? (void)0 : (void)
#define TraceMsgW       1 ? (void)0 : (void)
#define TraceMsg        1 ? (void)0 : (void)
#define DebugMsg        1 ? (void)0 : (void)

#endif // DEBUG



// THR(pfn)
// TBOOL(pfn)
// TINT(pfn)
// TPTR(pfn)
// TW32(pfn)
// 
//   These macros are useful to trace failed calls to functions that return
//   HRESULTs, BOOLs, ints, or pointers.  An example use of this is:
//
//   {
//       ...
//       hres = THR(CoCreateInstance(CLSID_Bar, NULL, CLSCTX_INPROC_SERVER, 
//                                   IID_IBar, (LPVOID*)&pbar));
//       if (SUCCEEDED(hres))
//       ...
//   }
//
//   If CoCreateInstance failed, you would see spew similar to:
//
//    err MODULE  THR: Failure of "CoCreateInstance(CLSID_Bar, NULL, CLSCTX_INPROC_SERVER, IID_IBar, (LPVOID*)&pbar)" at foo.cpp, line 100  (0x80004005)
//
//   THR keys off of the failure code of the hresult.
//   TBOOL considers FALSE to be a failure case.
//   TINT considers -1 to be a failure case.
//   TPTR considers NULL to be a failure case.
//   TW32 keys off the failure code of the Win32 error code.
//
//   Set the BF_THR bit in g_dwBreakFlags to stop when these macros see a failure.
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       nothing
//      Full debug builds:  spew on error
//
#ifdef DEBUG

EXTERN_C HRESULT TraceHR(HRESULT hrTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);
EXTERN_C BOOL    TraceBool(BOOL bTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);
EXTERN_C int     TraceInt(int iTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);
EXTERN_C LPVOID  TracePtr(LPVOID pvTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);
EXTERN_C DWORD   TraceWin32(DWORD dwTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);

#define THR(x)      (TraceHR((x), #x, __FILE__, __LINE__))
#define TBOOL(x)    (TraceBool((x), #x, __FILE__, __LINE__))
#define TINT(x)     (TraceInt((x), #x, __FILE__, __LINE__))
#define TPTR(x)     (TracePtr((x), #x, __FILE__, __LINE__))
#define TW32(x)     (TraceWin32((x), #x, __FILE__, __LINE__))

#else  // DEBUG

#define THR(x)          (x)
#define TBOOL(x)        (x)
#define TINT(x)         (x)
#define TPTR(x)         (x)
#define TW32(x)         (x)

#endif // DEBUG



// DBEXEC(flg, expr)
//
//   under DEBUG, does "if (flg) expr;" (w/ the usual safe syntax)
//   under !DEBUG, does nothing (and does not evaluate either of its args)
//
#ifdef DEBUG

#define DBEXEC(flg, expr)    ((flg) ? (expr) : 0)

#else  // DEBUG

#define DBEXEC(flg, expr)   /*NOTHING*/

#endif // DEBUG


// string and buffer whacking functions
//
#ifdef DEBUG

EXTERN_C void DEBUGWhackPathBufferA(LPSTR psz, UINT cch);
EXTERN_C void DEBUGWhackPathBufferW(LPWSTR psz, UINT cch);
EXTERN_C void DEBUGWhackPathStringA(LPSTR psz, UINT cch);
EXTERN_C void DEBUGWhackPathStringW(LPWSTR psz, UINT cch);

#else // DEBUG

#define DEBUGWhackPathBufferA(psz, cch)
#define DEBUGWhackPathBufferW(psz, cch)
#define DEBUGWhackPathStringA(psz, cch)
#define DEBUGWhackPathStringW(psz, cch)

#endif // DEBUG

#ifdef UNICODE
#define DEBUGWhackPathBuffer DEBUGWhackPathBufferW
#define DEBUGWhackPathString DEBUGWhackPathStringW
#else
#define DEBUGWhackPathBuffer DEBUGWhackPathBufferA
#define DEBUGWhackPathString DEBUGWhackPathStringA
#endif


// Some trickery to map ATL debug macros to ours, so ATL code that stops
// or spews in our code will look like the rest of our squirties.

#ifdef DEBUG

#ifdef _ATL_NO_DEBUG_CRT
// ATL uses _ASSERTE.  Map it to ours.
#define _ASSERTE(f)         ASSERT(f)

// We map ATLTRACE macros to our functions
void _cdecl ShellAtlTraceA(LPCSTR lpszFormat, ...);
void _cdecl ShellAtlTraceW(LPCWSTR lpszFormat, ...);
#ifdef UNICODE
#define ShellAtlTrace   ShellAtlTraceW
#else
#define ShellAtlTrace   ShellAtlTraceA
#endif
// These are turned off because they normally don't give
// feedback of error cases and so many fire that they
// swamp out other useful debug spew.
//#define ATLTRACE            ShellAtlTrace
#endif

#else  // DEBUG

#ifdef _ATL_NO_DEBUG_CRT
// ATL uses _ASSERTE.  Map it to ours.
#define _ASSERTE(f)

// We map ATLTRACE macros to our functions
#define ATLTRACE            1 ? (void)0 : (void)
#endif

#endif // DEBUG


// ------ Stay away from these macros below ----------
// BUGBUG (scotth):  remove these by 8/15/98.  They should not be used anymore. 
#ifdef DEBUG

#define AssertE(f)          ASSERT(f)
#define AssertMsg           _AssertMsg
#define AssertStrLen        _AssertStrLen
#define AssertStrLenA       _AssertStrLenA
#define AssertStrLenW       _AssertStrLenW

#ifdef FULL_DEBUG
#define FullDebugMsg        _DebugMsg
#else
#define FullDebugMsg        1 ? (void)0 : (void)
#endif

#define ASSERT_MSGW         CcshellAssertMsgW
#define ASSERT_MSGA         CcshellAssertMsgA
#define ASSERT_MSG          CcshellAssertMsg
#else  // DEBUG

#define AssertE(f)      (f)
#define AssertMsg       1 ? (void)0 : (void)
#define AssertStrLen(lpStr, iLen)
#define FullDebugMsg    1 ? (void)0 : (void)
#define ASSERT_MSGA     1 ? (void)0 : (void)
#define ASSERT_MSGW     1 ? (void)0 : (void)
#define ASSERT_MSG      1 ? (void)0 : (void)

#endif // DEBUG
// ------ Stay away from these macros above ----------



// It's necessary to find when classes that were designed to be single threaded are used
// across threads so they can be fixed to be multithreaded.  These asserts will point
// out such cases.
#ifdef DEBUG
#define ASSERT_SINGLE_THREADED              AssertMsg(_dwThreadIDForSingleThreadedAssert == GetCurrentThreadId(), TEXT("MULTI-THREADED BUG: This class is being used by more than one thread, but it's not thread safe."))
#define INIT_SINGLE_THREADED_ASSERT         _dwThreadIDForSingleThreadedAssert = GetCurrentThreadId();
#define SINGLE_THREADED_MEMBER_VARIABLE     DWORD _dwThreadIDForSingleThreadedAssert;
#else // DEBUG
#define ASSERT_SINGLE_THREADED              NULL;
#define INIT_SINGLE_THREADED_ASSERT         NULL;
#define SINGLE_THREADED_MEMBER_VARIABLE     
#endif // DEBUG



#ifdef DEBUG

#define Dbg_SafeStrA(psz)   (SAFECAST(psz, LPCSTR), (psz) ? (psz) : "NULL string")
#define Dbg_SafeStrW(psz)   (SAFECAST(psz, LPCWSTR), (psz) ? (psz) : L"NULL string")
#ifdef UNICODE
#define Dbg_SafeStr         Dbg_SafeStrW
#else
#define Dbg_SafeStr         Dbg_SafeStrA
#endif

#define FUNC_MSG            CcshellFuncMsg


// Helpful macro for mapping manifest constants to strings.  Assumes
// return string is pcsz.  You can use this macro in this fashion:
//
// LPCSTR Dbg_GetFoo(FOO foo)
// {
//    LPCTSTR pcsz = TEXT("Unknown <foo>");
//    switch (foo)
//    {
//    STRING_CASE(FOOVALUE1);
//    STRING_CASE(FOOVALUE2);
//    ...
//    }
//    return pcsz;
// }
//
#define STRING_CASE(val)               case val: pcsz = TEXT(#val); break


// Debug function enter


// DBG_ENTER(flag, fn)  -- Generates a function entry debug spew for
//                          a function
//
#define DBG_ENTER(flagFTF, fn)                  \
        (FUNC_MSG(flagFTF, " > " #fn "()"), \
         CcshellStackEnter())

// DBG_ENTER_TYPE(flag, fn, dw, pfnStrFromType)  -- Generates a function entry debug
//                          spew for functions that accept <type>.
//
#define DBG_ENTER_TYPE(flagFTF, fn, dw, pfnStrFromType)                   \
        (FUNC_MSG(flagFTF, " < " #fn "(..., %s, ...)", (LPCTSTR)pfnStrFromType(dw)), \
         CcshellStackEnter())

// DBG_ENTER_SZ(flag, fn, sz)  -- Generates a function entry debug spew for
//                          a function that accepts a string as one of its
//                          parameters.
//
#define DBG_ENTER_SZ(flagFTF, fn, sz)                  \
        (FUNC_MSG(flagFTF, " > " #fn "(..., \"%s\",...)", Dbg_SafeStr(sz)), \
         CcshellStackEnter())


// Debug function exit


// DBG_EXIT(flag, fn)  -- Generates a function exit debug spew
//
#define DBG_EXIT(flagFTF, fn)                              \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "()"))

// DBG_EXIT_TYPE(flag, fn, dw, pfnStrFromType)  -- Generates a function exit debug
//                          spew for functions that return <type>.
//
#define DBG_EXIT_TYPE(flagFTF, fn, dw, pfnStrFromType)                   \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %s", (LPCTSTR)pfnStrFromType(dw)))

// DBG_EXIT_INT(flag, fn, us)  -- Generates a function exit debug spew for
//                          functions that return an INT.
//
#define DBG_EXIT_INT(flagFTF, fn, n)                       \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %d", (int)(n)))

// DBG_EXIT_BOOL(flag, fn, b)  -- Generates a function exit debug spew for
//                          functions that return a boolean.
//
#define DBG_EXIT_BOOL(flagFTF, fn, b)                      \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %s", (b) ? (LPTSTR)TEXT("TRUE") : (LPTSTR)TEXT("FALSE")))

// DBG_EXIT_UL(flag, fn, ul)  -- Generates a function exit debug spew for
//                          functions that return a ULONG.
//
#ifdef _WIN64
#define DBG_EXIT_UL(flagFTF, fn, ul)                   \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %#016I64x", (ULONG_PTR)(ul)))
#else
#define DBG_EXIT_UL(flagFTF, fn, ul)                   \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %#08lx", (ULONG)(ul)))
#endif // _WIN64

#define DBG_EXIT_DWORD      DBG_EXIT_UL

// DBG_EXIT_HRES(flag, fn, hres)  -- Generates a function exit debug spew for
//                          functions that return an HRESULT.
//
#define DBG_EXIT_HRES(flagFTF, fn, hres)     DBG_EXIT_TYPE(flagFTF, fn, hres, Dbg_GetHRESULTName)



#else   // DEBUG


#define Dbg_SafeStr     1 ? (void)0 : (void)

#define FUNC_MSG        1 ? (void)0 : (void)


#define DBG_ENTER(flagFTF, fn)
#define DBG_ENTER_TYPE(flagFTF, fn, dw, pfn)
#define DBG_ENTER_SZ(flagFTF, fn, sz)
#define DBG_EXIT(flagFTF, fn)
#define DBG_EXIT_INT(flagFTF, fn, n)
#define DBG_EXIT_BOOL(flagFTF, fn, b)
#define DBG_EXIT_UL(flagFTF, fn, ul)
#define DBG_EXIT_DWORD      DBG_EXIT_UL
#define DBG_EXIT_TYPE(flagFTF, fn, dw, pfn)
#define DBG_EXIT_HRES(flagFTF, fn, hres)

#endif  // DEBUG



// COMPILETIME_ASSERT(f)
//
//  Generates a build break at compile time if the constant expression
//  is not true.  Unlike the "#if" compile-time directive, the expression
//  in COMPILETIME_ASSERT() is allowed to use "sizeof".
//
//  Compiler magic!  If the expression "f" is FALSE, then you get the
//  compiler error "Duplicate case expression in switch statement".
//
#define COMPILETIME_ASSERT(f) switch (0) case 0: case f:


#else  // NOSHELLDEBUG

#ifdef UNIX
#include <crtdbg.h>
#define ASSERT(f)	_ASSERT(f)
#include <mainwin.h>
#define TraceMsg(type, sformat)  DebugMessage(0, sformat)
#define TraceMSG(type, sformat, args)  DebugMessage(0, sformat, args)
#endif

#endif  // NOSHELLDEBUG


// 
// Debug dump helper functions
//

#ifdef DEBUG

LPCTSTR Dbg_GetCFName(UINT ucf);
LPCTSTR Dbg_GetHRESULTName(HRESULT hr);
LPCTSTR Dbg_GetREFIIDName(REFIID riid);
LPCTSTR Dbg_GetVTName(VARTYPE vt);

#else

#define Dbg_GetCFName(ucf)          (void)0
#define Dbg_GetHRESULTName(hr)      (void)0
#define Dbg_GetREFIIDName(riid)     (void)0
#define Dbg_GetVTName(vt)           (void)0

#endif // DEBUG

// I'm a lazy typist...
#define Dbg_GetHRESULT              Dbg_GetHRESULTName

// Parameter validation macros
#include "validate.h"

#endif // DECLARE_DEBUG

#ifdef PRODUCT_PROF 
int __stdcall StartCAP(void);	// start profiling
int __stdcall StopCAP(void);    // stop profiling until StartCAP
int __stdcall SuspendCAP(void); // suspend profiling until ResumeCAP
int __stdcall ResumeCAP(void);  // resume profiling
int __stdcall StartCAPAll(void);    // process-wide start profiling
int __stdcall StopCAPAll(void);     // process-wide stop profiling
int __stdcall SuspendCAPAll(void);  // process-wide suspend profiling
int __stdcall ResumeCAPAll(void);   // process-wide resume profiling
void __stdcall MarkCAP(long lMark);  // write mark to MEA
extern DWORD g_dwProfileCAP;
#else
#define StartCAP()      0
#define StopCAP()       0
#define SuspendCAP()    0
#define ResumeCAP()     0
#define StartCAPAll()   0
#define StopCAPAll()    0
#define SuspendCAPAll() 0
#define ResumeCAPAll()  0
#define MarkCAP(n)      0

#define g_dwProfileCAP  0
#endif

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\dldecl.h ===
#ifndef _DLDECL_H_
#define _DLDECL_H_

// Delay load declarations

// The following are defined to get the DECLSPEC_IMPORT stuff right.
// Since we have identically-named local functions that thunk to the
// real function, we need to correct the dll linkage.

#ifdef DL_OLEAUT32
#define _OLEAUT32_
#endif

#ifdef DL_OLE32
#define _OLE32_
#endif

#endif // _DLDECL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\dvocx.h ===
/*
** dvocx.h
**
** Private interface which DefView supports so OCs can get special information.
*/

#ifndef _DVOCX_H_
#define _DVOCX_H_


#endif // _DVOCX_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\filelist.h ===
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------

typedef struct
{
    DWORD dwAttribs;
    LPITEMIDLIST pidl;
    PSTR pszName;
} FILELIST_ITEM;
typedef FILELIST_ITEM *PFILELIST_ITEM;

typedef BOOL (*PFN_FOLDER_ENUM_CALLBACK)(LPSHELLFOLDER psf, LPITEMIDLIST pidlFolder, LPITEMIDLIST pidlItem, LPVOID pv);
BOOL Folder_Enum(LPITEMIDLIST pidlFolder, PFN_FOLDER_ENUM_CALLBACK pfn, PVOID pv);

void FileList_Destroy(HDPA hdpa);
BOOL FileList_Create(LPITEMIDLIST pidlFolder, HDPA *phdpa, PINT pcItems);
BOOL FileList_Sort(HDPA hdpaFLI);

BOOL FileList_CreateItem(IShellFolder *psf, LPITEMIDLIST pidl, PFILELIST_ITEM *ppfli);
void FileList_DestroyItem(PFILELIST_ITEM pfli);
BOOL Sz_AllocCopy(LPCTSTR pszSrc, LPSTR *ppszDst);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\desktopp.h ===
#ifndef _desktop_h
#define _desktop_h

#include <desktray.h>

// REVIEW: does not seem to be used...
// #define DTM_SIZEDESKTOP             (WM_USER + 75)
// #define DTM_EXITWINDOWS             (WM_USER + 78)

#define DTM_THREADEXIT              (WM_USER + 76)
#define DTM_SAVESTATE               (WM_USER + 77)
#define DTM_SHELLSERVICEOBJECTS     (WM_USER + 79)
#define DTM_STARTWAIT               (WM_USER + 80)
#define DTM_ENDWAIT                 (WM_USER + 81)

#define DTM_RELEASEPROXYDESKTOP     (WM_USER + 82)

#define DTM_RAISE                       (WM_USER + 83)
#define DTRF_RAISE      0
#define DTRF_LOWER      1
#define DTRF_QUERY      2    // to avoid sending a message to a hung desktop, query passes hwndTray in wParam, and desktop send TRAY a TM_DESKTOPSTATE message

#define DTM_ADDREFPROXYDESKTOP      (WM_USER + 84)
#define DTM_CREATESAVEDWINDOWS      (WM_USER + 85)
#define DTM_ENUMBANDS               (WM_USER + 86)

#ifdef DEBUG
#define DTM_NEXTCTL                 (WM_USER + 87)
#endif
#define DTM_UIACTIVATEIO            (WM_USER + 88)
#define DTM_ONFOCUSCHANGEIS         (WM_USER + 89)

#define DTM_SETUPAPPRAN             (WM_USER + 90)  // NT 5 USER posts this message to us

// END OF IE 4.00 / 4.01 MESSAGES

// BEGINNING OF IE 5.00 MESSAGES

#define DTM_GETVIEWAREAS            (WM_USER + 91)  // View area is WorkArea minus toolbar areas.
#define DTM_DESKTOPCONTEXTMENU      (WM_USER + 92)
#define DTM_UPDATENOW               (WM_USER + 93)

#define DTM_QUERYHKCRCHANGED        (WM_USER + 94)  // ask the desktop if HKCR has changed

#define DTM_MAKEHTMLCHANGES         (WM_USER + 95)  // Make changes to desktop html using dynamic HTML


#define COF_NORMAL              0x00000000
#define COF_CREATENEWWINDOW     0x00000001      // "/N"
#define COF_USEOPENSETTINGS     0x00000002      // "/A"
#define COF_WAITFORPENDING      0x00000004      // Should wait for Pending
#define COF_EXPLORE             0x00000008      // "/E"
#define COF_NEWROOT             0x00000010      // "/ROOT"
#define COF_ROOTCLASS           0x00000020      // "/ROOT,<GUID>"
#define COF_SELECT              0x00000040      // "/SELECT"
#define COF_AUTOMATION          0x00000080      // The user is trying to use automation
#define COF_OPENMASK            0x000000FF
#define COF_NOTUSERDRIVEN       0x00000100      // Not user driven
#define COF_NOTRANSLATE         0x00000200      // Don't ILCombine(pidlRoot, pidl)
#define COF_INPROC              0x00000400      // not used
#define COF_CHANGEROOTOK        0x00000800      // Try Desktop root if not in our root
#define COF_NOUI                0x00001000      // Start background desktop only (no folder/explorer)
#define COF_SHDOCVWFORMAT       0x00002000      // indicates this struct has been converted to abide by shdocvw format. 
                                                // this flag is temporary until we rip out all the 
#define COF_NOFINDWINDOW        0x00004000      // Don't try to find the window
#define COF_HASHMONITOR         0x00008000      // pidlRoot in IETHREADPARAM struct contains an HMONITOR
#define COF_SHELLFOLDERWINDOW   0x01000000      // This is a folder window, don't append - Microsoft Internet... when no pidl...
#define COF_PARSEPATHW          0x02000000      // the NFI.pszPath needs to be parsed but it is UNICODE
#define COF_FIREEVENTONDDEREG   0x20000000      // Fire an event when DDE server is registered
#define COF_FIREEVENTONCLOSE    0x40000000      // Fire an event when browser window closes
#define COF_IEXPLORE            0x80000000

//  this is used by DTM_QUERYHKCRCHANGED and the OpenAs Dialog
//  because the OpenAs Dialog is always in a separate process,
//  and it needs to cache a cookie in the desktop for the DTM
//  the QHKCRID is passed as the wParam in the message.
typedef enum 
{
    QHKCRID_NONE = 0,
    QHKCRID_MIN = 1, 
    QHKCRID_OPENAS = QHKCRID_MIN,
    QHKCRID_VIEWMENUPOPUP,
    QHKCRID_MAX
} QHKCRID;

//  didnt add PARSEPATHA because only browseui adds it, and it is UNICODE
//  but might need it later...
#define COF_PARSEPATH      COF_PARSEPATHW

typedef struct
{
    LPSTR pszPath;
    LPITEMIDLIST pidl;

    UINT uFlags;                // COF_ bits, (shared with IETHREADPARAM.uFlags
    int nShow;
    HWND hwndCaller;
    DWORD dwHotKey;
    LPITEMIDLIST pidlSelect;    // Only used if COF_SELECT

    LPSTR pszRoot;              // Only used for Parse_CmdLine
    LPITEMIDLIST pidlRoot;      // Only used if COF_NEWROOT
    CLSID clsid;                // Only used if COF_NEWROOT

    CLSID clsidInProc;          // Only used if COF_INPROC
} NEWFOLDERINFO, *PNEWFOLDERINFO;

STDAPI_(HANDLE) SHCreateDesktop(IDeskTray* pdtray);
STDAPI_(BOOL) CreateFromDesktop(PNEWFOLDERINFO pfi);
STDAPI_(BOOL) SHCreateFromDesktop(PNEWFOLDERINFO pfi);
STDAPI_(BOOL) SHDesktopMessageLoop(HANDLE hDesktop);
STDAPI_(BOOL) SHExplorerParseCmdLine(PNEWFOLDERINFO pfi);

// for the desktop to handle DDE
#define IDT_DDETIMEOUT      1
STDAPI_(LRESULT) DDEHandleMsgs(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
STDAPI_(void) DDEHandleTimeout(HWND hwnd);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\filetype.h ===
#ifndef _INC_FILETYPE_
#define _INC_FILETYPE_


// File Type Attributes key's bitmap values (HKEY_CLASSES_ROOT\filetype,Attributes)
#define FTA_Exclude             0x00000001 //  1. used to exclude types like drvfile
#define FTA_Show                0x00000002 //  2. used to show types like folder that don't have associations
#define FTA_HasExtension        0x00000004 //  3. type has assoc extension
#define FTA_NoEdit              0x00000008 //  4. no editing of file type
#define FTA_NoRemove            0x00000010 //  5. no deling of the file type
#define FTA_NoNewVerb           0x00000020 //  6. no adding of verbs
#define FTA_NoEditVerb          0x00000040 //  7. no editing of predefined verbs
#define FTA_NoRemoveVerb        0x00000080 //  8. no deling of predefined verbs
#define FTA_NoEditDesc          0x00000100 //  9. no editing of file type description
#define FTA_NoEditIcon          0x00000200 // 10. no editing of doc icon
#define FTA_NoEditDflt          0x00000400 // 11. no changing of default verb
#define FTA_NoEditVerbCmd       0x00000800 // 12. no editing of the verbs command
#define FTA_NoEditVerbExe       0x00001000 // 13. no editing of the verbs exe
#define FTA_NoDDE               0x00002000 // 14. no editing of the DDE fields
#define FTA_ExtShellOpen        0x00004000 // 15. old style type: HKCR/.ext/shell/open/command
#define FTA_NoEditMIME          0x00008000 // 16. no editing of the Content Type or Default Extension fields
#define FTA_OpenIsSafe          0x00010000 // 17. the file class's open verb may be safely invoked for downloaded files
#define FTA_AlwaysUnsafe        0x00020000 // 18. don't allow the "Never ask me" checkbox to be enabled; File Type dialog still allows user to turn this off
#define FTA_AlwaysShowExt       0x00040000 // 19. always show the extension (even if the user has "hide extensions" displayed)
#define FTA_MigratedShowExt     0x00080000 // 20. has the old lame AlwaysShowExt reg key been migrated into the class flags yet?
#define FTA_NoRecentDocs        0x00100000 // 21. dont add this file type to the Recent Documents folder

#define FTAV_UserDefVerb        0x00000001 // 1. identifies verb as being user defined (!predefined)


//================================================================
// typedef's
//================================================================

typedef enum mimeflags
{

    MIME_FL_CONTENT_TYPES_ADDED   = 0x0001, // The Content Type combo box drop down has been filled with MIME types.

    /* flag combinations */

    ALL_MIME_FLAGS                = MIME_FL_CONTENT_TYPES_ADDED
} MIMEFLAGS;


#endif // _INC_FILETYPE_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\findhlp.h ===
// Help id's for Find File dialog box (shell.dll)

#define NO_HELP                        ((DWORD) -1) // Disables Help for a control

#define IDH_FINDFILENAME_NAME           2200
#define IDH_FINDFILENAME_LOOKIN         2201
#define IDH_FINDFILENAME_BROWSE         2202
#define IDH_FINDFILENAME_TOPLEVEL       2203
#define IDH_FINDFILENAME_FINDNOW        2204
#define IDH_FINDFILENAME_STOP           2205
#define IDH_FINDFILENAME_NEWSEARCH      2206
#define IDH_FINDFILECRIT_OFTYPE         2207
#define IDH_FINDFILECRIT_CONTTEXT       2208
#define IDH_FINDFILECRIT_SIZEIS         2209
#define IDH_FINDFILECRIT_K              2210
#define IDH_FINDFILEDATE_ALLFILES       2211
#define IDH_FINDFILEDATE_CREATEORMOD    2212
#define IDH_FINDFILEDATE_DAYS           2213
#define IDH_FINDFILEDATE_FROM           2214
#define IDH_FINDFILEDATE_MONTHS         2215
#define IDH_FINDFILEDATE_RANGE          2216
#define IDH_FINDFILEDATE_TO             2217
#define IDH_FINDCOMP_NAME               2218
#define IDH_FINDCOMP_LOOKIN             2220
#define IDH_FINDCOMP_BROWSE             2221
#define IDH_FINDFILENAME_STATUSSCREEN   2223
#define IDH_BROWSELIST                  2224
#define IDH_DISPLAY_FOLDER              2225
#define IDH_CREATE_NEW_FOLDER           2226
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\fldset.h ===
#ifndef FLDSET_H_
#define FLDSET_H_


//
// view priority values
//
// NOTE: left gaps so that we can add more later
//
#define VIEW_PRIORITY_RESTRICTED    0x00000070  // a shell restriction is in place that forces this view to be the one we use
#define VIEW_PRIORITY_CACHEHIT      0x00000050  // we have registry info for the view, so the user has been there before
#define VIEW_PRIORITY_STALECACHEHIT 0x00000045  // we have stale registry info for the view, so we fall back to the "all folders like this" default
#define VIEW_PRIORITY_SHELLEXT      0x00000040  // next we let the shell extension have its say
#define VIEW_PRIORITY_CACHEMISS     0x00000030  // if we have a cache miss, then we fall back to the "all folders like this" default
#define VIEW_PRIORITY_INHERIT       0x00000020  // then try to inherit the view from the previous window
#define VIEW_PRIORITY_DESPERATE     0x00000010  // just pick the last view that the window supports
#define VIEW_PRIORITY_NONE          0x00000000  // dont have a view yet

typedef struct CShellViews
{
    HDPA _dpaViews;
} CShellViews;

void CShellViews_Delete(CShellViews*);

typedef struct tagFolderSetData {
    FOLDERSETTINGS  _fs;
    SHELLVIEWID     _vidRestore;
    DWORD           _dwViewPriority; // one of the VIEW_PRIORITY_* from above
} FOLDERSETDATA, *LPFOLDERSETDATA;

typedef struct tagFolderSetDataBase {
    FOLDERSETDATA   _fld;
    CShellViews     _cViews;
    UINT            _iViewSet;
} FOLDERSETDATABASE, *LPFOLDERSETDATABASE;    
    

HRESULT FileCabinet_CreateViewWindow2(IShellBrowser* psb, FOLDERSETDATABASE* that, IShellView *psvNew,
    IShellView *psvOld, RECT *prcView, HWND *phWnd);
BOOL FileCabinet_GetDefaultViewID2(FOLDERSETDATABASE* that, SHELLVIEWID* pvid);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\fsmenu.h ===
#ifndef _FSMENU_H
#define _FSMENU_H
//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------

#include <objbase.h>

//
// Define API decoration for direct importing of DLL references.
//
#ifndef FSMENUAPI
#if !defined(_FSMENU_)
#define FSSTDAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define FSSTDAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#else
#define FSSTDAPI          STDAPI
#define FSSTDAPI_(type)   STDAPI_(type)
#endif
#endif // FSMENUAPI

#ifdef __cplusplus
extern "C" {
#endif


#define FMF_NONE            0x00000000
#define FMF_NOEMPTYITEM     0x00000001
#define FMF_INCLUDEFOLDERS  0x00000002
#define FMF_NOPROGRAMS      0x00000004
#define FMF_LARGEICONS      0x00000008
#define FMF_NOBREAK         0x00000010
#define FMF_NOABORT         0x00000020
#define FMF_DELAY_INVALID   0x00000040
#define FMF_RESTRICTHEIGHT  0x00000080   // Restrict height of menu to cyMax
#define FMF_TOOLTIPS        0x00000100   // Call the callback for tooltips
#define FMF_MOREITEMS       0x00000200   // Add a "more items" item
#define FMF_CANORDER        0x00000400   // Order of menu is determined by user
#define FMF_INHERITMASK     0x00000784   // Flags inherited in submenus ;Internal  

#define FMF_DIRTY           0x80000000   // Don't include this in the mask ;Internal

#define FMAI_SEPARATOR      0x00000001

typedef struct tagFMCBDATA
{
    HMENU           hmenu;
    int             iPos;
    LPCITEMIDLIST   pidlFolder;
    LPCITEMIDLIST   pidl;
    IShellFolder *  psf;
    LPVOID          pvHeader;
    UINT            idCmd;
} FMCBDATA;


// Message values for callback
typedef enum
{
    FMM_ADD         = 0,
    FMM_DELETEALL   = 1,
    FMM_REMOVE      = 2,
    FMM_GETTOOLTIP  = 3,
    FMM_GETMORESTRING = 4,
    FMM_GETSTREAM   = 5
} FMM;


typedef struct tagFMMORESTRING
{
    UINT    uID;                    // command ID for the "More" item
    TCHAR   szMoreString[128];      // display string for menu item
} FMMORESTRING, * PFMMORESTRING;


typedef HRESULT (CALLBACK *PFNFMCALLBACK)(FMM fmm, FMCBDATA * pdata, LPARAM lParam);

typedef struct tagFMGETSTREAM
{
    IStream * pstm;
} FMGETSTREAM, * PFMGETSTREAM;


// Structure for a filemenu
typedef struct tagFMDATA
{
    DWORD           cbSize;
    DWORD           dwMask;         // FMD_ flags

    OUT int         cItems;         // Returned

} FMDATA, * PFMDATA;

// Mask values for FMDATA
#define FMD_DEFAULT     0x00000000


FSSTDAPI            FileMenu_InitMenuPopupEx(HMENU hmenu, PFMDATA pfmdata);
FSSTDAPI_(BOOL)     FileMenu_InitMenuPopup(HMENU hmenu);

// Structure for a filemenu item
typedef struct tagFMITEM
{
    DWORD           cbSize;
    DWORD           dwMask;         // FMI_ mask flags
    DWORD           dwType;         // FMIT_ flags
    UINT            uID;            // Command ID of item
    UINT            uItem;          // Position of item in menu
    int             iImage;         // Image 
    LPVOID          pvData;         // Data
    HMENU           hmenuSub;
    UINT            cyItem;
    LPARAM          lParam;         // Application data
} FMITEM, * PFMITEM;

// Mask values for FMITEM
#define FMI_TYPE        0x00000001      // dwType field
#define FMI_ID          0x00000002      // uID field
#define FMI_ITEM        0x00000004      // uItem field
#define FMI_IMAGE       0x00000008      // iImage field
#define FMI_DATA        0x00000010      // pvData field
#define FMI_HMENU       0x00000020      // hmenuSub field
#define FMI_METRICS     0x00000040      // cyItem field
#define FMI_LPARAM      0x00000080      // lParam field

// Type flags for FMITEM.  Refers to, among other things,
// the type of pvData.
#define FMIT_STRING     0x00000001      // string
#define FMIT_SEPARATOR  0x00000002      // separator
#define FMIT_UNICODE    0x80000000      // any string values are unicode

FSSTDAPI            FileMenu_InsertItemEx(HMENU hmenu, UINT iPos, FMITEM const * pfmitem);
FSSTDAPI_(BOOL)     FileMenu_InsertItem(HMENU hmenu, LPTSTR psz, UINT id, int iImage, HMENU hmenuSub, UINT cyItem, UINT iPos);

FSSTDAPI            FileMenu_GetItemInfo(HMENU hmenu, UINT uItem, BOOL bByPos, FMITEM * pfmitem);
FSSTDAPI            FileMenu_GetLastSelectedItem(HMENU hmenu, HMENU * phmenu, UINT * puItem);

FSSTDAPI_(LRESULT)  FileMenu_DrawItem(HWND hwnd, DRAWITEMSTRUCT *lpdi);
FSSTDAPI_(LRESULT)  FileMenu_MeasureItem(HWND hwnd, MEASUREITEMSTRUCT *lpmi);
FSSTDAPI_(UINT)     FileMenu_DeleteAllItems(HMENU hmenu);
FSSTDAPI_(LRESULT)  FileMenu_HandleMenuChar(HMENU hmenu, TCHAR ch);
FSSTDAPI_(BOOL)     FileMenu_GetLastSelectedItemPidls(HMENU hmenu, LPITEMIDLIST *ppidlFolder, LPITEMIDLIST *ppidlItem);
FSSTDAPI_(HMENU)    FileMenu_FindSubMenuByPidl(HMENU hmenu, LPITEMIDLIST pidl);
FSSTDAPI_(void)     FileMenu_Invalidate(HMENU hmenu);
FSSTDAPI_(HMENU)    FileMenu_Create(COLORREF clr, int cxBmpGap, HBITMAP hbmp, int cySel, DWORD fmf);
FSSTDAPI_(BOOL)     FileMenu_AppendItem(HMENU hmenu, LPTSTR psz, UINT id, int iImage, HMENU hmenuSub, UINT cyItem);
FSSTDAPI_(BOOL)     FileMenu_TrackPopupMenuEx(HMENU hmenu, UINT Flags, int x, int y, HWND hwndOwner, LPTPMPARAMS lpTpm);
FSSTDAPI_(BOOL)     FileMenu_DeleteItemByCmd(HMENU hmenu, UINT id);
FSSTDAPI_(void)     FileMenu_Destroy(HMENU hmenu);
FSSTDAPI_(BOOL)     FileMenu_EnableItemByCmd(HMENU hmenu, UINT id, BOOL fEnable);
FSSTDAPI_(BOOL)     FileMenu_DeleteSeparator(HMENU hmenu);
FSSTDAPI_(BOOL)     FileMenu_DeleteMenuItemByFirstID(HMENU hmenu, UINT id);
FSSTDAPI_(DWORD)    FileMenu_GetItemExtent(HMENU hmenu, UINT iItem);
FSSTDAPI_(BOOL)     FileMenu_DeleteItemByIndex(HMENU hmenu, UINT iItem);
FSSTDAPI_(void)     FileMenu_AbortInitMenu(void);
FSSTDAPI_(BOOL)     FileMenu_IsFileMenu(HMENU hmenu);
FSSTDAPI_(BOOL)     FileMenu_CreateFromMenu(HMENU hmenu, COLORREF clr, int cxBmpGap, HBITMAP hbmp, int cySel, DWORD fmf);
FSSTDAPI_(BOOL)     FileMenu_InsertSeparator(HMENU hmenu, UINT iPos);
FSSTDAPI_(BOOL)     FileMenu_GetPidl(HMENU hmenu, UINT iPos, LPITEMIDLIST *ppidl);
FSSTDAPI_(UINT)     FileMenu_AppendFilesForPidl(HMENU hmenu, LPITEMIDLIST pidl, BOOL bInsertSeparator);
FSSTDAPI_(UINT)     FileMenu_AddFilesForPidl(HMENU hmenu, UINT iPos, UINT idNewItems,
                                                    LPITEMIDLIST pidl, DWORD fmf, UINT fMenuFilter, PFNFMCALLBACK pfncb);


// Structure for composing a filemenu
typedef struct tagFMCOMPOSEA
{
    DWORD           cbSize;
    DWORD           dwMask;         // FMC_ flags
    UINT            id;
    DWORD           dwFlags;        // FMF_ flags
    DWORD           dwFSFilter;     // SHCONTF_ flags
    LPITEMIDLIST    pidlFolder;     // Folder to enumerate
    LPSTR           pszFolder;      // Folder to enumerate
    PFNFMCALLBACK   pfnCallback;    // Callback
    UINT            cyMax;          // Max allowable height in pixels
    UINT            cxMax;          // Max allowable width in pixels
    UINT            cySpacing;      // Spacing between menu items in pixels
    LPSTR           pszFilterTypes; // Multi-string list of extensions (e.g., "ext\0doc\0")

    OUT int         cItems;         // Returned
} FMCOMPOSEA;

typedef struct tagFMCOMPOSEW
{
    DWORD           cbSize;
    DWORD           dwMask;         // FMC_ flags
    UINT            id;
    DWORD           dwFlags;        // FMF_ flags
    DWORD           dwFSFilter;     // SHCONTF_ flags
    LPITEMIDLIST    pidlFolder;     // Folder to enumerate
    LPWSTR          pszFolder;      // Folder to enumerate
    PFNFMCALLBACK   pfnCallback;    // Callback
    UINT            cyMax;          // Max allowable height in pixels
    UINT            cxMax;          // Max allowable width in pixels
    UINT            cySpacing;      // Spacing between menu items in pixels
    LPWSTR          pszFilterTypes; // Multi-string list of extensions (e.g., "ext\0doc\0")

    OUT int         cItems;         // Returned
} FMCOMPOSEW;

#ifdef UNICODE
#define FMCOMPOSE   FMCOMPOSEW
#else
#define FMCOMPOSE   FMCOMPOSEA
#endif

// Mask values for FMCOMPOSE
#define FMC_FLAGS       0x00000001
#define FMC_FILTER      0x00000002
#define FMC_PIDL        0x00000004      // Mutually exclusive with FMC_STRING
#define FMC_STRING      0x00000008
#define FMC_CALLBACK    0x00000010
#define FMC_CYMAX       0x00000020
#define FMC_CXMAX       0x00000040
#define FMC_CYSPACING   0x00000080
#define FMC_FILTERTYPES 0x00000100

FSSTDAPI 
FileMenu_ComposeA(
    IN HMENU        hmenu,
    IN UINT         nMethod,
    IN FMCOMPOSEA * pfmc);
FSSTDAPI 
FileMenu_ComposeW(
    IN HMENU        hmenu,
    IN UINT         nMethod,
    IN FMCOMPOSEW * pfmc);

#ifdef UNICODE
#define FileMenu_Compose    FileMenu_ComposeW
#else
#define FileMenu_Compose    FileMenu_ComposeA
#endif

// Method ordinals for FileMenu_Compose
#define FMCM_INSERT     0
#define FMCM_APPEND     1
#define FMCM_REPLACE    2


typedef struct tagFMTOOLTIP
    {
    LPWSTR  pszTip;             // retured tip text, free with LocalFree()
    DWORD   dwMask;
    RECT    rcMargin;           // Margin to add around text
    DWORD   dwMaxWidth;         // Maximum tip width 
    DWORD   dwTabstop;
    UINT    uDrawFlags;
    } FMTOOLTIP;

// Mask flags for FMTOOLTIP 
#define FMTT_MARGIN     0x00000001      // Use the rcMargin field 
#define FMTT_MAXWIDTH   0x00000002      // Use the dwMaxWidth field 
#define FMTT_DRAWFLAGS  0x00000004      // Use the uDrawFlags field 
#define FMTT_TABSTOP    0x00000008      // Use the dwTabstop field 

FSSTDAPI_(BOOL)     FileMenu_ProcessCommand(HWND hwnd, HMENU hmenuBar, UINT idMenu, HMENU hmenu, UINT idCmd);
FSSTDAPI_(BOOL)     FileMenu_HandleMenuSelect(HMENU hmenu, WPARAM wparam, LPARAM lparam);
FSSTDAPI_(BOOL)     FileMenu_HandleNotify(HMENU hmenu, LPCITEMIDLIST * ppidl, LONG lEvent);
FSSTDAPI_(BOOL)     FileMenu_IsUnexpanded(HMENU hmenu);
FSSTDAPI_(void)     FileMenu_DelayedInvalidate(HMENU hmenu);
FSSTDAPI_(BOOL)     FileMenu_IsDelayedInvalid(HMENU hmenu);

FSSTDAPI            FileMenu_SaveOrder(HMENU hmenu);
FSSTDAPI_(void)     FileMenu_EditMode(BOOL bEdit);

#ifdef __cplusplus
}
#endif

#endif //_FSMENU_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\idhidden.h ===
#ifndef _IDHIDDEN_H_
#define _IDHIDDEN_H_

//
//  internal APIs for adding Hidden IDs to pidls
//      we use this to add data that we dont want
//      to be noticed by normal namespace handlers
//

typedef enum
{
    IDLHID_EMPTY            = 0xBEEF0000,   //  where's the BEEF?!
    IDLHID_URLFRAGMENT,                     //  Fragment IDs on URLs (#anchors)
    IDLHID_URLQUERY,                        //  Query strings on URLs (?query+info)
    IDLHID_JUNCTION,                        //  Junction point data
    IDLHID_LOCALIZEDNAME,                   //  for using ILocalizedName on folders
    IDLHID_DOCFINDDATA,                     //  DocFind's private attached data (not persisted)
} IDLHID;

typedef struct _HIDDENITEMID
{
    WORD    cb;     //  hidden item size
    IDLHID  id;     //  hidden item ID
    BYTE    ab[1];  //  hidden item data
} HIDDENITEMID;

typedef UNALIGNED HIDDENITEMID *PIDHIDDEN;
typedef const UNALIGNED HIDDENITEMID *PCIDHIDDEN;

STDAPI_(LPITEMIDLIST) ILAppendHiddenID(LPITEMIDLIST pidl, PCIDHIDDEN pidhid);
STDAPI_(PCIDHIDDEN) ILFindHiddenID(LPCITEMIDLIST pidl, IDLHID id);
STDAPI_(BOOL) ILRemoveHiddenID(LPITEMIDLIST pidl, IDLHID id);

//  helpers for common data types.
STDAPI_(LPITEMIDLIST) ILAppendHiddenClsid(LPITEMIDLIST pidl, IDLHID id, CLSID *pclsid);
STDAPI_(BOOL) ILGetHiddenClsid(LPCITEMIDLIST pidl, IDLHID id, CLSID *pclsid);
STDAPI_(LPITEMIDLIST) ILAppendHiddenStringW(LPITEMIDLIST pidl, IDLHID id, LPCWSTR psz);
STDAPI_(LPITEMIDLIST) ILAppendHiddenStringA(LPITEMIDLIST pidl, IDLHID id, LPCSTR psz);
STDAPI_(BOOL) ILGetHiddenStringW(LPCITEMIDLIST pidl, IDLHID id, LPWSTR psz, DWORD cch);
STDAPI_(BOOL) ILGetHiddenStringA(LPCITEMIDLIST pidl, IDLHID id, LPSTR psz, DWORD cch);
STDAPI_(int) ILCompareHiddenString(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, IDLHID id);

#ifdef UNICODE
#define ILAppendHiddenString            ILAppendHiddenStringW
#define ILGetHiddenString               ILGetHiddenStringW
#else //!UNICODE
#define ILAppendHiddenString            ILAppendHiddenStringA
#define ILGetHiddenString               ILGetHiddenStringA
#endif //UNICODE

#endif // _IDHIDDEN_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\heapaloc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:       heapaloc.h
//
//  Contents:   Macros which wrap the standard memory API calls, redirecting
//              them to HeapAlloc.
//
//  Functions:  __inline HLOCAL  HeapLocalAlloc   (fuFlags, cbBytes)
//              __inline HLOCAL  HeapLocalReAlloc (hMem, cbBytes, fuFlags)
//              __inline HLOCAL  HeapLocalFree    (HLOCAL hMem)
//
//  History:    2-01-95   davepl   Created
//              12-15-97  t-saml   changed to be used only for leak tracking
//
//--------------------------------------------------------------------------

#ifndef DEBUG
#define IMSAddToList(bAdd, pv, cb)
#else

// Function to add/remove from leak detection list
// In stocklib (shell\lib\debug.c)
STDAPI_(void) IMSAddToList(BOOL bAdd, void*pv, SIZE_T cb);
#ifdef _SHELLP_H_
// Function to call in allocspy.dll (GetShellMallocSpy)
typedef BOOL (__stdcall *PFNGSMS) (IShellMallocSpy **ppout);
#endif


#ifndef ASSERT
#define ASSERT Assert
#endif

#ifdef LocalAlloc
#error "HEAPALOC.H(42): LocalAlloc shouldn't be defined"
#endif

//
// These are functions normally in comctl32, but there's no good reason to call
// that dll, so handle them here.  Since Chicago may still want to use these
// shared memory routines, only "forward" them under NT.
//

#if defined(WINNT) && defined(_COMCTL32_)
#define Alloc(cb)                             HeapLocalAlloc(LMEM_ZEROINIT | LMEM_FIXED, cb)
#define ReAlloc(pb, cb)                       HeapLocalReAlloc(pb, cb, LMEM_ZEROINIT | LMEM_FIXED)
//
// Free() in comctl32 is just HeapFree(), so the return code reversing
// in HeapLocalFree is the opposite of what we want.  Reverse it
// again here for now, and consider redefining Free() as just
// HeapFree(g_hProcessHeap) if the compiler isn't smart enough
// to generate the same code already.  (BUGBUG investigate)
// REVIEW: who checks the return value from a free?  What do you do if it fails?
//
#define Free(pb)                              (!HeapLocalFree(pb))
#define GetSize(pb)                           HeapLocalSize(pb)
#endif


#if 0

// GlobalAllocs cannot be trivially replaced since they are used for DDE, OLE,
// and GDI operations.  However, on a case-by-case version we can switch them
// over to HeapGlobalAlloc as we identify instances that don't _really_ require
// GlobalAllocs.

#define GlobalAlloc(fuFlags, cbBytes)         HeapGlobalAlloc(fuFlags, cbBytes)
#define GlobalReAlloc(hMem, cbBytes, fuFlags) HeapGlobalReAlloc(hMem, cbBytes, fuFlags)
#define GlobalSize(hMem)                      HeapGlobalSize(hMem)
#define GlobalFree(hMem)                      HeapGlobalFree(hMem)
#define GlobalCompact                         InvalidMemoryCall
#define GlobalDiscard                         InvalidMemoryCall
#define GlobalFlags                           InvalidMemoryCall
#define GlobalHandle                          InvalidMemoryCall
#define GlobalLock                            InvalidMemoryCall
#define GlobalUnlock                          InvalidMemoryCall

#endif


__inline HLOCAL HeapLocalAlloc(IN UINT fuFlags, IN SIZE_T cbBytes)
{
    void * pv;

    pv = LocalAlloc(fuFlags, cbBytes);

    IMSAddToList(TRUE, pv, cbBytes); // Add to leak tracking

    return (HLOCAL) pv;
}

__inline HLOCAL HeapLocalFree(HLOCAL hMem)
{
    IMSAddToList(FALSE, hMem, 0); // Free leak tracking

    return LocalFree(hMem);
}

__inline HLOCAL HeapLocalReAlloc(IN HGLOBAL hMem,
                                 IN SIZE_T  cbBytes,
                                 IN UINT    fuFlags)
{
    void * pv;

    // BUGBUG (DavePl) Why can we realloc on a null ptr?

    if (NULL == hMem)
    {
        return LocalAlloc(fuFlags, cbBytes);
    }

    pv = LocalReAlloc((void *) hMem, cbBytes, fuFlags);

    IMSAddToList(FALSE, hMem, 0);    // Take out the old
    IMSAddToList(TRUE, pv, cbBytes);  // And bring in the new

    return (HGLOBAL) pv;
}

// Redefine the standard memory APIs to thunk over to our Heap-based funcs


#define LocalAlloc(fuFlags, cbBytes)          HeapLocalAlloc(fuFlags, cbBytes)
#define LocalReAlloc(hMem, cbBytes, fuFlags)  HeapLocalReAlloc(hMem, cbBytes, fuFlags)
#define LocalFree(hMem)                       HeapLocalFree(hMem)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\fsmenu2.h ===
//--------------------------------------------------------------------------
// 
//---------------------------------------------------------------------------

//----------------------------------------------------------------------------
typedef enum
{
    FMIUP_NONE                          = 0x0000,
    FMIUP_NO_EMPTY_ITEM                 = 0x0001,
    FMIUP_NO_PROGRAMS_SUBFOLDER         = 0x0002,         
    FMIUP_NO_SUBFOLDERS                 = 0x0004,
    FMIUP_DELAY                 	    = 0x0008,
} FMIUP_FLAGS;

//---------------------------------------------------------------------------
BOOL FM_Create(HIMAGELIST himlLarge, HIMAGELIST himlSmall, HMENU *phmenu, UINT cyExtra);
BOOL FM_AppendSubMenu(HMENU hmenu, LPCTSTR pszText, UINT id, UINT iImage, UINT fState, HMENU hmenuSub);
BOOL FM_AppendItem(HMENU hmenu, LPCTSTR pszText, UINT id, UINT fState, UINT iImage);
BOOL FM_InsertUsingPidl(HMENU hmenu, LPITEMIDLIST pidlFolder, UINT idFirst, FMIUP_FLAGS flags, PUINT pcItems);
BOOL FM_GetPidlFromMenuCommand(HMENU hmenu, UINT idCmd, LPITEMIDLIST *ppidlFolder, LPITEMIDLIST *ppidItem);
void FM_InvalidateAllImages(HMENU hmenu, BOOL fRecurse);
BOOL FM_SetImageSize(HMENU hmenu, BOOL fLarge);
BOOL FM_EnableItemByCmd(HMENU hmenu, UINT idCmd, BOOL fEnable);
BOOL FM_Destroy(HMENU hmenu);
BOOL FM_GetMenuFromPidl(HMENU hmenu, LPITEMIDLIST pidl, HMENU *phmenuSub, BOOL *pfExists);
BOOL FM_InsertItemByPidl(HMENU hmenu, LPITEMIDLIST pidl, FMIUP_FLAGS flags);
BOOL FM_DeleteItemByPidl(HMENU hmenu, LPITEMIDLIST pidl, FMIUP_FLAGS flags);
void FM_InvalidateItems(HMENU hmenu);
void FM_InvalidateItemsByPidl(HMENU hmenu, LPITEMIDLIST pidl);
BOOL FM_InvalidateImage(HMENU hmenu, UINT iImage);
BOOL FM_InvalidateAllImagesByPidl(HMENU hmenu, LPITEMIDLIST pidl);
BOOL FM_CreateFromMenu(HMENU hmenu, HIMAGELIST himlLarge, HIMAGELIST himlSmall, UINT cyExtra);
BOOL FM_DeleteAllItems(HMENU hmenu);
BOOL FM_ReplaceUsingPidl(HMENU hmenu, LPITEMIDLIST pidlFolder, UINT idFirst, FMIUP_FLAGS flags, PUINT pcItems);
BOOL FM_AppendUsingPidl(HMENU hmenu, LPITEMIDLIST pidlFolder, UINT idFirst, FMIUP_FLAGS flags, PUINT pcItems);

LRESULT FM_OnMeasureItem(LPMEASUREITEMSTRUCT pmi);
LRESULT FM_OnDrawItem(LPDRAWITEMSTRUCT pdi);
LRESULT FM_OnInitMenuPopup(HMENU hmenuPopup);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\inetsmgr.h ===
#if !defined(_INETSMGR_H_)
#define _INETSMGR_H_

// whoever inherits this class must implement _IsSafeSite
class CInternetSecurityMgrImpl : public IInternetSecurityManager
{
public:
    // *** IUnknown ***
    // (client must provide!)
    
    // *** IInternetSecurityManager methods ***
    virtual STDMETHODIMP MapUrlToZone(LPCWSTR pwszUrl, DWORD *pdwZone, DWORD dwReserved)
    {
        return INET_E_DEFAULT_ACTION;
    }
    virtual STDMETHODIMP GetSecurityId(LPCWSTR pwszUrl, BYTE* pbSecurityId, DWORD *pcbSecurityId, DWORD_PTR dwReserved)
    {
        return INET_E_DEFAULT_ACTION;
    }
    virtual STDMETHODIMP ProcessUrlAction(LPCWSTR pwszUrl, DWORD dwAction, BYTE *pPolicy, DWORD cbPolicy,
                                  BYTE *pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved)
    {
        HRESULT hres = INET_E_DEFAULT_ACTION;

        if (_IsSafeUrl(pwszUrl))
        {
            if (cbPolicy >= SIZEOF(DWORD))
            {
                *(DWORD *)pPolicy = URLPOLICY_ALLOW;
                hres = S_OK;
            }
            else
                hres = S_FALSE;
        }

        return hres;
    }
    virtual STDMETHODIMP QueryCustomPolicy(LPCWSTR pwszUrl, REFGUID guidKey, BYTE **ppPolicy, DWORD *pcbPolicy,
                                   BYTE *pContext, DWORD cbContext, DWORD dwReserved)
    {
        return INET_E_DEFAULT_ACTION;
    }
    virtual STDMETHODIMP SetSecuritySite(IInternetSecurityMgrSite *pSite)
    {
        return INET_E_DEFAULT_ACTION;
    }
    virtual STDMETHODIMP GetSecuritySite(IInternetSecurityMgrSite **ppSite)
    {
        return INET_E_DEFAULT_ACTION;
    }
    virtual STDMETHODIMP SetZoneMapping(DWORD dwZone, LPCWSTR lpszPattern, DWORD dwFlags)
    {
        return INET_E_DEFAULT_ACTION;
    }
    virtual STDMETHODIMP GetZoneMappings(DWORD dwZone, IEnumString **ppEnumString, DWORD dwFlags)
    {
        return INET_E_DEFAULT_ACTION;
    }

protected:
    virtual BOOL _IsSafeUrl(LPCWSTR pwszUrl) = 0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\iethread.h ===
//
// Defines IETHREADPARAM for shdocvw.dll and explorer.exe
//

#ifndef __IETHREAD_H__
#define __IETHREAD_H__

#include <desktopp.h>

typedef struct
{
    DWORD   dwSize;
    UINT    uFlags;
    int     nShow;
    HWND    hwndCaller;
    DWORD   dwHotKey;
    CLSID   clsid;
    CLSID   clsidInProc;
    UINT    oidl;               // Offset to pidl or 0
    UINT    oidlSelect;         // Offset to pidl or 0
    UINT    oidlRoot;           // Offset to pidl or 0
    UINT    opszPath;           // Offset to path or 0
} NEWFOLDERBLOCK, *PNEWFOLDERBLOCK;

typedef struct _WINVIEW
{
    BOOL UNUSED:1;      // unused
    BOOL bStdButtons:1; // Win95 called this bToolbar
    BOOL bStatusBar:1;  // Win95
    BOOL bLinks:1;      // IE3 called this bITBar
    BOOL bAddress:1;    // IE4
} WINVIEW;


// the size in characters of the name of the Event used to signal IEXPLORE
#define MAX_IEEVENTNAME (2+1+8+1+8+1)

#undef  INTERFACE
#define INTERFACE   IEFreeThreadedHandShake
DECLARE_INTERFACE_(IEFreeThreadedHandShake, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IIEFreeThreadedHandShake methods ***
    STDMETHOD_(void,   PutHevent) (THIS_ HANDLE hevent) PURE;
    STDMETHOD_(HANDLE, GetHevent) (THIS) PURE;
    STDMETHOD_(void,    PutHresult) (THIS_ HRESULT hres) PURE;
    STDMETHOD_(HRESULT, GetHresult) (THIS) PURE;
    STDMETHOD_(IStream*, GetStream) (THIS) PURE;
};


#ifdef NO_MARSHALLING

#undef  INTERFACE
#define INTERFACE IWindowStatus
DECLARE_INTERFACE_(IWindowStatus, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IWindowStatus methods ***
    STDMETHOD(IsWindowActivated)() PURE;
};

#endif


// NOTE: The IETHREADPARAM structure is used between shdocvw, shell32,
// and browseui, so it cannot be modified after we ship, only extended.
typedef struct
{
    LPCWSTR pszCmdLine;
    UINT    uFlags;             // COF_ bits
    int     nCmdShow;

    //  these will always be set together
    ITravelLog *ptl;
    DWORD dwBrowserIndex;

    IEFreeThreadedHandShake* piehs;   // caller (thread) owns it

    // these come from explorer's NEWFOLDERINFO
    LPITEMIDLIST pidl;

    WCHAR szDdeRegEvent[MAX_IEEVENTNAME];
    WCHAR szCloseEvent[MAX_IEEVENTNAME];
    
    IShellBrowser* psbCaller;
    HWND hwndCaller;
    ISplashScreen *pSplash;
    LPITEMIDLIST pidlSelect;    // Only used if COF_SELECT

    LPITEMIDLIST pidlRoot;      // Only used if COF_NEWROOT
                                // 99/04/07 #141049 vtan: Overload pidlRoot with
                                // HMONITOR information on Windows 2000. Check the
                                // uFlags for COF_HASHMONITOR before using this.

    CLSID clsid;                // Only used if COF_NEWROOT
    CLSID clsidInProc;          // Only used if COF_INPROC
    
    // these come from explorer.exe's cabview struct
    WINDOWPLACEMENT wp;
    FOLDERSETTINGS fs;
    UINT wHotkey;

    WINVIEW wv;

    SHELLVIEWID m_vidRestore;
    DWORD m_dwViewPriority;
    
    long dwRegister;            // The register that was gotten from RegisterPending
    IUnknown *punkRefProcess;

    BOOL fNoLocalFileWarning : 1;
    BOOL fDontUseHomePage : 1;
    BOOL fFullScreen : 1;
    BOOL fNoDragDrop : 1;
    BOOL fAutomation : 1;
    BOOL fCheckFirstOpen : 1;
    BOOL fDesktopChannel : 1;

#ifdef UNIX
    BOOL fShouldStart : 1;
#endif

#ifdef NO_MARSHALLING
    BOOL fOnIEThread : 1;
#endif //NO_MARSHALLING
} IETHREADPARAM;

#ifdef UNIX
#define COF_HELPMODE            0x00010000      // Special mode for help display
#endif

#endif // __IETHREAD_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\inststub.h ===
#ifndef __cplusplus
#error Install stub code must be C++!
#endif

#ifndef HINST_THISDLL
#error HINST_THISDLL must be defined!
#endif

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)    (sizeof(a)/sizeof((a)[0]))
#endif

#include <ccstock.h>
#include <stubres.h>
#include <trayp.h>

BOOL CheckWebViewShell();

/* This code runs the install/uninstall stubs recorded in the local-machine
 * part of the registry, iff the current user has not had them run in his
 * context yet.  Used for populating the user's profile with things like
 * links to applications.
 */
//---------------------------------------------------------------------------


BOOL ProfilesEnabled(void)
{
    BOOL fEnabled = FALSE;

    if (staticIsOS(OS_NT)) {
        fEnabled = TRUE;
    }
    else {
        HKEY hkeyLogon;
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Network\\Logon"), 0,
                         KEY_QUERY_VALUE, &hkeyLogon) == ERROR_SUCCESS) {
            DWORD fProfiles, cbData = sizeof(fProfiles), dwType;
            if (RegQueryValueEx(hkeyLogon, TEXT("UserProfiles"), NULL, &dwType,
                                (LPBYTE)&fProfiles, &cbData) == ERROR_SUCCESS) {
                if (dwType == REG_DWORD || (dwType == REG_BINARY && cbData == sizeof(DWORD)))
                    fEnabled = fProfiles;
            }
            RegCloseKey(hkeyLogon);
        }
    }
    return fEnabled;
}


DWORD MsgWaitForMultipleObjectsLoop(HANDLE hEvent, DWORD dwTimeout)
{
    MSG msg;
    DWORD dwObject;
    // DebugMsg(DM_TRACE, "c.t_rd: Waiting for run dlg...");
    while (1)
    {
        dwObject = MsgWaitForMultipleObjects(1, &hEvent, FALSE, dwTimeout, QS_ALLINPUT);
        // Are we done waiting?
        switch (dwObject) {
        case WAIT_OBJECT_0:
        case WAIT_FAILED:
            return dwObject;

        case WAIT_OBJECT_0 + 1:
            // Almost.
            // DebugMsg(DM_TRACE, "c.t_rd: Almost done waiting.");
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }

            break;
        }
    }
    // never gets here
    // return dwObject;
}

// The following handles running an application and optionally waiting for it
// to terminate.
void ShellExecuteRegApp(LPTSTR szCmdLine, UINT fFlags)
{
    TCHAR szQuotedCmdLine[MAX_PATH+2];    
    SHELLEXECUTEINFO ei;
    LPTSTR lpszArgs;

    //
    // We used to call CreateProcess( NULL, szCmdLine, ...) here,
    // but thats not useful for people with apppaths stuff.
    //
    // Don't let empty strings through, they will endup doing something dumb
    // like opening a command prompt or the like
    if (!szCmdLine || !*szCmdLine)
        return;


    // Gross, but if the process command fails, copy the command line to let
    // shell execute report the errors
    if (PathProcessCommand(szCmdLine, szQuotedCmdLine, ARRAYSIZE(szQuotedCmdLine),
                           PPCF_ADDARGUMENTS|PPCF_FORCEQUALIFY) == -1)
        lstrcpyn(szQuotedCmdLine, szCmdLine, ARRAYSIZE(szQuotedCmdLine) - 2);
    
    lpszArgs = PathGetArgs(szQuotedCmdLine);
    if (*lpszArgs)
        *(lpszArgs-1) = TEXT('\0'); // Strip args

    ei.lpFile          = szQuotedCmdLine;
    int cch = lstrlen(ei.lpFile);

    // Are the first and last chars quotes?
    if (szQuotedCmdLine[0] == TEXT('"') && szQuotedCmdLine[cch-1] == TEXT('"'))
    {
        // Yep, remove them.
        szQuotedCmdLine[cch-1] = TEXT('\0');
        ei.lpFile++;
    }

    ei.cbSize          = sizeof(SHELLEXECUTEINFO);
    ei.hwnd            = NULL;
    ei.lpVerb          = NULL;
    ei.lpParameters    = lpszArgs;
    ei.lpDirectory     = NULL;
    ei.nShow           = SW_SHOWNORMAL;
    ei.fMask           = (fFlags & RRA_NOUI)? 
            (SEE_MASK_NOCLOSEPROCESS | SEE_MASK_FLAG_NO_UI) :  SEE_MASK_NOCLOSEPROCESS;

    if (ShellExecuteEx(&ei))
    {
        if ((fFlags & RRA_WAIT) && ei.hProcess != NULL)
        {
            MsgWaitForMultipleObjectsLoop(ei.hProcess, INFINITE);
        }
        CloseHandle(ei.hProcess);
    }
}

// ---------------------------------------------------------------------------
// %%Function: GetVersionFromString
//
//  Snarfed from urlmon\download\helpers.cxx.
//
//    converts version in text format (a,b,c,d) into two dwords (a,b), (c,d)
//    The printed version number is of format a.b.d (but, we don't care)
// ---------------------------------------------------------------------------
HRESULT
GetVersionFromString(LPCTSTR szBuf, LPDWORD pdwFileVersionMS, LPDWORD pdwFileVersionLS)
{
    LPCTSTR pch = szBuf;
    TCHAR ch;
    USHORT n = 0;

    USHORT a = 0;
    USHORT b = 0;
    USHORT c = 0;
    USHORT d = 0;

    enum HAVE { HAVE_NONE, HAVE_A, HAVE_B, HAVE_C, HAVE_D } have = HAVE_NONE;


    *pdwFileVersionMS = 0;
    *pdwFileVersionLS = 0;

    if (!pch)            // default to zero if none provided
        return S_OK;

    if (lstrcmp(pch, TEXT("-1,-1,-1,-1")) == 0) {
        *pdwFileVersionMS = 0xffffffff;
        *pdwFileVersionLS = 0xffffffff;
    }


    for (ch = *pch++;;ch = *pch++) {

        if ((ch == ',') || (ch == '\0')) {

            switch (have) {

            case HAVE_NONE:
                a = n;
                have = HAVE_A;
                break;

            case HAVE_A:
                b = n;
                have = HAVE_B;
                break;

            case HAVE_B:
                c = n;
                have = HAVE_C;
                break;

            case HAVE_C:
                d = n;
                have = HAVE_D;
                break;

            case HAVE_D:
                return E_INVALIDARG; // invalid arg
            }

            if (ch == '\0') {
                // all done convert a,b,c,d into two dwords of version

                *pdwFileVersionMS = ((a << 16)|b);
                *pdwFileVersionLS = ((c << 16)|d);

                return S_OK;
            }

            n = 0; // reset

        } else if ( (ch < '0') || (ch > '9'))
            return E_INVALIDARG;    // invalid arg
        else
            n = n*10 + (ch - '0');


    } /* end forever */

    // NEVERREACHED
}


// Reg keys and values for install/uninstall stub list.  Each subkey under
// HKLM\Software\InstalledComponents is a component identifier (GUID).
// Each subkey has values "Path" for the EXE to run to install or uninstall;
// IsInstalled (dword) indicating whether the component has been installed
// or uninstalled;  and an optional Revision (dword) used to refresh a
// component without changing its GUID.  Locale (string) is used to describe
// the language/locale for the component;  this string is not interpreted by
// the install stub code, it is just compared between the HKLM and HKCU keys.
// If it's different between the two, the stub is re-run.
//
// HKCU\Software\InstalledComponents contains similar GUID subkeys, but the
// only values under each subkey are the optional Revision and Locale values,
// and an optional DontAsk value (also DWORD).  Presence of the subkey indicates
// that the component is installed for that user.
//
// If the DontAsk value is present under an HKCU subkey and is non-zero, that
// means that the user has decided to keep their settings for that component
// on all machines, even those that have had the component uninstalled, and
// that they don't want to be asked if they want to run the uninstall stub
// every time they log on.  This implies that for that user, the uninstall
// stub will never be run for that component unless the user somehow clears
// the flag.
//
// NOTE: mslocusr.dll also knows these registry paths.

const TCHAR c_szRegInstalledComponentsKey[] = TEXT("Software\\Microsoft\\Active Setup\\Installed Components");
const TCHAR c_szRegInstallStubValue[] = TEXT("StubPath");
const TCHAR c_szRegIsInstalledValue[] = TEXT("IsInstalled");
const TCHAR c_szRegInstallSequenceValue[] = TEXT("Version");
const TCHAR c_szRegDontAskValue[] = TEXT("DontAsk");
const TCHAR c_szRegLocaleValue[] = TEXT("Locale");


UINT ConfirmUninstall(LPCTSTR pszDescription)
{
    /* The only case where the user wouldn't want settings cleaned up on
     * uninstall would be if they'd roamed to a machine that had had this
     * component uninstalled.  If user profiles aren't enabled (which is
     * the case on a fair number of customers' machines), they're certainly
     * not roaming, so there's not much point in asking them.  Just pretend
     * they said YES, they want to clean up the settings.
     */
    if (!ProfilesEnabled())
        return IDYES;

    /* BUGBUG - change to a dialog with a checkbox for
     * the don't-ask value.
     */

    TCHAR szTitle[MAX_PATH];
#ifdef USERSTUB
    LoadString(HINST_THISDLL, IDS_DESKTOP, szTitle, ARRAYSIZE(szTitle));
#else
    MLLoadString(IDS_DESKTOP, szTitle, ARRAYSIZE(szTitle));
#endif

    TCHAR szMessageTemplate[MAX_PATH];
    LPTSTR pszMessage = NULL;
    int   cchMessage;

#ifdef USERSTUB
    LoadString(HINST_THISDLL, IDS_UNINSTALL, szMessageTemplate, ARRAYSIZE(szMessageTemplate));
#else
    MLLoadString(IDS_UNINSTALL, szMessageTemplate, ARRAYSIZE(szMessageTemplate));
#endif


    cchMessage = (lstrlen(szMessageTemplate)+lstrlen(pszDescription)+4)*sizeof(TCHAR);
    pszMessage = (LPTSTR)LocalAlloc(LPTR, cchMessage);
    if (pszMessage)
    {
#ifdef USERSTUB
        wsprintf(pszMessage, szMessageTemplate, pszDescription);
#else
        wnsprintf(pszMessage, cchMessage, szMessageTemplate, pszDescription);
#endif
    }
    else
    {
        pszMessage = szMessageTemplate;
    }

    // due to build in UNICODE the following call is broken under win95, user wsprintf above
    //if (!FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING |
    //                   FORMAT_MESSAGE_ARGUMENT_ARRAY,
    //                   (LPVOID)szMessageTemplate,
    //                   0,
    //                   0,
    //                   (LPTSTR)&pszMessage,
    //                   0,        /* min chars to allocate */
    //                   (va_list *)&pszDescription)) {
    //    pszMessage = szMessageTemplate;
    //}


    UINT idRet = MessageBox(NULL, pszMessage, szTitle,
                            MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2 | MB_SETFOREGROUND);

    if (pszMessage != szMessageTemplate)
        LocalFree(pszMessage);

    return idRet;
}


HWND hwndProgress = NULL;
BOOL fTriedProgressDialog = FALSE;

INT_PTR ProgressDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message) {
    case WM_INITDIALOG:
        return TRUE;

    case WM_SETCURSOR:
        SetCursor(LoadCursor(NULL, IDC_WAIT));
        return TRUE;


    default:
        return FALSE;
    }

    return TRUE;
}


void SetProgressInfo(HWND hwndProgress, LPCTSTR pszFriendlyName, BOOL fInstalling)
{
    HWND hwndInstalling = GetDlgItem(hwndProgress, IDC_RUNNING_INSTALL_STUB);
    HWND hwndUninstalling = GetDlgItem(hwndProgress, IDC_RUNNING_UNINSTALL_STUB);

    ShowWindow(hwndInstalling, fInstalling ? SW_SHOW : SW_HIDE);
    EnableWindow(hwndInstalling, fInstalling);
    ShowWindow(hwndUninstalling, fInstalling ? SW_HIDE : SW_SHOW);
    EnableWindow(hwndUninstalling, !fInstalling);
    SetDlgItemText(hwndProgress, IDC_INSTALL_STUB_NAME, pszFriendlyName);
}


void IndicateProgress(LPCTSTR pszFriendlyName, BOOL fInstalling)
{
    if (hwndProgress == NULL && !fTriedProgressDialog) {
        hwndProgress = CreateDialog(HINST_THISDLL, MAKEINTRESOURCE(IDD_InstallStubProgress),
                                    NULL, ProgressDialogProc);
    }

    if (hwndProgress != NULL) {
        SetProgressInfo(hwndProgress, pszFriendlyName, fInstalling);
        if (!fTriedProgressDialog) {
            ShowWindow(hwndProgress, SW_RESTORE);
            SetForegroundWindow(hwndProgress);
        }
    }
    fTriedProgressDialog = TRUE;
}


void CleanupProgressDialog(void)
{
    if (hwndProgress != NULL) {
        DestroyWindow(hwndProgress);
        hwndProgress = NULL;
    }
}


BOOL RunOneInstallStub( HKEY hklmList, HKEY hkcuList, LPCTSTR pszKeyName,
                        LPCTSTR pszCurrentUsername, int iPass )
{
     BOOL bNextPassNeeded = FALSE;
     /* See if this component is installed or an uninstall tombstone. */
     HKEY hkeyComponent;

     DWORD err = RegOpenKeyEx(hklmList, pszKeyName, 0, KEY_QUERY_VALUE,
                               &hkeyComponent);
     if (err == ERROR_SUCCESS) {
        TCHAR szCmdLine[MAX_PATH];
        DWORD fIsInstalled;
        DWORD dwType;
        DWORD cbData = sizeof(fIsInstalled);
        HKEY hkeyUser = NULL;

        /* Must have the stub path;  if not there, skip this entry. */
        cbData = sizeof(szCmdLine);
        if (SHQueryValueEx(hkeyComponent, c_szRegInstallStubValue,
                           NULL, &dwType, (LPBYTE)szCmdLine,
                           &cbData) != ERROR_SUCCESS || ((dwType != REG_SZ) && (dwType != REG_EXPAND_SZ)) ) {
            RegCloseKey(hkeyComponent);
            return bNextPassNeeded;
        }

        TCHAR szDescription[MAX_PATH];
        LPTSTR pszDescription = szDescription;
        cbData = sizeof(szDescription);
        if (SHQueryValueEx(hkeyComponent, TEXT(""),
                           NULL, &dwType, (LPBYTE)szDescription,
                           &cbData) != ERROR_SUCCESS || dwType != REG_SZ) {
            pszDescription = szCmdLine;
        }


        if (RegQueryValueEx(hkeyComponent, c_szRegIsInstalledValue,
                            NULL, &dwType, (LPBYTE)&fIsInstalled,
                            &cbData) != ERROR_SUCCESS ||
            (dwType != REG_DWORD && (dwType != REG_BINARY || cbData != sizeof(DWORD))))
            fIsInstalled = TRUE;

        /* If it's installed, check the user's profile, and if the
         * component (or its current revision) isn't installed there,
         * run it.
         */
        if (fIsInstalled) {
            DWORD dwRevisionHi, dwRevisionLo;
            DWORD dwUserRevisionHi = 0;
            DWORD dwUserRevisionLo = 0;
            BOOL fSetRevision;
            TCHAR szRevision[24], szUserRevision[24];   /* 65535,65535,65535,65535\0 */
            TCHAR szLocale[10], szUserLocale[10];       /* usually not very big strings */
            TCHAR szInstallUsername[128+1];  /* 128 is the win95 system username limit */

            DWORD fIsCloneUser;
            cbData = sizeof(fIsCloneUser);
            if (RegQueryValueEx(hkeyComponent, TEXT("CloneUser"),
                                NULL, &dwType, (LPBYTE)&fIsCloneUser,
                                &cbData) != ERROR_SUCCESS ||
                (dwType != REG_DWORD && (dwType != REG_BINARY || cbData != sizeof(DWORD))))
                fIsCloneUser = FALSE;

            cbData = sizeof(szRevision);
            if (RegQueryValueEx(hkeyComponent, c_szRegInstallSequenceValue,
                                NULL, &dwType, (LPBYTE)szRevision,
                                &cbData) != ERROR_SUCCESS ||
                dwType != REG_SZ ||
                FAILED(GetVersionFromString(szRevision, &dwRevisionHi, &dwRevisionLo))) {
                fSetRevision = FALSE;
                dwRevisionHi = 0;
                dwRevisionLo = 0;
            }
            else {
                fSetRevision = TRUE;
            }

            cbData = sizeof(szLocale);
            err = RegQueryValueEx(hkeyComponent, c_szRegLocaleValue,
                                  NULL, &dwType, (LPBYTE)szLocale,
                                  &cbData);
            if (err != ERROR_SUCCESS || dwType != REG_SZ) {
                szLocale[0] = '\0';
            }

            err = RegOpenKeyEx(hkcuList, pszKeyName, 0,
                               KEY_QUERY_VALUE | KEY_SET_VALUE, &hkeyUser);
            if (err == ERROR_SUCCESS) {
                cbData = sizeof(szUserRevision);
                if (RegQueryValueEx(hkeyUser, c_szRegInstallSequenceValue,
                                    NULL, &dwType, (LPBYTE)szUserRevision,
                                    &cbData) != ERROR_SUCCESS ||
                    dwType != REG_SZ ||
                    FAILED(GetVersionFromString(szUserRevision, &dwUserRevisionHi, &dwUserRevisionLo))) {
                    dwUserRevisionHi = 0;
                    dwUserRevisionLo = 0;
                }

                if (szLocale[0] != '\0') {
                    cbData = sizeof(szUserLocale);
                    err = RegQueryValueEx(hkeyUser, c_szRegLocaleValue,
                                          NULL, &dwType, (LPBYTE)szUserLocale,
                                          &cbData);
                    /* If there's a locale string under the user key
                     * and it's the same as the machine one, then we
                     * blank out the machine one so we won't consider
                     * that when running the stub.
                     */
                    if (err == ERROR_SUCCESS && dwType == REG_SZ &&
                        !lstrcmp(szLocale, szUserLocale)) {
                        szLocale[0] = '\0';
                    }
                }
                if (fIsCloneUser) {
                    /* Clone-user install stub.  We need to re-run it if the
                     * username we used when we last installed to this profile,
                     * or the one it was copied from, is different from the
                     * current username.
                     */
                    cbData = sizeof(szInstallUsername);
                    if (RegQueryValueEx(hkeyUser, TEXT("Username"),
                                        NULL, &dwType, (LPBYTE)szInstallUsername,
                                        &cbData) != ERROR_SUCCESS ||
                        dwType != REG_SZ) {
                        szInstallUsername[0] = '\0';
                    }
                }
            }
            else {
                hkeyUser = NULL;
            }

            /* Install if:
             *
             * - User doesn't have component installed, OR
             *   - Component installed on machine has a revision AND
             *   - Machine component revision greater than user's
             * - OR
             *   - Component installed on machine has a locale AND
             *   - Machine component locale different than user's
             *     (this is actually checked above)
             * - OR
             *   - Component is a clone-user install stub and the username
             *     recorded for the stub is different from the current username
             */
            if ((hkeyUser == NULL) ||
                (fSetRevision &&
                 ((dwRevisionHi > dwUserRevisionHi) ||
                  ((dwRevisionHi == dwUserRevisionHi) &&
                   (dwRevisionLo > dwUserRevisionLo)
                  )
                 )
                ) ||
                (szLocale[0] != '\0') ||
#ifdef UNICODE
                (fIsCloneUser && StrCmpI(szInstallUsername, pszCurrentUsername))
#else
                (fIsCloneUser && lstrcmpi(szInstallUsername, pszCurrentUsername))
#endif
                ) {

                if ( (iPass == -1 ) ||
                     ((iPass == 0) && (*pszKeyName == '<')) ||
                     ((iPass == 1) && (*pszKeyName != '<') && (*pszKeyName != '>')) ||
                     ((iPass == 2) && (*pszKeyName == '>')) )
                {
                    // the condition meets, run it now.
#ifdef TraceMsg
                    TraceMsg(TF_REGCHECK, "Running install stub ( %s )", szCmdLine);
#endif
                    IndicateProgress(pszDescription, TRUE);
                    ShellExecuteRegApp(szCmdLine, RRA_WAIT | RRA_NOUI);
                    if (hkeyUser == NULL) {
                        RegCreateKey(hkcuList, pszKeyName, &hkeyUser);
                    }
                    if (hkeyUser != NULL) {
                        if (fSetRevision) {
                            RegSetValueEx(hkeyUser, c_szRegInstallSequenceValue,
                                          0, REG_SZ,
                                          (LPBYTE)szRevision,
                                          (lstrlen(szRevision)+1)*sizeof(TCHAR));
                        }
                        if (szLocale[0]) {
                            RegSetValueEx(hkeyUser, c_szRegLocaleValue,
                                          0, REG_SZ,
                                          (LPBYTE)szLocale,
                                          (lstrlen(szLocale)+1)*sizeof(TCHAR));
                        }
                        if (fIsCloneUser) {
                            RegSetValueEx(hkeyUser, TEXT("Username"),
                                          0, REG_SZ,
                                          (LPBYTE)pszCurrentUsername,
                                          (lstrlen(pszCurrentUsername)+1)*sizeof(TCHAR));
                        }
                    }
                }
                else
                {
                    // decide if this belong to the next pass
                    // if it is in Pass 2, should never get here
                    if ( iPass == 0 )
                        bNextPassNeeded = TRUE;
                    else if ( (iPass == 1 ) && (*pszKeyName == '>') )
                        bNextPassNeeded = TRUE;
                }
            }
        }
        else {
            /* Component is an uninstall stub. */

            err = RegOpenKeyEx(hkcuList, pszKeyName, 0,
                               KEY_QUERY_VALUE, &hkeyUser);
            if (err == ERROR_SUCCESS) {
                DWORD fDontAsk = 0;

                /* Check the "Don't Ask" value.  If it's present, its value
                 * is interpreted as follows:
                 *
                 * 0 --> ask the user
                 * 1 --> do not run the stub
                 * 2 --> always run the stub
                 */
                cbData = sizeof(fDontAsk);
                if (RegQueryValueEx(hkeyComponent, c_szRegDontAskValue,
                                    NULL, &dwType, (LPBYTE)&fDontAsk,
                                    &cbData) != ERROR_SUCCESS ||
                    (dwType != REG_DWORD && (dwType != REG_BINARY || cbData != sizeof(DWORD))) ||
                    fDontAsk != 1) 
                {

                    if ( (iPass == -1 ) ||
                         ((iPass == 0) && (*pszKeyName == '>')) ||
                         ((iPass == 1) && (*pszKeyName != '<') && (*pszKeyName != '>')) ||
                         ((iPass == 2) && (*pszKeyName == '<')) )
                    {
                        // uninstall stub has the reversed order comparing with install stub
                        if (fDontAsk == 2 || ConfirmUninstall(pszDescription) == IDYES) {

#ifdef TraceMsg
                            TraceMsg(TF_REGCHECK, "Running uninstall stub ( %s )", szCmdLine);
#endif
                            IndicateProgress(pszDescription, FALSE);
                            ShellExecuteRegApp(szCmdLine, RRA_WAIT | RRA_NOUI);
    
                            /* Component has been uninstalled.  Forget that the
                             * user ever had it installed.
                             */
                            RegCloseKey(hkeyUser);
                            hkeyUser = NULL;
                            RegDeleteKey(hkcuList, pszKeyName);
                        }

                    }
                    else
                    {
                        // decide if this belong to the next pass
                        // if it is in Pass 2, should never get here
                        if ( iPass == 0 )
                            bNextPassNeeded = TRUE;
                        else if ( (iPass == 1 ) && (*pszKeyName == '<') )
                            bNextPassNeeded = TRUE;
                    }
                }
            }
        }

        if (hkeyUser != NULL) {
            RegCloseKey(hkeyUser);
        }
        RegCloseKey(hkeyComponent);
    }

    return bNextPassNeeded;
}


const TCHAR  c_szIE40GUID_STUB[] = TEXT("{89820200-ECBD-11cf-8B85-00AA005B4383}");
const TCHAR  c_szBlockIE4Stub[]  = TEXT("NoIE4StubProcessing");

extern "C" void RunInstallUninstallStubs2(LPCTSTR pszStubToRun)
{
    HKEY hklmList = NULL, hkcuList = NULL;
    LONG err;

    TCHAR szUsername[128+1];        /* 128 is the win95 limit, good default */
    LPTSTR pszCurrentUser = szUsername;

    /* As far as clone-user install stubs are concerned, we only want profile
     * usernames.
     */
    if (!ProfilesEnabled()) {
        *pszCurrentUser = '\0';
    }
    else {
        DWORD cbData = sizeof(szUsername);
        if (!GetUserName(szUsername, &cbData)) {
            if (cbData > sizeof(szUsername)) {
                cbData++;   /* allow for null char just in case */
                pszCurrentUser = (LPTSTR)LocalAlloc(LPTR, cbData+1);
                if (pszCurrentUser == NULL || !GetUserName(pszCurrentUser, &cbData)) {
                    if (pszCurrentUser != NULL)
                        LocalFree(pszCurrentUser);
                    pszCurrentUser = szUsername;
                    *pszCurrentUser = '\0';
                }
            }
            else {
                szUsername[0] = '\0';
            }
        }
    }

#ifdef TraceMsg
    TraceMsg(TF_REGCHECK, "Running install/uninstall stubs.");
#endif

    err = RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegInstalledComponentsKey, 0,
                       KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE, &hklmList);

    if (err == ERROR_SUCCESS) {
        DWORD dwDisp;
        err = RegCreateKeyEx(HKEY_CURRENT_USER, c_szRegInstalledComponentsKey, 0,
                             TEXT(""), REG_OPTION_NON_VOLATILE,
                             KEY_READ | KEY_WRITE, NULL, &hkcuList, &dwDisp);
    }

    if (err == ERROR_SUCCESS) {
        if (pszStubToRun != NULL) {
            // here we call with pass number -1 means no pass order enforced
            RunOneInstallStub(hklmList, hkcuList, pszStubToRun, pszCurrentUser, -1);
        }
        else {
            DWORD cbKeyName, iKey, iPass;
            TCHAR szKeyName[80];
            BOOL  bNextPassNeeded = TRUE;
            HANDLE hMutex;

            // This mutex check is to ensure if explore restarted due abnormal active desktop shutdown, and setup resume
            // per-user stubs should not be processed till setup is done.
            if (CheckWebViewShell())
            {
                hMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, TEXT("Ie4Setup.Mutext"));
                if (hMutex)
                {
                    CloseHandle(hMutex);                
                    goto done;
                }
            }

	        // check if we want to block the stub processing
            cbKeyName = sizeof(szKeyName);
            if ((RegQueryValueEx(hklmList, c_szBlockIE4Stub, NULL, NULL, 
                                (LPBYTE)szKeyName, &cbKeyName) == ERROR_SUCCESS) && 
                (*CharUpper(szKeyName) == 'Y') )
	        {
                 goto done;
            }                       

            /* we will do TWO passes to meet the ordering requirement when run component stubs.
               Any KeyName with '*' as the first char, get run in the 1st Pass.  the rest run 2nd pass */
            for ( iPass = 0; ((iPass<3) && bNextPassNeeded); iPass++ )
            {
                bNextPassNeeded = FALSE;
                
                // BUGBUG: in 2nd pass, we do want to special case of IE4.0 base browser stub
                // to run first.  The reason we did not use '<' for this is to 1) reserve < stuff
                // for pre-ie4 stubs and this whole thing should redo in sorted fashion.  For now,
                // we hard code this IE4.0 base browser GUID
                if ( iPass == 1 )
                {
                    if ( RunOneInstallStub(hklmList, hkcuList, c_szIE40GUID_STUB, pszCurrentUser, iPass) )                    
                        bNextPassNeeded = TRUE;
                }                    

                /* Enumerate components that are installed on the local machine. */
                for (iKey = 0; ; iKey++)
                {
                    LONG lEnum;

                    cbKeyName = ARRAYSIZE(szKeyName);

                    // BUGBUG (Unicode, Davepl) I'm assuming that the data is UNICODE,
                    // but I'm not sure who put it there yet... double check.

                    if ((lEnum = RegEnumKey(hklmList, iKey, szKeyName, cbKeyName)) == ERROR_MORE_DATA)
                    {
                        // ERROR_MORE_DATA means the value name or data was too large
                        // skip to the next item
#ifdef TraceMsg
                        TraceMsg( DM_ERROR, "Cannot run oversize entry in InstalledComponents");
#endif
                        continue;
                    }
                    else if( lEnum != ERROR_SUCCESS )
                    {
                        // could be ERROR_NO_MORE_ENTRIES, or some kind of failure
                        // we can't recover from any other registry problem, anyway
                        break;
                    }

                    // in case the user say NO when we try to run the IE4 stub first time,
                    // we should not re-process this stub again.
		    if ( (iPass == 1) && (!lstrcmpi(szKeyName, c_szIE40GUID_STUB)) )
                        continue;
                    
                    if ( RunOneInstallStub(hklmList, hkcuList, szKeyName, pszCurrentUser, iPass) )                    
                        bNextPassNeeded = TRUE;
                }
            }
        }
    }

done:

    if (hklmList != NULL)
        RegCloseKey(hklmList);
    if (hkcuList != NULL)
        RegCloseKey(hkcuList);

    if (pszCurrentUser != szUsername)
        LocalFree(pszCurrentUser);

    CleanupProgressDialog();
}

// Check shell32.dll's version and see if it is the one which supports the integrated WebView
BOOL CheckWebViewShell()
{
    HINSTANCE           hInstShell32;
    DLLGETVERSIONPROC   fpGetDllVersion;    
    BOOL                pWebViewShell = FALSE;
           
    hInstShell32 = LoadLibrary(TEXT("Shell32.dll"));
    if (hInstShell32)
    {
        fpGetDllVersion = (DLLGETVERSIONPROC)GetProcAddress(hInstShell32, "DllGetVersion");
        pWebViewShell = (fpGetDllVersion != NULL);
        FreeLibrary(hInstShell32);
    }
    return pWebViewShell;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\mmhelper.h ===
#ifndef _MMHELPER_H_
#define _MMHELPER_H_

/* This file contains the declarations of MultiMonitor helper functions used
   inside the shell, they are implemented in shell\lib\mmhelper.cpp */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

HMONITOR GetPrimaryMonitor();
BOOL GetMonitorRects(HMONITOR hMon, LPRECT prc, BOOL bWork);
#define GetMonitorRect(hMon, prc) \
        GetMonitorRects((hMon), (prc), FALSE)
#define GetMonitorWorkArea(hMon, prc) \
        GetMonitorRects((hMon), (prc), TRUE)
#define IsMonitorValid(hMon) \
        GetMonitorRects((hMon), NULL, TRUE)
#define GetNumberOfMonitors() \
        GetSystemMetrics(SM_CMONITORS)
#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif /* _MMHELPER_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\mirstyls.h ===
#ifndef _MIRSTYLS_H_
#define _MIRSTYLS_H_

#define PrivateWS_EX_LAYOUTRTL         0x00400000
#define PrivateWS_EX_NOINHERITLAYOUT   0x00100000

#if (WINVER >= 0x0500)
#if WS_EX_LAYOUTRTL != PrivateWS_EX_LAYOUTRTL
#error inconsistant WS_EX_LAYOUTRTL in winuser.h
#endif
#if WS_EX_NOINHERITLAYOUT != PrivateWS_EX_NOINHERITLAYOUT
#error inconsistant WS_EX_NOINHERITLAYOUT in winuser.h
#endif
#else
#define WS_EX_LAYOUTRTL          PrivateWS_EX_LAYOUTRTL
#define WS_EX_NOINHERITLAYOUT    PrivateWS_EX_NOINHERITLAYOUT
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\mluisupp.h ===
#ifndef _INC_MLUISUPP
#define _INC_MLUISUPP

#include <shlwapi.h>
#include <shlwapip.h>

#ifdef __cplusplus
extern "C"
{
#endif

//+------------------------------------------------------------------
// Multilang Pluggable UI support
// inline functions defs (to centralize code)
//+------------------------------------------------------------------

#ifdef UNICODE
#define MLLoadString            MLLoadStringW
#define MLLoadShellLangString   MLLoadShellLangStringW
#define MLBuildResURLWrap       MLBuildResURLWrapW
#define MLLoadResources         MLLoadResourcesW
#define SHHtmlHelpOnDemandWrap  SHHtmlHelpOnDemandWrapW
#define SHWinHelpOnDemandWrap   SHWinHelpOnDemandWrapW
#else
#define MLLoadString            MLLoadStringA
#define MLLoadShellLangString   MLLoadShellLangStringA
#define MLBuildResURLWrap       MLBuildResURLWrapA
#define MLLoadResources         MLLoadResourcesA
#define SHHtmlHelpOnDemandWrap  SHHtmlHelpOnDemandWrapA
#define SHWinHelpOnDemandWrap   SHWinHelpOnDemandWrapA
#endif

void        MLFreeResources(HINSTANCE hinstParent);
HINSTANCE   MLGetHinst();
HINSTANCE   MLLoadShellLangResources();

#ifdef MLUI_MESSAGEBOX
int         MLShellMessageBox(HWND hWnd, LPCTSTR pszMsg, LPCTSTR pszTitle, UINT fuStyle, ...);
#endif

//
// The following should be both A and W suffixed
//

int         MLLoadStringA(UINT id, LPSTR sz, UINT cchMax);
int         MLLoadStringW(UINT id, LPWSTR sz, UINT cchMax);

int         MLLoadShellLangStringA(UINT id, LPSTR sz, UINT cchMax);
int         MLLoadShellLangStringW(UINT id, LPWSTR sz, UINT cchMax);

HRESULT     MLBuildResURLWrapA(LPSTR    pszLibFile,
                               HMODULE  hModule,
                               DWORD    dwCrossCodePage,
                               LPSTR    pszResName,
                               LPSTR    pszResURL,
                               int      nBufSize,
                               LPSTR    pszParentDll);

HRESULT     MLBuildResURLWrapW(LPWSTR   pszLibFile,
                               HMODULE  hModule,
                               DWORD    dwCrossCodePage,
                               LPWSTR   pszResName,
                               LPWSTR   pszResURL,
                               int      nBufSize,
                               LPWSTR   pszParentDll);

void        MLLoadResourcesA(HINSTANCE hinstParent, LPSTR pszLocResDll);
void        MLLoadResourcesW(HINSTANCE hinstParent, LPWSTR pszLocResDll);

HWND        SHHtmlHelpOnDemandWrapA(HWND hwndCaller, LPCSTR pszFile, UINT uCommand, DWORD_PTR dwData, DWORD dwCrossCodePage);
HWND        SHHtmlHelpOnDemandWrapW(HWND hwndCaller, LPCWSTR pszFile, UINT uCommand, DWORD_PTR dwData, DWORD dwCrossCodePage);

BOOL        SHWinHelpOnDemandWrapA(HWND hwndCaller, LPCSTR lpszHelp, UINT uCommand, DWORD_PTR dwData);
BOOL        SHWinHelpOnDemandWrapW(HWND hwndCaller, LPCWSTR lpszHelp, UINT uCommand, DWORD_PTR dwData);

//
// End of: The following should be both A and W suffixed
//

#ifdef MLUI_INIT

// WARNING: do not attempt to access any of these members directly
// these members may not be initialized until appropriate accessors
// are called, for example hinstLocRes won't be intialized until
// you call MLGetHinst()... so just call the accessor.
struct tagMLUI_INFO
{
    HINSTANCE   hinstLocRes;
    HINSTANCE   hinstParent;
    WCHAR       szLocResDll[MAX_PATH];
    DWORD       dwCrossCodePage;
} g_mluiInfo;


// BUGBUG REVIEW: These aren't thread safe... Do they need to be?
//
void MLLoadResourcesA(HINSTANCE hinstParent, LPSTR pszLocResDll)
{
#ifdef RIP
    RIP(hinstParent != NULL);
    RIP(pszLocResDll != NULL);
#endif

    if (g_mluiInfo.hinstLocRes == NULL)
    {
#ifdef MLUI_SUPPORT
        // plugUI: resource dll == ?
        // resource dll must be dynamically determined and loaded.
        // but we are NOT allowed to LoadLibrary during process attach.
        // therefore we cache the info we need and load later when
        // the first resource is requested.
        SHAnsiToUnicode(pszLocResDll, g_mluiInfo.szLocResDll, sizeof(g_mluiInfo.szLocResDll)/sizeof(g_mluiInfo.szLocResDll[0]));
        g_mluiInfo.hinstParent = hinstParent;
        g_mluiInfo.dwCrossCodePage = ML_CROSSCODEPAGE;
#else
        // non-plugUI: resource dll == parent dll
        g_mluiInfo.hinstLocRes = hinstParent;
#endif
    }
}

void MLLoadResourcesW(HINSTANCE hinstParent, LPWSTR pszLocResDll)
{
#ifdef RIP
    RIP(hinstParent != NULL);
    RIP(pszLocResDll != NULL);
#endif

    if (g_mluiInfo.hinstLocRes == NULL)
    {
#ifdef MLUI_SUPPORT
        // plugUI: resource dll == ?
        // resource dll must be dynamically determined and loaded.
        // but we are NOT allowed to LoadLibrary during process attach.
        // therefore we cache the info we need and load later when
        // the first resource is requested.
        StrCpyNW(g_mluiInfo.szLocResDll, pszLocResDll, sizeof(g_mluiInfo.szLocResDll)/sizeof(g_mluiInfo.szLocResDll[0]));
        g_mluiInfo.hinstParent = hinstParent;
        g_mluiInfo.dwCrossCodePage = ML_CROSSCODEPAGE;
#else
        // non-plugUI: resource dll == parent dll
        g_mluiInfo.hinstLocRes = hinstParent;
#endif
    }
}

void
MLFreeResources(HINSTANCE hinstParent)
{
    if (g_mluiInfo.hinstLocRes != NULL &&
        g_mluiInfo.hinstLocRes != hinstParent)
    {
        MLClearMLHInstance(g_mluiInfo.hinstLocRes);
        g_mluiInfo.hinstLocRes = NULL;
    }
}

// this is a private internal helper.
// don't you dare call it from anywhere except at
// the beginning of new ML* functions in this file
__inline void
_MLResAssure()
{
#ifdef MLUI_SUPPORT
    if(g_mluiInfo.hinstLocRes == NULL)
    {
        g_mluiInfo.hinstLocRes = MLLoadLibraryW(g_mluiInfo.szLocResDll,
                                               g_mluiInfo.hinstParent,
                                               g_mluiInfo.dwCrossCodePage);

        // we're guaranteed to at least have resources in the install language
        ASSERT(g_mluiInfo.hinstLocRes != NULL);
    }
#endif
}

int
MLLoadStringA(UINT id, LPSTR sz, UINT cchMax)
{
    _MLResAssure();
    return LoadStringA(g_mluiInfo.hinstLocRes, id, sz, cchMax);
}

int
MLLoadStringW(UINT id, LPWSTR sz, UINT cchMax)
{
    _MLResAssure();
    return LoadStringWrapW(g_mluiInfo.hinstLocRes, id, sz, cchMax);
}

int
MLLoadShellLangStringA(UINT id, LPSTR sz, UINT cchMax)
{
    HINSTANCE   hinstShellLangRes;
    int         nRet;

    hinstShellLangRes = MLLoadShellLangResources();
    
    nRet = LoadStringA(hinstShellLangRes, id, sz, cchMax);

    MLFreeLibrary(hinstShellLangRes);

    return nRet;
}

int
MLLoadShellLangStringW(UINT id, LPWSTR sz, UINT cchMax)
{
    HINSTANCE   hinstShellLangRes;
    int         nRet;

    hinstShellLangRes = MLLoadShellLangResources();
    
    nRet = LoadStringWrapW(hinstShellLangRes, id, sz, cchMax);

    MLFreeLibrary(hinstShellLangRes);

    return nRet;
}

HINSTANCE
MLGetHinst()
{
    _MLResAssure();
    return g_mluiInfo.hinstLocRes;
}

HINSTANCE
MLLoadShellLangResources()
{
    HINSTANCE hinst;
    
    hinst = MLLoadLibraryW(g_mluiInfo.szLocResDll,
                           g_mluiInfo.hinstParent,
                           ML_SHELL_LANGUAGE);

    // we're guaranteed to at least have resources in the install language
    // unless we're 100% toasted
    ASSERT(hinst != NULL);

    return hinst;
}

#ifdef MLUI_MESSAGEBOX
int MLShellMessageBox(HWND hWnd, LPCTSTR pszMsg, LPCTSTR pszTitle, UINT fuStyle, ...)
{
    va_list     vaList;
    int         nRet            = 0;
    LPTSTR      pszFormattedMsg = NULL;
    TCHAR       szTitleBuf[256];
    TCHAR       szBuffer[1024];

    //
    // prepare the message
    //

    if (IS_INTRESOURCE(pszMsg))
    {
        if (MLLoadShellLangString(LOWORD((DWORD_PTR)pszMsg), szBuffer, ARRAYSIZE(szBuffer)))
        {
            pszMsg = szBuffer;
        }
    }

    if (!IS_INTRESOURCE(pszMsg) &&  // the string load might have failed
        pszMsg != NULL)
    {
        va_start(vaList, fuStyle);

        if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                          pszMsg, 0, 0, (LPTSTR)&pszFormattedMsg, 0, &vaList))
        {
            pszMsg = pszFormattedMsg;
        }

        va_end(vaList);
    }

    //
    // prepare the title
    //

    if (!IS_INTRESOURCE(pszTitle) && pszTitle != NULL)
    {
        // do nothing
    }
    else if (pszTitle != NULL && MLLoadShellLangString(LOWORD((DWORD_PTR)pszTitle), szTitleBuf, ARRAYSIZE(szTitleBuf)))
    {
        pszTitle = szTitleBuf;
    }
    else if (hWnd && GetWindowText(hWnd, szTitleBuf, ARRAYSIZE(szTitleBuf)))
    {
        pszTitle = szTitleBuf;
    }
    else
    {
        pszTitle = TEXT("");
    }

    //
    // launch a MessageBox
    //

    nRet = MessageBox(hWnd, pszFormattedMsg, pszTitle, fuStyle | MB_SETFOREGROUND);

    if (pszFormattedMsg != NULL)
    {
        LocalFree(pszFormattedMsg);
    }

    return nRet;
}
#endif // MLUI_MESSAGEBOX

#include "htmlhelp.h"

HWND 
SHHtmlHelpOnDemandWrapA(HWND hwndCaller, 
                       LPCSTR pszFile,
                       UINT uCommand,
                       DWORD_PTR dwData,
                       DWORD dwCrossCodePage)
{
    BOOL    fEnabled;

#ifdef MLUI_SUPPORT
    fEnabled = TRUE;
#else
    fEnabled = FALSE;
#endif

    return SHHtmlHelpOnDemandA(hwndCaller,
                              pszFile,
                              uCommand,
                              dwData,
                              dwCrossCodePage,
                              fEnabled);
}

HWND 
SHHtmlHelpOnDemandWrapW(HWND hwndCaller, 
                       LPCWSTR pszFile,
                       UINT uCommand,
                       DWORD_PTR dwData,
                       DWORD dwCrossCodePage)
{
    BOOL    fEnabled;

#ifdef MLUI_SUPPORT
    fEnabled = TRUE;
#else
    fEnabled = FALSE;
#endif

    return SHHtmlHelpOnDemandW(hwndCaller,
                              pszFile,
                              uCommand,
                              dwData,
                              dwCrossCodePage,
                              fEnabled);
}

HWND
MLHtmlHelpWrap(HWND hwndCaller,
               LPCTSTR pszFile,
               UINT uCommand,
               DWORD dwData,
               DWORD dwCrossCodePage)
{
    HWND    hwnd;

#ifdef MLUI_SUPPORT
    hwnd = MLHtmlHelp(hwndCaller,
                      pszFile,
                      uCommand,
                      dwData,
                      dwCrossCodePage);
#else
    hwnd = HtmlHelp(hwndCaller,
                    pszFile,
                    uCommand,
                    dwData);
#endif

    return hwnd;
}

BOOL
SHWinHelpOnDemandWrapA(HWND hwndCaller,
                      LPCSTR lpszHelp,
                      UINT uCommand,
                      DWORD_PTR dwData)
{
    BOOL    fEnabled;

#ifdef MLUI_SUPPORT
    fEnabled = TRUE;
#else
    fEnabled = FALSE;
#endif

    return SHWinHelpOnDemandA(hwndCaller,
                             lpszHelp,
                             uCommand,
                             dwData,
                             fEnabled);

}

BOOL
SHWinHelpOnDemandWrapW(HWND hwndCaller,
                      LPCWSTR lpszHelp,
                      UINT uCommand,
                      DWORD_PTR dwData)
{
    BOOL    fEnabled;

#ifdef MLUI_SUPPORT
    fEnabled = TRUE;
#else
    fEnabled = FALSE;
#endif

    return SHWinHelpOnDemandW(hwndCaller,
                             lpszHelp,
                             uCommand,
                             dwData,
                             fEnabled);

}

BOOL
MLWinHelpWrap(HWND hwndCaller,
                   LPCTSTR lpszHelp,
                   UINT uCommand,
                   DWORD dwData)
{
    BOOL    fRet;

#ifdef MLUI_SUPPORT
    fRet = MLWinHelp(hwndCaller,
                     lpszHelp,
                     uCommand,
                     dwData);
#else
    fRet = WinHelp(hwndCaller,
                   lpszHelp,
                   uCommand,
                   dwData);
#endif

    return fRet;
}

HRESULT
MLBuildResURLWrapA(LPSTR    pszLibFile,
                   HMODULE  hModule,
                   DWORD    dwCrossCodePage,
                   LPSTR    pszResName,
                   LPSTR    pszResURL,
                   int      nBufSize,
                   LPSTR    pszParentDll)
{
    HRESULT hr;

#ifdef MLUI_SUPPORT
    hr = MLBuildResURLA(pszLibFile,
                        hModule,
                        dwCrossCodePage,
                        pszResName,
                        pszResURL,
                        nBufSize);
#else
    wnsprintfA(pszResURL, nBufSize, "res://%s/%s", pszParentDll, pszResName);
    hr = S_OK;
#endif

    return hr;
}

HRESULT
MLBuildResURLWrapW(LPWSTR   pszLibFile,
                   HMODULE  hModule,
                   DWORD    dwCrossCodePage,
                   LPWSTR   pszResName,
                   LPWSTR   pszResURL,
                   int      nBufSize,
                   LPWSTR   pszParentDll)
{
    HRESULT hr;

#ifdef MLUI_SUPPORT
    hr = MLBuildResURLW(pszLibFile,
                        hModule,
                        dwCrossCodePage,
                        pszResName,
                        pszResURL,
                        nBufSize);
#else
    wnsprintfW(pszResURL, nBufSize, L"res://%s/%s", pszParentDll, pszResName);
    hr = S_OK;
#endif

    return hr;
}

#endif  // MLUI_INIT

#ifdef __cplusplus
};
#endif

#endif  // _INC_MLUISUPP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\xdktools\xbnmspc\inc\pif.h ===
/*
 *  Microsoft  Confidential
 *  Copyright (C) Microsoft Corporation 1991-1995
 *  All Rights Reserved.
 *
 *
 *  PIF.H
 *  DOS Program Information File structures, constants, etc.
 */


#ifndef _INC_PIF
#define _INC_PIF

/* XLATOFF */
#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */
/* XLATON */

#define PIFNAMESIZE     30
#define PIFSTARTLOCSIZE 63
#define PIFDEFPATHSIZE  64
#define PIFPARAMSSIZE   64
#define PIFSHPROGSIZE   64
#define PIFSHDATASIZE   64
#define PIFDEFFILESIZE  80
#define PIFMAXFILEPATH  260

#ifndef LF_FACESIZE
#define LF_FACESIZE     32
#endif

#define LARGEST_GROUP   sizeof(PROPPRG)

#define OPENPROPS_NONE          0x0000
#define OPENPROPS_RAWIO         0x0001
#define OPENPROPS_INFONLY       0x0002
#define OPENPROPS_FORCEREALMODE 0x0004
#define OPENPROPS_INHIBITPIF    0x8000

#define GETPROPS_NONE           0x0000
#define GETPROPS_RAWIO          0x0001
#define GETPROPS_EXTENDED       0x0004          // ;Internal
#define GETPROPS_OEM            0x0008

#define SETPROPS_NONE           0x0000
#define SETPROPS_RAWIO          0x0001
#define SETPROPS_CACHE          0x0002
#define SETPROPS_EXTENDED       0x0004          // ;Internal
#define SETPROPS_OEM            0x0008

#define FLUSHPROPS_NONE         0x0000
#define FLUSHPROPS_DISCARD      0x0001

#define CLOSEPROPS_NONE         0x0000
#define CLOSEPROPS_DISCARD      0x0001

#define CREATEPROPS_NONE        0x0000

#define DELETEPROPS_NONE        0x0000
#define DELETEPROPS_DISCARD     0x0001
#define DELETEPROPS_ABORT       0x0002

#define LOADPROPLIB_DEFER       0x0001


/* XLATOFF */
#ifndef FAR
#define FAR
#endif
/* XLATON */

//#ifdef  RECT
//#define _INC_WINDOWS
//#endif

//#ifndef _INC_WINDOWS

/* ASM
RECT    struc
        rcLeft      dw  ?
        rcTop       dw  ?
        rcRight     dw  ?
        rcBottom    dw  ?
RECT    ends
*/

/* XLATOFF */
typedef struct tagPIFRECT {
    WORD left;
    WORD top;
    WORD right;
    WORD bottom;
} PIFRECT;
typedef PIFRECT *PPIFRECT;
typedef PIFRECT FAR *LPPIFRECT;
/* XLATON */

//#endif


/*
 *  Property groups, used by PIFMGR.DLL and VxD interfaces
 *
 *  The structures for each of the pre-defined, ordinal-based groups
 *  is a logical view of data in the associated PIF file, if any -- not a
 *  physical view.
 */

#define GROUP_PRG               1           // program group

#define PRG_DEFAULT             0
#define PRG_CLOSEONEXIT         0x0001      // MSflags & EXITMASK
#define PRG_NOSUGGESTMSDOS      0x0400      // see also: PfW386Flags & fNoSuggestMSDOS

#define PRGINIT_DEFAULT         0
#define PRGINIT_MINIMIZED       0x0001      // see also: PfW386Flags & fMinimized
#define PRGINIT_MAXIMIZED       0x0002      // see also: PfW386Flags & fMaximized
#define PRGINIT_WINLIE          0x0004      // see also: PfW386Flags & fWinLie
#define PRGINIT_REALMODE        0x0008      // see also: PfW386Flags & fRealMode
#define PRGINIT_REALMODESILENT  0x0100      // see also: PfW386Flags & fRealModeSilent
#define PRGINIT_QUICKSTART      0x0200      // see also: PfW386Flags & fQuickStart  /* ;Internal */
#define PRGINIT_AMBIGUOUSPIF    0x0400      // see also: PfW386Flags & fAmbiguousPIF
#define PRGINIT_NOPIF           0x1000      // no PIF found
#define PRGINIT_DEFAULTPIF      0x2000      // default PIF found
#define PRGINIT_INFSETTINGS     0x4000      // INF settings found
#define PRGINIT_INHIBITPIF      0x8000      // INF indicates that no PIF be created

/*
 *  Real mode option flags.  NOTE: this field is a dword.  The low word
 *  uses these flags to indicate required options.  The high word is used
 *  to specify "nice" but not required options.
 */
#define RMOPT_MOUSE             0x0001      // Real mode mouse
#define RMOPT_EMS               0x0002      // Expanded Memory
#define RMOPT_CDROM             0x0004      // CD-ROM support
#define RMOPT_NETWORK           0x0008      // Network support
#define RMOPT_DISKLOCK          0x0010      // disk locking required
#define RMOPT_PRIVATECFG        0x0020      // use private configuration (ie, CONFIG/AUTOEXEC)
#define RMOPT_VESA              0x0040      // VESA driver


#define ICONFILE_DEFAULT        TEXT("PIFMGR.DLL")
#define ICONINDEX_DEFAULT       0

typedef struct PROPPRG {                    /* prg */
    WORD    flPrg;                          // see PRG_ flags
    WORD    flPrgInit;                      // see PRGINIT_ flags
    CHAR    achTitle[PIFNAMESIZE];          // name[30]
    CHAR    achCmdLine[PIFSTARTLOCSIZE+PIFPARAMSSIZE+1];// startfile[63] + params[64]
    CHAR    achWorkDir[PIFDEFPATHSIZE];     // defpath[64]
    WORD    wHotKey;                        // PfHotKeyScan thru PfHotKeyVal
    CHAR    achIconFile[PIFDEFFILESIZE];    // name of file containing icon
    WORD    wIconIndex;                     // index of icon within file
    DWORD   dwEnhModeFlags;                 // reserved enh-mode flags
    DWORD   dwRealModeFlags;                // real-mode flags (see RMOPT_*)
    CHAR    achOtherFile[PIFDEFFILESIZE];   // name of "other" file in directory
    CHAR    achPIFFile[PIFMAXFILEPATH];     // name of PIF file
} PROPPRG;
typedef UNALIGNED PROPPRG *PPROPPRG;
typedef UNALIGNED PROPPRG FAR *LPPROPPRG;
typedef const UNALIGNED PROPPRG FAR *LPCPROPPRG;



#define GROUP_TSK               2           // tasking group

#define TSK_DEFAULT             (TSK_BACKGROUND)
#define TSK_ALLOWCLOSE          0x0001      // PfW386Flags & fEnableClose
#define TSK_BACKGROUND          0x0002      // PfW386Flags & fBackground
#define TSK_EXCLUSIVE           0x0004      // PfW386Flags & fExclusive             /* ;Internal */
#define TSK_NOWARNTERMINATE     0x0010      // Don't warn before closing
#define TSK_NOSCREENSAVER       0x0020      // Do not activate screen saver

#define TSKINIT_DEFAULT         0

#define TSKFGNDBOOST_DEFAULT    0           // fgnd boost                           /* ;Internal */
#define TSKBGNDBOOST_DEFAULT    0           // bgnd boost                           /* ;Internal */
                                                                                    /* ;Internal */
#define TSKFGND_OLD_DEFAULT     100         // normal fgnd setting                  /* ;Internal */
#define TSKBGND_OLD_DEFAULT     50          // normal bgnd setting                  /* ;Internal */
                                                                                    /* ;Internal */
#define TSKIDLESENS_DEFAULT     50          // % (min-max == 0-100)

typedef struct PROPTSK {                    /* tsk */
    WORD    flTsk;                          // see TSK_ flags
    WORD    flTskInit;                      // see TSKINIT_ flags
    WORD    wReserved1;                     // (reserved, must be zero)
    WORD    wReserved2;                     // (reserved, must be zero)
    WORD    wReserved3;                     // (reserved, must be zero)
    WORD    wReserved4;                     // (reserved, must be zero)
    WORD    wIdleSensitivity;               // %, also affects PfW386Flags & fPollingDetect
} PROPTSK;
typedef UNALIGNED PROPTSK *PPROPTSK;
typedef UNALIGNED PROPTSK FAR *LPPROPTSK;


#define GROUP_VID               3           // video group

#define VID_DEFAULT             (VID_TEXTEMULATE)
#define VID_TEXTEMULATE         0x0001      // PfW386Flags2 & fVidTxtEmulate
#define VID_RETAINMEMORY        0x0080      // PfW386Flags2 & fVidRetainAllo
#define VID_FULLSCREEN          0x0100      // PfW386Flags  & fFullScreen

#define VIDINIT_DEFAULT         0

#define VIDSCREENLINES_MIN      0           // in # lines (0 = use VDD value)
#define VIDSCREENLINES_DEFAULT  0           // in # lines
#define VIDSCREENLINES_MAX      50          // in # lines                           /* ;Internal */

typedef struct PROPVID {                    /* vid */
    WORD    flVid;                          // see VID_ flags
    WORD    flVidInit;                      // see VIDINIT_ flags
    WORD    wReserved1;                     // (reserved, must be zero)
    WORD    wReserved2;                     // (reserved, must be zero)
    WORD    wReserved3;                     // (reserved, must be zero)
    WORD    cScreenLines;                   // ([NonWindowsApp]:ScreenLines)
} PROPVID;
typedef UNALIGNED PROPVID *PPROPVID;
typedef UNALIGNED PROPVID FAR *LPPROPVID;


#define GROUP_MEM               4           // memory group

#define MEM_DEFAULT             0

#define MEMINIT_DEFAULT         0
#define MEMINIT_NOHMA           0x0001      // PfW386Flags & fNoHMA
#define MEMINIT_LOWLOCKED       0x0002      // PfW386Flags & fVMLocked
#define MEMINIT_EMSLOCKED       0x0004      // PfW386Flags & fEMSLocked
#define MEMINIT_XMSLOCKED       0x0008      // PfW386Flags & fXMSLocked
#define MEMINIT_GLOBALPROTECT   0x0010      // PfW386Flags & fGlobalProtect
#define MEMINIT_STRAYPTRDETECT  0x0020      // PfW386Flags & fStrayPtrDetect        /* ;Internal */
#define MEMINIT_LOCALUMBS       0x0040      // PfW386Flags & fLocalUMBs             /* ;Internal */

#define MEMLOW_MIN              0           // in KB
#define MEMLOW_DEFAULT          0           // in KB
#define MEMLOW_MAX              640         // in KB

#define MEMEMS_MIN              0           // in KB
#define MEMEMS_DEFAULT          0           // in KB
#define MEMEMS_MAX              0xFFFF      // in KB

#define MEMXMS_MIN              0           // in KB
#define MEMXMS_DEFAULT          0           // in KB
#define MEMXMS_MAX              0xFFFF      // in KB

typedef struct PROPMEM {                    /* mem */
    WORD    flMem;                          // see MEM_ flags
    WORD    flMemInit;                      // see MEMINIT_ flags
    WORD    wMinLow;                        // PfW386minmem
    WORD    wMaxLow;                        // PfW386maxmem
    WORD    wMinEMS;                        // PfMinEMMK
    WORD    wMaxEMS;                        // PfMaxEMMK
    WORD    wMinXMS;                        // PfMinXmsK
    WORD    wMaxXMS;                        // PfMaxXmsK
} PROPMEM;
typedef UNALIGNED PROPMEM *PPROPMEM;
typedef UNALIGNED PROPMEM FAR *LPPROPMEM;


#define GROUP_KBD               5           // keyboard group

#define KBD_DEFAULT             (KBD_FASTPASTE)
#define KBD_FASTPASTE           0x0001      // PfW386Flags & fINT16Paste
#define KBD_NOALTTAB            0x0020      // PfW386Flags & fALTTABdis
#define KBD_NOALTESC            0x0040      // PfW386Flags & fALTESCdis
#define KBD_NOALTSPACE          0x0080      // PfW386Flags & fALTSPACEdis
#define KBD_NOALTENTER          0x0100      // PfW386Flags & fALTENTERdis
#define KBD_NOALTPRTSC          0x0200      // PfW386Flags & fALTPRTSCdis
#define KBD_NOPRTSC             0x0400      // PfW386Flags & fPRTSCdis
#define KBD_NOCTRLESC           0x0800      // PfW386Flags & fCTRLESCdis

#define KBDINIT_DEFAULT         0

#define KBDALTDELAY_MIN             1
#define KBDALTDELAY_DEFAULT         5
#define KBDALTDELAY_MAX             5000

#define KBDALTPASTEDELAY_MIN        1
#define KBDALTPASTEDELAY_DEFAULT    25
#define KBDALTPASTEDELAY_MAX        5000

#define KBDPASTEDELAY_MIN           1
#define KBDPASTEDELAY_DEFAULT       3
#define KBDPASTEDELAY_MAX           5000

#define KBDPASTEFULLDELAY_MIN       1
#define KBDPASTEFULLDELAY_DEFAULT   200
#define KBDPASTEFULLDELAY_MAX       5000

#define KBDPASTETIMEOUT_MIN         1
#define KBDPASTETIMEOUT_DEFAULT     1000
#define KBDPASTETIMEOUT_MAX         5000

#define KBDPASTESKIP_MIN            1
#define KBDPASTESKIP_DEFAULT        2
#define KBDPASTESKIP_MAX            100

#define KBDPASTECRSKIP_MIN          1
#define KBDPASTECRSKIP_DEFAULT      10
#define KBDPASTECRSKIP_MAX          100

typedef struct PROPKBD {                    /* kbd */
    WORD    flKbd;                          // see KBD_ flags
    WORD    flKbdInit;                      // see KBDINIT_ flags
    WORD    msAltDelay;                     // ([386Enh]:AltKeyDelay)
    WORD    msAltPasteDelay;                // ([386Enh]:AltPasteDelay)
    WORD    msPasteDelay;                   // ([386Enh]:KeyPasteDelay)
    WORD    msPasteFullDelay;               // ([386Enh]:KeyBufferDelay)
    WORD    msPasteTimeout;                 // ([386Enh]:KeyPasteTimeOut)
    WORD    cPasteSkip;                     // ([386Enh]:KeyPasteSkipCount)
    WORD    cPasteCRSkip;                   // ([386Enh]:KeyPasteCRSkipCount)
} PROPKBD;
typedef UNALIGNED PROPKBD *PPROPKBD;
typedef UNALIGNED PROPKBD FAR *LPPROPKBD;


#define GROUP_MSE               6           // mouse group

/* No VxD currently pays attention to PROPMSE. VMDOSAPP should know how to
 * handle all cases resulting from a change in these flags.
 *
 * Note that MSE_WINDOWENABLE corresponds to the Windows NT "QuickEdit"
 * property, except backwards.
 */

#define MSE_DEFAULT             (MSE_WINDOWENABLE)
#define MSE_WINDOWENABLE        0x0001      // ([NonWindowsApp]:MouseInDosBox)
#define MSE_EXCLUSIVE           0x0002      //

#define MSEINIT_DEFAULT         0           // default flags

typedef struct PROPMSE {                    /* mse */
    WORD    flMse;                          // see MSE_ flags
    WORD    flMseInit;                      // see MSEINIT_ flags
} PROPMSE;
typedef UNALIGNED PROPMSE *PPROPMSE;
typedef UNALIGNED PROPMSE FAR *LPPROPMSE;


#define GROUP_SND               7           // sound group                  /* ;Internal */
                                                                            /* ;Internal */
#define SND_DEFAULT             (SND_SPEAKERENABLE)                         /* ;Internal */
#define SND_SPEAKERENABLE       0x0001      //                              /* ;Internal */
                                                                            /* ;Internal */
#define SNDINIT_DEFAULT         0                                           /* ;Internal */
                                                                            /* ;Internal */
typedef struct PROPSND {                    /* snd */                       /* ;Internal */
    WORD    flSnd;                          // see SND_ flags               /* ;Internal */
    WORD    flSndInit;                      // see SNDINIT_ flags           /* ;Internal */
} PROPSND;                                                                  /* ;Internal */
typedef UNALIGNED PROPSND *PPROPSND;                                        /* ;Internal */
typedef UNALIGNED PROPSND FAR *LPPROPSND;                                   /* ;Internal */
                                                                            /* ;Internal */
                                                                            /* ;Internal */
#define GROUP_FNT               8           // font group

#define FNT_DEFAULT             (FNT_BOTHFONTS | FNT_AUTOSIZE)
#define FNT_RASTERFONTS         0x0004      // allow raster fonts in dialog
#define FNT_TTFONTS             0x0008      // allow truetype fonts in dialog
#define FNT_BOTHFONTS           (FNT_RASTERFONTS | FNT_TTFONTS)
#define FNT_AUTOSIZE            0x0010      // enable auto-sizing
#define FNT_RASTER              0x0400      // specified font is raster
#define FNT_TT                  0x0800      // specified font is truetype

#define FNT_FONTMASK            (FNT_BOTHFONTS)
#define FNT_FONTMASKBITS        2           // # of bits shifted left

#define FNTINIT_DEFAULT         0
#define FNTINIT_NORESTORE       0x0001      // don't restore on restart

typedef struct PROPFNT {                    /* fnt */
    WORD    flFnt;                          // see FNT_ flags
    WORD    flFntInit;                      // see FNTINIT_ flags
    WORD    cxFont;                         // width of desired font
    WORD    cyFont;                         // height of desired font
    WORD    cxFontActual;                   // actual width of desired font
    WORD    cyFontActual;                   // actual height of desired font
    CHAR    achRasterFaceName[LF_FACESIZE]; // name to use for raster font
    CHAR    achTTFaceName[LF_FACESIZE];     // name to use for tt font
    WORD    wCurrentCP;                     // Current Codepage
} PROPFNT;
typedef UNALIGNED PROPFNT *PPROPFNT;
typedef UNALIGNED PROPFNT FAR *LPPROPFNT;

#define GROUP_WIN               9          // window group

#define WIN_DEFAULT             (WIN_SAVESETTINGS | WIN_TOOLBAR)
#define WIN_SAVESETTINGS        0x0001      // save settings on exit (default)
#define WIN_TOOLBAR             0x0002      // enable toolbar

#define WININIT_DEFAULT         0
#define WININIT_NORESTORE       0x0001      // don't restore on restart

typedef struct PROPWIN {                    /* win */
    WORD    flWin;                          // see WIN_ flags
    WORD    flWinInit;                      // see WININIT flags
    WORD    cxCells;                        // width in cells
    WORD    cyCells;                        // height in cells
    WORD    cxClient;                       // width of client window
    WORD    cyClient;                       // height of client window
    WORD    cxWindow;                       // width of entire window
    WORD    cyWindow;                       // height of entire window
    WORD    wLength;
    WORD    wShowFlags;
    WORD    wShowCmd;
    WORD    xMinimize;
    WORD    yMinimize;
    WORD    xMaximize;
    WORD    yMaximize;
    PIFRECT rcNormal;
} PROPWIN;
typedef UNALIGNED PROPWIN *PPROPWIN;
typedef UNALIGNED PROPWIN FAR *LPPROPWIN;

#define PIF_WP_SIZE             ((sizeof(WORD)*7) + sizeof(PIFRECT))

#define GROUP_ENV               10          // environment/startup group

#define ENV_DEFAULT             0

#define ENVINIT_DEFAULT         0

#define ENVSIZE_MIN             0
#define ENVSIZE_DEFAULT         0
#define ENVSIZE_MAX             32768

#define ENVDPMI_MIN             0           // in KB
#define ENVDPMI_DEFAULT         0           // in KB (0 = Auto)
#define ENVDPMI_MAX             0xFFFF      // in KB

typedef struct PROPENV {                    /* env */
    WORD    flEnv;                          // see ENV_ flags
    WORD    flEnvInit;                      // see ENVINIT_ flags
    CHAR    achBatchFile[PIFDEFFILESIZE];   //
    WORD    cbEnvironment;                  // ([386Enh]:CommandEnvSize)
    WORD    wMaxDPMI;                       // (NEW)
} PROPENV;
typedef UNALIGNED PROPENV *PPROPENV;
typedef UNALIGNED PROPENV FAR *LPPROPENV;

#ifdef WINNT

#define GROUP_NT31              11
#ifndef UNICODE
#define MAX_VALID_GROUP         GROUP_NT31
#endif

typedef struct PROPNT31 {
   DWORD dwWNTFlags;                                                        /* ;Internal */
   DWORD dwRes1;                                                            /* ;Internal */
   DWORD dwRes2;                                                            /* ;Internal */
   char  achConfigFile[PIFDEFPATHSIZE];                                     /* ;Internal */
   char  achAutoexecFile[PIFDEFPATHSIZE];                                   /* ;Internal */
} PROPNT31;
typedef UNALIGNED PROPNT31 *PPROPNT31;
typedef UNALIGNED PROPNT31 FAR *LPPROPNT31;
#define COMPAT_TIMERTIC 0x10                                                /* ;Internal */
#define NT31_COMPATTIMER COMPAT_TIMERTIC                                    /* ;Internal */
#endif

#ifdef UNICODE
#ifdef GROUP_NT31
#define GROUP_NT40              12
#else
#define GROUP_NT40              11
#endif
#define MAX_VALID_GROUP         GROUP_NT40


#define WNT_LET_SYS_POS         0x0001
#define WNT_CONSOLE_PROPS       0x0002

typedef struct PROPNT40 {                                   /* wnt */
   DWORD    flWnt;                                          // NT Specific PIF falgs

// UNICODE version of strings, and copy of ANSI to see if they've changed

   WCHAR    awchCmdLine[PIFSTARTLOCSIZE+PIFPARAMSSIZE+1];   // Command line
   CHAR     achSaveCmdLine[PIFSTARTLOCSIZE+PIFPARAMSSIZE+1];// Saved ANSI Command Line

   WCHAR    awchOtherFile[PIFDEFFILESIZE];                  // name of "other" file in directory
   CHAR     achSaveOtherFile[PIFDEFFILESIZE];               // Saved ANSI "other" file in directory

   WCHAR    awchPIFFile[PIFDEFFILESIZE];                    // name of PIF file
   CHAR     achSavePIFFile[PIFDEFFILESIZE];                 // Saved ANSI name of PIF file

   WCHAR    awchTitle[PIFNAMESIZE];                         // Title for cmd window
   CHAR     achSaveTitle[PIFNAMESIZE];                      // Saved ANSI Title for cmd window

   WCHAR    awchIconFile[PIFDEFFILESIZE];                   // Name of file containing icons
   CHAR     achSaveIconFile[PIFDEFFILESIZE];                // Saved ANSI Name of file containing icons

   WCHAR    awchWorkDir[PIFDEFPATHSIZE];                    // working directory
   CHAR     achSaveWorkDir[PIFDEFPATHSIZE];                 // Saved ANSI working directory

   WCHAR    awchBatchFile[PIFDEFFILESIZE];                  // batch file
   CHAR     achSaveBatchFile[PIFDEFFILESIZE];               // Saved ANSI batch file

// Console properties

   DWORD    dwForeColor;                                    // Console Text Foreground Color
   DWORD    dwBackColor;                                    // Console Text Background Color
   DWORD    dwPopupForeColor;                               // Console Popup Text Foreground Color
   DWORD    dwPopupBackColor;                               // Console Popup Text Background Color
   COORD    WinSize;                                        // Console Window Size
   COORD    BuffSize;                                       // Console Buffer Size
   POINT    WinPos;                                         // Console Window Position
   DWORD    dwCursorSize;                                   // Console Cursor Size
   DWORD    dwCmdHistBufSize;                               // Console Command Histroy Buffer Size
   DWORD    dwNumCmdHist;                                   // Number of Command Histories for Console

} PROPNT40;
typedef UNALIGNED PROPNT40 *PPROPNT40;
typedef UNALIGNED PROPNT40 FAR *LPPROPNT40;

#else

#ifndef WINNT
#define MAX_VALID_GROUP         GROUP_ENV
#endif

#endif // UNICODE

#define GROUP_ICON              (MAX_VALID_GROUP+1)
#define GROUP_MAX               0x0FF

                                                                                // ;Internal
                                                                                // ;Internal
/*                                                                              // ;Internal
 * Additional group ordinal bits that can be passed to VxD property hooks       // ;Internal
 */                                                                             // ;Internal
#define EXT_GROUP_QUERY         0x100                                           // ;Internal
#define EXT_GROUP_UPDATE        0x200                                           // ;Internal
                                                                                // ;Internal
                                                                                // ;Internal
/*
 *  PIF "file" structures, used by .PIFs
 */

#define PIFEXTSIGSIZE   16                  // Length of extension signatures
#define MAX_GROUP_NAME  PIFEXTSIGSIZE       //
#define STDHDRSIG       "MICROSOFT PIFEX"   // extsig value for stdpifext
#define LASTHDRPTR      0xFFFF              // This value in the
                                            //  extnxthdrfloff field indicates
                                            //   there are no more extensions.
#define W286HDRSIG30     "WINDOWS 286 3.0"
#define W386HDRSIG30     "WINDOWS 386 3.0"
#define WNTHDRSIG31      "WINDOWS NT  3.1"
#define WENHHDRSIG40     "WINDOWS VMM 4.0"  //
#define WNTHDRSIG40      "WINDOWS NT  4.0"

#define CONFIGHDRSIG40   "CONFIG  SYS 4.0"  //
#define AUTOEXECHDRSIG40 "AUTOEXECBAT 4.0"  //

#define MAX_CONFIG_SIZE     4096
#define MAX_AUTOEXEC_SIZE   4096

#define CONFIGFILE      TEXT("\\CONFIG.SYS")      // normal filenames
#define AUTOEXECFILE    TEXT("\\AUTOEXEC.BAT")

#define MCONFIGFILE     TEXT("\\CONFIG.APP")      // msdos-mode temp filenames
#define MAUTOEXECFILE   TEXT("\\AUTOEXEC.APP")

#define WCONFIGFILE     TEXT("\\CONFIG.WOS")      // windows-mode temp filenames
#define WAUTOEXECFILE   TEXT("\\AUTOEXEC.WOS")


typedef struct PIFEXTHDR {                  /* peh */
    CHAR    extsig[PIFEXTSIGSIZE];
    WORD    extnxthdrfloff;
    WORD    extfileoffset;
    WORD    extsizebytes;
} PIFEXTHDR;
typedef UNALIGNED PIFEXTHDR *PPIFEXTHDR;
typedef UNALIGNED PIFEXTHDR FAR *LPPIFEXTHDR;


/* Flags for MSflags
 */

#define fResident       0x01    // Directly Modifies: Memory
#define fGraphics       0x02    // Screen Exchange: Graphics/Text
#define fNoSwitch       0x04    // Program Switch: Prevent
#define fNoGrab         0x08    // Screen Exchange: None
#define fDestroy        0x10    // Close Window on exit
#define fCOM2           0x40    // Directly Modifies: COM2
#define fCOM1           0x80    // Directly Modifies: COM1

#define MEMMASK         fResident
#define GRAPHMASK       fGraphics
#define TEXTMASK        ((BYTE)(~GRAPHMASK))
#define PSMASK          fNoSwitch
#define SGMASK          fNoGrab
#define EXITMASK        fDestroy
#define COM2MASK        fCOM2
#define COM1MASK        fCOM1

/* Flags for behavior
 */
#define fScreen         0x80    // Directly Modifies: Screen
#define fForeground     0x40    // Set same as fScreen (alias)
#define f8087           0x20    // No PIFEDIT control
#define fKeyboard       0x10    // Directly Modifies: Keyboard

#define SCRMASK         (fScreen + fForeground)
#define MASK8087        f8087
#define KEYMASK         fKeyboard

/* Flags for sysflags
 */

#define SWAPMASK        0x20
#define PARMMASK        0x40

/*
 * All strings in the STDPIF are in the OEM character set.
 */
typedef struct STDPIF {                     /* std */ //Examples
    BYTE    unknown;                        // 0x00     0x00
    BYTE    id;                             // 0x01     0x78
    CHAR    appname[PIFNAMESIZE];           // 0x02     'MS-DOS Prompt'
    WORD    maxmem;                         // 0x20     0x0200 (512Kb)
    WORD    minmem;                         // 0x22     0x0080 (128Kb)
    CHAR    startfile[PIFSTARTLOCSIZE];     // 0x24     "COMMAND.COM"
    BYTE    MSflags;                        // 0x63     0x10
    BYTE    reserved;                       // 0x64     0x00
    CHAR    defpath[PIFDEFPATHSIZE];        // 0x65     "\"
    CHAR    params[PIFPARAMSSIZE];          // 0xA5     ""
    BYTE    screen;                         // 0xE5     0x00
    BYTE    cPages;                         // 0xE6     0x01 (ALWAYS!)
    BYTE    lowVector;                      // 0xE7     0x00 (ALWAYS!)
    BYTE    highVector;                     // 0xE8     0xFF (ALWAYS!)
    BYTE    rows;                           // 0xE9     0x19 (Not used)
    BYTE    cols;                           // 0xEA     0x50 (Not used)
    BYTE    rowoff;                         // 0xEB     0x00 (Not used)
    BYTE    coloff;                         // 0xEC     0x00 (Not used)
    WORD    sysmem;                         // 0xED   0x0007 (Not used; 7=>Text, 23=>Grfx/Mult Text)
    CHAR    shprog[PIFSHPROGSIZE];          // 0xEF     0's  (Not used)
    CHAR    shdata[PIFSHDATASIZE];          // 0x12F    0's  (Not used)
    BYTE    behavior;                       // 0x16F    0x00
    BYTE    sysflags;                       // 0x170    0x00 (Not used)
} STDPIF;
typedef UNALIGNED STDPIF *PSTDPIF;
typedef UNALIGNED STDPIF FAR *LPSTDPIF;


/* Flags for PfW286Flags
 */

#define fALTTABdis286   0x0001
#define fALTESCdis286   0x0002
#define fALTPRTSCdis286 0x0004
#define fPRTSCdis286    0x0008
#define fCTRLESCdis286  0x0010
#define fNoSaveVid286   0x0020              // New for 3.10
#define fCOM3_286       0x4000
#define fCOM4_286       0x8000

typedef struct W286PIF30 {                  /* 286 */ //Examples
    WORD    PfMaxXmsK;                      // 0x19D    0x0000
    WORD    PfMinXmsK;                      // 0x19F    0x0000
    WORD    PfW286Flags;                    // 0x1A1    0x0000
} W286PIF30;
typedef UNALIGNED W286PIF30 *PW286PIF30;
typedef UNALIGNED W286PIF30 FAR *LPW286PIF30;


/* Flags for PfW386Flags
 */

#define fEnableClose    0x00000001          //
#define fEnableCloseBit             0       //
#define fBackground     0x00000002          //
#define fBackgroundBit              1       //
#define fExclusive      0x00000004          //                          /* ;Internal */
#define fExclusiveBit               2       //                          /* ;Internal */
#define fFullScreen     0x00000008          //
#define fFullScreenBit              3       //
#define fALTTABdis      0x00000020          //
#define fALTTABdisBit               5       //
#define fALTESCdis      0x00000040          //
#define fALTESCdisBit               6       //
#define fALTSPACEdis    0x00000080          //
#define fALTSPACEdisBit             7       //
#define fALTENTERdis    0x00000100          //
#define fALTENTERdisBit             8       //
#define fALTPRTSCdis    0x00000200          //
#define fALTPRTSCdisBit             9       //
#define fPRTSCdis       0x00000400          //
#define fPRTSCdisBit                10      //
#define fCTRLESCdis     0x00000800          //
#define fCTRLESCdisBit              11      //
#define fPollingDetect  0x00001000          //
#define fPollingDetectBit           12      //
#define fNoHMA          0x00002000          //
#define fNoHMABit                   13      //
#define fHasHotKey      0x00004000          //
#define fHasHotKeyBit               14      //
#define fEMSLocked      0x00008000          //
#define fEMSLockedBit               15      //
#define fXMSLocked      0x00010000          //
#define fXMSLockedBit               16      //
#define fINT16Paste     0x00020000          //
#define fINT16PasteBit              17      //
#define fVMLocked       0x00040000          //
#define fVMLockedBit                18      //
#define fGlobalProtect  0x00080000          //  New for 4.00
#define fGlobalProtectBit           19      //  New for 4.00
#define fMinimized      0x00100000          //  New for 4.00
#define fMinimizedBit               20      //  New for 4.00
#define fMaximized      0x00200000          //  New for 4.00
#define fMaximizedBit               21      //  New for 4.00
//                      0x00400000          //  Not used                /* ;Internal */
//                                  22      //  Not used                /* ;Internal */
#define fRealMode       0x00800000          //  New for 4.00
#define fRealModeBit                23      //  New for 4.00
#define fWinLie         0x01000000          //  New for 4.00
#define fWinLieBit                  24      //  New for 4.00
#define fStrayPtrDetect 0x02000000          //  New for 4.00            /* ;Internal */
#define fStrayPtrDetectBit          25      //  New for 4.00            /* ;Internal */
#define fNoSuggestMSDOS 0x04000000          //  New for 4.00
#define fNoSuggestMSDOSBit          26      //  New for 4.00
#define fLocalUMBs      0x08000000          //  New for 4.00            /* ;Internal */
#define fLocalUMBsBit               27      //  New for 4.00            /* ;Internal */
#define fRealModeSilent 0x10000000          //  New for 4.00
#define fRealModeSilentBit          28      //  New for 4.00
#define fQuickStart     0x20000000          //  New for 4.00            /* ;Internal */
#define fQuickStartBit              29      //  New for 4.00            /* ;Internal */
#define fAmbiguousPIF   0x40000000          //  New for 4.00
#define fAmbiguousPIFBit            30      //  New for 4.00

/* Flags for PfW386Flags2
 *
 *  NOTE THAT THE LOW 16 BITS OF THIS DWORD ARE VDD RELATED
 *  NOTE THAT ALL OF THE LOW 16 BITS ARE RESERVED FOR VIDEO BITS
 *
 *  You cannot monkey with these bits locations without breaking
 *  all VDDs as well as all old PIFs. SO DON'T MESS WITH THEM.
 */

#define fVDDMask        0x0000FFFF          //
#define fVDDMinBit                  0       //
#define fVDDMaxBit                  15      //

#define fVidTxtEmulate  0x00000001          //
#define fVidTxtEmulateBit           0       //
#define fVidNoTrpTxt    0x00000002          // Obsolete
#define fVidNoTrpTxtBit             1       // Obsolete
#define fVidNoTrpLRGrfx 0x00000004          // Obsolete
#define fVidNoTrpLRGrfxBit          2       // Obsolete
#define fVidNoTrpHRGrfx 0x00000008          // Obsolete
#define fVidNoTrpHRGrfxBit          3       // Obsolete
#define fVidTextMd      0x00000010          // Obsolete
#define fVidTextMdBit               4       // Obsolete
#define fVidLowRsGrfxMd 0x00000020          // Obsolete
#define fVidLowRsGrfxMdBit          5       // Obsolete
#define fVidHghRsGrfxMd 0x00000040          // Obsolete
#define fVidHghRsGrfxMdBit          6       // Obsolete
#define fVidRetainAllo  0x00000080          //
#define fVidRetainAlloBit           7       //

/*                                                                             ;Internal
 * This mask is used to isolate status bits shared with VM_Descriptor          ;Internal
 */                                                                         /* ;Internal */
                                                                            /* ;Internal */
#define PifDescMask                                                         /* ;Internal */ \
(fALTTABdis   + fALTESCdis    + fALTSPACEdis +                              /* ;Internal */ \
 fALTENTERdis + fALTPRTSCdis  + fPRTSCdis +                                 /* ;Internal */ \
 fCTRLESCdis  + fPollingDetect+ fNoHMA +                                    /* ;Internal */ \
 fHasHotKey   + fEMSLocked    + fXMSLocked +                                /* ;Internal */ \
 fINT16Paste  + fVMLocked)                                                  /* ;Internal */
                                                                            /* ;Internal */
                                                                            /* ;Internal */
typedef struct W386PIF30 {                  /* 386 */ //Examples
    // These new maxmem/minmem fields allow values
    // that will not conflict with the 286-specific values
    WORD    PfW386maxmem;                   // 0x1B9    0xFFFF (-1)
    WORD    PfW386minmem;                   // 0x1BB    0xFFFF (-1)
    WORD    PfFPriority;                    // 0x1BD    0x0064 (100)
    WORD    PfBPriority;                    // 0x1BF    0x0032 (50)
    WORD    PfMaxEMMK;                      // 0x1C1    0x0000 (0)
    WORD    PfMinEMMK;                      // 0x1C3    0x0000 (0)
    WORD    PfMaxXmsK;                      // 0x1C5    0x0800 (2048)
    WORD    PfMinXmsK;                      // 0x1C7    0x0000 (0)
    DWORD   PfW386Flags;                    // 0x1C9    0x00021003
    DWORD   PfW386Flags2;                   // 0x1CD    0x0000001F
    WORD    PfHotKeyScan;                   // 0x1D1    Scan code in lower byte
    WORD    PfHotKeyShVal;                  // 0x1D3    Shift state
    WORD    PfHotKeyShMsk;                  // 0x1D5    Mask for shift states interested in
    BYTE    PfHotKeyVal;                    // 0x1D7    Enhanced flags
    BYTE    PfHotKeyPad[9];                 // 0x1D8    Pad Hot key section to 16 bytes
    CHAR    PfW386params[PIFPARAMSSIZE];    // 0x1E1
} W386PIF30;
typedef UNALIGNED W386PIF30 *PW386PIF30;
typedef UNALIGNED W386PIF30 FAR *LPW386PIF30;


typedef struct WENHPIF40 {                  /* enh */                       /* ;Internal */
    DWORD   dwEnhModeFlagsProp;             // PROPPRG data (subset)        /* ;Internal */
    DWORD   dwRealModeFlagsProp;            // PROPPRG data (subset)        /* ;Internal */
    CHAR    achOtherFileProp[PIFDEFFILESIZE];//PROPPRG data (subset)        /* ;Internal */
    CHAR    achIconFileProp[PIFDEFFILESIZE];// PROPPRG data (subset)        /* ;Internal */
    WORD    wIconIndexProp;                 // PROPPRG data (subset)        /* ;Internal */
    PROPTSK tskProp;                        // PROPTSK data                 /* ;Internal */
    PROPVID vidProp;                        // PROPVID data                 /* ;Internal */
    PROPKBD kbdProp;                        // PROPKBD data                 /* ;Internal */
    PROPMSE mseProp;                        // PROPMSE data                 /* ;Internal */
    PROPSND sndProp;                        // PROPSND data                 /* ;Internal */
    PROPFNT fntProp;                        // PROPFNT data                 /* ;Internal */
    PROPWIN winProp;                        // PROPWIN data                 /* ;Internal */
    PROPENV envProp;                        // PROPENV data                 /* ;Internal */
    WORD    wInternalRevision;              // Internal WENHPIF40 version   /* ;Internal */
} WENHPIF40;                                                                /* ;Internal */
typedef UNALIGNED WENHPIF40 *PWENHPIF40;                                    /* ;Internal */
typedef UNALIGNED WENHPIF40 FAR *LPWENHPIF40;                               /* ;Internal */

#ifdef WINNT
/* Windows NT extension format */
typedef struct WNTPIF31 {                                                   /* ;Internal */
   PROPNT31 nt31Prop;                                                       /* ;Internal */
   WORD     wInternalRevision;                                              /* ;Internal */
} WNTPIF31;                                                                 /* ;Internal */
typedef UNALIGNED WNTPIF31 *PWNTPIF31;                                      /* ;Internal */
typedef UNALIGNED WNTPIF31 FAR *LPWNTPIF31;                                 /* ;Internal */
#endif
                                                                            /* ;Internal */
#ifdef UNICODE
typedef struct WNTPIF40 {                   /* adv */                       /* ;Internal */
    PROPNT40 nt40Prop;                      // PROPWNT data                 /* ;Internal */
    WORD    wInternalRevision;              // Internal WNTPIF40 version    /* ;Internal */
} WNTPIF40;                                                                 /* ;Internal */
typedef UNALIGNED WNTPIF40 *PWNTPIF40;                                      /* ;Internal */
typedef UNALIGNED WNTPIF40 FAR *LPWNTPIF40;                                 /* ;Internal */
#endif
                                                                            /* ;Internal */
//                                                                          /* ;Internal */
// Whenever a previously reserved field or bit becomes used, increment      /* ;Internal */
// the internal revision so that we know to zero them out when we see a     /* ;Internal */
// down-level PIF file.                                                     /* ;Internal */
//                                                                          /* ;Internal */
#define WENHPIF40_VERSION       1           // Current internal version     /* ;Internal */
#define WNTPIF40_VERSION        1           // Current internal version     /* ;Internal */
#define WNTPIF31_VERSION        1           // Current internal version     /* ;Internal */

                                                                            /* ;Internal */
typedef struct PIFDATA {                    /* pd */  //Examples            /* ;Internal */
                                                                            /* ;Internal */
    STDPIF      stdpifdata;                 // 0x000                        /* ;Internal */
                                                                            /* ;Internal */
    PIFEXTHDR   stdpifext;                  // 0x171                        /* ;Internal */
//  struct {                                                                /* ;Internal */
//      CHAR    extsig[PIFEXTSIGSIZE];      // 0x171    "MICROSOFT PIFEX"   /* ;Internal */
//      WORD    extnxthdrfloff;             // 0x181    0x0187 (or 0xFFFF)  /* ;Internal */
//      WORD    extfileoffset;              // 0x183    0x0000              /* ;Internal */
//      WORD    extsizebytes;               // 0x185    0x0171              /* ;Internal */
//  };                                                                      /* ;Internal */
                                                                            /* ;Internal */
    PIFEXTHDR   w286hdr30;                  // 0x187                        /* ;Internal */
//  struct {                                                                /* ;Internal */
//      CHAR    extsig[PIFEXTSIGSIZE];      // 0x187    "WINDOWS 286 3.0"   /* ;Internal */
//      WORD    extnxthdrfloff;             // 0x197    0x01A3 (or 0xFFFF)  /* ;Internal */
//      WORD    extfileoffset;              // 0x199    0x019D              /* ;Internal */
//      WORD    extsizebytes;               // 0x19B    0x0006              /* ;Internal */
//  };                                                                      /* ;Internal */
    W286PIF30   w286ext30;                  // 0x19D                        /* ;Internal */
                                                                            /* ;Internal */
    PIFEXTHDR   w386hdr30;                  // 0x1A3                        /* ;Internal */
//  struct {                                                                /* ;Internal */
//      CHAR    extsig[PIFEXTSIGSIZE];      // 0x1A3    "WINDOWS 386 3.0"   /* ;Internal */
//      WORD    extnxthdrfloff;             // 0x1B3    0xFFFF (ENH=0x221)  /* ;Internal */
//      WORD    extfileoffset;              // 0x1B5    0x01B9              /* ;Internal */
//      WORD    extsizebytes;               // 0x1B7    0x0068              /* ;Internal */
//  };                                                                      /* ;Internal */
    W386PIF30   w386ext30;                  // 0x1B9                        /* ;Internal */
                                                                            /* ;Internal */
    PIFEXTHDR   wenhhdr40;                  // 0x221                        /* ;Internal */
//  struct {                                                                /* ;Internal */
//      CHAR    extsig[PIFEXTSIGSIZE];      // 0x221    "WINDOWS VMM 4.0"   /* ;Internal */
//      WORD    extnxthdrfloff;             // 0x231    0x????              /* ;Internal */
//      WORD    extfileoffset;              // 0x233    0x0237              /* ;Internal */
//      WORD    extsizebytes;               // 0x235    ???                 /* ;Internal */
//  };                                                                      /* ;Internal */
    WENHPIF40   wenhext40;                  // 0x237                        /* ;Internal */

#ifdef WINNT
    PIFEXTHDR   wnthdr31;                   // 0x000                        /* ;Internal */
//  struct {                                                                /* ;Internal */
//      CHAR    extsig[PIFEXTSIGSIZE];      // 0x000    "WINDOWS NT  3.1"   /* ;Internal */
//      WORD    extnxthdrfloff;             // 0x000    0xFFFF              /* ;Internal */
//      WORD    extfileoffset;              // 0x000    0x0237              /* ;Internal */
//      WORD    extsizebytes;               // 0x000    ???                 /* ;Internal */
//  };                                                                      /* ;Internal */
    WNTPIF31    wntpif31;                   // 0x000                        /* ;Internal */
#endif


#ifdef UNICODE
    PIFEXTHDR   wnthdr40;                   // 0x000                        /* ;Internal */
//  struct {                                                                /* ;Internal */
//      CHAR    extsig[PIFEXTSIGSIZE];      // 0x000    "WINDOWS NT  4.0"   /* ;Internal */
//      WORD    extnxthdrfloff;             // 0x000    0xFFFF              /* ;Internal */
//      WORD    extfileoffset;              // 0x000    0x0237              /* ;Internal */
//      WORD    extsizebytes;               // 0x000    ???                 /* ;Internal */
//  };                                                                      /* ;Internal */
    WNTPIF40    wntpif40;                   // 0x000                        /* ;Internal */
#endif
                                                                            /* ;Internal */
} PIFDATA;                                  // 0x221 if Windows 3.x PIF     /* ;Internal */
typedef UNALIGNED PIFDATA *PPIFDATA;                                        /* ;Internal */
typedef UNALIGNED PIFDATA FAR *LPPIFDATA;                                   /* ;Internal */
                                                                            /* ;Internal */
                                                                            /* ;Internal */                                                                            /* ;Internal */
/* AssociateProperties associations
 */

#define HVM_ASSOCIATION         1
#define HWND_ASSOCIATION        2
#define LPARGS_ASSOCIATION      3                                           /* ;Internal */


/* SHEETTYPEs for AddPropertySheet/EnumPropertySheets
 */

#define SHEETTYPE_SIMPLE    0
#define SHEETTYPE_ADVANCED  1


/*  External function ordinals and prototypes
 */

#define ORD_OPENPROPERTIES      2
#define ORD_GETPROPERTIES       3
#define ORD_SETPROPERTIES       4
#define ORD_EDITPROPERTIES      5
#define ORD_FLUSHPROPERTIES     6
#define ORD_ENUMPROPERTIES      7
#define ORD_ASSOCIATEPROPERTIES 8
#define ORD_CLOSEPROPERTIES     9
#define ORD_LOADPROPERTYLIB     10
#define ORD_ENUMPROPERTYLIBS    11
#define ORD_FREEPROPERTYLIB     12
#define ORD_ADDPROPERTYSHEET    13
#define ORD_REMOVEPROPERTYSHEET 14
#define ORD_LOADPROPERTYSHEETS  15
#define ORD_ENUMPROPERTYSHEETS  16
#define ORD_FREEPROPERTYSHEETS  17
#define ORD_CREATESTARTUPPROPERTIES 20
#define ORD_DELETESTARTUPPROPERTIES 21

typedef UINT PIFWIZERR;

#define PIFWIZERR_SUCCESS           0
#define PIFWIZERR_GENERALFAILURE    1
#define PIFWIZERR_INVALIDPARAM      2
#define PIFWIZERR_UNSUPPORTEDOPT    3
#define PIFWIZERR_OUTOFMEM          4
#define PIFWIZERR_USERCANCELED      5

#define WIZACTION_UICONFIGPROP      0
#define WIZACTION_SILENTCONFIGPROP  1
#define WIZACTION_CREATEDEFCLEANCFG 2

/* XLATOFF */

#ifdef WINAPI
PIFWIZERR WINAPI AppWizard(HWND hwnd, HANDLE hProps, UINT action);

int  WINAPI OpenProperties(LPCTSTR lpszApp, LPCTSTR lpszPIF, UINT hInf, UINT flOpt);
int  WINAPI GetProperties(HANDLE hProps, LPCSTR lpszGroup, LPVOID lpProps, int cbProps, UINT flOpt);
int  WINAPI SetProperties(HANDLE hProps, LPCSTR lpszGroup, const VOID FAR *lpProps, int cbProps, UINT flOpt);
int  WINAPI EditProperties(HANDLE hProps, LPCTSTR lpszTitle, UINT uStartPage, HWND hwnd, UINT uMsgPost);
int  WINAPI FlushProperties(HANDLE hProps, UINT flOpt);
HANDLE  WINAPI EnumProperties(HANDLE hProps);
LONG_PTR WINAPI AssociateProperties(HANDLE hProps, int iAssociate, LONG_PTR lData);
int  WINAPI CloseProperties(HANDLE hProps, UINT flOpt);
int  WINAPI CreateStartupProperties(HANDLE hProps, UINT flOpt);
int  WINAPI DeleteStartupProperties(HANDLE hProps, UINT flOpt);
BOOL WINAPI PifPropGetPages(LPVOID lpv, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);


#ifdef  PIF_PROPERTY_SHEETS
HANDLE  WINAPI LoadPropertyLib(LPCTSTR lpszDLL, int fLoad);
HANDLE  WINAPI EnumPropertyLibs(HANDLE iLib, LPHANDLE lphDLL, LPSTR lpszDLL, int cbszDLL);
BOOL WINAPI FreePropertyLib(HANDLE hLib);
HANDLE  WINAPI AddPropertySheet(const PROPSHEETPAGE FAR *lppsi, int iType);
BOOL WINAPI RemovePropertySheet(HANDLE hSheet);
int  WINAPI Loa