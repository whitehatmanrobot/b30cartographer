glNVEvalMaps as info is copied from the 'gc' to 'info'

    int nAttr;              // number of active attrs
    int maxAttr;            // max attributes required for malloc's
    int firstAttr;          // first attribute found -- used in memcopies
    unsigned int maxOrder;  // max order of all enabled attributes
    int maxSwatch;          // set according to HW or SW swathing
    int nSwatchU, nSwatchV; // swatches in patch, including Begin/End stitch
    int fracSwatchU, fracSwatchV; // swatches not counting inner frac stitches

    int swatchFlags;        // control during swathing using NV_PATCH_SWATCH_*

    // Evaluation flags
    unsigned int flags;     // NV_PATCH_FLAG_*
    int flipT;              // set if (flags & NV_PATCH_FLAG_FLAG_TRANSPOSE)
    int flipU;              // set if (flags & NV_PATCH_FLAG_FLIPPED_U)
    int flipV;              // set if (flags & NV_PATCH_FLAG_FLIPPED_V)
    int flipUV;             // for stitches
    int flipTUV;            // combine transpose and both flips

    //MOVE TO QUADINFO ---------------->
    unsigned char* cachedPB;        // cached push buffer
    unsigned long  cachedPBSize;    // cached push buffer size
    unsigned long  cachedPBCounter; // hit count
    //<-------------------------

    // CW/CCW reversal for FRAC layered on INT
    int reverse;

    // Description of tesselation factors
    union {
        struct { float nu0, nu1, nv0, nv1; } tensor;
        struct { float n1, n2, n3;         } tri;
    } tess, originaltess;

    // The basis for the patch
    NV_PATCH_BASIS_TYPE basis;

    // Source and destination of AUTO_NORMAL calculations
    int srcNormal, dstNormal;
    int rational;
    float startu, endu, startv, endv;
    // Destination of AUTO_UV calculations
    int srcUV[8], dstUV[8]; //can have up to 8 sets??

    // Information for each map
    NV_PATCH_MAP_INFO maps[NV_PATCH_NUMBER_OF_ATTRIBS];

    // What type of backend we are writing to or calling to
    NV_PATCH_BACKEND_TYPE backendType;

    // Output buffer (pushbuffer, DP2 stream, ...)
    //MAY BE DEPRECATED?????
    unsigned char *buffer;
    unsigned int bufferLength; // in bytes
    int vertexSize;            // expected # of dwords to output per vertex

    // Opaque context pointer
    void *context;

    // for cache-able info
    NV_PATCH_ALLOC_CACHE *pCache[MAX_EV_CACHE];
    unsigned int retVal;    // for deeply nested alloc errors

    float *normalPatch;     // for NV_PATCH_FLAG_AUTO_NORMAL
    float *UVPatch;         // for NV_PATCH_FLAG_AUTO_UV

    // These point to the guard corners of the regular grid. They are in this
    // top-level structure to be used by all patch types.
    // Instead of fancy attribute arrays, they are simply enumerated for
    // the two attributes which require guard corners: vertex, normal
    // Think of drawing the regular grid from lower-left to upper-right.
    // These names match that orientation so the regular grid routine doesn't
    // need to worry about various orientation flipping and swatching cases.
    // Perhaps LL and LR are not needed for HW, but they're set up for now.
    // Generally these points are the corners of the regular grid,
    // except for LL and LR on the bottom row with a bottom stitch.
    // In this case, they correspond to the swatch corners, and must be stepped
    // up if you want the regular grid.
    //  UL=[0][1]   UR=[1][1]
    //  LL=[0][0]   LR=[0][1]
    float *pSwatchCorner[NV_PATCH_NUMBER_OF_ATTRIBS][2][2]; // [v][u]

    // These are available storage for the corners of the regular grid on
    // the outside of all swatches.
    // Whereas, pSwatchCornerVertex and pSwatchCornerNormal will be
    // correct per sub-patch, these need only be fully valid
    // after all swatches are done
    // Here, the indices are "absolute" because the stitch code was written
    // to draw stitches on the Left, Right, Bot, Top, not relative to the
    // regular grid.
    float gridCorner[NV_PATCH_NUMBER_OF_ATTRIBS][2][2][4]; // [v][u][xyzw]
    int setGridCorner;  // mask indicating which gridCorner to assign

    // SCRATCH SPACE
    // alloced once with the structure to prevent LOTS of malloc/free's later.
    NV_PATCH_CURVE_INFO tempCurve;
    FDMatrix tempMatrix;
    FDMatrix reparam;                        // used for Tri INT and FRAC
    FDMatrix *reduceTri[NV_PATCH_MAX_ORDER]; // see ReparameterizeTriPatch()

    int bytesGuardCurve;        // bytes in truncated NV_PATCH_CURVE_INFO
    int bytesGuardCurveAllAttr; // bytes for one curve set (one curve for each active attribute)

    NV_PATCH_QUAD_INFO *quadInfo;   // alloc'd by callers

    // temp storage allocated in DrawIntPatch() and used by lower routines
    void *pScratchBase; // ptr to group of all scratch stuff for free

    // temp FD matrix for reg grid, small steps in V and U
    FDMatrix *ppMatrixSetSS0[NV_PATCH_NUMBER_OF_ATTRIBS];

    // temp* curves are for boundary curves in regular grid
    NV_PATCH_CURVE_INFO *tempVBegin[NV_PATCH_NUMBER_OF_ATTRIBS];
    NV_PATCH_CURVE_INFO *tempVEnd[NV_PATCH_NUMBER_OF_ATTRIBS];

    // guard sets. Now only for FRAC. Later for more.
    FDCurveAttrSet guardSetUInnerFrac;  // for non-swathing
    FDCurveAttrSet guardSetVInnerFrac;  // for non-swathing
    FDCurveAttrSet *ppGuardSetUInnerFrac1[1];   // for non-swathing
    FDCurveAttrSet *ppGuardSetVInnerFrac1[1];   // for non-swathing
    FDCurveAttrSet **ppGuardSetUInnerFrac;
    FDCurveAttrSet **ppGuardSetVInnerFrac;
} NV_PATCH_INFO;

/*****************************************************************************/
// forward declarations
int nvAllocInfoScratch(NV_PATCH_INFO *info);
int nvAllocFDMatricesEtc(NV_PATCH_INFO *info);
unsigned int nvEvalPatchSetup(NV_PATCH_INFO *info);
unsigned int nvEvalPatch(NV_PATCH_INFO *info);
unsigned int nvEvalPatchCleanup(NV_PATCH_INFO *info);

unsigned int DrawKelvinIntPatchGrid(NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo, FDMatrix **matrices);
void SendGuardCurve(unsigned long curvetype, NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo, unsigned long flags);
void ComputeKelvinHOSControlWords(NV_PATCH_INFO *info, NV_PATCH_QUAD_INFO *quadInfo, long flags);
void CopyCurve(NV_PATCH_INFO *info, NV_PATCH_CURVE_INFO *dst, NV_PATCH_CURVE_INFO *src);

void OffsetFDMatrix(NV_PATCH_INFO *info, FDMatrix *m, int a, int b);
void OffsetCurve(NV_PATCH_INFO *info, NV_PATCH_CURVE_INFO *curve, int n);

int evAllocInitWithCache(NV_PATCH_INFO *info, void *context, 
                            NV_PATCH_ALLOC_CONTROL *pevMemory,
                            int tBytes, NV_PATCH_ALLOC_CACHE *pCache);

extern const int attrHwToSw[NV_PATCH_NUMBER_OF_ATTRIBS];
extern const int attrSwToHw[NV_PATCH_NUMBER_OF_ATTRIBS];

//d3d defs
#define VIEW_AS_DWORD(f) (*(DWORD *)(&(f)))
#define HOS_CREATE_AND_ASSIGN_PUSHBUF_LOCALS() \
CDevice* pDevice = g_pDevice; PPUSH pPush;

#define HOS_NOTE(a)
#define HOS_FLUSH()

#define MAX_PATCH_INNERLOOPS          16
#define OFFSET_FDMATRIX_ED_2x2      0
#define OFFSET_FDMATRIX_ED_4x4      1
#define OFFSET_FDMATRIX_ED_6x6      2
#define OFFSET_FDMATRIX_ED_DEF      3
#define OFFSET_FDMATRIX_2x2         4
#define OFFSET_FDMATRIX_4x4         5
#define OFFSET_FDMATRIX_6x6         6
#define OFFSET_FDMATRIX_DEF         7
#define OFFSET_CURVE_2x2            8
#define OFFSET_CURVE_4x4            9
#define OFFSET_CURVE_6x6            10
#define OFFSET_CURVE_DEF            11
#define OFFSET_MATRIX_MULT_2x2      12
#define OFFSET_MATRIX_MULT_4x4      13
#define OFFSET_MATRIX_MULT_6x6      14
#define OFFSET_MATRIX_MULT_DEF      15

typedef struct {
    //small FDMatrix cache to get rid of extra 
    unsigned int RetessFDtag[2][2];           //tags for a retessellation matrix cache
    FDMatrix *RetessFDCache[2];               //ptrs for retessellation matrix cache
    int RetessFDMRU;                          //MRU bit for the above cache
    
    //EV_ALLOC data structures to minimize the number of malloc/frees in shared code
    NV_PATCH_ALLOC_CACHE pCache[MAX_EV_CACHE];
} NV_PATCH_STATIC_DATA;

extern unsigned int RetessFDtag[2][2];           //tags for a retessellation matrix cache
extern FDMatrix *RetessFDCache[2];               //ptrs for retessellation matrix cache
extern int RetessFDMRU;                          //MRU bit for the above cache
extern NV_PATCH_ALLOC_CACHE MyCache[MAX_EV_CACHE];
void OffsetFDMatrix_Extract_Discard(NV_PATCH_INFO *info, NV_PATCH_CURVE_INFO *dst, int dir, FDMatrix *m, int a, int b);

#define MAX(a, b) max(a, b)
#define MIN(a, b) min(a, b)

void setFrontFace(NV_PATCH_INFO *info, int reversed);

#endif // __PATCH_UTIL_H__

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\precomp.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       precomp.hpp
 *  Content:    Common include file
 *
 ***************************************************************************/

// Wherever we call SetRenderState or SetTextureStageState internally is
// not speed-critical, so save some space by always calling the out-of-
// line version:

#define D3DCOMPILE_NOTINLINE 1

#ifdef STARTUPANIMATION
#define _NTSYSTEM_
#endif

#pragma code_seg("D3D")
#pragma data_seg("D3D_RW")
#pragma bss_seg("D3D_URW")
#pragma const_seg("D3D_RD")

#include <stdio.h>
#include <stddef.h>

extern "C" 
{
    #include <ntos.h>
    #include <nturtl.h>
    #include <av.h>
    #include <avmode.h>
};

#include <xtl.h>
#include <xdbg.h>
#include "xmetal.h"

#include "d3dver.h"

#include "nv32.h"
#include "nv_ref_2a.h"

// The following all encase themselves in the D3D namespace:

#include "hw.h"
#include "debug.hpp"
#include "mp.hpp"
#include "memalloc.h"
#include "misc.hpp"
#include "floatmath.hpp"
#include "math.hpp"
#include "memory.hpp"
#include "pixeljar.hpp"
#include "pusher.hpp"
#include "resource.hpp"
#include "surface.hpp"
#include "texture.hpp"
#include "enum.hpp"
#include "buffer.hpp"
#include "d3di.hpp"
#include "device.hpp"
#include "drawprim.hpp"
#include "state.hpp"
#include "stats.hpp"
#include "dumper.hpp"
#include "PatchUtil.hpp"
#include "patch.hpp"
#include "caps.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\present.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       present.cpp
 *  Content:    Support for handling the Present and Swap APIs
 *
 ***************************************************************************/

#include "precomp.hpp"
#include "dm.h"

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

//------------------------------------------------------------------------------
// g_AntiAliasedRenderStates, g_AntiAliasedTextureStates
//
// Default states needed for our Kelvin copy.

D3DCONST DWORD g_AntiAliasedRenderStates[] =
{
    D3DRS_FILLMODE,                     D3DFILL_SOLID,
    D3DRS_BACKFILLMODE,                 D3DFILL_SOLID,
    D3DRS_CULLMODE,                     D3DCULL_NONE,
    D3DRS_DITHERENABLE,                 TRUE,
    D3DRS_ALPHATESTENABLE,              FALSE,
    D3DRS_ALPHABLENDENABLE,             FALSE,
    D3DRS_FOGENABLE,                    FALSE,
    D3DRS_EDGEANTIALIAS,                FALSE,
    D3DRS_STENCILENABLE,                FALSE,
    D3DRS_LIGHTING,                     FALSE,
    D3DRS_MULTISAMPLEMASK,              0xffffffff,
    D3DRS_LOGICOP,                      D3DLOGICOP_NONE,
    D3DRS_COLORWRITEENABLE,             D3DCOLORWRITEENABLE_ALL,
    D3DRS_YUVENABLE,                    FALSE,
    D3DRS_SPECULARENABLE,               FALSE,
    D3DRS_ZBIAS,                        0,
    D3DRS_MULTISAMPLERENDERTARGETMODE,  D3DMULTISAMPLEMODE_1X,

    // Note that both the 'immediate' and one-back-buffer cases require
    // the swath to be off, otherwise tearing is visible, since swathing
    // causes the GPU to do the fill in vertical columns.

    D3DRS_SWATHWIDTH,                   D3DSWATH_OFF,
};

CONST g_AntiAliasedRenderStatesCount = sizeof(g_AntiAliasedRenderStates) / 8;

D3DCONST DWORD g_AntiAliasedTextureStates[] =
{
    D3DTSS_COLOROP,                     D3DTOP_SELECTARG1,
    D3DTSS_COLORARG1,                   D3DTA_TEXTURE,
    D3DTSS_ALPHAOP,                     D3DTOP_DISABLE,
    D3DTSS_TEXCOORDINDEX,               0,
    D3DTSS_ADDRESSU,                    D3DTADDRESS_CLAMP,
    D3DTSS_ADDRESSV,                    D3DTADDRESS_CLAMP,
    D3DTSS_COLORKEYOP,                  D3DTCOLORKEYOP_DISABLE,
    D3DTSS_COLORSIGN,                   0,
    D3DTSS_ALPHAKILL,                   D3DTALPHAKILL_DISABLE,
    D3DTSS_MINFILTER,                   D3DTEXF_LINEAR, // reset later
    D3DTSS_MAGFILTER,                   D3DTEXF_LINEAR, // reset later
};

CONST g_AntiAliasedTextureStatesCount = sizeof(g_AntiAliasedTextureStates) / 8;

//------------------------------------------------------------------------------
// SwapSavedState

struct SwapSavedState
{
    PixelShader *pPixelShader;
    DWORD VertexShaderHandle;
    DWORD Stage1ColorOp;
    DWORD PSTextureModes;
    DWORD RenderState[g_AntiAliasedRenderStatesCount];
    DWORD TextureState[g_AntiAliasedTextureStatesCount];
    DWORD PixelShaderState[D3DRS_PS_MAX - D3DRS_PS_MIN];
    DWORD VertexShaders[4 * D3DVS_XBOX_RESERVEDXYZRHWSLOTS];
};

//------------------------------------------------------------------------------
// SwapSetRenderState

static VOID SwapSetRenderState(
    D3DRENDERSTATETYPE State,
    DWORD Value,
    BOOL Restore)   // TRUE if in restoring pass
{
    ASSERT(State >= D3DRS_PS_MAX);

    // D3D doesn't save the state if we're a 'pure' device and the state
    // is 'simple':

    BOOL saved = (State >= D3DRS_SIMPLE_MAX) ||
                !(g_pDevice->m_StateFlags & STATE_PUREDEVICE);

    if ((Restore) && (!saved))
    {
        // Can't restore simple states when running on a pure device
        // because we don't know what values to restore them to:

        return;
    }

    if ((saved) && (Value == D3D__RenderState[State]))
    {
        // Don't bother setting the render state if it's already correct:

        return;
    }

    D3DDevice_SetRenderState(State, Value);
}

//------------------------------------------------------------------------------
// SwapSetTextureState

static VOID SwapSetTextureState(
    DWORD Stage,
    D3DTEXTURESTAGESTATETYPE Type,
    DWORD Value)
{
    if (Value == D3D__TextureState[Stage][Type])
    {
        // Don't bother setting the render state if it's already correct:

        return;
    }

    D3DDevice_SetTextureStageState(Stage, Type, Value);
}

//------------------------------------------------------------------------------
// SwapSetState
//
// Sets a bunch of Kelvin state to what's needed by 'SwapCopyBlt'.
//
// NOTE: Any state that gets touched here should have corresponding save and
//       restore functionality put into SwapSave/RestoreState!

static VOID SwapSetState(
    SwapSavedState *pSave)
{
    DWORD i;

    CDevice* pDevice = g_pDevice;

    for (i = 0; i < g_AntiAliasedRenderStatesCount; i++)
    {
        SwapSetRenderState(
            (D3DRENDERSTATETYPE) g_AntiAliasedRenderStates[2*i],
            g_AntiAliasedRenderStates[2*i + 1],
            FALSE);
    }

    for (i = 0; i < g_AntiAliasedTextureStatesCount; i++)
    {
        SwapSetTextureState(
            0,
            (D3DTEXTURESTAGESTATETYPE) g_AntiAliasedTextureStates[2*i],
            g_AntiAliasedTextureStates[2*i + 1]);
    }

    D3DDevice_SetPixelShader(NULL);
    D3DDevice_SetVertexShader(D3DFVF_XYZRHW | D3DFVF_TEX1);

    DWORD filter = D3D__RenderState[D3DRS_SWAPFILTER];

    SwapSetTextureState(0, D3DTSS_MINFILTER, filter);
    SwapSetTextureState(0, D3DTSS_MAGFILTER, filter);
    SwapSetTextureState(1, D3DTSS_COLOROP, D3DTOP_DISABLE);

    // Whack the hardware with the new state so that we're all set to go
    // when we enter SwapCopyBlt:

    SetState();
}

//------------------------------------------------------------------------------
// SwapSaveState

static VOID SwapSaveState(
    SwapSavedState *pSave)
{
    DWORD i;

    CDevice* pDevice = g_pDevice;

    pSave->pPixelShader = pDevice->m_pPixelShader;

    pSave->VertexShaderHandle = pDevice->m_VertexShaderHandle;

    pSave->Stage1ColorOp = D3D__TextureState[1][D3DTSS_COLOROP];

    for (i = 0; i < g_AntiAliasedRenderStatesCount; i++)
    {
        pSave->RenderState[i] = D3D__RenderState[g_AntiAliasedRenderStates[2*i]];
    }

    for (i = 0; i < g_AntiAliasedTextureStatesCount; i++)
    {
        pSave->TextureState[i] = D3D__TextureState[0]
            [g_AntiAliasedTextureStates[2*i]];
    }

    if (pSave->pPixelShader)
    {
        for (i = D3DRS_PS_MIN; i < D3DRS_PS_MAX; i++)
        {
            pSave->PixelShaderState[i - D3DRS_PS_MIN] = D3D__RenderState[i];
        }

        pSave->PSTextureModes = D3D__RenderState[D3DRS_PSTEXTUREMODES];
    }

    memcpy(pSave->VertexShaders,
           &pDevice->m_VertexShaderProgramSlots[0][0],
           sizeof(pSave->VertexShaders));
}

//------------------------------------------------------------------------------
// SwapRestoreState

static VOID SwapRestoreState(
    SwapSavedState* pSave)
{
    DWORD i;

    CDevice* pDevice = g_pDevice;

    D3DDevice_SetPixelShader((DWORD) pSave->pPixelShader);

    D3DDevice_SetVertexShader(pSave->VertexShaderHandle);

    BOOL pure = pDevice->m_StateFlags & STATE_PUREDEVICE;

    SwapSetTextureState(1, D3DTSS_COLOROP, pSave->Stage1ColorOp);

    for (i = 0; i < g_AntiAliasedRenderStatesCount; i++)
    {
        SwapSetRenderState(
                (D3DRENDERSTATETYPE) g_AntiAliasedRenderStates[2*i],
                pSave->RenderState[i],
                TRUE);
    }

    for (i = 0; i < g_AntiAliasedTextureStatesCount; i++)
    {
        SwapSetTextureState(
            0, 
            (D3DTEXTURESTAGESTATETYPE) g_AntiAliasedTextureStates[2*i],
            pSave->TextureState[i]);
    }

    if (!pure)
    {
        if (pSave->pPixelShader)
        {
            for (i = D3DRS_PS_MIN; i < D3DRS_PS_MAX; i++)
            {
                D3DDevice_SetRenderState((D3DRENDERSTATETYPE) i,
                    pSave->PixelShaderState[i - D3DRS_PS_MIN]);
            }

            D3DDevice_SetRenderState(D3DRS_PSTEXTUREMODES, pSave->PSTextureModes);
        }

        RestoreVertexShaders(pSave->VertexShaders,
                             sizeof(pSave->VertexShaders) / sizeof(DWORD));
    }
}

//------------------------------------------------------------------------------
// SwapSetSurfaces

static VOID SwapSetSurfaces(
    CDevice* pDevice)
{
    D3DDevice_SetRenderTarget(pDevice->m_pFrameBuffer[1], NULL);
    D3DDevice_SetTexture(0, (D3DTexture*) pDevice->m_pFrameBuffer[0]);
}

//------------------------------------------------------------------------------
// SwapSaveSurfaces

static VOID SwapSaveSurfaces(
    CDevice* pDevice)
{
    pDevice->m_pSaveRenderTarget = pDevice->m_pRenderTarget;
    pDevice->m_pSaveRenderTarget->AddRef();

    pDevice->m_pSaveZBuffer = pDevice->m_pZBuffer;
    if (pDevice->m_pSaveZBuffer)
        pDevice->m_pSaveZBuffer->AddRef();

    pDevice->m_pSaveTexture = pDevice->m_Textures[0];
    if (pDevice->m_pSaveTexture)
        pDevice->m_pSaveTexture->AddRef();

    // SetRenderTarget nukes the current viewport, so we have to save that
    // as well:

    pDevice->m_SaveViewport = pDevice->m_Viewport;
}

//------------------------------------------------------------------------------
// SwapRestoreSurfaces

static VOID SwapRestoreSurfaces(
    CDevice* pDevice)
{
    D3DDevice_SetRenderTarget(pDevice->m_pSaveRenderTarget, pDevice->m_pSaveZBuffer);
    pDevice->m_pSaveRenderTarget->Release();
    if (pDevice->m_pSaveZBuffer)
        pDevice->m_pSaveZBuffer->Release();

    D3DDevice_SetTexture(0, pDevice->m_pSaveTexture);
    if (pDevice->m_pSaveTexture)
        pDevice->m_pSaveTexture->Release();

    D3DDevice_SetViewport(&pDevice->m_SaveViewport);
}

//------------------------------------------------------------------------------
// SwapCopyBlt
//
// Does a minification filtered blt, using the current state.

static VOID SwapCopyBlt(
    CDevice* pDevice)
{
    PPUSH pPush = pDevice->StartPush();

    FLOAT xScale = pDevice->m_AntiAliasScaleX;
    FLOAT yScale = pDevice->m_AntiAliasScaleY;

    DWORD right = PixelJar::GetWidth(pDevice->m_pRenderTarget);
    DWORD bottom = PixelJar::GetHeight(pDevice->m_pRenderTarget);

    // I could have used DrawPrimitiveUP here instead of programming the
    // registers directly, but I didn't want to pull in all that UP code.

    PushCount(pPush++, NV097_SET_VERTEX_DATA_ARRAY_FORMAT(0), 16);

    for (DWORD i = 0; i < 16; i++)
    {
        *pPush++ = SIZEANDTYPE_DISABLED;
    }

    Push1(pPush,
          NV097_SET_VERTEX_DATA_ARRAY_FORMAT(SLOT_POSITION),
          DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F)
        | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _2));

    Push1(pPush + 2,
          NV097_SET_VERTEX_DATA_ARRAY_FORMAT(SLOT_TEXTURE0),
          DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F)
        | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _2));

    Push1(pPush + 4, NV097_SET_BEGIN_END, NV097_SET_BEGIN_END_OP_TRIANGLES);

    PushCount(pPush + 6, PUSHER_NOINC(NV097_INLINE_ARRAY), 12);

    DWORD filter = D3D__TextureState[0][D3DTSS_MINFILTER];

    if (DBG_CHECK(TRUE))
    {
        if ((filter == D3DTEXF_QUINCUNX) && 
            ((xScale != 2.0f) || (yScale != 1.0f)))
        {
            DPF_ERR("Quincunx filter is nonsensical unless x scale is 2, "
                    "y scale is 1. \n(Use linear filter instead?)");
        }
        if ((filter == D3DTEXF_GAUSSIANCUBIC) &&
            ((Round(xScale) != xScale) || (Round(yScale) != yScale)))
        {
            DPF_ERR("Gaussian filter is nonsensical unless x and y scale "
                    "are integral. \n(Use linear filter instead?)");
        }
    }

    // Set up the texture coordinate jiggle assuming a linear filter:

    FLOAT uAdjust = 0.0f;
    FLOAT vAdjust = 0.0f;

    // For the convolution kernels, when the scaling is 2x we always
    // contrive to center the kernel around every second pixel.
    // (Quincunx and the 2x multisample format require this, otherwise
    // the result is nonsensical.)  That is, we always want 0.5 in
    // the destination to map to 1.5 in the source:

    if ((filter == D3DTEXF_QUINCUNX) || (filter == D3DTEXF_GAUSSIANCUBIC))
    {
        if (xScale == 2.0f)
            uAdjust = 0.5f;
        if (yScale == 2.0f)
            vAdjust = 0.5f;
    }

    // If you subtract KELVIN_BORDER off of every screen space
    // coordinate, as I'm doing here, you can think of things
    // according to OGL's pixel center convention, which is a whole
    // heck of a lot easier to think with than D3D's.

    FLOAT xAdjust = -pDevice->m_ScreenSpaceOffsetX;
    FLOAT yAdjust = -pDevice->m_ScreenSpaceOffsetY;

    FLOAT* pVertices = (float*) (pPush + 7);

    pVertices[0] = xAdjust;
    pVertices[1] = yAdjust;
    pVertices[2] = uAdjust;
    pVertices[3] = vAdjust;

    pVertices[4] = xAdjust + (4.0f * right);
    pVertices[5] = yAdjust;
    pVertices[6] = uAdjust + (4.0f * (right * xScale)); // !!! Round
    pVertices[7] = vAdjust;

    pVertices[8] = xAdjust;
    pVertices[9] = yAdjust + (4.0f * bottom);
    pVertices[10] = uAdjust;
    pVertices[11] = vAdjust + (4.0f * (bottom * yScale));

    Push1(pPush + 19, NV097_SET_BEGIN_END, NV097_SET_BEGIN_END_OP_END);

    pPush += 21;

    // Account for the fact that we just blew away the vertex format
    // by accessing the registers directly:

    D3D__DirtyFlags |= D3DDIRTYFLAG_VERTEXFORMAT;

    // !!! This also blows away SetVertexShaderInput settings

    pDevice->EndPush(pPush);
}

//------------------------------------------------------------------------------
// SwapCopy

static VOID SwapCopy(
    CDevice* pDevice,
    DWORD Flags)
{
    PPUSH pPush;
    SwapSavedState savedState;

    ////////////////////////////////////////////////////////////////////////////
    // 1.  Begin

    if (Flags & (D3DSWAP_COPY | D3DSWAP_BYPASSCOPY))
    {
        // Rotate the back-buffers before doing SwapSetState if more
        // than one and we're synchronized to the vertical blank:

        if (pDevice->m_FrameBufferCount == 3)
        {
            // Swap the buffers so that index '1' points to the visible
            // surface:

            D3DSurface* pBuffer1 = pDevice->m_pFrameBuffer[1];
            D3DSurface* pBuffer2 = pDevice->m_pFrameBuffer[2];

            DWORD OldData = pBuffer2->Data;
            DWORD OldLock = pBuffer2->Lock;

            // Swap Data and Lock members.

            pBuffer2->Data = pBuffer1->Data;
            pBuffer2->Lock = pBuffer1->Lock;

            // Complete the swap by copying the old primary into the last
            // slot:

            pBuffer1->Data = OldData;
            pBuffer1->Lock = OldLock;
        }

        SwapSaveSurfaces(pDevice);

        SwapSetSurfaces(pDevice);

        if (Flags & D3DSWAP_COPY)
        {
            // Save away any rendering state we're about to clobber, if we can:

            SwapSaveState(&savedState);                     

            // Set any state in preparation for our final sampling blt.
            //
            // NOTE: We want to do this before the FLIP_STALL for the one-buffer
            //       case, so that the Blt starts as soon as possible at Vblank!

            SwapSetState(&savedState);
        }

        pPush = pDevice->StartPush();

        if (pDevice->m_PresentationInterval == D3DPRESENT_INTERVAL_IMMEDIATE)
        {
            // 1.  Immediate flip

        }
        else if (pDevice->m_FrameBufferCount < 3)
        {
            // 2.  Synchronized flips with one back-buffer
            //
            // Handle the one-back-buffer case, where we do a Blt that is 
            // started when the next Vblank happens.

            // When doing synchronized blts with one buffer, we release the
            // Blt command at the next Vblank, and when it beats the DAC
            // raster (as it should), then there's no tearing as a result.
            // To ensure that the GPU is ready to go as soon as the Vblank
            // comes where we commit to the blt, we tell the GPU to wait-for-
            // idle *before* processing the NVX_FLIP_SYNCHRONIZED command
            // (which is what will release the GPU to start processing the
            // blt).
            //
            // Note that the FLIP_STALL command automatically synchronizes
            // with the back-buffer, but that is not sufficient in this case.
            // If we did not do the following WAIT_FOR_IDLE, then
            // NVX_FLIP_SYNCHRONIZED could release the Blt while the back-end
            // is still digesting the synchronize in FLIP_STALL, and that
            // could delay the Blt long enough to causing a tear.

            Push1(pPush, NV097_WAIT_FOR_IDLE, 0);

            // Technically, we don't have to set the DAC address on every 
            // Swap for this case.  But NVX_FLIP_SYNCHRONIZED has the 
            // additional nice side effects of handling the gamma ramp 
            // change, and doing the INCREMENT_READ_3D at the next Vblank.

            // NVX_FLIP_* Data stored in NV097_SET_ZSTENCIL_CLEAR_VALUE

            DWORD flipAddress = pDevice->m_pFrameBuffer[1]->Data;

            Push1(pPush + 2, NV097_SET_ZSTENCIL_CLEAR_VALUE, flipAddress);

            Push1(pPush + 4, NV097_NO_OPERATION, NVX_FLIP_SYNCHRONIZED);

            Push1(pPush + 6, NV097_FLIP_INCREMENT_WRITE, 0);

            // Due to a bug, the hardware requires a NOP here, otherwise a stall 
            // may go through before the write:

            Push1(pPush + 8, NV097_NO_OPERATION, 0);

            // This command will stall the GPU until the INCREMENT_READ_3D is
            // done at the next Vblank, at which time the GPU is released to
            // immediately start the filter Blt.

            Push1(pPush + 10, NV097_FLIP_STALL, 0);

            pPush += 12;
        }
        else
        {
            // 3.  Synchronized flips with two back-buffers:
        
            Push1(pPush, NV097_FLIP_INCREMENT_WRITE, 0);

            // Due to a bug, the hardware requires a NOP here, otherwise a stall 
            // may go through before the write:

            Push1(pPush + 2, NV097_NO_OPERATION, 0);

            // This command will stall the GPU until one of the two buffers
            // becomes available:

            Push1(pPush + 4, NV097_FLIP_STALL, 0);

            pPush += 6;
        }

        pDevice->EndPush(pPush);
    }

    ////////////////////////////////////////////////////////////////////////////
    // 2.  Blt

    if (Flags & D3DSWAP_COPY)
    {
        SwapCopyBlt(pDevice);
        
        SwapRestoreState(&savedState);
    }

    ////////////////////////////////////////////////////////////////////////////
    // 3.  End

    if (Flags & D3DSWAP_FINISH)
    {
        SwapRestoreSurfaces(pDevice);

        pPush = pDevice->StartPush();

        DWORD flipAddress = pDevice->m_pFrameBuffer[1]->Data;

        if (pDevice->m_PresentationInterval == D3DPRESENT_INTERVAL_IMMEDIATE)
        {
            // 1.  Immediate flip

            // For the very first 'Swap' call, wait until the Blt completes
            // before letting the flip happen.  Otherwise, the DAC could start
            // showing memory before the Blt gets there, resulting in crap on 
            // the screen:
        
            if (pDevice->m_SwapCount == 1)
            {
                Push1(pPush, NV097_WAIT_FOR_IDLE, 0);
                pPush += 2;
            }
        
            // Technically, we don't have to set the DAC address on every 
            // Swap for this case.  But NVX_FLIP_IMMEDIATE has the 
            // beneficial side-effect of handling any posted gamma ramp 
            // changes.
        
            // NVX_FLIP_IMMEDIATE Data stored in NV097_SET_ZSTENCIL_CLEAR_VALUE
        
            Push1(pPush, NV097_SET_ZSTENCIL_CLEAR_VALUE, flipAddress);
        
            Push1(pPush + 2, NV097_NO_OPERATION, NVX_FLIP_IMMEDIATE);
        
            pPush += 4;
        }
        else if (pDevice->m_FrameBufferCount < 3)
        {
            // 2.  Synchronized flips with one back-buffer
        }
        else
        {
            // 3.  Synchronized flips with two back-buffers
        
            // Make sure the back-end isn't still doing work after the next
            // Flip call is started:
        
            Push1(pPush, NV097_WAIT_FOR_IDLE, 0);
        
            // Tell the DAC to scan out of the new buffer.  
            //
            // NVX_FLIP_SYCHRONIZED has the additional nice side effects of 
            // handling the gamma ramp change, and doing the INCREMENT_READ_3D 
            // at the next Vblank.
        
            // NVX_FLIP_* Data stored in NV097_SET_ZSTENCIL_CLEAR_VALUE
        
            Push1(pPush + 2, NV097_SET_ZSTENCIL_CLEAR_VALUE, flipAddress);
        
            Push1(pPush + 4, NV097_NO_OPERATION, NVX_FLIP_SYNCHRONIZED);
        
            pPush += 6;
        }

        pDevice->EndPush(pPush);
    }
}


//------------------------------------------------------------------------------
// SwapFlip

static VOID SwapFlip(
    CDevice* pDevice)
{
    // Remember the current primary header information:

    DWORD i = pDevice->m_FrameBufferCount - 1;

    D3DSurface* pBufferThis = pDevice->m_pFrameBuffer[i];

    DWORD OldData = pBufferThis->Data;
    DWORD OldLock = pBufferThis->Lock;

    do {
        // Swap Data and Lock members.

        D3DSurface* pBufferNext = pDevice->m_pFrameBuffer[i - 1];

        pBufferThis->Data = pBufferNext->Data;
        pBufferThis->Lock = pBufferNext->Lock;

        pBufferThis = pBufferNext;

    } while (--i != 0);

    // Complete the swap by copying the old primary into the last slot:

    pBufferThis->Data = OldData;
    pBufferThis->Lock = OldLock;

    // On debug builds, modify the context DMA to point to the
    // new render target address:

    DWORD colorBase = pDevice->m_Miniport.SetDmaRange(
                            D3D_COLOR_CONTEXT_DMA_IN_VIDEO_MEMORY,
                            pDevice->m_pFrameBuffer[0]);

    PPUSH pPush = pDevice->StartPush();

    // Send the flip software method.  Buffer one is always the one that
    // the DAC will be scanning from:

    Push1(pPush, NV097_WAIT_FOR_IDLE, 0);

    // NVX_FLIP_* Data stored in NV097_SET_ZSTENCIL_CLEAR_VALUE

    Push1(pPush + 2, 
          NV097_SET_ZSTENCIL_CLEAR_VALUE, 
          pDevice->m_pFrameBuffer[1]->Data);

    if (pDevice->m_PresentationInterval == D3DPRESENT_INTERVAL_IMMEDIATE)
    {
        Push1(pPush + 4, NV097_NO_OPERATION, NVX_FLIP_IMMEDIATE);

        pPush += 6;
    }
    else
    {
        Push1(pPush + 4, NV097_NO_OPERATION, NVX_FLIP_SYNCHRONIZED);

        Push1(pPush + 6, NV097_FLIP_INCREMENT_WRITE, 0);

        // Due to a bug, the hardware requires a NOP here, otherwise a stall 
        // may go through before the write:

        Push1(pPush + 8, NV097_NO_OPERATION, 0);

        pPush += 10;

        // If the current render target is not a texture, then tell the
        // hardware the location of the new backbuffer:

        if (pDevice->m_pRenderTarget == pDevice->m_pFrameBuffer[0])
        {
            // Stall the graphics pipe until we've flipped (flip_read == 
            // flip_write)

            Push1(pPush, NV097_FLIP_STALL, 0);

            pPush += 2;
        }
        else
        {
            // We don't have to stall the GPU while rendering to texture render
            // targets.  But the first time a SetRenderTarget is done back to
            // the back-buffer, we'll have to synchronize at that point:

            pDevice->m_StateFlags |= STATE_FLIPSTALLPENDING;
        }
    }

    // Set the new render target:

    Push1(pPush,
          NV097_SET_SURFACE_COLOR_OFFSET,
          pDevice->m_pFrameBuffer[0]->Data - colorBase);

    pDevice->EndPush(pPush + 2);
}

//------------------------------------------------------------------------------
// SwapFirstFlip
//
// Helper function to handle the very first flip

extern BOOL g_FlickerFilterSet;
extern BOOL g_SoftDisplayFilterSet;

static VOID SwapFirstFlip(
    CDevice* pDevice)
{
    DWORD DisplayMode = pDevice->m_Miniport.m_DisplayMode;
    DWORD Format = pDevice->m_Miniport.m_Format;
    DWORD Pitch = pDevice->m_Miniport.m_SurfacePitch;

    void *RegisterBase = pDevice->m_Miniport.m_RegisterBase;
    void *SavedDataAddress;

    ULONG Step;
    ULONG Field;

    KickOffAndWaitForIdle();

    // Set the pitch for a field-rendered mode to half of its true
    // value.
    //
    if (pDevice->m_Miniport.m_CurrentAvInfo & AV_FLAGS_FIELD)
    {
        Pitch /= 2;
    }

    DWORD flipAddress = pDevice->m_pFrameBuffer[1]->Data;

#ifdef STARTUPANIMATION

    REG_WR32(RegisterBase, NV_PCRTC_START, flipAddress);

#else

    Step = 0;

    do
    {
        D3DDevice_BlockUntilVerticalBlank();

        Step = AvSetDisplayMode(RegisterBase, Step, DisplayMode, Format, Pitch, flipAddress);
    }
    while (Step);

    // Field-rendered modes require that we turn off the flicker filter.

    if (pDevice->m_Miniport.m_CurrentAvInfo & AV_FLAGS_FIELD)
    {
        AvSendTVEncoderOption(pDevice->m_Miniport.m_RegisterBase, 
                              AV_OPTION_FLICKER_FILTER,
                              0,
                              NULL);
    }

    // Guess as to which field is currently being displayed and synchronize
    // the vblank count with it.

    AvSendTVEncoderOption(pDevice->m_Miniport.m_RegisterBase, AV_OPTION_GUESS_FIELD, 0, &Field);

    if ((pDevice->m_Miniport.m_VBlankCount & 1) == (Field & 1))
    {
        pDevice->m_Miniport.m_VBlankCount++;
    }

    // Make sure that the next call to these APIs don't get short-circuited.

    g_FlickerFilterSet = FALSE;
    g_SoftDisplayFilterSet = FALSE;

#endif

    // Clean up any buffers that were saved across reboots.

    SavedDataAddress = AvGetSavedDataAddress();

    if (SavedDataAddress != NULL)
    {
        SIZE_T AllocSize = MmQueryAllocationSize(SavedDataAddress);
        MmPersistContiguousMemory(SavedDataAddress, AllocSize, FALSE);
        MmFreeContiguousMemory(SavedDataAddress);
        AvSetSavedDataAddress(NULL);
    }

    // Unblank the screen that was blanked when the mode change first started.

    AvSendTVEncoderOption(RegisterBase, AV_OPTION_BLANK_SCREEN, FALSE, NULL);        

    pDevice->m_Miniport.m_FirstFlip = FALSE;
}

//------------------------------------------------------------------------------
// SwapStart

static VOID SwapStart(
    CDevice* pDevice)
{
    // Let any objects that are no longer being used be unlocked before
    // the Vblank occurs:

    SetFence(SETFENCE_NOKICKOFF);

    // Flip throttling.
    //
    // We never let the app have more than 3 frames queued up in the
    // push buffer at any time (3 is somewhat arbitrary, but should be
    // more than enough).  It's unlikely that games will ever get more
    // than 3 frames ahead, so a busy-loop here is just fine.

    DWORD blockTime = pDevice->m_SwapTime[
                (pDevice->m_SwapCount + 1) & (SWAP_THROTTLE_QUEUE_SIZE - 1)];

    if (blockTime != 0)
    {
        BlockOnTime(blockTime, FALSE);
    }

    // We need to do this increment after the block to reduce the amount of time
    // that the screen capture code in the debugger can be hosed.  We were
    // seeing a case where we would increment this value then block on the
    // above BlockOnTime at which point the user did an "xbcapture".  The 
    // screenshot logic would then stop all threads and wait for the swap
    // count to match the vblank flip count...something that would never happen
    // because we never actually pushed out the instructions to the GPU to
    // do the swap.  There still exists a possibility of this happening
    // if this thread loses its quantum in between now and when the swap
    // gets pushed but this thread is a lot more likely to get interrupted
    // in the above block then now and if it does get interrupted then the
    // capture will fail this one time.
    //
    // I don't think we can ever get this perfect without adding a bunch of
    // thread locking code to make this part of a swap atomic and that's 
    // something that we definately do not want to do just for the screenshot
    // utility.  If it fails, they can try it again.  But this change makes it
    // work 99% of the time instead of the 1% it was working before if we
    // entered the above BlockOnTime.

    pDevice->m_SwapCount++;
}

//------------------------------------------------------------------------------
// SwapFinish

static VOID SwapFinish(
    CDevice* pDevice)
{
    // Update the time-stamp of the framebuffer which we've just made
    // visible, in order to make sure that a LockRect() can't be done
    // on it until the flip is actually processed by the DAC (usually at 
    // the next VBlank), or that the copy-blt is completely done.
    //
    // Note that we do NOT have to do this for the framebuffer to which 
    // we're now rendering, since that is handled by the normal
    // IsResourceSetInDevice logic.

    pDevice->RecordSurfaceWritePush(pDevice->m_pFrameBuffer[1]);

    // Mark the time.  
    //
    // Calling SetFence() has the added benefit of doing a KickOff, 
    // which ensures that all the push-buffer instructions to handle 
    // our Swap don't get stuck in the queue forever:

    pDevice->m_SwapTime[pDevice->m_SwapCount 
                        & (SWAP_THROTTLE_QUEUE_SIZE - 1)] = SetFence(0);

    // Mode changes are deferred until after the first flip.  Wait around
    // until that flip happens and set the new mode.

    if (pDevice->m_Miniport.m_FirstFlip)
    {
        SwapFirstFlip(pDevice);
    }
}

//------------------------------------------------------------------------------
// D3DDevice_Swap

extern "C"
DWORD WINAPI D3DDevice_Swap(
    DWORD Flags)
{
    CDevice* pDevice = g_pDevice;

    if (DBG_CHECK(TRUE))
    {
        static BOOL InBegin;
        if (Flags & (D3DSWAP_COPY | D3DSWAP_BYPASSCOPY))
        {
            if (InBegin)
            {
                DPF_ERR("D3DSWAP_COPY/BYPASSCOPY before a previous one was FINISHed");
            }
            InBegin = TRUE;
        }
        if (Flags & D3DSWAP_FINISH)
        {
            if (!InBegin)
            {
                DPF_ERR("D3DSWAP_FINISH without a D3DSWAP_COPY/BYPASSCOPY first");
            }
            InBegin = FALSE;
        }
        if (Flags & ~(D3DSWAP_COPY | D3DSWAP_BYPASSCOPY | D3DSWAP_FINISH))
        {
            DPF_ERR("Invalid flag");
        }
        if (pDevice->m_StateFlags & STATE_RECORDPUSHBUFFER)
        {
            DPF_ERR("Can't call Swap while recording a push-buffer");
        }
        // only do end-of-field processing if this is the end of field
        if ((pDevice->m_dwOpcode) &&
            ((Flags == 0) || (Flags & D3DSWAP_FINISH)))
        {
            HandleShaderSnapshotOpcode();
        }
    }

    // Reset debug marker to 0 on each call to swap
    // (compiled away on non-debug build)
    pDevice->SetDebugMarker(0);

    if (Flags == 0)
    {
        Flags = D3DSWAP_COPY | D3DSWAP_FINISH;
    }

#if PROFILE

    // This var needs to persist between a beginning call to Swap and a Finish
    // call to swap.
    static D3DPERFEvent *pD3DPerfEvent;
    
    // Count this as the beginning of Present if (copy || bypasscopy) is specified
    if (Flags & (D3DSWAP_COPY | D3DSWAP_BYPASSCOPY))
    {
        COUNT_API(API_D3DDEVICE_PRESENT);
        pD3DPerfEvent = D3DPERF_PerfEventStart(D3DPERFEvent_Present, TRUE);
    }

#endif

    if (pDevice->m_StateFlags & STATE_COPYSWAP)
    {
        if (Flags & (D3DSWAP_COPY | D3DSWAP_BYPASSCOPY))
            SwapStart(pDevice);

        SwapCopy(pDevice, Flags);

        if (Flags & D3DSWAP_FINISH)
            SwapFinish(pDevice);
    }
    else if (Flags & D3DSWAP_FINISH)
    {
        SwapStart(pDevice);

        SwapFlip(pDevice);

        SwapFinish(pDevice);
    }
    
#if PROFILE

    // Count this as an end of Present if Finish is specified
    if(Flags & D3DSWAP_FINISH)
    {
        D3DPERF_PerfEventEnd(pD3DPerfEvent, TRUE);
        D3DPERF_HandlePresent();
    }

#endif

    return pDevice->m_SwapCount;
}

//------------------------------------------------------------------------------
// D3DDevice_SetBackBufferScale

extern "C"
void WINAPI D3DDevice_SetBackBufferScale(
    FLOAT xScale,
    FLOAT yScale)
{
    CDevice* pDevice = g_pDevice;

    COUNT_API(API_D3DDEVICE_SETBACKBUFFERSCALE);

    // The scale is always relative to the original antialiasing
    // scale factor:

    xScale *= ANTIALIAS_XSCALE(pDevice->m_MultiSampleType);
    yScale *= ANTIALIAS_YSCALE(pDevice->m_MultiSampleType);

    if (DBG_CHECK(TRUE))
    {
        if ((xScale <= 0.0f) || (yScale <= 0.0f))
        {
            DPF_ERR("Invalid scale value");
        }

        // Calculate the effective post- and pre-transform dimensions:

        DWORD drawWidth 
            = Round(PixelJar::GetWidth(pDevice->m_pFrameBuffer[1]) * xScale);
        DWORD drawHeight 
            = Round(PixelJar::GetHeight(pDevice->m_pFrameBuffer[1]) * yScale);

        DWORD surfaceWidth = PixelJar::GetWidth(pDevice->m_pFrameBuffer[0]);
        DWORD surfaceHeight = PixelJar::GetHeight(pDevice->m_pFrameBuffer[0]);

        if ((drawWidth > surfaceWidth) || (drawHeight > surfaceHeight))
        {
            DPF_ERR("Scale causes rendering to exceed pre-filter surface dimensions");
        }
    }

    // We handle SetBackBufferScale even for D3DSWAPEFFECT_FLIP by converting
    // on-the-fly to a 'copy' effect.  We also switch back to a 'flip' effect
    // when possible:

    if (pDevice->m_SwapEffect != D3DSWAPEFFECT_COPY)
    {
        if ((xScale == 1.0f) && (yScale == 1.0f))
        {
            // We can only convert to flipping when the format, dimensions, and 
            // stride are the same for each of the back-buffer surfaces.  It's 
            // sufficient just to check the back-buffer and one of the front-
            // buffers:

            if ((pDevice->m_pFrameBuffer[0]->Size 
                            == pDevice->m_pFrameBuffer[1]->Size) &&
                (pDevice->m_pFrameBuffer[0]->Format 
                            == pDevice->m_pFrameBuffer[1]->Format))
            {
                pDevice->m_StateFlags &= ~STATE_COPYSWAP;
            }
        }
        else
        {
            pDevice->m_StateFlags |= STATE_COPYSWAP;

            if (pDevice->m_StateFlags & STATE_FLIPSTALLPENDING)
            {
                pDevice->m_StateFlags &= ~STATE_FLIPSTALLPENDING;

                PPUSH pPush = pDevice->StartPush();

                Push1(pPush, NV097_FLIP_STALL, 0);

                pDevice->EndPush(pPush + 2);
            }
        }
    }

    pDevice->m_AntiAliasScaleX = xScale;
    pDevice->m_AntiAliasScaleY = yScale;

    D3DDevice_SetRenderTarget(pDevice->m_pRenderTarget, pDevice->m_pZBuffer);
}

//------------------------------------------------------------------------------
// D3DDevice_GetBackBufferScale

extern "C"
void WINAPI D3DDevice_GetBackBufferScale(
    FLOAT* pxScale,
    FLOAT* pyScale)
{
    CDevice* pDevice = g_pDevice;

    COUNT_API(API_D3DDEVICE_GETBACKBUFFERSCALE);

    *pxScale = pDevice->m_AntiAliasScaleX;
    *pyScale = pDevice->m_AntiAliasScaleY;
}

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\pusher.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       pusher.hpp
 *  Content:    Pusher access constants and macros
 *
 ***************************************************************************/

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

//------------------------------------------------------------------------------
// Flags for our internal SetFence routine:

#define SETFENCE_SEGMENT 0x1

#define SETFENCE_NOKICKOFF 0x2    

//------------------------------------------------------------------------------
// Debug state

#define PUSH_STATE_NONE 0x0
#define PUSH_STATE_START 0x1
#define PUSH_STATE_BLOCKED 0x3
 
//------------------------------------------------------------------------------
// Pusher defines

// Default size of the push-buffer, in bytes:

#define DEFAULT_PUSH_BUFFER_SIZE (512 * 1024)

// Default segment size:

#define DEFAULT_PUSH_BUFFER_SEGMENT_SIZE (DEFAULT_PUSH_BUFFER_SIZE / 16)

// This is the number of most-recently-created fences that we keep track
// of (which includes both user-inserted fences, and fences used to mark
// segments).  Must be a power of two:

    // #define PUSHER_FENCE_COUNT 4 // Test purposes only

#define PUSHER_FENCE_COUNT 64

// This shift is how many bits are left for the 'time' component.  A 
// value of 1 means that there's 31 bits of time, implying 2 billion 
// unique time values can be assigned before a wrap occurs (or about 
// 134 million wraps of the push-buffer if app doesn't use InsertFence 
// much).
//
// The nice thing about our system is that even if an object lives long
// enough to have its time value re-issued because of a wrap, that's 
// not even fatal: in the prohibitively rare case, the worst it will do
// is cause an incorrect wait (which is guaranteed not to be endless).

    // #define PUSHER_TIME_SHIFT 16 // Test purposes only

#define PUSHER_TIME_SHIFT 1

// The low bit of any valid 'Time' is always set.  (If it's not set, then
// that means it belongs to an object that has never yet been used.)

#define PUSHER_TIME_VALID_FLAG 1

// How far away, in bytes, must the Get be from a fence before we'll 
// block the thread instead of spin?  The absolute minimum must
// be 1024 to avoid writing a notifier into a spot in the push
// buffer after it has already been cached on the GPU.

#define PUSHER_BLOCK_THRESHOLD (32*1024)

// Dwords of data always available in the push buffer:
 
#define PUSHER_THRESHOLD_SIZE 128     

// Dwords of space we actually reserve at the end of the push buffer to
// leave room for our extra 'goo'.  The '+ 1' accounts for a JUMP instruction
// we may have to insert in order to wrap:

#define PUSHER_THRESHOLD_SIZE_PLUS_OVERHEAD (PUSHER_THRESHOLD_SIZE + 1)
            
// After running a large push-buffer, we always insert a fence for better
// object time granularity:

#define PUSHER_RUN_FENCE_THRESHOLD 8*1024

// The parser FIFO reads ahead even before our software method
// gets executed.  With the current setup, it can read 1024 bytes
// ahead, and so we have to be sure we don't try to fix-up 
// anything within that range.  We pad with NV097_NO_OPERATIONs if 
// the offset of our first fix-up isn't far enough.  (Note that we
// can't use PUSHER_NOPs in this case.)
//
// 32 bytes are added to account for the DMA fetch buffer, which is in
// addition to the FIFO slots.
//
// See NV_PFIFO_CACHE1_DMA_FETCH for more details.

#define PUSHER_MINIMUM_RUN_OFFSET (1024 + 32)

// Hardware push buffer encoding commands.  These use '+' instead of '|'
// because that's more conducive to address macros that have adds (the
// constant adds can be collapsed, whereas an 'or' and an 'add' cannot):

#define PUSHER_JUMP(x) \
            (0x00000001 + (x))  
            
#define PUSHER_CALL(x) \
            (0x00000002 + (x))  

#define PUSHER_NOINC(method) \
            (0x40000000 + (method))

#define PUSHER_METHOD(subch, method, count) \
            (((count) << 18) + ((subch) << 13) + (method))
            
// NOTE: Never use PUSHER_NOP!  It breaks our assumptions with 
//       PUSHER_MINIMUM_RUN_OFFSET because it doesn't take any FIFO
//       read-ahead slots:
            
#define PUSHER_NOP 0            

//------------------------------------------------------------------------------
// FenceEncoding
//
// Describes the actual push-buffer encoding of a fence.  A fence can be
// in one of two 'modes'...either just hanging out in the push buffer
// waiting to be executed or in 'block' mode when we want to actually
// block on the fence.

struct FenceEncoding
{
    // Semaphore command: NV097_BACK_END_WRITE_SEMAPHORE_RELEASE or
    // NV097_TEXTURE_READ_SEMAPHORE_RELEASE:

    DWORD m_SemaphoreCommand;      

    // Time of this fence:

    DWORD m_Time;         

    union
    {
        // Normal case:

        struct
        {
            // Kelvin NOP command - actually NV097_SET_COLOR_CLEAR_VALUE:

            DWORD m_SetColorClearCommand1;    

            // Set to zero by the CPU and ignored by the GPU:

            DWORD m_SetColorClearArgument1;  

            // Kelvin NOP command - actually NV097_SET_COLOR_CLEAR_VALUE:

            DWORD m_SetColorClearCommand2;    

            // Set to zero by the CPU and ignored by the GPU:

            DWORD m_SetColorClearArgument2;
        };

        // Blocking case:

        struct
        {
            // Wait-for-idle command - NV097_WAIT_FOR_IDLE:

            DWORD m_WaitForIdleCommand;

            // Zero:

            DWORD m_WaitForIdleArgument;

            // Notify command - NV097_NO_OPERATION:

            DWORD m_NoOperationCommand; 

            // NVX_FENCE:

            DWORD m_FenceCommand;
        };
    };
};

//------------------------------------------------------------------------------
// Fence

struct Fence
{
    // Time associated with this fence:

    DWORD Time;

    // Points directly into the push-buffer to the fence encoding.
    //
    // NOTE: This points into write-combined memory, so don't read from it!

    FenceEncoding* pEncoding;

    // Total number of bytes of RunPushBuffer calls ever inserted, at the time
    // that the fence was created:

    DWORD RunTotal;
};

//------------------------------------------------------------------------------
// FlushWCCache
//
// Forces the write-combined cache to get flushed.  sfence should be all we
// need but it doesn't always work out that way.

#ifdef ALIASPUSHER
    
__forceinline VOID FlushWCCache() { _asm { sfence }; }

#else

VOID FlushWCCache();

#endif


//------------------------------------------------------------------------------
// Pusher prototypes:

#if DBG

void DbgRecordPushStart(DWORD Size);

#else

static __forceinline void DbgRecordPushStart(DWORD Size) { }

#endif


class CDevice;

void KickOffAndWaitForIdle();
VOID BlockOnTime(DWORD Time, BOOL MakeSpace);
DWORD SetFence(DWORD Flags);

// Resource prototypes:

BOOLEAN IsResourceBusy(IDirect3DResource8 *pResource);
VOID BlockOnResource(IDirect3DResource8 *pResource);
VOID BlockOnNonSurfaceResource(IDirect3DResource8 *pResource);

//------------------------------------------------------------------------------
// EncodeMethod 

FORCEINLINE DWORD EncodeMethod(
    SubChannel subch,
    DWORD method,
    DWORD count = 1)
{
    // Hardware encoding limitation:

    ASSERT(count < 2048);       

    return PUSHER_METHOD(subch, method, count);
}

//------------------------------------------------------------------------------
// EncodeMethod 

FORCEINLINE DWORD EncodeMethod(
    DWORD method,
    DWORD count = 1)
{
    return EncodeMethod(SUBCH_3D, method, count);
}

//------------------------------------------------------------------------------
// DumpMatrixTransposed

VOID DumpMatrixTransposed(
    PPUSH pPush,
    DWORD encodedMethod,
    CONST D3DMATRIX* pMatrix);

#if !DBG

//------------------------------------------------------------------------------
// Stuff that doesn't do anything on retail builds:

FORCEINLINE VOID PARSE_PUSH_BUFFER() {}
FORCEINLINE VOID PRIMITIVE_LAUNCH_STATE_TEST() {}
FORCEINLINE VOID PRIMITIVE_LAUNCH_STATE_TEST2() {}

//------------------------------------------------------------------------------
// PushedRaw - Call this to advance the push pointer after having copied
//             raw data into the pusher buffer

FORCEINLINE VOID PushedRaw(
    PPUSH pPushNext)
{
}

//------------------------------------------------------------------------------
// Push1 - Push one dword

FORCEINLINE VOID Push1(
    PPUSH pPush,
    SubChannel subch,
    DWORD method,
    DWORD value)
{
    pPush[0] = PUSHER_METHOD(subch, method, 1);
    pPush[1] = value;
}

//------------------------------------------------------------------------------
// Push2 - Push two dwords

FORCEINLINE VOID Push2(
    PPUSH pPush,
    SubChannel subch,
    DWORD method,
    DWORD a,
    DWORD b)
{
    pPush[0] = PUSHER_METHOD(subch, method, 2);
    pPush[1] = a;
    pPush[2] = b;
}

//------------------------------------------------------------------------------
// Push3 - Push three dwords

FORCEINLINE VOID Push3(
    PPUSH pPush,
    SubChannel subch,
    DWORD method,
    DWORD a,
    DWORD b,
    DWORD c)
{
    pPush[0] = PUSHER_METHOD(subch, method, 3);
    pPush[1] = a;
    pPush[2] = b;
    pPush[3] = c;
}

//------------------------------------------------------------------------------
// Push4 - Push four dwords

FORCEINLINE VOID Push4(
    PPUSH pPush,
    SubChannel subch,
    DWORD method,
    DWORD a,
    DWORD b,
    DWORD c,
    DWORD d)
{
    pPush[0] = PUSHER_METHOD(subch, method, 4);
    pPush[1] = a;
    pPush[2] = b;
    pPush[3] = c;
    pPush[4] = d;
}

//------------------------------------------------------------------------------
// Push1f - Push one float

FORCEINLINE VOID Push1f(
    PPUSH pPush,
    SubChannel subch,
    DWORD method,
    FLOAT value)
{
    pPush[0] = PUSHER_METHOD(subch, method, 1);
    ((FLOAT*) pPush)[1] = value;
}

//------------------------------------------------------------------------------
// Push2f - Push two floats

FORCEINLINE VOID Push2f(
    PPUSH pPush,
    SubChannel subch,
    DWORD method,
    FLOAT a,
    FLOAT b)
{
    pPush[0] = PUSHER_METHOD(subch, method, 2);
    ((FLOAT*) pPush)[1] = a;
    ((FLOAT*) pPush)[2] = b;
}

//------------------------------------------------------------------------------
// Push3f - Push three floats

FORCEINLINE VOID Push3f(
    PPUSH pPush,
    SubChannel subch,
    DWORD method,
    FLOAT a,
    FLOAT b,
    FLOAT c)
{
    pPush[0] = PUSHER_METHOD(subch, method, 3);
    ((FLOAT*) pPush)[1] = a;
    ((FLOAT*) pPush)[2] = b;
    ((FLOAT*) pPush)[3] = c;
}

//------------------------------------------------------------------------------
// Push4f - Push four floats

FORCEINLINE VOID Push4f(
    PPUSH pPush,
    SubChannel subch,
    DWORD method,
    FLOAT a,
    FLOAT b,
    FLOAT c,
    FLOAT d)
{
    pPush[0] = PUSHER_METHOD(subch, method, 4);
    ((FLOAT*) pPush)[1] = a;
    ((FLOAT*) pPush)[2] = b;
    ((FLOAT*) pPush)[3] = c;
    ((FLOAT*) pPush)[4] = d;
}

//------------------------------------------------------------------------------
// PushCount - Just push the method, with a specified count of data to follow

FORCEINLINE VOID PushCount(
    PPUSH pPush,
    SubChannel subch,
    DWORD method,
    DWORD count)
{
    pPush[0] = PUSHER_METHOD(subch, method, count);
}

//------------------------------------------------------------------------------
// PushMatrixTransposed

FORCEINLINE VOID PushMatrixTransposed(
    PPUSH pPush,
    DWORD method,
    CONST D3DMATRIX* pMatrix)
{
    DumpMatrixTransposed(pPush, PUSHER_METHOD(SUBCH_3D, method, 16), pMatrix);
}

//------------------------------------------------------------------------------
// PushInverseModelViewMatrix

FORCEINLINE VOID PushInverseModelViewMatrix(
    PPUSH pPush,
    DWORD method,
    CONST D3DMATRIX* pMatrix)
{
    *pPush = PUSHER_METHOD(SUBCH_3D, method, 12);
    memcpy((void*) (pPush + 1), pMatrix, 12 * sizeof(float));
}

//------------------------------------------------------------------------------
// PushMatrix
//
// WARNING: Use this method sparingly, as it causes code bloat

FORCEINLINE VOID PushMatrix(
    PPUSH pPush,
    DWORD method,
    FLOAT m11, FLOAT m12, FLOAT m13, FLOAT m14,
    FLOAT m21, FLOAT m22, FLOAT m23, FLOAT m24,
    FLOAT m31, FLOAT m32, FLOAT m33, FLOAT m34,
    FLOAT m41, FLOAT m42, FLOAT m43, FLOAT m44)
{
    *(pPush) = PUSHER_METHOD(SUBCH_3D, method, 16);
    *((FLOAT*) pPush + 1) = m11;
    *((FLOAT*) pPush + 2) = m12;
    *((FLOAT*) pPush + 3) = m13;
    *((FLOAT*) pPush + 4) = m14;
    *((FLOAT*) pPush + 5) = m21;
    *((FLOAT*) pPush + 6) = m22;
    *((FLOAT*) pPush + 7) = m23;
    *((FLOAT*) pPush + 8) = m24;
    *((FLOAT*) pPush + 9) = m31;
    *((FLOAT*) pPush + 10) = m32;
    *((FLOAT*) pPush + 11) = m33;
    *((FLOAT*) pPush + 12) = m34;
    *((FLOAT*) pPush + 13) = m41;
    *((FLOAT*) pPush + 14) = m42;
    *((FLOAT*) pPush + 15) = m43;
    *((FLOAT*) pPush + 16) = m44;
}

#else // This #else handles the debug case

//------------------------------------------------------------------------------
// For debug, we have out-of-line routines which do a bunch of work:

VOID PushedRaw(PPUSH pPushNext);
VOID Push1(PPUSH pPush, SubChannel subch, DWORD method, DWORD value);
VOID Push2(PPUSH pPush, SubChannel subch, DWORD method, DWORD a, DWORD b);
VOID Push3(PPUSH pPush, SubChannel subch, DWORD method, DWORD a, DWORD b, DWORD c);
VOID Push4(PPUSH pPush, SubChannel subch, DWORD method, DWORD a, DWORD b, DWORD c, DWORD d);
VOID Push1f(PPUSH pPush, SubChannel subch, DWORD method, FLOAT value);
VOID Push2f(PPUSH pPush, SubChannel subch, DWORD method, FLOAT a, FLOAT b);
VOID Push3f(PPUSH pPush, SubChannel subch, DWORD method, FLOAT a, FLOAT b, FLOAT c);
VOID Push4f(PPUSH pPush, SubChannel subch, DWORD method, FLOAT a, FLOAT b, FLOAT c, FLOAT d);
VOID PushCount(PPUSH pPush, SubChannel subch, DWORD method, DWORD count);
VOID PushMatrixTransposed(PPUSH pPush, DWORD method, CONST D3DMATRIX* pMatrix);
VOID PushInverseModelViewMatrix(PPUSH pPush, DWORD method, CONST D3DMATRIX* pMatrix);
VOID PushMatrix(PPUSH pPush, DWORD method, 
                FLOAT m11, FLOAT m12, FLOAT m13, FLOAT m14,
                FLOAT m21, FLOAT m22, FLOAT m23, FLOAT m24, 
                FLOAT m31, FLOAT m32, FLOAT m33, FLOAT m34,
                FLOAT m41, FLOAT m42, FLOAT m43, FLOAT m44);

//------------------------------------------------------------------------------
// Debug routine prototypes and globals

VOID PARSE_PUSH_BUFFER();
VOID PRIMITIVE_LAUNCH_STATE_TEST();
VOID PRIMITIVE_LAUNCH_STATE_TEST2();
VOID ShowDump(DWORD subch);

extern PPUSH g_ParsePut;

#endif

//------------------------------------------------------------------------------
// 3D-default push methods:

FORCEINLINE VOID Push1(
    PPUSH pPush,
    DWORD method,
    DWORD value)
{
    XMETAL_Push1(pPush, method, value);
}

FORCEINLINE VOID Push1f(
    PPUSH pPush,
    DWORD method,
    FLOAT value)
{
    XMETAL_Push1f(pPush, method, value);
}

FORCEINLINE VOID Push2(
    PPUSH pPush,
    DWORD method,
    DWORD a,
    DWORD b)
{
    XMETAL_Push2(pPush, method, a, b);
}

FORCEINLINE VOID Push3(
    PPUSH pPush,
    DWORD method,
    DWORD a,
    DWORD b,
    DWORD c)
{
    XMETAL_Push3(pPush, method, a, b, c);
}

FORCEINLINE VOID Push4(
    PPUSH pPush,
    DWORD method,
    DWORD a,
    DWORD b,
    DWORD c,
    DWORD d)
{
    XMETAL_Push4(pPush, method, a, b, c, d);
}

FORCEINLINE VOID Push2f(
    PPUSH pPush,
    DWORD method,
    FLOAT a,
    FLOAT b)
{
    XMETAL_Push2f(pPush, method, a, b);
}

FORCEINLINE VOID Push3f(
    PPUSH pPush,
    DWORD method,
    FLOAT a,
    FLOAT b,
    FLOAT c)
{
    XMETAL_Push3f(pPush, method, a, b, c);
}

FORCEINLINE VOID Push4f(
    PPUSH pPush,
    DWORD method,
    FLOAT a,
    FLOAT b,
    FLOAT c,
    FLOAT d)
{
    XMETAL_Push4f(pPush, method, a, b, c, d);
}

FORCEINLINE VOID PushCount(
    PPUSH pPush,
    DWORD method,
    DWORD count)
{
    XMETAL_PushCount(pPush, method, count);
}

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\pixeljar.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       pixeljar.hpp
 *  Content:    Implementation of D3DPixelContainer.
 *
 ***************************************************************************/

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

//
// Random helpers.
//

//------------------------------------------------------------------------
// Table for determining various attributes of the texture format.
//

#define FMT_RENDERTARGET 0x80
#define FMT_DEPTHBUFFER 0x40
#define FMT_BITSPERPIXEL 0x3c
#define FMT_LINEAR 0x02
#define FMT_SWIZZLED 0x01

#define FMT_32BPP 0x20
#define FMT_16BPP 0x10
#define FMT_8BPP 0x08
#define FMT_4BPP 0x04

D3DCONST BYTE g_TextureFormat[] =
{
    FMT_8BPP  |                    FMT_SWIZZLED,  // 0x00 D3DFMT_L8
    FMT_8BPP  |                    FMT_SWIZZLED,  // 0x01 D3DFMT_AL8
    FMT_16BPP |                    FMT_SWIZZLED,  // 0x02 D3DFMT_A1R5G5B5
    FMT_16BPP | FMT_RENDERTARGET | FMT_SWIZZLED,  // 0x03 D3DFMT_X1R5G5B5
    FMT_16BPP |                    FMT_SWIZZLED,  // 0x04 D3DFMT_A4R4G4B4
    FMT_16BPP | FMT_RENDERTARGET | FMT_SWIZZLED,  // 0x05 D3DFMT_R5G6B5
    FMT_32BPP | FMT_RENDERTARGET | FMT_SWIZZLED,  // 0x06 D3DFMT_A8R8G8B8
    FMT_32BPP | FMT_RENDERTARGET | FMT_SWIZZLED,  // 0x07 D3DFMT_X8R8G8B8/D3DFMT_X8L8V8U8
    0,                                            // 0x08
    0,                                            // 0x09
    0,                                            // 0x0A
    FMT_8BPP  |                    FMT_SWIZZLED,  // 0x0B D3DFMT_P8
    FMT_4BPP,                                     // 0x0C D3DFMT_DXT1
    0,                                            // 0x0D
    FMT_8BPP,                                     // 0x0E D3DFMT_DXT2/D3DFMT_DXT3
    FMT_8BPP,                                     // 0x0F D3DFMT_DXT4/D3DFMT_DXT5
    FMT_16BPP |                    FMT_LINEAR,    // 0x10 D3DFMT_LIN_A1R5G5B5
    FMT_16BPP | FMT_RENDERTARGET | FMT_LINEAR,    // 0x11 D3DFMT_LIN_R5G6B5
    FMT_32BPP | FMT_RENDERTARGET | FMT_LINEAR,    // 0x12 D3DFMT_LIN_A8R8G8B8
    FMT_8BPP  | FMT_RENDERTARGET | FMT_LINEAR,    // 0x13 D3DFMT_LIN_L8
    0,                                            // 0x14
    0,                                            // 0x15
    FMT_16BPP |                    FMT_LINEAR,    // 0x16 D3DFMT_LIN_R8B8
    FMT_16BPP | FMT_RENDERTARGET | FMT_LINEAR,    // 0x17 D3DFMT_LIN_G8B8
    0,                                            // 0x18
    FMT_8BPP  |                    FMT_SWIZZLED,  // 0x19 D3DFMT_A8
    FMT_16BPP |                    FMT_SWIZZLED,  // 0x1A D3DFMT_A8L8
    FMT_8BPP  |                    FMT_LINEAR,    // 0x1B D3DFMT_LIN_AL8
    FMT_16BPP | FMT_RENDERTARGET | FMT_LINEAR,    // 0x1C D3DFMT_LIN_X1R5G5B5
    FMT_16BPP |                    FMT_LINEAR,    // 0x1D D3DFMT_LIN_A4R4G4B4
    FMT_32BPP | FMT_RENDERTARGET | FMT_LINEAR,    // 0x1E D3DFMT_LIN_X8R8G8B8
    FMT_8BPP  |                    FMT_LINEAR,    // 0x1F D3DFMT_LIN_A8
    FMT_16BPP |                    FMT_LINEAR,    // 0x20 D3DFMT_LIN_A8L8
    0,                                            // 0x21
    0,                                            // 0x22
    0,                                            // 0x23
    FMT_16BPP,                                    // 0x24 D3DFMT_UYVY
    FMT_16BPP,                                    // 0x25 D3DFMT_YUY2
    0,                                            // 0x26
    FMT_16BPP |                    FMT_SWIZZLED,  // 0x27 D3DFMT_R6G5B5/D3DFMT_L6V5U5
    FMT_16BPP |                    FMT_SWIZZLED,  // 0x28 D3DFMT_G8B8/D3DFMT_V8U8
    FMT_16BPP |                    FMT_SWIZZLED,  // 0x29 D3DFMT_R8B8
    FMT_32BPP | FMT_DEPTHBUFFER |  FMT_SWIZZLED,  // 0x2A D3DFMT_D24S8
    FMT_32BPP | FMT_DEPTHBUFFER |  FMT_SWIZZLED,  // 0x2B D3DFMT_F24S8
    FMT_16BPP | FMT_DEPTHBUFFER |  FMT_SWIZZLED,  // 0x2C D3DFMT_D16_LOCKABLE/D3DFMT_D16
    FMT_16BPP | FMT_DEPTHBUFFER |  FMT_SWIZZLED,  // 0x2D D3DFMT_F16
    FMT_32BPP | FMT_DEPTHBUFFER |  FMT_LINEAR,    // 0x2E D3DFMT_LIN_D24S8
    FMT_32BPP | FMT_DEPTHBUFFER |  FMT_LINEAR,    // 0x2F D3DFMT_LIN_F24S8
    FMT_16BPP | FMT_DEPTHBUFFER |  FMT_LINEAR,    // 0x30 D3DFMT_LIN_D16
    FMT_16BPP | FMT_DEPTHBUFFER |  FMT_LINEAR,    // 0x31 D3DFMT_LIN_F16
    FMT_16BPP |                    FMT_SWIZZLED,  // 0x32 D3DFMT_L16
    FMT_32BPP |                    FMT_SWIZZLED,  // 0x33 D3DFMT_V16U16
    0,                                            // 0x34
    FMT_16BPP |                    FMT_LINEAR,    // 0x35 D3DFMT_LIN_L16
    0,                                            // 0x36
    FMT_16BPP |                    FMT_LINEAR,    // 0x37 D3DFMT_LIN_R6G5B5
    FMT_16BPP |                    FMT_SWIZZLED,  // 0x38 D3DFMT_R5G5B5A1
    FMT_16BPP |                    FMT_SWIZZLED,  // 0x39 D3DFMT_R4G4B4A4
    FMT_32BPP |                    FMT_SWIZZLED,  // 0x3A D3DFMT_A8B8G8R8/D3DFMT_Q8W8V8U8
    FMT_32BPP |                    FMT_SWIZZLED,  // 0x3B D3DFMT_B8G8R8A8
    FMT_32BPP |                    FMT_SWIZZLED,  // 0x3C D3DFMT_R8G8B8A8
    FMT_16BPP |                    FMT_LINEAR,    // 0x3D D3DFMT_LIN_R5G5B5A1
    FMT_16BPP |                    FMT_LINEAR,    // 0x3E D3DFMT_LIN_R4G4B4A4
    FMT_32BPP |                    FMT_LINEAR,    // 0x3F D3DFMT_LIN_A8B8G8R8
    FMT_32BPP |                    FMT_LINEAR,    // 0x40 D3DFMT_LIN_B8G8R8A8
    FMT_32BPP |                    FMT_LINEAR,    // 0x41 D3DFMT_LIN_R8G8B8A8
};

//------------------------------------------------------------------------------
// Permissible tile pitches.
//
D3DCONST DWORD g_TilePitches[] =
{
    D3DTILE_PITCH_0200,
    D3DTILE_PITCH_0300,
    D3DTILE_PITCH_0400,
    D3DTILE_PITCH_0500,
    D3DTILE_PITCH_0600,
    D3DTILE_PITCH_0700,
    D3DTILE_PITCH_0800,
    D3DTILE_PITCH_0A00,
    D3DTILE_PITCH_0C00,
    D3DTILE_PITCH_0E00,
    D3DTILE_PITCH_1000,
    D3DTILE_PITCH_1400,
    D3DTILE_PITCH_1800,
    D3DTILE_PITCH_1C00,
    D3DTILE_PITCH_2000,
    D3DTILE_PITCH_2800,
    D3DTILE_PITCH_3000,
    D3DTILE_PITCH_3800,
    D3DTILE_PITCH_4000,
    D3DTILE_PITCH_5000,
    D3DTILE_PITCH_6000,
    D3DTILE_PITCH_7000,
    D3DTILE_PITCH_8000,
    D3DTILE_PITCH_A000,
    D3DTILE_PITCH_C000,
    D3DTILE_PITCH_E000,
};

//----------------------------------------------------------------------------
// Calculates the log2 of a number that is a power-of-two.
//
DWORD __fastcall Log2(
    DWORD Value
    );

//------------------------------------------------------------------------
// Helper which decodes the D3DFORMAT.
//
inline D3DFORMAT DecodeD3DFORMAT(
    DWORD Format
    )
{
    return (D3DFORMAT)((Format & D3DFORMAT_FORMAT_MASK) >> D3DFORMAT_FORMAT_SHIFT);
}

//------------------------------------------------------------------------
// Gets the log2 width.
//
inline DWORD DecodeLogWidth(
    DWORD Format
    )
{
    return (Format & D3DFORMAT_USIZE_MASK) >> D3DFORMAT_USIZE_SHIFT;
}

//------------------------------------------------------------------------
// Gets the log2 height.
//
inline DWORD DecodeLogHeight(
    DWORD Format
    )
{
    return (Format & D3DFORMAT_VSIZE_MASK) >> D3DFORMAT_VSIZE_SHIFT;
}

//------------------------------------------------------------------------
// Gets the log2 depth.
//
inline DWORD DecodeLogDepth(
    DWORD Format
    )
{
    return (Format & D3DFORMAT_PSIZE_MASK) >> D3DFORMAT_PSIZE_SHIFT;
}

//------------------------------------------------------------------------
// Maps a swizzled D3DFORMAT to its linear counterpart.  This should
// only be used from CDevice::InitializeFrameBuffers as we want to keep
// our lies and gibberish to a minimum.
//
D3DFORMAT MapToLinearD3DFORMAT(
    D3DFORMAT Format
    );

//------------------------------------------------------------------------
// Determines whether this is a valid render target format.
//
inline BOOL IsValidRenderTargetD3DFORMAT(
    DWORD Format
    )
{
    return g_TextureFormat[Format] & FMT_RENDERTARGET;
}

//------------------------------------------------------------------------
// Determines whether this is a valid z-buffer format.
//
inline BOOL IsValidDepthBufferD3DFORMAT(
    DWORD Format
    )
{
    return g_TextureFormat[Format] & FMT_DEPTHBUFFER;
}

//----------------------------------------------------------------------------
// Helper to determine if this is a swizzled texture or not.
//
inline BOOL IsSwizzledD3DFORMAT(
    D3DFORMAT Format
    )
{
    return g_TextureFormat[Format] & FMT_SWIZZLED;
}

//----------------------------------------------------------------------------
// Helper to determine if this is a linear texture or not.
//
inline BOOL IsLinearD3DFORMAT(
    DWORD Format
    )
{
    return g_TextureFormat[Format] & FMT_LINEAR;
}

//------------------------------------------------------------------------
// Determine the number of bits per pixel are required for this format.
//
inline DWORD BitsPerPixelOfD3DFORMAT(
    DWORD Format
    )
{
    return g_TextureFormat[Format] & FMT_BITSPERPIXEL;
}

//------------------------------------------------------------------------
// Determine the number of bits per pixel required for this format for
// video mode changes.
//
DWORD VideoBitsPerPixelOfD3DFORMAT(
    DWORD Format
    );

//----------------------------------------------------------------------------
// Determine if this is a compressed format.
//
bool IsCompressedD3DFORMAT(
    DWORD Format
    );

//------------------------------------------------------------------------
// Get the minimum log2 texture size for a format.
//
inline DWORD MinimumTextureSizeOfD3DFORMAT(
    DWORD Format
    )
{
    return IsCompressedD3DFORMAT(Format) ? 2 : 0;
}

//------------------------------------------------------------------------
// Calculate pitch from width and bpp
//
inline DWORD CalcPitch(
    DWORD Width,
    DWORD TexelSize
    )
{
    return (Width * TexelSize / 8 + D3DTEXTURE_PITCH_ALIGNMENT - 1) &
            ~(D3DTEXTURE_PITCH_ALIGNMENT - 1);
}

//----------------------------------------------------------------------------
// Calculate pitch taking tiling pitch values into account.
//
DWORD CalcTilePitch(
    DWORD Width,
    D3DFORMAT D3DFormat
    );

//
// PixelContainer implementation.
//

//----------------------------------------------------------------------------
// The PixelJar namespace  contains the methods used to implement all of the
// D3D types that contain pixels, including:
//
//      D3DSurface
//      D3DVolume
//      D3DBaseTexture
//      D3DTexture
//      D3DCubeTexture
//      D3DVolumeTexture
//
// All of these methods take an D3DPixelContainer on which to operate.
//
namespace PixelJar
{

    //------------------------------------------------------------------------
    // Differentiates between a surface/volume and a texture Texture instance.
    //
    inline bool IsSurface(
        D3DResource *pResource
        )
    {
        return (pResource->Common & D3DCOMMON_TYPE_MASK) == D3DCOMMON_TYPE_SURFACE;
    }

    //------------------------------------------------------------------------
    // Get the D3DFORMAT for the surface.
    //
    inline D3DFORMAT GetFormat(
        D3DPixelContainer *pPixels
        )
    {
        return (D3DFORMAT)((pPixels->Format & D3DFORMAT_FORMAT_MASK) >> D3DFORMAT_FORMAT_SHIFT);
    }

    //------------------------------------------------------------------------
    // Get the surface format value from a render target and its Zbuffer
    //
    DWORD GetSurfaceFormat(
        D3DPixelContainer *pRenderTarget,
        D3DPixelContainer *pZBuffer
        );

    //------------------------------------------------------------------------
    // Are the pixels in this jar swizzled?
    //
    inline BOOL IsSwizzled(
        D3DPixelContainer *pPixels
        )
    {
        return IsSwizzledD3DFORMAT(GetFormat(pPixels));
    }

    //------------------------------------------------------------------------
    // Can this PixelContainer be used as a render target?
    //
    inline BOOL IsValidRenderTarget(
        D3DPixelContainer *pPixels
        )
    {
        return IsValidRenderTargetD3DFORMAT(GetFormat(pPixels));
    }

    //------------------------------------------------------------------------
    // Can this PixelContainer be used as a z-buffer?
    //
    inline BOOL IsValidDepthBuffer(
        D3DPixelContainer *pPixels
        )
    {
        return IsValidDepthBufferD3DFORMAT(GetFormat(pPixels));
    }

    //------------------------------------------------------------------------
    // Gets the parent for this Surface.  Returns NULL for any jar that
    // doesn't have a parent, including all textures.
    //
    inline D3DBaseTexture *GetParent(
        D3DResource *pResource
        )
    {
        if (PixelJar::IsSurface(pResource))
        {
            return ((D3DSurface *)pResource)->Parent;
        }
        else
        {
            return NULL;
        }
    }

    //------------------------------------------------------------------------
    // Gets the # of mipmap levels in a texture.
    //
    inline DWORD GetMipmapLevelCount(
        D3DPixelContainer *pPixels
        )
    {
        return (pPixels->Format & D3DFORMAT_MIPMAP_MASK) >> D3DFORMAT_MIPMAP_SHIFT;
    }

    //------------------------------------------------------------------------
    // Gets the log2 width.
    //
    inline DWORD GetLogWidth(
        D3DPixelContainer *pPixels
        )
    {
        return DecodeLogWidth(pPixels->Format);
    }

    //------------------------------------------------------------------------
    // Gets the log2 height.
    //
    inline DWORD GetLogHeight(
        D3DPixelContainer *pPixels
        )
    {
        return DecodeLogHeight(pPixels->Format);
    }

    //------------------------------------------------------------------------
    // Gets the log2 depth.
    //
    inline DWORD GetLogDepth(
        D3DPixelContainer *pPixels
        )
    {
        return DecodeLogDepth(pPixels->Format);
    }


    //------------------------------------------------------------------------
    // Get the pixel/texel size of a format.
    //
    inline DWORD GetBitsPerPixel(
        D3DPixelContainer *pPixels
        )
    {
        return BitsPerPixelOfD3DFORMAT(GetFormat(pPixels));
    }

    //----------------------------------------------------------------------------
    // Determine if this is a compressed format.
    //
    inline bool IsCompressed(
        D3DPixelContainer *pPixels
        )
    {
        return IsCompressedD3DFORMAT(GetFormat(pPixels));
    }

    //------------------------------------------------------------------------
    // Calculates the scaling factor for a given depth buffer format.
    //
    void GetDepthBufferScale(
        D3DPixelContainer *pPixels,
        float *pScale
        );

    //------------------------------------------------------------------------
    // Gets the height/width of a pixel container.
    //
    void GetSize(
        D3DPixelContainer *pPixels,
        DWORD Level,
        DWORD *pWidth,
        DWORD *pHeight,
        DWORD *pDepth,
        DWORD *pPitch,
        DWORD *pSlice
        );

    //------------------------------------------------------------------------
    // Decodes the Pitch of a surface from the Size field.
    //
    __forceinline DWORD PitchFromSize(
        DWORD Size
        )
    {
        return (((Size & D3DSIZE_PITCH_MASK) >> D3DSIZE_PITCH_SHIFT) + 1) * D3DTEXTURE_PITCH_ALIGNMENT;
    }

    //------------------------------------------------------------------------
    // Gets the width of a linear surface.
    //
    __forceinline DWORD GetLinearWidth(
        D3DPixelContainer *pPixels
        )
    {
        ASSERT(pPixels->Size != 0);

        return (pPixels->Size & D3DSIZE_WIDTH_MASK) + 1;
    }

    //------------------------------------------------------------------------
    // Gets the height of a linear surface.
    //
    __forceinline DWORD GetLinearHeight(
        D3DPixelContainer *pPixels
        )
    {
        ASSERT(pPixels->Size != 0);

        return ((pPixels->Size & D3DSIZE_HEIGHT_MASK) >> D3DSIZE_HEIGHT_SHIFT) + 1;
    }

    //------------------------------------------------------------------------
    // Gets the pitch of a linear surface.
    //
    inline DWORD GetLinearPitch(
        D3DPixelContainer *pPixels
        )
    {
        ASSERT(pPixels->Size != 0);

        return PitchFromSize(pPixels->Size);
    }

    //------------------------------------------------------------------------
    // Gets the width of a pixel container.
    //
    __forceinline DWORD GetWidth(
        D3DPixelContainer *pPixels
        )
    {
        DWORD Size = pPixels->Size;

        if (!Size)
        {
            return (1 << GetLogWidth(pPixels));
        }
        else
        {
            return GetLinearWidth(pPixels);
        }
    }

    //------------------------------------------------------------------------
    // Gets the height of a pixel container.
    //
    __forceinline DWORD GetHeight(
        D3DPixelContainer *pPixels
        )
    {
        DWORD Size = pPixels->Size;

        if (!Size)
        {
            return (1 << GetLogHeight(pPixels));
        }
        else
        {
            return GetLinearHeight(pPixels);
        }
    }

    //------------------------------------------------------------------------
    // Gets the depth of a pixel container.
    //
    __forceinline DWORD GetDepth(
        D3DPixelContainer *pPixels
        )
    {
        DWORD Size = pPixels->Size;

        if (!Size)
        {
            return (1 << GetLogDepth(pPixels));
        }
        else
        {
            return 1;
        }
    }

    //------------------------------------------------------------------------
    // Gets the pitch of a pixel container.
    //
    inline DWORD GetPitch(
        D3DPixelContainer *pPixels
        )
    {
        DWORD Size = pPixels->Size;

        if (!Size)
        {
            DWORD Width = 1 << GetLogWidth(pPixels);

            switch(GetFormat(pPixels))
            {
            case D3DFMT_DXT1:
                return Width * 2;

            case D3DFMT_DXT2:
            case D3DFMT_DXT4:
                return Width * 4;

            default:
                return Width * GetBitsPerPixel(pPixels) / 8;
            }
        }
        else
        {
            return GetLinearPitch(pPixels);
        }
    }

    //------------------------------------------------------------------------
    // Gets the slice size of the surface.  Probably should be uninlined.
    //
    inline DWORD GetSlice(
        D3DPixelContainer *pPixels
        )
    {
        DWORD Size = pPixels->Size;
        DWORD BitsPerPixel = PixelJar::GetBitsPerPixel(pPixels);
        DWORD LogMin = MinimumTextureSizeOfD3DFORMAT(GetFormat(pPixels));

        if (!Size)
        {
            DWORD LogWidth = max(LogMin, GetLogWidth(pPixels));
            DWORD LogHeight = max(LogMin, GetLogHeight(pPixels));

            return (1 << (LogWidth + LogHeight)) * BitsPerPixel / 8;
        }
        else
        {
            return PitchFromSize(Size)
                   * (/* GetHeight */((Size & D3DSIZE_HEIGHT_MASK) >> D3DSIZE_HEIGHT_SHIFT) + 1);
        }
    }

    //------------------------------------------------------------------------------
    // Gets the surface desc information for a mipmap level.
    //
    void Get2DSurfaceDesc(
        D3DPixelContainer *pPixels,
        UINT Level,
        D3DSURFACE_DESC *pDesc
        );

    //------------------------------------------------------------------------------
    // Gets the surface desc information for a mipmap level.  This does not
    // set the type.
    //
    void Get3DSurfaceDesc(
        D3DPixelContainer *pPixels,
        UINT Level,
        D3DVOLUME_DESC *pDesc
        );

    //------------------------------------------------------------------------------
    // Finds the location of a surface within a texture.
    //
    void FindSurfaceWithinTexture(
        D3DPixelContainer *pPixels,
        D3DCUBEMAP_FACES FaceType,
        UINT Level,
        BYTE **ppbData,
        DWORD *pRowPitch,
        DWORD *pSlicePitch,
        DWORD *pFormat,
        DWORD *pSize
        );

    //------------------------------------------------------------------------------
    // Lock a 2D surface.
    //
    void Lock2DSurface(
        D3DPixelContainer *pPixels,
        D3DCUBEMAP_FACES FaceType,
        UINT Level,
        D3DLOCKED_RECT *pLockedRect,
        CONST RECT *pRect,
        DWORD Flags
        );

    //------------------------------------------------------------------------------
    // Lock a 3D surface.
    //
    void Lock3DSurface(
        D3DPixelContainer *pPixels,
        UINT Level,
        D3DLOCKED_BOX *pLockedVolume,
        CONST D3DBOX *pBox,
        DWORD Flags
        );

    //------------------------------------------------------------------------------
    // Encodes the Format and Size parameters for a surface and returns the number
    // of bytes required to the data for the surface.
    //
    DWORD EncodeFormat(
        DWORD Width,
        DWORD Height,
        DWORD Depth,
        DWORD Levels,
        D3DFORMAT D3DFormat,
        DWORD Pitch,
        bool isCubeMap,
        bool isVolume,
        DWORD *pFormat,
        DWORD *pSize
        );
};

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\pusher.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       pusher.cpp
 *  Content:    Handles access to the hardware's push buffer
 *
 ***************************************************************************/

#include "precomp.hpp"

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

#if DBG

// 'g_pPushNext' is used to make sure we don't leave any gaps in the
// push buffer when using Push() macros.

PPUSH g_pPushNext;

// 'g_PushIndex' is used to make sure we don't overwrite the end of
// our guaranteed buffer size when using Push() macros.

DWORD g_PushIndex;

// Number of dwords we reserved at either 'StartPush' or 'StartBuffer'
// time:

DWORD g_ReservedSize;

// 'g_PushState' is a debug-only global variable for making sure that
// 'StartPush/EndPush' is correctly paired by the calling code.

DWORD g_PushState;

#endif

#if DBG

//------------------------------------------------------------------------------
// Debug helper to record a 'StartPush'.

void DbgRecordPushStart(
    DWORD Size)
{
    if (g_PushState == PUSH_STATE_START)
    {
        DXGRIP("Pusher - Nested calls to the push-buffer allocator, potentially "
             "caused by calling drawing methods from multiple threads or from "
             "within a DPC.");
    }

    else if (g_PushState == PUSH_STATE_BLOCKED)
    {
        DXGRIP("Pusher - The push buffer allocator was called while a thread was "
             "blocked on a resource, potentially caused by calling a drawing "
             "from another thread or a DPC.");
    }

    g_PushState = PUSH_STATE_START;
    g_PushIndex = 0;
    g_pPushNext = g_pDevice->m_Pusher.m_pPut;
    g_ReservedSize = Size;
}

#endif DBG

//------------------------------------------------------------------------------
// BusyLoop
//
// Short time-waster.  Used mainly when we're looping on the 'HwGet()'
// register, as its bad hardware-pipeline-wise for us to be continually
// querying.
//
// Note that for longer delays it might be preferable to give up our time-
// slice for a while.

VOID BusyLoop()
{
    volatile DWORD i = 400;

    do {} while (--i != 0);
}

//------------------------------------------------------------------------------
// Set up the push buffer.  Separated from dxgcreate to keep it from getting
// too nasty.

HRESULT CDevice::InitializePushBuffer()
{
    m_pPushBase = (DWORD *)AllocateContiguousMemory(m_PushBufferSize, 0);
    if (m_pPushBase == NULL)
    {
        WARNING("FATAL: Unable to allocate push buffer, Init failed.");
        return E_OUTOFMEMORY;
    }

    m_pPushLimit = m_pPushBase + (m_PushBufferSize / sizeof(DWORD));

    m_Pusher.m_pPut = m_pPushBase;
    m_Pusher.m_pThreshold = m_pPushBase 
                          + (m_PushSegmentSize / sizeof(DWORD))
                          - PUSHER_THRESHOLD_SIZE_PLUS_OVERHEAD;

    // GPU time never equals CPU time, and neither are ever zero:

    m_CpuTime = (2 << PUSHER_TIME_SHIFT) | PUSHER_TIME_VALID_FLAG;
    *m_pGpuTime = (1 << PUSHER_TIME_SHIFT) | PUSHER_TIME_VALID_FLAG;
    m_LastRunPushBufferTime = (1 << PUSHER_TIME_SHIFT) | PUSHER_TIME_VALID_FLAG;

    // There must be enough bits in the Time variable to not overflow if
    // the entire push-buffer were filled with Fence commands (because
    // times would be re-issued while objects with those times are still
    // pending, which is bad):

    ASSERT(m_PushBufferSize / sizeof(FenceEncoding)
           < (1 << (32 - PUSHER_TIME_SHIFT)));

    // Initialize the segments:

    DWORD segments = (m_PushBufferSize - 1) / m_PushSegmentSize;
    DWORD power = 0;

    do {
        power++;
        segments >>= 1;

    } while (segments != 0);

    segments = (1 << power);

    ASSERT(segments >= m_PushBufferSize / m_PushSegmentSize);
    ASSERT(m_PusherSegment == NULL);

    m_PusherSegmentMask = (segments - 1);
    m_PusherSegment = (Fence*) MemAlloc(segments * sizeof(Fence));
    if (m_PusherSegment == NULL)
    {
        WARNING("FATAL: Unable to allocate segment array, Init failed.");
        return E_OUTOFMEMORY;
    }

#if DBG
    g_ParsePut = m_pPushBase;
#endif

    return S_OK;
}

//------------------------------------------------------------------------------
// UninitializePushBuffer

VOID CDevice::UninitializePushBuffer()
{
    if (m_pPushBase)
    {
        FreeContiguousMemory((void*) m_pPushBase);
    }

    if (m_PusherSegment)
    {
        MemFree(m_PusherSegment);
    }
}

//------------------------------------------------------------------------------
// SetFence
//
// Do the actual fence-putting into the push buffer.  Can't be called
// while recording a push-buffer.
//
// NOTE: Every SetFence MUST be accompanied by a KickOff!  The reason is
//       that our multi-threaded support lets a resource be released by
//       a non-drawing thread so long as that thread spins on IsBusy()
//       before doing the release.  A resource may be tied to any 
//       SetFence, so in order to not starve the thread we always do a
//       KickOff after every SetFence.

DWORD SetFence(
    DWORD Flags)
{
    CDevice *pDevice = g_pDevice;

    if (DBG_CHECK(pDevice->m_StateFlags & STATE_RECORDPUSHBUFFER))
    {
        DXGRIP("D3DDevice_InsertFence - can't InsertFence while recording a "
               "push-buffer.");
    }

    PPUSH pPush = pDevice->StartPush();

    FenceEncoding* pEncoding = (FenceEncoding *) pPush;

    DWORD time = pDevice->m_CpuTime;

    ASSERT(time & PUSHER_TIME_VALID_FLAG);

    // Fill in the fence:

    pEncoding->m_SemaphoreCommand
        = EncodeMethod(SUBCH_3D, NV097_BACK_END_WRITE_SEMAPHORE_RELEASE);
            
    pEncoding->m_Time = time;

    // We should use a Kelvin NOP here except that it will throw an
    // interrupt if the data is not zero.  SET_COLOR_CLEAR_VALUE takes the 
    // same amount of time to execute as a Kelvin NOP and allows any 
    // value.  It's safe to use because we always manually reset it
    // before we do any clears.

    pEncoding->m_SetColorClearCommand1 
            = PUSHER_METHOD(SUBCH_3D, NV097_SET_COLOR_CLEAR_VALUE, 1);
    pEncoding->m_SetColorClearArgument1 = 0;

    pEncoding->m_SetColorClearCommand2 
            = PUSHER_METHOD(SUBCH_3D, NV097_SET_COLOR_CLEAR_VALUE, 1);
    pEncoding->m_SetColorClearArgument2 = 0;

    PushedRaw(pPush + 6);
    pDevice->EndPush(pPush + 6);

    DWORD runTotal = pDevice->m_PusherPutRunTotal;
    DWORD fence = (time >> PUSHER_TIME_SHIFT) & (PUSHER_FENCE_COUNT - 1);

    pDevice->m_PusherFence[fence].Time = time;
    pDevice->m_PusherFence[fence].pEncoding = pEncoding;
    pDevice->m_PusherFence[fence].RunTotal = runTotal;

    // For 'segment' fences, which are to be kept at fairly regular
    // intervals, we also remember the fence in our segment array:

    if (Flags & SETFENCE_SEGMENT)
    {
        DWORD segment 
            = (pDevice->m_PusherLastSegment + 1) & pDevice->m_PusherSegmentMask;

        pDevice->m_PusherLastSegment = segment;

        pDevice->m_PusherSegment[segment].Time = time;
        pDevice->m_PusherSegment[segment].pEncoding = pEncoding;
        pDevice->m_PusherSegment[segment].RunTotal = runTotal;
    }

    // Open the next time.  We make sure we never have a CPU time of zero
    // by always adding by 2 and having the LSB set to one:

    pDevice->m_CpuTime += (1 << PUSHER_TIME_SHIFT);

    // The NOKICKOFF flag can only be set if the caller guarantees they will 
    // do their own KickOff:

    if (!(Flags & SETFENCE_NOKICKOFF))
    {
        pDevice->KickOff();
    }

    return time;
}

//------------------------------------------------------------------------------
// ComputeGap
//
// Computes the number of push-buffer bytes between a specified fence and
// where the GPU is currently reading.  If the GPU has already passed the
// fence, it returns zero.
//
// By its nature, this routine returns a value equal to or less than the
// true gap (the GPU is operating in real time to reduce the gap anyways).

DWORD FASTCALL ComputeGap(
    CDevice* pDevice,
    Fence* pFence)
{
    // Compute the push-buffer difference, accounting for wrapping of
    // the push-buffer:

    DWORD get = (DWORD) pDevice->GpuGet();
    if ((DWORD*) get <= pDevice->m_Pusher.m_pPut)
        get += pDevice->m_PusherLastSize;

    DWORD fence = (DWORD) pFence->pEncoding;
    if ((DWORD*) fence <= pDevice->m_Pusher.m_pPut)
        fence += pDevice->m_PusherLastSize;

    // The distance to the fence can be negative by the time we get here
    // because the GPU is constantly advancing in real-time:

    INT distance = fence - get;
    if (distance < 0)
        return 0;

    // Add in the length of all RunPushBuffer calls between the GPU and the
    // fence that haven't yet been executed by the GPU:

    INT run = pFence->RunTotal - pDevice->m_Miniport.m_PusherGetRunTotal;
    if (run < 0)
        run = 0;

    return run + distance;
}

//------------------------------------------------------------------------------
// FindFence
//
// Finds the fence of the same age (or newer if there isn't an exact match)
// as the specified 'Time'.
//
// Note that IsTimePending() should have already been done on 'Time'.

static Fence* FindFence(
    DWORD TargetTime)
{
    Fence* pFence;

    CDevice* pDevice = g_pDevice;

    ASSERT(TargetTime & PUSHER_TIME_VALID_FLAG);
    ASSERT(TargetTime != pDevice->m_CpuTime);

    // 'targetAge' is how many fences ago the particular fence we're looking
    // for was written:

    DWORD targetAge = pDevice->Age(TargetTime);

    // We keep the most recent PUSHER_FENCE_COUNT fences in the m_PusherFence
    // array:

    DWORD iFence = (DWORD) -1;
    DWORD iSegment;

    if (targetAge <= (PUSHER_FENCE_COUNT << PUSHER_TIME_SHIFT))
    {
        iFence = (TargetTime >> PUSHER_TIME_SHIFT) & (PUSHER_FENCE_COUNT - 1);
    }
    else
    {
        // D'oh, the specified time is older than anything in our fence array
        // (this can happen if a lot of InsertFences were done by the caller
        // recently).
        //
        // For this purpose, we use our segment array, which keeps fences over
        // a longer life time, at regular intervals.
        //
        // Start from the oldest and increase until we find something newer:
    
        iSegment = pDevice->m_PusherLastSegment;

        // We might not have a fence in the segment array that is the
        // same age or newer than the request.  If so, use the oldest
        // fence from the fence array.

        if (pDevice->Age(pDevice->m_PusherSegment[iSegment].Time) > targetAge)
        {
            iFence = (pDevice->m_CpuTime >> PUSHER_TIME_SHIFT) 
                   & (PUSHER_FENCE_COUNT - 1);
        }
        else
        {
            // We now know that there's a segment fence which is newer than the
            // target time, so our loop will terminate:

            do {
                iSegment = (iSegment + 1) & pDevice->m_PusherSegmentMask;

            } while (pDevice->Age(pDevice->m_PusherSegment[iSegment].Time) 
                        > targetAge);
        }
    }

    // Make sure the fence isn't stale by going through each of the newer
    // fences and ensuring that their push-buffer address is really
    // newer:

    if (iFence != (DWORD) -1)
    {
        pFence = &pDevice->m_PusherFence[iFence];
    
        DWORD fence = (DWORD) pFence->pEncoding;
        if ((DWORD*) fence <= pDevice->m_Pusher.m_pPut)
            fence += pDevice->m_PusherLastSize;
    
        DWORD iOldest = (pDevice->m_CpuTime >> PUSHER_TIME_SHIFT) 
                      & (PUSHER_FENCE_COUNT - 1);

        while (TRUE)
        {
            iFence = (iFence + 1) & (PUSHER_FENCE_COUNT - 1);
            if (iFence == iOldest)
                break;
    
            DWORD newerFence = (DWORD) pDevice->m_PusherFence[iFence].pEncoding;
            if ((DWORD*) newerFence <= pDevice->m_Pusher.m_pPut)
                newerFence += pDevice->m_PusherLastSize;
    
            if (newerFence < fence)
                return NULL;
        }
    }
    else
    {
        pFence = &pDevice->m_PusherSegment[iSegment];
    
        DWORD segment = (DWORD) pFence->pEncoding;
        if ((DWORD*) segment <= pDevice->m_Pusher.m_pPut)
            segment += pDevice->m_PusherLastSize;
    
        DWORD iOldest = (pDevice->m_PusherLastSegment + 1) 
                      & pDevice->m_PusherSegmentMask;
        while (TRUE)
        {
            iSegment = (iSegment + 1) & pDevice->m_PusherSegmentMask;
            if (iSegment == iOldest)
                break;
    
            DWORD newerSegment = (DWORD) pDevice->m_PusherSegment[iSegment].pEncoding;
            if ((DWORD*) newerSegment <= pDevice->m_Pusher.m_pPut)
                newerSegment += pDevice->m_PusherLastSize;
    
            if (newerSegment < segment)
                return NULL;
        }
    }

    ASSERT(pFence->pEncoding != NULL);
    ASSERT(pFence->Time & PUSHER_TIME_VALID_FLAG);

    // Make sure the returned fence is the same as (or newer than) the 
    // requested time:

    ASSERT(pDevice->Age(pFence->Time) <= pDevice->Age(TargetTime));

    return pFence;
}

//------------------------------------------------------------------------------
// BlockOnTime
//
// Wait until the GPU gets to the specified time.  
//
// If the GPU is very close to the requested time, simply spin the CPU until 
// the GPU gets there; if the GPU is far from the requested time, insert a 
// software-method instruction at the requested point in the push-buffer, and 
// yield our thread until the interrupt is hit, at which time our thread will
// be resumed.

VOID BlockOnTime(
    DWORD Time,
    BOOL MakeSpace)
{
    DWORD status;
    LARGE_INTEGER timeOut;
    LARGE_INTEGER* pTimeOut = NULL;

    CDevice* pDevice = g_pDevice;

    ASSERT(Time & PUSHER_TIME_VALID_FLAG);
    ASSERT((pDevice->GpuTime() != pDevice->m_CpuTime) &&
           (pDevice->GpuTime() & PUSHER_TIME_VALID_FLAG) &&
           (pDevice->m_CpuTime & PUSHER_TIME_VALID_FLAG));

    // No need to block if the GPU is already past the specified time
    // value:

    if (!pDevice->IsTimePending(Time))
        return;

    // If the time is current, then we need to insert a marker:

    if (Time == pDevice->m_CpuTime)
        SetFence(0);

    DWORD spinTime = Time;

    Fence* targetFence = FindFence(Time);
    if (targetFence == NULL)
        return;

#if DBG

    if (g_PushState == PUSH_STATE_START)
    {
        DXGRIP("Pusher - Attempting to block while pushing data to the push "
               "buffer, possibly because you are calling blocking/drawing "
               "methods from multiple threads or a DPC.");
    }
    else if (g_PushState == PUSH_STATE_BLOCKED)
    {
        DXGRIP("Pusher - Attempting to block on a fence while a thread is "
               "already blocked, possibly because you are calling blocking "
               "methods from multiple threads or a DPC.");
    }

    g_PushState = PUSH_STATE_BLOCKED;

    timeOut.QuadPart = (LONGLONG) D3D__DeadlockTimeOutVal * (LONGLONG)-10000;
    pTimeOut = &timeOut;

#endif DBG

    // Because of the GPU's read-ahead-cache, it will effectively ignore
    // any modifications we make that are less than 1KB ahead of where
    // the hardware is currently 'getting':

    DWORD gap = ComputeGap(pDevice, targetFence);

    if (gap >= PUSHER_BLOCK_THRESHOLD)
    {
        // Ensure that the fence is not stale.  Yes, these are reads from 
        // write-combined memory.  (Hi Mike.)

        ASSERT(targetFence->pEncoding->m_SemaphoreCommand 
            == EncodeMethod(SUBCH_3D, NV097_BACK_END_WRITE_SEMAPHORE_RELEASE));
        ASSERT(targetFence->Time == targetFence->pEncoding->m_Time);

        FenceEncoding* pEncoding = targetFence->pEncoding;
    
        KeClearEvent(&pDevice->m_Miniport.m_BusyBlockEvent);

        // Here we're going to modify an already-submitted portion of
        // the push-buffer in order to insert an interrupt command that 
        // will wake up the CPU and release our thread.  
        //
        // NOTE: Because the GPU is operating asynchronously to the CPU,
        //       there's a chance that the CPU may get paused between
        //       any instruction in this code - meaning that the GPU
        //       may get to where we're modifying before we've completed
        //       all of our push-buffer modifications!  Consequently, we
        //       have to make sure that we're robust if this happens (we
        //       can't crash the GPU with any partial writes, and we
        //       have to account for the possibility of the GPU getting 
        //       past the inserted interrupt command before we finish 
        //       writing it.)
        //
        // First, ensure that the back-end is flushed before the NVX_FENCE
        // command is processed (otherwise the kernel event could be 
        // set before the back-end finishes).  An alternative to this
        // would be to spin the CPU after the thread wakes up.
        //
        // We don't need to do this for MakeSpace...

        if (!MakeSpace)
        {
            pEncoding->m_WaitForIdleCommand 
                = PUSHER_METHOD(SUBCH_3D, NV097_WAIT_FOR_IDLE, 1);
    
            // Note that we technically don't have to write this zero,
            // since we wrote it as zero when we first created the fence.
            // I'm doing this here to keep the writes contiguous...
    
            pEncoding->m_WaitForIdleArgument
                = 0;
        }

        // Insert the command that wakes up the CPU and sets the kernel
        // event:
    
        pEncoding->m_NoOperationCommand 
            = PUSHER_METHOD(SUBCH_3D, NV097_NO_OPERATION, 1);
        pEncoding->m_FenceCommand 
            = NVX_FENCE;

        // Make sure that our modifications get written to the push-buffer:
    
        FlushWCCache();

        DWORD newGap = ComputeGap(pDevice, targetFence);
        ASSERT(newGap <= gap);
        if (newGap < PUSHER_BLOCK_THRESHOLD)
        {
            // Argh, the gap closed enough that we're not sure if we beat
            // the GPU's read-ahead.  It would be safe to let it go, but we
            // NOP out the wait-for-idle to save some GPU time in case we
            // truly did beat the read-ahead:

            pEncoding->m_WaitForIdleCommand 
                = PUSHER_METHOD(SUBCH_3D, NV097_NO_OPERATION, 1);
            pEncoding->m_WaitForIdleArgument
                = 0;
            pEncoding->m_NoOperationCommand 
                = PUSHER_METHOD(SUBCH_3D, NV097_NO_OPERATION, 1);
            pEncoding->m_FenceCommand 
                = 0;

            FlushWCCache();

            spinTime = targetFence->Time;
            goto Spin;
        }

        // Block on the event:

        while (TRUE)
        {
            status = KeWaitForSingleObject(&pDevice->m_Miniport.m_BusyBlockEvent,
                                           UserRequest,
                                           UserMode,
                                           FALSE,
                                           pTimeOut);
            if (status == STATUS_SUCCESS)
                break;

            DXGRIP("Possible deadlock");
        }
    }
    else
    {

Spin:

        // Spin if the GPU is close to the fence we're blocking on.  We do
        // this check again just in case the GPU has wandered across this
        // threshold while writing the notification above.

        COUNT_PERFCYCLES(PERF_CPUSPINDURINGWAIT_TIME);

        INITDEADLOCKCHECK();

        // Note that since 'm_pGpuTime' is in cached memory, we don't bother
        // to invoke BusyLoop here:

        while (pDevice->IsTimePending(spinTime))
        {
            if (DBG_CHECK(TRUE))
            {
                // Make sure that our gap logic works properly, and that the
                // gap never increases:

                DWORD newerGap = ComputeGap(pDevice, targetFence);
                // ASSERT(newerGap <= gap);
                gap = newerGap;
            }

            DODEADLOCKCHECK();
        }
    }

    // Assert that we did our job properly:

    ASSERT(MakeSpace || !pDevice->IsTimePending(Time));

#if DBG

    g_PushState = PUSH_STATE_NONE;

#endif DBG
}

//------------------------------------------------------------------------------
// MakeRequestedSpace
//
// This does the following:
//
//   - Kicks off what is in the push buffer so far
//   - Ensures that there is enough space to write the allocation
//   - Writes a marker indicating that we've started a new section
//
// RequestedSpace is the size (in bytes) that is requested, but it's okay
// to return a smaller allocation so long as it's as big as MinimumSpace.

PPUSH MakeRequestedSpace(
    DWORD MinimumSpace, 
    DWORD RequestedSpace) 
{
    CDevice* pDevice = g_pDevice;

    ASSERT(MinimumSpace <= RequestedSpace);

    // For best performance, 'RequestedSpace' should equal the standard
    // kick-off size.  But we allow larger requests.

    ASSERT(RequestedSpace >= pDevice->m_PushSegmentSize);

    // No single request can be larger than half the push-buffer size
    // (because we assume that when we've waited for half the push-buffer
    // to empty that there will always be enough room for the 
    // MakeRequestedSpace request).

    ASSERT(RequestedSpace <= pDevice->m_PushBufferSize / 2);

    if (pDevice->m_StateFlags & STATE_RECORDPUSHBUFFER)
    {
        // Uh oh, we're recording and we just overran the end of the caller's
        // buffer.  Mark the fact that this push-buffer is now messed up
        // (and at the same time remember how much memory will be needed
        // by the final result):

        pDevice->m_PushBufferRecordWrapSize
            += (DWORD) pDevice->m_Pusher.m_pPut 
             - pDevice->m_pPushBufferRecordResource->Data;

        // Since we've just declared the push-buffer officially screwed,
        // give us some place to write the new data by resetting the
        // pointer back to the beginning of the buffer:

        pDevice->m_Pusher.m_pPut 
            = (PPUSH) pDevice->m_pPushBufferRecordResource->Data;

        return pDevice->m_Pusher.m_pPut;
    }

    PPUSH pStart = pDevice->m_Pusher.m_pPut;
    PPUSH pEnd = (PPUSH) ((DWORD) pStart + RequestedSpace);

    DWORD gpuTime = pDevice->GpuTime();
    PPUSH pGet = pDevice->GpuGet();

    // Check to see if we're 'close' to the buffer end:

    if ((DWORD) pEnd + (DEFAULT_PUSH_BUFFER_SEGMENT_SIZE / 2)
                                        >= (DWORD) pDevice->m_pPushLimit)
    {
        if ((DWORD) pStart + MinimumSpace <= (DWORD) pDevice->m_pPushLimit)
        {
            // We're close to the end of the buffer, and there's enough
            // room for the minimum requested amount, so just give
            // the rest of it away:

            pEnd = pDevice->m_pPushLimit;
        }
        else
        {
            // Darn, there's not enough room to satisfy the minimum amount
            // we need.  We have to wrap to the beginning of the push-buffer.

            COUNT_PERF(PERF_PUSHBUFFER_JUMPTOBEGINNING);

            // Remember how far we got:

            pDevice->m_PusherLastSize = (DWORD) pDevice->m_Pusher.m_pPut 
                                      - (DWORD) pDevice->m_pPushBase;

            // Insert a jump at the current location.  This is always
            // legal because we reserve an extra DWORD at the end of
            // each segment.

            *pDevice->m_Pusher.m_pPut 
                = PUSHER_JUMP(GetGPUAddressFromWC((void*) pDevice->m_pPushBase));

            ASSERT(pDevice->m_Pusher.m_pPut < pDevice->m_pPushLimit);

            // If the requested size is bigger than the normal segment size,
            // we may get a case where the GPU is still reading the end of
            // the push-buffer from the previous pass.  Simply treat this
            // as if the push-buffer has advanced to reading the start, and
            // our logic below will correctly handle this case:

            if (pGet > pDevice->m_Pusher.m_pPut)
            {
                pGet = pDevice->m_pPushBase + 1;
            }

            // This apparently demented check is to handle the wrap case 
            // where the GPU is a full push-buffer behind, and is just now 
            // processing the JUMP to the start of the push-buffer, at the
            // same time we've just completed another whole pass of the
            // push-buffer.  This special case exists because the 
            // "((pStart < pGet) && (pGet <= pEnd))" check below should
            // really have pGet = pPushLimit if pGet == pPushBase.

            if (pGet == pDevice->m_pPushBase)
            {
                pGet = pDevice->m_pPushBase + 1;
            }

        #if PROFILE

            // Record the number of bytes at the end we just skipped:

            g_PerfCounters.m_PushBufferEndDwordsSkipped 
                += pDevice->m_pPushLimit - pDevice->m_Pusher.m_pPut;

        #endif

            // Reset back to the beginning:

            pStart = pDevice->m_pPushBase;
            pEnd = (PPUSH) ((DWORD) pStart + RequestedSpace);

            pDevice->m_Pusher.m_pPut = pStart;
        }
    }

    // Check to see if the GPU is still reading from the range we want to
    // use.
    //
    // Note that the GPU is completely caught-up if pStart == pGet:

    if ((pStart < pGet) && (pGet <= pEnd))
    {
        COUNT_PERFCYCLES(PERF_PUSHBUFFER_WAITS);
        COUNT_PERFEVENT(D3DPERFEvent_PushBufferWait, FALSE);

        PPUSH pSegment;
        DWORD blockTime;

        // Yep, the GPU's backed up and there's no room in the push-buffer 
        // for the new request.  We want to wait on a fence that is
        // approximately half way around the push-buffer (or newer).

        PPUSH pTarget 
            = (PPUSH) ((DWORD) pStart + (pDevice->m_PushBufferSize / 2));

        // Scan through the segment list.
        //
        // Note that we have to actually scan through the list - we can't
        // simply jump to an index half way around, because unfortunately
        // segments aren't guaranteed to be at regular points, because
        // of the Begin/End fence limitation imposed by the hardware.  (We
        // could do a binary search, though.)
        //
        // Proceed from the newest to the oldest, looking for the last 
        // segment newer than our target segment.  We have to have something
        // newer than half way around to ensure that there's enough room to
        // succeed our call:

        // [andrewso] If we get here then we know that the CPU has caught up
        // to the GPU.  The goal of this loop is to fine the first safe
        // time at which we can block to ensure that half of the push buffer
        // has been emptied before we continue.  But there can be a case where
        // the GPU slows down as the CPU is pushing a huge-o-mungo begin/end
        // dataset into the push buffer in which case there may be stale
        // entries in the segment table.  We do not want to block on these
        // stale entries!
        //
        // The solution is to block on the very next fence after the target
        // that has not been crossed by the GPU when this loop first starts.
        // If it has been crossed then we can't be sure if it's a stale 
        // entry of a valid one...we need to play it safe.
        
        DWORD i = pDevice->m_PusherLastSegment;

        do {
            blockTime = pDevice->m_PusherSegment[i].Time;

            // Look at the next, older segment:

            i = (i - 1) & pDevice->m_PusherSegmentMask;

            pSegment = (PPUSH) pDevice->m_PusherSegment[i].pEncoding;
            
            // Any segment with a value less than the current 'put' location 
            // is actually newer than any segment with a value more than the
            // current 'put'.  So to make the time comparison valid, bias
            // any values less than 'pStart':
    
            if (pSegment < pStart)
            {
                pSegment = (PPUSH) ((DWORD) pSegment + pDevice->m_PusherLastSize);
            }

            // Keep looping while the current segment is newer than our target
            // (larger values are newer), or we run off the end of the list:

        } while ((pSegment > pTarget) && (i != pDevice->m_PusherLastSegment) && pDevice->m_PusherSegment[i].Time > gpuTime);

        // If the caller is doing space requests (via RunPushBuffer or 
        // BeginPush) that are close to the size of the total push-buffer, 
        // we may be unable to find a single fence newer than the requested 
        // position on which to wait.  We simply break in that case:

        if (DBG_CHECK(pSegment < pStart))
        {
            DPF_ERR("Space request is too big - can't find a fence to block on.\n"
                    "Consider expanding push-buffer using SetPushBufferSize");
        }

        BlockOnTime(blockTime, TRUE);

        // Make sure our logic worked, and the GPU is no longer in the range
        // where we want to write:

        ASSERT((pGet = pDevice->GpuGet(), !((pStart < pGet) && (pGet <= pEnd))));
    }

    // Set the new threshold, which is the start of the next marker, minus
    // the threshold value plus a little.  This guarantees enough room at
    // the end of a segment for a jump and marker, if needed, and also
    // makes sure that a single allocation can't take us up to or past the
    // end of the segment.

    pDevice->m_Pusher.m_pThreshold = pEnd - PUSHER_THRESHOLD_SIZE_PLUS_OVERHEAD;

#if DBG

    // Quick, let's verify that we can actually use the whole segment by
    // scribbling over everything:

    PPUSH pTmp = pDevice->m_Pusher.m_pThreshold 
                + PUSHER_THRESHOLD_SIZE_PLUS_OVERHEAD - 1;
    DWORD c = 0;

    for (; pTmp >= pDevice->m_Pusher.m_pPut; pTmp--)
    {
        *pTmp = 0x0000BEEF | (c++ << 16);
    }

#endif

    // Mark the new segment if we can:

    if (pDevice->m_StateFlags & STATE_BEGINENDBRACKET)
    {
        pDevice->m_StateFlags |= STATE_SEGMENTFENCEPENDING;
    }
    else
    {
        SetFence(SETFENCE_SEGMENT);
    }

    // Finally, kick off the finished segment:

    pDevice->KickOff();

    return pDevice->m_Pusher.m_pPut;
}

//------------------------------------------------------------------------------
// MakeSpace
//
// This method is called anytime a push buffer allocation would cross
// a threshold boundary.

PPUSH MakeSpace()
{
    // You might think that such a small routine as this should be inlined.
    // But there are a zillion calls to MakeSpace, and pushing the default
    // segment size inline would increase our code size significantly.
    // Calls to MakeSpace are reasonably infrequent, and so do not have to
    // be the ultimate in performance.

    return MakeRequestedSpace(g_pDevice->m_PushSegmentSize / 2, 
                              g_pDevice->m_PushSegmentSize);
}

//------------------------------------------------------------------------------
// XMETAL_StartPushCount

extern "C"
PPUSH WINAPI XMETAL_StartPushCount(
    XMETAL_PushBuffer *pPusher,
    DWORD count)
{
    PPUSH pStart;

    // We currently always pass in 'g_pDevice' as a parameter since the
    // caller almost always has it enregistered already.

    CDevice* pDevice = (CDevice*) pPusher;

    if (DBG_CHECK(TRUE))
    {
        if (pDevice != g_pDevice)
        {
            DXGRIP("XMETAL_StartPushCount - invalid pusher pointer.");
        }

        if (pDevice->m_StateFlags & STATE_RECORDPUSHBUFFER)
        {
            if ((count + 1) * sizeof(DWORD)
                >= pDevice->m_pPushBufferRecordResource->AllocationSize)
            {
                DXGRIP("XMETAL_StartPush - an individual push buffer request "
                     "exceeds the total BeginPushBuffer buffer size.  \n"
                     "We need %li bytes, so we're about to overwrite the end "
                     "of the buffer...",
                     (count + 1) * sizeof(DWORD));
            }
        }
    }

    // We will usually take the early out here:

    if (pDevice->m_Pusher.m_pPut + count
            < pDevice->m_Pusher.m_pThreshold + PUSHER_THRESHOLD_SIZE)
    {
        pStart = pDevice->m_Pusher.m_pPut;
    }
    else
    {
        // Assume the default values first:

        DWORD maximumSpace = pDevice->m_PushSegmentSize;
        DWORD minimumSpace = pDevice->m_PushSegmentSize / 2;

        DWORD neededSpace = (count + PUSHER_THRESHOLD_SIZE + 1) * sizeof(DWORD);
        if (neededSpace > minimumSpace)
        {
            minimumSpace = neededSpace;
        }
        if (neededSpace > maximumSpace)
        {
            maximumSpace = neededSpace;
        }

        pStart = MakeRequestedSpace(minimumSpace, maximumSpace);

        ASSERT(pDevice->m_Pusher.m_pPut + count
                < pDevice->m_Pusher.m_pThreshold + PUSHER_THRESHOLD_SIZE);
    }

    DbgRecordPushStart(count);

    return pStart;
}

//------------------------------------------------------------------------------
// KickOff
//
// Update hardware's 'put' pointer to let it start chewing on the recent
// push buffer data:

void CDevice::KickOff()
{
    if (!(m_StateFlags & STATE_NULLHARDWARE))
    {
        COUNT_PERFEVENT(D3DPERFEvent_Kickoff, FALSE);
    
        // We still let KickOffs go through even while recording push-
        // buffers:
    
        PPUSH pPut = (m_StateFlags & STATE_RECORDPUSHBUFFER)
                    ? m_pPushBufferRecordSavedPut
                    : m_Pusher.m_pPut;
    
        // You can't call 'KickOff' while you've got an active PushStart or
        // BufferStart!
    
        ASSERT(g_PushState != PUSH_STATE_START);
        ASSERT((m_Pusher.m_pPut < m_pPushLimit) ||
               (m_StateFlags & STATE_RECORDPUSHBUFFER ));
    
        FlushWCCache();
    
        // Let the hardware know:
    
        HwPut(pPut);
    
        // Remember the push-buffer location:
    
        m_pKickOff = pPut;

        if (D3D__NullHardware)
        {
            // Wait for the hardware to go idle, then commandeer the 
            // hardware's get/put structure to point to normal system
            // memory (so that we can overwrite the 'get' and 'put'
            // registers):

            while (D3DDevice_IsBusy())
                ;

            m_StateFlags |= STATE_NULLHARDWARE;
        }
    }
    else
    {
        // Pretend that we sent the push-buffer to the hardware and it has
        // instantly processed everything:

        m_pControlDma = (Nv20ControlDma*) 
            ((BYTE*) g_NullHardwareGetPut - offsetof(Nv20ControlDma, Put));

        DWORD getPut = GetGPUAddress((void*) m_Pusher.m_pPut);

        m_pControlDma->Put = getPut;
        m_pControlDma->Get = getPut;

        *m_pGpuTime = m_CpuTime - (1 << PUSHER_TIME_SHIFT);

        m_Miniport.m_VBlankFlipCount = m_SwapCount;

        m_Miniport.m_PusherGetRunTotal = m_PusherPutRunTotal;
    }
}

//------------------------------------------------------------------------------
// KickOffAndWaitForIdle
//
// Waits until the GPU has emptied the push buffer and finished all processing.

void KickOffAndWaitForIdle()
{
    CDevice* pDevice = g_pDevice;

    BlockOnTime(pDevice->m_CpuTime, FALSE);

    ASSERT(pDevice->m_Miniport.m_PusherGetRunTotal == pDevice->m_PusherPutRunTotal);

    // The status register sometimes slightly lags the semaphore write-back, so 
    // unfortunately we can't always do this assertion:
    //
    //      ASSERT(!D3DDevice_IsBusy());
}

//------------------------------------------------------------------------------
// Block until a resource is no longer used by the GPU.
//
// Unlike the faster BlockOnNonSurfaceResource, this works for any type of 
// resource.

VOID BlockOnResource(
    D3DResource *pResource)
{
    COUNT_PERFCYCLES(PERF_OBJECTLOCK_WAITS);
    COUNT_PERFEVENT(D3DPERFEvent_ObjectLockWait, FALSE);

    // Handle the case where a resource Release occurs after the device is
    // released.

    if (g_pDevice == NULL)
        return;

    D3DResource *pParent = PixelJar::GetParent(pResource);

    if (pParent)
    {
        if (IsResourceSetInDevice(pResource))
        {
            KickOffAndWaitForIdle();
            return;
        }

        pResource = pParent;
    }

    DWORD ResourceTime = pResource->Lock;

    if (DBG_CHECK((ResourceTime != 0) && !(ResourceTime & PUSHER_TIME_VALID_FLAG)))
    {
        DXGRIP("Resource has an invalid 'Lock' field.  Uninitialized?");
    }

    // If the object is currently selected then wait for the GPU to idle.

    if (IsResourceSetInDevice(pResource))
    {
        KickOffAndWaitForIdle();
    }
    else
    {
        // If the time is zero, the resource hasn't been used yet (note that 
        // we permit titles to hit this case even while a different thread 
        // is busy rendering):

        if (ResourceTime != 0)
        {
            BlockOnTime(ResourceTime, FALSE);
        }
    }
}

//------------------------------------------------------------------------------
// Faster version of 'BlockOnResource', for non-surfaces only.

VOID BlockOnNonSurfaceResource(
    D3DResource *pResource)
{
    ASSERT((pResource->Common & D3DCOMMON_TYPE_MASK) != D3DCOMMON_TYPE_SURFACE);

    COUNT_PERFCYCLES(PERF_OBJECTLOCK_WAITS);
    COUNT_PERFEVENT(D3DPERFEvent_ObjectLockWait, FALSE);

    // Handle the case where a resource Release occurs after the device is
    // released.

    if (g_pDevice == NULL)
        return;

    DWORD ResourceTime = pResource->Lock;

    if (DBG_CHECK((ResourceTime != 0) && !(ResourceTime & PUSHER_TIME_VALID_FLAG)))
    {
        DXGRIP("Resource has an invalid 'Lock' field.  Uninitialized?");
    }

    // If the object is currently selected then wait for the GPU to idle.

    if (IsNonSurfaceResourceSetInDevice(pResource))
    {
        KickOffAndWaitForIdle();
    }
    else
    {
        // If the time is zero, the resource hasn't been used yet (note that 
        // we permit titles to hit this case even while a different thread 
        // is busy rendering):

        if (ResourceTime != 0)
        {
            BlockOnTime(ResourceTime, FALSE);
        }
    }
}

//------------------------------------------------------------------------------

#ifndef ALIASPUSHER

VOID FlushWCCache()
{
    BYTE* RegisterBase = (BYTE*)g_pDevice->m_Miniport.m_RegisterBase;

    // Flush the write-combine cache:

    _asm sfence;

    // Wait for the ol' chip to sync.
    
    FLD_WR_DRF_DEF(RegisterBase, _PFB, _WBC, _FLUSH, _PENDING);

    while (REG_RD_DRF(RegisterBase, _PFB, _WBC, _FLUSH))
        ;
}

#endif

//------------------------------------------------------------------------------
// Return whether a fence has been crossed yet or not.

extern "C"
BOOL WINAPI D3DDevice_IsFencePending(
    DWORD Fence)
{
    COUNT_API(API_D3DDEVICE_ISFENCEPENDING);

    CDevice *pDevice = g_pDevice;

    return pDevice->IsTimePending(Fence);
}

//------------------------------------------------------------------------------
// Insert a callback fence into the push buffer.

extern "C"
VOID WINAPI D3DDevice_InsertCallback(
    D3DCALLBACKTYPE Type,
    D3DCALLBACK pCallback,
    DWORD Context)
{
    COUNT_API(API_D3DDEVICE_INSERTCALLBACK);

    if (DBG_CHECK(TRUE))
    {
        if (!pCallback)
        {
            DXGRIP("D3DDevice_InsertCallback - Callback pointer.");
        }

        if (Type > D3DCALLBACK_WRITE)
        {
            DXGRIP("D3DDevice_InsertCallback - Invalid callback type.");
        }
    }

    CDevice *pDevice = g_pDevice;

    PPUSH pPush = pDevice->StartPush();

    // The callback context is stored in COLOR_CLEAR_VALUE.

    Push2(pPush, NV097_SET_ZSTENCIL_CLEAR_VALUE, 

          // NVX_READ_CALLBACK Data stored in NV097_SET_ZSTENCIL_CLEAR_VALUE

          (DWORD) pCallback, 

          // NVX_READ_CALLBACK Context stored in NV097_SET_COLOR_CLEAR_VALUE

          Context);

    // Push the software method with the callback value.

    if (Type == D3DCALLBACK_READ)
    {
        Push1(pPush + 3, NV097_NO_OPERATION, NVX_READ_CALLBACK);

        pDevice->EndPush(pPush + 5);
    }
    else
    {
        Push1(pPush + 3, NV097_WAIT_FOR_IDLE, 0);

        Push1(pPush + 5, NV097_NO_OPERATION, NVX_WRITE_CALLBACK);

        pDevice->EndPush(pPush + 7);
    }
}

//------------------------------------------------------------------------------
// External API for taking control of the push-buffer

#if DBG
    PPUSH g_pEndPush;
#endif

extern "C"
VOID WINAPI D3DDevice_BeginPush(
    DWORD Count,
    DWORD **ppPush)
{
    COUNT_API(API_D3DDEVICE_BEGINPUSH);

    CDevice* pDevice = g_pDevice;

    if (DBG_CHECK(TRUE))
    {
        if (ppPush == NULL)
        {
            DPF_ERR("NULL ppPush parameter");
        }
    }

    pDevice->SetStateVB(0);

    if (DBG_CHECK(TRUE))
    {
        // warn if vertex shader inputs remapped via TEXCOORDINDEX
        BYTE* pSlotMapping 
          = &g_SlotMapping[pDevice->m_pVertexShader->Flags & VERTEXSHADER_PROGRAM];

        for(UINT i=SLOT_TEXTURE0; i<=SLOT_TEXTURE3; i++)
        {
            if((pDevice->m_pVertexShader->Slot[pSlotMapping[i]].SizeAndType != 
                SIZEANDTYPE_DISABLED) && (pSlotMapping[i] != i))
            {
                char buf[256];
                sprintf(buf, "Texture stage %d is mapped to texture coordinate %d via "
                             "TEXCOORDINDEX.  BeginPush requires no remapping.\n",
                             i, pSlotMapping[i]);
                DPF_ERR(buf);
            }
        }
    }



    // Do a "+ 1" to save space for 0x0badbeef:

    PPUSH pPush = pDevice->StartPush(Count + 1);

#if DBG
    if (g_pEndPush != NULL)
    {
        DPF_ERR("Previous BeginPush never had an EndPush");
    }
    g_pEndPush = pPush + Count;
    *g_pEndPush = 0x0badbeef;
#endif

    *ppPush = (DWORD*) pPush;
}

//------------------------------------------------------------------------------
// Restore control of the push-buffer to D3D

extern "C"
VOID WINAPI D3DDevice_EndPush(
    DWORD *p)
{
    COUNT_API(API_D3DDEVICE_ENDPUSH);

    PPUSH pPush = (PPUSH) p;

    CDevice* pDevice = g_pDevice;

#if DBG
    if (g_pEndPush == NULL)
    {
        DPF_ERR("EndPush without having first done a BeginPush");
    }
    if (*g_pEndPush != 0x0badbeef)
    {
        DPF_ERR("End of buffer overwritten (more data written than specified to BeginPush)");
    }
    if ((pPush < pDevice->m_Pusher.m_pPut) || (pPush > g_pEndPush))
    {
        DPF_ERR("pPush parameter not within BeginPush range");
    }
    g_pEndPush = NULL;
#endif

    PushedRaw(pPush);

    pDevice->EndPush(pPush);
}

//------------------------------------------------------------------------------
// DumpMatrixTransposed

VOID DumpMatrixTransposed(
    PPUSH pPush,
    DWORD encodedMethod,
    CONST D3DMATRIX* pMatrix)
{
    *(pPush) = encodedMethod;

    *(pPush + 1) = *((DWORD*) &pMatrix->_11);
    *(pPush + 2) = *((DWORD*) &pMatrix->_21);
    *(pPush + 3) = *((DWORD*) &pMatrix->_31);
    *(pPush + 4) = *((DWORD*) &pMatrix->_41);
    *(pPush + 5) = *((DWORD*) &pMatrix->_12);
    *(pPush + 6) = *((DWORD*) &pMatrix->_22);
    *(pPush + 7) = *((DWORD*) &pMatrix->_32);
    *(pPush + 8) = *((DWORD*) &pMatrix->_42);
    *(pPush + 9) = *((DWORD*) &pMatrix->_13);
    *(pPush + 10) = *((DWORD*) &pMatrix->_23);
    *(pPush + 11) = *((DWORD*) &pMatrix->_33);
    *(pPush + 12) = *((DWORD*) &pMatrix->_43);
    *(pPush + 13) = *((DWORD*) &pMatrix->_14);
    *(pPush + 14) = *((DWORD*) &pMatrix->_24);
    *(pPush + 15) = *((DWORD*) &pMatrix->_34);
    *(pPush + 16) = *((DWORD*) &pMatrix->_44);
}

////////////////////////////////////////////////////////////////////////////////

#if DBG

//------------------------------------------------------------------------------
// CDevice::EndPush - debug

extern "C"
void WINAPI XMETAL_EndPush(
    XMETAL_PushBuffer *pPusher,
    PPUSH pPush)
{
    if (DBG_CHECK((void *)pPusher != (void *)g_pDevice))
    {
        DXGRIP("XMETAL_EndPush - invalid pusher pointer.");
    }

    CDevice *pDevice = g_pDevice;

    // Make sure we were paired with a StartPush call:

    if (g_PushState != PUSH_STATE_START)
    {
        DXGRIP("Pusher - End push is not paired with a start push, probably due to an earlier error.");
    }

    g_PushState = PUSH_STATE_NONE;

    // Make sure we ended where expected:

    ASSERTMSG(pPush == pPusher->m_pPut + g_PushIndex,
              "Bad EndPush: Expected %lx, got %lx.  g_PushIndex: %li",
                    pPusher->m_pPut + g_PushIndex, pPush, g_PushIndex);
    ASSERT((pPusher->m_pPut < pDevice->m_pPushLimit) ||
           (pDevice->m_StateFlags & STATE_RECORDPUSHBUFFER ));

    // This is the only work the retail version of this routine does:

    pPusher->m_pPut = pPush;

    // Do a single step.

    if (D3D__SingleStepPusher)
    {           
        // We can't do a KickOffAndWaitForIdle here anymore because
        // that now inserts a semaphore and a bunch of other Kelvin
        // goop that can't be done while in a Begin/End bracket.

        pDevice->KickOff();

        // Wait for the pusher to empty.

        INITDEADLOCKCHECK();

        while (D3DDevice_IsBusy())
        {
            BusyLoop();

            DODEADLOCKCHECK();
        }
    }

    // Parse the push buffer on debug builds to record the current register
    // state:

    PARSE_PUSH_BUFFER();
}

//------------------------------------------------------------------------------
// PushedRaw - Call this to advance the push pointer after having copied
//             raw data into the pusher buffer

VOID PushedRaw(
    PPUSH pPushNext)
{
    g_PushIndex += (pPushNext - g_pPushNext);
    g_pPushNext = pPushNext;

    // Make sure we're in the middle of a Start/End bracket:

    ASSERT(g_PushState == PUSH_STATE_START);

    // Make sure we didn't write past the end of our guaranteed space:

    ASSERT(g_PushIndex <= g_ReservedSize);
}

//------------------------------------------------------------------------------
// Push1 - debug

VOID Push1(
    PPUSH pPush,
    SubChannel subch,
    DWORD method,
    DWORD value)
{
    // Make sure we didn't leave a gap in the push buffer:

    ASSERT(pPush == g_pPushNext);

    // Make sure we're in the middle of a Start/End bracket:

    ASSERT(g_PushState == PUSH_STATE_START);

    pPush[0] = PUSHER_METHOD(subch, method, 1);
    pPush[1] = value;

    // Account for the two dwords just written:

    g_PushIndex += 2;
    g_pPushNext += 2;

    // Make sure we didn't write past the end of our guaranteed space:

    ASSERT(g_PushIndex <= g_ReservedSize);
}

//------------------------------------------------------------------------------
// Push2 - debug

VOID Push2(
    PPUSH pPush,
    SubChannel subch,
    DWORD method,
    DWORD a,
    DWORD b)
{
    ASSERT(pPush == g_pPushNext);
    ASSERT(g_PushState == PUSH_STATE_START);

    pPush[0] = PUSHER_METHOD(subch, method, 2);
    pPush[1] = a;
    pPush[2] = b;

    g_PushIndex += 3;
    g_pPushNext += 3;

    ASSERT(g_PushIndex <= g_ReservedSize);
}

//------------------------------------------------------------------------------
// Push3 - debug

VOID Push3(
    PPUSH pPush,
    SubChannel subch,
    DWORD method,
    DWORD a,
    DWORD b,
    DWORD c)
{
    ASSERT(pPush == g_pPushNext);
    ASSERT(g_PushState == PUSH_STATE_START);

    pPush[0] = PUSHER_METHOD(subch, method, 3);
    pPush[1] = a;
    pPush[2] = b;
    pPush[3] = c;

    g_PushIndex += 4;
    g_pPushNext += 4;

    ASSERT(g_PushIndex <= g_ReservedSize);
}

//------------------------------------------------------------------------------
// Push4 - debug

VOID Push4(
    PPUSH pPush,
    SubChannel subch,
    DWORD method,
    DWORD a,
    DWORD b,
    DWORD c,
    DWORD d)
{
    ASSERT(pPush == g_pPushNext);
    ASSERT(g_PushState == PUSH_STATE_START);

    pPush[0] = PUSHER_METHOD(subch, method, 4);
    pPush[1] = a;
    pPush[2] = b;
    pPush[3] = c;
    pPush[4] = d;

    g_PushIndex += 5;
    g_pPushNext += 5;

    ASSERT(g_PushIndex <= g_ReservedSize);
}

//------------------------------------------------------------------------------
// Push1f - debug

VOID Push1f(
    PPUSH pPush,
    SubChannel subch,
    DWORD method,
    FLOAT value)
{
    ASSERT(pPush == g_pPushNext);
    ASSERT(g_PushState == PUSH_STATE_START);

    pPush[0] = PUSHER_METHOD(subch, method, 1);
    ((FLOAT*) pPush)[1] = value;

    g_PushIndex += 2;
    g_pPushNext += 2;

    ASSERT(g_PushIndex <= g_ReservedSize);
}

//------------------------------------------------------------------------------
// Push2f - debug

VOID Push2f(
    PPUSH pPush,
    SubChannel subch,
    DWORD method,
    FLOAT a,
    FLOAT b)
{
    ASSERT(pPush == g_pPushNext);
    ASSERT(g_PushState == PUSH_STATE_START);

    pPush[0] = PUSHER_METHOD(subch, method, 2);
    ((FLOAT*) pPush)[1] = a;
    ((FLOAT*) pPush)[2] = b;

    g_PushIndex += 3;
    g_pPushNext += 3;

    ASSERT(g_PushIndex <= g_ReservedSize);
}

//------------------------------------------------------------------------------
// Push3f - debug

VOID Push3f(
    PPUSH pPush,
    SubChannel subch,
    DWORD method,
    FLOAT a,
    FLOAT b,
    FLOAT c)
{
    ASSERT(pPush == g_pPushNext);
    ASSERT(g_PushState == PUSH_STATE_START);

    pPush[0] = PUSHER_METHOD(subch, method, 3);
    ((FLOAT*) pPush)[1] = a;
    ((FLOAT*) pPush)[2] = b;
    ((FLOAT*) pPush)[3] = c;

    g_PushIndex += 4;
    g_pPushNext += 4;

    ASSERT(g_PushIndex <= g_ReservedSize);
}

//------------------------------------------------------------------------------
// Push4f - debug

VOID Push4f(
    PPUSH pPush,
    SubChannel subch,
    DWORD method,
    FLOAT a,
    FLOAT b,
    FLOAT c,
    FLOAT d)
{
    ASSERT(pPush == g_pPushNext);
    ASSERT(g_PushState == PUSH_STATE_START);

    pPush[0] = PUSHER_METHOD(subch, method, 4);
    ((FLOAT*) pPush)[1] = a;
    ((FLOAT*) pPush)[2] = b;
    ((FLOAT*) pPush)[3] = c;
    ((FLOAT*) pPush)[4] = d;

    g_PushIndex += 5;
    g_pPushNext += 5;

    ASSERT(g_PushIndex <= g_ReservedSize);
}

//------------------------------------------------------------------------------
// PushCount - debug

VOID PushCount(
    PPUSH pPush,
    SubChannel subch,
    DWORD method,
    DWORD count)
{
    ASSERT(pPush == g_pPushNext);
    ASSERT(g_PushState == PUSH_STATE_START);

    pPush[0] = PUSHER_METHOD(subch, method, count);

    g_PushIndex += count + 1;
    g_pPushNext += count + 1;

    ASSERT(g_PushIndex <= g_ReservedSize);
}

//------------------------------------------------------------------------------
// PushMatrixTransposed - debug

VOID PushMatrixTransposed(
    PPUSH pPush,
    DWORD method,
    CONST D3DMATRIX* pMatrix)
{
    ASSERT(pPush == g_pPushNext);
    ASSERT(g_PushState == PUSH_STATE_START);

    DumpMatrixTransposed(pPush, PUSHER_METHOD(SUBCH_3D, method, 16), pMatrix);

    g_PushIndex += 17;
    g_pPushNext += 17;

    ASSERT(g_PushIndex <= g_ReservedSize);
}

//------------------------------------------------------------------------------
// PushInverseModelViewMatrix - debug

VOID PushInverseModelViewMatrix(
    PPUSH pPush,
    DWORD method,
    CONST D3DMATRIX* pMatrix)
{
    ASSERT(pPush == g_pPushNext);
    ASSERT(g_PushState == PUSH_STATE_START);

    *pPush = PUSHER_METHOD(SUBCH_3D, method, 12);
    memcpy((void*) (pPush + 1), pMatrix, 12 * sizeof(float));

    g_PushIndex += 13;
    g_pPushNext += 13;

    ASSERT(g_PushIndex <= g_ReservedSize);
}

//------------------------------------------------------------------------------
// PushMatrix - debug

VOID PushMatrix(
    PPUSH pPush,
    DWORD method,
    FLOAT m11, FLOAT m12, FLOAT m13, FLOAT m14,
    FLOAT m21, FLOAT m22, FLOAT m23, FLOAT m24,
    FLOAT m31, FLOAT m32, FLOAT m33, FLOAT m34,
    FLOAT m41, FLOAT m42, FLOAT m43, FLOAT m44)
{
    ASSERT(pPush == g_pPushNext);
    ASSERT(g_PushState == PUSH_STATE_START);

    *pPush = PUSHER_METHOD(SUBCH_3D, method, 16);
    *((FLOAT*) pPush + 1) = m11;
    *((FLOAT*) pPush + 2) = m12;
    *((FLOAT*) pPush + 3) = m13;
    *((FLOAT*) pPush + 4) = m14;
    *((FLOAT*) pPush + 5) = m21;
    *((FLOAT*) pPush + 6) = m22;
    *((FLOAT*) pPush + 7) = m23;
    *((FLOAT*) pPush + 8) = m24;
    *((FLOAT*) pPush + 9) = m31;
    *((FLOAT*) pPush + 10) = m32;
    *((FLOAT*) pPush + 11) = m33;
    *((FLOAT*) pPush + 12) = m34;
    *((FLOAT*) pPush + 13) = m41;
    *((FLOAT*) pPush + 14) = m42;
    *((FLOAT*) pPush + 15) = m43;
    *((FLOAT*) pPush + 16) = m44;

    g_PushIndex += 17;
    g_pPushNext += 17;

    ASSERT(g_PushIndex <= g_ReservedSize);
}

//------------------------------------------------------------------------------
// The debug XMETAL pusher routines just defer to the subchanneled routines.

extern "C"
VOID WINAPI XMETAL_PushedRaw(PPUSH pPushNext)
{
    PushedRaw(pPushNext);
}

extern "C"
VOID WINAPI XMETAL_Push1(PPUSH pPush, DWORD method, DWORD value)
{
    Push1(pPush, SUBCH_3D, method, value);
}

extern "C"
VOID WINAPI XMETAL_Push2(PPUSH pPush, DWORD method, DWORD a, DWORD b)
{
    Push2(pPush, SUBCH_3D, method, a, b);
}

extern "C"
VOID WINAPI XMETAL_Push3(PPUSH pPush, DWORD method, DWORD a, DWORD b, DWORD c)
{
    Push3(pPush, SUBCH_3D, method, a, b, c);
}

extern "C"
VOID WINAPI XMETAL_Push4(PPUSH pPush, DWORD method, DWORD a, DWORD b, DWORD c, DWORD d)
{
    Push4(pPush, SUBCH_3D, method, a, b, c, d);
}

extern "C"
VOID WINAPI XMETAL_Push1f(PPUSH pPush, DWORD method, FLOAT value)
{
    Push1f(pPush, SUBCH_3D, method, value);
}

extern "C"
VOID WINAPI XMETAL_Push2f(PPUSH pPush, DWORD method, FLOAT a, FLOAT b)
{
    Push2f(pPush, SUBCH_3D, method, a, b);
}

extern "C"
VOID WINAPI XMETAL_Push3f(PPUSH pPush, DWORD method, FLOAT a, FLOAT b, FLOAT c)
{
    Push3f(pPush, SUBCH_3D, method, a, b, c);
}

extern "C"
VOID WINAPI XMETAL_Push4f(PPUSH pPush, DWORD method, FLOAT a, FLOAT b, FLOAT c, FLOAT d)
{
    Push4f(pPush, SUBCH_3D, method, a, b, c, d);
}

extern "C"
VOID WINAPI XMETAL_PushCount(PPUSH pPush, DWORD method, DWORD count)
{
    PushCount(pPush, SUBCH_3D, method, count);
}

#endif // DBG

} // end of namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\pushres.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       pushres.cpp
 *  Content:    Contains all functionality for handling push-buffer resources.
 *
 ***************************************************************************/
 
#include "precomp.hpp"

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

// We reserve 4 bytes of the push-buffer buffer for putting the JUMP
// instruction to jump back to the main push-buffer:

#define PUSHBUFFER_RETURN_RESERVE 4

// We use this flag with the Common field of a fix-up object on debug
// builds to mark when we're a Begin/End bracket:

#define D3DFIXUP_COMMON_IN_BEGIN_END 0x80000000

//------------------------------------------------------------------------------
// RunPushBufferParameterCheck

VOID RunPushBufferParameterCheck(
    D3DPushBuffer* pPushBuffer,
    D3DFixup* pFixup) // Can be NULL
{
    if (pPushBuffer->Size == 0)
    {
        DPF_ERR("Zero push-buffer 'Size' (maybe failed recording?)");
    }
    if (pPushBuffer->Size & 3)
    {
        DPF_ERR("Push-buffer 'Size' not a dword multiple");
    }
    if (pFixup != NULL)
    {
        CHECK(pFixup, "D3DDevice_RunPushBuffer");
        if (pFixup->Common & D3DFIXUP_COMMON_IN_BEGIN_END)
        {
            DPF_ERR("Can't RunPushBuffer with a Fixup object that is "
                    "in the middle of a begin/end bracket");
        }
        if (pFixup->Next > pFixup->Size)
        {
            DPF_ERR("The last fix-up overflowed the Fixup object");
        }
        DWORD* pFix = (DWORD*) (pFixup->Data + pFixup->Run);
        if (*pFix == 0xffffffff)
        {
            // Our 'firstModify' calculation depends on this:

            DPF_ERR("Can't have empty fix-up buffers");
        }

        DWORD previousOffset = 0;
        while (*pFix != 0xffffffff)
        {
            DWORD size = *(pFix);
            DWORD offset = *(pFix + 1);

            if (size >= pPushBuffer->Size)
            {
                DPF_ERR("Size in 'Fixup' larger than push-buffer size");
            }
            if (offset & 3)
            {
                DPF_ERR("Non-dword-aligned offset in 'Fixup'");
            }
            if (size & 3)
            {
                DPF_ERR("Non-dword-multiple size in 'Fixup'");
            }
            if (offset >= pPushBuffer->Size)
            {
                DPF_ERR("Offset in 'Fixup' larger than push buffer size");
            }
            if (offset < previousOffset)
            {
                DPF_ERR("Not in order of increasing offsets");
            }

            previousOffset = offset;
            pFix = (DWORD*) ((BYTE*) pFix + size + 8);
        }
    }

    if (!(pPushBuffer->Common & D3DPUSHBUFFER_RUN_USING_CPU_COPY))
    {
        AssertContiguous((VOID*) pPushBuffer->Data);
        AssertWriteCombined((VOID*) pPushBuffer->Data);
    }
    else
    {
        if (pFixup != NULL)
        {
            DPF_ERR("D3DPUSHBUFFER_RUN_USING_CPU_COPY push-buffers can't "
                    "take a fixup object (apply the fixups directly)");
        }
    }
}

//------------------------------------------------------------------------------
// D3DDevice_RunPushBuffer

extern "C"
VOID WINAPI D3DDevice_RunPushBuffer(
    D3DPushBuffer* pPushBuffer,
    D3DFixup* pFixup) // Can be NULL
{
#if PROFILE

    COUNT_API(API_D3DDEVICE_RUNPUSHBUFFER);
    ___D3DPERFEVENT _PerfEvent(D3DPERFEvent_RunPushBuffer, TRUE);

    // Store size of the pushbuffer instead of the space taken in pushbuffer
    if(_PerfEvent.m_pD3DPerfEvent)
        _PerfEvent.m_pD3DPerfEvent->Data = pPushBuffer->Size;

#endif

    // Note: we can get the size of this push buffer, but if other push-buffers
    // are called from this one we don't account for those.

    COUNT_ADD_PERF(PERF_RUNPUSHBUFFER_BYTES, pPushBuffer->Size);
    CHECK(pPushBuffer, "D3DDevice_RunPushBuffer");

    CDevice* pDevice = g_pDevice;

    if (DBG_CHECK(TRUE))
    {
        RunPushBufferParameterCheck(pPushBuffer, pFixup);
    }

#if DBG

    // We disable the debug-only SetDmaRange logic on the first call to
    // RunPushBuffer, because it's too hard to deal with SetRenderTarget
    // fix-ups when there's a context DMA involved.  Calling SetRenderTarget
    // with STATE_RUNPUSHBUFFERWASCALLED set will do this for us:

    if (!(pDevice->m_StateFlags & STATE_RUNPUSHBUFFERWASCALLED) &&
        !(pDevice->m_StateFlags & STATE_RECORDPUSHBUFFER))
    {
        pDevice->m_StateFlags |= STATE_RUNPUSHBUFFERWASCALLED;

        D3DDevice_SetRenderTarget(pDevice->m_pRenderTarget, pDevice->m_pZBuffer);
    }

#endif

    // Make sure that the push-buffer properly inherits any lazy state:

    pDevice->SetStateVB(0);

    // Take radically different code paths depending on whether the memory
    // is write-combined and contiguous, or not:

    if (!(pPushBuffer->Common & D3DPUSHBUFFER_RUN_USING_CPU_COPY))
    {
        DWORD pushbufferSize = pPushBuffer->Size - PUSHBUFFER_RETURN_RESERVE;
        BYTE* pStart = (BYTE*) pPushBuffer->Data;

        // Record the reference to the push-buffer so that it's not deleted
        // or modified before the GPU gets to it:

        pDevice->RecordResourceReadPush(pPushBuffer);

        DWORD* pFixupData = NULL;
        DWORD firstModify = pushbufferSize;
        if (pFixup != NULL)
        {
            pDevice->RecordResourceReadPush(pFixup);

            pFixupData = (DWORD*) (pFixup->Data + pFixup->Run);

            // First DWORD is 'size', second DWORD is 'offset':

            firstModify = pFixupData[1];
        }

        if (!(pDevice->m_StateFlags & STATE_RECORDPUSHBUFFER) && 
            !(pDevice->IsTimePending(pDevice->m_LastRunPushBufferTime)))
        {
            CMiniport::PUSHBUFFERFIXUPINFO fixupInfo;

            // Yahoo, no push-buffer resource is currently in use by the GPU.
            // That means we can apply the fix-ups directly and save us
            // the cost of an interrupt:

            PPUSH pPush = pDevice->StartPush();

            *pPush++ = PUSHER_JUMP(GetGPUAddressFromWC(pStart));

            fixupInfo.pFixupData = pFixupData;
            fixupInfo.pStart = pStart;
            fixupInfo.ReturnOffset = pushbufferSize;
            fixupInfo.ReturnAddress = (DWORD*) pPush;

            pDevice->m_Miniport.FixupPushBuffer(&fixupInfo, NVX_PUSH_BUFFER_RUN);

            PushedRaw(pPush);
            pDevice->EndPush(pPush);
        }
        else
        {
            DWORD method;
            DWORD jump;

            // We use PUSHER_CALL instead of PUSHER_JUMP in some cases in
            // order to have GpuGet() work properly.  A PUSHER_CALL has the
            // nice property that the hardware's FIFO getter will 
            // automatically update the NV_PFIFO_CACHE1_DMA_SUBROUTINE
            // register with the push-buffer address from which it was
            // called.  We use that register to determine where in the main
            // push-buffer we are if the GPU is currently running a called 
            // push-buffer.
            //
            // We can't use the pusher 'return' instruction because that's
            // broken on the NV2A.  So FixupPushBuffer will handle patching
            // the return address instead.
            //
            // We don't use PUSHER_CALL for nested push-buffers, because we
            // only ever want NV_PFIFO_CACHE1_DMA_SUBROUTINE to point to
            // an address in the main push-buffer.  Similarly, we avoid
            // NVX_PUSH_BUFFER_RUN in the case of a nested push-buffer so 
            // that the pusher code doesn't get confused about 
            // m_PusherGetRunTotal.

            if (pDevice->m_StateFlags & STATE_RECORDPUSHBUFFER)
            {
                method = NVX_PUSH_BUFFER_FIXUP;
                jump = PUSHER_JUMP(GetGPUAddressFromWC(pStart));
            }
            else
            {
                method = NVX_PUSH_BUFFER_RUN;                    
                jump = PUSHER_CALL(GetGPUAddressFromWC(pStart)); 
            }

            // Darn, a push-buffer is already in use by the GPU.  That
            // means we'll have to do more work and post an interrupt that
            // will handle the fix-up:

            if (DBG_CHECK(firstModify <= PUSHER_MINIMUM_RUN_OFFSET / 2))
            {
                DPF_ERR("Push-buffer size too small or fixup too close to start\n"
                        "(regenerate push-buffer data and fixups?)");
            }
    
            PPUSH pPush = pDevice->StartPush(); 
    
            // NVX_PUSH_BUFFER_FIXUP_POINTER Data stored in 
            // NV097_SET_ZSTENCIL_CLEAR_VALUE
    
            Push1(pPush, NV097_SET_ZSTENCIL_CLEAR_VALUE, 
    
                  // Store PushBufferFixupInfo after the pushbuffer jump
    
                  (DWORD)(pPush + 5));
    
            Push1(pPush + 2, NV097_NO_OPERATION, method);
    
            *(pPush + 4) = jump;

            volatile CMiniport::PUSHBUFFERFIXUPINFO* pFixupInfo
                = (CMiniport::PUSHBUFFERFIXUPINFO*) (pPush + 5);

            pPush = (PPUSH) (pFixupInfo + 1);

            pFixupInfo->pFixupData = pFixupData;
            pFixupInfo->pStart = pStart;
            pFixupInfo->ReturnOffset = pushbufferSize;
            pFixupInfo->ReturnAddress = (DWORD*) pPush;
    
            PushedRaw(pPush);
            pDevice->EndPush(pPush);
        }
        
        if (!(pDevice->m_StateFlags & STATE_RECORDPUSHBUFFER))
        {
            // Also remember the time so that we can tell if a RunPushBuffer
            // command is pending with the GPU:

            pDevice->m_LastRunPushBufferTime = pDevice->m_CpuTime;

            // Let the pusher code know the number of bytes called so that it
            // can be smarter about fences around RunPushBuffer calls:

            pDevice->m_PusherPutRunTotal += pushbufferSize;

            // For better resource time granularity with 'large' push-buffers,
            // we insert a fence:
    
            if (pushbufferSize > PUSHER_RUN_FENCE_THRESHOLD)
            {
                SetFence(0);
            }
        }
    }
    else
    {
        DWORD size = pPushBuffer->Size - PUSHBUFFER_RETURN_RESERVE;

        if (DBG_CHECK(TRUE))
        {
            if (size >= pDevice->m_PushBufferSize / 2)
            {
                DPF_ERR("D3DPUSHBUFFER_RUN_USING_CPU_COPY push-bufffers can't "
                        "be bigger than \nhalf of the main push-buffer size as "
                        "set by SetPushBufferSize\n");
            }
        }

        DWORD dwCount = size >> 2;

        PPUSH pPush = pDevice->StartPush(dwCount);

        FastCopyToWC(pPush, (DWORD*) pPushBuffer->Data, dwCount);

        PushedRaw(pPush + dwCount);

        pDevice->EndPush(pPush + dwCount);

        // Note that we don't call RecordResourceReadPush for the copy case.
    }
}

//------------------------------------------------------------------------------
// D3DDevice_CreatePushBuffer

extern "C"
HRESULT WINAPI D3DDevice_CreatePushBuffer(
    UINT Size,
    BOOL RunUsingCpuCopy,
    D3DPushBuffer** ppPushBuffer)
{
    COUNT_API(API_D3DDEVICE_CREATEPUSHBUFFER);

    if (DBG_CHECK(TRUE))
    {
        if (Size & 3)
        {
            DPF_ERR("Buffer allocation size must be a multiple of 4");
        }
        if (RunUsingCpuCopy > TRUE)
        {
            DPF_ERR("Invalid value for RunUsingCpuCopy");
        }
    }

    DWORD memAllocSize = (RunUsingCpuCopy) 
                       ? sizeof(D3DPushBuffer) + Size 
                       : sizeof(D3DPushBuffer);

    D3DPushBuffer* pPushBuffer = (D3DPushBuffer*) MemAllocNoZero(memAllocSize);
    if (!pPushBuffer)
    {
        return E_OUTOFMEMORY;
    }

    ZeroMemory(pPushBuffer, sizeof(D3DPushBuffer));

    pPushBuffer->Common = /* initial refcount */ 1
                        | D3DCOMMON_TYPE_PUSHBUFFER
                        | D3DCOMMON_D3DCREATED;

    if (RunUsingCpuCopy)
    {
        pPushBuffer->Common |= D3DPUSHBUFFER_RUN_USING_CPU_COPY;
        pPushBuffer->Data = (DWORD) (pPushBuffer + 1);
    }
    else
    {
        VOID *pData = AllocateContiguousMemory(Size, D3DPUSHBUFFER_ALIGNMENT);
        if (!pData)
        {
            MemFree(pPushBuffer);
            return E_OUTOFMEMORY;
        }

        // 'Data' for a push-buffer is always the virtual address:

        pPushBuffer->Data = (DWORD) pData;
    }

    pPushBuffer->AllocationSize = Size;

    *ppPushBuffer = pPushBuffer;

    return S_OK;
}

//------------------------------------------------------------------------------
// D3DDevice_BeginPushBuffer

extern "C"
VOID WINAPI D3DDevice_BeginPushBuffer(
    D3DPushBuffer* pPushBuffer)
{
    COUNT_API(API_D3DDEVICE_BEGINPUSHBUFFER);
    CHECK(pPushBuffer, "D3DDevice_BeginPushBuffer");

    CDevice* pDevice = g_pDevice;

    if (DBG_CHECK(TRUE))
    {
        if ((pPushBuffer->Data == 0) || (pPushBuffer->Data & 3))
        {
            DPF_ERR("Buffer pointer can't be NULL and must be dword aligned");
        }
        if (pDevice->m_StateFlags & STATE_RECORDPUSHBUFFER)
        {
            DPF_ERR("Already recording a push-buffer, BeginPushBuffer fails");
        }
        if (pPushBuffer->AllocationSize & 3)
        {
            DPF_ERR("Buffer allocation size must be a multiple of 4");
        }
        if (pPushBuffer->AllocationSize <= PUSHER_THRESHOLD_SIZE * sizeof(DWORD))
        {
            DPF_ERR("Buffer size (AllocationSize) must be more than 512 bytes "
                    "to use BeginPushBuffer");
        }
        if (pDevice->m_IndexBase != 0)
        {
            DPF_ERR("Can't call BeginPushBuffer when BaseVertexIndex as set by "
                    "SetIndices is non-zero");
        }
    }

    // Set any lazy state now so that no state set before BeginPushBuffer
    // gets recorded into the push-buffer:

    pDevice->SetStateVB(0);

    // Make sure we don't overwrite the previous contents if they're still
    // being used:

    BlockOnNonSurfaceResource(pPushBuffer);

    // Remember our inputs:

    pDevice->m_PushBufferRecordWrapSize = 0;
    pDevice->m_pPushBufferRecordResource = pPushBuffer;

    InternalAddRef(pPushBuffer);

    // Now hijack the push-buffer, remembering to save our current state
    // first:

    pDevice->m_pPushBufferRecordSavedPut = pDevice->m_Pusher.m_pPut;
    pDevice->m_pPushBufferRecordSavedThreshold = pDevice->m_Pusher.m_pThreshold;

    // Leave some room at the end for the 'JUMP' instruction:

    pDevice->m_Pusher.m_pPut = (DWORD*) pPushBuffer->Data;
    pDevice->m_Pusher.m_pThreshold 
        = (DWORD*) (pPushBuffer->Data 
                  + pPushBuffer->AllocationSize 
                  - PUSHBUFFER_RETURN_RESERVE)
        - PUSHER_THRESHOLD_SIZE;

    // Remember that we're recording:

    pDevice->m_StateFlags |= STATE_RECORDPUSHBUFFER;

    ASSERT(!(pDevice->m_StateFlags & STATE_RECORDPUSHBUFFERPADDED));
}

//------------------------------------------------------------------------------
// D3DDevice_EndPushBuffer

extern "C"
HRESULT WINAPI D3DDevice_EndPushBuffer()
{
    DWORD unused;

    COUNT_API(API_D3DDEVICE_ENDPUSHBUFFER);

    CDevice* pDevice = g_pDevice;

    if (DBG_CHECK(TRUE))
    {
        if (!(pDevice->m_StateFlags & STATE_RECORDPUSHBUFFER))
        {
            DPF_ERR("Can't call EndPushBuffer without first calling "
                    "BeginPushBuffer!");
        }
    }

    // Make sure we record any pending lazy state changes: 

    pDevice->SetStateVB(0);

    // GetPushBufferOffset has the side effect of padding the push-buffer
    // to the necessary minimum size for us:

    D3DDevice_GetPushBufferOffset(&unused);

    // Initialize the push-buffer structure:

    pDevice->m_pPushBufferRecordResource->Size 
        = pDevice->m_PushBufferRecordWrapSize 
        + (DWORD) pDevice->m_Pusher.m_pPut 
        - pDevice->m_pPushBufferRecordResource->Data
        + PUSHBUFFER_RETURN_RESERVE;

    ASSERT((pDevice->m_pPushBufferRecordResource->Size 
                <= pDevice->m_pPushBufferRecordResource->AllocationSize) ||
           (pDevice->m_PushBufferRecordWrapSize != 0));

    // Stop recording and restore our saved push-buffer state:

    pDevice->m_Pusher.m_pPut = pDevice->m_pPushBufferRecordSavedPut;
    pDevice->m_Pusher.m_pThreshold = pDevice->m_pPushBufferRecordSavedThreshold;

    pDevice->m_StateFlags &= ~(STATE_RECORDPUSHBUFFER | 
                               STATE_RECORDPUSHBUFFERPADDED);

    InternalRelease(pDevice->m_pPushBufferRecordResource);

    // Note that we may have failed even if the buffer was big enough
    // to hold the final result, so we HAVE to check the wrap count:

    if (pDevice->m_PushBufferRecordWrapSize != 0) 
    {
        pDevice->m_pPushBufferRecordResource->Size = 0;
        return D3DERR_BUFFERTOOSMALL;
    }

    return S_OK;
}

//------------------------------------------------------------------------------
// D3DDevice_GetPushBufferOffset

extern "C"
VOID WINAPI D3DDevice_GetPushBufferOffset(
    DWORD* pOffset)
{
    COUNT_API(API_D3DDEVICE_GETPUSHBUFFEROFFSET);

    CDevice* pDevice = g_pDevice;

    if (DBG_CHECK(TRUE))
    {
        if (!(pDevice->m_StateFlags & STATE_RECORDPUSHBUFFER))
        {
            DPF_ERR("GetPushBufferOffset can only be called while recording "
                    "a push-buffer");
        }
    }

    DWORD offset = (DWORD) pDevice->m_Pusher.m_pPut 
                 - pDevice->m_pPushBufferRecordResource->Data;

    // We may need to pad the push-buffer if we haven't done it already,
    // and it's not a RUN_USING_CPU_COPY one:

    INT nops = (PUSHER_MINIMUM_RUN_OFFSET - (INT) offset) / 8;

    if ((nops > 0) &&
        !(pDevice->m_StateFlags & STATE_RECORDPUSHBUFFERPADDED) &&
        !(pDevice->m_pPushBufferRecordResource->Common & 
            D3DPUSHBUFFER_RUN_USING_CPU_COPY))
    {
        pDevice->m_StateFlags |= STATE_RECORDPUSHBUFFERPADDED;

        // The GPU read-ahead is 1K, so we can't have any fixups
        // within 1K of the start of the push-buffer.   So we
        // always pad with NV097_NO_OPERATIONs to the 1K mark.  But 
        // the GPU caches the read-ahead in (offset, value) pairs, so
        // we can get away with only 512 bytes by using the NOINC
        // operation.
        //
        // (Note that we have to use NV097_NO_OPERATION and not
        // PUSHER_NOP in this case.)

        PPUSH pPush = pDevice->StartPush(nops + 1);

        PushCount(pPush, PUSHER_NOINC(NV097_NO_OPERATION), nops);
        ZeroMemory((void*) (pPush + 1), nops * sizeof(DWORD));

        pDevice->EndPush(pPush + nops + 1);

        offset = (DWORD) pDevice->m_Pusher.m_pPut 
               - pDevice->m_pPushBufferRecordResource->Data;
    }

    *pOffset = offset;
}

//------------------------------------------------------------------------------
// Fix-up helper functions

#if !DBG

    FORCEINLINE VOID EndFixup(BOOL IsRaw = FALSE)
    {
    }
    FORCEINLINE VOID Fixup1(DWORD* pFixup, DWORD method, DWORD a)
    {
        method = PUSHER_METHOD(SUBCH_3D, method, 1);
        pFixup[0] = method;
        pFixup[1] = a;
    }
    FORCEINLINE VOID Fixup2(DWORD* pFixup, DWORD method, DWORD a, DWORD b)
    {
        method = PUSHER_METHOD(SUBCH_3D, method, 2);
        pFixup[0] = method;
        pFixup[1] = a;
        pFixup[2] = b;
    }
    FORCEINLINE VOID FixupCount(DWORD* pFixup, DWORD method, DWORD count)
    {
        method = PUSHER_METHOD(SUBCH_3D, method, count);
        pFixup[0] = method;
    }
    FORCEINLINE VOID FixupCount(DWORD* pFixup, SubChannel subch, DWORD method, DWORD count)
    {
        method = PUSHER_METHOD(subch, method, count);
        pFixup[0] = method;
    }
    FORCEINLINE VOID FixupMatrixTransposed(
        DWORD* pFixup, 
        DWORD method, 
        CONST D3DMATRIX* pMatrix)
    {
        DumpMatrixTransposed(pFixup, 
                             PUSHER_METHOD(SUBCH_3D, method, 16),
                             pMatrix);
    }
    FORCEINLINE DWORD ReadBuffer(DWORD* pFixup) 
    {
        return 0xffffffff;
    }

#else

    // Are we in a BeginFixup/EndFixup bracket?

    BOOL g_FixupBracket;

    // Are we in a StartFixup/EndFixup bracket within a fix-up call?

    BOOL g_FixupActive;

    // Current count of dwords we've written within this fix-up call:

    DWORD g_FixupCount;

    // The next place we expect to write within this fix-up call:

    DWORD* g_pNextFixup;

    // Add this value to 'pFixup' (which is where we're currently writing
    // fix-up data) to get a pointer to the corresponding location in the
    // push-buffer, for verifying signatures:

    DWORD g_FixupToBuffer;

    // The size they tell us at StartFixup time has to match watch they
    // stick in the buffer:

    DWORD g_OriginalCount;

    //--------------------------------------------------------------------------
    // ReadBuffer - reads the corresponding address in the original push-buffer

    DWORD ReadBuffer(DWORD* pFixup) 
    {
        ASSERT(g_FixupActive);
        return *(pFixup + g_FixupToBuffer);
    }

    //--------------------------------------------------------------------------
    // EndFixup - analagous to EndPush

    VOID EndFixup(BOOL isRaw = FALSE)
    {
        ASSERT(g_FixupActive);
        ASSERT((isRaw) || (g_FixupCount == g_OriginalCount));

        g_FixupActive = FALSE;
    }

    //--------------------------------------------------------------------------
    // Fixup1 - analagous to Push1

    VOID Fixup1(DWORD* pFixup, DWORD method, DWORD a)
    {
        ASSERT(g_FixupActive);
        ASSERT(pFixup == g_pNextFixup);

        method = PUSHER_METHOD(SUBCH_3D, method, 1);
        if (ReadBuffer(pFixup) != method)
        {
            DPF_ERR("The fix-up signature doesn't match existing data\n"
                    "(A bad offset was specified, or the specified parameters \n"
                    "don't match the signatures of those recorded)");
        }

        g_FixupCount += 2;
        g_pNextFixup += 2;

        pFixup[0] = method;
        pFixup[1] = a;
    }

    //--------------------------------------------------------------------------
    // Fixup2 - analagous to Push2

    VOID Fixup2(DWORD* pFixup, DWORD method, DWORD a, DWORD b)
    {
        ASSERT(g_FixupActive);
        ASSERT(pFixup == g_pNextFixup);

        method = PUSHER_METHOD(SUBCH_3D, method, 2);
        if (ReadBuffer(pFixup) != method)
        {
            DPF_ERR("The fix-up signature doesn't match existing data\n"
                    "(A bad offset was specified, or the specified parameters \n"
                    "don't match the signatures of those recorded)");
        }

        g_FixupCount += 3;
        g_pNextFixup += 3;

        pFixup[0] = method;
        pFixup[1] = a;
        pFixup[2] = b;
    }

    //--------------------------------------------------------------------------
    // FixupCount - analagous to PushCount

    VOID FixupCount(DWORD* pFixup, SubChannel subch, DWORD method, DWORD count)
    {
        ASSERT(g_FixupActive);
        ASSERT(pFixup == g_pNextFixup);

        method = PUSHER_METHOD(subch, method, count);
        if (ReadBuffer(pFixup) != method)
        {
            DPF_ERR("The fix-up signature doesn't match existing data\n"
                    "(A bad offset was specified, or the specified parameters \n"
                    "don't match the signatures of those recorded)");
        }

        g_FixupCount += (count + 1);
        g_pNextFixup += (count + 1);

        pFixup[0] = method;
    }

    FORCEINLINE VOID FixupCount(DWORD* pFixup, DWORD method, DWORD count)
    {
        FixupCount(pFixup, SUBCH_3D, method, count);
    }

    //--------------------------------------------------------------------------
    // FixupMatrixTransposed - analagous to PushMatrixTransposed

    VOID FixupMatrixTransposed(
        DWORD* pFixup, 
        DWORD method, 
        CONST D3DMATRIX* pMatrix)
    {
        ASSERT(g_FixupActive);
        ASSERT(pFixup == g_pNextFixup);

        method = PUSHER_METHOD(SUBCH_3D, method, 16);
        if (ReadBuffer(pFixup) != method)
        {
            DPF_ERR("The fix-up signature doesn't match existing data\n"
                    "(A bad offset was specified, or the specified parameters \n"
                    "don't match the signatures of those recorded)");
        }

        DumpMatrixTransposed(pFixup, method, pMatrix);

        g_FixupCount += 17;
        g_pNextFixup += 17;
    }

#endif            

//------------------------------------------------------------------------------
// g_pFixup
//
// While in a BeginFixup/EndFixup bracket, points to the fix-up object (if any).

D3DFixup* g_pFixup;

//------------------------------------------------------------------------------
// AddToFixup - for early-outs to account for space that would have been used
//    by subsequent StartFixup calls in the same routine

VOID AddToFixup(
    DWORD Count)
{
    D3DFixup* pFixup = g_pFixup;
    if (pFixup != NULL)
    {
        DWORD size = Count * sizeof(DWORD);

        // Reserve 2 dwords of structure overhead for 'size' and 'offset':

        pFixup->Next += (8 + size);
    }
}

//------------------------------------------------------------------------------
// StartFixup - analagous to StartPush
//
// Handles the logic of setting up to write the fix-up data either to a
// fix-up array, or directly to the push-buffer data.
//
// NOTE: Once this function returns, you have to write ALL 'Count' DWORDS
//       to the buffer (you can't have any gaps in your writes, due to the
//       nature of the fix-up buffer).

DWORD* StartFixup(
    D3DPushBuffer* pPushBuffer,
    UINT Offset,
    DWORD Count)
{
    DWORD* pSrc = (DWORD*) ((BYTE*) pPushBuffer->Data + Offset);
    DWORD* pDst = pSrc;

    if (DBG_CHECK(TRUE))
    {
        if (DBG_CHECK(!g_FixupBracket))
        {
            DPF_ERR("Fix-up routine called without first calling BeginFixup");
        }
        if (pPushBuffer->Size == 0)
        {
            DPF_ERR("Zero push-buffer 'Size' (maybe failed recording?)");
        }
        if (pPushBuffer->Size & 3)
        {
            DPF_ERR("Push-buffer 'Size' not a dword multiple");
        }
        if (Offset >= pPushBuffer->Size)
        {
            DPF_ERR("Specified offset is larger than push-buffer");
        }
    }

    D3DFixup* pFixup = g_pFixup;
    if (pFixup != NULL)
    {
        DWORD* pFix = (DWORD*) (pFixup->Data + pFixup->Next);
        DWORD size = Count * sizeof(DWORD);

        // Reserve 2 dwords of structure overhead for 'size' and 'offset':

        pFixup->Next += (8 + size);
        if (pFixup->Next > pFixup->Size)
            return NULL;

        pFix[0] = size;
        pFix[1] = Offset;

        pDst = &pFix[2];
    }

#if DBG

    // Note that this assumes fix-ups aren't multi-threaded, but I think
    // this is okay, particularly since it's only on debug builds (meaning
    // this won't cause mysterious free builds crashes).

    ASSERT(!g_FixupActive);
    g_pNextFixup = pDst;
    g_FixupToBuffer = (pSrc - pDst);
    g_FixupActive = TRUE;
    g_FixupCount = 0;
    g_OriginalCount = Count;

#endif

    return pDst;
}

//------------------------------------------------------------------------------
// D3DPushBuffer_RunPushBuffer
//
// Note that this can't handle D3DPUSHBUFFER_RUN_USING_CPU_COPY cases for
// either the source or the destination.

extern "C"
VOID WINAPI D3DPushBuffer_RunPushBuffer(
    D3DPushBuffer* pPushBuffer,
    UINT Offset,
    D3DPushBuffer* pDestinationPushBuffer,
    D3DFixup* pDestinationFixup)
{
    COUNT_API(API_D3DPUSHBUFFER_RUNPUSHBUFFER);
    CHECK(pPushBuffer, "D3DPushBuffer_RunPushBuffer");

    if (DBG_CHECK(TRUE))
    {
        RunPushBufferParameterCheck(pDestinationPushBuffer, pDestinationFixup);

        if ((pPushBuffer->Common & D3DPUSHBUFFER_RUN_USING_CPU_COPY) ||
            (pDestinationPushBuffer->Common & D3DPUSHBUFFER_RUN_USING_CPU_COPY))
        {
            DPF_ERR("Can't handle D3DPUSHBUFFER_RUN_USING_CPU_COPY for either "
                    "source or \ndestination push-buffer types");
        }
    }

    DWORD infoDwords = sizeof(CMiniport::PUSHBUFFERFIXUPINFO) / sizeof(DWORD);
    DWORD* pFixup = StartFixup(pPushBuffer, Offset, 5 + infoDwords);
    if (!pFixup)
        return;

    CMiniport::PUSHBUFFERFIXUPINFO PushBufferFixupInfo;

    PushBufferFixupInfo.pStart = (BYTE *)pDestinationPushBuffer->Data;
    PushBufferFixupInfo.ReturnOffset =
        pDestinationPushBuffer->Size - PUSHBUFFER_RETURN_RESERVE;

    DWORD firstModify = PushBufferFixupInfo.ReturnOffset;
    DWORD* pFix = NULL;

    if (pDestinationFixup != 0)
    {
        pFix = (DWORD*) (pDestinationFixup->Data + pDestinationFixup->Run);
        firstModify = *pFix;
    }

    PushBufferFixupInfo.pFixupData = pFix;
    PushBufferFixupInfo.ReturnAddress = 
        (DWORD*) (pPushBuffer->Data + Offset + (5 + infoDwords)*sizeof(DWORD));

    // NVX_PUSH_BUFFER_FIXUP_POINTER Data stored in NV097_SET_ZSTENCIL_CLEAR_VALUE

    Fixup1(pFixup, 
           NV097_SET_ZSTENCIL_CLEAR_VALUE, 
           pPushBuffer->Data + Offset + 5*sizeof(DWORD));

    Fixup1(pFixup + 2,
           NV097_NO_OPERATION,
           NVX_PUSH_BUFFER_FIXUP);

    pFixup += 4;

    // Make sure the JUMP instruction was there:

    if (DBG_CHECK((ReadBuffer(pFixup) & 3) != 1))
    {
        DPF_ERR("Signature mismatch - Offset or push-buffer size may "
                "different from what was recorded.");
    }

    *pFixup = PUSHER_JUMP(GetGPUAddressFromWC(PushBufferFixupInfo.pStart));
    *(CMiniport::PUSHBUFFERFIXUPINFO *)(pFixup + 1) = PushBufferFixupInfo;

    EndFixup(TRUE);
}

//------------------------------------------------------------------------------
// D3DPushBuffer_SetModelView

extern "C"
VOID WINAPI D3DPushBuffer_SetModelView(
    D3DPushBuffer* pPushBuffer,
    UINT Offset,
    CONST D3DMATRIX* pModelView,
    CONST D3DMATRIX* pInverseModelView,
    CONST D3DMATRIX* pComposite)
{
    COUNT_API(API_D3DPUSHBUFFER_SETMODELVIEW);
    CHECK(pPushBuffer, "D3DPushBuffer_SetModelView");

    DWORD fixupCount = (pInverseModelView) ? (17*2 + 13) : (17*2);
    DWORD* pFixup = StartFixup(pPushBuffer, Offset, fixupCount);
    if (!pFixup)
        return;

    FixupMatrixTransposed(pFixup, NV097_SET_MODEL_VIEW_MATRIX0(0), pModelView);

    FixupMatrixTransposed(pFixup + 17, NV097_SET_COMPOSITE_MATRIX(0), pComposite);

    if (pInverseModelView)
    {
        FixupCount(pFixup + 34, NV097_SET_INVERSE_MODEL_VIEW_MATRIX0(0), 12);

        memcpy(pFixup + 35, pInverseModelView, 12 * sizeof(DWORD));
    }

    EndFixup();
}

//------------------------------------------------------------------------------
// D3DPushBuffer_SetVertexBlendModelView

extern "C"
VOID WINAPI D3DPushBuffer_SetVertexBlendModelView(
    D3DPushBuffer* pPushBuffer,
    UINT Offset,
    UINT Count,
    CONST D3DMATRIX* pModelViews,
    CONST D3DMATRIX* pInverseModelViews,
    CONST D3DMATRIX* pProjectionViewport)
{
    DWORD i;

    COUNT_API(API_D3DPUSHBUFFER_SETVERTEXBLENDMODELVIEW);
    CHECK(pPushBuffer, "D3DPushBuffer_SetVertexBlendModelView");

    DWORD fixupCount = 17 + 17 * Count;
    if (pInverseModelViews)
        fixupCount += 13 * Count;

    DWORD* pFixup = StartFixup(pPushBuffer, Offset, fixupCount);
    if (!pFixup)
        return;

    for (i = 0; i < Count; i++)
    {
        DWORD stride = NV097_SET_MODEL_VIEW_MATRIX1(0) 
                     - NV097_SET_MODEL_VIEW_MATRIX0(0);

        FixupMatrixTransposed(pFixup, 
                              NV097_SET_MODEL_VIEW_MATRIX0(0) + (i * stride),
                              &pModelViews[i]);

        pFixup += 17;
    }

    if (pInverseModelViews)
    {
        for (i = 0; i < Count; i++)
        {
            DWORD stride = NV097_SET_INVERSE_MODEL_VIEW_MATRIX1(0) 
                         - NV097_SET_INVERSE_MODEL_VIEW_MATRIX0(0);

            FixupCount(pFixup, 
                       NV097_SET_INVERSE_MODEL_VIEW_MATRIX0(0) + (i * stride), 
                       12);

            memcpy(pFixup + 1, &pInverseModelViews[i], 12 * sizeof(DWORD));

            pFixup += 13;
        }
    }

    FixupMatrixTransposed(pFixup,
                          NV097_SET_COMPOSITE_MATRIX(0),
                          pProjectionViewport);

    pFixup += 17;

    EndFixup();
}

//------------------------------------------------------------------------------
// D3DPushBuffer_SetVertexShaderInputDirect

extern "C"
void WINAPI D3DPushBuffer_SetVertexShaderInputDirect(
    D3DPushBuffer* pPushBuffer,
    UINT Offset,
    D3DVERTEXATTRIBUTEFORMAT *pVAF,
    UINT StreamCount,
    CONST D3DSTREAM_INPUT *pStreamInputs)
{
    // This API call is counted as an API_D3DPUSHBUFFER_SETVERTEXSHADERINPUT
    
    if (DBG_CHECK(TRUE))
    {
        if(pVAF == NULL)
        {
            DPF_ERR("NULL D3DVERTEXATTRIBUTEFORMAT is invalid in SetVertexShaderInputDirect");
        }
#if DBG
        CheckVertexAttributeFormatStruct(pVAF);
#endif    
    }

    memcpy(&(g_DirectVertexShader.Slot[0]), pVAF, sizeof(VertexShaderSlot)*16);
    D3DPushBuffer_SetVertexShaderInput(pPushBuffer, Offset, (DWORD)(&g_DirectVertexShader) | D3DFVF_RESERVED0, StreamCount, pStreamInputs);
}

//------------------------------------------------------------------------------
// D3DPushBuffer_SetVertexShaderInput

extern "C"
VOID WINAPI D3DPushBuffer_SetVertexShaderInput(
    D3DPushBuffer* pPushBuffer,
    UINT Offset,
    DWORD Handle,
    UINT StreamCount,
    CONST D3DSTREAM_INPUT *pStreamInputs)
{
    DWORD i;

    COUNT_API(API_D3DPUSHBUFFER_SETVERTEXSHADERINPUT);
    CHECK(pPushBuffer, "D3DPushBuffer_SetVertexInput");

    VertexShader *pVertexShader = (VertexShader*) (Handle - D3DFVF_RESERVED0);

    if (DBG_CHECK(TRUE))
    {
        if (!IsVertexProgram(Handle))
        {
            DPF_ERR("Must be a vertex shader program, not an FVF");
        }
    #if DBG
        if (pVertexShader->Signature != 'Vshd')
        {
            DPF_ERR("Invalid vertex shader object (already deleted?)");
        }
    #endif
        if ((StreamCount == 0) || (StreamCount > 15))
        {
            DPF_ERR("Stream count can't be 0 or more than 15");
        }
        for (i = 0; i < StreamCount; i++)
        {
            if (pStreamInputs[i].VertexBuffer == NULL)
            {
                DPF_ERR("Can't specify NULL VertexBuffer");
            }
            if (pStreamInputs[i].Stride > 255)
            {
                DPF_ERR("Can't have a stride more than 255");
            }
        }
    }

    DWORD* pFixup = StartFixup(pPushBuffer, Offset, 34);
    if (!pFixup)
        return;

    FixupCount(pFixup, NV097_SET_VERTEX_DATA_ARRAY_OFFSET(0), 16);
    FixupCount(pFixup + 17, NV097_SET_VERTEX_DATA_ARRAY_FORMAT(0), 16);

    for (i = 0; i < 16; i++)
    {
        VertexShaderSlot *pSlot = &pVertexShader->Slot[i];

        if (DBG_CHECK(pSlot->StreamIndex >= StreamCount))
        {
            DPF_ERR("Vertex Shader references more streams than given to "
                    "SetVertexShaderInput");
        }

        CONST D3DSTREAM_INPUT* pStreamInput = &pStreamInputs[pSlot->StreamIndex];

        DWORD offset = pStreamInput->VertexBuffer->Data
                     + pStreamInput->Offset
                     + pSlot->Offset;

        pFixup[1 + i] = offset;

        DWORD format = (pStreamInput->Stride << 8) + pSlot->SizeAndType;

        pFixup[18 + i] = format;
    }

    EndFixup();
}

//------------------------------------------------------------------------------
// D3DPushBuffer_SetRenderTarget
//
// NOTE: The new render target must be the same format and dimension as the old.

extern "C"
VOID WINAPI D3DPushBuffer_SetRenderTarget(
    D3DPushBuffer* pPushBuffer,
    UINT Offset,
    D3DSurface* pRenderTarget,
    D3DSurface* pZBuffer)
{
    COUNT_API(API_D3DPUSHBUFFER_SETRENDERTARGET);
    CHECK(pPushBuffer, "D3DPushBuffer_SetRenderTarget");

    DWORD* pFixup = StartFixup(pPushBuffer, Offset, 48);
    if (!pFixup)
        return;

    DWORD pitch = PixelJar::GetPitch(pRenderTarget);
    DWORD Zpitch = (pZBuffer) ? PixelJar::GetPitch(pZBuffer) : pitch;

    if (DBG_CHECK(TRUE))
    {
        if (ReadBuffer(pFixup + 3) != 
            (DRF_NUM(097, _SET_SURFACE_PITCH, _COLOR, pitch)
           | DRF_NUM(097, _SET_SURFACE_PITCH, _ZETA, Zpitch)))
        {
            DPF_ERR("Pitch mismatch");
        }
        if (ReadBuffer(pFixup + 3 + 24) != 
            (DRF_NUM(097, _SET_SURFACE_PITCH, _COLOR, pitch)
           | DRF_NUM(097, _SET_SURFACE_PITCH, _ZETA, Zpitch)))
        {
            DPF_ERR("Pitch mismatch");
        }
        if ((ReadBuffer(pFixup + 3 + 16) == 0) && (pZBuffer != NULL))
        {
            DPF_ERR("Z-buffer now but wasn't before");
        }
        if ((ReadBuffer(pFixup + 3 + 16) != 0) && (pZBuffer == NULL))
        {
            DPF_ERR("No z-buffer now but was one before");
        }
    }

    DWORD colorOffset = pRenderTarget->Data;
    DWORD Zoffset = (pZBuffer != NULL) ? pZBuffer->Data : 0;

    for (DWORD iterations = 0; iterations < 2; iterations++)
    {
        Fixup1(pFixup, NV097_NO_OPERATION, 0);
        Fixup1(pFixup + 2, NV097_SET_SURFACE_PITCH,
                     DRF_NUM(097, _SET_SURFACE_PITCH, _COLOR, pitch)
                   | DRF_NUM(097, _SET_SURFACE_PITCH, _ZETA, Zpitch));
        Fixup1(pFixup + 4, NV097_NO_OPERATION, 0);
        Fixup1(pFixup + 6, NV097_WAIT_FOR_IDLE, 0);
        pFixup += 8;

        Fixup1(pFixup, NV097_NO_OPERATION, 0);
        Fixup1(pFixup + 2, NV097_SET_SURFACE_COLOR_OFFSET, colorOffset);
        Fixup1(pFixup + 4, NV097_NO_OPERATION, 0);
        Fixup1(pFixup + 6, NV097_WAIT_FOR_IDLE, 0);
        pFixup += 8;

        Fixup1(pFixup, NV097_NO_OPERATION, 0);
        Fixup1(pFixup + 2, NV097_SET_SURFACE_ZETA_OFFSET, Zoffset);
        Fixup1(pFixup + 4, NV097_NO_OPERATION, 0);
        Fixup1(pFixup + 6, NV097_WAIT_FOR_IDLE, 0);
        pFixup += 8;
    }

    EndFixup();
}

//------------------------------------------------------------------------------
// D3DPushBuffer_SetTexture

extern "C"
VOID WINAPI D3DPushBuffer_SetTexture(
    D3DPushBuffer* pPushBuffer,
    UINT Offset,
    DWORD Stage,
    D3DBaseTexture *pTexture)
{
    COUNT_API(API_D3DPUSHBUFFER_SETTEXTURE);
    CHECK(pPushBuffer, "D3DPushBuffer_SetTexture");

    if (DBG_CHECK(TRUE))
    {
        if ((Offset & 3) || (Offset >= pPushBuffer->Size))
        {
            DPF_ERR("Offset must be multiple of 4 and less than push buffer size");
        }
        if (pTexture == NULL)
        {
            DPF_ERR("Can't take a NULL texture");
        }
    }

    DWORD fixupCount = (pTexture->Size != 0) ? 7 : 3;
    DWORD* pFixup = StartFixup(pPushBuffer, Offset, fixupCount);
    if (!pFixup)
        return;

    if (DBG_CHECK((pTexture->Format ^ ReadBuffer(pFixup + 2)) &
            (DRF_NUM(097, _SET_TEXTURE_FORMAT, _CUBEMAP_ENABLE, ~0) | 
             DRF_NUM(097, _SET_TEXTURE_FORMAT, _DIMENSIONALITY, ~0))))
    {
        DPF_ERR("New texture type doesn't match old");
    }

    Fixup2(pFixup,  
           NV097_SET_TEXTURE_OFFSET(Stage), 
           pTexture->Data, 
           pTexture->Format);

    if (pTexture->Size != 0)
    {
        DWORD width = PixelJar::GetLinearWidth(pTexture);
        DWORD height = PixelJar::GetLinearHeight(pTexture);
        DWORD pitch = PixelJar::GetLinearPitch(pTexture);
        
        Fixup1(pFixup + 3, 
               NV097_SET_TEXTURE_CONTROL1(Stage),
               DRF_NUMFAST(097, _SET_TEXTURE_CONTROL1, _IMAGE_PITCH, pitch));
        
        Fixup1(pFixup + 5, 
               NV097_SET_TEXTURE_IMAGE_RECT(Stage),
               DRF_NUMFAST(097, _SET_TEXTURE_IMAGE_RECT, _WIDTH, width)
               | DRF_NUMFAST(097, _SET_TEXTURE_IMAGE_RECT, _HEIGHT, height));
    }

    EndFixup();
}

//------------------------------------------------------------------------------
// D3DPushBuffer_SetPalette

extern "C"
VOID WINAPI D3DPushBuffer_SetPalette(
    D3DPushBuffer* pPushBuffer,
    UINT Offset,
    DWORD Stage,
    D3DPalette *pPalette)
{
    COUNT_API(API_D3DPUSHBUFFER_SETPALETTE);
    CHECK(pPushBuffer, "D3DPushBuffer_SetPalette");

    if (DBG_CHECK(TRUE))
    {
        if ((Offset & 3) || (Offset >= pPushBuffer->Size))
        {
            DPF_ERR("Offset must be multiple of 4 and less than push buffer size");
        }
    }

    DWORD* pFixup = StartFixup(pPushBuffer, Offset, 2);
    if (!pFixup)
        return;

    DWORD contextAndLength
        = (pPalette->Common >> D3DPALETTE_COMMON_PALETTESET_SHIFT)
        & D3DPALETTE_COMMON_PALETTESET_MASK;

    ASSERT((contextAndLength & 2) == 0);
    ASSERT(contextAndLength <=
           (DRF_DEF(097, _SET_TEXTURE_PALETTE, _LENGTH, _32)
          | DRF_DEF(097, _SET_TEXTURE_PALETTE, _CONTEXT_DMA, _B)));
    ASSERT((pPalette->Data & 63) == 0);

    Fixup1(pFixup, 
           NV097_SET_TEXTURE_PALETTE(Stage),
           pPalette->Data | contextAndLength);

    EndFixup();
}

//------------------------------------------------------------------------------
// D3DPushBuffer_EndVisibilityTest

extern "C"
HRESULT WINAPI D3DPushBuffer_EndVisibilityTest(
    D3DPushBuffer* pPushBuffer,
    UINT Offset,
    DWORD Index)
{
    COUNT_API(API_D3DPUSHBUFFER_ENDVISIBILITYTEST);
    CHECK(pPushBuffer, "D3DPushBuffer_EndVisibilityTest");

    BYTE* virtualAddress = GetVisibilityAddress(Index);
    if (virtualAddress == NULL)
        return E_OUTOFMEMORY;

    DWORD* pFixup = StartFixup(pPushBuffer, Offset, 3);
    if (!pFixup)
        return S_OK;

    Fixup2(pFixup, NV097_SET_ZPASS_PIXEL_COUNT_ENABLE,

          // NV097_SET_ZPASS_PIXEL_COUNT_ENABLE:

          FALSE,

          // NV097_GET_REPORT:
          
          DRF_DEF(097, _GET_REPORT, _TYPE, _ZPASS_PIXEL_CNT)
        | DRF_NUMFAST(097, _GET_REPORT, _OFFSET, GetGPUAddress(virtualAddress)));

    EndFixup();

    return S_OK;
}

//------------------------------------------------------------------------------
// D3DPushBuffer_SetVertexShaderConstant

extern "C"
VOID WINAPI D3DPushBuffer_SetVertexShaderConstant(
    D3DPushBuffer* pPushBuffer,
    UINT Offset,
    INT Register, // Not used
    CONST VOID* pConstantData,
    DWORD ConstantCount)
{
    COUNT_API(API_D3DPUSHBUFFER_SETVERTEXSHADERCONSTANT);
    CHECK(pPushBuffer, "D3DPushBuffer_SetVertexShaderConstant");

    CDevice* pDevice = g_pDevice;

    // Convert to number of DWORDs:

    DWORD totalCount = 4 * ConstantCount;
    DWORD batchCount = (totalCount + 31) / 32;
    CONST DWORD* pData = (CONST DWORD*) pConstantData;

    // Skip the NV097_SET_TRANSFORM_CONSTANT_LOAD load:

    Offset += 8;

    DWORD* pFixup = StartFixup(pPushBuffer, Offset, totalCount + batchCount);
    if (!pFixup)
        return;

    do {
        DWORD thisCount = min(totalCount, 32);

        totalCount -= thisCount;

        FixupCount(pFixup, NV097_SET_TRANSFORM_CONSTANT(0), thisCount);

        memcpy(&pFixup[1], pData, thisCount * sizeof(DWORD));

        pFixup += (thisCount + 1);
        pData += thisCount;

    } while (--batchCount != 0);

    ASSERT(totalCount == 0);

    EndFixup();
}

//------------------------------------------------------------------------------
// D3DPushBuffer_Jump

extern "C"
VOID WINAPI D3DPushBuffer_Jump(
    D3DPushBuffer* pPushBuffer,
    UINT Offset,
    UINT DestinationOffset)
{
    COUNT_API(API_D3DPUSHBUFFER_JUMP);
    CHECK(pPushBuffer, "D3DPushBuffer_SetJump");

    if (DBG_CHECK(TRUE))
    {
        if (pPushBuffer->Common & D3DPUSHBUFFER_RUN_USING_CPU_COPY)
        {
            DPF_ERR("Can't do a SetJump when D3DPUSHBUFFER_RUN_USING_CPU_COPY");
        }
    }

    DWORD* pFixup = StartFixup(pPushBuffer, Offset, 1);
    if (!pFixup)
        return;

    if (DBG_CHECK(TRUE))
    {
        DWORD oldInstruction = ReadBuffer(pFixup);

        if ((oldInstruction != PUSHER_METHOD(SUBCH_3D, NV097_NO_OPERATION, 1)) &&
            ((oldInstruction & 3) != 1))
        {
            DPF_ERR("Offset signature is neither a NOP nor a JUMP instruction");
        }
    }

    if (Offset == DestinationOffset)
    {
        *pFixup = PUSHER_METHOD(SUBCH_3D, NV097_NO_OPERATION, 1);
    }
    else
    {
        *pFixup = PUSHER_JUMP(GetGPUAddressFromWC((VOID*) pPushBuffer->Data) +
                             DestinationOffset);
    }

    EndFixup(TRUE);

    if (!g_pFixup)
    {
        // This is very likely to be called from a DPC to implement a 
        // conditional jump, so we'll do the WC flush now.  
    
        FlushWCCache();
    }
}

//------------------------------------------------------------------------------
// g_ResourceMethods

D3DCONST DWORD g_ResourceMethods[] =
{
    PUSHER_METHOD(SUBCH_3D, NV097_SET_SURFACE_COLOR_OFFSET, 0),
    PUSHER_METHOD(SUBCH_3D, NV097_SET_SURFACE_ZETA_OFFSET, 0),
    PUSHER_METHOD(SUBCH_3D, NV097_SET_VERTEX_DATA_ARRAY_OFFSET(0), 0),
    PUSHER_METHOD(SUBCH_3D, NV097_SET_VERTEX_DATA_ARRAY_OFFSET(1), 0),
    PUSHER_METHOD(SUBCH_3D, NV097_SET_VERTEX_DATA_ARRAY_OFFSET(2), 0),
    PUSHER_METHOD(SUBCH_3D, NV097_SET_VERTEX_DATA_ARRAY_OFFSET(3), 0),
    PUSHER_METHOD(SUBCH_3D, NV097_SET_VERTEX_DATA_ARRAY_OFFSET(4), 0),
    PUSHER_METHOD(SUBCH_3D, NV097_SET_VERTEX_DATA_ARRAY_OFFSET(5), 0),
    PUSHER_METHOD(SUBCH_3D, NV097_SET_VERTEX_DATA_ARRAY_OFFSET(6), 0),
    PUSHER_METHOD(SUBCH_3D, NV097_SET_VERTEX_DATA_ARRAY_OFFSET(7), 0),
    PUSHER_METHOD(SUBCH_3D, NV097_SET_VERTEX_DATA_ARRAY_OFFSET(8), 0),
    PUSHER_METHOD(SUBCH_3D, NV097_SET_VERTEX_DATA_ARRAY_OFFSET(9), 0),
    PUSHER_METHOD(SUBCH_3D, NV097_SET_VERTEX_DATA_ARRAY_OFFSET(10), 0),
    PUSHER_METHOD(SUBCH_3D, NV097_SET_VERTEX_DATA_ARRAY_OFFSET(11), 0),
    PUSHER_METHOD(SUBCH_3D, NV097_SET_VERTEX_DATA_ARRAY_OFFSET(12), 0),
    PUSHER_METHOD(SUBCH_3D, NV097_SET_VERTEX_DATA_ARRAY_OFFSET(13), 0),
    PUSHER_METHOD(SUBCH_3D, NV097_SET_VERTEX_DATA_ARRAY_OFFSET(14), 0),
    PUSHER_METHOD(SUBCH_3D, NV097_SET_VERTEX_DATA_ARRAY_OFFSET(15), 0),
    PUSHER_METHOD(SUBCH_3D, NV097_SET_TEXTURE_OFFSET(0), 0),
    PUSHER_METHOD(SUBCH_3D, NV097_SET_TEXTURE_OFFSET(1), 0),
    PUSHER_METHOD(SUBCH_3D, NV097_SET_TEXTURE_OFFSET(2), 0),
    PUSHER_METHOD(SUBCH_3D, NV097_SET_TEXTURE_OFFSET(3), 0),
    PUSHER_METHOD(SUBCH_3D, NV097_SET_TEXTURE_PALETTE(0), 0),
    PUSHER_METHOD(SUBCH_3D, NV097_SET_TEXTURE_PALETTE(1), 0),
    PUSHER_METHOD(SUBCH_3D, NV097_SET_TEXTURE_PALETTE(2), 0),
    PUSHER_METHOD(SUBCH_3D, NV097_SET_TEXTURE_PALETTE(3), 0),
    PUSHER_METHOD(SUBCH_3D, NV097_SET_SEMAPHORE_OFFSET, 0),
    PUSHER_METHOD(SUBCH_3D, NV097_GET_REPORT, 0),
};

#define STAMP_VALUE 0xfffffffd // Must have a 'JUMP' encoding

//------------------------------------------------------------------------------
// StampCheckValue

__forceinline VOID StampCheckValue(
    PPUSH pPush,
    BOOL Stamp,
    DWORD Offset)
{
    if (Stamp)
    {
        *pPush = STAMP_VALUE;
    }
    else if (*pPush == STAMP_VALUE)
    {
        DXGRIP("D3DPushBuffer_Verify: Unresolved resource reference "
               "near offset 0x%lx", Offset);
    }
}

//------------------------------------------------------------------------------
// VerifyInstruction

VOID VerifyInstruction(
    DWORD EncodedMethod, // NOTE: This includes the subchannel
    PPUSH pPush,
    DWORD Offset,
    BOOL Stamp)
{
    DWORD subch = EncodedMethod >> 13;

    if (subch != SUBCH_3D)
    {
        DPF_ERR("D3DPushBuffer_Verify: Unexpected sub-channel");
    }
    else if(EncodedMethod == PUSHER_METHOD(SUBCH_3D, NV097_SET_ZSTENCIL_CLEAR_VALUE, 0))
    {
        // NVX_PUSH_BUFFER_FIXUP_POINTER is the SET_ZSTENCIL_CLEAR_VALUE
        // followed by the data dword then a noop with the NVX_* method value.

        if(pPush[1] == PUSHER_METHOD(SUBCH_3D, NV097_NO_OPERATION, 1) &&
            ((pPush[2] == NVX_PUSH_BUFFER_FIXUP) || (pPush[2] == NVX_PUSH_BUFFER_RUN)))
        {
            StampCheckValue(pPush, Stamp, Offset);
        }

    }
    else
    {
        // This is obviously not the fastest search in the world, but what
        // the heck, this is debug only.

        for (DWORD i = 0; 
             i < sizeof(g_ResourceMethods) / sizeof(g_ResourceMethods[0]);
             i++)
        {
            if (EncodedMethod == g_ResourceMethods[i])
            {
                StampCheckValue(pPush, Stamp, Offset);
            }
        }
    }
}

//------------------------------------------------------------------------------
// D3DPushBuffer_Verify

extern "C"
VOID WINAPI D3DPushBuffer_Verify(
    D3DPushBuffer* pPushBuffer,
    BOOL StampResources)
{
    COUNT_API(API_D3DPUSHBUFFER_VERIFY);

    CHECK(pPushBuffer, "D3DPushBuffer_Verify");

#if DBG

    if (DBG_CHECK(TRUE))
    {
        if (StampResources > TRUE)
        {
            DPF_ERR("Invalid value for StampResources");
        }
    }

    PPUSH pPush = (DWORD*) (pPushBuffer->Data);
    PPUSH pPushEnd = (DWORD*) (pPushBuffer->Data + pPushBuffer->Size 
                                - PUSHBUFFER_RETURN_RESERVE);

    while (pPush < pPushEnd)
    {
        DWORD push = *pPush++;
        DWORD instruction = push >> 29;
        DWORD count = (push & 0x1ffc0000) >> 18;
        DWORD encodedMethod = push & 0xffff; // Note we include sub-channel

        ASSERT((push == 0) || (count > 0));
        ASSERT(instruction != 1);

        // In order to be able to stamp 'jumps', the stamp value must look
        // like a valid jump:

        ASSERT((STAMP_VALUE & 3) == 1); 

        if ((push & 3) == 1) // Jump case
        {
            DWORD i;
            DWORD jumpAndInfo = 1 + sizeof(CMiniport::PUSHBUFFERFIXUPINFO) 
                                  / sizeof(DWORD);

            if (StampResources)
            {
                for (i = 0; i < jumpAndInfo; i++)
                {
                    *(pPush - 1) = STAMP_VALUE;
                    pPush++;
                }
            }
            else 
            {
                for (i = 0; i < jumpAndInfo; i++)
                {
                    if (*(pPush - 1) == STAMP_VALUE)
                    {
                        DXGRIP("D3DPushBuffer_Verify: Unresolved Jump reference near "
                               "offset 0x%lx", (DWORD) pPush - pPushBuffer->Data);
                    }
                    pPush++;
                }
            }

            // We wanted to stamp 'jumpAndInfo' dwords, but only advance
            // 'pPush' by 'jumpAndInfo - 1' dwords:

            pPush--;
        }
        else if (instruction == 2) // No-increment case
        {
            VerifyInstruction(encodedMethod, 
                              pPush + count - 1,
                              (DWORD) pPush - pPushBuffer->Data,
                              StampResources);

            pPush += count;
        }
        else if (instruction == 0) // Increment case
        {
            while (count != 0)
            {
                VerifyInstruction(encodedMethod, 
                                  pPush, 
                                  (DWORD) pPush - pPushBuffer->Data,
                                  StampResources);

                pPush++;
                count--;
                encodedMethod += 4;
            }
        }
        else
        {
            RIP(("D3DPushBuffer_Verify: Unexpected push-buffer encoding (corrupted push-buffer?)"));
        }
    }

#endif

}

//------------------------------------------------------------------------------
// D3DDevice_CreateFixup

extern "C"
HRESULT WINAPI D3DDevice_CreateFixup(
    UINT Size,
    D3DFixup** ppFixup)
{
    COUNT_API(API_D3DDEVICE_CREATEFIXUP);

    D3DFixup* pFixup = (D3DFixup*) MemAllocNoZero(sizeof(D3DFixup) + Size);
    if (!pFixup)
    {
        return E_OUTOFMEMORY;
    }

    ZeroMemory(pFixup, sizeof(D3DFixup));

    pFixup->Common = /* initial refcount */ 1
                        | D3DCOMMON_TYPE_FIXUP
                        | D3DCOMMON_D3DCREATED;

    pFixup->Data = (DWORD) (pFixup + 1);
    pFixup->Size = Size;

    *ppFixup = pFixup;

    return S_OK;
}

//------------------------------------------------------------------------------
// D3DFixup_Reset

extern "C"
VOID WINAPI D3DFixup_Reset(
    D3DFixup* pFixup)
{
    COUNT_API(API_D3DFIXUP_RESET);

    CHECK(pFixup, "D3DFixup_Reset");

    if (DBG_CHECK(pFixup->Common & D3DFIXUP_COMMON_IN_BEGIN_END))
    {
        DPF_ERR("Can't Reset while in a Begin/End bracket");
    }

    BlockOnNonSurfaceResource(pFixup);

    pFixup->Next = 0;
    pFixup->Run = 0;
}

//------------------------------------------------------------------------------
// D3DPushBuffer_BeginFixup

extern "C"
VOID WINAPI D3DPushBuffer_BeginFixup(
    D3DPushBuffer* pPushBuffer,
    D3DFixup* pFixup,
    BOOL NoWait)
{
    COUNT_API(API_D3DPUSHBUFFER_BEGINFIXUP);

    CHECK(pPushBuffer, "D3DPushBuffer_BeginFixup");

    if (DBG_CHECK(TRUE))
    {
        if (NoWait > TRUE)
        {
            DPF_ERR("Invalid value for NoWait");
        }
        if (g_pFixup != NULL)
        {
            DPF_ERR("Can't have more than one BeginFixup/EndFixup active at "
                    "once");
        }
        if (pFixup != NULL)
        {
            CHECK(pFixup, "D3DPushBuffer_BeginFixup");

            if (pFixup->Common & D3DFIXUP_COMMON_IN_BEGIN_END)
            {
                DPF_ERR("Fixup object already in a BeginFixup/EndFixup bracket");
            }
        
            pFixup->Common |= D3DFIXUP_COMMON_IN_BEGIN_END;
        }

    #if DBG
        if (g_FixupBracket)
        {
            DPF_ERR("BeginFixup called twice with no intervening EndFixup");
        }
        g_FixupBracket = TRUE;
    #endif
    
    }

    // Stash a copy of the fix-up object for use by the push-buffer modify
    // routines.  If we were nice we would store this in the push-buffer
    // object and wouldn't have it as a global (which prevents multiple 
    // threads from using the modify methods at once),  But the BlockOnResource
    // below requires single-threaded semantics (since it can do a kick-off),
    // and our push-buffer modify routine debug code also has a bunch of 
    // globals.  But I don't think anyone will really mind if they can call
    // this from only one thread at a time.

    g_pFixup = pFixup;

    // Ready the fix-up object so that the next RunPushBuffer call knows
    // where to start reading:

    if (pFixup != NULL)
    {
        pFixup->Run = pFixup->Next;
    }

    // When directly modifying the contents of a WC push-buffer, make sure 
    // it's not in use:

    if ((pFixup == NULL) &&
        !(pPushBuffer->Common & D3DPUSHBUFFER_RUN_USING_CPU_COPY) && 
        !(NoWait))
    {
        BlockOnNonSurfaceResource(pPushBuffer);
    }
}

//------------------------------------------------------------------------------
// D3DPushBuffer_EndFixup

extern "C"
HRESULT WINAPI D3DPushBuffer_EndFixup(
    D3DPushBuffer* pPushBuffer)
{
    COUNT_API(API_D3DPUSHBUFFER_ENDFIXUP);

    CHECK(pPushBuffer, "D3DPushBuffer_EndFixup");

    if (DBG_CHECK(TRUE))
    {
    #if DBG
        if (!g_FixupBracket)
        {
            DPF_ERR("EndFixup called without first calling BeginFixup");
        }
        g_FixupBracket = FALSE;
    #endif
    }

    D3DFixup* pFixup = g_pFixup;

    // We only have to do anything if we were recording into a fix-up
    // object:

    if (pFixup)
    {
        g_pFixup = NULL;
    
        if (DBG_CHECK(TRUE))
        {
            if (!(pFixup->Common & D3DFIXUP_COMMON_IN_BEGIN_END))
            {
                DPF_ERR("End without a matching Begin");
            }
        
            pFixup->Common &= ~D3DFIXUP_COMMON_IN_BEGIN_END;
        }
    
        DWORD* pData = (DWORD*) (pFixup->Data + pFixup->Next);
    
        pFixup->Next += 4;
        if (pFixup->Next > pFixup->Size)
            return D3DERR_BUFFERTOOSMALL;
    
        *pData = 0xffffffff;
    }

    return S_OK;
}

//------------------------------------------------------------------------------
// D3DFixup_GetSize

extern "C"
VOID WINAPI D3DFixup_GetSize(
    D3DFixup* pFixup,
    DWORD *pSize)
{
    COUNT_API(API_D3DFIXUP_GETSIZE);

    CHECK(pFixup, "D3DFixup_GetSize");

    *pSize = pFixup->Next - pFixup->Run;
}

//------------------------------------------------------------------------------
// D3DFixup_GetSpace

extern "C"
VOID WINAPI D3DFixup_GetSpace(
    D3DFixup* pFixup,
    DWORD *pSpace)
{
    COUNT_API(API_D3DFIXUP_GETSPACE);

    CHECK(pFixup, "D3DFixup_GetSpace");

    INT space = (pFixup->Size - pFixup->Next);

    *pSpace = (space > 0) ? space : 0;
}

} // end of namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\rdi.cpp ===
/*==========================================================================
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       rdi.cpp
 *  Content:    implementation for gpu ram data access
 *
 ***************************************************************************/

#include "precomp.hpp"
#include "dm.h"
#include "rdi.h"

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

// Spew out disassembled vertex shader instruction
bool WINAPI DisasmInstr(void *pv);

//------------------------------------------------------------------------------
// D3DRDI_GetRamData

extern "C"
void WINAPI D3DRDI_GetRamData(
    DWORD index,
    DWORD address,
    void *pData,
    DWORD SizeOfData)
{
    if (DBG_CHECK(TRUE))
    {
        if (SizeOfData & 0x3)
        {
            DPF_ERR("SizeOfData must be multiple of 4");
        }
    }

    CMiniport *pMiniPort = &g_pDevice->m_Miniport;
    BYTE *RegBase = (BYTE *)(pMiniPort->m_RegisterBase);

    // from Shaun Ho:
    //
    // > Hi Mike,
    // > In general, we use RDI to handle context switch and therefore your read
    // > should just work. Please keep in mind that the read port
    // > (single ported) is muxed with other address requests, in
    // > addition to the RDI request. This is the reason why we
    // > always emphasize the importance of wait_for_idle for any
    // > rdi read.

    // kickoff pushbuffer
    D3DDevice_KickPushBuffer();

    // Calling D3DDevice_BlockUntilIdle() here seemed to trash some of the results
    // so I switched to TilingUpdateIdle.
    ULONG dmapush;
    pMiniPort->TilingUpdateIdle(&dmapush);

    REG_WR32(RegBase, NV_PGRAPH_RDI_INDEX, ((index << 16) | (address << 2)));

    DWORD *pdwData = (DWORD *)pData;

    SizeOfData /= sizeof(DWORD);

    while(SizeOfData--)
    {
        *pdwData++ = REG_RD32(RegBase, NV_PGRAPH_RDI_DATA);
    }

    // Resume graphics, now that PFB/PGRAPH are consistent
    REG_WR32(RegBase, NV_PFIFO_CACHE1_DMA_PUSH, dmapush);
}

//------------------------------------------------------------------------------
// D3DRDI_GetNextVTXLRUSlot

extern "C"
DWORD WINAPI D3DRDI_GetNextVTXLRUSlot()
{
    DWORD Data;

    D3DRDI_GetRamData(RDI_INDEX_IDX_FMT, 33, &Data, sizeof(Data));
    return Data >> 24;
}

//------------------------------------------------------------------------------
// D3DRDI_GetVTXFileEntry

extern "C"
void WINAPI D3DRDI_GetVTXFileEntry(
    DWORD index,
    D3DRDI_VTX_FILEENTRY *pentry)
{
    // Read in the first 8 DWORDS
    D3DRDI_GetRamData(RDI_INDEX_VTX_FILE0, index * 8, pentry, 8 * sizeof(DWORD));

    // Read in the next 20 DWORDS
    D3DRDI_GetRamData(RDI_INDEX_VTX_FILE1, index * 20, pentry->pos, 20 * sizeof(DWORD));
}

//------------------------------------------------------------------------------
// D3DRDI_GetPAEntry

extern "C"
void WINAPI D3DRDI_GetPAEntry(
    DWORD index,
    D3DRDI_PAENTRY *pentry)
{
    D3DRDI_GetRamData(RDI_INDEX_CAS0 + index, 0, pentry, sizeof(D3DRDI_PAENTRY));
}

/*
 * Helper dump routines
 */
VOID SpewFloat(
    void *pv)
{
    char szBuf[10];
    float f = *(float *)pv;
    long l = FloatToLong(f);

    f -= l;

    for(int i = 0; i < 6; i++)
    {
        f *= 10;
        DWORD dw = (DWORD)FloatToLong(f);

        szBuf[i] = (char)(dw + '0');

        f -= dw;
    }
    szBuf[i] = 0;

    DbgPrint("%li.%s ", l, szBuf);
}

//------------------------------------------------------------------------------
// D3DRDI_DumpVTXFileEntry

extern "C"
void WINAPI D3DRDI_DumpVTXFileEntry(
    DWORD index)
{
    D3DRDI_VTX_FILEENTRY vtxentry;

    D3DRDI_GetVTXFileEntry(index, &vtxentry);

    DbgPrint("%d\n", index);

    DbgPrint("  xyzw: ");
    for(int ipos = 0; ipos < 4; ipos++)
        SpewFloat(&vtxentry.pos[ipos]);
    DbgPrint("\n");

    DbgPrint("  xyzw: 0x%08lx, 0x%08lx, 0x%08lx, 0x%08lx\n",
        vtxentry.pos[0], vtxentry.pos[1], vtxentry.pos[2], vtxentry.pos[3]);

    DbgPrint("  diff: 0x%08lx  spec: 0x%08lx\n", vtxentry.diff, vtxentry.spec);
    DbgPrint("  bdiff: 0x%08lx  bspec: 0x%08lx\n", vtxentry.bdiff, vtxentry.bspec);

    DbgPrint("  fog: ");
    SpewFloat(&vtxentry.fog);
    DbgPrint("0x%08lx\n", vtxentry.fog);

    DbgPrint("  ptsize: 0x%08lx\n", vtxentry.ptsize);

    for(int tex = 0; tex < 4; tex++)
    {
        DbgPrint("  t%d: ", tex);

        for(int i = 0; i < 4; i++)
            SpewFloat(&vtxentry.tex[tex][i]);

        DbgPrint("\n");
    }

    DbgPrint("  mask: 0x%08lx  unused: 0x%08lx\n",
        vtxentry.mask, vtxentry.unused);
}

//------------------------------------------------------------------------------
// D3DRDI_DumpVTXProgram

extern "C"
void WINAPI D3DRDI_DumpVTXProgram(
    DWORD index,
    DWORD length)
{
    DWORD rgInstr[VSHADER_PROGRAM_SLOTS][4];

    index = min(VSHADER_PROGRAM_SLOTS - 1, index);
    length = min(VSHADER_PROGRAM_SLOTS - index, length);

    D3DRDI_GetRamData(RDI_INDEX_XL_PROGRAM, index * 4, rgInstr, length * 4 * sizeof(DWORD));

    for(DWORD i = 0; i < length; i++)
    {
        DbgPrint("% 3d: ", index + i);

        DisasmInstr(rgInstr[i]);
    }
}

// The user gets to use constant registers -96 through 95 (or 0 through 95
// if only using 96 registers).  We add 96 before giving those register
// values to the hardware:

#define VSHADER_CONSTANT_NUM 192
#define VSHADER_CONSTANT_BIAS 96

//------------------------------------------------------------------------------
// D3DRDI_DumpVTXConstants

extern "C"
void WINAPI D3DRDI_DumpVTXConstants(
    DWORD index,
    DWORD count)
{
    DWORD rgConsts[VSHADER_CONSTANT_NUM][4];

    index = min(VSHADER_CONSTANT_NUM - 1, index);
    count = min(VSHADER_CONSTANT_NUM - index, count);

    D3DRDI_GetRamData(RDI_INDEX_VTX_CONSTANTS0, index * 4, rgConsts, count * 4 * sizeof(DWORD));

    for(DWORD var = 0; var < count; var++)
    {
        DbgPrint("%03d: ", index + var);

        for(int i = 3; i >= 0; i--)
        {
            SpewFloat(&rgConsts[var][i]);
        }

        DbgPrint("\n");
    }
}

//------------------------------------------------------------------------------
// D3DRDI_DumpVAB

extern "C"
void WINAPI D3DRDI_DumpVAB()
{
#define VAB_SLOTS 17
    DWORD rgvab[VAB_SLOTS][4];

    D3DRDI_GetRamData(RDI_INDEX_XL_VAB, 0, rgvab, VAB_SLOTS * 4 * sizeof(DWORD));

    for(DWORD slot = 0; slot < VAB_SLOTS; slot++)
    {
        DbgPrint("%02d: ", slot);

        for(int i = 3; i >= 0; i--)
            DbgPrint("0x%08lx ", rgvab[slot][i]);

        DbgPrint("\n     (");

        for(int i = 3; i >= 0; i--)
            SpewFloat(&rgvab[slot][i]);

        DbgPrint(")\n");
    }
}

//------------------------------------------------------------------------------
// D3DRDI_DumpVAB

void WINAPI D3DRDI_DumpPA()
{
    for(int cas = 0; cas < 3; cas++)
    {
        D3DRDI_PAENTRY casentry = {0};

        D3DRDI_GetPAEntry(cas, &casentry);

        DbgPrint("CAS %d\n", cas);

        DbgPrint("  xyzw: ");
        for(int i = 0; i < 4; i++)
            SpewFloat(&casentry.pos[i]);
        DbgPrint("\n");

        DbgPrint("  xyzw: 0x%08lx, 0x%08lx, 0x%08lx, 0x%08lx\n",
            casentry.pos[0], casentry.pos[1], casentry.pos[2], casentry.pos[3]);

        DbgPrint("  z: 0x%08lx  w: 0x%08lx\n", casentry.z, casentry.w);
        DbgPrint("  diff: 0x%08lx  spec: 0x%08lx\n", casentry.diff, casentry.spec);
        DbgPrint("  bdiff: 0x%08lx  bspec: 0x%08lx\n", casentry.bdiff, casentry.bspec);

        DbgPrint("  fog: ");
        SpewFloat(&casentry.fog);
        DbgPrint("0x%08lx\n", casentry.fog);

        DbgPrint("  ptsize: 0x%08lx\n", casentry.ptsize);

        for(int tex = 0; tex < 4; tex++)
        {
            DbgPrint("  t%d: ", tex);

            for(int i = 0; i < 4; i++)
                SpewFloat(&casentry.tex[tex][i]);

            DbgPrint("\n");
        }

        DbgPrint("  unknown:");
        for(i = 0; i < 4; i++)
            DbgPrint(" 0x%08lx", casentry.unknown[i]);
        DbgPrint("\n");
    }
}

// Turn off warning about zero length array
#pragma warning(push)
#pragma warning(disable: 4200)

#pragma pack(push, 1)

struct VINSTR
{
    DWORD eos:1;     /* 0:00 last instruction */
    DWORD cin:1;     /* 0:01 ctx indexed address */
    DWORD  om:1;     /* 0:02 output mux */
    DWORD  oc:9;     /* 0:03 output write control */
    DWORD owm:4;     /* 0:12 output write mask */
    DWORD swm:4;     /* 0:16 secondary register write mask */
    DWORD  rw:4;     /* 0:20 register write */
    DWORD rwm:4;     /* 0:24 primary register write mask */
    DWORD cmx:2;     /* 0:28 c mux (NA,r1,v,c) */
    DWORD crrlo:2;   /* 0:30 c register read (low part) */

    DWORD crrhi:2;   /* 0:30 of c register read (hi part) */
    DWORD cws:2;     /* 0:30 c register read */
    DWORD czs:2;     /* 1:02 c w swizzle */
    DWORD cys:2;     /* 1:04 c z swizzle */
    DWORD cxs:2;     /* 1:06 c y swizzle */
    DWORD cne:1;     /* 1:08 c x swizzle */
    DWORD bmx:2;     /* 1:10 c negate */
    DWORD brr:4;     /* 1:11 b mux (NA,r1,v,c) */
    DWORD bws:2;     /* 1:13 b register read */
    DWORD bzs:2;     /* 1:17 b w swizzle */
    DWORD bys:2;     /* 1:19 b z swizzle */
    DWORD bxs:2;     /* 1:21 b y swizzle */
    DWORD bne:1;     /* 1:23 b x swizzle */
    DWORD amx:2;     /* 1:25 b negate */
    DWORD arr:4;     /* 1:26 a mux (NA,r0,v,c) */

    DWORD aws:2;     /* 2:00 a w swizzle */
    DWORD azs:2;     /* 2:02 a z swizzle */
    DWORD ays:2;     /* 2:04 a y swizzle */
    DWORD axs:2;     /* 2:06 a x swizzle */
    DWORD ane:1;     /* 2:08 a negate */
    DWORD  va:4;     /* 2:09 ibuffer address */
    DWORD  ca:8;     /* 2:13 ctx address */
    DWORD mac:4;     /* 2:21 MLU/ALU op */
    DWORD ilu:7;     /* 2:25 ILU op */

    DWORD dwPad;
};

#pragma pack(pop)
#pragma warning(pop)

static const bool kMacUsesA[] = {
    false,  // NV_IGRAPH_XF_V_NOP        0x00
    true,   // NV_IGRAPH_XF_V_MOV        0x01
    true,   // NV_IGRAPH_XF_V_MUL        0x02
    true,   // NV_IGRAPH_XF_V_ADD        0x03
    true,   // NV_IGRAPH_XF_V_MAD        0x04
    true,   // NV_IGRAPH_XF_V_DP3        0x05
    true,   // NV_IGRAPH_XF_V_DPH        0x06
    true,   // NV_IGRAPH_XF_V_DP4        0x07
    true,   // NV_IGRAPH_XF_V_DST        0x08
    true,   // NV_IGRAPH_XF_V_MIN        0x09
    true,   // NV_IGRAPH_XF_V_MAX        0x0a
    true,   // NV_IGRAPH_XF_V_SLT        0x0b
    true,   // NV_IGRAPH_XF_V_SGE        0x0c
    true,   // NV_IGRAPH_XF_V_ARL        0x0d
    false,  // ??
};
static const bool kMacUsesB[] = {
    false,  // NV_IGRAPH_XF_V_NOP        0x00
    false,  // NV_IGRAPH_XF_V_MOV        0x01
    true,   // NV_IGRAPH_XF_V_MUL        0x02
    false,  // NV_IGRAPH_XF_V_ADD        0x03
    true,   // NV_IGRAPH_XF_V_MAD        0x04
    true,   // NV_IGRAPH_XF_V_DP3        0x05
    true,   // NV_IGRAPH_XF_V_DPH        0x06
    true,   // NV_IGRAPH_XF_V_DP4        0x07
    true,   // NV_IGRAPH_XF_V_DST        0x08
    true,   // NV_IGRAPH_XF_V_MIN        0x09
    true,   // NV_IGRAPH_XF_V_MAX        0x0a
    true,   // NV_IGRAPH_XF_V_SLT        0x0b
    true,   // NV_IGRAPH_XF_V_SGE        0x0c
    false,  // NV_IGRAPH_XF_V_ARL        0x0d
    false,  // ??
};

static const bool kMacUsesC[] = {
    false,  // NV_IGRAPH_XF_V_NOP        0x00
    false,  // NV_IGRAPH_XF_V_MOV        0x01
    false,  // NV_IGRAPH_XF_V_MUL        0x02
    true,   // NV_IGRAPH_XF_V_ADD        0x03
    true,   // NV_IGRAPH_XF_V_MAD        0x04
    false,  // NV_IGRAPH_XF_V_DP3        0x05
    false,  // NV_IGRAPH_XF_V_DPH        0x06
    false,  // NV_IGRAPH_XF_V_DP4        0x07
    false,  // NV_IGRAPH_XF_V_DST        0x08
    false,  // NV_IGRAPH_XF_V_MIN        0x09
    false,  // NV_IGRAPH_XF_V_MAX        0x0a
    false,  // NV_IGRAPH_XF_V_SLT        0x0b
    false,  // NV_IGRAPH_XF_V_SGE        0x0c
    false,  // NV_IGRAPH_XF_V_ARL        0x0d
    false,  // ??
    false,  // ??
};

// inversion unit operation
static const char *iluOps[] = {
    "nop",  //  0x0
    "mov",  //  0x1
    "rcp",  //  0x2
    "rcc",  //  0x3
    "rsq",  //  0x4
    "exp",  //  0x5
    "log",  //  0x6
    "lit",  //  0x7
    "??8",
    "??9",
    "??a",
    "??b",
    "??c",
    "??d",
    "??e",
    "??f"
};

// multiply / add operation
static const char *macOps[] = {
    "nop",  //      0x0
    "mov",  //      0x1
    "mul",  //      0x2
    "add",  //      0x3
    "mad",  //      0x4
    "dp3",  //      0x5
    "dph",  //      0x6
    "dp4",  //      0x7
    "dst",  //      0x8
    "min",  //      0x9
    "max",  //      0xA
    "slt",  //      0xB
    "sge",  //      0xC
    "arl",  //      0xD
    "??e",
    "??f",
};

//=========================================================================
//
//=========================================================================
static const char *RegisterWriteMask(DWORD m)
{
    static const char *masks[] =
    {
        ".null",
        ".w",
        ".z",
        ".zw",
        ".y",
        ".yw",
        ".yz",
        ".yzw",
        ".x",
        ".xw",
        ".xz",
        ".xzw",
        ".xy",
        ".xyw",
        ".xyz",
        "",         // all
        "error"
    };

    return masks[min(m, ARRAYSIZE(masks) - 1)];
}

//=========================================================================
//
//=========================================================================
void ParseOut(VINSTR *pinstr)
{
    static const char *rgszOut[] =
    {
        "oPos",     // 0
        "?o1",      // 1
        "?o2",      // 2
        "oD0",      // 3
        "oD1",      // 4
        "oFog",     // 5
        "oPts",     // 6
        "oB0",      // 7
        "oB1",      // 8
        "oT0",      // 9
        "oT1",      // 10
        "oT2",      // 11
        "oT3",      // 12
        "?"
    };

    bool oc_output = (pinstr->oc & 0x0100) != 0;
    DWORD oc_index = pinstr->oc & 0xff;

    if(oc_output)
    {
        oc_index = min(oc_index, ARRAYSIZE(rgszOut) - 1);
        DbgPrint("%s%s", rgszOut[oc_index], RegisterWriteMask(pinstr->owm));
    }
    else
    {
        DbgPrint("c[%d]%s", oc_index - 96, RegisterWriteMask(pinstr->owm));
    }
}

//=========================================================================
//
//=========================================================================
void ParseMux(int mx, int rr, int ws, int zs, int ys, int xs, int ne,
    VINSTR *pinstr)
{
    static const char s[] = "xyzw"; // Swizzle
    static const char m[] = "?rvc";

    if(ne)
        DbgPrint("-");

    DbgPrint("%c", m[mx]);

    switch(mx)
    {
    default:
    case 0:
        DbgPrint("error");
        break;
    case 1:
        DbgPrint("%d", rr);
        break;
    case 2:
        DbgPrint("%d", pinstr->va);
        break;
    case 3:
        if(pinstr->cin)
            DbgPrint("a0.x+");

        DbgPrint("[%d]", pinstr->ca - 96);
        break;
    }

    if(xs == 0 && ys == 1 && zs == 2 && ws == 3)
        ;                       // print nothing for .xyzw
    else if(xs == ys && zs == ws && xs == zs)
        DbgPrint(".%c", s[xs]);   // print .x for .xxxx, etc.
    else
        DbgPrint(".%c%c%c%c", s[xs], s[ys], s[zs], s[ws]);

}

//=========================================================================
//
//=========================================================================
bool WINAPI DisasmInstr(void *pv)
{
    VINSTR *pinstr = (VINSTR *)pv;

    if(pinstr->mac || !pinstr->ilu)
    {
        // MAC instruction
        DbgPrint("%s ", macOps[pinstr->mac & 0xf]);

        // check if instruction has two destinations
        bool ftwodest = (pinstr->owm && !pinstr->om) && pinstr->rwm;

        if(ftwodest)
            DbgPrint("{");

        if(pinstr->mac == 0xd)
        {
            // arl is special case
            DbgPrint("a0.x");
        }
        else if(pinstr->owm && !pinstr->om)
        {
            ParseOut(pinstr);
        }

        if(ftwodest)
            DbgPrint(", ");

        if(pinstr->rwm)
        {
            DbgPrint("r%d%s", pinstr->rw, RegisterWriteMask(pinstr->rwm));
        }

        if(ftwodest)
            DbgPrint("}");

        if(kMacUsesA[pinstr->mac & 0xf])
        {
            DbgPrint(", ");
            ParseMux(
                pinstr->amx,        /* 1:26 a mux (NA,r0,v,c) */
                pinstr->arr,        /* 1:28 a register read */
                pinstr->aws,        /* 2:00 a w swizzle */
                pinstr->azs,        /* 2:02 a z swizzle */
                pinstr->ays,        /* 2:04 a y swizzle */
                pinstr->axs,        /* 2:06 a x swizzle */
                pinstr->ane,        /* 2:08 a negate */
                pinstr);
        }

        if(kMacUsesB[pinstr->mac & 0xf])
        {
            DbgPrint(", ");
            ParseMux(
                pinstr->bmx,        /* 1:11 b mux (NA,r1,v,c) */
                pinstr->brr,        /* 1:13 b register read */
                pinstr->bws,        /* 1:17 b w swizzle */
                pinstr->bzs,        /* 1:19 b z swizzle */
                pinstr->bys,        /* 1:21 b y swizzle */
                pinstr->bxs,        /* 1:23 b x swizzle */
                pinstr->bne,        /* 1:25 b negate */
                pinstr);
        }

        if(kMacUsesC[pinstr->mac & 0xf])
        {
            DbgPrint(", ");
            ParseMux(
                pinstr->cmx,        /* 0:28 c mux (NA,r1,v,c) */
                (pinstr->crrhi << 2) | pinstr->crrlo,        /* 0:30 c register read */
                pinstr->cws,        /* 1:02 c w swizzle */
                pinstr->czs,        /* 1:04 c z swizzle */
                pinstr->cys,        /* 1:06 c y swizzle */
                pinstr->cxs,        /* 1:08 c x swizzle */
                pinstr->cne,        /* 1:10 c negate */
                pinstr);
        }
    }

    if(pinstr->ilu)
    {
        // indent paired instruction
        if(pinstr->mac)
            DbgPrint("\n    ");

        DbgPrint("%s ", iluOps[pinstr->ilu & 0xf]);

        if(pinstr->swm)
        {
            // When this is a double opcode, and the ilu is writing to
            // a register, then the register has to be 1.
            DWORD ilu_rw = (pinstr->mac && pinstr->ilu) ? 1 : pinstr->rw;

            DbgPrint("r%d%s", ilu_rw, RegisterWriteMask(pinstr->swm));
        }

        if(pinstr->owm && pinstr->om)
        {
            if(pinstr->swm)
                DbgPrint(", ");

            ParseOut(pinstr);
        }

        DbgPrint(", ");
        ParseMux(
            pinstr->cmx,        /* 0:28 c mux (NA,r1,v,c) */
            (pinstr->crrhi << 2) | pinstr->crrlo,        /* 0:30 c register read */
            pinstr->cws,        /* 1:02 c w swizzle */
            pinstr->czs,        /* 1:04 c z swizzle */
            pinstr->cys,        /* 1:06 c y swizzle */
            pinstr->cxs,        /* 1:08 c x swizzle */
            pinstr->cne,        /* 1:10 c negate */
            pinstr);
    }

    DbgPrint("; %s \n", pinstr->eos ? "* eos *" : "");

    return pinstr->eos;
}

} // end of namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\pshader.cpp ===
/*============================================================================
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       pshader.cpp
 *  Content:    Pixel shader implementation.
 *
 ****************************************************************************/
 
#include "precomp.hpp"

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

// ---------------------------------------------------
// Pixel Shader register validation code
// ---------------------------------------------------

#if DBG
#define GETFIELD(value, upper, lower) \
    ((value >> lower) & ((2L << (upper-lower))-1))

#define ERRBADARG(err1, err2) \
    { \
        DbgPrint("%s: %s", err1, err2); \
        DPF_ERR(""); \
        return FALSE; \
    } 

#define CHECKZERO(value, upper, lower, err1, err2) \
    { \
        if(GETFIELD(value, upper, lower) != 0) \
            ERRBADARG(err1, err2) \
    }

#define CHECKENUM(value, upper, lower, valid, err1, err2) \
    { \
        if(!((valid >> GETFIELD(value, upper, lower)) & 0x1)) \
            ERRBADARG(err1, err2) \
    }

// The following constants define valid enumerants for a group of fields
// The lsb corresponds to enum 0, the next bit corresponds to enum 1, etc.
#define INPUT_SRC_REG      0x3f3fL // valid combiner input source registers
#define OUTPUT_MAPPING     0x005fL // valid output mapping enumerants
#define OUTPUT_DST_REG     0x3f31L // valid output destination registers
#define ABCD_INPUT_SRC_REG 0xff3fL // final combiner input source registers ABCD
#define EFG_INPUT_SRC_REG  0x3f3fL // final combiner input source register EFG
#define TEXTURE_MODE_STG0 0x0003fL // texture modes for stage 0
#define TEXTURE_MODE_STG1 0x380ffL // texture modes for stage 1
#define TEXTURE_MODE_STG2 0x38fffL // texture modes for stage 2
#define TEXTURE_MODE_STG3 0x5f7ffL // texture modes for stage 3
#define COMBINER_COUNT     0x01feL // valid combiner count values
#define TRUE_FALSE         0x0003L // only 0 and 1 are valid
#define DOT_MAPPING        0x00ffL // 0-7 are valid

    BOOL ValidCombinerInputs(DWORD val, char *err)
    {
        CHECKENUM(val, 27, 24, INPUT_SRC_REG, err, "Invalid A Register");
        CHECKENUM(val, 19, 16, INPUT_SRC_REG, err, "Invalid B Register");
        CHECKENUM(val, 11,  8, INPUT_SRC_REG, err, "Invalid C Register");
        CHECKENUM(val,  3,  0, INPUT_SRC_REG, err, "Invalid D Register");
        return TRUE;
    }

    BOOL ValidAlphaOutputs(DWORD val, char *err)
    {
        CHECKZERO(val, 31, 18, err, "31:18 must be 0");
        CHECKZERO(val, 13, 12, err, "13:12 must be 0");
        CHECKENUM(val, 17, 15, OUTPUT_MAPPING, err, "Invalid output mapping");
        CHECKENUM(val, 11,  8, OUTPUT_DST_REG, err, "Invalid Sum register");
        CHECKENUM(val,  7,  4, OUTPUT_DST_REG, err, "Invalid AB register");
        CHECKENUM(val,  3,  0, OUTPUT_DST_REG, err, "Invalid CD register");
        return TRUE;
    }

    BOOL ValidRGBOutputs(DWORD val, char *err)
    {
        CHECKZERO(val, 31, 20, err, "31:20 must be 0");
        CHECKENUM(val, 17, 15, OUTPUT_MAPPING, err, "Invalid output mapping");
        CHECKENUM(val, 11,  8, OUTPUT_DST_REG, err, "Invalid Sum register");
        CHECKENUM(val,  7,  4, OUTPUT_DST_REG, err, "Invalid AB register");
        CHECKENUM(val,  3,  0, OUTPUT_DST_REG, err, "Invalid CD register");
        return TRUE;
    }

    BOOL ValidFinalCombinerABCD(DWORD val, char *err)
    {
        DWORD src;
        // if A source i SUM or PROD, A_Alpha must be 0
        src = GETFIELD(val, 27, 24);
        if((src == 0xe) || (src == 0xf))
            CHECKZERO(val, 28, 28, err, "Alpha invalid for SUM or PROD on A");

        // if B source i SUM or PROD, B_Alpha must be 0
        src = GETFIELD(val, 19, 16);
        if((src == 0xe) || (src == 0xf))
            CHECKZERO(val, 20, 20, err, "Alpha invalid for SUM or PROD on B");

        // if C source i SUM or PROD, C_Alpha must be 0
        src = GETFIELD(val, 11,  8);
        if((src == 0xe) || (src == 0xf))
            CHECKZERO(val, 12, 12, err, "Alpha invalid for SUM or PROD on C");

        // if D source i SUM or PROD, D_Alpha must be 0
        src = GETFIELD(val,  3,  0);
        if((src == 0xe) || (src == 0xf))
            CHECKZERO(val,  4,  4, err, "Alpha invalid for SUM or PROD on D");

        CHECKENUM(val, 27, 24, ABCD_INPUT_SRC_REG, err, "Invalid A Register");
        CHECKENUM(val, 19, 16, ABCD_INPUT_SRC_REG, err, "Invalid B Register");
        CHECKENUM(val, 11,  8, ABCD_INPUT_SRC_REG, err, "Invalid C Register");
        CHECKENUM(val,  3,  0, ABCD_INPUT_SRC_REG, err, "Invalid D Register");
        CHECKENUM(val, 31, 29, TRUE_FALSE, err, "Invalid input mapping Reg A");
        CHECKENUM(val, 23, 21, TRUE_FALSE, err, "Invalid input mapping Reg B");
        CHECKENUM(val, 15, 13, TRUE_FALSE, err, "Invalid input mapping Reg C");
        CHECKENUM(val,  7,  5, TRUE_FALSE, err, "Invalid input mapping Reg D");
        return TRUE;
    }

    BOOL ValidFinalCombinerEFG(DWORD val, char *err)
    {
        CHECKENUM(val, 31, 29, TRUE_FALSE, err, "Invalid input mapping Reg E");
        CHECKENUM(val, 23, 21, TRUE_FALSE, err, "Invalid input mapping Reg F");
        CHECKENUM(val, 15, 13, TRUE_FALSE, err, "Invalid input mapping Reg G");
        CHECKZERO(val,  4,  0, err, "4:0 must be 0");
        CHECKENUM(val, 27, 24, EFG_INPUT_SRC_REG, err, "Invalid E Register");
        CHECKENUM(val, 19, 16, EFG_INPUT_SRC_REG, err, "Invalid F Register");
        CHECKENUM(val, 11,  8, EFG_INPUT_SRC_REG, err, "Invalid G Register");
        return TRUE;
    }

    BOOL ValidTextureModes(DWORD val, char *err)
    {
        CHECKENUM(val,  4,  0, TEXTURE_MODE_STG0, err, "Invalid Stg 0 Mode");
        CHECKENUM(val,  9,  5, TEXTURE_MODE_STG1, err, "Invalid Stg 1 Mode");
        CHECKENUM(val, 14, 10, TEXTURE_MODE_STG2, err, "Invalid Stg 2 Mode");
        CHECKENUM(val, 19, 15, TEXTURE_MODE_STG3, err, "Invalid Stg 3 Mode");
        CHECKZERO(val, 31, 20, err, "31:20 must be 0");
        
        // inter-field checks
        DWORD Stage0 = GETFIELD(val,  4,  0);
        DWORD Stage1 = GETFIELD(val,  9,  5);
        DWORD Stage2 = GETFIELD(val, 14, 10);
        DWORD Stage3 = GETFIELD(val, 19, 15);

        if(((Stage1 == PS_TEXTUREMODES_BUMPENVMAP) || 
            (Stage1 == PS_TEXTUREMODES_BUMPENVMAP_LUM) ||
            (Stage1 == PS_TEXTUREMODES_DPNDNT_AR) || 
            (Stage1 == PS_TEXTUREMODES_DPNDNT_GB) || 
            (Stage1 == PS_TEXTUREMODES_DOTPRODUCT)) &&
           ((Stage0 == PS_TEXTUREMODES_CLIPPLANE) ||
            (Stage0 == PS_TEXTUREMODES_NONE)))
            ERRBADARG(err, "Stg1 mode requires different Stg0 mode");

        if((Stage2 == PS_TEXTUREMODES_BRDF) && 
           ((Stage0 == PS_TEXTUREMODES_NONE) || 
            (Stage0 == PS_TEXTUREMODES_CLIPPLANE)))
            ERRBADARG(err, "Stg2 mode requires different Stg0 mode");

        if((Stage3 == PS_TEXTUREMODES_BRDF) && 
           ((Stage1 == PS_TEXTUREMODES_NONE) || 
            (Stage1 == PS_TEXTUREMODES_CLIPPLANE) || 
            (Stage1 == PS_TEXTUREMODES_DOTPRODUCT)))
            ERRBADARG(err, "Stg3 mode requires different Stg1 mode");

        if((Stage2 == PS_TEXTUREMODES_DOT_ST) && (Stage1 != PS_TEXTUREMODES_DOTPRODUCT))
            ERRBADARG(err, "Stg2 mode requires DOTPRODUCT in Stg1");

        if((Stage3 == PS_TEXTUREMODES_DOT_ST) && (Stage2 != PS_TEXTUREMODES_DOTPRODUCT))
            ERRBADARG(err, "Stg3 mode requires DOTPRODUCT in Stg2");

        if((Stage2 == PS_TEXTUREMODES_DOT_ZW) && (Stage1 != PS_TEXTUREMODES_DOTPRODUCT))
            ERRBADARG(err, "Stg2 mode requires DOTPRODUCT in Stg1");

        if((Stage3 == PS_TEXTUREMODES_DOT_ZW) && (Stage2 != PS_TEXTUREMODES_DOTPRODUCT))
            ERRBADARG(err, "Stg3 mode requires DOTPRODUCT in Stg2");

        if((Stage3 == PS_TEXTUREMODES_DOT_STR_3D) &&
           ((Stage2 != PS_TEXTUREMODES_DOTPRODUCT) || 
            (Stage1 != PS_TEXTUREMODES_DOTPRODUCT)))
            ERRBADARG(err, "Stg3 mode requires DOTPRODUCT in Stg2 or Stg1");

        if((Stage3 == PS_TEXTUREMODES_DOT_STR_CUBE) &&
           ((Stage2 != PS_TEXTUREMODES_DOTPRODUCT) || 
            (Stage1 != PS_TEXTUREMODES_DOTPRODUCT)))
            ERRBADARG(err, "Stg3 mode requires DOTPRODUCT in Stg2 or Stg1");

        if(((Stage3 == PS_TEXTUREMODES_DOT_RFLCT_SPEC) ||
            (Stage3 == PS_TEXTUREMODES_DOT_RFLCT_SPEC_CONST)) &&
           ((Stage2 != PS_TEXTUREMODES_DOTPRODUCT) &&
            (Stage2 != PS_TEXTUREMODES_DOT_RFLCT_DIFF)))
            ERRBADARG(err, "Stg3 mode requires DOTPRODUCT or DOT_RFLCT_DIFF in Stg2");

        if((Stage2 == PS_TEXTUREMODES_DOT_RFLCT_DIFF) &&
           ((Stage3 != PS_TEXTUREMODES_DOT_RFLCT_SPEC) &&
            (Stage3 != PS_TEXTUREMODES_DOT_RFLCT_SPEC_CONST)))
            ERRBADARG(err, "Stg2 mode requires DOT_RFLCT_SPEC or DOT_RFLCT_SPEC_CONST in Stg 3");

        if(((Stage3 == PS_TEXTUREMODES_DOT_RFLCT_SPEC) ||
            (Stage3 == PS_TEXTUREMODES_DOT_RFLCT_SPEC_CONST)) &&
           (Stage1 != PS_TEXTUREMODES_DOTPRODUCT))
            ERRBADARG(err, "Stg 3 mode requires DOTPRODUCT in Stg 1");

        return TRUE;
    }

    BOOL ValidInputTexture(DWORD val, char *err)
    {
        CHECKZERO(val, 15,  0, err, "15:0 must be 0");
        CHECKENUM(val, 19, 16, 0x3L, err, "Invalid input texture in stg 2"); // 0 and 1 valid
        CHECKENUM(val, 23, 20, 0x7L, err, "Invalid input texture in stg 3"); // 0, 1, and 2 valid
        CHECKZERO(val, 31, 24, err, "31:24 must be 0");
        return TRUE;
    }

    BOOL ValidCombinerCount(DWORD val, char *err)
    {
        CHECKENUM(val,  7,  0, COMBINER_COUNT, err, "Invalid Combiner Count");
        CHECKENUM(val, 11,  8, TRUE_FALSE, err, "Invalid Mux bit");
        CHECKENUM(val, 15, 12, TRUE_FALSE, err, "Invalid Separate C0 flag");
        CHECKZERO(val, 31, 17, err, "31:17 must be 0");
        return TRUE;
    }

    BOOL ValidCompareMode(DWORD val, char *err)
    {
        CHECKZERO(val, 31, 16, err, "31:16 must be 0\n");
        return TRUE;
    }

    BOOL ValidDotMapping(DWORD val, char *err)
    {
        CHECKENUM(val,  3,  0, DOT_MAPPING, err, "Stage 1 invalid");
        CHECKENUM(val,  7,  4, DOT_MAPPING, err, "Stage 2 invalid");
        CHECKENUM(val, 11,  8, DOT_MAPPING, err, "Stage 3 invalid");
        CHECKZERO(val, 31, 12, err, "31:12 must be 0");
        return TRUE;
    }

    BOOL ValidFinalCombinerConstants(DWORD val, char *err)
    {
        CHECKZERO(val, 31,  9, err, "31:9 must be 0");
        return TRUE;
    }

#endif

#define PSDEFCHECKS(pPSDef) \
    !ValidCombinerInputs(pPSDef->PSAlphaInputs[0], "PSAlphaInputs[0]") || \
    !ValidCombinerInputs(pPSDef->PSAlphaInputs[1], "PSAlphaInputs[1]") || \
    !ValidCombinerInputs(pPSDef->PSAlphaInputs[2], "PSAlphaInputs[2]") || \
    !ValidCombinerInputs(pPSDef->PSAlphaInputs[3], "PSAlphaInputs[3]") || \
    !ValidCombinerInputs(pPSDef->PSAlphaInputs[4], "PSAlphaInputs[4]") || \
    !ValidCombinerInputs(pPSDef->PSAlphaInputs[5], "PSAlphaInputs[5]") || \
    !ValidCombinerInputs(pPSDef->PSAlphaInputs[6], "PSAlphaInputs[6]") || \
    !ValidCombinerInputs(pPSDef->PSAlphaInputs[7], "PSAlphaInputs[7]") || \
    !ValidCombinerInputs(pPSDef->PSRGBInputs[0], "PSRGBInputs[0]") || \
    !ValidCombinerInputs(pPSDef->PSRGBInputs[1], "PSRGBInputs[1]") || \
    !ValidCombinerInputs(pPSDef->PSRGBInputs[2], "PSRGBInputs[2]") || \
    !ValidCombinerInputs(pPSDef->PSRGBInputs[3], "PSRGBInputs[3]") || \
    !ValidCombinerInputs(pPSDef->PSRGBInputs[4], "PSRGBInputs[4]") || \
    !ValidCombinerInputs(pPSDef->PSRGBInputs[5], "PSRGBInputs[5]") || \
    !ValidCombinerInputs(pPSDef->PSRGBInputs[6], "PSRGBInputs[6]") || \
    !ValidCombinerInputs(pPSDef->PSRGBInputs[7], "PSRGBInputs[7]") || \
    !ValidAlphaOutputs(pPSDef->PSAlphaOutputs[0], "PSAlphaOutputs[0]") || \
    !ValidAlphaOutputs(pPSDef->PSAlphaOutputs[1], "PSAlphaOutputs[1]") || \
    !ValidAlphaOutputs(pPSDef->PSAlphaOutputs[2], "PSAlphaOutputs[2]") || \
    !ValidAlphaOutputs(pPSDef->PSAlphaOutputs[3], "PSAlphaOutputs[3]") || \
    !ValidAlphaOutputs(pPSDef->PSAlphaOutputs[4], "PSAlphaOutputs[4]") || \
    !ValidAlphaOutputs(pPSDef->PSAlphaOutputs[5], "PSAlphaOutputs[5]") || \
    !ValidAlphaOutputs(pPSDef->PSAlphaOutputs[6], "PSAlphaOutputs[6]") || \
    !ValidAlphaOutputs(pPSDef->PSAlphaOutputs[7], "PSAlphaOutputs[7]") || \
    !ValidRGBOutputs(pPSDef->PSRGBOutputs[0], "PSRGBOutputs[0]") || \
    !ValidRGBOutputs(pPSDef->PSRGBOutputs[1], "PSRGBOutputs[1]") || \
    !ValidRGBOutputs(pPSDef->PSRGBOutputs[2], "PSRGBOutputs[2]") || \
    !ValidRGBOutputs(pPSDef->PSRGBOutputs[3], "PSRGBOutputs[3]") || \
    !ValidRGBOutputs(pPSDef->PSRGBOutputs[4], "PSRGBOutputs[4]") || \
    !ValidRGBOutputs(pPSDef->PSRGBOutputs[5], "PSRGBOutputs[5]") || \
    !ValidRGBOutputs(pPSDef->PSRGBOutputs[6], "PSRGBOutputs[6]") || \
    !ValidRGBOutputs(pPSDef->PSRGBOutputs[7], "PSRGBOutputs[7]") || \
    !ValidFinalCombinerABCD(pPSDef->PSFinalCombinerInputsABCD, "PSFinalCombinerInputsABCD") || \
    !ValidFinalCombinerEFG(pPSDef->PSFinalCombinerInputsEFG, "PSFinalCombinerInputsEFG") || \
    !ValidTextureModes(pPSDef->PSTextureModes, "PSTextureModes") || \
    !ValidInputTexture(pPSDef->PSInputTexture, "PSInputTexture") || \
    !ValidCombinerCount(pPSDef->PSCombinerCount, "PSCombinerCount") || \
    !ValidDotMapping(pPSDef->PSDotMapping, "PSDotMapping") || \
    !ValidCompareMode(pPSDef->PSCompareMode, "PSCompareMode") || \
    !ValidFinalCombinerConstants(pPSDef->PSFinalCombinerConstants, "PSFinalCombinerConstants")
           
//------------------------------------------------------------------------------
// D3DDevice_CreatePixelShader

extern "C"
HRESULT WINAPI D3DDevice_CreatePixelShader(
    CONST D3DPIXELSHADERDEF *pPSDef,
    DWORD* pHandle) 
{ 
    COUNT_API(API_D3DDEVICE_CREATEPIXELSHADER);

    if (DBG_CHECK(TRUE))
    {
        #if DBG
        if(PSDEFCHECKS(pPSDef))
        {
            DXGRIP("D3DDevice_CreatePixelShader - Invalid pixel shader definition.");
        }
        #endif
    }
    
    // Allocate PixelShader struct with a D3DPIXELSHADERDEF struct appended to the end
    PixelShader* pPixelShader = (PixelShader*) MemAllocNoZero(sizeof(*pPixelShader) +
                                                              sizeof(D3DPIXELSHADERDEF));
    if (pPixelShader == NULL)
    {
        return E_OUTOFMEMORY;
    }

#if DBG

    pPixelShader->Signature = 'Pshd';

#endif

    pPixelShader->RefCount = 1;
    pPixelShader->D3DOwned = 1;
    // make pPSDef point to the D3DPIXELSHADERDEF struct appended to pPixelShader
    pPixelShader->pPSDef = (D3DPIXELSHADERDEF *)(pPixelShader + 1);

    // keep a copy of the pixel shader definition
    memcpy(pPixelShader->pPSDef, pPSDef, sizeof(D3DPIXELSHADERDEF));
    
    *pHandle = (DWORD) pPixelShader;

    return S_OK;
}

//------------------------------------------------------------------------------
// D3DDevice_DeletePixelShader

extern "C"
void WINAPI D3DDevice_DeletePixelShader(
    DWORD Handle) 
{ 
    COUNT_API(API_D3DDEVICE_DELETEPIXELSHADER);

    CDevice* pDevice = g_pDevice;

    PixelShader* pPixelShader = (PixelShader*) Handle;

    if (DBG_CHECK(TRUE))
    {
        if (pPixelShader == NULL)
        {
            DPF_ERR("Invalid pixel shader handle value");
        }
        if ((pDevice->m_pPixelShader == pPixelShader) &&
            (pPixelShader->RefCount == 1))
        {
            DPF_ERR("Can't delete a pixel shader that's currently active");
        }

        #if DBG

            if (pPixelShader->Signature != 'Pshd')
            {
                DPF_ERR("Invalid pixel shader object (already deleted?)");
            }

        #endif
    }

    // We have to employ a reference count because of state blocks:

    if ((--pPixelShader->RefCount == 0) && (pPixelShader->D3DOwned))
    {
    
    #if DBG

        pPixelShader->Signature = 'xxxx';

    #endif

        // only free the memory if it is owned by D3D
        MemFree(pPixelShader);
    }
}

//------------------------------------------------------------------------------
// D3DDevice_SetUserPixelShader
//
// Same functionality as D3DDevice_SetPixelShader but this method does not keep
// a copy of the PIXELSHADERDEF.

extern "C"
void WINAPI D3DDevice_SetPixelShaderProgram(
    CONST D3DPIXELSHADERDEF *pPSDef) 
{ 
    COUNT_API(API_D3DDEVICE_SETPIXELSHADERPROGRAM);

    CDevice* pDevice = g_pDevice;
    
    if (DBG_CHECK(TRUE))
    {
        #if DBG
        if(pPSDef && (PSDEFCHECKS(pPSDef)))
        {
            DXGRIP("D3DDevice_SetUserPixelShader - Invalid pixel shader definition.");
        }
        #endif
    }
    
    if(pPSDef)
    {
#if DBG
        pDevice->m_UserPixelShader.Signature = 'Pshd';
#endif

        pDevice->m_UserPixelShader.RefCount = 1;
        pDevice->m_UserPixelShader.D3DOwned = 0;
        pDevice->m_UserPixelShader.pPSDef = (D3DPIXELSHADERDEF*)pPSDef;
        D3DDevice_SetPixelShader((DWORD)(&(pDevice->m_UserPixelShader)));
    }
    else
    {
        // uninstall pixel shader
        D3DDevice_SetPixelShader((DWORD)(NULL));
    }
}

//------------------------------------------------------------------------------
// D3DDevice_SetPixelShader

extern "C"
void WINAPI D3DDevice_SetPixelShader(
    DWORD Handle) 
{ 
    COUNT_API(API_D3DDEVICE_SETPIXELSHADER);

    PixelShader* pPixelShader = (PixelShader*) Handle;

    CDevice* pDevice = g_pDevice;
    
    if (DBG_CHECK(TRUE))
    {
        #if DBG
            // allow Handle to be NULL
            if (pPixelShader && (pPixelShader->Signature != 'Pshd'))
            {
                DPF_ERR("Invalid pixel shader object (already deleted?)");
            }
            // The pixel shader was validated at create time.
        #endif
    }

    PixelShader* pOldShader = pDevice->m_pPixelShader;

    // set current pixel shader
    pDevice->m_pPixelShader = pPixelShader;  
    
    if(!pPixelShader)
    {
        // removing pixel shader, make sure that the combiners get 
        // set up for the fixed-function pipeline lazily
        D3D__DirtyFlags |= (D3DDIRTYFLAG_COMBINERS | D3DDIRTYFLAG_SHADER_STAGE_PROGRAM);
        if(pDevice->m_ShaderUsesSpecFog != 0)
            D3D__DirtyFlags |= D3DDIRTYFLAG_SPECFOG_COMBINER;

        // D3DRS_TEXTUREFACTOR writes to the SetCombinerFactor registers, but
        // it's not handled lazily with the above, so we do the restore now
        D3DDevice_SetRenderState_TextureFactor(D3D__RenderState[D3DRS_TEXTUREFACTOR]);

        PPUSH pPush = pDevice->StartPush();

        // The bump-env registers map to different stages when a pixel shader
        // is no longer active
        pPush = CommonSetTextureBumpEnv(pDevice, pPush);

        // The fixed function pipeline always expects dependent texture 
        // lookups to run between stages i and i+1, so reset that now
        Push1(pPush, NV097_SET_SHADER_OTHER_STAGE_INPUT,
            (DRF_DEF (097, _SET_SHADER_OTHER_STAGE_INPUT, _STAGE1, _INSTAGE_0) |
             DRF_DEF (097, _SET_SHADER_OTHER_STAGE_INPUT, _STAGE2, _INSTAGE_1) |
             DRF_DEF (097, _SET_SHADER_OTHER_STAGE_INPUT, _STAGE3, _INSTAGE_2)));

        pDevice->EndPush(pPush + 2);
        
        // finished removing pixel shader
        return;
    }

    // at this point, pPixelShader != NULL
    // determine whether pixel shader uses the final combiner
    pDevice->m_ShaderUsesSpecFog = pPixelShader->pPSDef->PSFinalCombinerInputsABCD | 
                                   pPixelShader->pPSDef->PSFinalCombinerInputsEFG;
    
    // determine whether the pixel shade wants texture modes adjusted
    pDevice->m_ShaderAdjustsTexMode = pPixelShader->pPSDef->PSFinalCombinerConstants & 
                                                    (PS_GLOBALFLAGS_TEXMODE_ADJUST << 8);
    
    // If we made it here then we are installing a new pixel shader
    // or replacing a previous pixel shader with a new one.
    // Slam the bits into hardware.
    //
    // Is there anything to be gained by checking CombinerCount and only
    // downloading registers for active stages?  It seems like the data is
    // interleaved so much that this might require more pushbuffer data
    // than just dumping the whole structure.
    //
    
    D3DPIXELSHADERDEF *pPSDef = pPixelShader->pPSDef;
    
    // update texture modes according to currently set textures
    pDevice->m_PSShaderStageProgram = pPSDef->PSTextureModes;

    D3D__DirtyFlags |= D3DDIRTYFLAG_SHADER_STAGE_PROGRAM;

    PPUSH pPush = pDevice->StartPush();

    // The bump-env registers map to different stages when a pixel shader
    // becomes active
    if (pOldShader == NULL)
        pPush = CommonSetTextureBumpEnv(pDevice, pPush);

    PushCount(pPush, NV097_SET_COMBINER_ALPHA_ICW(0), 8);
        //pushbuffer[1] = PSAlphaInputs0 (0x0260)
        //pushbuffer[2] = PSAlphaInputs1 (0x0264)
        //pushbuffer[3] = PSAlphaInputs2 (0x0268)
        //pushbuffer[4] = PSAlphaInputs3 (0x026c)
        //pushbuffer[5] = PSAlphaInputs4 (0x0270)
        //pushbuffer[6] = PSAlphaInputs5 (0x0274)
        //pushbuffer[7] = PSAlphaInputs6 (0x0278)
        //pushbuffer[8] = PSAlphaInputs7 (0x027c)
    memcpy((void*) (pPush + 1), &(pPSDef->PSAlphaInputs[0]), 8 * sizeof(DWORD));

    PushCount(pPush+9, NV097_SET_COMBINER_FACTOR0(0), 32);
        //pushbuffer[10] = PSConstant0 (0x0a60)
        //pushbuffer[11] = PSConstant2 (0x0a64)
        //pushbuffer[12] = PSConstant4 (0x0a68)
        //pushbuffer[13] = PSConstant6 (0x0a6c)
        //pushbuffer[14] = PSConstant8 (0x0a70)
        //pushbuffer[15] = PSConstant10 (0x0a74)
        //pushbuffer[16] = PSConstant12 (0x0a78)
        //pushbuffer[17] = PSConstant14 (0x0a7c)
        //pushbuffer[18] = PSConstant1 (0x0a80)
        //pushbuffer[19] = PSConstant3 (0x0a84)
        //pushbuffer[20] = PSConstant5 (0x0a88)
        //pushbuffer[21] = PSConstant7 (0x0a8c)
        //pushbuffer[22] = PSConstant9 (0x0a90)
        //pushbuffer[23] = PSConstant11 (0x0a94)
        //pushbuffer[24] = PSConstant13 (0x0a98)
        //pushbuffer[25] = PSConstant15 (0x0a9c)
        //pushbuffer[26] = PSAlphaOutputs0 (0x0aa0)
        //pushbuffer[27] = PSAlphaOutputs1 (0x0aa4)
        //pushbuffer[28] = PSAlphaOutputs2 (0x0aa8)
        //pushbuffer[29] = PSAlphaOutputs3 (0x0aac)
        //pushbuffer[30] = PSAlphaOutputs4 (0x0ab0)
        //pushbuffer[31] = PSAlphaOutputs5 (0x0ab4)
        //pushbuffer[32] = PSAlphaOutputs6 (0x0ab8)
        //pushbuffer[33] = PSAlphaOutputs7 (0x0abc)
        //pushbuffer[34] = PSRGBInputs0 (0x0ac0)
        //pushbuffer[35] = PSRGBInputs1 (0x0ac4)
        //pushbuffer[36] = PSRGBInputs2 (0x0ac8)
        //pushbuffer[37] = PSRGBInputs3 (0x0acc)
        //pushbuffer[38] = PSRGBInputs4 (0x0ad0)
        //pushbuffer[39] = PSRGBInputs5 (0x0ad4)
        //pushbuffer[40] = PSRGBInputs6 (0x0ad8)
        //pushbuffer[41] = PSRGBInputs7 (0x0adc)
    memcpy((void*) (pPush + 10), &(pPSDef->PSConstant0), 32 * sizeof(DWORD));
    
    Push1(pPush+42, NV097_SET_SHADER_CLIP_PLANE_MODE, pPSDef->PSCompareMode);

    PushCount(pPush+44, NV097_SET_SPECULAR_FOG_FACTOR(0), 2);
        //pushbuffer[45] = PSConstant16 (0x1e20)
        //pushbuffer[46] = PSConstant17 (0x1e24)
    memcpy((void*) (pPush + 45), &(pPSDef->PSFinalCombinerConstant0), 2 * sizeof(DWORD));
    
    PushCount(pPush+47, NV097_SET_COMBINER_COLOR_OCW(0), 9);
        //pushbuffer[48] = PSRGBOutputs0 (0x1e40)
        //pushbuffer[49] = PSRGBOutputs1 (0x1e44)
        //pushbuffer[50] = PSRGBOutputs2 (0x1e48)
        //pushbuffer[51] = PSRGBOutputs3 (0x1e4c)
        //pushbuffer[52] = PSRGBOutputs4 (0x1e50)
        //pushbuffer[53] = PSRGBOutputs5 (0x1e54)
        //pushbuffer[54] = PSRGBOutputs6 (0x1e58)
        //pushbuffer[55] = PSRGBOutputs7 (0x1e5c)
        //pushbuffer[56] = PSCombinerCount (0x1e60)
    memcpy((void*) (pPush + 48), &(pPSDef->PSRGBOutputs[0]), 9 * sizeof(DWORD));
    
    PushCount(pPush+57, NV097_SET_DOT_RGBMAPPING, 2);
        //pushbuffer[58] = PSDotMapping (0x1e74)
        //pushbuffer[59] = PSInputTexture (0x1e78)
    memcpy((void*) (pPush + 58), &(pPSDef->PSDotMapping), 2 * sizeof(DWORD));
    
        //PSTextureModes (0x1e70) is handled by D3DDIRTYFLAG_SHADER_STAGE_PROGRAM

    if(pDevice->m_ShaderUsesSpecFog != 0)
    {
        PushCount(pPush+60, NV097_SET_COMBINER_SPECULAR_FOG_CW0, 2);
            //pushbuffer[61] = PSFinalCombinerInputsABCD (0x0288)
            //pushbuffer[62] = PSFinalCombinerInputsEFG  (0x028c)
        memcpy((void*) (pPush + 61), &(pPSDef->PSFinalCombinerInputsABCD), 2 * sizeof(DWORD));
        
        pDevice->EndPush(pPush+63);
    }
    else
        pDevice->EndPush(pPush+60); // count without specfog registers
    
    // copy the new pixel shader state to the renderstate shadow if necessary
    if (!(pDevice->m_StateFlags & STATE_PUREDEVICE))
    {
        // copy all but last three DWORDS to renderstate shadow
        memcpy(&(D3D__RenderState[D3DRS_PSALPHAINPUTS0]), 
               pPSDef, 
               sizeof(D3DPIXELSHADERDEF) - 3*sizeof(DWORD));

        // D3DRS_PSTEXTUREMODES isn't grouped with the others
        D3D__RenderState[D3DRS_PSTEXTUREMODES] = pPSDef->PSTextureModes;
    }
}

//------------------------------------------------------------------------------
// D3DDevice_GetPixelShader

extern "C"
void WINAPI D3DDevice_GetPixelShader(
    DWORD* pHandle) 
{ 
    COUNT_API(API_D3DDEVICE_GETPIXELSHADER);

    if (DBG_CHECK(TRUE))
    {
        if (pHandle == NULL)
        {
            DPF_ERR("Pixel shader handle pointer is NULL");
        }
    }
    
    *pHandle = (DWORD) g_pDevice->m_pPixelShader;
}

//------------------------------------------------------------------------------
// Float2UChar
//
// maps [0.0-1.0] to [0-255]

FORCEINLINE UCHAR Float2UChar(float in)
{
    if(in > 1.0f)
        in = 1.0f;
    else if(in < 0.0f)
        in = 0.0f;

    return (UCHAR)FloatToLong(in * 255.0f + 0.5f);
}

//------------------------------------------------------------------------------
// D3DDevice_SetPixelShaderConstant

extern "C"
void WINAPI D3DDevice_SetPixelShaderConstant(
    DWORD Register,
    CONST void* pConstantData,
    DWORD ConstantCount) 
{ 
    COUNT_API(API_D3DDEVICE_SETPIXELSHADERCONSTANT);
    
    CDevice* pDevice = g_pDevice;

    if (DBG_CHECK(TRUE))
    {
        if (pConstantData == NULL)
        {
            DPF_ERR("Invalid constant data pointer in SetPixelShaderConstant");
        }
        if ((Register + ConstantCount) > 16)  // maximum of 16 D3D constants
        {
            DPF_ERR("Too many constants specified in SetPixelShaderConstant");
        }
        if(pDevice->m_pPixelShader == NULL)
        {
            DPF_ERR("Attempt to set pixel shader constant with no active pixel shader.");
        }
    }
    
    // get the currently set pixel shader
    D3DPIXELSHADERDEF *pPsd = pDevice->m_pPixelShader->pPSDef;

    float *pFloatData = (float *)pConstantData;
    for (UINT i=0; i<ConstantCount; i++, Register++, pFloatData += 4) 
    {
        DWORD dVal = (((DWORD)Float2UChar(pFloatData[3])) << 24) |
                     (((DWORD)Float2UChar(pFloatData[0])) << 16) |
                     (((DWORD)Float2UChar(pFloatData[1])) <<  8) |
                     (((DWORD)Float2UChar(pFloatData[2]))      );

        // keep a copy of this constant
        pDevice->m_pPixelShaderConstants[Register] = dVal;

        // The pixelshaderdef struct has three dwords that map D3D constants 
        // to nVidia registers.  Scan the mapping to determine which registers
        // to write with this D3D constant.
        for(UINT r=0; r<8; r++) // check c0 registers
            if(((pPsd->PSC0Mapping >> (4*r)) & 0xf) == Register)
                pDevice->SetRenderState((D3DRENDERSTATETYPE)(D3DRS_PSCONSTANT0_0 + r), dVal);

        for(r=0; r<8; r++) // check c1 registers
            if((pPsd->PSC1Mapping >> (4*r) & 0xf) == Register)
                pDevice->SetRenderState((D3DRENDERSTATETYPE)(D3DRS_PSCONSTANT1_0 + r), dVal);
    
        for(r=0; r<2; r++) // check final combiner registers
            if((pPsd->PSFinalCombinerConstants >> (4*r) & 0xf) == Register)
                pDevice->SetRenderState((D3DRENDERSTATETYPE)(D3DRS_PSFINALCOMBINERCONSTANT0 + r), dVal);
        
        // if c0 is being set, also set the static eye vector
        if(Register == 0)
        {
            PPUSH pPush = pDevice->StartPush();
            // (c0.r, c0.g, c0.b) => (eye.x, eye.y, eye.z)
            PushCount(pPush, NV097_SET_EYE_VECTOR(0), 3);
                //pushbuffer[1] = eye.x
                //pushbuffer[2] = eye.y
                //pushbuffer[3] = eye.z
            memcpy((void*) (pPush + 1), &(pFloatData[0]), 3 * sizeof(DWORD));

            pDevice->EndPush(pPush + 4);
        }
    }
}

//------------------------------------------------------------------------------
// D3DDevice_GetPixelShaderConstant

extern "C"
void WINAPI D3DDevice_GetPixelShaderConstant(
    DWORD Register,
    void* pConstantData,
    DWORD ConstantCount) 
{ 
    COUNT_API(API_D3DDEVICE_GETPIXELSHADERCONSTANT);

    if (DBG_CHECK(TRUE))
    {
        if (pConstantData == NULL)
        {
            DPF_ERR("Invalid constant data pointer in GetPixelShaderConstant");
        }
        if ((Register + ConstantCount) > 16)
        {
            DPF_ERR("Too many constants specified in GetPixelShaderConstant");
        }
    }

    float *pFloatData = (float *)pConstantData;
    for (UINT i=0; i<ConstantCount; i++, Register++, pFloatData += 4) 
    {
        DWORD dVal = g_pDevice->m_pPixelShaderConstants[Register];
        // map [0-255] to [0.0-1.0] for each packed byte
        pFloatData[3] = ((FLOAT)((dVal >> 24) & 0xff))/255.0F;
        pFloatData[0] = ((FLOAT)((dVal >> 16) & 0xff))/255.0F;
        pFloatData[1] = ((FLOAT)((dVal >>  8) & 0xff))/255.0F;
        pFloatData[2] = ((FLOAT)((dVal      ) & 0xff))/255.0F;
    }
}

//------------------------------------------------------------------------------
// D3DDevice_GetPixelShaderFunction

extern "C"
void WINAPI D3DDevice_GetPixelShaderFunction(
    DWORD Handle,
    D3DPIXELSHADERDEF* pPSDef)
{ 
    COUNT_API(API_D3DDEVICE_GETPIXELSHADERFUNCTION);

    PixelShader* pPixelShader = (PixelShader*) Handle;
    
    if (DBG_CHECK(TRUE))
    {
        if (pPixelShader == NULL)
        {
            DPF_ERR("Invalid pixel shader handle value");
        }

        #if DBG

            if (pPixelShader->Signature != 'Pshd')
            {
                DPF_ERR("Invalid pixel shader object (already deleted?)");
            }

        #endif
        
        if (pPSDef == NULL) 
        {
            DPF_ERR("Invalid pixel shader definition pointer");
        }
    }
    
    memcpy(pPSDef, pPixelShader->pPSDef, sizeof(D3DPIXELSHADERDEF));
}

} // end of namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\rdi.h ===
/*==========================================================================
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       rdi.h
 *  Content:    header file for RDI Data access
 *
 ***************************************************************************/

#ifndef _D3DRDI_H_
#define _D3DRDI_H_


#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

#ifdef __cplusplus
extern "C" {
#endif

#define RDI_INDEX_XL_PROGRAM     0x00000010 //136x4   // Cheops Program
#define RDI_INDEX_XL_VAB         0x00000015 //17x4    // VAB
#define RDI_INDEX_VTX_CONSTANTS0 0x00000017 //192x4   // cheop context memory0
#define RDI_INDEX_VTX_CONSTANTS1 0x000000cc //192x4   // cheop context memory1
#define RDI_INDEX_IDX_FMT        0x00000026 //16+16+3 // Vertex Array Regs+State
#define RDI_INDEX_VTX_FILE0      0x00000028 //48x4    // Vertex File0
#define RDI_INDEX_VTX_FILE1      0x00000029 //144x4   // Vertex File1
#define RDI_INDEX_CAS0           0x0000002c //6x4 + 5 // Primitive Assembly Vtx0
#define RDI_INDEX_CAS1           0x0000002d //6x4 + 5 // Primitive Assembly Vtx1
#define RDI_INDEX_CAS2           0x0000002e //6x4 + 5 // Primitive Assembly Vtx2
#define RDI_INDEX_ASSM_STATE     0x0000002f //2       // Primitive Assembly State

// vtx file cache entry structure
typedef struct _tagRDIRAMDATA_VTX_FILEENTRY
{
    // RDI_INDEX_VTX_FILE0
    DWORD diff;
    DWORD spec;
    DWORD ptsize;
    DWORD mask;
    DWORD bdiff;
    DWORD bspec;
    DWORD fog;
    DWORD unused;

    // RDI_INDEX_VTX_FILE1
    DWORD pos[4];
    DWORD tex[4][4];

} D3DRDI_VTX_FILEENTRY;

// Primitive Assembly entry (from color assembly RAMS)
typedef struct _tagRDIRAMDATA_PAENTRY
{
    DWORD diff;
    DWORD spec;
    DWORD z, w;
    DWORD bdiff;
    DWORD bspec;
    DWORD fog;
    DWORD ptsize;
    DWORD tex[4][4];
    DWORD pos[4];
    DWORD unknown[4];

} D3DRDI_PAENTRY;

// Get a block of RDI data - !!! waits for gpu to become idle !!!
void WINAPI D3DRDI_GetRamData(DWORD index, DWORD address, void *pData, DWORD SizeOfData);

// Given an index 0-23 return the LRU cache entry data
void WINAPI D3DRDI_GetVTXFileEntry(DWORD index, D3DRDI_VTX_FILEENTRY *pentry);

// Get the next write slot for the 24 entry LRU cache
DWORD WINAPI D3DRDI_GetNextVTXLRUSlot();

// Given an index 0-2 return the PA data
void WINAPI D3DRDI_GetPAEntry(DWORD index, D3DRDI_PAENTRY *pentry);


/*
 * Dumper routines
 */

// Given an index 0-23, dump the LRU cache entry
void WINAPI D3DRDI_DumpVTXFileEntry(DWORD index);

// Given an index 0-135, dump the vertex shader program
void WINAPI D3DRDI_DumpVTXProgram(DWORD index, DWORD length);

// Given an index 0-191, dump the vertex shader constant values
void WINAPI D3DRDI_DumpVTXConstants(DWORD index, DWORD count);

// Dump VAB values
void WINAPI D3DRDI_DumpVAB();

// Dump the PA data
void WINAPI D3DRDI_DumpPA();

#ifdef __cplusplus
}
#endif

} // end namespace

#endif // _D3DRDI_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\resource.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       resource.cpp
 *  Content:    Implementation of the D3DResource class.
 *
 ***************************************************************************/

#include "precomp.hpp"

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

//------------------------------------------------------------------------------
// Global private data list

struct PrivateDataNode
{
    PrivateDataNode    *pNext;
    void               *pObject;
    GUID                guid;
    DWORD               size;
    DWORD               flags;

    union
    {
        IUnknown       *pUnknown;
        BYTE            Data[1];
    };
};

static PrivateDataNode *g_pPrivateData;

//------------------------------------------------------------------------------
// Helper that finds a private data node for a specific object/guid in the 
// private data list.

PrivateDataNode* FindPrivateData
(
    void *pObject, 
    REFGUID refguid
)
{
    PrivateDataNode *pNode = g_pPrivateData;

    while (pNode != NULL)
    {
        if (pNode->pObject == pObject && pNode->guid == refguid)
        {
            return pNode;
        }
    }

    return NULL;
}

//------------------------------------------------------------------------------
// Helper to free all of the private data associated with an object that
// is about to go away.

void CleanPrivateData
(
    void *p
)
{
    PrivateDataNode *pNode = g_pPrivateData;
    PrivateDataNode **ppPrev = &g_pPrivateData;

    while (pNode != NULL)
    {
        if (pNode->pObject == p)
        {
            *ppPrev = pNode->pNext;

            if (pNode->flags & D3DSPD_IUNKNOWN)
            {
                pNode->pUnknown->Release();
            }

            MemFree(pNode);

            pNode = *ppPrev;
        }
        else
        {
            ppPrev = &pNode->pNext;
            pNode = pNode->pNext;
        }
    }
}

//----------------------------------------------------------------------------
// Helper to get the data pointed to by a resource. This always returns
// a pointer to the data in the CPU's write-combined address space.
//
BYTE *GetDataFromResource
(
    D3DResource *pResource
)
{    
    if (pResource->Common & D3DCOMMON_VIDEOMEMORY)
    {
        return (BYTE *)GetVideoAddress(pResource->Data);
    }
    else
    {
        return (BYTE *)GetWriteCombinedAddress(pResource->Data);
    }
}

//----------------------------------------------------------------------------
// Destroys the contents of a resource when it has been completely released.
//
void DestroyResource(
    D3DResource *pResource
    )
{
    if (DBG_CHECK(!(pResource->Common & D3DCOMMON_D3DCREATED)))
    {
        DXGRIP("DestroyResource - The reference count of a non-d3d created resource went to zero.");
    }

    DWORD Type = pResource->Common & D3DCOMMON_TYPE_MASK;

    // Make sure this object isn't being used by the GPU.  We will always
    // block, it is the caller's responsibility to check to see if this
    // object may be freed before releasing this if they do not want
    // to block.
    //
    // There is no need to do this for a surface that does not
    // own its memory.
    //
    if (Type != D3DCOMMON_TYPE_SURFACE || pResource->Common & D3DSURFACE_OWNSMEMORY)
    {
        BlockOnResource(pResource);
    }
    
    // If anybody actually uses the private data then we should
    // use a bit on the object to see if any private data has been 
    // set on it or not.  Otherwise we'll walk the whole private data
    // list each time an object is destroyed.
    //
    CleanPrivateData(pResource);

    // Get rid of our data.  The data for an index buffer is allocated
    // directly with the header.
    //
    if (Type == D3DCOMMON_TYPE_SURFACE)
    {
        if (pResource->Common & D3DSURFACE_OWNSMEMORY)
        {
            FreeContiguousMemory(GetWriteCombinedAddress(pResource->Data));
        }
    }

    else if (Type == D3DCOMMON_TYPE_PUSHBUFFER) 
    {
        if (!(pResource->Common & D3DPUSHBUFFER_RUN_USING_CPU_COPY))
        {
            // A push-buffers always has a virtual address for 'Data':
            FreeContiguousMemory((void*) pResource->Data);
        }
    }
    else if ((Type != D3DCOMMON_TYPE_INDEXBUFFER) &&
             (Type != D3DCOMMON_TYPE_FIXUP))
    {
        FreeContiguousMemory(GetWriteCombinedAddress(pResource->Data));
    }

    // Destroy the header.
    MemFree(pResource);
}

//----------------------------------------------------------------------------
// Check a resource to see if it's in use.
//
// Unlike the faster IsNonSurfaceResourceSetInDevice, this handles any type
// of resource.
//
BOOL IsResourceSetInDevice(
    D3DResource *pResource
    )
{
    CHECK(pResource, "IsResourceSetInDevice");

    if (pResource->Common & D3DCOMMON_INTREFCOUNT_MASK)
    {
        return TRUE;
    }

    if ((pResource->Common & D3DCOMMON_TYPE_MASK) == D3DCOMMON_TYPE_SURFACE)
    {
        D3DBaseTexture *pParent = PixelJar::GetParent((D3DPixelContainer *)pResource);

        if (pParent && (pParent->Common & D3DCOMMON_INTREFCOUNT_MASK))
        {
            return TRUE;
        }
    }

    return FALSE;
}

//----------------------------------------------------------------------------
// Add an internal reference to a resource.  This indicates that the
// resource is currently being used in the device.
//
void InternalAddRefSurface(
    D3DResource *pResource
    )
{
    ASSERT((pResource->Common & D3DCOMMON_INTREFCOUNT_MASK) != D3DCOMMON_INTREFCOUNT_MASK);
    ASSERT((pResource->Common & D3DCOMMON_TYPE_MASK) == D3DCOMMON_TYPE_SURFACE);

    // If the resource being referenced is a surface then we also need
    // to increment the refcount on its parent.  We only do this once.
    //
    if (!(pResource->Common & D3DCOMMON_INTREFCOUNT_MASK))
    {
        D3DBaseTexture *pParent = PixelJar::GetParent((D3DPixelContainer *)pResource);
    
        if (pParent)
        {
            InternalAddRef(pParent);
        }
    }

    pResource->Common += (1 << D3DCOMMON_INTREFCOUNT_SHIFT);
}

//----------------------------------------------------------------------------
// Release an internal reference for surfaces.
//
void InternalReleaseSurface(
    D3DResource *pResource
    )
{
    ASSERT((pResource->Common & D3DCOMMON_INTREFCOUNT_MASK) != 0);
    ASSERT((pResource->Common & D3DCOMMON_TYPE_MASK) == D3DCOMMON_TYPE_SURFACE);

    if ((pResource->Common & D3DCOMMON_INTREFCOUNT_MASK) == (1 << D3DCOMMON_INTREFCOUNT_SHIFT))
    {
        // If this is the last internal release from a surface then we need
        // to release its internal reference on the parent.
        //
        D3DBaseTexture *pParent = PixelJar::GetParent((D3DPixelContainer *)pResource);

        if (pParent)
        {
            InternalRelease(pParent);
        }

        // Only destroy this if the external refcount is zero.
        if ((pResource->Common & D3DCOMMON_REFCOUNT_MASK) == 0)
        {
            DestroyResource(pResource);

            return;
        }
    }

    pResource->Common -= (1 << D3DCOMMON_INTREFCOUNT_SHIFT);
}
                       
//------------------------------------------------------------------------------
// D3DResource_AddRef
//
extern "C"
ULONG WINAPI D3DResource_AddRef
(
    D3DResource *pResource
) 
{
    COUNT_API(API_D3DRESOURCE_ADDREF);
    CHECK(pResource, "D3DResource_AddRef");

    ASSERT(D3DCOMMON_REFCOUNT_MASK == 0x0000FFFF);

    // If the resource being referenced is a surface then we also need
    // to increment the refcount on its parent.  We only do this once.
    //
    if ((pResource->Common & D3DCOMMON_REFCOUNT_MASK) == 0)
    {
        if ((pResource->Common & D3DCOMMON_TYPE_MASK) == D3DCOMMON_TYPE_SURFACE)
        {
            D3DBaseTexture *pParent = PixelJar::GetParent((D3DPixelContainer *)pResource);
    
            if (pParent)
            {
                pParent->AddRef();
            }
        }
    }

    ASSERTMSG((pResource->Common & D3DCOMMON_REFCOUNT_MASK) != D3DCOMMON_REFCOUNT_MASK,
              "D3DResource_AddRef overflow - was a Release() forgotten somewhere?");

    return ++pResource->Common & D3DCOMMON_REFCOUNT_MASK;
}

//------------------------------------------------------------------------------
// D3DResource_Release
//
// If the GPU is currently using this object when the last call to release
// is made then this call will block until the GPU is done with this object.
// The caller will have to manually check this if they do not want this call
// to block.
//
extern "C"
ULONG WINAPI D3DResource_Release
(
    D3DResource *pResource
) 
{
    COUNT_API(API_D3DRESOURCE_RELEASE);
    CHECK(pResource, "D3DResource_Release");

    ASSERT(D3DCOMMON_REFCOUNT_MASK == 0x0000FFFF);

    if ((pResource->Common & D3DCOMMON_REFCOUNT_MASK) == 1)
    {
        // If this is the last external release from a surface then we need
        // to release its external reference on the parent.
        //
        if ((pResource->Common & D3DCOMMON_TYPE_MASK) == D3DCOMMON_TYPE_SURFACE)
        {
            D3DBaseTexture *pParent = PixelJar::GetParent((D3DPixelContainer *)pResource);

            if (pParent)
            {
                pParent->Release();
            }
        }

        // Only destroy this if the internal refcount is zero.
        if ((pResource->Common & D3DCOMMON_INTREFCOUNT_MASK) == 0)
        {
            DestroyResource(pResource);

            return 0;
        }
    }

    ASSERTMSG((pResource->Common & D3DCOMMON_REFCOUNT_MASK) != 0,
              "D3DResource_Release underflow - was an AddRef() forgotten somewhere?");

    return --pResource->Common & D3DCOMMON_REFCOUNT_MASK;
}

//------------------------------------------------------------------------------
// D3DResource_GetType

extern "C"
D3DRESOURCETYPE WINAPI D3DResource_GetType
(
    D3DResource *pResource
) 
{
    COUNT_API(API_D3DRESOURCE_GETTYPE);
    CHECK(pResource, "D3DResource_GetType");

    DWORD Type = pResource->Common & D3DCOMMON_TYPE_MASK;

    switch(Type)
    {
    case D3DCOMMON_TYPE_VERTEXBUFFER:
        return D3DRTYPE_VERTEXBUFFER;

    case D3DCOMMON_TYPE_INDEXBUFFER:
        return D3DRTYPE_INDEXBUFFER;

    case D3DCOMMON_TYPE_PUSHBUFFER:
        return D3DRTYPE_PUSHBUFFER;

    case D3DCOMMON_TYPE_FIXUP:
        return D3DRTYPE_FIXUP;

    case D3DCOMMON_TYPE_PALETTE:
        return D3DRTYPE_PALETTE;

    case D3DCOMMON_TYPE_TEXTURE:
        {
            DWORD Format = ((D3DBaseTexture *)pResource)->Format;

            if (Format & D3DFORMAT_CUBEMAP)
            {
                return D3DRTYPE_CUBETEXTURE;
            }
            else if ((Format & D3DFORMAT_DIMENSION_MASK) > (2 << D3DFORMAT_DIMENSION_SHIFT))
            {
                return D3DRTYPE_VOLUMETEXTURE;  
            }
            else
            {
                return D3DRTYPE_TEXTURE;
            }
        }

    case D3DCOMMON_TYPE_SURFACE:
        {
            DWORD Format = ((D3DPixelContainer *)pResource)->Format;

            if ((Format & D3DFORMAT_DIMENSION_MASK) > (2 << D3DFORMAT_DIMENSION_SHIFT))
            {
                return D3DRTYPE_VOLUME;
            }
            else
            {
                return D3DRTYPE_SURFACE;
            }
        }

    default:
        NODEFAULT("D3DResource_GetType - unknown type\n");
        
        return (D3DRESOURCETYPE)0;
    }
}

//------------------------------------------------------------------------------
// D3DResource_IsBusy
//
// Check to see if a resource is currently being used by the GPU.
//
extern "C"
BOOL WINAPI D3DResource_IsBusy
(
    D3DResource *pResource
)
{
    COUNT_API(API_D3DRESOURCE_ISBUSY);
    CHECK(pResource, "D3DResource_IsBusy");

    CDevice *pDevice = g_pDevice;
    D3DResource *pParent = PixelJar::GetParent(pResource);

    if (pParent)
    {
        if (IsResourceSetInDevice(pResource))
        {
            return TRUE;
        }

        pResource = pParent;
    }

    if (IsResourceSetInDevice(pResource))
    {
        return TRUE;
    }

    BOOL Result = (pResource->Lock != 0) 
                && (pDevice->IsTimePending(pResource->Lock));

    // If this resource is not busy then reset the lock.  This is not needed
    // to protect from time rollover (our push-buffer logic handles this 
    // neatly), but rather because we document this behavior in our docs 
    // under "Using Resources From Multiple Threads": 
    //
    //      The following methods can be called on a resource as long as 
    //      the Lock field of the resource is set to zero and the resource 
    //      is not set on IDirect3DDevice8. The Lock field is automatically 
    //      set to zero if IDirect3DResource8::IsBusy is called and returns 
    //      FALSE.
    //
    //      ...

    if (!Result)
    {
        pResource->Lock = 0;
    }

    return Result;
}

//------------------------------------------------------------------------------
// D3DResource_GetDevice

extern "C"
void WINAPI D3DResource_GetDevice
(
    D3DResource *pResource,
    D3DDevice  **ppDevice
)
{
    COUNT_API(API_D3DRESOURCE_GETDEVICE);
    CHECK(pResource, "D3DResource_GetDevice");

    *ppDevice = g_pDevice;
    g_pDevice->AddRef();
}

//------------------------------------------------------------------------------
// D3DResource_Register

extern "C"
VOID WINAPI D3DResource_Register(
    D3DResource *pResource,
    void *pBase
    )
{
    COUNT_API(API_D3DRESOURCE_REGISTER);

    DWORD type = pResource->Common & D3DCOMMON_TYPE_MASK;
    void *pMemory = (BYTE*) pBase + pResource->Data;

    if (DBG_CHECK(!pResource))
    {
        DXGRIP("D3DResource_Register - NULL this pointer.");
    }

    if (DBG_CHECK(pResource->Common & D3DCOMMON_D3DCREATED))
    {
        DXGRIP("D3DResource_Register - Do not register a D3D created resource.");
    }

    if (DBG_CHECK(type == D3DCOMMON_TYPE_INDEXBUFFER))
    {
        DXGRIP("D3DResource_Register - Do not register index buffers.");
    }

    if (DBG_CHECK(type == D3DCOMMON_TYPE_FIXUP))
    {
        DXGRIP("D3DResource_Register - Do not register fixups.");
    }

    if (DBG_CHECK(!IsContiguousMemory(pMemory)))
    {
        DXGRIP("D3DResource_Register - The object must be in physically contiguous memory.");
    }

    if (DBG_CHECK(IsWriteCombinedMemory(pResource)))
    {
        DXGRIP("D3DResource_Register - D3DResource structure should not be in write-combined memory.");
    }

    if (DBG_CHECK(pResource->Lock != 0))
    {
        DXGRIP("D3DResource_Register - Lock field should be zero.");
    }

    // Push-buffers always set 'Data' to the virtual address.
    //
    if (type == D3DCOMMON_TYPE_PUSHBUFFER)
    {
        pResource->Data = (DWORD) pMemory;
    }
    else
    {
        pResource->Data = GetGPUAddress(pMemory);
    }

    // This will check for the proper alignment which is why we do it after
    // we set the data pointer.
    //
    CHECK(pResource, "D3DResource_Register");

#if DBG

    if (type == D3DCOMMON_TYPE_TEXTURE || type == D3DCOMMON_TYPE_SURFACE)
    {
        D3DPixelContainer *pPixels = (D3DPixelContainer*)pResource;

        if (pPixels->Size != 0)
        {
            DWORD Width, Height, Depth, Pitch, Slice;
            D3DFORMAT Format;
        
            PixelJar::GetSize(pPixels, 0, &Width, &Height, &Depth, &Pitch, &Slice);
            Format = PixelJar::GetFormat(pPixels);
        
            if (Pitch < CalcPitch(Width, BitsPerPixelOfD3DFORMAT(Format)))
            {
                if (Pitch != 64)
                {
                    DXGRIP("pResource->Size has a bad pitch value");
                }
                else
                {
                    DXGRIP("pResource->Size has a bad pitch value of 64 bytes.\n"
                           "(Could it be that a surface is being loaded that "
                           "wasn't created with the \nnew D3DSIZE_PITCH_MASK "
                           "encoding?)");
                }
            }
        }

        if ((pPixels->Format & D3DFORMAT_DMACHANNEL_MASK) == 0)
        {
            DXGRIP("pResource->Format must have D3DFORMAT_DMACHANNEL_A or _B set\n");
        }
    }

#endif

}

//------------------------------------------------------------------------------
// D3DResource_BlockUntilNotBusy

extern "C"
VOID WINAPI D3DResource_BlockUntilNotBusy(
    D3DResource *pResource
    )
{
    COUNT_API(API_D3DRESOURCE_BLOCKUNTILNOTBUSY);
    CHECK(pResource, "D3DResource_BlockUntilNotBusy");

    // We can get rid of the extra call here by making our
    // internal methods call this directly and moving the BlockOnResource
    // code in here, but then the API counter would also count the internal
    // blocks.  Not good.
    //   
    BlockOnResource(pResource);
}

#if DBG

LONG ExceptionFilter()
{
    WARNING("Possible attempt to use D3DSPD_IUNKNOWN with an object");
    WARNING("not derived from the IUnknown interface");
    return EXCEPTION_CONTINUE_SEARCH;
}

#endif // DBG

//------------------------------------------------------------------------------
// D3DResource_SetPrivateData

extern "C"
HRESULT WINAPI D3DResource_SetPrivateData
(
    D3DResource *pResource, 
    REFGUID refguid, 
    CONST void *pData, 
    DWORD SizeOfData, 
    DWORD Flags
)
{
    COUNT_API(API_D3DRESOURCE_SETPRIVATEDATA);
    CHECK(pResource, "D3DResource_SetPrivateData");

    PrivateDataNode *pNode;
    DWORD cbExtraData;

    if (DBG_CHECK(TRUE))
    {
        if (Flags & ~D3DSPD_IUNKNOWN)
        {
            DXGRIP("Invalid flags to SetPrivateData");
        }

        if (Flags & D3DSPD_IUNKNOWN)
        {
            if (SizeOfData != sizeof(LPVOID))
            {
                DXGRIP("Invalid SizeOfData for IUnknown to SetPrivateData");
            }
        }
    }

    // Find the node in our list if any and free it
    pNode = FindPrivateData(pResource, refguid);
    if (pNode != NULL)
    {
        D3DResource_FreePrivateData(pResource, refguid);
    }

    // No need to allocate more data to store the IUknown pointer
    if (Flags & D3DSPD_IUNKNOWN)
    {
        cbExtraData = 0;
    }
    else
    {
        cbExtraData = SizeOfData;
    }

    // Allocate the node and initialize the fields
    pNode = (PrivateDataNode*)MemAlloc(sizeof(PrivateDataNode) + SizeOfData);
    if (pNode == NULL)
    {
        return E_OUTOFMEMORY;
    }

    pNode->size = SizeOfData;
    pNode->guid = refguid;
    pNode->flags = Flags;
    pNode->pObject = pResource;

    // Copy the data portion over
    if (Flags & D3DSPD_IUNKNOWN)
    {
        pNode->pUnknown = (IUnknown*)pData;

    // If the AddRef has problems, the ExceptionFilter will notify the caller
    // the most likely cause of the problem is that the object is not derived
    // from IUnknown. Xbox D3D objects are not derived from IUnknown.

#if DBG
    __try
    {
#endif // DBG
        pNode->pUnknown->AddRef();
#if DBG
    }
    __except (ExceptionFilter())
    {
    }
#endif // DBG
    }
    else
    {
        memcpy(pNode->Data, pData, SizeOfData);
    }

    // Link it into the list
    pNode->pNext = g_pPrivateData;
    g_pPrivateData = pNode;

    return D3D_OK;
}   

//------------------------------------------------------------------------------
// D3DResource_GetPrivateData

extern "C"
HRESULT WINAPI D3DResource_GetPrivateData
(
    D3DResource *pResource, 
    REFGUID refguid, 
    void *pData, 
    DWORD *pSizeOfData
)
{
    COUNT_API(API_D3DRESOURCE_GETPRIVATEDATA);
    CHECK(pResource, "D3DResource_GetPrivateData");

    PrivateDataNode *pNode;

    // Find the node in our list
    pNode = FindPrivateData(pResource, refguid);
    if (pNode == NULL)
    {
        return D3DERR_NOTFOUND;
    }

    // Is the user just asking for the size?
    if (pData == NULL)
    {
        *pSizeOfData = pNode->size;
        return D3D_OK;
    }

    // Check if we were given a large enough buffer
    if (*pSizeOfData < pNode->size)
    {
        // If the buffer is insufficient, return
        // the necessary size in the out parameter
        *pSizeOfData = pNode->size;

        // An error is returned since pvBuffer != NULL and
        // no data was actually returned.
        return D3DERR_MOREDATA;
    }

    // There is enough room; so just overwrite with the right size
    *pSizeOfData = pNode->size;

    if (pNode->flags & D3DSPD_IUNKNOWN)
    {
        // Add-Ref the returned object
        *(IUnknown**)pData = pNode->pUnknown;
        pNode->pUnknown->AddRef();
        return D3D_OK;
    }
    else
    {
        memcpy(pData, pNode->Data, pNode->size);
    }

    return D3D_OK;
}

//------------------------------------------------------------------------------
// D3DResource_FreePrivateData

extern "C"
void WINAPI D3DResource_FreePrivateData
(
    D3DResource *pResource, 
    REFGUID refguid
)
{
    COUNT_API(API_D3DRESOURCE_FREEPRIVATEDATA);
    CHECK(pResource, "D3DResource_FreePrivateData");

    PrivateDataNode *pNode;
    PrivateDataNode **ppPrev;

    pNode = g_pPrivateData;
    ppPrev = &g_pPrivateData;

    while (pNode != NULL)
    {
        if (pNode->pObject == pResource && pNode->guid == refguid)
        {
            *ppPrev = pNode->pNext;

            if (pNode->flags & D3DSPD_IUNKNOWN)
            {
                pNode->pUnknown->Release();
            }

            MemFree(pNode);
            return;
        }

        ppPrev = &pNode->pNext;
        pNode = pNode->pNext;
    }
}

} // end of namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\resource.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       resource.hpp
 *  Content:    Resource helpers
 *
 ***************************************************************************/

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

//----------------------------------------------------------------------------
// Helper to get the data pointed to by a resource in the address space
// needed by the GPU. 
//
inline DWORD GetGPUDataFromResource(
    D3DResource *pResource
    )
{
    AssertPhysical(pResource->Data);

    return pResource->Data;
}

//----------------------------------------------------------------------------
// Check a surface to see if it's in use.
//
BOOL IsResourceSetInDevice(
    D3DResource *pResource
    );

//----------------------------------------------------------------------------
// Check a resource to see if it's in use.
//
__forceinline BOOL IsNonSurfaceResourceSetInDevice(
    D3DResource *pResource
    )
{
    ASSERT((pResource->Common & D3DCOMMON_TYPE_MASK) != D3DCOMMON_TYPE_SURFACE);

    return (pResource->Common & D3DCOMMON_INTREFCOUNT_MASK) != 0;
}

//----------------------------------------------------------------------------
// Destroys the contents of a resource when it has been completely released.
//
void DestroyResource(
    D3DResource *pResource
    );

//----------------------------------------------------------------------------
// Returns TRUE if the resource is a child surface (a surface pointing to
// a mipmap level or cubemap level), which always requires  special handling 
// of the parent for reference counts and surface times.
//
__forceinline BOOL IsChildSurface(
    D3DResource *pResource
    )
{
    return ((pResource->Common & D3DCOMMON_TYPE_MASK) == D3DCOMMON_TYPE_SURFACE)
         && (((D3DSurface*) pResource)->Parent != NULL);
}

//----------------------------------------------------------------------------
// Add an internal reference to a non-surface resource.  This indicates that 
// the resource is currently being used in the device.
//
__forceinline void InternalAddRef(
    D3DResource *pResource
    )
{
    ASSERT((pResource->Common & D3DCOMMON_INTREFCOUNT_MASK) != D3DCOMMON_INTREFCOUNT_MASK);
    ASSERT(!IsChildSurface(pResource));

    pResource->Common += (1 << D3DCOMMON_INTREFCOUNT_SHIFT);
}

//----------------------------------------------------------------------------
// Release an internal reference for non-surfaces.
//
__forceinline void InternalRelease(
    D3DResource *pResource
    )
{
    ASSERT((pResource->Common & D3DCOMMON_INTREFCOUNT_MASK) != 0);
    ASSERT(!IsChildSurface(pResource));

    pResource->Common -= (1 << D3DCOMMON_INTREFCOUNT_SHIFT);

    // Destroy the resource if both the internal and external reference counts
    // are now zero.
    if ((pResource->Common & (D3DCOMMON_INTREFCOUNT_MASK | D3DCOMMON_REFCOUNT_MASK)) == 0)
    {
        DestroyResource(pResource);
    }
}

//----------------------------------------------------------------------------
// Add an internal reference to a surface resource.  This indicates that 
// the resource is currently being used in the device.
//
void InternalAddRefSurface(
    D3DResource *pResource
    );

//----------------------------------------------------------------------------
// Release an internal reference for surfaces.
//
void InternalReleaseSurface(
    D3DResource *pResource
    );
                       
//----------------------------------------------------------------------------
// Helper to get the data pointed to by a resource. This always returns
// a pointer to the data in the CPU's write-combined address space and will
// need to be manually mapped to whatever view you need.
//
BYTE *GetDataFromResource(
    D3DResource *pResource
    );

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\shadersnapshot.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ShaderSnapshot.cpp
 *  Content:    Code to capture vertex and pixel shader snapshots for debug
 *
 ***************************************************************************/

#include "precomp.hpp"
#include "dm.h"
#include "rdi.h"

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

#define SHADER_CAPTURE_BUFFER_SIZE 32768

#define SS_REGISTER_T0IN      0x40000000
#define SS_REGISTER_T1IN      0x40000001
#define SS_REGISTER_T2IN      0x40000002
#define SS_REGISTER_T3IN      0x40000003

#define DRAWVERT_TYPE_VUP     0x1
#define DRAWVERT_TYPE_IVUP    0x2
#define DRAWVERT_TYPE_V       0x3
#define DRAWVERT_TYPE_IV      0x4

// Identifiers for data blocks in the capture buffer
#define PSS_EOF         0x00000000
#define PSS_PIXEL       0x01000000
#define PSS_FINAL       0x02000000
#define PSS_PRIMITIVE   0x03000000
#define PSS_STAGE       0x04000000
#define PSS_FINALSTAGE  0x05000000
#define PSS_IMAGE       0x06000000
#define PSS_NOSHADER    0x07000000
#define PSS_STAGE0      0x08000000

#define VSS_EOF         0x80000000
#define VSS_VERTEX      0x81000000
#define VSS_INSTRUCTION 0x82000000
#define VSS_PROGRAM     0x84000000
#define VSS_STATS       0x85000000

// opcode bits
#define SDOP_PSACTIVE   0x00000001
#define SDOP_VSACTIVE   0x00000002
#define SDOP_XRACTIVE   0x00000004
#define SDOP_HASALPHA   0x00000008

// encodings for Xray flags
#define INCREMENTSHIFT  4
#define INCREMENTMASK   (0xff << INCREMENTSHIFT)

#define FILLMODESHIFT   12
#define FILLMODEMASK    (0x3 << FILLMODESHIFT)

#define ZENABLESHIFT    14
#define ZENABLEMASK     (0x3 << ZENABLESHIFT)

#define STENCILENABLESHIFT    16
#define STENCILENABLEMASK     (0x3 << STENCILENABLESHIFT)

#define CULLMODESHIFT    18
#define CULLMODEMASK     (0x3 << CULLMODESHIFT)

#define GRAYSHIFT       20
#define GRAYMASK        (0x1 << GRAYSHIFT)

typedef struct _regval
{
    short a,r,g,b;
} REGVAL;

typedef struct _pscapture
{
    DWORD dwPreColor, dwPreDepth;
    DWORD dwCombinerCount;
    REGVAL t0in, t1in, t2in, t3in;
    REGVAL v0[9], v1[9];
    REGVAL t0[9], t1[9], t2[9], t3[9];
    REGVAL c0[9], c1[9];
    REGVAL r0[9], r1[9];
    REGVAL fog, sum, prod;
    DWORD dwPostColor, dwPostDepth;
} PSCAPTURE;

typedef struct _userstateentry
{
    D3DRENDERSTATETYPE Enum;
    DWORD Value;
} USERSTATEENTRY;

typedef struct vtxreg
{
    DWORD w,z,y,x;
} VTXREG;

typedef struct vtxio
{
    DWORD regs;     // lower 16 are VAB, upper are temp
    DWORD outs;     // output registers
    DWORD cnst;     // which constant
} VTXIO;

class DebugSnapshot
{
public:
    HRESULT HandleDrawVertices();
    HRESULT DrawVertices();
    
    // pixel shader methods
    HRESULT HandlePSDrawVertices();
    void BeginPSSnapshot(DWORD *args);
    void GetColorAndDepth(DWORD *pColor, DWORD *pDepth);
    void SetColorAndDepth(DWORD Color, DWORD Depth);
    void EndPSSnapshot(void);
    void GetStageData(UINT i);
    void GetRegister(DWORD dwReg, UINT i);
    void SaveUserState(void);
    void RestoreUserState(BOOL bUsingPixelShader);
    void SetPassThroughState(void);
    void WriteCapture(DWORD val);
    void DumpImage(void);
    void WriteColor24(DWORD val);
    
    // vertex shader methods
    HRESULT HandleVSDrawVertices();
    void BeginVSSnapshot(DWORD *args);
    void EndVSSnapshot(void);

    // xray methods
    HRESULT HandleXRDrawVertices();
    
public:    
    DWORD DrawVertType;
    D3DPRIMITIVETYPE PrimitiveType;
    UINT VertexCount;
    CONST void* pIndexData;
    CONST void* pVertexStreamZeroData;
    UINT VertexStreamZeroStride;
    UINT StartVertex;
    DWORD dwCaptureCount;
    DWORD dwFlags;
    DWORD dwMarker;
    DWORD dwXRFlags;

private:    
    // pixel shader capture
    DWORD dwX, dwY;     // pixel to sample
    IDirect3DSurface8 *pBackBuffer;
    IDirect3DSurface8 *pDepthBuffer;
    PSCAPTURE pscpt;
    DWORD dwXScale, dwYScale;
    USERSTATEENTRY UserState[50];
    DWORD UserStateCount;
    DWORD dwScissorRectCount;
    D3DRECT ScissorRects[D3DSCISSORS_MAX];
    BOOL  bScissorExclusive;

    // vertex shader capture
    VTXREG MaskOutputs[16];
    INT a0x;
    DWORD ShaderVerts, OtherVerts;
    DWORD dwProcessedVertexCount;
    DWORD dwFirstVertex, dwLastVertex;
    void DumpVtxInstruction(int inst, VTXREG *VtxProgram, VTXREG *VtxConstant, VTXREG *vals, DWORD *valcnt, BYTE *indexes, DWORD *idxcnt);
};

//------------------------------------------------------------------------------
// The following code and global variables are only needed in debug builds.

DebugSnapshot g_snapshot;

void
DebugSnapshot::WriteColor24(DWORD val)
{
    static DWORD dwByteCnt = 0;
    static DWORD dwData = 0;
    BYTE b;
    UINT i;
    for(i=0; i<3; i++)
    {
        switch(i)
        {
        case 0: b=(BYTE)((val >>  0) & 0xff); break;
        case 1: b=(BYTE)((val >>  8) & 0xff); break;
        case 2: b=(BYTE)((val >> 16) & 0xff); break;
        }
        switch(dwByteCnt)
        {
        case 0: dwData |= (DWORD)b <<  0; dwByteCnt++; break;
        case 1: dwData |= (DWORD)b <<  8; dwByteCnt++; break;
        case 2: dwData |= (DWORD)b << 16; dwByteCnt++; break;
        case 3: 
            dwData |= (DWORD)b << 24;
            WriteCapture(dwData);
            dwData = 0;
            dwByteCnt = 0;
            break;
        }
    }
}

void
DebugSnapshot::WriteCapture(DWORD val)
{
    if(dwCaptureCount >= SHADER_CAPTURE_BUFFER_SIZE/4)
        return;
    
    CDevice* pDevice = g_pDevice;
    *pDevice->m_pShaderCapturePtr = val;
    pDevice->m_pShaderCapturePtr++;
    dwCaptureCount++;
}

void
DebugSnapshot::RestoreUserState(BOOL bUsingPixelShader)
{
    UINT i;
    CDevice* pDevice = g_pDevice;

    if(bUsingPixelShader)
    {
        for(i=0; i<UserStateCount; i++)
            pDevice->SetRenderState(UserState[i].Enum, UserState[i].Value);
    }
    else
    {
        for(i=0; i<UserStateCount; i++)
        {
            if((UserState[i].Enum >= D3DRS_PS_MIN) && (UserState[i].Enum <= D3DRS_PS_MAX))
                continue;
            pDevice->SetRenderState(UserState[i].Enum, UserState[i].Value);
        }
    }

    D3D__DirtyFlags |= (D3DDIRTYFLAG_COMBINERS | D3DDIRTYFLAG_SHADER_STAGE_PROGRAM | D3DDIRTYFLAG_SPECFOG_COMBINER);

    // restore scissor rects
    pDevice->SetScissors(dwScissorRectCount, bScissorExclusive, ScissorRects);
}

void
DebugSnapshot::SaveUserState(void)
{
    UINT i;
    CDevice* pDevice = g_pDevice;

    for(i=0; i<UserStateCount; i++)
        UserState[i].Value = D3D__RenderState[UserState[i].Enum];

    // Get current scissor rects
    pDevice->GetScissors(&dwScissorRectCount, &bScissorExclusive, ScissorRects);
}

void
DebugSnapshot::SetPassThroughState(void)
{
    DWORD dwFCabcd, dwFCefg, dwFCefgSave;
    CDevice* pDevice = g_pDevice;

    // set scissor rects to a single pixel
    D3DRECT rect;
    rect.x1 = dwX;
    rect.y1 = dwY;
    rect.x2 = rect.x1 + 1;
    rect.y2 = rect.y1 + 1;
    pDevice->SetScissors(1, FALSE, &rect);

    // set pass-through mode
    pDevice->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE); // no alpha test
    pDevice->SetRenderState(D3DRS_STENCILENABLE, FALSE);   // no stencil test
    pDevice->SetRenderState(D3DRS_ZENABLE, FALSE);         // no z test
    pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
    pDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE); // write only source color
    pDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ZERO);
    pDevice->SetRenderState(D3DRS_COLORWRITEENABLE, D3DCOLORWRITEENABLE_RED |
                                                         D3DCOLORWRITEENABLE_GREEN |
                                                         D3DCOLORWRITEENABLE_BLUE |
                                                         D3DCOLORWRITEENABLE_ALPHA);
    // set up final combiner for pass-through
    dwFCabcd = PS_COMBINERINPUTS( 
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);

    // keep E and F inputs unchanged
    dwFCefg = PS_COMBINERINPUTS(
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_FINALCOMBINERSETTING_CLAMP_SUM | 0 | 0);
    pDevice->SetRenderState(D3DRS_PSFINALCOMBINERINPUTSABCD, dwFCabcd);
    dwFCefgSave = D3D__RenderState[D3DRS_PSFINALCOMBINERINPUTSEFG];
    dwFCefg &= 0x0000ffff;  // clear new E and F bits
    dwFCefgSave &= 0xffff0000;  // remove G and flags
    dwFCefg |= dwFCefgSave;     // combine old E and F with new G and flags
    pDevice->SetRenderState(D3DRS_PSFINALCOMBINERINPUTSEFG, dwFCefg);
    
}

void 
DebugSnapshot::BeginPSSnapshot(DWORD *args)
{
    CDevice* pDevice = g_pDevice;
    
    dwCaptureCount = 0;     //initialize count of dwords written

    dwX = *args;     // set pixel offsets for this session
    dwY = *(args+1);
    dwFlags = *(args+2);
    dwMarker = *(args+3);

    WriteCapture(PSS_PIXEL | 2);
    WriteCapture((dwY << 16) | dwX);
    
    // initialize user state storage
    UserStateCount = 0;
    UserState[UserStateCount++].Enum = D3DRS_ALPHATESTENABLE;
    UserState[UserStateCount++].Enum = D3DRS_STENCILENABLE;
    UserState[UserStateCount++].Enum = D3DRS_ZENABLE;
    UserState[UserStateCount++].Enum = D3DRS_ALPHABLENDENABLE;
    UserState[UserStateCount++].Enum = D3DRS_SRCBLEND;
    UserState[UserStateCount++].Enum = D3DRS_DESTBLEND;
    UserState[UserStateCount++].Enum = D3DRS_COLORWRITEENABLE;
    UserState[UserStateCount++].Enum = D3DRS_PSTEXTUREMODES;
    UserState[UserStateCount++].Enum = D3DRS_PSFINALCOMBINERINPUTSABCD;
    UserState[UserStateCount++].Enum = D3DRS_PSFINALCOMBINERINPUTSEFG;
    UserState[UserStateCount++].Enum = D3DRS_PSCOMBINERCOUNT;
    UserState[UserStateCount++].Enum = D3DRS_PSRGBINPUTS0;
    UserState[UserStateCount++].Enum = D3DRS_PSRGBINPUTS1;
    UserState[UserStateCount++].Enum = D3DRS_PSRGBINPUTS2;
    UserState[UserStateCount++].Enum = D3DRS_PSRGBINPUTS3;
    UserState[UserStateCount++].Enum = D3DRS_PSRGBINPUTS4;
    UserState[UserStateCount++].Enum = D3DRS_PSRGBINPUTS5;
    UserState[UserStateCount++].Enum = D3DRS_PSRGBINPUTS6;
    UserState[UserStateCount++].Enum = D3DRS_PSRGBINPUTS7;
    UserState[UserStateCount++].Enum = D3DRS_PSALPHAINPUTS0;
    UserState[UserStateCount++].Enum = D3DRS_PSALPHAINPUTS1;
    UserState[UserStateCount++].Enum = D3DRS_PSALPHAINPUTS2;
    UserState[UserStateCount++].Enum = D3DRS_PSALPHAINPUTS3;
    UserState[UserStateCount++].Enum = D3DRS_PSALPHAINPUTS4;
    UserState[UserStateCount++].Enum = D3DRS_PSALPHAINPUTS5;
    UserState[UserStateCount++].Enum = D3DRS_PSALPHAINPUTS6;
    UserState[UserStateCount++].Enum = D3DRS_PSALPHAINPUTS7;
    UserState[UserStateCount++].Enum = D3DRS_PSRGBOUTPUTS0;
    UserState[UserStateCount++].Enum = D3DRS_PSRGBOUTPUTS1;
    UserState[UserStateCount++].Enum = D3DRS_PSRGBOUTPUTS2;
    UserState[UserStateCount++].Enum = D3DRS_PSRGBOUTPUTS3;
    UserState[UserStateCount++].Enum = D3DRS_PSRGBOUTPUTS4;
    UserState[UserStateCount++].Enum = D3DRS_PSRGBOUTPUTS5;
    UserState[UserStateCount++].Enum = D3DRS_PSRGBOUTPUTS6;
    UserState[UserStateCount++].Enum = D3DRS_PSRGBOUTPUTS7;
    UserState[UserStateCount++].Enum = D3DRS_PSALPHAOUTPUTS0;
    UserState[UserStateCount++].Enum = D3DRS_PSALPHAOUTPUTS1;
    UserState[UserStateCount++].Enum = D3DRS_PSALPHAOUTPUTS2;
    UserState[UserStateCount++].Enum = D3DRS_PSALPHAOUTPUTS3;
    UserState[UserStateCount++].Enum = D3DRS_PSALPHAOUTPUTS4;
    UserState[UserStateCount++].Enum = D3DRS_PSALPHAOUTPUTS5;
    UserState[UserStateCount++].Enum = D3DRS_PSALPHAOUTPUTS6;
    UserState[UserStateCount++].Enum = D3DRS_PSALPHAOUTPUTS7;
    UserState[UserStateCount++].Enum = D3DRS_PSFINALCOMBINERINPUTSABCD;
    UserState[UserStateCount++].Enum = D3DRS_PSFINALCOMBINERINPUTSEFG;

    if(D3D_OK != pDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &(pBackBuffer)))
        pBackBuffer = NULL;
    if(D3D_OK != pDevice->GetDepthStencilSurface(&(pDepthBuffer)))
        pDepthBuffer = NULL;

    dwXScale = Round(pDevice->m_AntiAliasScaleX);
    dwYScale = Round(pDevice->m_AntiAliasScaleY);
}

void 
DebugSnapshot::GetColorAndDepth(DWORD *pColor, DWORD *pDepth)
{
    D3DLOCKED_RECT lr;
    
    g_pDevice->BlockUntilIdle();   // kick off the pushbuffer and wait until the hw is idle

    if(pBackBuffer)
    {
        pBackBuffer->LockRect(&lr, NULL, D3DLOCK_TILED);
        *pColor = *((DWORD *)lr.pBits + dwYScale*dwY*lr.Pitch/4 + dwXScale*dwX);
        pBackBuffer->UnlockRect();
    }
    else
        *pColor = 0;

    if(pDepthBuffer)
    {
        pDepthBuffer->LockRect(&lr, NULL, D3DLOCK_TILED);
        *pDepth = *((DWORD *)lr.pBits + dwYScale*dwY*lr.Pitch/4 + dwXScale*dwX);
        pDepthBuffer->UnlockRect();
    }
    else
        pDepth = 0;
}

void 
DebugSnapshot::SetColorAndDepth(DWORD Color, DWORD Depth)
{
    D3DLOCKED_RECT lr;
    
    g_pDevice->BlockUntilIdle();   // kick off the pushbuffer and wait until the hw is idle

    if(pBackBuffer)
    {
        pBackBuffer->LockRect(&lr, NULL, D3DLOCK_TILED);
        *((DWORD *)lr.pBits + dwYScale*dwY*lr.Pitch/4 + dwXScale*dwX) = Color;
        pBackBuffer->UnlockRect();
    }

    if(pDepthBuffer)
    {
        pDepthBuffer->LockRect(&lr, NULL, D3DLOCK_TILED);
        *((DWORD *)lr.pBits + dwYScale*dwY*lr.Pitch/4 + dwXScale*dwX) = Depth;
        pDepthBuffer->UnlockRect();
    }
}

void
DebugSnapshot::DumpImage(void)
{
    // dump 64x64 image surrounding the target
    D3DLOCKED_RECT lr;
    
    if(pBackBuffer)
    {
        WriteCapture(PSS_IMAGE | (3072+2));
        WriteCapture((64 << 16) | 64);          // size of image
        pBackBuffer->LockRect(&lr, NULL, D3DLOCK_TILED);
        
        INT iX, iY;
        for(iY=(dwY+32); iY>(INT)(dwY-32); iY--)
        {
            for(iX=(dwX-32); iX<(INT)(dwX+32); iX++)
            {
                if((iY<0) || (iY>=480) || (iX<0) || (iX>=640))
                    WriteColor24(0);
                else
                    WriteColor24(*((DWORD *)lr.pBits + dwYScale*iY*lr.Pitch/4 + dwXScale*iX));
            }
    
        }
        pBackBuffer->UnlockRect();
    }
}

void 
DebugSnapshot::EndPSSnapshot(void)
{
    // write final color to capture buffer
    DWORD dwColor, dwDepth;
    GetColorAndDepth(&dwColor, &dwDepth);

    WriteCapture(PSS_FINAL | 3);
    WriteCapture(dwColor);
    WriteCapture(dwDepth);
    
    // write an image of the pixels surrounding the target
    DumpImage();

    // mark the end of the buffer
    WriteCapture(PSS_EOF);

    if(pBackBuffer)
        pBackBuffer->Release();
    if(pDepthBuffer)
        pDepthBuffer->Release();
}

HRESULT
DebugSnapshot::DrawVertices()
{
    CDevice* pDevice = g_pDevice;
    DWORD dwSave = pDevice->m_dwSnapshot;
    BOOL bVSD;  // true if we're in the vertex shader debugger

    bVSD = ((pDevice->m_dwSnapshot & SDOP_VSACTIVE) != 0);

    // Leave snapshot mode and call the appropriate D3D DrawVertices method
    pDevice->m_dwSnapshot = 0x0;
    switch(DrawVertType)
    {
    case DRAWVERT_TYPE_VUP:
        pDevice->DrawVerticesUP(PrimitiveType,
                                VertexCount,
                                pVertexStreamZeroData,
                                VertexStreamZeroStride);

        break;
    case DRAWVERT_TYPE_IVUP:
        if(bVSD)
            // only draw 1 vertex so vertex cache doesn't keep shader from running
            pDevice->DrawIndexedVerticesUP(PrimitiveType,
                                           1,
                                           (const WORD *)pIndexData + VertexCount-1,
                                           pVertexStreamZeroData,
                                           VertexStreamZeroStride);
        else
            // draw all vertices
            pDevice->DrawIndexedVerticesUP(PrimitiveType,
                                           VertexCount,
                                           (const WORD *)pIndexData,
                                           pVertexStreamZeroData,
                                           VertexStreamZeroStride);
        break;
    case DRAWVERT_TYPE_V:
        pDevice->DrawVertices(PrimitiveType,
                              StartVertex,
                              VertexCount);

        break;
    case DRAWVERT_TYPE_IV:
        if(bVSD)
            // only draw 1 vertex so vertex cache doesn't keep shader from running
            pDevice->DrawIndexedVertices(PrimitiveType,
                                         1,
                                         (const WORD *)pIndexData + VertexCount-1);
        else
            // draw all vertices
            pDevice->DrawIndexedVertices(PrimitiveType,
                                         VertexCount,
                                         (const WORD *)pIndexData);
        break;
    }
    pDevice->m_dwSnapshot = dwSave;
    return S_OK;
}

static const char* kOutNames[] = {"oPos",
    "o1?", "o2?",
    "oD0", "oD1",
    "oFog", "oPts",
    "oB0", "oB1",
    "oT0", "oT1", "oT2", "oT3", "???"
};

void GetVertexInputsAndOutputs(VTXREG *pInst, VTXIO *pInputs, VTXIO *pOutputs)
{
    // initialize
    pInputs->regs = pOutputs->regs = 0;           // no regs selected
    pInputs->outs = pOutputs->outs = 0;           // no outputs selected
    pInputs->cnst = pOutputs->cnst = 0xffffffff;  // invalid constant

    // decode instruction
    DWORD aws = (pInst->y >>  0) & 0x3;
    DWORD azs = (pInst->y >>  2) & 0x3;
    DWORD ays = (pInst->y >>  4) & 0x3;
    DWORD axs = (pInst->y >>  6) & 0x3;
    DWORD ane = (pInst->y >>  8) & 0x1;
    DWORD va =  (pInst->y >>  9) & 0xf;
    DWORD ca =  (pInst->y >> 13) & 0xff;
    DWORD mac = (pInst->y >> 21) & 0xf;
    DWORD ilu = (pInst->y >> 25) & 0x7;

    DWORD crr = (pInst->z <<  2) & 0xc;
    DWORD cws = (pInst->z >>  2) & 0x3;
    DWORD czs = (pInst->z >>  4) & 0x3;
    DWORD cys = (pInst->z >>  6) & 0x3;
    DWORD cxs = (pInst->z >>  8) & 0x3;
    DWORD cne = (pInst->z >> 10) & 0x1;
    DWORD bmx = (pInst->z >> 11) & 0x3;
    DWORD brr = (pInst->z >> 13) & 0xf;
    DWORD bws = (pInst->z >> 17) & 0x3;
    DWORD bzs = (pInst->z >> 19) & 0x3;
    DWORD bys = (pInst->z >> 21) & 0x3;
    DWORD bxs = (pInst->z >> 23) & 0x3;
    DWORD bne = (pInst->z >> 25) & 0x1;
    DWORD amx = (pInst->z >> 26) & 0x3;
    DWORD arr = (pInst->z >> 28) & 0xf;

    DWORD eos = (pInst->w >>  0) & 0x1;
    DWORD cin = (pInst->w >>  1) & 0x1;
    DWORD om =  (pInst->w >>  2) & 0x1;
    DWORD oc =  (pInst->w >>  3) & 0x1ff;
    DWORD owm = (pInst->w >> 12) & 0xf;
    DWORD swm = (pInst->w >> 16) & 0xf;
    DWORD rw =  (pInst->w >> 20) & 0xf;
    DWORD rwm = (pInst->w >> 24) & 0xf;
    DWORD cmx = (pInst->w >> 28) & 0x3;
    crr |= (pInst->w >> 30) & 0x3;

    // decode inputs
    if(mac != 0)
    {
        switch(amx)
        {
        case 1: pInputs->regs |= (1 << (16+arr)); break;   // temp register input
        case 2: pInputs->regs |= (1 << va); break;       // vab register input
        case 3: pInputs->cnst = ca;                      // constant
        }
    }
    if((mac != 0x1) &&  // MAC_MOV
       (mac != 0x3) &&  // MAC_ADD
       (mac != 0xd))    // MAC_ARL
    {
        switch(bmx)
        {
        case 1: pInputs->regs |= (1 << (16+brr)); break;   // temp register input
        case 2: pInputs->regs |= (1 << va); break;       // vab register input
        case 3: pInputs->cnst = ca;                      // constant
        }
    }
    if((mac == 0x3) ||  // MAC_ADD
       (mac == 0x4) ||  // MAC_MAD
       (ilu != 0))
    {
        switch(cmx)
        {
        case 1: pInputs->regs |= (1 << (16+crr)); break;   // temp register input
        case 2: pInputs->regs |= (1 << va); break;       // vab register input
        case 3: pInputs->cnst = ca;                      // constant
        }
    }

    // decode outputs
    if(rwm)
        pOutputs->regs |= (1 << (16+rw));              // temp register output
    
    if(owm)
    {
        if(oc & 0x100)
            pOutputs->outs |= (1 << (oc & 0xff));
        else
            pOutputs->cnst = oc;
    }
    if(swm)
    {
        if((mac != 0) && (ilu != 0))
            pOutputs->regs |= (1 << (16+1));               // add R1 output
        else
            pOutputs->regs |= (1 << (16+rw));              // temp register output
    }
}

void ReplaceInstWithMoveTemp(int inst, int i)
{
    struct _VtxPgm
    {
        WORD    type;
        WORD    size;
        DWORD   x,y,z,w;
    } VtxPgm;
    
    VtxPgm.type = 0;
    VtxPgm.size = 1;
    VtxPgm.x = 0;
    VtxPgm.y = 0x0020001b; // microcode for mov c-96, r0
    VtxPgm.z = 0x0436106c;
    VtxPgm.w = 0x2070f000;
    
    // Change source register
    VtxPgm.z |= (i & 0xf) << 28;

    // load it
    g_pDevice->LoadVertexShaderProgram((DWORD *)&VtxPgm, inst);
}

void GetConstant0(VTXREG *pC0)
{
    g_pDevice->BlockUntilIdle();   // kick off the pushbuffer and wait until the hw is idle
    D3DRDI_GetRamData(RDI_INDEX_VTX_CONSTANTS0, 0, pC0, sizeof(VTXREG));
}

void ReplaceInst(int inst, VTXREG *pInstruction)
{
    struct _VtxPgm
    {
        WORD    type;
        WORD    size;
        DWORD   x,y,z,w;
    } VtxPgm;
    
    VtxPgm.type = 0;
    VtxPgm.size = 1;
    VtxPgm.x = pInstruction->x;
    VtxPgm.y = pInstruction->y;
    VtxPgm.z = pInstruction->z;
    VtxPgm.w = pInstruction->w;
    
    // load it
    g_pDevice->LoadVertexShaderProgram((DWORD *)&VtxPgm, inst);
}

void SetConstant(int i, VTXREG *pConstant)
{
    CDevice* pDevice = g_pDevice;
    DWORD reverse[4];
    reverse[0] = pConstant->x;
    reverse[1] = pConstant->y;
    reverse[2] = pConstant->z;
    reverse[3] = pConstant->w;

    DWORD save = pDevice->m_ConstantMode;
    pDevice->m_ConstantMode = D3DSCM_192CONSTANTS;
    pDevice->SetVertexShaderConstant(i-96, &reverse, 1);
    pDevice->m_ConstantMode = save;
}

void WriteVTXREG(VTXREG *val, VTXREG *vals, DWORD *valcnt, BYTE *indexes, DWORD *indcnt)
{
    UINT i;
    for(i=0; i<*valcnt; i++)
    {
        if((vals[i].x == val->x) &&
           (vals[i].y == val->y) &&
           (vals[i].z == val->z) &&
           (vals[i].w == val->w))
            break;
    }
    if(i == *valcnt)
    {
        // add new output value
        if(*valcnt == 256)
        {
            i = 0;
        }
        else
        {
            i = *valcnt;
            vals[*valcnt] = *val;
            *valcnt = *valcnt + 1;
        }
    }
    indexes[*indcnt] = (BYTE)i;
    *indcnt = *indcnt + 1;
}

void DebugSnapshot::DumpVtxInstruction(int inst, 
                                       VTXREG *VtxProgram, 
                                       VTXREG *VtxConstant, 
                                       VTXREG *vals, 
                                       DWORD *valcnt, 
                                       BYTE *indexes, 
                                       DWORD *idxcnt)
{
    int i;
    VTXIO inputs, outputs;
    VTXREG C0;
    DWORD ARLType=0, ARLCount, ARLVal=0, ARLSwizzle;
    INT idx;

    if(VtxProgram[inst].w & 0x2)
        idx = a0x;
    else
        idx = 0;

    GetVertexInputsAndOutputs(&(VtxProgram[inst]), &inputs, &outputs);

    if(((VtxProgram[inst].y >> 21) & 0xf) == 0xd)  // is this an ARL instruction?
    {
        ARLSwizzle = ((VtxProgram[inst].y >> 6) & 0x3); // (axs)
        ARLType = ((VtxProgram[inst].z >> 26) & 0x3);  // (amx)
        switch(ARLType)
        {
        case 1: // temp
            ARLCount = ((VtxProgram[inst].z >> 28) & 0xf);  // (arr)
            break;
        case 2: // vab
            ARLCount = ((VtxProgram[inst].y >> 9) & 0xf);   // (va)
            break;
        case 3: // const
            ARLCount = ((VtxProgram[inst].y >> 13) & 0xff); // (ca)
            break;
        }
    }

    // Dump inputs
    // vab
    for(i=0; i<16; i++)
    {
        if(inputs.regs & (1<<i))
        {
            // Get the VAB
            g_pDevice->BlockUntilIdle();   // kick off the pushbuffer and wait until the hw is idle
            VTXREG VtxVAB[16];
            D3DRDI_GetRamData(RDI_INDEX_XL_VAB, 0, VtxVAB, sizeof(VtxVAB));
            WriteVTXREG(&(VtxVAB[i]), vals, valcnt, indexes, idxcnt);
            if((ARLType == 2) && (ARLCount == i))
            {
                switch(ARLSwizzle)
                {
                case 0: ARLVal = VtxVAB[i].x; break;
                case 1: ARLVal = VtxVAB[i].y; break;
                case 2: ARLVal = VtxVAB[i].z; break;
                case 3: ARLVal = VtxVAB[i].w; break;
                }
            }
        }
    }

    // constant
    if(inputs.cnst != 0xffffffff)
    {
        // refresh the constants
        g_pDevice->BlockUntilIdle();   // kick off the pushbuffer and wait until the hw is idle
        D3DRDI_GetRamData(RDI_INDEX_VTX_CONSTANTS0, 0, VtxConstant, 192*sizeof(VTXREG));
        WriteVTXREG(&(VtxConstant[inputs.cnst+idx]), vals, valcnt, indexes, idxcnt);
        if((ARLType == 3) && (ARLCount == inputs.cnst))
        {
            switch(ARLSwizzle)
            {
            case 0: ARLVal = VtxConstant[inputs.cnst+idx].x; break;
            case 1: ARLVal = VtxConstant[inputs.cnst+idx].y; break;
            case 2: ARLVal = VtxConstant[inputs.cnst+idx].z; break;
            case 3: ARLVal = VtxConstant[inputs.cnst+idx].w; break;
            }
        }
    }
    
    // temp
    for(i=0; i<16; i++)
    {
        if(inputs.regs & (1<<(i+16)))
        {
            ReplaceInstWithMoveTemp(inst, i);
            DrawVertices();
            GetConstant0(&C0);
            ReplaceInst(inst, &(VtxProgram[inst]));
            SetConstant(0, &(VtxConstant[0]));
            WriteVTXREG(&(C0), vals, valcnt, indexes, idxcnt);
            if((ARLType == 1) && (ARLCount == i))
            {
                switch(ARLSwizzle)
                {
                case 0: ARLVal = C0.x; break;
                case 1: ARLVal = C0.y; break;
                case 2: ARLVal = C0.z; break;
                case 3: ARLVal = C0.w; break;
                }
            }
        }
    }
    
    // Dump outputs
    // Output registers
    for(i=0; i<16; i++)
    {
        if(outputs.outs & (1<<i))
        {
            // modify instruction to write constant instead of output
            VTXREG newi;
            newi = VtxProgram[inst];
            newi.w &= 0xfffff007;   // output is now c0
            ReplaceInst(inst, &newi);
            DrawVertices();
            GetConstant0(&C0);
            ReplaceInst(inst, &(VtxProgram[inst]));
            SetConstant(0, &(VtxConstant[0]));
            // get write mask for output register
            if((VtxProgram[inst].w >> 12) & 0x1) MaskOutputs[i].w = C0.w;
            if((VtxProgram[inst].w >> 13) & 0x1) MaskOutputs[i].z = C0.z;
            if((VtxProgram[inst].w >> 14) & 0x1) MaskOutputs[i].y = C0.y;
            if((VtxProgram[inst].w >> 15) & 0x1) MaskOutputs[i].x = C0.x;
            WriteVTXREG(&(MaskOutputs[i]), vals, valcnt, indexes, idxcnt);
        }
    }

    // constant
    if(outputs.cnst != 0xffffffff)
    {
        // modify instruction to end program
        VTXREG newi;
        newi = VtxProgram[inst];
        newi.w &= 0xfffff007;   // output is now c0
        ReplaceInst(inst, &newi);
        DrawVertices();
        GetConstant0(&C0);
        ReplaceInst(inst, &(VtxProgram[inst]));
        SetConstant(0, &(VtxConstant[0]));
        WriteVTXREG(&(C0), vals, valcnt, indexes, idxcnt);
    }

    // temp
    for(i=0; i<16; i++)
    {
        // can't get temp reg output for last program slot
        if((outputs.regs & (1<<(i+16))) && (inst < 135))
        {
            VTXREG newi;
            newi = VtxProgram[inst];
            newi.w &= 0xfffffffe;   // clear eos if set
            ReplaceInst(inst, &newi);
            // set next instruction to move temp reg to c0
            ReplaceInstWithMoveTemp(inst+1, i);
            DrawVertices();
            GetConstant0(&C0);
            // restore instructions
            ReplaceInst(inst, &(VtxProgram[inst]));
            ReplaceInst(inst+1, &(VtxProgram[inst+1]));
            SetConstant(0, &(VtxConstant[0]));
            WriteVTXREG(&(C0), vals, valcnt, indexes, idxcnt);
        }
    }
    
    // Update a0.x if necessary
    if(ARLType != 0)
    {
        a0x = (INT)FloatToLong(*((FLOAT *)(&(ARLVal))));
        if((VtxProgram[inst].y >> 8) & 0x1) // (ane)
            a0x = -a0x;
    }
}

HRESULT
DebugSnapshot::HandleVSDrawVertices()
{
    UINT i;
    CDevice* pDevice = g_pDevice;
    
    if (pDevice->m_pVertexShader->Flags & (VERTEXSHADER_PROGRAM))
    {
        ShaderVerts += VertexCount;
    }
    else
    {
        OtherVerts += VertexCount;
        return S_OK;    // no need to draw these
    }

    // *********** Set up for this vertex buffer
    
    // set the vertex shader to write mode
    PPUSH pPush = pDevice->StartPush();

    Push2(pPush, 
          
          NV097_SET_TRANSFORM_EXECUTION_MODE,

          // NV097_SET_TRANSFORM_EXECUTION_MODE:

          (DRF_DEF(097, _SET_TRANSFORM_EXECUTION_MODE, _MODE, _PROGRAM) |
           DRF_DEF(097, _SET_TRANSFORM_EXECUTION_MODE, _RANGE_MODE, _PRIV)),

          // NV097_SET_TRANSFORM_PROGRAM_CXT_WRITE_EN:

          0xffffffff & VERTEXSHADER_WRITE);
    
    pDevice->EndPush(pPush+3);
    
    
    g_pDevice->BlockUntilIdle();   // kick off the pushbuffer and wait until the hw is idle
    
    // Get the Constants
    VTXREG VtxConstant[192];
    D3DRDI_GetRamData(RDI_INDEX_VTX_CONSTANTS0, 0, VtxConstant, sizeof(VtxConstant));

    // Get the Vertex Program
    VTXREG VtxProgram[136];
    D3DRDI_GetRamData(RDI_INDEX_XL_PROGRAM, 0, VtxProgram, sizeof(VtxProgram));

    // Dump program instructions to buffer
    UINT instcnt = 0;
    for(i=pDevice->m_VertexShaderStart; ; i++)
    {
        instcnt++;
        if(VtxProgram[i].w & 0x1)
            break;
    }
    
    if(dwCaptureCount + instcnt*3+1 >= SHADER_CAPTURE_BUFFER_SIZE/4)
    {
        // Buffer won't hold program, write EOF instead
        WriteCapture(VSS_EOF);
        dwLastVertex = 0;       // finished capturing for this frame
    }
    else
    {
        WriteCapture(VSS_PROGRAM | instcnt*3+1);
        for(i=pDevice->m_VertexShaderStart; ; i++)
        {
            WriteCapture(VtxProgram[i].y);
            WriteCapture(VtxProgram[i].z);
            WriteCapture(VtxProgram[i].w);
            if(VtxProgram[i].w & 0x1)
                break;
        }
    }


    VTXREG vals[256];
    DWORD valcnt;
    BYTE indexes[500];
    DWORD idxcnt;

    // Step through vertices in vertex buffer
    DWORD dwTotalVertices = VertexCount;
    DWORD vert;

    for(vert=1; vert <= dwTotalVertices; vert++)
    {
        if((dwProcessedVertexCount < dwFirstVertex) ||
           (dwProcessedVertexCount > dwLastVertex))
        {
            dwProcessedVertexCount++;
            continue;
        }
        
        VertexCount = vert; // VertexCount determines vertices processed in DrawVertices
        
        //******** Set up to run this vertex through the shader
        // initialize output registers and address offset register
        for(i=0; i<16; i++)
        {
            MaskOutputs[i].x = 0;
            MaskOutputs[i].y = 0;
            MaskOutputs[i].z = 0;
            MaskOutputs[i].w = 0;
        }
        a0x = 0;    // initialize address offset register

        // Get V0
        DrawVertices();
        g_pDevice->BlockUntilIdle();   // kick off the pushbuffer and wait until the hw is idle
        VTXREG VtxVAB[16];
        D3DRDI_GetRamData(RDI_INDEX_XL_VAB, 0, VtxVAB, sizeof(VtxVAB));

        valcnt = idxcnt = 0;
        vals[valcnt++] = VtxVAB[0]; // make sure V0 is in the buffer first

        // Step through the current program
        for(i=pDevice->m_VertexShaderStart; ; i++)
        {
            DumpVtxInstruction(i, VtxProgram, VtxConstant, vals, &valcnt, indexes, &idxcnt);
            
            // Check for EOS
            if(VtxProgram[i].w & 0x1)
                break;
        }
        
        // Finished running shader, write out information for this vertex
        DWORD dwVertexSize = 3 + valcnt*4 + (idxcnt-1)/4 + 1;
        if(dwCaptureCount + dwVertexSize >= SHADER_CAPTURE_BUFFER_SIZE/4)
        {
            // Buffer won't hold vertex, write EOF instead
            WriteCapture(VSS_EOF);
            dwLastVertex = 0;       // finished capturing for this frame
        }
        else
        {
            WriteCapture(VSS_VERTEX | dwVertexSize);
            WriteCapture(dwProcessedVertexCount++);
            WriteCapture(((valcnt & 0xffff) << 16) | ((idxcnt-1)/4 + 1));
            for(i=0; i<valcnt; i++)
            {
                WriteCapture(vals[i].x);
                WriteCapture(vals[i].y);
                WriteCapture(vals[i].z);
                WriteCapture(vals[i].w);
            }
            DWORD *dwptr = (DWORD *)indexes;
            for(i=0; i < ((idxcnt-1)/4 + 1); i++)
                WriteCapture(*dwptr++);
        }
    }
    // restore original VertexCount value
    VertexCount = dwTotalVertices;

    // *********** Finished with this vertex buffer
    
    // reset write mode to original
    pPush = pDevice->StartPush();

    Push2(pPush, 
          
          NV097_SET_TRANSFORM_EXECUTION_MODE,

          // NV097_SET_TRANSFORM_EXECUTION_MODE:

          (DRF_DEF(097, _SET_TRANSFORM_EXECUTION_MODE, _MODE, _PROGRAM) |
           DRF_DEF(097, _SET_TRANSFORM_EXECUTION_MODE, _RANGE_MODE, _PRIV)),

          // NV097_SET_TRANSFORM_PROGRAM_CXT_WRITE_EN:

          pDevice->m_pVertexShader->Flags & VERTEXSHADER_WRITE);
    
    pDevice->EndPush(pPush+3);
    return S_OK;
}

HRESULT 
DebugSnapshot::HandlePSDrawVertices()
{
    UINT i;
    CDevice* pDevice = g_pDevice;
    
    // Save user state at time of DrawVertices call
    SaveUserState();

    // get color and z value before capture
    GetColorAndDepth(&(pscpt.dwPreColor), &(pscpt.dwPreDepth));
    
    // Check if this DrawVertices call affects the sample pixel
    SetPassThroughState();
    DrawVertices();

    DWORD dwTestColor, dwTestDepth;
    GetColorAndDepth(&dwTestColor, &dwTestDepth);

    if((dwTestColor == pscpt.dwPreColor) &&
       (dwTestDepth == pscpt.dwPreDepth))
    {
        // bail out, these primitives don't affect the pixel
        RestoreUserState(pDevice->m_pPixelShader != NULL);
        DrawVertices();
        return S_OK;
    }

    // find out if a pixel shader is active
    if(!pDevice->m_pPixelShader)
    {
        // save primitive information but don't capture registers
        RestoreUserState(pDevice->m_pPixelShader != NULL);
        
        // restore color and depth
        SetColorAndDepth(pscpt.dwPreColor, pscpt.dwPreDepth);
        
        DrawVertices();
        GetColorAndDepth(&(pscpt.dwPostColor), &(pscpt.dwPostDepth));
        
        WriteCapture(PSS_PRIMITIVE | 5);
        WriteCapture(pscpt.dwPreColor);
        WriteCapture(pscpt.dwPreDepth);
        WriteCapture(pscpt.dwPostColor);
        WriteCapture(pscpt.dwPostDepth);
        WriteCapture(PSS_NOSHADER | 1);
        
        return S_OK;
    }

    // find out how many combiner stages are active
    pscpt.dwCombinerCount = D3D__RenderState[D3DRS_PSCOMBINERCOUNT];
    pscpt.dwCombinerCount &= 0xf;

    for(i=0; i<pscpt.dwCombinerCount; i++)    // get texture registers and all stage registers
        GetStageData(i);

    GetStageData(8);    // get final combiner

    // restore color and depth
    SetColorAndDepth(pscpt.dwPreColor, pscpt.dwPreDepth);

    // draw the primitives using the user's state
    RestoreUserState(pDevice->m_pPixelShader != NULL);
    DrawVertices();
    
    // get color and z value after capture
    GetColorAndDepth(&(pscpt.dwPostColor), &(pscpt.dwPostDepth));
    
    WriteCapture(PSS_PRIMITIVE | 5);
    WriteCapture(pscpt.dwPreColor);
    WriteCapture(pscpt.dwPreDepth);
    WriteCapture(pscpt.dwPostColor);
    WriteCapture(pscpt.dwPostDepth);

    for(i=0; i<=pscpt.dwCombinerCount; i++)    // write captured stages to capture buffer
    {
        if(i == pscpt.dwCombinerCount) i = 8;   // final combiner
        switch (i)
        {
        case 0: // combiner stage 0
            WriteCapture(PSS_STAGE0 | 33);
            WriteCapture(D3D__RenderState[D3DRS_PSRGBINPUTS0+i]);
            WriteCapture(D3D__RenderState[D3DRS_PSALPHAINPUTS0+i]);
            WriteCapture(D3D__RenderState[D3DRS_PSRGBOUTPUTS0+i]);
            WriteCapture(D3D__RenderState[D3DRS_PSALPHAOUTPUTS0+i]);
            break;
        case 8: // final combiner stage
            WriteCapture(PSS_FINALSTAGE | 29);
            WriteCapture(D3D__RenderState[D3DRS_PSFINALCOMBINERINPUTSABCD]);
            WriteCapture(D3D__RenderState[D3DRS_PSFINALCOMBINERINPUTSEFG]);
            break;
        default:    // intermediate combiner stages
            WriteCapture(PSS_STAGE | 25);
            WriteCapture(D3D__RenderState[D3DRS_PSRGBINPUTS0+i]);
            WriteCapture(D3D__RenderState[D3DRS_PSALPHAINPUTS0+i]);
            WriteCapture(D3D__RenderState[D3DRS_PSRGBOUTPUTS0+i]);
            WriteCapture(D3D__RenderState[D3DRS_PSALPHAOUTPUTS0+i]);
        }
        WriteCapture(((DWORD)pscpt.r0[i].a << 16) | (pscpt.r0[i].r & 0xffff));
        WriteCapture(((DWORD)pscpt.r0[i].g << 16) | (pscpt.r0[i].b & 0xffff));
        WriteCapture(((DWORD)pscpt.r1[i].a << 16) | (pscpt.r1[i].r & 0xffff));
        WriteCapture(((DWORD)pscpt.r1[i].g << 16) | (pscpt.r1[i].b & 0xffff));
        WriteCapture(((DWORD)pscpt.c0[i].a << 16) | (pscpt.c0[i].r & 0xffff));
        WriteCapture(((DWORD)pscpt.c0[i].g << 16) | (pscpt.c0[i].b & 0xffff));
        WriteCapture(((DWORD)pscpt.c1[i].a << 16) | (pscpt.c1[i].r & 0xffff));
        WriteCapture(((DWORD)pscpt.c1[i].g << 16) | (pscpt.c1[i].b & 0xffff));
        WriteCapture(((DWORD)pscpt.v0[i].a << 16) | (pscpt.v0[i].r & 0xffff));
        WriteCapture(((DWORD)pscpt.v0[i].g << 16) | (pscpt.v0[i].b & 0xffff));
        WriteCapture(((DWORD)pscpt.v1[i].a << 16) | (pscpt.v1[i].r & 0xffff));
        WriteCapture(((DWORD)pscpt.v1[i].g << 16) | (pscpt.v1[i].b & 0xffff));
        WriteCapture(((DWORD)pscpt.t0[i].a << 16) | (pscpt.t0[i].r & 0xffff));
        WriteCapture(((DWORD)pscpt.t0[i].g << 16) | (pscpt.t0[i].b & 0xffff));
        WriteCapture(((DWORD)pscpt.t1[i].a << 16) | (pscpt.t1[i].r & 0xffff));
        WriteCapture(((DWORD)pscpt.t1[i].g << 16) | (pscpt.t1[i].b & 0xffff));
        WriteCapture(((DWORD)pscpt.t2[i].a << 16) | (pscpt.t2[i].r & 0xffff));
        WriteCapture(((DWORD)pscpt.t2[i].g << 16) | (pscpt.t2[i].b & 0xffff));
        WriteCapture(((DWORD)pscpt.t3[i].a << 16) | (pscpt.t3[i].r & 0xffff));
        WriteCapture(((DWORD)pscpt.t3[i].g << 16) | (pscpt.t3[i].b & 0xffff));
        if(i == 0)
        {
            WriteCapture(((DWORD)pscpt.t0in.a << 16) | (pscpt.t0in.r & 0xffff));
            WriteCapture(((DWORD)pscpt.t0in.g << 16) | (pscpt.t0in.b & 0xffff));
            WriteCapture(((DWORD)pscpt.t1in.a << 16) | (pscpt.t1in.r & 0xffff));
            WriteCapture(((DWORD)pscpt.t1in.g << 16) | (pscpt.t1in.b & 0xffff));
            WriteCapture(((DWORD)pscpt.t2in.a << 16) | (pscpt.t2in.r & 0xffff));
            WriteCapture(((DWORD)pscpt.t2in.g << 16) | (pscpt.t2in.b & 0xffff));
            WriteCapture(((DWORD)pscpt.t3in.a << 16) | (pscpt.t3in.r & 0xffff));
            WriteCapture(((DWORD)pscpt.t3in.g << 16) | (pscpt.t3in.b & 0xffff));
        }
        else if (i == 8)
        {
            WriteCapture(((DWORD)pscpt.fog.a << 16) | (pscpt.fog.r & 0xffff));
            WriteCapture(((DWORD)pscpt.fog.g << 16) | (pscpt.fog.b & 0xffff));
            WriteCapture(((DWORD)pscpt.sum.a << 16) | (pscpt.sum.r & 0xffff));
            WriteCapture(((DWORD)pscpt.sum.g << 16) | (pscpt.sum.b & 0xffff));
            WriteCapture(((DWORD)pscpt.prod.a << 16) | (pscpt.prod.r & 0xffff));
            WriteCapture(((DWORD)pscpt.prod.g << 16) | (pscpt.prod.b & 0xffff));
        }
    }
    return S_OK;
}

HRESULT 
DebugSnapshot::HandleXRDrawVertices()
{
    CDevice* pDevice = g_pDevice;

    // save user state
    DWORD savePSHandle;
    pDevice->GetPixelShader(&savePSHandle);
    DWORD saveZEnable = D3D__RenderState[D3DRS_ZENABLE];
    DWORD saveSrcBlend = D3D__RenderState[D3DRS_SRCBLEND];
    DWORD saveDestBlend = D3D__RenderState[D3DRS_DESTBLEND];
    DWORD saveAlphaBlend = D3D__RenderState[D3DRS_ALPHABLENDENABLE];
    DWORD saveFillMode = D3D__RenderState[D3DRS_FILLMODE];
    DWORD saveStencilEnable = D3D__RenderState[D3DRS_STENCILENABLE];
    DWORD saveCullMode = D3D__RenderState[D3DRS_CULLMODE];
    D3DPIXELSHADERDEF *saveUserPSDef = pDevice->m_UserPixelShader.pPSDef;

    D3DPIXELSHADERDEF psd;
    if(dwXRFlags & GRAYMASK)
    {
        ZeroMemory(&psd, sizeof(psd));
        psd.PSCombinerCount=PS_COMBINERCOUNT(
            1,
            PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
        psd.PSTextureModes=PS_TEXTUREMODES(
            PS_TEXTUREMODES_NONE,
            PS_TEXTUREMODES_NONE,
            PS_TEXTUREMODES_NONE,
            PS_TEXTUREMODES_NONE);
        psd.PSInputTexture=PS_INPUTTEXTURE(0,0,0,0);
        psd.PSDotMapping=PS_DOTMAPPING(
            0,
            PS_DOTMAPPING_ZERO_TO_ONE,
            PS_DOTMAPPING_ZERO_TO_ONE,
            PS_DOTMAPPING_ZERO_TO_ONE);
        psd.PSCompareMode=PS_COMPAREMODE(
            PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
            PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
            PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
            PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT);
        
        //------------- Stage 0 -------------
        psd.PSRGBInputs[0]=PS_COMBINERINPUTS(
            PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
            PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
            PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
            PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
        psd.PSAlphaInputs[0]=PS_COMBINERINPUTS(
            PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
            PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
            PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
            PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
        psd.PSRGBOutputs[0]=PS_COMBINEROUTPUTS(
            PS_REGISTER_R0,
            PS_REGISTER_DISCARD,
            PS_REGISTER_DISCARD,
            PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
        psd.PSAlphaOutputs[0]=PS_COMBINEROUTPUTS(
            PS_REGISTER_R0,
            PS_REGISTER_DISCARD,
            PS_REGISTER_DISCARD,
            PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
        
        //------------- FinalCombiner -------------
        psd.PSFinalCombinerInputsABCD=PS_COMBINERINPUTS(
            PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
            PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
            PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
            PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
        psd.PSFinalCombinerInputsEFG=PS_COMBINERINPUTS(
            PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
            PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
            PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
            PS_FINALCOMBINERSETTING_CLAMP_SUM | 0 | 0);
    
        pDevice->SetPixelShaderProgram(&psd);
        pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
        pDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);
        pDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
    }
    
    // read flags and set user-selected state
    // fillmode
    switch((dwXRFlags & FILLMODEMASK) >> FILLMODESHIFT)
    {
    case 1: pDevice->SetRenderState(D3DRS_FILLMODE, D3DFILL_POINT); break;
    case 2: pDevice->SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME); break;
    case 3: pDevice->SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID); break;
    }
    // cullmode
    switch((dwXRFlags & CULLMODEMASK) >> CULLMODESHIFT)
    {
    case 1: pDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE); break;
    case 2: pDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_CW); break;
    case 3: pDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW); break;
    }
    // Z Enable
    switch((dwXRFlags & ZENABLEMASK) >> ZENABLESHIFT)
    {
    case 1: pDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_TRUE); break;
    case 2: pDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE); break;
    case 3: pDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_USEW); break;
    }
    // Stencil Enable
    switch((dwXRFlags & STENCILENABLEMASK) >> STENCILENABLESHIFT)
    {
    case 1: pDevice->SetRenderState(D3DRS_STENCILENABLE, TRUE); break;
    case 2: pDevice->SetRenderState(D3DRS_STENCILENABLE, FALSE); break;
    }
    
    DWORD inc = (dwXRFlags & INCREMENTMASK) >> INCREMENTSHIFT;
    inc |= inc << 8;
    inc |= inc << 16;
    pDevice->SetRenderState(D3DRS_PSCONSTANT0_0, inc);


    // Xray state is set, draw the geometry
    DrawVertices();

    // Now restore the user state
    pDevice->m_UserPixelShader.pPSDef = saveUserPSDef;
    pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, saveAlphaBlend);
    pDevice->SetRenderState(D3DRS_DESTBLEND, saveDestBlend);
    pDevice->SetRenderState(D3DRS_SRCBLEND, saveSrcBlend);
    pDevice->SetRenderState(D3DRS_ZENABLE, saveZEnable);
    pDevice->SetRenderState(D3DRS_FILLMODE, saveFillMode);
    pDevice->SetRenderState(D3DRS_STENCILENABLE, saveStencilEnable);
    pDevice->SetRenderState(D3DRS_CULLMODE, saveCullMode);
    
    if(dwXRFlags & GRAYMASK)
        pDevice->SetPixelShader(savePSHandle);

    return S_OK;
}
    
HRESULT 
DebugSnapshot::HandleDrawVertices()
{
    CDevice* pDevice = g_pDevice;
    
    // if more than one operation is enabled at a time, the priority is:
    // 1. markers
    // 2. vertex shader debugger
    // 3. pixel shader debugger
    // 4. xray

    // if debug markers are enabled, filter out geometry with different marker.
    if((dwFlags & 0x1) &&
       (pDevice->m_dwDebugMarker != dwMarker))
    {
        return S_OK;
    }

    if(pDevice->m_dwSnapshot & SDOP_VSACTIVE)
    {
        // vertex shader debugger is active
        return HandleVSDrawVertices();
    }

    if(pDevice->m_dwSnapshot & SDOP_PSACTIVE)
    {
        // pixel shader debugger is active
        return HandlePSDrawVertices();
    }
    
    if(pDevice->m_dwSnapshot & SDOP_XRACTIVE)
    {
        // xray utility is active
        return HandleXRDrawVertices();
    }

    return S_OK;
}

void 
DebugSnapshot::GetStageData(UINT i)
{
    DWORD dwCombinerCount;
    CDevice* pDevice = g_pDevice;
    
    RestoreUserState(pDevice->m_pPixelShader != NULL);
    SetPassThroughState();

    if(i != 8)
    {
        // not final combiner, set combiner count
        dwCombinerCount = D3D__RenderState[D3DRS_PSCOMBINERCOUNT];
        dwCombinerCount &= 0xfffffff0;
        dwCombinerCount |= i+1;
        pDevice->SetRenderState(D3DRS_PSCOMBINERCOUNT, dwCombinerCount);
    }
    else
    {
        // final combiner
        GetRegister(PS_REGISTER_FOG, i);
        GetRegister(PS_REGISTER_V1R0_SUM, i);
        GetRegister(PS_REGISTER_EF_PROD, i);
    }
    GetRegister(PS_REGISTER_V0, i);
    GetRegister(PS_REGISTER_V1, i);
    GetRegister(PS_REGISTER_T0, i);
    GetRegister(PS_REGISTER_T1, i);
    GetRegister(PS_REGISTER_T2, i);
    GetRegister(PS_REGISTER_T3, i);
    GetRegister(PS_REGISTER_R0, i);
    GetRegister(PS_REGISTER_R1, i);
    GetRegister(PS_REGISTER_C0, i);
    GetRegister(PS_REGISTER_C1, i);
    if(i == 0)
    {
        // get texture addresses
        GetRegister(SS_REGISTER_T0IN, i);
        GetRegister(SS_REGISTER_T1IN, i);
        GetRegister(SS_REGISTER_T2IN, i);
        GetRegister(SS_REGISTER_T3IN, i);
    }
}

void 
DebugSnapshot::GetRegister(DWORD dwReg, UINT i)
{
    DWORD dwRGBIn, dwRGBOut, dwAlphaIn, dwAlphaOut;
    DWORD dwFCabcd, dwFCefg, dwFCefgSave;
    DWORD dwColor, dwDepth;
    SHORT d;
    CDevice* pDevice = g_pDevice;
    DWORD dwChannel, dwIter, dwStart, dwEnd;
    DWORD dwSampleReg;

    if(pDevice->m_dwSnapshot & SDOP_HASALPHA)
    {
        // framebuffer format has alpha
        dwStart = dwEnd = 3;    // one iteration, save both alpha and rgb
    }
    else
    {
        dwStart = 1;    // first iteration, save rgb
        dwEnd = 2;      // second iteration, save alpha
    }
    
    for(dwIter=dwStart; dwIter<=dwEnd; dwIter++)
    {
        if(dwIter == 2)
        {
            // don't request alpha from these registers
            if(dwReg == PS_REGISTER_V1R0_SUM)
            {
                pscpt.sum.a = 0;
                continue;
            }
            if(dwReg == PS_REGISTER_EF_PROD)
            {
                pscpt.prod.a = 0;
                continue;
            }
            dwChannel = PS_CHANNEL_ALPHA;
        }
        else
            dwChannel = PS_CHANNEL_RGB;

        if(i != 8)
        {
            // setup for texture inputs if requested
            if(dwReg >= SS_REGISTER_T0IN)
            {
                pDevice->SetRenderState(D3DRS_PSTEXTUREMODES, PS_TEXTUREMODES(PS_TEXTUREMODES_PASSTHRU, 
                                                                              PS_TEXTUREMODES_PASSTHRU, 
                                                                              PS_TEXTUREMODES_PASSTHRU, 
                                                                              PS_TEXTUREMODES_PASSTHRU));
                dwSampleReg = dwReg - SS_REGISTER_T0IN + PS_REGISTER_T0;
            }
            else
                dwSampleReg = dwReg;

            // not final combiner
            dwRGBIn = PS_COMBINERINPUTS(
                dwSampleReg      | dwChannel      | PS_INPUTMAPPING_SIGNED_IDENTITY,
                PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
                PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
                PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
        
            dwAlphaIn = PS_COMBINERINPUTS(
                dwSampleReg      | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
                PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
                PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
                PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
        
            dwRGBOut = PS_COMBINEROUTPUTS(
                PS_REGISTER_R0,
                PS_REGISTER_DISCARD,
                PS_REGISTER_DISCARD,
                PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | 
                PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
        
            dwAlphaOut = PS_COMBINEROUTPUTS(
                PS_REGISTER_R0,
                PS_REGISTER_DISCARD,
                PS_REGISTER_DISCARD,
                PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | 
                PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
        
            pDevice->SetRenderState((D3DRENDERSTATETYPE)((DWORD)D3DRS_PSRGBINPUTS0+i), dwRGBIn);
            pDevice->SetRenderState((D3DRENDERSTATETYPE)((DWORD)D3DRS_PSALPHAINPUTS0+i), dwAlphaIn);
            pDevice->SetRenderState((D3DRENDERSTATETYPE)((DWORD)D3DRS_PSRGBOUTPUTS0+i), dwRGBOut);
            pDevice->SetRenderState((D3DRENDERSTATETYPE)((DWORD)D3DRS_PSALPHAOUTPUTS0+i), dwAlphaOut);

        }
        else
        {
            // final combiner
            dwFCabcd = PS_COMBINERINPUTS( 
                PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
                dwReg            | dwChannel      | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
                dwReg            | dwChannel      | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
                PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
        
            DWORD dwAlphaReg;
            if((dwReg == PS_REGISTER_FOG) || (dwReg == PS_REGISTER_V1R0_SUM) || (dwReg == PS_REGISTER_EF_PROD))
                dwAlphaReg = PS_REGISTER_ZERO;
            else
                dwAlphaReg = dwReg;
            dwFCefg = PS_COMBINERINPUTS(
                PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
                PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
                dwAlphaReg       | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
                PS_FINALCOMBINERSETTING_CLAMP_SUM | 0 | 0);
            pDevice->SetRenderState(D3DRS_PSFINALCOMBINERINPUTSABCD, dwFCabcd);
            dwFCefgSave = D3D__RenderState[D3DRS_PSFINALCOMBINERINPUTSEFG];
            dwFCefg &= 0x0000ffff;  // clear new E and F bits
            dwFCefgSave &= 0xffff0000;  // remove G and flags
            dwFCefg |= dwFCefgSave;     // combine old E and F with new G and flags
            pDevice->SetRenderState(D3DRS_PSFINALCOMBINERINPUTSEFG, dwFCefg);
        }
    
        // draw the primitives
        DrawVertices();
    
        // get the result of the rendering
        GetColorAndDepth(&dwColor, &dwDepth);
        
        REGVAL *pRv = NULL;
        switch(dwReg)
        {
        case PS_REGISTER_V0: pRv = &pscpt.v0[i]; break;
        case PS_REGISTER_V1: pRv = &pscpt.v1[i]; break;
        case PS_REGISTER_T0: pRv = &pscpt.t0[i]; break;
        case PS_REGISTER_T1: pRv = &pscpt.t1[i]; break;
        case PS_REGISTER_T2: pRv = &pscpt.t2[i]; break;
        case PS_REGISTER_T3: pRv = &pscpt.t3[i]; break;
        case PS_REGISTER_R0: pRv = &pscpt.r0[i]; break;
        case PS_REGISTER_R1: pRv = &pscpt.r1[i]; break;
        case PS_REGISTER_C0: pRv = &pscpt.c0[i]; break;
        case PS_REGISTER_C1: pRv = &pscpt.c1[i]; break;
        case PS_REGISTER_FOG: pRv = &pscpt.fog; break;
        case PS_REGISTER_V1R0_SUM: pRv = &pscpt.sum; break;
        case PS_REGISTER_EF_PROD: pRv = &pscpt.prod; break;
        case SS_REGISTER_T0IN:    pRv = &pscpt.t0in; break;
        case SS_REGISTER_T1IN:    pRv = &pscpt.t1in; break;
        case SS_REGISTER_T2IN:    pRv = &pscpt.t2in; break;
        case SS_REGISTER_T3IN:    pRv = &pscpt.t3in; break;
        }
        if(pRv)
        {
            switch(dwIter)
            {
            case 1:
                pRv->r = (short)(dwColor >> 16) & 0xff;
                pRv->g = (short)(dwColor >>  8) & 0xff;
                pRv->b = (short)(dwColor >>  0) & 0xff;
                break;
            case 2:
                pRv->a = (short)(dwColor >>  0) & 0xff;
                break;
            case 3:
                pRv->a = (short)(dwColor >> 24) & 0xff;
                pRv->r = (short)(dwColor >> 16) & 0xff;
                pRv->g = (short)(dwColor >>  8) & 0xff;
                pRv->b = (short)(dwColor >>  0) & 0xff;
                break;
            }
        }
    
        if(i != 8)
        {
            // not final combiner
            // setup for texture inputs if requested
            if(dwReg >= SS_REGISTER_T0IN)
                dwSampleReg = dwReg - SS_REGISTER_T0IN + PS_REGISTER_T0;
            else
                dwSampleReg = dwReg;

            // set up the combiner stage to add 0xff to the register
            dwRGBIn = PS_COMBINERINPUTS(
                dwSampleReg      | dwChannel      | PS_INPUTMAPPING_SIGNED_IDENTITY,
                PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
                PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
                PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT);
        
            dwAlphaIn = PS_COMBINERINPUTS(
                dwSampleReg      | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
                PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
                PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
                PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT);
        
            dwRGBOut = PS_COMBINEROUTPUTS(
                PS_REGISTER_DISCARD,
                PS_REGISTER_DISCARD,
                PS_REGISTER_R0,
                PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | 
                PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
        
            dwAlphaOut = PS_COMBINEROUTPUTS(
                PS_REGISTER_DISCARD,
                PS_REGISTER_DISCARD,
                PS_REGISTER_R0,
                PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | 
                PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
        
            pDevice->SetRenderState((D3DRENDERSTATETYPE)((DWORD)D3DRS_PSRGBINPUTS0+i), dwRGBIn);
            pDevice->SetRenderState((D3DRENDERSTATETYPE)((DWORD)D3DRS_PSALPHAINPUTS0+i), dwAlphaIn);
            pDevice->SetRenderState((D3DRENDERSTATETYPE)((DWORD)D3DRS_PSRGBOUTPUTS0+i), dwRGBOut);
            pDevice->SetRenderState((D3DRENDERSTATETYPE)((DWORD)D3DRS_PSALPHAOUTPUTS0+i), dwAlphaOut);
    
            // draw the primitives again to get the sign bits
            DrawVertices();
        
            // get the result of the rendering
            GetColorAndDepth(&dwColor, &dwDepth);
        
            pRv = NULL;
            switch(dwReg)
            {
            case PS_REGISTER_V0: pRv = &pscpt.v0[i]; break;
            case PS_REGISTER_V1: pRv = &pscpt.v1[i]; break;
            case PS_REGISTER_T0: pRv = &pscpt.t0[i]; break;
            case PS_REGISTER_T1: pRv = &pscpt.t1[i]; break;
            case PS_REGISTER_T2: pRv = &pscpt.t2[i]; break;
            case PS_REGISTER_T3: pRv = &pscpt.t3[i]; break;
            case PS_REGISTER_R0: pRv = &pscpt.r0[i]; break;
            case PS_REGISTER_R1: pRv = &pscpt.r1[i]; break;
            case PS_REGISTER_C0: pRv = &pscpt.c0[i]; break;
            case PS_REGISTER_C1: pRv = &pscpt.c1[i]; break;
            case SS_REGISTER_T0IN: pRv = &pscpt.t0in; break;
            case SS_REGISTER_T1IN: pRv = &pscpt.t0in; break;
            case SS_REGISTER_T2IN: pRv = &pscpt.t0in; break;
            case SS_REGISTER_T3IN: pRv = &pscpt.t0in; break;
            }
            if(pRv)
            {
                switch(dwIter)
                {
                case 1:
                    d = (short)(dwColor >> 16) & 0xff;
                    if(d != 0xff) pRv->r = d - 0xff;
                    d = (short)(dwColor >>  8) & 0xff;
                    if(d != 0xff) pRv->g = d - 0xff;
                    d = (short)(dwColor >>  0) & 0xff;
                    if(d != 0xff) pRv->b = d - 0xff;
                    break;
                case 2:
                    d = (short)(dwColor >>  0) & 0xff;
                    if(d != 0xff) pRv->a = d - 0xff;
                    break;
                case 3:
                    d = (short)(dwColor >> 24) & 0xff;
                    if(d != 0xff) pRv->a = d - 0xff;
                    d = (short)(dwColor >> 16) & 0xff;
                    if(d != 0xff) pRv->r = d - 0xff;
                    d = (short)(dwColor >>  8) & 0xff;
                    if(d != 0xff) pRv->g = d - 0xff;
                    d = (short)(dwColor >>  0) & 0xff;
                    if(d != 0xff) pRv->b = d - 0xff;
                    break;
                }
            }
        }
    }
}

void HandleShaderSnapshotOpcode()
{
#if PROFILE
    CDevice* pDevice = g_pDevice;
    DWORD *args;
    
    switch(pDevice->m_dwOpcode & 0xff000000)
    {
    // Pixel shader capture opcodes
    case PSSNAP_IDLE:           // nothing to do (also VSSNAP_IDLE)
    case PSSNAP_ACK:            // waiting for DM response
    case PSSNAP_ERROR:          // waiting for DM response
        break;
    case PSSNAP_REQUEST:         // start pixel shader snapshot
        // check for pure device
        if (pDevice->m_StateFlags & STATE_PUREDEVICE)
        {
            pDevice->m_dwOpcode = PSSNAP_ERROR | 2; // signal pure device error
            return;
        }

        // check for supported framebuffer format
        IDirect3DSurface8 *pBackBuffer;
        D3DSURFACE_DESC sDesc;
        pDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &(pBackBuffer));
        pBackBuffer->GetDesc(&sDesc);
        pBackBuffer->Release();
        if((sDesc.Format != D3DFMT_LIN_A8R8G8B8) &&
           (sDesc.Format != D3DFMT_LIN_X8R8G8B8))
        {
            pDevice->m_dwOpcode = PSSNAP_ERROR | 1; // signal format error
            return;
        }

        args = (DWORD *)(pDevice->m_pShaderCaptureBuffer);   // save pointer to arguments

        // initialize capture buffer
        pDevice->m_pShaderCaptureBuffer = (DWORD *)MemAllocNoZero(SHADER_CAPTURE_BUFFER_SIZE);
        pDevice->m_pShaderCapturePtr = pDevice->m_pShaderCaptureBuffer; // set write pointer
        if(pDevice->m_pShaderCaptureBuffer == NULL)
        {
            pDevice->m_dwOpcode = PSSNAP_ERROR | 3; // signal memory error
            return;
        }

        // initialize capture state
        g_snapshot.BeginPSSnapshot(args);

        pDevice->m_dwOpcode = PSSNAP_BUSY;
        pDevice->m_dwSnapshot |= SDOP_PSACTIVE; // pixel shader capture active
        if(sDesc.Format == D3DFMT_LIN_A8R8G8B8)
            pDevice->m_dwSnapshot |= SDOP_HASALPHA;
        break;
    case PSSNAP_BUSY:            // finished with pixel shader snapshot
        pDevice->m_dwSnapshot &= ~(SDOP_PSACTIVE | SDOP_HASALPHA);
        g_snapshot.EndPSSnapshot();
        pDevice->m_dwOpcode = PSSNAP_ACK | ((DWORD)(pDevice->m_pShaderCapturePtr) - (DWORD)(pDevice->m_pShaderCaptureBuffer));
        break;
    case PSSNAP_DONE:            // DM has acknowledged receiving data, cleanup
        MemFree(pDevice->m_pShaderCaptureBuffer);
        pDevice->m_pShaderCaptureBuffer = pDevice->m_pShaderCapturePtr = NULL;
        pDevice->m_dwOpcode = PSSNAP_IDLE;
        break;
    
    // Vertex shader capture opcodes
    case VSSNAP_ACK:            // waiting for DM response
    case VSSNAP_ERROR:          // waiting for DM response
        break;
    case VSSNAP_REQUEST:         // start vertex shader snapshot
        // check for pure device
        if (pDevice->m_StateFlags & STATE_PUREDEVICE)
        {
            pDevice->m_dwOpcode = VSSNAP_ERROR | 2; // signal pure device error
            return;
        }

        args = (DWORD *)(pDevice->m_pShaderCaptureBuffer);   // save pointer to arguments

        // initialize capture buffer
        pDevice->m_pShaderCaptureBuffer = (DWORD *)MemAllocNoZero(SHADER_CAPTURE_BUFFER_SIZE);
        pDevice->m_pShaderCapturePtr = pDevice->m_pShaderCaptureBuffer; // set write pointer
        if(pDevice->m_pShaderCaptureBuffer == NULL)
        {
            pDevice->m_dwOpcode = VSSNAP_ERROR | 3; // signal memory error
            return;
        }
        
        // initialize capture state
        g_snapshot.BeginVSSnapshot(args);

        pDevice->m_dwOpcode = VSSNAP_BUSY;
        pDevice->m_dwSnapshot |= SDOP_VSACTIVE;    // vertex shader capture active
        break;
    case VSSNAP_BUSY:            // finished with vertex shader snapshot
        pDevice->m_dwSnapshot &= ~SDOP_VSACTIVE;
        g_snapshot.EndVSSnapshot();
        pDevice->m_dwOpcode = VSSNAP_ACK | ((DWORD)(pDevice->m_pShaderCapturePtr) - (DWORD)(pDevice->m_pShaderCaptureBuffer));
        break;
    case VSSNAP_DONE:            // DM has acknowledged receiving data, cleanup
        MemFree(pDevice->m_pShaderCaptureBuffer);
        pDevice->m_pShaderCaptureBuffer = pDevice->m_pShaderCapturePtr = NULL;
        pDevice->m_dwOpcode = VSSNAP_IDLE;
        break;
    
    // Xray opcodes
    case XRAY_ENDACK:
    case XRAY_BEGINACK:
    case XRAY_ERROR:
        break;            // waiting for DM response

    case XRAY_BEGINREQ:   // Enter Xray mode
        pDevice->m_dwSnapshot |= SDOP_XRACTIVE;
        pDevice->m_dwOpcode = XRAY_BEGINACK;
        args = (DWORD *)(pDevice->m_pShaderCaptureBuffer);   // save pointer to arguments
        g_snapshot.dwXRFlags = *(args+2);
        g_snapshot.dwFlags = *(args+2) & 0xf;
        g_snapshot.dwMarker = *(args+3);
        break;

    case XRAY_ENDREQ:     // Leave Xray mode
        pDevice->m_dwSnapshot &= ~SDOP_XRACTIVE;
        pDevice->m_dwOpcode = XRAY_ENDACK;
        break;
    }
#endif //PROFILE
}

void HandleShaderSnapshot_DrawVerticesUP(
    D3DPRIMITIVETYPE PrimitiveType,
    UINT VertexCount,
    CONST void* pVertexStreamZeroData,
    UINT VertexStreamZeroStride)
{
    g_snapshot.DrawVertType = DRAWVERT_TYPE_VUP;
    g_snapshot.PrimitiveType = PrimitiveType;
    g_snapshot.VertexCount = VertexCount;
    g_snapshot.pVertexStreamZeroData = pVertexStreamZeroData;
    g_snapshot.VertexStreamZeroStride = VertexStreamZeroStride;
    g_snapshot.HandleDrawVertices();
}

void HandleShaderSnapshot_DrawIndexedVerticesUP(
    D3DPRIMITIVETYPE PrimitiveType,
    UINT VertexCount,
    CONST void* pIndexData,
    CONST void* pVertexStreamZeroData,
    UINT VertexStreamZeroStride)
{
    g_snapshot.DrawVertType = DRAWVERT_TYPE_IVUP;
    g_snapshot.PrimitiveType = PrimitiveType;
    g_snapshot.VertexCount = VertexCount;
    g_snapshot.pIndexData = pIndexData;
    g_snapshot.pVertexStreamZeroData = pVertexStreamZeroData;
    g_snapshot.VertexStreamZeroStride = VertexStreamZeroStride;
    g_snapshot.HandleDrawVertices();
}
    
void HandleShaderSnapshot_DrawVertices(
    D3DPRIMITIVETYPE PrimitiveType,
    UINT StartVertex,
    UINT VertexCount)
{
    g_snapshot.DrawVertType = DRAWVERT_TYPE_V;
    g_snapshot.PrimitiveType = PrimitiveType;
    g_snapshot.StartVertex = StartVertex;
    g_snapshot.VertexCount = VertexCount;
    g_snapshot.HandleDrawVertices();
}
    
void HandleShaderSnapshot_DrawIndexedVertices(
    D3DPRIMITIVETYPE PrimitiveType,
    UINT VertexCount,
    CONST WORD* pIndexData)
{
    g_snapshot.DrawVertType = DRAWVERT_TYPE_IV;
    g_snapshot.PrimitiveType = PrimitiveType;
    g_snapshot.VertexCount = VertexCount;
    g_snapshot.pIndexData = pIndexData;
    g_snapshot.HandleDrawVertices();
}

void HandleShaderSnapshot_Clear(DWORD Count,
                                CONST D3DRECT *pRects,
                                DWORD Flags,
                                D3DCOLOR Color,
                                float Z,
                                DWORD Stencil) 
{
    CDevice* pDevice = g_pDevice;
    DWORD dwSave = pDevice->m_dwSnapshot;
    
    // Leave snapshot mode and call the appropriate D3D clear method
    pDevice->m_dwSnapshot = 0x0;
    // clear what the user wants first
    D3DDevice_Clear(Count, pRects, Flags, Color, Z, Stencil);
    if(g_snapshot.dwXRFlags & GRAYMASK)
    {
        // now make sure the buffer is black if user selected grayscale
        D3DDevice_Clear( 0, NULL, D3DCLEAR_TARGET,D3DCOLOR_XRGB(0,0,0), 1.0f, 0 );
    }
    pDevice->m_dwSnapshot = dwSave;
}

void 
DebugSnapshot::BeginVSSnapshot(DWORD *args)
{
    CDevice* pDevice = g_pDevice;
    
    dwCaptureCount = 0;     //initialize count of dwords written
    ShaderVerts = OtherVerts = 0;
    dwProcessedVertexCount = 0; // initialize count of processed vertices
    a0x = 0;
    WriteCapture(VSS_STATS | 0x3);
    WriteCapture(0);    // room for stats
    WriteCapture(0);
    dwFirstVertex = *args;
    dwLastVertex = *(args+1);
    dwFlags = *(args+2);
    dwMarker = *(args+3);
}

void 
DebugSnapshot::EndVSSnapshot(void)
{
    WriteCapture(VSS_EOF | 1);
    *(g_pDevice->m_pShaderCaptureBuffer+1) = ShaderVerts;
    *(g_pDevice->m_pShaderCaptureBuffer+2) = OtherVerts;
}

//------------------------------------------------------------------------------
// SetDebugMarker

extern "C"
DWORD WINAPI D3DDevice_SetDebugMarker(
    DWORD Marker)
{
    CDevice* pDevice = g_pDevice;
    DWORD dwOldMarker = pDevice->m_dwDebugMarker;
    pDevice->m_dwDebugMarker = Marker;
    return dwOldMarker;
}

//------------------------------------------------------------------------------
// GetDebugMarker

extern "C"
DWORD WINAPI D3DDevice_GetDebugMarker()
{
    return g_pDevice->m_dwDebugMarker;
}


} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\sources.inc ===
MAJORCOMP=directx
MINORCOMP=d3d

TARGETTYPE=LIBRARY

INCLUDES=..;$(BASEDIR)\private\ntos\inc

# PERFFLAGS=/fastcap

# Optimize for speed.  We do this because we use write-combined memory a lot,
# and when compiling for size the compiler will sometimes change writes-to-
# memory into read-and-modify-writes (such as when moving zero to memory,
# where the form 'and dword ptr [esi], 0' has a smaller byte encoding than
# 'move dword ptr [esi], 0').  Reads from write-combined memory are VERY
# painful.

!if "$(MSC_OPTIMIZATION)"==""
MSC_OPTIMIZATION=/Ox
!endif

SOURCES=\
    block.cpp \
    buffer.cpp \
    clear.cpp \
    combiner.cpp \
    d3dbase.cpp \
    d3ddev.cpp \
    debug.cpp \
    drawprim.cpp \
    dumper.cpp \
    dxgcreate.cpp \
    enum.cpp \
    floatmath.cpp \
    globals.cpp \
    lazy.cpp \
    math.cpp \
    memory.cpp \
    mpcore.cpp  \
    mpdac.cpp \
    mphal.cpp \
    mpintr.cpp \
    mpmode.cpp \
    overlay.cpp \
    patch.cpp \
    patchbackend.cpp \
    patchconst.cpp \
    patchutil.cpp \
    pixeljar.cpp \
    present.cpp \
    pshader.cpp \
    pusher.cpp \
    pushres.cpp \
    rdi.cpp \
    resource.cpp \
    shadersnapshot.cpp \
    state.cpp \
    stats.cpp \
    surface.cpp \
    texture.cpp \
    vshader.cpp 
    
    
PRECOMPILED_INCLUDE=..\precomp.hpp
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\state.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       state.hpp
 *  Content:    header file for state.cpp
 *
 ***************************************************************************/

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

extern BYTE g_SlotMapping[];

HRESULT PresentationParametersParameterCheck(
    D3DPRESENT_PARAMETERS* pPresentationParams);

VOID SetState();

VOID UpdateProjectionViewportTransform();

VOID LazySetCombiners(CDevice* pDevice);

VOID VerifyHeaderFileEncodings();

extern BOOL ValidCombinerInputs(DWORD val, char *err);
extern BOOL ValidAlphaOutputs(DWORD val, char *err);
extern BOOL ValidRGBOutputs(DWORD val, char *err);
extern BOOL ValidFinalCombinerABCD(DWORD val, char *err);
extern BOOL ValidFinalCombinerEFG(DWORD val, char *err);
extern BOOL ValidTextureModes(DWORD val, char *err);
extern BOOL ValidInputTexture(DWORD val, char *err);
extern BOOL ValidCombinerCount(DWORD val, char *err);
extern BOOL ValidCompareMode(DWORD val, char *err);
extern BOOL ValidDotMapping(DWORD val, char *err);

// Prototypes for state-setting routines common to multiple APIs:

PPUSH FASTCALL CommonSetTextureBumpEnv(CDevice* pDevice, PPUSH pPush);

PPUSH FASTCALL CommonSetViewport(CDevice* pDevice, PPUSH pPush);

PPUSH FASTCALL CommonSetControl0(CDevice* pDevice, PPUSH pPush);

PPUSH FASTCALL CommonSetOccludeZStencilEn(CDevice* pDevice, PPUSH pPush);

VOID FASTCALL CommonSetPassthroughProgram(CDevice* pDevice);

VOID FASTCALL CommonSetAntiAliasingControl(CDevice* pDevice);

VOID FASTCALL CommonSetDebugRegisters();

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\state.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       state.cpp
 *  Content:    Handles any state-changing APIs, either by whacking the
 *              hardware immediately or marking them as dirty for
 *              later lazy setting.
 *
 ***************************************************************************/
 
#include "precomp.hpp"

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

const float F_MINUS_8 = -8.0f;

//------------------------------------------------------------------------------
// Table for handling TEXCOORDINDEX re-mapping
//
// Because of D3DRS_TEXCOORDINDEX, texture coordinates for the fixed-function
// pipeline may be mapped arbitrarily to the hardware texture stages.  This
// array handles that remapping (the D3DRS_TEXCOORDINDEX render state can
// modify the entries for SLOT_TEXTURE0 through SLOT_TEXTURE3).
//
// The first 16 bytes are for the fixed-function pipeline, and the second 16
// bytes are for vertex shaders (which don't respect D3DRS_TEXCOORDINDEX and
// so always get an identity mapping).

BYTE g_SlotMapping[] = 
{ 
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
};

//------------------------------------------------------------------------------
// g_ComplexRenderStateFunctionTable

typedef VOID (*SetComplexRenderStateFunction)(DWORD Value);

D3DCONST SetComplexRenderStateFunction g_ComplexRenderStateFunctionTable[] = 
{
    D3DDevice_SetRenderState_PSTextureModes,
    D3DDevice_SetRenderState_VertexBlend,
    D3DDevice_SetRenderState_FogColor,
    D3DDevice_SetRenderState_FillMode,
    D3DDevice_SetRenderState_BackFillMode,
    D3DDevice_SetRenderState_TwoSidedLighting,
    D3DDevice_SetRenderState_NormalizeNormals,
    D3DDevice_SetRenderState_ZEnable,
    D3DDevice_SetRenderState_StencilEnable,
    D3DDevice_SetRenderState_StencilFail,
    D3DDevice_SetRenderState_FrontFace,
    D3DDevice_SetRenderState_CullMode,
    D3DDevice_SetRenderState_TextureFactor,
    D3DDevice_SetRenderState_ZBias,
    D3DDevice_SetRenderState_LogicOp,
    D3DDevice_SetRenderState_EdgeAntiAlias,
    D3DDevice_SetRenderState_MultiSampleAntiAlias,
    D3DDevice_SetRenderState_MultiSampleMask,
    D3DDevice_SetRenderState_MultiSampleMode,
    D3DDevice_SetRenderState_MultiSampleRenderTargetMode,
    D3DDevice_SetRenderState_ShadowFunc,
    D3DDevice_SetRenderState_LineWidth,
    D3DDevice_SetRenderState_Dxt1NoiseEnable,
    D3DDevice_SetRenderState_YuvEnable,
    D3DDevice_SetRenderState_OcclusionCullEnable,
    D3DDevice_SetRenderState_StencilCullEnable,
    D3DDevice_SetRenderState_RopZCmpAlwaysRead,
    D3DDevice_SetRenderState_RopZRead,
    D3DDevice_SetRenderState_DoNotCullUncompressed,
};

#if DBG

// Debug-only variable for tracking if stencil was ever enabled:

BOOL g_StencilEverEnabled;

// Debug-only variable for tracking if caller was ever warned about Z-clears
// being faster if Stencil is cleared at the same time:

BOOL g_WarnedAboutStencil;

// Debug-only variable for tracking if caller was ever warned about 
// rops / clipping rects with swizzled textures.

BOOL g_WarnAboutCopyRectStateSwizzle;

//------------------------------------------------------------------------------
// g_RenderStateEncodings
//
// This array is used on debug exclusively to verify that the inline
// D3DSIMPLERENDERSTATEENCODE array in d3d8.x contains the right values,
// and to re-generate the hex values for that table (do an "nmake state.cod")

#define E(Method) PUSHER_METHOD(SUBCH_3D, (Method), 1)

D3DCONST DWORD g_RenderStateEncodings[] =
{
    // NOTE: Any unused slots should be assigned NV097_NO_OPERATION because
    // state blocks will try to restore their values...

    E(NV097_SET_COMBINER_ALPHA_ICW(0)),        D3DRS_PSALPHAINPUTS0,
    E(NV097_SET_COMBINER_ALPHA_ICW(1)),        D3DRS_PSALPHAINPUTS1,
    E(NV097_SET_COMBINER_ALPHA_ICW(2)),        D3DRS_PSALPHAINPUTS2,
    E(NV097_SET_COMBINER_ALPHA_ICW(3)),        D3DRS_PSALPHAINPUTS3,
    E(NV097_SET_COMBINER_ALPHA_ICW(4)),        D3DRS_PSALPHAINPUTS4,
    E(NV097_SET_COMBINER_ALPHA_ICW(5)),        D3DRS_PSALPHAINPUTS5,
    E(NV097_SET_COMBINER_ALPHA_ICW(6)),        D3DRS_PSALPHAINPUTS6,
    E(NV097_SET_COMBINER_ALPHA_ICW(7)),        D3DRS_PSALPHAINPUTS7,
    E(NV097_SET_COMBINER_SPECULAR_FOG_CW0),    D3DRS_PSFINALCOMBINERINPUTSABCD,
    E(NV097_SET_COMBINER_SPECULAR_FOG_CW1),    D3DRS_PSFINALCOMBINERINPUTSEFG,
    E(NV097_SET_COMBINER_FACTOR0(0)),          D3DRS_PSCONSTANT0_0,
    E(NV097_SET_COMBINER_FACTOR0(1)),          D3DRS_PSCONSTANT0_1,
    E(NV097_SET_COMBINER_FACTOR0(2)),          D3DRS_PSCONSTANT0_2,
    E(NV097_SET_COMBINER_FACTOR0(3)),          D3DRS_PSCONSTANT0_3,
    E(NV097_SET_COMBINER_FACTOR0(4)),          D3DRS_PSCONSTANT0_4,
    E(NV097_SET_COMBINER_FACTOR0(5)),          D3DRS_PSCONSTANT0_5,
    E(NV097_SET_COMBINER_FACTOR0(6)),          D3DRS_PSCONSTANT0_6,
    E(NV097_SET_COMBINER_FACTOR0(7)),          D3DRS_PSCONSTANT0_7,
    E(NV097_SET_COMBINER_FACTOR1(0)),          D3DRS_PSCONSTANT1_0,
    E(NV097_SET_COMBINER_FACTOR1(1)),          D3DRS_PSCONSTANT1_1,
    E(NV097_SET_COMBINER_FACTOR1(2)),          D3DRS_PSCONSTANT1_2,
    E(NV097_SET_COMBINER_FACTOR1(3)),          D3DRS_PSCONSTANT1_3,
    E(NV097_SET_COMBINER_FACTOR1(4)),          D3DRS_PSCONSTANT1_4,
    E(NV097_SET_COMBINER_FACTOR1(5)),          D3DRS_PSCONSTANT1_5,
    E(NV097_SET_COMBINER_FACTOR1(6)),          D3DRS_PSCONSTANT1_6,
    E(NV097_SET_COMBINER_FACTOR1(7)),          D3DRS_PSCONSTANT1_7,
    E(NV097_SET_COMBINER_ALPHA_OCW(0)),        D3DRS_PSALPHAOUTPUTS0,
    E(NV097_SET_COMBINER_ALPHA_OCW(1)),        D3DRS_PSALPHAOUTPUTS1,
    E(NV097_SET_COMBINER_ALPHA_OCW(2)),        D3DRS_PSALPHAOUTPUTS2,
    E(NV097_SET_COMBINER_ALPHA_OCW(3)),        D3DRS_PSALPHAOUTPUTS3,
    E(NV097_SET_COMBINER_ALPHA_OCW(4)),        D3DRS_PSALPHAOUTPUTS4,
    E(NV097_SET_COMBINER_ALPHA_OCW(5)),        D3DRS_PSALPHAOUTPUTS5,
    E(NV097_SET_COMBINER_ALPHA_OCW(6)),        D3DRS_PSALPHAOUTPUTS6,
    E(NV097_SET_COMBINER_ALPHA_OCW(7)),        D3DRS_PSALPHAOUTPUTS7,
    E(NV097_SET_COMBINER_COLOR_ICW(0)),        D3DRS_PSRGBINPUTS0,
    E(NV097_SET_COMBINER_COLOR_ICW(1)),        D3DRS_PSRGBINPUTS1,
    E(NV097_SET_COMBINER_COLOR_ICW(2)),        D3DRS_PSRGBINPUTS2,
    E(NV097_SET_COMBINER_COLOR_ICW(3)),        D3DRS_PSRGBINPUTS3,
    E(NV097_SET_COMBINER_COLOR_ICW(4)),        D3DRS_PSRGBINPUTS4,
    E(NV097_SET_COMBINER_COLOR_ICW(5)),        D3DRS_PSRGBINPUTS5,
    E(NV097_SET_COMBINER_COLOR_ICW(6)),        D3DRS_PSRGBINPUTS6,
    E(NV097_SET_COMBINER_COLOR_ICW(7)),        D3DRS_PSRGBINPUTS7,
    E(NV097_SET_SHADER_CLIP_PLANE_MODE),       D3DRS_PSCOMPAREMODE,
    E(NV097_SET_SPECULAR_FOG_FACTOR(0)),       D3DRS_PSFINALCOMBINERCONSTANT0,
    E(NV097_SET_SPECULAR_FOG_FACTOR(1)),       D3DRS_PSFINALCOMBINERCONSTANT1,
    E(NV097_SET_COMBINER_COLOR_OCW(0)),        D3DRS_PSRGBOUTPUTS0,
    E(NV097_SET_COMBINER_COLOR_OCW(1)),        D3DRS_PSRGBOUTPUTS1,
    E(NV097_SET_COMBINER_COLOR_OCW(2)),        D3DRS_PSRGBOUTPUTS2,
    E(NV097_SET_COMBINER_COLOR_OCW(3)),        D3DRS_PSRGBOUTPUTS3,
    E(NV097_SET_COMBINER_COLOR_OCW(4)),        D3DRS_PSRGBOUTPUTS4,
    E(NV097_SET_COMBINER_COLOR_OCW(5)),        D3DRS_PSRGBOUTPUTS5,
    E(NV097_SET_COMBINER_COLOR_OCW(6)),        D3DRS_PSRGBOUTPUTS6,
    E(NV097_SET_COMBINER_COLOR_OCW(7)),        D3DRS_PSRGBOUTPUTS7,
    E(NV097_SET_COMBINER_CONTROL),             D3DRS_PSCOMBINERCOUNT,
    E(NV097_SET_COLOR_CLEAR_VALUE),            54, // Slot reserved for PSTEXTUREMODES
                                                   // (so we use a parameterized NOP)
    E(NV097_SET_DOT_RGBMAPPING),               D3DRS_PSDOTMAPPING,
    E(NV097_SET_SHADER_OTHER_STAGE_INPUT),     D3DRS_PSINPUTTEXTURE,
                                                                            
    E(NV097_SET_DEPTH_FUNC),                   D3DRS_ZFUNC,
    E(NV097_SET_ALPHA_FUNC),                   D3DRS_ALPHAFUNC,
    E(NV097_SET_BLEND_ENABLE),                 D3DRS_ALPHABLENDENABLE,
    E(NV097_SET_ALPHA_TEST_ENABLE),            D3DRS_ALPHATESTENABLE,
    E(NV097_SET_ALPHA_REF),                    D3DRS_ALPHAREF,
    E(NV097_SET_BLEND_FUNC_SFACTOR),           D3DRS_SRCBLEND,
    E(NV097_SET_BLEND_FUNC_DFACTOR),           D3DRS_DESTBLEND,
    E(NV097_SET_DEPTH_MASK),                   D3DRS_ZWRITEENABLE,
    E(NV097_SET_DITHER_ENABLE),                D3DRS_DITHERENABLE,
    E(NV097_SET_SHADE_MODE),                   D3DRS_SHADEMODE,
    E(NV097_SET_COLOR_MASK),                   D3DRS_COLORWRITEENABLE,
    E(NV097_SET_STENCIL_OP_ZFAIL),             D3DRS_STENCILZFAIL,
    E(NV097_SET_STENCIL_OP_ZPASS),             D3DRS_STENCILPASS,
    E(NV097_SET_STENCIL_FUNC),                 D3DRS_STENCILFUNC,
    E(NV097_SET_STENCIL_FUNC_REF),             D3DRS_STENCILREF,
    E(NV097_SET_STENCIL_FUNC_MASK),            D3DRS_STENCILMASK,
    E(NV097_SET_STENCIL_MASK),                 D3DRS_STENCILWRITEMASK,
    E(NV097_SET_BLEND_EQUATION),               D3DRS_BLENDOP,
    E(NV097_SET_BLEND_COLOR),                  D3DRS_BLENDCOLOR,
    E(NV097_SET_SWATH_WIDTH),                  D3DRS_SWATHWIDTH,
    E(NV097_SET_POLYGON_OFFSET_SCALE_FACTOR),  D3DRS_POLYGONOFFSETZSLOPESCALE,
    E(NV097_SET_POLYGON_OFFSET_BIAS),          D3DRS_POLYGONOFFSETZOFFSET,
    E(NV097_SET_POLY_OFFSET_POINT_ENABLE),     D3DRS_POINTOFFSETENABLE,
    E(NV097_SET_POLY_OFFSET_LINE_ENABLE),      D3DRS_WIREFRAMEOFFSETENABLE,
    E(NV097_SET_POLY_OFFSET_FILL_ENABLE),      D3DRS_SOLIDOFFSETENABLE,
};

//------------------------------------------------------------------------------
// VerifyHeaderFileEncodings
//
// Verify that the header file render and texture states are consistent
// with all the various tables we have sprinkled around everywhere.

VOID VerifyHeaderFileEncodings()
{
    DWORD i;

    // If you hit an assert in here, it's most likely because one of the
    // state tables is out-of-whack.

    ASSERT(sizeof(g_RenderStateEncodings) / (2 * sizeof(DWORD)) 
           == D3DRS_SIMPLE_MAX);
    ASSERT(sizeof(D3DSIMPLERENDERSTATEENCODE) / (sizeof(DWORD)) 
           == D3DRS_SIMPLE_MAX);

    for (i = 0; i < D3DRS_SIMPLE_MAX; i++)
    {
        ASSERT(g_RenderStateEncodings[2*i + 1] == i);
        ASSERT(g_RenderStateEncodings[2*i] == D3DSIMPLERENDERSTATEENCODE[i]);
    }

    ASSERT(sizeof(D3DDIRTYFROMRENDERSTATE) / sizeof(D3DDIRTYFROMRENDERSTATE[0])
           == (D3DRS_DEFERRED_MAX - D3DRS_SIMPLE_MAX));

    ASSERT(sizeof(g_ComplexRenderStateFunctionTable) 
         / sizeof(g_ComplexRenderStateFunctionTable[0])
           == (D3DRS_MAX - D3DRS_DEFERRED_MAX));

    ASSERT(sizeof(D3DDIRTYFROMTEXTURESTATE) / sizeof(D3DDIRTYFROMTEXTURESTATE[0])
           == (D3DTSS_DEFERRED_MAX));
}

#endif

//------------------------------------------------------------------------------
// D3DDevice_SetRenderState_EdgeAntiAlias

extern "C"
VOID WINAPI D3DDevice_SetRenderState_EdgeAntiAlias(
    DWORD Value)
{
    COUNT_API(API_D3DDEVICE_SETRENDERSTATE_EDGEANTIALIAS);

    CDevice* pDevice = g_pDevice;

    PPUSH pPush = pDevice->StartPush();

    // Note that we don't do PointSmoothEnable because that's truly
    // PointSpritesEnable, which is done via D3DRS_POINTSPRITEENABLE.

    Push2(pPush, NV097_SET_LINE_SMOOTH_ENABLE, 

          // NV097_SET_LINE_SMOOTH_ENABLE:

          Value,

          // NV097_SET_POLY_SMOOTH_ENABLE:

          Value);

    pDevice->EndPush(pPush + 3);

    D3D__RenderState[D3DRS_EDGEANTIALIAS] = Value;
}

//------------------------------------------------------------------------------
// D3DDevice_SetRenderState_ShadowFunc

extern "C"
VOID WINAPI D3DDevice_SetRenderState_ShadowFunc(
    DWORD Value)
{
    COUNT_API(API_D3DDEVICE_SETRENDERSTATE_SHADOWFUNC);

    CDevice* pDevice = g_pDevice;

    PPUSH pPush = pDevice->StartPush();

    // Oddly enough, the hardware takes 0-based values for 
    // NV097_SET_SHADOW_DEPTH_FUNC:

    Push1(pPush, NV097_SET_SHADOW_DEPTH_FUNC, Value - D3DCMP_NEVER);

    pDevice->EndPush(pPush + 2);

    D3D__RenderState[D3DRS_SHADOWFUNC] = Value;
}

//------------------------------------------------------------------------------
// D3DDevice_SetRenderState_FogColor

extern "C"
VOID WINAPI D3DDevice_SetRenderState_FogColor(
    DWORD Value)
{
    COUNT_API(API_D3DDEVICE_SETRENDERSTATE_FOGCOLOR);

    CDevice* pDevice = g_pDevice;

    PPUSH pPush = pDevice->StartPush();

    // Note that this requires a 'SwapRgb' whereas no other color register
    // does (why I don't know)...

    Push1(pPush, NV097_SET_FOG_COLOR, SwapRgb(Value));

    pDevice->EndPush(pPush + 2);

    D3D__RenderState[D3DRS_FOGCOLOR] = Value;
}

//------------------------------------------------------------------------------
// D3DDevice_SetRenderState_CullMode

extern "C"
VOID WINAPI D3DDevice_SetRenderState_CullMode(
    DWORD Value)
{
    COUNT_API(API_D3DDEVICE_SETRENDERSTATE_CULLMODE);

    CDevice* pDevice = g_pDevice;

    PPUSH pPush = pDevice->StartPush();

    if (Value == D3DCULL_NONE)
    {
        Push1(pPush, NV097_SET_CULL_FACE_ENABLE, FALSE);
        pDevice->EndPush(pPush + 2);
    }
    else
    {
        Push1(pPush, NV097_SET_CULL_FACE_ENABLE, TRUE);

        DWORD cullFace = (Value == D3D__RenderState[D3DRS_FRONTFACE]) 
                       ? NV097_SET_CULL_FACE_V_FRONT
                       : NV097_SET_CULL_FACE_V_BACK;

        Push1(pPush + 2, NV097_SET_CULL_FACE, cullFace);

        pDevice->EndPush(pPush + 4);
    }

    D3D__RenderState[D3DRS_CULLMODE] = Value;
}

//------------------------------------------------------------------------------
// D3DDevice_SetRenderState_FrontFace

extern "C"
VOID WINAPI D3DDevice_SetRenderState_FrontFace(
    DWORD Value)
{
    COUNT_API(API_D3DDEVICE_SETRENDERSTATE_FRONTFACE);

    CDevice* pDevice = g_pDevice;

    PPUSH pPush = pDevice->StartPush();

    Push1(pPush, NV097_SET_FRONT_FACE, Value);

    pDevice->EndPush(pPush + 2);

    D3D__RenderState[D3DRS_FRONTFACE] = Value;

    // Because the hardware sets the cull-mode based on 'front' or 'back',
    // whereas our API does it based on 'clockwise' or 'counterclockwise',
    // we have to reprogram the cull-mode when our definition of 'front'
    // changes:

    D3DDevice_SetRenderState_CullMode(D3D__RenderState[D3DRS_CULLMODE]);
}

//------------------------------------------------------------------------------
// D3DDevice_SetRenderState_NormalizeNormals

extern "C"
VOID WINAPI D3DDevice_SetRenderState_NormalizeNormals(
    DWORD Value)
{
    COUNT_API(API_D3DDEVICE_SETRENDERSTATE_NORMALIZENORMALS);

    CDevice* pDevice = g_pDevice;

    PPUSH pPush = pDevice->StartPush();

    Push1(pPush, NV097_SET_NORMALIZATION_ENABLE, Value);

    pDevice->EndPush(pPush + 2);

    // Transforms need to know:

    D3D__DirtyFlags |= D3DDIRTYFLAG_TRANSFORM;

    D3D__RenderState[D3DRS_NORMALIZENORMALS] = Value;
}

//------------------------------------------------------------------------------
// D3DDevice_SetRenderState_ZEnable

extern "C"
VOID WINAPI D3DDevice_SetRenderState_ZEnable(
    DWORD Value)
{
    COUNT_API(API_D3DDEVICE_SETRENDERSTATE_ZENABLE);

    CDevice* pDevice = g_pDevice;

    PPUSH pPush = pDevice->StartPush();

    Push1(pPush, 
          NV097_SET_DEPTH_TEST_ENABLE, 
          ((Value != D3DZB_FALSE) && (pDevice->m_pZBuffer != NULL)));

    if (Value == D3DZB_USEW)
    {
        Push1(pPush + 2,
              NV097_SET_ZMIN_MAX_CONTROL, 
              DRF_DEF(097, _SET_ZMIN_MAX_CONTROL, _CULL_NEAR_FAR_EN, _FALSE)
            | DRF_DEF(097, _SET_ZMIN_MAX_CONTROL, _ZCLAMP_EN, _CULL)
            | DRF_DEF(097, _SET_ZMIN_MAX_CONTROL, _CULL_IGNORE_W, _FALSE)); 
    }
    else
    {
        Push1(pPush + 2,
              NV097_SET_ZMIN_MAX_CONTROL, 
              DRF_DEF(097, _SET_ZMIN_MAX_CONTROL, _CULL_NEAR_FAR_EN, _TRUE)
            | DRF_DEF(097, _SET_ZMIN_MAX_CONTROL, _ZCLAMP_EN, _CULL)
            | DRF_DEF(097, _SET_ZMIN_MAX_CONTROL, _CULL_IGNORE_W, _FALSE)); 
    }

    pDevice->EndPush(pPush + 4);

    DWORD oldValue = D3D__RenderState[D3DRS_ZENABLE];

    D3D__RenderState[D3DRS_ZENABLE] = Value;

    // When transitioning to or from w-buffering mode, we have to do
    // a bunch of extra junk:

    if ((oldValue == D3DZB_USEW) || (Value == D3DZB_USEW))
    {
        UpdateProjectionViewportTransform();

        CommonSetPassthroughProgram(pDevice);

        PPUSH pPush = pDevice->StartPush();

        pPush = CommonSetControl0(pDevice, pPush);

        pPush = CommonSetViewport(pDevice, pPush);

        pDevice->EndPush(pPush);
    }
}

//------------------------------------------------------------------------------
// D3DDevice_SetRenderState_StencilEnable

extern "C"
VOID WINAPI D3DDevice_SetRenderState_StencilEnable(
    DWORD Value)
{
    COUNT_API(API_D3DDEVICE_SETRENDERSTATE_STENCILENABLE);

    CDevice* pDevice = g_pDevice;

#if DBG

    if (DBG_CHECK(Value))
    {
        g_StencilEverEnabled = TRUE;
    }

#endif

    PPUSH pPush = pDevice->StartPush();

    pPush = CommonSetOccludeZStencilEn(pDevice, pPush);

    Push1(pPush, 
          NV097_SET_STENCIL_TEST_ENABLE, 
          (Value && (pDevice->m_pZBuffer != NULL)));

    pDevice->EndPush(pPush + 2);

    D3D__RenderState[D3DRS_STENCILENABLE] = Value;
}

//------------------------------------------------------------------------------
// D3DDevice_SetRenderState_StencilFail

extern "C"
VOID WINAPI D3DDevice_SetRenderState_StencilFail(
    DWORD Value)
{
    COUNT_API(API_D3DDEVICE_SETRENDERSTATE_STENCILFAIL);

    CDevice* pDevice = g_pDevice;

    PPUSH pPush = pDevice->StartPush();

    pPush = CommonSetOccludeZStencilEn(pDevice, pPush);

    Push1(pPush, NV097_SET_STENCIL_OP_FAIL, Value);

    pDevice->EndPush(pPush + 2);

    D3D__RenderState[D3DRS_STENCILFAIL] = Value;
}

//------------------------------------------------------------------------------
// D3DDevice_SetRenderState_TextureFactor

extern "C"
VOID WINAPI D3DDevice_SetRenderState_TextureFactor(
    DWORD Value)
{
    COUNT_API(API_D3DDEVICE_SETRENDERSTATE_TEXTUREFACTOR);

    CDevice* pDevice = g_pDevice;

    // Only whack the combiner-factor registers if a pixel shader is not
    // active:

    if (pDevice->m_pPixelShader == NULL)
    {
        PPUSH pPush = pDevice->StartPush();
    
        // Hit NV097_SET_COMBINER_FACTOR0 and NV097_SET_COMBINER_FACTOR1 for
        // all the stages:
    
        PushCount(pPush++, NV097_SET_COMBINER_FACTOR0(0), 2 * NUM_COMBINERS);
    
        for (DWORD i = 0; i < 2 * NUM_COMBINERS; i++)
            *pPush++ = Value;
    
        pDevice->EndPush(pPush);
    }

    D3D__RenderState[D3DRS_TEXTUREFACTOR] = Value;
}

//------------------------------------------------------------------------------
// D3DDevice_SetRenderState_LineWidth

extern "C"
VOID WINAPI D3DDevice_SetRenderState_LineWidth(
    DWORD Value)
{
    COUNT_API(API_D3DDEVICE_SETRENDERSTATE_LINEWIDTH);

    CDevice* pDevice = g_pDevice;

    // Convert to 6.3:

    DWORD width = Round(Floatify(Value) * 8.0f * pDevice->m_SuperSampleScale);

    // Clamp to 63.875:

    if (width > 0x1ff)
    {
        width = 0x1ff;
    }

    PPUSH pPush = pDevice->StartPush();

    Push1(pPush, NV097_SET_LINE_WIDTH, width);

    pDevice->EndPush(pPush + 2);

    D3D__RenderState[D3DRS_LINEWIDTH] = Value;
}

//------------------------------------------------------------------------------
// D3DDevice_SetRenderState_Dxt1NoiseEnable

extern "C"
VOID WINAPI D3DDevice_SetRenderState_Dxt1NoiseEnable(
    DWORD Value)
{
    CDevice* pDevice = g_pDevice;

    // We ignore the noise-enable render state when the render target is
    // 16bpp:

    BOOL noiseEnable = FALSE;
    if (PixelJar::GetBitsPerPixel(pDevice->m_pRenderTarget) == 32)
    {
        noiseEnable = Value;
    }

    // Changing the noise-enable status is extremely expensive, so in a rare
    // departure we actually check to see if the new value is different (in
    // part because this is called for every SetRenderTarget call).

    ASSERT((STATE_DXTNOISEENABLE == TRUE) && ((noiseEnable & ~1) == 0));

    if (noiseEnable != (pDevice->m_StateFlags & STATE_DXTNOISEENABLE))
    {
        // Since this is always called from SetRenderTarget, count the 
        // API call only if the state changes:

        COUNT_API(API_D3DDEVICE_SETRENDERSTATE_DXT1NOISEENABLE);

        pDevice->m_StateFlags ^= STATE_DXTNOISEENABLE;

        PPUSH pPush = pDevice->StartPush();
    
        Push1(pPush, NV097_WAIT_FOR_IDLE, 0);

        // NVX_DXT1_NOISE_ENABLE Data stored in NV097_SET_ZSTENCIL_CLEAR_VALUE

        Push1(pPush + 2, NV097_SET_ZSTENCIL_CLEAR_VALUE, 
              noiseEnable);
    
        Push1(pPush + 4,
              NV097_NO_OPERATION,
              NVX_DXT1_NOISE_ENABLE);
    
        pDevice->EndPush(pPush + 6);
    }

    D3D__RenderState[D3DRS_DXT1NOISEENABLE] = Value;
}

//------------------------------------------------------------------------------
// D3DDevice_SetRenderState_YuvEnable

extern "C"
VOID WINAPI D3DDevice_SetRenderState_YuvEnable(
    DWORD Value)
{
    COUNT_API(API_D3DDEVICE_SETRENDERSTATE_YUVENABLE);

    CDevice* pDevice = g_pDevice;

    D3D__RenderState[D3DRS_YUVENABLE] = Value;

    PPUSH pPush = pDevice->StartPush();

    pPush = CommonSetControl0(pDevice, pPush);

    pDevice->EndPush(pPush);
}

//------------------------------------------------------------------------------
// D3DDevice_SetRenderState_OcclusionCullEnable

extern "C"
VOID WINAPI D3DDevice_SetRenderState_OcclusionCullEnable(
    DWORD Value)
{
    COUNT_API(API_D3DDEVICE_SETRENDERSTATE_OCCLUSIONCULLENABLE);

    CDevice* pDevice = g_pDevice;

    D3D__RenderState[D3DRS_OCCLUSIONCULLENABLE] = Value;

    PPUSH pPush = pDevice->StartPush();

    pPush = CommonSetOccludeZStencilEn(pDevice, pPush);

    pDevice->EndPush(pPush);
}

//------------------------------------------------------------------------------
// D3DDevice_SetRenderState_StencilCullEnable

extern "C"
VOID WINAPI D3DDevice_SetRenderState_StencilCullEnable(
    DWORD Value)
{
    COUNT_API(API_D3DDEVICE_SETRENDERSTATE_STENCILCULLENABLE);

    CDevice* pDevice = g_pDevice;

    D3D__RenderState[D3DRS_STENCILCULLENABLE] = Value;

    PPUSH pPush = pDevice->StartPush();

    pPush = CommonSetOccludeZStencilEn(pDevice, pPush);

    pDevice->EndPush(pPush);
}

//------------------------------------------------------------------------------
// D3DDevice_SetRenderState_RopZCmpAlwaysRead

extern "C"
VOID WINAPI D3DDevice_SetRenderState_RopZCmpAlwaysRead(
    DWORD Value)
{
    COUNT_API(API_D3DDEVICE_SETRENDERSTATE_ROPZCMPALWAYSREAD);

    D3D__RenderState[D3DRS_ROPZCMPALWAYSREAD] = Value;

    CommonSetDebugRegisters();
}

//------------------------------------------------------------------------------
// D3DDevice_SetRenderState_RopZRead

extern "C"
VOID WINAPI D3DDevice_SetRenderState_RopZRead(
    DWORD Value)
{
    COUNT_API(API_D3DDEVICE_SETRENDERSTATE_ROPZREAD);

    D3D__RenderState[D3DRS_ROPZREAD] = Value;

    CommonSetDebugRegisters();
}

//------------------------------------------------------------------------------
// D3DDevice_SetRenderState_DoNotCullUncompressed

extern "C"
VOID WINAPI D3DDevice_SetRenderState_DoNotCullUncompressed(
    DWORD Value)
{
    COUNT_API(API_D3DDEVICE_SETRENDERSTATE_DONOTCULLUNCOMPRESSED);

    D3D__RenderState[D3DRS_DONOTCULLUNCOMPRESSED] = Value;

    CommonSetDebugRegisters();
}

//------------------------------------------------------------------------------
// D3DDevice_SetRenderState_ZBias
//
// DOC: This overwrites current D3DRS_POLYGONOFFSETZSLOPESCALE, 
//      D3DRS_POLYGONOFFSETZOFFSET, D3DRS_POINTOFFSETENABLE, 
//      D3DRS_WIREFRAMEOFFSETENABLE, D3DRS_SOLIDOFFSETENABLE values.

extern "C"
VOID WINAPI D3DDevice_SetRenderState_ZBias(
    DWORD Value)
{
    COUNT_API(API_D3DDEVICE_SETRENDERSTATE_ZBIAS);

    CDevice* pDevice = g_pDevice;

    // State blocks restore stuff in reverse order, so make sure ZBias won't
    // nuke any individually set parameters:

    ASSERT((D3DRS_ZBIAS > D3DRS_POLYGONOFFSETZSLOPESCALE) &&
           (D3DRS_ZBIAS > D3DRS_POLYGONOFFSETZOFFSET) &&
           (D3DRS_ZBIAS > D3DRS_POINTOFFSETENABLE) &&
           (D3DRS_ZBIAS > D3DRS_WIREFRAMEOFFSETENABLE) &&
           (D3DRS_ZBIAS > D3DRS_SOLIDOFFSETENABLE));

    BOOL enable = (Value != 0);
    FLOAT bias = -(FLOAT)Value;
    FLOAT scale = 0.25f * bias;

    pDevice->SetRenderState(D3DRS_POLYGONOFFSETZSLOPESCALE, Dwordify(scale));
    pDevice->SetRenderState(D3DRS_POLYGONOFFSETZOFFSET, Dwordify(bias));
    pDevice->SetRenderState(D3DRS_POINTOFFSETENABLE, enable);
    pDevice->SetRenderState(D3DRS_WIREFRAMEOFFSETENABLE, enable);
    pDevice->SetRenderState(D3DRS_SOLIDOFFSETENABLE, enable);

    D3D__RenderState[D3DRS_ZBIAS] = Value;
}

//------------------------------------------------------------------------------
// D3DDevice_SetRenderState_MultiSampleMode

extern "C"
VOID WINAPI D3DDevice_SetRenderState_MultiSampleMode(
    DWORD Value)
{
    COUNT_API(API_D3DDEVICE_SETRENDERSTATE_MULTISAMPLEMODE);

    CDevice* pDevice = g_pDevice;

    D3D__RenderState[D3DRS_MULTISAMPLEMODE] = Value;

    D3DSurface* pRenderTarget = pDevice->m_pRenderTarget;
    if (pRenderTarget == pDevice->m_pFrameBuffer[0])
    {
        D3DDevice_SetRenderTarget(pRenderTarget, pDevice->m_pZBuffer); 
    }
}

//------------------------------------------------------------------------------
// D3DDevice_SetRenderState_MultiSampleRenderTargetMode

extern "C"
VOID WINAPI D3DDevice_SetRenderState_MultiSampleRenderTargetMode(
    DWORD Value)
{
    COUNT_API(API_D3DDEVICE_SETRENDERSTATE_MULTISAMPLERENDERTARGETMODE);

    CDevice* pDevice = g_pDevice;

    D3D__RenderState[D3DRS_MULTISAMPLERENDERTARGETMODE] = Value;

    D3DSurface* pRenderTarget = pDevice->m_pRenderTarget;
    if (pRenderTarget != pDevice->m_pFrameBuffer[0])
    {
        D3DDevice_SetRenderTarget(pRenderTarget, pDevice->m_pZBuffer); 
    }
}

//------------------------------------------------------------------------------
// D3DDevice_SetRenderState_MultiSampleAntiAlias

extern "C"
VOID WINAPI D3DDevice_SetRenderState_MultiSampleAntiAlias(
    DWORD Value)
{
    COUNT_API(API_D3DDEVICE_SETRENDERSTATE_MULTISAMPLEANTIALIAS);

    CDevice* pDevice = g_pDevice;

    D3D__RenderState[D3DRS_MULTISAMPLEANTIALIAS] = Value;

    CommonSetAntiAliasingControl(pDevice);
}

//------------------------------------------------------------------------------
// D3DDevice_SetRenderState_MultiSampleMask

extern "C"
VOID WINAPI D3DDevice_SetRenderState_MultiSampleMask(
    DWORD Value)
{
    COUNT_API(API_D3DDEVICE_SETRENDERSTATE_MULTISAMPLEMASK);

    CDevice* pDevice = g_pDevice;

    D3D__RenderState[D3DRS_MULTISAMPLEMASK] = Value;

    CommonSetAntiAliasingControl(pDevice);
}

//------------------------------------------------------------------------------
// D3DDevice_SetRenderState_LogicOp

extern "C"
VOID WINAPI D3DDevice_SetRenderState_LogicOp(
    DWORD Value)
{
    COUNT_API(API_D3DDEVICE_SETRENDERSTATE_LOGICOP);

    CDevice* pDevice = g_pDevice;

    PPUSH pPush = pDevice->StartPush();

    if (Value == D3DLOGICOP_NONE)
    {
        Push1(pPush, NV097_SET_LOGIC_OP_ENABLE, FALSE);

        pPush += 2;
    }
    else
    {
        Push2(pPush, NV097_SET_LOGIC_OP_ENABLE, 
    
              // NV097_SET_LOGIC_OP_ENABLE:
    
              TRUE,
    
              // NV097_SET_LOGIC_OP:
    
              Value);

        pPush += 3;
    }

    pDevice->EndPush(pPush);

    D3D__RenderState[D3DRS_LOGICOP] = Value;
}

//------------------------------------------------------------------------------
// D3DDevice_SetRenderState_FillMode

extern "C"
VOID WINAPI D3DDevice_SetRenderState_FillMode(
    DWORD Value)
{
    COUNT_API(API_D3DDEVICE_SETRENDERSTATE_FILLMODE);

    CDevice* pDevice = g_pDevice;

    PPUSH pPush = pDevice->StartPush();

    DWORD backFillMode = D3D__RenderState[D3DRS_TWOSIDEDLIGHTING]
                       ? D3D__RenderState[D3DRS_BACKFILLMODE]
                       : Value;

    // Set both NV097_SET_FRONT_POLYGON_MODE and NV097_SET_BACK_POLYGON_MODE:

    Push2(pPush, NV097_SET_FRONT_POLYGON_MODE, Value, backFillMode);

    pDevice->EndPush(pPush + 3);

    D3D__RenderState[D3DRS_FILLMODE] = Value;
}

//------------------------------------------------------------------------------
// D3DDevice_SetRenderState_BackFillMode

extern "C"
VOID WINAPI D3DDevice_SetRenderState_BackFillMode(
    DWORD Value)
{
    COUNT_API(API_D3DDEVICE_SETRENDERSTATE_BACKFILLMODE);

    D3D__RenderState[D3DRS_BACKFILLMODE] = Value;

    D3DDevice_SetRenderState_FillMode(D3D__RenderState[D3DRS_FILLMODE]);
}

//------------------------------------------------------------------------------
// D3DDevice_SetRenderState_TwoSidedLighting

extern "C"
VOID WINAPI D3DDevice_SetRenderState_TwoSidedLighting(
    DWORD Value)
{
    COUNT_API(API_D3DDEVICE_SETRENDERSTATE_TWOSIDEDLIGHTING);

    CDevice* pDevice = g_pDevice;

    // We could D3DDIRTYFLAG_LIGHTS only for the disable case if we actually
    // hit the two-sided enable register here...

    D3D__DirtyFlags |= D3DDIRTYFLAG_LIGHTS;

    D3D__RenderState[D3DRS_TWOSIDEDLIGHTING] = Value;

    // When two-sided lighting is disabled, FILLMODE applies to both the
    // back-sides and front-sides.  So if it changes, we have to update:

    D3DDevice_SetRenderState_FillMode(D3D__RenderState[D3DRS_FILLMODE]);
}

//------------------------------------------------------------------------------
// D3DDevice_SetRenderState_VertexBlend

extern "C"
VOID WINAPI D3DDevice_SetRenderState_VertexBlend(
    DWORD Value)
{
    COUNT_API(API_D3DDEVICE_SETRENDERSTATE_VERTEXBLEND);

    CDevice* pDevice = g_pDevice;

    D3D__DirtyFlags |= D3DDIRTYFLAG_TRANSFORM;

    PPUSH pPush = pDevice->StartPush();

    Push1(pPush, NV097_SET_SKIN_MODE, Value);

    pDevice->EndPush(pPush + 2);

    D3D__RenderState[D3DRS_VERTEXBLEND] = Value;
}

//------------------------------------------------------------------------------
// D3DDevice_SetRenderState_PSTextureModes

extern "C"
VOID WINAPI D3DDevice_SetRenderState_PSTextureModes(
    DWORD Value)
{
    COUNT_API(API_D3DDEVICE_SETRENDERSTATE_PSTEXTUREMODES);

    CDevice* pDevice = g_pDevice;

    // Make adjustments to texture modes based on current textures

    pDevice->m_PSShaderStageProgram = Value;

    D3D__DirtyFlags |= D3DDIRTYFLAG_SHADER_STAGE_PROGRAM;

    D3D__RenderState[D3DRS_PSTEXTUREMODES] = Value;
}

#if DBG

//------------------------------------------------------------------------------
// D3DDevice_SetRenderState_ParameterCheck

extern "C"
HRESULT WINAPI D3DDevice_SetRenderState_ParameterCheck(
    D3DRENDERSTATETYPE State,
    DWORD Value) 
{ 
    COUNT_API(API_D3DDEVICE_SETRENDERSTATE_PARAMETERCHECK);

    CDevice *pDevice = g_pDevice;

    if (DBG_CHECK(TRUE))
    {
        if (State >= D3DRS_MAX) 
        {
            D3D_ERR("Invalid render state type");
            return D3DERR_INVALIDCALL;
        }

        switch(State)
        {
        case D3DRS_ALPHATESTENABLE:
            if ((Value != FALSE) && (Value != TRUE))
            {
                DPF_ERR("Invalid value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_ALPHAREF:
            if (Value & 0xffffff00)
            {
                DPF_ERR("Invalid value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_ALPHAFUNC:
            if ((Value < D3DCMP_NEVER) || (Value > D3DCMP_ALWAYS))
            {
                DPF_ERR("Invalid value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_ZWRITEENABLE:
            if ((Value != FALSE) && (Value != TRUE))
            {
                DPF_ERR("Invalid value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_ALPHABLENDENABLE:
            if ((Value != FALSE) && (Value != TRUE))
            {
                DPF_ERR("Invalid value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_SRCBLEND:
            if (((Value > D3DBLEND_ONE) && (Value < D3DBLEND_SRCCOLOR)) ||
                ((Value > D3DBLEND_SRCALPHASAT) && (Value < D3DBLEND_CONSTANTCOLOR)) ||
                (Value > D3DBLEND_INVCONSTANTALPHA))
            {
                DPF_ERR("Invalid value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_DESTBLEND:
            if (((Value > D3DBLEND_ONE) && (Value < D3DBLEND_SRCCOLOR)) ||
                ((Value > D3DBLEND_SRCALPHASAT) && (Value < D3DBLEND_CONSTANTCOLOR)) ||
                (Value > D3DBLEND_INVCONSTANTALPHA))
            {
                DPF_ERR("Invalid value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_DITHERENABLE:
            if ((Value != FALSE) && (Value != TRUE))
            {
                DPF_ERR("Invalid value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_FILLMODE:
        case D3DRS_BACKFILLMODE:
            if ((Value < D3DFILL_POINT) || (Value > D3DFILL_SOLID))
            {
                DPF_ERR("Invalid value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_SHADEMODE:
            if ((Value < D3DSHADE_FLAT) || (Value > D3DSHADE_GOURAUD))
            {
                DPF_ERR("Invalid value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_CULLMODE:
            if ((Value != D3DCULL_NONE) && 
                (Value != D3DCULL_CW) && 
                (Value != D3DCULL_CCW))
            {
                DPF_ERR("Invalid value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_NORMALIZENORMALS:
            if ((Value != FALSE) && (Value != TRUE))
            {
                DPF_ERR("Invalid value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_SWATHWIDTH:
            if (((Value > D3DSWATH_128) && (Value < D3DSWATH_OFF)) ||
                (Value > D3DSWATH_OFF))
            {
                DPF_ERR("Invalid value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_ZENABLE:
            if (Value > D3DZB_USEW)
            {
                DPF_ERR("Invalid value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_ZFUNC:
            if ((Value < D3DCMP_NEVER) || (Value > D3DCMP_ALWAYS))
            {
                DPF_ERR("Invalid value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_COLORWRITEENABLE:
            if (Value & ~(D3DCOLORWRITEENABLE_ALPHA |
                          D3DCOLORWRITEENABLE_RED |
                          D3DCOLORWRITEENABLE_GREEN |
                          D3DCOLORWRITEENABLE_BLUE))
            {
                DPF_ERR("Invalid value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_STENCILENABLE:
            if ((Value != FALSE) && (Value != TRUE))
            {
                DPF_ERR("Invalid value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_STENCILFAIL:
            if (!((Value == D3DSTENCILOP_ZERO) ||
                  (Value >= D3DSTENCILOP_KEEP && Value <= D3DSTENCILOP_DECRSAT) ||
                  (Value == D3DSTENCILOP_INVERT) ||
                  (Value >= D3DSTENCILOP_INCR && Value <= D3DSTENCILOP_DECR)))
            {
                DPF_ERR("Invalid value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_STENCILZFAIL:
            if (!((Value == D3DSTENCILOP_ZERO) ||
                  (Value >= D3DSTENCILOP_KEEP && Value <= D3DSTENCILOP_DECRSAT) ||
                  (Value == D3DSTENCILOP_INVERT) ||
                  (Value >= D3DSTENCILOP_INCR && Value <= D3DSTENCILOP_DECR)))
            {
                DPF_ERR("Invalid value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_STENCILPASS:
            if (!((Value == D3DSTENCILOP_ZERO) ||
                  (Value >= D3DSTENCILOP_KEEP && Value <= D3DSTENCILOP_DECRSAT) ||
                  (Value == D3DSTENCILOP_INVERT) ||
                  (Value >= D3DSTENCILOP_INCR && Value <= D3DSTENCILOP_DECR)))
            {
                DPF_ERR("Invalid value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_STENCILFUNC:
            if ((Value < D3DCMP_NEVER) || (Value > D3DCMP_ALWAYS))
            {
                DPF_ERR("Invalid value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_STENCILREF:
            if (Value > 0xff)
            {
                DPF_ERR("Invalid value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_VERTEXBLEND:
            if (Value >= D3DVBF_MAX)
            {
                DPF_ERR("Invalid value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_LINEWIDTH:
            if (Floatify(Value) < 0.0f)
            {
                DPF_ERR("Invalid value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_DXT1NOISEENABLE:
        case D3DRS_YUVENABLE:
        case D3DRS_OCCLUSIONCULLENABLE:
        case D3DRS_STENCILCULLENABLE:
        case D3DRS_ROPZCMPALWAYSREAD:
        case D3DRS_ROPZREAD:
        case D3DRS_DONOTCULLUNCOMPRESSED:
            if ((Value != FALSE) && (Value != TRUE))
            {
                DPF_ERR("Invalid value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_POINTSIZE:
        case D3DRS_POINTSIZE_MIN:
        case D3DRS_POINTSIZE_MAX:
            if (Floatify(Value) < 0.0f)
            {
                DPF_ERR("Invalid value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_POINTSCALEENABLE:
            if ((Value != FALSE) && (Value != TRUE))
            {
                DPF_ERR("Invalid value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_POINTSPRITEENABLE:
            if ((Value != FALSE) && (Value != TRUE))
            {
                DPF_ERR("Invalid value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_POINTOFFSETENABLE:
            if ((Value != FALSE) && (Value != TRUE))
            {
                DPF_ERR("Invalid value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_WIREFRAMEOFFSETENABLE:
            if ((Value != FALSE) && (Value != TRUE))
            {
                DPF_ERR("Invalid value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_SOLIDOFFSETENABLE:
            if ((Value != FALSE) && (Value != TRUE))
            {
                DPF_ERR("Invalid value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_SHADOWFUNC:
            if ((Value < D3DCMP_NEVER) || (Value > D3DCMP_ALWAYS))
            {
                DPF_ERR("Invalid value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_ZBIAS:
            if (Value > 16)
            {
                DPF_ERR("Invalid value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_MULTISAMPLEANTIALIAS:
            if ((Value != FALSE) && (Value != TRUE))
            {
                DPF_ERR("Invalid value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_MULTISAMPLEMODE:
        case D3DRS_MULTISAMPLERENDERTARGETMODE:
            if ((Value != D3DMULTISAMPLEMODE_1X) &&
                (Value != D3DMULTISAMPLEMODE_2X) &&
                (Value != D3DMULTISAMPLEMODE_4X))
            {
                DPF_ERR("Invalid D3DMULTISAMPLEMODE value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_SWAPFILTER:
            if ((Value < D3DTEXF_POINT) || (Value > D3DTEXF_GAUSSIANCUBIC))
            {
                D3D_ERR("Invalid value.");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_LOGICOP:
            if (((Value < D3DLOGICOP_CLEAR) || (Value > D3DLOGICOP_SET)) &&
                (Value != D3DLOGICOP_NONE))
            {
                DPF_ERR("Invalid value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_EDGEANTIALIAS:
            if ((Value != FALSE) && (Value != TRUE))
            {
                DPF_ERR("Invalid value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_BLENDOP:
            if ((Value < D3DBLENDOP_ADD) ||
                ((Value > D3DBLENDOP_MAX) && (Value < D3DBLENDOP_SUBTRACT)) ||
                ((Value > D3DBLENDOP_REVSUBTRACT) && 
                        (Value < D3DBLENDOP_REVSUBTRACTSIGNED)) ||
                (Value > D3DBLENDOP_ADDSIGNED))
            {
                DPF_ERR("Invalid value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_WRAP0:
        case D3DRS_WRAP1:
        case D3DRS_WRAP2:
        case D3DRS_WRAP3:
            if (Value & ~(DRF_DEF(097, _SET_TEXTURE_ADDRESS, _CYLWRAP_U, _TRUE) 
                        | DRF_DEF(097, _SET_TEXTURE_ADDRESS, _CYLWRAP_V, _TRUE) 
                        | DRF_DEF(097, _SET_TEXTURE_ADDRESS, _CYLWRAP_P, _TRUE) 
                        | DRF_DEF(097, _SET_TEXTURE_ADDRESS, _CYLWRAP_Q, _TRUE)))
            {
                D3D_ERR("Invalid WRAP value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_LIGHTING:
        case D3DRS_TWOSIDEDLIGHTING:
        case D3DRS_SPECULARENABLE:
        case D3DRS_LOCALVIEWER:
            if ((Value != FALSE) && (Value != TRUE))
            {
                DPF_ERR("Invalid value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_BACKSPECULARMATERIALSOURCE:
        case D3DRS_BACKDIFFUSEMATERIALSOURCE:
        case D3DRS_BACKAMBIENTMATERIALSOURCE:
        case D3DRS_BACKEMISSIVEMATERIALSOURCE:
        case D3DRS_SPECULARMATERIALSOURCE:
        case D3DRS_DIFFUSEMATERIALSOURCE:
        case D3DRS_AMBIENTMATERIALSOURCE:
        case D3DRS_EMISSIVEMATERIALSOURCE:
            if ((Value != D3DMCS_COLOR1) &&
                (Value != D3DMCS_COLOR2) &&
                (Value != D3DMCS_MATERIAL))
            {
                D3D_ERR("Invalid D3DMCS value");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DRS_PSALPHAINPUTS0:
            if(!ValidCombinerInputs(Value, "PSAlphaInputs0"))
                return D3DERR_INVALIDCALL;
            break;
        case D3DRS_PSALPHAINPUTS1:
            if(!ValidCombinerInputs(Value, "PSAlphaInputs1"))
                return D3DERR_INVALIDCALL;
            break;
        case D3DRS_PSALPHAINPUTS2:
            if(!ValidCombinerInputs(Value, "PSAlphaInputs2"))
                return D3DERR_INVALIDCALL;
            break;
        case D3DRS_PSALPHAINPUTS3:
            if(!ValidCombinerInputs(Value, "PSAlphaInputs3"))
                return D3DERR_INVALIDCALL;
            break;
        case D3DRS_PSALPHAINPUTS4:
            if(!ValidCombinerInputs(Value, "PSAlphaInputs4"))
                return D3DERR_INVALIDCALL;
            break;
        case D3DRS_PSALPHAINPUTS5:
            if(!ValidCombinerInputs(Value, "PSAlphaInputs5"))
                return D3DERR_INVALIDCALL;
            break;
        case D3DRS_PSALPHAINPUTS6:
            if(!ValidCombinerInputs(Value, "PSAlphaInputs6"))
                return D3DERR_INVALIDCALL;
            break;
        case D3DRS_PSALPHAINPUTS7:
            if(!ValidCombinerInputs(Value, "PSAlphaInputs7"))
                return D3DERR_INVALIDCALL;
            break;
        case D3DRS_PSRGBINPUTS0:
            if(!ValidCombinerInputs(Value, "PSRGBInputs0"))
                return D3DERR_INVALIDCALL;
            break;
        case D3DRS_PSRGBINPUTS1:
            if(!ValidCombinerInputs(Value, "PSRGBInputs1"))
                return D3DERR_INVALIDCALL;
            break;
        case D3DRS_PSRGBINPUTS2:
            if(!ValidCombinerInputs(Value, "PSRGBInputs2"))
                return D3DERR_INVALIDCALL;
            break;
        case D3DRS_PSRGBINPUTS3:
            if(!ValidCombinerInputs(Value, "PSRGBInputs3"))
                return D3DERR_INVALIDCALL;
            break;
        case D3DRS_PSRGBINPUTS4:
            if(!ValidCombinerInputs(Value, "PSRGBInputs4"))
                return D3DERR_INVALIDCALL;
            break;
        case D3DRS_PSRGBINPUTS5:
            if(!ValidCombinerInputs(Value, "PSRGBInputs5"))
                return D3DERR_INVALIDCALL;
            break;
        case D3DRS_PSRGBINPUTS6:
            if(!ValidCombinerInputs(Value, "PSRGBInputs6"))
                return D3DERR_INVALIDCALL;
            break;
        case D3DRS_PSRGBINPUTS7:
            if(!ValidCombinerInputs(Value, "PSRGBInputs7"))
                return D3DERR_INVALIDCALL;
            break;
        case D3DRS_PSALPHAOUTPUTS0:
            if(!ValidAlphaOutputs(Value, "PSAlphaOutputs0"))
                return D3DERR_INVALIDCALL;
            break;
        case D3DRS_PSALPHAOUTPUTS1:
            if(!ValidAlphaOutputs(Value, "PSAlphaOutputs1"))
                return D3DERR_INVALIDCALL;
            break;
        case D3DRS_PSALPHAOUTPUTS2:
            if(!ValidAlphaOutputs(Value, "PSAlphaOutputs2"))
                return D3DERR_INVALIDCALL;
            break;
        case D3DRS_PSALPHAOUTPUTS3:
            if(!ValidAlphaOutputs(Value, "PSAlphaOutputs3"))
                return D3DERR_INVALIDCALL;
            break;
        case D3DRS_PSALPHAOUTPUTS4:
            if(!ValidAlphaOutputs(Value, "PSAlphaOutputs4"))
                return D3DERR_INVALIDCALL;
            break;
        case D3DRS_PSALPHAOUTPUTS5:
            if(!ValidAlphaOutputs(Value, "PSAlphaOutputs5"))
                return D3DERR_INVALIDCALL;
            break;
        case D3DRS_PSALPHAOUTPUTS6:
            if(!ValidAlphaOutputs(Value, "PSAlphaOutputs6"))
                return D3DERR_INVALIDCALL;
            break;
        case D3DRS_PSALPHAOUTPUTS7:
            if(!ValidAlphaOutputs(Value, "PSAlphaOutputs7"))
                return D3DERR_INVALIDCALL;
            break;
        case D3DRS_PSRGBOUTPUTS0:
            if(!ValidRGBOutputs(Value, "PSRGBOutputs0"))
                return D3DERR_INVALIDCALL;
            break;
        case D3DRS_PSRGBOUTPUTS1:
            if(!ValidRGBOutputs(Value, "PSRGBOutputs1"))
                return D3DERR_INVALIDCALL;
            break;
        case D3DRS_PSRGBOUTPUTS2:
            if(!ValidRGBOutputs(Value, "PSRGBOutputs2"))
                return D3DERR_INVALIDCALL;
            break;
        case D3DRS_PSRGBOUTPUTS3:
            if(!ValidRGBOutputs(Value, "PSRGBOutputs3"))
                return D3DERR_INVALIDCALL;
            break;
        case D3DRS_PSRGBOUTPUTS4:
            if(!ValidRGBOutputs(Value, "PSRGBOutputs4"))
                return D3DERR_INVALIDCALL;
            break;
        case D3DRS_PSRGBOUTPUTS5:
            if(!ValidRGBOutputs(Value, "PSRGBOutputs5"))
                return D3DERR_INVALIDCALL;
            break;
        case D3DRS_PSRGBOUTPUTS6:
            if(!ValidRGBOutputs(Value, "PSRGBOutputs6"))
                return D3DERR_INVALIDCALL;
            break;
        case D3DRS_PSRGBOUTPUTS7:
            if(!ValidRGBOutputs(Value, "PSRGBOutputs7"))
                return D3DERR_INVALIDCALL;
            break;
        case D3DRS_PSFINALCOMBINERINPUTSABCD:
            if(!ValidFinalCombinerABCD(Value, "PSFinalCombinerInputsABCD"))
                return D3DERR_INVALIDCALL;
            break;
        case D3DRS_PSFINALCOMBINERINPUTSEFG:
            if(!ValidFinalCombinerEFG(Value, "PSFinalCombinerInputsEFG"))
                return D3DERR_INVALIDCALL;
            break;
        case D3DRS_PSTEXTUREMODES:
            if(!ValidTextureModes(Value, "PSTextureModes"))
                return D3DERR_INVALIDCALL;
            break;
        case D3DRS_PSINPUTTEXTURE:
            if(!ValidInputTexture(Value, "PSInputTexture"))
                return D3DERR_INVALIDCALL;
            break;
        case D3DRS_PSCOMBINERCOUNT:
            if(!ValidCombinerCount(Value, "PSCombinerCount"))
                return D3DERR_INVALIDCALL;
            break;
        case D3DRS_PSCOMPAREMODE:
            if(!ValidCompareMode(Value, "PSCompareMode"))
                return D3DERR_INVALIDCALL;
            break;
        case D3DRS_PSDOTMAPPING:
            if(!ValidDotMapping(Value, "PSDotMapping"))
                return D3DERR_INVALIDCALL;
            break;
        }
    }

    return S_OK;
}

#endif

//------------------------------------------------------------------------------
// D3DDevice_SetRenderState_Simple[_Fast]

extern "C"
#if DBG
_declspec(naked) void D3DFASTCALL D3DDevice_SetRenderState_Simple_Fast(
#else
_declspec(naked) void D3DFASTCALL D3DDevice_SetRenderState_Simple(
#endif
    DWORD Method, // Already encoded with one-dword count
    DWORD Value)
{ 
    _asm
    {
        ; ecx = Method
        ; edx = Value

    Simple_Start:
        mov     eax, g_Device.m_Pusher.m_pPut
        add     eax, 8
        cmp     eax, g_Device.m_Pusher.m_pThreshold
        jae     Simple_MakeSpace
        mov     [g_Device.m_Pusher.m_pPut], eax
        mov     [eax-8], ecx
        mov     [eax-4], edx
        ret     

    Simple_MakeSpace:
        push    edx
        push    ecx
        call    MakeSpace
        pop     ecx
        pop     edx
        jmp     Simple_Start
    }
}

#if DBG

//------------------------------------------------------------------------------
// D3DDevice_SetRenderState_Simple (Debug only)

extern "C"
VOID D3DFASTCALL D3DDevice_SetRenderState_Simple(
    DWORD Method,
    DWORD Value)
{
    COUNT_API(API_D3DDEVICE_SETRENDERSTATE_SIMPLE);

    if (DBG_CHECK(TRUE))
    {
        if (((Method & 3) != 0) ||
            ((Method & PUSHER_METHOD(-1, 0, 0)) !=  
                       PUSHER_METHOD(SUBCH_3D, 0, 1)))
        {
            DPF_ERR("Invalid encoding");
        }
    }

    D3DDevice_SetRenderState_Simple_Fast(Method, Value);
}

#endif DBG

//------------------------------------------------------------------------------
// D3DDevice_SetRenderStateNotInline

extern "C"
VOID WINAPI D3DDevice_SetRenderStateNotInline(
    D3DRENDERSTATETYPE State,
    DWORD Value) 
{ 
    CDevice* pDevice = g_pDevice;

#if PROFILE

    // If we're supposed to override this renderstate's value then do it.

    if(g_PerfCounters.m_RenderStateOverrides[State].Override)
        Value = g_PerfCounters.m_RenderStateOverrides[State].Value;

#endif

    if (DBG_CHECK(D3DDevice_SetRenderState_ParameterCheck(State, Value) != S_OK))
        return;

    COUNT_API(API_D3DDEVICE_SETRENDERSTATENOTINLINE);
    COUNT_RENDERSTATE(State);
    if (Value == D3D__RenderState[State])
    {
        COUNT_PERF(PERF_REDUNDANT_SETRENDERSTATE);
    }

    if (State < D3DRS_SIMPLE_MAX)
    {
        D3DDevice_SetRenderState_Simple(D3DSIMPLERENDERSTATEENCODE[State], Value);

        D3D__RenderState[State] = Value;
    }
    else if (State < D3DRS_DEFERRED_MAX)
    {
        D3D__DirtyFlags |= D3DDIRTYFROMRENDERSTATE[State - D3DRS_SIMPLE_MAX];
        D3D__RenderState[State] = Value;
    }
    else
    {
        g_ComplexRenderStateFunctionTable[State - D3DRS_DEFERRED_MAX](Value);
    }
}

//------------------------------------------------------------------------------
// D3DDevice_SetTextureState_TexCoordIndex

extern "C"
VOID WINAPI D3DDevice_SetTextureState_TexCoordIndex(
    DWORD Stage, 
    DWORD Value)
{
    COUNT_API(API_D3DDEVICE_SETTEXTURESTATE_TEXCOORDINDEX);

    CDevice* pDevice = g_pDevice;

    if (DBG_CHECK((Value & 0xffff) >= D3DDP_MAXTEXCOORD))
    {
        DPF_ERR("Index can't be D3DDP_MAXTEXCOORD (4) or more");
    }

    D3D__TextureState[Stage][D3DTSS_TEXCOORDINDEX] = Value;

    // Initialize assuming D3DTSS_TCI_PASSTHRU:

    DWORD needsInverseModelViewState = FALSE;
    DWORD mapToStage = Value;
    DWORD texgenMode = NV097_SET_TEXGEN_S_V_DISABLE;

    PPUSH pPush = pDevice->StartPush();

    // Now specifically handle texgens:

    DWORD texGen = Value & 0xffff0000;
    if (texGen != D3DTSS_TCI_PASSTHRU)
    {
        // Since texgen is enabled, we obviously don't need to read texture 
        // coordinates from the vertex buffer for this stage.  Rather than 
        // add special logic in the vertex buffer setup code, we simply make
        // sure we map to this stage, and work under the assumption that
        // the caller won't specify a texture coordinate for this stage in
        // their FVF.

        mapToStage = Stage;

        // Stomp the texture coordinate with (0, 0, 0, 1).  We do this to  
        // get a '1' into 'W' because we leave Q disabled.

        Push1(pPush, NV097_SET_VERTEX_DATA4UB(SLOT_TEXTURE0 + Stage), 0xff000000);

        pPush += 2;

        switch (texGen)
        {
        case D3DTSS_TCI_CAMERASPACENORMAL:
            needsInverseModelViewState = TRUE;
            texgenMode = NV097_SET_TEXGEN_S_V_NORMAL_MAP;
            break;
    
        case D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR:
            needsInverseModelViewState = TRUE;
            texgenMode = NV097_SET_TEXGEN_S_V_REFLECTION_MAP;
            break;
    
        case D3DTSS_TCI_CAMERASPACEPOSITION:
            // Note, we already initialized to identity the texgen plane 
            // (NV097_SET_TEXGEN_SPLANE0, etc.) in our initialization code.
    
            texgenMode = NV097_SET_TEXGEN_S_V_EYE_LINEAR;
            break;
    
        case D3DTSS_TCI_OBJECT:
            texgenMode = NV097_SET_TEXGEN_S_V_OBJECT_LINEAR;
            break;
    
        case D3DTSS_TCI_SPHERE:
            needsInverseModelViewState = TRUE;
            texgenMode = NV097_SET_TEXGEN_S_V_SPHERE_MAP;
            break;
    
        default:
            NODEFAULT("Unexpected texgen\n");
        }
    }

    // Handle the re-mapping of a stage:

    g_SlotMapping[SLOT_TEXTURE0 + Stage] = SLOT_TEXTURE0 + (BYTE) mapToStage;

    // Set S, T, and R all to the same mode.  We leave Q disabled:

    Push3(pPush, NV097_SET_TEXGEN_S(Stage), texgenMode, texgenMode, texgenMode);

    pDevice->EndPush(pPush + 4);

    // If we suddenly start needing the inverse modelview matrix, make sure
    // that LazySetTransform computes it on the very next call:

    if (!(pDevice->m_TexGenInverseNeeded) && (needsInverseModelViewState))
    {
        D3D__DirtyFlags |= D3DDIRTYFLAG_TRANSFORM;
    }
    
    pDevice->m_TexGenInverseNeeded &= ~(1 << Stage);
    pDevice->m_TexGenInverseNeeded |= (needsInverseModelViewState << Stage);


    D3D__DirtyFlags |= (D3DDIRTYFLAG_TEXTURE_TRANSFORM | 
                        D3DDIRTYFLAG_TEXTURE_STATE | 
                        D3DDIRTYFLAG_VERTEXFORMAT);
}

//------------------------------------------------------------------------------
// D3DDevice_SetTextureState_BumpEnv

extern "C"
VOID WINAPI D3DDevice_SetTextureState_BumpEnv(
    DWORD Stage, 
    D3DTEXTURESTAGESTATETYPE Type,
    DWORD Value)
{
    COUNT_API(API_D3DDEVICE_SETTEXTURESTATE_BUMPENV);

    CDevice* pDevice = g_pDevice;

    ASSERT((Type >= D3DTSS_BUMPENVMAT00) && (Type <= D3DTSS_BUMPENVLOFFSET));
    ASSERT((D3DTSS_BUMPENVMAT00 + 1 == D3DTSS_BUMPENVMAT01) &&
           (D3DTSS_BUMPENVMAT00 + 2 == D3DTSS_BUMPENVMAT11) &&
           (D3DTSS_BUMPENVMAT00 + 3 == D3DTSS_BUMPENVMAT10) &&
           (D3DTSS_BUMPENVMAT00 + 4 == D3DTSS_BUMPENVLSCALE) &&
           (D3DTSS_BUMPENVMAT00 + 5 == D3DTSS_BUMPENVLOFFSET));

    // D3D uses the i'th texture stage to express the bump map data, where
    // the environment is in the next stage.  NV20 uses the i+1'th stage,
    // so have to add one to the D3D stage when programming the hardware.
    //
    // But when a pixel shader is active, it maps directly.

    DWORD textureUnit = (pDevice->m_pPixelShader != NULL) ? Stage : Stage + 1;

    // Only texture units 1, 2, and 3 can be programmed:

    if (textureUnit & 3)
    {
        PPUSH pPush = pDevice->StartPush();

        // Also hit NV097_SET_TEXTURE_SET_BUMP_ENV_OFFSET and
        // NV097_SET_TEXTURE_SET_BUMP_ENV_SCALE here:
    
        Push1(pPush, 
              NV097_SET_TEXTURE_SET_BUMP_ENV_MAT00(textureUnit) 
                    + 4 * (Type - D3DTSS_BUMPENVMAT00),
              Value);
    
        pDevice->EndPush(pPush + 2);
    }

    D3D__TextureState[Stage][Type] = Value;
}

//------------------------------------------------------------------------------
// D3DDevice_SetTextureState_BorderColor

extern "C"
VOID WINAPI D3DDevice_SetTextureState_BorderColor(
    DWORD Stage, 
    DWORD Value)
{
    COUNT_API(API_D3DDEVICE_SETTEXTURESTATE_BORDERCOLOR);

    CDevice* pDevice = g_pDevice;

    PPUSH pPush = pDevice->StartPush();

    Push1(pPush, NV097_SET_TEXTURE_BORDER_COLOR(Stage), Value);

    pDevice->EndPush(pPush + 2);

    D3D__TextureState[Stage][D3DTSS_BORDERCOLOR] = Value;
}

//------------------------------------------------------------------------------
// D3DDevice_SetTextureState_ColorKeyColor

extern "C"
VOID WINAPI D3DDevice_SetTextureState_ColorKeyColor(
    DWORD Stage, 
    DWORD Value)
{
    COUNT_API(API_D3DDEVICE_SETTEXTURESTATE_COLORKEYCOLOR);

    CDevice* pDevice = g_pDevice;

    PPUSH pPush = pDevice->StartPush();

    Push1(pPush, NV097_SET_COLOR_KEY_COLOR(Stage), Value);

    pDevice->EndPush(pPush + 2);

    D3D__TextureState[Stage][D3DTSS_COLORKEYCOLOR] = Value;
}

//------------------------------------------------------------------------------
// D3DDevice_SetTextureState_ParameterCheck

extern "C"
HRESULT WINAPI D3DDevice_SetTextureState_ParameterCheck(
    DWORD Stage,
    D3DTEXTURESTAGESTATETYPE Type,
    DWORD Value) 
{ 
    COUNT_API(API_D3DDEVICE_SETTEXTURESTATE_PARAMETERCHECK);

    CDevice *pDevice = g_pDevice;

    if (DBG_CHECK(TRUE))
    {
        if ((Stage >= D3DTSS_MAXSTAGES) || (Type >= D3DTSS_MAX))
        {
            D3D_ERR("Invalid texture stage or state index");
            return D3DERR_INVALIDCALL;
        }

        switch(Type)
        {
        case D3DTSS_COLOROP:
        case D3DTSS_ALPHAOP:
            /* D3DTEXTUREOP - per-stage blending controls for color channels */

            if (!(Value) || (Value >= D3DTOP_MAX))
            {
                D3D_ERR("Invalid value for D3DTSS_COLOROP/ALPHAOP");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DTSS_COLORARG0:
        case D3DTSS_ALPHAARG0:
        case D3DTSS_COLORARG1:
        case D3DTSS_COLORARG2:
        case D3DTSS_ALPHAARG1:
        case D3DTSS_ALPHAARG2:
        case D3DTSS_RESULTARG:
            /* D3DTA_* (texture arg) */

            if ((Value & D3DTA_SELECTMASK) >= D3DTA_SELECTMAX)
            {
                D3D_ERR("Invalid value selector for D3DTSS_COLORARGx/D3DTSS_ALPHAARGx.");
                return D3DERR_INVALIDCALL;
            }

            if ((Value & ~D3DTA_SELECTMASK) >= D3DTA_MODIFIERMAX)
            {
                D3D_ERR("Invalid modifier for D3DTSS_COLORARGx/D3DTSS_ALPHAARGx.");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DTSS_ADDRESSU:
        case D3DTSS_ADDRESSV:
        case D3DTSS_ADDRESSW:
            /* D3DTEXTUREADDRESS for U/V/W coordinate */

            if ((Value == 0) || (Value >= D3DTADDRESS_MAX))
            {
                D3D_ERR("Invalid value for D3DTSS_ADRESSx.");
                return D3DERR_INVALIDCALL;
            }
            break;  

        case D3DTSS_MAGFILTER:
        case D3DTSS_MINFILTER:
            if ((Value < D3DTEXF_POINT) || (Value > D3DTEXF_GAUSSIANCUBIC))
            {
                D3D_ERR("Invalid D3DTSS_MAGFILTER/D3DTSS_MINFILTER value.");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DTSS_MIPFILTER:
            if (Value > D3DTEXF_LINEAR)
            {
                D3D_ERR("Invalid D3DTSS_MIPFILTER value.");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DTSS_MIPMAPLODBIAS:
            /* float Mipmap LOD bias */
            break;

        case D3DTSS_MAXMIPLEVEL:
            /* DWORD 0..(n-1) LOD index of largest map to use (0 == largest) */
            break;

        case D3DTSS_MAXANISOTROPY:
            /* DWORD maximum anisotropy */
            if (Value > 4)
            {
                D3D_ERR("Maximum MAXANISOTROPY is 4");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DTSS_BUMPENVMAT00:
        case D3DTSS_BUMPENVMAT01:
        case D3DTSS_BUMPENVMAT10:
        case D3DTSS_BUMPENVMAT11:
            if ((Floatify(Value) < F_MINUS_8) || (Floatify(Value) > 8.0f))
            {
                D3D_ERR("Must be in the range [-8.0, 8.0]");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DTSS_BUMPENVLSCALE:
            /* float scale for bump map luminance */
            break;

        case D3DTSS_BUMPENVLOFFSET:
            /* float offset for bump map luminance */
            break;

        case D3DTSS_TEXTURETRANSFORMFLAGS:
            /* D3DTEXTURETRANSFORMFLAGS controls texture transform */

            if ((Value & 0xFF) >= 5)
            {
                D3D_ERR("Invalid coordinate count for D3DTSS_TEXTURETRANSFORMFLAGS.");
                return D3DERR_INVALIDCALL;
            }

            if (Value & ~0x1FF)
            {
                D3D_ERR("Invalid flags for D3DTSS_TEXTURETRANSFORMFLAGS.");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DTSS_COLORKEYOP:
            // DOC: This new texture stage state

            if (Value >= D3DTCOLORKEYOP_MAX)
            {
                D3D_ERR("Invalid D3DTSS_COLORKEYOP value.");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DTSS_COLORSIGN:
            // DOC: This new texture stage state

            if (Value & ~(DRF_DEF(097, _SET_TEXTURE_FILTER, _ASIGNED, _BIT_ENABLED)
                        | DRF_DEF(097, _SET_TEXTURE_FILTER, _RSIGNED, _BIT_ENABLED)
                        | DRF_DEF(097, _SET_TEXTURE_FILTER, _GSIGNED, _BIT_ENABLED)
                        | DRF_DEF(097, _SET_TEXTURE_FILTER, _BSIGNED, _BIT_ENABLED)))
            {
                D3D_ERR("Invalid D3DTSS_COLORSIGN value.");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DTSS_ALPHAKILL:
            // DOC: This new texture stage state

            if ((Value != D3DTALPHAKILL_ENABLE) && (Value != D3DTALPHAKILL_DISABLE))
            {
                D3D_ERR("Invalid D3DTSS_ALPHAKILL value.");
                return D3DERR_INVALIDCALL;
            }
            break;

        case D3DTSS_TEXCOORDINDEX:
            if ((Value & 0xffff) > D3DTSS_TCI_TEXCOORDINDEX_MAX)
            {
                D3D_ERR("Texture coordinate index is too big");
                return D3DERR_INVALIDCALL;
            }

            if ((Value & 0xffff0000) > D3DTSS_TCI_TEXGEN_MAX)
            {
                D3D_ERR("Invalid texgen");
                return D3DERR_INVALIDCALL;
            }
            break;
        }
    }

    return S_OK;
}

//------------------------------------------------------------------------------
// D3DDevice_SetTextureStageStateNotInline

extern "C"
void WINAPI D3DDevice_SetTextureStageStateNotInline(
    DWORD Stage,
    D3DTEXTURESTAGESTATETYPE Type,
    DWORD Value) 
{ 
    COUNT_API(API_D3DDEVICE_SETTEXTURESTAGESTATENOTINLINE);

    CDevice *pDevice = g_pDevice;

    if (DBG_CHECK(D3DDevice_SetTextureState_ParameterCheck(Stage, Type, Value) 
                  != S_OK))
        return;

    COUNT_TEXTURESTATE(Type);
    if (Value == D3D__TextureState[Stage][Type])
    {
        COUNT_PERF(PERF_REDUNDANT_SETTEXTURESTATE);
    }

    if (Type < D3DTSS_DEFERRED_TEXTURE_STATE_MAX)
    {
        D3D__DirtyFlags |= (D3DDIRTYFLAG_TEXTURE_STATE_0 << Stage);
        D3D__TextureState[Stage][Type] = Value;
    }
    else if (Type == D3DTSS_COLOROP)
    {
        // Only D3DTOP_BUMPENVMAP and D3DTOP_BUMPENVMAPLUMINANCE require the
        // sign flags and shader program to be recomputed:

        D3D__DirtyFlags |= (Value < D3DTOP_BUMPENVMAP)
                         ? (D3DDIRTYFLAG_COMBINERS)
                         : (D3DDIRTYFLAG_COMBINERS | 
                            D3DDIRTYFLAG_SHADER_STAGE_PROGRAM | 
                            D3DDIRTYFLAG_TEXTURE_STATE);

        ASSERT((Value < D3DTOP_BUMPENVMAP) || 
               (Value == D3DTOP_BUMPENVMAP) || 
               (Value == D3DTOP_BUMPENVMAPLUMINANCE));

        D3D__TextureState[Stage][Type] = Value;
    }
    else if (Type < D3DTSS_DEFERRED_MAX)
    {
        D3D__DirtyFlags |= D3DDIRTYFROMTEXTURESTATE[Type];
        D3D__TextureState[Stage][Type] = Value;
    }
    else if (Type == D3DTSS_TEXCOORDINDEX)
    {
        D3DDevice_SetTextureState_TexCoordIndex(Stage, Value);
    }
    else if (Type == D3DTSS_BORDERCOLOR)
    {
        D3DDevice_SetTextureState_BorderColor(Stage, Value);
    }
    else if (Type == D3DTSS_COLORKEYCOLOR)
    {
        D3DDevice_SetTextureState_ColorKeyColor(Stage, Value);
    }
    else if ((Type >= D3DTSS_BUMPENVMAT00) && (Type <= D3DTSS_BUMPENVLOFFSET))
    {
        D3DDevice_SetTextureState_BumpEnv(Stage, Type, Value);
    }
}

//------------------------------------------------------------------------------
// CommonSetTextureBumpEnv
//
// For the bump-env registers, what stages map to what texture units changes
// depending on whether a pixel shader is active or not.
//
// Rather than do extra work in LazySetTextureState or other places, we 
// just always reprogram all the bump-env registers when switching in or
// out of a pixel shader.

PPUSH FASTCALL CommonSetTextureBumpEnv(
    CDevice* pDevice,
    PPUSH pPush)
{
    // D3D uses the i'th texture stage to express the bump map data, where
    // the environment is in the next stage.  NV20 uses the i+1'th stage,
    // so have to add one to the D3D stage when programming the hardware.
    //
    // But when a pixel shader is active, it maps directly.

    DWORD stage = (pDevice->m_pPixelShader == NULL) ? 0 : 1;

    for (DWORD unit = 1; unit <= 3; unit++)
    {
        PushCount(pPush, NV097_SET_TEXTURE_SET_BUMP_ENV_MAT00(unit), 6);

        // Also hit NV097_SET_TEXTURE_SET_BUMP_ENV_OFFSET and
        // NV097_SET_TEXTURE_SET_BUMP_ENV_SCALE here:

        memcpy((void*) (pPush + 1),
               &D3D__TextureState[stage][D3DTSS_BUMPENVMAT00], 
               6 * sizeof(DWORD));

        pPush += 7;
        stage++;
    }

    return pPush;
}

//------------------------------------------------------------------------------
// CommonSetViewport
//
// Sets the NV097_SET_VIEWPORT_OFFSET, NV097_SET_VIEWPORT_SCALE, and 
// NV097_SET_CLIP_MIN registers as appropriate for the current state.

PPUSH FASTCALL CommonSetViewport(
    CDevice* pDevice,
    PPUSH pPush)
{
    FLOAT clipNear;
    FLOAT clipFar;

    FLOAT xViewport = pDevice->m_Viewport.X * pDevice->m_SuperSampleScaleX
                    + pDevice->m_ScreenSpaceOffsetX;
    FLOAT yViewport = pDevice->m_Viewport.Y * pDevice->m_SuperSampleScaleY
                    + pDevice->m_ScreenSpaceOffsetY;

    // Adjust for the implicit 0.5 offset that the hardware multisampling 
    // applies:

    if ((pDevice->m_StateFlags & STATE_MULTISAMPLING) &&
        (D3D__RenderState[D3DRS_MULTISAMPLEANTIALIAS]))
    {
        xViewport -= 0.5f;
        yViewport -= 0.5f;
    }
    
    if (pDevice->m_pVertexShader->Flags & (VERTEXSHADER_PASSTHROUGH |
                                           VERTEXSHADER_PROGRAM))
    {
        // Programmable vertex shader case.  Set the magic '-38' and 
        // '-37' constant registers:

        if (!(pDevice->m_StateFlags & STATE_NORESERVEDCONSTANTS))
        {
            FLOAT fm11 = 0.5f * pDevice->m_Viewport.Width 
                              * pDevice->m_SuperSampleScaleX;
            FLOAT fm41 = fm11;
        
            FLOAT fm22 = -0.5f * pDevice->m_Viewport.Height 
                               * pDevice->m_SuperSampleScaleY;
            FLOAT fm42 = -fm22;
        
            FLOAT fm33 = pDevice->m_ZScale * (pDevice->m_Viewport.MaxZ - 
                                              pDevice->m_Viewport.MinZ);
            FLOAT fm43 = pDevice->m_ZScale * (pDevice->m_Viewport.MinZ);
        
            Push4f(pPush, 
                   NV097_SET_VIEWPORT_OFFSET(0), 
                   fm41 + xViewport, 
                   fm42 + yViewport, 
                   fm43, 
                   0.0f);
        
            Push4f(pPush + 5,
                   NV097_SET_VIEWPORT_SCALE(0), 
                   fm11, 
                   fm22, 
                   fm33, 
                   0.0f);

            pPush += 10;
        }

        clipNear = 0.0f;
        clipFar = pDevice->m_ZScale;
    }
    else
    {
        // Fixed-function-pipeline case:

        Push4f(pPush, 
               NV097_SET_VIEWPORT_OFFSET(0), 
               xViewport,
               yViewport,
               0.0f,
               0.0f);
        
        pPush += 5;

        if (D3D__RenderState[D3DRS_ZENABLE] == D3DZB_USEW)
        {
            clipNear = pDevice->m_ZScale * pDevice->m_WNear * pDevice->m_InverseWFar;
            clipFar = pDevice->m_ZScale;
        }
        else
        {
            clipNear = pDevice->m_ZScale * pDevice->m_Viewport.MinZ;
            clipFar = pDevice->m_ZScale * pDevice->m_Viewport.MaxZ;
        }
    }

    Push2f(pPush, NV097_SET_CLIP_MIN, clipNear, clipFar);

    return pPush + 3;
}

//------------------------------------------------------------------------------
// CommonSetControl0
//
// Sets the NV097_SETCONTROL0 register.
//
// Dependencies:
//
//      D3DRS_ZENABLE
//      D3DRS_YUVENABLE

PPUSH FASTCALL CommonSetControl0(
    CDevice* pDevice,
    PPUSH pPush)
{
    DWORD control0 = DRF_DEF(097, _SET_CONTROL0, _TEXTUREPERSPECTIVE, _TRUE)
                   | DRF_DEF(097, _SET_CONTROL0, _STENCIL_WRITE_ENABLE, _TRUE);

    if (D3D__RenderState[D3DRS_YUVENABLE])
    {
        control0 |= DRF_DEF(097, _SET_CONTROL0, _COLOR_SPACE_CONVERT, _CRYCB_TO_RGB);
    }

    if (D3D__RenderState[D3DRS_ZENABLE] == D3DZB_USEW)
    {
        control0 |= DRF_DEF(097, _SET_CONTROL0, _Z_PERSPECTIVE_ENABLE, _TRUE);
    }

    if (pDevice->m_pZBuffer)
    {
        D3DFORMAT Format = PixelJar::GetFormat(pDevice->m_pZBuffer);

        if (Format == D3DFMT_F16
            || Format == D3DFMT_F24S8
            || Format == D3DFMT_LIN_F16
            || Format == D3DFMT_LIN_F24S8)
        {
            control0 |= DRF_DEF(097, _SET_CONTROL0, _Z_FORMAT, _FLOAT);
        }
    }

    Push1(pPush, NV097_SET_CONTROL0, control0);

    return pPush + 2;
}

//------------------------------------------------------------------------------
// CommonSetAntiAliasingControl

VOID FASTCALL CommonSetAntiAliasingControl(
    CDevice* pDevice)
{
    // The passthrough program and viewport are dependent upon the
    // D3DRS_MULTISAMPLEANTIALIASING state...

    CommonSetPassthroughProgram(pDevice);

    PPUSH pPush = pDevice->StartPush();

    pPush = CommonSetViewport(pDevice, pPush);

    Push1(pPush, 
          NV097_SET_ANTI_ALIASING_CONTROL, 
          DRF_NUM(097, _SET_ANTI_ALIASING_CONTROL, _ENABLE, 
                  D3D__RenderState[D3DRS_MULTISAMPLEANTIALIAS])
        | DRF_NUM(097, _SET_ANTI_ALIASING_CONTROL, _SAMPLE_MASK, 
                  D3D__RenderState[D3DRS_MULTISAMPLEMASK]));

    pDevice->EndPush(pPush + 2);
}

//------------------------------------------------------------------------------
// CommonSetOccludeZStencilEn                                                           
//                                                                             
// Sets the NV097_SET_OCCLUDE_ZSTENCIL_EN register.                                        
//                                                                             
// Dependencies:                                                               
//                                                                             
//      D3DRS_STENCILFAIL
//      D3DRS_STENCILENABLE
//      D3DRS_OCCLUSIONCULLENABLE
//      D3DRS_STENCILCULLENABLE

PPUSH FASTCALL CommonSetOccludeZStencilEn(
    CDevice* pDevice,
    PPUSH pPush)
{
    DWORD occlude = 0;

    if (D3D__RenderState[D3DRS_STENCILCULLENABLE])
    {
        occlude |= DRF_DEF(097, _SET_OCCLUDE_ZSTENCIL_EN, 
                           _OCCLUDE_STENCIL_EN, _ENABLE);
    }

    if (D3D__RenderState[D3DRS_OCCLUSIONCULLENABLE])
    {
        // Both the NV20 and the NV2A have bugs with Z culling when stencil is
        // on and stencil fails but the mode is not KEEP - they will incorrectly
        // cull out the pixels.
    
        if ((!D3D__RenderState[D3DRS_STENCILENABLE]) || 
            (D3D__RenderState[D3DRS_STENCILFAIL] == D3DSTENCILOP_KEEP))
        {
            occlude |= DRF_DEF(097, _SET_OCCLUDE_ZSTENCIL_EN, _OCCLUDE_ZEN, 
                               _ENABLE);
        }
    }

    Push1(pPush, NV097_SET_OCCLUDE_ZSTENCIL_EN, occlude);

    return pPush + 2;
}

//------------------------------------------------------------------------------
// CommonSetDebugRegisters

VOID FASTCALL CommonSetDebugRegisters()
{
    CDevice* pDevice = g_pDevice;

    // Debug register 5:

    pDevice->m_Miniport.m_DebugRegister[5] 
        &= ~(DRF_NUM(_PGRAPH, _DEBUG_5, _ZCULL_RETURN_COMP, ~0));

    if (D3D__RenderState[D3DRS_DONOTCULLUNCOMPRESSED])
    {
        pDevice->m_Miniport.m_DebugRegister[5]
            |= DRF_DEF(_PGRAPH, _DEBUG_5, _ZCULL_RETURN_COMP, _ENABLED);
    }

    // Debug register 6:

    pDevice->m_Miniport.m_DebugRegister[6] 
        &= ~(DRF_NUM(_PGRAPH, _DEBUG_6, _ROP_ZCMP_ALWAYS_READ, ~0)
           | DRF_NUM(_PGRAPH, _DEBUG_6, _ROP_ZREAD, ~0));

    if (D3D__RenderState[D3DRS_ROPZCMPALWAYSREAD])
    {
        pDevice->m_Miniport.m_DebugRegister[6] 
            |= DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_ZCMP_ALWAYS_READ, _ENABLED);
    }
    if (D3D__RenderState[D3DRS_ROPZREAD])
    {
        pDevice->m_Miniport.m_DebugRegister[6] 
            |= DRF_DEF(_PGRAPH, _DEBUG_6, _ROP_ZREAD, _FORCE_ZREAD);
    }

    // Set the state, synchronized to the push-buffer:

    PPUSH pPush = pDevice->StartPush();

    Push1(pPush, NV097_WAIT_FOR_IDLE, 0);

    Push2(pPush + 2, NV097_SET_ZSTENCIL_CLEAR_VALUE, 
          NV_PGRAPH_DEBUG_5,
          pDevice->m_Miniport.m_DebugRegister[5]);

    Push1(pPush + 5, NV097_NO_OPERATION,
        NVX_WRITE_REGISTER_VALUE);

    Push2(pPush + 7, NV097_SET_ZSTENCIL_CLEAR_VALUE, 
          NV_PGRAPH_DEBUG_6,
          pDevice->m_Miniport.m_DebugRegister[6]);

    Push1(pPush + 10, NV097_NO_OPERATION,
        NVX_WRITE_REGISTER_VALUE);

    pDevice->EndPush(pPush + 12);
}

//------------------------------------------------------------------------------
// UpdateProjectionViewportTransform
//
// Depedencies:
//
//      D3DRS_ZENABLE
//      m_Viewport
//      D3DTS_PROJECTION
//      antialising

VOID UpdateProjectionViewportTransform()
{
    D3DALIGN D3DMATRIX viewportTransform;
    float fm11, fm22, fm33, fm41, fm42, fm43, fm44;

    CDevice* pDevice = g_pDevice;

    // This is based on clipX = -1.0, clipY = 1.0

    fm11 = 0.5f * pDevice->m_SuperSampleScaleX * pDevice->m_Viewport.Width;
    fm41 = fm11;

    fm22 = -0.5f * pDevice->m_SuperSampleScaleY * pDevice->m_Viewport.Height;
    fm42 = -fm22;

    fm33 = pDevice->m_ZScale * (pDevice->m_Viewport.MaxZ - 
                                pDevice->m_Viewport.MinZ);
    fm43 = pDevice->m_ZScale * pDevice->m_Viewport.MinZ;

    if (D3D__RenderState[D3DRS_ZENABLE] == D3DZB_USEW)
    {
        // We are doing w-buffering - scale w to optimize use of buffer:

        fm44 = pDevice->m_ZScale * pDevice->m_InverseWFar;

        // Scale x, y, and z similarly to negate the effect of dividing
        // through by a scaled w:

        fm11 *= fm44;  fm22 *= fm44;  fm33 *= fm44;
        fm41 *= fm44;  fm42 *= fm44;  fm43 *= fm44;
    }
    else
    {
        fm44 = 1.0f;
    }

    ZeroMemory(&viewportTransform, sizeof(viewportTransform));

    viewportTransform._11 = fm11;
    viewportTransform._22 = fm22;
    viewportTransform._33 = fm33;
    viewportTransform._41 = fm41;
    viewportTransform._42 = fm42;
    viewportTransform._43 = fm43;
    viewportTransform._44 = fm44;

    // Update our cached transform:

    MatrixProduct4x4(&pDevice->m_ProjectionViewportTransform,
                     &pDevice->m_Transform[D3DTS_PROJECTION],
                     &viewportTransform);

    // The transform stuff is naturally dependent upon our cached transform:

    D3D__DirtyFlags |= D3DDIRTYFLAG_TRANSFORM;
}

} // end of namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\stats.cpp ===
/*==========================================================================
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       stats.cpp
 *  Content:    implementation for debug-only statistics gathering
 *
 ***************************************************************************/

#include "precomp.hpp"
#include "dm.h"
#include <xbdm.h>

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

#if PROFILE

D3DPERF g_PerfCounters =
{
    // m_TSCLastResetVal
    0,

    // m_TSCLastPresentVal
    0,

    // m_FrameTimeMin
    { 0, (ULONGLONG)-1 },

    // m_FrameTimeMax
    { 0, 0 },

    // m_BreakCount
    0,

    // m_Breakperfctr
    PERF_OBJECTLOCK_WAITS,

    // m_pPutLocationAtReset
    NULL,

    // m_PushBufferEndDwordsSkipped
    0,

    // m_FrameRateIntervalTime
    0,

    // m_dwDumpFPSInfoMask
    D3DPERF_DUMP_FPS_INTINFO |
        D3DPERF_DUMP_FPS_MEMORY |
        D3DPERF_DUMP_FPS_PUSHBUFFER |
        D3DPERF_DUMP_FPS_WAITINFO |
        D3DPERF_DUMP_FPS_VERTEXINFO,

    // m_pfnDumpFrameRateInfoHandler
    D3DPERF_DumpFrameRateInfo,

    // m_DumpWaitCycleTimesThreshold
    (DWORD)-1,

    // m_pfnCycleThresholdHandler
    D3DPERF_DumpCounterCycleInfo,
};

KPRCB g_rcbAtReset;

DWORD g_CpuCyclesPerMsec = 1;  // init non-zero to avoid divide by zero, in case we can't get CPU speed

// Perf routine gpu last busy counts
DWORD g_PerfLastProfileSamples;
DWORD g_PerfLastGpuBusyCounts[D3DPERF_PROF_MAX];

// Boolean to make sure we only stop profile runs we started
static BOOL g_PerProfileStarted = FALSE;

// When true this will toggle the current vertex file/cache
// renderstate at the next D3DPERF_Reset() call. This allows
// someone to set those guys via the debugger.
extern "C" BOOL g_ToggleVTXStatesOnReset = FALSE;

// Profiler interrupt handler typedef.
typedef void (WINAPI * PROFINTHANDLER)(PKTRAP_FRAME ptf);

// Profile interrupt data.
struct D3DPERF_PROFDATA
{
    BOOL Sampling;          // currently sampling?
} g_PerfProfData;

//  Helper class for decimals since DbgPrint doesn't support %f.
class PERFFIXEDPOINT
{
public:
    PERFFIXEDPOINT(ULONGLONG Number, DWORD Base)
    {
        IntPart = (DWORD)(Number / Base);
        DecPart = (DWORD)(Number - (IntPart * Base));
    }

    DWORD IntPart;
    DWORD DecPart;
};

//------------------------------------------------------------------------------
// D3DPERF_GetPushBufferBytesWritten
//
// Calculates number of bytes written to the pushbuffer since last reset.

extern "C"
ULONGLONG WINAPI D3DPERF_GetPushBufferBytesWritten()
{
    DWORD NumJumps = g_PerfCounters.m_PerformanceCounters[PERF_PUSHBUFFER_JUMPTOBEGINNING].Count;

    ASSERT(!(g_pDevice->m_StateFlags & STATE_RECORDPUSHBUFFER));

    if(NumJumps)
    {
        return ((BYTE *)g_pPushBuffer->m_pPut - (BYTE *)g_pDevice->m_pPushBase) +
            ((BYTE *)g_pDevice->m_pPushLimit - (BYTE *)g_PerfCounters.m_pPutLocationAtReset) +
            (ULONGLONG)(g_pDevice->m_PushBufferSize * (NumJumps - 1)) -
            g_PerfCounters.m_PushBufferEndDwordsSkipped * sizeof(DWORD);
    }
    else
    {
        ASSERT(!g_PerfCounters.m_PushBufferEndDwordsSkipped);

        return (BYTE *)g_pPushBuffer->m_pPut - (BYTE *)g_PerfCounters.m_pPutLocationAtReset;
    }
}

//------------------------------------------------------------------------------
// D3DPERF_GetPushBufferInfo
//
// Returns push buffer information.

extern "C"
void WINAPI D3DPERF_GetPushBufferInfo(
    D3DPUSHBUFFERINFO *pPushBufferInfo)
{
    pPushBufferInfo->PushBufferSize = g_pDevice->m_PushBufferSize;
    pPushBufferInfo->PushSegmentSize = g_pDevice->m_PushSegmentSize;
    pPushBufferInfo->PushSegmentCount = g_pDevice->m_PusherSegmentMask + 1;

    pPushBufferInfo->pPushBase = (DWORD*) g_pDevice->m_pPushBase;
    pPushBufferInfo->pPushLimit = (DWORD*) g_pDevice->m_pPushLimit;

    pPushBufferInfo->PushBufferBytesWritten = D3DPERF_GetPushBufferBytesWritten();
}

//------------------------------------------------------------------------------
// D3DPERF_GetStatistics
//
// Returns the performance structure which is statically allocated and should
// never be freed.

extern "C"
D3DPERF * WINAPI D3DPERF_GetStatistics()
{
    return &g_PerfCounters;
}

//------------------------------------------------------------------------------
// D3DPERF_GetNames
//
// Returns an array of names which is statically allocated.

extern "C"
D3DPERFNAMES * WINAPI D3DPERF_GetNames()
{
    return (D3DPERFNAMES *)&g_PerfNames;
}

//------------------------------------------------------------------------------
// D3DPERF_Reset
//
// Reset all the counters

extern "C"
void WINAPI D3DPERF_Reset()
{
    ASSERT(!(g_pDevice->m_StateFlags & STATE_RECORDPUSHBUFFER));

    memset(&g_PerfCounters.m_PerformanceCounters, 0, sizeof(g_PerfCounters.m_PerformanceCounters));
    memset(&g_PerfCounters.m_APICounters, 0, sizeof(g_PerfCounters.m_APICounters));
    memset(&g_PerfCounters.m_RenderStateCounters, 0, sizeof(g_PerfCounters.m_RenderStateCounters));
    memset(&g_PerfCounters.m_TextureStateCounters, 0, sizeof(g_PerfCounters.m_TextureStateCounters));

    g_PerfCounters.m_pPutLocationAtReset = (DWORD*) g_pPushBuffer->m_pPut;
    g_PerfCounters.m_PushBufferEndDwordsSkipped = 0;

    g_rcbAtReset = *KeGetCurrentPrcb();

    g_PerfCounters.m_FrameTimeMin.Count = 0;
    g_PerfCounters.m_FrameTimeMin.Cycles = (ULONGLONG)-1;

    g_PerfCounters.m_FrameTimeMax.Count = 0;
    g_PerfCounters.m_FrameTimeMax.Cycles = 0;

    g_PerfCounters.m_TSCLastPresentVal = 0;

    // Prime any of the renderstate overrides if told to.
    if(g_PerfCounters.m_SetRenderStateOverridesOnReset)
    {
        for(int State = 0; State < D3DRS_MAX; State++)
        {
            if(g_PerfCounters.m_RenderStateOverrides[State].Override)
            {
                D3DDevice_SetRenderState((D3DRENDERSTATETYPE)State,
                    g_PerfCounters.m_RenderStateOverrides[State].Value);
            }
        }

        g_PerfCounters.m_SetRenderStateOverridesOnReset = FALSE;
    }

    // If the toggle vtx states bool is set then flip the vtx cache states.
    if(g_ToggleVTXStatesOnReset)
    {
        D3DPERF_SetState(D3DPERFSTATE_VTX_ALL, 0x80000000);

        g_ToggleVTXStatesOnReset = FALSE;
    }

#ifndef STARTUPANIMATION
    if(g_PerfCounters.m_dwDumpFPSInfoMask & D3DPERF_DUMP_FPS_PERFPROFILE)
    {
        // make sure we're profiling
        D3DPERF_StartPerfProfile();

        g_PerProfileStarted = TRUE;
    }
    else if(g_PerProfileStarted)
    {
        // turn off perf profiling
        D3DPERF_StopPerfProfile();

        g_PerProfileStarted = FALSE;
    }
#endif // STARTUPANIMATION

    if(g_PerfCounters.pD3DPerfEvents)
    {
        // Disable interrupts so VBlanks don't jump in here and mess us up.
        _asm pushfd
        _asm cli

        memset(g_PerfCounters.pD3DPerfEvents, 0,
            sizeof(D3DPERFEvent) * g_PerfCounters.CountD3DPerfEvents);
        g_PerfCounters.CurrentD3DPerfEvent = 0;

        _asm popfd
    }

    // record the last reset time
    g_PerfCounters.m_TSCLastResetVal = ___D3DCYCLETIMER_GetTime();
}

//------------------------------------------------------------------------------
// D3DPERF_DumpCounterCycleInfo
//
// Default handler for WaitCycleTimeThreshold spew

extern "C"
void WINAPI D3DPERF_DumpCounterCycleInfo(
    D3DPERF_PerformanceCounters perfctr,
    ULONGLONG Cycles)
{
    if(perfctr == PERF_OBJECTLOCK_WAITS)
    {
        DbgPrint("#%Lu) %s %I64u cycles (%Lums)\n",
             g_PerfCounters.m_PerformanceCounters[perfctr].Count,
             g_PerfNames.m_PerformanceCounterNames[perfctr],
             Cycles,
             MilliSecsFromCycles(Cycles));
    }
}

//------------------------------------------------------------------------------
// D3DPERF_DumpFrameRateInfo
//
// Dumps current frame rate information.

extern "C"
void WINAPI D3DPERF_DumpFrameRateInfo()
{
    DWORD i;

    // Pause the perf profile interrupt handler so if you break into the debugger
    // after this point it doesn't keep going and tromp all over the captured
    // m_ProfileData.
    DmTell(DMTELL_GPUPERF, NULL);

    BOOL RecordD3DPerfEventsBak = g_PerfCounters.RecordD3DPerfEvents;
    g_PerfCounters.RecordD3DPerfEvents = FALSE;

    // Block here until idle as the high prio DbgPrints mess up the
    // gpu timing callbacks from here on out.
    if(g_PerfCounters.m_dwDumpFPSInfoMask & D3DPERF_DUMP_FPS_PERFEVENTS)
        D3DDevice_BlockUntilIdle();

    ULONGLONG CurTime = ___D3DCYCLETIMER_GetTime();
    DWORD TotalTime = MilliSecsFromCycles(CurTime - g_PerfCounters.m_TSCLastResetVal);

    // Spit out frames per second info.

    DWORD frames = g_PerfCounters.m_APICounters[API_D3DDEVICE_PRESENT];
    PERFFIXEDPOINT fps(frames * (LONGLONG)1000000 / TotalTime, 1000);
    PERFFIXEDPOINT msecPerFrame(TotalTime * (LONGLONG)1000 / frames, 1000);

    DbgPrint("fps: %Lu.%Lu (%Lu.%Lu ms/frame)  frames: %Lu  time: %Lums\n",
        fps.IntPart, fps.DecPart,
        msecPerFrame.IntPart, msecPerFrame.DecPart,
        frames,
        TotalTime);

    DbgPrint("Min/max frame times:  frame #%Lu=%Lums  frame #%Lu=%Lums\n",
        g_PerfCounters.m_FrameTimeMin.Count,
        MilliSecsFromCycles(g_PerfCounters.m_FrameTimeMin.Cycles),
        g_PerfCounters.m_FrameTimeMax.Count,
        MilliSecsFromCycles(g_PerfCounters.m_FrameTimeMax.Cycles));

    if(g_PerfCounters.m_dwDumpFPSInfoMask & D3DPERF_DUMP_FPS_WAITINFO)
    {
        // Spit out WAIT info.
        static const D3DPERF_PerformanceCounters EventList[] =
        {
            PERF_PUSHBUFFER_WAITS,
            PERF_OBJECTLOCK_WAITS,
            PERF_D3DDEVICE_BLOCKUNTILIDLE_WAITS,
            PERF_D3DDEVICE_BLOCKONFENCE_WAITS,
            PERF_D3DDEVICE_BLOCKUNTILVERTICALBLANK_WAITS,
            PERF_PRESENT_WAITS,
            PERF_CPUSPINDURINGWAIT_TIME,
        };

        for(i = 0; i < sizeof(EventList) / sizeof(EventList[0]); i++)
        {
            // Check if we wasted any cycles on this counter
            DWORD id = EventList[i];

            if (g_PerfCounters.m_PerformanceCounters[id].Count)
            {
                ULONGLONG CyclesX10 =
                    MilliSecsFromCycles(g_PerfCounters.m_PerformanceCounters[id].Cycles * 10);
                PERFFIXEDPOINT WaitTime(CyclesX10, 10);
                PERFFIXEDPOINT WaitTimePerWait(
                    CyclesX10 / g_PerfCounters.m_PerformanceCounters[id].Count, 10);
                PERFFIXEDPOINT WaitTimePerFrame(CyclesX10 / frames, 10);

                DbgPrint("%s (%Lu): %Lu.%Lums (%Lu.%Lums/wait %Lu.%Lums/frame)\n",
                         g_PerfNames.m_PerformanceCounterNames[id],
                         g_PerfCounters.m_PerformanceCounters[id].Count,
                         WaitTime.IntPart, WaitTime.DecPart,
                         WaitTimePerWait.IntPart, WaitTimePerWait.DecPart,
                         WaitTimePerFrame.IntPart, WaitTimePerFrame.DecPart
                        );
            }
        }
    }

    if(g_PerfCounters.m_dwDumpFPSInfoMask & D3DPERF_DUMP_FPS_VERTEXINFO)
    {
        // Spit out vertex info.
        DWORD  Vertices = g_PerfCounters.m_PerformanceCounters[PERF_VERTICES].Count;
        DWORD  VerticesPerFrame = Vertices / frames;
        DbgPrint("Vertices processed: %Lu verts (%Lu verts/frame)\n", Vertices, VerticesPerFrame);
        if( 0 != g_PerfCounters.m_PerformanceCounters[PERF_RUNPUSHBUFFER_BYTES].Count )
        {
            DbgPrint(" --> Doesn't include vertices processed via RunPushBuffer!\n");
        }
    }

    if(g_PerfCounters.m_dwDumpFPSInfoMask & D3DPERF_DUMP_FPS_PUSHBUFFER)
    {
        // Spit out pushbuffer info.
        ULONGLONG PBBytes = D3DPERF_GetPushBufferBytesWritten();
        ULONGLONG PBBytesPerFrame = PBBytes / frames;
        DbgPrint("PushBuffer writes: %I64u bytes (%I64u bytes/frame)\n",
                 PBBytes,
                 PBBytesPerFrame
                );
        DWORD RunPushBufferBytes = g_PerfCounters.m_PerformanceCounters[PERF_RUNPUSHBUFFER_BYTES].Count;
        if( RunPushBufferBytes != 0 )
        {
            DWORD RunPushBufferBytesPerFrame = RunPushBufferBytes / frames;
            DbgPrint("RunPushBuffer bytes traversed: %Lu bytes (%Lu bytes/frame)\n",
                     RunPushBufferBytes,
                     RunPushBufferBytesPerFrame
                    );
        }
    }

    if(g_PerfCounters.m_dwDumpFPSInfoMask & D3DPERF_DUMP_FPS_MEMORY)
    {
        // Print out the total number of available pages

        MM_STATISTICS mmStatistics = { sizeof(MM_STATISTICS) };

        MmQueryStatistics(&mmStatistics);

        DbgPrint("Available RAM: %Lu kbytes\n", mmStatistics.AvailablePages * 4);
    }

    if(g_PerfCounters.m_dwDumpFPSInfoMask & D3DPERF_DUMP_FPS_INTINFO)
    {
        // Calculate number of interrupts and context switches

        PKPRCB Prcb = KeGetCurrentPrcb();

        DbgPrint(
            "Interrupts: %Lu\n"
            "Context Switches: %Lu\n",
            Prcb->InterruptCount - g_rcbAtReset.InterruptCount,
            Prcb->KeContextSwitches - g_rcbAtReset.KeContextSwitches);
    }

    if(g_PerfCounters.m_dwDumpFPSInfoMask & D3DPERF_DUMP_FPS_PERFPROFILE)
    {
        // dump perf profile counts
        D3DPERF_DumpPerfProfCounts();
    }

    if(g_PerfCounters.m_dwDumpFPSInfoMask & D3DPERF_DUMP_FPS_PERFEVENTS)
    {
        // If a user set D3DPERF_DUMP_FPS_PERFEVENTS but didn't initialize
        // the storage structure then alloc it for them.
        if(!g_PerfCounters.pD3DPerfEvents)
        {
#ifndef STARTUPANIMATION
            D3DPERF_StartCountingPerfEvent(5000);

            if(!RecordD3DPerfEventsBak)
                RecordD3DPerfEventsBak = g_PerfCounters.RecordD3DPerfEvents;
#endif
        }
        else
        {
            D3DPERF_DumpPerfEvents();
        }
    }

    DbgPrint("\n");

    g_PerfCounters.RecordD3DPerfEvents = RecordD3DPerfEventsBak;

    DmTell(DMTELL_GPUPERF, &g_PerfCounters);
}

//------------------------------------------------------------------------------
// PerfEventCallbackStart
//
// Perf Event callback to record gpu start time.

void __cdecl PerfEventCallbackStart(
    DWORD Context)
{
    D3DPERFEvent *pD3DPerfEvent = (D3DPERFEvent *)Context;
    ULONGLONG Time = ___D3DCYCLETIMER_GetTime() - pD3DPerfEvent->CycleCpuStart;

    // Store the delta from when the cpu launched this guy.
    pD3DPerfEvent->CycleGpuStartDelta = (DWORD)Time;
}

//------------------------------------------------------------------------------
// PerfEventCallbackTime
//
// Perf Event callback to record gpu time.

void __cdecl PerfEventCallbackTime(
    DWORD Context)
{
    D3DPERFEvent *pD3DPerfEvent = (D3DPERFEvent *)Context;
    ULONGLONG Time = ___D3DCYCLETIMER_GetTime() - pD3DPerfEvent->CycleCpuStart;

    // Store the actual time the cpu thinks this thing took from
    // PerfEventCallbackStart to PerfEventCallbackTime.
    pD3DPerfEvent->CycleGpuLength = (DWORD)(Time - pD3DPerfEvent->CycleGpuStartDelta);
}

//------------------------------------------------------------------------------
// D3DPERF_PerfEventEnd
//
// End a performance event and write record info.

extern "C"
void WINAPI D3DPERF_PerfEventEnd(
    D3DPERFEvent *pD3DPerfEvent,
    BOOL RecordGpuTime)
{
    if(!pD3DPerfEvent)
        return;

    // Store the cpu length of this event.
    pD3DPerfEvent->CycleCpuLength =
        (DWORD)(___D3DCYCLETIMER_GetTime() - pD3DPerfEvent->CycleCpuStart);

    if(RecordGpuTime)
    {
        // Record end of gpu event.

        D3DDevice_InsertCallback(D3DCALLBACK_WRITE,
            PerfEventCallbackTime,
            (DWORD)pD3DPerfEvent);
    }

    // If data field hasn't been recorded, store the pushbuffer size used
    if(!pD3DPerfEvent->Data)
    {
        CDevice* pDevice = g_pDevice;

        // Get the current Cpu Put Ptr
        DWORD CpuPutPtr = (DWORD)(pDevice->m_StateFlags & STATE_RECORDPUSHBUFFER ?
            pDevice->m_pPushBufferRecordSavedPut : pDevice->m_Pusher.m_pPut);

        // Handle wrappage
        if(CpuPutPtr < pD3DPerfEvent->CpuPutPtr)
            CpuPutPtr += pDevice->m_PushBufferSize;

        pD3DPerfEvent->Data = CpuPutPtr - pD3DPerfEvent->CpuPutPtr;
    }
}

//------------------------------------------------------------------------------
// D3DPERF_PerfEventStart
//
// Start a performance event and return the record.

extern "C"
D3DPERFEvent * WINAPI D3DPERF_PerfEventStart(
    WORD Type,
    BOOL RecordGpuTime)
{
    if(!g_PerfCounters.CountD3DPerfEvents)
        return NULL;

    if((1 << Type) &&
        !(g_PerfCounters.RecordD3DPerfEvents & (1 << Type)))
    {
        return NULL;
    }

    // Grab an event. This also gets called from Dpc so be careful.
    DWORD CurrentEvent =
        (InterlockedIncrement((PLONG)&g_PerfCounters.CurrentD3DPerfEvent) - 1) %
        g_PerfCounters.CountD3DPerfEvents;

    D3DPERFEvent *pD3DPerfEvent = &g_PerfCounters.pD3DPerfEvents[CurrentEvent];

    // Calculate gpu busy percentage since last call.

    DWORD NumSamples = g_PerfCounters.m_ProfileSamples - g_PerfLastProfileSamples;
    if(NumSamples > 15)
    {
        // If the number of samples since last time is large enough, calc the %.

        DWORD GpuPct[D3DPERF_PROF_MAX];

        for(int iProf = D3DPERF_PROF_FE; iProf <= D3DPERF_PROF_BE; iProf++)
        {
            GpuPct[iProf] = (g_PerfCounters.m_ProfileBusyCounts[iProf] -
                g_PerfLastGpuBusyCounts[iProf]) * 99 / NumSamples;

            g_PerfLastGpuBusyCounts[iProf] = g_PerfCounters.m_ProfileBusyCounts[iProf];
        }

        g_PerfLastProfileSamples = g_PerfCounters.m_ProfileSamples;

        pD3DPerfEvent->GpuPct = (WORD)(GpuPct[D3DPERF_PROF_FE] | (GpuPct[D3DPERF_PROF_BE] << 8));
    }
    else
    {
        // Don't record anything for pct as we don't have enough samples.

        pD3DPerfEvent->GpuPct = 0xffff;
    }

    if(RecordGpuTime)
    {
        // Insert callback if we're timing how long the gpu is taking.

        D3DDevice_InsertCallback(D3DCALLBACK_WRITE,
            PerfEventCallbackStart,
            (DWORD)pD3DPerfEvent);
    }

    CDevice* pDevice = g_pDevice;

    pD3DPerfEvent->CpuPutPtr = (DWORD)(pDevice->m_StateFlags & STATE_RECORDPUSHBUFFER ?
        pDevice->m_pPushBufferRecordSavedPut : pDevice->m_Pusher.m_pPut);

    pD3DPerfEvent->Type = Type;
    pD3DPerfEvent->Data = 0;

    pD3DPerfEvent->CycleGpuStartDelta = 0;
    pD3DPerfEvent->CycleGpuLength = 0;

    pD3DPerfEvent->CycleCpuLength = 0;
    pD3DPerfEvent->CycleCpuStart = ___D3DCYCLETIMER_GetTime();

    return pD3DPerfEvent;
}

//------------------------------------------------------------------------------
// SpewPerfEvent
//
// Print out one pD3DPerfEvent.

void SpewPerfEvent(
    D3DPERFEvent *pD3DPerfEvent,
    ULONGLONG *pFirstCpuStart,
    ULONGLONG *pLastCpuTime)
{
    static const char *EventsNames[] =
    {
        "Header",               // 0
        "DrawVerticesUP",       // 1
        "DrawIndexedVertsUP",   // 2
        "DrawVertices",         // 3
        "DrawIndexedVerts",     // 4
        "BeginEnd",             // 5
        "RunPushBuffer",        // 6
        "VBlank",               // 7
        "Kickoff",              // 8
        "Present",              // 9
        "BlockUntilIdle",       // 10
        "BlockOnFence",         // 11
        "PushBufferWait",       // 12
        "ObjectLockWait",       // 13
        "event14",              // 14
        "event15",              // 15
        "event16",              // 16
        "event17",              // 17
        "event18",              // 18
        "event19",              // 19
        "event20",              // 20
        "User0",                // 21
        "User1",                // 22
        "User2",                // 23
        "User3",                // 24
        "User4",                // 25
        "User5",                // 26
        "User6",                // 27
        "User7",                // 28
        "User8",                // 29
        "User9",                // 30
        "User10",               // 31
    };

    if(pD3DPerfEvent->Type == D3DPERFEvent_Header)
    {
        DbgPrint("    *** %s ***\n", pD3DPerfEvent->HeaderText);
    }
    else if(pD3DPerfEvent->Type == D3DPERFEvent_Present ||
        /* pD3DPerfEvent->GpuPct != 0xffff || */
        pD3DPerfEvent->CycleCpuLength >= g_PerfCounters.m_DumpPerfCycleTimesThresholdCpu ||
        pD3DPerfEvent->CycleGpuLength >= g_PerfCounters.m_DumpPerfCycleTimesThresholdGpu)
    {
        char szBuf[11];
        const char *szEvent;
        ULONGLONG GpuStart = 0;
        DWORD Type = pD3DPerfEvent->Type;
        static const char HexDigits[] = "0123456789abcdef";

        if(pD3DPerfEvent->Type < ARRAYSIZE(EventsNames))
        {
            szEvent = EventsNames[pD3DPerfEvent->Type];
        }
        else
        {
            // For events larger than our array stick in the number.

            szBuf[0] = '0';
            szBuf[1] = 'x';

            for(int i = 2; i < 6; i++, Type <<= 4)
            {
                szBuf[i] = HexDigits[(Type >> 12) & 0xf];
            }

            szBuf[i] = 0;
            szEvent = szBuf;
        }

        // If this is our first record grab the CpuStart time
        if(!*pFirstCpuStart)
            *pFirstCpuStart = pD3DPerfEvent->CycleCpuStart;

        // If we've got a Gpu time, figure out when it started
        if(pD3DPerfEvent->CycleGpuStartDelta)
        {
            GpuStart = pD3DPerfEvent->CycleCpuStart +
                pD3DPerfEvent->CycleGpuStartDelta - *pFirstCpuStart;
        }

        // If we've got an event which happened within some other events cpu
        // time then bump it over by one char

        char Spacer[2];
        ULONGLONG CpuStart = pD3DPerfEvent->CycleCpuStart - *pFirstCpuStart;

        Spacer[0] = (CpuStart < *pLastCpuTime) ? '+' : 0;
        Spacer[1] = 0;

        char szPct[6];

        if(pD3DPerfEvent->GpuPct != 0xffff)
        {
            DWORD GpuFe = pD3DPerfEvent->GpuPct & 0xff;
            DWORD GpuBe = pD3DPerfEvent->GpuPct >> 8;

            // Convert Gpu Pct to a printable string

            szPct[0] = (BYTE)(GpuFe / 10) + '0';
            szPct[1] = (BYTE)(GpuFe % 10) + '0';
            szPct[2] = '/';
            szPct[3] = (BYTE)(GpuBe / 10) + '0';
            szPct[4] = (BYTE)(GpuBe % 10) + '0';
            szPct[5] = 0;
        }
        else
        {
            szPct[0] = 0;
        }

        // Print all this nonsense

        DbgPrint("%s%-*s %9I64u %9lu %9I64u %8lu %7lu %6lu %s\n",
            Spacer,
            19 - !!Spacer[0],
            szEvent,
            CpuStart,
            pD3DPerfEvent->CycleCpuLength,
            GpuStart,
            pD3DPerfEvent->CycleGpuLength,
            pD3DPerfEvent->CpuPutPtr - (DWORD)g_pDevice->m_pPushBase,
            pD3DPerfEvent->Data,
            szPct);

        // Record the largest cpu ending time we've gotten to date for indentation.

        *pLastCpuTime = max(*pLastCpuTime, CpuStart + pD3DPerfEvent->CycleCpuLength);
    }
}

//------------------------------------------------------------------------------
// D3DPERF_DumpPerfEvents
//
// Display all the performance events we've racked up

extern "C"
void WINAPI D3DPERF_DumpPerfEvents()
{
    if(!g_PerfCounters.CurrentD3DPerfEvent)
        return;

    // Turn off event recording so those VBlanks don't kill us whilst printing. I know this
    // was done in D3DPERF_DumpFrameRateInfo but D3DPERF_DumpPerfEvents() is user callable.
    BOOL RecordD3DPerfEventsBak = g_PerfCounters.RecordD3DPerfEvents;
    g_PerfCounters.RecordD3DPerfEvents = FALSE;

    // Block until we're idle to flush all the gpu events and make sure they've
    // had a chance to get written.
    D3DDevice_BlockUntilIdle();

    // Give em a header.
    DbgPrint("\nEvent                "
        "CpuStart   CpuTime  GpuStart  GpuTime  CpuPut  Data  Fe/Be\n");

    DWORD PresentNum = 0;
    ULONGLONG FirstCpuStart = 0;
    ULONGLONG LastCpuTime = 0;

    DWORD EndEvent =
        g_PerfCounters.CurrentD3DPerfEvent % g_PerfCounters.CountD3DPerfEvents;
    DWORD CurrentEvent =
        g_PerfCounters.CurrentD3DPerfEvent > g_PerfCounters.CountD3DPerfEvents ?
            EndEvent : 0;
    DWORD SpewFrameCount = g_PerfCounters.D3DPerfEventSpewFrameCount;
    DWORD SpewFrameStart =
        SpewFrameCount ? g_PerfCounters.D3DPerfEventSpewFrameStart : 0;

    do
    {
        D3DPERFEvent *pD3DPerfEvent = &g_PerfCounters.pD3DPerfEvents[CurrentEvent];
        BOOL IsPresentFrame = pD3DPerfEvent->Type == D3DPERFEvent_Present;

        PresentNum += IsPresentFrame;
        if(PresentNum >= SpewFrameStart)
        {
            SpewPerfEvent(pD3DPerfEvent, &FirstCpuStart, &LastCpuTime);
        }

        if(SpewFrameCount &&
            IsPresentFrame &&
            (PresentNum >= SpewFrameStart + SpewFrameCount))
        {
            // Run through the rest so we get an accurate Present count but
            // set FrameStart to -1 so we'll never spew anything else.
            SpewFrameStart = (DWORD)-1;
            SpewFrameCount = 0;
        }

        CurrentEvent = (CurrentEvent + 1) % g_PerfCounters.CountD3DPerfEvents;

    } while (CurrentEvent != EndEvent);

    DbgPrint("Total Perf Events: %lu  Presents Captured: %lu\n",
        g_PerfCounters.CurrentD3DPerfEvent, PresentNum);

    // Set everything back to normal and slide out of the room quietly.
    g_PerfCounters.RecordD3DPerfEvents = RecordD3DPerfEventsBak;
}

//------------------------------------------------------------------------------
// D3DPERF_Dump
//
// Display all the statistics we've accumulated

extern "C"
void WINAPI D3DPERF_Dump()
{
    DWORD id, i;

    ULONGLONG CurTime = ___D3DCYCLETIMER_GetTime();

    DbgPrint("Performance Counters:\n\n");

    for (id = 0; id < D3DPERF_MAX; id++)
    {
        if(g_PerfCounters.m_PerformanceCounters[id].Cycles)
        {
            DbgPrint("%10Lu - %s - %I64u\n",
                     g_PerfCounters.m_PerformanceCounters[id].Count,
                     g_PerfNames.m_PerformanceCounterNames[id],
                     g_PerfCounters.m_PerformanceCounters[id].Cycles);
        }
        else if (g_PerfCounters.m_PerformanceCounters[id].Count)
        {
            DbgPrint("%10Lu - %s\n",
                     g_PerfCounters.m_PerformanceCounters[id].Count,
                     g_PerfNames.m_PerformanceCounterNames[id]);
        }
    }

    DbgPrint("\nAPI Counters:\n\n");

    for (id = 0; id < D3DAPI_MAX; id++)
    {
        if (g_PerfCounters.m_APICounters[id])
        {
            DbgPrint("%10Lu - %s\n",
                     g_PerfCounters.m_APICounters[id],
                     g_PerfNames.m_APICounterNames[id]);
        }
    }

    DbgPrint("\nRenderState counters:\n\n");

    for (id = 0; id < D3DRS_MAX; id++)
    {
        if (g_PerfCounters.m_RenderStateCounters[id])
        {
            char *szName = "missing description";

            for (i = 0;
                 i < sizeof(g_PerfNames.m_RenderStateNames) / sizeof(D3DSTATENAME);
                 i++)
            {
                if (g_PerfNames.m_RenderStateNames[i].m_State == id)
                {
                    szName = g_PerfNames.m_RenderStateNames[i].m_Name;
                    break;
                }
            }

            DbgPrint("%10Lu - %s\n",
                     g_PerfCounters.m_RenderStateCounters[id],
                     szName);
        }
    }

    DbgPrint("\nTextureState counters:\n\n");

    for (id = 0; id < D3DTSS_MAX; id++)
    {
        if (g_PerfCounters.m_TextureStateCounters[id])
        {
            char *szName = "missing description";

            for (i = 0;
                 i < sizeof(g_PerfNames.m_TextureStateNames) / sizeof(D3DSTATENAME);
                 i++)
            {
                if (g_PerfNames.m_TextureStateNames[i].m_State == id)
                {
                    szName = g_PerfNames.m_TextureStateNames[i].m_Name;
                    break;
                }
            }

            DbgPrint("%10Lu - %s\n",
                     g_PerfCounters.m_TextureStateCounters[id],
                     szName);
        }
    }

    DbgPrint("\nTotal Cycles: %I64u\n",
        CurTime - g_PerfCounters.m_TSCLastResetVal);
}

//------------------------------------------------------------------------------
// D3DPERF_SetState
//
// Set perf state.

extern "C" HRESULT WINAPI
D3DPERF_SetState(
    D3DPERFSTATETYPE State,
    DWORD Value)
{
    static const DWORD rgDebug1[] =
    {
//$ BUGBUG: Not sure what the page table entry vertex cache dude does.
//  Commented out until we know and find out whether it is relevant to the
//  NV2A and/or useful.
//        DRF_DEF(_PGRAPH, _DEBUG_1, _VTX_PTE, _ENABLED),
        DRF_DEF(_PGRAPH, _DEBUG_1, _VTX_CACHE, _ENABLED),
        DRF_DEF(_PGRAPH, _DEBUG_1, _VTX_FILE, _ENABLED),
        DRF_DEF(_PGRAPH, _DEBUG_1, _VTX_CACHE, _ENABLED) |
            DRF_DEF(_PGRAPH, _DEBUG_1, _VTX_FILE, _ENABLED),
    };

    DWORD misc;
    CMiniport *pMiniPort = &g_pDevice->m_Miniport;
    BYTE *RegBase = (BYTE*)(pMiniPort->m_RegisterBase);

    switch(State)
    {
//$ case D3DPERFSTATE_VTX_PTE:
    case D3DPERFSTATE_VTX_CACHE:
    case D3DPERFSTATE_VTX_FILE:
    case D3DPERFSTATE_VTX_ALL:
        D3DDevice_BlockUntilIdle();

        misc = REG_RD32(RegBase, NV_PGRAPH_DEBUG_1);

        if(!Value)
            misc &= ~rgDebug1[State];
        else if(Value == 0x80000000)
            misc ^= rgDebug1[State];
        else
            misc |= rgDebug1[State];

        REG_WR32(RegBase, NV_PGRAPH_DEBUG_1, misc);
        return S_OK;
    }

    return E_FAIL;
}

/*
 * GPU Perf Profile stuff
 */

// Struct which hold card busy/idle bits and names.
//
static const struct
{
    DWORD State;
    const char *Name;
} g_GpuStates[D3DPERF_PROF_MAX] =
{
    { DRF_SHIFT(NV_PGRAPH_STATUS_STATE),    "gpu"       },
    { DRF_SHIFT(NV_PGRAPH_STATUS_FE_3D),    "frontend", },
    { DRF_SHIFT(NV_PGRAPH_STATUS_COMBINER), "backend",  },
};

//------------------------------------------------------------------------------
// D3DPERF_DumpPerfProfCounts
//

extern "C" void WINAPI
D3DPERF_DumpPerfProfCounts()
{
    if(g_PerfCounters.m_ProfileSamples)
    {
        for(int i = 0; i < D3DPERF_PROF_MAX; i++)
        {
            DbgPrint("%20s: %Lu (%Lu%%)\n",
                g_GpuStates[i].Name, g_PerfCounters.m_ProfileBusyCounts[i],
                g_PerfCounters.m_ProfileBusyCounts[i] * 100 / g_PerfCounters.m_ProfileSamples);
        }
    }

    DbgPrint("%20s: %Lu\n", "total samples", g_PerfCounters.m_ProfileSamples);
}

#ifndef STARTUPANIMATION

//------------------------------------------------------------------------------
// D3DPERF_StartPerfProfile
//
// Start GPU profiler.

extern "C"
BOOL WINAPI D3DPERF_StartPerfProfile()
{
    if(DmTell(DMTELL_GPUPERF, &g_PerfCounters))
        g_PerfProfData.Sampling = TRUE;

    g_PerfLastProfileSamples = 0;
    memset(&g_PerfLastGpuBusyCounts, 0, sizeof(g_PerfLastGpuBusyCounts));

    // clear profile information
    memset(g_PerfCounters.m_ProfileBusyCounts, 0, sizeof(g_PerfCounters.m_ProfileBusyCounts));
    memset(g_PerfCounters.m_ProfileData, 0xff, sizeof(g_PerfCounters.m_ProfileData));
    g_PerfCounters.m_ProfileSamples = 0;

    // record interrupt profile start time
    g_PerfCounters.m_TSCProfileStartTime = ___D3DCYCLETIMER_GetTime();

    return g_PerfProfData.Sampling;
}

//------------------------------------------------------------------------------
// D3DPERF_StopPerfProfile
//
// Stop GPU profiler.

extern "C"
void WINAPI D3DPERF_StopPerfProfile()
{
    if(g_PerfProfData.Sampling)
    {
        DmTell(DMTELL_GPUPERF, NULL);
        g_PerfProfData.Sampling = FALSE;
    }
}

#endif // STARTUPANIMATION

//------------------------------------------------------------------------------
// D3DPERF_HandlePresent
//
// Called once perf frame after Present call does its work.

extern "C"
void WINAPI D3DPERF_HandlePresent()
{
    // If the framerateinterval check to see if we've been doing stuff
    // for longer than the user specified

    if(g_PerfCounters.m_FrameRateIntervalTime)
    {
        ULONGLONG CurTime = ___D3DCYCLETIMER_GetTime();

        if(g_PerfCounters.m_TSCLastPresentVal)
        {
            ULONGLONG diff = CurTime - g_PerfCounters.m_TSCLastPresentVal;

            if(diff < g_PerfCounters.m_FrameTimeMin.Cycles)
            {
                g_PerfCounters.m_FrameTimeMin.Cycles = diff;
                g_PerfCounters.m_FrameTimeMin.Count =
                    g_PerfCounters.m_APICounters[API_D3DDEVICE_PRESENT];
            }

            if(diff > g_PerfCounters.m_FrameTimeMax.Cycles)
            {
                g_PerfCounters.m_FrameTimeMax.Cycles = diff;
                g_PerfCounters.m_FrameTimeMax.Count =
                    g_PerfCounters.m_APICounters[API_D3DDEVICE_PRESENT];
            }
        }

        g_PerfCounters.m_TSCLastPresentVal = CurTime;

        DWORD Time = MilliSecsFromCycles(CurTime - g_PerfCounters.m_TSCLastResetVal);

        if(Time > g_PerfCounters.m_FrameRateIntervalTime)
        {
            // Dump the current statistics and reset our counters

            if(g_PerfCounters.m_pfnDumpFrameRateInfoHandler)
                g_PerfCounters.m_pfnDumpFrameRateInfoHandler();

            D3DPERF_Reset();
        }
    }
}

//------------------------------------------------------------------------------
// PerfGetPushBufferDistance
//
// Performance Counter callback to track Gpu Get / Cpu put distance.

STDAPI PerfGetPushBufferDistance(
    PLARGE_INTEGER pliData,
    PLARGE_INTEGER pliUnused)
{
    CDevice* pDevice = g_pDevice;

    // Compute the push-buffer difference, accounting for wrapping of
    // the push-buffer:

    DWORD get = (DWORD) pDevice->GpuGet();
    if ((DWORD*) get <= pDevice->m_Pusher.m_pPut)
        get += pDevice->m_PusherLastSize;

    DWORD fence = (DWORD) pDevice->m_Pusher.m_pPut +
        pDevice->m_PusherLastSize;

    // The distance can be less than zero if the back-end write-back is
    // late because of slow rendering and we already gave away the pusher 
    // space in MakeSpace to newer stuff:

    INT distance = max(0, fence - get);

    pliData->QuadPart = (distance * 100) / g_pDevice->m_PushBufferSize;

    return XBDM_NOERR;
}

#endif  // PROFILE

//------------------------------------------------------------------------------
// D3DPERF_GetRegisterBase
//
// Return gpu register base.

extern "C"
BYTE * WINAPI D3DPERF_GetRegisterBase()
{
    CMiniport *pMiniPort = &g_pDevice->m_Miniport;
    BYTE *RegBase = (BYTE*)(pMiniPort->m_RegisterBase);

    return RegBase;
}

} // end of namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\ltcg\makefile.inc ===
$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\surface.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       surface.hpp
 *  Content:    Class header the stand-alone surface class. This class
 *              is intended to be returned by the CreateRenderTarget
 *              creation method. It is also used by the CreateZStencil
 *              device method.
 *
 ***************************************************************************/

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

//------------------------------------------------------------------------------
// Creates a surface that wraps part of a texture.
//
HRESULT CreateSurfaceOfTexture(
    DWORD Format,
    DWORD Size,
    D3DBaseTexture *pParent,
    void *pvData,
    D3DSurface **ppSurface
    );

//------------------------------------------------------------------------------
// Initializes a pre-allocated surface.  This will never be a PO2 surface
// and the pitch will always match the width.  This is only used for
// frame- and back-buffers.
//
void InitializeSurface(
    D3DSurface *pSurface,
    DWORD Format,
    DWORD Size,
    void *pvData);

//------------------------------------------------------------------------------
// Creates a surface that has no owner.
//
HRESULT CreateStandAloneSurface(
    DWORD Width,
    DWORD Height, 
    D3DFORMAT D3DFormat,
    D3DSurface **ppSurface
    );

//------------------------------------------------------------------------------
// Creates a volume that wraps part of a texture.
//
HRESULT CreateVolumeOfTexture(
    DWORD Format,
    D3DBaseTexture *pParent,
    void *pvData,
    D3DVolume **ppVolume
    );

//------------------------------------------------------------------------------
// Creates a surface in which the header and data are contiguous.
//
HRESULT CreateSurfaceWithContiguousHeader(
    DWORD Width,
    DWORD Height,     
    D3DFORMAT D3DFormat,
    D3DSurface **ppSurface
    );

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\profile\makefile.inc ===
$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\user\makefile.inc ===
$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\texture.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       texture.hpp
 *  Content:    Base class for all texture objects. Texture management is
 *              done at this level.
 *
 ***************************************************************************/

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{
 
//----------------------------------------------------------------------------
// Helper to create an instance of any texture.
//
HRESULT CreateTexture(
    DWORD Width,
    DWORD Height,
    DWORD Depth,
    DWORD Levels,
    DWORD Usage,
    D3DFORMAT Format,
    bool isCubeMap,
    bool isVolumeTexture,
    D3DBaseTexture **ppTexture
    );

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\texture.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       texture.cpp
 *  Content:    Implementation of the CBaseTexture class.
 *
 ***************************************************************************/
 
#include "precomp.hpp"

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

/*
 * D3DBaseTexture implementation
 */

//----------------------------------------------------------------------------
// Helper to create an instance of any texture.
//
HRESULT CreateTexture
(
    DWORD Width,
    DWORD Height,
    DWORD Depth,
    DWORD Levels,
    DWORD Usage,
    D3DFORMAT D3DFormat,
    bool isCubeMap,
    bool isVolumeTexture,
    D3DBaseTexture **ppTexture
)
{
    D3DBaseTexture *pTexture;
    void *pData;

    // Assume failure.
    *ppTexture = NULL;

    // Get the format, size and memory size of the texture.
    DWORD MemorySize;
    DWORD Format;
    DWORD Size;

    MemorySize = PixelJar::EncodeFormat(Width,
                                        Height,
                                        Depth,
                                        Levels,
                                        D3DFormat,
                                        0,
                                        isCubeMap,
                                        isVolumeTexture,
                                        &Format,
                                        &Size);

    if (Usage & D3DUSAGE_BORDERSOURCE_TEXTURE)
    {
        Format &= ~D3DFORMAT_BORDERSOURCE_COLOR;
    }

    // Allocate the memory for the header.
    pTexture = (D3DBaseTexture *)MemAlloc(sizeof(D3DBaseTexture));

    if (!pTexture)
    {
        return E_OUTOFMEMORY;
    }

    // Allocate the memory for the texture data.
    pData = AllocateContiguousMemory(MemorySize,
                                     D3DTEXTURE_ALIGNMENT);

    if (!pData)
    {
        MemFree(pTexture);
        return E_OUTOFMEMORY;
    }

    // Fill in its fields.  We just whack them in instead of going through a 
    // helper.  Probably not a good idea as these fields may change
    // in the future.
    //
    pTexture->Common  = /* initial refcount */ 1 | D3DCOMMON_TYPE_TEXTURE | D3DCOMMON_VIDEOMEMORY | D3DCOMMON_D3DCREATED;
    pTexture->Data    = GetGPUAddress(pData);
    pTexture->Format  = Format;
    pTexture->Size    = Size;
    pTexture->Lock    = 0;

    *ppTexture = pTexture;

    return S_OK;
}

//------------------------------------------------------------------------------
// Get the number of mipmap levels for this texture.  This is encode directly
// into the format.
//
extern "C"
DWORD WINAPI D3DBaseTexture_GetLevelCount
(
    D3DBaseTexture *pTexture
)
{
    COUNT_API(API_D3DBASETEXTURE_GETLEVELCOUNT);
    CHECK(pTexture, "D3DBaseTexture_GetLevelCount");

    return PixelJar::GetMipmapLevelCount(pTexture);
}

/*
 * D3DTexture implementation
 */

//------------------------------------------------------------------------------
// Build a descriptor structure that provides information about a specific
// level of this texture.
//
extern "C"
void WINAPI D3DTexture_GetLevelDesc
(
    D3DTexture *pTexture, 
    UINT Level, 
    D3DSURFACE_DESC *pDesc
)
{
    COUNT_API(API_D3DTEXTURE_GETLEVELDESC);
    CHECK(pTexture, "D3DTexture_GetLevelDesc");

    PixelJar::Get2DSurfaceDesc(pTexture,
                               Level, 
                               pDesc);
}

//------------------------------------------------------------------------------
// Create a surface which wraps a mipmap level of this texture.
//
extern "C"
HRESULT WINAPI D3DTexture_GetSurfaceLevel
(
    D3DTexture *pTexture, 
    UINT Level, 
    D3DSurface **ppSurfaceLevel
)
{
    COUNT_API(API_D3DTEXTURE_GETSURFACELEVEL);
    CHECK(pTexture, "D3DTexture_GetSurfaceLevel");

    if (DBG_CHECK(Level >= PixelJar::GetMipmapLevelCount(pTexture)))
    {
        DXGRIP("D3DTexture_GetSurfaceLevel - invalid mipmap level.");
    }

    BYTE *pbData;
    DWORD RowPitch, SlicePitch;
    DWORD Format, Size;

    // Find the memory for our texture.
    PixelJar::FindSurfaceWithinTexture(pTexture,
                                       D3DCUBEMAP_FACE_POSITIVE_X, 
                                       Level, 
                                       &pbData,
                                       &RowPitch,
                                       &SlicePitch,
                                       &Format,
                                       &Size);

    // Allocate the surface.
    return CreateSurfaceOfTexture(Format,
                                  Size,
                                  pTexture,
                                  pbData,
                                  ppSurfaceLevel);
}

//------------------------------------------------------------------------------
// Lock the memory for this texture and allow it to be read/written.
//
extern "C"
void WINAPI D3DTexture_LockRect
(
    D3DTexture *pTexture, 
    UINT Level, 
    D3DLOCKED_RECT *pLockedRect, 
    CONST RECT *pRect, 
    DWORD Flags
)
{
    COUNT_API(API_D3DTEXTURE_LOCKRECT);
    CHECK(pTexture, "D3DTexture_LockRect");

    // This code is shared between normal textures and cube maps.
    PixelJar::Lock2DSurface(pTexture, 
                            D3DCUBEMAP_FACE_POSITIVE_X, 
                            Level, 
                            pLockedRect, 
                            pRect,  
                            Flags);

}

/*
 * D3DCubeTexture implementation
 */

//------------------------------------------------------------------------------
// Build a descriptor structure that provides information about a specific
// level of this texture.
//
extern "C"
void WINAPI D3DCubeTexture_GetLevelDesc
(
    D3DCubeTexture *pTexture, 
    UINT Level, 
    D3DSURFACE_DESC *pDesc
)
{
    COUNT_API(API_D3DCUBETEXTURE_GETLEVELDESC);
    CHECK(pTexture, "D3DCubeTexture_GetLevelDesc");

    PixelJar::Get2DSurfaceDesc(pTexture, 
                               Level, 
                               pDesc);
}

//------------------------------------------------------------------------------
// Create a surface which wraps a mipmap level of a face of this texture.
//
extern "C"
HRESULT WINAPI D3DCubeTexture_GetCubeMapSurface
(
    D3DCubeTexture *pTexture, 
    D3DCUBEMAP_FACES FaceType, 
    UINT Level, 
    D3DSurface **ppCubeMapSurface
)
{
    COUNT_API(API_D3DCUBETEXTURE_GETCUBEMAPSURFACE);
    CHECK(pTexture, "D3DCubeTexture_GetCubeMapSurface");

    if (DBG_CHECK(Level >= PixelJar::GetMipmapLevelCount(pTexture)))
    {
        DXGRIP("D3DTexture_GetSurfaceLevel - invalid mipmap level.");
    }

    BYTE *pbData;
    DWORD RowPitch, SlicePitch;
    DWORD Format, Size;

    // Find the memory for our texture.
    PixelJar::FindSurfaceWithinTexture(pTexture,
                                       FaceType, 
                                       Level, 
                                       &pbData,
                                       &RowPitch,
                                       &SlicePitch,
                                       &Format,
                                       &Size);

    // Allocate the surface.
    return CreateSurfaceOfTexture(Format,
                                  Size,
                                  pTexture,
                                  pbData,
                                  ppCubeMapSurface);
}

//------------------------------------------------------------------------------
// Lock the memory for this texture and allow it to be read/written.
//
extern "C"
void WINAPI D3DCubeTexture_LockRect
(
    D3DCubeTexture *pTexture, 
    D3DCUBEMAP_FACES FaceType, 
    UINT Level, 
    D3DLOCKED_RECT *pLockedRect, 
    CONST RECT *pRect, 
    DWORD Flags
)
{
    COUNT_API(API_D3DCUBETEXTURE_LOCKRECT);
    CHECK(pTexture, "D3DCubeTexture_LockRect");

    // This code is shared between normal textures and cube maps.
    PixelJar::Lock2DSurface(pTexture, 
                            FaceType, 
                            Level, 
                            pLockedRect, 
                            pRect, 
                            Flags);
}

/*
 * D3DVolumeTexture implementation
 */

//------------------------------------------------------------------------------
// Build a descriptor structure that provides information about a specific
// level of this texture.
//
extern "C"
void WINAPI D3DVolumeTexture_GetLevelDesc
(
    D3DVolumeTexture *pTexture, 
    UINT Level, 
    D3DVOLUME_DESC *pDesc
)
{
    COUNT_API(API_D3DVOLUMETEXURE_GETLEVELDESC);
    CHECK(pTexture, "D3DVolumeTexture_GetLevelDesc");

    PixelJar::Get3DSurfaceDesc(pTexture,
                               Level,
                               pDesc);
}

//------------------------------------------------------------------------------
// Create a volume which wraps a mipmap level of this texture.
//
extern "C"
HRESULT WINAPI D3DVolumeTexture_GetVolumeLevel
(
    D3DVolumeTexture *pTexture, 
    UINT Level, 
    D3DVolume **ppVolumeLevel
)
{
    COUNT_API(API_D3DVOLUMETEXURE_GETVOLUMELEVEL);
    CHECK(pTexture, "D3DVolumeTexture_GetVolumeLevel");

    if (DBG_CHECK(Level >= PixelJar::GetMipmapLevelCount(pTexture)))
    {
        DXGRIP("D3DVolumeTexture_GetVolumeLevel - invalid mipmap level.");
    }

    BYTE *pbData;
    DWORD RowPitch, SlicePitch;
    DWORD Format, Size;

    // Find the memory for our texture.
    PixelJar::FindSurfaceWithinTexture(pTexture,
                                       D3DCUBEMAP_FACE_POSITIVE_X, 
                                       Level, 
                                       &pbData,
                                       &RowPitch,
                                       &SlicePitch,
                                       &Format,
                                       &Size);

    // Allocate the surface.
    return CreateVolumeOfTexture(Format,
                                 pTexture,
                                 pbData,
                                 ppVolumeLevel);
}

//------------------------------------------------------------------------------
// Lock a portion of a 3D texture.
//
extern "C"
void WINAPI D3DVolumeTexture_LockBox
(
    D3DVolumeTexture *pTexture, 
    UINT Level, 
    D3DLOCKED_BOX *pLockedVolume, 
    CONST D3DBOX *pBox, 
    DWORD Flags
)
{
    COUNT_API(API_D3DVOLUMETEXURE_LOCKBOX);
    CHECK(pTexture, "D3DVolumeTexture_LockBox");

    PixelJar::Lock3DSurface(pTexture,
                            Level, 
                            pLockedVolume,
                            pBox,
                            Flags);
}

} // end of namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\surface.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       surface.cpp
 *  Content:    Implementation of the CSurface class.
 *
 ***************************************************************************/
 
#include "precomp.hpp" 

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

/*
 * D3DSurface
 */

//------------------------------------------------------------------------------
// Creates a surface that wraps part of a texture.
//
HRESULT CreateSurfaceOfTexture(
    DWORD Format,
    DWORD Size,
    D3DBaseTexture *pParent,
    void *pvData,
    D3DSurface **ppSurface
    )
{
    D3DSurface *pSurface;

    // Allocate the memory for the header.
    pSurface = (D3DSurface *)MemAlloc(sizeof(D3DSurface));

    if (!pSurface)
    {
        return E_OUTOFMEMORY;
    }

    // Fill in its fields.
    pSurface->Common  = /* initial refcount */ 1 | D3DCOMMON_TYPE_SURFACE | (pParent->Common & D3DCOMMON_VIDEOMEMORY) | D3DCOMMON_D3DCREATED;
    pSurface->Data    = GetGPUAddress(pvData);
    pSurface->Format  = Format;
    pSurface->Size    = Size;
    pSurface->Parent  = pParent;
    pSurface->Lock    = 0;

    pParent->AddRef();

    *ppSurface = pSurface;

    return S_OK;
}

//------------------------------------------------------------------------------
// Initializes a pre-allocated surface.  These will not be a PO2 surface.
//
void InitializeSurface(
    D3DSurface *pSurface,
    DWORD Format,
    DWORD Size,
    void *pvData)
{
    // Just fill it in.
    pSurface->Common  = /* initial refcount */ 1 | D3DCOMMON_TYPE_SURFACE | D3DCOMMON_VIDEOMEMORY | D3DCOMMON_D3DCREATED;
    pSurface->Data    = GetGPUAddress(pvData);
    pSurface->Format  = Format;
    pSurface->Size    = Size;
    pSurface->Parent  = NULL;
    pSurface->Lock    = 0;
}

//------------------------------------------------------------------------------
// Creates a surface that has no owner.
//
HRESULT CreateStandAloneSurface(
    DWORD Width,
    DWORD Height,     
    D3DFORMAT D3DFormat,
    D3DSurface **ppSurface
    )
{
    D3DSurface *pSurface;

    DWORD Format;
    DWORD Size;
    DWORD MemorySize;

    void *pData;

    MemorySize = PixelJar::EncodeFormat(Width,
                                        Height,
                                        1,
                                        1,
                                        D3DFormat,
                                        0,
                                        false, 
                                        false,
                                        &Format,
                                        &Size);

    // Allocate the memory for the header.
    pSurface = (D3DSurface *)MemAlloc(sizeof(D3DSurface));
    if (!pSurface)
    {
        return E_OUTOFMEMORY;
    }

    // Allocate the data.
    pData = AllocateContiguousMemory(MemorySize, D3DSURFACE_ALIGNMENT);
    if (!pData)
    {
        MemFree(pSurface);
        return E_OUTOFMEMORY;
    }
    
    // Fill in its fields.  We just whack them in instead of going through a 
    // helper.  Probably not a good idea as these fields may change
    // in the future.
    //
    pSurface->Common  = /* initial refcount */ 1 | D3DSURFACE_OWNSMEMORY | D3DCOMMON_TYPE_SURFACE | D3DCOMMON_VIDEOMEMORY | D3DCOMMON_D3DCREATED;
    pSurface->Data    = GetGPUAddress(pData);
    pSurface->Format  = Format;
    pSurface->Size    = Size;
    pSurface->Parent  = NULL;
    pSurface->Lock    = 0;

    *ppSurface = pSurface;

    return S_OK;
}

//------------------------------------------------------------------------------
// Creates a surface in which the header and data are contiguous.
//
HRESULT CreateSurfaceWithContiguousHeader(
    DWORD Width,
    DWORD Height,     
    D3DFORMAT D3DFormat,
    D3DSurface **ppSurface
    )
{
    D3DSurface *pSurface;

    DWORD Format;
    DWORD Size;
    DWORD MemorySize;
    DWORD HeaderSize;

    void *pData;

    MemorySize = PixelJar::EncodeFormat(Width,
                                        Height,
                                        1,
                                        1,
                                        D3DFormat,
                                        0,
                                        false, 
                                        false,
                                        &Format,
                                        &Size);

    HeaderSize = (sizeof(D3DSurface) + D3DSURFACE_ALIGNMENT - 1) & 
            ~(D3DSURFACE_ALIGNMENT - 1);

    pSurface = (D3DSurface *)MmAllocateContiguousMemoryEx(
            HeaderSize + MemorySize,
            0, 
            AGP_APERTURE_BYTES - 1,
            D3DSURFACE_ALIGNMENT, 
            PAGE_READWRITE | PAGE_WRITECOMBINE);

    if (!pSurface)
    {
        return E_OUTOFMEMORY;
    }

    pData = (PVOID)((PBYTE)pSurface + HeaderSize);

    // Fill in its fields.  We just whack them in instead of going through a 
    // helper.  Probably not a good idea as these fields may change
    // in the future.
    //
    pSurface->Common  = /* initial refcount */ 1 | D3DSURFACE_OWNSMEMORY | D3DCOMMON_TYPE_SURFACE | D3DCOMMON_VIDEOMEMORY | D3DCOMMON_D3DCREATED;
    pSurface->Data    = GetGPUAddress(pData);
    pSurface->Format  = Format;
    pSurface->Size    = Size;
    pSurface->Parent  = NULL;
    pSurface->Lock    = 0;

    *ppSurface = pSurface;

    return S_OK;
}

//------------------------------------------------------------------------------
// D3DSurface_GetContainer
//
extern "C"
HRESULT WINAPI D3DSurface_GetContainer(
    D3DSurface      *pSurface,
    D3DBaseTexture **ppTexture) 
{ 
    COUNT_API(API_D3DSURFACE_GETCONTAINER);
    CHECK(pSurface, "D3DSurface_GetContainer");

    *ppTexture = pSurface->Parent;

    if (*ppTexture)
    {
        (*ppTexture)->AddRef();
    }

    return *ppTexture ? S_OK : E_FAIL;
}

//------------------------------------------------------------------------------
// D3DSurface_GetDesc
//
extern "C"
void WINAPI D3DSurface_GetDesc(
    D3DSurface *pSurface,
    D3DSURFACE_DESC   *pDesc) 
{ 
    COUNT_API(API_D3DSURFACE_GETDESC);
    CHECK(pSurface, "D3DSurface_GetDesc");

    PixelJar::Get2DSurfaceDesc(pSurface,
                               0,
                               pDesc);
}

//------------------------------------------------------------------------------
// D3DSurface_LockRect
//
extern "C"
void WINAPI D3DSurface_LockRect(
    D3DSurface *pSurface,
    D3DLOCKED_RECT    *pLockedRect,
    CONST RECT        *pRect,
    DWORD Flags) 
{ 
    COUNT_API(API_D3DSURFACE_LOCKRECT);
    CHECK(pSurface, "D3DSurface_LockRect");

    // This code is shared between normal textures and cube maps.
    PixelJar::Lock2DSurface(pSurface,
                            D3DCUBEMAP_FACE_POSITIVE_X, 
                            0, 
                            pLockedRect, 
                            pRect, 
                            Flags);

}

/*
 * D3DVolume
 */

//------------------------------------------------------------------------------
// Creates a volume that wraps part of a texture.
//
HRESULT CreateVolumeOfTexture(
    DWORD Format,
    D3DBaseTexture *pParent,
    void *pvData,
    D3DVolume **ppVolume
    )
{
    D3DVolume *pVolume;

    // Allocate the memory for the header.
    pVolume = (D3DVolume *)MemAlloc(sizeof(D3DVolume));

    if (!pVolume)
    {
        return E_OUTOFMEMORY;
    }

    // Fill in its fields.
    pVolume->Common  = /* initial refcount */ 1 | D3DCOMMON_TYPE_SURFACE | (pParent->Common & D3DCOMMON_VIDEOMEMORY) | D3DCOMMON_D3DCREATED;
    pVolume->Data   = GetGPUAddress(pvData);
    pVolume->Format = Format;
    pVolume->Size   = 0;
    pVolume->Parent = pParent;
    pVolume->Lock   = 0;

    pParent->AddRef();

    *ppVolume = pVolume;

    return S_OK;
}

//------------------------------------------------------------------------------
// D3DVolume_GetDesc
//
extern "C"
void WINAPI D3DVolume_GetDesc(
    D3DVolume *pVolume, 
    D3DVOLUME_DESC *pDesc
    ) 
{ 
    COUNT_API(API_D3DVOLUME_GETDESC);
    CHECK(pVolume, "D3DVolume_GetDesc");

    PixelJar::Get3DSurfaceDesc(pVolume,
                               0,
                               pDesc);
}

//------------------------------------------------------------------------------
// D3DVolume_LockBox
//
extern "C"
void WINAPI D3DVolume_LockBox(
    D3DVolume *pVolume,
    D3DLOCKED_BOX *pLockedVolume,
    CONST D3DBOX *pBox,
    DWORD Flags
    ) 
{
    COUNT_API(API_D3DVOLUME_LOCKBOX);
    CHECK(pVolume, "D3DVolume_LockBox");

    // This code is shared between normal textures and cube maps.
    PixelJar::Lock3DSurface(pVolume, 
                            0, 
                            pLockedVolume, 
                            pBox, 
                            Flags);

}

//------------------------------------------------------------------------------
// D3DVolume_GetContainer
//
extern "C"
HRESULT WINAPI D3DVolume_GetContainer(
    D3DVolume *pVolume, 
    D3DBaseTexture **ppTexture
    )
{
    COUNT_API(API_D3DVOLUME_GETCONTAINER);
    CHECK(pVolume, "D3DVolume_GetContainer");

    *ppTexture = pVolume->Parent;

    if (*ppTexture)
    {
        (*ppTexture)->AddRef();
    }

    return *ppTexture ? S_OK : E_FAIL;
}

} // end of namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\stats.hpp ===
/*==========================================================================
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       stats.hpp
 *  Content:    header file for debug-only statistics gathering
 *
 ***************************************************************************/

#ifndef PROFILE

#if DBG
#define PROFILE     1
#endif

#endif

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

#if !PROFILE

    #define CLEAR_STATISTICS()

    #define COUNT_PERF(x)
    #define COUNT_ADD_PERF(x, amount)
    #define COUNT_API(x)
    #define COUNT_RENDERSTATE(x)
    #define COUNT_TEXTURESTATE(x)
    #define COUNT_PERFCYCLES(x)
    #define COUNT_PERFEVENT(x, y)

#else

    #include "d3d8perf.h"

    // function prototypes
    extern "C" void WINAPI D3DPERF_HandlePresent();

    STDAPI PerfGetPushBufferDistance(
        PLARGE_INTEGER pliData, PLARGE_INTEGER pliUnused);

    // Stats prototypes:

    extern D3DPERF g_PerfCounters;
    extern DWORD   g_CpuCyclesPerMsec;

    // Reset all of our counters:

    #define CLEAR_STATISTICS() D3DPERF_Reset()

    // 'function' : no return value

    #pragma warning(disable:4035)

    // Read Time Stamp Counter helper

    __forceinline ULONGLONG ___D3DCYCLETIMER_GetTime()
    {
        _asm rdtsc
    }

    // Helper routine to calc milliseconds.

    __forceinline DWORD MilliSecsFromCycles(ULONGLONG Cycles)
    {
        return (DWORD)(Cycles / g_CpuCyclesPerMsec);
    }

    // Cycle Timer class

    struct ___D3DCYCLETIMER
    {
        ULONGLONG m_CycleStart;
        D3DPERF_PerformanceCounters m_perfctr;

        __forceinline ___D3DCYCLETIMER(D3DPERF_PerformanceCounters perfctr)
        {
            m_perfctr = perfctr;
            g_PerfCounters.m_PerformanceCounters[perfctr].Count++;
            if(g_PerfCounters.m_Breakperfctr == perfctr &&
                g_PerfCounters.m_PerformanceCounters[perfctr].Count == g_PerfCounters.m_BreakCount)
            {
                _asm int 3;
            }

            m_CycleStart = ___D3DCYCLETIMER_GetTime();
        }

        __forceinline ~___D3DCYCLETIMER()
        {
            _asm cpuid;
            ULONGLONG Cycles = ___D3DCYCLETIMER_GetTime() - m_CycleStart;

            g_PerfCounters.m_PerformanceCounters[m_perfctr].Cycles += Cycles;

            if(g_PerfCounters.m_pfnCycleThresholdHandler &&
                (g_PerfCounters.m_DumpWaitCycleTimesThreshold < (DWORD)Cycles))
            {
                g_PerfCounters.m_pfnCycleThresholdHandler(m_perfctr, Cycles);
            }
        }
    };

    // Use the following routines to increment counters for the various types
    // of calls.  On non-profile-enabled builds, these expand to nothing.

    __forceinline void COUNT_PERF(D3DPERF_PerformanceCounters perfctr)
    {
        g_PerfCounters.m_PerformanceCounters[perfctr].Count++;
        if(g_PerfCounters.m_Breakperfctr == perfctr &&
            g_PerfCounters.m_PerformanceCounters[perfctr].Count == g_PerfCounters.m_BreakCount)
        {
            _asm int 3;
        }
    }

    __forceinline void COUNT_ADD_PERF(D3DPERF_PerformanceCounters perfctr, DWORD amount)
    {
        DWORD countbak = g_PerfCounters.m_PerformanceCounters[perfctr].Count;

        g_PerfCounters.m_PerformanceCounters[perfctr].Count += amount;
        if(g_PerfCounters.m_Breakperfctr == perfctr &&
            countbak < g_PerfCounters.m_BreakCount &&
            g_PerfCounters.m_PerformanceCounters[perfctr].Count >= g_PerfCounters.m_BreakCount)
        {
            _asm int 3;
        }
    }

    // Perf Event class

    struct ___D3DPERFEVENT
    {
        BOOL m_RecordGpuTime;
        D3DPERFEvent *m_pD3DPerfEvent;

        __forceinline ___D3DPERFEVENT(WORD Type, BOOL RecordGpuTime)
        {
            m_RecordGpuTime = RecordGpuTime;
            m_pD3DPerfEvent = D3DPERF_PerfEventStart(Type, RecordGpuTime);
        }

        __forceinline ~___D3DPERFEVENT()
        {
            D3DPERF_PerfEventEnd(m_pD3DPerfEvent, m_RecordGpuTime);
        }
    };

    #define COUNT_API(x)                    g_PerfCounters.m_APICounters[x]++
    #define COUNT_RENDERSTATE(x)            g_PerfCounters.m_RenderStateCounters[x]++
    #define COUNT_TEXTURESTATE(x)           g_PerfCounters.m_TextureStateCounters[x]++
    #define COUNT_PERFCYCLES(x)             ___D3DCYCLETIMER _ct##x(x)
    #define COUNT_PERFEVENT(x, y)           ___D3DPERFEVENT _PerfEvent(x, y)

    const D3DPERFNAMES g_PerfNames =
    {
        {
            #define DEFINE_PERF(x) #x,

            #include "d3d8perfp.h"

            #undef DEFINE_PERF
        },
        {
            #define DEFINE_API(x) #x,

            #include "d3d8perfp.h"

            #undef DEFINE_API
        },
        {
            #define RS(x) { D3DRS_##x, #x },

            RS(ZENABLE)
            RS(FILLMODE)
            RS(SHADEMODE)
            RS(ZWRITEENABLE)
            RS(ALPHATESTENABLE)
            RS(SRCBLEND)
            RS(DESTBLEND)
            RS(CULLMODE)
            RS(ZFUNC)
            RS(ALPHAREF)
            RS(ALPHAFUNC)
            RS(DITHERENABLE)
            RS(ALPHABLENDENABLE)
            RS(FOGENABLE)
            RS(SPECULARENABLE)
            RS(FOGCOLOR)
            RS(FOGTABLEMODE)
            RS(FOGSTART)
            RS(FOGEND)
            RS(FOGDENSITY)
            RS(EDGEANTIALIAS)
            RS(ZBIAS)
            RS(RANGEFOGENABLE)
            RS(STENCILENABLE)
            RS(STENCILFAIL)
            RS(STENCILZFAIL)
            RS(STENCILPASS)
            RS(STENCILFUNC)
            RS(STENCILREF)
            RS(STENCILMASK)
            RS(STENCILWRITEMASK)
            RS(TEXTUREFACTOR)
            RS(WRAP0)
            RS(WRAP1)
            RS(WRAP2)
            RS(WRAP3)
            RS(LIGHTING)
            RS(AMBIENT)
            RS(COLORVERTEX)
            RS(LOCALVIEWER)
            RS(NORMALIZENORMALS)
            RS(DIFFUSEMATERIALSOURCE)
            RS(SPECULARMATERIALSOURCE)
            RS(AMBIENTMATERIALSOURCE)
            RS(EMISSIVEMATERIALSOURCE)
            RS(VERTEXBLEND)
            RS(POINTSIZE)
            RS(POINTSIZE_MIN)
            RS(POINTSPRITEENABLE)
            RS(POINTSCALEENABLE)
            RS(POINTSCALE_A)
            RS(POINTSCALE_B)
            RS(POINTSCALE_C)
            RS(MULTISAMPLEANTIALIAS)
            RS(MULTISAMPLEMASK)
            RS(PATCHEDGESTYLE)
            RS(PATCHSEGMENTS)
            RS(POINTSIZE_MAX)
            RS(COLORWRITEENABLE)
            RS(BLENDOP)

            #undef RS
        },
        {
            #define TS(x) { D3DTSS_##x, #x},

            TS(COLOROP)
            TS(COLORARG1)
            TS(COLORARG2)
            TS(ALPHAOP)
            TS(ALPHAARG1)
            TS(ALPHAARG2)
            TS(BUMPENVMAT00)
            TS(BUMPENVMAT01)
            TS(BUMPENVMAT10)
            TS(BUMPENVMAT11)
            TS(TEXCOORDINDEX)
            TS(ADDRESSU)
            TS(ADDRESSV)
            TS(BORDERCOLOR)
            TS(MAGFILTER)
            TS(MINFILTER)
            TS(MIPFILTER)
            TS(MIPMAPLODBIAS)
            TS(MAXMIPLEVEL)
            TS(MAXANISOTROPY)
            TS(BUMPENVLSCALE)
            TS(BUMPENVLOFFSET)
            TS(TEXTURETRANSFORMFLAGS)
            TS(ADDRESSW)
            TS(COLORARG0)
            TS(ALPHAARG0)
            TS(RESULTARG)

            #undef TS
        }
    };

#endif // PROFILE

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\vshader.cpp ===
/*============================================================================
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       vshader.cpp
 *  Content:    Contains all of the vertex shader and stream logic.
 *
 ****************************************************************************/
 
#include "precomp.hpp"

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

//------------------------------------------------------------------------------
// g_LoadedVertexShaderSlot
//
// This debug-only array is used for tracking what slots are loaded with
// vertex shader program via LoadVertexShader.  0 in the byte means no
// no program is actively loaded there, 1 means there's some program loaded
// at that slot:

#if DBG

BYTE g_LoadedVertexShaderSlot[VSHADER_PROGRAM_SLOTS];

#endif

//------------------------------------------------------------------------------
// Shader constants

// Vertex Shader 'Magic cookies'

#define VSHADER_TYPE_ORDINARY 0x2078
#define VSHADER_TYPE_WRITE 0x7778
#define VSHADER_TYPE_STATE 0x7378

// The user gets to use constant registers -96 through 95 (or 0 through 95
// if only using 96 registers).  We add 96 before giving those register
// values to the hardware:

#define VSHADER_CONSTANT_MIN -96
#define VSHADER_CONSTANT_MAX 96     // (exclusive)
#define VSHADER_CONSTANT_NUM 192
#define VSHADER_CONSTANT_BIAS 96

// We always download constants and programs in batches of this many
// slots (where a slot is 4 DWORDS, or equivalently 16 BYTEs), because
// that's what the hardware limits us to:

#define VSHADER_BATCH_LIMIT 8

//------------------------------------------------------------------------------
// g_FvfVertexShader is storage used whenever an FVF is specified as the 
// current vertex shader program.  CDevice::m_pVertexShader will often 
// point to this...

VertexShader g_FvfVertexShader;

//------------------------------------------------------------------------------
// g_DirectVertexShader is storage used whenever an structure is used 
// to specify the vertex attribute format. CDevice::m_pVertexShader will often 
// point to this if the Direct vertex shader APIs are used...

VertexShader g_DirectVertexShader;

//------------------------------------------------------------------------------
// g_Stream
//
// Keeps track of all the currently selected streams for the device.

Stream g_Stream[16];

//------------------------------------------------------------------------------
// g_TextureCount is for mapping the FVF count of textures:

D3DCONST DWORD g_TextureCount[] = 
{ 
    2, 3, 4, 1 
};

//------------------------------------------------------------------------------
// g_PassthruProgramSpecularFog 
//
// Xbox Shader Assembler 1.00.3624.1
//
//    ; szPassthruProgramSpecFog
//    ; from nvKelvinState.cpp
//    xvs.1.1
//    
//    #pragma screenspace
//    
//        mov r0,v0
//        rcp r0.w,r0.w
//        mul r0,r0,c[-96]
//        add oPos,r0,c[-95]
//        mov oD0,v3
//        mov oD1,v4
//        mov oFog,v4.w
//        mov oPts,v1.x
//        mov oB0,v7
//        mov oB1,v8
//        mov oT0,v9
//        mov oT1,v10
//        mov oT2,v11
//        mov oT3,v12

D3DCONST DWORD g_PassthruProgramSpecularFog[] =
{
        0x00000000, 0x0020001b, 0x0836106c, 0x2f100ff8,
        0x00000000, 0x0420061b, 0x083613fc, 0x5011f818,
        0x00000000, 0x002008ff, 0x0836106c, 0x2070f828,
        0x00000000, 0x0240081b, 0x1436186c, 0x2f20f824,
        0x00000000, 0x0060201b, 0x2436106c, 0x3070f800,
        0x00000000, 0x00200200, 0x0836106c, 0x2070f830,
        0x00000000, 0x00200e1b, 0x0836106c, 0x2070f838,
        0x00000000, 0x0020101b, 0x0836106c, 0x2070f840,
        0x00000000, 0x0020121b, 0x0836106c, 0x2070f848,
        0x00000000, 0x0020141b, 0x0836106c, 0x2070f850,
        0x00000000, 0x0020161b, 0x0836106c, 0x2070f858,
        0x00000000, 0x0020181b, 0x0836106c, 0x2070f861
};

//------------------------------------------------------------------------------
// g_PassthruProgramZFog
//
// Xbox Shader Assembler 1.00.3624.1
//
//    ; szPassthruProgramZFog
//    ; from nvKelvinState.cpp
//    xvs.1.1
//    
//    #pragma screenspace
//    
//        mov r0,v0
//        rcp r0.w,r0.w
//        mul r0,r0,c[-96]
//        add oPos,r0,c[-95]
//        mov oD0,v3
//        mov oD1,v4
//        mov oFog,v0.z
//        mov oPts,v1.x
//        mov oB0,v7
//        mov oB1,v8
//        mov oT0,v9
//        mov oT1,v10
//        mov oT2,v11
//        mov oT3,v12

D3DCONST DWORD g_PassthruProgramZFog[] =
{
        0x00000000, 0x022000aa, 0x0836086c, 0x201ff828,
        0x00000000, 0x0020081b, 0x0836106c, 0x2070f820,
        0x00000000, 0x0420061b, 0x083613fc, 0x5011f818,
        0x00000000, 0x00200e1b, 0x0836106c, 0x2070f838,
        0x00000000, 0x0240021b, 0x14361800, 0x2f20f834,
        0x00000000, 0x0060201b, 0x2436106c, 0x3070f800,
        0x00000000, 0x0020101b, 0x0836106c, 0x2070f840,
        0x00000000, 0x0020121b, 0x0836106c, 0x2070f848,
        0x00000000, 0x0020141b, 0x0836106c, 0x2070f850,
        0x00000000, 0x0020161b, 0x0836106c, 0x2070f858,
        0x00000000, 0x0020181b, 0x0836106c, 0x2070f861
};

//------------------------------------------------------------------------------
// g_PassthruProgramWFog
//
// Xbox Shader Assembler 1.00.3624.1
//
//    ; szPassthruProgramWFog
//    ; from nvKelvinState.cpp
//    xvs.1.1
//    
//    #pragma screenspace
//    
//        mov r0,v0
//        rcp r0.w,r0.w
//        mul r0,r0,c[-96]
//        add oPos,r0,c[-95]
//        mov oD0,v3
//        mov oD1,v4
//        rcp oFog,v0.w
//        mov oPts,v1.x
//        mov oB0,v7
//        mov oB1,v8
//        mov oT0,v9
//        mov oT1,v10
//        mov oT2,v11
//        mov oT3,v12

D3DCONST DWORD g_PassthruProgramWFog[] =
{
        0x00000000, 0x0020001b, 0x0836106c, 0x2f100ff8,
        0x00000000, 0x0420061b, 0x083613fc, 0x5011f818,
        0x00000000, 0x0400001b, 0x083613fc, 0x2070f82c,
        0x00000000, 0x0240081b, 0x1436186c, 0x2f20f824,
        0x00000000, 0x0060201b, 0x2436106c, 0x3070f800,
        0x00000000, 0x00200200, 0x0836106c, 0x2070f830,
        0x00000000, 0x00200e1b, 0x0836106c, 0x2070f838,
        0x00000000, 0x0020101b, 0x0836106c, 0x2070f840,
        0x00000000, 0x0020121b, 0x0836106c, 0x2070f848,
        0x00000000, 0x0020141b, 0x0836106c, 0x2070f850,
        0x00000000, 0x0020161b, 0x0836106c, 0x2070f858,
        0x00000000, 0x0020181b, 0x0836106c, 0x2070f861
};

//------------------------------------------------------------------------------
// InitializeVertexShaderFromFvf
//
// Loosely derived from nvGenerateFVFData and nvComputeTextureCoordinateData.

VOID InitializeVertexShaderFromFvf(
    VertexShader* pVertexShader,
    DWORD Fvf)
{
    DWORD offset;
    DWORD position;
    DWORD i;
    DWORD weights;

    pVertexShader->Flags = 0;
    pVertexShader->Dimensionality = 0;

    // Kelvin doesn't let us use a type of '0' with a size of '0', so
    // we have to run through and stamp the values:

    for (i = 0; i < 16; i++)
    {
        pVertexShader->Slot[i].SizeAndType = SIZEANDTYPE_DISABLED;
    }

    position = Fvf & D3DFVF_POSITION_MASK;

    offset = 0;

    if (position == D3DFVF_XYZRHW)
    {
        pVertexShader->Flags |= VERTEXSHADER_PASSTHROUGH;

        pVertexShader->Slot[SLOT_POSITION].SizeAndType 
             = DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _4)
             | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F);

        offset = 4 * sizeof(float);
    }
    else if (position != 0)
    {
        pVertexShader->Slot[SLOT_POSITION].SizeAndType 
             = DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _3)
             | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F);

        offset = 3 * sizeof(float);

        if (position >= D3DFVF_XYZB1)
        {
            weights = ((position - D3DFVF_XYZB1) >> 1) + 1;

            if (position == D3DFVF_XYZB1)
            {
                ASSERT(weights == 1);
            }
            else if (position == D3DFVF_XYZB4)
            {
                ASSERT(weights == 4);
            }

            pVertexShader->Slot[SLOT_WEIGHT].Offset = offset;
            pVertexShader->Slot[SLOT_WEIGHT].SizeAndType 
                 = DRF_NUMFAST(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, weights)
                 | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F);

            offset += weights * sizeof(float);
        }
    }

    if (Fvf & D3DFVF_NORMAL)
    {
        pVertexShader->Slot[SLOT_NORMAL].Offset = offset;
        pVertexShader->Slot[SLOT_NORMAL].SizeAndType
             = DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _3)
             | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F);

        offset += 3 * sizeof(float);
    }

    if (Fvf & D3DFVF_DIFFUSE)
    {
        pVertexShader->Slot[SLOT_DIFFUSE].Offset = offset;
        pVertexShader->Slot[SLOT_DIFFUSE].SizeAndType
             = DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _4)
             | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _UB_D3D);

        pVertexShader->Flags |= VERTEXSHADER_HASDIFFUSE;

        offset += sizeof(DWORD);
    }

    if (Fvf & D3DFVF_SPECULAR)
    {
        pVertexShader->Slot[SLOT_SPECULAR].Offset = offset;
        pVertexShader->Slot[SLOT_SPECULAR].SizeAndType
             = DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _4)
             | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _UB_D3D);

        pVertexShader->Flags |= VERTEXSHADER_HASSPECULAR;

        offset += sizeof(DWORD);
    }

    DWORD numTextures = FVF_TEXCOORD_NUMBER(Fvf);
    DWORD textureFormats = Fvf >> 16;

    ASSERT(numTextures <= D3DDP_MAXTEXCOORD);

    // Handle the texture encoding:

    for (i = 0; i < numTextures; i++, textureFormats >>= 2)
    {
        DWORD count = g_TextureCount[textureFormats & 3];
        DWORD size = count << 2;

        pVertexShader->Slot[i + SLOT_TEXTURE0].Offset = offset;
        pVertexShader->Slot[i + SLOT_TEXTURE0].SizeAndType
            = DRF_NUMFAST(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, count)
            | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F);

        pVertexShader->Dimensionality |= (count << (i * 8));

        offset += size;
    }
}

//------------------------------------------------------------------------------
// D3DDevice_SetStreamSource
//
// DOC: Unlike in DX8, the stride for a FVF does not have to match the vertex
//      size.

extern "C"
void WINAPI D3DDevice_SetStreamSource(
    UINT StreamNumber,
    D3DVertexBuffer* pVertexBuffer,
    UINT Stride) 
{                              
    COUNT_API(API_D3DDEVICE_SETSTREAMSOURCE);

    if (DBG_CHECK(TRUE))
    {
        if (StreamNumber > 15)
        {
            DPF_ERR("Invalid stream number");
        }
        if (Stride > 255)
        {
            DPF_ERR("NV2A allows a maximum stride of 255");
        }
        if (D3D__DirtyFlags & D3DDIRTYFLAG_DIRECT_INPUT)
        {
            WARNING("SetStreamSource called while SetVertexShaderInput in effect,\n"
                    "will be deferred");
        }
    }

    if ((pVertexBuffer == g_Stream[StreamNumber].pVertexBuffer) &&
        (Stride == g_Stream[StreamNumber].Stride))
    {
        COUNT_PERF(PERF_REDUNDANT_SETSTREAMSOURCE);
    }

    CDevice* pDevice = g_pDevice;
    
    // Reference the new, release the old, remembering that either may be
    // NULL:

    if (pVertexBuffer)
    {
        InternalAddRef(pVertexBuffer);
    }

    if (g_Stream[StreamNumber].pVertexBuffer)
    {
        pDevice->RecordResourceReadPush(g_Stream[StreamNumber].pVertexBuffer);

        InternalRelease(g_Stream[StreamNumber].pVertexBuffer);
    }

    // If the stride has not changed, we can get away with only reprogramming
    // the vertex offset registers.  If the stride has changed, we also
    // have to reprogram the SizeAndType registers.

    if (Stride == g_Stream[StreamNumber].Stride)
    {
        D3D__DirtyFlags |= D3DDIRTYFLAG_VERTEXFORMAT_OFFSETS;
    }
    else
    {
        D3D__DirtyFlags |= D3DDIRTYFLAG_VERTEXFORMAT;
    }

    // Remember the new data:

    g_Stream[StreamNumber].pVertexBuffer = pVertexBuffer;
    g_Stream[StreamNumber].Stride = Stride;
}

//------------------------------------------------------------------------------
// D3DDevice_GetStreamSource

extern "C"
void WINAPI D3DDevice_GetStreamSource(
    UINT StreamNumber,
    D3DVertexBuffer** ppVertexBuffer,
    UINT* pStride) 
{ 
    COUNT_API(API_D3DDEVICE_GETSTREAMSOURCE);

    if (DBG_CHECK(TRUE))
    {
        if (StreamNumber > 15)
        {
            DPF_ERR("Invalid stream number");
        }
    }

    CDevice* pDevice = g_pDevice;

    D3DVertexBuffer* pVertexBuffer = g_Stream[StreamNumber].pVertexBuffer;

    if (pVertexBuffer)
    {
        pVertexBuffer->AddRef();

        *ppVertexBuffer = pVertexBuffer;
        *pStride = g_Stream[StreamNumber].Stride;
    }
    else
    {
        *ppVertexBuffer = NULL;
        *pStride = 0;
    }
}

//------------------------------------------------------------------------------
// ValidateFVF

void ValidateFVF(
    DWORD type)
{
    DWORD dwTexCoord = FVF_TEXCOORD_NUMBER(type);
    DWORD vertexType = type & D3DFVF_POSITION_MASK;

    // Xbox allows NULL FVF values:

    if (type == 0)
        return;

    // Texture format bits above texture count should be zero
    // Reserved field 0 and 2 should be 0
    // Reserved 1 should be set only for LVERTEX
    // Only two vertex position types allowed

    if (type & g_TextureFormatMask[dwTexCoord])
    {
        D3D_ERR("FVF has incorrect texture format");
    }
    if (type & D3DFVF_RESERVED0)
    {
        D3D_ERR("FVF has reserved bit(s) set");
    }
    if (!(vertexType == D3DFVF_XYZRHW ||
          vertexType == D3DFVF_XYZ ||
          vertexType == D3DFVF_XYZB1 ||
          vertexType == D3DFVF_XYZB2 ||
          vertexType == D3DFVF_XYZB3 ||
          vertexType == D3DFVF_XYZB4))
    {
        D3D_ERR("FVF has incorrect position type");
    }

    if (vertexType == D3DFVF_XYZRHW && type & D3DFVF_NORMAL)
    {
        D3D_ERR("Normal should not be used with XYZRHW position type");
    }
}

//------------------------------------------------------------------------------
// ShadowVertexShaderState
//
// Parse the function stream and update our shadowed copies of the constant
// registers and program slots

VOID ShadowVertexShaderState(
    VertexShader* pVertexShader,
    DWORD Address)
{
    CDevice* pDevice = g_pDevice;

    DWORD* pProgramAndConstants = pVertexShader->ProgramAndConstants;

    DWORD* pSlots = &pDevice->m_VertexShaderProgramSlots[Address][0];

    FLOAT* pConstants;
    DWORD constantSlot;

    // First parse the program loads:

    do {
        DWORD methodEncode = *pProgramAndConstants++;
        DWORD count = methodEncode >> 18;

        ASSERT(count != 0);
        if (count == 1)
        {
            constantSlot = *pProgramAndConstants;

            ASSERT(constantSlot < VSHADER_CONSTANT_NUM);
            ASSERT((methodEncode & 0xffff) 
              == PUSHER_METHOD(SUBCH_3D, NV097_SET_TRANSFORM_CONSTANT_LOAD, 0));

            pConstants = &pDevice->m_VertexShaderConstants[constantSlot][0];
        }
        else if ((methodEncode & 0xffff)
            == PUSHER_METHOD(SUBCH_3D, NV097_SET_TRANSFORM_PROGRAM(0), 0))
        {
            ASSERT(((count & 3) == 0) && 
                   (count != 0) && 
                   (count < VSHADER_PROGRAM_SLOTS*4));
            ASSERT(pSlots + count 
               <= &pDevice->m_VertexShaderProgramSlots[VSHADER_PROGRAM_SLOTS][0]);
            ASSERT((methodEncode & 0xffff) 
               == PUSHER_METHOD(SUBCH_3D, NV097_SET_TRANSFORM_PROGRAM(0), 0));
    
            memcpy(pSlots, pProgramAndConstants, count * sizeof(DWORD));
    
            pSlots += count;
        }
        else
        {
            ASSERT(((count & 3) == 0) && (count < VSHADER_PROGRAM_SLOTS*4));
            ASSERT(pConstants + count <= 
                   &pDevice->m_VertexShaderConstants[VSHADER_CONSTANT_NUM][0]);
            ASSERT((methodEncode & 0xffff) 
                == PUSHER_METHOD(SUBCH_3D, NV097_SET_TRANSFORM_CONSTANT(0), 0));

            memcpy(pConstants, pProgramAndConstants, count * sizeof(DWORD));

            pConstants += count;
        }

        pProgramAndConstants += count;

    } while (*pProgramAndConstants != 0);

    // Make sure we parsed the whole thing, and ended where we expected:

    ASSERT(pProgramAndConstants == &pVertexShader->ProgramAndConstants[
                                pVertexShader->ProgramAndConstantsDwords]);
}

//------------------------------------------------------------------------------
// ParseProgram
//
// Copies an Nvidia opcode vertex shader program and at the same time
// interperses the required NV2A load commands every 32 dwords.
//
// Returns the a pointer to the end of the resulting push buffer snippet.

PPUSH ParseProgram(
    PPUSH pDst,
    CONST DWORD* pProgram,
    DWORD Dwords) // 'pProgram' size, in dwords
{
    DWORD batchSize;
    PPUSH pPush = pDst;

    do {
        batchSize = min(Dwords, 4 * VSHADER_BATCH_LIMIT); // In dwords

        *pPush = PUSHER_METHOD(SUBCH_3D, 
                                 NV097_SET_TRANSFORM_PROGRAM(0), 
                                 batchSize);

        memcpy((void*) (pPush + 1), pProgram, batchSize * sizeof(DWORD));
        
        pProgram += batchSize;
        pPush += batchSize + 1;

    } while ((Dwords -= batchSize) != 0);

    return pPush;
}

//------------------------------------------------------------------------------
// D3DDevice_RunVertexStateShader

extern "C"
void WINAPI D3DDevice_RunVertexStateShader(
    DWORD Address,
    CONST FLOAT *pData)
{
    COUNT_API(API_D3DDEVICE_RUNVERTEXSTATESHADER);

    CDevice* pDevice = g_pDevice;

    if (DBG_CHECK(TRUE))
    {
        // At least verify that the currently selected vertex shader is
        // a state shader:

        if (!(pDevice->m_pVertexShader->Flags & VERTEXSHADER_STATE))
        {
            DPF_ERR("Must have a vertex state shader selected");
        }
        if (Address >= VSHADER_PROGRAM_SLOTS)
        {
            DPF_ERR("Start address can't be larger than 135");
        }
    #if DBG
        if (!g_LoadedVertexShaderSlot[Address])
        {
            DPF_ERR("Can't run a vertex state shader if it hasn't been loaded");
        }
    #endif
    }

    PPUSH pPush = pDevice->StartPush();

    if (pData != NULL)
    {
        Push4f(pPush, NV097_SET_TRANSFORM_DATA(0),
               pData[0], pData[1], pData[2], pData[3]);

        pPush += 5;
    }

    Push1(pPush, NV097_LAUNCH_TRANSFORM_PROGRAM, Address);

    pDevice->EndPush(pPush + 2);
}

//------------------------------------------------------------------------------
// D3DDevice_LoadVertexShader

extern "C"
void WINAPI D3DDevice_LoadVertexShader(
    DWORD Handle,
    DWORD Address)
{
    COUNT_API(API_D3DDEVICE_LOADVERTEXSHADER);

    CDevice* pDevice = g_pDevice;

    VertexShader* pVertexShader = (VertexShader*) (Handle - D3DFVF_RESERVED0);

    if (DBG_CHECK(TRUE))
    {
        if (!IsVertexProgram(Handle))
        {
            DPF_ERR("Must be a vertex shader program, not an FVF");
        }
    #if DBG
        if (pVertexShader->Signature != 'Vshd')
        {
            DPF_ERR("Invalid vertex shader object (already deleted?)");
        }
    #endif
        if (Address >= VSHADER_PROGRAM_SLOTS)
        {
            DPF_ERR("Start address can't be larger than 135");
        }
        if (Address + pVertexShader->ProgramSize > VSHADER_PROGRAM_SLOTS)
        {
            DPF_ERR("End address larger than 136");
        }

        // Remember which slots have been loaded:

    #if DBG
        memset(&g_LoadedVertexShaderSlot[Address], 1, pVertexShader->ProgramSize);
    #endif
    }

    if (!(pDevice->m_StateFlags & STATE_PUREDEVICE))
    {
        ShadowVertexShaderState(pVertexShader, Address);
    }

    DWORD dwordCount = pVertexShader->ProgramAndConstantsDwords;

    PPUSH pPush = pDevice->StartPush(dwordCount + 2);

    Push1(pPush, NV097_SET_TRANSFORM_PROGRAM_LOAD, Address); 

    memcpy((void*) (pPush + 2), pVertexShader->ProgramAndConstants, 4 * dwordCount);

    PushedRaw(pPush + dwordCount + 2);

    pDevice->EndPush(pPush + dwordCount + 2);
}

//------------------------------------------------------------------------------
// D3DDevice_LoadVertexShaderProgram
//
// NOTE: Like LoadVeretxShader, the read/write/state-shader aspect is ignored
//       on the load.

extern "C"
void WINAPI D3DDevice_LoadVertexShaderProgram(
    CONST DWORD* pFunction,
    DWORD Address)
{
    COUNT_API(API_D3DDEVICE_LOADVERTEXSHADERPROGRAM);

    CDevice* pDevice = g_pDevice;

    // 'shaderLength' ranges from 1 to 136:

    DWORD shaderLength = *((WORD*) pFunction + 1);

    if (DBG_CHECK(TRUE))
    {
        if ((shaderLength < 1) || (shaderLength > VSHADER_PROGRAM_SLOTS))
        {
            DPF_ERR("Length specified in second WORD must be between 1 and 136");
        }
        if (Address >= VSHADER_PROGRAM_SLOTS)
        {
            DPF_ERR("Start address can't be larger than 135");
        }
        if (Address + shaderLength > VSHADER_PROGRAM_SLOTS)
        {
            DPF_ERR("End address larger than 136");
        }

        // Remember which slots have been loaded:

    #if DBG
        memset(&g_LoadedVertexShaderSlot[Address], 1, shaderLength);
    #endif
    }

    DWORD dwordCount = shaderLength * 4;

    if (!(pDevice->m_StateFlags & STATE_PUREDEVICE))
    {
        memcpy(&pDevice->m_VertexShaderProgramSlots[Address][0],
               pFunction + 1,
               dwordCount * sizeof(DWORD));
    }

    PPUSH pPush = pDevice->StartPush(dwordCount + 2 + 
                                (VSHADER_PROGRAM_SLOTS / VSHADER_BATCH_LIMIT));

    Push1(pPush, NV097_SET_TRANSFORM_PROGRAM_LOAD, Address); 

    pPush = ParseProgram(pPush + 2, pFunction + 1, dwordCount);

    PushedRaw(pPush);

    pDevice->EndPush(pPush);
}

//------------------------------------------------------------------------------
// D3DDevice_SelectVertexShaderDirect

extern "C"
void WINAPI D3DDevice_SelectVertexShaderDirect(
    D3DVERTEXATTRIBUTEFORMAT *pVAF,       // DOC: Can be NULL
    DWORD Address)
{
    // This API call is counted as an API_D3DDEVICE_SELECTVERTEXSHADER

    if (DBG_CHECK(TRUE))
    {
#if DBG
        if(pVAF != NULL)
        {
            CheckVertexAttributeFormatStruct(pVAF);
        }
#endif    
    }

    if(pVAF != NULL)
    {
        memcpy(&(g_DirectVertexShader.Slot[0]), pVAF, sizeof(VertexShaderSlot)*16);
        D3DDevice_SelectVertexShader((DWORD)(&g_DirectVertexShader) | D3DFVF_RESERVED0, Address);
    }
    else
    {
        D3DDevice_SelectVertexShader(NULL, Address);
    }
}

//------------------------------------------------------------------------------
// D3DDevice_SelectVertexShader

extern "C"
void WINAPI D3DDevice_SelectVertexShader(
    DWORD Handle,       // DOC: Can be NULL
    DWORD Address)
{
    COUNT_API(API_D3DDEVICE_SELECTVERTEXSHADER);

    CDevice* pDevice = g_pDevice;

    if (DBG_CHECK(TRUE))
    {
        if (Address >= VSHADER_PROGRAM_SLOTS)
        {
            DPF_ERR("Start address can't be larger than 135");
        }
    #if DBG
        if (!g_LoadedVertexShaderSlot[Address])
        {
            DPF_ERR("Can't select a vertex state shader if it hasn't been loaded");
        }
    #endif
        if ((Handle == NULL) && (pDevice->m_pVertexShader == NULL))
        {
            DPF_ERR("Shader handle required in SelectVertexShader when switching "
                    "from fixed-function to vertex shader");
        }
    }

    if (Handle != NULL)
    {
        VertexShader* pVertexShader = (VertexShader*) (Handle - D3DFVF_RESERVED0);

        if (DBG_CHECK(TRUE))
        {
            if (!IsVertexProgram(Handle))
            {
                DPF_ERR("Must be a vertex shader program, not an FVF");
            }
        #if DBG
            if (pVertexShader->Signature != 'Vshd')
            {
                DPF_ERR("Invalid vertex shader object (already deleted?)");
            }
        #endif
        }

        pDevice->m_pVertexShader = pVertexShader;

        pDevice->m_VertexShaderHandle = Handle;

        // The 'D3DDIRTYFLAG_LIGHTS' is really needed only if switching from the
        // fixed function  pipeline to a programmable shader.  But it's not
        // a lot of overhead for the non-fixed-function-pipeline case, so I'm
        // not going to special-case it here:

        D3D__DirtyFlags |= (D3DDIRTYFLAG_VERTEXFORMAT |
                            D3DDIRTYFLAG_LIGHTS);

        // Tell the hardware our mode:

        PPUSH pPush = pDevice->StartPush();

        Push2(pPush, 
              
              NV097_SET_TRANSFORM_EXECUTION_MODE,

              // NV097_SET_TRANSFORM_EXECUTION_MODE:

              (DRF_DEF(097, _SET_TRANSFORM_EXECUTION_MODE, _MODE, _PROGRAM) |
               DRF_DEF(097, _SET_TRANSFORM_EXECUTION_MODE, _RANGE_MODE, _PRIV)),

              // NV097_SET_TRANSFORM_PROGRAM_CXT_WRITE_EN:

              pVertexShader->Flags & VERTEXSHADER_WRITE);

        // Reset the viewport if the fixed-function pipeline was previously
        // active:

        pPush = CommonSetViewport(pDevice, pPush + 3);

        pDevice->EndPush(pPush);
    }

    // Tell the hardware the start location of the current program:

    PPUSH pPush = pDevice->StartPush();

    Push1(pPush, NV097_SET_TRANSFORM_PROGRAM_START, Address); 

    pDevice->EndPush(pPush + 2);

    pDevice->m_VertexShaderStart = Address;   // set shadow value

}

//------------------------------------------------------------------------------
// D3DDevice_GetVertexShaderSize

extern "C"
void WINAPI D3DDevice_GetVertexShaderSize(
    DWORD Handle, 
    UINT* pSize)
{
    COUNT_API(API_D3DDEVICE_GETVERTEXSHADERSIZE);

    VertexShader* pVertexShader = (VertexShader*) (Handle - D3DFVF_RESERVED0);

    if (DBG_CHECK(TRUE))
    {
        if (!IsVertexProgram(Handle))
        {
            DPF_ERR("Must be a vertex shader program, not an FVF");
        }
    #if DBG
        if (pVertexShader->Signature != 'Vshd')
        {
            DPF_ERR("Invalid vertex shader object (already deleted?)");
        }
    #endif
    }

    if (pSize != NULL) 
    {
        *pSize = pVertexShader->ProgramSize;
    }
}

//------------------------------------------------------------------------------
// D3DDevice_GetVertexShaderType

extern "C"
void WINAPI D3DDevice_GetVertexShaderType(
    DWORD Handle, 
    DWORD* pType)
{
    COUNT_API(API_D3DDEVICE_GETVERTEXSHADERTYPE);

    VertexShader* pVertexShader = (VertexShader*) (Handle - D3DFVF_RESERVED0);

    if (DBG_CHECK(TRUE))
    {
        if (!IsVertexProgram(Handle))
        {
            DPF_ERR("Must be a vertex shader program, not an FVF");
        }
    #if DBG
        if (pVertexShader->Signature != 'Vshd')
        {
            DPF_ERR("Invalid vertex shader object (already deleted?)");
        }
    #endif
    }

    DWORD type;

    if (pVertexShader->Flags & VERTEXSHADER_STATE)
    {
        type = D3DSMT_VERTEXSTATESHADER;
    }
    else if (pVertexShader->Flags & VERTEXSHADER_WRITE)
    {
        type = D3DSMT_READWRITE_VERTEXSHADER;
    }
    else 
    {
        type = D3DSMT_VERTEXSHADER;
    }

    if (pType != NULL) 
    {
        *pType = type;
    }
}

//------------------------------------------------------------------------------
// g_FixedFunctionPipelineConstants
//
// These constant register values were copied out of the NV miniport:

D3DCONST DWORD g_FixedFunctionPipelineConstants[] =
{

    0x00000000,   // 0.0
    0x3f000000,   // 0.5
    0x3f800000,   // 1.0
    0x40000000,   // 2.0
    
    0xbf800000,   // -1.0
    0x00000000,   //  0.0
    0x3f800000,   //  1.0
    0x40000000,   //  2.0
    
    0x00000000,   //  0.0
    0x00000000,   //  0.0
    0xbf800000,   // -1.0
    0x00000000,   //  0.0
};

//------------------------------------------------------------------------------
// D3DDevice_SetShaderConstantMode

extern "C"
void WINAPI D3DDevice_SetShaderConstantMode(
    D3DSHADERCONSTANTMODE Mode)
{
    COUNT_API(API_D3DDEVICE_SETSHADERCONSTANTMODE);

    CDevice* pDevice = g_pDevice;

    if (Mode & D3DSCM_NORESERVEDCONSTANTS)
    {
        pDevice->m_StateFlags |= STATE_NORESERVEDCONSTANTS;
    }
    else
    {
        pDevice->m_StateFlags &= ~STATE_NORESERVEDCONSTANTS;
    }

    Mode &= ~D3DSCM_NORESERVEDCONSTANTS;

    if (DBG_CHECK(TRUE))
    {
        if (Mode > D3DSCM_192CONSTANTSANDFIXEDPIPELINE)
        {
            DPF_ERR("Invalid mode");
        }
        if ((pDevice->m_StateFlags & STATE_RECORDBLOCK) &&
            (Mode != D3DSCM_96CONSTANTS))
        {
            DPF_ERR("Can't set constant mode while recording a state block");
        }
    }

    pDevice->m_ConstantMode = Mode;

    if (Mode == D3DSCM_96CONSTANTS)
    {
        // Dirty all of the fixed function T&L constants:

        D3D__DirtyFlags |= (D3DDIRTYFLAG_LIGHTS |
                            D3DDIRTYFLAG_TEXTURE_TRANSFORM |
                            D3DDIRTYFLAG_TRANSFORM);

        // Now reset any remaining fixed function T&L constants that aren't
        // covered by the above:

        PPUSH pPush = pDevice->StartPush();

        // Slot 60 is 'cSMAP', followed by 'cSKIN' and 'cREFL':

        Push1(pPush, NV097_SET_TRANSFORM_CONSTANT_LOAD, NV_IGRAPH_XF_XFCTX_CONS0);

        PushCount(pPush + 2, 
                  NV097_SET_TRANSFORM_CONSTANT(0), 
                  sizeof(g_FixedFunctionPipelineConstants) / 4);

        memcpy((void*) (pPush + 3),
               g_FixedFunctionPipelineConstants, 
               sizeof(g_FixedFunctionPipelineConstants));

        pPush += 3 + sizeof(g_FixedFunctionPipelineConstants) / 4;

        // Our texgen modes always assume an identity texgen plane (unlike
        // in the Nvidia driver, which has to muck with the plane to emulate
        // user clip planes).  

        PushMatrixTransposed(pPush, NV097_SET_TEXGEN_PLANE_S(0, 0), 
                             &g_IdentityMatrix);
        PushMatrixTransposed(pPush + 17, NV097_SET_TEXGEN_PLANE_S(1, 0), 
                             &g_IdentityMatrix);
        PushMatrixTransposed(pPush + 34, NV097_SET_TEXGEN_PLANE_S(2, 0), 
                             &g_IdentityMatrix);
        PushMatrixTransposed(pPush + 51, NV097_SET_TEXGEN_PLANE_S(3, 0), 
                             &g_IdentityMatrix);

        // When we enable FOG_GEN_MODE_PLANAR, we assume we've already 
        // constructed the plane:

        Push4f(pPush + 68, NV097_SET_FOG_PLANE(0), 0.0f, 0.0f, 1.0f, 0.0f);

        pDevice->EndPush(pPush + 73);
    }
}

//------------------------------------------------------------------------------
// D3DDevice_GetShaderConstantMode

extern "C"
void WINAPI D3DDevice_GetShaderConstantMode(
    D3DSHADERCONSTANTMODE *pMode)
{
    COUNT_API(API_D3DDEVICE_GETSHADERCONSTANTMODE);

    if (DBG_CHECK(pMode == NULL))
    {
        DPF_ERR("Null pointer");
    }

    *pMode = g_pDevice->m_ConstantMode;
}

//------------------------------------------------------------------------------
// ParseDeclarationStream
//
// Parses the Vertex Shader declaration token stream that describes the
// vertex format, stream binding, and vertex shader constant registers,
// and correspondingly initializes the VertexShader structure.
//
// Analagous to CVertexShader::create.

VOID ParseDeclarationStream(
    VertexShader* pVertexShader,
    CONST DWORD* pDeclaration,
    BOOL IsFixedFunction)
{
    DWORD offset = 0;
    DWORD streamIndex = 0;
    DWORD count;
    DWORD sizeAndType;
    DWORD dimensionality;
    DWORD reg;
    DWORD slot;
    DWORD address;

    while (TRUE)
    {
        DWORD token = *pDeclaration++;
    
        switch (token & D3DVSD_TOKENTYPEMASK)
        {
        case D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAM):
            ASSERTMSG((token & 0x0ffffff0) == 0,
                      "Bad declaration STREAM token: 0x%lx", token);

            streamIndex = token & 0xf;
            offset = 0;
            break;
    
        case D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAMDATA):
            if (token & 0x10000000)
            {
                // Skip case (both D3DVSD_SKIP and D3DVSD_SKIPBYTES):

                ASSERTMSG((token & 0x07f0ffff) == 0,
                          "Bad declaration SKIP token: 0x%lx", token);

                count = (token & D3DVSD_SKIPCOUNTMASK) >> D3DVSD_SKIPCOUNTSHIFT;

                if (!(token & 0x08000000))
                {
                    count <<= 2;
                }

                offset += count;
            }
            else
            {
                ASSERTMSG((token & 0x0f00ffe0) == 0,
                          "Bad declaration REG token: 0x%lx", token);

                sizeAndType = (token & D3DVSD_DATATYPEMASK) >> D3DVSD_DATATYPESHIFT;
                reg = (token & D3DVSD_VERTEXREGMASK) >> D3DVSD_VERTEXREGSHIFT;

                if (DBG_CHECK(TRUE))
                {
                    if (reg > 15) 
                    {
                        DXGRIP("Can't specify a register more than 15");
                        reg = 15;
                    }
                    if (((sizeAndType & 0xf0) > 0x70) ||
                        ((sizeAndType & 0xf) > 6))
                    {
                        DXGRIP("Invalid type encoding");
                    }
                }

                pVertexShader->Slot[reg].Offset = offset;
                pVertexShader->Slot[reg].StreamIndex = streamIndex;
                pVertexShader->Slot[reg].SizeAndType = sizeAndType;
                pVertexShader->Slot[reg].Flags = AUTONONE;

                if (IsFixedFunction)
                {
                    if ((reg >= D3DVSDE_TEXCOORD0) && (reg <= D3DVSDE_TEXCOORD3))
                    {
                        // Compute dimensionality, watching for the 3W and 
                        // CMP special cases:

                        dimensionality = (sizeAndType & 0xf0) >> 4;
                        if (dimensionality == 7)
                            dimensionality = 4;
                        else if (sizeAndType == D3DVSDT_NORMPACKED3)
                            dimensionality = 3;

                        DWORD shift = 8 * (reg - D3DVSDE_TEXCOORD0);

                        ASSERT((pVertexShader->Dimensionality 
                                    & (0xff << shift)) == 0);

                        pVertexShader->Dimensionality 
                            |= (dimensionality << shift);
                    }
                    if (reg == D3DVSDE_DIFFUSE)
                    {
                        pVertexShader->Flags |= VERTEXSHADER_HASDIFFUSE;
                    }
                    if (reg == D3DVSDE_SPECULAR)
                    {
                        pVertexShader->Flags |= VERTEXSHADER_HASSPECULAR;
                    }
                    if (reg == D3DVSDE_BACKDIFFUSE)
                    {
                        pVertexShader->Flags |= VERTEXSHADER_HASBACKDIFFUSE;
                    }
                    if (reg == D3DVSDE_BACKSPECULAR)
                    {
                        pVertexShader->Flags |= VERTEXSHADER_HASBACKSPECULAR;
                    }
                }

                // Finally, advance the current offset based on the size of 
                // the attribute:

                offset += g_UnitsOfElement[(sizeAndType & 0xf0) >> 4]
                        * g_BytesPerUnit[sizeAndType & 0xf];
            }
            break;

        case D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_TESSELLATOR):
            reg = (token & D3DVSD_VERTEXREGMASK) >> D3DVSD_VERTEXREGSHIFT;

            pVertexShader->Slot[reg].Offset = 0;
            pVertexShader->Slot[reg].StreamIndex = 0;
            pVertexShader->Slot[reg].SizeAndType = SIZEANDTYPE_DISABLED;
            pVertexShader->Slot[reg].Source = (BYTE)
                ((token & D3DVSD_VERTEXREGINMASK) >> D3DVSD_VERTEXREGINSHIFT);

            // Is this a vertex normal definition or a UV definition?

            if (token & 0x10000000)
            {
                pVertexShader->Slot[reg].Flags = AUTOTEXCOORD;
            }
            else
            {
                pVertexShader->Slot[reg].Flags = AUTONORMAL;
            }
            break;

        case D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_CONSTMEM):
            ASSERTMSG((token & 0x01ffff00) == 0,
                      "Bad delcaration CONST token: 0x%lx", token);

            count = (token & D3DVSD_CONSTCOUNTMASK) >> D3DVSD_CONSTCOUNTSHIFT;

            pDeclaration += (4 * count);
            break;

        case D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_NOP):
            break;

        case D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_END):
            return;

        default:
            NODEFAULT("Unidentified token\n");
            DXGRIP("Token type: 0x%lx", token);
        }
    } 
}

//------------------------------------------------------------------------------
// ParseDeclarationConstants
//
// Returns the size in DWORDS.

DWORD ParseDeclarationConstants(
    CONST DWORD* pDeclaration,
    PPUSH pPushStart)
{
    CDevice* pDevice = g_pDevice;
    PPUSH pPush = pPushStart;
    DWORD oldAddress = 0xdeadbeef;
    DWORD size = 0;

    while (TRUE)
    {
        DWORD token = *pDeclaration++;

        if (token == D3DVSD_END())
        {
            ASSERT((pPush == NULL) || (pPush == pPushStart + size));

            return size;
        }

        if (DBG_CHECK(TRUE))
        {
            // Try to catch some invalid tokens:

            if (((token & D3DVSD_TOKENTYPEMASK)
                    != D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_EXT)) &&
                ((token & 0x0000ff00) != 0))
            {
                DPF_ERR("Invalid declaration token (missing D3DVSD_END?)");
            }
        }
        
        if ((token & D3DVSD_TOKENTYPEMASK) 
                == D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_CONSTMEM))
        {
            DWORD count = (token & D3DVSD_CONSTCOUNTMASK) >> 
                D3DVSD_CONSTCOUNTSHIFT;

            DWORD address = (token & D3DVSD_CONSTADDRESSMASK) >> 
                D3DVSD_CONSTADDRESSSHIFT;

            // Note that the macros already pre-bias the constant address
            // by 96:

            if (DBG_CHECK(TRUE))
            {
                if ((address >= VSHADER_CONSTANT_NUM) ||
                    (address + count > VSHADER_CONSTANT_NUM))
                {
                    DPF_ERR("Invalid constant address range (not between -96 "
                            "and 95) (missing D3DVSD_END?)");
                }
                if (!(pDevice->m_StateFlags & STATE_NORESERVEDCONSTANTS) &&
                    (address <= D3DVS_XBOX_RESERVEDCONSTANT2) &&
                    (address + count > D3DVS_XBOX_RESERVEDCONSTANT1))
                {
                    DPF_ERR("Address range can't include reserved addresses -38 "
                            "or -37 (D3DVS_XBOX_RESERVEDCONSTANT1 \nand "
                            "D3DVS_XBOX_RESERVEDCONSTANT2)  (missing D3DVSD_END?)");
                }
            }

            // Set the start address:

            if (address != oldAddress + 1)
            {
                if (pPush)
                {
                    pPush[0] = PUSHER_METHOD(SUBCH_3D, 
                                  NV097_SET_TRANSFORM_CONSTANT_LOAD, 1);
                    pPush[1] = address;
                    pPush += 2;
                }

                size += 2;
            }

            oldAddress = address;

            // The transform constant register is replicated only 32 times,
            // which means that we can only load 8 'slots' in a single batch:

            DWORD batchSize;

            do {
                batchSize = min(count, VSHADER_BATCH_LIMIT);

                if (pPush)
                {
                    *pPush++ = PUSHER_METHOD(SUBCH_3D, 
                               NV097_SET_TRANSFORM_CONSTANT(0), 4 * batchSize);

                    memcpy((void*) pPush, pDeclaration, 4 * batchSize * sizeof(DWORD));

                    pPush += 4 * batchSize;
                }

                pDeclaration += 4 * batchSize;

                size += 4 * batchSize + 1;

                address += batchSize;

            } while ((count -= batchSize) != 0);
        }
    }
}

//------------------------------------------------------------------------------
// RestoreVertexShaders
//
// Intended for use by state blocks and Present to restore any loaded
// vertex shader programs

VOID RestoreVertexShaders(
    CONST DWORD* pProgram,
    DWORD Dwords)
{
    CDevice* pDevice = g_pDevice;

    // Remember which slots have been loaded:

    #if DBG
        memset(&g_LoadedVertexShaderSlot[0], 1, Dwords / 4);
    #endif

    PPUSH pPush = pDevice->StartPush();

    Push1(pPush, NV097_SET_TRANSFORM_PROGRAM_LOAD, 0);

    pPush = ParseProgram(pPush + 2, pProgram, Dwords);

    PushedRaw(pPush);

    pDevice->EndPush(pPush);
}

//------------------------------------------------------------------------------
// D3DDevice_CreateVertexShader

extern "C"
HRESULT WINAPI D3DDevice_CreateVertexShader(
    CONST DWORD* pDeclaration,
    CONST DWORD* pFunction,
    DWORD* pHandle,
    DWORD Usage) 
{ 
    DWORD shaderType;
    DWORD shaderLength;

    COUNT_API(API_D3DDEVICE_CREATEVERTEXSHADER);

    if (pFunction != NULL)
    {
        // Format of vertex shader microcode is (little endian):
        // Byte offset
        //   0..1   WORD - magic number describing type of shader:
        //                 0x2078 - ordinary vertex shader
        //                 0x7778 - read/write vertex shader
        //                 0x7378 - vertex state shader
        //   2..3   WORD - length of shader, in instructions, ranges from 
        //                 1 to 136
        //   4..end the shader microcode.

        shaderType = *((WORD*) pFunction);
        shaderLength = *((WORD*) pFunction + 1);
    }

    if (DBG_CHECK(TRUE))
    {
        if (Usage & ~(D3DUSAGE_PERSISTENTDIFFUSE |
                      D3DUSAGE_PERSISTENTSPECULAR |
                      D3DUSAGE_PERSISTENTBACKDIFFUSE |
                      D3DUSAGE_PERSISTENTBACKSPECULAR))
        {
            DPF_ERR("Invalid usage flag");
        }
        if (pFunction != NULL)
        {
            if (((shaderType != VSHADER_TYPE_ORDINARY) &&
                 (shaderType != VSHADER_TYPE_WRITE) &&
                 (shaderType != VSHADER_TYPE_STATE)) ||
                (shaderLength == 0) ||
                (shaderLength > VSHADER_PROGRAM_SLOTS))
            {
                DPF_ERR("Invalid function header.  Only valid "
                        "Xbox-assembled function declarations are accepted.");
                DPF_ERR("(Perhaps you're calling with a DX8-defined token "
                        "stream?  Use Xgraphics assembler to compile into Xbox "
                        "form.)");
            }

            if ((shaderType == VSHADER_TYPE_STATE) && (pDeclaration != NULL))
            {
                DPF_ERR("State shaders must pass a NULL declaration pointer");
            }
        }
        if ((pDeclaration == NULL) &&
            ((pFunction == NULL) || (shaderType != VSHADER_TYPE_STATE)))
        {
            DPF_ERR("Declaration pointer can be NULL only for state shaders");
        }
    }

    DWORD programSize = 0;

    if (pFunction != NULL)
    {
        // Compute how many bytes we'll need for the program:

        programSize = 16 * shaderLength;

        // Every 32 dwords requires another DWORD to account for a new
        // NV097_SET_TRANSFORM_CONSTANT instruction:

        programSize += 4 * ((programSize + 127) / 128);
    }

    // See how much room we'll need for the constants:

    DWORD constantsSize = 0;

    if (pDeclaration != NULL)
    {
        constantsSize = 4 * ParseDeclarationConstants(pDeclaration, NULL);
    }

    // Compute the total size:

    DWORD programAndConstantsSize = programSize + constantsSize;

    // Sleazy programming note: We have an extra dword at the end because
    // the structure declaration declares 'DWORD ProgramAndConstants[1]':

    VertexShader* pVertexShader = (VertexShader*) MemAllocNoZero(
                        sizeof(*pVertexShader) + programAndConstantsSize);
    if (pVertexShader == NULL)
    {
        return E_OUTOFMEMORY;
    }

    // Zero-init the header:

    ZeroMemory(pVertexShader, sizeof(*pVertexShader));

#if DBG

    pVertexShader->Signature = 'Vshd';

#endif

    pVertexShader->RefCount = 1;

    ASSERT((D3DUSAGE_PERSISTENTDIFFUSE == VERTEXSHADER_HASDIFFUSE) &&
           (D3DUSAGE_PERSISTENTSPECULAR == VERTEXSHADER_HASSPECULAR) &&
           (D3DUSAGE_PERSISTENTBACKDIFFUSE == VERTEXSHADER_HASBACKDIFFUSE) &&
           (D3DUSAGE_PERSISTENTBACKSPECULAR == VERTEXSHADER_HASBACKSPECULAR));

    ASSERT((Usage & ~(D3DUSAGE_PERSISTENTDIFFUSE |
                      D3DUSAGE_PERSISTENTSPECULAR |
                      D3DUSAGE_PERSISTENTBACKDIFFUSE |
                      D3DUSAGE_PERSISTENTBACKSPECULAR)) == 0);

    pVertexShader->Flags = Usage;

    // First disable every slot.  Kelvin doesn't let us use a type of '0' with 
    // a size of '0', so we have to run through and stamp the values:

    for (DWORD i = 0; i < VERTEXSHADER_SLOTS; i++)
    {
        pVertexShader->Slot[i].SizeAndType = SIZEANDTYPE_DISABLED;
    }

    // Parse the stream that describes the vertex format, stream binding, and
    // vertex shader constant registers:

    if (pDeclaration != NULL)
    {
        ParseDeclarationStream(pVertexShader, 
                               pDeclaration, 
                               pFunction == NULL);
    }

    // Assume there's no function:

    DWORD functionDwords = 0;

    // Copy the function declaration, which includes the actual program
    // load and constant setting:

    if (pFunction != NULL)
    {
        pVertexShader->Flags |= VERTEXSHADER_PROGRAM;

        if (shaderType != VSHADER_TYPE_ORDINARY)
        {
            pVertexShader->Flags |= VERTEXSHADER_WRITE;
        }
        if (shaderType == VSHADER_TYPE_STATE)
        {
            pVertexShader->Flags |= VERTEXSHADER_STATE;
        }

        pVertexShader->ProgramSize = shaderLength;

        DWORD* pProgramAndConstants = pVertexShader->ProgramAndConstants;

        functionDwords = ParseProgram(pProgramAndConstants,
                                      pFunction + 1, 
                                      4 * shaderLength) - pProgramAndConstants;

        ASSERT(programSize == 4 * functionDwords);
    }

    // Now parse the constants from the declaration, and add that to
    // our 'ProgramAndConstants' push-buffer snippet:

    if (pDeclaration != NULL)
    {
        ParseDeclarationConstants(
            pDeclaration, 
            pVertexShader->ProgramAndConstants + functionDwords);
    }

    DWORD programAndConstantsDwords = programAndConstantsSize >> 2;

    pVertexShader->ProgramAndConstantsDwords = programAndConstantsDwords;

    // Zero the last byte for easy parsing:

    pVertexShader->ProgramAndConstants[programAndConstantsDwords] = 0;

    // The reserved bit lets us differentiate between an FVF and a vertex
    // shader handle:

    *pHandle = (DWORD) pVertexShader | D3DFVF_RESERVED0;

    return S_OK;
}

//------------------------------------------------------------------------------
// D3DDevice_DeleteVertexShader

extern "C"
void WINAPI D3DDevice_DeleteVertexShader(
    DWORD Handle) 
{ 
    COUNT_API(API_D3DDEVICE_DELETEVERTEXSHADER);

    CDevice* pDevice = g_pDevice;

    VertexShader* pVertexShader = (VertexShader*) (Handle - D3DFVF_RESERVED0);

    if (DBG_CHECK(TRUE))
    {
        if (!IsVertexProgram(Handle))
        {
            DPF_ERR("Invalid vertex shader handle value");
        }

        if ((pDevice->m_pVertexShader == pVertexShader) &&
            (pVertexShader->RefCount == 1))
        {
            DPF_ERR("Can't delete a vertex shader that's currently active");
        }

        #if DBG

            if (pVertexShader->Signature != 'Vshd')
            {
                DPF_ERR("Invalid vertex shader object (already deleted?)");
            }

        #endif
    }

    // We have to employ a reference count because of state blocks:

    if (--pVertexShader->RefCount == 0)
    {
    #if DBG

        pVertexShader->Signature = 'xxxx';

    #endif

        MemFree(pVertexShader);
    }
}

//------------------------------------------------------------------------------
// CommonSetPassthroughProgram
//
// Loads the correct passthrough program for handling XYZRHW, as appropriate 
// for the current fog state.
//
// Dependencies:
//
//      STATE_FOGSOURCEZ
//      STATE_MULTISAMPLING
//      D3DRS_FOGTABLEMODE
//      D3DRS_ZENABLE
//      SetRenderTarget

VOID FASTCALL CommonSetPassthroughProgram(
    CDevice* pDevice)
{
    DWORD programDwords; 
    CONST DWORD* pProgram; 

    if (pDevice->m_pVertexShader->Flags & VERTEXSHADER_PASSTHROUGH)
    {
        if (D3D__RenderState[D3DRS_FOGTABLEMODE] == D3DFOG_NONE)
        {
            programDwords = sizeof(g_PassthruProgramSpecularFog) / sizeof(DWORD);
            pProgram = g_PassthruProgramSpecularFog;
        }
        else if (pDevice->m_StateFlags & STATE_FOGSOURCEZ)
        {
            programDwords = sizeof(g_PassthruProgramZFog) / sizeof(DWORD);
            pProgram = g_PassthruProgramZFog;
        }
        else
        {
            programDwords = sizeof(g_PassthruProgramWFog) / sizeof(DWORD);
            pProgram = g_PassthruProgramWFog;
        }

        // Make sure that our header #define value is correct:

        ASSERT(programDwords <= D3DVS_XBOX_RESERVEDXYZRHWSLOTS * 4);
    
        // 136 program slots / 8 slots per batch = 17 batches at 1 dword each.
        // Plus the 13 dwords for the constant load plus other stuff:
    
        PPUSH pPush = pDevice->StartPush(30 + programDwords);

        // Load the scales and biases for passthrough mode, for use by the 
        // passthrough program:

        Push1(pPush, NV097_SET_TRANSFORM_CONSTANT_LOAD, 0);
        PushCount(pPush + 2, NV097_SET_TRANSFORM_CONSTANT(0), 8);

        FLOAT* pConstant = (FLOAT*) (pPush + 3);

        FLOAT wScale = (D3D__RenderState[D3DRS_ZENABLE] == D3DZB_USEW)
                     ? pDevice->m_InverseWFar * pDevice->m_ZScale
                     : 1.0f;

        pConstant[0] = pDevice->m_SuperSampleScaleX;    // Scale
        pConstant[1] = pDevice->m_SuperSampleScaleY;
        pConstant[2] = pDevice->m_ZScale;
        pConstant[3] = wScale;

        // Adjust for the implicit 0.5 offset that the hardware multisampling 
        // applies:

        FLOAT multiSampleOffset = 0;

        if ((pDevice->m_StateFlags & STATE_MULTISAMPLING) &&
            (D3D__RenderState[D3DRS_MULTISAMPLEANTIALIAS]))
        {
            multiSampleOffset = 0.5f;
        }

        pConstant[4] = pDevice->m_ScreenSpaceOffsetX - multiSampleOffset;
        pConstant[5] = pDevice->m_ScreenSpaceOffsetY - multiSampleOffset;

        pConstant[6] = 0.0f;
        pConstant[7] = 0.0f;
    
        Push1(pPush + 11, NV097_SET_TRANSFORM_PROGRAM_LOAD, 0);

        pPush = ParseProgram(pPush + 13, pProgram, programDwords);
    
        PushedRaw(pPush);
    
        pDevice->EndPush(pPush);
    }
}

//------------------------------------------------------------------------------
// D3DDevice_SetVertexShader
//
// DOC: Calling SetVertexShader will invalidate any programs loaded via
//      LoadVertexShader.

extern "C"
void WINAPI D3DDevice_SetVertexShader(
    DWORD Handle) 
{ 
    VertexShader* pVertexShader;

    COUNT_API(API_D3DDEVICE_SETVERTEXSHADER);

    CDevice *pDevice = g_pDevice;

    if (DBG_CHECK(D3D__DirtyFlags & D3DDIRTYFLAG_DIRECT_INPUT))
    {
        WARNING("SetVertexShader called while SetVertexShaderInput in effect,\n"
                "will be deferred");
    }

    if (Handle == pDevice->m_VertexShaderHandle)
    {
        COUNT_PERF(PERF_REDUNDANT_SETVERTEXSHADER);
    }

    // Get a copy of the current flags for later use, because 
    // InitializeVertexShaderFromFvf can modify the flags in-place:

    DWORD previousFlags = pDevice->m_pVertexShader->Flags;
    DWORD previousDimensionality = pDevice->m_pVertexShader->Dimensionality;

    // We can be passed either an FVF, or a handle to a vertex shader
    // program.  In the latter case, it's actually a pointer with the
    // low bit set:

    if (IsVertexProgram(Handle))
    {
        // Vertex shader program...

        pVertexShader = (VertexShader*) (Handle - D3DFVF_RESERVED0);

        if (DBG_CHECK(TRUE))
        {
        #if DBG
        
            if (pVertexShader->Signature != 'Vshd')
            {
                DPF_ERR("Invalid vertex shader object (already deleted?)");
            }

        #endif
        
            if (!(pVertexShader->Flags & VERTEXSHADER_PROGRAM) &&
                (pDevice->m_ConstantMode == D3DSCM_192CONSTANTS))
            {
                DPF_ERR("Can't use fixed function pipeline if "
                        "D3DSCM_192CONSTANTS is enabled");
            }
        }
    }
    else
    {
        // FVF...

        if (DBG_CHECK(TRUE))
        {
            ValidateFVF(Handle);

            if ((pDevice->m_ConstantMode == D3DSCM_192CONSTANTS) &&
                (Handle != 0) &&
                ((Handle & D3DFVF_POSITION_MASK) != D3DFVF_XYZRHW))
            {
                DPF_ERR("Can't use fixed function pipeline if "
                        "D3DSCM_192CONSTANTS is enabled");
            }
        }

        pVertexShader = &g_FvfVertexShader;

        InitializeVertexShaderFromFvf(pVertexShader, Handle);
    }

    D3D__DirtyFlags |= D3DDIRTYFLAG_VERTEXFORMAT;

    if (previousDimensionality != pVertexShader->Dimensionality)
    {
        // Ugh, the texture transform depends on the number of texture 
        // coordinates and the dimensionality:
    
        D3D__DirtyFlags |= D3DDIRTYFLAG_TEXTURE_TRANSFORM;
    }

    if (previousFlags != pVertexShader->Flags)
    {
        // The presence or absence of specular and diffuse components in the
        // vertex can affect the DX8 material behavior.  Plus vertex programs
        // and pass-through programs have special lighting implications:

        D3D__DirtyFlags |= D3DDIRTYFLAG_LIGHTS;

        // The passthrough program stomps on constants 0 and 1 (-96 and -95
        // in user-speak), so we have to regen the composite matrix (which
        // maps to constants 0 through 3) for the fixed function pipeline
        // when switching away from passthrough.  We always re-dirty when
        // the type changes because a vertex shader program won't cause 
        // LazySetTransform to re-initialize the composite matrix:

        D3D__DirtyFlags |= D3DDIRTYFLAG_TRANSFORM;
    }

    // Remember our new state:

    pDevice->m_pVertexShader = pVertexShader;

    pDevice->m_VertexShaderHandle = Handle;

    if (pVertexShader->Flags & VERTEXSHADER_PROGRAM)
    {
        // SetVertexShader always defaults to slot zero:

        D3DDevice_LoadVertexShader(Handle, 0);
        D3DDevice_SelectVertexShader(Handle, 0);
    }
    else 
    {
        pDevice->m_VertexShaderStart = 0;   // set shadow value

        // If there's no diffuse or specular color in the vertex, 
        // substitute the D3D defaults.
        //
        // Note that because of persistent vertex attributes, we can't
        // simply whack both registers without checking first (because
        // one attribute may be persistent while the other may simply
        // not be present, requiring the default):
        PPUSH pPush = pDevice->StartPush();

        if (!(pVertexShader->Flags & VERTEXSHADER_HASDIFFUSE))
        {
            Push1(pPush, NV097_SET_VERTEX_DATA4UB(SLOT_DIFFUSE), -1);
            pPush += 2;
        }
        if (!(pVertexShader->Flags & VERTEXSHADER_HASSPECULAR))
        {
            Push1(pPush, NV097_SET_VERTEX_DATA4UB(SLOT_SPECULAR), 0);
            pPush += 2;
        }
        if (!(pVertexShader->Flags & VERTEXSHADER_HASBACKDIFFUSE))
        {
            Push1(pPush, NV097_SET_VERTEX_DATA4UB(SLOT_BACK_DIFFUSE), -1);
            pPush += 2;
        }
        if (!(pVertexShader->Flags & VERTEXSHADER_HASBACKSPECULAR))
        {
            Push1(pPush, NV097_SET_VERTEX_DATA4UB(SLOT_BACK_SPECULAR), 0);
            pPush += 2;
        }
        
        if (pVertexShader->Flags & VERTEXSHADER_PASSTHROUGH)
        {
            Push1(pPush, NV097_SET_TRANSFORM_PROGRAM_START, 0); 
    
            Push2(pPush + 2, 
                  NV097_SET_TRANSFORM_EXECUTION_MODE,
    
                  // NV097_SET_TRANSFORM_EXECUTION_MODE:
    
                  (DRF_DEF(097, _SET_TRANSFORM_EXECUTION_MODE, _MODE, _PROGRAM) |
                   DRF_DEF(097, _SET_TRANSFORM_EXECUTION_MODE, _RANGE_MODE, _PRIV)),
    
                  // NV097_SET_TRANSFORM_PROGRAM_CXT_WRITE_EN:
    
                  DRF_DEF (097, _SET_TRANSFORM_PROGRAM_CXT_WRITE_EN, _V, _READ_ONLY));
    
            // Reset the viewport if the fixed-function pipeline was previously
            // active:
    
            pPush = CommonSetViewport(pDevice, pPush + 5);

            pDevice->EndPush(pPush);
    
            // We always load the passthrough program and constants here, 
            // clobbering whatever may have already been in there:
    
            CommonSetPassthroughProgram(pDevice);
    
            // Now note the slots that we've clobbered:
    
            #if DBG
                memset(g_LoadedVertexShaderSlot, 0, D3DVS_XBOX_RESERVEDXYZRHWSLOTS);
            #endif
        }
        else
        {
            // Enable the fixed function pipeline:
    
            Push1(pPush, NV097_SET_TRANSFORM_EXECUTION_MODE, 
                  DRF_DEF(097, _SET_TRANSFORM_EXECUTION_MODE, _MODE, _FIXED) |
                  DRF_DEF(097, _SET_TRANSFORM_EXECUTION_MODE, _RANGE_MODE, _PRIV));
    
            // If a vertex shader program (or passthrough) was previously active,
            // we have to re-initialize the viewport offset:
    
            pPush = CommonSetViewport(pDevice, pPush + 2);

            pDevice->EndPush(pPush);
        }
    }
}

//------------------------------------------------------------------------------
// D3DDevice_GetVertexShader

extern "C"
void WINAPI D3DDevice_GetVertexShader(
    DWORD* pHandle) 
{ 
    if (DBG_CHECK(pHandle == NULL))
    {
        DPF_ERR("NULL pointer");
    }

    COUNT_API(API_D3DDEVICE_GETVERTEXSHADER);

    CDevice* pDevice = g_pDevice;

    // Note that we do NOT increment the reference count (on account of the
    // fact that there's no Release() API for vertex shader objects!).

    *pHandle = pDevice->m_VertexShaderHandle;
}

//------------------------------------------------------------------------------
// D3DDevice_SetVertexShaderConstant
//
// DOC: Addresses D3DVS_XBOX_RESERVEDCONSTANT1 and D3DVS_XBOX_RESERVEDCONSTANT2
//      are reserved

extern "C"
void WINAPI D3DDevice_SetVertexShaderConstant(
    INT Register,
    CONST void* pConstantData,
    DWORD ConstantCount) 
{ 
    COUNT_API(API_D3DDEVICE_SETVERTEXSHADERCONSTANT);

    CDevice* pDevice = g_pDevice;

    if (DBG_CHECK(TRUE))
    {
        INT start = Register;
        INT end = Register + ConstantCount;

        if (pConstantData == NULL)
        {
            DPF_ERR("NULL pointer");
        }
        if ((ConstantCount == 0) || (ConstantCount > VSHADER_CONSTANT_NUM))
        {
            DPF_ERR("Invalid count");
        }
        if ((start < VSHADER_CONSTANT_MIN) || (end > VSHADER_CONSTANT_MAX))
        {
            DPF_ERR("Invalid address range (not between -96 and 95)");
        }
        if (pDevice->m_ConstantMode == D3DSCM_96CONSTANTS)
        {
            if (start < 0)
            {
                DPF_ERR("Negative addresses allowed only if not "
                        "D3DSCM_96CONSTANTS");
            }
        }
        else 
        {
            if (!(pDevice->m_StateFlags & STATE_NORESERVEDCONSTANTS) &&
                (start <= D3DVS_XBOX_RESERVEDCONSTANT2) &&
                (end > D3DVS_XBOX_RESERVEDCONSTANT1))
            {
                DPF_ERR("Address range can't include reserved addresses -38 or "
                        "-37 (D3DVS_XBOX_RESERVEDCONSTANT1 \nand "
                        "D3DVS_XBOX_RESERVEDCONSTANT2)");
            }
        }
    }

    // Registers 0 through 95 get mapped to the hardware's 96 through 191
    // (because the fixed function pipeline uses hardware register 0 through
    // 95).  And -96 through 95 gets mapped to 0 through 95 when not using
    // the fixed function pipeline:

    Register += VSHADER_CONSTANT_BIAS;

    // Convert to number of DWORDs:

    DWORD totalCount = 4 * ConstantCount;

    // Shadow the register constants only if we need to:

    if (!(pDevice->m_StateFlags & STATE_PUREDEVICE))
    {
        memcpy(&pDevice->m_VertexShaderConstants[Register][0],
               pConstantData,
               totalCount * sizeof(FLOAT));
    }

    // We can load a maximum of 192 slots here.  Since each batch
    // can download only 8 slots, we may need to do 24 batches, each
    // of which requires a DWORD of overhead.  We also need 2 DWORDs
    // for setting the initial address.  Hence the magic 26 value:

    PPUSH pPush = pDevice->StartPush(totalCount + 26);

    Push1(pPush, NV097_SET_TRANSFORM_CONSTANT_LOAD, Register);

    // I wrote the following in Asm for two compelling reasons:
    //
    // 1. This routine will be called a lot for vertex shader programs;
    // 2. After calling 'rep movsd', 'esi' and 'edi' are properly advanced,
    //    which C doesn't realize when invoking 'memcpy'.  Consequently,
    //    C does a bunch of extra work to remember the pointers and then 
    //    advance them after the 'rep movsd'.

    _asm {

        mov edi, pPush;
        mov esi, pConstantData
        mov eax, totalCount;
        add edi, 12;        
        cmp eax, 32;
        jle last_chunk;

    main_loop:

        mov ecx, 32;
        mov dword ptr [edi - 4], PUSHER_METHOD(SUBCH_3D, 
                                          NV097_SET_TRANSFORM_CONSTANT(0), 32);
        rep movsd;
        add edi, 4;
        sub eax, 32;
        cmp eax, 32;
        jg main_loop;

    last_chunk:

        mov ecx, eax;
        shl eax, 18;
        or eax, PUSHER_METHOD(SUBCH_3D, NV097_SET_TRANSFORM_CONSTANT(0), 0);
        mov dword ptr [edi - 4], eax;
        rep movsd;
        mov pPush, edi;
    }

    PushedRaw(pPush);

    pDevice->EndPush(pPush);
}

//------------------------------------------------------------------------------
// D3DDevice_GetVertexShaderConstant

extern "C"
void WINAPI D3DDevice_GetVertexShaderConstant(
    INT Register,
    void* pConstantData,
    DWORD ConstantCount) 
{ 
    COUNT_API(API_D3DDEVICE_GETVERTEXSHADERCONSTANT);

    CDevice* pDevice = g_pDevice;

    if (DBG_CHECK(TRUE))
    {
        INT start = Register;
        INT end = Register + ConstantCount;

        if (pConstantData == NULL)
        {
            DPF_ERR("NULL pointer");
        }
        if ((ConstantCount == 0) || (ConstantCount > VSHADER_CONSTANT_NUM))
        {
            DPF_ERR("Invalid count");
        }
        if ((start < VSHADER_CONSTANT_MIN) || (end > VSHADER_CONSTANT_MAX))
        {
            DPF_ERR("Invalid range");
        }
        if (pDevice->m_ConstantMode == D3DSCM_96CONSTANTS)
        {
            if (start < 0)
            {
                DPF_ERR("Negative registers allowed only if not "
                        "D3DSCM_96CONSTANTS");
            }
        }
        else
        {
            if (!(pDevice->m_StateFlags & STATE_NORESERVEDCONSTANTS) &&
                (start <= D3DVS_XBOX_RESERVEDCONSTANT2) &&
                (end > D3DVS_XBOX_RESERVEDCONSTANT1))
            {
                DPF_ERR("Register range can't include reserved -38 or -37");
            }
        }
        if (pDevice->m_StateFlags & STATE_PUREDEVICE)
        {
            DPF_ERR("Can't query the constant register on a pure device");
        }
    }

    // Registers 0 through 95 get mapped to the hardware's 96 through 191
    // (because the fixed function pipeline uses hardware register 0 through
    // 95).  And -96 through 95 gets mapped to 0 through 95 when not using
    // the fixed function pipeline:

    Register += VSHADER_CONSTANT_BIAS;

    memcpy(pConstantData,
           &pDevice->m_VertexShaderConstants[Register][0],
           4 * ConstantCount * sizeof(FLOAT));
}

//------------------------------------------------------------------------------
// D3DDevice_GetVertexShaderDeclaration
//
// The performance of this function is atrocious.  Ask me if I care.

extern "C"
HRESULT WINAPI D3DDevice_GetVertexShaderDeclaration(
    DWORD Handle,
    void* pData,
    DWORD* pSizeOfData) 
{ 
    COUNT_API(API_D3DDEVICE_GETVERTEXSHADERDECLARATION);

    CDevice* pDevice = g_pDevice;

    VertexShader* pVertexShader = (VertexShader*) (Handle - D3DFVF_RESERVED0);

    if (DBG_CHECK(TRUE))
    {
        if (!IsVertexProgram(Handle))
        {
            DPF_ERR("Invalid vertex shader handle value");
        }

        #if DBG

            if (pVertexShader->Signature != 'Vshd')
            {
                DPF_ERR("Invalid vertex shader object (already deleted?)");
            }

        #endif
        
        if (pSizeOfData == NULL)
        {
            DPF_ERR("Can't have a NULL pSizeOfData");
        }
    }

    // We can only return a declaration if there is actually one:

    if (pVertexShader->Flags & VERTEXSHADER_STATE)
    {
        *pSizeOfData = 0;
        return S_OK;
    }

    DWORD* pDst = NULL;

    // We do two passes, the first to count up the size of the structure
    // we'll need, the second to actually copy it:

    while (TRUE)
    {
        // Process stuff stream by stream:
    
        DWORD currentStream = 0xffffffff;
        DWORD index = 0;
        DWORD slot;
    
        for (DWORD stream = 0; stream < 16; stream++)
        {
            // We're on to a new stream, so zero our current end offset (which
            // is the offset one byte past the last attribute that we've 
            // processed so far for this stream):
    
            DWORD currentEndOffset = 0;
    
            // Loop and find all attributes for this stream:

            while (TRUE)
            {
                // Loop through and find the attribute in this stream with the
                // smallest offset equal to or greater than our current end
                // offset:
        
                DWORD offset = 0xffffffff;

                // Always go backwards so that we find the 'virtual' texture
                // slot first:

                DWORD i = VERTEXSHADER_SLOTS - 1;
                do {
                    if ((pVertexShader->Slot[i].StreamIndex == stream) &&
                        (pVertexShader->Slot[i].Offset < offset) &&
                        (pVertexShader->Slot[i].Offset >= currentEndOffset) &&
                        (pVertexShader->Slot[i].Flags == AUTONONE) &&
                        (pVertexShader->Slot[i].SizeAndType != 
                                                        SIZEANDTYPE_DISABLED))
                    {
                        offset = pVertexShader->Slot[i].Offset;
                        slot = i;
                    }

                } while (i-- != 0);

                // If we found no more attributes for this stream, move on to
                // the next stream:
        
                if (offset == 0xffffffff)
                    break;                      // ===========>
    
                // Insert the stream reference if it's new:
    
                if (stream != currentStream)
                {
                    currentStream = stream;
                    if (pDst != NULL)
                    {
                        pDst[index] = D3DVSD_STREAM(stream);
                    }
                    index++;
                }
    
                // Insert any padding that's necessary:
    
                DWORD padding = offset - currentEndOffset;
                while (padding > 0)
                {
                    // The maximum value of a skip is '15':
    
                    DWORD batchSize = min(padding, 15);
    
                    if (pDst != NULL)
                    {
                        pDst[index] = D3DVSD_SKIPBYTES(batchSize);
                    }
    
                    index++;
                    padding -= batchSize;
                }
    
                // Find the D3D type:
    
                DWORD sizeAndType = pVertexShader->Slot[slot].SizeAndType;
    
                // Insert the token:
    
                if (pDst != NULL)
                {
                    pDst[index] = D3DVSD_REG(slot, sizeAndType);
                }
                index++;
    
                // Advance the current offset to account for the size
                // of the attribute:
    
                currentEndOffset = offset 
                                 + g_UnitsOfElement[(sizeAndType & 0xf0) >> 4]
                                 * g_BytesPerUnit[sizeAndType & 0xf];

                ASSERT(currentEndOffset != offset);
            }
        }
    
        // Handle the tessellator tokens, which aren't related to a stream:
    
        for (slot = 0; slot < VERTEXSHADER_SLOTS; slot++)
        {
            if (pVertexShader->Slot[slot].Flags == AUTOTEXCOORD)
            {
                if (pDst != NULL)
                {
                    pDst[index] = D3DVSD_TESSUV(slot);
                }
                index++;
            }
            else if (pVertexShader->Slot[slot].Flags == AUTONORMAL)
            {
                if (pDst != NULL)
                {
                    pDst[index] = D3DVSD_TESSNORMAL(
                        pVertexShader->Slot[slot].Source, slot);
                }
                index++;
            }
        }
    
        // Now handle the constant registers:
    
        DWORD* pProgramAndConstants = pVertexShader->ProgramAndConstants;
        FLOAT* pConstants;
        DWORD constantSlot;
        DWORD methodEncode;

        while (methodEncode = *pProgramAndConstants++)
        {
            DWORD count = methodEncode >> 18;   // Number of dwords
            ASSERT(count != 0);
    
            if (count == 1)
            {
                constantSlot = *pProgramAndConstants;
    
                ASSERT(constantSlot < VSHADER_CONSTANT_NUM);
                ASSERT((methodEncode & 0xffff) 
                  == PUSHER_METHOD(SUBCH_3D, NV097_SET_TRANSFORM_CONSTANT_LOAD, 
                                     0));
            }
            else if ((methodEncode & 0xffff)
                == PUSHER_METHOD(SUBCH_3D, NV097_SET_TRANSFORM_CONSTANT(0), 0))
            {
                ASSERT(((count & 3) == 0) && (count < VSHADER_PROGRAM_SLOTS*4));
                ASSERT((methodEncode & 0xffff) 
                    == PUSHER_METHOD(SUBCH_3D, NV097_SET_TRANSFORM_CONSTANT(0), 
                                       0));
    
                if (pDst != NULL)
                {
                    DWORD slotCount = count >> 2;
                    ASSERT(slotCount <= 15);
    
                    pDst[index] = D3DVSD_CONST(
                        constantSlot - VSHADER_CONSTANT_BIAS, slotCount);

                    memcpy(&pDst[index + 1], 
                           pProgramAndConstants, 
                           count * sizeof(DWORD));
                }
    
                index += 1 + count;
            }
    
            pProgramAndConstants += count;
        }

        // Finally, add the end token:

        if (pDst != NULL)
        {
            pDst[index] = D3DVSD_END();
        }
        index++;

        // See if we're done the second pass:

        if (pDst != NULL)
            return S_OK;

        // Okay, we've only completed the first pass so far, but now we
        // know the size of the buffer we'll need.

        DWORD sizeOfData = index * sizeof(DWORD);
        if (sizeOfData > *pSizeOfData)
        {
            *pSizeOfData = sizeOfData;
            return (pData == NULL) ? S_OK : D3DERR_MOREDATA;
        }

        *pSizeOfData = sizeOfData;
        if (pData == NULL)
            return S_OK;

        // Set up for the second pass:

        pDst = (DWORD*) pData;
    }
}

//------------------------------------------------------------------------------
// D3DDevice_GetVertexShaderFunction

extern "C"
HRESULT WINAPI D3DDevice_GetVertexShaderFunction(
    DWORD Handle,
    void* pData,
    DWORD* pSizeOfData) 
{ 
    COUNT_API(API_D3DDEVICE_GETVERTEXSHADERFUNCTION);

    CDevice* pDevice = g_pDevice;

    VertexShader* pVertexShader = (VertexShader*) (Handle - D3DFVF_RESERVED0);

    if (DBG_CHECK(TRUE))
    {
        if (!IsVertexProgram(Handle))
        {
            DPF_ERR("Invalid vertex shader handle value");
        }

        #if DBG

            if (pVertexShader->Signature != 'Vshd')
            {
                DPF_ERR("Invalid vertex shader object (already deleted?)");
            }

        #endif
        
        if (pSizeOfData == NULL)
        {
            DPF_ERR("Can't have a NULL pSizeOfData");
        }
    }

    // We can only return a function if there's actually a program:

    if (!(pVertexShader->Flags & VERTEXSHADER_PROGRAM))
    {
        *pSizeOfData = 0;
        return S_OK;
    }

    // There's one DWORD of type/size, followed by 4 DWORDs per slot:

    DWORD size = 16 * pVertexShader->ProgramSize;

    DWORD sizeOfData = 4 + size;

    if (sizeOfData > *pSizeOfData)
    {
        *pSizeOfData = sizeOfData;
        return (pData == NULL) ? S_OK : D3DERR_MOREDATA;
    }

    *pSizeOfData = sizeOfData;
    if (pData == NULL)
        return S_OK;

    // Skip the first DWORD of the program, which is always
    // NV097_SET_TRANSFORM_PROGRAM:

    BYTE* pSrc = (BYTE*) (pVertexShader->ProgramAndConstants + 1);
    BYTE* pDst = (BYTE*) (pData);

    DWORD type = VSHADER_TYPE_ORDINARY;

    if (pVertexShader->Flags & VERTEXSHADER_STATE)
    {
        type = VSHADER_TYPE_STATE;
    }
    else if (pVertexShader->Flags & VERTEXSHADER_WRITE)
    {
        type = VSHADER_TYPE_WRITE;
    }

    *((DWORD*) pDst) = type | (pVertexShader->ProgramSize << 16);
    pDst += 4;

    // Skip the DWORDs between batches:

    DWORD batchSize;
    do {
        batchSize = min(size, 16 * VSHADER_BATCH_LIMIT);

        memcpy(pDst, pSrc, batchSize);
        pDst += batchSize;
        pSrc += batchSize + 4;

    } while ((size -= batchSize) != 0);

    ASSERT((DWORD) pDst - (DWORD) pData == sizeOfData);

    return S_OK;
}


//------------------------------------------------------------------------------
// D3DDevice_SetVertexShaderInputDirect

extern "C"
void WINAPI D3DDevice_SetVertexShaderInputDirect(
    D3DVERTEXATTRIBUTEFORMAT *pVAF,
    UINT StreamCount,
    CONST D3DSTREAM_INPUT *pStreamInputs)
{
    // This API call is counted as an API_D3DDEVICE_SETVERTEXSHADERINPUT
    
    if (DBG_CHECK(TRUE))
    {
#if DBG
        if(pVAF != NULL)
        {
            CheckVertexAttributeFormatStruct(pVAF);
        }
#endif    
    }

    if(pVAF != NULL)
    {
        memcpy(&(g_DirectVertexShader.Slot[0]), pVAF, sizeof(VertexShaderSlot)*16);
        D3DDevice_SetVertexShaderInput((DWORD)(&g_DirectVertexShader) | D3DFVF_RESERVED0, StreamCount, pStreamInputs);
    }
    else
    {
        D3DDevice_SetVertexShaderInput(0, StreamCount, pStreamInputs);
    }
}

//------------------------------------------------------------------------------
// D3DDevice_SetVertexShaderInput

extern "C"
void WINAPI D3DDevice_SetVertexShaderInput(
    DWORD Handle,
    UINT StreamCount,
    CONST D3DSTREAM_INPUT *pStreamInputs)
{
    COUNT_API(API_D3DDEVICE_SETVERTEXSHADERINPUT);

    DWORD i;

    CDevice* pDevice = g_pDevice;

    // Let them go back to the old way of doing things:

    if (Handle == 0)
    {
        if (DBG_CHECK(TRUE))
        {
            if ((StreamCount != 0) || (pStreamInputs != NULL))
            {
                DPF_ERR("StreamCount and pStreamInputs must be zero when NULL "
                        "handle");
            }
        }

        D3D__DirtyFlags &= ~D3DDIRTYFLAG_DIRECT_INPUT;
        D3D__DirtyFlags |= D3DDIRTYFLAG_VERTEXFORMAT;

        // Release all VBs:

        for (i = 0; i < pDevice->m_VertexShaderInputCount; i++)
        {
            D3DVertexBuffer* pVertexBuffer 
                = pDevice->m_VertexShaderInputStream[i].VertexBuffer;

            pDevice->RecordResourceReadPush(pVertexBuffer);

            InternalRelease(pVertexBuffer);
        }

        pDevice->m_VertexShaderInputCount = 0;

        return;
    }

    VertexShader *pVertexShader = (VertexShader*) (Handle - D3DFVF_RESERVED0);

    if (DBG_CHECK(TRUE))
    {
        if (!IsVertexProgram(Handle))
        {
            DPF_ERR("Must be a vertex shader program, not an FVF");
        }
    #if DBG
        if (pVertexShader->Signature != 'Vshd')
        {
            DPF_ERR("Invalid vertex shader object (already deleted?)");
        }
    #endif
        if ((StreamCount == 0) || (StreamCount > 15))
        {
            DPF_ERR("Stream count can't be 0 or more than 15");
        }
        for (i = 0; i < StreamCount; i++)
        {
            if (pStreamInputs[i].VertexBuffer == NULL)
            {
                DPF_ERR("Can't specify NULL VertexBuffer");
            }
            if (pStreamInputs[i].Stride > 255)
            {
                DPF_ERR("Can't have a stride more than 255");
            }
        }
        if (((D3D__TextureState[0][D3DTSS_TEXCOORDINDEX] & 0xffff) != 0) ||
            ((D3D__TextureState[1][D3DTSS_TEXCOORDINDEX] & 0xffff) != 1) ||
            ((D3D__TextureState[2][D3DTSS_TEXCOORDINDEX] & 0xffff) != 2) ||
            ((D3D__TextureState[3][D3DTSS_TEXCOORDINDEX] & 0xffff) != 3))
        {
            DPF_ERR("D3DTSS_TEXCOORDINDEX mapping for every stage must be "
                    "identity");
        }
    }

    // Handle the reference counts.  Note that we do NOT reference count
    // the vertex shader (just like SetVertexShader).

    for (i = 0; i < StreamCount; i++)
    {
        InternalAddRef(pStreamInputs[i].VertexBuffer);
    }

    for (i = 0; i < pDevice->m_VertexShaderInputCount; i++)
    {
        D3DVertexBuffer* pVertexBuffer 
            = pDevice->m_VertexShaderInputStream[i].VertexBuffer;

        pDevice->RecordResourceReadPush(pVertexBuffer);

        InternalRelease(pVertexBuffer);
    }

    // Save our state:

    D3D__DirtyFlags &= ~D3DDIRTYFLAG_VERTEXFORMAT;
    D3D__DirtyFlags |= D3DDIRTYFLAG_DIRECT_INPUT;

    pDevice->m_VertexShaderInputHandle = Handle;
    pDevice->m_VertexShaderInputCount = StreamCount;
    memcpy(pDevice->m_VertexShaderInputStream, 
           pStreamInputs, 
           StreamCount * sizeof(pStreamInputs[0]));

    PPUSH pPush = pDevice->StartPush();
    DWORD format[16];

    // Hit the registers:

    PushCount(pPush, NV097_SET_VERTEX_DATA_ARRAY_OFFSET(0), 16);

    for (i = 0; i < 16; i++)
    {
        VertexShaderSlot *pSlot = &pVertexShader->Slot[i];

        if (DBG_CHECK(pSlot->StreamIndex >= StreamCount))
        {
            DPF_ERR("Vertex Shader references more streams than given to "
                    "SetVertexShaderInput");
        }

        CONST D3DSTREAM_INPUT* pStreamInput = &pStreamInputs[pSlot->StreamIndex];

        DWORD offset = pStreamInput->VertexBuffer->Data
                     + pStreamInput->Offset
                     + pSlot->Offset;

        pPush[1 + i] = offset;

        format[i] = (pStreamInput->Stride << 8) + pSlot->SizeAndType;
    }

    PushCount(pPush + 17, NV097_SET_VERTEX_DATA_ARRAY_FORMAT(0), 16);
    memcpy((VOID*) (pPush + 18), format, 16*sizeof(DWORD));

    pDevice->EndPush(pPush + 34);
}

//------------------------------------------------------------------------------
// D3DDevice_GetVertexShaderInput

extern "C"
HRESULT WINAPI D3DDevice_GetVertexShaderInput(
    DWORD *pHandle,
    UINT *pStreamCount,
    D3DSTREAM_INPUT *pStreamInputs) // May be NULL
{
    COUNT_API(API_D3DDEVICE_GETVERTEXSHADERINPUT);

    CDevice* pDevice = g_pDevice;

    if (pStreamCount)
    {
        *pStreamCount = pDevice->m_VertexShaderInputCount;
    }
    if (pHandle)
    {
        *pHandle = pDevice->m_VertexShaderInputHandle;
    }
    if (pStreamInputs)
    {
        memcpy(pStreamInputs, 
               pDevice->m_VertexShaderInputStream, 
               pDevice->m_VertexShaderInputCount  * sizeof(pStreamInputs[0]));
    }

    return (D3D__DirtyFlags & D3DDIRTYFLAG_DIRECT_INPUT) ? S_OK : S_FALSE;
}

//------------------------------------------------------------------------------
// D3DDevice_GetVertexShaderInput
//
// Checks to make sure that valid formats have been provided in the 
// VertexAttributeFormat Struct and also that no formats overlap in a stream.
// pVAF must not be NULL.

#if DBG
void CheckVertexAttributeFormatStruct(D3DVERTEXATTRIBUTEFORMAT *pVAF)
{
    char buf[256];
    UINT i,j, begin, end, size;
    BYTE type;
    
    // check for valid types and sizes
    for(i=0; i<16; i++)
    {
        type = (BYTE)(pVAF->Input[i].Format & 0xf);
        size = pVAF->Input[i].Format >> 4;     // check upper bits, too
        if(((type == 0) && (size != 4)) ||
           ((type == 1) && ((size < 1) || (size > 4))) ||
           ((type == 2) && ((size == 5) || (size == 6) || (size > 7))) ||
           ((type == 3)) ||
           ((type == 4) && ((size < 1) || (size > 4))) ||
           ((type == 5) && ((size < 1) || (size > 4))) ||
           ((type == 6) && (size != 1)) ||
           (type > 6))
        {
            sprintf(buf, "Invalid Format in Input %d of D3DVERTEXATTRIBUTEFORMAT Structure", i);
            DPF_ERR(buf);
        }
        // Check for overlapping offsets
        if(pVAF->Input[i].Format != SIZEANDTYPE_DISABLED)
        {
            begin = pVAF->Input[i].Offset;
            end = begin - 1 +
                  g_UnitsOfElement[size]* 
                  g_BytesPerUnit[type]; // this is the extent of this attribute
            // check against other attributes
            for(j=i+1; j<16; j++)
            {
                if(pVAF->Input[j].Format != SIZEANDTYPE_DISABLED)
                {
                    if(pVAF->Input[i].StreamIndex != 
                       pVAF->Input[j].StreamIndex) continue; // different stream
                    
                    UINT begin2 = pVAF->Input[j].Offset;
                    if(begin2 > end) continue;  // can't overlap
                    
                    UINT end2 = begin2 - 1 + 
                                g_UnitsOfElement[pVAF->Input[j].Format >> 4] * 
                                g_BytesPerUnit[pVAF->Input[j].Format & 0xf];
                    if(end2 >= begin)
                    {
                        sprintf(buf, "Invalid Format in D3DVERTEXATTRIBUTEFORMAT Structure: Input %d and Input %d overlap", i, j);
                        DPF_ERR(buf);
                    }
                }
            }
        }
    }
}
#endif // DBG

} // end of namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\core\CD3DXBuffer.cpp ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       CBuffer.cpp
//  Content:    Buffer object
//
///////////////////////////////////////////////////////////////////////////

#include "pchcore.h"

CD3DXBuffer::CD3DXBuffer()
{
    m_pbBuffer = NULL;
    m_dwSize = 0;
    m_cRef = 1;
}


CD3DXBuffer::~CD3DXBuffer()
{
    if(m_pbBuffer)
        delete [] m_pbBuffer;
}


HRESULT
CD3DXBuffer::Init(DWORD dwSize)
{
    m_dwSize = dwSize;

    m_pbBuffer = new BYTE[dwSize];
    if (m_pbBuffer == NULL)
        return E_OUTOFMEMORY;
    else
        return S_OK;
}


// IUnknown
STDMETHODIMP
CD3DXBuffer::QueryInterface(REFIID riid, LPVOID *ppv)
{
    *ppv=NULL;
    if (riid == IID_IUnknown)
        *ppv=(IUnknown*)this;
    else if (riid == IID_ID3DXBuffer)
        *ppv=(ID3DXBuffer*)this;
    else
        return E_NOINTERFACE;

    ((LPUNKNOWN)*ppv)->AddRef();

    return S_OK;
}


ULONG STDMETHODCALLTYPE
CD3DXBuffer::AddRef()
{
    m_cRef += 1;
    return m_cRef;
}


ULONG STDMETHODCALLTYPE
CD3DXBuffer::Release()
{
    ULONG cRef = m_cRef;
    m_cRef -= 1;

    if (cRef == 1)
        delete this;

    return cRef-1;
}


PVOID STDMETHODCALLTYPE
CD3DXBuffer::GetBufferPointer()
{
    return m_pbBuffer;
}


DWORD STDMETHODCALLTYPE
CD3DXBuffer::GetBufferSize()
{
    return m_dwSize;
}

HRESULT CD3DXBuffer::Grow(DWORD dwSize)
{
    if (dwSize > m_dwSize)
    {
        // Allocate new buffer
        PBYTE pBuffer = new BYTE[dwSize];
        if (pBuffer == NULL)
            return E_OUTOFMEMORY;

        // Copy contents
        memcpy(pBuffer, m_pbBuffer, m_dwSize);

        // Delete old buffer
        delete [] m_pbBuffer;
        m_pbBuffer = pBuffer;
        m_dwSize = dwSize;
    }
    return S_OK;
}

CD3DXStringBuffer::CD3DXStringBuffer()
{
    m_pStringLow = NULL;
    m_pStringHigh = NULL;
}

HRESULT CD3DXStringBuffer::Init(DWORD size)
{
    HRESULT hr = CD3DXBuffer::Init(size);
    if (FAILED(hr))
        return hr;
    m_pStringLow = reinterpret_cast<char**>(m_pbBuffer);
    m_pStringHigh = reinterpret_cast<char*>(m_pbBuffer + m_dwSize);
    return S_OK;
}

HRESULT D3DXCreateStringBuffer(DWORD size, CD3DXStringBuffer** ppBuffer)
{
    CD3DXStringBuffer *pBuffer = NULL;
    HRESULT hr = S_OK;

    // first allocate the container
    pBuffer = new CD3DXStringBuffer();
    if (pBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    // now allocate the buffer
    hr = pBuffer->Init(size);
    if (FAILED(hr))
        goto e_Exit;

    *ppBuffer = pBuffer;
    pBuffer = NULL;

e_Exit:
    delete pBuffer;
    return hr;
}

HRESULT CD3DXStringBuffer::AddString(char* pString)
{
    DWORD size = strlen(pString);
    if (reinterpret_cast<char*>(m_pStringLow + 1) > m_pStringHigh - size - 1)
    {
        DWORD newSize = max(m_dwSize + size, static_cast<DWORD>(m_dwSize * 1.2f));
        // Allocate new buffer
        PBYTE pBuffer = new BYTE[newSize];
        if (pBuffer == NULL)
            return E_OUTOFMEMORY;

        // Compute new pointers
        DWORD stringSize = m_dwSize - (DWORD)(((LPBYTE)m_pStringHigh) - m_pbBuffer);
        char* pStringHigh = reinterpret_cast<char*>(pBuffer + newSize - stringSize);

        // Copy strings
        memcpy(pStringHigh, m_pStringHigh, stringSize);

        // Update string pointers
        int offset = (int)(pStringHigh - m_pStringHigh);
        char** pStringLow = reinterpret_cast<char**>(pBuffer);
        for (char** t = reinterpret_cast<char**>(m_pbBuffer); t < m_pStringLow; ++t)
        {
            *pStringLow = *t + offset;
            pStringLow++;
        }

        // Delete old buffer & update data
        delete [] m_pbBuffer;
        m_pbBuffer = pBuffer;
        m_dwSize = newSize;
        m_pStringLow = pStringLow;
        m_pStringHigh = pStringHigh;
    }
    m_pStringHigh -= size + 1;
    strcpy(m_pStringHigh, pString);
    *m_pStringLow = m_pStringHigh;
    m_pStringLow++;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\core\CD3DXFile.cpp ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       CD3DXFile.cpp
//  Content:    Memory-mappied files
//
///////////////////////////////////////////////////////////////////////////

#include "pchcore.h"


///////////////////////////////////////////////////////////////////////////
// CD3DXFile //////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


CD3DXFile::CD3DXFile()
{
    m_pvData   = NULL;
    m_cbData   = 0;
}


CD3DXFile::~CD3DXFile()
{
    Close();
}


HRESULT CD3DXFile::Open(LPCVOID pFile, BOOL bUnicode)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;

    if(!pFile)
        return E_INVALIDARG;

    char *szFile, szFileBuf[_MAX_PATH];

    if (bUnicode)
    {
        WideCharToMultiByte(CP_ACP, 0, (LPCWSTR)pFile, -1, szFileBuf, _MAX_PATH, NULL, NULL);
        szFile = szFileBuf;
    }
    else
    {
        szFile = (char *)pFile;
    }

    hFile = CreateFileA(szFile, GENERIC_READ, FILE_SHARE_READ, NULL,
            OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

    if(INVALID_HANDLE_VALUE == hFile)
        goto LError;

    // Get file size
    m_cbData = GetFileSize(hFile, NULL);

    if(0xffffffff == m_cbData)
        goto LError;

    // Make room.
    m_pvData = (const void *)malloc(m_cbData);

    if (!m_pvData)
    {
        goto LError;
    }

    // Read it in.
    DWORD dwRead;

    if (!ReadFile(hFile, (void *)m_pvData, m_cbData, &dwRead, NULL))
    {
        goto LError;
    }

    CloseHandle(hFile);

    return S_OK;

LError:
    DWORD dwError;
    dwError = GetLastError();

    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT CD3DXFile::Close()
{
    if(m_pvData)
    {
        free((void *)m_pvData);

        m_pvData = NULL;
        m_cbData = 0;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\core\cd3dxrendertoenvmap.cpp ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       CD3DXRenderToEnvMap.cpp
//  Content:    RenderToEnvMap object
//
///////////////////////////////////////////////////////////////////////////

#include "pchcore.h"


#define MODE_NONE           0
#define MODE_CUBE           1
#define MODE_SPHERE         2
#define MODE_HEMISPHERE     3
#define MODE_PARABOLIC      4



CD3DXRenderToEnvMap::CD3DXRenderToEnvMap()
{
    UINT i;

    m_cRef      = 1;
    m_pDevice   = NULL;
    m_pColor    = NULL;
    m_pDepth    = NULL;
    m_pColorOld = NULL;
    m_pDepthOld = NULL;
    m_pCubeTex  = NULL;

    for(i = 0; i < 6; i++)
        m_pFace[i] = NULL;

    for(i = 0; i < 2; i++)
        m_pTex[i] = NULL;

    m_dwMode = 0;
    m_dwStateBlock = 0;
    m_bInScene = FALSE;
}


CD3DXRenderToEnvMap::~CD3DXRenderToEnvMap()
{
    UINT i;

    if(m_pDevice && m_dwStateBlock)
        m_pDevice->DeleteStateBlock(m_dwStateBlock);

    RELEASE(m_pDevice);
    RELEASE(m_pColor);
    RELEASE(m_pDepth);
    RELEASE(m_pColorOld);
    RELEASE(m_pDepthOld);
    RELEASE(m_pCubeTex);

    for(i = 0; i < 6; i++)
        RELEASE(m_pFace[i]);

    for(i = 0; i < 2; i++)
        RELEASE(m_pTex[i]);
}


HRESULT 
CD3DXRenderToEnvMap::Init(LPDIRECT3DDEVICE8 pDevice, UINT Size, D3DFORMAT Format, 
    BOOL DepthStencil, D3DFORMAT DepthStencilFormat)
{
    if(!pDevice)
    {
        DPF(0, "pDevice pointer is invalid");
        return D3DERR_INVALIDCALL;
    }

    D3DXASSERT(m_pDevice == NULL);

    m_pDevice = pDevice;
    m_pDevice->AddRef();

    m_Desc.Size               = Size;
    m_Desc.Format             = Format;
    m_Desc.DepthStencil       = DepthStencil;
    m_Desc.DepthStencilFormat = DepthStencilFormat;

    m_Viewport.X      = 0;
    m_Viewport.Y      = 0;
    m_Viewport.Width  = Size;
    m_Viewport.Height = Size;
    m_Viewport.MinZ   = 0.0f;
    m_Viewport.MaxZ   = 1.0f;

    return S_OK;
}



HRESULT
CD3DXRenderToEnvMap::Begin()
{
    // Create StateBlock if needed
    if(!m_dwStateBlock)
    {
        m_pDevice->BeginStateBlock();
        m_pDevice->SetViewport(&m_Viewport);
        m_pDevice->EndStateBlock(&m_dwStateBlock);
    }

    m_pDevice->CaptureStateBlock(m_dwStateBlock);
    m_pDevice->GetRenderTarget(&m_pColorOld);
    m_pDevice->GetDepthStencilSurface(&m_pDepthOld);
    m_pDevice->SetViewport(&m_Viewport);

    return S_OK;
}


HRESULT
CD3DXRenderToEnvMap::BeginScene(D3DCUBEMAP_FACES Face)
{
    HRESULT hr;
    D3DSURFACE_DESC desc;
    LPDIRECT3DSURFACE8 pSurf = NULL;


    if(MODE_CUBE == m_dwMode)
    {
        m_pCubeTex->GetLevelDesc(0, &desc);
    }
    else
    {
        // Create face texture, if needed
        if(!m_pFace[Face])
        {
            if(FAILED(hr = m_pDevice->CreateTexture(m_Desc.Size, m_Desc.Size, 1, D3DUSAGE_RENDERTARGET, m_Desc.Format, D3DPOOL_DEFAULT, &m_pFace[Face])) &&
               FAILED(hr = m_pDevice->CreateTexture(m_Desc.Size, m_Desc.Size, 1, 0, m_Desc.Format, D3DPOOL_DEFAULT, &m_pFace[Face])))
            {
                DPF(0, "CreateTexture failed");
                return hr;
            }               
        }

        m_pFace[Face]->GetLevelDesc(0, &desc);
    }


    m_bRenderTarget = (desc.Usage & D3DUSAGE_RENDERTARGET);

    if(!m_bRenderTarget)
    {
        // Create color buffer, if needed
        if(!m_pColor)
        {
            if(FAILED(hr = m_pDevice->CreateRenderTarget(m_Desc.Size, m_Desc.Size, 
                m_Desc.Format, D3DMULTISAMPLE_NONE, TRUE, &m_pColor)))
            {
                DPF(0, "CreateRenderTarget failed");
                return hr;
            }
        }

        pSurf = m_pColor;
    }
    else 
    {
        if(MODE_CUBE == m_dwMode)
            m_pCubeTex->GetCubeMapSurface(Face, 0, &pSurf);
        else
            m_pFace[Face]->GetSurfaceLevel(0, &pSurf);
    }


    // Create depth-stencil, if needed
    if(!m_pDepth && m_Desc.DepthStencil)
    {
        if(FAILED(hr = m_pDevice->CreateDepthStencilSurface(m_Desc.Size,
            m_Desc.Size, 
            m_Desc.DepthStencilFormat, D3DMULTISAMPLE_NONE, &m_pDepth)))
        {
            DPF(0, "CreateDepthStencilSurface failed");
            return hr;
        }
    }


    // Set rendertarget
    m_pDevice->SetRenderTarget(pSurf, m_pDepth);

    if(m_bRenderTarget)
        pSurf->Release();


    if(FAILED(hr = m_pDevice->BeginScene()))
        return hr;

    m_bInScene = TRUE;
    m_Face = Face;
    return S_OK;
}


HRESULT
CD3DXRenderToEnvMap::EndScene()
{
    HRESULT hr;

    if(!m_bInScene)
        return S_OK;

    if(FAILED(hr = m_pDevice->EndScene()))
        return hr;
    
    if(!m_bRenderTarget)
    {
        LPDIRECT3DSURFACE8 pSurf;

        if(MODE_CUBE == m_dwMode)
            hr = m_pCubeTex->GetCubeMapSurface(m_Face, 0, &pSurf);
        else
            hr = m_pFace[m_Face]->GetSurfaceLevel(0, &pSurf);

        if(FAILED(hr))
            return hr;

        m_pDevice->CopyRects(m_pColor, NULL, 0, pSurf, NULL);
        pSurf->Release();
    }

    m_bInScene = FALSE;
    return S_OK;
}


HRESULT 
CD3DXRenderToEnvMap::RenderSphere()
{

    return E_NOTIMPL;
}


HRESULT 
CD3DXRenderToEnvMap::RenderHemisphere()
{
    return E_NOTIMPL;
}


HRESULT 
CD3DXRenderToEnvMap::RenderParabolic()
{
    return E_NOTIMPL;
}





// IUnknown
STDMETHODIMP
CD3DXRenderToEnvMap::QueryInterface(REFIID riid, LPVOID *ppv)
{
    *ppv=NULL;
    if (riid == IID_IUnknown)
        *ppv=(IUnknown*)this;
    else if (riid == IID_ID3DXRenderToEnvMap)
        *ppv=(ID3DXRenderToEnvMap*)this;
    else
        return E_NOINTERFACE;

    ((LPUNKNOWN)*ppv)->AddRef();

    return S_OK;
}


ULONG STDMETHODCALLTYPE
CD3DXRenderToEnvMap::AddRef()
{
    m_cRef += 1;
    return m_cRef;
}


ULONG STDMETHODCALLTYPE
CD3DXRenderToEnvMap::Release()
{
    ULONG cRef = m_cRef;
    m_cRef -= 1;

    if (cRef == 1)
        delete this;

    return cRef-1;
}


// ID3DXRenderToEnvMap
STDMETHODIMP
CD3DXRenderToEnvMap::GetDevice(LPDIRECT3DDEVICE8* ppDevice)
{
    if(!ppDevice)
    {
        DPF(0, "ppDevice pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    *ppDevice = m_pDevice;
    m_pDevice->AddRef();
    return S_OK;
}


STDMETHODIMP
CD3DXRenderToEnvMap::GetDesc(D3DXRTE_DESC* pDesc)
{
    if(!pDesc)
    {
        DPF(0, "pDesc pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    *pDesc = m_Desc;
    return S_OK;
}


STDMETHODIMP 
CD3DXRenderToEnvMap::BeginCube(LPDIRECT3DCUBETEXTURE8 pCubeTex)
{
    HRESULT hr;
    D3DSURFACE_DESC desc;

    // Validate texture
    if(!pCubeTex)
    {
        DPF(0, "pCubeTex pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if(m_dwMode)
    {
        DPF(0, "Begin called inside a scene");
        return D3DERR_INVALIDCALL;
    }

    
    // Cube map must be same size/format as EnvMap
    pCubeTex->GetLevelDesc(0, &desc);

    if(desc.Format != m_Desc.Format)
    {
        DPF(0, "Surface format does not match render target");
        return D3DERR_INVALIDCALL;
    }

    if(desc.Width != m_Desc.Size || desc.Height != m_Desc.Size)
    {
        DPF(0, "Surface size does not match render target");
        return D3DERR_INVALIDCALL;
    }


    // Begin
    if(FAILED(hr = Begin()))
        return hr;

    m_pCubeTex = pCubeTex;
    m_pCubeTex->AddRef();

    m_dwMode = MODE_CUBE;
    return S_OK;
}


STDMETHODIMP 
CD3DXRenderToEnvMap::BeginSphere(LPDIRECT3DTEXTURE8 pTex)
{
    HRESULT hr;
    D3DSURFACE_DESC desc;

    // Validate texture
    if(!pTex)
    {
        DPF(0, "pTex pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if(m_dwMode)
    {
        DPF(0, "Begin called inside a scene");
        return E_FAIL;
    }
    
    // Begin
    if(FAILED(hr = Begin()))
        return hr;

    m_pTex[0] = pTex;
    m_pTex[0]->AddRef();

    m_dwMode = MODE_SPHERE;
    return S_OK;
}


STDMETHODIMP 
CD3DXRenderToEnvMap::BeginHemisphere(LPDIRECT3DTEXTURE8 pTexZPos, LPDIRECT3DTEXTURE8 pTexZNeg)
{
    HRESULT hr;
    D3DSURFACE_DESC desc;

    // Validate texture
    if(!pTexZPos && !pTexZNeg)
    {
        DPF(0, "pTexZPos and pTexZNeg pointers are both invalid");
        return D3DERR_INVALIDCALL;
    }
    if(m_dwMode)
    {
        DPF(0, "Begin called inside a scene");
        return E_FAIL;
    }
    
    // Begin
    if(FAILED(hr = Begin()))
        return hr;

    m_pTex[0] = pTexZPos;
    m_pTex[1] = pTexZNeg;

    for(UINT i = 0; i < 2; i++)
    {
        if(m_pTex[i])
            m_pTex[i]->AddRef();
    }

    m_dwMode = MODE_HEMISPHERE;
    return S_OK;
}


STDMETHODIMP 
CD3DXRenderToEnvMap::BeginParabolic(LPDIRECT3DTEXTURE8 pTexZPos, LPDIRECT3DTEXTURE8 pTexZNeg)
{
    HRESULT hr;
    D3DSURFACE_DESC desc;

    // Validate texture
    if(!pTexZPos && !pTexZNeg)
    {
        DPF(0, "pTexZPos and pTexZNeg pointers are both invalid");
        return D3DERR_INVALIDCALL;
    }
    if(m_dwMode)
    {
        DPF(0, "Begin called inside a scene");
        return E_FAIL;
    }
    
    // Begin
    if(FAILED(hr = Begin()))
        return hr;

    m_pTex[0] = pTexZPos;
    m_pTex[1] = pTexZNeg;

    for(UINT i = 0; i < 2; i++)
    {
        if(m_pTex[i])
            m_pTex[i]->AddRef();
    }

    m_dwMode = MODE_PARABOLIC;
    return S_OK;
}


STDMETHODIMP
CD3DXRenderToEnvMap::Face(D3DCUBEMAP_FACES Face)
{
    HRESULT hr;

    if(FAILED(hr = EndScene()))
        return hr;

    if(FAILED(hr = BeginScene(Face)))
        return hr;

    return S_OK;
}


STDMETHODIMP 
CD3DXRenderToEnvMap::End()
{
    HRESULT hr;

    // End current scene
    if(FAILED(hr = EndScene()))
        return hr;

    // Restore state
    m_pDevice->SetRenderTarget(m_pColorOld, m_pDepthOld);
    m_pDevice->ApplyStateBlock(m_dwStateBlock);

    RELEASE(m_pColorOld);
    RELEASE(m_pDepthOld);

    
    // Calculate maps
    if(MODE_CUBE == m_dwMode)
        hr = S_OK;
    else if(MODE_SPHERE == m_dwMode)
        hr = RenderSphere();
    else if(MODE_HEMISPHERE == m_dwMode)
        hr = RenderHemisphere();
    else if(MODE_PARABOLIC == m_dwMode)
        hr = RenderParabolic();
    else
        hr = E_FAIL;

    RELEASE(m_pCubeTex);
    RELEASE(m_pTex[0]);
    RELEASE(m_pTex[1]);

    m_dwMode = 0;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\core\CD3DXFile.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       CD3DXFile.h
//  Content:    Memory-mapped file class
//
///////////////////////////////////////////////////////////////////////////

#ifndef __CD3DXFile_H__
#define __CD3DXFile_H__


///////////////////////////////////////////////////////////////////////////
// CD3DXFile //////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

class CD3DXFile
{
public:
    LPCVOID     m_pvData;
    DWORD       m_cbData;

public:
    CD3DXFile();
    ~CD3DXFile();

    HRESULT Open(LPCVOID pFile, BOOL bUnicode);
    HRESULT Close();
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\core\CD3DXBuffer.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       CBuffer.h
//  Content:    Buffer object
//
///////////////////////////////////////////////////////////////////////////

#ifndef __D3DXBUFFER_H__
#define __D3DXBUFFER_H__

class CD3DXBuffer : public ID3DXBuffer
{
public:
    CD3DXBuffer();
   ~CD3DXBuffer();

    HRESULT Init(DWORD dwSize);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // ID3DXBuffer
    virtual PVOID STDMETHODCALLTYPE GetBufferPointer();
    virtual DWORD STDMETHODCALLTYPE GetBufferSize();

protected:
    ULONG m_cRef;
    DWORD m_dwSize;
    PBYTE m_pbBuffer;
    HRESULT Grow(DWORD dwSize);
};

class CD3DXStringBuffer : public CD3DXBuffer
{
private:
    char** m_pStringLow;
    char* m_pStringHigh;
public:
    CD3DXStringBuffer();
    HRESULT Init(DWORD size);
    HRESULT AddString(char* pString);
};

HRESULT D3DXCreateStringBuffer(DWORD size, CD3DXStringBuffer** ppBuffer);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\core\CD3DXRenderToSurface.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       CD3DXRenderToSurface.h
//  Content:    Render to surface object
//
///////////////////////////////////////////////////////////////////////////

#ifndef __D3DXRENDERTOSURFACE_H__
#define __D3DXRENDERTOSURFACE_H__

class CD3DXRenderToSurface : public ID3DXRenderToSurface
{
public:
    CD3DXRenderToSurface();
   ~CD3DXRenderToSurface();

    HRESULT Init(LPDIRECT3DDEVICE8 pDevice, UINT Width, UINT Height,
        D3DFORMAT Format, BOOL DepthStencil, D3DFORMAT DepthStencilFormat);

    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    // ID3DXRenderToSurface
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice);
    STDMETHOD(GetDesc)(THIS_ D3DXRTS_DESC* pDesc);

    STDMETHOD(BeginScene)(THIS_ LPDIRECT3DSURFACE8 pSurface, CONST D3DVIEWPORT8* pViewport);
    STDMETHOD(EndScene)(THIS);


protected:
    UINT                m_cRef;
    LPDIRECT3DDEVICE8   m_pDevice;
    D3DXRTS_DESC        m_Desc;

    LPDIRECT3DSURFACE8  m_pColor;
    LPDIRECT3DSURFACE8  m_pColorOld;
    LPDIRECT3DSURFACE8  m_pZStencil;
    LPDIRECT3DSURFACE8  m_pZStencilOld;
    LPDIRECT3DSURFACE8  m_pSurface;

    BOOL                m_bRenderTarget;
    DWORD               m_dwStateBlock;
    D3DVIEWPORT8        m_Viewport;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\core\CD3DXRenderToSurface.cpp ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       CD3DXRenderToSurface.cpp
//  Content:    RenderToSurface object
//
///////////////////////////////////////////////////////////////////////////

#include "pchcore.h"


CD3DXRenderToSurface::CD3DXRenderToSurface()
{
    m_cRef         = 1;
    m_pDevice      = NULL;
    m_pColor       = NULL;
    m_pColorOld    = NULL;
    m_pZStencil    = NULL;
    m_pZStencilOld = NULL;
    m_pSurface     = NULL;
    m_dwStateBlock = 0;
}


CD3DXRenderToSurface::~CD3DXRenderToSurface()
{
    RELEASE(m_pColor);
    RELEASE(m_pColorOld);
    RELEASE(m_pZStencil);
    RELEASE(m_pZStencilOld);
    RELEASE(m_pSurface);

    if(m_dwStateBlock)
        m_pDevice->DeleteStateBlock(m_dwStateBlock);

    RELEASE(m_pDevice);
}


HRESULT 
CD3DXRenderToSurface::Init(LPDIRECT3DDEVICE8 pDevice, UINT Width, UINT Height,
        D3DFORMAT Format, BOOL DepthStencil, D3DFORMAT DepthStencilFormat)
{
    if(!pDevice)
    {
        DPF(0, "pDevice pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if(m_pDevice)
        return E_FAIL;

    m_pDevice = pDevice;
    m_pDevice->AddRef();

    m_Desc.Width              = Width;
    m_Desc.Height             = Height;
    m_Desc.Format             = Format;
    m_Desc.DepthStencil       = DepthStencil;
    m_Desc.DepthStencilFormat = DepthStencilFormat;

    return S_OK;
}


// IUnknown
STDMETHODIMP
CD3DXRenderToSurface::QueryInterface(REFIID riid, LPVOID *ppv)
{
    *ppv=NULL;
    if (riid == IID_IUnknown)
        *ppv=(IUnknown*)this;
    else if (riid == IID_ID3DXRenderToSurface)
        *ppv=(ID3DXRenderToSurface*)this;
    else
        return E_NOINTERFACE;

    ((LPUNKNOWN)*ppv)->AddRef();

    return S_OK;
}


ULONG STDMETHODCALLTYPE
CD3DXRenderToSurface::AddRef()
{
    m_cRef += 1;
    return m_cRef;
}


ULONG STDMETHODCALLTYPE
CD3DXRenderToSurface::Release()
{
    ULONG cRef = m_cRef;
    m_cRef -= 1;

    if (cRef == 1)
        delete this;

    return cRef-1;
}


// ID3DXRenderToSurface
STDMETHODIMP
CD3DXRenderToSurface::GetDevice(LPDIRECT3DDEVICE8* ppDevice)
{
    if(!ppDevice)
    {
        DPF(0, "ppDevice pointer is invalid");
        return D3DERR_INVALIDCALL;
    }

    *ppDevice = m_pDevice;
    m_pDevice->AddRef();
    return S_OK;
}


STDMETHODIMP
CD3DXRenderToSurface::GetDesc(D3DXRTS_DESC* pDesc)
{
    if(!pDesc)
    {
        DPF(0, "pDesc pointer is invalid");
        return D3DERR_INVALIDCALL;
    }

    *pDesc = m_Desc;
    return S_OK;
}


STDMETHODIMP
CD3DXRenderToSurface::BeginScene(LPDIRECT3DSURFACE8 pSurface, CONST D3DVIEWPORT8* pViewport)
{
    HRESULT hr;

    if(!pSurface)
    {
        DPF(0, "pSurface pointer is invalid");
        return D3DERR_INVALIDCALL;
    }

    if(m_pSurface)
    {
        DPF(0, "BeginScene called inside a scene");
        return E_FAIL;
    }


    // Get surface desc
    D3DSURFACE_DESC desc;
    pSurface->GetDesc(&desc);

    if(desc.Format != m_Desc.Format)
    {
        DPF(0, "Surface format does not match render target");
        return E_FAIL;
    }

    if(desc.Width != m_Desc.Width || desc.Height != m_Desc.Height)
    {
        DPF(0, "Surface size does not match render target");
        return E_FAIL;
    }

    m_bRenderTarget = (desc.Usage & D3DUSAGE_RENDERTARGET);



    // Compute viewport
    if(pViewport)
    {
        m_Viewport = *pViewport;

        if(m_Viewport.X + m_Viewport.Width  > m_Desc.Width ||
           m_Viewport.Y + m_Viewport.Height > m_Desc.Height)
        {
            DPF(0, "Viewport outside surface limits");
            return D3DERR_INVALIDCALL;
        }
    }
    else
    {
        m_Viewport.X      = 0;
        m_Viewport.Y      = 0;
        m_Viewport.Width  = m_Desc.Width;
        m_Viewport.Height = m_Desc.Height;
        m_Viewport.MinZ   = 0.0f;
        m_Viewport.MaxZ   = 1.0f;
    }


    // Create Color buffer if needed
    if(!m_pColor && !m_bRenderTarget)
    {
        if(FAILED(hr = m_pDevice->CreateRenderTarget(m_Desc.Width, m_Desc.Height, 
            m_Desc.Format, D3DMULTISAMPLE_NONE, TRUE, &m_pColor)))
        {
            DPF(0, "CreateRenderTarget failed");
            return hr;
        }
    }


    // Create ZStencil buffer if needed
    if(!m_pZStencil && m_Desc.DepthStencil)
    {
        if(FAILED(hr = m_pDevice->CreateDepthStencilSurface(m_Desc.Width,
            m_Desc.Height,
            m_Desc.DepthStencilFormat, D3DMULTISAMPLE_NONE, &m_pZStencil)))
        {
            DPF(0, "CreateDepthStencilSurface failed");
            return hr;
        }
    }

    // Create StateBlock if needed
    if(!m_dwStateBlock)
    {
        m_pDevice->BeginStateBlock();
        m_pDevice->SetViewport(&m_Viewport);
        m_pDevice->EndStateBlock(&m_dwStateBlock);
    }



    // Set new render target
    RELEASE(m_pColorOld);
    RELEASE(m_pZStencilOld);

    m_pDevice->CaptureStateBlock(m_dwStateBlock);
    m_pDevice->GetRenderTarget(&m_pColorOld);
    m_pDevice->GetDepthStencilSurface(&m_pZStencilOld);


    if(FAILED(hr = m_pDevice->SetRenderTarget(m_bRenderTarget ? pSurface : m_pColor, m_pZStencil)))
    {
        DPF(0, "SetRenderTarget failed");
        return hr;
    }

    if(FAILED(hr = m_pDevice->SetViewport(&m_Viewport)))
    {
        DPF(0, "SetViewport failed");
        return hr;
    }

    if(FAILED(hr = m_pDevice->BeginScene()))
    {
        DPF(0, "BeginScene failed");
        return hr;
    }

    m_pSurface = pSurface;
    m_pSurface->AddRef();

    return S_OK;
}


STDMETHODIMP
CD3DXRenderToSurface::EndScene()
{
    if(!m_pSurface)
    {
        DPF(0, "EndScene called outside a scene");
        return E_FAIL;
    }

    m_pDevice->EndScene();
    
    // Blit, if we weren't rendering directly to texture
    if(!m_bRenderTarget)
    {
        RECT rect;

        rect.left   = (LONG) m_Viewport.X;
        rect.top    = (LONG) m_Viewport.Y;
        rect.right  = (LONG) (m_Viewport.X + m_Viewport.Width);
        rect.bottom = (LONG) (m_Viewport.Y + m_Viewport.Height);

        m_pDevice->CopyRects(m_pColor, &rect, 1, m_pSurface, (POINT *) &rect);
    }


    // Put render target back
    m_pDevice->SetRenderTarget(m_pColorOld, m_pZStencilOld);
    m_pDevice->ApplyStateBlock(m_dwStateBlock);

    RELEASE(m_pColorOld);
    RELEASE(m_pZStencilOld);
    RELEASE(m_pSurface);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\core\cd3dxrendertoenvmap.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       CD3DXRenderToEnvMap.h
//  Content:    Render to surface object
//
///////////////////////////////////////////////////////////////////////////

#ifndef __D3DXRenderToEnvMap_H__
#define __D3DXRenderToEnvMap_H__

class CD3DXRenderToEnvMap : public ID3DXRenderToEnvMap
{
public:
    CD3DXRenderToEnvMap();
   ~CD3DXRenderToEnvMap();

    HRESULT Init(LPDIRECT3DDEVICE8 pDevice, UINT Size, D3DFORMAT Format, 
        BOOL DepthStencil, D3DFORMAT DepthStencilFormat);

    HRESULT Begin();
    HRESULT BeginScene(D3DCUBEMAP_FACES Face);
    HRESULT EndScene();

    HRESULT RenderSphere();
    HRESULT RenderHemisphere();
    HRESULT RenderParabolic();


    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);


    // ID3DXRenderToEnvMap
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice);
    STDMETHOD(GetDesc)(THIS_ D3DXRTE_DESC* pDesc);

    STDMETHOD(BeginCube)(THIS_ 
        LPDIRECT3DCUBETEXTURE8 pCubeTex);

    STDMETHOD(BeginSphere)(THIS_
        LPDIRECT3DTEXTURE8 pTex);

    STDMETHOD(BeginHemisphere)(THIS_ 
        LPDIRECT3DTEXTURE8 pTexZPos,
        LPDIRECT3DTEXTURE8 pTexZNeg);

    STDMETHOD(BeginParabolic)(THIS_ 
        LPDIRECT3DTEXTURE8 pTexZPos,
        LPDIRECT3DTEXTURE8 pTexZNeg);

    STDMETHOD(Face)(THIS_ D3DCUBEMAP_FACES Face);

    STDMETHOD(End)(THIS);


protected:
    UINT                    m_cRef;
    LPDIRECT3DDEVICE8       m_pDevice;
    D3DXRTE_DESC            m_Desc;

    LPDIRECT3DSURFACE8      m_pColor;
    LPDIRECT3DSURFACE8      m_pDepth;
    LPDIRECT3DSURFACE8      m_pColorOld;
    LPDIRECT3DSURFACE8      m_pDepthOld;
    LPDIRECT3DTEXTURE8      m_pFace[6];
    LPDIRECT3DCUBETEXTURE8  m_pCubeTex;
    LPDIRECT3DTEXTURE8      m_pTex[2];

    DWORD                   m_dwMode;
    D3DCUBEMAP_FACES        m_Face;
    BOOL                    m_bInScene;
    BOOL                    m_bRenderTarget;
    DWORD                   m_dwStateBlock;
    D3DVIEWPORT8            m_Viewport;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\core\CD3DXStack.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       stacks.h
//  Content:    Stacks
//
///////////////////////////////////////////////////////////////////////////



//----------------------------------------------------------------------------
// CD3DXDwStack
//----------------------------------------------------------------------------


class CD3DXDwStack
{
    DWORD *m_pdw;

    UINT m_cdw;
    UINT m_cdwLim;

    HRESULT m_hr;

public:
    CD3DXDwStack();
    ~CD3DXDwStack();

    HRESULT Push(DWORD dw);
    HRESULT Pop (DWORD *pdw);

    HRESULT GetLastError();
};


//----------------------------------------------------------------------------
// CD3DXSzStack
//----------------------------------------------------------------------------

class CD3DXSzStack
{
    char **m_ppsz;
    UINT m_cpsz;
    UINT m_cpszLim;
    HRESULT m_hr;

public:
    CD3DXSzStack();
    ~CD3DXSzStack();

    HRESULT Push(char *psz);
    HRESULT Pop (char **ppsz);

    HRESULT GetLastError();
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\core\CD3DXStack.cpp ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       stacks.cpp
//  Content:    Stacks
//
///////////////////////////////////////////////////////////////////////////

#include "pchcore.h"

//----------------------------------------------------------------------------
// CD3DXDwStack - DWORD stack
//----------------------------------------------------------------------------


CD3DXDwStack::CD3DXDwStack()
{
    m_pdw = NULL;
    m_cdw = 0;
    m_cdwLim = 0;
    m_hr = S_OK;
}

CD3DXDwStack::~CD3DXDwStack()
{
    if(m_pdw)
        delete [] m_pdw;
}

HRESULT
CD3DXDwStack::Push(DWORD dw)
{
    if(m_cdw == m_cdwLim)
    {
        DWORD *pdw;
        
        if(!(pdw = new DWORD[m_cdwLim + 16]))
            return m_hr = E_OUTOFMEMORY;

        if(m_pdw)
        {
            memcpy(pdw, m_pdw, m_cdw * sizeof(DWORD));
            delete [] m_pdw;
        }

        m_pdw = pdw;
        m_cdwLim += 16;
    }

    m_pdw[m_cdw++] = dw;
    return S_OK;
}

HRESULT
CD3DXDwStack::Pop(DWORD *pdw)
{
    if(m_cdw == 0)
    {
        if(pdw)
            *pdw = 0;

        DPF(0, "Stack Empty");
        return m_hr = E_FAIL;
    }

    m_cdw--;

    if(pdw)
        *pdw = m_pdw[m_cdw];

    return S_OK;
}

HRESULT
CD3DXDwStack::GetLastError()
{
    HRESULT hr = m_hr;
    m_hr = S_OK;
    return hr;
}


//----------------------------------------------------------------------------
// CD3DXSzStack - String stack
//----------------------------------------------------------------------------

CD3DXSzStack::CD3DXSzStack()
{
    m_ppsz = NULL;
    m_cpsz = 0;
    m_cpszLim = 0;
    m_hr = S_OK;
}

CD3DXSzStack::~CD3DXSzStack()
{
    if(m_ppsz)
    {
        for(UINT ipsz = 0; ipsz < m_cpsz; ipsz++)
        {
            if(m_ppsz[ipsz])
                delete [] m_ppsz[ipsz];
        }

        delete [] m_ppsz;
    }
}

HRESULT
CD3DXSzStack::Push(char *psz)
{
    if(m_cpsz == m_cpszLim)
    {
        char **ppsz;
        
        if(!(ppsz = new char* [m_cpszLim + 16]))
            return m_hr = E_OUTOFMEMORY;

        if(m_ppsz)
        {
            memcpy(ppsz, m_ppsz, m_cpsz * sizeof(char *));
            delete [] m_ppsz;
        }

        m_ppsz = ppsz;
        m_cpszLim += 16;
    }

    if(psz)
    {
        UINT cch;
        char *pszCopy;

        cch = strlen(psz);

        if(!(pszCopy = new char[cch + 1]))
            return m_hr = E_OUTOFMEMORY;

        memcpy(pszCopy, psz, cch * sizeof(char));
        pszCopy[cch] = 0;

        m_ppsz[m_cpsz++] = pszCopy;
    }
    else
    {
        m_ppsz[m_cpsz++] = NULL;
    }

    return S_OK;
}

HRESULT
CD3DXSzStack::Pop(char **ppsz)
{
    if(m_cpsz == 0)
    {
        if(ppsz)
            *ppsz = NULL;

        DPF(0, "Stack Empty");
        return m_hr = E_FAIL;
    }

    m_cpsz--;

    if(ppsz)
        *ppsz = m_ppsz[m_cpsz];

    return S_OK;
}

HRESULT
CD3DXSzStack::GetLastError()
{
    HRESULT hr = m_hr;
    m_hr = S_OK;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\core\CD3DXSprite.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       CD3DXSprite.h
//  Content:    Sprite support
//
///////////////////////////////////////////////////////////////////////////

#ifndef __CD3DXSprite_H__
#define __CD3DXSprite_H__


///////////////////////////////////////////////////////////////////////////
// CD3DXSprite //////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

class CD3DXSprite : public ID3DXSprite
{
public:
    CD3DXSprite();
   ~CD3DXSprite();

    HRESULT Initialize(LPDIRECT3DDEVICE8 pDevice);

    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    // ID3DXSprite
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice);

    STDMETHOD(Begin)(THIS);

    STDMETHOD(Draw)(THIS_ LPDIRECT3DTEXTURE8  pSrcTexture, 
        CONST RECT* pSrcRect, CONST D3DXVECTOR2* pScaling, 
        CONST D3DXVECTOR2* pRotationCenter, FLOAT Rotation, 
        CONST D3DXVECTOR2* pTranslation, D3DCOLOR Color);

    STDMETHOD(DrawTransform)(THIS_ LPDIRECT3DTEXTURE8 pSrcTexture, 
        CONST RECT* pSrcRect, CONST D3DXMATRIX* pTransform, 
        D3DCOLOR Color);

    STDMETHOD(End)(THIS);

public:
    UINT                m_uRef;
    LPDIRECT3DDEVICE8   m_pDevice;
    BOOL                m_bBegin;
    DWORD               m_dwOldState;
    DWORD               m_dwNewState;
};

#endif //__CD3DXSprite_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\core\d3dx8dbg.cpp ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx8dbg.cpp
//  Content:    D3DX debugging functions
//
///////////////////////////////////////////////////////////////////////////

#include "pchcore.h"
#if DBG


//
// DPF
//

void cdecl D3DXDebugPrintf(UINT lvl, LPSTR szFormat, ...)
{
    char strA[256];
    char strB[256];

//    if(lvl > (UINT) g_dwDebugLevel)
//        return;

    va_list ap;
    va_start(ap, szFormat);
    _vsnprintf(strA, sizeof(strA), szFormat, ap);
    strA[255] = '\0';
    va_end(ap);

    _snprintf(strB, sizeof(strB), "D3DX: %s\r\n", strA);
    strB[255] = '\0';

    OutputDebugStringA(strB);
}


//
// DPFHR
//

void cdecl D3DXDebugPrintfHR(UINT lvl, HRESULT hr, LPSTR szFormat, ...)
{
    char strA[256];
    char strB[256];

    va_list ap;
    va_start(ap, szFormat);
    _vsnprintf(strA, sizeof(strA), szFormat, ap);
    strA[255] = '\0';
    va_end(ap);

    D3DXGetErrorStringA(hr, strB, sizeof(strB));
    D3DXDebugPrintf(lvl, "%s: %s", strA, strB);
}



//
// D3DXASSERT
//

int WINAPI D3DXDebugAssert(LPCSTR szFile, int nLine, LPCSTR szCondition)
{
	return 0;
}


#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\core\d3dx8core.cpp ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       CCapsDatabase.cpp
//  Content:    D3DX capabilities database
//
///////////////////////////////////////////////////////////////////////////

#include "pchcore.h"


//-------------------------------------------------------------------------
// D3DXCreateSprite
//-------------------------------------------------------------------------

HRESULT WINAPI
    D3DXCreateSprite(
        LPDIRECT3DDEVICE8   pDevice,
        LPD3DXSPRITE*       ppSprite)
{
    HRESULT hr;
    CD3DXSprite *pSprite = NULL;

    if (!pDevice)
    {
        DPF(0, "pDevice pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if (!ppSprite)
    {
        DPF(0, "ppSprite pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if(!(pSprite = new CD3DXSprite))
        return E_OUTOFMEMORY;

    if(FAILED(hr = pSprite->Initialize(pDevice)))
    {
        delete pSprite;
        return hr;
    }

    *ppSprite = (LPD3DXSPRITE) pSprite;
    return S_OK;
}



//-------------------------------------------------------------------------
// D3DXCreateRenderToSurface
//-------------------------------------------------------------------------

HRESULT WINAPI
    D3DXCreateRenderToSurface(
        LPDIRECT3DDEVICE8       pDevice,
        UINT                    Width,
        UINT                    Height,
        D3DFORMAT               Format,
        BOOL                    DepthStencil,
        D3DFORMAT               DepthStencilFormat,
        LPD3DXRENDERTOSURFACE*  ppRenderToSurface)
{
    HRESULT hr;
    CD3DXRenderToSurface *pRTS;

    if(!pDevice)
    {
        DPF(0, "pDevice pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if (!ppRenderToSurface)
    {
        DPF(0, "ppRenderToSurface pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if(!(pRTS = new CD3DXRenderToSurface()))
        return E_OUTOFMEMORY;

    if(FAILED(hr = pRTS->Init(pDevice, Width, Height, Format, 
        DepthStencil, DepthStencilFormat)))
    {
        delete pRTS;
        return hr;
    }

    *ppRenderToSurface = (ID3DXRenderToSurface *) pRTS;
    return S_OK;
}


//-------------------------------------------------------------------------
// D3DXCreateRenderToEnvMap
//-------------------------------------------------------------------------

HRESULT WINAPI
    D3DXCreateRenderToEnvMap(
        LPDIRECT3DDEVICE8       pDevice,
        UINT                    Size,
        D3DFORMAT               Format,
        BOOL                    DepthStencil,
        D3DFORMAT               DepthStencilFormat,
        LPD3DXRenderToEnvMap*   ppRenderToEnvMap)
{
    HRESULT hr;
    CD3DXRenderToEnvMap *pRTE;

    if(!pDevice)
    {
        DPF(0, "pDevice pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if (!ppRenderToEnvMap)
    {
        DPF(0, "ppRenderToEnvMap pointer is invalid");
        return D3DERR_INVALIDCALL;
    }

    if(!(pRTE = new CD3DXRenderToEnvMap()))
        return E_OUTOFMEMORY;

    if(FAILED(hr = pRTE->Init(pDevice, Size, Format, 
        DepthStencil, DepthStencilFormat)))
    {
        delete pRTE;
        return hr;
    }

    *ppRenderToEnvMap = (ID3DXRenderToEnvMap *) pRTE;
    return S_OK;
}


//-------------------------------------------------------------------------
// D3DXGetFVFVertexSize:
//-------------------------------------------------------------------------

UINT WINAPI
    D3DXGetFVFVertexSize(DWORD dwFVF)
{
    UINT uSize = 0;

    switch (dwFVF & D3DFVF_POSITION_MASK)
    {
    case D3DFVF_XYZ:    uSize = 3 * sizeof(float); break;
    case D3DFVF_XYZRHW: uSize = 4 * sizeof(float); break;
    case D3DFVF_XYZB1:  uSize = 4 * sizeof(float); break;
    case D3DFVF_XYZB2:  uSize = 5 * sizeof(float); break;
    case D3DFVF_XYZB3:  uSize = 6 * sizeof(float); break;
    case D3DFVF_XYZB4:  uSize = 7 * sizeof(float); break;
    }

    if(dwFVF & D3DFVF_NORMAL)
        uSize += 3 * sizeof(float);

    if(dwFVF & D3DFVF_DIFFUSE)
        uSize += sizeof(DWORD);

    if(dwFVF & D3DFVF_SPECULAR)
        uSize += sizeof(DWORD);


    // Texture coordinates
    UINT uNumTexCoords = (((dwFVF) & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT);
    UINT uTextureFormats = dwFVF >> 16;

    if(uTextureFormats)
    {
        for (UINT i=0; i < uNumTexCoords; i++)
        {
            switch(uTextureFormats & 3)
            {
            case 0: uSize += 2 * sizeof(float); break;
            case 1: uSize += 3 * sizeof(float); break;
            case 2: uSize += 4 * sizeof(float); break;
            case 3: uSize += 1 * sizeof(float); break;
            }

            uTextureFormats >>= 2;
        }
    }
    else
    {
        uSize += uNumTexCoords * (2 * sizeof(float));
    }

    return uSize;
}



//-------------------------------------------------------------------------
// D3DXGetErrorString
//-------------------------------------------------------------------------

HRESULT WINAPI
    D3DXGetErrorStringA(
        HRESULT             hr,
        LPSTR               pBuffer,
        UINT                cchBuffer)
{
    if(!pBuffer || !cchBuffer)
        return S_OK;


    // Lookup error
    LPSTR pErrStr = NULL;

    switch (hr)
    {
    #define CASE_ERROR( err ) \
        case err: pErrStr = #err; break

    // Generic errors
    CASE_ERROR( S_OK );
    CASE_ERROR( E_FAIL );
    CASE_ERROR( E_OUTOFMEMORY );
    CASE_ERROR( E_NOTIMPL );

    // D3D errors
    CASE_ERROR( D3DERR_WRONGTEXTUREFORMAT );
    CASE_ERROR( D3DERR_UNSUPPORTEDCOLOROPERATION );
    CASE_ERROR( D3DERR_UNSUPPORTEDCOLORARG );
    CASE_ERROR( D3DERR_UNSUPPORTEDALPHAOPERATION );
    CASE_ERROR( D3DERR_UNSUPPORTEDALPHAARG );
    CASE_ERROR( D3DERR_TOOMANYOPERATIONS );
    CASE_ERROR( D3DERR_CONFLICTINGTEXTUREFILTER );
    CASE_ERROR( D3DERR_UNSUPPORTEDFACTORVALUE );
    CASE_ERROR( D3DERR_CONFLICTINGRENDERSTATE );
    CASE_ERROR( D3DERR_UNSUPPORTEDTEXTUREFILTER );
    CASE_ERROR( D3DERR_CONFLICTINGTEXTUREPALETTE );
    CASE_ERROR( D3DERR_DRIVERINTERNALERROR );
    CASE_ERROR( D3DERR_NOTFOUND );
    CASE_ERROR( D3DERR_MOREDATA );
    CASE_ERROR( D3DERR_DEVICELOST );
    CASE_ERROR( D3DERR_DEVICENOTRESET );
    CASE_ERROR( D3DERR_NOTAVAILABLE );
    CASE_ERROR( D3DERR_OUTOFVIDEOMEMORY );
    CASE_ERROR( D3DERR_INVALIDDEVICE );
    CASE_ERROR( D3DERR_INVALIDCALL );

    // D3DX errors
    CASE_ERROR( D3DXERR_CANNOTMODIFYINDEXBUFFER );
    CASE_ERROR( D3DXERR_INVALIDMESH );
    CASE_ERROR( D3DXERR_CANNOTATTRSORT );
    CASE_ERROR( D3DXERR_SKINNINGNOTSUPPORTED );
    CASE_ERROR( D3DXERR_TOOMANYINFLUENCES );
    CASE_ERROR( D3DXERR_INVALIDDATA );

    #undef CASE_ERROR
    }


    // Copy error into supplied buffer
    int cch;

    if( pErrStr )
        cch = _snprintf(pBuffer, cchBuffer, "%s", pErrStr );
    else
        cch = _snprintf(pBuffer, cchBuffer, "Unrecognized error: 0x%0.8x", hr );

    if(cch < 0 && cchBuffer > 0)
        pBuffer[cchBuffer - 1] = '\0';

    return S_OK;
}


HRESULT WINAPI
    D3DXGetErrorStringW(
        HRESULT             hr,
        LPWSTR              pBuffer,
        UINT                cchBuffer)
{
    int err;
    if(!pBuffer || !cchBuffer)
        return S_OK;

    char *pszA = (char *) _alloca(cchBuffer);

    if(FAILED(hr = D3DXGetErrorStringA(hr, pszA, cchBuffer)))
        return hr;

    if(!(err = MultiByteToWideChar(CP_ACP, 0, pszA, strlen(pszA), pBuffer, cchBuffer)))
    {
        DPF(0, "Could not generate wide char string");
        return HRESULT_FROM_WIN32(err);
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\core\pchcore.h ===
//
// D3DX core precompiled header
//

#ifndef __PCHCORE_H__
#define __PCHCORE_H__
#include <d3dx8seg.h>

#define D3DCOMPILE_BEGINSTATEBLOCK 1

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <malloc.h>
#include <xtl.h>

#include "d3dx8.h"
#include "d3dx8dbg.h"
#include "d3d8types.h"

#include "CD3DXFile.h"
#include "CD3DXStack.h"
#include "CD3DXBuffer.h"
#include "CD3DXSprite.h"
#include "CD3DXRenderToSurface.h"
#include "CD3DXRenderToEnvMap.h"

#define RELEASE(x) \
    do { if(x) { x->Release(); x = NULL; } } while(0)

#endif //__PCHCORE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\core\init.c ===
#define INITGUID

// HACK alert: the d3dx8 headers don't compile under C because they don't define
//   : INTERFACE for any of the interfaces they define.  This causes massive headaches
//   : when compiling this stuff for C.
//
//   : This will make it work for now (we're just instantiating GUIDs after all).  It'll 
//   : be fixed for real when we decomize.
//
#define INTERFACE IUnknown

#include <xtl.h>
#include <rmxfguid.h>
#include <rmxftmpl.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\core\CD3DXSprite.cpp ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       CD3DXSprite.cpp
//  Content:    Bitmap font support
//
///////////////////////////////////////////////////////////////////////////

#include "pchcore.h"


struct SPRITE_VERTEX
{
    D3DXVECTOR4 m_Pos;
    D3DCOLOR    m_Color;
    D3DXVECTOR2 m_Tex;
};

#define SPRITE_VERTEX_FVF (D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_TEX1)




//////////////////////////////////////////////////////////////////////////////
// CD3DXSprite ///////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

CD3DXSprite::CD3DXSprite()
{
    m_uRef       = 1;
    m_pDevice    = NULL;
    m_bBegin     = FALSE;
    m_dwOldState = NULL;
    m_dwNewState = NULL;
}


CD3DXSprite::~CD3DXSprite()
{
    if(m_pDevice)
    {
        if(m_dwNewState)
            m_pDevice->DeleteStateBlock(m_dwNewState);

        if(m_dwOldState)
            m_pDevice->DeleteStateBlock(m_dwOldState);

        m_pDevice->Release();
    }
}


STDMETHODIMP
CD3DXSprite::QueryInterface(REFIID iid, LPVOID *ppv)
{
#if DBG
    if(!ppv)
    {
        DPF(0, "ppv pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
#endif

    if(IsEqualIID(iid, IID_ID3DXSprite))
        *ppv = (ID3DXSprite *) this;
    else if(IsEqualIID(iid, IID_IUnknown))
        *ppv = (IUnknown *) this;
    else
        return E_NOINTERFACE;

    AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG)
CD3DXSprite::AddRef()
{
    return ++m_uRef;
}


STDMETHODIMP_(ULONG)
CD3DXSprite::Release()
{
    if(--m_uRef)
        return m_uRef;

    delete this;
    return 0;
}


HRESULT
CD3DXSprite::Initialize(LPDIRECT3DDEVICE8 pDevice)
{
    HRESULT hr;

    if(!pDevice)
    {
        DPF(0, "pDevice pointer is invalid");
        return D3DERR_INVALIDCALL;
    }

    m_pDevice = pDevice;
    m_pDevice->AddRef();


    // Get device caps
    D3DCAPS8 caps;

    if(FAILED(hr = m_pDevice->GetDeviceCaps(&caps)))
        return hr;


    for(UINT i = 0; i < 2; i++)
    {
        m_pDevice->BeginStateBlock();

        m_pDevice->SetVertexShader(SPRITE_VERTEX_FVF);

        // Random device state
        m_pDevice->SetRenderState(D3DRS_WRAP0, 0);
        m_pDevice->SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);
        m_pDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
        m_pDevice->SetRenderState(D3DRS_VERTEXBLEND, FALSE);
        m_pDevice->SetRenderState(D3DRS_PATCHSEGMENTS, 1);

        // Modulate color and alpha
        m_pDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);
        m_pDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
        m_pDevice->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
        m_pDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
        m_pDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
        m_pDevice->SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);
        m_pDevice->SetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_DISABLE);
        m_pDevice->SetTextureStageState(1, D3DTSS_ALPHAOP, D3DTOP_DISABLE);

        // Setup texture addressing and filtering
        m_pDevice->SetTextureStageState(0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR);
        m_pDevice->SetTextureStageState(0, D3DTSS_MINFILTER, D3DTEXF_LINEAR);
        m_pDevice->SetTextureStageState(0, D3DTSS_MIPFILTER, D3DTEXF_NONE);
        m_pDevice->SetTextureStageState(0, D3DTSS_TEXCOORDINDEX, 0);
        m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
        m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);
        m_pDevice->SetTextureStageState(0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE);

        // Use alphatest on cards which dont support alphablend
        if((caps.SrcBlendCaps  & D3DPBLENDCAPS_SRCALPHA) &&
           (caps.DestBlendCaps & D3DPBLENDCAPS_INVSRCALPHA))
        {
            m_pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
            m_pDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
            m_pDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
        }
        else
        {
            m_pDevice->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
            m_pDevice->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATEREQUAL);
            m_pDevice->SetRenderState(D3DRS_ALPHAREF, 0x7f);
        }

        if(0 == i)
        {
            m_pDevice->SetTexture(0, NULL);
            m_pDevice->SetStreamSource(0, NULL, 0);
        }

        m_pDevice->EndStateBlock(i ? &m_dwNewState : &m_dwOldState);
    }

    return S_OK;
}


STDMETHODIMP
CD3DXSprite::GetDevice(LPDIRECT3DDEVICE8* ppDevice)
{
    if(!ppDevice)
    {
        DPF(0, "ppDevice pointer is invalid");
        return D3DERR_INVALIDCALL;
    }

    *ppDevice = m_pDevice;
    m_pDevice->AddRef();

    return S_OK;
}


STDMETHODIMP CD3DXSprite::Begin()
{
    if(m_bBegin)
    {
        DPF(0, "BeginScene called inside a scene");
        return E_FAIL;
    }
    m_pDevice->CaptureStateBlock(m_dwOldState);
    m_pDevice->ApplyStateBlock(m_dwNewState);

    m_bBegin = TRUE;
    return S_OK;
}


STDMETHODIMP CD3DXSprite::Draw(LPDIRECT3DTEXTURE8 pSrcTexture,
    CONST RECT* pSrcRect, CONST D3DXVECTOR2 *pScaling,
    CONST D3DXVECTOR2* pRotationCenter, FLOAT Rotation,
    CONST D3DXVECTOR2* pTranslation, D3DCOLOR Color)
{
    D3DXVECTOR3 vS, vRC, vT;
    D3DXQUATERNION qR;
    D3DXMATRIX mat;

    if(pScaling)
    {
        vS.x = pScaling->x;
        vS.y = pScaling->y;
        vS.z = 1.0f;
    }

    if(pRotationCenter)
    {
        vRC.x = pRotationCenter->x;
        vRC.y = pRotationCenter->y;
        vRC.z = 0.0f;
    }

    if(Rotation != 0.0f)
    {
        qR.x = 0.0f;
        qR.y = 0.0f;
        qR.z = sinf(-0.5f * Rotation);
        qR.w = cosf(-0.5f * Rotation);
    }

    if(pTranslation)
    {
        vT.x = pTranslation->x;
        vT.y = pTranslation->y;
        vT.z = 0.0f;
    }

    D3DXMatrixTransformation(
        &mat,
        NULL,
        NULL,
        pScaling ? &vS : NULL,
        pRotationCenter ? &vRC : NULL,
        (Rotation != 0.0f) ? &qR : NULL,
        pTranslation ? &vT : NULL);


    return DrawTransform(pSrcTexture, pSrcRect, &mat, Color);
}


STDMETHODIMP CD3DXSprite::DrawTransform(LPDIRECT3DTEXTURE8 pSrcTexture,
    CONST RECT* pSrcRect, CONST D3DXMATRIX* pTransformation,
    D3DCOLOR Color)
{
    HRESULT hr;

    if(!pSrcTexture)
    {
        DPF(0, "pSrcTexture pointer is invalid");
        return D3DERR_INVALIDCALL;
    }

    // Validate rect
    RECT rect;
    D3DSURFACE_DESC desc;
    pSrcTexture->GetLevelDesc(0, &desc);

    if(pSrcRect)
    {
        rect = *pSrcRect;

        if((rect.left < 0) || (rect.left > rect.right) || (rect.left > (LONG) desc.Width) ||
           (rect.top < 0) || (rect.top > rect.bottom) || (rect.top > (LONG) desc.Height))
        {
            DPF(0, "Source rect is outside surface limits");
            return D3DERR_INVALIDCALL;
        }
    }
    else
    {
        rect.left   = 0;
        rect.top    = 0;
        rect.right  = (LONG) desc.Width;
        rect.bottom = (LONG) desc.Height;
    }



    // Setup vertices
    SPRITE_VERTEX v[4];

    float fWidth  = (float) (rect.right - rect.left);
    float fHeight = (float) (rect.bottom - rect.top);
    float fWidthInv  = 1.0f / (float) desc.Width;
    float fHeightInv = 1.0f / (float) desc.Height;

    float fMinX = fWidthInv  * (float) rect.left;
    float fMaxX = fWidthInv  * (float) rect.right;
    float fMinY = fHeightInv * (float) rect.top;
    float fMaxY = fHeightInv * (float) rect.bottom;


    v[0].m_Pos = D3DXVECTOR4(0.0f, 0.0f, 0.0f, 1.0f);
    v[0].m_Color = Color;
    v[0].m_Tex = D3DXVECTOR2(fMinX, fMinY);

    v[1].m_Pos = D3DXVECTOR4(0.0f, fHeight, 0.0f, 1.0f);
    v[1].m_Color = Color;
    v[1].m_Tex = D3DXVECTOR2(fMinX, fMaxY);

    v[2].m_Pos = D3DXVECTOR4(fWidth, fHeight, 0.0f, 1.0f);
    v[2].m_Color = Color;
    v[2].m_Tex = D3DXVECTOR2(fMaxX, fMaxY);

    v[3].m_Pos = D3DXVECTOR4(fWidth, 0.0f, 0.0f, 1.0f);
    v[3].m_Color = Color;
    v[3].m_Tex = D3DXVECTOR2(fMaxX, fMinY);

    if(pTransformation)
    {
        for(UINT i = 0; i < 4; i++)
            D3DXVec4Transform(&v[i].m_Pos, &v[i].m_Pos, pTransformation);
    }

    // Offset x and y by half a pixel, and convert w into rhw
    for(UINT i = 0; i < 4; i++)
    {
        float f = 0.5f * v[i].m_Pos.w;

        v[i].m_Pos.x -= f;
        v[i].m_Pos.y -= f;
        v[i].m_Pos.w = 1.0f / v[i].m_Pos.w;
    }



    // Draw stuff
    BOOL bBegin = m_bBegin;
    BOOL bAlpha = ((Color >> 24) != 0xff);

    if(!bAlpha)
    {
        switch(desc.Format)
        {
        case D3DFMT_A8R8G8B8:
        case D3DFMT_A1R5G5B5:
        case D3DFMT_A4R4G4B4:
        case D3DFMT_A8:
#if 0
        case D3DFMT_A8R3G3B2:
        case D3DFMT_A8P8:
        case D3DFMT_A4L4:
        case D3DFMT_DXT3:
        case D3DFMT_DXT5:
#endif
        case D3DFMT_P8:
        case D3DFMT_A8L8:
        case D3DFMT_DXT2:
        case D3DFMT_DXT4:
            bAlpha = TRUE;
            break;
        }
    }

    if(!m_bBegin)
    {
        if(FAILED(hr = Begin()))
            return hr;
    }


    m_pDevice->SetTexture(0, pSrcTexture);
    m_pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, bAlpha);
    m_pDevice->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, (LPCVOID) &v, sizeof(SPRITE_VERTEX));

    if(!bBegin)
    {
        if(FAILED(hr = End()))
            return hr;
    }

    return S_OK;
}


STDMETHODIMP CD3DXSprite::End()
{
    if(!m_bBegin)
    {
        DPF(0, "Begin was not yet called");
        return E_FAIL;
    }
    m_pDevice->ApplyStateBlock(m_dwOldState);

    m_bBegin = FALSE;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\effect\ccompiler.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       compiler.h
//  Content:    Vertex Shader compiler
//
///////////////////////////////////////////////////////////////////////////



//
// Binary file nodes
//

#define N_EFFECT     MAKEFOURCC('F', 'X', '1', '0')
#define N_PARAMETERS MAKEFOURCC('P', 'A', 'R', 'S')
#define N_TECHNIQUES MAKEFOURCC('T', 'E', 'C', 'S')
#define N_PARAMETER  MAKEFOURCC('P', 'A', 'R', 'M')
#define N_TECHNIQUE  MAKEFOURCC('T', 'E', 'C', 'H')
#define N_PASS       MAKEFOURCC('P', 'A', 'S', 'S')
#define N_ASSIGNMENT MAKEFOURCC('A', 'S', 'G', 'N')
#define N_VALUE      MAKEFOURCC('V', 'A', 'L', 'U')
#define N_REFERENCE  MAKEFOURCC('R', 'E', 'F', 'E')
#define N_INTERNAL   MAKEFOURCC('X', 'X', 'X', 'X')



//
// Effect States
//

#define D3DXES_RS(rs)               (0x01000000 | (rs  & 0x00ffffff))
#define D3DXES_TSS(tss)             (0x02000000 | (tss & 0x00ffffff))

#define D3DXES_LIGHTTYPE            (0x03000000)
#define D3DXES_LIGHTDIFFUSE         (0x03000001)
#define D3DXES_LIGHTSPECULAR        (0x03000002)
#define D3DXES_LIGHTAMBIENT         (0x03000003)
#define D3DXES_LIGHTPOSITION        (0x03000004)
#define D3DXES_LIGHTDIRECTION       (0x03000005)
#define D3DXES_LIGHTRANGE           (0x03000006)
#define D3DXES_LIGHTFALLOFF         (0x03000007)
#define D3DXES_LIGHTATTENUATION0    (0x03000008)
#define D3DXES_LIGHTATTENUATION1    (0x03000009)
#define D3DXES_LIGHTATTENUATION2    (0x0300000a)
#define D3DXES_LIGHTTHETA           (0x0300000b)
#define D3DXES_LIGHTPHI             (0x0300000c)
#define D3DXES_LIGHTENABLE          (0x0300000d)

#define D3DXES_MATERIALDIFFUSE      (0x04000000)
#define D3DXES_MATERIALAMBIENT      (0x04000001)
#define D3DXES_MATERIALSPECULAR     (0x04000002)
#define D3DXES_MATERIALEMISSIVE     (0x04000003)
#define D3DXES_MATERIALPOWER        (0x04000004)

#define D3DXES_TEXTURE              (0x05000000)

#define D3DXES_VERTEXSHADER         (0x06000000)
#define D3DXES_PIXELSHADER          (0x06000001)
#define D3DXES_VERTEXSHADERCONSTANT (0x06000002)
#define D3DXES_PIXELSHADERCONSTANT  (0x06000003)

#define D3DXES_PROJECTIONTRANSFORM  (0x07000000)
#define D3DXES_VIEWTRANSFORM        (0x07000001)
#define D3DXES_WORLDTRANSFORM       (0x07000002)
#define D3DXES_TEXTURETRANSFORM     (0x07000003)



//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//
// Node
//

class CNode
{
public:
    DWORD   m_dwType;
    UINT    m_cdwData;
    DWORD*  m_pdwData;
    UINT    m_cNodes;
    CNode** m_ppNodes;
    CNode*  m_pStack;

public:
    CNode();
   ~CNode();

    HRESULT Initialize(DWORD dwType, UINT cdwData, UINT cNodes);
};




//
// RValue
//

struct RValue
{
    char*    szName;
    DWORD    dwValue;
};


//
// LValue
//

struct LValue
{
    char*    szName;
    DWORD    dwType;
    DWORD    dwSize;
    DWORD    dwState;
    RValue*  pRValue;
};




//----------------------------------------------------------------------------
// CD3DXEffectCompiler
//----------------------------------------------------------------------------

class CD3DXEffectCompiler
{
    CNode *m_pEffect;
    CNode *m_pErrors;
    CNode *m_pParameters;

    BOOL  m_bFail;

    UINT  m_iLine;
    char  m_szFile[256];
    char *m_pchSource;
    char *m_pchLine;
    char *m_pch;
    char *m_pchLim;

    char  m_szTok[256];
    char *m_pchAsm;
    UINT  m_cchAsm;
    char  m_szFileAsm[256];
    UINT  m_iLineAsm;

public:
    static CD3DXEffectCompiler* s_pCompiler;

public:
    CD3DXEffectCompiler();
   ~CD3DXEffectCompiler();

    HRESULT Compile(LPCVOID pv, UINT cb, LPCSTR szFile, 
        LPD3DXBUFFER *ppCompiledEffect, LPD3DXBUFFER *ppCompilationErrors);

    int     Token();
    void    Production(UINT uProduction, UINT uArgs);
    void    Push(CNode *pNode);
    CNode*  Pop();
    UINT    Serialize(CNode *pNode, LPVOID pv);
    void    Error(char *psz, ...);
    void    AppendError(char *psz);

    HRESULT CreateNode(DWORD dwId, UINT cdwData, UINT cNodes, CNode **ppNode);
    HRESULT EvalExpression(DWORD dwState, CNode **ppNode);
    HRESULT ValidAssignment(DWORD dwDstType, DWORD dwSrcType);
    HRESULT LookupType(char *psz, DWORD *pdwType);
    HRESULT LookupState(char *psz, DWORD dwIndex, DWORD *pdwType, DWORD *pdwState);
    HRESULT LookupParameter(DWORD dwName, DWORD *pdwType);
    HRESULT UnusedParameter(DWORD dwName);
    HRESULT MakeFourCC(char *psz, DWORD *pdwFourCC);
    HRESULT AssembleShader(CNode *pDecl, CNode *pFunc, CNode **ppNode);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\core\shadeasm.h ===
#ifndef lint
static char yysccsid[] = "@(#)yaccpar	1.9 (Berkeley) 02/21/93";
#endif
#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define yyclearin (yychar=(-1))
#define yyerrok (yyerrflag=0)
#define YYRECOVERING (yyerrflag!=0)
#define yyparse d3dxasm_parse
#define yylex d3dxasm_lex
#define yyerror d3dxasm_error
#define yychar d3dxasm_char
#define yyval d3dxasm_val
#define yylval d3dxasm_lval
#define yydebug d3dxasm_debug
#define yynerrs d3dxasm_nerrs
#define yyerrflag d3dxasm_errflag
#define yyss d3dxasm_ss
#define yyssp d3dxasm_ssp
#define yyvs d3dxasm_vs
#define yyvsp d3dxasm_vsp
#define yylhs d3dxasm_lhs
#define yylen d3dxasm_len
#define yydefred d3dxasm_defred
#define yydgoto d3dxasm_dgoto
#define yysindex d3dxasm_sindex
#define yyrindex d3dxasm_rindex
#define yygindex d3dxasm_gindex
#define yytable d3dxasm_table
#define yycheck d3dxasm_check
#define yyname d3dxasm_name
#define yyrule d3dxasm_rule
#define YYPREFIX "d3dxasm_"

#define isatty _isatty
#define fileno _fileno

#define T_VS 257
#define T_PS 258
#define T_DEF 259
#define T_OP0 260
#define T_OP1 261
#define T_OP2 262
#define T_OP3 263
#define T_OP4 264
#define T_ID 265
#define T_NUM 266
#define T_FLT 267
#define T_EOF 268
#define YYERRCODE 256
short d3dxasm_lhs[] = {                                        -1,
    0,    0,    1,    1,    2,    2,    5,    5,    6,    4,
    4,    9,    9,    9,    9,    9,   12,   12,   14,   14,
   14,   18,   18,    7,    7,   19,   19,   19,   19,   10,
   10,   11,   11,   13,   13,   15,   15,   16,   16,    8,
    8,    8,    8,    8,    8,   17,    3,   20,
};
short d3dxasm_len[] = {                                         2,
    2,    3,    5,    5,    1,    2,    1,    2,   10,    1,
    2,    1,    2,    4,    6,    8,    1,    3,    1,    2,
    3,    1,    3,    1,    4,    1,    1,    3,    3,    1,
    2,    1,    2,    1,    2,    1,    2,    1,    2,    1,
    2,    2,    1,    2,    2,    1,    1,    1,
};
short d3dxasm_defred[] = {                                      0,
    0,    0,    0,    0,    0,    0,    0,   30,   32,   34,
   36,   38,    1,    0,    0,    5,    0,    0,    0,   12,
    0,    0,    0,    0,   47,    0,    0,   46,    0,    0,
   31,   33,   35,   37,   39,    2,    6,    8,   11,    0,
   13,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    3,    4,   48,    0,    0,   40,    0,   43,
    0,    0,    0,    0,   18,    0,    0,   14,   19,    0,
    0,   42,   45,   41,   44,    0,    0,    0,    0,   25,
   20,    0,    0,    0,    0,   29,   23,   28,   21,   15,
    0,    0,    0,    0,   16,    0,    9,
};
short d3dxasm_dgoto[] = {                                       3,
    4,   15,   67,   16,   17,   18,   62,   59,   19,   20,
   21,   41,   22,   68,   23,   24,   30,   69,   64,   60,
};
short d3dxasm_sindex[] = {                                   -253,
  -38,  -14,    0,  -24, -230, -230, -224,    0,    0,    0,
    0,    0,    0, -237, -213,    0,   -6, -214,   -6,    0,
 -224, -224, -224, -224,    0,   14,   15,    0,   18,  -27,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   19,
    0,   22,   26,   27, -230, -230,  -25, -226, -224,  -33,
  -33,  -33,    0,    0,    0, -223, -223,    0,   29,    0,
   31,   30,   32,  -12,    0, -224,   34,    0,    0,   42,
   43,    0,    0,    0,    0,  -25, -226, -224, -226,    0,
    0, -224,  -33,  -33,   44,    0,    0,    0,    0,    0,
   45,  -25,  -33,   46,    0,  -25,    0,
};
short d3dxasm_rindex[] = {                                      0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   -1, -177,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  -43,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  -15,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    2,  -34,    3,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,
};
short d3dxasm_gindex[] = {                                      0,
    0,    0,    1,   16,   74,    0,   61,  -62,    0,    0,
    0,   -7,    0,  -30,    0,    0,  -47,  -10,  -66,   -5,
};
#define YYTABLESIZE 263
short d3dxasm_table[] = {                                      24,
   24,   65,   24,    1,    2,   26,   27,    5,   22,   22,
   86,   66,   88,   85,   42,   43,   44,   57,   14,   56,
   70,   71,   31,   32,   33,   34,   35,   17,   17,   94,
   87,    6,   37,   97,   39,   25,   14,   63,   28,   25,
   28,    7,   25,   55,    7,   53,   54,   58,   61,   24,
   73,   75,   90,   91,   36,   81,   72,   74,   22,   45,
   46,   47,   95,   48,   49,   50,   63,   29,   63,   51,
   52,   89,   76,   77,   79,   78,   58,   61,   82,   61,
   80,   40,   40,   40,   40,   83,   84,   92,   93,   96,
   10,   38,   58,    0,   27,   26,   58,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   24,   24,   24,   24,
   24,    0,    0,    0,   24,   22,   22,   22,   22,   22,
    0,   28,   25,   22,    7,    8,    9,   10,   11,   12,
   25,   55,    0,   13,   17,   17,   17,   17,   17,    0,
    0,    0,   17,    8,    9,   10,   11,   12,    7,    7,
    7,    7,    7,
};
short d3dxasm_check[] = {                                      43,
   44,   49,   46,  257,  258,    5,    6,   46,   43,   44,
   77,   45,   79,   76,   22,   23,   24,   43,   43,   45,
   51,   52,  260,  261,  262,  263,  264,   43,   44,   92,
   78,   46,   17,   96,   19,  266,   43,   48,  265,  266,
  265,   43,  266,  267,  259,   45,   46,   47,   48,   93,
   56,   57,   83,   84,  268,   66,   56,   57,   93,   46,
   46,   44,   93,   91,   46,   44,   77,    7,   79,   44,
   44,   82,   44,   43,   43,   46,   76,   77,   45,   79,
   93,   21,   22,   23,   24,   44,   44,   44,   44,   44,
  268,   18,   92,   -1,   93,   93,   96,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  260,  261,  262,  263,
  264,   -1,   -1,   -1,  268,  260,  261,  262,  263,  264,
   -1,  265,  266,  268,  259,  260,  261,  262,  263,  264,
  266,  267,   -1,  268,  260,  261,  262,  263,  264,   -1,
   -1,   -1,  268,  260,  261,  262,  263,  264,  260,  261,
  262,  263,  264,
};
#define YYFINAL 3
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 268
#if YYDEBUG
char *d3dxasm_name[] = {
"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,"'+'","','","'-'","'.'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"'['",0,"']'",0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"T_VS",
"T_PS","T_DEF","T_OP0","T_OP1","T_OP2","T_OP3","T_OP4","T_ID","T_NUM","T_FLT",
"T_EOF",
};
char *d3dxasm_rule[] = {
"$accept : Shader",
"Shader : Version T_EOF",
"Shader : Version Body T_EOF",
"Version : T_VS '.' Num '.' Num",
"Version : T_PS '.' Num '.' Num",
"Body : Statements",
"Body : Constants Statements",
"Constants : Constant",
"Constants : Constant Constants",
"Constant : T_DEF Reg ',' Val ',' Val ',' Val ',' Val",
"Statements : Statement",
"Statements : Statement Statements",
"Statement : Op0",
"Statement : Op1 Dst",
"Statement : Op2 Dst ',' Src",
"Statement : Op3 Dst ',' Src ',' Src",
"Statement : Op4 Dst ',' Src ',' Src ',' Src",
"Dst : Reg",
"Dst : Reg '.' Id",
"Src : Src2",
"Src : '-' Src2",
"Src : Num '-' Src2",
"Src2 : Reg",
"Src2 : Reg '.' Id",
"Reg : Id",
"Reg : Id '[' Offset ']'",
"Offset : Src2",
"Offset : Num",
"Offset : Src2 '+' Offset",
"Offset : Num '+' Offset",
"Op0 : T_OP0",
"Op0 : '+' T_OP0",
"Op1 : T_OP1",
"Op1 : '+' T_OP1",
"Op2 : T_OP2",
"Op2 : '+' T_OP2",
"Op3 : T_OP3",
"Op3 : '+' T_OP3",
"Op4 : T_OP4",
"Op4 : '+' T_OP4",
"Val : Num",
"Val : '+' Num",
"Val : '-' Num",
"Val : Flt",
"Val : '+' Flt",
"Val : '-' Flt",
"Id : T_ID",
"Num : T_NUM",
"Flt : T_FLT",
};
#endif
#ifndef YYSTYPE
typedef int YYSTYPE;
#endif
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH YYSTACKSIZE
#else
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#else
#define YYSTACKSIZE 500
#define YYMAXDEPTH 500
#endif
#endif
int yydebug;
int yynerrs;
int yyerrflag;
int yychar;
short *yyssp;
YYSTYPE *yyvsp;
YYSTYPE yyval;
YYSTYPE yylval;
short yyss[YYSTACKSIZE];
YYSTYPE yyvs[YYSTACKSIZE];
#define yystacksize YYSTACKSIZE
#define YYABORT goto yyabort
#define YYREJECT goto yyabort
#define YYACCEPT goto yyaccept
#define YYERROR goto yyerrlab
int
yyparse()
{
    register int yym, yyn, yystate;
#if YYDEBUG
    register char *yys;
    extern char *getenv();

    if (yys = getenv("YYDEBUG"))
    {
        yyn = *yys;
        if (yyn >= '0' && yyn <= '9')
            yydebug = yyn - '0';
    }
#endif

    yynerrs = 0;
    yyerrflag = 0;
    yychar = (-1);

    yyssp = yyss;
    yyvsp = yyvs;
    *yyssp = yystate = 0;

yyloop:
    if (yyn = yydefred[yystate]) goto yyreduce;
    if (yychar < 0)
    {
        if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
    }
    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, yystate, yytable[yyn]);
#endif
        if (yyssp >= yyss + yystacksize - 1)
        {
            goto yyoverflow;
        }
        *++yyssp = yystate = yytable[yyn];
        *++yyvsp = yylval;
        yychar = (-1);
        if (yyerrflag > 0)  --yyerrflag;
        goto yyloop;
    }
    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        yyn = yytable[yyn];
        goto yyreduce;
    }
    if (yyerrflag) goto yyinrecovery;
#ifdef lint
    goto yynewerror;
#endif
yynewerror:
    yyerror("syntax error");
#ifdef lint
    goto yyerrlab;
#endif
yyerrlab:
    ++yynerrs;
yyinrecovery:
    if (yyerrflag < 3)
    {
        yyerrflag = 3;
        for (;;)
        {
            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: state %d, error recovery shifting\
 to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
#endif
                if (yyssp >= yyss + yystacksize - 1)
                {
                    goto yyoverflow;
                }
                *++yyssp = yystate = yytable[yyn];
                *++yyvsp = yylval;
                goto yyloop;
            }
            else
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: error recovery discarding state %d\n",
                            YYPREFIX, *yyssp);
#endif
                if (yyssp <= yyss) goto yyabort;
                --yyssp;
                --yyvsp;
            }
        }
    }
    else
    {
        if (yychar == 0) goto yyabort;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
        yychar = (-1);
        goto yyloop;
    }
yyreduce:
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, yystate, yyn, yyrule[yyn]);
#endif
    yym = yylen[yyn];
    yyval = yyvsp[1-yym];
    switch (yyn)
    {
case 1:
{ Prod(P_SHADER_0); }
break;
case 2:
{ Prod(P_SHADER_1); }
break;
case 3:
{ Prod(P_VERSION_0); }
break;
case 4:
{ Prod(P_VERSION_1); }
break;
case 5:
{ Prod(P_BODY_0); }
break;
case 6:
{ Prod(P_BODY_1); }
break;
case 7:
{ Prod(P_CONSTANTS_0); }
break;
case 8:
{ Prod(P_CONSTANTS_1); }
break;
case 9:
{ Prod(P_CONSTANT_0); }
break;
case 10:
{ Prod(P_STATEMENTS_0); }
break;
case 11:
{ Prod(P_STATEMENTS_1); }
break;
case 12:
{ Prod(P_STATEMENT_0); }
break;
case 13:
{ Prod(P_STATEMENT_1); }
break;
case 14:
{ Prod(P_STATEMENT_2); }
break;
case 15:
{ Prod(P_STATEMENT_3); }
break;
case 16:
{ Prod(P_STATEMENT_4); }
break;
case 17:
{ Prod(P_DST_0); }
break;
case 18:
{ Prod(P_DST_1); }
break;
case 19:
{ Prod(P_SRC_0); }
break;
case 20:
{ Prod(P_SRC_1); }
break;
case 21:
{ Prod(P_SRC_2); }
break;
case 22:
{ Prod(P_SRC2_0); }
break;
case 23:
{ Prod(P_SRC2_1); }
break;
case 24:
{ Prod(P_REG_0); }
break;
case 25:
{ Prod(P_REG_1); }
break;
case 26:
{ Prod(P_OFFSET_0); }
break;
case 27:
{ Prod(P_OFFSET_1); }
break;
case 28:
{ Prod(P_OFFSET_2); }
break;
case 29:
{ Prod(P_OFFSET_3); }
break;
case 30:
{ Prod(P_OP0_0); }
break;
case 31:
{ Prod(P_OP0_1); }
break;
case 32:
{ Prod(P_OP1_0); }
break;
case 33:
{ Prod(P_OP1_1); }
break;
case 34:
{ Prod(P_OP2_0); }
break;
case 35:
{ Prod(P_OP2_1); }
break;
case 36:
{ Prod(P_OP3_0); }
break;
case 37:
{ Prod(P_OP3_1); }
break;
case 38:
{ Prod(P_OP4_0); }
break;
case 39:
{ Prod(P_OP4_1); }
break;
case 40:
{ Prod(P_VAL_0); }
break;
case 41:
{ Prod(P_VAL_1); }
break;
case 42:
{ Prod(P_VAL_2); }
break;
case 43:
{ Prod(P_VAL_3); }
break;
case 44:
{ Prod(P_VAL_4); }
break;
case 45:
{ Prod(P_VAL_5); }
break;
case 46:
{ Prod(P_ID); }
break;
case 47:
{ Prod(P_NUM); }
break;
case 48:
{ Prod(P_FLT); }
break;
    }
    yyssp -= yym;
    yystate = *yyssp;
    yyvsp -= yym;
    yym = yylhs[yyn];
    if (yystate == 0 && yym == 0)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: after reduction, shifting from state 0 to\
 state %d\n", YYPREFIX, YYFINAL);
#endif
        yystate = YYFINAL;
        *++yyssp = YYFINAL;
        *++yyvsp = yyval;
        if (yychar < 0)
        {
            if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
            if (yydebug)
            {
                yys = 0;
                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
                if (!yys) yys = "illegal-symbol";
                printf("%sdebug: state %d, reading %d (%s)\n",
                        YYPREFIX, YYFINAL, yychar, yys);
            }
#endif
        }
        if (yychar == 0) goto yyaccept;
        goto yyloop;
    }
    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
        yystate = yytable[yyn];
    else
        yystate = yydgoto[yym];
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: after reduction, shifting from state %d \
to state %d\n", YYPREFIX, *yyssp, yystate);
#endif
    if (yyssp >= yyss + yystacksize - 1)
    {
        goto yyoverflow;
    }
    *++yyssp = yystate;
    *++yyvsp = yyval;
    goto yyloop;
yyoverflow:
    yyerror("yacc stack overflow");
yyabort:
    return (1);
yyaccept:
    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\effect\CD3DXEffectParser.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       compiler.h
//  Content:    Vertex Shader compiler
//
///////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

enum
{
    NODE_EFFECT = 0,
    NODE_DECLARATION,
    NODE_TECHNIQUE,
    NODE_PASS,
    NODE_STAGE,
    NODE_VSHADER,
    NODE_PSHADER,
    NODE_STATE,
    NODE_ID,
    NODE_DWORD,
    NODE_FLOAT,
    NODE_VECTOR,
    NODE_ASM,
};



class Node
{
public:
    DWORD m_dwType;
    Node *m_pNext;
    Node *m_pStack;

public:
    Node(DWORD dwType);
    virtual ~Node();
};

class EffectNode : public Node
{
public:
    Node *m_pDeclarations;
    Node *m_pTechniques;

public:
    EffectNode();
    virtual ~EffectNode();
};


class DeclarationNode : public Node
{
public:
    Node *m_pType;
    Node *m_pName;

public:
    DeclarationNode();
    virtual ~DeclarationNode();
};


class TechniqueNode : public Node
{
public:
    Node *m_pLOD;
    Node *m_pStates;
    Node *m_pPasses;
    Node *m_pShaders;

public:
    TechniqueNode();
    virtual ~TechniqueNode();
};


class PassNode : public Node
{
public:
    Node *m_pSrcBlend;
    Node *m_pDstBlend;
    Node *m_pStates;
    Node *m_pStages;
    Node *m_pShaders;

public:
    PassNode();
    virtual ~PassNode();
};


class StageNode : public Node
{
public:
    Node *m_pTexture;
    Node *m_pMatrix;
    Node *m_pStates;

public:
    StageNode();
    virtual ~StageNode();
};


class VShaderNode : public Node
{
public:
    Node *m_pConst;
    Node *m_pAsm;

public:
    VShaderNode();
    virtual ~VShaderNode();
};


class PShaderNode : public Node
{
public:
    Node *m_pConst;
    Node *m_pAsm;

public:
    PShaderNode();
    virtual ~PShaderNode();
};


class StateNode : public Node
{
public:
    Node *m_pLValue;
    Node *m_pRValue;

public:
    StateNode();
    virtual ~StateNode();
};


class IdNode : public Node
{
public:
    char *m_szId;

public:
    IdNode(char *sz);
    virtual ~IdNode();
};


class DwordNode : public Node
{
public:
    DWORD m_dwValue;

public:
    DwordNode(DWORD dwValue);
};


class FloatNode : public Node
{
public:
    float m_fValue;

public:
    FloatNode(float fValue);
};


class VectorNode : public Node
{
public:
    D3DXVECTOR4 m_vec;

public:
    VectorNode(float x, float y, float z, float w);
};


class AsmNode : public Node
{
public:
    char *m_pchAsm;
    UINT  m_cchAsm;

public:
    AsmNode(char *pchAsm, UINT cchAsm);
};


struct Binding
{
    char *m_szName;
    DWORD m_dwValue;
    Binding *m_pBind;
};




//----------------------------------------------------------------------------
// CD3DXEffectParser
//----------------------------------------------------------------------------

class CD3DXEffectParser
{
    Node *m_pNode;

    BOOL  m_bFail;
    UINT  m_cErrors;
    UINT  m_cbErrors;

    char *m_pchSource;
    char *m_pchLine;
    char *m_pch;
    char *m_pchLim;

    char  m_szTok[256];
    char *m_pchAsm;
    UINT  m_cchAsm;

    UINT  m_iLine;
    char  m_szFile[256];

    EffectNode *m_pEffectNode;
    EffectData *m_pEffectData;

public:
    static CD3DXEffectParser* s_pParser;

public:
    CD3DXEffectParser();
   ~CD3DXEffectParser();


    HRESULT Parse(LPCVOID pv, UINT cb, LPCSTR szFile, LPDIRECT3DDEVICE8 pDevice, 
        LPD3DXEFFECT *ppEffect, LPD3DXBUFFER *ppErrors);


    int  Token();
    void Production(UINT nProduction);
    void Error(char *psz, ...);


protected:
    void  Push(Node *pNode);
    Node *Pop();
    void  Combine();

    HRESULT Compile();
    BOOL Eval(Node *pNode, Binding *pBind, DWORD *pdw, Binding **ppBind);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\effect\CD3DXEffect.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       CD3DXEffect.h
//  Content:    D3DX effect types and functions
//
///////////////////////////////////////////////////////////////////////////

#ifndef __CD3DXEFFECT_H__
#define __CD3DXEFFECT_H__

class EffectData
{
public:
    UINT m_uDwords;
    UINT m_uFloats;
    UINT m_uColors;
    UINT m_uVectors;
    UINT m_uMatrices;
    UINT m_uTextures;
    UINT m_uTechniques;

    UINT m_uMinLOD;
    UINT m_uMaxLOD;

    TechniqueData *m_pTechnique;

public:
    EffectData();
   ~EffectData();
};


//////////////////////////////////////////////////////////////////////////////
// CD3DXEffect ///////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

class CD3DXEffect : public ID3DXEffect
{
public:
    CD3DXEffect();
   ~CD3DXEffect();

    HRESULT Initialize(IDirect3DDevice8 *pDevice, EffectData *pData);


    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    // ID3DXEffect
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice8 **ppDevice);
    STDMETHOD_(D3DXEFFECT_DESC, GetEffectDesc)(THIS);

    STDMETHOD(SetDword)  (THIS_ UINT uIndex, DWORD dw);
    STDMETHOD(SetFloat)  (THIS_ UINT uIndex, float f);
    STDMETHOD(SetColor)  (THIS_ UINT uIndex, D3DCOLOR Color);
    STDMETHOD(SetVector) (THIS_ UINT uIndex, D3DXVECTOR4 *pVector);
    STDMETHOD(SetMatrix) (THIS_ UINT uIndex, D3DMATRIX *pMatrix);
    STDMETHOD(SetTexture)(THIS_ UINT uIndex, IDirect3DBaseTexture8 *pTexture);

    STDMETHOD(GetTechnique) (THIS_ UINT uIndex, ID3DXTechnique **ppTechnique);
    STDMETHOD(PickTechnique)(THIS_ UINT uMinLOD, UINT uMaxLOD, ID3DXTechnique **ppTechnique);


public:
    UINT m_uRefCount;
    EffectData *m_pData;
    IDirect3DBaseTexture8 **m_ppSurface;
    D3DXMATRIX *m_pMatrix;
    IDirect3DDevice8 *m_pDevice;
};

#endif //__CD3DXEFFECT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\effect\ccompiler.cpp ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) Microsoft Corporation.  All Rights Reserved.
//
//  File:       parse.cpp
//  Content:    Parse D3DX Effect files
//
///////////////////////////////////////////////////////////////////////////

#include "pcheffect.h"
#include <xgraphics.h>
#undef AssembleShader

//
// Productions
//

enum
{
    P_EFFECT_BODY0,
    P_EFFECT_BODY1,
    P_PARAMETERS0,
    P_PARAMETERS1,
    P_PARAMETER0,
    P_PARAMETER1,
    P_TECHNIQUES0,
    P_TECHNIQUES1,
    P_TECHNIQUE0,
    P_TECHNIQUE1,
    P_TECHNIQUE_BODY0,
    P_TECHNIQUE_BODY1,
    P_TECHNIQUE_BODY2,
    P_TECHNIQUE_BODY3,
    P_PASSES0,
    P_PASSES1,
    P_PASS0,
    P_PASS1,
    P_PASS_BODY0,
    P_PASS_BODY1,
    P_ASSIGNMENTS0,
    P_ASSIGNMENTS1,
    P_ASSIGNMENT0,
    P_ASSIGNMENT1,
    P_LVALUE0,
    P_LVALUE1,
    P_EXPRESSION0,
    P_EXPRESSION1,
    P_REFERENCE0,
    P_CONST_DWORD,
    P_CONST_FLOAT,
    P_CONST_VECTOR,
    P_CONST_MATRIX,
    P_CONST_VERTEXSHADER,
    P_CONST_PIXELSHADER,
    P_VALUE0,
    P_VALUE1,
    P_DWORD0,
    P_DWORD1,
    P_DWORD2,
    P_DWORD3,
    P_FLOAT0,
    P_FLOAT1,
    P_VECTOR0,
    P_VECTOR1,
    P_VECTOR2,
    P_VECTOR3,
    P_MATRIX0,
    P_VERTEXSHADER0,
    P_VERTEXSHADER1,
    P_PIXELSHADER0,
    P_FOURCC0,
    P_ID0,
    P_DECL0,
    P_ASM0
};

#define Prod(n, m) \
    CD3DXEffectCompiler::s_pCompiler->Production(n, m)

#define d3dxeffect_lex \
    CD3DXEffectCompiler::s_pCompiler->Token

#define d3dxeffect_error \
    CD3DXEffectCompiler::s_pCompiler->Error

#define lint
#pragma warning(disable : 4242)
#include "effect_y.h"
#pragma warning(default : 4242)




//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


#define RVALUE_END() \
    { NULL, 0 }

#define LVALUE_END() \
    { NULL, D3DXPT_DWORD, 0, 0, NULL }


static RValue g_rvType[] =
{
    { "DWORD",        D3DXPT_DWORD         },
    { "FLOAT",        D3DXPT_FLOAT         },
    { "VECTOR",       D3DXPT_VECTOR        },
    { "MATRIX",       D3DXPT_MATRIX        },
    { "TEXTURE",      D3DXPT_TEXTURE       },
    { "VERTEXSHADER", D3DXPT_VERTEXSHADER  },
    { "PIXELSHADER",  D3DXPT_PIXELSHADER   },
    RVALUE_END()
};


static RValue g_rvBool[] =
{
    { "FALSE",  0 },
    { "TRUE",   1 },
    RVALUE_END()
};


static RValue g_rvSHADE[] =
{
    { "FLAT",       D3DSHADE_FLAT    },
    { "GOURAUD",    D3DSHADE_GOURAUD },
    RVALUE_END()            
};

static RValue g_rvFILL[] =
{
    { "POINT",      D3DFILL_POINT     },
    { "WIREFRAME",  D3DFILL_WIREFRAME },
    { "SOLID",      D3DFILL_SOLID     },
    RVALUE_END()
};

static RValue g_rvBLEND[] =
{
    { "ZERO",               D3DBLEND_ZERO            },
    { "ONE",                D3DBLEND_ONE             },
    { "SRCCOLOR",           D3DBLEND_SRCCOLOR        },
    { "INVSRCCOLOR",        D3DBLEND_INVSRCCOLOR     },
    { "SRCALPHA",           D3DBLEND_SRCALPHA        },
    { "INVSRCALPHA",        D3DBLEND_INVSRCALPHA     },
    { "DESTALPHA",          D3DBLEND_DESTALPHA       },
    { "INVDESTALPHA",       D3DBLEND_INVDESTALPHA    },
    { "DESTCOLOR",          D3DBLEND_DESTCOLOR       },
    { "INVDESTCOLOR",       D3DBLEND_INVDESTCOLOR    },
    { "SRCALPHASAT",        D3DBLEND_SRCALPHASAT     },
    RVALUE_END()
};

static RValue g_rvTADDRESS[] =
{
    { "WRAP",   D3DTADDRESS_WRAP   },
    { "MIRROR", D3DTADDRESS_MIRROR },
    { "CLAMP",  D3DTADDRESS_CLAMP  },
    { "BORDER", D3DTADDRESS_BORDER },
    RVALUE_END()
};

static RValue g_rvCULL[] =
{
    { "NONE",   D3DCULL_NONE },
    { "CW",     D3DCULL_CW   },
    { "CCW",    D3DCULL_CCW  },
    RVALUE_END()
};

static RValue g_rvCMP[] =
{
    { "NEVER",          D3DCMP_NEVER        },
    { "LESS",           D3DCMP_LESS         },
    { "EQUAL",          D3DCMP_EQUAL        },
    { "LESSEQUAL",      D3DCMP_LESSEQUAL    },
    { "GREATER",        D3DCMP_GREATER      },
    { "NOTEQUAL",       D3DCMP_NOTEQUAL     },
    { "GREATEREQUAL",   D3DCMP_GREATEREQUAL },
    { "ALWAYS",         D3DCMP_ALWAYS       },
    RVALUE_END()
};

static RValue g_rvSTENCILOP[] =
{
    { "KEEP",       D3DSTENCILOP_KEEP    },
    { "ZERO",       D3DSTENCILOP_ZERO    },
    { "REPLACE",    D3DSTENCILOP_REPLACE },
    { "INCRSAT",    D3DSTENCILOP_INCRSAT },
    { "DECRSAT",    D3DSTENCILOP_DECRSAT },
    { "INVERT",     D3DSTENCILOP_INVERT  },
    { "INCR",       D3DSTENCILOP_INCR    },
    { "DECR",       D3DSTENCILOP_DECR    },
    RVALUE_END()
};


static RValue g_rvFOG[] =
{
    { "NONE",   D3DFOG_NONE   },
    { "EXP",    D3DFOG_EXP    },
    { "EXP2",   D3DFOG_EXP2   },
    { "LINEAR", D3DFOG_LINEAR },
    RVALUE_END()
};


static RValue g_rvZB[] =
{
    { "TRUE",   D3DZB_TRUE  },
    { "FALSE",  D3DZB_FALSE },
    { "USEW",   D3DZB_USEW  },
    RVALUE_END()
};


static RValue g_rvMCS[] =
{
    { "MATERIAL",   D3DMCS_MATERIAL },
    { "COLOR1",     D3DMCS_COLOR1   },
    { "COLOR2",     D3DMCS_COLOR2   },
    RVALUE_END()
};


static RValue g_rvWRAP[] =
{
    { "U",      D3DWRAP_U      },
    { "V",      D3DWRAP_V      },
    { "W",      D3DWRAP_W      },
    { "COORD0", D3DWRAPCOORD_0 },
    { "COORD1", D3DWRAPCOORD_1 },
    { "COORD2", D3DWRAPCOORD_2 },
    { "COORD3", D3DWRAPCOORD_3 },
    RVALUE_END()
};


static RValue g_rvCOLORWRITEENABLE[] =
{
    { "RED",    D3DCOLORWRITEENABLE_RED   },
    { "GREEN",  D3DCOLORWRITEENABLE_GREEN },
    { "BLUE",   D3DCOLORWRITEENABLE_BLUE  },
    { "ALPHA",  D3DCOLORWRITEENABLE_ALPHA },
    RVALUE_END()
};


static RValue g_rvHOB[] =
{
    { "BEZIER",         D3DBASIS_BEZIER      },
    { "BSPLINE",        D3DBASIS_BSPLINE     },
    { "INTERPOLATE",    D3DBASIS_INTERPOLATE },
    RVALUE_END()
};


static RValue g_rvORDER[] =
{
    { "LINEAR", D3DORDER_LINEAR },
    { "CUBIC",  D3DORDER_CUBIC  },
    RVALUE_END()
};


static RValue g_rvVBF[] =
{
    { "DISABLE",    D3DVBF_DISABLE  },
//    { "0WEIGHTS",   D3DVBF_0WEIGHTS },
    { "1WEIGHTS",   D3DVBF_1WEIGHTS },
    { "2WEIGHTS",   D3DVBF_2WEIGHTS },
    { "3WEIGHTS",   D3DVBF_3WEIGHTS },
    RVALUE_END()
};


static RValue g_rvBLENDOP[] =
{
    { "ADD",            D3DBLENDOP_ADD         },
    { "SUBTRACT",       D3DBLENDOP_SUBTRACT    },
    { "REVSUBTRACT",    D3DBLENDOP_REVSUBTRACT },
    { "MIN",            D3DBLENDOP_MIN         },
    { "MAX",            D3DBLENDOP_MAX         },
    RVALUE_END()
};


static RValue g_rvTSS_TCI[] =
{
    { "PASSTHRU",                       D3DTSS_TCI_PASSTHRU                    },
    { "CAMERASPACENORMAL",              D3DTSS_TCI_CAMERASPACENORMAL           },
    { "CAMERASPACEPOSITION",            D3DTSS_TCI_CAMERASPACEPOSITION         },
    { "CAMERASPACEREFLECTIONVECTOR",    D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR },
    RVALUE_END()
};


static RValue g_rvTOP[] =
{
    { "DISABLE",                   D3DTOP_DISABLE                   },
    { "SELECTARG1",                D3DTOP_SELECTARG1                },
    { "SELECTARG2",                D3DTOP_SELECTARG2                },
    { "MODULATE",                  D3DTOP_MODULATE                  },
    { "MODULATE2X",                D3DTOP_MODULATE2X                },
    { "MODULATE4X",                D3DTOP_MODULATE4X                },
    { "ADD",                       D3DTOP_ADD                       },
    { "ADDSIGNED",                 D3DTOP_ADDSIGNED                 },
    { "ADDSIGNED2X",               D3DTOP_ADDSIGNED2X               },
    { "SUBTRACT",                  D3DTOP_SUBTRACT                  },
    { "ADDSMOOTH",                 D3DTOP_ADDSMOOTH                 },
    { "BLENDDIFFUSEALPHA",         D3DTOP_BLENDDIFFUSEALPHA         },
    { "BLENDTEXTUREALPHA",         D3DTOP_BLENDTEXTUREALPHA         },
    { "BLENDFACTORALPHA",          D3DTOP_BLENDFACTORALPHA          },
    { "BLENDTEXTUREALPHAPM",       D3DTOP_BLENDTEXTUREALPHAPM       },
    { "BLENDCURRENTALPHA",         D3DTOP_BLENDCURRENTALPHA         },
    { "PREMODULATE",               D3DTOP_PREMODULATE               },
    { "MODULATEALPHA_ADDCOLOR",    D3DTOP_MODULATEALPHA_ADDCOLOR    },
    { "MODULATECOLOR_ADDALPHA",    D3DTOP_MODULATECOLOR_ADDALPHA    },
    { "MODULATEINVALPHA_ADDCOLOR", D3DTOP_MODULATEINVALPHA_ADDCOLOR },
    { "MODULATEINVCOLOR_ADDALPHA", D3DTOP_MODULATEINVCOLOR_ADDALPHA },
    { "BUMPENVMAP",                D3DTOP_BUMPENVMAP                },
    { "BUMPENVMAPLUMINANCE",       D3DTOP_BUMPENVMAPLUMINANCE       },
    { "DOTPRODUCT3",               D3DTOP_DOTPRODUCT3               },
    { "MULTIPLYADD",               D3DTOP_MULTIPLYADD               },
    { "LERP",                      D3DTOP_LERP                      },
    RVALUE_END()
};


static RValue g_rvTA[] =
{
    { "SELECTMASK",     D3DTA_SELECTMASK     },
    { "DIFFUSE",        D3DTA_DIFFUSE        },
    { "CURRENT",        D3DTA_CURRENT        },
    { "TEXTURE",        D3DTA_TEXTURE        },
    { "TFACTOR",        D3DTA_TFACTOR        },
    { "SPECULAR",       D3DTA_SPECULAR       },
    { "TEMP",           D3DTA_TEMP           },
    { "COMPLEMENT",     D3DTA_COMPLEMENT     },
    { "ALPHAREPLICATE", D3DTA_ALPHAREPLICATE },
    RVALUE_END()
};


static RValue g_rvTEXF[] =
{
    { "NONE",           D3DTEXF_NONE          },
    { "POINT",          D3DTEXF_POINT         },
    { "LINEAR",         D3DTEXF_LINEAR        },
    { "ANISOTROPIC",    D3DTEXF_ANISOTROPIC   },
    { "FLATCUBIC",      D3DTEXF_QUINCUNX      },
    { "GAUSSIANCUBIC",  D3DTEXF_GAUSSIANCUBIC },
    RVALUE_END()
};


static RValue g_rvTTFF[] =
{
    { "FALSE",      D3DTTFF_DISABLE   },
    { "DISABLE",    D3DTTFF_DISABLE   },
    { "COUNT1",     D3DTTFF_COUNT1    },
    { "COUNT2",     D3DTTFF_COUNT2    },
    { "COUNT3",     D3DTTFF_COUNT3    },
    { "COUNT4",     D3DTTFF_COUNT4    },
    { "PROJECTED",  D3DTTFF_PROJECTED },
    RVALUE_END()
};


static RValue g_rvLT[] =
{
    { "POINT",       D3DLIGHT_POINT       },
    { "SPOT",        D3DLIGHT_SPOT        },
    { "DIRECTIONAL", D3DLIGHT_DIRECTIONAL },
    RVALUE_END()
};


static LValue g_lv[] =
{
    // RS    
    { "ZENABLE",                  D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_ZENABLE),                  g_rvZB },
    { "FILLMODE",                 D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_FILLMODE),                 g_rvFILL },
    { "SHADEMODE",                D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_SHADEMODE),                g_rvSHADE },
    { "ZWRITEENABLE",             D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_ZWRITEENABLE),             g_rvBool },
    { "ALPHATESTENABLE",          D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_ALPHATESTENABLE),          g_rvBool },
    { "SRCBLEND",                 D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_SRCBLEND),                 g_rvBLEND },
    { "DESTBLEND",                D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_DESTBLEND),                g_rvBLEND },
    { "CULLMODE",                 D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_CULLMODE),                 g_rvCULL },
    { "ZFUNC",                    D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_ZFUNC),                    g_rvCMP },
    { "ALPHAREF",                 D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_ALPHAREF),                 NULL },
    { "ALPHAFUNC",                D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_ALPHAFUNC),                g_rvCMP },
    { "DITHERENABLE",             D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_DITHERENABLE),             g_rvBool },
    { "ALPHABLENDENABLE",         D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_ALPHABLENDENABLE),         g_rvBool },
    { "FOGENABLE",                D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_FOGENABLE),                g_rvBool },
    { "SPECULARENABLE",           D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_SPECULARENABLE),           g_rvBool },
    { "FOGCOLOR",                 D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_FOGCOLOR),                 NULL },
    { "FOGTABLEMODE",             D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_FOGTABLEMODE),             g_rvFOG },
    { "FOGSTART",                 D3DXPT_FLOAT,        1, D3DXES_RS(D3DRS_FOGSTART),                 NULL },
    { "FOGEND",                   D3DXPT_FLOAT,        1, D3DXES_RS(D3DRS_FOGEND),                   NULL },
    { "FOGDENSITY",               D3DXPT_FLOAT,        1, D3DXES_RS(D3DRS_FOGDENSITY),               NULL },
    { "EDGEANTIALIAS",            D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_EDGEANTIALIAS),            g_rvBool },
    { "ZBIAS",                    D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_ZBIAS),                    NULL },
    { "RANGEFOGENABLE",           D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_RANGEFOGENABLE),           NULL },
    { "STENCILENABLE",            D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_STENCILENABLE),            g_rvBool },
    { "STENCILFAIL",              D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_STENCILFAIL),              g_rvSTENCILOP },
    { "STENCILZFAIL",             D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_STENCILZFAIL),             g_rvSTENCILOP },
    { "STENCILPASS",              D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_STENCILPASS),              g_rvSTENCILOP },
    { "STENCILFUNC",              D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_STENCILFUNC),              g_rvCMP },
    { "STENCILREF",               D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_STENCILREF),               NULL },
    { "STENCILMASK",              D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_STENCILMASK),              NULL },
    { "STENCILWRITEMASK",         D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_STENCILWRITEMASK),         NULL },
    { "TEXTUREFACTOR",            D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_TEXTUREFACTOR),            NULL },
    { "WRAP0",                    D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_WRAP0),                    g_rvWRAP },
    { "WRAP1",                    D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_WRAP1),                    g_rvWRAP },
    { "WRAP2",                    D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_WRAP2),                    g_rvWRAP },
    { "WRAP3",                    D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_WRAP3),                    g_rvWRAP },
    { "LIGHTING",                 D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_LIGHTING),                 g_rvBool },
    { "AMBIENT",                  D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_AMBIENT),                  NULL },
    { "COLORVERTEX",              D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_COLORVERTEX),              g_rvBool },
    { "LOCALVIEWER",              D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_LOCALVIEWER),              g_rvBool },
    { "NORMALIZENORMALS",         D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_NORMALIZENORMALS),         g_rvBool },
    { "DIFFUSEMATERIALSOURCE",    D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_DIFFUSEMATERIALSOURCE),    g_rvMCS },
    { "SPECULARMATERIALSOURCE",   D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_SPECULARMATERIALSOURCE),   g_rvMCS },
    { "AMBIENTMATERIALSOURCE",    D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_AMBIENTMATERIALSOURCE),    g_rvMCS },
    { "EMISSIVEMATERIALSOURCE",   D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_EMISSIVEMATERIALSOURCE),   g_rvMCS },
    { "VERTEXBLEND",              D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_VERTEXBLEND),              g_rvVBF },
    { "POINTSIZE",                D3DXPT_FLOAT,        1, D3DXES_RS(D3DRS_POINTSIZE),                NULL },
    { "POINTSIZE_MIN",            D3DXPT_FLOAT,        1, D3DXES_RS(D3DRS_POINTSIZE_MIN),            NULL },
    { "POINTSIZE_MAX",            D3DXPT_FLOAT,        1, D3DXES_RS(D3DRS_POINTSIZE_MAX),            NULL },
    { "POINTSPRITEENABLE",        D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_POINTSPRITEENABLE),        g_rvBool },
    { "POINTSCALEENABLE",         D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_POINTSCALEENABLE),         g_rvBool },
    { "POINTSCALE_A",             D3DXPT_FLOAT,        1, D3DXES_RS(D3DRS_POINTSCALE_A),             NULL },
    { "POINTSCALE_B",             D3DXPT_FLOAT,        1, D3DXES_RS(D3DRS_POINTSCALE_B),             NULL },
    { "POINTSCALE_C",             D3DXPT_FLOAT,        1, D3DXES_RS(D3DRS_POINTSCALE_C),             NULL },
    { "MULTISAMPLEANTIALIAS",     D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_MULTISAMPLEANTIALIAS),     g_rvBool },
    { "MULTISAMPLEMASK",          D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_MULTISAMPLEMASK),          NULL },
    { "PATCHSEGMENTS",            D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_PATCHSEGMENTS),            NULL },
    { "COLORWRITEENABLE",         D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_COLORWRITEENABLE),         g_rvBool },
    { "BLENDOP",                  D3DXPT_DWORD,        1, D3DXES_RS(D3DRS_BLENDOP),                  g_rvBLENDOP },

    // TSS
    { "COLOROP",                  D3DXPT_DWORD,        8, D3DXES_TSS(D3DTSS_COLOROP),                g_rvTOP },
    { "COLORARG0",                D3DXPT_DWORD,        8, D3DXES_TSS(D3DTSS_COLORARG0),              g_rvTA },
    { "COLORARG1",                D3DXPT_DWORD,        8, D3DXES_TSS(D3DTSS_COLORARG1),              g_rvTA },
    { "COLORARG2",                D3DXPT_DWORD,        8, D3DXES_TSS(D3DTSS_COLORARG2),              g_rvTA },
    { "ALPHAOP",                  D3DXPT_DWORD,        8, D3DXES_TSS(D3DTSS_ALPHAOP),                g_rvTOP },
    { "ALPHAARG0",                D3DXPT_DWORD,        8, D3DXES_TSS(D3DTSS_ALPHAARG0),              g_rvTA },
    { "ALPHAARG1",                D3DXPT_DWORD,        8, D3DXES_TSS(D3DTSS_ALPHAARG1),              g_rvTA },
    { "ALPHAARG2",                D3DXPT_DWORD,        8, D3DXES_TSS(D3DTSS_ALPHAARG2),              g_rvTA },
    { "RESULTARG",                D3DXPT_DWORD,        8, D3DXES_TSS(D3DTSS_RESULTARG),              g_rvTA },
    { "BUMPENVMAT00",             D3DXPT_DWORD,        8, D3DXES_TSS(D3DTSS_BUMPENVMAT00),           NULL },
    { "BUMPENVMAT01",             D3DXPT_DWORD,        8, D3DXES_TSS(D3DTSS_BUMPENVMAT01),           NULL },
    { "BUMPENVMAT10",             D3DXPT_DWORD,        8, D3DXES_TSS(D3DTSS_BUMPENVMAT10),           NULL },
    { "BUMPENVMAT11",             D3DXPT_DWORD,        8, D3DXES_TSS(D3DTSS_BUMPENVMAT11),           NULL },
    { "TEXCOORDINDEX",            D3DXPT_DWORD,        8, D3DXES_TSS(D3DTSS_TEXCOORDINDEX),          g_rvTSS_TCI },
    { "ADDRESSU",                 D3DXPT_DWORD,        8, D3DXES_TSS(D3DTSS_ADDRESSU),               g_rvTADDRESS },
    { "ADDRESSV",                 D3DXPT_DWORD,        8, D3DXES_TSS(D3DTSS_ADDRESSV),               g_rvTADDRESS },
    { "ADDRESSW",                 D3DXPT_DWORD,        8, D3DXES_TSS(D3DTSS_ADDRESSW),               g_rvTADDRESS },
    { "BORDERCOLOR",              D3DXPT_DWORD,        8, D3DXES_TSS(D3DTSS_BORDERCOLOR),            NULL },
    { "MAGFILTER",                D3DXPT_DWORD,        8, D3DXES_TSS(D3DTSS_MAGFILTER),              g_rvTEXF },
    { "MINFILTER",                D3DXPT_DWORD,        8, D3DXES_TSS(D3DTSS_MINFILTER),              g_rvTEXF },
    { "MIPFILTER",                D3DXPT_DWORD,        8, D3DXES_TSS(D3DTSS_MIPFILTER),              g_rvTEXF },
    { "MIPMAPLODBIAS",            D3DXPT_DWORD,        8, D3DXES_TSS(D3DTSS_MIPMAPLODBIAS),          NULL },
    { "MAXMIPLEVEL",              D3DXPT_DWORD,        8, D3DXES_TSS(D3DTSS_MAXMIPLEVEL),            NULL },
    { "MAXANISOTROPY",            D3DXPT_DWORD,        8, D3DXES_TSS(D3DTSS_MAXANISOTROPY),          NULL },
    { "BUMPENVLSCALE",            D3DXPT_FLOAT,        8, D3DXES_TSS(D3DTSS_BUMPENVLSCALE),          NULL },
    { "BUMPENVLOFFSET",           D3DXPT_FLOAT,        8, D3DXES_TSS(D3DTSS_BUMPENVLOFFSET),         NULL },
    { "TEXTURETRANSFORMFLAGS",    D3DXPT_DWORD,        8, D3DXES_TSS(D3DTSS_TEXTURETRANSFORMFLAGS),  g_rvTTFF },

    // Light
    { "LIGHTTYPE",                D3DXPT_DWORD,       -1, D3DXES_LIGHTTYPE,                          g_rvLT },
    { "LIGHTDIFFUSE",             D3DXPT_VECTOR,      -1, D3DXES_LIGHTDIFFUSE,                       NULL },
    { "LIGHTSPECULAR",            D3DXPT_VECTOR,      -1, D3DXES_LIGHTSPECULAR,                      NULL },
    { "LIGHTAMBIENT",             D3DXPT_VECTOR,      -1, D3DXES_LIGHTAMBIENT,                       NULL },
    { "LIGHTPOSITION",            D3DXPT_VECTOR,      -1, D3DXES_LIGHTPOSITION,                      NULL },
    { "LIGHTDIRECTION",           D3DXPT_VECTOR,      -1, D3DXES_LIGHTDIRECTION,                     NULL },
    { "LIGHTRANGE",               D3DXPT_FLOAT,       -1, D3DXES_LIGHTRANGE,                         NULL },
    { "LIGHTFALLOFF",             D3DXPT_FLOAT,       -1, D3DXES_LIGHTFALLOFF,                       NULL },
    { "LIGHTATTENUATION0",        D3DXPT_FLOAT,       -1, D3DXES_LIGHTATTENUATION0,                  NULL },
    { "LIGHTATTENUATION1",        D3DXPT_FLOAT,       -1, D3DXES_LIGHTATTENUATION1,                  NULL },
    { "LIGHTATTENUATION2",        D3DXPT_FLOAT,       -1, D3DXES_LIGHTATTENUATION2,                  NULL },
    { "LIGHTTHETA",               D3DXPT_FLOAT,       -1, D3DXES_LIGHTTHETA,                         NULL },
    { "LIGHTPHI",                 D3DXPT_FLOAT,       -1, D3DXES_LIGHTPHI,                           NULL },
    { "LIGHTENABLE",              D3DXPT_DWORD,       -1, D3DXES_LIGHTENABLE,                        g_rvBool },

    // Material
    { "MATERIALDIFFUSE",          D3DXPT_VECTOR,       1, D3DXES_MATERIALDIFFUSE,                    NULL },
    { "MATERIALAMBIENT",          D3DXPT_VECTOR,       1, D3DXES_MATERIALAMBIENT,                    NULL },
    { "MATERIALSPECULAR",         D3DXPT_VECTOR,       1, D3DXES_MATERIALSPECULAR,                   NULL },
    { "MATERIALEMISSIVE",         D3DXPT_VECTOR,       1, D3DXES_MATERIALEMISSIVE,                   NULL },
    { "MATERIALPOWER",            D3DXPT_FLOAT,        1, D3DXES_MATERIALPOWER,                      NULL },

    // Misc
    { "VERTEXSHADER",             D3DXPT_VERTEXSHADER, 1, D3DXES_VERTEXSHADER,                       NULL },
    { "PIXELSHADER",              D3DXPT_PIXELSHADER,  1, D3DXES_PIXELSHADER,                        NULL },
    { "VERTEXSHADERCONSTANT",     D3DXPT_CONSTANT,    -1, D3DXES_VERTEXSHADERCONSTANT,               NULL },
    { "PIXELSHADERCONSTANT",      D3DXPT_CONSTANT,    -1, D3DXES_PIXELSHADERCONSTANT,                NULL },
    { "TEXTURE",                  D3DXPT_TEXTURE,      8, D3DXES_TEXTURE,                            NULL },
    { "PROJECTIONTRANSFORM",      D3DXPT_MATRIX,       1, D3DXES_PROJECTIONTRANSFORM,                NULL },
    { "VIEWTRANSFORM",            D3DXPT_MATRIX,       1, D3DXES_VIEWTRANSFORM,                      NULL },
    { "WORLDTRANSFORM",           D3DXPT_MATRIX,     256, D3DXES_WORLDTRANSFORM,                     NULL },
    { "TEXTURETRANSFORM",         D3DXPT_MATRIX,       8, D3DXES_TEXTURETRANSFORM,                   NULL },

    LVALUE_END()
};


//////////////////////////////////////////////////////////////////////////////
// CNode /////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

CNode::CNode()
{
    m_dwType  = 0;
    m_cdwData = 0;
    m_pdwData = NULL;
    m_cNodes  = 0;
    m_ppNodes = NULL;
    m_pStack  = NULL;
}


CNode::~CNode()
{
    if(m_pdwData)
        delete [] m_pdwData;

    if(m_ppNodes)
    {
        for(UINT i = 0; i < m_cNodes; i++)
        {
            if(m_ppNodes[i])
                delete m_ppNodes[i];
        }

        delete [] m_ppNodes;
    }

    if(m_pStack)
        delete m_pStack;
}


HRESULT 
CNode::Initialize(DWORD dwType, UINT cdwData, UINT cNodes)
{
    m_dwType  = dwType;
    m_cdwData = cdwData;
    m_cNodes  = cNodes;

    if(m_cdwData)
    {
        if(!(m_pdwData = new DWORD[m_cdwData]))
            return E_OUTOFMEMORY;
    }
    else
    {
        m_pdwData = NULL;
    }


    if(m_cNodes)
    {
        if(!(m_ppNodes = new CNode*[m_cNodes]))
            return E_OUTOFMEMORY;

        memset(m_ppNodes, 0x00, m_cNodes * sizeof(CNode*));
    }
    else
    {
        m_ppNodes = NULL;
    }

    return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
// CEffectCompiler ///////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

CD3DXEffectCompiler* CD3DXEffectCompiler::s_pCompiler = NULL;

CD3DXEffectCompiler::CD3DXEffectCompiler()
{
    m_pEffect = NULL;
    m_pErrors = NULL;
    m_pParameters = NULL;

    m_bFail = FALSE;

    m_iLine     = 1;
    m_szFile[0] = '\0';
    m_pchSource = NULL;
    m_pchLine   = NULL;
    m_pch       = NULL;
    m_pchLim    = NULL;

    m_szTok[0]  = '\0';
    m_pchAsm    = NULL;
    m_cchAsm    = 0;

    s_pCompiler = this;
}


CD3DXEffectCompiler::~CD3DXEffectCompiler()
{
    if(m_pEffect)
        delete m_pEffect;

    if(m_pErrors)
        delete m_pErrors;
}



//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////



HRESULT
CD3DXEffectCompiler::Compile(LPCVOID pv, UINT cb, LPCSTR szFile,
        LPD3DXBUFFER *ppCompiledEffect, LPD3DXBUFFER *ppCompilationErrors)
{
    HRESULT hr = D3DERR_INVALIDCALL;

    if(!pv || !cb)
        goto LDone;

    m_bFail     = FALSE;
    m_iLine     = 1;
    m_pchSource = (char *) pv;
    m_pch       = m_pchSource;
    m_pchLine   = m_pchSource;
    m_pchLim    = m_pchSource + cb;

    _snprintf(m_szFile, 256, "%s", szFile ? szFile : "");



    // Parse

    if(yyparse() || m_bFail)
    {
        delete m_pEffect;
        m_pEffect = NULL;
        hr = E_FAIL;
        goto LDone;
    }

    hr = S_OK;
    goto LDone;


LDone:
    // Create code buffer
    if(ppCompiledEffect)
    {
        UINT cdwSize = Serialize(m_pEffect, NULL);
    
        if(SUCCEEDED(D3DXCreateBuffer(cdwSize * sizeof(DWORD), ppCompiledEffect)))
        {
            Serialize(m_pEffect, (*ppCompiledEffect)->GetBufferPointer());
        }
    }

    // Create error buffer
    if(ppCompilationErrors)
    {
        *ppCompilationErrors = NULL;

        CNode *pNode;
        UINT cbSize = 1;

        for(pNode = m_pErrors; pNode; pNode = pNode->m_pStack)
            cbSize += strlen((char *) pNode->m_pdwData) + 1;

        if(SUCCEEDED(D3DXCreateBuffer(cbSize, ppCompilationErrors)))
        {
            BYTE *pb = (BYTE *) (*ppCompilationErrors)->GetBufferPointer() + cbSize;
            *--pb = '\0';

            for(pNode = m_pErrors; pNode; pNode = pNode->m_pStack)
            {
                UINT cb = strlen((char *) pNode->m_pdwData) + 1;

                pb -= cb;
                memcpy(pb, pNode->m_pdwData, cb);
                pb[cb - 1] = '\n';
            }   
        }
    }

    return hr;
}





int
CD3DXEffectCompiler::Token()
{
    char *pch;
    int nToken;
    SIZE_T cch;

    int iAsm = 0;
    char *pchAsm = NULL;

    while(m_pch < m_pchLim)
    {
        char ch = *m_pch;

        if(ch == '\n')
        {
            // newline
            m_pch++;
            m_pchLine = m_pch;
            m_iLine++;
        }
        else if(isspace(ch))
        {
            // whitespace
            m_pch++;
        }
        else if(ch == '#' && m_pch == m_pchLine)
        {
            // preprocessor directive
            pch = m_pch;
            for(m_pch++; m_pch < m_pchLim && *m_pch != '\n'; m_pch++);

            if(m_pch - pch > 5 && !memcmp(pch, "#line", 5))
            {
                // Skip #line
                for(; pch < m_pch && !isspace(*pch); pch++);

                // Skip whitespace
                for(; pch < m_pch && isspace(*pch); pch++);
                char *pchNum = pch;

                // Line number
                for(; pch < m_pch && !isspace(*pch); pch++);
                char *pchNumLim = pch;

                // Beginning of file name
                for(; pch < m_pch && *pch != '"'; pch++);
                char *pchFile = pch;

                if(pch < m_pch)
                    pch++;

                // End of file name
                for(; pch < m_pch && *pch != '"'; pch++);
                char *pchFileLim = pch;


                char sz[256];

                SIZE_T cchNum = pchNumLim - pchNum;
                SIZE_T cchFile = pchFileLim - pchFile;

                if(cchNum >= sizeof(sz))
                    cchNum = sizeof(sz) - 1;

                if(cchFile >= sizeof(m_szFile))
                    cchFile = sizeof(m_szFile) - 1;

                if(cchNum)
                {
                    memcpy(sz, pchNum, cchNum);
                    sz[cchNum] = 0;
                    m_iLine = atoi(sz) - 1;
                }

                if(cchFile > 1)
                {
                    // Copy filename, removing double backslashes
                    pchFile++;
                    pch = m_szFile;

                    while(pchFile < pchFileLim)
                    {
                        *pch = *pchFile++;

                        if(*pch == '\\' && pchFile < pchFileLim && *pchFile == '\\')
                            pchFile++;

                        pch++;
                    }

                    *pch = 0;
                }
            }
            else
            {
                Error("preprocessor directives are not supported.");
            }
        }
        else if(ch == '/' && m_pch + 1 < m_pchLim && m_pch[1] == '/')
        {
            // comment
            for(m_pch++; m_pch < m_pchLim && *m_pch != '\n'; m_pch++);
        }
        else if(iAsm)
        {
            // Asm block
            if(ch == '{')
            {
                pchAsm = ++m_pch;
                strcpy(m_szFileAsm, m_szFile);
                m_iLineAsm = m_iLine;
            }
            else if(ch == '}')
            {
                m_pchAsm = pchAsm;
                m_cchAsm = (UINT)(m_pch - m_pchAsm);

                m_pch++;
                return iAsm;
            }
            else if((ch == ';') && (iAsm == T_ASM))
            {
                // comment
                for(m_pch++; m_pch < m_pchLim && *m_pch != '\n'; m_pch++);
            }
            else if(!pchAsm)
            {
                // failure!
                m_pchAsm = NULL;
                m_cchAsm = 0;

                return iAsm;
            }
            else
            {
                m_pch++;
            }
        }
        else if(isalpha(ch))
        {
            // keyword / identifier
            pch = m_pch;
            for(m_pch++; m_pch < m_pchLim && (isalnum(*m_pch) || '_' == *m_pch); m_pch++);

            cch = m_pch - pch;

            if(cch >= sizeof(m_szTok))
                cch = sizeof(m_szTok) - 1;

            memcpy(m_szTok, pch, cch);
            m_szTok[cch] = 0;

            if(!_stricmp(m_szTok, "technique")) { return T_KW_TECHNIQUE; }
            if(!_stricmp(m_szTok, "pass"))      { return T_KW_PASS; }
            if(!_stricmp(m_szTok, "asm"))       { iAsm = T_ASM;  continue; }
            if(!_stricmp(m_szTok, "decl"))      { iAsm = T_DECL; continue; }

            return T_ID;
        }
        else if(ch == '0' && m_pch + 1 < m_pchLim && m_pch[1] == 'x')
        {
            // hex
            m_pch += 2;
            pch = m_pch;

            for(; m_pch < m_pchLim && (isdigit(*m_pch) || tolower(*m_pch) >= 'a' && tolower(*m_pch) <= 'f'); m_pch++);

            cch = m_pch - pch;

            if(cch >= sizeof(m_szTok))
                cch = sizeof(m_szTok) - 1;

            memcpy(m_szTok, pch, cch);
            m_szTok[cch] = 0;

            return T_HEX;
        }
        else if(isdigit(ch) || (('.' == ch) && (m_pch + 1 < m_pchLim) && isdigit(m_pch[1])))
        {
            // number
            pch = m_pch;
            nToken = T_INT;

            for(m_pch++; m_pch < m_pchLim; m_pch++)
            {
                if(isdigit(*m_pch))
                    continue;

                if(*m_pch == '.')
                {
                    nToken = T_FLOAT;
                    continue;
                }

                break;
            }

            cch = m_pch - pch;

            if(cch >= sizeof(m_szTok))
                cch = sizeof(m_szTok) - 1;

            memcpy(m_szTok, pch, cch);
            m_szTok[cch] = 0;

            if(m_pch < m_pchLim && *m_pch == 'f')
            {
                nToken = T_FLOAT;
                m_pch++;
            }

            return nToken;
        }
        else
        {
            // other character
            m_pch++;
            return ch;
        }
    }


    if(m_pch == m_pchLim)
    {
        m_pch++;
        return T_EOF;
    }

    return -1;
}



void
CD3DXEffectCompiler::Production(UINT uProduction, UINT uArgs)
{
    UINT i;
    CNode *pNode = NULL;
    CNode **ppArg = (CNode **) _alloca(uArgs * sizeof(CNode *));

    if(m_bFail)
        return;


    // Pop arguments off of stack
    for(i = uArgs; i--; )
        ppArg[i] = Pop();

    if(m_bFail)
        goto LDone;


    // Handle productions
    switch(uProduction)
    {
    case P_EFFECT_BODY0:
        if(FAILED(CreateNode(N_EFFECT, 0, 2, &pNode)))
            break;

        if(FAILED(CreateNode(N_PARAMETERS, 0, 0, &pNode->m_ppNodes[0])))
            break;

        pNode->m_ppNodes[1] = ppArg[0];
        ppArg[0] = NULL;

        break;

    case P_EFFECT_BODY1:
        if(FAILED(CreateNode(N_EFFECT, 0, 2, &pNode)))
            break;

        pNode->m_ppNodes[0] = ppArg[0];
        ppArg[0] = NULL;

        pNode->m_ppNodes[1] = ppArg[1];
        ppArg[1] = NULL;

        break;


    case P_PARAMETERS0:
        if(FAILED(CreateNode(N_PARAMETERS, 0, 1, &pNode)))
            break;

        pNode->m_ppNodes[0] = ppArg[0];
        ppArg[0] = NULL;

        m_pParameters = pNode;
        break;

    case P_PARAMETERS1:
        if(FAILED(UnusedParameter(ppArg[0]->m_pdwData[1])))
            break;

        if(FAILED(CreateNode(N_PARAMETERS, 0, 1 + ppArg[1]->m_cNodes, &pNode)))
            break;

        pNode->m_ppNodes[0] = ppArg[0];
        ppArg[0] = NULL;

        for(i = 0; i < ppArg[1]->m_cNodes; i++)
        {
            pNode->m_ppNodes[i + 1] = ppArg[1]->m_ppNodes[i];
            ppArg[1]->m_ppNodes[i] = NULL;
        }

        m_pParameters = pNode;
        break;


    case P_PARAMETER0:
        if(FAILED(CreateNode(N_PARAMETER, 2, 0, &pNode)))
            break;

        if(FAILED(LookupType((char *) ppArg[0]->m_pdwData, &pNode->m_pdwData[0])))
            break;

        pNode->m_pdwData[1] = ppArg[1]->m_pdwData[0];
        break;

    case P_PARAMETER1:
        if(FAILED(CreateNode(N_PARAMETER, 2, 1, &pNode)))
            break;

        if(FAILED(LookupType((char *) ppArg[0]->m_pdwData, &pNode->m_pdwData[0])))
            break;

        pNode->m_pdwData[1] = ppArg[1]->m_pdwData[0];
        pNode->m_ppNodes[0] = ppArg[2];
        ppArg[2] = NULL;

        if(FAILED(ValidAssignment(pNode->m_pdwData[0], pNode->m_ppNodes[0]->m_pdwData[0])))
            break;

        break;


    case P_TECHNIQUES0:
        if(FAILED(CreateNode(N_TECHNIQUES, 0, 1, &pNode)))
            break;

        pNode->m_ppNodes[0] = ppArg[0];
        ppArg[0] = NULL;

        break;

    case P_TECHNIQUES1:
        if(FAILED(CreateNode(N_TECHNIQUES, 0, 1 + ppArg[1]->m_cNodes, &pNode)))
            break;

        pNode->m_ppNodes[0] = ppArg[0];
        ppArg[0] = NULL;

        for(i = 0; i < ppArg[1]->m_cNodes; i++)
        {
            pNode->m_ppNodes[i + 1] = ppArg[1]->m_ppNodes[i];
            ppArg[1]->m_ppNodes[i] = NULL;
        }

        break;


    case P_TECHNIQUE0:
        if(FAILED(CreateNode(N_TECHNIQUE, 1, ppArg[0]->m_cNodes, &pNode)))
            break;

        pNode->m_pdwData[0] = 0;
        
        for(i = 0; i < ppArg[0]->m_cNodes; i++)
        {
            pNode->m_ppNodes[i] = ppArg[0]->m_ppNodes[i];
            ppArg[0]->m_ppNodes[i] = NULL;
        }

        break;

    case P_TECHNIQUE1:
        if(FAILED(CreateNode(N_TECHNIQUE, 1, ppArg[1]->m_cNodes, &pNode)))
            break;

        pNode->m_pdwData[0] = ppArg[0]->m_pdwData[0];
        
        for(i = 0; i < ppArg[1]->m_cNodes; i++)
        {
            pNode->m_ppNodes[i] = ppArg[1]->m_ppNodes[i];
            ppArg[1]->m_ppNodes[i] = NULL;
        }

        break;


    case P_TECHNIQUE_BODY0:
        if(FAILED(CreateNode(N_INTERNAL, 0, 0, &pNode)))
            break;

        break;

    case P_TECHNIQUE_BODY1:
        pNode = ppArg[0];
        ppArg[0] = NULL;
        break;

    case P_TECHNIQUE_BODY2:
        if(FAILED(CreateNode(N_INTERNAL, 0, 1, &pNode)))
            break;

        if(FAILED(CreateNode(N_PASS, 1, ppArg[0]->m_cNodes, &pNode->m_ppNodes[0])))
            break;

        pNode->m_ppNodes[0]->m_pdwData[0] = 0;

        for(i = 0; i < ppArg[0]->m_cNodes; i++)
        {
            pNode->m_ppNodes[0]->m_ppNodes[i] = ppArg[0]->m_ppNodes[i];
            ppArg[0]->m_ppNodes[i] = NULL;
        }

        break;

    case P_TECHNIQUE_BODY3:
        if(FAILED(CreateNode(N_INTERNAL, 0, ppArg[1]->m_cNodes, &pNode)))
            break;

        if(FAILED(CreateNode(N_PASS, 1, ppArg[0]->m_cNodes + ppArg[1]->m_ppNodes[0]->m_cNodes, &pNode->m_ppNodes[0])))
            break;

        pNode->m_ppNodes[0]->m_pdwData[0] = ppArg[1]->m_ppNodes[0]->m_pdwData[0];

        for(i = 0; i < ppArg[0]->m_cNodes; i++)
        {
            pNode->m_ppNodes[0]->m_ppNodes[i] = ppArg[0]->m_ppNodes[i];
            ppArg[0]->m_ppNodes[i] = NULL;
        }

        for(i = 0; i < ppArg[1]->m_ppNodes[0]->m_cNodes; i++)
        {
            pNode->m_ppNodes[0]->m_ppNodes[i + ppArg[0]->m_cNodes] = ppArg[1]->m_ppNodes[0]->m_ppNodes[i];
            ppArg[1]->m_ppNodes[0]->m_ppNodes[i] = NULL;
        }

        for(i = 1; i < ppArg[1]->m_cNodes; i++)
        {
            pNode->m_ppNodes[i] = ppArg[1]->m_ppNodes[i];
            ppArg[1]->m_ppNodes[i] = NULL;
        }

        break;


    case P_PASSES0:
        if(FAILED(CreateNode(N_INTERNAL, 0, 1, &pNode)))
            break;

        pNode->m_ppNodes[0] = ppArg[0];
        ppArg[0] = NULL;

        break;

    case P_PASSES1:
        if(FAILED(CreateNode(N_INTERNAL, 0, 1 + ppArg[1]->m_cNodes, &pNode)))
            break;

        pNode->m_ppNodes[0] = ppArg[0];
        ppArg[0] = NULL;

        for(i = 0; i < ppArg[1]->m_cNodes; i++)
        {
            pNode->m_ppNodes[i + 1] = ppArg[1]->m_ppNodes[i];
            ppArg[1]->m_ppNodes[i] = NULL;
        }

        break;


    case P_PASS0:
        if(FAILED(CreateNode(N_PASS, 1, ppArg[0]->m_cNodes, &pNode)))
            break;

        pNode->m_pdwData[0] = 0;

        for(i = 0; i < ppArg[0]->m_cNodes; i++)
        {
            pNode->m_ppNodes[i] = ppArg[0]->m_ppNodes[i];
            ppArg[0]->m_ppNodes[i] = NULL;
        }

        break;

    case P_PASS1:
        if(FAILED(CreateNode(N_PASS, 1, ppArg[1]->m_cNodes, &pNode)))
            break;

        pNode->m_pdwData[0] = ppArg[0]->m_pdwData[0];

        for(i = 0; i < ppArg[1]->m_cNodes; i++)
        {
            pNode->m_ppNodes[i] = ppArg[1]->m_ppNodes[i];
            ppArg[1]->m_ppNodes[i] = NULL;
        }

        break;


    case P_PASS_BODY0:
        if(FAILED(CreateNode(N_INTERNAL, 0, 0, &pNode)))
            break;

        break;

    case P_PASS_BODY1:
        pNode = ppArg[0];
        ppArg[0] = NULL;
        break;


    case P_ASSIGNMENTS0:
        if(FAILED(CreateNode(N_INTERNAL, 0, 1, &pNode)))
            break;

        pNode->m_ppNodes[0] = ppArg[0];
        ppArg[0] = NULL;

        break;

    case P_ASSIGNMENTS1:
        if(FAILED(CreateNode(N_INTERNAL, 0, 1 + ppArg[1]->m_cNodes, &pNode)))
            break;

        pNode->m_ppNodes[0] = ppArg[0];
        ppArg[0] = NULL;

        for(i = 0; i < ppArg[1]->m_cNodes; i++)
        {
            pNode->m_ppNodes[i + 1] = ppArg[1]->m_ppNodes[i];
            ppArg[1]->m_ppNodes[i] = NULL;
        }

        break;


    case P_ASSIGNMENT0:
        if(FAILED(CreateNode(N_ASSIGNMENT, 3, 1, &pNode)))
            break;

        pNode->m_pdwData[0] = ppArg[0]->m_pdwData[0];
        pNode->m_pdwData[1] = ppArg[0]->m_pdwData[1];
        pNode->m_pdwData[2] = ppArg[0]->m_pdwData[2];

        pNode->m_ppNodes[0] = ppArg[1];
        ppArg[1] = NULL;

        if(FAILED(EvalExpression(pNode->m_pdwData[1], &pNode->m_ppNodes[0])))
            break;

        if(FAILED(ValidAssignment(pNode->m_pdwData[0], pNode->m_ppNodes[0]->m_pdwData[0])))
            break;

        break;
        
    case P_ASSIGNMENT1:
        if(FAILED(CreateNode(N_ASSIGNMENT, 3, 1, &pNode)))
            break;

        pNode->m_pdwData[0] = ppArg[0]->m_pdwData[0];
        pNode->m_pdwData[1] = ppArg[0]->m_pdwData[1];
        pNode->m_pdwData[2] = ppArg[0]->m_pdwData[2];

        pNode->m_ppNodes[0] = ppArg[1];
        ppArg[1] = NULL;

        if(FAILED(ValidAssignment(pNode->m_pdwData[0], pNode->m_ppNodes[0]->m_pdwData[0])))
            break;

        break;

        
    case P_LVALUE0:
        if(FAILED(CreateNode(N_INTERNAL, 3, 0, &pNode)))
            break;

        if(FAILED(LookupState((char *) ppArg[0]->m_pdwData, 0, 
            &pNode->m_pdwData[0], &pNode->m_pdwData[1])))
        {
           break;
        }

        pNode->m_pdwData[2] = 0;
        break;

    case P_LVALUE1:
        if(FAILED(CreateNode(N_INTERNAL, 3, 0, &pNode)))
            break;

        if(FAILED(LookupState((char *) ppArg[0]->m_pdwData, ppArg[1]->m_pdwData[1], 
            &pNode->m_pdwData[0], &pNode->m_pdwData[1])))
        {
            break;
        }

        pNode->m_pdwData[2] = ppArg[1]->m_pdwData[1];
        break;


    case P_EXPRESSION0:
        pNode = ppArg[0];
        ppArg[0] = NULL;
        break;

    case P_EXPRESSION1:
        if(FAILED(CreateNode(ppArg[0]->m_dwType, ppArg[0]->m_cdwData, 1, &pNode)))
            break;

        for(i = 0; i < ppArg[0]->m_cdwData; i++)
            pNode->m_pdwData[i] = ppArg[0]->m_pdwData[i];

        pNode->m_ppNodes[0] = ppArg[1];
        ppArg[1] = NULL;
        break;


    case P_REFERENCE0:
        if(FAILED(CreateNode(N_REFERENCE, 2, 0, &pNode)))
            break;

        if(FAILED(LookupParameter(ppArg[0]->m_pdwData[0], &pNode->m_pdwData[0])))
            break;

        pNode->m_pdwData[1] = ppArg[0]->m_pdwData[0];
        break;


    case P_CONST_DWORD:
    case P_CONST_FLOAT:
    case P_CONST_VECTOR:
    case P_CONST_MATRIX:
    case P_CONST_VERTEXSHADER:
    case P_CONST_PIXELSHADER:
        pNode = ppArg[0];
        ppArg[0] = NULL;
        break;


    case P_VALUE0:
    case P_VALUE1:
        pNode = ppArg[0];
        ppArg[0] = NULL;
        break;


    case P_DWORD0:
        if(FAILED(CreateNode(N_VALUE, 2, 0, &pNode)))
            break;

        pNode->m_pdwData[0] = D3DXPT_DWORD;
        sscanf(m_szTok, "%d", &pNode->m_pdwData[1]);
        break;

    case P_DWORD1:
        if(FAILED(CreateNode(N_VALUE, 2, 0, &pNode)))
            break;

        pNode->m_pdwData[0] = D3DXPT_DWORD;
        sscanf(m_szTok, "%d", &pNode->m_pdwData[1]);
        pNode->m_pdwData[1] = 0 - pNode->m_pdwData[1];
        break;

    case P_DWORD2:
        if(FAILED(CreateNode(N_VALUE, 2, 0, &pNode)))
            break;

        pNode->m_pdwData[0] = D3DXPT_DWORD;
        sscanf(m_szTok, "%x", &pNode->m_pdwData[1]);
        break;

    case P_DWORD3:
        if(FAILED(CreateNode(N_VALUE, 2, 0, &pNode)))
            break;

        pNode->m_pdwData[0] = D3DXPT_DWORD;
        sscanf(m_szTok, "%x", &pNode->m_pdwData[1]);
        pNode->m_pdwData[1] = 0 - pNode->m_pdwData[1];
        break;


    case P_FLOAT0:
        if(FAILED(CreateNode(N_VALUE, 2, 0, &pNode)))
            break;

        pNode->m_pdwData[0] = D3DXPT_FLOAT;
        sscanf(m_szTok, "%f", &pNode->m_pdwData[1]);
        break;

    case P_FLOAT1:
        if(FAILED(CreateNode(N_VALUE, 2, 0, &pNode)))
            break;

        pNode->m_pdwData[0] = D3DXPT_FLOAT;
        sscanf(m_szTok, "%f", &pNode->m_pdwData[1]);
        *((FLOAT *) &pNode->m_pdwData[1]) = - *((FLOAT *) &pNode->m_pdwData[1]);
        break;


    case P_VECTOR0:
        if(FAILED(CreateNode(N_VALUE, 5, 0, &pNode)))
            break;

        pNode->m_pdwData[0] = D3DXPT_VECTOR;
        pNode->m_pdwData[1] = ppArg[0]->m_pdwData[0];

        ((FLOAT *) pNode->m_pdwData)[2] = 0.0f;
        ((FLOAT *) pNode->m_pdwData)[3] = 0.0f;
        ((FLOAT *) pNode->m_pdwData)[4] = 1.0f;
        break;

    case P_VECTOR1:
        if(FAILED(CreateNode(N_VALUE, 5, 0, &pNode)))
            break;

        pNode->m_pdwData[0] = D3DXPT_VECTOR;
        pNode->m_pdwData[1] = ppArg[0]->m_pdwData[0];
        pNode->m_pdwData[2] = ppArg[1]->m_pdwData[0];

        ((FLOAT *) pNode->m_pdwData)[3] = 0.0f;
        ((FLOAT *) pNode->m_pdwData)[4] = 1.0f;
        break;

    case P_VECTOR2:
        if(FAILED(CreateNode(N_VALUE, 5, 0, &pNode)))
            break;

        pNode->m_pdwData[0] = D3DXPT_VECTOR;
        pNode->m_pdwData[1] = ppArg[0]->m_pdwData[0];
        pNode->m_pdwData[2] = ppArg[1]->m_pdwData[0];
        pNode->m_pdwData[3] = ppArg[2]->m_pdwData[0];

        ((FLOAT *) pNode->m_pdwData)[4] = 1.0f;
        break;

    case P_VECTOR3:
        if(FAILED(CreateNode(N_VALUE, 5, 0, &pNode)))
            break;

        pNode->m_pdwData[0] = D3DXPT_VECTOR;
        pNode->m_pdwData[1] = ppArg[0]->m_pdwData[0];
        pNode->m_pdwData[2] = ppArg[1]->m_pdwData[0];
        pNode->m_pdwData[3] = ppArg[2]->m_pdwData[0];
        pNode->m_pdwData[4] = ppArg[3]->m_pdwData[0];
        break;


    case P_MATRIX0:
        if(FAILED(CreateNode(N_VALUE, 17, 0, &pNode)))
            break;

        pNode->m_pdwData[0] = D3DXPT_MATRIX;
        
        for(i = 0; i < 16; i++)
            pNode->m_pdwData[i + 1] = ppArg[i]->m_pdwData[0];

        break;


    case P_VERTEXSHADER0:
        AssembleShader(ppArg[0], NULL, &pNode);
        break;

    case P_VERTEXSHADER1:
        AssembleShader(ppArg[0], ppArg[1], &pNode);
        break;

    case P_PIXELSHADER0:
        AssembleShader(NULL, ppArg[0], &pNode);
        break;


    case P_FOURCC0:
        if(FAILED(CreateNode(N_INTERNAL, 1, 0, &pNode)))
            break;

        if(FAILED(MakeFourCC((char *) ppArg[0]->m_pdwData, &pNode->m_pdwData[0])))
            break;

        break;


    case P_ID0:
        {
            UINT cb  = strlen(m_szTok) + 1;
            UINT cdw = (cb + 3) >> 2;

            if(FAILED(CreateNode(N_INTERNAL, cdw, 0, &pNode)))
                break;

            memset(pNode->m_pdwData, 0x00, cdw * sizeof(DWORD));
            memcpy(pNode->m_pdwData, m_szTok, cb);
        }

        break;


    case P_DECL0:
    case P_ASM0:
        {
            UINT cb  = m_cchAsm + 1;
            UINT cdw = (cb + 3) >> 2;

            if(FAILED(CreateNode(N_INTERNAL, cdw, 0, &pNode)))
                break;

            memset(pNode->m_pdwData, 0x00, cdw * sizeof(DWORD));
            memcpy(pNode->m_pdwData, m_pchAsm, m_cchAsm);
        }

        break;
    }


    // Push the new node on the stack
    if(!m_bFail)
    {
        if(pNode)
            Push(pNode);
        else
            Error("Internal compiler error! %d", __LINE__);
    }


LDone:
    // Delete arguments
    for(i = 0; i < uArgs; i++)
    {
        if(ppArg[i])
            delete ppArg[i];
    }

    return;
}



void
CD3DXEffectCompiler::Push(CNode *pNode)
{
    if(!pNode || pNode->m_pStack)
    {
        Error("Internal compiler error! %d", __LINE__);
        return;
    }

    pNode->m_pStack = m_pEffect;
    m_pEffect = pNode;
    return;
}


CNode *
CD3DXEffectCompiler::Pop()
{
    if(!m_pEffect)
    {
        Error("Internal compiler error! %d", __LINE__);
        return NULL;
    }

    CNode *pNode = m_pEffect;
    m_pEffect = pNode->m_pStack;
    pNode->m_pStack = NULL;
    return pNode;
}


UINT 
CD3DXEffectCompiler::Serialize(CNode *pNode, LPVOID pv)
{
    UINT   cdw = 0;
    DWORD* pdw = (DWORD *) pv;
    
    if(!pNode)
        return 0;


    // Header
    if(pdw)
    {
        pdw[0] = pNode->m_dwType;
        pdw[1] = (DWORD) pNode->m_cdwData;
        pdw[2] = 0; // Filled in later;

        pdw += 3;
    }

    cdw += 3;


    // Data
    if(pdw)
    {
        memcpy(pdw, pNode->m_pdwData, pNode->m_cdwData * sizeof(DWORD));
        pdw += pNode->m_cdwData;
    }

    cdw += pNode->m_cdwData;


    // Nodes
    for(UINT i = 0; i < pNode->m_cNodes; i++)
    {
        UINT cdwNode;

        cdwNode = Serialize(pNode->m_ppNodes[i], pdw);

        if(pdw)
            pdw += cdwNode;

        cdw += cdwNode;
    }

    if(pdw)
        ((DWORD *) pv)[2] = (DWORD) (cdw - pNode->m_cdwData - 3);

    return cdw;
}


void
CD3DXEffectCompiler::Error(char *szFormat, ...)
{
    char szA[256];
    char szB[256];


    // Format error
    va_list ap;
    va_start(ap, szFormat);
    _vsnprintf(szA, sizeof(szA), szFormat, ap);
    szA[255] = '\0';
    va_end(ap);

    _snprintf(szB, sizeof(szB), "%s(%d) : %s", m_szFile, m_iLine, szA);
    szB[255] = '\0';


    // Output error in debug spew
    DPF(0, "%s", szB);
    AppendError(szB);
    m_bFail = TRUE;
}


void
CD3DXEffectCompiler::AppendError(char *sz)
{
    UINT cch = strlen(sz);

    if(cch && sz[cch - 1] == '\n')
        cch--;

    if(!cch)
        return;


    CNode *pNode = new CNode;

    if(pNode && SUCCEEDED(pNode->Initialize(0, (cch + 4) >> 2, 0)))
    {
        memcpy(pNode->m_pdwData, sz, cch);
        ((char *) pNode->m_pdwData)[cch] = 0;

        pNode->m_pStack = m_pErrors;
        m_pErrors = pNode;
    }
}


HRESULT 
CD3DXEffectCompiler::CreateNode(DWORD dwId, UINT cdwData, UINT cNodes, CNode **ppNode)
{
    CNode *pNode;

    D3DXASSERT(ppNode != NULL);

    if(!(pNode = new CNode))
    {
        Error("Out of memory!");
        return E_OUTOFMEMORY;
    }

    if(FAILED(pNode->Initialize(dwId, cdwData, cNodes)))
    {
        delete pNode;
        Error("Out of memory!");
        return E_OUTOFMEMORY;
    }

    *ppNode = pNode;
    return S_OK;
}


HRESULT 
CD3DXEffectCompiler::EvalExpression(DWORD dwState, CNode **ppNode)
{
    CNode *pNode = *ppNode;

    if((N_VALUE == pNode->m_dwType) && (0 == pNode->m_cNodes))
        return S_OK;

    DWORD dwType  = D3DXPT_DWORD;
    DWORD dwValue = 0;


    // Find RValue set for this state
    RValue *prvState;
    LValue *plv;

    for(plv = g_lv; plv->szName; plv++)
    {
        if(plv->dwState == dwState)
            break;
    }

    if(!plv->szName)
    {
        Error("Internal compiler error! %d", __LINE__);
        return E_FAIL;
    }

    prvState = plv->pRValue;


    // Loop thru expression
    while(pNode)
    {
        if(pNode->m_dwType == N_VALUE)
        {
            switch(pNode->m_pdwData[0])
            {
            case D3DXPT_DWORD:
                dwValue |= pNode->m_pdwData[1];
                break;

            case D3DXPT_VECTOR:                
                dwValue |= (DWORD) D3DXCOLOR((FLOAT *) &pNode->m_pdwData[1]);
                break;

            default:
                Error("Invalid type in DWORD expression");
                return E_FAIL;
            }
        }
        else if(prvState)
        {
            for(RValue *prv = prvState; prv->szName; prv++)
            {
                if(!_stricmp(prv->szName, (char *) pNode->m_pdwData))
                {
                    dwValue |= prv->dwValue;   
                    break;
                }
            }

            if(!prv->szName)
            {
                Error("Unknown value in DWORD expression: '%s'", (char *) pNode->m_pdwData);
                return E_FAIL;
            }
        }

        if(0 == pNode->m_cNodes)
            break;

        pNode = pNode->m_ppNodes[0];
    }

    HRESULT hr;
    if(FAILED(hr = CreateNode(N_VALUE, 2, 0, &pNode)))
        return hr;

    pNode->m_pdwData[0] = dwType;
    pNode->m_pdwData[1] = dwValue;

    delete *ppNode;
    *ppNode = pNode;

    return S_OK;
}


HRESULT 
CD3DXEffectCompiler::ValidAssignment(DWORD dwDstType, DWORD dwSrcType)
{
    static const BOOL bDstSrc[8][8] =
    {        
    //    Src                       Dest
    //    D  F  V  M  T  V  P
        { 1, 0, 1, 0, 0, 0, 0, 0 }, // DWORD
        { 0, 1, 0, 0, 0, 0, 0, 0 }, // FLOAT  
        { 1, 1, 1, 0, 0, 0, 0, 0 }, // VECTOR 
        { 0, 0, 0, 1, 0, 0, 0, 0 }, // MATRIX 
        { 0, 0, 0, 0, 1, 0, 0, 0 }, // TEXTURE
        { 0, 0, 0, 0, 0, 1, 0, 0 }, // VERTEXSHADER
        { 0, 0, 0, 0, 0, 0, 1, 0 }, // PIXELSHADER
        { 1, 1, 1, 1, 0, 0, 0, 0 }, // CONSTANT
    };


    if(!bDstSrc[dwDstType][dwSrcType])
    {
        static const char *szName[8] =
        {
            "DWORD",
            "FLOAT",
            "VECTOR",
            "MATRIX",
            "TEXTURE",
            "VERTEXSHADER",
            "PIXELSHADER",
            "CONSTANT"
        };

        Error("Invalid assignment: %s = %s", szName[dwDstType], szName[dwSrcType]);
        return E_FAIL;
    }
    
    return S_OK;
}


HRESULT
CD3DXEffectCompiler::LookupType(char *psz, DWORD *pdwType)
{
    for(RValue *prv = g_rvType; prv->szName; prv++)
    {
        if(!_stricmp(psz, prv->szName))
        {
            if(pdwType)
                *pdwType = prv->dwValue;

            return S_OK;
        }
    }

    Error("Unknown type in parameter declaration: '%s'", psz);
    return E_FAIL;
}


HRESULT 
CD3DXEffectCompiler::LookupState(char *psz, DWORD dwIndex, DWORD *pdwType, DWORD *pdwState)
{
    for(LValue *plv = g_lv; plv->szName; plv++)
    {
        if(!_stricmp(psz, plv->szName))
        {
            if(dwIndex >= plv->dwSize)
            {
                Error("Invalid index: '%s[%d]' (must be < %d)", psz, dwIndex, plv->dwSize);
                return E_FAIL;
            }

            if(pdwType)
                *pdwType = plv->dwType;

            if(pdwState)
                *pdwState = plv->dwState;

            return S_OK;
        }
    }

    Error("Unknown state '%s'", psz);
    return E_FAIL;
}


HRESULT 
CD3DXEffectCompiler::LookupParameter(DWORD dwName, DWORD *pdwType)
{
    // Find name in parameter list
    if(m_pParameters)
    {
        for(UINT iNode = 0; iNode < m_pParameters->m_cNodes; iNode++)
        {
            if(m_pParameters->m_ppNodes[iNode]->m_pdwData[1] == dwName)
            {
                if(pdwType)
                    *pdwType = m_pParameters->m_ppNodes[iNode]->m_pdwData[0];

                return S_OK;
            }
        }
    }

    Error("Undeclared parameter: '%.4s'", &dwName);
    return E_FAIL;
}


HRESULT 
CD3DXEffectCompiler::UnusedParameter(DWORD dwName)
{
    // Find name in parameter list
    if(m_pParameters)
    {
        for(UINT iNode = 0; iNode < m_pParameters->m_cNodes; iNode++)
        {
            if(m_pParameters->m_ppNodes[iNode]->m_pdwData[1] == dwName)
            {
                Error("Parameter declared more than once: '%.4s'", &dwName);
                return S_OK;
            }
        }
    }

    return S_OK;
}


HRESULT 
CD3DXEffectCompiler::MakeFourCC(char *psz, DWORD *pdwFourCC)
{
    D3DXASSERT(pdwFourCC != NULL);

    char ch[4];
    UINT cch = strlen(psz);

    if(cch > 4)
    {
        Error("Invalid FourCC: '%s'", psz);
        return E_FAIL;
    }

    memset(ch, 0x00, 4);
    memcpy(ch, psz, cch);

    *pdwFourCC = MAKEFOURCC(ch[0], ch[1], ch[2], ch[3]);
    return S_OK;
}


HRESULT 
CD3DXEffectCompiler::AssembleShader(CNode *pDeclNode, CNode *pFuncNode, CNode **ppNode)
{
    return E_NOTIMPL;

    HRESULT hr;

    LPD3DXBUFFER pDecl   = NULL;
    LPD3DXBUFFER pd3dxErrors = NULL;
    LPXGBUFFER pConst  = NULL;
    LPXGBUFFER pFunc   = NULL;
    LPXGBUFFER pErrors = NULL;

    CNode *pNode;

    DWORD cdwDecl, cdwConst, cdwFunc;
    DWORD *pdwDecl, *pdwConst, *pdwFunc;

    // Assemble declaration
    if(pDeclNode)
    {
        char *szDecl = (char *) pDeclNode->m_pdwData;
        UINT cchDecl = strlen(szDecl);

        CD3DXDeclarationCompiler compiler;

        hr = compiler.Compile(szDecl, cchDecl, m_szFileAsm, m_iLineAsm, &pDecl, &pd3dxErrors);

        if(pd3dxErrors)
        {
            AppendError((char *) pd3dxErrors->GetBufferPointer());
            RELEASE(pErrors);
        }

        if(FAILED(hr))
        {
            m_bFail = TRUE;
            goto LDone;
        }
    }


    // Assemble shader
    if(pFuncNode)
    {
        char *szFunc = (char *) pFuncNode->m_pdwData;
        UINT cchFunc = strlen(szFunc);

        XGAssembleShader(
                m_szFileAsm,
                szFunc,
                cchFunc,
                SASM_DEBUG,
                &pConst,
                &pFunc,
                &pErrors,
                NULL,
                NULL,
                NULL,
                NULL);


        if(pErrors)
        {
            AppendError((char *) pErrors->GetBufferPointer());
            RELEASE(pErrors);
        }

        if(FAILED(hr))
        {
            m_bFail = TRUE;
            goto LDone;
        }
    }


    // Create shader node
    cdwDecl  = pDecl  ? (pDecl ->GetBufferSize() >> 2) : 0;
    cdwConst = pConst ? (pConst->GetBufferSize() >> 2) : 0;
    cdwFunc  = pFunc  ? (pFunc ->GetBufferSize() >> 2) : 0;

    pdwDecl  = pDecl  ? (DWORD *) pDecl ->GetBufferPointer() : NULL;
    pdwConst = pConst ? (DWORD *) pConst->GetBufferPointer() : NULL;
    pdwFunc  = pFunc  ? (DWORD *) pFunc ->GetBufferPointer() : NULL;

    if(cdwConst && !pDeclNode)
    {
        Error("Constant definitions in pixel shaders currently unsupported.");
        hr = E_FAIL;
        goto LDone;
    }


    if(FAILED(hr = CreateNode(N_VALUE, 2 + cdwDecl + cdwConst + cdwFunc, 0, &pNode)))
        goto LDone;


    pNode->m_pdwData[0] = pDeclNode ? D3DXPT_VERTEXSHADER : D3DXPT_PIXELSHADER;
    pNode->m_pdwData[1] = (DWORD) (cdwDecl + cdwConst);

    memcpy(&pNode->m_pdwData[2], pdwDecl, cdwDecl << 2);
    memcpy(&pNode->m_pdwData[2 + cdwDecl], pdwConst, cdwConst << 2);
    memcpy(&pNode->m_pdwData[2 + cdwDecl + cdwConst], pdwFunc, cdwFunc << 2);

    *ppNode = pNode;

    hr = S_OK;
    goto LDone;


LDone:
    RELEASE(pDecl);
    RELEASE(pConst);
    RELEASE(pFunc);
    RELEASE(pErrors);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\effect\CD3DXTechnique.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       effect.h
//  Content:    D3DX effect types and functions
//
//////////////////////////////////////////////////////////////////////////////


#include "pcheffect.h"




StateData::StateData()
{
    m_dwState = NULL;
    m_dwValue = NULL;
    m_pNext = NULL;
}

StateData::~StateData()
{
    delete m_pNext;
}


StageData::StageData()
{
    m_uTexture = (UINT) -1;
    m_uMatrix  = (UINT) -1;

    m_pTSS = NULL;
    m_pNext = NULL;
}

StageData::~StageData()
{
    delete m_pTSS;
    delete m_pNext;
}


VShaderData::VShaderData()
{
    m_pShader = NULL;
}

VShaderData::~VShaderData()
{
    RELEASE(m_pShader);
}


PShaderData::PShaderData()
{
    m_pDeclaration = NULL;
    m_pShader = NULL;
}

PShaderData::~PShaderData()
{
    RELEASE(m_pDeclaration);
    RELEASE(m_pShader);
}


PassData::PassData()
{
    m_pRS = NULL;
    m_pStage = NULL;
    m_pVShader = NULL;
    m_pPShader = NULL;
    m_pNext = NULL;

    m_dwState = 0;
    m_dwVShader = 0;
    m_dwPShader = 0;

    m_pDevice = NULL;
}

PassData::~PassData()
{
    delete m_pRS;
    delete m_pStage;
    delete m_pVShader;
    delete m_pPShader;
    delete m_pNext;

    if(m_pDevice)
    {
        if(m_dwState)
            m_pDevice->DeleteStateBlock(m_dwState);

        if(m_dwVShader)
            m_pDevice->DeleteVertexShader(m_dwVShader);

        if(m_dwPShader)
            m_pDevice->DeletePixelShader(m_dwPShader);
    }
}


TechniqueData::TechniqueData()
{
    m_uLOD       = 0;
    m_uPasses    = 0;
    m_uRefCount  = 0;

    m_pRS   = NULL;
    m_pPass = NULL;
    m_pNext = NULL;
}

TechniqueData::~TechniqueData()
{
    delete m_pRS;
    delete m_pPass;
    delete m_pNext;
}





//////////////////////////////////////////////////////////////////////////////
// CD3DXTechnique ////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

CD3DXTechnique::CD3DXTechnique()
{
    m_uRefCount = 1;
    m_dwClear = 0;
    m_pEffect = NULL;
    m_pTechniqueData = NULL;
    m_pDevice = NULL;
}


CD3DXTechnique::~CD3DXTechnique()
{
    if(!m_pEffect)
        return;

    m_pTechniqueData->m_uRefCount--;

    if(!m_pTechniqueData->m_uRefCount)
    {
        PassData *pPassData = m_pTechniqueData->m_pPass;

        while(pPassData)
        {
            m_pDevice->DeleteStateBlock(pPassData->m_dwState);
            pPassData->m_dwState = 0;

            if(pPassData->m_dwVShader)
            {
                m_pDevice->DeleteVertexShader(pPassData->m_dwVShader);
                pPassData->m_dwVShader = 0;
            }

            if(pPassData->m_dwPShader)
            {
                m_pDevice->DeletePixelShader(pPassData->m_dwPShader);
                pPassData->m_dwPShader = 0;
            }

            pPassData = pPassData->m_pNext;
        }
    }

    m_pDevice->DeleteStateBlock(m_dwClear);

    m_pEffect->Release();
    m_pDevice->Release();
}


HRESULT
CD3DXTechnique::Initialize(CD3DXEffect *pEffect, TechniqueData *pTechniqueData,
                           DWORD dwClear, DWORD dwTextureUsed, DWORD dwMatrixUsed)
{
    m_dwClear = dwClear;

    m_pEffect = pEffect;
    m_pEffect->AddRef();

    m_pTechniqueData = pTechniqueData;
    m_pTechniqueData->m_uRefCount++;

    m_pDevice = m_pEffect->m_pDevice;
    m_pDevice->AddRef();

    m_dwDwordUsed   = 0;
    m_dwFloatUsed   = 0;
    m_dwColorUsed   = 0;
    m_dwVectorUsed  = 0;
    m_dwMatrixUsed  = dwMatrixUsed;
    m_dwTextureUsed = dwTextureUsed;

    return S_OK;
}



HRESULT
CD3DXTechnique::ValidateDX8(UINT uPass)
{
    PassData *pPass = m_pTechniqueData->m_pPass;

    while(uPass && pPass)
    {
        pPass = pPass->m_pNext;
        uPass--;
    }

    if(!pPass)
        return E_FAIL;


    D3DCAPS8 caps;
    m_pDevice->GetDeviceCaps(&caps);

    UINT uStages = 0;
    UINT uTextures = 0;

    StageData *pStage = pPass->m_pStage;

    while(pStage)
    {
        if(pStage->m_uTexture < m_pEffect->m_pData->m_uTextures)
            uTextures++;

        StateData *pState = pStage->m_pTSS;

        while(pState)
        {
            if(pState->m_dwState == D3DTSS_COLOROP ||
               pState->m_dwState == D3DTSS_ALPHAOP)
            {
                if(0 == (((1 << pState->m_dwValue) >> 1) & caps.TextureOpCaps))
                    return E_FAIL;
            }


            if(pState->m_dwState == D3DTSS_TEXTURETRANSFORMFLAGS)
            {
                UINT uCoords = pState->m_dwValue & 0xff;

                if(pState->m_dwValue & D3DTTFF_PROJECTED)
                {
                    uCoords--;

                    if(!(caps.TextureCaps & D3DPTEXTURECAPS_PROJECTED))
                        return E_FAIL;
                }

                if(3 == uCoords)
                {
                    if(!(caps.TextureCaps & (D3DPTEXTURECAPS_CUBEMAP | D3DPTEXTURECAPS_VOLUMEMAP)))
                        return E_FAIL;
                }

                if(4 == uCoords)
                    return E_FAIL;
            }

            pState = pState->m_pNext;
        }

        uStages++;
        pStage = pStage->m_pNext;
    }

    if(uStages > caps.MaxTextureBlendStages)
        return E_FAIL;

    if(uTextures > caps.MaxSimultaneousTextures)
        return E_FAIL;

    return S_OK;
}


STDMETHODIMP
CD3DXTechnique::QueryInterface(REFIID iid, LPVOID *ppv)
{
#if DBG
    if(!ppv)
        return E_INVALIDARG;
#endif

    if(IsEqualIID(iid, IID_ID3DXTechnique))
        *ppv = (ID3DXTechnique *) this;
    else if(IsEqualIID(iid, IID_IUnknown))
        *ppv = (IUnknown *) this;
    else
        return E_NOINTERFACE;

    AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG)
CD3DXTechnique::AddRef()
{
    return ++m_uRefCount;
}


STDMETHODIMP_(ULONG)
CD3DXTechnique::Release()
{
    if(--m_uRefCount)
        return m_uRefCount;

    delete this;
    return 0;
}


STDMETHODIMP_(D3DXTECHNIQUE_DESC)
CD3DXTechnique::GetTechniqueDesc()
{
    D3DXTECHNIQUE_DESC desc;
    memset(&desc, 0x00, sizeof(desc));

    desc.Passes = m_pTechniqueData->m_uPasses;
    desc.LOD    = m_pTechniqueData->m_uLOD;

    return desc;
}


STDMETHODIMP
CD3DXTechnique::GetDevice(IDirect3DDevice8 **ppDevice)
{
#if DBG
    if(!ppDevice)
        return E_INVALIDARG;
#endif

    m_pDevice->AddRef();
    *ppDevice = m_pDevice;

    return S_OK;
}


STDMETHODIMP_(BOOL)
CD3DXTechnique::IsDwordUsed(UINT uIndex)
{
    return m_dwDwordUsed & (1 << uIndex);
}


STDMETHODIMP_(BOOL)
CD3DXTechnique::IsFloatUsed(UINT uIndex)
{
    return m_dwFloatUsed & (1 << uIndex);
}


STDMETHODIMP_(BOOL)
CD3DXTechnique::IsColorUsed(UINT uIndex)
{
    return m_dwColorUsed & (1 << uIndex);
}


STDMETHODIMP_(BOOL)
CD3DXTechnique::IsVectorUsed(UINT uIndex)
{
    return m_dwVectorUsed & (1 << uIndex);
}


STDMETHODIMP_(BOOL)
CD3DXTechnique::IsMatrixUsed(UINT uIndex)
{
    return m_dwMatrixUsed & (1 << uIndex);
}

STDMETHODIMP_(BOOL)
CD3DXTechnique::IsTextureUsed(UINT uIndex)
{
    return m_dwTextureUsed & (1 << uIndex);
}


STDMETHODIMP
CD3DXTechnique::Validate()
{
    HRESULT hr;
    UINT uPass;
    UINT uPasses;
    DWORD dw;

    if(FAILED(hr = Begin(&uPasses)))
        return hr;

    for(uPass = 0; uPass < uPasses; uPass++)
    {
        if(FAILED(hr = Pass(uPass)) ||
           FAILED(hr = ValidateDX8(uPass)) ||
           FAILED(hr = m_pDevice->ValidateDevice(&dw)))
        {
            End();
            return hr;
        }
    }

    if(FAILED(hr = End()))
        return hr;

    return S_OK;
}


STDMETHODIMP
CD3DXTechnique::Begin(UINT *puPasses)
{
    if(puPasses)
        *puPasses = m_pTechniqueData->m_uPasses;

    m_pDevice->CaptureStateBlock(m_dwClear);

    return S_OK;
}


STDMETHODIMP
CD3DXTechnique::Pass(UINT uPass)
{
#if DBG
    if(uPass >= m_pTechniqueData->m_uPasses)
        return E_INVALIDARG;
#endif

    PassData *pPass = m_pTechniqueData->m_pPass;

    while(uPass && pPass)
    {
        pPass = pPass->m_pNext;
        uPass--;
    }

    if(!pPass)
        return E_FAIL;

    m_pDevice->ApplyStateBlock(pPass->m_dwState);

    if(pPass->m_dwVShader)
        m_pDevice->SetVertexShader(pPass->m_dwVShader);

    if(pPass->m_dwPShader)
        m_pDevice->SetPixelShader(pPass->m_dwPShader);


    // Setup textures and matrices
    UINT uStage = 0;
    StageData *pStage = pPass->m_pStage;

    while(pStage)
    {
        if(pStage->m_uTexture < m_pEffect->m_pData->m_uTextures)
            m_pDevice->SetTexture(uStage, m_pEffect->m_ppSurface[pStage->m_uTexture]);

        if(pStage->m_uMatrix < m_pEffect->m_pData->m_uMatrices)
            m_pDevice->SetTransform((_D3DTRANSFORMSTATETYPE) (uStage + D3DTS_TEXTURE0), &m_pEffect->m_pMatrix[pStage->m_uMatrix]);

        uStage++;
        pStage = pStage->m_pNext;
    }

    return S_OK;
}


STDMETHODIMP
CD3DXTechnique::End()
{
    m_pDevice->ApplyStateBlock(m_dwClear);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\effect\CD3DXEffectParser.cpp ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       parse.cpp
//  Content:    Parse D3DX Effect files
//
///////////////////////////////////////////////////////////////////////////

#include "pcheffect.h"


//
// Productions
//

enum
{
    P_EFFECT_BODY0,
    P_EFFECT_BODY1,
    P_DECLARATIONS0,
    P_DECLARATIONS1,
    P_DECLARATION0,
    P_TECHNIQUES0,
    P_TECHNIQUES1,
    P_TECHNIQUE0,
    P_TECHNIQUE1,
    P_TECHNIQUE_BODY0,
    P_TECHNIQUE_BODY1,
    P_TECHNIQUE_BODY2,
    P_TECHNIQUE_BODY3,
    P_TECHNIQUE_BODY4,
    P_TECHNIQUE_BODY5,
    P_TECHNIQUE_BODY6,
    P_TECHNIQUE_BODY7,
    P_PASSES0,
    P_PASSES1,
    P_PASS0,
    P_PASS1,
    P_PASS_BODY0,
    P_PASS_BODY1,
    P_PASS_BODY2,
    P_PASS_BODY3,
    P_STAGES0,
    P_STAGES1,
    P_STAGE0,
    P_STAGE1,
    P_STAGE2,
    P_STAGE_BODY0,
    P_STAGE_BODY1,
    P_SHADERS0,
    P_SHADERS1,
    P_SHADERS2,
    P_VSHADER0,
    P_VSHADER_BODY0,
    P_VSHADER_BODY1,
    P_PSHADER0,
    P_PSHADER_BODY0,
    P_PSHADER_BODY1,
    P_ASSIGNMENTS0,
    P_ASSIGNMENTS1,
    P_ASSIGNMENT0,
    P_EXPRESSION0,
    P_EXPRESSION1,
    P_VALUE0,
    P_VALUE1,
    P_VALUE2,
    P_VALUE3,
    P_VALUE4,
    P_VECTOR0,
    P_VECTOR1,
    P_VECTOR2,
    P_VECTOR3,
    P_NUM0,
    P_NUM1,
    P_INT0,
    P_HEX0,
    P_FLOAT0,
    P_ID0,
    P_ASM0
};

#define Prod(n) \
    CD3DXEffectParser::s_pParser->Production(n)

#define d3dxeffect_lex \
    CD3DXEffectParser::s_pParser->Token

#define d3dxeffect_error \
    CD3DXEffectParser::s_pParser->Error

#define lint

#include "effect_y.h"


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


#define BIND_END() \
    { NULL, 0, NULL }


static Binding g_BindDecl[] =
{
    { "DWORD",      0,  NULL },
    { "FLOAT",      1,  NULL },
    { "COLOR",      2,  NULL },
    { "VECTOR",     3,  NULL },
    { "MATRIX",     4,  NULL },
    { "TEXTURE",    5,  NULL },
    BIND_END()
};


static Binding g_BindBool[] =
{
    { "FALSE",  0, NULL },
    { "TRUE",   1, NULL },
    BIND_END()
};


static Binding g_BindSHADE[] =
{
    { "FLAT",       D3DSHADE_FLAT,      NULL },
    { "GOURAUD",    D3DSHADE_GOURAUD,   NULL },
    { "PHONG",      D3DSHADE_PHONG,     NULL },
    BIND_END()
};

static Binding g_BindFILL[] =
{
    { "POINT",      D3DFILL_POINT,      NULL },
    { "WIREFRAME",  D3DFILL_WIREFRAME,  NULL },
    { "SOLID",      D3DFILL_SOLID,      NULL },
    BIND_END()
};

static Binding g_BindBLEND[] =
{
    { "ZERO",               D3DBLEND_ZERO,              NULL },
    { "ONE",                D3DBLEND_ONE,               NULL },
    { "SRCCOLOR",           D3DBLEND_SRCCOLOR,          NULL },
    { "INVSRCCOLOR",        D3DBLEND_INVSRCCOLOR,       NULL },
    { "SRCALPHA",           D3DBLEND_SRCALPHA,          NULL },
    { "INVSRCALPHA",        D3DBLEND_INVSRCALPHA,       NULL },
    { "DESTALPHA",          D3DBLEND_DESTALPHA,         NULL },
    { "INVDESTALPHA",       D3DBLEND_INVDESTALPHA,      NULL },
    { "DESTCOLOR",          D3DBLEND_DESTCOLOR,         NULL },
    { "INVDESTCOLOR",       D3DBLEND_INVDESTCOLOR,      NULL },
    { "SRCALPHASAT",        D3DBLEND_SRCALPHASAT,       NULL },
    { "BOTHSRCALPHA",       D3DBLEND_BOTHSRCALPHA,      NULL },
    { "BOTHINVSRCALPHA",    D3DBLEND_BOTHINVSRCALPHA,   NULL },
    BIND_END()
};

static Binding g_BindTADDRESS[] =
{
    { "WRAP",   D3DTADDRESS_WRAP,   NULL },
    { "MIRROR", D3DTADDRESS_MIRROR, NULL },
    { "CLAMP",  D3DTADDRESS_CLAMP,  NULL },
    { "BORDER", D3DTADDRESS_BORDER, NULL },
    BIND_END()
};

static Binding g_BindCULL[] =
{
    { "NONE",   D3DCULL_NONE,   NULL },
    { "CW",     D3DCULL_CW,     NULL },
    { "CCW",    D3DCULL_CCW,    NULL },
    BIND_END()
};

static Binding g_BindCMP[] =
{
    { "NEVER",          D3DCMP_NEVER,           NULL },
    { "LESS",           D3DCMP_LESS,            NULL },
    { "EQUAL",          D3DCMP_EQUAL,           NULL },
    { "LESSEQUAL",      D3DCMP_LESSEQUAL,       NULL },
    { "GREATER",        D3DCMP_GREATER,         NULL },
    { "NOTEQUAL",       D3DCMP_NOTEQUAL,        NULL },
    { "GREATEREQUAL",   D3DCMP_GREATEREQUAL,    NULL },
    { "ALWAYS",         D3DCMP_ALWAYS,          NULL },
    BIND_END()
};

static Binding g_BindSTENCILOP[] =
{
    { "KEEP",       D3DSTENCILOP_KEEP,      NULL },
    { "ZERO",       D3DSTENCILOP_ZERO,      NULL },
    { "REPLACE",    D3DSTENCILOP_REPLACE,   NULL },
    { "INCRSAT",    D3DSTENCILOP_INCRSAT,   NULL },
    { "DECRSAT",    D3DSTENCILOP_DECRSAT,   NULL },
    { "INVERT",     D3DSTENCILOP_INVERT,    NULL },
    { "INCR",       D3DSTENCILOP_INCR,      NULL },
    { "DECR",       D3DSTENCILOP_DECR,      NULL },
    BIND_END()
};


static Binding g_BindFOG[] =
{
    { "NONE",   D3DFOG_NONE,    NULL },
    { "EXP",    D3DFOG_EXP,     NULL },
    { "EXP2",   D3DFOG_EXP2,    NULL },
    { "LINEAR", D3DFOG_LINEAR,  NULL },
    BIND_END()
};


static Binding g_BindZB[] =
{
    { "TRUE",   D3DZB_TRUE,     NULL },
    { "FALSE",  D3DZB_FALSE,    NULL },
    { "USEW",   D3DZB_USEW,     NULL },
    BIND_END()
};


static Binding g_BindMCS[] =
{
    { "MATERIAL",   D3DMCS_MATERIAL,    NULL },
    { "COLOR1",     D3DMCS_COLOR1,      NULL },
    { "COLOR2",     D3DMCS_COLOR2,  NULL },
    BIND_END()
};


static Binding g_BindWRAP[] =
{
    { "U",      D3DWRAP_U,      NULL },
    { "V",      D3DWRAP_V,      NULL },
    { "W",      D3DWRAP_W,      NULL },
    { "COORD0", D3DWRAPCOORD_0, NULL },
    { "COORD1", D3DWRAPCOORD_1, NULL },
    { "COORD2", D3DWRAPCOORD_2, NULL },
    { "COORD3", D3DWRAPCOORD_3, NULL },
    BIND_END()
};


static Binding g_BindCOLORWRITEENABLE[] =
{
    { "RED",    D3DCOLORWRITEENABLE_RED,    NULL },
    { "GREEN",  D3DCOLORWRITEENABLE_GREEN,  NULL },
    { "BLUE",   D3DCOLORWRITEENABLE_BLUE,   NULL },
    { "ALPHA",  D3DCOLORWRITEENABLE_ALPHA,  NULL },
    BIND_END()
};


static Binding g_BindHOB[] =
{
    { "BEZIER",         D3DBASIS_BEZIER,      NULL },
    { "BSPLINE",        D3DBASIS_BSPLINE,     NULL },
    { "INTERPOLATE",    D3DBASIS_INTERPOLATE, NULL },
    BIND_END()
};


static Binding g_BindORDER[] =
{
    { "LINEAR", D3DORDER_LINEAR,    NULL },
    { "CUBIC",  D3DORDER_CUBIC,     NULL },
    BIND_END()
};


static Binding g_BindVBF[] =
{
    { "DISABLE",    D3DVBF_DISABLE,  NULL },
    { "0WEIGHTS",   D3DVBF_0WEIGHTS, NULL },
    { "1WEIGHTS",   D3DVBF_1WEIGHTS, NULL },
    { "2WEIGHTS",   D3DVBF_2WEIGHTS, NULL },
    { "3WEIGHTS",   D3DVBF_3WEIGHTS, NULL },
    BIND_END()
};


static Binding g_BindTSS_TCI[] =
{
    { "PASSTHRU",                       D3DTSS_TCI_PASSTHRU,                    NULL },
    { "CAMERASPACENORMAL",              D3DTSS_TCI_CAMERASPACENORMAL,           NULL },
    { "CAMERASPACEPOSITION",            D3DTSS_TCI_CAMERASPACEPOSITION,         NULL },
    { "CAMERASPACEREFLECTIONVECTOR",    D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR, NULL },
    BIND_END()
};


static Binding g_BindTOP[] =
{
    { "DISABLE",                    D3DTOP_DISABLE,                     NULL },
    { "SELECTARG1",                 D3DTOP_SELECTARG1,                  NULL },
    { "SELECTARG2",                 D3DTOP_SELECTARG2,                  NULL },
    { "MODULATE",                   D3DTOP_MODULATE,                    NULL },
    { "MODULATE2X",                 D3DTOP_MODULATE2X,                  NULL },
    { "MODULATE4X",                 D3DTOP_MODULATE4X,                  NULL },
    { "ADD",                        D3DTOP_ADD,                         NULL },
    { "ADDSIGNED",                  D3DTOP_ADDSIGNED,                   NULL },
    { "ADDSIGNED2X",                D3DTOP_ADDSIGNED2X,                 NULL },
    { "SUBTRACT",                   D3DTOP_SUBTRACT,                    NULL },
    { "ADDSMOOTH",                  D3DTOP_ADDSMOOTH,                   NULL },
    { "BLENDDIFFUSEALPHA",          D3DTOP_BLENDDIFFUSEALPHA,           NULL },
    { "BLENDTEXTUREALPHA",          D3DTOP_BLENDTEXTUREALPHA,           NULL },
    { "BLENDFACTORALPHA",           D3DTOP_BLENDFACTORALPHA,            NULL },
    { "BLENDTEXTUREALPHAPM",        D3DTOP_BLENDTEXTUREALPHAPM,         NULL },
    { "BLENDCURRENTALPHA",          D3DTOP_BLENDCURRENTALPHA,           NULL },
    { "PREMODULATE",                D3DTOP_PREMODULATE,                 NULL },
    { "MODULATEALPHA_ADDCOLOR",     D3DTOP_MODULATEALPHA_ADDCOLOR,      NULL },
    { "MODULATECOLOR_ADDALPHA",     D3DTOP_MODULATECOLOR_ADDALPHA,      NULL },
    { "MODULATEINVALPHA_ADDCOLOR",  D3DTOP_MODULATEINVALPHA_ADDCOLOR,   NULL },
    { "MODULATEINVCOLOR_ADDALPHA",  D3DTOP_MODULATEINVCOLOR_ADDALPHA,   NULL },
    { "BUMPENVMAP",                 D3DTOP_BUMPENVMAP,                  NULL },
    { "BUMPENVMAPLUMINANCE",        D3DTOP_BUMPENVMAPLUMINANCE,         NULL },
    { "DOTPRODUCT3",                D3DTOP_DOTPRODUCT3,                 NULL },
    BIND_END()
};


static Binding g_BindTA[] =
{
    { "SELECTMASK",     D3DTA_SELECTMASK,       NULL },
    { "DIFFUSE",        D3DTA_DIFFUSE,          NULL },
    { "CURRENT",        D3DTA_CURRENT,          NULL },
    { "TEXTURE",        D3DTA_TEXTURE,          NULL },
    { "TFACTOR",        D3DTA_TFACTOR,          NULL },
    { "SPECULAR",       D3DTA_SPECULAR,         NULL },
    { "COMPLEMENT",     D3DTA_COMPLEMENT,       NULL },
    { "ALPHAREPLICATE", D3DTA_ALPHAREPLICATE,   NULL },
    BIND_END()
};


static Binding g_BindTEXF[] =
{
    { "NONE",           D3DTEXF_NONE,           NULL },
    { "POINT",          D3DTEXF_POINT,          NULL },
    { "LINEAR",         D3DTEXF_LINEAR,         NULL },
    { "ANISOTROPIC",    D3DTEXF_ANISOTROPIC,    NULL },
    { "FLATCUBIC",      D3DTEXF_QUINCUNX,       NULL },
    { "GAUSSIANCUBIC",  D3DTEXF_GAUSSIANCUBIC,  NULL },
    BIND_END()
};


static Binding g_BindTTFF[] =
{
    { "FALSE",      D3DTTFF_DISABLE,    NULL },
    { "DISABLE",    D3DTTFF_DISABLE,    NULL },
    { "COUNT1",     D3DTTFF_COUNT1,     NULL },
    { "COUNT2",     D3DTTFF_COUNT2,     NULL },
    { "COUNT3",     D3DTTFF_COUNT3,     NULL },
    { "COUNT4",     D3DTTFF_COUNT4,     NULL },
    { "PROJECTED",  D3DTTFF_PROJECTED,  NULL },
    BIND_END()
};


static Binding g_BindFVF[] =
{
    { "XYZ",        D3DFVF_XYZ,         NULL },
    { "XYZRHW",     D3DFVF_XYZRHW,      NULL },
    { "XYZB1",      D3DFVF_XYZB1,       NULL },
    { "XYZB2",      D3DFVF_XYZB2,       NULL },
    { "XYZB3",      D3DFVF_XYZB3,       NULL },
    { "XYZB4",      D3DFVF_XYZB4,       NULL },
    { "XYZB5",      D3DFVF_XYZB5,       NULL },
    { "NORMAL",     D3DFVF_NORMAL,      NULL },
    { "PSIZE",      D3DFVF_PSIZE,       NULL },
    { "DIFFUSE",    D3DFVF_DIFFUSE,     NULL },
    { "SPECULAR",   D3DFVF_SPECULAR,    NULL },
    { "TEX0",       D3DFVF_TEX0,        NULL },
    { "TEX1",       D3DFVF_TEX1,        NULL },
    { "TEX2",       D3DFVF_TEX2,        NULL },
    { "TEX3",       D3DFVF_TEX3,        NULL },
    { "TEX4",       D3DFVF_TEX4,        NULL },
    { "TEX5",       D3DFVF_TEX5,        NULL },
    { "TEX6",       D3DFVF_TEX6,        NULL },
    { "TEX7",       D3DFVF_TEX7,        NULL },
    { "TEX8",       D3DFVF_TEX8,        NULL },
    { "VERTEX",     D3DFVF_VERTEX,      NULL },
    { "TLVERTEX",   D3DFVF_TLVERTEX,    NULL },
    BIND_END()
};


static Binding g_BindRS[] =
{
    { "ZENABLE",                    D3DRS_ZENABLE,                  g_BindZB },
    { "FILLMODE",                   D3DRS_FILLMODE,                 g_BindFILL },
    { "SHADEMODE",                  D3DRS_SHADEMODE,                g_BindSHADE },
    { "LINEPATTERN",                D3DRS_LINEPATTERN,              NULL },
    { "ZWRITEENABLE",               D3DRS_ZWRITEENABLE,             g_BindBool },
    { "ALPHATESTENABLE",            D3DRS_ALPHATESTENABLE,          g_BindBool },
    { "LASTPIXEL",                  D3DRS_LASTPIXEL,                g_BindBool },
    { "SRCBLEND",                   D3DRS_SRCBLEND,                 g_BindBLEND },
    { "DESTBLEND",                  D3DRS_DESTBLEND,                g_BindBLEND },
    { "CULLMODE",                   D3DRS_CULLMODE,                 g_BindCULL },
    { "ZFUNC",                      D3DRS_ZFUNC,                    g_BindCMP },
    { "ALPHAREF",                   D3DRS_ALPHAREF,                 NULL },
    { "ALPHAFUNC",                  D3DRS_ALPHAFUNC,                g_BindCMP },
    { "DITHERENABLE",               D3DRS_DITHERENABLE,             g_BindBool },
    { "ALPHABLENDENABLE",           D3DRS_ALPHABLENDENABLE,         g_BindBool },
    { "FOGENABLE",                  D3DRS_FOGENABLE,                g_BindBool },
    { "SPECULARENABLE",             D3DRS_SPECULARENABLE,           g_BindBool },
    { "ZVISIBLE",                   D3DRS_ZVISIBLE,                 g_BindBool },
    { "FOGCOLOR",                   D3DRS_FOGCOLOR,                 NULL },
    { "FOGTABLEMODE",               D3DRS_FOGTABLEMODE,             g_BindFOG },
    { "FOGSTART",                   D3DRS_FOGSTART,                 NULL },
    { "FOGEND",                     D3DRS_FOGEND,                   NULL },
    { "FOGDENSITY",                 D3DRS_FOGDENSITY,               NULL },
    { "EDGEANTIALIAS",              D3DRS_EDGEANTIALIAS,            g_BindBool },
    { "ZBIAS",                      D3DRS_ZBIAS,                    NULL },
    { "RANGEFOGENABLE",             D3DRS_RANGEFOGENABLE,           NULL },
    { "STENCILENABLE",              D3DRS_STENCILENABLE,            g_BindBool },
    { "STENCILFAIL",                D3DRS_STENCILFAIL,              g_BindSTENCILOP },
    { "STENCILZFAIL",               D3DRS_STENCILZFAIL,             g_BindSTENCILOP },
    { "STENCILPASS",                D3DRS_STENCILPASS,              g_BindSTENCILOP },
    { "STENCILFUNC",                D3DRS_STENCILFUNC,              g_BindCMP },
    { "STENCILREF",                 D3DRS_STENCILREF,               NULL },
    { "STENCILMASK",                D3DRS_STENCILMASK,              NULL },
    { "STENCILWRITEMASK",           D3DRS_STENCILWRITEMASK,         NULL },
    { "TEXTUREFACTOR",              D3DRS_TEXTUREFACTOR,            NULL },
    { "WRAP0",                      D3DRS_WRAP0,                    g_BindWRAP },
    { "WRAP1",                      D3DRS_WRAP1,                    g_BindWRAP },
    { "WRAP2",                      D3DRS_WRAP2,                    g_BindWRAP },
    { "WRAP3",                      D3DRS_WRAP3,                    g_BindWRAP },
    { "WRAP4",                      D3DRS_WRAP4,                    g_BindWRAP },
    { "WRAP5",                      D3DRS_WRAP5,                    g_BindWRAP },
    { "WRAP6",                      D3DRS_WRAP6,                    g_BindWRAP },
    { "WRAP7",                      D3DRS_WRAP7,                    g_BindWRAP },
    { "CLIPPING",                   D3DRS_CLIPPING,                 g_BindBool },
    { "LIGHTING",                   D3DRS_LIGHTING,                 g_BindBool },
    { "AMBIENT",                    D3DRS_AMBIENT,                  NULL },
    { "FOGVERTEXMODE",              D3DRS_FOGVERTEXMODE,            NULL },
    { "COLORVERTEX",                D3DRS_COLORVERTEX,              g_BindBool },
    { "LOCALVIEWER",                D3DRS_LOCALVIEWER,              g_BindBool },
    { "NORMALIZENORMALS",           D3DRS_NORMALIZENORMALS,         g_BindBool },
    { "DIFFUSEMATERIALSOURCE",      D3DRS_DIFFUSEMATERIALSOURCE,    g_BindMCS },
    { "SPECULARMATERIALSOURCE",     D3DRS_SPECULARMATERIALSOURCE,   g_BindMCS },
    { "AMBIENTMATERIALSOURCE",      D3DRS_AMBIENTMATERIALSOURCE,    g_BindMCS },
    { "EMISSIVEMATERIALSOURCE",     D3DRS_EMISSIVEMATERIALSOURCE,   g_BindMCS },
    { "VERTEXBLEND",                D3DRS_VERTEXBLEND,              g_BindVBF },
    { "CLIPPLANEENABLE",            D3DRS_CLIPPLANEENABLE,          g_BindBool },
    { "SOFTWAREVERTEXPROCESSING",   D3DRS_SOFTWAREVERTEXPROCESSING, g_BindBool },
    { "POINTSIZE",                  D3DRS_POINTSIZE,                NULL },
    { "POINTSIZE_MIN",              D3DRS_POINTSIZE_MIN,            NULL },
    { "POINTSIZE_MAX",              D3DRS_POINTSIZE_MAX,            NULL },
    { "POINTSPRITEENABLE",          D3DRS_POINTSPRITEENABLE,        g_BindBool },
    { "POINTSCALEENABLE",           D3DRS_POINTSCALEENABLE,         g_BindBool },
    { "POINTSCALE_A",               D3DRS_POINTSCALE_A,             NULL },
    { "POINTSCALE_B",               D3DRS_POINTSCALE_B,             NULL },
    { "POINTSCALE_C",               D3DRS_POINTSCALE_C,             NULL },
    { "MULTISAMPLEANTIALIAS",       D3DRS_MULTISAMPLEANTIALIAS,     g_BindBool },
    { "MULTISAMPLEMASK",            D3DRS_MULTISAMPLEMASK,          NULL },
    { "PATCHSEGMENTS",              D3DRS_PATCHSEGMENTS,            NULL },
    { "DEBUGMONITORTOKEN",          D3DRS_DEBUGMONITORTOKEN,        NULL },
    { "INDEXEDVERTEXBLENDENABLE",   D3DRS_INDEXEDVERTEXBLENDENABLE, g_BindBool },
    { "COLORWRITEENABLE",           D3DRS_COLORWRITEENABLE,         g_BindBool },
    { "FVF",                        D3DRS_FVF,                      g_BindFVF },
    BIND_END()
};


static Binding g_BindTSS[] =
{
    { "COLOROP",                D3DTSS_COLOROP,                 g_BindTOP },
    { "COLORARG1",              D3DTSS_COLORARG1,               g_BindTA },
    { "COLORARG2",              D3DTSS_COLORARG2,               g_BindTA },
    { "ALPHAOP",                D3DTSS_ALPHAOP,                 g_BindTOP },
    { "ALPHAARG1",              D3DTSS_ALPHAARG1,               g_BindTA },
    { "ALPHAARG2",              D3DTSS_ALPHAARG2,               g_BindTA },
    { "BUMPENVMAT00",           D3DTSS_BUMPENVMAT00,            NULL },
    { "BUMPENVMAT01",           D3DTSS_BUMPENVMAT01,            NULL },
    { "BUMPENVMAT10",           D3DTSS_BUMPENVMAT10,            NULL },
    { "BUMPENVMAT11",           D3DTSS_BUMPENVMAT11,            NULL },
    { "TEXCOORDINDEX",          D3DTSS_TEXCOORDINDEX,           g_BindTSS_TCI },
    { "ADDRESS",                D3DTSS_ADDRESS,                 g_BindTADDRESS },
    { "ADDRESSU",               D3DTSS_ADDRESSU,                g_BindTADDRESS },
    { "ADDRESSV",               D3DTSS_ADDRESSV,                g_BindTADDRESS },
    { "ADDRESSW",               D3DTSS_ADDRESSW,                g_BindTADDRESS },
    { "BORDERCOLOR",            D3DTSS_BORDERCOLOR,             NULL },
    { "MAGFILTER",              D3DTSS_MAGFILTER,               g_BindTEXF },
    { "MINFILTER",              D3DTSS_MINFILTER,               g_BindTEXF },
    { "MIPFILTER",              D3DTSS_MIPFILTER,               g_BindTEXF },
    { "MIPMAPLODBIAS",          D3DTSS_MIPMAPLODBIAS,           NULL },
    { "MAXMIPLEVEL",            D3DTSS_MAXMIPLEVEL,             NULL },
    { "MAXANISOTROPY",          D3DTSS_MAXANISOTROPY,           NULL },
    { "BUMPENVLSCALE",          D3DTSS_BUMPENVLSCALE,           NULL },
    { "BUMPENVLOFFSET",         D3DTSS_BUMPENVLOFFSET,          NULL },
    { "TEXTURETRANSFORMFLAGS",  D3DTSS_TEXTURETRANSFORMFLAGS,   g_BindTTFF },
    BIND_END()
};


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

Node::Node(DWORD dwType)
{
    m_dwType = dwType;
    m_pNext = NULL;
    m_pStack = NULL;
}

Node::~Node()
{
    delete m_pNext;
    delete m_pStack;
}

EffectNode::EffectNode() : Node(NODE_EFFECT)
{
    m_pDeclarations = NULL;
    m_pTechniques = NULL;
}

EffectNode::~EffectNode()
{
    delete m_pDeclarations;
    delete m_pTechniques;
}


DeclarationNode::DeclarationNode() : Node(NODE_DECLARATION)
{
    m_pType = NULL;
    m_pName = NULL;
}

DeclarationNode::~DeclarationNode()
{
    delete m_pType;
    delete m_pName;
}


TechniqueNode::TechniqueNode() : Node(NODE_TECHNIQUE)
{
    m_pLOD    = NULL;
    m_pStates = NULL;
    m_pPasses = NULL;
}

TechniqueNode::~TechniqueNode()
{
    delete m_pLOD;
    delete m_pStates;
    delete m_pPasses;
}


PassNode::PassNode() : Node(NODE_PASS)
{
    m_pSrcBlend = NULL;
    m_pDstBlend = NULL;
    m_pStates   = NULL;
    m_pStages   = NULL;
    m_pShaders  = NULL;
}

PassNode::~PassNode()
{
    delete m_pSrcBlend;
    delete m_pDstBlend;
    delete m_pStates;
    delete m_pStages;
}


StageNode::StageNode() : Node(NODE_STAGE)
{
    m_pTexture   = NULL;
    m_pMatrix    = NULL;
    m_pStates    = NULL;
}

StageNode::~StageNode()
{
    delete m_pTexture;
    delete m_pMatrix;
    delete m_pStates;
}


VShaderNode::VShaderNode() : Node(NODE_VSHADER)
{
    m_pConst = NULL;
    m_pAsm   = NULL;
}

VShaderNode::~VShaderNode()
{
    delete m_pConst;
    delete m_pAsm;
}


PShaderNode::PShaderNode() : Node(NODE_PSHADER)
{
    m_pConst = NULL;
    m_pAsm   = NULL;
}

PShaderNode::~PShaderNode()
{
    delete m_pConst;
    delete m_pAsm;
}


StateNode::StateNode() : Node(NODE_STATE)
{
    m_pLValue = NULL;
    m_pRValue = NULL;
}

StateNode::~StateNode()
{
    delete m_pLValue;
    delete m_pRValue;
}


IdNode::IdNode(char *sz) : Node(NODE_ID)
{
    m_szId = _strdup(sz);
}

IdNode::~IdNode()
{
    free(m_szId);
}


DwordNode::DwordNode(DWORD dwValue) : Node(NODE_DWORD)
{
    m_dwValue = dwValue;
}


FloatNode::FloatNode(float fValue) : Node(NODE_FLOAT)
{
    m_fValue = fValue;
}


VectorNode::VectorNode(float x, float y, float z, float w) : Node(NODE_VECTOR)
{
    m_vec.x = x;
    m_vec.y = y;
    m_vec.z = z;
    m_vec.w = w;
}


AsmNode::AsmNode(char *pchAsm, UINT cchAsm) : Node(NODE_ASM)
{
    m_pchAsm = pchAsm;
    m_cchAsm = cchAsm;
}



//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

CD3DXEffectParser* CD3DXEffectParser::s_pParser = NULL;

CD3DXEffectParser::CD3DXEffectParser()
{
    m_pNode = NULL;
    m_bFail = FALSE;
    m_cErrors = 0;
    m_cbErrors = 0;

    m_pchSource = NULL;
    m_pchLine   = NULL;
    m_pch       = NULL;
    m_pchLim    = NULL;

    m_iLine = 1;

    m_pEffectNode = NULL;
    m_pEffectData = NULL;

    s_pParser = this;
}


CD3DXEffectParser::~CD3DXEffectParser()
{
    if(m_pNode)
        delete m_pNode;

    if(m_pEffectData)
        delete m_pEffectData;
}


void
CD3DXEffectParser::Push(Node *pNode)
{
    if(!pNode)
    {
        m_bFail = TRUE;
        return;
    }

    pNode->m_pStack = m_pNode;
    m_pNode = pNode;
    return;
}


Node *
CD3DXEffectParser::Pop()
{
    if(!m_pNode)
    {
        m_bFail = TRUE;
        return NULL;
    }

    Node *pNode = m_pNode;
    m_pNode = pNode->m_pStack;
    pNode->m_pStack = NULL;
    return pNode;
}


void
CD3DXEffectParser::Combine()
{
    if(!m_pNode || !m_pNode->m_pStack || m_pNode->m_pStack->m_pNext)
    {
        m_bFail = TRUE;
        return;
    }

    Node *pNode = m_pNode;
    m_pNode->m_pStack->m_pNext = pNode;
    m_pNode = m_pNode->m_pStack;
    pNode->m_pStack = NULL;
    return;
}


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


int
CD3DXEffectParser::Token()
{
    char *pch;
    int nToken;
    SIZE_T cch;

    BOOL bAsm = FALSE;
    char *pchAsm = NULL;

    while(m_pch < m_pchLim)
    {
        char ch = *m_pch;

        if(ch == '\n')
        {
            // newline
            m_pch++;
            m_pchLine = m_pch;
            m_iLine++;
        }
        else if(isspace(ch))
        {
            // whitespace
            m_pch++;
        }
        else if(ch == '#' && m_pch == m_pchLine)
        {
            // preprocessor directive
            pch = m_pch;
            for(m_pch++; m_pch < m_pchLim && *m_pch != '\n'; m_pch++);

            if(m_pch - pch > 5 && !memcmp(pch, "#line", 5))
            {
                // Skip #line
                for(; pch < m_pch && !isspace(*pch); pch++);

                // Skip whitespace
                for(; pch < m_pch && isspace(*pch); pch++);
                char *pchNum = pch;

                // Line number
                for(; pch < m_pch && !isspace(*pch); pch++);
                char *pchNumLim = pch;

                // Beginning of file name
                for(; pch < m_pch && *pch != '"'; pch++);
                char *pchFile = pch;

                if(pch < m_pch)
                    pch++;

                // End of file name
                for(; pch < m_pch && *pch != '"'; pch++);
                char *pchFileLim = pch;


                char sz[256];

                SIZE_T cchNum = pchNumLim - pchNum;
                SIZE_T cchFile = pchFileLim - pchFile;

                if(cchNum >= sizeof(sz))
                    cchNum = sizeof(sz) - 1;

                if(cchFile >= sizeof(m_szFile))
                    cchFile = sizeof(m_szFile) - 1;

                if(cchNum)
                {
                    memcpy(sz, pchNum, cchNum);
                    sz[cchNum] = 0;
                    m_iLine = atoi(sz) - 1;
                }

                if(cchFile > 1)
                {
                    // Copy filename, removing double backslashes
                    pchFile++;
                    pch = m_szFile;

                    while(pchFile < pchFileLim)
                    {
                        *pch = *pchFile++;

                        if(*pch == '\\' && pchFile < pchFileLim && *pchFile == '\\')
                            pchFile++;

                        pch++;
                    }

                    *pch = 0;
                }
            }
            else
            {
                Error("preprocessor directives are not supported.");
            }
        }
        else if(bAsm)
        {
            // Asm block
            if(ch == '{')
            {
                pchAsm = m_pch++;
            }
            else if(ch == '}')
            {
                m_pchAsm = pchAsm;
                m_cchAsm = (UINT)(m_pchAsm - m_pch);

                m_pch++;

                bAsm = FALSE;
                pchAsm = NULL;
            }
            else if(ch == ';')
            {
                // comment
                for(m_pch++; m_pch < m_pchLim && *m_pch != '\n'; m_pch++);
            }
            else if(!pchAsm)
            {
                // failure!
                m_pch = m_pchLim;
            }
            else
            {
                m_pch++;
            }
        }
        else if(ch == '/' && m_pch + 1 < m_pchLim && m_pch[1] == '/')
        {
            // comment
            for(m_pch++; m_pch < m_pchLim && *m_pch != '\n'; m_pch++);
        }
        else if(isalpha(ch))
        {
            // keyword / identifier
            pch = m_pch;
            for(m_pch++; m_pch < m_pchLim && (isalnum(*m_pch) || '_' == *m_pch); m_pch++);

            cch = m_pch - pch;

            if(cch >= sizeof(m_szTok))
                cch = sizeof(m_szTok) - 1;

            memcpy(m_szTok, pch, cch);
            m_szTok[cch] = 0;

            if(!_stricmp(m_szTok, "technique"))    return T_TECHNIQUE;
            if(!_stricmp(m_szTok, "pass"))         return T_PASS;
            if(!_stricmp(m_szTok, "stage"))        return T_STAGE;
            if(!_stricmp(m_szTok, "vertexshader")) return T_VSHADER;
            if(!_stricmp(m_szTok, "pixelshader"))  return T_PSHADER;

            if(!_stricmp(m_szTok, "asm"))
            {
                bAsm = TRUE;
                pchAsm = NULL;
                continue;
            }

            return T_ID;
        }
        else if(ch == '0' && m_pch + 1 < m_pchLim && m_pch[1] == 'x')
        {
            // hex
            m_pch += 2;
            pch = m_pch;

            for(; m_pch < m_pchLim && (isalpha(*m_pch) || tolower(*m_pch) >= 'a' && tolower(*m_pch) <= 'f'); m_pch++);

            cch = m_pch - pch;

            if(cch >= sizeof(m_szTok))
                cch = sizeof(m_szTok) - 1;

            memcpy(m_szTok, pch, cch);
            m_szTok[cch] = 0;

            return T_HEX;
        }
        else if(isdigit(ch))
        {
            // number
            pch = m_pch;
            nToken = T_INT;

            for(m_pch++; m_pch < m_pchLim; m_pch++)
            {
                if(isdigit(*m_pch))
                    continue;

                if(*m_pch == '.')
                {
                    nToken = T_FLOAT;
                    continue;
                }

                break;
            }

            cch = m_pch - pch;

            if(cch >= sizeof(m_szTok))
                cch = sizeof(m_szTok) - 1;

            memcpy(m_szTok, pch, cch);
            m_szTok[cch] = 0;

            if(m_pch < m_pchLim && *m_pch == 'f')
            {
                nToken = T_FLOAT;
                m_pch++;
            }

            return nToken;
        }
        else
        {
            // other character
            m_pch++;
            return ch;
        }
    }


    if(m_pch == m_pchLim)
    {
        m_pch++;
        return T_EOF;
    }

    return -1;
}


void
CD3DXEffectParser::Production(UINT nProd)
{
    DWORD dw;
    float f;

    EffectNode      *pEffectNode;
    DeclarationNode *pDeclarationNode;
    TechniqueNode   *pTechniqueNode;
    PassNode        *pPassNode;
    VShaderNode     *pVShaderNode;
    PShaderNode     *pPShaderNode;
    StageNode       *pStageNode;
    StateNode       *pStateNode;
    DwordNode       *pDwordNode;
    FloatNode       *pFloatNodeA, *pFloatNodeB, *pFloatNodeC, *pFloatNodeD;


    if(m_bFail)
        return;


    switch(nProd)
    {
    case P_EFFECT_BODY0:
        if(!(pEffectNode = new EffectNode()))
            goto LFail;

        pEffectNode->m_pTechniques = Pop();
        Push(pEffectNode);
        break;

    case P_EFFECT_BODY1:
        if(!(pEffectNode = new EffectNode()))
            goto LFail;

        pEffectNode->m_pTechniques = Pop();
        pEffectNode->m_pDeclarations = Pop();
        Push(pEffectNode);
        break;

    case P_DECLARATIONS0:
        break;

    case P_DECLARATIONS1:
        Combine();
        break;


    case P_DECLARATION0:
        if(!(pDeclarationNode = new DeclarationNode()))
            goto LFail;

        pDeclarationNode->m_pName = Pop();
        pDeclarationNode->m_pType = Pop();

        Push(pDeclarationNode);
        break;

    case P_TECHNIQUES0:
        break;

    case P_TECHNIQUES1:
        Combine();
        break;


    case P_TECHNIQUE0:
        break;

    case P_TECHNIQUE1:
        pTechniqueNode = (TechniqueNode *) Pop();
        pTechniqueNode->m_pLOD  = Pop();
        Push(pTechniqueNode);
        break;


    case P_TECHNIQUE_BODY0:
        if(!(pTechniqueNode = new TechniqueNode()))
            goto LFail;

        Push(pTechniqueNode);
        break;

    case P_TECHNIQUE_BODY1:
        if(!(pTechniqueNode = new TechniqueNode()))
            goto LFail;

        pTechniqueNode->m_pStates = Pop();
        Push(pTechniqueNode);
        break;

    case P_TECHNIQUE_BODY2:
        if(!(pTechniqueNode = new TechniqueNode()))
            goto LFail;

        pTechniqueNode->m_pPasses = Pop();
        Push(pTechniqueNode);
        break;

    case P_TECHNIQUE_BODY3:
        if(!(pTechniqueNode = new TechniqueNode()))
            goto LFail;

        pTechniqueNode->m_pShaders = Pop();
        Push(pTechniqueNode);
        break;

    case P_TECHNIQUE_BODY4:
        if(!(pTechniqueNode = new TechniqueNode()))
            goto LFail;

        pTechniqueNode->m_pPasses = Pop();
        pTechniqueNode->m_pStates = Pop();
        Push(pTechniqueNode);
        break;

    case P_TECHNIQUE_BODY5:
        if(!(pTechniqueNode = new TechniqueNode()))
            goto LFail;

        pTechniqueNode->m_pShaders = Pop();
        pTechniqueNode->m_pStates = Pop();
        Push(pTechniqueNode);
        break;

    case P_TECHNIQUE_BODY6:
        if(!(pTechniqueNode = new TechniqueNode()))
            goto LFail;

        pTechniqueNode->m_pShaders = Pop();
        pTechniqueNode->m_pPasses = Pop();
        Push(pTechniqueNode);
        break;

    case P_TECHNIQUE_BODY7:
        if(!(pTechniqueNode = new TechniqueNode()))
            goto LFail;

        pTechniqueNode->m_pShaders = Pop();
        pTechniqueNode->m_pPasses = Pop();
        pTechniqueNode->m_pStates = Pop();
        Push(pTechniqueNode);
        break;


    case P_PASSES0:
        break;

    case P_PASSES1:
        Combine();
        break;


    case P_PASS0:
        break;

    case P_PASS1:
        pPassNode = (PassNode *) Pop();
        pPassNode->m_pDstBlend = Pop();
        pPassNode->m_pSrcBlend = Pop();
        Push(pPassNode);
        break;


    case P_PASS_BODY0:
        if(!(pPassNode = new PassNode()))
            goto LFail;

        Push(pPassNode);
        break;

    case P_PASS_BODY1:
        if(!(pPassNode = new PassNode()))
            goto LFail;

        pPassNode->m_pStates = Pop();
        Push(pPassNode);
        break;

    case P_PASS_BODY2:
        if(!(pPassNode = new PassNode()))
            goto LFail;

        pPassNode->m_pStages = Pop();
        Push(pPassNode);
        break;

    case P_PASS_BODY3:
        if(!(pPassNode = new PassNode()))
            goto LFail;

        pPassNode->m_pStages = Pop();
        pPassNode->m_pStates = Pop();
        Push(pPassNode);
        break;


    case P_STAGES0:
        break;

    case P_STAGES1:
        Combine();
        break;


    case P_STAGE0:
        break;

    case P_STAGE1:
        pStageNode = (StageNode *) Pop();
        pStageNode->m_pTexture = Pop();
        Push(pStageNode);
        break;

    case P_STAGE2:
        pStageNode = (StageNode *) Pop();
        pStageNode->m_pMatrix = Pop();
        pStageNode->m_pTexture = Pop();
        Push(pStageNode);
        break;


    case P_STAGE_BODY0:
        if(!(pStageNode = new StageNode()))
            goto LFail;

        Push(pStageNode);
        break;

    case P_STAGE_BODY1:
        if(!(pStageNode = new StageNode()))
            goto LFail;

        pStageNode->m_pStates = Pop();
        Push(pStageNode);
        break;


    case P_SHADERS0:
    case P_SHADERS1:
        break;

    case P_SHADERS2:
        Combine();
        break;


    case P_VSHADER0:
        break;

    case P_VSHADER_BODY0:
        if(!(pVShaderNode = new VShaderNode()))
            goto LFail;

        pVShaderNode->m_pAsm = Pop();
        Push(pVShaderNode);
        break;

    case P_VSHADER_BODY1:
        if(!(pVShaderNode = new VShaderNode()))
            goto LFail;

        pVShaderNode->m_pAsm = Pop();
        pVShaderNode->m_pConst = Pop();
        Push(pVShaderNode);
        break;



    case P_PSHADER0:
        break;


    case P_PSHADER_BODY0:
        if(!(pPShaderNode = new PShaderNode()))
            goto LFail;

        pPShaderNode->m_pAsm = Pop();
        Push(pPShaderNode);
        break;

    case P_PSHADER_BODY1:
        if(!(pPShaderNode = new PShaderNode()))
            goto LFail;

        pPShaderNode->m_pAsm = Pop();
        pPShaderNode->m_pConst = Pop();
        Push(pPShaderNode);
        break;



    case P_ASSIGNMENTS0:
        break;

    case P_ASSIGNMENTS1:
        Combine();
        break;


    case P_ASSIGNMENT0:
        if(!(pStateNode = new StateNode()))
            goto LFail;

        pStateNode->m_pRValue = Pop();
        pStateNode->m_pLValue = Pop();
        Push(pStateNode);
        break;


    case P_EXPRESSION0:
        break;

    case P_EXPRESSION1:
        Combine();
        break;


    case P_VALUE0:
    case P_VALUE1:
    case P_VALUE2:
    case P_VALUE3:
    case P_VALUE4:
        break;

    case P_VECTOR0:
        pFloatNodeA = (FloatNode *) Pop();
        Push(new VectorNode(pFloatNodeA->m_fValue, 0.0f, 0.0f, 1.0f));
        delete pFloatNodeA;
        break;

    case P_VECTOR1:
        pFloatNodeB = (FloatNode *) Pop();
        pFloatNodeA = (FloatNode *) Pop();

        Push(new VectorNode(pFloatNodeA->m_fValue, pFloatNodeB->m_fValue, 0.0f, 1.0f));

        delete pFloatNodeA;
        delete pFloatNodeB;
        break;

    case P_VECTOR2:
        pFloatNodeC = (FloatNode *) Pop();
        pFloatNodeB = (FloatNode *) Pop();
        pFloatNodeA = (FloatNode *) Pop();

        Push(new VectorNode(pFloatNodeA->m_fValue, pFloatNodeB->m_fValue, pFloatNodeC->m_fValue, 1.0f));

        delete pFloatNodeA;
        delete pFloatNodeB;
        delete pFloatNodeC;
        break;

    case P_VECTOR3:
        pFloatNodeD = (FloatNode *) Pop();
        pFloatNodeC = (FloatNode *) Pop();
        pFloatNodeB = (FloatNode *) Pop();
        pFloatNodeA = (FloatNode *) Pop();

        Push(new VectorNode(pFloatNodeA->m_fValue, pFloatNodeB->m_fValue, pFloatNodeC->m_fValue, pFloatNodeD->m_fValue));

        delete pFloatNodeA;
        delete pFloatNodeB;
        delete pFloatNodeC;
        delete pFloatNodeD;
        break;


    case P_NUM0:
        break;

    case P_NUM1:
        pDwordNode = (DwordNode *) Pop();
        Push(new FloatNode((float) pDwordNode->m_dwValue));
        delete pDwordNode;
        break;

    case P_INT0:
        sscanf(m_szTok, "%d", &dw);
        Push(new DwordNode(dw));
        break;

    case P_HEX0:
        sscanf(m_szTok, "%x", &dw);
        Push(new DwordNode(dw));
        break;


    case P_FLOAT0:
        sscanf(m_szTok, "%f", &f);
        Push(new FloatNode(f));
        break;


    case P_ID0:
        Push(new IdNode(m_szTok));
        break;


    case P_ASM0:
        Push(new AsmNode(m_pchAsm, m_cchAsm));
        break;


    default:
        goto LFail;
    }

    return;

LFail:
    m_bFail = TRUE;
    return;
}



void
CD3DXEffectParser::Error(char *szFormat, ...)
{
    char szA[256];
    char szB[256];

    va_list ap;
    va_start(ap, szFormat);
    _vsnprintf(szA, sizeof(szB), szFormat, ap);
    szA[255] = '\0';
    va_end(ap);

    _snprintf(szB, sizeof(szB), "%s(%d) : %s", m_szFile, m_iLine, szA);
    szB[255] = '\0';

    DPF(0, "%s", szB);
/*
    m_Errors.Push(szB);
    m_cErrors++;
    m_cbErrors += strlen(szB) + 1;
*/
    m_bFail = TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////



HRESULT
CD3DXEffectParser::Parse(LPCVOID pv, UINT cb, LPCSTR szFile,
                         LPDIRECT3DDEVICE8 pDevice, LPD3DXEFFECT *ppEffect,
                         LPD3DXBUFFER *ppErrors)
{
    HRESULT hr;
    CD3DXEffect *pEffect;

    if(ppErrors)
        *ppErrors = NULL;

    if(!ppEffect)
        return E_INVALIDARG;

    if(ppEffect)
        *ppEffect = NULL;

    if(!pv)
        return E_INVALIDARG;

    if(!pDevice)
        return E_INVALIDARG;

    if(szFile)
        _snprintf(m_szFile, 256, "%s", szFile);
    else
        m_szFile[0] = 0;


    m_pchSource = (char *) pv;
    m_pch       = m_pchSource;
    m_pchLine   = m_pchSource;
    m_pchLim    = m_pchSource + cb;

    m_bFail    = FALSE;
    m_cErrors  = 0;
    m_cbErrors = 0;
    m_iLine    = 1;


    // Parse
    if(yyparse())
        goto LFail;

    if(FAILED(hr = Compile()))
        goto LDone;

    if(!(pEffect = new CD3DXEffect()))
        goto LOutOfMemory;

    if(FAILED(hr = pEffect->Initialize(pDevice, m_pEffectData)))
    {
        delete pEffect;
        goto LDone;
    }

    *ppEffect = pEffect;
    m_pEffectData = NULL;

    hr = S_OK;
    goto LDone;


LFail:
    hr = E_FAIL;
    goto LDone;

LOutOfMemory:
    hr = E_OUTOFMEMORY;
    goto LDone;

LDone:
    if(m_pNode)
        delete m_pNode;

    if(m_pEffectData)
        delete m_pEffectData;

    m_pNode = NULL;
    m_pEffectNode = NULL;
    m_pEffectData = NULL;

    // XXXlorenmcq - Fill in error buffer
    return hr;
}



//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


BOOL
CD3DXEffectParser::Eval(Node *pNode, Binding *pBind, DWORD *pdw, Binding **ppBind)
{
    DWORD dw = 0;

    while(pNode)
    {
        if(NODE_DWORD == pNode->m_dwType)
        {
            DwordNode *pDwordNode = (DwordNode *) pNode;
            dw |= pDwordNode->m_dwValue;
        }
        else if(NODE_FLOAT == pNode->m_dwType)
        {
            FloatNode *pFloatNode = (FloatNode *) pNode;
            dw |= *((DWORD *) &pFloatNode->m_fValue);
        }
        else if(NODE_ID == pNode->m_dwType)
        {
            IdNode *pIdNode = (IdNode *) pNode;
            DWORD dwBind = 0;

            while(pBind[dwBind].m_szName && _stricmp(pIdNode->m_szId, pBind[dwBind].m_szName))
                dwBind++;

            if(pBind[dwBind].m_szName)
            {
                dw |= pBind[dwBind].m_dwValue;

                if(ppBind)
                    *ppBind = pBind[dwBind].m_pBind;
            }
            else
            {
                DPF(0, "'%s' unexpected", pIdNode->m_szId);
                return FALSE;
            }
        }

        pNode = pNode->m_pNext;
    }

    *pdw = dw;
    return TRUE;
}


HRESULT
CD3DXEffectParser::Compile()
{
    DWORD dwType;
    DWORD dwSrcBlend;
    DWORD dwDstBlend;
    DWORD dwTechniqueFVF;
    DWORD dwPassFVF;

    UINT uDwords;
    UINT uFloats;
    UINT uColors;
    UINT uVectors;
    UINT uMatrices;
    UINT uTextures;
    UINT uTechniques;

    UINT uMinLOD;
    UINT uMaxLOD;

    Node *pNode;

    TechniqueData **ppTechniqueData;
    TechniqueNode *pTechniqueNode;
    TechniqueData *pTechniqueData;

    DeclarationNode *pDeclarationNode;

    PassData **ppPassData;
    PassNode *pPassNode;
    PassData *pPassData;

    StageData **ppStageData;
    StageNode *pStageNode;
    StageData *pStageData;

    StateData **ppStateData;
    StateNode *pStateNode;
    StateData *pStateData;

    VShaderNode *pVShaderNode;
    VShaderData *pVShaderData;

    PShaderNode *pPShaderNode;
    PShaderData *pPShaderData;

    AsmNode *pAsmNode;

    Binding *pBind;
    Binding *pBindDword   = NULL;
    Binding *pBindFloat   = NULL;
    Binding *pBindColor   = NULL;
    Binding *pBindVector  = NULL;
    Binding *pBindMatrix  = NULL;
    Binding *pBindTexture = NULL;


    if(!m_pNode)
        return E_FAIL;

    if(m_pNode->m_dwType != NODE_EFFECT)
        return E_FAIL;

    if(m_pNode->m_pStack != NULL)
        return E_FAIL;

    m_pEffectNode = (EffectNode *) m_pNode;

    if(!(m_pEffectData = new EffectData))
        return NULL;


    // Count variables
    uDwords   = 0;
    uFloats   = 0;
    uColors   = 0;
    uVectors  = 0;
    uMatrices = 0;
    uTextures = 0;

    pDeclarationNode = (DeclarationNode *) m_pEffectNode->m_pDeclarations;

    while(pDeclarationNode)
    {
        if(!Eval(pDeclarationNode->m_pType, g_BindDecl, &dwType, NULL))
            goto LFail;

        switch(dwType)
        {
        case 0: uDwords++;   break;
        case 1: uFloats++;   break;
        case 2: uColors++;   break;
        case 3: uVectors++;  break;
        case 4: uMatrices++; break;
        case 5: uTextures++; break;
        }

        pDeclarationNode = (DeclarationNode *) pDeclarationNode->m_pNext;
    }

    m_pEffectData->m_uDwords   = uDwords;
    m_pEffectData->m_uFloats   = uFloats;
    m_pEffectData->m_uColors   = uColors;
    m_pEffectData->m_uVectors  = uVectors;
    m_pEffectData->m_uMatrices = uMatrices;
    m_pEffectData->m_uTextures = uTextures;


    // Create bindings for textures & matrices
    if(!(pBindDword   = new Binding[uDwords   + 1]) ||
       !(pBindFloat   = new Binding[uFloats   + 1]) ||
       !(pBindColor   = new Binding[uColors   + 1]) ||
       !(pBindVector  = new Binding[uVectors  + 1]) ||
       !(pBindMatrix  = new Binding[uMatrices + 1]) ||
       !(pBindTexture = new Binding[uTextures + 1]))
    {
        goto LFail;
    }

    uDwords   = 0;
    uFloats   = 0;
    uColors   = 0;
    uVectors  = 0;
    uMatrices = 0;
    uTextures = 0;

    pDeclarationNode = (DeclarationNode *) m_pEffectNode->m_pDeclarations;


    while(pDeclarationNode)
    {
        UINT uBind;

        if(!Eval(pDeclarationNode->m_pType, g_BindDecl, &dwType, NULL))
            goto LFail;

        switch(dwType)
        {
        case 0: pBind = pBindDword;   uBind = uDwords++;   break;
        case 1: pBind = pBindFloat;   uBind = uFloats++;   break;
        case 2: pBind = pBindColor;   uBind = uColors++;   break;
        case 3: pBind = pBindVector;  uBind = uVectors++;  break;
        case 4: pBind = pBindMatrix;  uBind = uMatrices++; break;
        case 5: pBind = pBindTexture; uBind = uTextures++; break;
        }

        pBind[uBind].m_szName  = ((IdNode *) (pDeclarationNode->m_pName))->m_szId;
        pBind[uBind].m_dwValue = (DWORD) uBind;
        pBind[uBind].m_pBind   = NULL;

        pDeclarationNode = (DeclarationNode *) pDeclarationNode->m_pNext;
    }

    memset(&pBindDword  [uDwords],   0x00, sizeof(Binding));
    memset(&pBindFloat  [uFloats],   0x00, sizeof(Binding));
    memset(&pBindColor  [uColors],   0x00, sizeof(Binding));
    memset(&pBindVector [uVectors],  0x00, sizeof(Binding));
    memset(&pBindMatrix [uMatrices], 0x00, sizeof(Binding));
    memset(&pBindTexture[uTextures], 0x00, sizeof(Binding));


    // Process techniques
    uTechniques = 0;
    uMinLOD = (DWORD) -1;
    uMaxLOD = 0;

    ppTechniqueData = &m_pEffectData->m_pTechnique;
    pTechniqueNode = (TechniqueNode *) m_pEffectNode->m_pTechniques;

    while(pTechniqueNode)
    {
        if(!(pTechniqueData = new TechniqueData))
            goto LFail;

        *ppTechniqueData = pTechniqueData;
        ppTechniqueData = &pTechniqueData->m_pNext;


        // LOD
        if(pTechniqueNode->m_pLOD)
        {
            DwordNode *pDwordNode = (DwordNode *) pTechniqueNode->m_pLOD;
            pTechniqueData->m_uLOD = pDwordNode->m_dwValue;

            if(uMaxLOD < pDwordNode->m_dwValue)
                uMaxLOD = pDwordNode->m_dwValue;

            if(uMinLOD > pDwordNode->m_dwValue)
                uMinLOD = pDwordNode->m_dwValue;
        }


        // Renderstates
        dwTechniqueFVF = 0;

        ppStateData = &pTechniqueData->m_pRS;
        pStateNode = (StateNode *) pTechniqueNode->m_pStates;

        while(pStateNode)
        {
            if(!(pStateData = new StateData))
                goto LFail;

            *ppStateData = pStateData;
            ppStateData = &pStateData->m_pNext;

            if(!Eval(pStateNode->m_pLValue, g_BindRS, &pStateData->m_dwState, &pBind))
                goto LFail;

            if(!Eval(pStateNode->m_pRValue, pBind, &pStateData->m_dwValue, NULL))
                goto LFail;

            if(pStateData->m_dwState == D3DRS_FVF)
                dwTechniqueFVF = pStateData->m_dwValue;

            pStateNode = (StateNode *) pStateNode->m_pNext;
        }


        // Passes
        ppPassData = &pTechniqueData->m_pPass;
        pPassNode = (PassNode *) pTechniqueNode->m_pPasses;

        while(pPassNode)
        {
            if(!(pPassData = new PassData))
                goto LFail;

            *ppPassData = pPassData;
            ppPassData = &pPassData->m_pNext;


            // Enable AlphaBlend if Src/DstBlend is specified
            pStateData;
            ppStateData = &pPassData->m_pRS;

            if(!(pStateData = new StateData))
                goto LFail;

            pStateData->m_dwState = D3DRS_ALPHABLENDENABLE;
            pStateData->m_dwValue = (pPassNode->m_pSrcBlend && pPassNode->m_pDstBlend);
            pStateData->m_pNext   = NULL;

            *ppStateData = pStateData;
            ppStateData = &pStateData->m_pNext;


            // Add Src/DstBlend states
            if(pPassNode->m_pSrcBlend && pPassNode->m_pDstBlend)
            {
                if(!Eval(pPassNode->m_pSrcBlend, g_BindBLEND, &dwSrcBlend, NULL))
                    goto LFail;

                if(!Eval(pPassNode->m_pDstBlend, g_BindBLEND, &dwDstBlend, NULL))
                    goto LFail;

                if(!(pStateData = new StateData))
                    goto LFail;

                pStateData->m_dwState = D3DRS_SRCBLEND;
                pStateData->m_dwValue = dwSrcBlend;
                pStateData->m_pNext   = NULL;

                *ppStateData = pStateData;
                ppStateData = &pStateData->m_pNext;

                if(!(pStateData = new StateData))
                    goto LFail;

                pStateData->m_dwState = D3DRS_DESTBLEND;
                pStateData->m_dwValue = dwDstBlend;
                pStateData->m_pNext   = NULL;

                *ppStateData = pStateData;
                ppStateData = &pStateData->m_pNext;
            }



            // Renderstates
            dwPassFVF = dwTechniqueFVF;
            pStateNode = (StateNode *) pPassNode->m_pStates;

            while(pStateNode)
            {
                if(!(pStateData = new StateData))
                    goto LFail;

                *ppStateData = pStateData;
                ppStateData = &pStateData->m_pNext;

                if(!Eval(pStateNode->m_pLValue, g_BindRS, &pStateData->m_dwState, &pBind))
                    goto LFail;

                if(!Eval(pStateNode->m_pRValue, pBind, &pStateData->m_dwValue, NULL))
                    goto LFail;

                if(pStateData->m_dwState == D3DRS_FVF)
                    dwPassFVF = pStateData->m_dwValue;

                pStateNode = (StateNode *) pStateNode->m_pNext;
            }


            // Stages
            ppStageData = &pPassData->m_pStage;
            pStageNode = (StageNode *) pPassNode->m_pStages;

            while(pStageNode)
            {
                if(!(pStageData = new StageData))
                    goto LFail;

                *ppStageData = pStageData;
                ppStageData = &pStageData->m_pNext;


                if(pStageNode->m_pTexture)
                {
                    if(!Eval(pStageNode->m_pTexture, pBindTexture, (DWORD *) &pStageData->m_uTexture, NULL))
                        goto LFail;
                }

                if(pStageNode->m_pMatrix)
                {
                    if(!Eval(pStageNode->m_pMatrix, pBindMatrix, (DWORD *) &pStageData->m_uMatrix, NULL))
                        goto LFail;
                }

                // TextureStageStates
                ppStateData = &pStageData->m_pTSS;
                pStateNode = (StateNode *) pStageNode->m_pStates;

                while(pStateNode)
                {
                    if(!(pStateData = new StateData))
                        goto LFail;

                    *ppStateData = pStateData;
                    ppStateData = &pStateData->m_pNext;

                    if(!Eval(pStateNode->m_pLValue, g_BindTSS, (DWORD *) &pStateData->m_dwState, &pBind))
                        goto LFail;

                    if(!Eval(pStateNode->m_pRValue, pBind, (DWORD *) &pStateData->m_dwValue, NULL))
                        goto LFail;

                    pStateNode = (StateNode *) pStateNode->m_pNext;
                }

                pStageNode = (StageNode *) pStageNode->m_pNext;
            }


            // VertexShader
            pNode = pPassNode->m_pShaders;

            if(pNode && pNode->m_dwType == NODE_VSHADER)
            {
                pVShaderNode = (VShaderNode *) pNode;

                if(!(pVShaderData = new VShaderData))
                    goto LFail;

                pPassData->m_pVShader = pVShaderData;

                // FVF
                if(dwPassFVF)
                {
                    if(FAILED(D3DXDeclaratorFromFVF(dwPassFVF, pVShaderData->m_pDeclaration)))
                        goto LFail;
                }

                // Consts
                if(pVShaderNode->m_pConst)
                {
                    // UNDONE
                }

                // Asm
                pAsmNode = (AsmNode *) pVShaderNode->m_pAsm;

                if(FAILED(D3DXAssembleVertexShader(pAsmNode->m_pchAsm, pAsmNode->m_cchAsm, &pVShaderData->m_pShader, NULL)))
                    goto LFail;

                pNode = pNode->m_pNext;
            }


            // Pixel Shader
            if(pNode && pNode->m_dwType == NODE_PSHADER)
            {
                pPShaderNode = (PShaderNode *) pNode;

                if(!(pPShaderData = new PShaderData))
                    goto LFail;

                pPassData->m_pPShader = pPShaderData;

                // Consts
                if(pPShaderNode->m_pConst)
                {
                    // UNDONE
                }

                // Asm
                pAsmNode = (AsmNode *) pVShaderNode->m_pAsm;

                if(FAILED(D3DXAssemblePixelShader(pAsmNode->m_pchAsm, pAsmNode->m_cchAsm, &pPShaderData->m_pShader, NULL)))
                    goto LFail;
            }


            pTechniqueData->m_uPasses++;
            pPassNode = (PassNode *) pPassNode->m_pNext;
        }


        uTechniques++;
        pTechniqueNode = (TechniqueNode *) pTechniqueNode->m_pNext;
    }

    if(uMinLOD > uMaxLOD)
        uMinLOD = uMaxLOD;

    m_pEffectData->m_uMinLOD = uMinLOD;
    m_pEffectData->m_uMaxLOD = uMaxLOD;
    m_pEffectData->m_uTechniques = uTechniques;

    return S_OK;

LFail:
    if(pBindDword)   delete pBindDword;
    if(pBindFloat)   delete pBindFloat;
    if(pBindColor)   delete pBindColor;
    if(pBindVector)  delete pBindVector;
    if(pBindMatrix)  delete pBindMatrix;
    if(pBindTexture) delete pBindTexture;

    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\effect\CD3DXEffect.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       effect.h
//  Content:    D3DX effect types and functions
//
//////////////////////////////////////////////////////////////////////////////


#include "pcheffect.h"


EffectData::EffectData()
{
    m_uTextures = 0;
    m_uMatrices = 0;
    m_uTechniques = 0;

    m_uMaxLOD = 0;
    m_uMaxLOD = 0;

    m_pTechnique = NULL;
}

EffectData::~EffectData()
{
    delete m_pTechnique;
}



//////////////////////////////////////////////////////////////////////////////
// CD3DXEffect ///////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

CD3DXEffect::CD3DXEffect()
{
    m_uRefCount  = 1;
    m_pData      = NULL;
    m_ppSurface  = NULL;
    m_pMatrix    = NULL;
    m_pDevice    = NULL;
}


CD3DXEffect::~CD3DXEffect()
{
    if(!m_pData)
        return;

    for(UINT u = 0; u < m_pData->m_uTextures; u++)
    {
        if(m_ppSurface[u])
            m_ppSurface[u]->Release();
    }

    delete m_ppSurface;
    delete m_pMatrix;
    delete m_pData;

    if(m_pDevice)
        m_pDevice->Release();
}


HRESULT
CD3DXEffect::Initialize(IDirect3DDevice8 *pDevice, EffectData *pData)
{
    // Setup data structures
    if(!(m_ppSurface = new IDirect3DBaseTexture8*[pData->m_uTextures]))
        return E_OUTOFMEMORY;

    if(!(m_pMatrix = new D3DXMATRIX[pData->m_uMatrices]))
        return E_OUTOFMEMORY;

    memset(m_ppSurface, 0x00, pData->m_uTextures * sizeof(IDirect3DBaseTexture8*));

    for(UINT u = 0; u < pData->m_uMatrices; u++)
        D3DXMatrixIdentity(&m_pMatrix[u]);

    m_pData = pData;
    m_pDevice = pDevice;
    m_pDevice->AddRef();


    return S_OK;
}


STDMETHODIMP
CD3DXEffect::QueryInterface(REFIID iid, LPVOID *ppv)
{
#if DBG
    if(!ppv)
        return E_INVALIDARG;
#endif

    if(IsEqualIID(iid, IID_ID3DXEffect))
        *ppv = (ID3DXEffect *) this;
    else if(IsEqualIID(iid, IID_IUnknown))
        *ppv = (IUnknown *) this;
    else
        return E_NOINTERFACE;

    AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG)
CD3DXEffect::AddRef()
{
    return ++m_uRefCount;
}


STDMETHODIMP_(ULONG)
CD3DXEffect::Release()
{
    if(--m_uRefCount)
        return m_uRefCount;

    delete this;
    return 0;
}


STDMETHODIMP
CD3DXEffect::GetDevice(IDirect3DDevice8 **ppDevice)
{
#if DBG
    if(!ppDevice)
        return E_INVALIDARG;
#endif

    m_pDevice->AddRef();
    *ppDevice = m_pDevice;

    return S_OK;
}


STDMETHODIMP_(D3DXEFFECT_DESC)
CD3DXEffect::GetEffectDesc()
{
    D3DXEFFECT_DESC desc;
    memset(&desc, 0x00, sizeof(desc));

    desc.Matrices   = m_pData->m_uMatrices;
    desc.Textures   = m_pData->m_uTextures;
    desc.Techniques = m_pData->m_uTechniques;
    desc.MinLOD     = m_pData->m_uMinLOD;
    desc.MaxLOD     = m_pData->m_uMaxLOD;

    return desc;
}


STDMETHODIMP
CD3DXEffect::SetDword(UINT uINdex, DWORD dw)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CD3DXEffect::SetFloat(UINT uINdex, FLOAT f)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CD3DXEffect::SetColor(UINT uINdex, D3DCOLOR c)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CD3DXEffect::SetVector(UINT uINdex, D3DXVECTOR4 *pVector)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CD3DXEffect::SetMatrix(UINT uIndex, D3DMATRIX *pMatrix)
{
#if DBG
    if(uIndex >= m_pData->m_uMatrices)
        return E_INVALIDARG;
    if(!pMatrix)
        return E_INVALIDARG;
#endif

    m_pMatrix[uIndex] = *pMatrix;
    return S_OK;
}


STDMETHODIMP
CD3DXEffect::SetTexture(UINT uIndex, IDirect3DBaseTexture8* pSurface)
{
#if DBG
    if(uIndex >= m_pData->m_uTextures)
        return E_INVALIDARG;
#endif

    if(pSurface)
        pSurface->AddRef();

    if(m_ppSurface[uIndex])
        m_ppSurface[uIndex]->Release();

    m_ppSurface[uIndex] = pSurface;
    return S_OK;
}


STDMETHODIMP
CD3DXEffect::GetTechnique(UINT uIndex, LPD3DXTECHNIQUE *ppTechnique)
{
#if DBG
    if(uIndex >= m_pData->m_uTechniques)
        return E_INVALIDARG;
    if(!ppTechnique)
        return E_INVALIDARG;
#endif

    HRESULT hr;

    D3DXMATRIX mat;
    D3DXMatrixIdentity(&mat);

    DWORD dwClear;
    DWORD dwTextureUsed = 0;
    DWORD dwMatrixUsed = 0;

    CD3DXTechnique *pTechnique = NULL;


    TechniqueData *pTechniqueData = m_pData->m_pTechnique;

    while(pTechniqueData && uIndex)
    {
        pTechniqueData = pTechniqueData->m_pNext;
        uIndex--;
    }

    if(!pTechniqueData)
        return E_INVALIDARG;



    // Create stateblocks
    for(BOOL bClear = 0; bClear <= 1; bClear++)
    {
        if(bClear)
            m_pDevice->BeginStateBlock();

        PassData *pPassData = pTechniqueData->m_pPass;

        while(pPassData)
        {
            if(bClear || !pPassData->m_dwState)
            {
                if(!bClear)
                    m_pDevice->BeginStateBlock();

                // Set technique renderstates
                StateData *pStateData = pTechniqueData->m_pRS;

                while(pStateData)
                {
                    switch(pStateData->m_dwState)
                    {
                    case D3DRS_FVF:
                        m_pDevice->SetVertexShader(pStateData->m_dwValue);
                        break;

                    default:
                        m_pDevice->SetRenderState((_D3DRENDERSTATETYPE) pStateData->m_dwState, pStateData->m_dwValue);
                        break;
                    }

                    pStateData = pStateData->m_pNext;
                }

                // Set pass renderstates
                pStateData = pPassData->m_pRS;

                while(pStateData)
                {
                    switch(pStateData->m_dwState)
                    {
                    case D3DRS_FVF:
                        m_pDevice->SetVertexShader(pStateData->m_dwValue);
                        break;

                    default:
                        m_pDevice->SetRenderState((_D3DRENDERSTATETYPE) pStateData->m_dwState, pStateData->m_dwValue);
                        break;
                    }

                    pStateData = pStateData->m_pNext;
                }

                // Set pass texturestagestates
                UINT uStage = 0;
                StageData *pStageData = pPassData->m_pStage;

                while(pStageData)
                {
                    if(bClear)
                    {
                        if(pStageData->m_uTexture < m_pData->m_uTextures)
                        {
                            dwTextureUsed |= (1 << pStageData->m_uTexture);
                            m_pDevice->SetTexture(uStage, NULL);
                        }

                        if(pStageData->m_uMatrix < m_pData->m_uMatrices)
                        {
                            dwMatrixUsed |= (1 << pStageData->m_uMatrix);
                            m_pDevice->SetTransform((_D3DTRANSFORMSTATETYPE) (uStage + D3DTS_TEXTURE0), &mat);
                        }
                    }

                    m_pDevice->SetTextureStageState(uStage, D3DTSS_COLOROP, D3DTOP_DISABLE);
                    m_pDevice->SetTextureStageState(uStage, D3DTSS_ALPHAOP, D3DTOP_DISABLE);

                    StateData *pStateData = pStageData->m_pTSS;

                    while(pStateData)
                    {
                        m_pDevice->SetTextureStageState(uStage, (_D3DTEXTURESTAGESTATETYPE) pStateData->m_dwState, pStateData->m_dwValue);
                        pStateData = pStateData->m_pNext;
                    }

                    uStage++;
                    pStageData = pStageData->m_pNext;
                }

                if(uStage < 8)
                {
                    m_pDevice->SetTextureStageState(uStage, D3DTSS_COLOROP, D3DTOP_DISABLE);
                    m_pDevice->SetTextureStageState(uStage, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
                }

                if(!bClear)
                    m_pDevice->EndStateBlock(&pPassData->m_dwState);
            }


            // Vertex shader
            if(!bClear && pPassData->m_pVShader && !pPassData->m_dwVShader)
            {
                DWORD *pdwShader = (DWORD *) pPassData->m_pVShader->m_pShader->GetBufferPointer();

                if(FAILED(hr = m_pDevice->CreateVertexShader(pPassData->m_pVShader->m_pDeclaration, pdwShader, &pPassData->m_dwVShader, 0)))
                    return hr;
            }


            // Pixel shader
            if(!bClear && pPassData->m_pPShader && !pPassData->m_dwPShader)
            {
                DWORD *pdwShader = (DWORD *) pPassData->m_pPShader->m_pDeclaration->GetBufferPointer();

                if(FAILED(hr = m_pDevice->CreatePixelShader(pdwShader, &pPassData->m_dwVShader)))
                    return hr;
            }


            pPassData = pPassData->m_pNext;
        }

        if(bClear)
            m_pDevice->EndStateBlock(&dwClear);
    }


    // Create technique
    if(!(pTechnique = new CD3DXTechnique))
        return E_OUTOFMEMORY;


    if(FAILED(hr = pTechnique->Initialize(this, pTechniqueData, dwClear, dwTextureUsed, dwMatrixUsed)))
    {
        pTechnique->Release();
        return hr;
    }

    *ppTechnique = (LPD3DXTECHNIQUE) pTechnique;
    return S_OK;
}


STDMETHODIMP
CD3DXEffect::PickTechnique(UINT uMinLOD, UINT uMaxLOD, LPD3DXTECHNIQUE *ppTechnique)
{
#if DBG
    if(!ppTechnique)
        return E_INVALIDARG;
#endif

    UINT uTechnique = 0;
    TechniqueData *pTechniqueData = m_pData->m_pTechnique;

    while(pTechniqueData)
    {
        if(pTechniqueData->m_uLOD >= uMinLOD &&
           pTechniqueData->m_uLOD <= uMaxLOD)
        {
            LPD3DXTECHNIQUE pTechnique;

            if(SUCCEEDED(GetTechnique(uTechnique, &pTechnique)))
            {
                if(SUCCEEDED(pTechnique->Validate()))
                {
                    *ppTechnique = pTechnique;
                    return S_OK;
                }

                pTechnique->Release();
            }
        }

        uTechnique++;
        pTechniqueData = pTechniqueData->m_pNext;
    }

    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\effect\cdeclaration.cpp ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       CDeclaration.cpp
//  Content:    Parse declarations
//
///////////////////////////////////////////////////////////////////////////

#include "pcheffect.h"


//
// Productions
//

enum
{
    P_DECLARATION_0,
    P_DECLARATION_1,
    P_STATEMENTS_0,
    P_STATEMENTS_1,
    P_STATEMENT_0,
    P_STATEMENT_1,
    P_STATEMENT_2,
    P_STATEMENT_3,
    P_STATEMENT_4,
    P_TYPE_UINT8,
    P_TYPE_INT16,
    P_TYPE_FLOAT,
    P_TYPE_D3DCOLOR,
    P_FVF_0,
    P_FVF_1,
    P_NUM_0,
    P_NUM_1,
    P_ID_0
};

#define Prod(n, m) \
    CD3DXDeclarationCompiler::s_pCompiler->Production(n, m)

#define d3dxdecl_lex \
    CD3DXDeclarationCompiler::s_pCompiler->Token

#define d3dxdecl_error \
    CD3DXDeclarationCompiler::s_pCompiler->Error

#define lint
#pragma warning(disable : 4242)
#include "decl_y.h"
#pragma warning(default : 4242)




//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

enum
{
    TYPE_UINT8,
    TYPE_INT16,
    TYPE_FLOAT,
    TYPE_D3DCOLOR
};

#define RVALUE_END() \
    { NULL, 0 }

static RValue g_rvFvf[] =
{
    { "XYZ",             D3DFVF_XYZ              },
    { "XYZRHW",          D3DFVF_XYZRHW           },
    { "XYZB1",           D3DFVF_XYZB1            },
    { "XYZB2",           D3DFVF_XYZB2            },
    { "XYZB3",           D3DFVF_XYZB3            },
    { "XYZB4",           D3DFVF_XYZB4            },

    { "NORMAL",          D3DFVF_NORMAL           },
    { "DIFFUSE",         D3DFVF_DIFFUSE          },
    { "SPECULAR",        D3DFVF_SPECULAR         },

    { "TEX0",            D3DFVF_TEX0             },
    { "TEX1",            D3DFVF_TEX1             },
    { "TEX2",            D3DFVF_TEX2             },
    { "TEX3",            D3DFVF_TEX3             },

    { "TEXCOORDSIZE1_0", D3DFVF_TEXCOORDSIZE1(0) },
    { "TEXCOORDSIZE1_1", D3DFVF_TEXCOORDSIZE1(1) },
    { "TEXCOORDSIZE1_2", D3DFVF_TEXCOORDSIZE1(2) },
    { "TEXCOORDSIZE1_3", D3DFVF_TEXCOORDSIZE1(3) },
    { "TEXCOORDSIZE1_4", D3DFVF_TEXCOORDSIZE1(4) },
    { "TEXCOORDSIZE1_5", D3DFVF_TEXCOORDSIZE1(5) },
    { "TEXCOORDSIZE1_6", D3DFVF_TEXCOORDSIZE1(6) },
    { "TEXCOORDSIZE1_7", D3DFVF_TEXCOORDSIZE1(7) },

    { "TEXCOORDSIZE2_0", D3DFVF_TEXCOORDSIZE2(0) },
    { "TEXCOORDSIZE2_1", D3DFVF_TEXCOORDSIZE2(1) },
    { "TEXCOORDSIZE2_2", D3DFVF_TEXCOORDSIZE2(2) },
    { "TEXCOORDSIZE2_3", D3DFVF_TEXCOORDSIZE2(3) },
    { "TEXCOORDSIZE2_4", D3DFVF_TEXCOORDSIZE2(4) },
    { "TEXCOORDSIZE2_5", D3DFVF_TEXCOORDSIZE2(5) },
    { "TEXCOORDSIZE2_6", D3DFVF_TEXCOORDSIZE2(6) },
    { "TEXCOORDSIZE2_7", D3DFVF_TEXCOORDSIZE2(7) },

    { "TEXCOORDSIZE3_0", D3DFVF_TEXCOORDSIZE3(0) },
    { "TEXCOORDSIZE3_1", D3DFVF_TEXCOORDSIZE3(1) },
    { "TEXCOORDSIZE3_2", D3DFVF_TEXCOORDSIZE3(2) },
    { "TEXCOORDSIZE3_3", D3DFVF_TEXCOORDSIZE3(3) },
    { "TEXCOORDSIZE3_4", D3DFVF_TEXCOORDSIZE3(4) },
    { "TEXCOORDSIZE3_5", D3DFVF_TEXCOORDSIZE3(5) },
    { "TEXCOORDSIZE3_6", D3DFVF_TEXCOORDSIZE3(6) },
    { "TEXCOORDSIZE3_7", D3DFVF_TEXCOORDSIZE3(7) },

    { "TEXCOORDSIZE4_0", D3DFVF_TEXCOORDSIZE4(0) },
    { "TEXCOORDSIZE4_1", D3DFVF_TEXCOORDSIZE4(1) },
    { "TEXCOORDSIZE4_2", D3DFVF_TEXCOORDSIZE4(2) },
    { "TEXCOORDSIZE4_3", D3DFVF_TEXCOORDSIZE4(3) },
    { "TEXCOORDSIZE4_4", D3DFVF_TEXCOORDSIZE4(4) },
    { "TEXCOORDSIZE4_5", D3DFVF_TEXCOORDSIZE4(5) },
    { "TEXCOORDSIZE4_6", D3DFVF_TEXCOORDSIZE4(6) },
    { "TEXCOORDSIZE4_7", D3DFVF_TEXCOORDSIZE4(7) },

    RVALUE_END()
};


//////////////////////////////////////////////////////////////////////////////
// CEffectCompiler ///////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

CD3DXDeclarationCompiler* CD3DXDeclarationCompiler::s_pCompiler = NULL;

CD3DXDeclarationCompiler::CD3DXDeclarationCompiler()
{
    m_pDeclaration = NULL;
    m_pErrors = NULL;

    m_bFail = FALSE;

    m_iLine     = 1;
    m_szFile[0] = '\0';
    m_pchSource = NULL;
    m_pchLine   = NULL;
    m_pch       = NULL;
    m_pchLim    = NULL;

    m_szTok[0]  = '\0';
    s_pCompiler = this;
}


CD3DXDeclarationCompiler::~CD3DXDeclarationCompiler()
{
    if(m_pDeclaration)
        delete m_pDeclaration;

    if(m_pErrors)
        delete m_pErrors;
}



//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////



HRESULT
CD3DXDeclarationCompiler::Compile(LPCVOID pv, UINT cb, LPCSTR szFile, UINT iLine,
        LPD3DXBUFFER *ppCompiledDeclaration, LPD3DXBUFFER *ppCompilationErrors)
{
    HRESULT hr = D3DERR_INVALIDCALL;

    if(!pv)
        goto LDone;

    m_bFail     = FALSE;
    m_iLine     = iLine;
    m_pchSource = (char *) pv;
    m_pch       = m_pchSource;
    m_pchLine   = m_pchSource;
    m_pchLim    = m_pchSource + cb;

    _snprintf(m_szFile, 256, "%s", szFile ? szFile : "");



    // Parse

    if(yyparse() || m_bFail)
    {
        delete m_pDeclaration;
        m_pDeclaration = NULL;
        hr = E_FAIL;
        goto LDone;
    }

    hr = S_OK;
    goto LDone;


LDone:
    // Create code buffer
    if(ppCompiledDeclaration)
    {
        UINT cdwSize = Serialize(m_pDeclaration, NULL);
    
        if(SUCCEEDED(D3DXCreateBuffer(cdwSize * sizeof(DWORD), ppCompiledDeclaration)))
        {
            Serialize(m_pDeclaration, (*ppCompiledDeclaration)->GetBufferPointer());
        }
    }

    // Create error buffer
    if(ppCompilationErrors)
    {
        *ppCompilationErrors = NULL;

        CNode *pNode;
        UINT cbSize = 1;

        for(pNode = m_pErrors; pNode; pNode = pNode->m_pStack)
            cbSize += strlen((char *) pNode->m_pdwData) + 1;

        if(SUCCEEDED(D3DXCreateBuffer(cbSize, ppCompilationErrors)))
        {
            BYTE *pb = (BYTE *) (*ppCompilationErrors)->GetBufferPointer() + cbSize;
            *--pb = '\0';

            for(pNode = m_pErrors; pNode; pNode = pNode->m_pStack)
            {
                UINT cb = strlen((char *) pNode->m_pdwData) + 1;

                pb -= cb;
                memcpy(pb, pNode->m_pdwData, cb);
                pb[cb - 1] = '\n';
            }   
        }
    }

    return hr;
}





int
CD3DXDeclarationCompiler::Token()
{
    char *pch;
    SIZE_T cch;

    while(m_pch < m_pchLim)
    {
        char ch = *m_pch;

        if(ch == '\n')
        {
            // newline
            m_pch++;
            m_pchLine = m_pch;
            m_iLine++;
        }
        else if(isspace(ch))
        {
            // whitespace
            m_pch++;
        }
        else if(ch == '#' && m_pch == m_pchLine)
        {
            // preprocessor directive
            pch = m_pch;
            for(m_pch++; m_pch < m_pchLim && *m_pch != '\n'; m_pch++);

            if(m_pch - pch > 5 && !memcmp(pch, "#line", 5))
            {
                // Skip #line
                for(; pch < m_pch && !isspace(*pch); pch++);

                // Skip whitespace
                for(; pch < m_pch && isspace(*pch); pch++);
                char *pchNum = pch;

                // Line number
                for(; pch < m_pch && !isspace(*pch); pch++);
                char *pchNumLim = pch;

                // Beginning of file name
                for(; pch < m_pch && *pch != '"'; pch++);
                char *pchFile = pch;

                if(pch < m_pch)
                    pch++;

                // End of file name
                for(; pch < m_pch && *pch != '"'; pch++);
                char *pchFileLim = pch;


                char sz[256];

                SIZE_T cchNum = pchNumLim - pchNum;
                SIZE_T cchFile = pchFileLim - pchFile;

                if(cchNum >= sizeof(sz))
                    cchNum = sizeof(sz) - 1;

                if(cchFile >= sizeof(m_szFile))
                    cchFile = sizeof(m_szFile) - 1;

                if(cchNum)
                {
                    memcpy(sz, pchNum, cchNum);
                    sz[cchNum] = 0;
                    m_iLine = atoi(sz) - 1;
                }

                if(cchFile > 1)
                {
                    // Copy filename, removing double backslashes
                    pchFile++;
                    pch = m_szFile;

                    while(pchFile < pchFileLim)
                    {
                        *pch = *pchFile++;

                        if(*pch == '\\' && pchFile < pchFileLim && *pchFile == '\\')
                            pchFile++;

                        pch++;
                    }

                    *pch = 0;
                }
            }
            else
            {
                Error("preprocessor directives are not supported.");
            }
        }
        else if(ch == '/' && m_pch + 1 < m_pchLim && m_pch[1] == '/')
        {
            // comment
            for(m_pch++; m_pch < m_pchLim && *m_pch != '\n'; m_pch++);
        }
        else if(isalpha(ch))
        {
            // keyword / identifier
            pch = m_pch;
            for(m_pch++; m_pch < m_pchLim && (isalnum(*m_pch) || '_' == *m_pch); m_pch++);

            cch = m_pch - pch;

            if(cch >= sizeof(m_szTok))
                cch = sizeof(m_szTok) - 1;

            memcpy(m_szTok, pch, cch);
            m_szTok[cch] = 0;

            if(!_stricmp(m_szTok, "stream"))     { return T_KW_STREAM; }
            if(!_stricmp(m_szTok, "skip"))       { return T_KW_SKIP; }
            if(!_stricmp(m_szTok, "fvf"))        { return T_KW_FVF; }
            if(!_stricmp(m_szTok, "ubyte"))      { return T_KW_UINT8; }
            if(!_stricmp(m_szTok, "short"))      { return T_KW_INT16; }
            if(!_stricmp(m_szTok, "float"))      { return T_KW_FLOAT; }
            if(!_stricmp(m_szTok, "d3dcolor"))   { return T_KW_D3DCOLOR; }

            return T_ID;
        }
        else if(ch == '0' && m_pch + 1 < m_pchLim && m_pch[1] == 'x')
        {
            // hex
            m_pch += 2;
            pch = m_pch;

            for(; m_pch < m_pchLim && (isdigit(*m_pch) || tolower(*m_pch) >= 'a' && tolower(*m_pch) <= 'f'); m_pch++);

            cch = m_pch - pch;

            if(cch >= sizeof(m_szTok))
                cch = sizeof(m_szTok) - 1;

            memcpy(m_szTok, pch, cch);
            m_szTok[cch] = 0;

            return T_HEX;
        }
        else if(isdigit(ch))
        {
            // number
            pch = m_pch;
            for(m_pch++; m_pch < m_pchLim && isdigit(*m_pch); m_pch++);
            cch = m_pch - pch;

            if(cch >= sizeof(m_szTok))
                cch = sizeof(m_szTok) - 1;

            memcpy(m_szTok, pch, cch);
            m_szTok[cch] = 0;

            return T_NUM;
        }
        else
        {
            // other character
            m_pch++;
            return ch;
        }
    }


    if(m_pch == m_pchLim)
    {
        m_pch++;
        return T_EOF;
    }

    return -1;
}



void
CD3DXDeclarationCompiler::Production(UINT uProduction, UINT uArgs)
{
    UINT i;
    DWORD pdwDecl[MAX_FVF_DECL_SIZE];

    CNode *pNode = NULL;
    CNode **ppArg = (CNode **) _alloca(uArgs * sizeof(CNode *));

    if(m_bFail)
        return;


    // Pop arguments off of stack
    for(i = uArgs; i--; )
        ppArg[i] = Pop();

    if(m_bFail)
        goto LDone;


    // Handle productions
    switch(uProduction)
    {
    case P_DECLARATION_0:
        if(FAILED(CreateNode(N_INTERNAL, 1, 0, &pNode)))
            break;

        pNode->m_pdwData[0] = D3DVSD_END();
        break;

    case P_DECLARATION_1:
        if((ppArg[0]->m_pdwData[0] & D3DVSD_TOKENTYPEMASK) != (D3DVSD_TOKEN_STREAM << D3DVSD_TOKENTYPESHIFT))
        {
            if(FAILED(CreateNode(N_INTERNAL, 1, 1, &pNode)))
                break;

            pNode->m_pdwData[0] = D3DVSD_STREAM(0);
            pNode->m_ppNodes[0] = ppArg[0];
            ppArg[0] = pNode;
        }

        for(pNode = ppArg[0]; pNode->m_ppNodes[0]; pNode = pNode->m_ppNodes[0]);

        if(FAILED(CreateNode(N_INTERNAL, 1, 0, &pNode->m_ppNodes[0])))
            break;

        pNode->m_ppNodes[0]->m_pdwData[0] = D3DVSD_END();

        pNode = ppArg[0];
        ppArg[0] = NULL;
        break;

    case P_STATEMENTS_0:
        pNode = ppArg[0];
        ppArg[0] = NULL;
        break;

    case P_STATEMENTS_1:
        pNode = ppArg[0];
        ppArg[0] = NULL;

        pNode->m_ppNodes[0] = ppArg[1];
        ppArg[1] = NULL;
        break;

    case P_STATEMENT_0:
        if(FAILED(CreateNode(N_INTERNAL, 1, 1, &pNode)))
            break;

        pNode->m_pdwData[0] = D3DVSD_STREAM(ppArg[0]->m_pdwData[0]);
        pNode->m_ppNodes[0] = NULL;
        break;
        
    case P_STATEMENT_1:
        if(FAILED(CreateNode(N_INTERNAL, 1, 1, &pNode)))
            break;

        pNode->m_pdwData[0] = D3DVSD_SKIP(ppArg[0]->m_pdwData[0]);
        pNode->m_ppNodes[0] = NULL;
        break;
        
    case P_STATEMENT_2:
        {
            DWORD cdw;

            if(FAILED(D3DXDeclaratorFromFVF(ppArg[0]->m_pdwData[0], pdwDecl)))
                break;

            for(cdw = 0; pdwDecl[cdw] != D3DVSD_END(); cdw++);

            if(FAILED(CreateNode(N_INTERNAL, cdw + 1, 1, &pNode)))
                break;

            memcpy(&pNode->m_pdwData[0], &pdwDecl[1], cdw * sizeof(DWORD));
            pNode->m_ppNodes[0] = NULL;
        }

        break;

    case P_STATEMENT_3:
        if(FAILED(CreateNode(N_INTERNAL, 1, 1, &pNode)))
            break;

        if(FAILED(LookupDecl(ppArg[0]->m_pdwData[0], (char *) ppArg[1]->m_pdwData, 1, &pNode->m_pdwData[0])))
            break;

        pNode->m_ppNodes[0] = NULL;
        break;

    case P_STATEMENT_4:
        if(FAILED(CreateNode(N_INTERNAL, 1, 1, &pNode)))
            break;

        if(FAILED(LookupDecl(ppArg[0]->m_pdwData[0], (char *) ppArg[1]->m_pdwData, ppArg[2]->m_pdwData[0], &pNode->m_pdwData[0])))
            break;

        pNode->m_ppNodes[0] = NULL;
        break;


    case P_TYPE_UINT8:
        if(FAILED(CreateNode(N_INTERNAL, 1, 0, &pNode)))
            break;

        pNode->m_pdwData[0] = TYPE_UINT8;
        break;

    case P_TYPE_INT16:
        if(FAILED(CreateNode(N_INTERNAL, 1, 0, &pNode)))
            break;

        pNode->m_pdwData[0] = TYPE_INT16;
        break;

    case P_TYPE_FLOAT:
        if(FAILED(CreateNode(N_INTERNAL, 1, 0, &pNode)))
            break;

        pNode->m_pdwData[0] = TYPE_FLOAT;
        break;

    case P_TYPE_D3DCOLOR:
        if(FAILED(CreateNode(N_INTERNAL, 1, 0, &pNode)))
            break;

        pNode->m_pdwData[0] = TYPE_D3DCOLOR;
        break;

    case P_FVF_0:
        if(FAILED(CreateNode(N_INTERNAL, 1, 0, &pNode)))
            break;

        pNode->m_pdwData[0] = 0;

        if(FAILED(LookupFvf((char *) ppArg[0]->m_pdwData, &pNode->m_pdwData[0])))
            break;

        break;

    case P_FVF_1:
        pNode = ppArg[1];
        ppArg[1] = NULL;

        if(FAILED(LookupFvf((char *) ppArg[0]->m_pdwData, &pNode->m_pdwData[0])))
            break;

        break;

    case P_NUM_0:
        if(FAILED(CreateNode(N_INTERNAL, 1, 0, &pNode)))
            break;

        sscanf(m_szTok, "%d", &pNode->m_pdwData[0]);
        break;

    case P_NUM_1:
        if(FAILED(CreateNode(N_INTERNAL, 1, 0, &pNode)))
            break;

        sscanf(m_szTok, "%x", &pNode->m_pdwData[1]);
        break;

    case P_ID_0:
        {
            UINT cb  = strlen(m_szTok) + 1;
            UINT cdw = (cb + 3) >> 2;

            if(FAILED(CreateNode(N_INTERNAL, cdw, 0, &pNode)))
                break;

            memset(pNode->m_pdwData, 0x00, cdw * sizeof(DWORD));
            memcpy(pNode->m_pdwData, m_szTok, cb);
        }

        break;
    }


    // Push the new node on the stack
    if(!m_bFail)
    {
        if(pNode)
            Push(pNode);
        else
            Error("Internal compiler error! %d", __LINE__);
    }


LDone:
    // Delete arguments
    for(i = 0; i < uArgs; i++)
    {
        if(ppArg[i])
            delete ppArg[i];
    }

    return;
}



void
CD3DXDeclarationCompiler::Push(CNode *pNode)
{
    if(!pNode || pNode->m_pStack)
    {
        Error("Internal compiler error! %d", __LINE__);
        return;
    }

    pNode->m_pStack = m_pDeclaration;
    m_pDeclaration = pNode;
    return;
}


CNode *
CD3DXDeclarationCompiler::Pop()
{
    if(!m_pDeclaration)
    {
        Error("Internal compiler error! %d", __LINE__);
        return NULL;
    }

    CNode *pNode = m_pDeclaration;
    m_pDeclaration = pNode->m_pStack;
    pNode->m_pStack = NULL;
    return pNode;
}


UINT 
CD3DXDeclarationCompiler::Serialize(CNode *pNode, LPVOID pv)
{
    UINT   cdw = 0;
    DWORD* pdw = (DWORD *) pv;
    
    if(!pNode)
        return 0;


    // Data
    if(pdw)
    {
        memcpy(pdw, pNode->m_pdwData, pNode->m_cdwData * sizeof(DWORD));
        pdw += pNode->m_cdwData;
    }

    cdw += pNode->m_cdwData;


    // Nodes
    for(UINT i = 0; i < pNode->m_cNodes; i++)
    {
        UINT cdwNode;

        cdwNode = Serialize(pNode->m_ppNodes[i], pdw);

        if(pdw)
            pdw += cdwNode;

        cdw += cdwNode;
    }

    return cdw;
}


void
CD3DXDeclarationCompiler::Error(char *szFormat, ...)
{
    char szA[256];
    char szB[256];


    // Format error
    va_list ap;
    va_start(ap, szFormat);
    _vsnprintf(szA, sizeof(szA), szFormat, ap);
    szA[255] = '\0';
    va_end(ap);

    _snprintf(szB, sizeof(szB), "%s(%d) : %s", m_szFile, m_iLine, szA);
    szB[255] = '\0';


    // Output error in debug spew
    DPF(0, "%s", szB);
    AppendError(szB);
    m_bFail = TRUE;
}


void
CD3DXDeclarationCompiler::AppendError(char *sz)
{
    UINT cb = strlen(sz) + 1;
    CNode *pNode = new CNode;

    if(pNode && SUCCEEDED(pNode->Initialize(0, (cb + 3) >> 2, 0)))
    {
        memcpy(pNode->m_pdwData, sz, cb);
        pNode->m_pStack = m_pErrors;
        m_pErrors = pNode;
    }
}


HRESULT 
CD3DXDeclarationCompiler::CreateNode(DWORD dwId, UINT cdwData, UINT cNodes, CNode **ppNode)
{
    CNode *pNode;

    D3DXASSERT(ppNode != NULL);

    if(!(pNode = new CNode))
    {
        Error("Out of memory!");
        return E_OUTOFMEMORY;
    }

    if(FAILED(pNode->Initialize(dwId, cdwData, cNodes)))
    {
        Error("Out of memory!");
        return E_OUTOFMEMORY;
    }

    *ppNode = pNode;
    return S_OK;
}


HRESULT 
CD3DXDeclarationCompiler::LookupDecl(DWORD dwType, char *szId, DWORD dwDim, DWORD *pdwDecl)
{
    DWORD dwTDim = (DWORD) -1;

    switch(dwType)
    {

    case TYPE_UINT8:
        switch(dwDim)
        {
        case 4: _asm int 3; break; // dwTDim = D3DVSDT_UBYTE4; break;
        }
        break;

    case TYPE_INT16:
        switch(dwDim)
        {
        case 2: dwTDim = D3DVSDT_SHORT2; break;
        case 4: dwTDim = D3DVSDT_SHORT4; break;
        }
        break;

    case TYPE_FLOAT:
        switch(dwDim)
        {
        case 1: dwTDim = D3DVSDT_FLOAT1; break;
        case 2: dwTDim = D3DVSDT_FLOAT2; break;
        case 3: dwTDim = D3DVSDT_FLOAT3; break;
        case 4: dwTDim = D3DVSDT_FLOAT4; break;
        }
        break;

    case TYPE_D3DCOLOR:
        switch(dwDim)
        {
        case 1: dwTDim = D3DVSDT_D3DCOLOR; break;
        }
        break;
    }

    if((DWORD) -1 == dwTDim)
    {
        Error("Invalid dimension");
        return E_FAIL;
    }


    UINT cch = strlen(szId);
    char *psz = szId;

    if(*psz != 'v')
    {
        Error("Vertex register expected (v#)");
        return E_FAIL;
    }

    for(psz++; *psz && isdigit(*psz); psz++);

    if(*psz)
    {
        Error("Vertex register expected (v#)");
        return E_FAIL;
    }

    DWORD dwReg = atoi(&szId[1]);

    *pdwDecl = D3DVSD_REG(dwReg, dwTDim);
    return S_OK;
}


HRESULT 
CD3DXDeclarationCompiler::LookupFvf(char *szId, DWORD *pdwFvf)
{
    RValue *prv = g_rvFvf;

    while(prv->szName)
    {
        if(!_stricmp(szId, prv->szName))
        {
            *pdwFvf |= prv->dwValue;
            return S_OK;
        }

        prv++;
    }

    Error("Unknown identifier in FVF experssion");
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\effect\cdeclaration.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       CDeclaration.h
//  Content:    Declaration compiler
//
///////////////////////////////////////////////////////////////////////////



//----------------------------------------------------------------------------
// CD3DXDeclarationCompiler
//----------------------------------------------------------------------------

class CD3DXDeclarationCompiler
{
    CNode *m_pDeclaration;
    CNode *m_pErrors;

    BOOL  m_bFail;

    UINT  m_iLine;
    char  m_szFile[256];
    char *m_pchSource;
    char *m_pchLine;
    char *m_pch;
    char *m_pchLim;

    char  m_szTok[256];

public:
    static CD3DXDeclarationCompiler* s_pCompiler;

public:
    CD3DXDeclarationCompiler();
   ~CD3DXDeclarationCompiler();

    HRESULT Compile(LPCVOID pv, UINT cb, LPCSTR szFile, UINT iLine,
        LPD3DXBUFFER *ppCompiledDeclaration, LPD3DXBUFFER *ppCompilationErrors);

    int     Token();
    void    Production(UINT uProduction, UINT uArgs);
    void    Push(CNode *pNode);
    CNode*  Pop();
    UINT    Serialize(CNode *pNode, LPVOID pv);
    void    Error(char *psz, ...);
    void    AppendError(char *psz);


    HRESULT CreateNode(DWORD dwId, UINT cdwData, UINT cNodes, CNode **ppNode);
    HRESULT LookupDecl(DWORD dwType, char *szId, DWORD dwDim, DWORD *pdwDecl);
    HRESULT LookupFvf(char *szId, DWORD *pdwFvf);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\effect\ceffect.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       CD3DXEffect.h
//  Content:    D3DX effect types and functions
//
///////////////////////////////////////////////////////////////////////////

#ifndef __CD3DXEFFECT_H__
#define __CD3DXEFFECT_H__



//////////////////////////////////////////////////////////////////////////////
// CEffectNode ///////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

class CEffectNode
{
public:
    DWORD m_dwId;
    DWORD m_cdwData;
    DWORD m_cdwNodes;
    DWORD m_dwData[1];

public:
    CEffectNode* Children();
    CEffectNode* Sibling(CEffectNode *pChild);
};



///////////////////////////////////////////////////////////////////////////
// CD3DXValue /////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

class CD3DXValue
{
public:
    D3DXPARAMETERTYPE m_Type;

    union
    {
        DWORD                   m_Dword;
        FLOAT                   m_Float;
        D3DXVECTOR4*            m_pVector;
        D3DXMATRIX*             m_pMatrix;
        LPDIRECT3DBASETEXTURE8  m_pTexture;
        DWORD                   m_VertexShader;
        DWORD                   m_PixelShader;
        DWORD*                  m_pConstant;
    };

public:
    CD3DXValue();
   ~CD3DXValue();

    HRESULT Initialize(CD3DXEffect* pEffect, D3DXPARAMETERTYPE Type);
    HRESULT Initialize(CD3DXEffect* pEffect, CEffectNode* pValue);

    HRESULT Cast(CD3DXValue *pValue);
};



///////////////////////////////////////////////////////////////////////////
// CD3DXParameter /////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

class CD3DXParameter
{
public:
    DWORD       m_dwName;
    CD3DXValue  m_Value;

public:
    CD3DXParameter();
   ~CD3DXParameter();

    HRESULT Initialize(CD3DXEffect* pEffect, CEffectNode* pParameter);
};



//////////////////////////////////////////////////////////////////////////////
// CD3DXEffect ///////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

class CD3DXEffect : public ID3DXEffect
{
public:
    CD3DXEffect();
   ~CD3DXEffect();

    HRESULT Initialize(LPDIRECT3DDEVICE8 pDevice, LPCVOID pData, UINT cbData, DWORD Usage);
    CD3DXParameter* FindParameter(D3DXPARAMETERTYPE Type, DWORD dwName);

    ULONG AddRefTechnique();
    ULONG ReleaseTechnique();


    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID* ppv);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    // ID3DXEffect
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice);
    STDMETHOD(GetDesc)(THIS_ D3DXEFFECT_DESC* pDesc);

    STDMETHOD(GetParameterDesc)(THIS_ UINT Index, D3DXPARAMETER_DESC* pDesc);
    STDMETHOD(GetTechniqueDesc)(THIS_ UINT Index, D3DXTECHNIQUE_DESC* pDesc);

    STDMETHOD(SetDword)(THIS_ DWORD Name, DWORD dw);
    STDMETHOD(GetDword)(THIS_ DWORD Name, DWORD* pdw); 
    STDMETHOD(SetFloat)(THIS_ DWORD Name, FLOAT f);
    STDMETHOD(GetFloat)(THIS_ DWORD Name, FLOAT* pf);
    STDMETHOD(SetVector)(THIS_ DWORD Name, D3DXVECTOR4* pVector);
    STDMETHOD(GetVector)(THIS_ DWORD Name, D3DXVECTOR4* pVector);
    STDMETHOD(SetMatrix)(THIS_ DWORD Name, D3DXMATRIX* pMatrix);
    STDMETHOD(GetMatrix)(THIS_ DWORD Name, D3DXMATRIX* pMatrix);
    STDMETHOD(SetTexture)(THIS_ DWORD Name, LPDIRECT3DBASETEXTURE8 pTexture);
    STDMETHOD(GetTexture)(THIS_ DWORD Name, LPDIRECT3DBASETEXTURE8 *ppTexture);
    STDMETHOD(SetVertexShader)(THIS_ DWORD Name, DWORD Handle);
    STDMETHOD(GetVertexShader)(THIS_ DWORD Name, DWORD* pHandle);
    STDMETHOD(SetPixelShader)(THIS_ DWORD Name, DWORD Handle);
    STDMETHOD(GetPixelShader)(THIS_ DWORD Name, DWORD* pHandle);

    STDMETHOD(GetTechnique)(THIS_ UINT Index, LPD3DXTECHNIQUE* ppTechnique);
    STDMETHOD(CloneEffect)(THIS_ LPDIRECT3DDEVICE8 pDevice, DWORD Usage, LPD3DXEFFECT* ppEffect);


public:
    UINT m_uRefCount;
    UINT m_uRefTechnique;

    LPDIRECT3DDEVICE8 m_pDevice;
    DWORD*            m_pData;
    D3DXEFFECT_DESC   m_Desc;
    CD3DXParameter*   m_pParameter;
    CD3DXTechnique*   m_pTechnique;
};

#endif //__CD3DXEFFECT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\effect\CD3DXTechnique.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       CD3DXTechnique.h
//  Content:    D3DX technique types and functions
//
///////////////////////////////////////////////////////////////////////////

#ifndef __CD3DXTECHNIQUE_H__
#define __CD3DXTECHNIQUE_H__


#define D3DRS_FVF 0x80000001 // For fixed-function pipe.. not really a D3DRS



class StateData
{
public:
    DWORD m_dwState;
    DWORD m_dwValue;
    StateData *m_pNext;

public:
    StateData();
   ~StateData();
};


class StageData
{
public:
    UINT m_uTexture;
    UINT m_uMatrix;

    StateData *m_pTSS;
    StageData *m_pNext;

public:
    StageData();
   ~StageData();
};


class VShaderData
{
public:
    DWORD m_pDeclaration[MAX_FVF_DECL_SIZE];
    ID3DXBuffer *m_pShader;

public:
    VShaderData();
   ~VShaderData();
};


class PShaderData
{
public:
    ID3DXBuffer *m_pDeclaration;
    ID3DXBuffer *m_pShader;

public:
    PShaderData();
   ~PShaderData();
};


class PassData
{
public:
    StateData   *m_pRS;
    StageData   *m_pStage;
    VShaderData *m_pVShader;
    PShaderData *m_pPShader;
    PassData    *m_pNext;

    DWORD m_dwState;
    DWORD m_dwVShader;
    DWORD m_dwPShader;

    IDirect3DDevice8 *m_pDevice;

public:
    PassData();
   ~PassData();
};


class TechniqueData
{
public:
    UINT   m_uPasses;
    UINT   m_uLOD;
    UINT   m_uRefCount;

    StateData     *m_pRS;
    PassData      *m_pPass;
    TechniqueData *m_pNext;

public:
    TechniqueData();
   ~TechniqueData();
};


class CD3DXTechnique;
class CD3DXEffect;


//////////////////////////////////////////////////////////////////////////////
// CD3DXTechnique ////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

class CD3DXTechnique : public ID3DXTechnique
{
public:
    CD3DXTechnique();
   ~CD3DXTechnique();

    HRESULT Initialize(CD3DXEffect *pEffect, TechniqueData *pTechniqueData, 
                       DWORD dwClear, DWORD dwTextureUsed, DWORD dwMatrixUsed);

    HRESULT ValidateDX8(UINT uPass);


    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    // ID3DXTechnique
    STDMETHOD_(D3DXTECHNIQUE_DESC, GetTechniqueDesc)(THIS);
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice8 **ppDevice);

    STDMETHOD_(BOOL, IsDwordUsed)    (THIS_ UINT uIndex);
    STDMETHOD_(BOOL, IsFloatUsed)    (THIS_ UINT uIndex);
    STDMETHOD_(BOOL, IsColorUsed)    (THIS_ UINT uIndex);
    STDMETHOD_(BOOL, IsVectorUsed)   (THIS_ UINT uIndex);
    STDMETHOD_(BOOL, IsMatrixUsed)   (THIS_ UINT uIndex);
    STDMETHOD_(BOOL, IsTextureUsed)  (THIS_ UINT uIndex);

    STDMETHOD(Validate)(THIS);

    STDMETHOD(Begin)(THIS_ UINT *puPasses);
    STDMETHOD(Pass)(THIS_ UINT uPass);
    STDMETHOD(End)(THIS);


public:
    UINT m_uRefCount;
    DWORD m_dwClear;

    DWORD m_dwDwordUsed;
    DWORD m_dwFloatUsed;
    DWORD m_dwColorUsed;
    DWORD m_dwVectorUsed;
    DWORD m_dwMatrixUsed;
    DWORD m_dwTextureUsed;

    CD3DXEffect *m_pEffect;
    TechniqueData *m_pTechniqueData;
    IDirect3DDevice8 *m_pDevice;
};

#endif //__CD3DXTECHNIQUE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\effect\d3dx8effect.cpp ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx8effect.cpp
//  Content:    Compile D3DX Effect files
//
///////////////////////////////////////////////////////////////////////////

#include "pcheffect.h"
#include "CD3DXFile.h"


//----------------------------------------------------------------------------
// D3DXCompileEffect
//----------------------------------------------------------------------------

HRESULT WINAPI
    D3DXCompileEffectFromFileA(
        LPCSTR            pSrcFile,
        LPD3DXBUFFER*     ppCompiledEffect,
        LPD3DXBUFFER*     ppCompilationErrors)
{
    HRESULT hr;
    CD3DXFile fm;
    CD3DXEffectCompiler compiler;

    if(ppCompiledEffect)
        *ppCompiledEffect = NULL;

    if(ppCompilationErrors)
        *ppCompilationErrors = NULL;

    if(FAILED(hr = fm.Open(pSrcFile, FALSE)))
        return hr;

    if(FAILED(hr = compiler.Compile(fm.m_pvData, fm.m_cbData, pSrcFile, ppCompiledEffect, ppCompilationErrors)))
        return hr;

    return S_OK;
}


HRESULT WINAPI
    D3DXCompileEffectFromFileW(
        LPCWSTR           pSrcFile,
        LPD3DXBUFFER*     ppCompiledEffect,
        LPD3DXBUFFER*     ppCompilationErrors)
{
    HRESULT hr;
    CD3DXFile fm;
    CD3DXEffectCompiler compiler;

    // Convert file name to ascii
    int cch = WideCharToMultiByte(CP_ACP, 0, pSrcFile, -1, NULL, 0, NULL, NULL);
    char *pch = (char *) _alloca(cch);
    WideCharToMultiByte(CP_ACP, 0, pSrcFile, -1, pch, cch, NULL, NULL);


    if(ppCompiledEffect)
        *ppCompiledEffect = NULL;

    if(ppCompilationErrors)
        *ppCompilationErrors = NULL;

    if(FAILED(hr = fm.Open(pSrcFile, TRUE)))
        return hr;

    if(FAILED(hr = compiler.Compile(fm.m_pvData, fm.m_cbData, pch, ppCompiledEffect, ppCompilationErrors)))
        return hr;

    return S_OK;
}


HRESULT WINAPI
    D3DXCompileEffect(
        LPCVOID           pSrcData,
        UINT              SrcDataSize,
        LPD3DXBUFFER*     ppCompiledEffect,
        LPD3DXBUFFER*     ppCompilationErrors)
{
    HRESULT hr;
    CD3DXEffectCompiler compiler;

    if(ppCompiledEffect)
        *ppCompiledEffect = NULL;

    if(ppCompilationErrors)
        *ppCompilationErrors = NULL;

    if(FAILED(hr = compiler.Compile(pSrcData, SrcDataSize, NULL, ppCompiledEffect, ppCompilationErrors)))
        return hr;

    return S_OK;
}



//----------------------------------------------------------------------------
// D3DXCreateEffect
//----------------------------------------------------------------------------

HRESULT WINAPI
    D3DXCreateEffect(
        LPDIRECT3DDEVICE8 pDevice,
        LPCVOID           pCompiledEffect,
        UINT              CompiledEffectSize,
        DWORD             Usage,
        LPD3DXEFFECT*     ppEffect)
{
    HRESULT hr;
    CD3DXEffect *pEffect;

    if(ppEffect)
        *ppEffect = NULL;

    if(!pDevice)
    {
        DPF(0, "pDevice pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if (!pCompiledEffect)
    {
        DPF(0, "pCompiledEffect pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if (!ppEffect)
    {
        DPF(0, "ppEffect pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if (CompiledEffectSize == 0)
    {
        DPF(0, "CompiledEffectSize should be > 0");
        return D3DERR_INVALIDCALL;
    }

    if(!(pEffect = new CD3DXEffect))
        return E_OUTOFMEMORY;

    if(FAILED(hr = pEffect->Initialize(pDevice, pCompiledEffect, CompiledEffectSize, Usage)))
    {
        if (hr == D3DXERR_INVALIDDATA || hr == E_FAIL)
        {
            DPF(0, "Could not parse compiled effect");
            hr = D3DXERR_INVALIDDATA;
        }
        delete pEffect;
        return hr;
    }

    *ppEffect = (LPD3DXEFFECT) pEffect;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\effect\ceffect.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       effect.h
//  Content:    D3DX effect types and functions
//
//////////////////////////////////////////////////////////////////////////////

#include "pcheffect.h"


//////////////////////////////////////////////////////////////////////////////
// CEffectNode ///////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


CEffectNode*
CEffectNode::Children()
{
    if(!m_cdwNodes)
        return NULL;

    return (CEffectNode *) &m_dwData[m_cdwData];
}


CEffectNode* 
CEffectNode::Sibling(CEffectNode *pChild)
{
    DWORD* pdw = &pChild->m_dwData[pChild->m_cdwData + pChild->m_cdwNodes];

    if((pdw < &m_dwData[0]) || (pdw >= &m_dwData[m_cdwData + m_cdwNodes]))
        return NULL;

    return (CEffectNode *) pdw;
}



//////////////////////////////////////////////////////////////////////////////
// CD3DXValue ////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

CD3DXValue::CD3DXValue()
{
    m_Type = D3DXPT_DWORD;
    m_Dword = 0;
}


CD3DXValue::~CD3DXValue()
{
    switch(m_Type)
    {
    case D3DXPT_VECTOR:
        delete m_pVector;
        break;

    case D3DXPT_MATRIX:
        delete m_pMatrix;
        break;

    case D3DXPT_CONSTANT:
        delete [] m_pConstant;
        break;       
    }
}


HRESULT 
CD3DXValue::Initialize(CD3DXEffect* pEffect, D3DXPARAMETERTYPE Type)
{
    m_Type = Type;

    // Default values
    switch(m_Type)
    {
    case D3DXPT_DWORD:
        m_Dword = 0;
        break;

    case D3DXPT_FLOAT:
        m_Float = 0.0f;
        break;

    case D3DXPT_VECTOR:
        if(!(m_pVector = new D3DXVECTOR4))
            return E_OUTOFMEMORY;

        m_pVector->x = 0.0f;
        m_pVector->y = 0.0f;
        m_pVector->z = 0.0f;
        m_pVector->w = 1.0f;
        break;

    case D3DXPT_MATRIX:
        if(!(m_pMatrix = new D3DXMATRIX))
            return E_OUTOFMEMORY;

        D3DXMatrixIdentity(m_pMatrix);
        break;

    case D3DXPT_TEXTURE:
        m_pTexture = NULL;
        break;

    case D3DXPT_VERTEXSHADER:
        m_VertexShader = 0;
        break;

    case D3DXPT_PIXELSHADER:
        m_PixelShader = 0;
        break;

    case D3DXPT_CONSTANT:
        m_pConstant = NULL;
        break;
    }

    return S_OK;
}


HRESULT 
CD3DXValue::Initialize(CD3DXEffect* pEffect, CEffectNode* pValue)
{
    D3DXASSERT((pEffect != NULL) && (pValue != NULL));

    if(N_VALUE != pValue->m_dwId)
        return D3DXERR_INVALIDDATA;

    m_Type = (D3DXPARAMETERTYPE) pValue->m_dwData[0];

    switch(m_Type)
    {
    case D3DXPT_DWORD:
        m_Dword = pValue->m_dwData[1];
        break;

    case D3DXPT_FLOAT:
        m_Float = *((FLOAT *) &pValue->m_dwData[1]);
        break;

    case D3DXPT_VECTOR:
        if(!(m_pVector = new D3DXVECTOR4))
            return E_OUTOFMEMORY;

        memcpy(m_pVector, &pValue->m_dwData[1], sizeof(D3DXVECTOR4));
        break;

    case D3DXPT_MATRIX:
        if(!(m_pMatrix = new D3DXMATRIX))
            return E_OUTOFMEMORY;

        memcpy(m_pMatrix, &pValue->m_dwData[1], sizeof(D3DXMATRIX));
        break;

    case D3DXPT_TEXTURE:
        DPF(0, "Cannot initialized a texture");
        return D3DXERR_INVALIDDATA;

    case D3DXPT_VERTEXSHADER:
        if(FAILED(pEffect->m_pDevice->CreateVertexShader(
            &pValue->m_dwData[2], (pValue->m_cdwData - pValue->m_dwData[1] - 2) ? 
            &pValue->m_dwData[2 + pValue->m_dwData[1]] : NULL, &m_VertexShader,
            pEffect->m_Desc.Usage)))
        {
            m_VertexShader = 0;
        }
        break;

    case D3DXPT_PIXELSHADER:
        /*** HACK - kylej - cast to D3DPIXELSHADERDEF to fix a build break.  This will have to be 
             fixed eventually if we decide to support effects on Xbox ***/
        
        if(FAILED(pEffect->m_pDevice->CreatePixelShader(
            (D3DPIXELSHADERDEF *)(&pValue->m_dwData[2 + pValue->m_dwData[1]]), &m_PixelShader)))
        {
            m_PixelShader = 0;
        }
        break;

    case D3DXPT_CONSTANT:
        m_pConstant = NULL;
        break;
    }

    return S_OK;
}


HRESULT 
CD3DXValue::Cast(CD3DXValue *pValue)
{
    switch(m_Type)
    {
    case D3DXPT_DWORD:
        switch(pValue->m_Type)
        {
        case D3DXPT_DWORD:
            m_Dword = pValue->m_Dword;
            return S_OK;

        case D3DXPT_VECTOR:
            m_Dword = (DWORD) D3DXCOLOR((FLOAT *) pValue->m_pVector);
            return S_OK;
        }
        break;

    case D3DXPT_FLOAT:
        switch(pValue->m_Type)
        {
        case D3DXPT_FLOAT:
            m_Float = pValue->m_Float;
            return S_OK;
        }
        break;

    case D3DXPT_VECTOR:
        switch(pValue->m_Type)
        {
        case D3DXPT_DWORD:
            *((D3DXCOLOR *) m_pVector) = D3DXCOLOR(pValue->m_Dword);
            return S_OK;

        case D3DXPT_FLOAT:
            m_pVector->x =  m_pVector->y = m_pVector->z = m_pVector->w = pValue->m_Float;
            return S_OK;

        case D3DXPT_VECTOR:
            *m_pVector = *pValue->m_pVector;
            return S_OK;
        }
        break;

    case D3DXPT_MATRIX:
        switch(pValue->m_Type)
        {
        case D3DXPT_MATRIX:
            *m_pMatrix = *pValue->m_pMatrix;
            return S_OK;
        }
        break;

    case D3DXPT_TEXTURE:
        switch(pValue->m_Type)
        {
        case D3DXPT_TEXTURE:
            m_pTexture = pValue->m_pTexture;
            return S_OK;
        }
        break;

    case D3DXPT_VERTEXSHADER:
        switch(pValue->m_Type)
        {
        case D3DXPT_VERTEXSHADER:
            m_VertexShader = pValue->m_VertexShader;
            return S_OK;
        }
        break;

    case D3DXPT_PIXELSHADER:
        switch(pValue->m_Type)
        {
        case D3DXPT_PIXELSHADER:
            m_PixelShader = pValue->m_PixelShader;
            return S_OK;
        }
        break;

    case D3DXPT_CONSTANT:
        if(m_pConstant)
        {
            delete [] m_pConstant;
            m_pConstant = NULL;
        }

        switch(pValue->m_Type)
        {
        case D3DXPT_DWORD:
        case D3DXPT_FLOAT:
        case D3DXPT_VECTOR:
            if(!(m_pConstant = new DWORD[5]))
                return E_OUTOFMEMORY;

            m_pConstant[0] = 1;
            break;

        case D3DXPT_MATRIX:
            if(!(m_pConstant = new DWORD[17]))
                return E_OUTOFMEMORY;

            m_pConstant[0] = 4;
        }

        switch(pValue->m_Type)
        {
        case D3DXPT_DWORD:
            *((D3DXCOLOR *) &m_pConstant[1]) = D3DXCOLOR(pValue->m_Dword);
            return S_OK;

        case D3DXPT_FLOAT:
            m_pConstant[1] = m_pConstant[2] = m_pConstant[3] = m_pConstant[4] = *((DWORD *) &pValue->m_Float);
            return S_OK;

        case D3DXPT_VECTOR:
            *((D3DXVECTOR4 *) &m_pConstant[1]) = *pValue->m_pVector;
            return S_OK;

        case D3DXPT_MATRIX:
            *((D3DXMATRIX *) &m_pConstant[1]) = *pValue->m_pMatrix;
            return S_OK;
        }
        
        break;
    }

    return D3DXERR_INVALIDDATA;
}



//////////////////////////////////////////////////////////////////////////////
// CD3DXParameter ////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


CD3DXParameter::CD3DXParameter()
{
    m_dwName = 0;
}


CD3DXParameter::~CD3DXParameter()
{
    if(D3DXPT_TEXTURE == m_Value.m_Type)
    {
        RELEASE(m_Value.m_pTexture);
    }
}


HRESULT
CD3DXParameter::Initialize(CD3DXEffect *pEffect, CEffectNode* pParameter)
{
    HRESULT hr;

    D3DXASSERT((pEffect != NULL) && (pParameter != NULL));


    // Parse header
    if(N_PARAMETER != pParameter->m_dwId)
        return D3DXERR_INVALIDDATA;

    m_dwName = pParameter->m_dwData[1];

    if(FAILED(hr = m_Value.Initialize(pEffect, (D3DXPARAMETERTYPE) pParameter->m_dwData[0])))
        return hr;


    // Initial value present?
    CEffectNode *pValue = pParameter->Children();

    if(pValue)
    {
        CD3DXValue Value;

        if(FAILED(hr = Value.Initialize(pEffect, pValue)))
            return hr;

        if(FAILED(hr = m_Value.Cast(&Value)))
            return hr;

        return S_OK;
    }

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
// CD3DXEffect ///////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

CD3DXEffect::CD3DXEffect()
{
    m_uRefCount     = 1;
    m_uRefTechnique = 0;

    m_pDevice       = NULL;
    m_pData         = NULL;
    m_pParameter    = NULL;
    m_pTechnique    = NULL;

    memset(&m_Desc, 0x00, sizeof(D3DXEFFECT_DESC));
}


CD3DXEffect::~CD3DXEffect()
{
    delete [] m_pData;
    delete [] m_pParameter;
    delete [] m_pTechnique;

    RELEASE(m_pDevice);
}


HRESULT
CD3DXEffect::Initialize(IDirect3DDevice8 *pDevice, LPCVOID pData, UINT cbData, DWORD Usage)
{
    HRESULT hr;

    // Validate args.
    D3DXASSERT(pDevice != NULL);
    D3DXASSERT(pData != NULL);
    D3DXASSERT(cbData  != 0);

    if(Usage != 0)
    {
        DPF(0, "Usage parameter is invalid");
        return D3DERR_INVALIDCALL;
    }
    m_pDevice = pDevice;
    m_pDevice->AddRef();


    // Create our own buffer and copy effect data into it.
    if(!(m_pData = new DWORD[(cbData + 3) >> 2]))
        return E_OUTOFMEMORY;

    memcpy(m_pData, pData, cbData);

    DWORD *pdw = m_pData;
    UINT cdw = (cbData + 3) >> 2;



    //
    // Parse header
    //

    CEffectNode *pEffect = (CEffectNode *) pdw;

    if(cdw < 3)
    {
        return D3DXERR_INVALIDDATA;
    }

    if(N_EFFECT != pEffect->m_dwId)
    {
        return D3DXERR_INVALIDDATA;
    }

    if(cbData != (3 + pEffect->m_cdwData + pEffect->m_cdwNodes) * sizeof(DWORD))
    {
        return D3DXERR_INVALIDDATA;
    }

    CEffectNode *pParameters = pEffect->Children();
    CEffectNode *pTechniques = pEffect->Sibling(pParameters);

    memset(&m_Desc, 0x00, sizeof(D3DXEFFECT_DESC));
    m_Desc.Usage = Usage;


    //
    // Parameters
    //

    UINT iParameter;
    CEffectNode* pParameter;

    // Count parameters
    pParameter = pParameters->Children();

    while(pParameter)
    {
        m_Desc.Parameters++;
        pParameter = pParameters->Sibling(pParameter);
    }

    if(!(m_pParameter = new CD3DXParameter[m_Desc.Parameters]))
        return E_OUTOFMEMORY;

    // Initialize parameters
    iParameter = 0;
    pParameter = pParameters->Children();

    while(pParameter)
    {
        if(FAILED(hr = m_pParameter[iParameter].Initialize(this, pParameter)))
            return hr;

        iParameter++;
        pParameter = pParameters->Sibling(pParameter);
    }


    //
    // Techniques
    //

    UINT iTechnique;
    CEffectNode* pTechnique;

    // Count techniques
    pTechnique = pTechniques->Children();

    while(pTechnique)
    {
        m_Desc.Techniques++;
        pTechnique = pTechniques->Sibling(pTechnique);
    }

    if(!(m_pTechnique = new CD3DXTechnique[m_Desc.Techniques]))
        return E_OUTOFMEMORY;

    // Initialize techniques
    iTechnique = 0;
    pTechnique = pTechniques->Children();

    while(pTechnique)
    {
        if(FAILED(hr = m_pTechnique[iTechnique].Initialize(this, pTechnique)))
            return hr;

        iTechnique++;
        pTechnique = pTechniques->Sibling(pTechnique);
    }


    return S_OK;
}



CD3DXParameter* 
CD3DXEffect::FindParameter(D3DXPARAMETERTYPE Type, DWORD dwName)
{
#if DBG
    static const char* szType[] =
        { "DWORD", "FLOAT", "VECTOR", "MATRIX", "TEXTURE", "VERTEXSHADER", "PIXELSHADER" };
#endif

    for(UINT iParameter = 0; iParameter < m_Desc.Parameters; iParameter++)
    {
        if(m_pParameter[iParameter].m_dwName == dwName)
        {
            if(m_pParameter[iParameter].m_Value.m_Type == Type)
                return &m_pParameter[iParameter];

            DPF(0, "Type mismatch: '%.4s' is a %s (not a %s)", &dwName, 
                szType[m_pParameter[iParameter].m_Value.m_Type], szType[Type]);

            return NULL;
        }
    }

    DPF(0, "Parameter not found: '%.4s'", &dwName);
    return NULL;
}


ULONG
CD3DXEffect::AddRefTechnique()
{
    return ++m_uRefTechnique;
}


ULONG
CD3DXEffect::ReleaseTechnique()
{
    if(m_uRefTechnique)
        m_uRefTechnique--;

    if(m_uRefTechnique || m_uRefCount)
        return m_uRefTechnique;

    delete this;
    return 0;
}


STDMETHODIMP
CD3DXEffect::QueryInterface(REFIID iid, LPVOID *ppv)
{
#if DBG
    if(!ppv)
    {
        DPF(0, "ppv pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
#endif

    if(IsEqualIID(iid, IID_ID3DXEffect))
        *ppv = (ID3DXEffect *) this;
    else if(IsEqualIID(iid, IID_IUnknown))
        *ppv = (IUnknown *) this;
    else
        return E_NOINTERFACE;

    AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG)
CD3DXEffect::AddRef()
{
    return ++m_uRefCount;
}


STDMETHODIMP_(ULONG)
CD3DXEffect::Release()
{
    if(m_uRefCount)
        m_uRefCount--;

    if(m_uRefCount || m_uRefTechnique)
        return m_uRefCount;

    delete this;
    return 0;
}


STDMETHODIMP
CD3DXEffect::GetDevice(IDirect3DDevice8 **ppDevice)
{
    if(!ppDevice)
    {
        DPF(0, "ppDevice pointer is invalid");
        return D3DERR_INVALIDCALL;
    }

    m_pDevice->AddRef();
    *ppDevice = m_pDevice;

    return S_OK;
}


STDMETHODIMP
CD3DXEffect::GetDesc(D3DXEFFECT_DESC* pDesc)
{
    if(!pDesc)
    {
        DPF(0, "pDesc pointer is invalid");
        return D3DERR_INVALIDCALL;
    }

    *pDesc = m_Desc;
    return S_OK;
}


HRESULT 
CD3DXEffect::GetParameterDesc(UINT Index, D3DXPARAMETER_DESC* pDesc)
{
    if(Index >= m_Desc.Parameters)
    {
        DPF(0, "Invalid parameter index");
        return D3DERR_INVALIDCALL;
    }

    if(!pDesc)
    {
        DPF(0, "pDesc pointer is invalid");
        return D3DERR_INVALIDCALL;
    }

    pDesc->Name = m_pParameter[Index].m_dwName;
    pDesc->Type = m_pParameter[Index].m_Value.m_Type;

    return S_OK;
}


HRESULT 
CD3DXEffect::GetTechniqueDesc(UINT Index, D3DXTECHNIQUE_DESC* pDesc)
{
    if(Index >= m_Desc.Techniques)
    {
        DPF(0, "Invalid technique index");
        return D3DERR_INVALIDCALL;
    }

    if(!pDesc)
    {
        DPF(0, "pDesc pointer is invalid");
        return D3DERR_INVALIDCALL;
    }

    *pDesc = m_pTechnique[Index].m_Desc;
    return S_OK;
}


HRESULT 
CD3DXEffect::SetDword(DWORD Name, DWORD dw)
{
    CD3DXParameter *pParameter;

    if(!(pParameter = FindParameter(D3DXPT_DWORD, Name)))
    {
        return D3DERR_INVALIDCALL;
    }
    pParameter->m_Value.m_Dword = dw;
    return S_OK;
}



HRESULT 
CD3DXEffect::GetDword(DWORD Name, DWORD* pdw)
{
    CD3DXParameter *pParameter;

    if(!pdw)
    {
        DPF(0, "pdw pointer is invalid");
        return D3DERR_INVALIDCALL;
    }

    if(!(pParameter = FindParameter(D3DXPT_DWORD, Name)))
    {
        return D3DERR_INVALIDCALL;
    }

    *pdw = pParameter->m_Value.m_Dword;
    return S_OK;
}


HRESULT 
CD3DXEffect::SetFloat(DWORD Name, FLOAT f)
{
    CD3DXParameter *pParameter;

    if(!(pParameter = FindParameter(D3DXPT_FLOAT, Name)))
    {
        return D3DERR_INVALIDCALL;
    }

    pParameter->m_Value.m_Float = f;
    return S_OK;
}


HRESULT 
CD3DXEffect::GetFloat(DWORD Name, FLOAT* pf)
{
    CD3DXParameter *pParameter;

    if(!pf)
    {
        DPF(0, "pf pointer is invalid");
        return D3DERR_INVALIDCALL;
    }

    if(!(pParameter = FindParameter(D3DXPT_FLOAT, Name)))
    {
        return D3DERR_INVALIDCALL;
    }

    *pf = pParameter->m_Value.m_Float;
    return S_OK;
}


HRESULT 
CD3DXEffect::SetVector(DWORD Name, D3DXVECTOR4* pVec)
{
    CD3DXParameter *pParameter;

    if(!pVec)
    {
        DPF(0, "pVec pointer is invalid");
        return D3DERR_INVALIDCALL;
    }

    if(!(pParameter = FindParameter(D3DXPT_VECTOR, Name)))
    {
        return D3DERR_INVALIDCALL;
    }

    *pParameter->m_Value.m_pVector = *pVec;
    return S_OK;
}


HRESULT 
CD3DXEffect::GetVector(DWORD Name, D3DXVECTOR4* pVec)
{
    CD3DXParameter *pParameter;

    if(!pVec)
    {
        DPF(0, "pVec pointer is invalid");
        return D3DERR_INVALIDCALL;
    }

    if(!(pParameter = FindParameter(D3DXPT_VECTOR, Name)))
    {
        return D3DERR_INVALIDCALL;
    }

    *pVec = *pParameter->m_Value.m_pVector;
    return S_OK;
}


HRESULT 
CD3DXEffect::SetMatrix(DWORD Name, D3DXMATRIX* pMat)
{
    CD3DXParameter *pParameter;

    if(!pMat)
    {
        DPF(0, "pMat pointer is invalid");
        return D3DERR_INVALIDCALL;
    }

    if(!(pParameter = FindParameter(D3DXPT_MATRIX, Name)))
    {
        return D3DERR_INVALIDCALL;
    }

    *pParameter->m_Value.m_pMatrix = *pMat;
    return S_OK;
}


HRESULT 
CD3DXEffect::GetMatrix(DWORD Name, D3DXMATRIX* pMat)
{
    CD3DXParameter *pParameter;

    if(!pMat)
    {
        DPF(0, "pMat pointer is invalid");
        return D3DERR_INVALIDCALL;
    }

    if(!(pParameter = FindParameter(D3DXPT_MATRIX, Name)))
    {
        return D3DERR_INVALIDCALL;
    }

    *pMat = *pParameter->m_Value.m_pMatrix;
    return S_OK;
}


HRESULT 
CD3DXEffect::SetTexture(DWORD Name, LPDIRECT3DBASETEXTURE8 pTexture)
{
    CD3DXParameter *pParameter;

    if(!(pParameter = FindParameter(D3DXPT_TEXTURE, Name)))
    {
        return D3DERR_INVALIDCALL;
    }

    if(pTexture)
        pTexture->AddRef();

    if(pParameter->m_Value.m_pTexture)
        pParameter->m_Value.m_pTexture->Release();

    pParameter->m_Value.m_pTexture = pTexture;
    return S_OK;
}


HRESULT 
CD3DXEffect::GetTexture(DWORD Name, LPDIRECT3DBASETEXTURE8 *ppTex)
{
    CD3DXParameter *pParameter;

    if(!ppTex)
    {
        DPF(0, "ppTex pointer is invalid");
        return D3DERR_INVALIDCALL;
    }

    if(!(pParameter = FindParameter(D3DXPT_TEXTURE, Name)))
    {
        return D3DERR_INVALIDCALL;
    }

    if(pParameter->m_Value.m_pTexture)
        pParameter->m_Value.m_pTexture->AddRef();

    *ppTex = pParameter->m_Value.m_pTexture;
    return S_OK;
}


HRESULT 
CD3DXEffect::SetVertexShader(DWORD Name, DWORD Handle)
{
    CD3DXParameter *pParameter;

    if(!(pParameter = FindParameter(D3DXPT_VERTEXSHADER, Name)))
    {
        return D3DERR_INVALIDCALL;
    }

    pParameter->m_Value.m_VertexShader = Handle;
    return S_OK;
}


HRESULT 
CD3DXEffect::GetVertexShader(DWORD Name, DWORD* pHandle)
{
    CD3DXParameter *pParameter;

    if(!pHandle)
    {
        DPF(0, "pHandle pointer is invalid");
        return D3DERR_INVALIDCALL;
    }

    if(!(pParameter = FindParameter(D3DXPT_VERTEXSHADER, Name)))
    {
        return D3DERR_INVALIDCALL;
    }

    *pHandle = pParameter->m_Value.m_VertexShader;
    return S_OK;
}


HRESULT 
CD3DXEffect::SetPixelShader(DWORD Name, DWORD Handle)
{
    CD3DXParameter *pParameter;

    if(!(pParameter = FindParameter(D3DXPT_PIXELSHADER, Name)))
    {
        return D3DERR_INVALIDCALL;
    }

    pParameter->m_Value.m_PixelShader = Handle;
    return S_OK;
}


HRESULT 
CD3DXEffect::GetPixelShader(DWORD Name, DWORD* pHandle)
{
    CD3DXParameter *pParameter;

    if(!pHandle)
    {
        DPF(0, "pHandle pointer is invalid");
        return D3DERR_INVALIDCALL;
    }

    if(!(pParameter = FindParameter(D3DXPT_PIXELSHADER, Name)))
    {
        return D3DERR_INVALIDCALL;
    }

    *pHandle = pParameter->m_Value.m_PixelShader;
    return S_OK;
}


HRESULT 
CD3DXEffect::GetTechnique(UINT Index, LPD3DXTECHNIQUE* ppTechnique)
{
    if(Index >= m_Desc.Techniques)
    {
        DPF(0, "Invalid technique index");
        return D3DERR_INVALIDCALL;
    }

    if(!ppTechnique)
    {
        DPF(0, "ppTechnique pointer is invalid");
        return D3DERR_INVALIDCALL;
    }

    m_uRefTechnique++;
    *ppTechnique = (LPD3DXTECHNIQUE) &m_pTechnique[Index];
    return S_OK;
}


STDMETHODIMP
CD3DXEffect::CloneEffect(LPDIRECT3DDEVICE8 pDevice, DWORD Usage, LPD3DXEFFECT* ppEffect)
{
    HRESULT hr;

    // Validate args
    if(!pDevice)
    {
        DPF(0, "pDevice pointer is invalid");
        return D3DERR_INVALIDCALL;
    }

    if(!ppEffect)
    {
        DPF(0, "ppEffect pointer is invalid");
        return D3DERR_INVALIDCALL;
    }


    // Compute data size
    CEffectNode *pNode = (CEffectNode *) m_pData;
    UINT cbData = (3 + pNode->m_cdwData + pNode->m_cdwNodes) * sizeof(DWORD);


    // Create new effect, similar to this one
    CD3DXEffect *pEffect;

    if(!(pEffect = new CD3DXEffect))
        return E_OUTOFMEMORY;

    if(FAILED(hr = pEffect->Initialize(pDevice, m_pData, cbData, Usage)))
    {
        if (hr == D3DXERR_INVALIDDATA || hr == E_FAIL)
        {
            DPF(0, "Could not parse compiled effect");
            hr = D3DXERR_INVALIDDATA;
        }
        delete pEffect;
        return hr;
    }


    // Share stateblocks and shaders
    // XXXlorenmcq - UNDONE


    *ppEffect = (LPD3DXEFFECT) pEffect;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\effect\ctechnique.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       CD3DXTechnique.h
//  Content:    D3DX technique types and functions
//
///////////////////////////////////////////////////////////////////////////

#ifndef __CD3DXTECHNIQUE_H__
#define __CD3DXTECHNIQUE_H__


//////////////////////////////////////////////////////////////////////////////
// CD3DXAssignment ///////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

class CD3DXAssignment
{
public:
    CD3DXAssignment();
   ~CD3DXAssignment();

    HRESULT Initialize(CD3DXEffect *pEffect, CEffectNode *pAssignment, 
        CD3DXAssignment *pAsgns);

    BOOL IsParameterUsed(DWORD Name);

    HRESULT Validate(D3DCAPS8 *pCaps);
    HRESULT Apply(LPDIRECT3DDEVICE8 pDevice);

public:
    D3DXPARAMETERTYPE   m_Type;
    DWORD               m_dwState;
    DWORD               m_dwIndex;
    CD3DXValue          m_Value;
    CD3DXParameter*     m_pParameter;
    DWORD               m_dwFlags;

    union
    {
        D3DLIGHT8*      m_pLight;
        D3DMATERIAL8*   m_pMaterial;
    };
};


//////////////////////////////////////////////////////////////////////////////
// CD3DXPass /////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

class CD3DXPass
{
public:
    CD3DXPass();
   ~CD3DXPass();    
    
    HRESULT Initialize(CD3DXEffect *pEffect, CEffectNode *pPass);

    BOOL IsParameterUsed(DWORD Name);

    HRESULT Validate(D3DCAPS8 *pCaps);
    HRESULT Apply(BOOL bUseStateBlocks);

public:
    CD3DXEffect*      m_pEffect;
    LPDIRECT3DDEVICE8 m_pDevice;
    D3DXPASS_DESC     m_Desc;
    DWORD             m_dwState;

    UINT              m_cAssignment;
    CD3DXAssignment*  m_pAssignment;
};


//////////////////////////////////////////////////////////////////////////////
// CD3DXTechnique ////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

class CD3DXTechnique : public ID3DXTechnique
{
public:
    CD3DXTechnique();
   ~CD3DXTechnique();

    HRESULT Initialize(CD3DXEffect *pEffect, CEffectNode *pTechnique);


    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    // ID3DXTechnique
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice);
    STDMETHOD(GetDesc)(THIS_ D3DXTECHNIQUE_DESC* pDesc);
    STDMETHOD(GetPassDesc)(THIS_ UINT Index, D3DXPASS_DESC* pDesc);

    STDMETHOD_(BOOL, IsParameterUsed)(THIS_ DWORD Name);

    STDMETHOD(Validate)(THIS);
    STDMETHOD(Begin)(THIS_ UINT *pPasses);
    STDMETHOD(Pass)(THIS_ UINT Index);
    STDMETHOD(End)(THIS);


public:
    UINT                m_uRefCount;
    CD3DXEffect*        m_pEffect;
    LPDIRECT3DDEVICE8   m_pDevice;
    CEffectNode*        m_pTechnique;
    D3DXTECHNIQUE_DESC  m_Desc;
    CD3DXPass*          m_pPass;
    DWORD               m_dwClear;
};

#endif //__CD3DXTECHNIQUE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\effect\decl_y.h ===
#ifndef lint
static char yysccsid[] = "@(#)yaccpar	1.9 (Berkeley) 02/21/93";
#endif
#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define yyclearin (yychar=(-1))
#define yyerrok (yyerrflag=0)
#define YYRECOVERING (yyerrflag!=0)
#define yyparse d3dxdecl_parse
#define yylex d3dxdecl_lex
#define yyerror d3dxdecl_error
#define yychar d3dxdecl_char
#define yyval d3dxdecl_val
#define yylval d3dxdecl_lval
#define yydebug d3dxdecl_debug
#define yynerrs d3dxdecl_nerrs
#define yyerrflag d3dxdecl_errflag
#define yyss d3dxdecl_ss
#define yyssp d3dxdecl_ssp
#define yyvs d3dxdecl_vs
#define yyvsp d3dxdecl_vsp
#define yylhs d3dxdecl_lhs
#define yylen d3dxdecl_len
#define yydefred d3dxdecl_defred
#define yydgoto d3dxdecl_dgoto
#define yysindex d3dxdecl_sindex
#define yyrindex d3dxdecl_rindex
#define yygindex d3dxdecl_gindex
#define yytable d3dxdecl_table
#define yycheck d3dxdecl_check
#define yyname d3dxdecl_name
#define yyrule d3dxdecl_rule
#define YYPREFIX "d3dxdecl_"

#define isatty _isatty
#define fileno _fileno

#define T_KW_STREAM 257
#define T_KW_SKIP 258
#define T_KW_FVF 259
#define T_KW_UINT8 260
#define T_KW_INT16 261
#define T_KW_FLOAT 262
#define T_KW_D3DCOLOR 263
#define T_NUM 264
#define T_HEX 265
#define T_ID 266
#define T_EOF 267
#define YYERRCODE 256
short d3dxdecl_lhs[] = {                                        -1,
    0,    0,    1,    1,    2,    2,    2,    2,    2,    5,
    5,    5,    5,    4,    4,    3,    3,    6,
};
short d3dxdecl_len[] = {                                         2,
    1,    2,    1,    2,    3,    3,    3,    3,    6,    1,
    1,    1,    1,    1,    3,    1,    1,    1,
};
short d3dxdecl_defred[] = {                                      0,
    0,    0,    0,   10,   11,   12,   13,    1,    0,    0,
    0,    0,   16,   17,    0,    0,   18,    0,    0,    2,
    4,    0,    5,    6,    7,    0,    8,    0,   15,    0,
    0,    9,
};
short d3dxdecl_dgoto[] = {                                       9,
   10,   11,   15,   18,   12,   19,
};
short d3dxdecl_sindex[] = {                                   -255,
 -254, -254, -257,    0,    0,    0,    0,    0,    0, -247,
 -244, -257,    0,    0,  -38,  -37,    0,  -36, -100,    0,
    0,  -59,    0,    0,    0, -257,    0, -254,    0,  -68,
  -33,    0,
};
short d3dxdecl_rindex[] = {                                      0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
 -239,    0,    0,    0,    0,    0,    0,    0,  -30,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,
};
short d3dxdecl_gindex[] = {                                      0,
   19,    0,   -1,    5,    0,   21,
};
#define YYTABLESIZE 33
short d3dxdecl_table[] = {                                      27,
   16,    1,    2,    3,    4,    5,    6,    7,   17,   13,
   14,    8,    1,    2,    3,    4,    5,    6,    7,   20,
   23,   24,   25,   26,   31,   32,   30,    3,   14,   21,
   29,   28,   22,
};
short d3dxdecl_check[] = {                                      59,
    2,  257,  258,  259,  260,  261,  262,  263,  266,  264,
  265,  267,  257,  258,  259,  260,  261,  262,  263,  267,
   59,   59,   59,  124,   93,   59,   28,  267,   59,   11,
   26,   91,   12,
};
#define YYFINAL 9
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 267
#if YYDEBUG
char *d3dxdecl_name[] = {
"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"';'",0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"'['",0,"']'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"'|'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"T_KW_STREAM",
"T_KW_SKIP","T_KW_FVF","T_KW_UINT8","T_KW_INT16","T_KW_FLOAT","T_KW_D3DCOLOR",
"T_NUM","T_HEX","T_ID","T_EOF",
};
char *d3dxdecl_rule[] = {
"$accept : Declaration",
"Declaration : T_EOF",
"Declaration : Statements T_EOF",
"Statements : Statement",
"Statements : Statement Statements",
"Statement : T_KW_STREAM Num ';'",
"Statement : T_KW_SKIP Num ';'",
"Statement : T_KW_FVF Fvf ';'",
"Statement : Type Id ';'",
"Statement : Type Id '[' Num ']' ';'",
"Type : T_KW_UINT8",
"Type : T_KW_INT16",
"Type : T_KW_FLOAT",
"Type : T_KW_D3DCOLOR",
"Fvf : Id",
"Fvf : Id '|' Fvf",
"Num : T_NUM",
"Num : T_HEX",
"Id : T_ID",
};
#endif
#ifndef YYSTYPE
typedef int YYSTYPE;
#endif
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH YYSTACKSIZE
#else
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#else
#define YYSTACKSIZE 500
#define YYMAXDEPTH 500
#endif
#endif
int yydebug;
int yynerrs;
int yyerrflag;
int yychar;
short *yyssp;
YYSTYPE *yyvsp;
YYSTYPE yyval;
YYSTYPE yylval;
short yyss[YYSTACKSIZE];
YYSTYPE yyvs[YYSTACKSIZE];
#define yystacksize YYSTACKSIZE
#define YYABORT goto yyabort
#define YYREJECT goto yyabort
#define YYACCEPT goto yyaccept
#define YYERROR goto yyerrlab
int
yyparse()
{
    register int yym, yyn, yystate;
#if YYDEBUG
    register char *yys;
    extern char *getenv();

    if (yys = getenv("YYDEBUG"))
    {
        yyn = *yys;
        if (yyn >= '0' && yyn <= '9')
            yydebug = yyn - '0';
    }
#endif

    yynerrs = 0;
    yyerrflag = 0;
    yychar = (-1);

    yyssp = yyss;
    yyvsp = yyvs;
    *yyssp = yystate = 0;

yyloop:
    if (yyn = yydefred[yystate]) goto yyreduce;
    if (yychar < 0)
    {
        if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
    }
    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, yystate, yytable[yyn]);
#endif
        if (yyssp >= yyss + yystacksize - 1)
        {
            goto yyoverflow;
        }
        *++yyssp = yystate = yytable[yyn];
        *++yyvsp = yylval;
        yychar = (-1);
        if (yyerrflag > 0)  --yyerrflag;
        goto yyloop;
    }
    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        yyn = yytable[yyn];
        goto yyreduce;
    }
    if (yyerrflag) goto yyinrecovery;
#ifdef lint
    goto yynewerror;
#endif
yynewerror:
    yyerror("syntax error");
#ifdef lint
    goto yyerrlab;
#endif
yyerrlab:
    ++yynerrs;
yyinrecovery:
    if (yyerrflag < 3)
    {
        yyerrflag = 3;
        for (;;)
        {
            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: state %d, error recovery shifting\
 to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
#endif
                if (yyssp >= yyss + yystacksize - 1)
                {
                    goto yyoverflow;
                }
                *++yyssp = yystate = yytable[yyn];
                *++yyvsp = yylval;
                goto yyloop;
            }
            else
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: error recovery discarding state %d\n",
                            YYPREFIX, *yyssp);
#endif
                if (yyssp <= yyss) goto yyabort;
                --yyssp;
                --yyvsp;
            }
        }
    }
    else
    {
        if (yychar == 0) goto yyabort;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
        yychar = (-1);
        goto yyloop;
    }
yyreduce:
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, yystate, yyn, yyrule[yyn]);
#endif
    yym = yylen[yyn];
    yyval = yyvsp[1-yym];
    switch (yyn)
    {
case 1:
{ Prod(P_DECLARATION_0, 0); }
break;
case 2:
{ Prod(P_DECLARATION_1, 1); }
break;
case 3:
{ Prod(P_STATEMENTS_0, 1); }
break;
case 4:
{ Prod(P_STATEMENTS_1, 2); }
break;
case 5:
{ Prod(P_STATEMENT_0, 1); }
break;
case 6:
{ Prod(P_STATEMENT_1, 1); }
break;
case 7:
{ Prod(P_STATEMENT_2, 1); }
break;
case 8:
{ Prod(P_STATEMENT_3, 2); }
break;
case 9:
{ Prod(P_STATEMENT_4, 3); }
break;
case 10:
{ Prod(P_TYPE_UINT8,    0); }
break;
case 11:
{ Prod(P_TYPE_INT16,    0); }
break;
case 12:
{ Prod(P_TYPE_FLOAT,    0); }
break;
case 13:
{ Prod(P_TYPE_D3DCOLOR, 0); }
break;
case 14:
{ Prod(P_FVF_0, 1); }
break;
case 15:
{ Prod(P_FVF_1, 2); }
break;
case 16:
{ Prod(P_NUM_0, 0); }
break;
case 17:
{ Prod(P_NUM_1, 0); }
break;
case 18:
{ Prod(P_ID_0, 0); }
break;
    }
    yyssp -= yym;
    yystate = *yyssp;
    yyvsp -= yym;
    yym = yylhs[yyn];
    if (yystate == 0 && yym == 0)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: after reduction, shifting from state 0 to\
 state %d\n", YYPREFIX, YYFINAL);
#endif
        yystate = YYFINAL;
        *++yyssp = YYFINAL;
        *++yyvsp = yyval;
        if (yychar < 0)
        {
            if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
            if (yydebug)
            {
                yys = 0;
                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
                if (!yys) yys = "illegal-symbol";
                printf("%sdebug: state %d, reading %d (%s)\n",
                        YYPREFIX, YYFINAL, yychar, yys);
            }
#endif
        }
        if (yychar == 0) goto yyaccept;
        goto yyloop;
    }
    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
        yystate = yytable[yyn];
    else
        yystate = yydgoto[yym];
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: after reduction, shifting from state %d \
to state %d\n", YYPREFIX, *yyssp, yystate);
#endif
    if (yyssp >= yyss + yystacksize - 1)
    {
        goto yyoverflow;
    }
    *++yyssp = yystate;
    *++yyvsp = yyval;
    goto yyloop;
yyoverflow:
    yyerror("yacc stack overflow");
yyabort:
    return (1);
yyaccept:
    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\effect\ctechnique.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       effect.h
//  Content:    D3DX effect types and functions
//
//////////////////////////////////////////////////////////////////////////////


#include "pcheffect.h"



//////////////////////////////////////////////////////////////////////////////
// CD3DXAssignment ///////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

#define ASGN_STATEBLOCK     (1 << 0)
#define ASGN_LIGHT_INIT     (1 << 1)
#define ASGN_LIGHT_SET      (1 << 2)
#define ASGN_MATERIAL_INIT  (1 << 3)
#define ASGN_MATERIAL_SET   (1 << 4)


CD3DXAssignment::CD3DXAssignment()
{
    m_Type          = D3DXPT_DWORD;
    m_dwState       = 0;
    m_dwIndex       = 0;
    m_pParameter    = NULL;
    m_dwFlags       = 0;
    m_pLight        = NULL;
    m_pMaterial     = NULL;
}


CD3DXAssignment::~CD3DXAssignment()
{
    if(m_dwFlags & ASGN_LIGHT_INIT)
        delete m_pLight;

    if(m_dwFlags & ASGN_MATERIAL_INIT)
        delete m_pMaterial;
}


HRESULT 
CD3DXAssignment::Initialize(CD3DXEffect *pEffect, CEffectNode *pAssignment, 
                            CD3DXAssignment *pAsgns)
{
    HRESULT hr;

    D3DXASSERT((pEffect != NULL) && (pAssignment != NULL));


    //
    // Parse header
    //

    if(N_ASSIGNMENT != pAssignment->m_dwId)
        return E_FAIL;

    m_Type    = (D3DXPARAMETERTYPE) pAssignment->m_dwData[0];
    m_dwState = pAssignment->m_dwData[1];
    m_dwIndex = pAssignment->m_dwData[2];

    if(FAILED(hr = m_Value.Initialize(pEffect, m_Type)))
        return hr;


    //
    // Parse Value/Reference
    //

    CEffectNode *pNode;

    if(!(pNode = pAssignment->Children()))
        return E_FAIL;


    if(N_VALUE == pNode->m_dwId)
    {
        CD3DXValue Value;

        if(FAILED(hr = Value.Initialize(pEffect, pNode)))
            return hr;

        if(FAILED(hr = m_Value.Cast(&Value)))
            return hr;

        m_dwFlags |= ASGN_STATEBLOCK;
    }
    else if(N_REFERENCE == pNode->m_dwId)
    {
        if(!(m_pParameter = pEffect->FindParameter((D3DXPARAMETERTYPE) pNode->m_dwData[0], pNode->m_dwData[1])))
            return E_FAIL;
    }
    else
    {
        return E_FAIL;
    }


    // Allocate lights
    if((m_dwState >> 24) == 0x03)
    {
        for(CD3DXAssignment *pAsgn = pAsgns; pAsgn < this; pAsgn++)
        {
            if(((pAsgn->m_dwState >> 24) == 0x03) && (pAsgn->m_dwIndex == m_dwIndex))
            {
                m_pLight = pAsgn->m_pLight;
                pAsgn->m_dwFlags &= ~ASGN_LIGHT_SET;
                break;
            }

        }

        if(!m_pLight)
        {
            if(!(m_pLight = new D3DLIGHT8))
                return E_OUTOFMEMORY;

            m_dwFlags |= ASGN_LIGHT_INIT;
        }

        m_dwFlags |= ASGN_LIGHT_SET;
        m_dwFlags &= ~ASGN_STATEBLOCK;
    }


    // Allocate materials
    if((m_dwState >> 24) == 0x04)
    {
        for(CD3DXAssignment *pAsgn = pAsgns; pAsgn < this; pAsgn++)
        {
            if((pAsgn->m_dwState >> 24) == 0x04)
            {
                m_pMaterial = pAsgn->m_pMaterial;
                pAsgn->m_dwFlags &= ~ASGN_MATERIAL_SET;
                break;
            }

        }

        if(!m_pMaterial)
        {
            if(!(m_pMaterial = new D3DMATERIAL8))
                return E_OUTOFMEMORY;

            m_dwFlags |= ASGN_MATERIAL_INIT;
        }

        m_dwFlags |= ASGN_MATERIAL_SET;
        m_dwFlags &= ~ASGN_STATEBLOCK;
    }

    return S_OK;
}


BOOL 
CD3DXAssignment::IsParameterUsed(DWORD Name)
{
    if(!m_pParameter)
        return FALSE;

    return (m_pParameter->m_dwName == Name);
}


HRESULT 
CD3DXAssignment::Validate(D3DCAPS8 *pCaps)
{
    HRESULT hr;

    // If this is a reference, get current value as set on effect
    if(m_pParameter)
    {
        if(FAILED(hr = m_Value.Cast(&m_pParameter->m_Value)))
            return hr;
    }


    // Validate state
    switch(m_dwState >> 24)
    {
    case 0x01: // RenderState
        switch(m_dwState & 0x00ffffff)
        {
        case D3DRS_SRCBLEND:
            if(!m_Value.m_Dword || !(pCaps->SrcBlendCaps & (1 << (m_Value.m_Dword - 1))))
                return E_FAIL;

            break;

        case D3DRS_DESTBLEND:
            if(!m_Value.m_Dword || !(pCaps->DestBlendCaps & (1 << (m_Value.m_Dword - 1))))
                return E_FAIL;

            break;

        case D3DRS_BLENDOP:
            if(D3DBLENDOP_ADD == m_Value.m_Dword)
                break;

            if(!m_Value.m_Dword || !(pCaps->PrimitiveMiscCaps & D3DPMISCCAPS_BLENDOP))
                return E_FAIL;

            break;

        case D3DRS_ZFUNC:
            if(!m_Value.m_Dword || !(pCaps->ZCmpCaps & (1 << (m_Value.m_Dword - 1))))
                return E_FAIL;

            break;

        case D3DRS_ALPHAFUNC:
            if(!m_Value.m_Dword || !(pCaps->AlphaCmpCaps & (1 << (m_Value.m_Dword - 1))))
                return E_FAIL;

            break;

        case D3DRS_STENCILFAIL:
        case D3DRS_STENCILZFAIL:
        case D3DRS_STENCILPASS:
            if(!m_Value.m_Dword || !(pCaps->StencilCaps & (1 << (m_Value.m_Dword - 1))))
                return E_FAIL;

            break;            
        }

        break;

    case 0x02: // TextureStageState
        if(m_dwIndex >= 8)
            return E_FAIL;

        switch(m_dwState & 0x00ffffff)
        {
        case D3DTSS_COLOROP:
        case D3DTSS_ALPHAOP:
            if((m_Value.m_Dword != D3DTOP_DISABLE) && (m_dwIndex >= pCaps->MaxTextureBlendStages))
                return E_FAIL;

            if(!m_Value.m_Dword || !(pCaps->TextureOpCaps & (1 << (m_Value.m_Dword - 1))))
                return E_FAIL;

            break;

        case D3DTSS_COLORARG0:
        case D3DTSS_COLORARG1:
        case D3DTSS_COLORARG2:
        case D3DTSS_ALPHAARG0:
        case D3DTSS_ALPHAARG1:
        case D3DTSS_ALPHAARG2:
            break;

        case D3DTSS_RESULTARG:
            if(D3DTA_CURRENT == m_Value.m_Dword)
                break;

            if((D3DTA_TEMP == m_Value.m_Dword) && (pCaps->PrimitiveMiscCaps & D3DPMISCCAPS_TSSARGTEMP))
                break;

            return E_FAIL;

        case D3DTSS_TEXCOORDINDEX:
            if((m_Value.m_Dword != D3DTSS_TCI_PASSTHRU) && !(pCaps->VertexProcessingCaps & D3DVTXPCAPS_TEXGEN))
                return E_FAIL;

            break;

        case D3DTSS_ADDRESSU:
        case D3DTSS_ADDRESSV:            
            if(!m_Value.m_Dword || !(pCaps->TextureAddressCaps & (1 << (m_Value.m_Dword - 1))))
                return E_FAIL;

            break;

        case D3DTSS_ADDRESSW:
            if(!m_Value.m_Dword || !(pCaps->VolumeTextureAddressCaps & (1 << (m_Value.m_Dword - 1))))
                return E_FAIL;

            break;

        case D3DTSS_MAGFILTER:
            if(!m_Value.m_Dword || !(pCaps->TextureFilterCaps & (0x01000000 << (m_Value.m_Dword - 1))))
                return E_FAIL;

            break;

        case D3DTSS_MINFILTER:
            if(!m_Value.m_Dword || !(pCaps->TextureFilterCaps & (0x00000100 << (m_Value.m_Dword - 1))))
                return E_FAIL;

            break;

        case D3DTSS_MIPFILTER:
            if( m_Value.m_Dword && !(pCaps->TextureFilterCaps & (0x00010000 << (m_Value.m_Dword - 1))))
                return E_FAIL;

            break;


        case D3DTSS_TEXTURETRANSFORMFLAGS:
            if((m_Value.m_Dword & D3DTTFF_PROJECTED) && !(pCaps->TextureCaps & D3DPTEXTURECAPS_PROJECTED))
                return E_FAIL;

            switch((m_Value.m_Dword & 0xff) - ((m_Value.m_Dword & D3DTTFF_PROJECTED) ? 1 : 0))
            {
            case 0:
                return E_FAIL;

            case 1:
            case 2:
                break;

            case 3:
                if(!(pCaps->TextureCaps & D3DPTEXTURECAPS_CUBEMAP) && !(pCaps->TextureCaps & D3DPTEXTURECAPS_VOLUMEMAP))
                    return E_FAIL;

                break;

            default:
                return E_FAIL;
            }

            break;
        }
        break;


    case 0x03: // Light
        break;

    case 0x04: // Material
        break;

    case 0x05: // Texture
        if(m_dwIndex >= 8)
            return E_FAIL;
        break;

    case 0x06: // Shader
        switch(m_dwState)
        {
        case D3DXES_VERTEXSHADER:
            if(!m_Value.m_VertexShader)
                return E_FAIL;

            break;

        case D3DXES_PIXELSHADER:
            if(!m_Value.m_PixelShader)
                return E_FAIL;

            break;

        case D3DXES_VERTEXSHADERCONSTANT:
            if((m_dwIndex >= pCaps->MaxVertexShaderConst))
                return E_FAIL;

            if(!m_Value.m_pConstant)
                return E_FAIL;

            if((m_dwIndex + m_Value.m_pConstant[0] > pCaps->MaxVertexShaderConst))
                return E_FAIL;

            break;

        case D3DXES_PIXELSHADERCONSTANT:
            if((m_dwIndex >= D3DPS_CONSTREG_MAX_DX8))
                return E_FAIL;

            if(!m_Value.m_pConstant)
                return E_FAIL;

            if((m_dwIndex + m_Value.m_pConstant[0] > D3DPS_CONSTREG_MAX_DX8))
                return E_FAIL;

            break;
        }
        break;

    case 0x07: // Transform
        switch(m_dwState)
        {
        case D3DXES_PROJECTIONTRANSFORM:
        case D3DXES_VIEWTRANSFORM:
            break;

        case D3DXES_WORLDTRANSFORM:
            if(m_dwIndex >= pCaps->MaxVertexBlendMatrixIndex)
                return E_FAIL;

            break;

        case D3DXES_TEXTURETRANSFORM:
            if(m_dwIndex >= 8)
                return E_FAIL;
        }
        break;
    }

    return S_OK;
}


HRESULT 
CD3DXAssignment::Apply(LPDIRECT3DDEVICE8 pDevice)
{
    HRESULT hr;

    // If this is a reference, get current value as set on effect
    if(m_pParameter)
    {
        if(FAILED(hr = m_Value.Cast(&m_pParameter->m_Value)))
            return hr;
    }


    // Apply state
    switch(m_dwState >> 24)
    {
    case 0x01: // RenderState
        pDevice->SetRenderState((D3DRENDERSTATETYPE) (m_dwState & 0x00ffffff), m_Value.m_Dword);
        break;

    case 0x02: // TextureStageState
        pDevice->SetTextureStageState(m_dwIndex, (D3DTEXTURESTAGESTATETYPE) (m_dwState & 0x00ffffff), m_Value.m_Dword);
        break;

    case 0x03: // Light
        if(m_dwFlags & ASGN_LIGHT_INIT)
        {
            // Set default value to the light
            memset(m_pLight, 0x00, sizeof(D3DLIGHT8));

            m_pLight->Type = D3DLIGHT_DIRECTIONAL;
            m_pLight->Direction.x = 0.0f;
            m_pLight->Direction.y = 0.0f;
            m_pLight->Direction.z = 1.0f;
            m_pLight->Diffuse.r = 1.0f;
            m_pLight->Diffuse.g = 1.0f;
            m_pLight->Diffuse.b = 1.0f;
        }

        switch(m_dwState)
        {
        case D3DXES_LIGHTTYPE:
            m_pLight->Type = (D3DLIGHTTYPE) m_Value.m_Dword;
            break;

        case D3DXES_LIGHTDIFFUSE:
            m_pLight->Diffuse.r = m_Value.m_pVector->x;
            m_pLight->Diffuse.g = m_Value.m_pVector->y;
            m_pLight->Diffuse.b = m_Value.m_pVector->z;
            m_pLight->Diffuse.a = m_Value.m_pVector->w;
            break;

        case D3DXES_LIGHTSPECULAR:
            m_pLight->Specular.r = m_Value.m_pVector->x;
            m_pLight->Specular.g = m_Value.m_pVector->y;
            m_pLight->Specular.b = m_Value.m_pVector->z;
            m_pLight->Specular.a = m_Value.m_pVector->w;
            break;

        case D3DXES_LIGHTAMBIENT:
            m_pLight->Ambient.r = m_Value.m_pVector->x;
            m_pLight->Ambient.g = m_Value.m_pVector->y;
            m_pLight->Ambient.b = m_Value.m_pVector->z;
            m_pLight->Ambient.a = m_Value.m_pVector->w;
            break;

        case D3DXES_LIGHTPOSITION:
            m_pLight->Position.x = m_Value.m_pVector->x;
            m_pLight->Position.y = m_Value.m_pVector->y;
            m_pLight->Position.z = m_Value.m_pVector->z;
            break;

        case D3DXES_LIGHTDIRECTION:
            m_pLight->Direction.x = m_Value.m_pVector->x;
            m_pLight->Direction.y = m_Value.m_pVector->y;
            m_pLight->Direction.z = m_Value.m_pVector->z;
            break;

        case D3DXES_LIGHTRANGE:
            m_pLight->Range = m_Value.m_Float;
            break;

        case D3DXES_LIGHTFALLOFF:
            m_pLight->Falloff = m_Value.m_Float;
            break;

        case D3DXES_LIGHTATTENUATION0:
            m_pLight->Attenuation0 = m_Value.m_Float;
            break;

        case D3DXES_LIGHTATTENUATION1:
            m_pLight->Attenuation1 = m_Value.m_Float;
            break;

        case D3DXES_LIGHTATTENUATION2:
            m_pLight->Attenuation2 = m_Value.m_Float;
            break;

        case D3DXES_LIGHTTHETA:
            m_pLight->Theta = m_Value.m_Float;
            break;

        case D3DXES_LIGHTPHI:
            m_pLight->Phi = m_Value.m_Float;
            break;

        case D3DXES_LIGHTENABLE:
            pDevice->LightEnable(m_dwIndex, m_Value.m_Dword);
            break;
        }

        if(m_dwFlags & ASGN_LIGHT_SET)
            pDevice->SetLight(m_dwIndex, m_pLight);

        break;

    case 0x04: // Material
        if(m_dwFlags & ASGN_MATERIAL_INIT)
            memset(m_pMaterial, 0x00, sizeof(D3DMATERIAL8));

        switch(m_dwState)
        {
        case D3DXES_MATERIALDIFFUSE:
            m_pMaterial->Diffuse.r = m_Value.m_pVector->x;
            m_pMaterial->Diffuse.g = m_Value.m_pVector->y;
            m_pMaterial->Diffuse.b = m_Value.m_pVector->z;
            m_pMaterial->Diffuse.a = m_Value.m_pVector->w;
            break;

        case D3DXES_MATERIALAMBIENT:
            m_pMaterial->Ambient.r = m_Value.m_pVector->x;
            m_pMaterial->Ambient.g = m_Value.m_pVector->y;
            m_pMaterial->Ambient.b = m_Value.m_pVector->z;
            m_pMaterial->Ambient.a = m_Value.m_pVector->w;
            break;

        case D3DXES_MATERIALSPECULAR:
            m_pMaterial->Specular.r = m_Value.m_pVector->x;
            m_pMaterial->Specular.g = m_Value.m_pVector->y;
            m_pMaterial->Specular.b = m_Value.m_pVector->z;
            m_pMaterial->Specular.a = m_Value.m_pVector->w;
            break;

        case D3DXES_MATERIALEMISSIVE:
            m_pMaterial->Emissive.r = m_Value.m_pVector->x;
            m_pMaterial->Emissive.g = m_Value.m_pVector->y;
            m_pMaterial->Emissive.b = m_Value.m_pVector->z;
            m_pMaterial->Emissive.a = m_Value.m_pVector->w;
            break;

        case D3DXES_MATERIALPOWER:
            m_pMaterial->Power = m_Value.m_Float;
            break;
        }

        if(m_dwFlags & ASGN_MATERIAL_SET)
            pDevice->SetMaterial(m_pMaterial);

        break;

    case 0x05: // Texture
        pDevice->SetTexture(m_dwIndex, m_Value.m_pTexture);
        break;

    case 0x06: // Shader
        switch(m_dwState)
        {
        case D3DXES_VERTEXSHADER:
            if(m_Value.m_VertexShader)
                pDevice->SetVertexShader(m_Value.m_VertexShader);
            break;

        case D3DXES_PIXELSHADER:
            if(m_Value.m_PixelShader)
                pDevice->SetPixelShader(m_Value.m_PixelShader);
            break;

        case D3DXES_VERTEXSHADERCONSTANT:
            if(m_Value.m_pConstant)
                pDevice->SetVertexShaderConstant(m_dwIndex, &m_Value.m_pConstant[1], m_Value.m_pConstant[0]);
            break;

        case D3DXES_PIXELSHADERCONSTANT:
            if(m_Value.m_pConstant)
                pDevice->SetPixelShaderConstant(m_dwIndex, &m_Value.m_pConstant[1], m_Value.m_pConstant[0]);
            break;
        }
        break;

    case 0x07: // Transform
        switch(m_dwState)
        {
        case D3DXES_PROJECTIONTRANSFORM:
            pDevice->SetTransform(D3DTS_PROJECTION, m_Value.m_pMatrix);
            break;

        case D3DXES_VIEWTRANSFORM:
            pDevice->SetTransform(D3DTS_VIEW, m_Value.m_pMatrix);
            break;

        case D3DXES_WORLDTRANSFORM:
            pDevice->SetTransform(D3DTS_WORLDMATRIX(m_dwIndex), m_Value.m_pMatrix);
            break;

        case D3DXES_TEXTURETRANSFORM:
            pDevice->SetTransform((D3DTRANSFORMSTATETYPE) (D3DTS_TEXTURE0 + m_dwIndex), m_Value.m_pMatrix);
            break;
        }
        break;
    }

    return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
// CD3DXPass /////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

CD3DXPass::CD3DXPass()
{
    m_pEffect = NULL;
    m_pDevice = NULL;
    m_dwState = NULL;

    m_cAssignment = 0;
    m_pAssignment = 0;

    memset(&m_Desc, 0x00, sizeof(D3DXPASS_DESC));
}


CD3DXPass::~CD3DXPass()
{
    if(m_pDevice && m_dwState)
        m_pDevice->DeleteStateBlock(m_dwState);

    delete [] m_pAssignment;
}


HRESULT 
CD3DXPass::Initialize(CD3DXEffect *pEffect, CEffectNode *pPass)
{
    HRESULT hr;

    D3DXASSERT((pEffect != NULL) && (pPass != NULL));

    m_pEffect = pEffect;
    m_pDevice = pEffect->m_pDevice;


    //
    // Parse header
    //

    if(N_PASS != pPass->m_dwId)
        return E_FAIL;

    m_Desc.Name = pPass->m_dwData[0];


    //
    // Parse assignments
    //

    UINT iAssignment;
    CEffectNode *pAssignment;

    pAssignment = pPass->Children();

    while(pAssignment)
    {
        m_cAssignment++;
        pAssignment = pPass->Sibling(pAssignment);
    }

    if(!(m_pAssignment = new CD3DXAssignment[m_cAssignment]))
        return E_OUTOFMEMORY;

    iAssignment = 0;
    pAssignment = pPass->Children();

    while(pAssignment)
    {
        if(FAILED(hr = m_pAssignment[iAssignment].Initialize(pEffect, pAssignment, m_pAssignment)))
            return hr;

        iAssignment++;
        pAssignment = pPass->Sibling(pAssignment);
    }

    return S_OK;
}


BOOL
CD3DXPass::IsParameterUsed(DWORD Name)
{
    for(UINT iAssignment = 0; iAssignment < m_cAssignment; iAssignment++)
    {
        if(m_pAssignment[iAssignment].IsParameterUsed(Name))
            return TRUE;
    }

    return FALSE;
}


HRESULT 
CD3DXPass::Validate(D3DCAPS8 *pCaps)
{
    HRESULT hr;

    for(UINT iAssignment = 0; iAssignment < m_cAssignment; iAssignment++)
    {
        if(FAILED(hr = m_pAssignment[iAssignment].Validate(pCaps)))
            return hr;
    }

    return S_OK;
}


HRESULT 
CD3DXPass::Apply(BOOL bUseStateBlocks)
{
    HRESULT hr;

    if(bUseStateBlocks)
    {
        if(!m_dwState)
        {
            m_pDevice->BeginStateBlock();

            for(UINT iAssignment = 0; iAssignment < m_cAssignment; iAssignment++)
            {
                if(m_pAssignment[iAssignment].m_dwFlags & ASGN_STATEBLOCK)
                    m_pAssignment[iAssignment].Apply(m_pDevice);
            }

            m_pDevice->EndStateBlock(&m_dwState);
        }

        m_pDevice->ApplyStateBlock(m_dwState);
    }

    for(UINT iAssignment = 0; iAssignment < m_cAssignment; iAssignment++)
    {
        if(!bUseStateBlocks || !(m_pAssignment[iAssignment].m_dwFlags & ASGN_STATEBLOCK))
            m_pAssignment[iAssignment].Apply(m_pDevice);
    }

    return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
// CD3DXTechnique ////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

CD3DXTechnique::CD3DXTechnique()
{
    m_uRefCount  = 1;
    m_pDevice    = NULL;
    m_pTechnique = NULL;
    m_pPass      = NULL;
    m_dwClear    = 0;

    memset(&m_Desc, 0x00, sizeof(D3DXTECHNIQUE_DESC));
}


CD3DXTechnique::~CD3DXTechnique()
{
    delete [] m_pPass;

    if(m_pDevice && m_dwClear)
        m_pDevice->DeleteStateBlock(m_dwClear);
}


HRESULT
CD3DXTechnique::Initialize(CD3DXEffect *pEffect, CEffectNode *pTechnique)
{
    HRESULT hr;

    D3DXASSERT((pEffect !=NULL) && (pTechnique != NULL));

    m_pEffect = pEffect;
    m_pDevice = pEffect->m_pDevice;


    //
    // Parse header
    //

    if(N_TECHNIQUE != pTechnique->m_dwId)
        return E_FAIL;

    m_Desc.Name = pTechnique->m_dwData[0];


    //
    // Parse passes
    //

    UINT iPass;
    CEffectNode *pPass;

    pPass = pTechnique->Children();

    while(pPass)
    {
        m_Desc.Passes++;
        pPass = pTechnique->Sibling(pPass);
    }

    if(!(m_pPass = new CD3DXPass[m_Desc.Passes]))
        return E_OUTOFMEMORY;

    iPass = 0;
    pPass = pTechnique->Children();

    while(pPass)
    {
        if(FAILED(hr = m_pPass[iPass].Initialize(pEffect, pPass)))
            return hr;

        iPass++;
        pPass = pTechnique->Sibling(pPass);
    }

    return S_OK;
}





STDMETHODIMP
CD3DXTechnique::QueryInterface(REFIID iid, LPVOID *ppv)
{
#if DBG
    if(!ppv)
    {
        DPF(0, "ppv pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
#endif

    if(IsEqualIID(iid, IID_ID3DXTechnique))
        *ppv = (ID3DXTechnique *) this;
    else if(IsEqualIID(iid, IID_IUnknown))
        *ppv = (IUnknown *) this;
    else
        return E_NOINTERFACE;

    AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG)
CD3DXTechnique::AddRef()
{
    if(m_pEffect)
        m_pEffect->AddRefTechnique();

    return ++m_uRefCount;
}


STDMETHODIMP_(ULONG)
CD3DXTechnique::Release()
{
    UINT uRefCount = --m_uRefCount;

    if(m_pEffect)
        m_pEffect->ReleaseTechnique();

    return uRefCount;
}


STDMETHODIMP
CD3DXTechnique::GetDesc(D3DXTECHNIQUE_DESC* pDesc)
{
    if(!pDesc)
    {
        DPF(0, "pDesc pointer is invalid");
        return D3DERR_INVALIDCALL;
    }

    *pDesc = m_Desc;
    return S_OK;
}


STDMETHODIMP
CD3DXTechnique::GetPassDesc(UINT Index, D3DXPASS_DESC* pDesc)
{
    if(!pDesc)
    {
        DPF(0, "pDesc pointer is invalid");
        return D3DERR_INVALIDCALL;
    }

    if(Index >= m_Desc.Passes)
    {
        DPF(0, "Invalid pass index");
        return D3DERR_INVALIDCALL;
    }

    *pDesc = m_pPass[Index].m_Desc;
    return S_OK;
}



STDMETHODIMP
CD3DXTechnique::GetDevice(IDirect3DDevice8 **ppDevice)
{
    if(!ppDevice)
    {
        DPF(0, "pDevice pointer is invalid");
        return D3DERR_INVALIDCALL;
    }

    m_pDevice->AddRef();
    *ppDevice = m_pDevice;

    return S_OK;
}


STDMETHODIMP_(BOOL)
CD3DXTechnique::IsParameterUsed(DWORD Name)
{
    for(UINT iPass = 0; iPass < m_Desc.Passes; iPass++)
    {
        if(m_pPass[iPass].IsParameterUsed(Name))
            return TRUE;
    }

    return FALSE;
}


STDMETHODIMP
CD3DXTechnique::Validate()
{
    HRESULT hr;
    UINT iPass;
    DWORD dw;
    D3DCAPS8 caps;


    // Do some preliminary validation against device caps, since drivers
    // don't generally tend to do a very good job of ValidateDevice.
    m_pDevice->GetDeviceCaps(&caps);

#if 0
    if(m_pEffect->m_Desc.Usage & D3DUSAGE_SOFTWAREPROCESSING)
    {
        caps.VertexProcessingCaps = D3DVTXPCAPS_TEXGEN | D3DVTXPCAPS_MATERIALSOURCE7 |
            D3DVTXPCAPS_DIRECTIONALLIGHTS | D3DVTXPCAPS_POSITIONALLIGHTS | D3DVTXPCAPS_LOCALVIEWER;

        caps.MaxActiveLights           = 0xffffffff;
        caps.MaxUserClipPlanes         = 6;
        caps.MaxVertexBlendMatrices    = 4;
        caps.MaxVertexBlendMatrixIndex = 255;

        if(0.0f == caps.MaxPointSize)
            caps.MaxPointSize = 64.0f;

        caps.MaxPrimitiveCount         = 0xffffffff;
        caps.MaxVertexIndex            = 0xffffffff;
        caps.MaxStreams                = 16;
        caps.MaxStreamStride           = 0xffffffff;
        caps.VertexShaderVersion       = D3DVS_VERSION(1, 0);
        caps.MaxVertexShaderConst      = D3DVS_CONSTREG_MAX_V1_0;
    }
#endif 0

    for(iPass = 0; iPass < m_Desc.Passes; iPass++)
    {
        if(FAILED(hr = m_pPass[iPass].Validate(&caps)))
            return hr;
    }


    // Actually setup the device state for each pass and call ValidateDevice.
    if(FAILED(hr = Begin(NULL)))
        return hr;

    for(iPass = 0; iPass < m_Desc.Passes; iPass++)
    {
        if(FAILED(hr = Pass(iPass)) /* ||
           FAILED(hr = m_pDevice->ValidateDevice(&dw)) */ )
        {
            End();
            return hr;
        }
    }

    if(FAILED(hr = End()))
        return hr;

    return S_OK;
}


STDMETHODIMP
CD3DXTechnique::Begin(UINT *pPasses)
{
    HRESULT hr;

    if(!m_dwClear)
    {
        m_pDevice->BeginStateBlock();

        for(UINT iPass = 0; iPass < m_Desc.Passes; iPass++)
            m_pPass[iPass].Apply(FALSE);

        m_pDevice->EndStateBlock(&m_dwClear);
    }

    m_pDevice->CaptureStateBlock(m_dwClear);

    if(pPasses)
        *pPasses = m_Desc.Passes;

    return S_OK;
}


STDMETHODIMP
CD3DXTechnique::Pass(UINT Index)
{
    HRESULT hr;

    if(Index >= m_Desc.Passes)
    {
        DPF(0, "Invalid pass index");
        return D3DERR_INVALIDCALL;
    }

    if(FAILED(hr = m_pPass[Index].Apply(TRUE)))
        return hr;

    return S_OK;
}


STDMETHODIMP
CD3DXTechnique::End()
{
    if(m_dwClear)
        m_pDevice->ApplyStateBlock(m_dwClear);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\effect\effect_y.h ===
#ifndef lint
static char yysccsid[] = "@(#)yaccpar	1.9 (Berkeley) 02/21/93";
#endif
#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define yyclearin (yychar=(-1))
#define yyerrok (yyerrflag=0)
#define YYRECOVERING (yyerrflag!=0)
#define yyparse d3dxeffect_parse
#define yylex d3dxeffect_lex
#define yyerror d3dxeffect_error
#define yychar d3dxeffect_char
#define yyval d3dxeffect_val
#define yylval d3dxeffect_lval
#define yydebug d3dxeffect_debug
#define yynerrs d3dxeffect_nerrs
#define yyerrflag d3dxeffect_errflag
#define yyss d3dxeffect_ss
#define yyssp d3dxeffect_ssp
#define yyvs d3dxeffect_vs
#define yyvsp d3dxeffect_vsp
#define yylhs d3dxeffect_lhs
#define yylen d3dxeffect_len
#define yydefred d3dxeffect_defred
#define yydgoto d3dxeffect_dgoto
#define yysindex d3dxeffect_sindex
#define yyrindex d3dxeffect_rindex
#define yygindex d3dxeffect_gindex
#define yytable d3dxeffect_table
#define yycheck d3dxeffect_check
#define yyname d3dxeffect_name
#define yyrule d3dxeffect_rule
#define YYPREFIX "d3dxeffect_"
typedef union {
	char *tokval;
} YYSTYPE;
#define T_EOF 257
#define T_INT 258
#define T_HEX 259
#define T_FLOAT 260
#define T_ID 261
#define T_DECL 262
#define T_ASM 263
#define T_KW_TECHNIQUE 264
#define T_KW_PASS 265
#define YYERRCODE 256
short d3dxeffect_lhs[] = {                                        -1,
    0,    0,    2,    2,    3,    3,    1,    1,    7,    7,
    8,    8,    8,    8,    9,    9,   11,   11,   12,   12,
   10,   10,   13,   13,   14,   14,   15,   15,   16,    6,
    6,    6,    6,    6,    6,   18,   18,   17,   17,   17,
   17,   19,   19,   20,   20,   20,   20,   21,   22,   22,
   23,    5,    4,   24,   25,
};
short d3dxeffect_len[] = {                                         2,
    2,    3,    1,    2,    3,    5,    1,    2,    3,    4,
    1,    2,    2,    3,    1,    2,    3,    4,    1,    2,
    1,    2,    4,    4,    1,    4,    1,    3,    3,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    2,    1,
    2,    1,    2,    3,    5,    7,    9,   33,    1,    2,
    1,    1,    1,    1,    1,
};
short d3dxeffect_defred[] = {                                      0,
   53,    0,    0,    0,    0,    0,    0,    0,    0,   52,
    0,    1,    0,    4,    0,    8,    0,   11,    0,    9,
    0,    0,    0,    0,    0,    0,    2,    5,    0,    0,
    0,    0,   12,   13,    0,   16,   22,    0,   10,   38,
   40,   42,   54,   55,    0,    0,    0,    0,   30,   31,
   32,   33,   34,   35,    0,   51,   19,    0,   17,    0,
    0,    0,   14,    0,   37,   36,    0,    0,    0,    0,
    0,   39,   41,   43,    0,    6,   50,   20,   18,   26,
    0,   23,   24,    0,    0,   44,    0,   29,   28,    0,
    0,    0,   45,    0,    0,    0,    0,   46,    0,    0,
    0,    0,   47,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   48,
};
short d3dxeffect_dgoto[] = {                                       3,
    4,    5,    6,   19,   11,   66,    8,   20,   21,   22,
   23,   59,   24,   25,   67,   68,   49,   69,   50,   51,
   52,   53,   54,   55,   56,
};
short d3dxeffect_sindex[] = {                                   -234,
    0, -116,    0, -243, -246, -235, -235, -246, -123,    0,
  -85,    0, -209,    0,  -12,    0, -115,    0,  -41,    0,
  -71, -122, -210, -235,   -5, -123,    0,    0,  -28, -112,
  -65,  -22,    0,    0,  -63,    0,    0,  -40,    0,    0,
    0,    0,    0,    0,  -44, -217,  -44,    5,    0,    0,
    0,    0,    0,    0, -198,    0,    0,  -58,    0, -112,
 -214,  -24,    0, -235,    0,    0,   11,   16,  -47, -182,
   36,    0,    0,    0,  -10,    0,    0,    0,    0,    0,
   20,    0,    0,  -34,  -44,    0,  -44,    0,    0,   40,
   -9,  -44,    0,  -44,   44,   -8,  -44,    0,  -44,   46,
   51,  -44,    0,   50,  -44,   52,  -44,   54,  -44,   56,
  -44,   57,  -44,   58,  -44,   59,  -44,   60,  -44,   61,
  -44,   63,  -44,   64,  -44,   17,    0,
};
short d3dxeffect_rindex[] = {                                      0,
    0,    0,    0,    0,    0, -155,    0, -146,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   53,    0,
    0,    0,  -13, -121,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  -50,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   62,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,
};
short d3dxeffect_gindex[] = {                                      0,
   32,  107,    0,   22,    8,   86,    0,   90,   30,  -14,
    0,   65,    0,    0,   33,    0,   87,    0,  -26,    0,
    0,    0,    0,    0,   67,
};
#define YYTABLESIZE 237
short d3dxeffect_table[] = {                                      47,
   70,   18,   34,   21,   46,   47,    9,   30,   49,   37,
   46,   47,   57,   12,   15,   58,   46,    2,   71,   64,
   75,    7,   61,   10,   31,    1,    1,    7,   10,    2,
   86,   93,   98,   87,   94,   99,   13,   26,   10,   16,
   72,   73,   74,   72,   73,   58,   28,   27,   29,   32,
   45,   35,   36,   33,   17,   38,   45,   60,   90,   65,
   91,   63,   45,   76,   44,   95,   78,   96,   80,   82,
  100,   81,  101,   49,   83,  104,   84,   74,  106,   85,
  108,   88,  110,   92,  112,   10,  114,   97,  116,  102,
  118,  103,  120,  105,  122,  107,  124,  109,  126,  111,
  113,  115,  117,  119,  121,   65,  123,  125,    3,  127,
    7,   15,   14,   25,   48,   39,   89,    0,   62,    0,
   27,   77,    0,    0,   79,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    1,    0,    0,
    0,   17,   17,   21,    1,    1,    0,    0,    1,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,   42,    0,   40,   41,   42,
    1,   43,   44,   40,   41,   42,    1,   43,   44,   40,
   41,   42,    0,   43,   44,   40,   41,
};
short d3dxeffect_check[] = {                                      40,
   45,  125,  125,  125,   45,   40,  123,  123,   59,   24,
   45,   40,  125,  257,    7,   30,   45,  264,   45,   60,
   47,    0,   45,    2,   17,  261,  261,    6,    7,  264,
   41,   41,   41,   44,   44,   44,    5,  123,   17,    8,
  258,  259,  260,  258,  259,   60,   59,  257,   61,   91,
   91,   22,   23,  125,  265,   61,   91,  123,   85,   38,
   87,  125,   91,   59,  263,   92,  125,   94,   93,   59,
   97,   64,   99,  124,   59,  102,  124,  260,  105,   44,
  107,   62,  109,   44,  111,   64,  113,   44,  115,   44,
  117,   41,  119,   44,  121,   44,  123,   44,  125,   44,
   44,   44,   44,   44,   44,   84,   44,   44,  264,   93,
  257,  125,    6,   61,   29,   26,   84,   -1,   32,   -1,
   59,   55,   -1,   -1,   60,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  261,   -1,   -1,
   -1,  265,  265,  265,  261,  261,   -1,   -1,  261,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  260,   -1,  258,  259,  260,
  261,  262,  263,  258,  259,  260,  261,  262,  263,  258,
  259,  260,   -1,  262,  263,  258,  259,
};
#define YYFINAL 3
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 265
#if YYDEBUG
char *d3dxeffect_name[] = {
"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,"'('","')'",0,0,"','","'-'",0,0,0,0,0,0,0,0,0,0,0,0,0,"';'","'<'",
"'='","'>'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"'['",0,
"']'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"'{'","'|'",
"'}'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,"T_EOF","T_INT","T_HEX","T_FLOAT","T_ID","T_DECL",
"T_ASM","T_KW_TECHNIQUE","T_KW_PASS",
};
char *d3dxeffect_rule[] = {
"$accept : EffectBody",
"EffectBody : Techniques T_EOF",
"EffectBody : Parameters Techniques T_EOF",
"Parameters : Parameter",
"Parameters : Parameter Parameters",
"Parameter : Id FourCC ';'",
"Parameter : Id FourCC '=' Const ';'",
"Techniques : Technique",
"Techniques : Technique Techniques",
"Technique : T_KW_TECHNIQUE '{' TechniqueBody",
"Technique : T_KW_TECHNIQUE FourCC '{' TechniqueBody",
"TechniqueBody : '}'",
"TechniqueBody : Passes '}'",
"TechniqueBody : Assignments '}'",
"TechniqueBody : Assignments Passes '}'",
"Passes : Pass",
"Passes : Pass Passes",
"Pass : T_KW_PASS '{' PassBody",
"Pass : T_KW_PASS FourCC '{' PassBody",
"PassBody : '}'",
"PassBody : Assignments '}'",
"Assignments : Assignment",
"Assignments : Assignment Assignments",
"Assignment : LValue '=' Expression ';'",
"Assignment : LValue '=' Reference ';'",
"LValue : Id",
"LValue : Id '[' Dword ']'",
"Expression : Value",
"Expression : Value '|' Expression",
"Reference : '<' FourCC '>'",
"Const : Dword",
"Const : Float",
"Const : Vector",
"Const : Matrix",
"Const : VertexShader",
"Const : PixelShader",
"Value : Const",
"Value : Id",
"Dword : T_INT",
"Dword : '-' T_INT",
"Dword : T_HEX",
"Dword : '-' T_HEX",
"Float : T_FLOAT",
"Float : '-' T_FLOAT",
"Vector : '(' Float ')'",
"Vector : '(' Float ',' Float ')'",
"Vector : '(' Float ',' Float ',' Float ')'",
"Vector : '(' Float ',' Float ',' Float ',' Float ')'",
"Matrix : '[' Float ',' Float ',' Float ',' Float ',' Float ',' Float ',' Float ',' Float ',' Float ',' Float ',' Float ',' Float ',' Float ',' Float ',' Float ',' Float ']'",
"VertexShader : Decl",
"VertexShader : Decl Asm",
"PixelShader : Asm",
"FourCC : Id",
"Id : T_ID",
"Decl : T_DECL",
"Asm : T_ASM",
};
#endif
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH YYSTACKSIZE
#else
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#else
#define YYSTACKSIZE 500
#define YYMAXDEPTH 500
#endif
#endif
int yydebug;
int yynerrs;
int yyerrflag;
int yychar;
short *yyssp;
YYSTYPE *yyvsp;
YYSTYPE yyval;
YYSTYPE yylval;
short yyss[YYSTACKSIZE];
YYSTYPE yyvs[YYSTACKSIZE];
#define yystacksize YYSTACKSIZE
#define YYABORT goto yyabort
#define YYREJECT goto yyabort
#define YYACCEPT goto yyaccept
#define YYERROR goto yyerrlab
int
yyparse()
{
    register int yym, yyn, yystate;
#if YYDEBUG
    register char *yys;
    extern char *getenv();

    if (yys = getenv("YYDEBUG"))
    {
        yyn = *yys;
        if (yyn >= '0' && yyn <= '9')
            yydebug = yyn - '0';
    }
#endif

    yynerrs = 0;
    yyerrflag = 0;
    yychar = (-1);

    yyssp = yyss;
    yyvsp = yyvs;
    *yyssp = yystate = 0;

yyloop:
    if (yyn = yydefred[yystate]) goto yyreduce;
    if (yychar < 0)
    {
        if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
    }
    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, yystate, yytable[yyn]);
#endif
        if (yyssp >= yyss + yystacksize - 1)
        {
            goto yyoverflow;
        }
        *++yyssp = yystate = yytable[yyn];
        *++yyvsp = yylval;
        yychar = (-1);
        if (yyerrflag > 0)  --yyerrflag;
        goto yyloop;
    }
    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        yyn = yytable[yyn];
        goto yyreduce;
    }
    if (yyerrflag) goto yyinrecovery;
#ifdef lint
    goto yynewerror;
#endif
yynewerror:
    yyerror("syntax error");
#ifdef lint
    goto yyerrlab;
#endif
yyerrlab:
    ++yynerrs;
yyinrecovery:
    if (yyerrflag < 3)
    {
        yyerrflag = 3;
        for (;;)
        {
            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: state %d, error recovery shifting\
 to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
#endif
                if (yyssp >= yyss + yystacksize - 1)
                {
                    goto yyoverflow;
                }
                *++yyssp = yystate = yytable[yyn];
                *++yyvsp = yylval;
                goto yyloop;
            }
            else
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: error recovery discarding state %d\n",
                            YYPREFIX, *yyssp);
#endif
                if (yyssp <= yyss) goto yyabort;
                --yyssp;
                --yyvsp;
            }
        }
    }
    else
    {
        if (yychar == 0) goto yyabort;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
        yychar = (-1);
        goto yyloop;
    }
yyreduce:
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, yystate, yyn, yyrule[yyn]);
#endif
    yym = yylen[yyn];
    yyval = yyvsp[1-yym];
    switch (yyn)
    {
case 1:
{ Prod(P_EFFECT_BODY0, 1); }
break;
case 2:
{ Prod(P_EFFECT_BODY1, 2); }
break;
case 3:
{ Prod(P_PARAMETERS0, 1); }
break;
case 4:
{ Prod(P_PARAMETERS1, 2); }
break;
case 5:
{ Prod(P_PARAMETER0, 2); }
break;
case 6:
{ Prod(P_PARAMETER1, 3); }
break;
case 7:
{ Prod(P_TECHNIQUES0, 1); }
break;
case 8:
{ Prod(P_TECHNIQUES1, 2); }
break;
case 9:
{ Prod(P_TECHNIQUE0, 1); }
break;
case 10:
{ Prod(P_TECHNIQUE1, 2); }
break;
case 11:
{ Prod(P_TECHNIQUE_BODY0, 0); }
break;
case 12:
{ Prod(P_TECHNIQUE_BODY1, 1); }
break;
case 13:
{ Prod(P_TECHNIQUE_BODY2, 1); }
break;
case 14:
{ Prod(P_TECHNIQUE_BODY3, 2); }
break;
case 15:
{ Prod(P_PASSES0, 1); }
break;
case 16:
{ Prod(P_PASSES1, 2); }
break;
case 17:
{ Prod(P_PASS0, 1); }
break;
case 18:
{ Prod(P_PASS1, 2); }
break;
case 19:
{ Prod(P_PASS_BODY0, 0); }
break;
case 20:
{ Prod(P_PASS_BODY1, 1); }
break;
case 21:
{ Prod(P_ASSIGNMENTS0, 1); }
break;
case 22:
{ Prod(P_ASSIGNMENTS1, 2); }
break;
case 23:
{ Prod(P_ASSIGNMENT0, 2); }
break;
case 24:
{ Prod(P_ASSIGNMENT1, 2); }
break;
case 25:
{ Prod(P_LVALUE0, 1); }
break;
case 26:
{ Prod(P_LVALUE1, 2); }
break;
case 27:
{ Prod(P_EXPRESSION0, 1); }
break;
case 28:
{ Prod(P_EXPRESSION1, 2); }
break;
case 29:
{ Prod(P_REFERENCE0, 1); }
break;
case 30:
{ Prod(P_CONST_DWORD, 1); }
break;
case 31:
{ Prod(P_CONST_FLOAT, 1); }
break;
case 32:
{ Prod(P_CONST_VECTOR, 1); }
break;
case 33:
{ Prod(P_CONST_MATRIX, 1); }
break;
case 34:
{ Prod(P_CONST_VERTEXSHADER, 1); }
break;
case 35:
{ Prod(P_CONST_PIXELSHADER, 1); }
break;
case 36:
{ Prod(P_VALUE0, 1); }
break;
case 37:
{ Prod(P_VALUE1, 1); }
break;
case 38:
{ Prod(P_DWORD0, 0); }
break;
case 39:
{ Prod(P_DWORD1, 0); }
break;
case 40:
{ Prod(P_DWORD2, 0); }
break;
case 41:
{ Prod(P_DWORD3, 0); }
break;
case 42:
{ Prod(P_FLOAT0, 0); }
break;
case 43:
{ Prod(P_FLOAT1, 0); }
break;
case 44:
{ Prod(P_VECTOR0, 1); }
break;
case 45:
{ Prod(P_VECTOR1, 2); }
break;
case 46:
{ Prod(P_VECTOR2, 3); }
break;
case 47:
{ Prod(P_VECTOR3, 4); }
break;
case 48:
{ Prod(P_MATRIX0, 16); }
break;
case 49:
{ Prod(P_VERTEXSHADER0, 1); }
break;
case 50:
{ Prod(P_VERTEXSHADER1, 2); }
break;
case 51:
{ Prod(P_PIXELSHADER0, 1); }
break;
case 52:
{ Prod(P_FOURCC0, 1); }
break;
case 53:
{ Prod(P_ID0, 0); }
break;
case 54:
{ Prod(P_DECL0, 0); }
break;
case 55:
{ Prod(P_ASM0, 0); }
break;
    }
    yyssp -= yym;
    yystate = *yyssp;
    yyvsp -= yym;
    yym = yylhs[yyn];
    if (yystate == 0 && yym == 0)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: after reduction, shifting from state 0 to\
 state %d\n", YYPREFIX, YYFINAL);
#endif
        yystate = YYFINAL;
        *++yyssp = YYFINAL;
        *++yyvsp = yyval;
        if (yychar < 0)
        {
            if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
            if (yydebug)
            {
                yys = 0;
                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
                if (!yys) yys = "illegal-symbol";
                printf("%sdebug: state %d, reading %d (%s)\n",
                        YYPREFIX, YYFINAL, yychar, yys);
            }
#endif
        }
        if (yychar == 0) goto yyaccept;
        goto yyloop;
    }
    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
        yystate = yytable[yyn];
    else
        yystate = yydgoto[yym];
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: after reduction, shifting from state %d \
to state %d\n", YYPREFIX, *yyssp, yystate);
#endif
    if (yyssp >= yyss + yystacksize - 1)
    {
        goto yyoverflow;
    }
    *++yyssp = yystate;
    *++yyvsp = yyval;
    goto yyloop;
yyoverflow:
    yyerror("yacc stack overflow");
yyabort:
    return (1);
yyaccept:
    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\effect\pcheffect.h ===
//
// D3DX effect precompiled header
//

#ifndef __PCHEFFECT_H__
#define __PCHEFFECT_H__

#include <d3dx8seg.h>

#define D3DCOMPILE_BEGINSTATEBLOCK 1

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <malloc.h>
#include <xtl.h>

#include "d3dx8.h"
#include "d3dx8dbg.h"
#include "d3d8types.h"

class CEffectNode;
class CD3DXValue;
class CD3DXParameter;
class CD3DXAssignment;
class CD3DXPass;
class CD3DXTechnique;
class CD3DXEffect;

#include "CD3DXStack.h"
#include "CCompiler.h"
#include "CDeclaration.h"
#include "CEffect.h"
#include "CTechnique.h"

#define RELEASE(x) \
    do { if(x) { x->Release(); x = NULL; } } while(0)


#endif //__PCHEFFECT_H__//
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\effect\parse.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       parse.cpp
//  Content:    Parse D3DX effect files
//
///////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\link\makefile.inc ===
$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\inc\d3dx8p.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 - 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx8.h
//  Content:    D3DX utility library
//
///////////////////////////////////////////////////////////////////////////

#ifndef __D3DX8_H__
#define __D3DX8_H__

#include <d3d8.h>
#include <limits.h>

#include <xobjbase.h>

#ifndef D3DXINLINE
#ifdef __cplusplus
#define D3DXINLINE inline
#else
#define D3DXINLINE _inline
#endif
#endif

#define D3DX_DEFAULT ULONG_MAX
#define D3DX_DEFAULT_FLOAT FLT_MAX


#include "d3dx8math.h"
#include "d3dx8core.h"
#include "d3dx8tex.h"
#include "d3dx8meshp.h"
#include "d3dx8shape.h"
#include "d3dx8effect.h"

#endif //__D3DX8_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\inc\d3dx8dbg.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx8dbg.h
//  Content:    D3DX debugging functions
//
///////////////////////////////////////////////////////////////////////////


#ifndef __D3DX8DBG_H__
#define __D3DX8DBG_H__

#include <xdbg.h>

#if DBG
#define SURFACE_PORT_WARNING() \
{ \
    static BOOL bWarned = FALSE; \
    if (!bWarned) { \
        XDebugWarning("D3DX8", "Loading from resource is more efficient than using D3DX"); \
        XDebugWarning("D3DX8", "See bundler tool in XDK for examples on how to do it"); \
        bWarned = TRUE; \
    } \
}
#else
#define SURFACE_PORT_WARNING()
#endif

//
// DPF
//

#if DBG

    void cdecl D3DXDebugPrintf(UINT lvl, LPSTR szFormat, ...);
    void cdecl D3DXDebugPrintfHR(UINT lvl, HRESULT hr, LPSTR szFormat, ...);

    #define DPF D3DXDebugPrintf
    #define DPFHR D3DXDebugPrintfHR

#else // !DBG

    #pragma warning(disable:4002)
    #define DPF()
    #define DPFHR()

#endif // !DBG




//
// D3DXASSERT
//

#if DBG

    int WINAPI D3DXDebugAssert(LPCSTR szFile, int nLine, LPCSTR szCondition);

    #define D3DXASSERT(condition) \
        do { if(!(condition) && D3DXDebugAssert(__FILE__, __LINE__, #condition)) DebugBreak(); } while(0)

#else // !DBG

    #define D3DXASSERT(condition) 0

#endif // !DBG


//
// Memory leak checking
//
#ifdef DBG
//#define MEM_DEBUG
#endif

#ifdef MEM_DEBUG

    BOOL WINAPI D3DXDumpUnfreedMemoryInfo();
    void *operator new(size_t stAllocateBlock, const UINT32 uiLineNumber, const char *szFilename);
    void operator delete(void *pvMem, size_t stAllocateBlock, const UINT32 uiLineNumber, const char *szFilename);
    //void operator delete( void *pvMem );


#define new new(__LINE__, __FILE__)

#else // !DBG

    BOOL WINAPI D3DXDumpUnfreedMemoryInfo();

#define New new

#endif // !DBG

#endif // __D3DX8DBG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\inc\d3dx8seg.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx8seg.h
//  Content:    sets the sections for code and data in d3dx8.lib
//
///////////////////////////////////////////////////////////////////////////

#ifndef __D3DX8SEG_H__
#define __D3DX8SEG_H__

#include "xboxverp.h"

#pragma code_seg("D3DX")
#pragma data_seg("D3DX_RW")
#pragma const_seg("D3DX_RD")

// Tell the linker to merge constant data and data sections into code section.
#pragma comment(linker, "/merge:D3DX_RD=D3DX")
#pragma comment(linker, "/merge:D3DX_RW=D3DX")

// Tell the linker that the code section contains read/write data.
#pragma comment(linker, "/section:D3DX,ERW")

#ifdef __cplusplus
extern "C"
{
#endif

#pragma data_seg(".XBLD$V")

#if DBG
#pragma comment(linker, "/include:_D3DX8BuildNumberD")
__declspec(selectany) unsigned short D3DX8BuildNumberD[8] =
        { 'D' | ('3' << 8), 'D' | ('X' << 8), '8' | ('D' << 8), 0,
          VER_PRODUCTVERSION | 0x8000 };
#else
#pragma comment(linker, "/include:_D3DX8BuildNumber")
__declspec(selectany) unsigned short D3DX8BuildNumber[8] =
        { 'D' | ('3' << 8), 'D' | ('X' << 8), '8', 0,
          VER_PRODUCTVERSION | 0x4000 };
#endif

#pragma data_seg()
#ifdef __cplusplus
}
#endif

#endif //__D3DX8SEG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\inc\xskinexptemplates.h ===
//-----------------------------------------------------------------------------
// File: XSkinExpTemplates.h
//
// Desc: Custom templates used for skin export format.
//
// Copyright (C) 1998-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------
#ifndef __XSKINEXPTEMPLATES_H__
#define __XSKINEXPTEMPLATES_H__

// {3CF169CE-FF7C-44ab-93C0-F78F62D172E2}
DEFINE_GUID(DXFILEOBJ_XSkinMeshHeader,
0x3cf169ce, 0xff7c, 0x44ab, 0x93, 0xc0, 0xf7, 0x8f, 0x62, 0xd1, 0x72, 0xe2);

// {B8D65549-D7C9-4995-89CF-53A9A8B031E3}
DEFINE_GUID(DXFILEOBJ_VertexDuplicationIndices, 
0xb8d65549, 0xd7c9, 0x4995, 0x89, 0xcf, 0x53, 0xa9, 0xa8, 0xb0, 0x31, 0xe3);

// {6F0D123B-BAD2-4167-A0D0-80224F25FABB}
DEFINE_GUID(DXFILEOBJ_SkinWeights, 
0x6f0d123b, 0xbad2, 0x4167, 0xa0, 0xd0, 0x80, 0x22, 0x4f, 0x25, 0xfa, 0xbb);

// {A3EB5D44-FC22-429d-9AFB-3221CB9719A6}
DEFINE_GUID(DXFILEOBJ_Patch, 
0xa3eb5d44, 0xfc22, 0x429d, 0x9a, 0xfb, 0x32, 0x21, 0xcb, 0x97, 0x19, 0xa6);

// {D02C95CC-EDBA-4305-9B5D-1820D7704BBF}
DEFINE_GUID(DXFILEOBJ_PatchMesh, 
0xd02c95cc, 0xedba, 0x4305, 0x9b, 0x5d, 0x18, 0x20, 0xd7, 0x70, 0x4b, 0xbf);

// {B6C3E656-EC8B-4b92-9B62-681659522947}
DEFINE_GUID(DXFILEOBJ_PMInfo, 
0xb6c3e656, 0xec8b, 0x4b92, 0x9b, 0x62, 0x68, 0x16, 0x59, 0x52, 0x29, 0x47);

// {917E0427-C61E-4a14-9C64-AFE65F9E9844}
DEFINE_GUID(DXFILEOBJ_PMAttributeRange, 
0x917e0427, 0xc61e, 0x4a14, 0x9c, 0x64, 0xaf, 0xe6, 0x5f, 0x9e, 0x98, 0x44);

// {574CCC14-F0B3-4333-822D-93E8A8A08E4C}
DEFINE_GUID(DXFILEOBJ_PMVSplitRecord,
0x574ccc14, 0xf0b3, 0x4333, 0x82, 0x2d, 0x93, 0xe8, 0xa8, 0xa0, 0x8e, 0x4c);

// {B6E70A0E-8EF9-4e83-94AD-ECC8B0C04897}
DEFINE_GUID(DXFILEOBJ_FVFData, 
0xb6e70a0e, 0x8ef9, 0x4e83, 0x94, 0xad, 0xec, 0xc8, 0xb0, 0xc0, 0x48, 0x97);


#define XSKINEXP_TEMPLATES \
        "xof 0303txt 0032\
        template XSkinMeshHeader \
        { \
            <3CF169CE-FF7C-44ab-93C0-F78F62D172E2> \
            WORD nMaxSkinWeightsPerVertex; \
            WORD nMaxSkinWeightsPerFace; \
            WORD nBones; \
        } \
        template VertexDuplicationIndices \
        { \
            <B8D65549-D7C9-4995-89CF-53A9A8B031E3> \
            DWORD nIndices; \
            DWORD nOriginalVertices; \
            array DWORD indices[nIndices]; \
        } \
        template SkinWeights \
        { \
            <6F0D123B-BAD2-4167-A0D0-80224F25FABB> \
            STRING transformNodeName;\
            DWORD nWeights; \
            array DWORD vertexIndices[nWeights]; \
            array float weights[nWeights]; \
            Matrix4x4 matrixOffset; \
        } \
        template Patch \
        { \
            <A3EB5D44-FC22-429D-9AFB-3221CB9719A6> \
            DWORD nControlIndices; \
            array DWORD controlIndices[nControlIndices]; \
        } \
        template PatchMesh \
        { \
            <D02C95CC-EDBA-4305-9B5D-1820D7704BBF> \
            DWORD nVertices; \
            array Vector vertices[nVertices]; \
            DWORD nPatches; \
            array Patch patches[nPatches]; \
        } "

#define XEXTENSIONS_TEMPLATES \
        "xof 0303txt 0032\
        template FVFData \
        { \
            <B6E70A0E-8EF9-4e83-94AD-ECC8B0C04897> \
            DWORD dwFVF; \
            DWORD nDWords; \
            array DWORD data[nDWords]; \
        } \
        template PMAttributeRange \
        { \
            <917E0427-C61E-4a14-9C64-AFE65F9E9844> \
            DWORD iFaceOffset; \
            DWORD nFacesMin; \
            DWORD nFacesMax; \
            DWORD iVertexOffset; \
            DWORD nVerticesMin; \
            DWORD nVerticesMax; \
        } \
        template PMVSplitRecord \
        { \
            <574CCC14-F0B3-4333-822D-93E8A8A08E4C> \
            DWORD iFaceCLW; \
            DWORD iVlrOffset; \
            DWORD iCode; \
        } \
        template PMInfo \
        { \
            <B6C3E656-EC8B-4b92-9B62-681659522947> \
            DWORD nAttributes; \
            array PMAttributeRange attributeRanges[nAttributes]; \
            DWORD nMaxValence; \
            DWORD nMinLogicalVertices; \
            DWORD nMaxLogicalVertices; \
            DWORD nVSplits; \
            array PMVSplitRecord splitRecords[nVSplits]; \
            DWORD nAttributeMispredicts; \
            array DWORD attributeMispredicts[nAttributeMispredicts]; \
        } "

#endif //__XSKINEXPTEMPLATES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\inc\d3dxerrswitch.h ===
CASE_ERROR( D3DXERR_NOMEMORY );
    CASE_ERROR( D3DXERR_NULLPOINTER );
    CASE_ERROR( D3DXERR_INVALIDD3DXDEVICEINDEX );
    CASE_ERROR( D3DXERR_NODIRECTDRAWAVAILABLE );
    CASE_ERROR( D3DXERR_NODIRECT3DAVAILABLE );
    CASE_ERROR( D3DXERR_NODIRECT3DDEVICEAVAILABLE );
    CASE_ERROR( D3DXERR_NOPRIMARYAVAILABLE );
    CASE_ERROR( D3DXERR_NOZBUFFERAVAILABLE );
    CASE_ERROR( D3DXERR_NOBACKBUFFERAVAILABLE );
    CASE_ERROR( D3DXERR_COULDNTUPDATECAPS );
    CASE_ERROR( D3DXERR_NOZBUFFER );
    CASE_ERROR( D3DXERR_INVALIDMODE );
    CASE_ERROR( D3DXERR_INVALIDPARAMETER );
    CASE_ERROR( D3DXERR_INITFAILED );
    CASE_ERROR( D3DXERR_STARTUPFAILED );
    CASE_ERROR( D3DXERR_D3DXNOTSTARTEDYET );
    CASE_ERROR( D3DXERR_NOTINITIALIZED );
    CASE_ERROR( D3DXERR_FAILEDDRAWTEXT );
    CASE_ERROR( D3DXERR_BADD3DXCONTEXT );
    CASE_ERROR( D3DXERR_CAPSNOTSUPPORTED );
    CASE_ERROR( D3DXERR_UNSUPPORTEDFILEFORMAT );
    CASE_ERROR( D3DXERR_IFLERROR );
    CASE_ERROR( D3DXERR_FAILEDGETCAPS );
    CASE_ERROR( D3DXERR_CANNOTRESIZEFULLSCREEN );
    CASE_ERROR( D3DXERR_CANNOTRESIZENONWINDOWED );
    CASE_ERROR( D3DXERR_FRONTBUFFERALREADYEXISTS );
    CASE_ERROR( D3DXERR_FULLSCREENPRIMARYEXISTS );
    CASE_ERROR( D3DXERR_GETDCFAILED );
    CASE_ERROR( D3DXERR_BITBLTFAILED );
    CASE_ERROR( D3DXERR_NOTEXTURE );
    CASE_ERROR( D3DXERR_MIPLEVELABSENT );
    CASE_ERROR( D3DXERR_SURFACENOTPALETTED );
    CASE_ERROR( D3DXERR_ENUMFORMATSFAILED );
    CASE_ERROR( D3DXERR_COLORDEPTHTOOLOW );
    CASE_ERROR( D3DXERR_INVALIDFILEFORMAT );
    CASE_ERROR( D3DXERR_NOMATCHFOUND );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\math\cstack.cpp ===
#include "pchmath.h"

CD3DXMatrixStack::CD3DXMatrixStack()
{
    m_pstack = NULL;
    m_stackSize = 0;

    m_currentPos = 0;
    m_ulRefCount = 1;
}

CD3DXMatrixStack::~CD3DXMatrixStack()
{
    if(m_pstack)
        delete [] m_pstack;

    return;
}

HRESULT
CD3DXMatrixStack::Initialize(int stackSize)
{
    D3DXASSERT(m_pstack == NULL);

    if(!(m_pstack = new D3DXMATRIX[stackSize]))
        return E_OUTOFMEMORY;

    m_stackSize = stackSize;
    m_currentPos = 0;

    LoadIdentity();
    return S_OK;
}

HRESULT STDMETHODCALLTYPE
CD3DXMatrixStack::QueryInterface( REFIID riid, LPVOID * ppvObj)
{
    if( !ppvObj )
    {
        DPF(0, "ppvObj pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if( IsEqualIID( riid, IID_ID3DXMatrixStack ) )
    {
        *ppvObj = (ID3DXMatrixStack *) this;
    }
    else if( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppvObj = (IUnknown *) this;
    }
    else
    {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

ULONG  STDMETHODCALLTYPE
CD3DXMatrixStack::AddRef()
{
    return ++m_ulRefCount;
}

ULONG  STDMETHODCALLTYPE
CD3DXMatrixStack::Release()
{
    ULONG ulRefCount = --m_ulRefCount;
    if( ulRefCount == 0 )
    {
        delete this;
    }
    return ulRefCount; // return the copy on the stack, which is guaranteed to still exist.
}


HRESULT
CD3DXMatrixStack::Pop()
{
    if (m_currentPos == 0)
        return S_OK;
    else
        m_currentPos--;

    return S_OK;
}

HRESULT
CD3DXMatrixStack::Push()
{
    m_currentPos++;

    if (m_currentPos >= m_stackSize)
    {
        D3DXMATRIX *pstack;

        if(!(pstack = new D3DXMATRIX[m_stackSize * 2]))
            return E_OUTOFMEMORY;

        if(m_pstack)
        {
            memcpy(pstack, m_pstack, m_stackSize * sizeof(D3DXMATRIX));
            delete [] m_pstack;
        }

        m_pstack = pstack;
        m_stackSize *= 2;
    }

    m_pstack[m_currentPos] = m_pstack[m_currentPos-1];
    return S_OK;
}

HRESULT
CD3DXMatrixStack::LoadIdentity()
{
    D3DXMatrixIdentity(&m_pstack[m_currentPos]);
    return S_OK;
}

HRESULT
CD3DXMatrixStack::LoadMatrix( const D3DXMATRIX *pMat )
{
#if DBG
    if(!pMat)
    {
        DPF(0, "pMat pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
#endif

    m_pstack[m_currentPos] = *pMat;
    return S_OK;
}

HRESULT
CD3DXMatrixStack::MultMatrix( const D3DXMATRIX *pMat )
{
#if DBG
    if(!pMat)
    {
        DPF(0, "pMat pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
#endif

    m_pstack[m_currentPos] = m_pstack[m_currentPos] * *pMat;
    return S_OK;
}

HRESULT
CD3DXMatrixStack::MultMatrixLocal( const D3DXMATRIX *pMat )
{
#if DBG
    if(!pMat)
    {
        DPF(0, "pMat pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
#endif

    m_pstack[m_currentPos] = *pMat * m_pstack[m_currentPos];
    return S_OK;
}

D3DXMATRIX *
CD3DXMatrixStack::GetTop()
{
    return &m_pstack[m_currentPos];
}

HRESULT
CD3DXMatrixStack::RotateAxis( const D3DXVECTOR3 *pV, float angle )
{
#if DBG
    if(!pV)
    {
        DPF(0, "pV pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
#endif

    D3DXMATRIX tmp;

    D3DXMatrixRotationAxis( &tmp, pV, angle );
    m_pstack[m_currentPos] = m_pstack[m_currentPos] * tmp;
    return S_OK;
}

HRESULT
CD3DXMatrixStack::RotateAxisLocal( const D3DXVECTOR3 *pV, float angle )
{
#if DBG
    if(!pV)
    {
        DPF(0, "pV pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
#endif

    D3DXMATRIX tmp;

    D3DXMatrixRotationAxis( &tmp, pV, angle );
    m_pstack[m_currentPos] = tmp * m_pstack[m_currentPos];
    return S_OK;
}

HRESULT
CD3DXMatrixStack::RotateYawPitchRoll( float yaw, float pitch, float roll )
{
    D3DXMATRIX tmp;

    D3DXMatrixRotationYawPitchRoll( &tmp, yaw, pitch, roll );
    m_pstack[m_currentPos] = m_pstack[m_currentPos] * tmp;
    return S_OK;
}

HRESULT
CD3DXMatrixStack::RotateYawPitchRollLocal( float yaw, float pitch, float roll )
{
    D3DXMATRIX tmp;

    D3DXMatrixRotationYawPitchRoll( &tmp, yaw, pitch, roll );
    m_pstack[m_currentPos] = tmp * m_pstack[m_currentPos];
    return S_OK;
}

HRESULT
CD3DXMatrixStack::Scale( float x, float y, float z )
{
    D3DXMATRIX tmp;

    D3DXMatrixScaling( &tmp, x, y, z );
    m_pstack[m_currentPos] = m_pstack[m_currentPos] * tmp;
    return S_OK;
}

HRESULT
CD3DXMatrixStack::ScaleLocal( float x, float y, float z )
{
    D3DXMATRIX tmp;

    D3DXMatrixScaling( &tmp, x, y, z );
    m_pstack[m_currentPos] = tmp * m_pstack[m_currentPos];
    return S_OK;
}

HRESULT
CD3DXMatrixStack::Translate( float x, float y, float z )
{
    D3DXMATRIX tmp;

    D3DXMatrixTranslation( &tmp, x, y, z );
    m_pstack[m_currentPos] = m_pstack[m_currentPos] * tmp;
    return S_OK;
}

HRESULT
CD3DXMatrixStack::TranslateLocal( float x, float y, float z )
{
    D3DXMATRIX tmp;

    D3DXMatrixTranslation( &tmp, x, y, z );
    m_pstack[m_currentPos] = tmp * m_pstack[m_currentPos];
    return S_OK;
}




HRESULT WINAPI
D3DXCreateMatrixStack( DWORD flags, ID3DXMatrixStack **ppStack )
{
    HRESULT hr;

    // These flags will be used in the future to specify that
    // the user wants the internals to be double precision

    // Validate Parameters
    if( ppStack == NULL )
    {
        DPF(0, "ppStack pointer is invalid");
        return D3DERR_INVALIDCALL;
    }

    CD3DXMatrixStack *pStack = new CD3DXMatrixStack;

    if( pStack == NULL )
        return E_OUTOFMEMORY;

    if( FAILED(hr = pStack->Initialize(16)) )
    {
        pStack->Release();
        return hr;
    }

    *ppStack = pStack;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\inc\d3dx8meshp.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1998 - 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx8mesh.h
//  Content:    D3DX mesh types and functions
//
//////////////////////////////////////////////////////////////////////////////

#include "d3dx8.h"

#ifndef __D3DX8MESH_H__
#define __D3DX8MESH_H__

#include "dxfile.h"     // defines LPDIRECTXFILEDATA

// {A69BA991-1F7D-11d3-B929-00C04F68DC23}
DEFINE_GUID(IID_ID3DXBaseMesh,
0xa69ba991, 0x1f7d, 0x11d3, 0xb9, 0x29, 0x0, 0xc0, 0x4f, 0x68, 0xdc, 0x23);

// {9D84AC46-6B90-49a9-A721-085C7A3E3DAE}
DEFINE_GUID(IID_ID3DXMesh,
0x9d84ac46, 0x6b90, 0x49a9, 0xa7, 0x21, 0x8, 0x5c, 0x7a, 0x3e, 0x3d, 0xae);

// {15981AA8-1A05-48e3-BBE7-FF5D49654E3F}
DEFINE_GUID(IID_ID3DXPMesh,
0x15981aa8, 0x1a05, 0x48e3, 0xbb, 0xe7, 0xff, 0x5d, 0x49, 0x65, 0x4e, 0x3f);

// {BC3BBDE2-1F7D-11d3-B929-00C04F68DC23}
DEFINE_GUID(IID_ID3DXSPMesh,
0xbc3bbde2, 0x1f7d, 0x11d3, 0xb9, 0x29, 0x0, 0xc0, 0x4f, 0x68, 0xdc, 0x23);

// {82A53844-F322-409e-A2E9-992E1104069D}
DEFINE_GUID(IID_ID3DXSkinMesh,
0x82a53844, 0xf322, 0x409e, 0xa2, 0xe9, 0x99, 0x2e, 0x11, 0x4, 0x6, 0x9d);


enum _D3DXMESH {
    D3DXMESH_32BIT                  = 0x001, // If set, then use 32 bit indices, if not set use 16 bit indices. 32BIT meshes currently not supported on ID3DXSkinMesh object
    D3DXMESH_DONOTCLIP              = 0x002, // Use D3DUSAGE_DONOTCLIP for VB & IB.
    D3DXMESH_POINTS                 = 0x004, // Use D3DUSAGE_POINTS for VB & IB.
    D3DXMESH_RTPATCHES              = 0x008, // Use D3DUSAGE_RTPATCHES for VB & IB.
    D3DXMESH_NPATCHES               = 0x4000,// Use D3DUSAGE_NPATCHES for VB & IB.
    D3DXMESH_VB_SYSTEMMEM           = 0x010, // Use D3DPOOL_SYSTEMMEM for VB. Overrides D3DXMESH_MANAGEDVERTEXBUFFER
    D3DXMESH_VB_MANAGED             = 0x020, // Use D3DPOOL_MANAGED for VB.
    D3DXMESH_VB_WRITEONLY           = 0x040, // Use D3DUSAGE_WRITEONLY for VB.
    D3DXMESH_VB_DYNAMIC             = 0x080, // Use D3DUSAGE_DYNAMIC for VB.
    D3DXMESH_IB_SYSTEMMEM           = 0x100, // Use D3DPOOL_SYSTEMMEM for IB. Overrides D3DXMESH_MANAGEDINDEXBUFFER
    D3DXMESH_IB_MANAGED             = 0x200, // Use D3DPOOL_MANAGED for IB.
    D3DXMESH_IB_WRITEONLY           = 0x400, // Use D3DUSAGE_WRITEONLY for IB.
    D3DXMESH_IB_DYNAMIC             = 0x800, // Use D3DUSAGE_DYNAMIC for IB.

    D3DXMESH_VB_SHARE               = 0x1000, // Valid for Clone* calls only, forces cloned mesh/pmesh to share vertex buffer

    D3DXMESH_USEHWONLY              = 0x2000, // Valid for ID3DXSkinMesh::ConvertToBlendedMesh

    // Helper options
    D3DXMESH_SYSTEMMEM              = 0x110, // D3DXMESH_VB_SYSTEMMEM | D3DXMESH_IB_SYSTEMMEM
    D3DXMESH_MANAGED                = 0x220, // D3DXMESH_VB_MANAGED | D3DXMESH_IB_MANAGED
    D3DXMESH_WRITEONLY              = 0x440, // D3DXMESH_VB_WRITEONLY | D3DXMESH_IB_WRITEONLY
    D3DXMESH_DYNAMIC                = 0x880, // D3DXMESH_VB_DYNAMIC | D3DXMESH_IB_DYNAMIC

    D3DXMESH_VALIDBITS              = 0x4fff,
    D3DXMESH_VALIDCLONEBITS         = 0x5fff,
    D3DXMESH_VALIDBLENDEDBITS       = 0x6fff,
};

// option field values for specifying min value in D3DXGeneratePMesh and D3DXSimplifyMesh
enum _D3DXMESHSIMP
{
    D3DXMESHSIMP_VERTEX   = 0x1,
    D3DXMESHSIMP_FACE     = 0x2,

    D3DXMESHSIMP_VALIDBITS =0x03
};

enum _MAX_FVF_DECL_SIZE
{
    MAX_FVF_DECL_SIZE = 20
};

typedef struct ID3DXBaseMesh *LPD3DXBASEMESH;
typedef struct ID3DXMesh *LPD3DXMESH;
typedef struct ID3DXPMesh *LPD3DXPMESH;
typedef struct ID3DXSPMesh *LPD3DXSPMESH;
typedef struct ID3DXSkinMesh *LPD3DXSKINMESH;

typedef struct _D3DXATTRIBUTERANGE
{
    DWORD AttribId;
    DWORD FaceStart;
    DWORD FaceCount;
    DWORD VertexStart;
    DWORD VertexCount;
} D3DXATTRIBUTERANGE;

typedef D3DXATTRIBUTERANGE* LPD3DXATTRIBUTERANGE;

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus
struct D3DXMATERIAL
{
    D3DMATERIAL8  MatD3D;
    LPSTR         pTextureFilename;
};
typedef struct D3DXMATERIAL *LPD3DXMATERIAL;
#ifdef __cplusplus
}
#endif //__cplusplus

typedef struct _D3DXATTRIBUTEWEIGHTS
{
    FLOAT Position;
    FLOAT Boundary;
    FLOAT Normal;
    FLOAT Diffuse;
    FLOAT Specular;
    FLOAT Tex[8];
} D3DXATTRIBUTEWEIGHTS;

typedef D3DXATTRIBUTEWEIGHTS* LPD3DXATTRIBUTEWEIGHTS;

DECLARE_INTERFACE_(ID3DXBaseMesh, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXBaseMesh
    STDMETHOD(DrawSubset)(THIS_ DWORD AttribId) PURE;
    STDMETHOD_(DWORD, GetNumFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetNumVertices)(THIS) PURE;
    STDMETHOD_(DWORD, GetFVF)(THIS) PURE;
    STDMETHOD(GetDeclaration)(THIS_ DWORD Declaration[MAX_FVF_DECL_SIZE]) PURE;
    STDMETHOD_(DWORD, GetOptions)(THIS) PURE;
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(CloneMeshFVF)(THIS_ DWORD Options,
                DWORD FVF, LPDIRECT3DDEVICE8 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(CloneMesh)(THIS_ DWORD Options,
                CONST DWORD *pDeclaration, LPDIRECT3DDEVICE8 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(GetVertexBuffer)(THIS_ LPDIRECT3DVERTEXBUFFER8* ppVB) PURE;
    STDMETHOD(GetIndexBuffer)(THIS_ LPDIRECT3DINDEXBUFFER8* ppIB) PURE;
    STDMETHOD(LockVertexBuffer)(THIS_ DWORD Flags, BYTE** ppData) PURE;
    STDMETHOD(UnlockVertexBuffer)(THIS) PURE;
    STDMETHOD(LockIndexBuffer)(THIS_ DWORD Flags, BYTE** ppData) PURE;
    STDMETHOD(UnlockIndexBuffer)(THIS) PURE;
    STDMETHOD(GetAttributeTable)(
                THIS_ D3DXATTRIBUTERANGE *pAttribTable, DWORD* pAttribTableSize) PURE;
};

DECLARE_INTERFACE_(ID3DXMesh, ID3DXBaseMesh)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXBaseMesh
    STDMETHOD(DrawSubset)(THIS_ DWORD AttribId) PURE;
    STDMETHOD_(DWORD, GetNumFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetNumVertices)(THIS) PURE;
    STDMETHOD_(DWORD, GetFVF)(THIS) PURE;
    STDMETHOD(GetDeclaration)(THIS_ DWORD Declaration[MAX_FVF_DECL_SIZE]) PURE;
    STDMETHOD_(DWORD, GetOptions)(THIS) PURE;
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(CloneMeshFVF)(THIS_ DWORD Options,
                DWORD FVF, LPDIRECT3DDEVICE8 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(CloneMesh)(THIS_ DWORD Options,
                CONST DWORD *pDeclaration, LPDIRECT3DDEVICE8 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(GetVertexBuffer)(THIS_ LPDIRECT3DVERTEXBUFFER8* ppVB) PURE;
    STDMETHOD(GetIndexBuffer)(THIS_ LPDIRECT3DINDEXBUFFER8* ppIB) PURE;
    STDMETHOD(LockVertexBuffer)(THIS_ DWORD Flags, BYTE** ppData) PURE;
    STDMETHOD(UnlockVertexBuffer)(THIS) PURE;
    STDMETHOD(LockIndexBuffer)(THIS_ DWORD Flags, BYTE** ppData) PURE;
    STDMETHOD(UnlockIndexBuffer)(THIS) PURE;
    STDMETHOD(GetAttributeTable)(
                THIS_ D3DXATTRIBUTERANGE *pAttribTable, DWORD* pAttribTableSize) PURE;

    // ID3DXMesh
    STDMETHOD(LockAttributeBuffer)(THIS_ DWORD Flags, DWORD** ppData) PURE;
    STDMETHOD(UnlockAttributeBuffer)(THIS) PURE;
    STDMETHOD(ConvertPointRepsToAdjacency)(THIS_ CONST DWORD* pPRep, DWORD* pAdjacency) PURE;
    STDMETHOD(ConvertAdjacencyToPointReps)(THIS_ CONST DWORD* pAdjacency, DWORD* pPRep) PURE;
    STDMETHOD(GenerateAdjacency)(THIS_ FLOAT fEpsilon, DWORD* pAdjacency) PURE;
    STDMETHOD(Optimize)(THIS_ DWORD Flags, CONST DWORD* pAdjacencyIn, DWORD* pAdjacencyOut,
                     DWORD* pFaceRemap, LPD3DXBUFFER *ppVertexRemap,
                     LPD3DXMESH* ppOptMesh) PURE;
    STDMETHOD(OptimizeInplace)(THIS_ DWORD Flags, CONST DWORD* pAdjacencyIn, DWORD* pAdjacencyOut,
                     DWORD* pFaceRemap, LPD3DXBUFFER *ppVertexRemap) PURE;
};

DECLARE_INTERFACE_(ID3DXPMesh, ID3DXBaseMesh)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXBaseMesh
    STDMETHOD(DrawSubset)(THIS_ DWORD AttribId) PURE;
    STDMETHOD_(DWORD, GetNumFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetNumVertices)(THIS) PURE;
    STDMETHOD_(DWORD, GetFVF)(THIS) PURE;
    STDMETHOD(GetDeclaration)(THIS_ DWORD Declaration[MAX_FVF_DECL_SIZE]) PURE;
    STDMETHOD_(DWORD, GetOptions)(THIS) PURE;
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(CloneMeshFVF)(THIS_ DWORD Options,
                DWORD FVF, LPDIRECT3DDEVICE8 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(CloneMesh)(THIS_ DWORD Options,
                CONST DWORD *pDeclaration, LPDIRECT3DDEVICE8 pD3DDevice, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(GetVertexBuffer)(THIS_ LPDIRECT3DVERTEXBUFFER8* ppVB) PURE;
    STDMETHOD(GetIndexBuffer)(THIS_ LPDIRECT3DINDEXBUFFER8* ppIB) PURE;
    STDMETHOD(LockVertexBuffer)(THIS_ DWORD Flags, BYTE** ppData) PURE;
    STDMETHOD(UnlockVertexBuffer)(THIS) PURE;
    STDMETHOD(LockIndexBuffer)(THIS_ DWORD Flags, BYTE** ppData) PURE;
    STDMETHOD(UnlockIndexBuffer)(THIS) PURE;
    STDMETHOD(GetAttributeTable)(
                THIS_ D3DXATTRIBUTERANGE *pAttribTable, DWORD* pAttribTableSize) PURE;

    // ID3DXPMesh
    STDMETHOD(ClonePMeshFVF)(THIS_ DWORD Options,
                DWORD FVF, LPDIRECT3DDEVICE8 pD3D, LPD3DXPMESH* ppCloneMesh) PURE;
    STDMETHOD(ClonePMesh)(THIS_ DWORD Options,
                CONST DWORD *pDeclaration, LPDIRECT3DDEVICE8 pD3D, LPD3DXPMESH* ppCloneMesh) PURE;
    STDMETHOD(SetNumFaces)(THIS_ DWORD Faces) PURE;
    STDMETHOD(SetNumVertices)(THIS_ DWORD Vertices) PURE;
    STDMETHOD_(DWORD, GetMaxFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetMinFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetMaxVertices)(THIS) PURE;
    STDMETHOD_(DWORD, GetMinVertices)(THIS) PURE;
    STDMETHOD(Save)(THIS_ IStream *pStream, LPD3DXMATERIAL pMaterials, DWORD NumMaterials) PURE;

    STDMETHOD(Optimize)(THIS_ DWORD Flags, DWORD* pAdjacencyOut,
                     DWORD* pFaceRemap, LPD3DXBUFFER *ppVertexRemap,
                     LPD3DXMESH* ppOptMesh) PURE;
    STDMETHOD(GetAdjacency)(THIS_ DWORD* pAdjacency) PURE;
};

DECLARE_INTERFACE_(ID3DXSPMesh, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXSPMesh
    STDMETHOD_(DWORD, GetNumFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetNumVertices)(THIS) PURE;
    STDMETHOD_(DWORD, GetFVF)(THIS) PURE;
    STDMETHOD(GetDeclaration)(THIS_ DWORD Declaration[MAX_FVF_DECL_SIZE]) PURE;
    STDMETHOD_(DWORD, GetOptions)(THIS) PURE;
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(CloneMeshFVF)(THIS_ DWORD Options,
                DWORD FVF, LPDIRECT3DDEVICE8 pD3D, DWORD *pAdjacencyOut, DWORD *pVertexRemapOut, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(CloneMesh)(THIS_ DWORD Options,
                CONST DWORD *pDeclaration, LPDIRECT3DDEVICE8 pD3DDevice, DWORD *pAdjacencyOut, DWORD *pVertexRemapOut, LPD3DXMESH* ppCloneMesh) PURE;
    STDMETHOD(ClonePMeshFVF)(THIS_ DWORD Options,
                DWORD FVF, LPDIRECT3DDEVICE8 pD3D, DWORD *pVertexRemapOut, LPD3DXPMESH* ppCloneMesh) PURE;
    STDMETHOD(ClonePMesh)(THIS_ DWORD Options,
                CONST DWORD *pDeclaration, LPDIRECT3DDEVICE8 pD3D, DWORD *pVertexRemapOut, LPD3DXPMESH* ppCloneMesh) PURE;
    STDMETHOD(ReduceFaces)(THIS_ DWORD Faces) PURE;
    STDMETHOD(ReduceVertices)(THIS_ DWORD Vertices) PURE;
    STDMETHOD_(DWORD, GetMaxFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetMaxVertices)(THIS) PURE;
};

#define UNUSED16 (0xffff)
#define UNUSED32 (0xffffffff)

// ID3DXMesh::Optimize options
enum _D3DXMESHOPT {
    D3DXMESHOPT_COMPACT       = 0x001,
    D3DXMESHOPT_ATTRSORT      = 0x002,
    D3DXMESHOPT_VERTEXCACHE   = 0x004,
    D3DXMESHOPT_STRIPREORDER  = 0x008,
    D3DXMESHOPT_IGNOREVERTS   = 0x010,  // optimize faces only, don't touch vertices
    D3DXMESHOPT_SHAREVB       = 0x020,
    D3DXMESHOPT_VALIDBITS     = 0x03f
};

// Subset of the mesh that has the same attribute and bone combination.
// This subset can be rendered in a single draw call
typedef struct _D3DXBONECOMBINATION
{
    DWORD AttribId;
    DWORD FaceStart;
    DWORD FaceCount;
    DWORD VertexStart;
    DWORD VertexCount;
    DWORD* BoneId;
} D3DXBONECOMBINATION, *LPD3DXBONECOMBINATION;

DECLARE_INTERFACE_(ID3DXSkinMesh, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // ID3DXMesh
    STDMETHOD_(DWORD, GetNumFaces)(THIS) PURE;
    STDMETHOD_(DWORD, GetNumVertices)(THIS) PURE;
    STDMETHOD_(DWORD, GetFVF)(THIS) PURE;
    STDMETHOD(GetDeclaration)(THIS_ DWORD Declaration[MAX_FVF_DECL_SIZE]) PURE;
    STDMETHOD_(DWORD, GetOptions)(THIS) PURE;
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice) PURE;
    STDMETHOD(GetVertexBuffer)(THIS_ LPDIRECT3DVERTEXBUFFER8* ppVB) PURE;
    STDMETHOD(GetIndexBuffer)(THIS_ LPDIRECT3DINDEXBUFFER8* ppIB) PURE;
    STDMETHOD(LockVertexBuffer)(THIS_ DWORD flags, BYTE** ppData) PURE;
    STDMETHOD(UnlockVertexBuffer)(THIS) PURE;
    STDMETHOD(LockIndexBuffer)(THIS_ DWORD flags, BYTE** ppData) PURE;
    STDMETHOD(UnlockIndexBuffer)(THIS) PURE;
    STDMETHOD(LockAttributeBuffer)(THIS_ DWORD flags, DWORD** ppData) PURE;
    STDMETHOD(UnlockAttributeBuffer)(THIS) PURE;
    // ID3DXSkinMesh
    STDMETHOD_(DWORD, GetNumBones)(THIS) PURE;
    STDMETHOD(GetOriginalMesh)(THIS_ LPD3DXMESH* ppMesh) PURE;
    STDMETHOD(SetBoneInfluence)(THIS_ DWORD bone, DWORD numInfluences, CONST DWORD* vertices, CONST FLOAT* weights) PURE;
    STDMETHOD_(DWORD, GetNumBoneInfluences)(THIS_ DWORD bone) PURE;
    STDMETHOD(GetBoneInfluence)(THIS_ DWORD bone, DWORD* vertices, FLOAT* weights) PURE;
    STDMETHOD(GetMaxVertexInfluences)(THIS_ DWORD* maxVertexInfluences) PURE;
    STDMETHOD(GetMaxFaceInfluences)(THIS_ DWORD* maxFaceInfluences) PURE;
    STDMETHOD(ConvertToBlendedMesh)(THIS_ DWORD options, CONST LPDWORD pAdjacencyIn, LPDWORD pAdjacencyOut,
                            DWORD* pNumBoneCombinations, LPD3DXBUFFER* ppBoneCombinationTable, LPD3DXMESH* ppMesh) PURE;
    STDMETHOD(ConvertToIndexedBlendedMesh)(THIS_ DWORD options,
                                           CONST LPDWORD pAdjacencyIn,
                                           DWORD paletteSize,
                                           LPDWORD pAdjacencyOut,
                                           DWORD* pNumBoneCombinations,
                                           LPD3DXBUFFER* ppBoneCombinationTable,
                                           LPD3DXMESH* ppMesh) PURE;
    STDMETHOD(GenerateSkinnedMesh)(THIS_ DWORD options, FLOAT minWeight, CONST LPDWORD pAdjacencyIn, LPDWORD pAdjacencyOut, LPD3DXMESH* ppMesh) PURE;
    STDMETHOD(UpdateSkinnedMesh)(THIS_ CONST D3DXMATRIX* pBoneTransforms, LPD3DXMESH pMesh) PURE;
};

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

HRESULT WINAPI
    D3DXCreateMesh(
        DWORD NumFaces,
        DWORD NumVertices,
        DWORD Options,
        CONST DWORD *pDeclaration,
        LPDIRECT3DDEVICE8 pD3D,
        LPD3DXMESH* ppMesh);

HRESULT WINAPI
    D3DXCreateMeshFVF(
        DWORD NumFaces,
        DWORD NumVertices,
        DWORD Options,
        DWORD FVF,
        LPDIRECT3DDEVICE8 pD3D,
        LPD3DXMESH* ppMesh);

HRESULT WINAPI
    D3DXCreateSPMesh(
        LPD3DXMESH pMesh,
        CONST DWORD* pAdjacency,
        CONST LPD3DXATTRIBUTEWEIGHTS pVertexAttributeWeights,
        CONST FLOAT *pVertexWeights,
        LPD3DXSPMESH* ppSMesh);

// clean a mesh up for simplification, try to make manifold
HRESULT WINAPI
    D3DXCleanMesh(
    LPD3DXMESH pMeshIn,
    CONST DWORD* pAdjacency,
    LPD3DXMESH* ppMeshOut);

HRESULT WINAPI
    D3DXValidMesh(
    LPD3DXMESH pMeshIn,
    CONST DWORD* pAdjacency);

HRESULT WINAPI
    D3DXGeneratePMesh(
        LPD3DXMESH pMesh,
        CONST DWORD* pAdjacency,
        CONST LPD3DXATTRIBUTEWEIGHTS pVertexAttributeWeights,
        CONST FLOAT *pVertexWeights,
        DWORD MinValue,
        DWORD Options,
        LPD3DXPMESH* ppPMesh);

HRESULT WINAPI
    D3DXSimplifyMesh(
        LPD3DXMESH pMesh,
        CONST DWORD* pAdjacency,
        CONST LPD3DXATTRIBUTEWEIGHTS pVertexAttributeWeights,
        CONST FLOAT *pVertexWeights,
        DWORD MinValue,
        DWORD Options,
        LPD3DXMESH* ppMesh);

HRESULT WINAPI
    D3DXComputeBoundingSphere(
        PVOID pPointsFVF,
        DWORD NumVertices,
        DWORD FVF,
        D3DXVECTOR3 *pCenter,
        FLOAT *pRadius);

HRESULT WINAPI
    D3DXComputeBoundingBox(
        PVOID pPointsFVF,
        DWORD NumVertices,
        DWORD FVF,
        D3DXVECTOR3 *pMin,
        D3DXVECTOR3 *pMax);

HRESULT WINAPI
    D3DXComputeNormals(
        LPD3DXBASEMESH pMesh);

HRESULT WINAPI
    D3DXCreateBuffer(
        DWORD NumBytes,
        LPD3DXBUFFER *ppBuffer);


HRESULT WINAPI
    D3DXLoadMeshFromX(
        LPSTR pFilename,
        DWORD Options,
        LPDIRECT3DDEVICE8 pD3D,
        LPD3DXBUFFER *ppAdjacency,
        LPD3DXBUFFER *ppMaterials,
        PDWORD pNumMaterials,
        LPD3DXMESH *ppMesh);

HRESULT WINAPI
    D3DXSaveMeshToX(
        LPSTR pFilename,
        LPD3DXMESH pMesh,
        CONST DWORD* pAdjacency,
        CONST LPD3DXMATERIAL pMaterials,
        DWORD NumMaterials,
        DWORD Format
        );

HRESULT WINAPI
    D3DXCreatePMeshFromStream(
        IStream *pStream,
    DWORD Options,
        LPDIRECT3DDEVICE8 pD3DDevice,
        LPD3DXBUFFER *ppMaterials,
        DWORD* pNumMaterials,
        LPD3DXPMESH *ppPMesh);

HRESULT WINAPI
    D3DXCreateSkinMesh(
        DWORD numFaces,
        DWORD numVertices,
        DWORD numBones,
        DWORD options,
        CONST DWORD *pDeclaration,
        LPDIRECT3DDEVICE8 pD3D,
        LPD3DXSKINMESH* ppSkinMesh);

HRESULT WINAPI
    D3DXCreateSkinMeshFVF(
        DWORD numFaces,
        DWORD numVertices,
        DWORD numBones,
        DWORD options,
        DWORD fvf,
        LPDIRECT3DDEVICE8 pD3D,
        LPD3DXSKINMESH* ppSkinMesh);

HRESULT WINAPI
    D3DXCreateSkinMeshFromMesh(
        LPD3DXMESH pMesh,
        DWORD numBones,
        LPD3DXSKINMESH* ppSkinMesh);

HRESULT WINAPI
    D3DXLoadMeshFromXof(
        LPDIRECTXFILEDATA pXofObjMesh,
        DWORD Options,
        LPDIRECT3DDEVICE8 pD3DDevice,
        LPD3DXBUFFER *ppAdjacency,
        LPD3DXBUFFER *ppMaterials,
        PDWORD pNumMaterials,
        LPD3DXMESH *ppMesh);

HRESULT WINAPI
    D3DXLoadSkinMeshFromXof(
        LPDIRECTXFILEDATA pxofobjMesh,
        DWORD options,
        LPDIRECT3DDEVICE8 pD3D,
        LPD3DXBUFFER* ppAdjacency,
        LPD3DXBUFFER* ppMaterials,
        PDWORD pMatOut,
        LPD3DXBUFFER* ppBoneNames,
        LPD3DXBUFFER* ppBoneTransforms,
        LPD3DXSKINMESH* ppMesh);

HRESULT WINAPI
    D3DXTesselateMesh(
        LPD3DXMESH pMeshIn,
        CONST DWORD* pAdjacency,
        FLOAT NumSegs,
        BOOL  QuadraticInterpNormals,     // if false use linear intrep for normals, if true use quadratic
        LPD3DXMESH *ppMeshOut);

HRESULT WINAPI
    D3DXDeclaratorFromFVF(
        DWORD FVF,
        DWORD Declaration[MAX_FVF_DECL_SIZE]);

HRESULT WINAPI
    D3DXFVFFromDeclarator(
        CONST DWORD *pDeclarator,
        DWORD *pFVF);

HRESULT WINAPI
    D3DXWeldVertices(
        CONST LPD3DXMESH pMesh,
        float fEpsilon,
        CONST DWORD *rgdwAdjacencyIn,
        DWORD *rgdwAdjacencyOut,
        DWORD* pFaceRemap,
        LPD3DXBUFFER *ppbufVertexRemap);

HRESULT WINAPI
    D3DXIntersect(
        LPD3DXBASEMESH pMesh,
        CONST D3DXVECTOR3 *pRayPos,
        CONST D3DXVECTOR3 *pRayDir,
        BOOL    *pHit,
        DWORD   *pFaceIndex,
        FLOAT   *pU,
        FLOAT   *pV,
        FLOAT   *pDist);

BOOL WINAPI
    D3DXSphereBoundProbe(
        CONST D3DXVECTOR3 *pvCenter,
        FLOAT fRadius,
        D3DXVECTOR3 *pvRayPosition,
        D3DXVECTOR3 *pvRayDirection);

BOOL WINAPI
    D3DXBoxBoundProbe(
        CONST D3DXVECTOR3 *pvMin,
        CONST D3DXVECTOR3 *pvMax,
        D3DXVECTOR3 *pvRayPosition,
        D3DXVECTOR3 *pvRayDirection);

enum _D3DXERR {
    D3DXERR_CANNOTMODIFYINDEXBUFFER     = MAKE_DDHRESULT(2900),
    D3DXERR_INVALIDMESH                 = MAKE_DDHRESULT(2901),
    D3DXERR_CANNOTATTRSORT              = MAKE_DDHRESULT(2902),
    D3DXERR_SKINNINGNOTSUPPORTED        = MAKE_DDHRESULT(2903),
    D3DXERR_TOOMANYINFLUENCES           = MAKE_DDHRESULT(2904),
    D3DXERR_INVALIDDATA                 = MAKE_DDHRESULT(2905),
};

#ifdef __cplusplus
}
#endif //__cplusplus

#endif //__D3DX8MESH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\math\cstack.h ===
#ifndef  __CSTACK_H__
#define  __CSTACK_H__

class CD3DXMatrixStack : public ID3DXMatrixStack
{
private:
    int m_stackSize;
    D3DXMATRIX *m_pstack;

    int m_currentPos;
    ULONG m_ulRefCount;

public:
    CD3DXMatrixStack();
    ~CD3DXMatrixStack();

    HRESULT Initialize(int stackSize);

    // IUnknown
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID * ppvObj);
    ULONG  STDMETHODCALLTYPE AddRef();
    ULONG  STDMETHODCALLTYPE Release();

    // ID3DXMatrixStack
    STDMETHOD(Pop)(THIS);
    STDMETHOD(Push)(THIS);
    STDMETHOD(LoadIdentity)(THIS);
    STDMETHOD(LoadMatrix)(THIS_ const D3DXMATRIX* pM );
    STDMETHOD(MultMatrix)(THIS_ const D3DXMATRIX* pM );
    STDMETHOD(MultMatrixLocal)(THIS_ const D3DXMATRIX* pM );
    STDMETHOD(RotateAxis)(THIS_ const D3DXVECTOR3* pV, float angle);
    STDMETHOD(RotateAxisLocal)(THIS_ const D3DXVECTOR3* pV, float angle);
    STDMETHOD(RotateYawPitchRoll)(THIS_ float yaw, float pitch, float roll);
    STDMETHOD(RotateYawPitchRollLocal)(THIS_ float yaw, float pitch, float roll);
    STDMETHOD(Scale)(THIS_ float x, float y, float z);
    STDMETHOD(ScaleLocal)(THIS_ float x, float y, float z);
    STDMETHOD(Translate)(THIS_ float x, float y, float z );
    STDMETHOD(TranslateLocal)(THIS_ float x, float y, float z);
    STDMETHOD_(D3DXMATRIX*, GetTop)(THIS);

};

#endif //__CSTACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\math\d3dxmath.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dxmath.cpp
//  Content:
//
//////////////////////////////////////////////////////////////////////////////

#include "pchmath.h"
#define EPSILON 0.00001f



//
// WithinEpsilon - Are two values within EPSILON of each other?
//

static inline BOOL
WithinEpsilon(float a, float b)
{
    float f = a - b;
    return -EPSILON <= f && f <= EPSILON;
}


//
// sincosf - Compute the sin and cos of an angle at the same time
//

static inline void
sincosf(float angle, float *psin, float *pcos)
{
#ifdef _X86_
#define fsincos __asm _emit 0xd9 __asm _emit 0xfb
    __asm {
        mov eax, psin
        mov edx, pcos
        fld angle
        fsincos
        fstp DWORD ptr [edx]
        fstp DWORD ptr [eax]
    }
#undef fsincos
#else //!_X86_
    *psin = sinf(angle);
    *pcos = cosf(angle);
#endif //!_X86_
}


//--------------------------
// 2D Vector
//--------------------------

D3DXVECTOR2* WINAPI D3DXVec2Normalize
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV )
{
#if DBG
    if(!pOut || !pV)
        return NULL;
#endif

    float f = D3DXVec2LengthSq(pV);

    if(WithinEpsilon(f, 1.0f))
    {
        if(pOut != pV)
            *pOut = *pV;
    }
    else if(f > EPSILON * EPSILON)
    {
        *pOut = *pV / sqrtf(f);
    }
    else
    {
        pOut->x = 0.0f;
        pOut->y = 0.0f;
    }

    return pOut;
}

D3DXVECTOR2* WINAPI D3DXVec2Hermite
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pT1,
      const D3DXVECTOR2 *pV2, const D3DXVECTOR2 *pT2, float s )
{
#if DBG
    if(!pOut || !pV1 || !pT1 || !pV2 || !pT2)
        return NULL;
#endif

    float s2 = s * s;
    float s3 = s * s2;

    float sV1 = 2.0f * s3 - 3.0f * s2 + 1.0f;
    float sT1 = s3 - 2.0f * s2 + s;
    float sV2 = -2.0f * s3 + 3.0f * s2;
    float sT2 = s3 - s2;

    pOut->x = sV1 * pV1->x + sT1 * pT1->x + sV2 * pV2->x + sT2 * pT2->x;
    pOut->y = sV1 * pV1->y + sT1 * pT1->y + sV2 * pV2->y + sT2 * pT2->y;
    return pOut;
}

D3DXVECTOR2* WINAPI D3DXVec2CatmullRom
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV0, const D3DXVECTOR2 *pV1,
      const D3DXVECTOR2 *pV2, const D3DXVECTOR2 *pV3, float s )
{
#if DBG
    if(!pOut || !pV0 || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    float s2 = s * s;
    float s3 = s * s2;

    float sV0 = -s3 + s2 + s2 - s;
    float sV1 = 3.0f * s3 - 5.0f * s2 + 2.0f;
    float sV2 = -3.0f * s3 + 4.0f * s2 + s;
    float sV3 = s3 - s2;

    pOut->x = 0.5f * (sV0 * pV0->x + sV1 * pV1->x + sV2 * pV2->x + sV3 * pV3->x);
    pOut->y = 0.5f * (sV0 * pV0->y + sV1 * pV1->y + sV2 * pV2->y + sV3 * pV3->y);
    return pOut;
}

D3DXVECTOR2* WINAPI D3DXVec2BaryCentric
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2,
      D3DXVECTOR2 *pV3, float f, float g)
{
#if DBG
    if(!pOut || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    pOut->x = pV1->x + f * (pV2->x - pV1->x) + g * (pV3->x - pV1->x);
    pOut->y = pV1->y + f * (pV2->y - pV1->y) + g * (pV3->y - pV1->y);
    return pOut;
}

D3DXVECTOR4* WINAPI D3DXVec2Transform
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR2 *pV, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
#endif


#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pV]
        mov   edx, DWORD PTR [pM]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+0)*4] ; M00
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+2)*4] ; M02
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+1)*4] ; M01
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+3)*4] ; M03
        fxch  st(3)

        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+0)*4] ; M10
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+2)*4] ; M12
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+1)*4] ; M11
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+3)*4] ; M13
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fld   DWORD PTR [edx+(3*4+0)*4] ; M30
        faddp st(1), st
        fld   DWORD PTR [edx+(3*4+1)*4] ; M31
        faddp st(2), st
        fld   DWORD PTR [edx+(3*4+2)*4] ; M32
        faddp st(3), st
        fld   DWORD PTR [edx+(3*4+3)*4] ; M33
        faddp st(4), st

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]
        fstp  DWORD PTR [ecx+2*4]
        fstp  DWORD PTR [ecx+3*4]
    }

    return pOut;

#else // !_X86_
    D3DXVECTOR4 v;

    v.x = pV->x * pM->_11 + pV->y * pM->_21 + pM->_41;
    v.y = pV->x * pM->_12 + pV->y * pM->_22 + pM->_42;
    v.z = pV->x * pM->_13 + pV->y * pM->_23 + pM->_43;
    v.w = pV->x * pM->_14 + pV->y * pM->_24 + pM->_44;

    *pOut = v;
    return pOut;
#endif // !_X86_
}

D3DXVECTOR2* WINAPI D3DXVec2TransformCoord
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
#endif

    float w;

#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pV]
        mov   edx, DWORD PTR [pM]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+0)*4] ; M00
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+1)*4] ; M01
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+3)*4] ; M03
        fxch  st(2)

        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+0)*4] ; M10
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+1)*4] ; M11
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+3)*4] ; M13
        fxch  st(2)

        faddp st(3), st
        faddp st(3), st
        faddp st(3), st

        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+0)*4] ; M20
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+1)*4] ; M21
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+3)*4] ; M23
        fxch  st(2)

        faddp st(3), st
        faddp st(3), st
        faddp st(3), st

        fld   DWORD PTR [edx+(3*4+0)*4] ; M30
        faddp st(1), st
        fld   DWORD PTR [edx+(3*4+1)*4] ; M31
        faddp st(2), st
        fld   DWORD PTR [edx+(3*4+3)*4] ; M33
        faddp st(3), st

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]
        fstp  DWORD PTR [w]
    }

#else // !_X86_
    D3DXVECTOR4 v;

    v.x = pV->x * pM->_11 + pV->y * pM->_21 + pM->_41;
    v.y = pV->x * pM->_12 + pV->y * pM->_22 + pM->_42;
    w   = pV->x * pM->_14 + pV->y * pM->_24 + pM->_44;

    *pOut = *((D3DXVECTOR2 *) &v);
#endif // !_X86_

    if(!WithinEpsilon(w, 1.0f))
        *pOut /= w;

    return pOut;
}

D3DXVECTOR2* WINAPI D3DXVec2TransformNormal
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
#endif


#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pV]
        mov   edx, DWORD PTR [pM]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+0)*4] ; M00
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+1)*4] ; M01
        fxch  st(1)

        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+0)*4] ; M10
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+1)*4] ; M11
        fxch  st(1)

        faddp st(2), st
        faddp st(2), st

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]
    }

    return pOut;

#else // !_X86_
    D3DXVECTOR2 v;

    v.x = pV->x * pM->_11 + pV->y * pM->_21;
    v.y = pV->x * pM->_12 + pV->y * pM->_22;

    *pOut = v;
    return pOut;
#endif // !_X86_
}


//--------------------------
// 3D Vector
//--------------------------

D3DXVECTOR3* WINAPI D3DXVec3Normalize
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV )
{
#if DBG
    if(!pOut || !pV)
        return NULL;
#endif

    float f = D3DXVec3LengthSq(pV);

    if(WithinEpsilon(f, 1.0f))
    {
        if(pOut != pV)
            *pOut = *pV;
    }
    else if(f > EPSILON * EPSILON)
    {
        *pOut = *pV / sqrtf(f);
    }
    else
    {
        pOut->x = 0.0f;
        pOut->y = 0.0f;
        pOut->z = 0.0f;
    }

    return pOut;
}

D3DXVECTOR3* WINAPI D3DXVec3Hermite
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pT1,
      const D3DXVECTOR3 *pV2, const D3DXVECTOR3 *pT2, float s )
{
#if DBG
    if(!pOut || !pV1 || !pT1 || !pV2 || !pT2)
        return NULL;
#endif

    float s2 = s * s;
    float s3 = s * s2;

    float sV1 = 2.0f * s3 - 3.0f * s2 + 1.0f;
    float sT1 = s3 - 2.0f * s2 + s;
    float sV2 = -2.0f * s3 + 3.0f * s2;
    float sT2 = s3 - s2;

    pOut->x = sV1 * pV1->x + sT1 * pT1->x + sV2 * pV2->x + sT2 * pT2->x;
    pOut->y = sV1 * pV1->y + sT1 * pT1->y + sV2 * pV2->y + sT2 * pT2->y;
    pOut->z = sV1 * pV1->z + sT1 * pT1->z + sV2 * pV2->z + sT2 * pT2->z;
    return pOut;
}

D3DXVECTOR3* WINAPI D3DXVec3CatmullRom
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV0, const D3DXVECTOR3 *pV1,
      const D3DXVECTOR3 *pV2, const D3DXVECTOR3 *pV3, float s )
{
#if DBG
    if(!pOut || !pV0 || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    float s2 = s * s;
    float s3 = s * s2;

    float sV0 = -s3 + s2 + s2 - s;
    float sV1 = 3.0f * s3 - 5.0f * s2 + 2.0f;
    float sV2 = -3.0f * s3 + 4.0f * s2 + s;
    float sV3 = s3 - s2;

    pOut->x = 0.5f * (sV0 * pV0->x + sV1 * pV1->x + sV2 * pV2->x + sV3 * pV3->x);
    pOut->y = 0.5f * (sV0 * pV0->y + sV1 * pV1->y + sV2 * pV2->y + sV3 * pV3->y);
    pOut->z = 0.5f * (sV0 * pV0->z + sV1 * pV1->z + sV2 * pV2->z + sV3 * pV3->z);
    return pOut;
}

D3DXVECTOR3* WINAPI D3DXVec3BaryCentric
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2,
      const D3DXVECTOR3 *pV3, float f, float g)
{
#if DBG
    if(!pOut || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    pOut->x = pV1->x + f * (pV2->x - pV1->x) + g * (pV3->x - pV1->x);
    pOut->y = pV1->y + f * (pV2->y - pV1->y) + g * (pV3->y - pV1->y);
    pOut->z = pV1->z + f * (pV2->z - pV1->z) + g * (pV3->z - pV1->z);
    return pOut;
}

D3DXVECTOR4* WINAPI D3DXVec3Transform
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR3 *pV, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
#endif

#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pV]
        mov   edx, DWORD PTR [pM]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+0)*4] ; M00
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+2)*4] ; M02
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+1)*4] ; M01
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+3)*4] ; M03
        fxch  st(3)

        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+0)*4] ; M10
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+2)*4] ; M12
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+1)*4] ; M11
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+3)*4] ; M13
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+0)*4] ; M20
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+2)*4] ; M22
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+1)*4] ; M21
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+3)*4] ; M23
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fld   DWORD PTR [edx+(3*4+0)*4] ; M30
        faddp st(1), st
        fld   DWORD PTR [edx+(3*4+1)*4] ; M31
        faddp st(2), st
        fld   DWORD PTR [edx+(3*4+2)*4] ; M32
        faddp st(3), st
        fld   DWORD PTR [edx+(3*4+3)*4] ; M33
        faddp st(4), st

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]
        fstp  DWORD PTR [ecx+2*4]
        fstp  DWORD PTR [ecx+3*4]
    }

    return pOut;

#else // !_X86_
    D3DXVECTOR4 v;

    v.x = pV->x * pM->_11 + pV->y * pM->_21 + pV->z * pM->_31 + pM->_41;
    v.y = pV->x * pM->_12 + pV->y * pM->_22 + pV->z * pM->_32 + pM->_42;
    v.z = pV->x * pM->_13 + pV->y * pM->_23 + pV->z * pM->_33 + pM->_43;
    v.w = pV->x * pM->_14 + pV->y * pM->_24 + pV->z * pM->_34 + pM->_44;

    *pOut = v;
    return pOut;
#endif // !_X86_
}

D3DXVECTOR3* WINAPI D3DXVec3TransformCoord
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
#endif

    float w;

#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pV]
        mov   edx, DWORD PTR [pM]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+0)*4] ; M00
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+2)*4] ; M02
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+1)*4] ; M01
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+3)*4] ; M03
        fxch  st(3)

        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+0)*4] ; M10
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+2)*4] ; M12
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+1)*4] ; M11
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+3)*4] ; M13
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+0)*4] ; M20
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+2)*4] ; M22
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+1)*4] ; M21
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+3)*4] ; M23
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fld   DWORD PTR [edx+(3*4+0)*4] ; M30
        faddp st(1), st
        fld   DWORD PTR [edx+(3*4+1)*4] ; M31
        faddp st(2), st
        fld   DWORD PTR [edx+(3*4+2)*4] ; M32
        faddp st(3), st
        fld   DWORD PTR [edx+(3*4+3)*4] ; M33
        faddp st(4), st

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]
        fstp  DWORD PTR [ecx+2*4]
        fstp  DWORD PTR [w]
    }

#else // !_X86_
    D3DXVECTOR3 v;

    v.x = pV->x * pM->_11 + pV->y * pM->_21 + pV->z * pM->_31 + pM->_41;
    v.y = pV->x * pM->_12 + pV->y * pM->_22 + pV->z * pM->_32 + pM->_42;
    v.z = pV->x * pM->_13 + pV->y * pM->_23 + pV->z * pM->_33 + pM->_43;
    w   = pV->x * pM->_14 + pV->y * pM->_24 + pV->z * pM->_34 + pM->_44;

    *pOut = v;
#endif // !_X86_

    if(!WithinEpsilon(w, 1.0f))
        *pOut /= w;

    return pOut;
}

D3DXVECTOR3* WINAPI D3DXVec3TransformNormal
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
#endif

#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pV]
        mov   edx, DWORD PTR [pM]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+0)*4] ; M00
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+1)*4] ; M01
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+2)*4] ; M02
        fxch  st(2)

        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+0)*4] ; M10
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+1)*4] ; M11
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+2)*4] ; M12
        fxch  st(2)

        faddp st(3), st
        faddp st(3), st
        faddp st(3), st

        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+0)*4] ; M20
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+1)*4] ; M21
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+2)*4] ; M22
        fxch  st(2)

        faddp st(3), st
        faddp st(3), st
        faddp st(3), st

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]
        fstp  DWORD PTR [ecx+2*4]
    }

    return pOut;

#else // !_X86_
    D3DXVECTOR3 v;

    v.x = pV->x * pM->_11 + pV->y * pM->_21 + pV->z * pM->_31;
    v.y = pV->x * pM->_12 + pV->y * pM->_22 + pV->z * pM->_32;
    v.z = pV->x * pM->_13 + pV->y * pM->_23 + pV->z * pM->_33;

    *pOut = v;
    return pOut;
#endif // !_X86_
}


D3DXVECTOR3* WINAPI D3DXVec3Project
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV, const D3DVIEWPORT8 *pViewport,
      const D3DXMATRIX *pProjection, const D3DXMATRIX *pView, const D3DXMATRIX *pWorld)
{
#if DBG
    if(!pOut || !pV)
        return NULL;
#endif

    D3DXMATRIX mat;
    const D3DXMATRIX *pMat = &mat;

    switch(((NULL != pWorld) << 2) | ((NULL != pView) << 1) | (NULL != pProjection))
    {
    case 0: // ---
        D3DXMatrixIdentity(&mat);
        break;

    case 1: // --P
        pMat = pProjection;
        break;

    case 2: // -V-
        pMat = pView;
        break;

    case 3: // -VP
        D3DXMatrixMultiply(&mat, pView, pProjection);
        break;

    case 4: // W--
        pMat = pWorld;
        break;

    case 5: // W-P
        D3DXMatrixMultiply(&mat, pWorld, pProjection);
        break;

    case 6: // WV-
        D3DXMatrixMultiply(&mat, pWorld, pView);
        break;

    case 7: // WVP
        D3DXMatrixMultiply(&mat, pWorld, pView);
        D3DXMatrixMultiply(&mat, &mat, pProjection);
        break;
    }


    D3DXVec3TransformCoord(pOut, pV, pMat);

    if(pViewport)
    {
        pOut->x = ( pOut->x + 1.0f) * 0.5f * (float) pViewport->Width  + (float) pViewport->X;
        pOut->y = (-pOut->y + 1.0f) * 0.5f * (float) pViewport->Height + (float) pViewport->Y;
        pOut->z = pOut->z * (pViewport->MaxZ - pViewport->MinZ) +  pViewport->MinZ;
    }

    return pOut;
}


D3DXVECTOR3* WINAPI D3DXVec3Unproject
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV, const D3DVIEWPORT8 *pViewport,
      const D3DXMATRIX *pProjection, const D3DXMATRIX *pView, const D3DXMATRIX *pWorld)
{
#if DBG
    if(!pOut || !pV)
        return NULL;
#endif

    D3DXMATRIX mat;

    switch(((NULL != pWorld) << 2) | ((NULL != pView) << 1) | (NULL != pProjection))
    {
    case 0: // ---
        D3DXMatrixIdentity(&mat);
        break;

    case 1: // --P
        D3DXMatrixInverse(&mat, NULL, pProjection);
        break;

    case 2: // -V-
        D3DXMatrixInverse(&mat, NULL, pView);
        break;

    case 3: // -VP
        D3DXMatrixMultiply(&mat, pView, pProjection);
        D3DXMatrixInverse(&mat, NULL, &mat);
        break;

    case 4: // W--
        D3DXMatrixInverse(&mat, NULL, pWorld);
        break;

    case 5: // W-P
        D3DXMatrixMultiply(&mat, pWorld, pProjection);
        D3DXMatrixInverse(&mat, NULL, &mat);
        break;

    case 6: // WV-
        D3DXMatrixMultiply(&mat, pWorld, pView);
        D3DXMatrixInverse(&mat, NULL, &mat);
        break;

    case 7: // WVP
        D3DXMatrixMultiply(&mat, pWorld, pView);
        D3DXMatrixMultiply(&mat, &mat, pProjection);
        D3DXMatrixInverse(&mat, NULL, &mat);
        break;
    }


    if(pViewport)
    {
        pOut->x = (pV->x - (float) pViewport->X) / (float) pViewport->Width * 2.0f - 1.0f;
        pOut->y = -((pV->y - (float) pViewport->Y) / (float) pViewport->Height * 2.0f - 1.0f);
        pOut->z = (pV->z - pViewport->MinZ) / (pViewport->MaxZ - pViewport->MinZ);

        D3DXVec3TransformCoord(pOut, pOut, &mat);
    }
    else
    {
        D3DXVec3TransformCoord(pOut, pV, &mat);
    }

    return pOut;
}



//--------------------------
// 4D Vector
//--------------------------

D3DXVECTOR4* WINAPI D3DXVec4Cross
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2,
      const D3DXVECTOR4 *pV3)
{
#if DBG
    if(!pOut || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    D3DXVECTOR4 v;

    v.x = pV1->y * (pV2->z * pV3->w - pV3->z * pV2->w) -
          pV1->z * (pV2->y * pV3->w - pV3->y * pV2->w) +
          pV1->w * (pV2->y * pV3->z - pV3->y * pV2->z);

    v.y = pV1->x * (pV3->z * pV2->w - pV2->z * pV3->w) -
          pV1->z * (pV3->x * pV2->w - pV2->x * pV3->w) +
          pV1->w * (pV3->x * pV2->z - pV2->x * pV3->z);

    v.z = pV1->x * (pV2->y * pV3->w - pV3->y * pV2->w) -
          pV1->y * (pV2->x * pV3->w - pV3->x * pV2->w) +
          pV1->w * (pV2->x * pV3->y - pV3->x * pV2->y);

    v.w = pV1->x * (pV3->y * pV2->z - pV2->y * pV3->z) -
          pV1->y * (pV3->x * pV2->z - pV2->x * pV3->z) +
          pV1->z * (pV3->x * pV2->y - pV2->x * pV3->y);

    *pOut = v;
    return pOut;
}

D3DXVECTOR4* WINAPI D3DXVec4Normalize
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV )
{
#if DBG
    if(!pOut || !pV)
        return NULL;
#endif

    float f = D3DXVec4LengthSq(pV);

    if(WithinEpsilon(f, 1.0f))
    {
        if(pOut != pV)
            *pOut = *pV;
    }
    else if(f > EPSILON * EPSILON)
    {
        *pOut = *pV / sqrtf(f);
    }
    else
    {
        pOut->x = 0.0f;
        pOut->y = 0.0f;
        pOut->z = 0.0f;
        pOut->w = 0.0f;
    }

    return pOut;
}

D3DXVECTOR4* WINAPI D3DXVec4Hermite
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pT1,
      const D3DXVECTOR4 *pV2, const D3DXVECTOR4 *pT2, float s )
{
#if DBG
    if(!pOut || !pV1 || !pT1 || !pV2 || !pT2)
        return NULL;
#endif

    float s2 = s * s;
    float s3 = s * s2;

    float sV1 = 2.0f * s3 - 3.0f * s2 + 1.0f;
    float sT1 = s3 - 2.0f * s2 + s;
    float sV2 = -2.0f * s3 + 3.0f * s2;
    float sT2 = s3 - s2;

    pOut->x = sV1 * pV1->x + sT1 * pT1->x + sV2 * pV2->x + sT2 * pT2->x;
    pOut->y = sV1 * pV1->y + sT1 * pT1->y + sV2 * pV2->y + sT2 * pT2->y;
    pOut->z = sV1 * pV1->z + sT1 * pT1->z + sV2 * pV2->z + sT2 * pT2->z;
    pOut->w = sV1 * pV1->w + sT1 * pT1->w + sV2 * pV2->w + sT2 * pT2->w;
    return pOut;
}

D3DXVECTOR4* WINAPI D3DXVec4CatmullRom
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV0, const D3DXVECTOR4 *pV1,
      const D3DXVECTOR4 *pV2, const D3DXVECTOR4 *pV3, float s )
{
#if DBG
    if(!pOut || !pV0 || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    float s2 = s * s;
    float s3 = s * s2;

    float sV0 = -s3 + s2 + s2 - s;
    float sV1 = 3.0f * s3 - 5.0f * s2 + 2.0f;
    float sV2 = -3.0f * s3 + 4.0f * s2 + s;
    float sV3 = s3 - s2;

    pOut->x = 0.5f * (sV0 * pV0->x + sV1 * pV1->x + sV2 * pV2->x + sV3 * pV3->x);
    pOut->y = 0.5f * (sV0 * pV0->y + sV1 * pV1->y + sV2 * pV2->y + sV3 * pV3->y);
    pOut->z = 0.5f * (sV0 * pV0->z + sV1 * pV1->z + sV2 * pV2->z + sV3 * pV3->z);
    pOut->w = 0.5f * (sV0 * pV0->w + sV1 * pV1->w + sV2 * pV2->w + sV3 * pV3->w);
    return pOut;
}

D3DXVECTOR4* WINAPI D3DXVec4BaryCentric
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2,
      const D3DXVECTOR4 *pV3, float f, float g)
{
#if DBG
    if(!pOut || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    pOut->x = pV1->x + f * (pV2->x - pV1->x) + g * (pV3->x - pV1->x);
    pOut->y = pV1->y + f * (pV2->y - pV1->y) + g * (pV3->y - pV1->y);
    pOut->z = pV1->z + f * (pV2->z - pV1->z) + g * (pV3->z - pV1->z);
    pOut->w = pV1->w + f * (pV2->w - pV1->w) + g * (pV3->w - pV1->w);
    return pOut;
}

D3DXVECTOR4* WINAPI D3DXVec4Transform
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
#endif

#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pV]
        mov   edx, DWORD PTR [pM]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+0)*4] ; M00
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+2)*4] ; M02
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+1)*4] ; M01
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+3)*4] ; M03
        fxch  st(3)

        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+0)*4] ; M10
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+2)*4] ; M12
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+1)*4] ; M11
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+3)*4] ; M13
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+0)*4] ; M20
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+2)*4] ; M22
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+1)*4] ; M21
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+3)*4] ; M23
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fld   DWORD PTR [eax+3*4]       ; W
        fmul  DWORD PTR [edx+(3*4+0)*4] ; M30
        fld   DWORD PTR [eax+3*4]       ; W
        fmul  DWORD PTR [edx+(3*4+2)*4] ; M32
        fld   DWORD PTR [eax+3*4]       ; W
        fmul  DWORD PTR [edx+(3*4+1)*4] ; M31
        fld   DWORD PTR [eax+3*4]       ; W
        fmul  DWORD PTR [edx+(3*4+3)*4] ; M33
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]
        fstp  DWORD PTR [ecx+2*4]
        fstp  DWORD PTR [ecx+3*4]
    }

    return pOut;

#else // !_X86_
    D3DXVECTOR4 v;

    v.x = pV->x * pM->_11 + pV->y * pM->_21 + pV->z * pM->_31 + pV->w * pM->_41;
    v.y = pV->x * pM->_12 + pV->y * pM->_22 + pV->z * pM->_32 + pV->w * pM->_42;
    v.z = pV->x * pM->_13 + pV->y * pM->_23 + pV->z * pM->_33 + pV->w * pM->_43;
    v.w = pV->x * pM->_14 + pV->y * pM->_24 + pV->z * pM->_34 + pV->w * pM->_44;

    *pOut = v;
    return pOut;
#endif // !_X86_
}


//--------------------------
// 4D Matrix
//--------------------------

float WINAPI D3DXMatrixfDeterminant
    ( const D3DXMATRIX *pM )
{
#if DBG
    if(!pM)
        return 0.0f;
#endif

    return (pM->_11 * (pM->_22 * (pM->_33 * pM->_44 - pM->_43 * pM->_34) -
                       pM->_23 * (pM->_32 * pM->_44 - pM->_42 * pM->_34) +
                       pM->_24 * (pM->_32 * pM->_43 - pM->_42 * pM->_33)))

         - (pM->_12 * (pM->_21 * (pM->_33 * pM->_44 - pM->_43 * pM->_34) -
                       pM->_23 * (pM->_31 * pM->_44 - pM->_41 * pM->_34) +
                       pM->_24 * (pM->_31 * pM->_43 - pM->_41 * pM->_33)))

         + (pM->_13 * (pM->_21 * (pM->_32 * pM->_44 - pM->_42 * pM->_34) -
                       pM->_22 * (pM->_31 * pM->_44 - pM->_41 * pM->_34) +
                       pM->_24 * (pM->_31 * pM->_42 - pM->_41 * pM->_32)))

         - (pM->_14 * (pM->_21 * (pM->_32 * pM->_43 - pM->_42 * pM->_33) -
                       pM->_22 * (pM->_31 * pM->_43 - pM->_41 * pM->_33) +
                       pM->_23 * (pM->_31 * pM->_42 - pM->_41 * pM->_32)));
}


D3DXMATRIX* WINAPI D3DXMatrixMultiply
    ( D3DXMATRIX *pOut, const D3DXMATRIX *pM1, const D3DXMATRIX *pM2 )
{
#if DBG
    if(!pOut || !pM1 || !pM2)
        return NULL;
#endif

#ifdef _X86_
#define MAT(m,a,b) DWORD PTR [(m)+(a)*4+(b)*4]

    D3DXMATRIX Out;

    if(pM2 != pOut)
        goto LRowByColumn;
    if(pM1 != pOut)
        goto LColumnByRow;

    Out = *pM2;
    pM2 = &Out;
    goto LRowByColumn;


LRowByColumn:
    __asm {
        mov ebx, DWORD PTR[pOut]    // result
        mov ecx, DWORD PTR[pM1]     // a
        mov edx, DWORD PTR[pM2]     // b
        mov edi, -4

    LLoopRow:
        mov esi, -4

        fld MAT(ecx, 0, 0)          // a0
        fld MAT(ecx, 0, 1)          // a1
        fld MAT(ecx, 0, 2)          // a2
        fld MAT(ecx, 0, 3)          // a3

    LLoopColumn:
        fld st(3)                   // a0
        fmul MAT(edx, esi, 1*4)     // a0*b0
        fld st(3)                   // a1
        fmul MAT(edx, esi, 2*4)     // a1*b1
        fld st(3)                   // a2
        fmul MAT(edx, esi, 3*4)     // a2*b2
        fld st(3)                   // a3
        fmul MAT(edx, esi, 4*4)     // a3*b3

        fxch st(3)
        faddp st(1), st             // a2*b2+a0*b0
        fxch st(2)
        faddp st(1), st             // a3*b3+a1*b1
        faddp st(1), st             // a3*b3+a1*b1+a2*b2+a0*b0
        fstp MAT(ebx, esi, 4)

        inc esi
        jnz LLoopColumn

        ffree st(3)
        ffree st(2)
        ffree st(1)
        ffree st(0)

        lea ecx, MAT(ecx, 0, 4)
        lea ebx, MAT(ebx, 0, 4)

        inc edi
        jnz LLoopRow
    }

    return pOut;


LColumnByRow:
    __asm {
        mov ebx, DWORD PTR[pOut]    // result
        mov ecx, DWORD PTR[pM1]     // a
        mov edx, DWORD PTR[pM2]     // b
        mov edi, -4

    LLoopColumn2:
        mov esi, -16

        fld MAT(edx, edi, 1*4);     // b0
        fld MAT(edx, edi, 2*4);     // b1
        fld MAT(edx, edi, 3*4);     // b2
        fld MAT(edx, edi, 4*4);     // b3

    LLoopRow2:
        fld st(3)                   // b0
        fmul MAT(ecx, esi, 0+16)    // a0*b0
        fld st(3)                   // b1
        fmul MAT(ecx, esi, 1+16)    // a1*b1
        fld st(3)                   // b2
        fmul MAT(ecx, esi, 2+16)    // a2*b2
        fld st(3)                   // b3
        fmul MAT(ecx, esi, 3+16)    // a3*b3

        fxch st(3)
        faddp st(1), st             // a2*b2+a0*b0
        fxch st(2)
        faddp st(1), st             // a3*b3+a1*b1
        faddp st(1), st             // a3*b3+a1*b1+a2*b2+a0*b0
        fstp MAT(ebx, esi, 0+16)

        add esi, 4
        jnz LLoopRow2

        ffree st(3)
        ffree st(2)
        ffree st(1)
        ffree st(0)

        lea ebx, MAT(ebx, 0, 1)
        inc edi
        jnz LLoopColumn2
    }

    return pOut;
#undef MAT
#else //!_X86_
    D3DXMATRIX Out;
    D3DXMATRIX *pM = (pOut == pM1 || pOut == pM2) ? &Out : pOut;

    pM->_11 = pM1->_11 * pM2->_11 + pM1->_12 * pM2->_21 + pM1->_13 * pM2->_31 + pM1->_14 * pM2->_41;
    pM->_12 = pM1->_11 * pM2->_12 + pM1->_12 * pM2->_22 + pM1->_13 * pM2->_32 + pM1->_14 * pM2->_42;
    pM->_13 = pM1->_11 * pM2->_13 + pM1->_12 * pM2->_23 + pM1->_13 * pM2->_33 + pM1->_14 * pM2->_43;
    pM->_14 = pM1->_11 * pM2->_14 + pM1->_12 * pM2->_24 + pM1->_13 * pM2->_34 + pM1->_14 * pM2->_44;

    pM->_21 = pM1->_21 * pM2->_11 + pM1->_22 * pM2->_21 + pM1->_23 * pM2->_31 + pM1->_24 * pM2->_41;
    pM->_22 = pM1->_21 * pM2->_12 + pM1->_22 * pM2->_22 + pM1->_23 * pM2->_32 + pM1->_24 * pM2->_42;
    pM->_23 = pM1->_21 * pM2->_13 + pM1->_22 * pM2->_23 + pM1->_23 * pM2->_33 + pM1->_24 * pM2->_43;
    pM->_24 = pM1->_21 * pM2->_14 + pM1->_22 * pM2->_24 + pM1->_23 * pM2->_34 + pM1->_24 * pM2->_44;

    pM->_31 = pM1->_31 * pM2->_11 + pM1->_32 * pM2->_21 + pM1->_33 * pM2->_31 + pM1->_34 * pM2->_41;
    pM->_32 = pM1->_31 * pM2->_12 + pM1->_32 * pM2->_22 + pM1->_33 * pM2->_32 + pM1->_34 * pM2->_42;
    pM->_33 = pM1->_31 * pM2->_13 + pM1->_32 * pM2->_23 + pM1->_33 * pM2->_33 + pM1->_34 * pM2->_43;
    pM->_34 = pM1->_31 * pM2->_14 + pM1->_32 * pM2->_24 + pM1->_33 * pM2->_34 + pM1->_34 * pM2->_44;

    pM->_41 = pM1->_41 * pM2->_11 + pM1->_42 * pM2->_21 + pM1->_43 * pM2->_31 + pM1->_44 * pM2->_41;
    pM->_42 = pM1->_41 * pM2->_12 + pM1->_42 * pM2->_22 + pM1->_43 * pM2->_32 + pM1->_44 * pM2->_42;
    pM->_43 = pM1->_41 * pM2->_13 + pM1->_42 * pM2->_23 + pM1->_43 * pM2->_33 + pM1->_44 * pM2->_43;
    pM->_44 = pM1->_41 * pM2->_14 + pM1->_42 * pM2->_24 + pM1->_43 * pM2->_34 + pM1->_44 * pM2->_44;

    if(pM != pOut)
        *pOut = *pM;

    return pOut;
#endif //!_X86_
}

D3DXMATRIX* WINAPI D3DXMatrixTranspose
    ( D3DXMATRIX *pOut, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pM)
        return NULL;
#endif

    float f;

    f = pM->_12; pOut->_12 = pM->_21; pOut->_21 = f;
    f = pM->_13; pOut->_13 = pM->_31; pOut->_31 = f;
    f = pM->_14; pOut->_14 = pM->_41; pOut->_41 = f;
    f = pM->_23; pOut->_23 = pM->_32; pOut->_32 = f;
    f = pM->_24; pOut->_24 = pM->_42; pOut->_42 = f;
    f = pM->_34; pOut->_34 = pM->_43; pOut->_43 = f;

    if(pOut != pM)
    {
        pOut->_11 = pM->_11;
        pOut->_22 = pM->_22;
        pOut->_33 = pM->_33;
        pOut->_44 = pM->_44;
    }

    return pOut;
}

D3DXMATRIX* WINAPI D3DXMatrixInverse
    ( D3DXMATRIX *pOut, float *pfDeterminant, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pM)
        return NULL;
#endif

    // XXXlorenmcq - The code was designed to work on a processor with more
    //  than 4 general-purpose registers.  Is there a more optimal way of
    //  doing this on X86?

    float fX00, fX01, fX02;
    float fX10, fX11, fX12;
    float fX20, fX21, fX22;
    float fX30, fX31, fX32;
    float fY01, fY02, fY03, fY12, fY13, fY23;
    float fZ02, fZ03, fZ12, fZ13, fZ22, fZ23, fZ32, fZ33;

#define fX03 fX01
#define fX13 fX11
#define fX23 fX21
#define fX33 fX31
#define fZ00 fX02
#define fZ10 fX12
#define fZ20 fX22
#define fZ30 fX32
#define fZ01 fX03
#define fZ11 fX13
#define fZ21 fX23
#define fZ31 fX33
#define fDet fY01
#define fRcp fY02

    // read 1st two columns of matrix
    fX00 = pM->_11;
    fX01 = pM->_12;
    fX10 = pM->_21;
    fX11 = pM->_22;
    fX20 = pM->_31;
    fX21 = pM->_32;
    fX30 = pM->_41;
    fX31 = pM->_42;

    // compute all six 2x2 determinants of 1st two columns
    fY01 = fX00 * fX11 - fX10 * fX01;
    fY02 = fX00 * fX21 - fX20 * fX01;
    fY03 = fX00 * fX31 - fX30 * fX01;
    fY12 = fX10 * fX21 - fX20 * fX11;
    fY13 = fX10 * fX31 - fX30 * fX11;
    fY23 = fX20 * fX31 - fX30 * fX21;

    // read 2nd two columns of matrix
    fX02 = pM->_13;
    fX03 = pM->_14;
    fX12 = pM->_23;
    fX13 = pM->_24;
    fX22 = pM->_33;
    fX23 = pM->_34;
    fX32 = pM->_43;
    fX33 = pM->_44;

    // compute all 3x3 cofactors for 2nd two columns
    fZ33 = fX02 * fY12 - fX12 * fY02 + fX22 * fY01;
    fZ23 = fX12 * fY03 - fX32 * fY01 - fX02 * fY13;
    fZ13 = fX02 * fY23 - fX22 * fY03 + fX32 * fY02;
    fZ03 = fX22 * fY13 - fX32 * fY12 - fX12 * fY23;
    fZ32 = fX13 * fY02 - fX23 * fY01 - fX03 * fY12;
    fZ22 = fX03 * fY13 - fX13 * fY03 + fX33 * fY01;
    fZ12 = fX23 * fY03 - fX33 * fY02 - fX03 * fY23;
    fZ02 = fX13 * fY23 - fX23 * fY13 + fX33 * fY12;

    // compute all six 2x2 determinants of 2nd two columns
    fY01 = fX02 * fX13 - fX12 * fX03;
    fY02 = fX02 * fX23 - fX22 * fX03;
    fY03 = fX02 * fX33 - fX32 * fX03;
    fY12 = fX12 * fX23 - fX22 * fX13;
    fY13 = fX12 * fX33 - fX32 * fX13;
    fY23 = fX22 * fX33 - fX32 * fX23;

    // read 1st two columns of matrix
    fX00 = pM->_11;
    fX01 = pM->_12;
    fX10 = pM->_21;
    fX11 = pM->_22;
    fX20 = pM->_31;
    fX21 = pM->_32;
    fX30 = pM->_41;
    fX31 = pM->_42;

    // compute all 3x3 cofactors for 1st two columns
    fZ30 = fX11 * fY02 - fX21 * fY01 - fX01 * fY12;
    fZ20 = fX01 * fY13 - fX11 * fY03 + fX31 * fY01;
    fZ10 = fX21 * fY03 - fX31 * fY02 - fX01 * fY23;
    fZ00 = fX11 * fY23 - fX21 * fY13 + fX31 * fY12;
    fZ31 = fX00 * fY12 - fX10 * fY02 + fX20 * fY01;
    fZ21 = fX10 * fY03 - fX30 * fY01 - fX00 * fY13;
    fZ11 = fX00 * fY23 - fX20 * fY03 + fX30 * fY02;
    fZ01 = fX20 * fY13 - fX30 * fY12 - fX10 * fY23;

    // compute 4x4 determinant & its reciprocal
    fDet = fX30 * fZ30 + fX20 * fZ20 + fX10 * fZ10 + fX00 * fZ00;

    if(pfDeterminant)
        *pfDeterminant = fDet;

    fRcp = 1.0f / fDet;

    if(!_finite(fRcp))
        return NULL;


    // multiply all 3x3 cofactors by reciprocal & transpose
    pOut->_11 = fZ00 * fRcp;
    pOut->_12 = fZ10 * fRcp;
    pOut->_13 = fZ20 * fRcp;
    pOut->_14 = fZ30 * fRcp;
    pOut->_21 = fZ01 * fRcp;
    pOut->_22 = fZ11 * fRcp;
    pOut->_23 = fZ21 * fRcp;
    pOut->_24 = fZ31 * fRcp;
    pOut->_31 = fZ02 * fRcp;
    pOut->_32 = fZ12 * fRcp;
    pOut->_33 = fZ22 * fRcp;
    pOut->_34 = fZ32 * fRcp;
    pOut->_41 = fZ03 * fRcp;
    pOut->_42 = fZ13 * fRcp;
    pOut->_43 = fZ23 * fRcp;
    pOut->_44 = fZ33 * fRcp;

    return pOut;
}



D3DXMATRIX* WINAPI D3DXMatrixScaling
    ( D3DXMATRIX *pOut, float sx, float sy, float sz )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    pOut->_12 = pOut->_13 = pOut->_14 =
    pOut->_21 = pOut->_23 = pOut->_24 =
    pOut->_31 = pOut->_32 = pOut->_34 =
    pOut->_41 = pOut->_42 = pOut->_43 = 0.0f;

    pOut->_11 = sx;
    pOut->_22 = sy;
    pOut->_33 = sz;
    pOut->_44 = 1.0f;
    return pOut;
}

D3DXMATRIX* WINAPI D3DXMatrixTranslation
    ( D3DXMATRIX *pOut, float x, float y, float z )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    pOut->_12 = pOut->_13 = pOut->_14 =
    pOut->_21 = pOut->_23 = pOut->_24 =
    pOut->_31 = pOut->_32 = pOut->_34 = 0.0f;

    pOut->_11 = pOut->_22 = pOut->_33 = pOut->_44 = 1.0f;

    pOut->_41 = x;
    pOut->_42 = y;
    pOut->_43 = z;
    return pOut;
}


D3DXMATRIX* WINAPI D3DXMatrixRotationX
    ( D3DXMATRIX *pOut, float angle )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float s, c;
    sincosf(angle, &s, &c);

    pOut->_11 = 1.0f; pOut->_12 = 0.0f; pOut->_13 = 0.0f; pOut->_14 = 0.0f;
    pOut->_21 = 0.0f; pOut->_22 =    c; pOut->_23 =    s; pOut->_24 = 0.0f;
    pOut->_31 = 0.0f; pOut->_32 =   -s; pOut->_33 =    c; pOut->_34 = 0.0f;
    pOut->_41 = 0.0f; pOut->_42 = 0.0f; pOut->_43 = 0.0f; pOut->_44 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI D3DXMatrixRotationY
    ( D3DXMATRIX *pOut, float angle )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float s, c;
    sincosf(angle, &s, &c);

    pOut->_11 =    c; pOut->_12 = 0.0f; pOut->_13 =   -s; pOut->_14 = 0.0f;
    pOut->_21 = 0.0f; pOut->_22 = 1.0f; pOut->_23 = 0.0f; pOut->_24 = 0.0f;
    pOut->_31 =    s; pOut->_32 = 0.0f; pOut->_33 =    c; pOut->_34 = 0.0f;
    pOut->_41 = 0.0f; pOut->_42 = 0.0f; pOut->_43 = 0.0f; pOut->_44 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI D3DXMatrixRotationZ
    ( D3DXMATRIX *pOut, float angle )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float s, c;
    sincosf(angle, &s, &c);

    pOut->_11 =    c; pOut->_12 =    s; pOut->_13 = 0.0f; pOut->_14 = 0.0f;
    pOut->_21 =   -s; pOut->_22 =    c; pOut->_23 = 0.0f; pOut->_24 = 0.0f;
    pOut->_31 = 0.0f; pOut->_32 = 0.0f; pOut->_33 = 1.0f; pOut->_34 = 0.0f;
    pOut->_41 = 0.0f; pOut->_42 = 0.0f; pOut->_43 = 0.0f; pOut->_44 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI D3DXMatrixRotationAxis
    ( D3DXMATRIX *pOut, const D3DXVECTOR3 *pV, float angle )
{
#if DBG
    if(!pOut || !pV)
        return NULL;
#endif

    float s, c;
    sincosf(angle, &s, &c);
    float c1 = 1 - c;

    D3DXVECTOR3 v = *pV;
    D3DXVec3Normalize(&v, &v);

    float xyc1 = v.x * v.y * c1;
    float yzc1 = v.y * v.z * c1;
    float zxc1 = v.z * v.x * c1;

    pOut->_11 = v.x * v.x * c1 + c;
    pOut->_12 = xyc1 + v.z * s;
    pOut->_13 = zxc1 - v.y * s;
    pOut->_14 = 0.0f;

    pOut->_21 = xyc1 - v.z * s;
    pOut->_22 = v.y * v.y * c1 + c;
    pOut->_23 = yzc1 + v.x * s;
    pOut->_24 = 0.0f;

    pOut->_31 = zxc1 + v.y * s;
    pOut->_32 = yzc1 - v.x * s;
    pOut->_33 = v.z * v.z * c1 + c;
    pOut->_34 = 0.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = 0.0f;
    pOut->_44 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI D3DXMatrixRotationQuaternion
    ( D3DXMATRIX *pOut, const D3DXQUATERNION *pQ)
{
#if DBG
    if(!pOut || !pQ)
        return NULL;
#endif

    float x2 = pQ->x + pQ->x;
    float y2 = pQ->y + pQ->y;
    float z2 = pQ->z + pQ->z;

    float wx2 = pQ->w * x2;
    float wy2 = pQ->w * y2;
    float wz2 = pQ->w * z2;
    float xx2 = pQ->x * x2;
    float xy2 = pQ->x * y2;
    float xz2 = pQ->x * z2;
    float yy2 = pQ->y * y2;
    float yz2 = pQ->y * z2;
    float zz2 = pQ->z * z2;

    pOut->_11 = 1.0f - yy2 - zz2;
    pOut->_12 = xy2 + wz2;
    pOut->_13 = xz2 - wy2;
    pOut->_14 = 0.0f;

    pOut->_21 = xy2 - wz2;
    pOut->_22 = 1.0f - xx2 - zz2;
    pOut->_23 = yz2 + wx2;
    pOut->_24 = 0.0f;

    pOut->_31 = xz2 + wy2;
    pOut->_32 = yz2 - wx2;
    pOut->_33 = 1.0f - xx2 - yy2;
    pOut->_34 = 0.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = 0.0f;
    pOut->_44 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI D3DXMatrixRotationYawPitchRoll
    ( D3DXMATRIX *pOut, float yaw, float pitch, float roll )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    D3DXQUATERNION q;

    D3DXQuaternionRotationYawPitchRoll(&q, yaw, pitch, roll);
    D3DXMatrixRotationQuaternion(pOut, &q);

    return pOut;
}


D3DXMATRIX* WINAPI D3DXMatrixTransformation
    ( D3DXMATRIX *pOut, const D3DXVECTOR3 *pScalingCenter,
      const D3DXQUATERNION *pScalingRotation, const D3DXVECTOR3 *pScaling,
      const D3DXVECTOR3 *pRotationCenter, const D3DXQUATERNION *pRotation,
      const D3DXVECTOR3 *pTranslation)
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    D3DXMATRIX matS, matR, matRI;

    if (pScaling)
    {
        if (pScalingRotation)
        {
            matS._12 = matS._13 = matS._14 =
            matS._21 = matS._23 = matS._24 =
            matS._31 = matS._32 = matS._34 =
            matS._41 = matS._42 = matS._43 = 0.0f;

            matS._11 = pScaling->x;
            matS._22 = pScaling->y;
            matS._33 = pScaling->z;
            matS._44 = 1.0f;

            D3DXMatrixRotationQuaternion(&matR, pScalingRotation);


            if (pScalingCenter)
            {
                // SC-1, SR-1, S, SR, SC
                D3DXMatrixTranspose(&matRI, &matR);
                D3DXMatrixIdentity(pOut);

                pOut->_41 -= pScalingCenter->x;
                pOut->_42 -= pScalingCenter->y;
                pOut->_43 -= pScalingCenter->z;

                D3DXMatrixMultiply(pOut, pOut, &matRI);
                D3DXMatrixMultiply(pOut, pOut, &matS);
                D3DXMatrixMultiply(pOut, pOut, &matR);

                pOut->_41 += pScalingCenter->x;
                pOut->_42 += pScalingCenter->y;
                pOut->_43 += pScalingCenter->z;
            }
            else
            {
                // SR-1, S, SR
                D3DXMatrixTranspose(pOut, &matR);
                D3DXMatrixMultiply(pOut, pOut, &matS);
                D3DXMatrixMultiply(pOut, pOut, &matR);
            }
        }
        else
        {
            // S
            pOut->_12 = pOut->_13 = pOut->_14 =
            pOut->_21 = pOut->_23 = pOut->_24 =
            pOut->_31 = pOut->_32 = pOut->_34 =
            pOut->_41 = pOut->_42 = pOut->_43 = 0.0f;

            pOut->_11 = pScaling->x;
            pOut->_22 = pScaling->y;
            pOut->_33 = pScaling->z;
            pOut->_44 = 1.0f;
        }

    }
    else
    {
        D3DXMatrixIdentity(pOut);
    }

    if (pRotation)
    {
        D3DXMatrixRotationQuaternion(&matR, pRotation);

        if (pRotationCenter)
        {
            // RC-1, R, RC
            pOut->_41 -= pRotationCenter->x;
            pOut->_42 -= pRotationCenter->y;
            pOut->_43 -= pRotationCenter->z;

            D3DXMatrixMultiply(pOut, pOut, &matR);

            pOut->_41 += pRotationCenter->x;
            pOut->_42 += pRotationCenter->y;
            pOut->_43 += pRotationCenter->z;
        }
        else
        {
            // R
            D3DXMatrixMultiply(pOut, pOut, &matR);
        }
    }

    if (pTranslation)
    {
        // T
        pOut->_41 += pTranslation->x;
        pOut->_42 += pTranslation->y;
        pOut->_43 += pTranslation->z;
    }

    return pOut;
}

D3DXMATRIX* WINAPI D3DXMatrixAffineTransformation
    ( D3DXMATRIX *pOut, float Scaling, const D3DXVECTOR3 *pRotationCenter,
      const D3DXQUATERNION *pRotation, const D3DXVECTOR3 *pTranslation)
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    // S
    pOut->_12 = pOut->_13 = pOut->_14 =
    pOut->_21 = pOut->_23 = pOut->_24 =
    pOut->_31 = pOut->_32 = pOut->_34 =
    pOut->_41 = pOut->_42 = pOut->_43 = 0.0f;

    pOut->_11 = Scaling;
    pOut->_22 = Scaling;
    pOut->_33 = Scaling;
    pOut->_44 = 1.0f;


    if (pRotation)
    {
        D3DXMATRIX matR;
        D3DXMatrixRotationQuaternion(&matR, pRotation);

        if (pRotationCenter)
        {
            // RC-1, R, RC
            pOut->_41 -= pRotationCenter->x;
            pOut->_42 -= pRotationCenter->y;
            pOut->_43 -= pRotationCenter->z;

            D3DXMatrixMultiply(pOut, pOut, &matR);

            pOut->_41 += pRotationCenter->x;
            pOut->_42 += pRotationCenter->y;
            pOut->_43 += pRotationCenter->z;
        }
        else
        {
            // R
            D3DXMatrixMultiply(pOut, pOut, &matR);
        }
    }


    if (pTranslation)
    {
        // T
        pOut->_41 += pTranslation->x;
        pOut->_42 += pTranslation->y;
        pOut->_43 += pTranslation->z;
    }

    return pOut;
}


D3DXMATRIX* WINAPI D3DXMatrixLookAtRH
    ( D3DXMATRIX *pOut, const D3DXVECTOR3 *pEye, const D3DXVECTOR3 *pAt,
      const D3DXVECTOR3 *pUp )
{
#if DBG
    if(!pOut || !pEye || !pAt || !pUp)
        return NULL;
#endif

    D3DXVECTOR3 XAxis, YAxis, ZAxis;

    // Compute direction of gaze. (-Z)
    D3DXVec3Subtract(&ZAxis, pEye, pAt);
    D3DXVec3Normalize(&ZAxis, &ZAxis);

    // Compute orthogonal axes from cross product of gaze and pUp vector.
    D3DXVec3Cross(&XAxis, pUp, &ZAxis);
    D3DXVec3Normalize(&XAxis, &XAxis);
    D3DXVec3Cross(&YAxis, &ZAxis, &XAxis);

    // Set rotation and translate by pEye
    pOut->_11 = XAxis.x;
    pOut->_21 = XAxis.y;
    pOut->_31 = XAxis.z;
    pOut->_41 = -D3DXVec3Dot(&XAxis, pEye);

    pOut->_12 = YAxis.x;
    pOut->_22 = YAxis.y;
    pOut->_32 = YAxis.z;
    pOut->_42 = -D3DXVec3Dot(&YAxis, pEye);

    pOut->_13 = ZAxis.x;
    pOut->_23 = ZAxis.y;
    pOut->_33 = ZAxis.z;
    pOut->_43 = -D3DXVec3Dot(&ZAxis, pEye);

    pOut->_14 = 0.0f;
    pOut->_24 = 0.0f;
    pOut->_34 = 0.0f;
    pOut->_44 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI D3DXMatrixLookAtLH
    ( D3DXMATRIX *pOut, const D3DXVECTOR3 *pEye, const D3DXVECTOR3 *pAt,
      const D3DXVECTOR3 *pUp )
{
#if DBG
    if(!pOut || !pEye || !pAt || !pUp)
        return NULL;
#endif

    D3DXVECTOR3 XAxis, YAxis, ZAxis;

    // Compute direction of gaze. (+Z)
    D3DXVec3Subtract(&ZAxis, pAt, pEye);
    D3DXVec3Normalize(&ZAxis, &ZAxis);

    // Compute orthogonal axes from cross product of gaze and pUp vector.
    D3DXVec3Cross(&XAxis, pUp, &ZAxis);
    D3DXVec3Normalize(&XAxis, &XAxis);
    D3DXVec3Cross(&YAxis, &ZAxis, &XAxis);

    // Set rotation and translate by pEye
    pOut->_11 = XAxis.x;
    pOut->_21 = XAxis.y;
    pOut->_31 = XAxis.z;
    pOut->_41 = -D3DXVec3Dot(&XAxis, pEye);

    pOut->_12 = YAxis.x;
    pOut->_22 = YAxis.y;
    pOut->_32 = YAxis.z;
    pOut->_42 = -D3DXVec3Dot(&YAxis, pEye);

    pOut->_13 = ZAxis.x;
    pOut->_23 = ZAxis.y;
    pOut->_33 = ZAxis.z;
    pOut->_43 = -D3DXVec3Dot(&ZAxis, pEye);

    pOut->_14 = 0.0f;
    pOut->_24 = 0.0f;
    pOut->_34 = 0.0f;
    pOut->_44 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI D3DXMatrixPerspectiveRH
    ( D3DXMATRIX *pOut, float w, float h, float zn, float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    pOut->_11 = 2.0f * zn / w;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = 2.0f * zn / h;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = 0.0f;
    pOut->_32 = 0.0f;
    pOut->_33 = zf / (zn - zf);
    pOut->_34 = -1.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = pOut->_33 * zn;
    pOut->_44 = 0.0f;

    return pOut;
}

D3DXMATRIX* WINAPI D3DXMatrixPerspectiveLH
    ( D3DXMATRIX *pOut, float w, float h, float zn, float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    pOut->_11 = 2.0f * zn / w;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = 2.0f * zn / h;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = 0.0f;
    pOut->_32 = 0.0f;
    pOut->_33 = zf / (zf - zn);
    pOut->_34 = 1.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = -pOut->_33 * zn;
    pOut->_44 = 0.0f;

    return pOut;
}

D3DXMATRIX* WINAPI D3DXMatrixPerspectiveFovRH
    ( D3DXMATRIX *pOut, float fovy, float aspect, float zn, float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float s, c;
    sincosf(0.5f * fovy, &s, &c);

    float h = c / s;
    float w = h / aspect;

    pOut->_11 = w;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = h;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = 0.0f;
    pOut->_32 = 0.0f;
    pOut->_33 = zf / (zn - zf);
    pOut->_34 = -1.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = pOut->_33 * zn;
    pOut->_44 = 0.0f;

    return pOut;
}

D3DXMATRIX* WINAPI D3DXMatrixPerspectiveFovLH
    ( D3DXMATRIX *pOut, float fovy, float aspect, float zn, float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float s, c;
    sincosf(0.5f * fovy, &s, &c);

    float h = c / s;
    float w = h / aspect;

    pOut->_11 = w;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = h;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = 0.0f;
    pOut->_32 = 0.0f;
    pOut->_33 = zf / (zf - zn);
    pOut->_34 = 1.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = -pOut->_33 * zn;
    pOut->_44 = 0.0f;

    return pOut;
}

D3DXMATRIX* WINAPI D3DXMatrixPerspectiveOffCenterRH
    ( D3DXMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float wInv = 1.0f / (r - l);
    float hInv = 1.0f / (t - b);

    pOut->_11 = 2.0f * zn * wInv;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = 2.0f * zn * hInv;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = (l + r) * wInv;
    pOut->_32 = (t + b) * hInv;
    pOut->_33 = zf / (zn - zf);
    pOut->_34 = -1.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = pOut->_33 * zn;
    pOut->_44 = 0.0f;

    return pOut;
}

D3DXMATRIX* WINAPI D3DXMatrixPerspectiveOffCenterLH
    ( D3DXMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float wInv = 1.0f / (r - l);
    float hInv = 1.0f / (t - b);

    pOut->_11 = 2.0f * zn * wInv;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = 2.0f * zn * hInv;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = -(l + r) * wInv;
    pOut->_32 = -(t + b) * hInv;
    pOut->_33 = zf / (zf - zn);
    pOut->_34 = 1.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = -pOut->_33 * zn;
    pOut->_44 = 0.0f;

    return pOut;
}

D3DXMATRIX* WINAPI D3DXMatrixOrthoRH
    ( D3DXMATRIX *pOut, float w, float h, float zn, float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    pOut->_11 = 2.0f / w;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = 2.0f / h;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = 0.0f;
    pOut->_32 = 0.0f;
    pOut->_33 = 1.0f / (zn - zf);
    pOut->_34 = 0.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = pOut->_33 * zn;
    pOut->_44 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI D3DXMatrixOrthoLH
    ( D3DXMATRIX *pOut, float w, float h, float zn, float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    pOut->_11 = 2.0f / w;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = 2.0f / h;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = 0.0f;
    pOut->_32 = 0.0f;
    pOut->_33 = 1.0f / (zf - zn);
    pOut->_34 = 0.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = -pOut->_33 * zn;
    pOut->_44 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI D3DXMatrixOrthoOffCenterRH
    ( D3DXMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float wInv = 1.0f / (r - l);
    float hInv = 1.0f / (t - b);

    pOut->_11 = 2.0f * wInv;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = 2.0f * hInv;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = 0.0f;
    pOut->_32 = 0.0f;
    pOut->_33 = 1.0f / (zn - zf);
    pOut->_34 = 0.0f;

    pOut->_41 = -(l + r) * wInv;
    pOut->_42 = -(t + b) * hInv;
    pOut->_43 = pOut->_33 * zn;
    pOut->_44 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI D3DXMatrixOrthoOffCenterLH
    ( D3DXMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float wInv = 1.0f / (r - l);
    float hInv = 1.0f / (t - b);

    pOut->_11 = 2.0f * wInv;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = 2.0f * hInv;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = 0.0f;
    pOut->_32 = 0.0f;
    pOut->_33 = 1.0f / (zf - zn);
    pOut->_34 = 0.0f;

    pOut->_41 = -(l + r) * wInv;
    pOut->_42 = -(t + b) * hInv;
    pOut->_43 = -pOut->_33 * zn;
    pOut->_44 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI D3DXMatrixShadow
    ( D3DXMATRIX *pOut, const D3DXVECTOR4 *pLight,
      const D3DXPLANE *pPlane )
{
#if DBG
    if(!pOut || !pLight || !pPlane)
        return NULL;
#endif

    D3DXPLANE p;
    D3DXPlaneNormalize(&p, pPlane);
    float dot = D3DXPlaneDot(&p, pLight);
    p = -p;

    pOut->_11 = p.a * pLight->x + dot;
    pOut->_21 = p.b * pLight->x;
    pOut->_31 = p.c * pLight->x;
    pOut->_41 = p.d * pLight->x;

    pOut->_12 = p.a * pLight->y;
    pOut->_22 = p.b * pLight->y + dot;
    pOut->_32 = p.c * pLight->y;
    pOut->_42 = p.d * pLight->y;

    pOut->_13 = p.a * pLight->z;
    pOut->_23 = p.b * pLight->z;
    pOut->_33 = p.c * pLight->z + dot;
    pOut->_43 = p.d * pLight->z;

    pOut->_14 = p.a * pLight->w;
    pOut->_24 = p.b * pLight->w;
    pOut->_34 = p.c * pLight->w;
    pOut->_44 = p.d * pLight->w + dot;

    return pOut;
}


D3DXMATRIX* WINAPI D3DXMatrixReflect
    ( D3DXMATRIX *pOut, const D3DXPLANE *pPlane )
{
#if DBG
    if(!pOut || !pPlane)
        return NULL;
#endif

    D3DXPLANE p;
    D3DXPlaneNormalize(&p, pPlane);

    float fa = -2.0f * p.a;
    float fb = -2.0f * p.b;
    float fc = -2.0f * p.c;

    pOut->_11 = fa * p.a + 1.0f;
    pOut->_12 = fb * p.a;
    pOut->_13 = fc * p.a;
    pOut->_14 = 0.0f;

    pOut->_21 = fa * p.b;
    pOut->_22 = fb * p.b + 1.0f;
    pOut->_23 = fc * p.b;
    pOut->_24 = 0.0f;

    pOut->_31 = fa * p.c;
    pOut->_32 = fb * p.c;
    pOut->_33 = fc * p.c + 1.0f;
    pOut->_34 = 0.0f;

    pOut->_41 = fa * p.d;
    pOut->_42 = fb * p.d;
    pOut->_43 = fc * p.d;
    pOut->_44 = 1.0f;

    return pOut;
}

//--------------------------
// Quaternion
//--------------------------

void WINAPI D3DXQuaternionToAxisAngle
    ( const D3DXQUATERNION *pQ, D3DXVECTOR3 *pAxis, float *pAngle )
{
#if DBG
    if(!pQ)
        return;
#endif

    // expects unit quaternions!
	// q = cos(A/2), sin(A/2) * v

    float lsq = D3DXQuaternionLengthSq(pQ);

    if(lsq > EPSILON * EPSILON)
    {
        if(pAxis)
        {
            float scale = 1.0f / sqrtf(lsq);
            pAxis->x = pQ->x * scale;
            pAxis->y = pQ->y * scale;
            pAxis->z = pQ->z * scale;
        }

        if(pAngle)
            *pAngle = 2.0f * acosf(pQ->w);

    }
    else
    {
        if(pAxis)
        {
            pAxis->x = 1.0;
            pAxis->y = 0.0;
            pAxis->z = 0.0;
        }

        if(pAngle)
            *pAngle = 0.0f;
    }
}

D3DXQUATERNION* WINAPI D3DXQuaternionRotationMatrix
    ( D3DXQUATERNION *pOut, const D3DXMATRIX *pM)
{
#if DBG
    if(!pOut || !pM)
        return NULL;
#endif

    float w2 = pM->_11 + pM->_22 + pM->_33; // 4w2 - 1

    if(w2 > 0.0f)
    {
        pOut->w = 0.5f * sqrtf(w2 + 1.0f);
        float wInv = 0.25f / pOut->w;

        pOut->x = (pM->_23 - pM->_32) * wInv; // 4xw / 4w
        pOut->y = (pM->_31 - pM->_13) * wInv; // 4yw / 4w
        pOut->z = (pM->_12 - pM->_21) * wInv; // 4zw / 4w
    }
    else
    {
        const UINT next[3] = { 1, 2, 0 };
        float *pf = (float *) pOut;
        float n2[3];
        UINT i, j, k;

        n2[0] =   pM->_11 - pM->_22 - pM->_33; // 4x2 - 1
        n2[1] = - pM->_11 + pM->_22 - pM->_33; // 4y2 - 1
        n2[2] = - pM->_11 - pM->_22 + pM->_33; // 4z2 - 1

        i = (n2[0] >= n2[1]) ? 0 : 1;
        i = (n2[i] >= n2[2]) ? i : 2;

        j = next[i];
        k = next[j];

        pf[i] = 0.5f * sqrtf(n2[i] + 1.0f); // x
        float nInv = 0.25f / pf[i];

        pf[j] = (pM->m[i][j] + pM->m[j][i]) * nInv; // 4yx / 4x
        pf[k] = (pM->m[k][i] + pM->m[i][k]) * nInv; // 4zx / 4x
        pf[3] = (pM->m[j][k] - pM->m[k][j]) * nInv; // 4wz / 4x
    }

    return pOut;
}

D3DXQUATERNION* WINAPI D3DXQuaternionRotationAxis
    ( D3DXQUATERNION *pOut, const D3DXVECTOR3 *pV, float angle )
{
#if DBG
    if(!pOut || !pV)
        return NULL;
#endif

    D3DXVECTOR3 v;
    D3DXVec3Normalize(&v, pV);

    float s;
    sincosf(0.5f * angle, &s, &pOut->w);

    pOut->x = v.x * s;
    pOut->y = v.y * s;
    pOut->z = v.z * s;

    return pOut;
}

D3DXQUATERNION* WINAPI D3DXQuaternionRotationYawPitchRoll
    ( D3DXQUATERNION *pOut, float yaw, float pitch, float roll )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    //  Roll first, about axis the object is facing, then
    //  pitch upward, then yaw to face into the new heading

    float SR, CR, SP, CP, SY, CY;

    sincosf(0.5f * roll,  &SR, &CR);
    sincosf(0.5f * pitch, &SP, &CP);
    sincosf(0.5f * yaw,   &SY, &CY);

    pOut->x = CY*SP*CR + SY*CP*SR;
    pOut->y = SY*CP*CR - CY*SP*SR;
    pOut->z = CY*CP*SR - SY*SP*CR;
    pOut->w = CY*CP*CR + SY*SP*SR;

    return pOut;
}


D3DXQUATERNION* WINAPI D3DXQuaternionMultiply
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ1,
      const D3DXQUATERNION *pQ2 )
{
#if DBG
    if(!pOut || !pQ1 || !pQ2)
        return NULL;
#endif


#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pQ2]
        mov   edx, DWORD PTR [pQ1]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+3*4]
        fmul  DWORD PTR [edx+0*4] ; wx
        fld   DWORD PTR [eax+3*4]
        fmul  DWORD PTR [edx+2*4] ; wz
        fld   DWORD PTR [eax+3*4]
        fmul  DWORD PTR [edx+1*4] ; wy
        fld   DWORD PTR [eax+3*4]
        fmul  DWORD PTR [edx+3*4] ; ww
        fxch  st(3)
        // wx wy wz ww

        fld   DWORD PTR [eax+0*4]
        fmul  DWORD PTR [edx+3*4] ; xw
        fld   DWORD PTR [eax+0*4]
        fmul  DWORD PTR [edx+1*4] ; xy
        fld   DWORD PTR [eax+0*4]
        fmul  DWORD PTR [edx+2*4] ; xz
        fld   DWORD PTR [eax+0*4]
        fmul  DWORD PTR [edx+0*4] ; xx
        fxch  st(3)
        // xw xz xy xx  wx wy wz ww

        faddp st(4), st
        fsubp st(4), st
        faddp st(4), st
        fsubp st(4), st
        // wx-xw wy-xz wz+xy ww-xx

        fld   DWORD PTR [eax+1*4]
        fmul  DWORD PTR [edx+2*4] ; yz
        fld   DWORD PTR [eax+1*4]
        fmul  DWORD PTR [edx+0*4] ; yx
        fld   DWORD PTR [eax+1*4]
        fmul  DWORD PTR [edx+3*4] ; yw
        fld   DWORD PTR [eax+1*4]
        fmul  DWORD PTR [edx+1*4] ; yy
        fxch  st(3)
        // yz yw yx yy  wx-xw wy-xz wz+xy ww-xx

        faddp st(4), st
        faddp st(4), st
        fsubp st(4), st
        fsubp st(4), st
        // wx-xw+yz wy-xz+yw wz+xy-yx ww-xx-yy

        fld   DWORD PTR [eax+2*4]
        fmul  DWORD PTR [edx+1*4] ; zy
        fld   DWORD PTR [eax+2*4]
        fmul  DWORD PTR [edx+3*4] ; zw
        fld   DWORD PTR [eax+2*4]
        fmul  DWORD PTR [edx+0*4] ; zx
        fld   DWORD PTR [eax+2*4]
        fmul  DWORD PTR [edx+2*4] ; zz
        fxch  st(3)
        // zy zx zw zz wx-xw+yz wy-xz+yw wz+xy-yx ww-xx-yy

        fsubp st(4), st
        faddp st(4), st
        faddp st(4), st
        fsubp st(4), st
        // wx-xw+yz-zy wy-xz+yw+zx wz+xy-yx+zw ww-xx-yy-zz

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]
        fstp  DWORD PTR [ecx+2*4]
        fstp  DWORD PTR [ecx+3*4]
    }

    return pOut;

#else // !_X86_
    D3DXQUATERNION Q;

    Q.x = pQ2->w * pQ1->x + pQ2->x * pQ1->w + pQ2->y * pQ1->z - pQ2->z * pQ1->y;
    Q.y = pQ2->w * pQ1->y - pQ2->x * pQ1->z + pQ2->y * pQ1->w + pQ2->z * pQ1->x;
    Q.z = pQ2->w * pQ1->z + pQ2->x * pQ1->y - pQ2->y * pQ1->x + pQ2->z * pQ1->w;
    Q.w = pQ2->w * pQ1->w - pQ2->x * pQ1->x - pQ2->y * pQ1->y - pQ2->z * pQ1->z;

    *pOut = Q;
    return pOut;
#endif // !_X86_
}

D3DXQUATERNION* WINAPI D3DXQuaternionNormalize
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ )
{
#if DBG
    if(!pOut || !pQ)
        return NULL;
#endif

    float f = D3DXQuaternionLengthSq(pQ);

    if(WithinEpsilon(f, 1.0f))
    {
        if(pOut != pQ)
            *pOut = *pQ;
    }
    else if(f > EPSILON * EPSILON)
    {
        *pOut = *pQ / sqrtf(f);
    }
    else
    {
        pOut->x = 0.0f;
        pOut->y = 0.0f;
        pOut->z = 0.0f;
        pOut->w = 0.0f;
    }

    return pOut;
}

D3DXQUATERNION* WINAPI D3DXQuaternionInverse
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ )
{
#if DBG
    if(!pOut || !pQ)
        return NULL;
#endif

    float f = D3DXQuaternionLengthSq(pQ);

    if(f > EPSILON*EPSILON)
    {
        D3DXQuaternionConjugate(pOut, pQ);

        if(!WithinEpsilon(f, 1.0f))
            *pOut /= f;
    }
    else
    {
        pOut->x = 0.0f;
        pOut->y = 0.0f;
        pOut->z = 0.0f;
        pOut->w = 0.0f;
    }

    return pOut;
}

D3DXQUATERNION* WINAPI D3DXQuaternionLn
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ )
{
#if DBG
    if(!pOut || !pQ)
        return NULL;
#endif

    // expects unit quaternions!
    // q = (cos(theta), sin(theta) * v); ln(q) = (0, theta * v)

    float theta, s;

    if(pQ->w < 1.0f)
    {
        theta = acosf(pQ->w);
        s = sinf(theta);

        if(!WithinEpsilon(s, 0.0f))
        {
            float scale = theta / s;
            pOut->x = pQ->x * scale;
            pOut->y = pQ->y * scale;
            pOut->z = pQ->z * scale;
            pOut->w = 0.0f;
        }
        else
        {
            pOut->x = pQ->x;
            pOut->y = pQ->y;
            pOut->z = pQ->z;
            pOut->w = 0.0f;
        }
    }
    else
    {
        pOut->x = pQ->x;
        pOut->y = pQ->y;
        pOut->z = pQ->z;
        pOut->w = 0.0f;
    }

    return pOut;
}

D3DXQUATERNION* WINAPI D3DXQuaternionExp
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ )
{
#if DBG
    if(!pOut || !pQ)
        return NULL;
#endif

    // expects pure quaternions! (w == 0)
    // q = (0, theta * v) ; exp(q) = (cos(theta), sin(theta) * v)

    float theta, s;

    theta = sqrtf(pQ->x * pQ->x + pQ->y * pQ->y + pQ->z * pQ->z);
    sincosf(theta, &s, &pOut->w);

    if(WithinEpsilon(s, 0.0f))
    {
        if(pOut != pQ)
        {
            pOut->x = pQ->x;
            pOut->y = pQ->y;
            pOut->z = pQ->z;
        }
    }
    else
    {
        s /= theta;

        pOut->x = pQ->x * s;
        pOut->y = pQ->y * s;
        pOut->z = pQ->z * s;
    }

    return pOut;
}


D3DXQUATERNION* WINAPI D3DXQuaternionSlerp
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ1,
      const D3DXQUATERNION *pQ2, float b )
{
#if DBG
    if(!pOut || !pQ1 || !pQ2)
        return NULL;
#endif

    // expects unit quaternions!
    float a, c, flip, s, omega, sInv;

    a = 1.0f - b;
    c = D3DXQuaternionDot(pQ1, pQ2);
    flip = (c >= 0.0f) ? 1.0f : -1.0f;
    c *= flip;

	if(1.0f - c > EPSILON) {
        s = sqrtf(1.0f - c * c);
 		omega = atan2f(s, c);
 		sInv = 1.0f / s;

 		a = sinf(a * omega) * sInv;
 		b = sinf(b * omega) * sInv;
 	}

    b *= flip;

    pOut->x = a * pQ1->x + b * pQ2->x;
    pOut->y = a * pQ1->y + b * pQ2->y;
    pOut->z = a * pQ1->z + b * pQ2->z;
    pOut->w = a * pQ1->w + b * pQ2->w;

    return pOut;
}

D3DXQUATERNION* WINAPI D3DXQuaternionSquad
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ1,
      const D3DXQUATERNION *pQ2, const D3DXQUATERNION *pQ3,
      const D3DXQUATERNION *pQ4, float t )
{
#if DBG
    if(!pOut || !pQ1 || !pQ2 || !pQ3 || !pQ4)
        return NULL;
#endif

    // expects unit quaternions!
    D3DXQUATERNION QA, QB;

    D3DXQuaternionSlerp(&QA, pQ1, pQ4, t);
    D3DXQuaternionSlerp(&QB, pQ2, pQ3, t);
    D3DXQuaternionSlerp(pOut, &QA, &QB, 2.0f * t * (1.0f - t));

    return pOut;
}

D3DXQUATERNION* WINAPI D3DXQuaternionBaryCentric
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ1,
      const D3DXQUATERNION *pQ2, const D3DXQUATERNION *pQ3,
      float f, float g )
{
#if DBG
    if(!pOut || !pQ1 || !pQ2 || !pQ3)
        return NULL;
#endif

    // expects unit quaternions!
    D3DXQUATERNION QA, QB;
    float s = f + g;

    if(WithinEpsilon(s, 0.0f))
    {
        if(pOut != pQ1)
            *pOut = *pQ1;
    }
    else
    {
        D3DXQuaternionSlerp(&QA, pQ1, pQ2, s);
        D3DXQuaternionSlerp(&QB, pQ1, pQ3, s);
        D3DXQuaternionSlerp(pOut, &QA, &QB, g / s);
    }

    return pOut;
}


//--------------------------
// Plane
//--------------------------

D3DXPLANE* WINAPI D3DXPlaneNormalize
    ( D3DXPLANE *pOut, const D3DXPLANE *pP )
{
#if DBG
    if(!pOut || !pP)
        return NULL;
#endif

    float f = pP->a * pP->a + pP->b * pP->b + pP->c * pP->c;

    if(WithinEpsilon(f, 1.0f))
    {
        if(pOut != pP)
            *pOut = *pP;
    }
    else if(f > EPSILON * EPSILON)
    {
        float fInv = 1.0f / sqrtf(f);

        pOut->a = pP->a * fInv;
        pOut->b = pP->b * fInv;
        pOut->c = pP->c * fInv;
        pOut->d = pP->d * fInv;
    }
    else
    {
        pOut->a = 0.0f;
        pOut->b = 0.0f;
        pOut->c = 0.0f;
        pOut->d = 0.0f;
    }

    return pOut;
}

D3DXVECTOR3* WINAPI D3DXPlaneIntersectLine
    ( D3DXVECTOR3 *pOut, const D3DXPLANE *pP, const D3DXVECTOR3 *pV1,
      const D3DXVECTOR3 *pV2)
{
#if DBG
    if(!pOut || !pP || !pV1 || !pV2)
        return NULL;
#endif

    float d =  D3DXPlaneDotNormal(pP, pV1) - D3DXPlaneDotNormal(pP, pV2);

    if(d == 0.0f)
        return NULL;

    float f = D3DXPlaneDotCoord(pP, pV1) / d;

    if(!_finite(f))
        return NULL;

    D3DXVec3Lerp(pOut, pV1, pV2, f);
    return pOut;
}

D3DXPLANE* WINAPI D3DXPlaneFromPointNormal
    ( D3DXPLANE *pOut, const D3DXVECTOR3 *pPoint, const D3DXVECTOR3 *pNormal)
{
#if DBG
    if(!pOut || !pPoint || !pNormal)
        return NULL;
#endif

    pOut->a = pNormal->x;
    pOut->b = pNormal->y;
    pOut->c = pNormal->z;
    pOut->d = -D3DXVec3Dot(pPoint, pNormal);
    return pOut;
}

D3DXPLANE* WINAPI D3DXPlaneFromPoints
    ( D3DXPLANE *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2,
      const D3DXVECTOR3 *pV3)
{
#if DBG
    if(!pOut || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    D3DXVECTOR3 V12 = *pV1 - *pV2;
    D3DXVECTOR3 V13 = *pV1 - *pV3;

    D3DXVec3Cross((D3DXVECTOR3 *) pOut, &V12, &V13);
    D3DXVec3Normalize((D3DXVECTOR3 *) pOut, (D3DXVECTOR3 *) pOut);

    pOut->d = -D3DXPlaneDotNormal(pOut, pV1);
    return pOut;
}

D3DXPLANE* WINAPI D3DXPlaneTransform
    ( D3DXPLANE *pOut, const D3DXPLANE *pP, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pP || !pM)
        return NULL;
#endif

    D3DXPLANE P;
    D3DXPlaneNormalize(&P, pP);

    D3DXVECTOR3 V(-P.a * P.d, -P.b * P.d, -P.c * P.d);
    D3DXVec3TransformCoord(&V, &V, pM);

    D3DXVec3TransformNormal((D3DXVECTOR3 *) pOut, (const D3DXVECTOR3 *) &P, pM);
    D3DXVec3Normalize((D3DXVECTOR3 *) pOut, (const D3DXVECTOR3 *) pOut);

    pOut->d = -D3DXPlaneDotNormal(pOut, &V);
    return pOut;
}


//--------------------------
// Color
//--------------------------

D3DXCOLOR* WINAPI D3DXColorAdjustSaturation
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC, float s)
{
#if DBG
    if(!pOut || !pC)
        return NULL;
#endif

    // Approximate values for each component's contribution to luminance.
    // (Based upon the NTSC standard described in the comp.graphics.algorithms
    // colorspace FAQ)
    float grey = pC->r * 0.2125f + pC->g * 0.7154f + pC->b * 0.0721f;

    pOut->r = grey + s * (pC->r - grey);
    pOut->g = grey + s * (pC->g - grey);
    pOut->b = grey + s * (pC->b - grey);
    pOut->a = pC->a;
    return pOut;
}

D3DXCOLOR* WINAPI D3DXColorAdjustContrast
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC, float c)
{
#if DBG
    if(!pOut || !pC)
        return NULL;
#endif

    pOut->r = 0.5f + c * (pC->r - 0.5f);
    pOut->g = 0.5f + c * (pC->g - 0.5f);
    pOut->b = 0.5f + c * (pC->b - 0.5f);
    pOut->a = pC->a;
    return pOut;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\math\pchmath.h ===
#include <d3dx8seg.h>
#include "xtl.h"
#include "cstack.h"

#define D3DXASSERT
#define DPF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\mesh\cd3dxbitfield.h ===
#define BITSPERINT      32
#define BITSHIFT        5 // 2^5 == 32 bits == 1 DWORD
#define BITFIELDSIZE    8 // 8 * 32 = 256 bits

class CD3DXBitField256
{
    DWORD bits[BITFIELDSIZE];
    static const DWORD nibbleCount[];

public:
    CD3DXBitField256()
    {
        memset(bits, 0, BITFIELDSIZE * sizeof(DWORD));
    }

    void Set(DWORD bit)
    {
        bits[bit >> BITSHIFT] |= 1 << (bit & (BITSPERINT - 1));
    }

    BOOL IsSet(DWORD bit)
    {
        return bits[bit >> BITSHIFT] & (1 << (bit & (BITSPERINT - 1)));
    }

    BOOL IsSubset(CD3DXBitField256& sub)
    {
        if (((bits[0] & sub.bits[0]) == sub.bits[0]) &&
            ((bits[1] & sub.bits[1]) == sub.bits[1]) &&
            ((bits[2] & sub.bits[2]) == sub.bits[2]) &&
            ((bits[3] & sub.bits[3]) == sub.bits[3]) &&
            ((bits[4] & sub.bits[4]) == sub.bits[4]) &&
            ((bits[5] & sub.bits[5]) == sub.bits[5]) &&
            ((bits[6] & sub.bits[6]) == sub.bits[6]) &&
            ((bits[7] & sub.bits[7]) == sub.bits[7]))
            return TRUE;
        return FALSE;
    }

    void Clear(DWORD bit)
    {
        bits[bit >> BITSHIFT] &= ~(1 << (bit & (BITSPERINT - 1)));
    }

    void Or(CD3DXBitField256& src1, CD3DXBitField256& src2)
    {
        bits[0] = src1.bits[0] | src2.bits[0];
        bits[1] = src1.bits[1] | src2.bits[1];
        bits[2] = src1.bits[2] | src2.bits[2];
        bits[3] = src1.bits[3] | src2.bits[3];
        bits[4] = src1.bits[4] | src2.bits[4];
        bits[5] = src1.bits[5] | src2.bits[5];
        bits[6] = src1.bits[6] | src2.bits[6];
        bits[7] = src1.bits[7] | src2.bits[7];
    }

    void Xor(CD3DXBitField256& src1, CD3DXBitField256& src2)
    {
        bits[0] = src1.bits[0] ^ src2.bits[0];
        bits[1] = src1.bits[1] ^ src2.bits[1];
        bits[2] = src1.bits[2] ^ src2.bits[2];
        bits[3] = src1.bits[3] ^ src2.bits[3];
        bits[4] = src1.bits[4] ^ src2.bits[4];
        bits[5] = src1.bits[5] ^ src2.bits[5];
        bits[6] = src1.bits[6] ^ src2.bits[6];
        bits[7] = src1.bits[7] ^ src2.bits[7];
    }
    void And(CD3DXBitField256& src1, CD3DXBitField256& src2)
    {
        bits[0] = src1.bits[0] & src2.bits[0];
        bits[1] = src1.bits[1] & src2.bits[1];
        bits[2] = src1.bits[2] & src2.bits[2];
        bits[3] = src1.bits[3] & src2.bits[3];
        bits[4] = src1.bits[4] & src2.bits[4];
        bits[5] = src1.bits[5] & src2.bits[5];
        bits[6] = src1.bits[6] & src2.bits[6];
        bits[7] = src1.bits[7] & src2.bits[7];
    }
    DWORD Count()
    {
        DWORD   cOnes   = 0;                                    
                                                                
        for (DWORD i = 0; i < 8; i++)                           
        {                                                       
            DWORD   n   = bits[i];                              
                                                                
            while (n)                                           
            {                                                   
                n &= ~(n & ~(n - 1));                           
                                                                
                cOnes++;                                        
            }                                                   
        }                                                       
                                                                
        return cOnes;                                           
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\mesh\btri.cpp ===
#include "pchmesh.h"


typedef struct _D3DXBEZIERTRI
{
    UINT16 rgiControlPoints[10];
    DWORD rgiVertices[3];
} D3DXBEZIERTRI, *LPD3DXBEZIERTRI;

#if 0
void
EvalBezierTri
(
    LPD3DXVECTOR2 pPosition, 
    LPD3DXBEZIERTRI pbtTri, 
    LPD3DXVECTOR3 rgvControl, 
    LPD3DXVECTOR3 rgvControlNormal, 
    BOOL bLinearNormal,
    PVOID pvVertices,
    DXCrackFVF &cfvf,
    PVOID pvOut
    )
{
	float *pfTexCur0;
	float *pfTexCur1;
	float *pfTexCur2;
	float *pfTexCurOut;
	DWORD iTex;
	DWORD cTexFloats;

	float *pfWeightCur0;
	float *pfWeightCur1;
	float *pfWeightCur2;
	float *pfWeightCurOut;
	DWORD iWeight;

	D3DXCOLOR colorOut;

    D3DXVec3BaryCentric(cfvf.PvGetPosition(pvOut), 
                                    &rgvControl[pbtTri->rgiControlPoints[0]],
                                    &rgvControl[pbtTri->rgiControlPoints[3]],
                                    &rgvControl[pbtTri->rgiControlPoints[6]],
                                    pPosition->x, pPosition->y);

    if (cfvf.CTexCoords() > 0)
    {
		cTexFloats = (cfvf.m_cBytesPerVertex - cfvf.m_oTex1) / sizeof(float);

		pfTexCur0 = (float*)cfvf.PuvGetTex1(cfvf.GetArrayElem(pvVertices, pbtTri->rgiVertices[0]));
		pfTexCur1 = (float*)cfvf.PuvGetTex1(cfvf.GetArrayElem(pvVertices, pbtTri->rgiVertices[1]));
		pfTexCur2 = (float*)cfvf.PuvGetTex1(cfvf.GetArrayElem(pvVertices, pbtTri->rgiVertices[2]));
		pfTexCurOut = (float*)cfvf.PuvGetTex1(pvOut);

		for (iTex = 0; iTex < cTexFloats; iTex++)
		{
		    *pfTexCurOut = *pfTexCur0
									+ pPosition->x * (*pfTexCur1 - *pfTexCur0) 
									+ pPosition->y * (*pfTexCur2 - *pfTexCur0);

			pfTexCurOut += 1;
			pfTexCur0 += 1;
			pfTexCur1 += 1;
			pfTexCur2 += 1;
		}
    }

	if (cfvf.CWeights() > 0)
	{
		pfWeightCur0 = cfvf.PfGetWeights(cfvf.GetArrayElem(pvVertices, pbtTri->rgiVertices[0]));
		pfWeightCur1 = cfvf.PfGetWeights(cfvf.GetArrayElem(pvVertices, pbtTri->rgiVertices[1]));
		pfWeightCur2 = cfvf.PfGetWeights(cfvf.GetArrayElem(pvVertices, pbtTri->rgiVertices[2]));
		pfWeightCurOut = cfvf.PfGetWeights(pvOut);


		for (iWeight = 0; iWeight < cfvf.CWeights(); iWeight++)
		{
		    *pfWeightCurOut = *pfWeightCur0
									+ pPosition->x * (*pfWeightCur1 - *pfWeightCur0) 
									+ pPosition->y * (*pfWeightCur2 - *pfWeightCur0);


			pfWeightCur0 += 1;
			pfWeightCur1 += 1;
			pfWeightCur2 += 1;
			pfWeightCurOut += 1;
		}
	}

	if (cfvf.BDiffuse())
	{
		D3DXVec4BaryCentric((D3DXVECTOR4*)&colorOut,
								(D3DXVECTOR4*)&D3DXCOLOR(cfvf.ColorGetDiffuse(cfvf.GetArrayElem(pvVertices, pbtTri->rgiVertices[0]))),
								(D3DXVECTOR4*)&D3DXCOLOR(cfvf.ColorGetDiffuse(cfvf.GetArrayElem(pvVertices, pbtTri->rgiVertices[1]))),
								(D3DXVECTOR4*)&D3DXCOLOR(cfvf.ColorGetDiffuse(cfvf.GetArrayElem(pvVertices, pbtTri->rgiVertices[2]))),
								pPosition->x, pPosition->y);

		cfvf.SetDiffuse(pvOut, (DWORD)colorOut);
	}

	if (cfvf.BSpecular())
	{
		D3DXVec4BaryCentric((D3DXVECTOR4*)&colorOut,
								(D3DXVECTOR4*)&D3DXCOLOR(cfvf.ColorGetSpecular(cfvf.GetArrayElem(pvVertices, pbtTri->rgiVertices[0]))),
								(D3DXVECTOR4*)&D3DXCOLOR(cfvf.ColorGetSpecular(cfvf.GetArrayElem(pvVertices, pbtTri->rgiVertices[1]))),
								(D3DXVECTOR4*)&D3DXCOLOR(cfvf.ColorGetSpecular(cfvf.GetArrayElem(pvVertices, pbtTri->rgiVertices[2]))),
								pPosition->x, pPosition->y);

		cfvf.SetSpecular(pvOut, (DWORD)colorOut);
	}

    if (cfvf.BNormal())
    {
        D3DXVec3BaryCentric(cfvf.PvGetNormal(pvOut), 
                                        cfvf.PvGetNormal(cfvf.GetArrayElem(pvVertices, pbtTri->rgiVertices[0])),
                                        cfvf.PvGetNormal(cfvf.GetArrayElem(pvVertices, pbtTri->rgiVertices[1])),
                                        cfvf.PvGetNormal(cfvf.GetArrayElem(pvVertices, pbtTri->rgiVertices[2])),
                                        pPosition->x, pPosition->y);
    }
}

#else
void
EvalBezierTri
(
    LPD3DXVECTOR2 pPosition, 
    LPD3DXBEZIERTRI pbtTri, 
    LPD3DXVECTOR3 rgvControl, 
    LPD3DXVECTOR3 rgvControlNormal, 
    BOOL bLinearNormal,
    PVOID pvVertices,
    DXCrackFVF &cfvf,
    PVOID pvOut
    )
{
    D3DXVECTOR3 p002;
    D3DXVECTOR3 p020;
    D3DXVECTOR3 p200;
    D3DXVECTOR3 p110;
    D3DXVECTOR3 p101;
    D3DXVECTOR3 p011;
    D3DXVECTOR3 p100;
    D3DXVECTOR3 p010;
    D3DXVECTOR3 p001;

	float *pfTexCur0;
	float *pfTexCur1;
	float *pfTexCur2;
	float *pfTexCurOut;
	DWORD iTex;
	DWORD cTexFloats;

	float *pfWeightCur0;
	float *pfWeightCur1;
	float *pfWeightCur2;
	float *pfWeightCurOut;
	DWORD iWeight;

	D3DXCOLOR colorOut;


    D3DXVec3BaryCentric(&p002, &rgvControl[pbtTri->rgiControlPoints[0]],
                                    &rgvControl[pbtTri->rgiControlPoints[1]],
                                    &rgvControl[pbtTri->rgiControlPoints[8]],
                                    pPosition->x, pPosition->y);

    D3DXVec3BaryCentric(&p011, &rgvControl[pbtTri->rgiControlPoints[1]],
                                    &rgvControl[pbtTri->rgiControlPoints[2]],
                                    &rgvControl[pbtTri->rgiControlPoints[9]],
                                    pPosition->x, pPosition->y);

    D3DXVec3BaryCentric(&p020, &rgvControl[pbtTri->rgiControlPoints[2]],
                                    &rgvControl[pbtTri->rgiControlPoints[3]],
                                    &rgvControl[pbtTri->rgiControlPoints[4]],
                                    pPosition->x, pPosition->y);

    D3DXVec3BaryCentric(&p110, &rgvControl[pbtTri->rgiControlPoints[9]],
                                    &rgvControl[pbtTri->rgiControlPoints[4]],
                                    &rgvControl[pbtTri->rgiControlPoints[5]],
                                    pPosition->x, pPosition->y);

    D3DXVec3BaryCentric(&p101, &rgvControl[pbtTri->rgiControlPoints[8]],
                                    &rgvControl[pbtTri->rgiControlPoints[9]],
                                    &rgvControl[pbtTri->rgiControlPoints[7]],
                                    pPosition->x, pPosition->y);

    D3DXVec3BaryCentric(&p200, &rgvControl[pbtTri->rgiControlPoints[7]],
                                    &rgvControl[pbtTri->rgiControlPoints[5]],
                                    &rgvControl[pbtTri->rgiControlPoints[6]],
                                    pPosition->x, pPosition->y);

    D3DXVec3BaryCentric(&p001, &p002, &p011, &p101, pPosition->x, pPosition->y);
    D3DXVec3BaryCentric(&p010, &p011, &p020, &p110, pPosition->x, pPosition->y);
    D3DXVec3BaryCentric(&p100, &p101, &p110, &p200, pPosition->x, pPosition->y);

    D3DXVec3BaryCentric(cfvf.PvGetPosition(pvOut), &p001, &p010, &p100, pPosition->x, pPosition->y);

    if (cfvf.CTexCoords() > 0)
    {
		cTexFloats = (cfvf.m_cBytesPerVertex - cfvf.m_oTex1) / sizeof(float);

		pfTexCur0 = (float*)cfvf.PuvGetTex1(cfvf.GetArrayElem(pvVertices, pbtTri->rgiVertices[0]));
		pfTexCur1 = (float*)cfvf.PuvGetTex1(cfvf.GetArrayElem(pvVertices, pbtTri->rgiVertices[1]));
		pfTexCur2 = (float*)cfvf.PuvGetTex1(cfvf.GetArrayElem(pvVertices, pbtTri->rgiVertices[2]));
		pfTexCurOut = (float*)cfvf.PuvGetTex1(pvOut);

		for (iTex = 0; iTex < cTexFloats; iTex++)
		{
		    *pfTexCurOut = *pfTexCur0
									+ pPosition->x * (*pfTexCur1 - *pfTexCur0) 
									+ pPosition->y * (*pfTexCur2 - *pfTexCur0);

			pfTexCurOut += 1;
			pfTexCur0 += 1;
			pfTexCur1 += 1;
			pfTexCur2 += 1;
		}
    }

	if (cfvf.CWeights() > 0)
	{
		pfWeightCur0 = cfvf.PfGetWeights(cfvf.GetArrayElem(pvVertices, pbtTri->rgiVertices[0]));
		pfWeightCur1 = cfvf.PfGetWeights(cfvf.GetArrayElem(pvVertices, pbtTri->rgiVertices[1]));
		pfWeightCur2 = cfvf.PfGetWeights(cfvf.GetArrayElem(pvVertices, pbtTri->rgiVertices[2]));
		pfWeightCurOut = cfvf.PfGetWeights(pvOut);


		for (iWeight = 0; iWeight < cfvf.CWeights(); iWeight++)
		{
		    *pfWeightCurOut = *pfWeightCur0
									+ pPosition->x * (*pfWeightCur1 - *pfWeightCur0) 
									+ pPosition->y * (*pfWeightCur2 - *pfWeightCur0);


			pfWeightCur0 += 1;
			pfWeightCur1 += 1;
			pfWeightCur2 += 1;
			pfWeightCurOut += 1;
		}
	}

	if (cfvf.BDiffuse())
	{
		D3DXVec4BaryCentric((D3DXVECTOR4*)&colorOut,
								(D3DXVECTOR4*)&D3DXCOLOR(cfvf.ColorGetDiffuse(cfvf.GetArrayElem(pvVertices, pbtTri->rgiVertices[0]))),
								(D3DXVECTOR4*)&D3DXCOLOR(cfvf.ColorGetDiffuse(cfvf.GetArrayElem(pvVertices, pbtTri->rgiVertices[1]))),
								(D3DXVECTOR4*)&D3DXCOLOR(cfvf.ColorGetDiffuse(cfvf.GetArrayElem(pvVertices, pbtTri->rgiVertices[2]))),
								pPosition->x, pPosition->y);

		cfvf.SetDiffuse(pvOut, (DWORD)colorOut);
	}

	if (cfvf.BSpecular())
	{
		D3DXVec4BaryCentric((D3DXVECTOR4*)&colorOut,
								(D3DXVECTOR4*)&D3DXCOLOR(cfvf.ColorGetSpecular(cfvf.GetArrayElem(pvVertices, pbtTri->rgiVertices[0]))),
								(D3DXVECTOR4*)&D3DXCOLOR(cfvf.ColorGetSpecular(cfvf.GetArrayElem(pvVertices, pbtTri->rgiVertices[1]))),
								(D3DXVECTOR4*)&D3DXCOLOR(cfvf.ColorGetSpecular(cfvf.GetArrayElem(pvVertices, pbtTri->rgiVertices[2]))),
								pPosition->x, pPosition->y);

		cfvf.SetSpecular(pvOut, (DWORD)colorOut);
	}

    if (cfvf.BNormal())
    {
        if (bLinearNormal)
        {
            D3DXVec3BaryCentric(cfvf.PvGetNormal(pvOut), 
                                            cfvf.PvGetNormal(cfvf.GetArrayElem(pvVertices, pbtTri->rgiVertices[0])),
                                            cfvf.PvGetNormal(cfvf.GetArrayElem(pvVertices, pbtTri->rgiVertices[1])),
                                            cfvf.PvGetNormal(cfvf.GetArrayElem(pvVertices, pbtTri->rgiVertices[2])),
                                            pPosition->x, pPosition->y);
        }
        else
        {
            D3DXVec3BaryCentric(&p001, &rgvControlNormal[0], &rgvControlNormal[1], &rgvControlNormal[5], pPosition->x, pPosition->y);
            D3DXVec3BaryCentric(&p010, &rgvControlNormal[1], &rgvControlNormal[2], &rgvControlNormal[3], pPosition->x, pPosition->y);
            D3DXVec3BaryCentric(&p100, &rgvControlNormal[5], &rgvControlNormal[3], &rgvControlNormal[4], pPosition->x, pPosition->y);

            D3DXVec3BaryCentric(cfvf.PvGetNormal(pvOut), &p001, &p010, &p100, pPosition->x, pPosition->y);
        }
    }
}
#endif

template <class UINT_IDX>
struct SFaceTempStruct
{
    UINT_IDX rgwIndices[3];
};

template <class UINT_IDX>
struct SVertOffsetStruct
{
    UINT_IDX rgdwOffsets[3];
};


// -------------------------------------------------------------------------------
//  method    CalculateCounts
//
//  devnote     Calculates the number of vertices and faces for a bezier triangle
//                  that is tesselated with the given level
//
//  returns     S_OK if suceeded, else error code
//
void 
CalculateCounts(DWORD cLevels, PDWORD pcFaces, PDWORD pcVertices)
{
    DWORD iLevel;
    DWORD cFacesPrev;
    DWORD cFacesOut;


    // UNDONE - should be a convenient formula to figure this one out
    cFacesOut = 1;
    cFacesPrev = 1;
    for (iLevel = 0; iLevel < cLevels; iLevel++)
    {
        cFacesPrev += 2;
        cFacesOut += cFacesPrev;
    }

    *pcVertices = ((cLevels+2) * (cLevels + 3)) / 2;
    *pcFaces = cFacesOut;
}

// -------------------------------------------------------------------------------
//  method    TesselateBTri
//
//  devnote     Tesselates the bezier triangle into the provided buffer
//
//  returns     S_OK if suceeded, else error code
//
template<class UINT_IDX, unsigned int UNUSED>
HRESULT TesselateBTri
(
    LPD3DXBEZIERTRI pbtTri,             // bezier triangle to tesselate
    LPD3DXVECTOR3 rgvControl,           // control point buffer (n control points, indexed by pbtTri)
    LPD3DXVECTOR3 rgvControlNormal,     // normal control point buffer (n control points)
    BOOL bLinearNormals,                // should the normals be tesselated linearly or quadraticly
    PVOID pvPointsInt,                  // input vertices
    UINT_IDX *rgiVerts,                   // input indices, indices that are != UNUSED have already been computed
    DXCrackFVF &cfvf,                   // fvf of input and output vertices
    DWORD cLevels,                       // number of levels of tesselation
    DWORD cVertices,                     // number of vertices to tesselate to (derived from cLevels)
    DWORD &iCurVertex,                    // relative index of pvPointsOut to the start of the vertex buffer
    PBYTE &pvPointsOut,                  // generated vertices
    SFaceTempStruct<UINT_IDX> *rgwFaceOut, // generated face indices
    UINT_IDX *rgiVertOffsets               // at what offset do each of the side vertices start on
)
{
    DWORD iLevel;
    //DWORD iVertex;
    DWORD iCurTriangle;
    DWORD iPrevLevelPos;
    DWORD iCurLevelPos;
    float fIncrement;
    float fCurLevelA;
    //DWORD iattr;
    DWORD iTriangle;
    PBYTE pbCurPoint;
    float fPos;
    float fIntIncrement;
    D3DXVECTOR2 vPos;
    D3DXVECTOR2 vPos1;
    D3DXVECTOR2 vPos2;
    DWORD cNewVertices;
    DWORD iPosIncrement;

    pbCurPoint = (PBYTE)pvPointsOut;

    if (cLevels > 0)
    {
        fIncrement = 1.0f / (float)(cLevels + 1);
    }
    else
    {
        fIncrement = 1.0f;
    }

    cNewVertices = 0;

    if (rgiVerts[0] == UNUSED)
    {
        vPos = D3DXVECTOR2(0.0, 0.0);
        EvalBezierTri(&vPos, pbtTri, rgvControl, rgvControlNormal, bLinearNormals, pvPointsInt, cfvf, pbCurPoint);
        pbCurPoint += cfvf.m_cBytesPerVertex;
        rgiVerts[0] = (UINT_IDX)iCurVertex + 0;
        iCurVertex += 1;
        cNewVertices += 1;
    }

    // NOTE: the cLevels+1 is not necessary if the three original points are always specified!

    // first do left side points
    fCurLevelA = fIncrement;
    iPosIncrement = 2;
    iCurLevelPos = 1;
    rgiVertOffsets[0] = (UINT_IDX)iCurVertex;
    for (iLevel = 0; iLevel < cLevels+1; iLevel++)
    {
        vPos1 = D3DXVECTOR2(fCurLevelA, 0.0f);

        if (rgiVerts[iCurLevelPos] == UNUSED)
        {
            EvalBezierTri(&vPos1, pbtTri, rgvControl, rgvControlNormal, bLinearNormals, pvPointsInt, cfvf, pbCurPoint);
            pbCurPoint += cfvf.m_cBytesPerVertex;
            rgiVerts[iCurLevelPos] = (UINT_IDX)iCurVertex;
            iCurVertex += 1;
            cNewVertices += 1;
        }

        iCurLevelPos += iPosIncrement;
        iPosIncrement += 1;
        fCurLevelA += fIncrement;
    }

    // next do right side points
    fCurLevelA = 1.0f - fIncrement;
    iPosIncrement = cLevels + 1;
    iCurLevelPos = cVertices - 1 - (cLevels + 2);
    rgiVertOffsets[2] = (UINT_IDX)iCurVertex;
    for (iLevel = 0; iLevel < cLevels+1; iLevel++)
    {
        vPos2 = D3DXVECTOR2(0, fCurLevelA);

        if (rgiVerts[iCurLevelPos] == UNUSED)
        {
            EvalBezierTri(&vPos2, pbtTri, rgvControl, rgvControlNormal, bLinearNormals, pvPointsInt, cfvf, pbCurPoint);
            pbCurPoint += cfvf.m_cBytesPerVertex;
            rgiVerts[iCurLevelPos] = (UINT_IDX)iCurVertex;
            iCurVertex += 1;
            cNewVertices += 1;
        }

        iCurLevelPos -= iPosIncrement;
        iPosIncrement -= 1;
        fCurLevelA -= fIncrement;
    }

    // next do bottom side points
    fCurLevelA = fIncrement;
    iCurLevelPos = cVertices - (cLevels + 2);
    fPos = 0.0f;
    fIntIncrement = fIncrement;
    rgiVertOffsets[1] = (UINT_IDX)iCurVertex;
    for (iLevel = 0; iLevel < cLevels+2; iLevel++)
    {
        vPos1 = D3DXVECTOR2(1.0f, 0.0f);
        vPos2 = D3DXVECTOR2(0.0f, 1.0f);

        if (rgiVerts[iCurLevelPos] == UNUSED)
        {
            D3DXVec2Lerp(&vPos, &vPos1, &vPos2, fPos);
            EvalBezierTri(&vPos, pbtTri, rgvControl, rgvControlNormal, bLinearNormals, pvPointsInt, cfvf, pbCurPoint);
            pbCurPoint += cfvf.m_cBytesPerVertex;
            rgiVerts[iCurLevelPos] = (UINT_IDX)iCurVertex;
            iCurVertex += 1;
            cNewVertices += 1;
        }

        iCurLevelPos += 1;
        fPos += fIntIncrement;
    }

    // process the inner vertices only if there are any
    if (cLevels > 0)
    {
        iCurLevelPos = 3;
        iPrevLevelPos = 1;
        fCurLevelA = fIncrement + fIncrement;
        iCurTriangle = 1;
        for (iLevel = 0; iLevel < cLevels - 1; iLevel++)
        {
            vPos1 = D3DXVECTOR2(fCurLevelA, 0.0f);
            vPos2 = D3DXVECTOR2(0.0f, fCurLevelA);

            fIntIncrement = 1.0f / (iLevel + 2.0f);
            fPos = fIntIncrement;

            for (iTriangle = 0; iTriangle < iLevel + 1; iTriangle++)
            {
                if (rgiVerts[iCurLevelPos + 1] == UNUSED)
                {
                    D3DXVec2Lerp(&vPos, &vPos1, &vPos2, fPos);
                    EvalBezierTri(&vPos, pbtTri, rgvControl, rgvControlNormal, bLinearNormals, pvPointsInt, cfvf, pbCurPoint);
                    pbCurPoint += cfvf.m_cBytesPerVertex;
                    rgiVerts[iCurLevelPos + 1] = (UINT_IDX)iCurVertex;
                    iCurVertex += 1;
                    cNewVertices += 1;
                }

                iCurLevelPos++;
                iPrevLevelPos++;
                fPos += fIntIncrement;
            }
            fCurLevelA += fIncrement;

            iPrevLevelPos += 1;
            iCurLevelPos += 2;
        }
    }

    // make certain that we haven't added too many vertices
    if (iCurVertex >= UNUSED)
    {
        return E_FAIL;
    }

    rgwFaceOut[0].rgwIndices[0] = rgiVerts[0];
    rgwFaceOut[0].rgwIndices[1] = rgiVerts[1];
    rgwFaceOut[0].rgwIndices[2] = rgiVerts[2];

    iCurLevelPos = 3;
    iPrevLevelPos = 1;
    iCurTriangle = 1;
    for (iLevel = 0; iLevel < cLevels; iLevel++)
    {
        for (iTriangle = 0; iTriangle < iLevel + 1; iTriangle++)
        {
            // add two triangles
            rgwFaceOut[iCurTriangle].rgwIndices[0] = rgiVerts[iPrevLevelPos];
            rgwFaceOut[iCurTriangle].rgwIndices[1] = rgiVerts[iCurLevelPos];
            rgwFaceOut[iCurTriangle].rgwIndices[2] = rgiVerts[iCurLevelPos + 1];
            iCurTriangle++;

            rgwFaceOut[iCurTriangle].rgwIndices[0] = rgiVerts[iPrevLevelPos];
            rgwFaceOut[iCurTriangle].rgwIndices[1] = rgiVerts[iCurLevelPos + 1];
            rgwFaceOut[iCurTriangle].rgwIndices[2] = rgiVerts[iPrevLevelPos + 1];
            iCurTriangle++;

            iCurLevelPos++;
            iPrevLevelPos++;
        }

        // add one triangle
        rgwFaceOut[iCurTriangle].rgwIndices[0] = rgiVerts[iPrevLevelPos];
        rgwFaceOut[iCurTriangle].rgwIndices[1] = rgiVerts[iCurLevelPos];
        rgwFaceOut[iCurTriangle].rgwIndices[2] = rgiVerts[iCurLevelPos + 1];
        iCurTriangle++;

        iPrevLevelPos += 1;
        iCurLevelPos += 2;
    }

    // update the current vertex pointer
    //iCurVertex += cNewVertices;

    pvPointsOut = pbCurPoint;

    return S_OK;
}

#if 0
// -------------------------------------------------------------------------------
//  method    D3DXTesselateBezierTri
//
//  devnote     Tesselates the given bezier triangle into a mesh
//
//  returns     S_OK if suceeded, else error code
//
HRESULT
D3DXTesselateBezierTri
(
    LPD3DXBEZIERTRI pbtTri,             // bezier triangle to tesselate
    LPD3DXVECTOR3 rgvControl,           // control point buffer (n control points, indexed by pbtTri)
    PVOID pvVertices,                   // vertices (indexed by pbtTri)
    DWORD cLevels,                       // number of levels of tesselation
    DWORD dwFVF,                        // FVF both for the mesh and the pvVertices vertex array
    DWORD dwOptions,                    // options to specify to the mesh
    LPDIRECT3DDEVICE8 pD3DDevice,       // device for mesh
    LPD3DXMESH *pptmMesh                  // output mesh for the tesselation
)
{
    HRESULT hr = S_OK;
    LPD3DXMESH ptmMesh = NULL;
    LPDIRECT3DVERTEXBUFFER8 pVertexBuffer = NULL;
    PVOID pvPoints = NULL;
    DXCrackFVF cfvf(dwFVF);

    DWORD cFacesOut;
    DWORD cFacesPrev;
    DWORD cVerticesOut;


    // temporary data
    SFaceTempStruct *rgwFaceTemp = NULL;
    DWORD *rgattrTemp = NULL;


    if ((rgvControl == NULL) || (pvVertices == NULL) || (dwOptions & D3DXMESH_32BIT))
        return D3DERR_INVALIDCALL;

    // get the number of faces and vertices generated
    CalculateCounts(cLevels, &cFacesOut, &cVerticesOut);

    rgwFaceTemp = new SFaceTempStruct[cFacesOut];
    rgattrTemp = new DWORD[cFacesOut];
    if ((rgwFaceTemp == NULL) || (rgattrTemp == NULL))
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    memset(rgattrTemp, 0, sizeof(DWORD) * cFacesOut);

    hr = D3DXCreateMeshFVF(cFacesOut, cVerticesOut, dwOptions, dwFVF, pD3DDevice, &ptmMesh);
    if (FAILED(hr))
        goto e_Exit;


    hr = ptmMesh->GetVertexBuffer(&pVertexBuffer);
    if (FAILED(hr))
        goto e_Exit;

    hr = pVertexBuffer->Lock(0,0, (PBYTE*)&pvPoints, 0);
    if (FAILED(hr))
        goto e_Exit;

    TesselateBTri(pbtTri, rgvControl, NULL, TRUE, pvVertices, cfvf, cLevels, cVerticesOut, 0, pvPoints, rgwFaceTemp);

    ptmMesh->SetMesh(rgwFaceTemp, rgattrTemp);

    *pptmMesh = ptmMesh;
    ptmMesh = NULL;

e_Exit:
    GXRELEASE(ptmMesh);

    delete []rgwFaceTemp;
    delete []rgattrTemp;

    if (pvPoints != NULL)
    {
        pVertexBuffer->Unlock();
    }
    GXRELEASE(pVertexBuffer);
    return hr;
}
#endif

// -------------------------------------------------------------------------------
//  method    CalculateEdgeControlPoint
//
//  devnote     Generate an interior control point given the position and normal
//
//  returns     S_OK if suceeded, else error code
//
void
CalculateEdgeControlPoint
(
    D3DXVECTOR3 *pvPos1, 
    D3DXVECTOR3 *pvPos0, 
    D3DXVECTOR3 *pvNormal, 
    float fTension, 
    D3DXVECTOR3 *pvControl
)
{
    //float fEdgeLen;
    //float fTanLen;
    D3DXVECTOR3 vEdge;
    D3DXVECTOR3 vTangent;
  	//edge = v1 - v0
	//Cv01 = v0 + (edge - (edge dot N0)*N0)*Tension

    *pvControl = *pvPos1;
    *pvControl -= *pvPos0;
    vEdge = *pvControl;
    *pvControl -= (D3DXVec3Dot(pvControl, pvNormal) * *pvNormal);
    vTangent = *pvControl;

#if 0
    fEdgeLen = D3DXVec3Length(&vEdge);
    fTanLen = D3DXVec3Length(&vTangent);

    fTension = ((2.0f / 3.0f) * (fEdgeLen / fTanLen)) / (1.0f + ( D3DXVec3Dot(&vEdge, &vTangent) / (fEdgeLen * fTanLen) ) );
#endif

    *pvControl *= fTension;
	*pvControl += *pvPos0;
}

// -------------------------------------------------------------------------------
//  method    CalculateEdgeControlPoint
//
//  devnote     Generate an interior control point given the position and normal
//
//  returns     S_OK if suceeded, else error code
//
void
CalculateEdgeControlPoint2
(
    D3DXVECTOR3 *pvPos1, 
    D3DXVECTOR3 *pvMid, 
    D3DXVECTOR3 *pvPos0, 
    D3DXVECTOR3 *pvNormal, 
    float fTension, 
    D3DXVECTOR3 *pvControl
)
{
  	//edge = v1 - mid
	//Cv01 = v0 + (edge - (edge dot N0)*N0)*Tension

    *pvControl = *pvPos1;
    *pvControl -= *pvMid;
    *pvControl -= (D3DXVec3Dot(pvControl, pvNormal) * *pvNormal);
    *pvControl *= fTension;
	*pvControl += *pvPos0;
}

void
EvalBezier( D3DXVECTOR3 *pvPos0, D3DXVECTOR3 *pvPos1, D3DXVECTOR3 *pvPos2, D3DXVECTOR3 *pvPos3, 
           float t, D3DXVECTOR3 *pvOut)
{
    D3DXVECTOR3 p[4];

    p[0] = *pvPos0;
    p[1] = *pvPos1;
    p[2] = *pvPos2;
    p[3] = *pvPos3;

    for (int r = 1; r <= 3; r++)
    {
        for (int i = 0; i <= 3-r; i++)
        {
            D3DXVec3Lerp(&p[i], &p[i], &p[i+1], t );
        }
    }

    *pvOut = p[0];
}

// -------------------------------------------------------------------------------
//  method    CalcEdge
//
//  devnote     Calculates the normalized edge vector between two points
//
void
CalcEdge
(
    D3DXVECTOR3 *pvNormEdge,
    D3DXVECTOR3 *pvPoint1,
    D3DXVECTOR3 *pvPoint2
)
{
    *pvNormEdge = *pvPoint1;
    *pvNormEdge -= *pvPoint2;
    D3DXVec3Normalize(pvNormEdge, pvNormEdge);
}

// -------------------------------------------------------------------------------
//  method    GenerateNormalControlPoints
//
//  devnote     Generate control points for normals from the normals and position provided
//
//  returns     S_OK if suceeded, else error code
//
void 
GenerateNormalControlPoints
(
    PVOID pvPoint0,
    PVOID pvPoint1,
    PVOID pvPoint2,
    DXCrackFVF &cfvf,
    LPD3DXVECTOR3 rgvControl
)
{
    D3DXVECTOR3 vNorm;
    D3DXVECTOR3 vProj;
    float fProj;

    rgvControl[0] = *cfvf.PvGetNormal(pvPoint0);
    rgvControl[2] = *cfvf.PvGetNormal(pvPoint1);
    rgvControl[4] = *cfvf.PvGetNormal(pvPoint2);

	// Navg = (N0 + N1)*0.5;		// average the normals at both ends
	// enorm = Normalize( v1 - v0 );		// normalize edge vector (wah)
	// Nproj = (enorm dot Navg)*Navg;	// project onto edge vector
	// Nmid = Navg - 2*Nproj;			// reflect it

    D3DXVec3Lerp( &rgvControl[1], &rgvControl[0], &rgvControl[2], 0.5);
    D3DXVec3Lerp( &rgvControl[3], &rgvControl[2], &rgvControl[4], 0.5);
    D3DXVec3Lerp( &rgvControl[5], &rgvControl[0], &rgvControl[4], 0.5);

    CalcEdge(&vNorm, cfvf.PvGetPosition(pvPoint1), cfvf.PvGetPosition(pvPoint0));
    fProj = D3DXVec3Dot(&vNorm, &rgvControl[1]);
    vProj = vNorm;
    vProj *= 2.0f * fProj;
    rgvControl[1] -= vProj;

    CalcEdge(&vNorm, cfvf.PvGetPosition(pvPoint2), cfvf.PvGetPosition(pvPoint1));
    fProj = D3DXVec3Dot(&vNorm, &rgvControl[3]);
    vProj = vNorm;
    vProj *= 2.0f * fProj;
    rgvControl[3] -= vProj;

    CalcEdge(&vNorm, cfvf.PvGetPosition(pvPoint0), cfvf.PvGetPosition(pvPoint2));
    fProj = D3DXVec3Dot(&vNorm, &rgvControl[5]);
    vProj = vNorm;
    vProj *= 2.0f * fProj;
    rgvControl[5] -= vProj;
}

// -------------------------------------------------------------------------------
//  method    GenerateControlPoints
//
//  devnote     Generate control points from the normals and position provided
//
//  returns     S_OK if suceeded, else error code
//
void 
GenerateControlPoints
(
    PVOID pvPoint0,
    PVOID pvPoint1,
    PVOID pvPoint2,
    DXCrackFVF &cfvf,
    float fExtSlack,
    float fIntSlack,
    LPD3DXVECTOR3 rgvControl
)
{
    D3DXVECTOR3 *pvPos0;
    D3DXVECTOR3 *pvPos1;
    D3DXVECTOR3 *pvPos2;
    D3DXVECTOR3 *pvNormal0;
    D3DXVECTOR3 *pvNormal1;
    D3DXVECTOR3 *pvNormal2;
    //float fTension = 1.0f / 3.0f; 		// for now.
    float fTension = fExtSlack; 		// for now.
    //float fTension = 0.55f; 		// for now.
    //float fTension = 0.45f; 		// for now.
    D3DXVECTOR3 vTemp;

    pvPos0 = cfvf.PvGetPosition(pvPoint0);
    pvPos1 = cfvf.PvGetPosition(pvPoint1);
    pvPos2 = cfvf.PvGetPosition(pvPoint2);
    pvNormal0 = cfvf.PvGetNormal(pvPoint0);
    pvNormal1 = cfvf.PvGetNormal(pvPoint1);
    pvNormal2 = cfvf.PvGetNormal(pvPoint2);

    rgvControl[0] = *pvPos0;
    rgvControl[3] = *pvPos1;
    rgvControl[6] = *pvPos2;

#if 0
    if (cfvf.CTexCoords() <= 1)
    {
#endif
        CalculateEdgeControlPoint(pvPos1, pvPos0, pvNormal0, fTension, &rgvControl[1]);

        CalculateEdgeControlPoint(pvPos0, pvPos1, pvNormal1, fTension, &rgvControl[2]);

        CalculateEdgeControlPoint(pvPos2, pvPos1, pvNormal1, fTension, &rgvControl[4]);

        CalculateEdgeControlPoint(pvPos1, pvPos2, pvNormal2, fTension, &rgvControl[5]);

        CalculateEdgeControlPoint(pvPos0, pvPos2, pvNormal2, fTension, &rgvControl[7]);

        CalculateEdgeControlPoint(pvPos2, pvPos0, pvNormal0, fTension, &rgvControl[8]);
#if 0  
    }  // crease prototype
    else
    {
        D3DXVECTOR3 *pvEdgeNormal0;
        D3DXVECTOR3 *pvEdgeNormal1;
        D3DXVECTOR3 *pvEdgeNormal2;

        pvEdgeNormal0 = (D3DXVECTOR3*)cfvf.PuvGetTex1(pvPoint0);
        pvEdgeNormal1 = (D3DXVECTOR3*)cfvf.PuvGetTex1(pvPoint1);
        pvEdgeNormal2 = (D3DXVECTOR3*)cfvf.PuvGetTex1(pvPoint2);

        if ((*pvEdgeNormal0 == *pvNormal0) || (*pvEdgeNormal1 == *pvNormal1))
        {
            CalculateEdgeControlPoint(pvPos1, pvPos0, pvNormal0, fTension, &rgvControl[1]);

            CalculateEdgeControlPoint(pvPos0, pvPos1, pvNormal1, fTension, &rgvControl[2]);
        }
        else
        {
            CalculateEdgeControlPoint(pvPos1, pvPos0, pvEdgeNormal0, fTension, &rgvControl[1]);

            CalculateEdgeControlPoint(pvPos0, pvPos1, pvEdgeNormal1, fTension, &rgvControl[2]);
        }


        if ((*pvEdgeNormal1 == *pvNormal1) || (*pvEdgeNormal2 == *pvNormal2))
        {
            CalculateEdgeControlPoint(pvPos2, pvPos1, pvNormal1, fTension, &rgvControl[4]);

            CalculateEdgeControlPoint(pvPos1, pvPos2, pvNormal2, fTension, &rgvControl[5]);
        }
        else
        {
            CalculateEdgeControlPoint(pvPos2, pvPos1, pvEdgeNormal1, fTension, &rgvControl[4]);

            CalculateEdgeControlPoint(pvPos1, pvPos2, pvEdgeNormal2, fTension, &rgvControl[5]);
        }

        if ((*pvEdgeNormal0 == *pvNormal0) || (*pvEdgeNormal2 == *pvNormal2))
        {
            CalculateEdgeControlPoint(pvPos0, pvPos2, pvNormal2, fTension, &rgvControl[7]);

            CalculateEdgeControlPoint(pvPos2, pvPos0, pvNormal0, fTension, &rgvControl[8]);
        }
        else
        {
            CalculateEdgeControlPoint(pvPos0, pvPos2, pvEdgeNormal2, fTension, &rgvControl[7]);

            CalculateEdgeControlPoint(pvPos2, pvPos0, pvEdgeNormal0, fTension, &rgvControl[8]);
        }
    }
#endif

	//Cv = (Cv01 + Cv02 + Cv12 + Cv10 + Cv21 + Cv20)/4.0;	// edge control pts
	//Cv -= (v0 + v1 + v2 )/6.0;					// corner pts

    vTemp = rgvControl[1];
    vTemp += rgvControl[2];
    vTemp += rgvControl[4];
    vTemp += rgvControl[5];
    vTemp += rgvControl[7];
    vTemp += rgvControl[8];
    vTemp /= 4;
    //vTemp /= 3;
    //vTemp /= 2.4f;
    //vTemp /= 1.5f;
    rgvControl[9] = vTemp;

    vTemp = rgvControl[0];
    vTemp += rgvControl[3];
    vTemp += rgvControl[6];
    //vTemp /= 3;
    vTemp /= 6;
    //vTemp /= 2.0f;
    //vTemp /= 1.0f;
    rgvControl[9] -= vTemp;
}

DWORD FindNeighbor
    (
    CONST DWORD *pdwAdjacency, 
    DWORD iFace
    )
{
    if (pdwAdjacency[0] == iFace)
        return 0;
    else if (pdwAdjacency[1] == iFace)
        return 1;
    else 
        return 2;
}

template<class UINT_IDX, unsigned int UNUSED>
void InitVertIndices
    (
    UINT_IDX *rgiVerts, 
    DWORD cLevels, 
    DWORD cVertices, 
    DWORD iFace, 
    SFaceTempStruct<UINT_IDX> *rgwFaces, 
    CONST DWORD *rgdwAdjacency, 
    SVertOffsetStruct<UINT_IDX> *rgdwVertOffsets
    )
{
    CONST DWORD *pdwAdjacency;
    UINT_IDX rgiVertOffsets[3];
    DWORD iOffset;
    DWORD iEdge;
    DWORD iNeighbor;
    DWORD iLeftPos;
    DWORD iRightPos;
    DWORD iPoint;
    DWORD iInc;
    SFaceTempStruct<UINT_IDX> *pwFace = &rgwFaces[iFace];


    memset(rgiVerts, 0xff, cVertices * sizeof(UINT_IDX));

    if ((rgdwAdjacency != NULL) && (cLevels > 0))
    {
        pdwAdjacency = &rgdwAdjacency[iFace * 3];

        for (iOffset = 0; iOffset < 3; iOffset++)
        {
            iNeighbor = pdwAdjacency[iOffset];
            if (iNeighbor != UNUSED32)
            {
                iEdge = FindNeighbor(&rgdwAdjacency[iNeighbor * 3], iFace);

                // make certain that there is no crease between this triangle and the neighbor
                if ((rgwFaces[iNeighbor].rgwIndices[iEdge] == pwFace->rgwIndices[(iOffset+1)%3])
                    && (rgwFaces[iNeighbor].rgwIndices[(iEdge+1)%3] == pwFace->rgwIndices[iOffset]))
                {
                    rgiVertOffsets[iOffset] = rgdwVertOffsets[iNeighbor].rgdwOffsets[iEdge];
                }
                else
                {
                    rgiVertOffsets[iOffset] = UNUSED;
                }
            }
            else
            {
                rgiVertOffsets[iOffset] = UNUSED;
            }
        }

        if ((rgiVertOffsets[2] != UNUSED) || (rgiVertOffsets[0] != UNUSED))
        {
            if (rgiVertOffsets[0] != UNUSED)
                rgiVertOffsets[0] += (UINT_IDX)(cLevels - 1);

            iLeftPos = 1;
            iRightPos = 2;
            iInc = 2;
            for (iPoint = 0; iPoint < cLevels; iPoint++)
            {
                if (rgiVertOffsets[0] != UNUSED)
                {
                    rgiVerts[iLeftPos] = (UINT_IDX)rgiVertOffsets[0];
                    rgiVertOffsets[0] -= 1;
                }

                if (rgiVertOffsets[2] != UNUSED)
                {
                    rgiVerts[iRightPos] = (UINT_IDX)rgiVertOffsets[2];
                    rgiVertOffsets[2] += 1;
                }

                iLeftPos += iInc;
                iInc += 1;
                iRightPos += iInc;
            }
        }

        if (rgiVertOffsets[1] != UNUSED)
        {
            iLeftPos = cVertices - 2;
            for (iPoint = 0; iPoint < cLevels; iPoint++)
            {
                rgiVerts[iLeftPos] = (UINT_IDX)rgiVertOffsets[1];
                rgiVertOffsets[1] += 1;

                iLeftPos -= 1;
            }
           
        }
    }

    rgiVerts[0] = pwFace->rgwIndices[0];
    rgiVerts[cVertices - (cLevels + 2)] = pwFace->rgwIndices[1];
    rgiVerts[cVertices-1] = pwFace->rgwIndices[2];
}

// -------------------------------------------------------------------------------
//  method    D3DXTesselateMesh
//
//  devnote     Tesselates the given mesh, treating each triangle as a bezier triangle
//
//  returns     S_OK if suceeded, else error code
//
template<class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
inline
HRESULT 
D3DXTesselateMeshEx
(
    LPD3DXMESH ptmMeshIn,               // mesh to tesselate
    CONST DWORD *rgdwAdjacency,               // adjacency info
    FLOAT fNumSegs,                      // number of segments per edge to tesselate to
    BOOL bQuadraticNormals,             // if true use quadratic interp for normals, if false use linear
    LPD3DXMESH *pptmMeshOut,             // tesselated mesh
    UINT_IDX Bogus
)
{
    DWORD cNumSegs = (DWORD)fNumSegs;
    DWORD cLevels = (cNumSegs == 0) ? 0 : cNumSegs - 1;
    DWORD iNormalInterpDegree = bQuadraticNormals ? 2 : 1;
    float fExtSlack = 1.0f/3.0f;
    float fIntSlack = 2.0f/3.0f;

    HRESULT hr = S_OK;
    DWORD cNewFacesPerTriangle;
    DWORD cNewVerticesPerTriangle;
    DWORD cFacesOrig;
    DWORD cFacesNew;
    DWORD cVerticesOrig;
    DWORD cVerticesNew;
    DWORD dwOptions;
    DWORD dwFVF;
    LPDIRECT3DDEVICE8 pD3DDevice;
    LPD3DXMESH ptmMesh = NULL;
    SFaceTempStruct<UINT_IDX> *rgwFaceOrig = NULL;
    SFaceTempStruct<UINT_IDX> *pwFaceCur;
    SVertOffsetStruct<UINT_IDX> *rgdwVertOffsets = NULL;
    D3DXBEZIERTRI btri;
    D3DXVECTOR3 rgvControl[10];
    D3DXVECTOR3 rgvControlNormal[6];
    DWORD iCurVertex;
    DWORD iFace;
    DWORD iFaceNew;
    DXCrackFVF cfvf(D3DFVF_XYZ);
    DWORD iPoint;

    PBYTE pvPointsNew = NULL;
    PBYTE pvPointsNewMesh = NULL;
    PBYTE pvPointsOrig = NULL;
    PBYTE pvPointsCur = NULL;
    DWORD *rgattrIn = NULL;
    BOOL bLinearNormals;
    PBYTE rgbVertBuf = NULL;
    PBYTE rgbFaceBuf = NULL;
    UINT_IDX *rgwFacesNewMesh = NULL;
    DWORD *rgattrNew = NULL;

//    DWORD rgiVertOffsets[3];

    // temporary data
    SFaceTempStruct<UINT_IDX> *rgwFaceTemp = NULL;
    DWORD *rgattrTemp = NULL;
    UINT_IDX *rgiVerts;

    if ((ptmMeshIn == NULL) || (pptmMeshOut == NULL) 
        || ((iNormalInterpDegree != 1) && (iNormalInterpDegree != 2)))
    {
        hr = D3DERR_INVALIDCALL;
        goto e_Exit;
    }

    if (b16BitIndex)
    {
        GXASSERT(!(ptmMeshIn->GetOptions() & D3DXMESH_32BIT));
    }
    else
    {
        GXASSERT(ptmMeshIn->GetOptions() & D3DXMESH_32BIT);
    }

    bLinearNormals = iNormalInterpDegree == 1;

    // first calculate the new faces/vertex counts from the original and tesselation level
    cFacesOrig = ptmMeshIn->GetNumFaces();
    cVerticesOrig = ptmMeshIn->GetNumVertices();
    dwFVF = ptmMeshIn->GetFVF();
    dwOptions = ptmMeshIn->GetOptions();
    ptmMeshIn->GetDevice(&pD3DDevice);
    pD3DDevice->Release(); // ptmMeshIn still maintains a ref to it, create mesh will add another
    cfvf = DXCrackFVF(dwFVF);

    CalculateCounts(cLevels, &cNewFacesPerTriangle, &cNewVerticesPerTriangle);

    cVerticesNew = cNewVerticesPerTriangle * cFacesOrig;
    cFacesNew = cNewFacesPerTriangle * cFacesOrig;

    rgiVerts = (UINT_IDX*)_alloca(cNewVerticesPerTriangle * sizeof(UINT_IDX));

    // if too many for a 16 bit mesh, bail
    if ((cFacesNew >= UNUSED) || (cVerticesNew >= UNUSED))
    {
        if (b16BitIndex)
            DPF(0, "D3DXTesselateMesh: Too many faces/vertices for a 16bit mesh, convert input mesh to 32 bit and try again\n");
        else
            DPF(0, "D3DXTesselateMesh: Too many faces/vertices for a 32bit mesh\n");

        hr = D3DERR_INVALIDCALL;
        goto e_Exit;
    }

    // work around issue with delete's not working on arrays of templated structures
    rgbFaceBuf = new BYTE[sizeof(SFaceTempStruct<UINT_IDX>) * cFacesNew];
    rgbVertBuf = new BYTE[sizeof(SVertOffsetStruct<UINT_IDX>) * cFacesNew];

    // need to create these wonderful arrays to temporarily fill
    rgwFaceTemp = (SFaceTempStruct<UINT_IDX>*)rgbFaceBuf;
    rgdwVertOffsets = (SVertOffsetStruct<UINT_IDX>*)rgbVertBuf;
    rgattrTemp = new DWORD[cFacesNew];
    pvPointsNew = new BYTE[cfvf.m_cBytesPerVertex * cVerticesNew];
    if ((rgwFaceTemp == NULL) || (rgattrTemp == NULL) || (rgdwVertOffsets == NULL) || (pvPointsNew == NULL))
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    // initialize all vert offsets to unused
    memset(rgdwVertOffsets, 0xff, sizeof(SVertOffsetStruct<UINT_IDX>) * cFacesNew);

    hr = ptmMeshIn->LockAttributeBuffer(D3DLOCK_READONLY ,&rgattrIn);
    if (FAILED(hr))
        goto e_Exit;

    for (iFace = 0; iFace < cFacesOrig; iFace++)
    {
        for (iFaceNew = 0; iFaceNew < cNewFacesPerTriangle; iFaceNew++)
        {
            rgattrTemp[iFace * cNewFacesPerTriangle + iFaceNew] = rgattrIn[iFace];
        }
    }

    hr = ptmMeshIn->LockIndexBuffer(0, (PBYTE*)&rgwFaceOrig);
    if (FAILED(hr))
        goto e_Exit;

    hr = ptmMeshIn->LockVertexBuffer(0, &pvPointsOrig);
    if (FAILED(hr))
        goto e_Exit;

    memcpy(pvPointsNew, pvPointsOrig, cVerticesOrig * cfvf.m_cBytesPerVertex);

    // probably should remove this extra level of indirection
    for (iPoint = 0; iPoint < 10; iPoint++)
    {
        btri.rgiControlPoints[iPoint] = static_cast<UINT16>(iPoint);
    }

    pvPointsCur = (PBYTE)pvPointsNew + cVerticesOrig * cfvf.m_cBytesPerVertex;
    pwFaceCur = rgwFaceTemp;
    iCurVertex = cVerticesOrig;
    for (iFace = 0; iFace < cFacesOrig; iFace++)
    {
        GenerateControlPoints(cfvf.GetArrayElem(pvPointsOrig, rgwFaceOrig[iFace].rgwIndices[0]),
                              cfvf.GetArrayElem(pvPointsOrig, rgwFaceOrig[iFace].rgwIndices[1]),
                              cfvf.GetArrayElem(pvPointsOrig, rgwFaceOrig[iFace].rgwIndices[2]), 
                              cfvf, fExtSlack, fIntSlack,
                              rgvControl);

        if (!bLinearNormals)
        {
            GenerateNormalControlPoints(cfvf.GetArrayElem(pvPointsOrig, rgwFaceOrig[iFace].rgwIndices[0]),
                                        cfvf.GetArrayElem(pvPointsOrig, rgwFaceOrig[iFace].rgwIndices[1]),
                                        cfvf.GetArrayElem(pvPointsOrig, rgwFaceOrig[iFace].rgwIndices[2]), 
                                        cfvf,
                                        rgvControlNormal);
        }

        for (iPoint = 0; iPoint < 3; iPoint++)
        {
            btri.rgiVertices[iPoint] = rgwFaceOrig[iFace].rgwIndices[iPoint];
        }

        InitVertIndices<UINT_IDX,UNUSED>(rgiVerts, cLevels, cNewVerticesPerTriangle, iFace, rgwFaceOrig, rgdwAdjacency, rgdwVertOffsets);

        hr = TesselateBTri<UINT_IDX,UNUSED>(&btri, rgvControl, rgvControlNormal, bLinearNormals, pvPointsOrig, rgiVerts, cfvf, cLevels, cNewVerticesPerTriangle, iCurVertex, pvPointsCur, pwFaceCur, rgdwVertOffsets[iFace].rgdwOffsets);
        if (FAILED(hr))
            goto e_Exit;

        pwFaceCur += cNewFacesPerTriangle;
    }

    // create mesh after tesselation when number of vertices is known
    hr = D3DXCreateMeshFVF(cFacesNew, iCurVertex, dwOptions, dwFVF, pD3DDevice, &ptmMesh);
    if (FAILED(hr))
        goto e_Exit;

    // latch in the face neighborhood
    hr = ptmMesh->LockVertexBuffer(0, (PBYTE*)&pvPointsNewMesh);
    if (FAILED(hr))
        goto e_Exit;

    hr = ptmMesh->LockIndexBuffer(0, (PBYTE*)&rgwFacesNewMesh);
    if (FAILED(hr))
        goto e_Exit;

    hr = ptmMesh->LockAttributeBuffer(0, &rgattrNew);
    if (FAILED(hr))
        goto e_Exit;

    memcpy(pvPointsNewMesh, pvPointsNew, cfvf.m_cBytesPerVertex * iCurVertex);
    memcpy(rgwFacesNewMesh, rgwFaceTemp, cFacesNew * 3 * sizeof(UINT_IDX));
    memcpy(rgattrNew, rgattrTemp, sizeof(DWORD) * cFacesNew);

    *pptmMeshOut = ptmMesh;
    ptmMesh->AddRef();

e_Exit:
    delete []rgattrTemp;
    delete []rgbFaceBuf;
    delete []rgbVertBuf;
    delete []pvPointsNew;

    if (rgattrIn != NULL)
    {
        ptmMeshIn->UnlockAttributeBuffer();
    }

    if (rgwFaceOrig != NULL)
    {
        ptmMeshIn->UnlockIndexBuffer();
    }

    if (rgwFacesNewMesh != NULL)
    {
        ptmMesh->UnlockIndexBuffer();
    }
    
    if (rgattrNew != NULL)
    {
        ptmMesh->UnlockAttributeBuffer();
    }

    if (pvPointsNewMesh != NULL)
    {
        ptmMesh->UnlockVertexBuffer();
    }
 
    if (pvPointsOrig != NULL)
    {
        ptmMeshIn->UnlockVertexBuffer();
    } 

    GXRELEASE(ptmMesh);

    return hr;
}


// -------------------------------------------------------------------------------
//  method    D3DXTesselateMesh
//
//  devnote     Tesselates the given mesh, treating each triangle as a bezier triangle
//
//  returns     S_OK if suceeded, else error code
//
HRESULT WINAPI
D3DXTesselateMesh
(
    LPD3DXMESH ptmMeshIn,               // mesh to tesselate
    CONST DWORD *rgdwAdjacency,               // adjacency info
    FLOAT fNumSegs,                      // number of segments per edge to tesselate to
    BOOL bQuadraticNormals,             // if true use quadratic interp for normals, if false use linear
    LPD3DXMESH *pptmMeshOut             // tesselated mesh
)
{
    unsigned int Bogus1 = 0;
    unsigned short Bogus2 = 0;
	if (ptmMeshIn == NULL)
    {
        DPF(0, "D3DXTesselateMesh: Failed due to input mesh being NULL\n");
		return D3DERR_INVALIDCALL;
    }

    if (ptmMeshIn->GetOptions() & D3DXMESH_32BIT)
        return D3DXTesselateMeshEx<unsigned int, FALSE, UNUSED32>(ptmMeshIn, rgdwAdjacency, fNumSegs, bQuadraticNormals, pptmMeshOut, Bogus1);
    else
        return D3DXTesselateMeshEx<unsigned short, TRUE, UNUSED16>(ptmMeshIn, rgdwAdjacency, fNumSegs, bQuadraticNormals, pptmMeshOut, Bogus2);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\mesh\cleanmesh.cpp ===
/*//////////////////////////////////////////////////////////////////////////////
//
// File: createmesh.cpp
//
// Copyright (C) 1999 Microsoft Corporation. All Rights Reserved.
//
// @@BEGIN_MSINTERNAL
//
// History:
// -@-          (craigp)    - created 
// -@- 08/19/99 (mikemarr)  - prepend GX to gxfmath functions
//                          - started comment history
//                          - replace references to gxbasetype.h with gxmathcore.h
// -@- 09/23/99 (mikemarr)  - changed <> to "" on #includes
//
// @@END_MSINTERNAL
//
//////////////////////////////////////////////////////////////////////////////*/

#include "pchmesh.h"
#include "orbitvertex.h"

template<class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT ValidateIndices
    (
	UINT_IDX *rgwIndices,
	CONST DWORD *rgdwAdjacency,
	DWORD cFaces,
	DWORD cVertices
	);


// break bowties... two fans of triangles using the same vertex, just add a new vertex
HRESULT D3DXBreakBowTies
    (
    LPD3DXMESH pMeshIn,
    CONST DWORD *rgdwAdjacency,
    LPD3DXMESH *ppMeshOut
    )
{
    HRESULT hr = S_OK;
    BYTE *rgbFaceSeen = NULL;
    DWORD *rgdwFaceIds = NULL;
    DWORD *rgdwNewVertices = NULL;
    DWORD cNewVerticesMax;
    DWORD cNewVertices;
    DWORD cVertices;
    DWORD cFaces;
    COrbitVertexIter ovi(NULL, NULL, 2);
    BOOL b16BitIndex;
    DWORD wPoint;
    DWORD wCurPoint;
    DWORD iPoint;
    DWORD iCurPoint;
    DWORD iCurFace;
    WORD *rgwIndices = NULL;
    DWORD *rgdwIndices;
    WORD *rgwIndicesNew = NULL;
    DWORD *rgdwIndicesNew = NULL;
    WORD *rgwIndicesOut = NULL;
    PBYTE pbPointsOut = NULL;
    PBYTE pbPointsIn = NULL;
    PBYTE pbCurPoint;
    PBYTE pbSplitPoint;
    DWORD iVertex;
    DWORD iFace;
    DWORD iReplaceVertex;
    DWORD iReplaceValue;
    DWORD *rgdwTemp;
    DWORD iCurNewVertex;
    DXCrackFVF cfvf(D3DFVF_XYZ);
    LPD3DXMESH pMeshOut = NULL;
    LPDIRECT3DDEVICE8 pDevice;

    if ((pMeshIn == NULL) || (rgdwAdjacency == NULL) || (ppMeshOut == NULL))
    {
        hr = D3DERR_INVALIDCALL;
        goto e_Exit;
    }

    cVertices = pMeshIn->GetNumVertices();
    cFaces = pMeshIn->GetNumFaces();
    b16BitIndex = !(pMeshIn->GetOptions() & D3DXMESH_32BIT);
    cfvf = DXCrackFVF(pMeshIn->GetFVF());

    hr = pMeshIn->LockIndexBuffer(0, (PBYTE*)&rgwIndices);
    if (FAILED(hr))
        goto e_Exit;
    rgdwIndices = (DWORD*)rgwIndices;

	if (b16BitIndex)
	{
		hr = ValidateIndices<unsigned short, TRUE, UNUSED16>(rgwIndices, rgdwAdjacency, cFaces, cVertices);
		if (FAILED(hr))
			goto e_Exit;
	}
	else
	{
		hr = ValidateIndices<unsigned int, FALSE, UNUSED32>((unsigned int*)rgdwIndices, rgdwAdjacency, cFaces, cVertices);
		if (FAILED(hr))
			goto e_Exit;
	}

    ovi = COrbitVertexIter(rgdwAdjacency, (PVOID)rgwIndices, b16BitIndex ? 2 : 4);

    cNewVertices = 0; 
    cNewVerticesMax = 10;
    iCurNewVertex = cVertices;

    rgbFaceSeen = new BYTE[cFaces * 3];
    rgdwFaceIds = new DWORD[cVertices];
    rgdwNewVertices = new DWORD[cNewVerticesMax];
    if ((rgbFaceSeen == NULL) 
        || (rgdwFaceIds == NULL)
        || (rgdwNewVertices == NULL))
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }
    if (b16BitIndex)
    {
        rgwIndicesNew = new WORD[cFaces * 3];
        if (rgwIndicesNew == NULL) 
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }
        memcpy(rgwIndicesNew, rgwIndices, sizeof(WORD) * 3 * cFaces);
    }
    else
    {
        rgdwIndicesNew = new DWORD[cFaces * 3];
        if (rgdwIndicesNew == NULL) 
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }
        memcpy(rgdwIndicesNew, rgdwIndices, sizeof(DWORD) * 3 * cFaces);
    }


    memset(rgbFaceSeen, 0, sizeof(BYTE) * 3 * cFaces);
    memset(rgdwFaceIds, 0xff, sizeof(DWORD) * cVertices);

    for (iFace = 0; iFace < cFaces; iFace++)
    {
        for (iPoint = 0; iPoint < 3; iPoint++)
        {
            if (!rgbFaceSeen[iFace * 3 + iPoint])
            {
                rgbFaceSeen[iFace*3 + iPoint] = TRUE;

                if (b16BitIndex)
                {
                    wPoint = rgwIndices[iFace * 3 + iPoint];
                }
                else
                {
                    wPoint = rgdwIndices[iFace * 3 + iPoint];
                }

                ovi.Init(iFace, wPoint, x_iAllFaces);
                ovi.MoveToCCWFace();

                iReplaceVertex = UNUSED32;
                iReplaceValue = UNUSED32;

                while (!ovi.BEndOfList())
                {
                    iCurFace = ovi.GetNextFace();

                    iCurPoint = ovi.IGetPointIndex();
                    rgbFaceSeen[iCurFace * 3 + iCurPoint] = TRUE;

                    if (b16BitIndex)
                    {
                        wCurPoint = rgwIndices[iCurFace * 3 + iCurPoint];
                    }
                    else
                    {
                        wCurPoint = rgdwIndices[iCurFace * 3 + iCurPoint];
                    }

                    // if the point is in the process of being split, then remap to new value
                    if (wCurPoint == iReplaceVertex)
                    {
                        if (b16BitIndex)
                            rgwIndicesNew[iCurFace * 3 + iCurPoint] = (WORD)iReplaceValue;
                        else
                            rgdwIndicesNew[iCurFace * 3 + iCurPoint] = (WORD)iReplaceValue;
                    }
                    // if unclaimed, then claim it
                    else if (rgdwFaceIds[wCurPoint] == UNUSED32)
                    {
                        rgdwFaceIds[wCurPoint] = iFace;
                    }
                    // if it is claimed, but not by a face in this orbit, then split (bow tie found)
                    else if (rgdwFaceIds[wCurPoint] != iFace)
                    {
                        // realloc arry if neccessary
                        if (cNewVertices == cNewVerticesMax)
                        {
                            cNewVerticesMax *= 2;
                            rgdwTemp = new DWORD[cNewVerticesMax];
                            if (rgdwTemp == NULL)
                            {
                                hr = E_OUTOFMEMORY;
                                goto e_Exit;
                            }

                            memcpy(rgdwTemp, rgdwNewVertices, sizeof(DWORD) * cNewVertices);
                            
                            rgdwNewVertices = rgdwTemp;
                        }

                        // come up with a new vertex to split out to
                        iReplaceVertex = wCurPoint;
                        iReplaceValue = iCurNewVertex;
                        iCurNewVertex += 1;

                        // add a new point to be replicated onto the end of the original vertex buffer
                        rgdwNewVertices[cNewVertices] = iReplaceVertex;
                        cNewVertices += 1;

                        // update the current face to point at the next value
                        if (b16BitIndex)
                            rgwIndicesNew[iCurFace * 3 + iCurPoint] = (WORD)iReplaceValue;
                        else
                            rgdwIndicesNew[iCurFace * 3 + iCurPoint] = (WORD)iReplaceValue;
                    }
                }
            }
        }
    }

    GXASSERT(iCurNewVertex == cVertices + cNewVertices);

    // if any vertices were split, create a new mesh
    if (cNewVertices > 0)
    {
        pMeshIn->GetDevice(&pDevice);
        pDevice->Release(); // pMeshIn still maintains a ref to it, create mesh will add another

        hr = D3DXCreateMeshFVF(cFaces, iCurNewVertex, pMeshIn->GetOptions(), pMeshIn->GetFVF(), pDevice, &pMeshOut);
        if (FAILED(hr))
            goto e_Exit;

        hr = pMeshOut->LockIndexBuffer(0, (PBYTE*)&rgwIndicesOut);
        if (FAILED(hr))
            goto e_Exit;

        hr = pMeshIn->LockVertexBuffer(0, &pbPointsIn);
        if (FAILED(hr))
            goto e_Exit;

        hr = pMeshOut->LockVertexBuffer(0, &pbPointsOut);
        if (FAILED(hr))
            goto e_Exit;

        if (b16BitIndex)
            memcpy(rgwIndicesOut, rgwIndicesNew, sizeof(WORD) * 3 * cFaces);
        else
            memcpy(rgwIndicesOut, rgdwIndicesNew, sizeof(DWORD) * 3 * cFaces);

        memcpy(pbPointsOut, pbPointsIn, cfvf.m_cBytesPerVertex * cVertices);

        pbCurPoint = pbPointsOut + cfvf.m_cBytesPerVertex * cVertices;
        for (iVertex = 0; iVertex < cNewVertices; iVertex++)
        {
            pbSplitPoint = cfvf.GetArrayElem(pbPointsIn, rgdwNewVertices[iVertex]);
            memcpy(pbCurPoint, pbSplitPoint, cfvf.m_cBytesPerVertex);

            pbCurPoint += cfvf.m_cBytesPerVertex;
        }

        *ppMeshOut = pMeshOut;
        pMeshOut->AddRef();
    }
    else // no bow ties found return the same mesh
    {
        *ppMeshOut = pMeshIn;
        pMeshIn->AddRef();
    }


e_Exit:
    delete []rgdwFaceIds;
    delete []rgbFaceSeen;
    delete []rgdwNewVertices;
    delete []rgwIndicesNew;
    delete []rgdwIndicesNew;

    if (rgwIndices != NULL)
    {
        pMeshIn->UnlockIndexBuffer();
    }

    if (rgwIndicesOut != NULL)
    {
        pMeshOut->UnlockIndexBuffer();
    }

    if (pbPointsIn != NULL)
    {
        pMeshIn->UnlockVertexBuffer();
    }

    if (pbPointsOut != NULL)
    {
        pMeshOut->UnlockVertexBuffer();
    }

    GXRELEASE(pMeshOut);

    return hr;
}

// clean a mesh up for simplification (try to make manifold) currently only breaks bowties
HRESULT WINAPI D3DXCleanMesh
    (
    LPD3DXMESH pMeshIn,
    CONST DWORD *rgdwAdjacency,
    LPD3DXMESH *ppMeshOut
    )
{
	HRESULT hr = S_OK;
    hr = D3DXBreakBowTies(pMeshIn, rgdwAdjacency,ppMeshOut);

#ifdef _DEBUG
	// if debug, do a valid mesh to spit other consistencies out to 
	//  the debug window, but DON'T return the return code
	//    CleanMesh succeeds if it cleans up what is is supposed to
    if (!FAILED(hr))
	    D3DXValidMesh(*ppMeshOut, rgdwAdjacency);
#endif

	return hr;
}

template<class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT ValidateIndices
    (
	UINT_IDX *rgwIndices,
	CONST DWORD *rgdwAdjacency,
	DWORD cFaces,
	DWORD cVertices
	)
{
	HRESULT hr = S_OK;
	DWORD iFace;
	DWORD iPoint;
    DWORD iPointBad;
    DWORD iFaceBad;

	for (iFace = 0; iFace < cFaces; iFace++)
	{
		// make sure that the index values are valid
		for (iPoint = 0; iPoint < 3; iPoint++)
		{
			if ((rgwIndices[iFace*3 + iPoint] >= cVertices) 
				|| (rgwIndices[iFace*3 + iPoint] == UNUSED))
			{
				DPF(0, "D3DXValidIndices: An invalid index value(%d) was found on face %d", rgwIndices[iFace*3 + iPoint], iFace);
				hr = D3DXERR_INVALIDMESH;
			}

			if ((rgdwAdjacency[iFace*3 + iPoint] >= cFaces) && (rgdwAdjacency[iFace*3 + iPoint] != UNUSED32)) 
			{
				DPF(0, "D3DXValidIndices: An invalid neighbor index value(%d) was found on face %d", rgdwAdjacency[iFace*3 + iPoint], iFace);
				hr = D3DXERR_INVALIDMESH;
			}
		}

		// first check to make sure that there are no degenerate triangles with
		//   two or more identical vertex indices per face
		if ((rgwIndices[iFace*3 + 0] == rgwIndices[iFace*3 + 1])
			|| (rgwIndices[iFace*3 + 0] == rgwIndices[iFace*3 + 2])
			|| (rgwIndices[iFace*3 + 1] == rgwIndices[iFace*3 + 2]))
		{
            if (rgwIndices[iFace*3 + 0] == rgwIndices[iFace*3 + 1])
                iPointBad = rgwIndices[iFace*3 + 0];
            else if (rgwIndices[iFace*3 + 1] == rgwIndices[iFace*3 + 2])
                iPointBad = rgwIndices[iFace*3 + 2];
            else //if (rgwIndices[iFace*3 + 0] == rgwIndices[iFace*3 + 2])
                iPointBad = rgwIndices[iFace*3 + 0];

			DPF(0, "D3DXValidIndices: A point(%d) was found more than once in triangle %d", iPointBad, iFace);
			hr = D3DXERR_INVALIDMESH;
		}

		// next make sure that each triangle points
		//   two or more identical vertex indices per face
		if (((rgdwAdjacency[iFace*3 + 0] == rgdwAdjacency[iFace*3 + 1]) && (rgdwAdjacency[iFace*3 + 0] != UNUSED32))
			|| ((rgdwAdjacency[iFace*3 + 0] == rgdwAdjacency[iFace*3 + 2]) && (rgdwAdjacency[iFace*3 + 0] != UNUSED32))
			|| ((rgdwAdjacency[iFace*3 + 1] == rgdwAdjacency[iFace*3 + 2]) && (rgdwAdjacency[iFace*3 + 1] != UNUSED32)))
		{
		    if ((rgdwAdjacency[iFace*3 + 0] == rgdwAdjacency[iFace*3 + 1]) && (rgdwAdjacency[iFace*3 + 0] != UNUSED32))
                iFaceBad = rgdwAdjacency[iFace*3 + 0];
            else if ((rgdwAdjacency[iFace*3 + 0] == rgdwAdjacency[iFace*3 + 2]) && (rgdwAdjacency[iFace*3 + 0] != UNUSED32))
                iFaceBad = rgdwAdjacency[iFace*3 + 0];
			else // if  ((rgdwAdjacency[iFace*3 + 1] == rgdwAdjacency[iFace*3 + 2]) && (rgdwAdjacency[iFace*3 + 1] != UNUSED32)))
                iFaceBad = rgdwAdjacency[iFace*3 + 1];

			DPF(0, "D3DXValidIndices: A neighbor triangle index(%d) was found more than once on triangle %d", iFaceBad, iFace);
			DPF(0, "D3DXValidIndices:   (Likely problem is that two triangles share same points with opposite orientations)");
			hr = D3DXERR_INVALIDMESH;
		}
	}

	return hr;
}
 


template<class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT D3DXValidMeshEx
    (
    LPD3DXMESH pMeshIn,
    CONST DWORD *rgdwAdjacency,
	UINT_IDX Bogus
    )
{
	HRESULT hr = S_OK;
	UINT_IDX *rgwIndices = NULL;
	DWORD cVertices;
	DWORD cFaces;
	DWORD iFace;
	DWORD iPoint;
	UINT_IDX wPoint;
	DWORD iCurPoint;
	DWORD iCurFace;
	UINT_IDX wCurPoint;
	DXCrackFVF cfvf(D3DFVF_XYZ);
	BYTE *rgbFaceSeen = NULL;
	UINT_IDX *rgwFaceIds = NULL;
    COrbitVertexIter ovi(NULL, NULL, 2);

    if ((pMeshIn == NULL) || (rgdwAdjacency == NULL))
    {
        hr = D3DERR_INVALIDCALL;
        goto e_Exit;
    }

    cVertices = pMeshIn->GetNumVertices();
    cFaces = pMeshIn->GetNumFaces();
    cfvf = DXCrackFVF(pMeshIn->GetFVF());

    hr = pMeshIn->LockIndexBuffer(0, (PBYTE*)&rgwIndices);
    if (FAILED(hr))
        goto e_Exit;

	hr = ValidateIndices<UINT_IDX,b16BitIndex,UNUSED>(rgwIndices, rgdwAdjacency, cFaces, cVertices);
	if (FAILED(hr))
		goto e_Exit;

	// allocate buffers to check for bow ties
    rgbFaceSeen = new BYTE[cFaces * 3];
    rgwFaceIds = new UINT_IDX[cVertices];
    if ((rgbFaceSeen == NULL) 
        || (rgwFaceIds == NULL))
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    memset(rgbFaceSeen, 0, sizeof(BYTE) * 3 * cFaces);
    memset(rgwFaceIds, 0xff, sizeof(UINT_IDX) * cVertices);

    ovi = COrbitVertexIter(rgdwAdjacency, (PVOID)rgwIndices, b16BitIndex ? 2 : 4);

	// actually check all the faces for bowties
	for (iFace = 0; iFace < cFaces; iFace++)
	{
        for (iPoint = 0; iPoint < 3; iPoint++)
        {
            if (!rgbFaceSeen[iFace*3 + iPoint])
            {
                rgbFaceSeen[iFace*3 + iPoint] = TRUE;

                wPoint = rgwIndices[iFace*3 + iPoint];

				// walk all the faces around the point looking for bowties
                ovi.Init(iFace, wPoint, x_iAllFaces);
                ovi.MoveToCCWFace();
                while (!ovi.BEndOfList())
                {
                    iCurFace = ovi.GetNextFace();

                    iCurPoint = ovi.IGetPointIndex();
                    rgbFaceSeen[iCurFace*3 + iCurPoint] = TRUE;
                    wCurPoint = rgwIndices[iCurFace*3 + iCurPoint];

					// if the point hasn't been claimed yet, then mark it
                    if (rgwFaceIds[wCurPoint] == UNUSED)
                    {
                        rgwFaceIds[wCurPoint] = (UINT_IDX)iFace;
                    }
					// else if it wasn't claimed by another face in this orbit, then
					//   we have found a bowtie
					else if (rgwFaceIds[wCurPoint] != iFace)
					{
						DPF(0, "D3DXValidMesh: Bowtie found");
						hr = D3DXERR_INVALIDMESH;
						goto e_Exit;
					}
				}
			}
		}
	}

e_Exit:
    if (rgwIndices != NULL)
    {
        pMeshIn->UnlockIndexBuffer();
    }

	delete []rgbFaceSeen;
	delete []rgwFaceIds;
	return hr;
}

HRESULT WINAPI D3DXValidMesh
    (
    LPD3DXMESH pMeshIn,
    CONST DWORD *rgdwAdjacency
    )
{
    unsigned int Bogus1 = 0;
    unsigned short Bogus2 = 0;

	if (pMeshIn == NULL)
    {
        DPF(0, "pMeshIn pointer is invalid");
		return D3DERR_INVALIDCALL;
    }

    if (pMeshIn->GetOptions() & D3DXMESH_32BIT)
        return D3DXValidMeshEx<unsigned int, FALSE, UNUSED32>(pMeshIn, rgdwAdjacency, Bogus1);
    else
        return D3DXValidMeshEx<unsigned short, TRUE, UNUSED16>(pMeshIn, rgdwAdjacency, Bogus2);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\mesh\createmesh.cpp ===
/*//////////////////////////////////////////////////////////////////////////////
//
// File: createmesh.cpp
//
// Copyright (C) 1999 Microsoft Corporation. All Rights Reserved.
//
// @@BEGIN_MSINTERNAL
//
// History:
// -@-          (craigp)    - created 
// -@- 08/19/99 (mikemarr)  - prepend GX to gxfmath functions
//                          - started comment history
//                          - replace references to gxbasetype.h with gxmathcore.h
// -@- 09/23/99 (mikemarr)  - changed <> to "" on #includes
//
// @@END_MSINTERNAL
//
//////////////////////////////////////////////////////////////////////////////*/

#include "pchmesh.h"

#include "tri3mesh.h"
#include "pmeshhe.h"
#include "simplify.h"
#include "CD3DXBuffer.h"

HRESULT WINAPI D3DXCreateMesh
    (
    DWORD numFaces, 
    DWORD numVertices, 
    DWORD dwOptions, 
    CONST DWORD *pDeclaration, 
    LPDIRECT3DDEVICE8 pD3DDevice, 
    LPD3DXMESH* pptmNewMesh
    )
{
    DWORD dwFVF;
    HRESULT hr;

    hr = D3DXFVFFromDeclarator(pDeclaration, &dwFVF);
    if (FAILED(hr))
    {
        DPF(0,"CloneMesh: Declaration cannot be converted to FVF");
        return hr;
    }

    return D3DXCreateMeshFVF(numFaces, numVertices, dwOptions, dwFVF, pD3DDevice, pptmNewMesh);
}


HRESULT WINAPI D3DXCreateMeshFVF
    (
    DWORD numFaces, 
    DWORD numVertices, 
    DWORD dwOptions, 
    DWORD dwFVF, 
    LPDIRECT3DDEVICE8 pD3DDevice, 
    LPD3DXMESH* pptmNewMesh
    )
{
    HRESULT hr = S_OK;
    GXTri3Mesh<tp32BitIndex> *ptmNewMesh32;
    GXTri3Mesh<tp16BitIndex> *ptmNewMesh16;

    if (((dwOptions & ~D3DXMESH_VALIDBITS) != 0) || (pD3DDevice == NULL) || (pptmNewMesh == NULL))
    {
#if DBG
        if (dwOptions & D3DXMESH_VB_SHARE)
		    DPF(0, "D3DXCreateMesh: VB_SHARE flag only valid on clone mesh calls.\n");
        if ((dwOptions & ~D3DXMESH_VALIDBITS) != 0)
		    DPF(0, "D3DXCreateMesh: Invalid mesh flag specified\n");
        else if (pD3DDevice == NULL)
		    DPF(0, "D3DXCreateMesh: NULL device specified\n");
        else if (pptmNewMesh == NULL)
		    DPF(0, "D3DXCreateMesh: NULL mesh output parameter\n");
#endif
        hr = D3DERR_INVALIDCALL;
        goto e_Exit;
    }

	if ((numFaces == 0) || (numVertices == 0))
	{
		DPF(0, "D3DXCreateMesh: Number of faces and vertices must be greater than zero\n");
		hr = D3DERR_INVALIDCALL;
		goto e_Exit;
	}

    *pptmNewMesh = NULL;

    if (dwOptions & D3DXMESH_32BIT)
    {
        ptmNewMesh32 = new GXTri3Mesh<tp32BitIndex>(pD3DDevice, dwFVF, dwOptions);

        if (ptmNewMesh32 == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }

        hr = ptmNewMesh32->Resize(numFaces, numVertices);
        if (FAILED(hr))
            goto e_Exit;

        *pptmNewMesh = ptmNewMesh32;
    }
    else
    {
        if ((numFaces > UNUSED16) || (numVertices > UNUSED16))
        {
		    DPF(0, "D3DXCreateMesh: Too many faces/vertices for a 16bit mesh\n");

            hr = D3DERR_INVALIDCALL;
            goto e_Exit;
        }

        ptmNewMesh16 = new GXTri3Mesh<tp16BitIndex>(pD3DDevice, dwFVF, dwOptions);
        if (ptmNewMesh16 == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }

        hr = ptmNewMesh16->Resize(numFaces, numVertices);
        if (FAILED(hr))
            goto e_Exit;

        *pptmNewMesh = ptmNewMesh16;
    }

e_Exit:
    return hr;
}

// internal function used to abstract GXHalfEdgePMesh template from loading code
HRESULT WINAPI D3DXCreatePMeshFromData
    (
    LPD3DXMESH ptmMesh,
    DWORD dwOptions,
    DWORD *rgdwAdjacency,
    PBYTE pbPMData, 
    DWORD cbPMData,
    LPD3DXPMESH *pptmPMesh
    )
{
    HRESULT hr = S_OK;
    GXHalfEdgePMesh<tp16BitIndex> *ptmPMesh16 = NULL;
    GXHalfEdgePMesh<tp32BitIndex> *ptmPMesh32 = NULL;
    LPDIRECT3DDEVICE8 pDevice;

    ptmMesh->GetDevice(&pDevice);
    pDevice->Release();  // ptmMesh retains a ref, create will add a new permanent one

    GXASSERT(CheckAdjacency(rgdwAdjacency, ptmMesh->GetNumFaces()));

    if (!(ptmMesh->GetOptions() & D3DXMESH_32BIT))
    {
        ptmPMesh16 = new GXHalfEdgePMesh<tp16BitIndex>(pDevice, ptmMesh->GetFVF(), dwOptions);
        if (ptmPMesh16 == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }

        // fill the pmesh from the data loaded from the file
        hr = ptmPMesh16->LoadFromData(ptmMesh, rgdwAdjacency, pbPMData, cbPMData);
        if (FAILED(hr))
            goto e_Exit;

        *pptmPMesh = ptmPMesh16;
        ptmPMesh16 = NULL;
    }
    else
    {
        ptmPMesh32 = new GXHalfEdgePMesh<tp32BitIndex>(pDevice, ptmMesh->GetFVF(), dwOptions|D3DXMESH_32BIT);
        if (ptmPMesh32 == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }

        // fill the pmesh from the data loaded from the file
        hr = ptmPMesh32->LoadFromData(ptmMesh, rgdwAdjacency, pbPMData, cbPMData);
        if (FAILED(hr))
            goto e_Exit;

        *pptmPMesh = ptmPMesh32;
        ptmPMesh32 = NULL;
    }


e_Exit:
    GXRELEASE(ptmPMesh16);
    GXRELEASE(ptmPMesh32);

    return hr;
}

HRESULT WINAPI D3DXCreateSPMesh
    (
    LPD3DXMESH pMesh, 
    CONST DWORD* adjacency, 
    CONST LPD3DXATTRIBUTEWEIGHTS pVertexAttributeWeights,
    CONST FLOAT *rgfVertexWeights,
    LPD3DXSPMESH* ppsmNewMesh
    )
{
    HRESULT hr = S_OK;
    GXSimplifyMesh<tp16BitIndex> *ptmSimpMesh16 = NULL;
    GXSimplifyMesh<tp32BitIndex> *ptmSimpMesh32 = NULL;
    GXTri3Mesh<tp32BitIndex> *ptmSrcMesh32;
    GXTri3Mesh<tp16BitIndex> *ptmSrcMesh16;
    DWORD dwFVF;
    DWORD dwOptions;
    LPDIRECT3DDEVICE8 pDevice;

    if ((pMesh == NULL) || (adjacency == NULL) || (ppsmNewMesh == NULL))
    {
#if DBG
        if (pMesh == NULL)
		    DPF(0, "D3DXCreateSPMesh: NULL mesh provided\n");
        else if (adjacency == NULL) 
		    DPF(0, "D3DXCreateSPMesh: No adjacency provided\n");
        else if (ppsmNewMesh == NULL)
		    DPF(0, "D3DXCreateSPMesh: NULL output mesh parameter\n");
#endif
        hr = D3DERR_INVALIDCALL;
        goto e_Exit;
    }

#ifdef _DEBUG
	// in debug, make sure the validate method would succeed
	hr = D3DXValidMesh(pMesh, adjacency);
	if (FAILED(hr))
		return hr;
#endif

    // make the simp mesh have the same options as the input mesh
    dwFVF = pMesh->GetFVF();
    dwOptions = pMesh->GetOptions();
    pMesh->GetDevice(&pDevice);
    pDevice->Release();  // ptmMesh retains a ref, create will add a new permanent one

    if (dwOptions & D3DXMESH_32BIT)
    {
        ptmSrcMesh32 = (GXTri3Mesh<tp32BitIndex>*)pMesh;

        ptmSimpMesh32 = new GXSimplifyMesh<tp32BitIndex>(pDevice, dwFVF, dwOptions);
        if (ptmSimpMesh32 == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }

        hr = ptmSimpMesh32->SetupSimplification(ptmSrcMesh32, adjacency, pVertexAttributeWeights, rgfVertexWeights);
        if (FAILED(hr))
            goto e_Exit;

        *ppsmNewMesh = ptmSimpMesh32;
        ptmSimpMesh32 = NULL;
    }
    else
    {
        ptmSrcMesh16 = (GXTri3Mesh<tp16BitIndex>*)pMesh;

        ptmSimpMesh16 = new GXSimplifyMesh<tp16BitIndex>(pDevice, dwFVF, dwOptions);
        if (ptmSimpMesh16 == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }

        hr = ptmSimpMesh16->SetupSimplification(ptmSrcMesh16, adjacency, pVertexAttributeWeights, rgfVertexWeights);
        if (FAILED(hr))
            goto e_Exit;

        *ppsmNewMesh = ptmSimpMesh16;
        ptmSimpMesh16 = NULL;
    }

e_Exit:
    GXRELEASE(ptmSimpMesh16);
//    GXRELEASE(ptmSimpMesh32);
    return hr;
}



HRESULT WINAPI
    D3DXGeneratePMesh(
        LPD3DXMESH pMesh, 
        CONST DWORD* adjacency, 
        CONST LPD3DXATTRIBUTEWEIGHTS pVertexAttributeWeights,
        CONST FLOAT *rgfVertexWeights,
        DWORD minValue, 
        DWORD options, 
        LPD3DXPMESH* pptmNewMesh)
{
    HRESULT hr = S_OK;
    LPD3DXSPMESH ptmSimpMesh = NULL;
    LPDIRECT3DDEVICE8 pDevice;

    if ((pMesh == NULL) || ((options & ~D3DXMESHSIMP_VALIDBITS) != 0) 
        || (adjacency == NULL)
        || (pptmNewMesh == NULL))
    {
#if DBG
        if (pMesh == NULL)
		    DPF(0, "D3DXGeneratePMesh: NULL mesh provided\n");
        else if ((options & ~D3DXMESHSIMP_VALIDBITS) != 0)
		    DPF(0, "D3DXGeneratePMesh: Invalid simplification parameter specified\n");
        else if (adjacency == NULL) 
		    DPF(0, "D3DXGeneratePMesh: No adjacency provided\n");
        else if (pptmNewMesh == NULL)
		    DPF(0, "D3DXGeneratePMesh: NULL output mesh parameter\n");
#endif
        hr = D3DERR_INVALIDCALL;
        goto e_Exit;
    }

    if ((options == 0) || (options ==  (D3DXMESHSIMP_VERTEX | D3DXMESHSIMP_FACE)))
    {
#if DBG
        if (options == 0)
		    DPF(0, "D3DXGeneratePMesh: No simplification option specified\n");
        else if (options ==  (D3DXMESHSIMP_VERTEX | D3DXMESHSIMP_FACE))
		    DPF(0, "D3DXGeneratePMesh: Incompatible simplification options specified\n");
#endif
        hr = D3DERR_INVALIDCALL;
        goto e_Exit;
    }


    hr = D3DXCreateSPMesh(pMesh, adjacency, pVertexAttributeWeights, rgfVertexWeights, &ptmSimpMesh);
    if (FAILED(hr))
        goto e_Exit;

    if (options & D3DXMESHSIMP_VERTEX)
        hr = ptmSimpMesh->ReduceVertices(minValue);
    else 
        hr = ptmSimpMesh->ReduceFaces(minValue);

    if (FAILED(hr))
        goto e_Exit;

    ptmSimpMesh->GetDevice(&pDevice);
    pDevice->Release();  // ptmMesh retains a ref, create will add a new permanent one

    hr = ptmSimpMesh->ClonePMeshFVF(
                ptmSimpMesh->GetOptions(), 
                ptmSimpMesh->GetFVF(),
                pDevice,
                NULL, pptmNewMesh);
    if (FAILED(hr))
        goto e_Exit;

e_Exit:
    GXRELEASE(ptmSimpMesh);
    return hr;
}


HRESULT WINAPI
    D3DXSimplifyMesh(
        LPD3DXMESH pMesh, 
        CONST DWORD* adjacency, 
        CONST LPD3DXATTRIBUTEWEIGHTS pVertexAttributeWeights,
        CONST FLOAT *rgfVertexWeights,
        DWORD minValue, 
        DWORD options, 
        LPD3DXMESH* pptmNewMesh)
{
    HRESULT hr = S_OK;
    LPD3DXSPMESH ptmSimpMesh = NULL;
    LPDIRECT3DDEVICE8 pDevice;

    if ((pMesh == NULL) || ((options & ~D3DXMESHSIMP_VALIDBITS) != 0) 
        || (adjacency == NULL)
        || (pptmNewMesh == NULL))
    {
#if DBG
        if (pMesh == NULL)
		    DPF(0, "D3DXSimplifyMesh: NULL mesh provided\n");
        else if ((options & ~D3DXMESHSIMP_VALIDBITS) != 0)
		    DPF(0, "D3DXSimplifyMesh: Invalid simplification parameter specified\n");
        else if (adjacency == NULL) 
		    DPF(0, "D3DXSimplifyMesh: No adjacency provided\n");
        else if (pptmNewMesh == NULL)
		    DPF(0, "D3DXSimplifyMesh: NULL output mesh parameter\n");
#endif
        hr = D3DERR_INVALIDCALL;
        goto e_Exit;
    }

    if ((options == 0) || (options ==  (D3DXMESHSIMP_VERTEX | D3DXMESHSIMP_FACE)))
    {
#if DBG
        if (options == 0)
		    DPF(0, "D3DXSimplifyMesh: No simplification option specified\n");
        else if (options ==  (D3DXMESHSIMP_VERTEX | D3DXMESHSIMP_FACE))
		    DPF(0, "D3DXSimplifyMesh: Incompatible simplification options specified\n");
#endif
        hr = D3DERR_INVALIDCALL;
        goto e_Exit;
    }


    hr = D3DXCreateSPMesh(pMesh, adjacency, pVertexAttributeWeights, rgfVertexWeights, &ptmSimpMesh);
    if (FAILED(hr))
        goto e_Exit;

    if (options & D3DXMESHSIMP_VERTEX)
        hr = ptmSimpMesh->ReduceVertices(minValue);
    else 
        hr = ptmSimpMesh->ReduceFaces(minValue);

    if (FAILED(hr))
        goto e_Exit;

    ptmSimpMesh->GetDevice(&pDevice);
    pDevice->Release();  // ptmMesh retains a ref, create will add a new permanent one

    hr = ptmSimpMesh->CloneMeshFVF(
                ptmSimpMesh->GetOptions(), 
                ptmSimpMesh->GetFVF(),
                pDevice,
                NULL, NULL, pptmNewMesh);
    if (FAILED(hr))
        goto e_Exit;

e_Exit:
    GXRELEASE(ptmSimpMesh);
    return hr;
}

// -------------------------------------------------------------------------------
//  function    D3DXComputeBoundingSphere
//
//   devnote    Compute a basic bounding sphere for all the points in the mesh
//
//   returns    S_OK if success, failed otherwise
//
HRESULT WINAPI D3DXComputeBoundingSphere
    (
    PVOID pvPoints, 
    DWORD cVertices, 
    DWORD dwFVF,
    D3DXVECTOR3 *pvCenter, 
    float *pfRadius
    )
{
    D3DXVECTOR3 vDist;
    float fDistSq;
    float fRadiusSq;
    UINT iPoint;
    PBYTE pbCur;
    PBYTE pbPoints = (PBYTE)pvPoints;
    HRESULT hr = S_OK;
    D3DXVECTOR3 *pvCur;
    DXCrackFVF cfvf(dwFVF);

    if ((pvPoints == NULL) || (pvCenter == NULL) || (pfRadius == NULL))
    {
#if DBG
        if (pvPoints == NULL)
		    DPF(0, "D3DXComputeBoundingSphere: NULL input vertex array\n");
        else if (pvCenter == NULL)
		    DPF(0, "D3DXComputeBoundingSphere: NULL center output parameter\n");
        else if (pfRadius == NULL)
		    DPF(0, "D3DXComputeBoundingSphere: NULL radius output paramter\n");
#endif     
        hr = D3DERR_INVALIDCALL;
        goto e_Exit;
    }

    *pvCenter = D3DXVECTOR3(0.0, 0.0, 0.0);

    if (cVertices == 0)
    {
        *pfRadius = 1.0;

        hr = S_OK;
        goto e_Exit;
    }

    for( iPoint=0, pbCur = pbPoints; iPoint < cVertices; iPoint++, pbCur += cfvf.m_cBytesPerVertex )
    {
        pvCur = (D3DXVECTOR3*)pbCur;

        pvCenter->x += pvCur->x;
        pvCenter->y += pvCur->y;
        pvCenter->z += pvCur->z;
    }

    *(D3DXVECTOR3*)pvCenter /= (float)cVertices;


    fRadiusSq = 0.0;
    for( iPoint=0, pbCur = pbPoints; iPoint < cVertices; iPoint++, pbCur += cfvf.m_cBytesPerVertex )
    {
        pvCur = (D3DXVECTOR3*)pbCur;

        vDist = *pvCur - *pvCenter;

        fDistSq = D3DXVec3LengthSq(&vDist);

        if( fDistSq > fRadiusSq )
            fRadiusSq = fDistSq;
    }

    (*pfRadius) = (float)sqrt((double)fRadiusSq);

e_Exit:

    return hr;
}


// -------------------------------------------------------------------------------
//  function    D3DXComputeBoundingBox
//
//   devnote    Compute a basic axis aligned bounding box for all the points in the mesh
//
//   returns    S_OK if success, failed otherwise
//
HRESULT WINAPI D3DXComputeBoundingBox
    (
    PVOID pvPoints, 
    DWORD cVertices, 
    DWORD dwFVF,
    D3DXVECTOR3 *pvMin, 
    D3DXVECTOR3 *pvMax
    )
{
    D3DXVECTOR3 vDist;
    //float fDistSq;
    //float fRadiusSq;
    UINT iPoint;
    PBYTE pbCur;
    PBYTE pbPoints = (PBYTE)pvPoints;
    HRESULT hr = S_OK;
    D3DXVECTOR3 *pvCur;
    //UINT cNonZeroVertices;
    DXCrackFVF cfvf(dwFVF);

    if ((pvPoints == NULL) || (pvMin == NULL) || (pvMax == NULL))
    {
#if DBG
        if (pvPoints == NULL)
		    DPF(0, "D3DXComputeBoundingBox: NULL input vertex array\n");
        else if (pvMin == NULL)
		    DPF(0, "D3DXComputeBoundingBox: NULL min output parameter\n");
        else if (pvMax == NULL)
		    DPF(0, "D3DXComputeBoundingBox: NULL max output paramter\n");
#endif     
        hr = D3DERR_INVALIDCALL;
        goto e_Exit;
    }

    if (cVertices == 0)
    {
        *pvMin = D3DXVECTOR3(0.0f,0.0f,0.0f);
        *pvMax = D3DXVECTOR3(0.0f,0.0f,0.0f);

        hr = S_OK;
        goto e_Exit;
    }

    // initialize pvMin/pvMax
    *pvMin = *(D3DXVECTOR3*)pbPoints;
    *pvMax = *(D3DXVECTOR3*)pbPoints;

    for( iPoint=1, pbCur = pbPoints; iPoint < cVertices; iPoint++, pbCur += cfvf.m_cBytesPerVertex )
    {
        pvCur = (D3DXVECTOR3*)pbCur;

        if (pvCur->x < pvMin->x)
            pvMin->x = pvCur->x;
        else if (pvCur->x > pvMax->x)
            pvMax->x = pvCur->x;

        if (pvCur->y < pvMin->y)
            pvMin->y = pvCur->y;
        else if (pvCur->y > pvMax->y)
            pvMax->y = pvCur->y;

        if (pvCur->z < pvMin->z)
            pvMin->z = pvCur->z;
        else if (pvCur->z > pvMax->z)
            pvMax->z = pvCur->z;
    }

e_Exit:

    return hr;
}

// -------------------------------------------------------------------------------
//  function    D3DXCreateBuffer
//
//   devnote    Creates a buffer of the given size and returns
//                  it as an ID3DXBuffer, used to give a 
//                  generic memory buffer AddRef/Release sematics
//
//   returns    S_OK if success, failed otherwise
//
HRESULT WINAPI D3DXCreateBuffer
    (
    DWORD cBytes, 
    LPD3DXBUFFER *ppBuffer
    )
{
    CD3DXBuffer *pBuffer = NULL;
    HRESULT hr = S_OK;

    // first allocate the container
    pBuffer = new CD3DXBuffer();
    if (pBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    // now allocate the buffer
    hr = pBuffer->Init(cBytes);
    if (FAILED(hr))
        goto e_Exit;

    *ppBuffer = pBuffer;
    pBuffer = NULL;

e_Exit:
    delete pBuffer;
    return hr;
}


// -------------------------------------------------------------------------------
//  function    D3DXComputeNormals
//
//   devnote    Does an inplace calculation of smooth normals for the given mesh
//
//   returns    S_OK if success, failed otherwise
//
HRESULT WINAPI D3DXComputeNormals
    (
    LPD3DXBASEMESH pMesh
    )
{
    HRESULT hr = S_OK;

    D3DXVECTOR3 vNormal;
    D3DXVECTOR3 *pvNormal;
    D3DXVECTOR3 vEdge1;
    D3DXVECTOR3 vEdge2;
    D3DXVECTOR3 *pvPos0;
    D3DXVECTOR3 *pvPos1;
    D3DXVECTOR3 *pvPos2;
    WORD *pwFace;
    DWORD *pdwFace;
    UINT iVert;
    UINT cVertices;
    UINT iFace;
    UINT cFaces;
    UINT iPoint;
    PVOID pvPoint;
    LPDIRECT3DVERTEXBUFFER8 pibVertices = NULL;
    PVOID pvPoints = NULL;
    LPDIRECT3DINDEXBUFFER8 pibFaces = NULL;
    WORD *rgwFaces = NULL;
    DWORD *rgdwFaces;
    DXCrackFVF cfvf(D3DFVF_XYZ);
    BOOL b16BitIndex;
    DWORD pdwFaceCur[3];

    if ((pMesh == NULL) || !(pMesh->GetFVF() & D3DFVF_NORMAL))
    {
        if (pMesh == NULL)
        {
            DPF(0, "D3DXComputeNormals: Failed due to input mesh being NULL\n");
        }
        else
        {
            DPF(0, "D3DXComputeNormals: Normal field required on input mesh to be filled in (clonemesh can be used to add them)\n");
        }

        hr = D3DERR_INVALIDCALL;
        goto e_Exit;
    }

    cFaces = pMesh->GetNumFaces();
    cVertices = pMesh->GetNumVertices();
    cfvf = DXCrackFVF(pMesh->GetFVF());
    b16BitIndex = !(pMesh->GetOptions() & D3DXMESH_32BIT);

    hr = pMesh->GetIndexBuffer(&pibFaces);
    if (FAILED(hr))
        goto e_Exit;

    hr = pibFaces->Lock(0,0, (PBYTE*)&rgwFaces, 0 );
    if (FAILED(hr))
        goto e_Exit;
    rgdwFaces = (DWORD*)rgwFaces;

    hr = pMesh->GetVertexBuffer(&pibVertices);
    if (FAILED(hr))
        goto e_Exit;

    hr = pibVertices->Lock(0,0, (PBYTE*)&pvPoints, 0 );
    if (FAILED(hr))
        goto e_Exit;

    // reinitialize all normals to zero
    for (iVert = 0; iVert < cVertices; iVert++)
    {
        pvPoint = cfvf.GetArrayElem(pvPoints, iVert);

        pvNormal = cfvf.PvGetNormal(pvPoint);
        *pvNormal = D3DXVECTOR3(0.0, 0.0, 0.0);
    }

    // add in face normals
    for (iFace = 0; iFace < cFaces; iFace++)
    {
        // upconvert to 32 bit for simplicity
        if (b16BitIndex)
        {
            pwFace = &rgwFaces[iFace*3];

            pdwFaceCur[0] = pwFace[0];
            pdwFaceCur[1] = pwFace[1];
            pdwFaceCur[2] = pwFace[2];
        }
        else
        {
            pdwFace = &rgdwFaces[iFace*3];
            memcpy(pdwFaceCur, pdwFace, sizeof(DWORD)*3);
        }

        pvPos0 = cfvf.PvGetPosition(cfvf.GetArrayElem(pvPoints, pdwFaceCur[0]));
        pvPos1 = cfvf.PvGetPosition(cfvf.GetArrayElem(pvPoints, pdwFaceCur[1]));
        pvPos2 = cfvf.PvGetPosition(cfvf.GetArrayElem(pvPoints, pdwFaceCur[2]));

        vEdge1 = *pvPos0 - *pvPos1;
        vEdge2 = *pvPos0 - *pvPos2;

        // calculate the normal of the face from the two edge vectors
        D3DXVec3Cross(&vNormal, &vEdge1, &vEdge2);
//      vNormal /= D3DXVec3Length(&vNormal);

        for (iPoint = 0; iPoint < 3; iPoint++)
        {
            pvPoint = cfvf.GetArrayElem(pvPoints, pdwFaceCur[iPoint]);
            pvNormal = cfvf.PvGetNormal(pvPoint);

            *pvNormal += vNormal;
        }
    }

    // renormalize all normals
    for (iVert = 0; iVert < cVertices; iVert++)
    {
        pvPoint = cfvf.GetArrayElem(pvPoints, iVert);
        pvNormal = cfvf.PvGetNormal(pvPoint);

        D3DXVec3Normalize(pvNormal, pvNormal);
    }

e_Exit:
    if (rgwFaces != NULL)
    {
        pibFaces->Unlock();
    }
    GXRELEASE(pibFaces);

    if (pvPoints != NULL)
    {
        pibVertices->Unlock();
    }
    GXRELEASE(pibVertices);

    return hr;
}

// -------------------------------------------------------------------------------
//  function    D3DXDeclaratorFromFVF
//
//   devnote    Generates a declarator from a given FVF
//
//   returns    S_OK if success, failed otherwise
//
HRESULT WINAPI D3DXDeclaratorFromFVF
    (
    DWORD dwFVF,
    DWORD Declarator[MAX_FVF_DECL_SIZE]
    )
{
    DXCrackFVF cfvf(dwFVF);
    HRESULT hr = S_OK;

    DWORD iTemp;
    DWORD iTexCoord;
    DWORD nTexCoords;
    DWORD dwVsdt;
    DWORD dwTextureFormats;

    // UNDONE - need to make sure the FVF is valid

    iTemp = 0;
    Declarator[iTemp] = D3DVSD_STREAM(0);
    iTemp++;

    Declarator[iTemp] = D3DVSD_REG( D3DVSDE_POSITION,  D3DVSDT_FLOAT3),
    iTemp++;

    if (cfvf.CWeights() > 0)
    {
        if (cfvf.BIndexedWeights())
        {
            DPF(0, "D3DXDeclaratorFromFVF: Indexed weights not supported on Xbox");
            hr = D3DERR_INVALIDCALL;
            goto e_Exit;
        }
        else
        {
            if (cfvf.CWeights() >= 5)
            {
                DPF(0, "D3DXDeclaratorFromFVF: Five weights is not supported in declarator without blend indices bit set");
                hr = D3DERR_INVALIDCALL;
                goto e_Exit;
            }

            // subtract one to convert to D3DVSDT_FLOAT* 
            switch( cfvf.CWeights() - 1 )
            {
               case 1: 
                  Declarator[iTemp] = D3DVSD_REG( D3DVSDE_BLENDWEIGHT,  D3DVSDT_FLOAT1 );
                  break;
               case 2: 
                  Declarator[iTemp] = D3DVSD_REG( D3DVSDE_BLENDWEIGHT,  D3DVSDT_FLOAT2 );
                  break;
               case 3: 
                  Declarator[iTemp] = D3DVSD_REG( D3DVSDE_BLENDWEIGHT,  D3DVSDT_FLOAT3 );
                  break;
               case 4: 
                  Declarator[iTemp] = D3DVSD_REG( D3DVSDE_BLENDWEIGHT,  D3DVSDT_FLOAT4 );
                  break;
            }

            iTemp++;
        }
    }

    GXASSERT(  (D3DVSDT_FLOAT1 == 0) && (D3DVSDT_FLOAT4 == 3) );

    if (cfvf.BNormal())
    {
        Declarator[iTemp] = D3DVSD_REG( D3DVSDE_NORMAL,  D3DVSDT_FLOAT3),
        iTemp++;
    }

    if (cfvf.BDiffuse())
    {
        Declarator[iTemp] = D3DVSD_REG( D3DVSDE_DIFFUSE,  D3DVSDT_D3DCOLOR),
        iTemp++;
    }

    if (cfvf.BSpecular())
    {
        Declarator[iTemp] = D3DVSD_REG( D3DVSDE_SPECULAR,  D3DVSDT_D3DCOLOR),
        iTemp++;
    }

    if (cfvf.CTexCoords() > 0)
    {
        dwTextureFormats = dwFVF >> 16;
    
        if (dwTextureFormats == 0)
        {
            for (iTexCoord = 0; iTexCoord < cfvf.CTexCoords(); iTexCoord++)
            {
                Declarator[iTemp] = D3DVSD_REG( D3DVSDE_TEXCOORD0 + iTexCoord,  D3DVSDT_FLOAT2),
                iTemp++;
            }
        }
        else
        {
            for (iTexCoord = 0; iTexCoord < cfvf.CTexCoords(); iTexCoord++)
            {
                switch (dwTextureFormats & 3)
                {
                case D3DFVF_TEXTUREFORMAT1:
                    dwVsdt = D3DVSDT_FLOAT1;
                    break;

                case D3DFVF_TEXTUREFORMAT2:
                    dwVsdt = D3DVSDT_FLOAT2;
                    break;

                case D3DFVF_TEXTUREFORMAT3:
                    dwVsdt = D3DVSDT_FLOAT3;
                    break;

                case D3DFVF_TEXTUREFORMAT4:
                    dwVsdt = D3DVSDT_FLOAT4;
                    break;
                }
    
                Declarator[iTemp] = D3DVSD_REG(D3DVSDE_TEXCOORD0 + iTexCoord, dwVsdt),
                iTemp++;

                dwTextureFormats >>= 2;
            }
        }
    }

    Declarator[iTemp] = D3DVSD_END();
    iTemp++;

e_Exit:
    GXASSERT(iTemp <= MAX_FVF_DECL_SIZE);
    return hr;
}

// -------------------------------------------------------------------------------
//  function    D3DXDeclaratorFromFVF
//
//   devnote    Generates an FVF from a given declarator if possible.
//
//   returns    S_OK if success, failed otherwise
//
HRESULT WINAPI D3DXFVFFromDeclarator
    (
    CONST DWORD *pDeclarator,
    DWORD *pdwFVF
    )
{
    HRESULT hr = S_OK;
    DWORD dwFVF;
    DWORD iMaxTexCoord;
    DWORD dwDataType;
    DWORD dwToken;
    CONST DWORD *pdwCur;

    // UNDONE UNDONE - this does not reject a number of invalid declarator to fvf ....

    dwFVF = 0;
    iMaxTexCoord = 0;
    pdwCur = pDeclarator;
    while ( 1 )
    {
        dwToken = (*pdwCur & D3DVSD_TOKENTYPEMASK) >> D3DVSD_TOKENTYPESHIFT;

        switch (dwToken)
        {
            case D3DVSD_TOKEN_STREAM:
                if (0 != ((*pdwCur & D3DVSD_STREAMNUMBERMASK) >> D3DVSD_STREAMNUMBERSHIFT))
                {
                    DPF(0, "D3DXFVFFromDeclarator: Only single stream declarators can be converted to FVF");
                }
                break;

            case D3DVSD_TOKEN_STREAMDATA:
                dwDataType = ((*pdwCur & D3DVSD_DATATYPEMASK) >> D3DVSD_DATATYPESHIFT);

                switch ((*pdwCur & D3DVSD_VERTEXREGMASK) >> D3DVSD_VERTEXREGSHIFT)
                {
                    case D3DVSDE_POSITION:    
                        if (dwDataType != D3DVSDT_FLOAT3)
                        {
                            DPF(0, "D3DXFVFFromDeclarator: Position not specified as a FLOAT3\n");
                            hr = D3DERR_INVALIDCALL;
                            goto e_Exit;
                        }

                        dwFVF |= D3DFVF_XYZ;
                        break;

                    case D3DVSDE_BLENDWEIGHT: 
                        dwFVF &= ~D3DFVF_POSITION_MASK;
                        switch (dwDataType)
                        {
                            case D3DVSDT_FLOAT1:
                                dwFVF |= D3DFVF_XYZB1;
                                break;
                            case D3DVSDT_FLOAT2:
                                dwFVF |= D3DFVF_XYZB2;
                                break;
                            case D3DVSDT_FLOAT3:
                                dwFVF |= D3DFVF_XYZB3;
                                break;
                            case D3DVSDT_FLOAT4:
                                dwFVF |= D3DFVF_XYZB4;
                                break;
                            default:
                                DPF(0, "D3DXFVFFromDeclarator: Unsupported type for D3DVSDE_BLENDWEIGHT, only FLOAT1-FLOAT4 are supported");
                                hr = D3DERR_INVALIDCALL;
                                goto e_Exit;
                        }
                        break;

                    case D3DVSDE_NORMAL:      
                        if (dwDataType != D3DVSDT_FLOAT3)
                        {
                            DPF(0, "D3DXFVFFromDeclarator: Normal not specified as a FLOAT3\n");
                            hr = D3DERR_INVALIDCALL;
                            goto e_Exit;
                        }
                        
                        dwFVF |= D3DFVF_NORMAL;
                        break;

                    case D3DVSDE_DIFFUSE:     
                        if (dwDataType != D3DVSDT_D3DCOLOR)
                        {
                            DPF(0, "D3DXFVFFromDeclarator: Diffuse not specified as a D3DCOLOR\n");
                            hr = D3DERR_INVALIDCALL;
                            goto e_Exit;
                        }

                        dwFVF |= D3DFVF_DIFFUSE;
                        break;

                    case D3DVSDE_SPECULAR:    
                        if (dwDataType != D3DVSDT_D3DCOLOR)
                        {
                            DPF(0, "D3DXFVFFromDeclarator: Specular not specified as a D3DCOLOR\n");
                            hr = D3DERR_INVALIDCALL;
                            goto e_Exit;
                        }

                        dwFVF |= D3DFVF_SPECULAR;
                        break;

                    case D3DVSDE_TEXCOORD0:   
                    case D3DVSDE_TEXCOORD1:   
                    case D3DVSDE_TEXCOORD2:   
                    case D3DVSDE_TEXCOORD3:   
                        if (dwDataType != D3DVSDT_FLOAT2)
                        {
                            // UNDONE UNDONE (Bug 33526) need to support 1D-4D tex coords
                            DPF(0, "D3DXFVFFromDeclarator: Texcoord not specified as a FLOAT2\n");
                            hr = D3DERR_INVALIDCALL;
                            goto e_Exit;
                        }

                        iMaxTexCoord = max(iMaxTexCoord, ((*pdwCur & D3DVSD_VERTEXREGMASK) >> D3DVSD_VERTEXREGSHIFT) - D3DVSDE_TEXCOORD0 + 1);

                        break;
                }
                break;

            case D3DVSD_TOKEN_NOP:
            case D3DVSD_TOKEN_TESSELLATOR:
            case D3DVSD_TOKEN_CONSTMEM:   
            case D3DVSD_TOKEN_EXT:
                DPF(0, "D3DXFVFFromDeclarator: Unhandled token type found in declarator to be converted");
                hr = D3DERR_INVALIDCALL;
                goto e_Exit;

            case D3DVSD_TOKEN_END:
                goto EndToken;

            default:
                DPF(0, "D3DXFVFFromDeclarator: Invalid token type found in declarator to be converted");
                hr = D3DERR_INVALIDCALL;
                goto e_Exit;
        }

        pdwCur += 1;
    }
EndToken:
    // save setting the 
    if (iMaxTexCoord > 0)
    {
        dwFVF |= (D3DFVF_TEX1 * iMaxTexCoord);
    }

    *pdwFVF = dwFVF;

e_Exit:
    return hr;
}

// Compare function for qsort in GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED>::AttributeSort()
int __cdecl CmpFunc(const void* elem1, const void * elem2)
{
    return *((DWORD*)elem1) - *((DWORD*)elem2);
}

// -------------------------------------------------------------------------------
//  function    GenerateWedgeList
//
//   devnote    Helper function for D3DXWeldVertices, used to 
//
//   returns    S_OK if success, failed otherwise
//
HRESULT GenerateWedgeList
    (
    DWORD *rgdwPointReps, 
    DWORD cVertices, 
    BOOL *pbIdentityPointReps, 
    DWORD *rgdwWedgeList
    )
{
    BOOL bLinkFound = FALSE;
    DWORD iVertex;
    DWORD dwPointRep;

    // initialize all entries to point to themselves
    for (iVertex = 0; iVertex < cVertices; iVertex++)
    {
        rgdwWedgeList[iVertex] = iVertex;
    }

    // now go back and link them up using the pointreps
    for (iVertex = 0; iVertex < cVertices; iVertex++)
    {
        // get the representative for this set of wedges
        dwPointRep = rgdwPointReps[iVertex];

        if (dwPointRep != iVertex)
        {
            bLinkFound = TRUE;

            // link the new point in just after the representative vertex
            rgdwWedgeList[iVertex] = rgdwWedgeList[dwPointRep];
            rgdwWedgeList[dwPointRep] = iVertex;
        }
    }

    *pbIdentityPointReps = !bLinkFound;

    return S_OK;;
}

BOOL BFloatsEqual
    (
    float fEpsilon,
    float f1,
    float f2
    )
{
    // first do a bitwise compare
    if ((*(DWORD*)&f1) == (*(DWORD*)&f2))
        return TRUE;

    // next do an epsilon compare
    float fDiff = (f1 - f2);
    return (fDiff <= fEpsilon) && (fDiff >= -fEpsilon);
}

BOOL BEqualVertices
    (
    DXCrackFVF &cfvf, 
    float fEpsilon,
    PBYTE pbVertex1,
    PBYTE pbVertex2
    )
{
    BOOL bEqual = TRUE;
    DWORD cTexFloats;
    DWORD iTexFloat;
    float *pfTexFloats1;
    float *pfTexFloats2;
    D3DXVECTOR3 *pvNormal1;
    D3DXVECTOR3 *pvNormal2;
    float *pfWeights1;
    float *pfWeights2;
    DWORD iWeight;

    if (cfvf.BNormal())
    {
        pvNormal1 = cfvf.PvGetNormal(pbVertex1);
        pvNormal2 = cfvf.PvGetNormal(pbVertex2);

        if (!BFloatsEqual(fEpsilon, pvNormal1->x, pvNormal2->x)
            || !BFloatsEqual(fEpsilon, pvNormal1->y, pvNormal2->y)
            || !BFloatsEqual(fEpsilon, pvNormal1->z, pvNormal2->z))
        {
            bEqual = FALSE;
            goto e_Exit;
        }
    }

    // ignore epsilon for both diffuse and specular colors
    if (cfvf.BDiffuse())
    {
        if (cfvf.ColorGetDiffuse(pbVertex1) != cfvf.ColorGetDiffuse(pbVertex2))
        {
            bEqual = FALSE;
            goto e_Exit;
        }
    }

    if (cfvf.BSpecular())
    {
        if (cfvf.ColorGetSpecular(pbVertex1) != cfvf.ColorGetSpecular(pbVertex2))
        {
            bEqual = FALSE;
            goto e_Exit;
        }
    }

    if (cfvf.CWeights() > 0)
    {
        pfWeights1 = (float*)(((PBYTE)cfvf.PvGetPosition(pbVertex1)) + sizeof(D3DXVECTOR3));
        pfWeights2 = (float*)(((PBYTE)cfvf.PvGetPosition(pbVertex2)) + sizeof(D3DXVECTOR3));

        for (iWeight = 0; iWeight < cfvf.CWeights(); iWeight++)
        {
            if (!BFloatsEqual(fEpsilon, pfWeights1[iWeight], pfWeights2[iWeight]))
            {
                bEqual = FALSE;
                goto e_Exit;
            }
        }
    }

    if (cfvf.CTexCoords() > 0)
    {
		cTexFloats = (cfvf.m_cBytesPerVertex - cfvf.m_oTex1) / sizeof(float);
        pfTexFloats1 = (float*)cfvf.PuvGetTex1(pbVertex1);
        pfTexFloats2 = (float*)cfvf.PuvGetTex1(pbVertex2);

        for (iTexFloat = 0; iTexFloat < cTexFloats; iTexFloat++)
        {
            if (!BFloatsEqual(fEpsilon, pfTexFloats1[iTexFloat], pfTexFloats2[iTexFloat]))
            {
                bEqual = FALSE;
                goto e_Exit;
            }
        }
    }

e_Exit:
    return bEqual;
}


// -------------------------------------------------------------------------------
//  function    D3DXWeldVertices
//
//   devnote    Welds replicated vertices together that have attributes that are equal (using epsilon compare)
//                  NOTE: this requires vertices with equal position to already have been calculated
//                              represented by point reps
//
//   returns    S_OK if success, failed otherwise
//
HRESULT WINAPI D3DXWeldVertices
    (
    CONST LPD3DXMESH pMesh,         // mesh to weld from
    float fEpsilon,                 // error in comparing identical attributes
    CONST DWORD *rgdwAdjacencyIn, 
    DWORD *rgdwAdjacencyOut,
    DWORD* pFaceRemap, 
    LPD3DXBUFFER *ppbufVertexRemap
    )
{
    HRESULT hr = S_OK;
    BOOL bIdentityPointReps;
    DWORD *rgdwPointReps = NULL;
    DWORD *rgdwWedgeList = NULL;
    DWORD cVertices;
    DWORD *rgdwRemap = NULL;
    DWORD *rgdwAdjacencyComputed = NULL;
    PBYTE pbFaces;
    PDWORD pdwFaces;
    PWORD pwFaces;
    DWORD cFaces;
    DWORD iVertex;
    DWORD dwCurOuter;
    DWORD dwCurInner;
    DWORD iFace;
    BOOL b16BitMesh;
    BOOL bRemapFound = FALSE;
    PBYTE pbVertices = NULL;
    DXCrackFVF cfvf(D3DFVF_XYZ);

    if ((pMesh == NULL) || (fEpsilon < 0.0f))
    {
        if (pMesh == NULL)
		    DPF(0, "D3DXWeldVertices: No mesh specified to weld");
        else if (rgdwAdjacencyIn == NULL)
        {
		    DPF(0, "D3DXWeldVertices: No adjacency specified to D3DXWeldVertices");
		    DPF(0, "D3DXWeldVertices:   Adjacency info is required to identify replicated vertices");
        }
        else if (fEpsilon < 0.0f)
        {
		    DPF(0, "D3DXWeldVertices: Epsilon value must be greater than or equal to zero.");
        }

        hr = D3DERR_INVALIDCALL;
        goto e_Exit;
    }

    cVertices = pMesh->GetNumVertices();
    cFaces = pMesh->GetNumFaces();
    b16BitMesh = !(pMesh->GetOptions() & D3DXMESH_32BIT);
    cfvf = DXCrackFVF(pMesh->GetFVF());

    if (rgdwAdjacencyIn == NULL)
    {
        rgdwAdjacencyComputed = new DWORD[cFaces * 3];
        if (rgdwAdjacencyComputed == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }

        hr = pMesh->GenerateAdjacency(fEpsilon, rgdwAdjacencyComputed);
        if (FAILED(hr))
            goto e_Exit;

        rgdwAdjacencyIn = rgdwAdjacencyComputed;
    }

    rgdwRemap = new DWORD[cVertices];
    rgdwPointReps = new DWORD[cVertices];
    rgdwWedgeList = new DWORD[cVertices];
    if ((rgdwRemap == NULL) || (rgdwPointReps == NULL) || (rgdwWedgeList == NULL))
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    // initialize all remapings to self
    for (iVertex = 0; iVertex < cVertices; iVertex++)
    {
        rgdwRemap[iVertex] = iVertex;
    }

    // first generate the point reps
    hr = pMesh->ConvertAdjacencyToPointReps(rgdwAdjacencyIn, rgdwPointReps);
    if (FAILED(hr))
        goto e_Exit;

    // next generate the wedge list
    hr = GenerateWedgeList(rgdwPointReps, cVertices, &bIdentityPointReps, rgdwWedgeList);
    if (FAILED(hr))
        goto e_Exit;

    hr = pMesh->LockVertexBuffer(D3DLOCK_READONLY, &pbVertices);
    if (FAILED(hr))
        goto e_Exit;

    // if identity point reps, nothing to weld
    if (!bIdentityPointReps) 
    {
        // now we need to look at each of the vertex loops to decide
        //   who we need to merge
        for (iVertex = 0; iVertex < cVertices; iVertex++)
        {
            // use the point reps to look at each loop only once
            //   find the head of a loop (the point rep) and then walk the wedge list
            // NOTE: also skip if the wedge list has only this vertex on it
            if ((rgdwPointReps[iVertex] == iVertex) && (rgdwWedgeList[iVertex] != iVertex))
            {
                dwCurOuter = iVertex;
                do
                {
                    // if a remapping for the vertex hasn't been found, check to see
                    //   if it matches any other vertices
                    if (rgdwRemap[dwCurOuter] == dwCurOuter)
                    {
                        dwCurInner = rgdwWedgeList[iVertex];
                        do 
                        {
                            // don't check for equalivalence if indices the same (had better be equal then)
                            //    and/or if the one being checked is already being remapped
                            if ((dwCurInner != dwCurOuter) && (rgdwRemap[dwCurInner] == dwCurInner))
                            {
                                // if the two vertices are equal, then remap one to the other
                                if (BEqualVertices(cfvf, fEpsilon, 
                                                        cfvf.GetArrayElem(pbVertices, dwCurInner), 
                                                        cfvf.GetArrayElem(pbVertices, dwCurOuter)))
                                {
                                    // remap the inner vertices to the outer...
                                    rgdwRemap[dwCurInner] = dwCurOuter;

                                    bRemapFound = TRUE;
                                }

                            }

                            dwCurInner = rgdwWedgeList[dwCurInner];
                        } while (dwCurInner != iVertex);
                    }

                    dwCurOuter = rgdwWedgeList[dwCurOuter];
                } while (dwCurOuter != iVertex);
            }
        }
    }

    // if one or more vertices was found to weld, then weld
    if (bRemapFound)
    {
        pMesh->LockIndexBuffer(0, &pbFaces);

        // first fixup the indices to not point at the redundant vertices
        if (b16BitMesh)
        {
            pwFaces = (WORD*)pbFaces;

            for (iFace = 0; iFace < cFaces * 3; iFace++)
            {
                pwFaces[iFace] = (WORD)rgdwRemap[pwFaces[iFace]];
            }
        }
        else  // 32bit indices
        {
            pdwFaces = (DWORD*)pbFaces;

            for (iFace = 0; iFace < cFaces * 3; iFace++)
            {
                pdwFaces[iFace] = rgdwRemap[pdwFaces[iFace]];
            }
        }

        pMesh->UnlockIndexBuffer();

    }

    pMesh->UnlockVertexBuffer();
    pbVertices = NULL;

    // last but not least, optimize to get rid of the dead vertices    
    hr = pMesh->OptimizeInplace(D3DXMESHOPT_ATTRSORT, rgdwAdjacencyIn, rgdwAdjacencyOut, pFaceRemap, ppbufVertexRemap);

    if (FAILED(hr))
        goto e_Exit;

e_Exit:
    if (pbVertices != NULL)
    {
        pMesh->UnlockVertexBuffer();
    }

    delete []rgdwWedgeList;
    delete []rgdwPointReps;
    delete []rgdwRemap;
    delete []rgdwAdjacencyComputed;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\mesh\common.h ===
#pragma once

#ifndef __COMMON_H
#define __COMMON_H

/*/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File: common.h
//
// @@BEGIN_MSINTERNAL
//
// -@- 03/17/99 (mikemarr)  - created for Luciform99
// -@- 08/23/99 (mikemarr)  - HRESULTS for library - snarfed from gxutils.h
//
// @@END_MSINTERNAL
//
/////////////////////////////////////////////////////////////////////////////*/

#include <xtl.h>
#include "d3dx8dbg.h"

#ifndef FALSE
    #define FALSE 0
#endif

#ifndef TRUE
    #define TRUE 1
#endif

// These are copied from basetsd.h
typedef signed char         INT8, *PINT8;
typedef signed short        INT16, *PINT16;
typedef signed int          INT32, *PINT32;
typedef signed __int64      INT64, *PINT64;
typedef unsigned char       UINT8, *PUINT8;
typedef unsigned short      UINT16, *PUINT16;
typedef unsigned int        UINT32, *PUINT32;
typedef unsigned __int64    UINT64, *PUINT64;


#define GXMEMALLOC(__nBytes__) HeapAlloc(GetProcessHeap(), 0, __nBytes__)
#define GXMEMFREE(__p__) HeapFree(GetProcessHeap(), 0, __p__)

#ifndef MAKE_USERERROR
    #define MAKE_USERERROR(code)    MAKE_HRESULT(1,FACILITY_ITF,code)
#endif
#ifndef E_NOTINITIALIZED
    #define E_NOTINITIALIZED        MAKE_USERERROR(0xFFFC)
#endif
#ifndef E_ALREADYINITIALIZED
    #define E_ALREADYINITIALIZED    MAKE_USERERROR(0xFFFB)
#endif
#ifndef E_NOTFOUND
    #define E_NOTFOUND              MAKE_USERERROR(0xFFFA)
#endif
#ifndef E_INSUFFICIENTDATA
    #define E_INSUFFICIENTDATA      MAKE_USERERROR(0xFFF9)
#endif


#if defined(DBG) || defined(DEBUG) || defined (_DEBUG)
    #ifndef _DEBUG
        #define _DEBUG
    #endif
    #ifndef DBG
        #define DBG 1
    #endif
#endif

#if defined(WIN32) || defined(_WIN32)
    #ifndef WIN32
        #define WIN32
    #endif
    #ifndef _WIN32
        #define _WIN32
    #endif
#endif // #if defined(WIN32) || defined(_WIN32)


#define MACSTART do {
#define MACEND } while (0)

#if defined(_WINDOWS) || defined(WIN32)
    #ifndef _INC_WINDOWS
        #ifndef WIN32_EXTRA_LEAN
            #define WIN32_EXTRA_LEAN
        #endif
        #ifndef WIN32_LEAN_AND_MEAN
            #define WIN32_LEAN_AND_MEAN
        #endif
        #include <xtl.h>
    #endif

    #ifndef _WINBASE_
        #include <winbase.h>
    #endif
    #define ISVALIDINTERFACE(__p)               ((__p) && !::IsBadReadPtr(__p, sizeof(*(__p))) && !::IsBadCodePtr((FARPROC) ((PDWORD)(__p))[0]))
    #define ISVALIDREAD(__p)                    ((__p) && !::IsBadReadPtr(__p, sizeof(*(__p))))
    #define ISVALIDWRITE(__p)                   ((__p) && !::IsBadWritePtr(__p, sizeof(*(__p))))
    #define ISVALIDREADWRITE(__p)               ((__p) && !::IsBadReadPtr(__p, sizeof(*(__p))) && !::IsBadWritePtr(__p, sizeof(*(__p))))
    #define ISRGVALIDREAD(__p, __cItems)        ((__p) && !::IsBadReadPtr(__p, (__cItems) * sizeof(*(__p))))
    #define ISRGVALIDWRITE(__p, __cItems)       ((__p) && !::IsBadWritePtr(__p, (__cItems) * sizeof(*(__p))))
    #define ISRGVALIDREADWRITE(__p, __cItems)   ((__p) && !::IsBadReadPtr(__p, (__cItems) * sizeof(*(__p))) && !::IsBadWritePtr(__p, (__cItems) * sizeof(*(__p))))

    #define ISVALIDWINDOW(__hwnd)               ((__hwnd) && ::IsWindow(__hwnd))
    #define ISVHWND(__hwnd)                     ISVALIDWINDOW(__hwnd)

    #include <winerror.h>
#else
    #define ISVALIDINTERFACE(__p)               ((__p) != NULL)
    #define ISVALIDREAD(__p)                    ((__p) != NULL)
    #define ISVALIDWRITE(__p)                   ((__p) != NULL)
    #define ISVALIDREADWRITE(__p)               ((__p) != NULL)
    #define ISRGVALIDREAD(__p, __cItems)        ((__p) != NULL)
    #define ISRGVALIDWRITE(__p, __cItems)       ((__p) != NULL)
    #define ISRGVALIDREADWRITE(__p, __cItems)   ((__p) != NULL)
#endif

#define ISVI(__p)                               ISVALIDINTERFACE(__p)
#define ISVR(__p)                               ISVALIDREAD(__p)
#define ISVW(__p)                               ISVALIDWRITE(__p)
#define ISVRW(__p)                              ISVALIDREADWRITE(__p)
#define ISRGVR(__p, __cItems)                   ISRGVALIDREAD(__p, __cItems)
#define ISRGVW(__p, __cItems)                   ISRGVALIDWRITE(__p, __cItems)
#define ISRGVRW(__p, __cItems)                  ISRGVALIDREADWRITE(__p, __cItems)


// Macro: GXRELEASE
//    Safe release for COM objects
// ***this code should never change - there is stuff that relies on the pointer being
//    set to NULL after being released
#ifndef GXRELEASE
    #define GXRELEASE(_p) MACSTART if ((_p) != NULL) {(_p)->Release(); (_p) = NULL;} MACEND
#endif
#ifndef GXULTRARELEASE
    #define GXULTRARELEASE(_p) MACSTART if (ISVI(_p)) {(_p)->Release();} (_p) = NULL; MACEND
#endif

// @@BEGIN_MSINTERNAL
#if 0
#ifndef GXDELETE
    #define GXDELETE(__ptr) MACSTART delete (__ptr); (__ptr) = NULL; MACEND
#endif
#ifndef GXULTRADELETE
    #define GXULTRADELETE(__ptr) MACSTART if (ISVW(__ptr)) { delete (__ptr);} (__ptr) = NULL; MACEND
#endif
#ifndef GXDELETERG
    #define GXDELETERG(__ptr) MACSTART delete [] (__ptr); (__ptr) = NULL; MACEND
#endif
#endif // #if 0
// @@END_MSINTERNAL

#ifndef GXCOPYI
    #define GXCOPYI(_pDstI, _pSrcI) MACSTART if ((_pDstI) = (_pSrcI)) (_pDstI)->AddRef(); MACEND
#endif
#ifndef CHECK_HR
    #define CHECK_HR(__hr) MACSTART if (FAILED(__hr)) goto e_Exit; MACEND
#endif
#ifndef CHECK_MEM
    #define CHECK_MEM(__p) MACSTART if ((__p) == NULL) { hr = E_OUTOFMEMORY; goto e_Exit; } MACEND
#endif
#ifndef CHECK_OUTPTR
    #define CHECK_OUTPTR(__p) MACSTART if (!ISVW(__p)) return E_POINTER; else *(__p) = NULL; MACEND
#endif


//
// DEBUG STUFF
//

#ifdef _DEBUG
    #include <stdio.h>
    #include <crtdbg.h>
    inline void __cdecl
        _GXTrace(const char *szFmt, ...)
    {
        char szMsgBuf[1024];
        va_list alist;
        va_start( alist, szFmt );
        _vsnprintf(szMsgBuf, 1024 - 1, szFmt, alist );
    #if defined(_WINDOWS) || defined(WIN32) || defined(_WIN32)
        // OutputDebugString(szMsgBuf);
    #endif // #if defined(_WINDOWS) || defined(WIN32) || defined(_WIN32)
        //fprintf(stderr, "%s", szMsgBuf);
        //fflush(stderr);
    }

    //#define GXASSERT(exp)       ((void) 0)
    #define GXASSERT(exp)       D3DXASSERT(exp)
    #define GXVERIFY(exp)       GXASSERT(exp)
    #define GXDEBUG_ONLY(exp)   (exp)
    #define GXTRACE             ::_GXTrace
#else // #ifdef _DEBUG
    inline void __cdecl _GXTrace(const char *szFmt, ...) {}
    #define GXASSERT(exp)       ((void) 0)
    #define GXVERIFY(exp)       ((void) (exp))
    #define GXDEBUG_ONLY(exp)   ((void) 0)
    #define GXTRACE             1 ? (void) 0 : ::_GXTrace
#endif // #else // #ifdef _DEBUG


#ifndef GXSETMAX
    #define GXSETMAX(dst, src1, src2)   MACSTART if ((src1) < (src2)) (dst) = (src2); else (dst) = (src1); MACEND
    #define GXSETMIN(dst, src1, src2)   MACSTART if ((src1) > (src2)) (dst) = (src2); else (dst) = (src1); MACEND
    #define GXUPDATEMAX(dst, src)       MACSTART if ((src) > (dst)) (dst) = (src); MACEND
    #define GXUPDATEMIN(dst, src)       MACSTART if ((src) < (dst)) (dst) = (src); MACEND
#endif

#ifndef GXISWAP
    #define GXISWAP(a,b)                MACSTART (a)^=(b); (b)^=(a); (a)^=(b); MACEND
#endif

// Macro: GXPSWAP
//    This macro swaps two pointers in place using 3 xor's.
#ifndef GXPSWAP
#define GXPSWAP(a,b,type) MACSTART \
    a = (type *)(int(a) ^ int(b)); \
    b = (type *)(int(a) ^ int(b)); \
    a = (type *)(int(a) ^ int(b)); \
MACEND
#endif


template<class T>
inline void
swap(T &a, T &b)
{
    T c(a);
    a = b;
    b = c;
}

static const int x_rgmod3[6]={0,1,2,0,1,2};
inline int MOD3(int j)
{
    GXASSERT(j>=0 && j<6);
    return x_rgmod3[j];
}


// Pointer checking
#if DBG
inline BOOL DWORD_PTR_OK(DWORD *p) {return !IsBadWritePtr(p, sizeof(DWORD));}
#else
inline BOOL DWORD_PTR_OK(DWORD *p) {return (p? TRUE:FALSE);}
#endif


// For X-file loading code
typedef HRESULT (STDAPICALLTYPE *LPDIRECTXFILECREATE)(LPDIRECTXFILE*);

#endif  // #ifndef __COMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\mesh\load3ds.cpp ===
/*//////////////////////////////////////////////////////////////////////////////
//
// File: load3ds.cpp
//
// Copyright (C) 1999 Microsoft Corporation. All Rights Reserved.
//
// @@BEGIN_MSINTERNAL
//
// History:
// -@-          (craigp)    - created
// -@- 08/26/99 (mikemarr)  - started comment history
//                          - replace gxbasetype.h with gxmathcore.h
// -@- 09/23/99 (mikemarr)  - replaced <> with "" on #includes
//
// @@END_MSINTERNAL
//
//////////////////////////////////////////////////////////////////////////////*/
#include "pchmesh.h"

#include "loadutil.h"

#include "3ds/3dsftk.h"
#define ON_ERROR_FAIL(hrNew) {if(ftkerr3ds && !ignoreftkerr3ds) { hr = hrNew; goto e_Exit;} }

UINT ISmoothingGroupID(UINT iSmoothingGroup)
{
    UINT iCur;
    UINT i;

    if (iSmoothingGroup == 0)
        return 0;

    iCur = iSmoothingGroup;
    for (i = 0; i < 32; i++)
    {
        if (iCur & 0x1)
            break;

        iCur = iCur >> 1;
    }

    GXASSERT(i <= 31);
    GXASSERT(iCur & 0x1);

    return i+1;
}

HRESULT WINAPI
D3DXLoadMeshFrom3ds(char *szFilename, DWORD options, DWORD fvf,
                    LPDIRECT3DDEVICE8 pD3DDevice,
                    LPD3DXMESH *ppMesh, LPD3DXBUFFER *ppbufAdjacency,
                    LPD3DXBUFFER *ppbufMaterials, PDWORD pcMaterials)
{
    file3ds *file= NULL;
    database3ds *db = NULL;
    ulong3ds cMeshes;
    ulong3ds iMesh;
    ulong3ds cVertices;
    ulong3ds cFaces;
    mesh3ds **rgpMesh = NULL;
    mesh3ds *pMesh;
    ulong3ds iVertex;
    ulong3ds iVertexIndex;
    point3ds *pvCur;
    ulong3ds cVerticesCur;
    ulong3ds iFaceIndex;
    ulong3ds iVertexOffset;
    face3ds *pfaceCur;
    ulong3ds cFacesCur;
    ulong3ds iFace;
    ulong3ds cMaterials = 0;
    ulong3ds iMaterial;
    material3ds *pmat;
    material3ds **rgMaterials = NULL;
    HRESULT hr = S_OK;
    LPD3DXMATERIAL rgmatMaterials = NULL;
    char *szTexName;
    char *szName;
    ulong3ds cMatFaces;
    ushort3ds *rgiMatFaces;
    ulong3ds i;
    UINT cchTexName;
    //IGXAttributeBundleDX7 *pattrCur;
    //IGXAttributeBundleDX7 *pattrEmpty = NULL;

    PBYTE       pvPoints = NULL;
    PBYTE       pvCurPoint = NULL;

    SLoadedFace *rglfFaces = NULL;
    SLoadVertex *rglvLoaded = NULL;

    SLoadedFace *plfFace;


    if ((ppMesh == NULL) || (szFilename == NULL))
    {
        hr = D3DERR_INVALIDCALL;
        goto e_Exit;
    }

    file = OpenFile3ds(szFilename, "rw");
    ON_ERROR_FAIL(E_FAIL);

    InitDatabase3ds(&db);
    ON_ERROR_FAIL(E_FAIL);

    CreateDatabase3ds(file, db);
    ON_ERROR_FAIL(E_FAIL);

    cMaterials = GetMaterialCount3ds(db);
    ON_ERROR_FAIL(E_FAIL);

    cMeshes = GetMeshCount3ds(db);
    ON_ERROR_FAIL(E_FAIL);

    //printf("# of meshes: %d\n", cMeshes);
    //fprintf(stderr, "# of meshes: %d\n", cMeshes);

    //fprintf(stderr, "# of materials: %d\n", cMaterials);

    rgMaterials = new material3ds*[cMaterials];
    rgmatMaterials = new D3DXMATERIAL[cMaterials];
    if ((rgMaterials == NULL) || (rgmatMaterials == NULL))
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }
    memset(rgMaterials, 0, sizeof(material3ds*) * cMaterials);
    memset(rgmatMaterials, 0, sizeof(D3DXMATERIAL) * cMaterials);

    // first retrieve all the materials
    for (iMaterial = 0; iMaterial < cMaterials; iMaterial++)
    {
        pmat = NULL;
        GetMaterialByIndex3ds(db, iMaterial, &pmat);
        ON_ERROR_FAIL(E_FAIL);

        rgMaterials[iMaterial] = pmat;
    }

    for (iMaterial = 0; iMaterial < cMaterials; iMaterial++)
    {
        rgmatMaterials[iMaterial].MatD3D.Diffuse.r = rgMaterials[iMaterial]->diffuse.r;
        rgmatMaterials[iMaterial].MatD3D.Diffuse.g = rgMaterials[iMaterial]->diffuse.g;
        rgmatMaterials[iMaterial].MatD3D.Diffuse.b = rgMaterials[iMaterial]->diffuse.b;
        rgmatMaterials[iMaterial].MatD3D.Diffuse.a = 1.0f;

        rgmatMaterials[iMaterial].MatD3D.Specular.r = rgMaterials[iMaterial]->specular.r;
        rgmatMaterials[iMaterial].MatD3D.Specular.g = rgMaterials[iMaterial]->specular.g;
        rgmatMaterials[iMaterial].MatD3D.Specular.b = rgMaterials[iMaterial]->specular.b;
        rgmatMaterials[iMaterial].MatD3D.Specular.a = 1.0f;

        rgmatMaterials[iMaterial].MatD3D.Ambient.r = rgMaterials[iMaterial]->ambient.r;
        rgmatMaterials[iMaterial].MatD3D.Ambient.g = rgMaterials[iMaterial]->ambient.g;
        rgmatMaterials[iMaterial].MatD3D.Ambient.b = rgMaterials[iMaterial]->ambient.b;
        rgmatMaterials[iMaterial].MatD3D.Ambient.a = 1.0f;

        szTexName = rgMaterials[iMaterial]->texture.map.name;
        cchTexName = strlen(szTexName) + 1;
        if (cchTexName > 0)
        {
            // allocate a buffer to store the texture name in
            rgmatMaterials[iMaterial].pTextureFilename = new char[cchTexName];
            if (rgmatMaterials[iMaterial].pTextureFilename == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto e_Exit;
            }

            // copy the texture filename into the prepared buffer
            strcpy(rgmatMaterials[iMaterial].pTextureFilename, szTexName);
        }
    }

    rgpMesh = new mesh3ds*[cMeshes];
    if (rgpMesh == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    for (iMesh = 0; iMesh < cMeshes; iMesh++)
    {
        pMesh = NULL;
        GetMeshByIndex3ds(db, iMesh, &pMesh);
        ON_ERROR_FAIL(E_FAIL);

        if (_stricmp(pMesh->name, "SUELO") == 0)
        {
            pMesh = NULL;
        }

        rgpMesh[iMesh] = pMesh;
    }

    cVertices = 0;
    cFaces = 0;
    for (iMesh = 0; iMesh < cMeshes; iMesh++)
    {
        if (rgpMesh[iMesh] != NULL)
        {
            cVertices += rgpMesh[iMesh]->nvertices;
            cFaces += rgpMesh[iMesh]->nfaces;
        }
    }

    // allocate memory to load data into

    hr = InitVertices(rglvLoaded, cVertices);
    if (FAILED(hr))
        goto e_Exit;

    hr = InitFaces(rglfFaces, cFaces);
    if (FAILED(hr))
        goto e_Exit;

    iVertexIndex = 0;
    for (iMesh = 0; iMesh < cMeshes; iMesh++)
    {
        if (rgpMesh[iMesh] == NULL)
            continue;

        cVerticesCur = rgpMesh[iMesh]->nvertices;
        for (iVertex = 0; iVertex < cVerticesCur; iVertex++)
        {
            pvCur = &rgpMesh[iMesh]->vertexarray[iVertex];

            rglvLoaded[iVertexIndex].m_vPos = *(D3DXVECTOR3*)pvCur;

            if (rgpMesh[iMesh]->ntextverts > 0)
            {
                rglvLoaded[iVertexIndex].m_uvTex1 = *(D3DXVECTOR2*)&rgpMesh[iMesh]->textarray[iVertex];
                rglvLoaded[iVertexIndex].m_uvTex1.y = 1 - rglvLoaded[iVertexIndex].m_uvTex1.y;
            }

            iVertexIndex += 1;
       }
   }

    iFaceIndex = 0;
    iVertexOffset = 0;
    for (iMesh = 0; iMesh < cMeshes; iMesh++)
    {
        if (rgpMesh[iMesh] == NULL)
            continue;

        cFacesCur = rgpMesh[iMesh]->nfaces;
        for (iFace = 0; iFace < cFacesCur; iFace++)
        {
            pfaceCur = &rgpMesh[iMesh]->facearray[iFace];

            rglfFaces[iFaceIndex].m_wIndices[0] = pfaceCur->v1 + iVertexOffset;
            rglfFaces[iFaceIndex].m_wIndices[1] = pfaceCur->v3 + iVertexOffset;
            rglfFaces[iFaceIndex].m_wIndices[2] = pfaceCur->v2 + iVertexOffset;

            rglfFaces[iFaceIndex].m_attr = 0;

            if (rgpMesh[iMesh]->smootharray)
            {
                rglfFaces[iFaceIndex].m_bSmoothingGroupSpecified = true;
                rglfFaces[iFaceIndex].m_iSmoothingGroup = (UINT16)(iMesh * 32 + ISmoothingGroupID(rgpMesh[iMesh]->smootharray[iFace]));
            }

            iFaceIndex += 1;
        }

        iVertexOffset += rgpMesh[iMesh]->nvertices;
   }

   iFaceIndex = 0;
   for (iMesh = 0; iMesh < cMeshes; iMesh++)
   {
        if (rgpMesh[iMesh] == NULL)
            continue;

        for (iMaterial = 0; iMaterial < rgpMesh[iMesh]->nmats; iMaterial++)
        {
            szName = rgpMesh[iMesh]->matarray[iMaterial].name;
            cMatFaces = rgpMesh[iMesh]->matarray[iMaterial].nfaces;
            rgiMatFaces = rgpMesh[iMesh]->matarray[iMaterial].faceindex;

            // lookup the index of the material
            for (i = 0; i < cMaterials; i++)
            {
                if (strcmp(rgMaterials[i]->name, szName) == 0)
                {
                    break;
                }
            }

            // check for not finding the material by name
            if (i == cMaterials)
            {
                hr = E_FAIL;
                goto e_Exit;
            }

            // now walk the index list, assigning the correct attribute bundle for
            //    the given material
            for (iFace = 0; iFace < cMatFaces; iFace++)
            {
                plfFace = &rglfFaces[iFaceIndex + rgiMatFaces[iFace]];

                plfFace->m_bAttributeSpecified = true;
                plfFace->m_attr = i;

                // UNDONE - should have option specifying whether to push
                    //   material colors down to vertices or not
                //plfFace->m_bColorSpecified = true;
                //plfFace->m_colorFace = *(D3DXCOLOR*)&rgMaterials[i]->diffuse;
            }
        }

        iFaceIndex += rgpMesh[iMesh]->nfaces;
   }

#if 0
    hr = GXCreateAttributeBundleDX7(&pattrEmpty);
    if (FAILED(hr))
    {
        goto e_Exit;
    }

    // for all faces without a texture, fill in with an attribute bundle that
    //   unsets the texture stage state
    for (iFace = 0; iFace < cFaces; iFace++)
    {
        plfFace = &rglfFaces[iFace];

        if (plfFace->m_pattr == NULL)
        {
            plfFace->m_bAttributeSpecified = true;
            plfFace->m_pattr = pattrEmpty;
        }
    }
#endif

    // now create the mesh
    hr = SetMesh(rglfFaces, cFaces, rglvLoaded, cVertices, NULL, 0, NULL, FALSE,
                        options, fvf, pD3DDevice, ppMesh, ppbufAdjacency);
    if (FAILED(hr))
        goto e_Exit;


    if (ppbufMaterials != NULL)
    {
        hr = CreateMaterialBuffer(rgmatMaterials, cMaterials, ppbufMaterials);
        if (FAILED(hr))
            goto e_Exit;
    }

    if (pcMaterials != NULL)
    {
        *pcMaterials = cMaterials;
    }

e_Exit:

    if (rgmatMaterials != NULL)
    {
        for (iMaterial = 0; iMaterial < cMaterials; iMaterial++)
        {
            delete []rgmatMaterials[iMaterial].pTextureFilename;
        }
    }

    delete []rgmatMaterials;
    delete []rgMaterials;

    delete []rglfFaces;
    delete []rglvLoaded;

    if (db != NULL)
    {
        ReleaseDatabase3ds(&db);
        //hr = E_FAIL;
        //ON_ERROR_RETURNR(E_FAIL);
    }

    if (file != NULL)
    {
        CloseFile3ds(file);
        //hr = E_FAIL;
        //ON_ERROR_RETURNR(E_FAIL);
    }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\mesh\intersect.cpp ===
/*//////////////////////////////////////////////////////////////////////////////
//
// File: intersect.cpp
//
// Copyright (C) 1999 Microsoft Corporation. All Rights Reserved.
//
// @@BEGIN_MSINTERNAL
//
// History:
// -@-          (craigp)    - created
//
// @@END_MSINTERNAL
//
//////////////////////////////////////////////////////////////////////////////*/

#include "pchmesh.h"

/*****************************************************************************
This function returns true if the ray intersects the volume of the bounding
sphere (not just the surface of the sphere).

The basis for this algorithm is found in "Real-Time Rendering", Moller/Haines,
sec. 10.3.
*****************************************************************************/

BOOL WINAPI D3DXSphereBoundProbe 
    (
    CONST D3DXVECTOR3 *pvCenter,
    float fRadius,
    D3DXVECTOR3 *pvRayPosition,
    D3DXVECTOR3 *pvRayDirection
    )
{
    D3DXVECTOR3 vLength;
    float fLengthSq;
    float fDot;
    float fDotSq;
    float fProjLength;
    float fRayLengthSq;
    const float fRadiusSq = fRadius * fRadius;

    // If the sphere radius is negative, the sphere is nil; return false.
    if (fRadius <= 0.0f) 
        return FALSE;


    // Length <- sphere.center - ray.origin
    vLength = *pvCenter;
    vLength -= *pvRayPosition;

    // L2 <- L dot L (squared length of vector L)

    fLengthSq = D3DXVec3LengthSq(&vLength);

    // If the ray origin is inside the sphere, then return true.

    if (fLengthSq < fRadiusSq) 
        return TRUE;

    // d <- L dot ray.direction
    fDot = D3DXVec3Dot(&vLength, pvRayDirection);

    // Due to the (L2 < r2) test above, we know that the ray origin is outside
    // the sphere.  Given this, the ray cannot intersect the sphere if the
    // sphere center is behind the ray.

    if (fDot < 0)
        return FALSE;

    // At this point, we need the ray direction to be normalized.

    fRayLengthSq = D3DXVec3LengthSq(pvRayDirection);
    fDotSq = (fDot * fDot) / fRayLengthSq;
    fProjLength = fLengthSq - fDotSq;     // m^2 <- L^2 - d^2

    // If the distance from the sphere center to its projection on the ray is
    // greater than the radius of the sphere, then the ray does not intersect.

    if (fProjLength > fRadiusSq) 
        return FALSE;
    else 
        return TRUE;
}

/*****************************************************************************
This function returns true if the probe ray intersects the bbox volume (not
just the surface of the box).

Based on Woo's method presented in Gems I, p. 395.  See also "Real-Time
Rendering", Haines, sec 10.4.2.
*****************************************************************************/

BOOL WINAPI D3DXBoxBoundProbe 
    (
    CONST D3DXVECTOR3 *pvMin, 
    CONST D3DXVECTOR3 *pvMax,
    D3DXVECTOR3 *pvRayPosition,
    D3DXVECTOR3 *pvRayDirection
    )
{
    // Reject empty bounding boxes.

    if (*pvMin == *pvMax)
        return FALSE;

    BOOL   inside = TRUE;
    BOOL   middle[3];        // True if ray origin in middle for coord i.
    DOUBLE plane[3];         // Candidate BBox Planes
    int    i;                // General Loop Counter

    // Find all candidate planes; select the plane nearest to the ray origin
    // for each coordinate.

    float *rgfRayPos = (float*)pvRayPosition;
    float *rgfMin = (float*)pvMin;
    float *rgfMax = (float*)pvMax;
    float *rgfRayDir = (float*)pvRayDirection;

    for (i=0;  i < 3;  ++i)
    {
        if (rgfRayPos[i] < rgfMin[i])
        {
            middle[i] = FALSE;
            plane[i] = rgfMin[i];
            inside = FALSE;
        }
        else if (rgfRayPos[i] > rgfMax[i])
        {
            middle[i] = FALSE;
            plane[i] = rgfMax[i];
            inside = FALSE;
        }
        else
        {
            middle[i] = TRUE;
        }
    }

    // If the ray origin is inside the box, then it must intersect the volume
    // of the bounding box.

    if (inside) 
        return TRUE;

    DOUBLE rayt = -1;
    int maxPlane = 0;

    for (i=0;  i < 3;  ++i)
    {
        if (!middle[i] && (rgfRayDir[i] != 0))
        {
            const DOUBLE t = (plane[i] - rgfRayPos[i]) / rgfRayDir[i];

            if (t > rayt)
            {   rayt = t;
                maxPlane = i;
            }
        }
    }

    // If the box is behind the ray, or if the box is beyond the extent of the
    // ray, then return no-intersect.

    if (rayt < 0)
        return FALSE;

    // The intersection candidate point is within acceptible range; test each
    // coordinate here to ensure that it actually hits the box.

    for (i=0;  i < 3;  ++i)
    {
        if (i != maxPlane)
        {
            DOUBLE c = rgfRayPos[i] + (rayt * rgfRayDir[i]);
            if ((c < rgfMin[i]) || (rgfMax[i] < c))
                return FALSE;
        }
    }

    return TRUE;
}

/*****************************************************************************
This is the main routine that determines if the ray intersects the triangle.
*****************************************************************************/

BOOL IntersectTri 
(
    CONST D3DXVECTOR3 *pv0,
    CONST D3DXVECTOR3 *pv1,
    CONST D3DXVECTOR3 *pv2,
    CONST D3DXVECTOR3 *pfRayPos,            // ray origin
    CONST D3DXVECTOR3 *pfRayDir,            // ray direction
    float *pfU,                       // Barycentric Hit Coordinates
    float *pfV,                       // Barycentric Hit Coordinates
    float *pfDist)                    // Ray-Intersection Parameter Distance
{
    D3DXVECTOR3 e1 (pv1->x - pv0->x, pv1->y - pv0->y, pv1->z - pv0->z);
    D3DXVECTOR3 e2 (pv2->x - pv0->x, pv2->y - pv0->y, pv2->z - pv0->z);
    D3DXVECTOR3 r;
    double a;
    double f;
    D3DXVECTOR3 s;
    D3DXVECTOR3 q;
    double u;
    double v;
    double t;

    D3DXVec3Cross(&r, pfRayDir, &e2);

    a = D3DXVec3Dot (&e1, &r);


    if (a > 0)
    {
        s = D3DXVECTOR3(pfRayPos->x - pv0->x, pfRayPos->y - pv0->y, pfRayPos->z - pv0->z);
    }
    else if (a < 0)
    {
        s = D3DXVECTOR3(pv0->x - pfRayPos->x, pv0->y - pfRayPos->y, pv0->z - pfRayPos->z);
        a = -a;
    }
    else
    {
        return FALSE;
    }

    f = 1 / a;

    u = D3DXVec3Dot(&s, &r);
    if ((u < 0) || (a < u)) 
        return FALSE;

    D3DXVec3Cross(&q, &s, &e1);

    v = D3DXVec3Dot(pfRayDir, &q);
    if ((v < 0) || (a < (u+v))) 
        return FALSE;

    t = D3DXVec3Dot(&e2, &q);
    if (t < 0)
        return FALSE;

    t = t * f;
    u = u * f;
    v = v * f;

    *pfU = (float)u;
    *pfV = (float)v;
    *pfDist = (float)t;

    return TRUE;
}

/*****************************************************************************
*****************************************************************************/

HRESULT WINAPI D3DXIntersect 
    (
    LPD3DXBASEMESH pMesh,
    CONST D3DXVECTOR3 *pfRayPos,
    CONST D3DXVECTOR3 *pfRayDir,
    BOOL    *pbHit,
    DWORD   *piFaceIndex,
    float   *pfA,
    float   *pfB,
    float   *pfDist
    )
{
    HRESULT hr = S_OK;
    DWORD cVertices;
    DWORD cFaces;
    BYTE *rgbFlags = NULL;
    float fA;
    float fB;
    float fDist;
    DWORD iFaceIndex;
    D3DXPLANE plane;
    float fBa,fBb;   // Barycentric Hit Coordinates
    float fDistCur;    // Current Hit Distance (Ray Parameter)
    float fD;
    WORD *rgwFaces = NULL;
    PBYTE pbPoints = NULL;
    DWORD iVertex;
    D3DXVECTOR3 *pvPos;
    DXCrackFVF cfvf(D3DFVF_XYZ);
    DWORD iFace;
    DWORD iFaceEnd;
    D3DXATTRIBUTERANGE *rgAttribTable = NULL;
    DWORD iAttrib;
    DWORD cAttribs;
    DWORD cMaxVertices;

    if ((pMesh == NULL) 
        || (pfRayPos == NULL) 
        || (pfRayDir == NULL)
        || (pbHit == NULL))
    {
        hr = D3DERR_INVALIDCALL;
        goto e_Exit;
    }

    // UNDONE UNDONE - templatize to fix 32 bit mesh issues
    if (pMesh->GetOptions() & D3DXMESH_32BIT)
    {
        hr = E_NOTIMPL;
        goto e_Exit;
    }

    cfvf = DXCrackFVF(pMesh->GetFVF());
    cVertices = pMesh->GetNumVertices();
    cFaces = pMesh->GetNumFaces();

    hr = pMesh->GetAttributeTable(NULL, &cAttribs);
    if (FAILED(hr))
        goto e_Exit;

    hr = pMesh->LockIndexBuffer(D3DLOCK_READONLY, (PBYTE*)&rgwFaces);
    if (FAILED(hr))
        goto e_Exit;

    hr = pMesh->LockVertexBuffer(D3DLOCK_READONLY, &pbPoints);
    if (FAILED(hr))
        goto e_Exit;

    *pbHit = FALSE;
    fDist = 1.0e35f;

    if (cVertices == 0) 
        goto e_Exit;

    rgAttribTable = new D3DXATTRIBUTERANGE[max(1, cAttribs)];
    if (rgAttribTable == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    // get the attribute table, if zero
    if (cAttribs > 0)
    {
        hr = pMesh->GetAttributeTable(rgAttribTable, NULL);
        if (FAILED(hr))
            goto e_Exit;
    }
    else
    {
        cAttribs = 1;  // allocated to be at least 1 in size above
                            // set to one, the "faked" up one
        rgAttribTable[0].FaceStart = 0;
        rgAttribTable[0].FaceCount = cFaces;
        rgAttribTable[0].VertexStart = 0;
        rgAttribTable[0].VertexCount = cVertices;
    }

    // find the max vertex index
    cMaxVertices = 0;
    for (iAttrib = 0; iAttrib < cAttribs; iAttrib++)
    {
        cMaxVertices = max(cMaxVertices, (rgAttribTable[iAttrib].VertexStart + rgAttribTable[iAttrib].VertexCount));
    }

    // allocate an array of vertex flags to help narrow the search
    rgbFlags = new BYTE[cMaxVertices];
    if (rgbFlags == NULL) 
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    memset(rgbFlags, 0, sizeof(BYTE) * cMaxVertices);

    // generate a plane containing the ray, which is parallel to the z-axis
    if (pfRayDir->x == 0)
    {
        plane.a = 1.0f;
        plane.b = 0.0f;
        plane.c = 0.0f;        
        plane.d = -pfRayPos->x;
    }
    else
    {
        plane.a = pfRayDir->y;
        plane.b = -pfRayDir->x;
        plane.c = 0.0f;        
        plane.d = (pfRayPos->y * pfRayDir->x) - (pfRayPos->x * pfRayDir->y);
    }

    fD = -plane.d;  // This speeds up the following loop.
    for (iVertex = 0; iVertex < cVertices; iVertex++)
    {
        pvPos = cfvf.PvGetPosition(cfvf.GetArrayElem(pbPoints, iVertex));

        if (((plane.a * pvPos->x) + (plane.b * pvPos->y)) > fD)
            rgbFlags[iVertex] = 0x1;
    }

    // use the attribute table in case there are any faces that are invalid
    //   i.e. a PM with multiple attributes not at the highest LOD
    for (iAttrib = 0; iAttrib < cAttribs; iAttrib++)
    {
        iFaceEnd = rgAttribTable[iAttrib].FaceStart + rgAttribTable[iAttrib].FaceCount;
        for (iFace = rgAttribTable[iAttrib].FaceStart; iFace < iFaceEnd; iFace++)
        {
            // first check the flags to see if all the points of the triangles lay
            //   on the same side of the plane, if they do, they can't intersect
            if ( (   rgbFlags[rgwFaces[3*iFace+0]]
                  == rgbFlags[rgwFaces[3*iFace+2]])
               &&(   rgbFlags[rgwFaces[3*iFace+1]]
                  == rgbFlags[rgwFaces[3*iFace+2]]))
            {
                continue;
            }

            if (IntersectTri(cfvf.PvGetPosition(cfvf.GetArrayElem(pbPoints, rgwFaces[3*iFace+0])),
                            cfvf.PvGetPosition(cfvf.GetArrayElem(pbPoints, rgwFaces[3*iFace+1])),
                            cfvf.PvGetPosition(cfvf.GetArrayElem(pbPoints, rgwFaces[3*iFace+2])),
                            pfRayPos, pfRayDir, &fBa, &fBb, &fDistCur))
            {
                // If the current hit is closer to the ray origin, then choose this
                // one as the winner.

                if (fDistCur < fDist)
                {
                    iFaceIndex = iFace;
                    fA = fBa;
                    fB = fBb;
                    fDist = fDistCur;
                    *pbHit = TRUE;
                }
            }
        }
    }

    if (*pbHit == TRUE)
    {
        if (piFaceIndex)
        {
            *piFaceIndex = iFaceIndex;
        }
        if (pfA)
        {
            *pfA = fA;
        }
        if (pfB)
        {
            *pfB = fB;
        }
        if (pfDist)
        {
            *pfDist = fDist;
        }
    }
e_Exit:
    delete []rgbFlags;
    delete []rgAttribTable;

	if (rgwFaces != NULL)
	{
		pMesh->UnlockIndexBuffer();
	}
	if (pbPoints != NULL)
	{
		pMesh->UnlockVertexBuffer();
	}

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\mesh\loadmesh.cpp ===
/*//////////////////////////////////////////////////////////////////////////////
//
// File: loadmesh.cpp
//
// Copyright (C) 1999 Microsoft Corporation. All Rights Reserved.
//
// @@BEGIN_MSINTERNAL
//
// History:
// -@-          (craigp)    - created
// -@- 08/06/99 (mikemarr)  - prepend GX to all Luciform functions
//                          - started comment history
// -@- 08/26/99 (mikemarr)  - replace gxbasetype.h with gxmathcore.h
// -@- 09/23/99 (mikemarr)  - changed <> to "" in #includes
//
// @@END_MSINTERNAL
//
//////////////////////////////////////////////////////////////////////////////*/

#include "pchmesh.h"

#include "loadutil.h"

#if 0
/*
 * Template routine to handle dynamic allocation, based on Heap* Win32 APIs.
 *
 *  T **ppBase: base of array.
 *  const T& obj: object to add to end of array.
 *  UINT *pcNum: number of objects in array.
 *  UINT *pcMax: max. number of objects in array.
 *
 * ppBase, pcNum and pcMax point to values that usually get modified
 * by the call. The only case when they are not updated is if there
 * is insufficient memory for the initial allocation (if *pBase is NULL)
 * or a second allocation if *pcNum==*pcMax.
 *
 * Return value: TRUE if allocation was successful
 *               FALSE if there was insufficient memory
 *      FALSE means nothing was added to the array, but nothing
 *        was lost either. No weird realloc semantics allowed!
 */
template<class T>
BOOL
AddToDynamicArray( T **ppBase, const T& obj, UINT *pcNum, UINT *pcMax )
{
    T *pBase = *ppBase;
    if ( ! pBase )
    {
        HeapValidate( GetProcessHeap(), 0, NULL );
        pBase = new T[2];
        *pcNum = 0;
        *pcMax = 2;
    }
    if ( *pcNum == *pcMax )
    {
        UINT cNewMax = *pcMax*2;
        T *newarr = new T[cNewMax];
        if ( ! newarr )
            return FALSE;
        for (UINT i = 0; i < *pcNum; i++)
            newarr[i] = pBase[i];
        *pcMax = cNewMax;
        delete []pBase;
        pBase = newarr;
    }
    pBase[ (*pcNum)++ ] = obj;
    *ppBase = pBase;
    return TRUE;
}


class GXColorAttributeBundle : public IGXAttributeBundle
{
public:

    virtual HRESULT STDMETHODCALLTYPE QueryInterface(
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject)
    {
        return E_FAIL;
    };

    virtual ULONG STDMETHODCALLTYPE AddRef( void) { return 1; }

    virtual ULONG STDMETHODCALLTYPE Release( void) { return 1; };

    // punch attribute set to device
    virtual HRESULT SetAttributesToDevice( LPDIRECT3DDEVICE8 pD3DDevice )
    {
        return pD3DDevice->SetMaterial(&m_mtrlColor);
    }

    // user defined data
    virtual HRESULT SetUserData( PVOID pvUserData ) { return E_NOTIMPL; };
    virtual HRESULT GetUserData( PVOID *ppvUserData ) { return E_NOTIMPL; };

    // user defined sort index for preferred order to draw attribute bundle sets in
    virtual HRESULT SetSortIndex( DWORD dwSortIndex ) { return S_OK; };
    virtual HRESULT GetSortIndex( PDWORD pdwSortIndex ) { *pdwSortIndex = 0; return S_OK;};

    GXColorAttributeBundle(D3DXCOLOR &color)
    {
        ZeroMemory( &m_mtrlColor, sizeof(D3DMATERIAL8) );
        m_mtrlColor.dcvDiffuse.r = m_mtrlColor.dcvAmbient.r = color.r;
        m_mtrlColor.dcvDiffuse.g = m_mtrlColor.dcvAmbient.g = color.g;
        m_mtrlColor.dcvDiffuse.b = m_mtrlColor.dcvAmbient.b = color.b;
        m_mtrlColor.dcvDiffuse.a = m_mtrlColor.dcvAmbient.a = 1.0f;
        m_mtrlColor.dcvEmissive.r = 0;
        m_mtrlColor.dcvEmissive.g = 0;
        m_mtrlColor.dcvEmissive.b = 0;
    }

private:
    D3DMATERIAL8 m_mtrlColor;
};
#endif

// identifier was truncated to '255' characters in the browser information
#pragma warning(disable: 4786)

const char *x_szSeparators = " \n\r\t";
const char *x_szVertex = "Vertex";
const UINT x_cchVertex = 6;
const char *x_szCorner = "Corner";
const UINT x_cchCorner = 6;
const char *x_szFace = "Face";
const UINT x_cchFace = 4;
const char *x_szOpenParen = "(";
const char *x_szCloseParen = ")";
const char *x_szOptionalArgStart = "{";
const char *x_szOptionalArgEnd = "}";
const char *x_szRGB = "rgb";
const char *x_szMatId = "matid";
const char *x_szNormal = "normal";
const char *x_szUv = "uv";
const char *x_szEquals = "=";

HRESULT
CFileContext::GetCharHelper(char *pchBuffer, bool &bEOF)
{
    HRESULT hr = S_OK;
    unsigned long cchRead;

    GXASSERT(m_ichBuffer == m_cchBuffer);

    if (m_bEndOfFile)
    {
        bEOF = true;
        goto e_Exit;
    }

    hr = m_pstream->Read(m_szBuffer, x_cbBufferSize, &cchRead);
    if (FAILED(hr) || (cchRead == 0))
    {
        if ((hr == S_FALSE) || (cchRead == 0))
        {
            m_bEndOfFile = true;
            bEOF = true;
            hr = S_OK;
        }

        goto e_Exit;
    }

    m_cchBuffer = cchRead;
    m_ichBuffer = 0;

    hr = GetChar(pchBuffer, bEOF);
    if (FAILED(hr))
        goto e_Exit;

e_Exit:
    return hr;
}

HRESULT
CFileContext::GetLine(char *szBuffer, int cchBuffer, bool &bEOF)
{
    int ichBuffer;
    HRESULT hr = S_OK;
    bool bTemp;
    char chTemp;

    ichBuffer = 0;
    bEOF = false;

    hr = GetChar(&szBuffer[ichBuffer], bEOF);
        if (FAILED(hr) || bEOF)
    {
        // this is both an acceptable EOF case, and an error case, but no way to tell the user
        goto e_Exit;
    }

    while ((szBuffer[ichBuffer] != '\n') && (ichBuffer < cchBuffer - 2))
    {
        ichBuffer += 1;

        hr = GetChar(&szBuffer[ichBuffer], bTemp);
            if (FAILED(hr) || bTemp)
        {
            szBuffer[ichBuffer+1] = '\0';
            goto e_Exit;
        }

        if (szBuffer[ichBuffer] == '\r')
            ichBuffer -= 1;
    }


    szBuffer[ichBuffer+1] = '\0';

    // if we hit the limit of the string without hitting the end of the line
    //    then skip the rest of the line
    if ((ichBuffer == cchBuffer - 2) && (szBuffer[ichBuffer] != '\n'))
    {
        do
        {
            hr = GetChar(&chTemp, bTemp);
            if (FAILED(hr) || bTemp)
                goto e_Exit;
        }
        while (chTemp != '\n');
    }

e_Exit:
    return hr;
}



const UINT x_cOptionalArgsMax = 4;

class CParseOptionalArgs
{
private:
    char *m_rgszArgs[x_cOptionalArgsMax];
    UINT m_rgcchArgs[x_cOptionalArgsMax];
    char *m_rgszValues[x_cOptionalArgsMax];
    UINT m_rgcchValues[x_cOptionalArgsMax];

    UINT m_cOptionalArgs;

public:
    CParseOptionalArgs()
        :m_cOptionalArgs(0) { }

    UINT COptionalArgs() const { return m_cOptionalArgs; }

    HRESULT Parse(char *szOptionalArgs);
    bool BCompareArg(UINT iOptionalArg, const char *szPossibleArg);

    HRESULT GetPoint2(UINT iOptionalArg, D3DXVECTOR2 *puvPoint);
    HRESULT GetVector3(UINT iOptionalArg, D3DXVECTOR3 *pvVector);
    HRESULT GetCoVector3(UINT iOptionalArg, D3DXVECTOR3 *pvVector);

    HRESULT GetColorRGB(UINT iOptionalArg, D3DXCOLOR *pcolor);
    HRESULT GetDWORD(UINT iOptionalArg, DWORD *piArg);
};

char *
EatWhiteSpace(char *szBuf)
{
    while ((*szBuf == ' ') || (*szBuf == '\t'))
    {
        szBuf++;
    }

    return szBuf;
}

bool NotZero(D3DXVECTOR3 &vNormal)
{
    return (vNormal.x != 0.0f) || (vNormal.y != 0.0f) || (vNormal.z != 0.0f);
}

char *
EatNonWhiteSpace(char *szBuf, char chTerminator)
{
    while ((*szBuf != '\0') && (*szBuf != ' ') && (*szBuf != '\t') && (*szBuf != chTerminator))
    {
        szBuf++;
    }

    return szBuf;
}

char *
EatUntilTerminator(char *szBuf, char chTerminator)
{
    while ((*szBuf != '\0') && (*szBuf != chTerminator))
    {
        szBuf++;
    }

    return szBuf;
}

HRESULT
CParseOptionalArgs::Parse(char *szOptionalArgs)
{
    HRESULT hr = S_OK;
    char *szCur = szOptionalArgs;
    UINT iOptionalArg;

    // find the start of the string
    szCur = EatWhiteSpace(szCur);

    if (*szCur != '{')
    {
        hr = E_FAIL;
        goto e_Exit;
    }
    szCur++;

    while (szCur != '\0')
    {
        szCur = EatWhiteSpace(szCur);

        // if at the end of the string, then exit
        if (*szCur == '\0')
            break;

        // found the first argument
        iOptionalArg = m_cOptionalArgs;
        m_cOptionalArgs += 1;

        m_rgszArgs[iOptionalArg] = szCur;


        // now figure out how long it is
        szCur = EatNonWhiteSpace(szCur, '=');
        m_rgcchArgs[iOptionalArg] = (DWORD)(szCur - m_rgszArgs[iOptionalArg]);

        szCur = EatWhiteSpace(szCur);

        // if there is a value, find it, else go to next arg
        if (*szCur == '=')
        {
            szCur++; // skip the '='

            szCur = EatWhiteSpace(szCur);

            // had better be an argument if there was an '='
            if (*szCur == '\0')
            {
                hr = E_FAIL;
                goto e_Exit;
            }

            m_rgszValues[iOptionalArg] = szCur;

            if (*szCur == '(')
            {
                szCur = EatUntilTerminator(szCur, ')');
                if (*szCur == '\0')
                {
                    hr = E_FAIL;
                    goto e_Exit;
                }
                szCur++;  // move beyond the ')'

                m_rgcchValues[iOptionalArg] = (DWORD)(szCur - m_rgszValues[iOptionalArg]);
            }
            else
            {
                // NOTE: hitting end of string here is completely acceptable
                //   and pass in ' ' as the terminator because there is no special terminator
                szCur = EatNonWhiteSpace(szCur, ' ');

                m_rgcchValues[iOptionalArg] = (DWORD)(szCur - m_rgszValues[iOptionalArg]);
            }

        }
        else
        {
            m_rgszValues[iOptionalArg] = NULL;
            m_rgcchValues[iOptionalArg] = 0;
        }
    }

e_Exit:
    return hr;
}

bool
CParseOptionalArgs::BCompareArg(UINT iOptionalArg, const char *szPossibleArg)
{
    GXASSERT(iOptionalArg < m_cOptionalArgs);
    return strncmp(szPossibleArg, m_rgszArgs[iOptionalArg], m_rgcchArgs[iOptionalArg]) == 0;
}

HRESULT
CParseOptionalArgs::GetDWORD(UINT iOptionalArg, DWORD *piArg)
{
    GXASSERT(iOptionalArg < m_cOptionalArgs);

    *piArg = atoi(m_rgszValues[iOptionalArg]);

    return S_OK;
}

HRESULT
CParseOptionalArgs::GetColorRGB(UINT iOptionalArg, D3DXCOLOR *pcolor)
{
    GXASSERT(iOptionalArg < m_cOptionalArgs);

    HRESULT hr = S_OK;
    char *szCur;

    szCur = m_rgszValues[iOptionalArg];

    GXASSERT(*szCur == '(');
    szCur++;

    // convert the three numbers into a color
    pcolor->r = (float)strtod(szCur, &szCur);
    pcolor->g = (float)strtod(szCur, &szCur);
    pcolor->b = (float)strtod(szCur, &szCur);
    pcolor->a = 0.0f;

    return hr;
}

HRESULT
CParseOptionalArgs::GetPoint2(UINT iOptionalArg, D3DXVECTOR2 *puvPoint)
{
    GXASSERT(iOptionalArg < m_cOptionalArgs);

    HRESULT hr = S_OK;
    char *szCur;

    szCur = m_rgszValues[iOptionalArg];

    GXASSERT(*szCur == '(');
    szCur++;

    // find and convert the first number
    puvPoint->x = (float)strtod(szCur, &szCur);
    puvPoint->y = (float)strtod(szCur, &szCur);

    return hr;
}

HRESULT
CParseOptionalArgs::GetVector3(UINT iOptionalArg, D3DXVECTOR3 *pvVector)
{
    GXASSERT(iOptionalArg < m_cOptionalArgs);

    HRESULT hr = S_OK;
    char *szCur;

    szCur = m_rgszValues[iOptionalArg];

    GXASSERT(*szCur == '(');
    szCur++;

    // find and convert the first number
    pvVector->x = (float)strtod(szCur, &szCur);
    pvVector->y = (float)strtod(szCur, &szCur);
    pvVector->z = (float)strtod(szCur, &szCur);

    return hr;
}

HRESULT
CParseOptionalArgs::GetCoVector3(UINT iOptionalArg, D3DXVECTOR3 *pvVector)
{
    HRESULT hr;

    D3DXVECTOR3 vTemp;
    hr = GetVector3(iOptionalArg, &vTemp);
    if (FAILED(hr))
        return hr;

    *pvVector = vTemp;

    return S_OK;
}


HRESULT
LoadCounts(CFileContext *pfc, UINT *pcVertices, UINT *pcFaces, UINT *pcCorners)
{
    HRESULT hr = S_OK;
    char rgchBuf[20];
    char *szHeader;
    UINT cFaces;
    UINT cVertices;
    UINT cCorners;
    char *szValue;
    UINT cNewValue;
    bool bEOF;

    GXASSERT((pcVertices != NULL) && (pcFaces != NULL) && (pcCorners != NULL));

    // initialize the counters
    *pcVertices = UINT_MAX;
    *pcFaces = UINT_MAX;
    *pcCorners = UINT_MAX;


    cFaces = 0;
    cVertices = 0;
    cCorners = 0;

    // get the counts of the faces, vertices, etc
    while ( 1 )
    {
        hr = pfc->GetLine(rgchBuf, sizeof(rgchBuf), bEOF);
        if (FAILED(hr))
        {
            goto e_Exit;
        }

        if (bEOF)
        {
            break;  // EOF, break out of loop
        }

        szHeader = strtok( rgchBuf, x_szSeparators );

        // if the token is NULL, go onto the next line
        if (szHeader != NULL)
        {
            // add the line to the proper count if it fits the profile
            if (strcmp(szHeader, x_szVertex) == 0)
            {
                szValue = strtok( NULL, x_szSeparators );
                if (szValue == NULL)
                {
                    hr = E_FAIL;
                    goto e_Exit;
                }

                cNewValue = atol(szValue);
                if (cVertices < cNewValue)
                    cVertices = cNewValue;
            }
            else if (strcmp(szHeader, x_szFace) == 0)
            {
                szValue = strtok( NULL, x_szSeparators );
                if (szValue == NULL)
                {
                    hr = E_FAIL;
                    goto e_Exit;
                }

                cNewValue = atol(szValue);
                if (cFaces < cNewValue)
                    cFaces = cNewValue;
            }
            else if (strcmp(szHeader, x_szCorner) == 0)
            {
                cCorners += 1;
            }

        }
    }

    *pcFaces = cFaces;
    *pcVertices = cVertices;
    *pcCorners = cCorners;

    // rewind
    hr = pfc->Rewind();
    if (FAILED(hr))
        goto e_Exit;

e_Exit:
    return hr;
}


HRESULT
LoadVertex(char *szLineBuf, SLoadVertex *rglvVertices, UINT cVertices, bool &bNormalFound)
{
    HRESULT hr = S_OK;
    char *szToken;
    char *szPointId;
    char *szPointX;
    char *szPointY;
    char *szPointZ;
    char *szHeader;
    UINT ulPointId;
    UINT iOptionalArg;


    // the header should always be present, checked before calling this function
    szHeader = strtok( szLineBuf, x_szSeparators );
    GXASSERT((szHeader != NULL) && strcmp(szHeader, x_szVertex) == 0);

    // get the number for the count
    szPointId = strtok( NULL, x_szSeparators );
    if (szPointId == NULL)
    {
        hr = E_FAIL;
        goto e_Exit;
    }

    // load the various parts of the vertex from the strings
    szPointX = strtok( NULL, x_szSeparators );
    if (szPointX == NULL)
    {
        hr = E_FAIL;
        goto e_Exit;
    }

    szPointY = strtok( NULL, x_szSeparators );
    if (szPointY == NULL)
    {
        hr = E_FAIL;
        goto e_Exit;
    }

    szPointZ = strtok( NULL, x_szSeparators );
    if (szPointZ == NULL)
    {
        hr = E_FAIL;
        goto e_Exit;
    }

    ulPointId = atoi(szPointId);
    if ((ulPointId == 0) || (ulPointId > cVertices))
    {
        hr = E_FAIL;
        goto e_Exit;
    }

    // convert from one based to zero based
    ulPointId -= 1;

    // UNDONE - handle errors by not using atof
    rglvVertices[ulPointId].m_vPos = D3DXVECTOR3((float)atof(szPointX), (float)atof(szPointY), (float)atof(szPointZ));

    // look optional information
    szToken = strtok( NULL, "}" );
    if (szToken != NULL)
    {
        CParseOptionalArgs ParseArgs;

        // parse the optional information, into an wonder of all wonders, a readable form
        hr = ParseArgs.Parse(szToken);
        if (FAILED(hr))
        {
            goto e_Exit;
        }

        // loop over all the args, getting the info for the understood items
        for (iOptionalArg = 0; iOptionalArg < ParseArgs.COptionalArgs(); iOptionalArg++)
        {
            if (ParseArgs.BCompareArg(iOptionalArg, x_szNormal))
            {
                hr = ParseArgs.GetCoVector3(iOptionalArg, &rglvVertices[ulPointId].m_vNormal);
                if (FAILED(hr))
                    goto e_Exit;

                bNormalFound = NotZero(rglvVertices[ulPointId].m_vNormal);
            }
            else if (ParseArgs.BCompareArg(iOptionalArg, x_szUv))
            {
                hr = ParseArgs.GetPoint2(iOptionalArg, &rglvVertices[ulPointId].m_uvTex1);
                if (FAILED(hr))
                    goto e_Exit;
            }
        }
    }

e_Exit:
    return hr;
}

HRESULT
LoadFace(char *szLineBuf, UINT cFacesMax, SLoadedFace *rgFaces)
{
    HRESULT hr = S_OK;
    char *szToken;
    char *szFaceId;
    char *szPoint1;
    char *szPoint2;
    char *szPoint3;
    char *szHeader;
    UINT ulFaceId;
    UINT iOptionalArg;

    szHeader = strtok( szLineBuf, x_szSeparators );
    GXASSERT((szHeader != NULL) && strcmp(szHeader, x_szFace) == 0);


    // get the number for the count
    szFaceId = strtok( NULL, x_szSeparators );
    if (szFaceId == NULL)
    {
        hr = E_FAIL;
        goto e_Exit;
    }

    ulFaceId = atoi(szFaceId) - 1;

    // if the face id is too high, and/or the face is already in use (specified twice in file)
    if ((ulFaceId >= cFacesMax) || (rgFaces[ulFaceId].m_wIndices[0] != UNUSED32))
    {
        hr = D3DERR_INVALIDCALL;
        goto e_Exit;
    }

    // load the various parts of the vertex from the strings
    szPoint1 = strtok( NULL, x_szSeparators );
    if (szPoint1 == NULL)
    {
        hr = E_FAIL;
        goto e_Exit;
    }

    szPoint2 = strtok( NULL, x_szSeparators );
    if (szPoint2 == NULL)
    {
        hr = E_FAIL;
        goto e_Exit;
    }

    szPoint3 = strtok( NULL, x_szSeparators );
    if (szPoint3 == NULL)
    {
        hr = E_FAIL;
        goto e_Exit;
    }

    // UNDONE - handle errors by not using atoi
    // NOTE: reverse the ordering of the indices... otherwise CCW ordering becomes CW ordering
    //          when -z applied to change from right hand to left hand coordinate system
    rgFaces[ulFaceId] = SLoadedFace(atoi(szPoint1)-1, atoi(szPoint2)-1, atoi(szPoint3)-1);


    // look optional information
    szToken = strtok( NULL, "}\n" );
    if (szToken != NULL)
    {
        CParseOptionalArgs ParseArgs;

        // parse the optional information, into an wonder of all wonders, a readable form
        hr = ParseArgs.Parse(szToken);
        if (FAILED(hr))
        {
            goto e_Exit;
        }

        // loop over all the args, getting the info for the understood items
        for (iOptionalArg = 0; iOptionalArg < ParseArgs.COptionalArgs(); iOptionalArg++)
        {
            if (ParseArgs.BCompareArg(iOptionalArg, x_szMatId))
            {
                rgFaces[ulFaceId].m_bMaterialSpecified = true;

                hr = ParseArgs.GetDWORD(iOptionalArg, &rgFaces[ulFaceId].m_matid);
                if (FAILED(hr))
                    goto e_Exit;
            }
            else if (ParseArgs.BCompareArg(iOptionalArg, x_szRGB))
            {
                rgFaces[ulFaceId].m_bColorSpecified = true;

                hr = ParseArgs.GetColorRGB(iOptionalArg, &rgFaces[ulFaceId].m_colorFace);
                if (FAILED(hr))
                    goto e_Exit;
            }
        }
    }

e_Exit:

    return hr;
}

HRESULT
LoadCorner(char *szLineBuf, UINT iCorner, UINT cVertices, UINT cFaces, SCorner *rgCorners, bool &bNormalFound)
{
    HRESULT hr = S_OK;
    char *szToken;
    char *szFaceId;
    char *szPointId;
    char *szHeader;
    UINT ulFaceId;
    UINT ulPointId;
    UINT iOptionalArg;

    szHeader = strtok( szLineBuf, x_szSeparators );
    GXASSERT((szHeader != NULL) && strcmp(szHeader, x_szCorner) == 0);


    // get the number for the count
    szPointId = strtok( NULL, x_szSeparators );
    if (szPointId == NULL)
    {
        hr = E_FAIL;
        goto e_Exit;
    }

    szFaceId = strtok( NULL, x_szSeparators );
    if (szFaceId == NULL)
    {
        hr = E_FAIL;
        goto e_Exit;
    }

    ulFaceId = atoi(szFaceId) - 1;
    ulPointId = atoi(szPointId) - 1;

    if ((ulFaceId >= cFaces) || (ulPointId > cVertices))
    {
        hr = D3DERR_INVALIDCALL;
        goto e_Exit;
    }

    rgCorners[iCorner].m_wFace = ulFaceId;
    rgCorners[iCorner].m_wPoint = ulPointId;


    // look optional information
    szToken = strtok( NULL, "}\n" );
    if (szToken != NULL)
    {
        CParseOptionalArgs ParseArgs;

        // parse the optional information, into an wonder of all wonders, a readable form
        hr = ParseArgs.Parse(szToken);
        if (FAILED(hr))
        {
            goto e_Exit;
        }

        // loop over all the args, getting the info for the understood items
        for (iOptionalArg = 0; iOptionalArg < ParseArgs.COptionalArgs(); iOptionalArg++)
        {

            if (ParseArgs.BCompareArg(iOptionalArg, x_szNormal))
            {
                rgCorners[iCorner].m_bNormalSpecified = true;

                hr = ParseArgs.GetCoVector3(iOptionalArg, &rgCorners[iCorner].m_vNormal);
                if (FAILED(hr))
                    goto e_Exit;

                bNormalFound = NotZero(rgCorners[iCorner].m_vNormal);
            }
            else if (ParseArgs.BCompareArg(iOptionalArg, x_szUv))
            {
                rgCorners[iCorner].m_bUvSpecified = true;

                hr = ParseArgs.GetPoint2(iOptionalArg, &rgCorners[iCorner].m_uvTex1);
                if (FAILED(hr))
                    goto e_Exit;
            }
        }
    }

e_Exit:

    return hr;
}

HRESULT WINAPI
LoadMeshFromM(IStream *pstream, DWORD options, DWORD fvf,
              LPDIRECT3DDEVICE8 pD3DDevice,
              LPD3DXMESH *ppMesh, LPD3DXBUFFER *ppbufAdjacency)
{
    HRESULT hr = S_OK;
    UINT cVertices;
    UINT cCorners;
    UINT cFaces;
    UINT iVert;
    bool bNormalFound = false;
    UINT iFace;

    SLoadedFace        *rglfFaces = NULL;
    SLoadVertex *rglvLoaded = NULL;
    SCorner *rgCorners = NULL;

    bool bEOF;
    UINT iCorner = 0;
    CFileContext fc(pstream);

    char rgchBuf[256];

#if 0 // color attribute bundle testing
    //IGXAttributeBundle *pattrColor;
    //IGXAttributeBundle **rgBundles = NULL;
    UINT cBundles = 0;
    UINT cBundlesMax = 0;
    D3DXCOLOR *rgColors = NULL;
    UINT cColors = 0;
    UINT cColorsMax = 0;
    UINT iColor;
    const D3DXCOLOR colorGrey(0.5f, 0.5f, 0.5f, 0.0f);
#endif

    if ((ppMesh == NULL) || (pstream == NULL))
    {
        hr = D3DERR_INVALIDCALL;
        goto e_Exit;
    }

    hr = LoadCounts(&fc, &cVertices, &cFaces, &cCorners);
    if (FAILED(hr))
        goto e_Exit;

    if ((cVertices == 0) || (cFaces == 0))
    {
        hr = D3DERR_INVALIDCALL;
        goto e_Exit;
    }

    // allocate memory to load data into

    hr = InitVertices(rglvLoaded, cVertices);
    if (FAILED(hr))
        goto e_Exit;

    hr = InitFaces(rglfFaces, cFaces);
    if (FAILED(hr))
        goto e_Exit;

    hr = InitCorners(rgCorners, cCorners);
    if (FAILED(hr))
        goto e_Exit;

    // initialize the colors of the vertices to a reasonable default
    for (iVert = 0; iVert < cVertices; iVert++)
    {
        rglvLoaded[iVert].m_color = D3DXCOLOR(0.9f, 0.6f, 0.4f, 0.0f);
    }

    while ( 1 )
    {
        hr = fc.GetLine(rgchBuf, sizeof(rgchBuf), bEOF);
        if (FAILED(hr))
        {
            goto e_Exit;
        }

        if (bEOF)
        {
            break;  // EOF, break out of loop
        }

        // load the various face and vertices, ignore unrecognized lines

        if (strncmp(rgchBuf, x_szVertex, x_cchVertex) == 0)
        {
            hr = LoadVertex(rgchBuf, rglvLoaded, cVertices, bNormalFound);
            if (FAILED(hr))
                goto e_Exit;
        }
        else if (strncmp(rgchBuf, x_szFace, x_cchFace) == 0)
        {
            hr = LoadFace(rgchBuf, cFaces, rglfFaces);
            if (FAILED(hr))
                goto e_Exit;
        }
        else if (strncmp(rgchBuf, x_szCorner, x_cchCorner) == 0)
        {
            hr = LoadCorner(rgchBuf, iCorner, cVertices, cFaces, rgCorners, bNormalFound);
            if (FAILED(hr))
                goto e_Exit;

            iCorner++;
        }
    }

    GXASSERT(iCorner == cCorners);

    if (!bNormalFound)
    {
        for (iFace = 0; iFace < cFaces; iFace++)
        {
            if (rglfFaces[iFace].m_wIndices[0] != UNUSED32)
            {
                rglfFaces[iFace].m_bSmoothingGroupSpecified = true;
                rglfFaces[iFace].m_iSmoothingGroup = 1;
            }
        }
    }

    // test materials by generating materials for colors

#if 0
    for (iFace = 0; iFace < cFaces; iFace++)
    {
        if (rglfFaces[iFace].m_bColorSpecified)
        {
            for (iColor = 0; iColor < cColors; iColor++)
            {
                if (rgColors[iColor] == rglfFaces[iFace].m_colorFace)
                    break;
            }

            if (iColor == cColors)
            {
                if ( ! AddToDynamicArray( &rgColors, rglfFaces[iFace].m_colorFace, &cColors, &cColorsMax ) )
                {
                    hr = E_OUTOFMEMORY;
                    goto e_Exit;
                }
            }

#if 0
            if (iColor < cColors)
            {
                pattrColor = rgBundles[iColor];
            }
            else
            {
                if ( ! AddToDynamicArray( &rgColors, rglfFaces[iFace].m_colorFace, &cColors, &cColorsMax ) )
                {
                    hr = E_OUTOFMEMORY;
                    goto e_Exit;
                }

                pattrColor = new GXColorAttributeBundle(rglfFaces[iFace].m_colorFace);
                if (pattrColor == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto e_Exit;
                }

                if ( ! AddToDynamicArray( &rgBundles, pattrColor, &cBundles, &cBundlesMax ) )
                {
                    hr = E_OUTOFMEMORY;
                    goto e_Exit;
                }
            }
#endif

            //rglfFaces[iFace].m_pattr = pattrColor;
            rglfFaces[iFace].m_attr = iColor;
            rglfFaces[iFace].m_bAttributeSpecified = true;

            rglfFaces[iFace].m_colorFace = colorGrey;
            //rglfFaces[iFace].m_bColorSpecified = false;
        }
    }
#endif


    hr = SetMesh(rglfFaces, cFaces, rglvLoaded, cVertices, rgCorners, cCorners, NULL, FALSE,
                        options, fvf, pD3DDevice, ppMesh, ppbufAdjacency);
    if (FAILED(hr))
        goto e_Exit;

e_Exit:

    delete []rglfFaces;
    delete []rglvLoaded;
    delete []rgCorners;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\mesh\loadutil.h ===
#pragma once

#ifndef __LOADUTIL_H
#define __LOADUTIL_H

/*//////////////////////////////////////////////////////////////////////////////
//
// File: loadutil.h
//
// Copyright (C) 1999 Microsoft Corporation. All Rights Reserved.
//
// @@BEGIN_MSINTERNAL
//
// History:
// -@-          (craigp)    - created
// -@- 09/23/99 (mikemarr)  - copyright, started history
//
// @@END_MSINTERNAL
//
//////////////////////////////////////////////////////////////////////////////*/


struct SLoadVertex
{
    D3DXVECTOR3    m_vPos;
    D3DXCOLOR  m_color;
    D3DXVECTOR2    m_uvTex1;
    D3DXVECTOR3 m_vNormal;
    DWORD       m_wPointRep;
    DWORD       m_wPointList;
    bool        m_bOwned;
    WORD        m_iSmoothingGroup;
    WORD        m_cSmoothingGroupFaces;
    DWORD       m_iFVFDataOffset;
};

struct SLoadedFace
{
public:
    SLoadedFace()        
        { InitEmpty(); }
    SLoadedFace( DWORD w0, DWORD w1, DWORD w2 )
    {
        Init(w0, w1, w2);
    }
    SLoadedFace( DWORD wIndices[3] )
    {
        Init(wIndices[0], wIndices[1], wIndices[2]);
    }

    void Init(DWORD w0, DWORD w1, DWORD w2)
    {
        m_bColorSpecified = false;
        m_bMaterialSpecified = false;
        m_bAttributeSpecified = false;
        m_bSmoothingGroupSpecified = false;
        m_wIndices[0] = w0;
        m_wIndices[1] = w1;
        m_wIndices[2] = w2;
    }

    void InitEmpty()
    {
        Init(UNUSED32, UNUSED32, UNUSED32);
    }

    DWORD m_wIndices[3];
    WORD m_bColorSpecified:1;
    WORD m_bMaterialSpecified:1;
    WORD m_bAttributeSpecified:1;
    WORD m_bSmoothingGroupSpecified:1;
    D3DXCOLOR m_colorFace;
    DWORD m_matid;
    DWORD m_attr;
    WORD m_iSmoothingGroup;
};

struct SCorner
{
    DWORD        m_wPoint;
    DWORD        m_wFace;
    WORD        m_bNormalSpecified:1;
    WORD        m_bUvSpecified:1;
    D3DXVECTOR2    m_uvTex1;
    D3DXVECTOR3   m_vNormal;
};

// structure used to define additional data not in a SLoadVertex
struct SFVFData
{
    DWORD dwFVF;
    DWORD cBytesPerVertex;
    DWORD *rgiFVFData;
    DWORD iTexCoordOffset;  // 0 if no normal tex data present in x file, 1 if separate texcoord block of data specified
};

HRESULT InitVertices(SLoadVertex *&rglvVertices, DWORD cVertices);
HRESULT InitCorners(SCorner *&rgCorners, DWORD cCorners);
HRESULT InitFaces(SLoadedFace *&rglfFaces, DWORD cFaces);
bool BEqualWedges(SLoadVertex &lv1, SLoadVertex &lv2);

HRESULT SetVertexColor(SLoadedFace *pface, DWORD iPoint, D3DXCOLOR &color, SLoadVertex **prglvLoaded, DWORD *pcVertices, DWORD *pcVerticesMax);
HRESULT SetVertexAttributes(SLoadedFace *pface, DWORD iPoint, D3DXVECTOR3 *pvNormal, D3DXVECTOR2 *puvTex1, SLoadVertex **prglvLoaded, DWORD *pcVertices, DWORD *pcVerticesMax);
DWORD FindPoint(PDWORD pwIndices, DWORD iPointSearch, SLoadVertex *rglvVerts);
HRESULT SetMesh(SLoadedFace *&rglfFaces, DWORD cFaces, 
                SLoadVertex *&rglvLoaded, DWORD cVertices, 
                SCorner *rgCorners, DWORD cCorners,
                SFVFData *pFVFData, BOOL bUsePointRepData,
                DWORD options, DWORD fvf, LPDIRECT3DDEVICE8 pD3D, 
                LPD3DXMESH *ppMesh, LPD3DXBUFFER *ppbufAdjacency);

HRESULT
CreateMaterialBuffer(LPD3DXMATERIAL rgmat, DWORD cmat, LPD3DXBUFFER *ppbufMaterials);

HRESULT
MergeMaterialBuffers(LPD3DXBUFFER pbufMat1, DWORD cmat1, LPD3DXBUFFER pbufMat2, DWORD cmat2, LPD3DXBUFFER *ppbufMaterials);

const int x_cbBufferSize = 256;

class CFileContext
{
public:
    CFileContext(IStream *pstream)
        :m_pstream(pstream), m_ichBuffer(0), m_cchBuffer(0), m_bEndOfFile(false) {}

    HRESULT GetLine(char *szBuffer, int cchBuffer, bool &bEOF);

    HRESULT Rewind()
    {
        m_bEndOfFile = false;

        LARGE_INTEGER li;
        li.QuadPart = 0;
        return m_pstream->Seek(li, STREAM_SEEK_SET, NULL);
    }
private:

    inline HRESULT GetChar(char *szBuffer, bool &bEOF)
    {
        bEOF = false;

        if (m_ichBuffer < m_cchBuffer)
        {
            *szBuffer = m_szBuffer[m_ichBuffer];
            m_ichBuffer += 1;
            return S_OK;
        }
        else
        {
            return GetCharHelper(szBuffer, bEOF);
        }

    }

    HRESULT GetCharHelper(char *szBuffer, bool &bEOF);

    IStream *m_pstream;
    char m_szBuffer[x_cbBufferSize];

    ULONG m_ichBuffer;
    ULONG m_cchBuffer;
    bool m_bEndOfFile;
};

HRESULT WINAPI 
    D3DXCreateBuffer(
        DWORD numBytes, 
        LPD3DXBUFFER *ppBuffer);

#endif  // #ifndef __LOADUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\mesh\gxcrackfvf.h ===
#pragma once

#ifndef __DXCRACKFVF_H__
#define __DXCRACKFVF_H__

/*//////////////////////////////////////////////////////////////////////////////
//
// File: DXCrackFVF.h
//
// Copyright (C) 1999 Microsoft Corporation. All Rights Reserved.
//
// @@BEGIN_MSINTERNAL
//
// History:
// -@-          (craigp)    - created
// -@- 09/23/99 (mikemarr)  - added copyright and history
//                          - newline to end of file
//
// @@END_MSINTERNAL
//
//////////////////////////////////////////////////////////////////////////////*/


// -------------------------------------------------------------------------------
//  class DXCrackFVF
//          used to simplify retreiving and storing data to FVF formats.
//          on construction, it creates a set of offsets in the FVF format
//          that it uses in the the methods to access the correct members
//
class DXCrackFVF
{
public:
    inline DXCrackFVF(DWORD dwFVF);

    inline PBYTE GetArrayElem(PVOID pvPoints, DWORD iElem);

    inline void         SetPosition    (PVOID pvPoint, D3DXVECTOR3 *pvPos);
    inline void         SetNormal      (PVOID pvPoint, D3DXVECTOR3 *pvNormal);
    inline void         SetPointSize   (PVOID pvPoint, float fPointSize);
    inline void         SetDiffuse     (PVOID pvPoint, D3DCOLOR color);
    inline void         SetSpecular    (PVOID pvPoint, D3DCOLOR color);
    inline void         SetTex1        (PVOID pvPoint, D3DXVECTOR2 *puvTex1);

    inline void         SetTexCoord     (PVOID pvPoint, UINT iTexCoord, D3DXVECTOR2 *pvTexCoord);
    inline void         SetWeight       (PVOID pvPoint, UINT iWeight,   float fWeight);


    inline D3DXVECTOR3 *PvGetPosition    (PVOID pvPoint);
    inline D3DXVECTOR3 *PvGetNormal      (PVOID pvPoint);
    inline float        FGetPointSize    (PVOID pvPoint);
    inline D3DCOLOR     ColorGetDiffuse  (PVOID pvPoint);
    inline D3DCOLOR     ColorGetSpecular (PVOID pvPoint);
    inline D3DXVECTOR2 *PuvGetTex1       (PVOID pvPoint);
	inline float		*PfGetWeights	 (PVOID pvPoint);

    inline bool         BPosition()     { return true; }
    inline bool         BNormal()       { return m_oNormal > 0; }
    inline bool         BPointSize()    { return m_oPointSize > 0; }
    inline bool         BDiffuse()      { return m_oDiffuse > 0; }
    inline bool         BSpecular()     { return m_oSpecular > 0; }
    inline bool         BTex1()         { return m_oTex1 > 0; }

    inline DWORD        CWeights()      { return m_cWeights; }
    inline DWORD        CTexCoords()    { return m_cTexCoords; }
    inline DWORD        CbTexCoordSize(DWORD iTexCoord);
    inline void         GetTexCoordSizes(DWORD *rgdwTexCoordSizes);
    inline BOOL         BIndexedWeights() { return FALSE; }


    DWORD m_dwFVF;
    DWORD m_cBytesPerVertex; 
    DWORD m_oNormal;
    DWORD m_oPointSize;
    DWORD m_oDiffuse;
    DWORD m_oSpecular;
    DWORD m_oTex1;
    DWORD m_cWeights;
    DWORD m_cTexCoords;
};


// -------------------------------------------------------------------------------
//  class DXCrackFVF inline functions - used to simplify access to the FVF 
//

const DWORD x_rgdwTexCoordSize[] = { 8, 12, 16, 4};

// -------------------------------------------------------------------------------
//  constructor for DXCrackFVF, generates offsets used to access members
//      of the given FVF
//
inline 
DXCrackFVF::DXCrackFVF(DWORD dwFVF)
:m_dwFVF(dwFVF),
m_oNormal(0),
m_oPointSize(0),
m_oDiffuse(0),
m_oSpecular(0),
m_oTex1(0),
m_cWeights(0),
m_cTexCoords(0)
{
    DWORD oCur;
    DWORD dwPosition;
    DWORD dwTexCoordInfo;
    DWORD iTexCoord;
    DWORD dwTexCoordSize;

    oCur = 12;   // xyz
    dwPosition = dwFVF & D3DFVF_POSITION_MASK;

    if (dwPosition == D3DFVF_XYZRHW)
    {
        oCur += 4;
        DPF(0, "D3DX: Detected a mesh that is using XYZRHW which is not supported.");
    }

    if (dwPosition >= D3DFVF_XYZB1)
    {
        dwPosition -= 4;
        dwPosition /= 2;

        GXASSERT((dwPosition >= 1) && (dwPosition <= 5));
        oCur += 4 * dwPosition;

        m_cWeights = dwPosition;
    }

    if ( dwFVF & D3DFVF_NORMAL )
    {
        m_oNormal = oCur;
        oCur += 12;
    }

    if ( dwFVF & D3DFVF_DIFFUSE )
    {
        m_oDiffuse = oCur;
        oCur += 4;
    }

    if ( dwFVF & D3DFVF_SPECULAR )
    {
        m_oSpecular = oCur;
        oCur += 4;
    }

    if ( dwFVF & D3DFVF_TEXCOUNT_MASK )
    {
        m_oTex1 = oCur;

        // only one tu/tv set currently supported

        m_cTexCoords = ((dwFVF & D3DFVF_TEXCOUNT_MASK)>>D3DFVF_TEXCOUNT_SHIFT);

        // all 2d, then go quick route
        //if ((dwFVF & 0xffff0000) == 0)
        //{
            //oCur += sizeof(float) * 2 * m_cTexCoords;
        //}
        //else
        {
            dwTexCoordSize = (dwFVF & 0xffff0000) >> 16;
            for (iTexCoord = 0; iTexCoord < m_cTexCoords; iTexCoord++)
            {
                oCur += x_rgdwTexCoordSize[dwTexCoordSize & 0x3];
                dwTexCoordSize = dwTexCoordSize >> 2;
            }
        }
    }

    m_cBytesPerVertex = oCur;
}


// -------------------------------------------------------------------------------
//  function - GetArrayElem,  gets the ith element of the given FVF array
//
inline PBYTE 
DXCrackFVF::GetArrayElem(PVOID pvPoints, DWORD iElem)
{ 
    return ((PBYTE)pvPoints + (iElem * m_cBytesPerVertex)); 
}

// -------------------------------------------------------------------------------
//  function - SetPosition, sets the given position into the given FVF point
//
inline void 
DXCrackFVF::SetPosition    (PVOID pvPoint, D3DXVECTOR3 *pvPos)
{
    memcpy(pvPoint, pvPos, sizeof(D3DXVECTOR3));
}

// -------------------------------------------------------------------------------
//  function - SetNormal, sets the given normal into the given FVF point
//                  if no normal, this call is a no-op
//
inline void 
DXCrackFVF::SetNormal      (PVOID pvPoint, D3DXVECTOR3 *pvNormal)
{
    if (m_oNormal)
    {
        memcpy(((PBYTE)pvPoint) + m_oNormal, pvNormal, sizeof(D3DXVECTOR3));
    }
}

// -------------------------------------------------------------------------------
//  function - SetPointsize, sets the given point size into the given FVF point
//                  if no normal, this call is a no-op
//
inline void 
DXCrackFVF::SetPointSize   (PVOID pvPoint, float fPointSize)
{
    if (m_oPointSize)
    {
        memcpy(((PBYTE)pvPoint) + m_oPointSize, &fPointSize, sizeof(float));
    }
}

// -------------------------------------------------------------------------------
//  function - SetDiffuse, sets the given diffuse color into the given FVF point
//                  if no diffuse color, this call is a no-op
//
inline void 
DXCrackFVF::SetDiffuse     (PVOID pvPoint, D3DCOLOR color)
{
    if (m_oDiffuse)
    {
        memcpy(((PBYTE)pvPoint) + m_oDiffuse, &color, sizeof(D3DCOLOR));
    }
}

// -------------------------------------------------------------------------------
//  function - SetSpecular, sets the given specular color into the given FVF point
//                  if no specular color, this call is a no-op
//
inline void 
DXCrackFVF::SetSpecular    (PVOID pvPoint, D3DCOLOR color)
{
    if (m_oSpecular)
    {
        memcpy(((PBYTE)pvPoint) + m_oSpecular, &color, sizeof(D3DCOLOR));
    }
}

// -------------------------------------------------------------------------------
//  function - SetTex1, sets the given Tex1 UV coords into the given FVF point
//                  if no Tex1 coords, this call is a no-op
//
inline void 
DXCrackFVF::SetTex1        (PVOID pvPoint, D3DXVECTOR2 *puvTex1)
{
    if (m_oTex1)
    {
        memcpy(((PBYTE)pvPoint) + m_oTex1, puvTex1, sizeof(D3DXVECTOR2));
    }
}

// -------------------------------------------------------------------------------
//  function - SetTexCoord, sets the given textures coords into the given FVF point
//                  if the specified texture coordinate is not present, just return
//
inline void 
DXCrackFVF::SetTexCoord    (PVOID pvPoint, UINT iTexCoord, D3DXVECTOR2 *pvTexCoord)
{
    if (iTexCoord < m_cTexCoords)
    {
        memcpy(((PBYTE)pvPoint) + m_oTex1 + sizeof(D3DXVECTOR2) * iTexCoord, pvTexCoord, sizeof(D3DXVECTOR2));
    }
}

// -------------------------------------------------------------------------------
//  function - SetWeight, sets the given blend weight into the given FVF point
//                  if the specified blend weight is not present, just return
//
inline void 
DXCrackFVF::SetWeight     (PVOID pvPoint, UINT iWeight, float fWeight)
{
    if (iWeight < m_cWeights)
    {
        memcpy(((PBYTE)pvPoint) + sizeof(D3DXVECTOR3) + sizeof(float) * iWeight, &fWeight, sizeof(float));
    }
}

// -------------------------------------------------------------------------------
//  function - PvGetPosition, returns a pointer to the position in the given FVF vertex
//
inline D3DXVECTOR3  *
DXCrackFVF::PvGetPosition    (PVOID pvPoint)
{
    return (D3DXVECTOR3*)pvPoint;
}

// -------------------------------------------------------------------------------
//  function - PvGetNormal, returns a pointer to the normal in the given FVF vertex
//                              NOTE: the normal HAS to be present in the FVF format
//
inline D3DXVECTOR3 *
DXCrackFVF::PvGetNormal      (PVOID pvPoint)
{
    return (D3DXVECTOR3*)  (((PBYTE)pvPoint) + m_oNormal);
}

// -------------------------------------------------------------------------------
//  function - FGetPointSize, returns a the pointsize in the given FVF vertex
//                              NOTE: the point size HAS to be present in the FVF format
//
inline float
DXCrackFVF::FGetPointSize    (PVOID pvPoint)
{
    return *( (float*)  (((PBYTE)pvPoint) + m_oPointSize) );
}

// -------------------------------------------------------------------------------
//  function - ColorGetDiffuse, returns the diffuse color in the given FVF vertex
//                              NOTE: the color HAS to be present in the FVF format
//
inline D3DCOLOR  
DXCrackFVF::ColorGetDiffuse  (PVOID pvPoint)
{
    return *(D3DCOLOR*)  (((PBYTE)pvPoint) + m_oDiffuse);
}

// -------------------------------------------------------------------------------
//  function - ColorGetSpecular, returns the specular color in the given FVF vertex
//                              NOTE: the color HAS to be present in the FVF format
//
inline D3DCOLOR  
DXCrackFVF::ColorGetSpecular (PVOID pvPoint)
{
    return *(D3DCOLOR*)  (((PBYTE)pvPoint) + m_oSpecular);
}

// -------------------------------------------------------------------------------
//  function - PuvGetTex1, returns a pointer to the tex1 position in the given FVF vertex
//                              NOTE: the tex1 HAS to be present in the FVF format
//
inline D3DXVECTOR2  *
DXCrackFVF::PuvGetTex1       (PVOID pvPoint)
{
    return (D3DXVECTOR2*)  (((PBYTE)pvPoint) + m_oTex1);
}

// -------------------------------------------------------------------------------
//  function - PuvGetWeights, returns a pointer to the first weight 
//                              NOTE: the weights HAS to be present in the FVF format
//
inline float  *
DXCrackFVF::PfGetWeights       (PVOID pvPoint)
{
    return (float*)(((PBYTE)pvPoint) + sizeof(D3DXVECTOR3));
}

// -------------------------------------------------------------------------------
//  function - CbTexCoordSize, returns the size of the given set of texture coordinates
//
inline DWORD
DXCrackFVF::CbTexCoordSize       (DWORD iTexCoord)
{
    if (iTexCoord < m_cTexCoords)
        return x_rgdwTexCoordSize[(m_dwFVF >> (16 + iTexCoord * 2)) & 0x3];
    else
        return 0;
}

// -------------------------------------------------------------------------------
//  function - CbTexCoordSize, returns the sizes of all 8 texture coords (0 if not present)
//
inline void
DXCrackFVF::GetTexCoordSizes       (DWORD *rgdwTexCoordSizes)
{
    DWORD iTexCoord;

    for (iTexCoord = 0; iTexCoord < m_cTexCoords; iTexCoord++)
    {
        rgdwTexCoordSizes[iTexCoord] = x_rgdwTexCoordSize[(m_dwFVF >> (16 + iTexCoord * 2)) & 0x3];
    }

    // set the rest to 0
    for (;iTexCoord < 8; iTexCoord++)
    {
        rgdwTexCoordSizes[iTexCoord] = 0;
    }
}


    inline void         GetTexCoordSizes(DWORD *rgdwTexCoordSizes);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\mesh\loadx.cpp ===
/*//////////////////////////////////////////////////////////////////////////////
//
// File: loadmesh.cpp
//
// Copyright (C) 1999 Microsoft Corporation. All Rights Reserved.
//
// @@BEGIN_MSINTERNAL
//
// History:
// -@-          (craigp)    - created
// -@- 08/06/99 (mikemarr)  - prepend GX to all Luciform functions
//                          - started comment history
// -@- 08/26/99 (mikemarr)  - replace gxbasetype.h with gxmathcore.h
// -@- 09/23/99 (mikemarr)  - changed <> to "" in #includes
//
// @@END_MSINTERNAL
//
//////////////////////////////////////////////////////////////////////////////*/

#include "pchmesh.h"

#include "loadutil.h"
#include "skinmesh.h"
#include <initguid.h>
#define D3DRM_XTEMPLATES _D3DX_D3DRM_XTEMPLATES
#include "CD3dxbuffer.h"
#include "rmxftmpl.h"

typedef enum tagSTATFLAG {
    STATFLAG_DEFAULT= 0,
    STATFLAG_NONAME = 1,
    STATFLAG_NOOPEN = 2
} STATFLAG;

#undef DEFINE_GUID
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    static const GUID name \
                    = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#include "rmxfguid.h"
#include "xskinexptemplates.h"

#include "savemesh.cpp"

// predecl
HRESULT WINAPI D3DXLoadMeshFromXofEx
    (
    LPDIRECTXFILEDATA pxofobjMesh,
    DWORD options,
    LPDIRECT3DDEVICE8 pD3DDevice,
    LPD3DXBUFFER *ppbufAdjacency,
    LPD3DXBUFFER *ppbufMaterials,
    PDWORD pcMaterials,
    LPD3DXMESH *ppMesh,
    PBYTE *ppbPMData,
    DWORD *pcbPMData,
    LPD3DXBUFFER *ppBoneNames,
    LPD3DXBUFFER *ppBoneTransforms,
    LPBONE *ppBones,
    DWORD *pNumBones
    );

DWORD DwCombineFVFs(DWORD dwFVF1, DWORD dwFVF2)
{
    DXCrackFVF cfvf1(dwFVF1);
    DXCrackFVF cfvf2(dwFVF2);
    DWORD dwWeights;
    DWORD dwTex;
    DWORD dwOut;

    dwWeights = max(cfvf1.CWeights(), cfvf2.CWeights());
    if (dwWeights > 0)
    {
        dwWeights *= 2;
        dwWeights += 4;
        dwOut = dwWeights;
    }
    else
    {
        dwOut = D3DFVF_XYZ;
    }

    if (cfvf1.BNormal() || cfvf2.BNormal())
        dwOut |= D3DFVF_NORMAL;

    if (cfvf1.BDiffuse() || cfvf2.BDiffuse())
        dwOut |= D3DFVF_DIFFUSE;

    if (cfvf1.BSpecular() || cfvf2.BSpecular())
        dwOut |= D3DFVF_SPECULAR;

    dwTex = max(cfvf1.CTexCoords(), cfvf2.CTexCoords());
    if (dwTex > 0)
    {
        dwOut |= (dwTex << D3DFVF_TEXCOUNT_SHIFT);
    }

    return dwOut;
}

// INTERNAL function, used to avoid header file issues with the PM template
HRESULT WINAPI
    D3DXCreatePMeshFromData
    (
    LPD3DXMESH ptmMesh,
    DWORD dwOptions,
    DWORD *rgdwAdjacency,
    PBYTE pbPMData,
    DWORD cbPMData,
    LPD3DXPMESH *pptmPMesh
    );

HRESULT D3DXMergeMeshes
    (
    LPD3DXMESH pMesh1,
    PDWORD rgdwAdjacency1,
    LPD3DXBUFFER pbufMaterials1,
    DWORD cmat1,
    LPD3DXMESH pMesh2,
    PDWORD rgdwAdjacency2,
    LPD3DXBUFFER pbufMaterials2,
    DWORD cmat2,
    LPDIRECT3DDEVICE8 pD3DDevice,
    LPD3DXMESH *ppMeshOut,
    LPD3DXBUFFER *ppbufAdjacencyOut,
    LPD3DXBUFFER *ppbufMaterialsOut,
    LPDWORD pcmatOut
    )
{
    HRESULT hr = S_OK;
    DWORD cVertices1;
    DWORD cVertices2;
    DWORD cVerticesOut;
    DWORD cFaces1;
    DWORD cFaces2;
    DWORD cFacesOut;
    LPD3DXMESH ptmMeshOut = NULL;
    LPD3DXBUFFER pbufAdjacencyOut = NULL;
    PDWORD rgdwAdjacencyOut;
    PDWORD rgdwAttribs1 = NULL;
    PDWORD rgdwAttribs2 = NULL;
    BOOL b16BitIndex;
    PBYTE pFacesOut = NULL;
    PDWORD rgdwAttribsOut = NULL;
    UINT iIndex;
    UINT iIndex2;
    DXCrackFVF cfvf(D3DFVF_XYZ);
    PBYTE pFaces1 = NULL;
    PBYTE pFaces2 = NULL;
    PBYTE pvPointsOut = NULL;
    PBYTE pvPoints1 = NULL;
    PBYTE    pvPoints2 = NULL;
    UINT cBytesPerIndex;
    LPD3DXBUFFER pbufMaterialsOut = NULL;
    DWORD dwFVF;
    DWORD dwOptions;
    LPD3DXMESH pTempMesh1 = NULL;
    LPD3DXMESH pTempMesh2 = NULL;

    // need all mesh pointers
    if ((pMesh1 == NULL) || (pMesh2 == NULL) || (ppMeshOut == NULL))
    {
        DPF(0, "Internal error - D3DXMergeMesh: Invalid pMesh1, pMesh2 or ppMeshOut pointers");
        return D3DXERR_INVALIDDATA;
    }

    // number of vertices
    cVertices1 = pMesh1->GetNumVertices();
    cVertices2 = pMesh2->GetNumVertices();
    cVerticesOut = cVertices1 + cVertices2;

    // number of faces
    cFaces1 = pMesh1->GetNumFaces();
    cFaces2 = pMesh2->GetNumFaces();
    cFacesOut = cFaces1 + cFaces2;

    dwOptions = pMesh1->GetOptions();

    if ((cFacesOut >= UNUSED16) 
        || (cVerticesOut >= UNUSED16)
        || (pMesh2->GetOptions() & D3DXMESH_32BIT))
    {
        dwOptions |= D3DXMESH_32BIT;
    }
    b16BitIndex = !(dwOptions & D3DXMESH_32BIT);

    if (pMesh1->GetFVF() != pMesh2->GetFVF())
    {
        dwFVF = DwCombineFVFs(pMesh1->GetFVF(), pMesh2->GetFVF());
    }
    else
    {
        dwFVF = pMesh1->GetFVF();
    }

    if ((pMesh1->GetOptions() != dwOptions) 
        || (pMesh1->GetFVF() != dwFVF))
    {
        hr = pMesh1->CloneMeshFVF(dwOptions, dwFVF, pD3DDevice, &pTempMesh1);
        if (FAILED(hr))
            return hr;

        // NOTE: don't release pMesh1, owned by caller, just release pTempMesh1 on exit
        pMesh1 = pTempMesh1;
    }

    if ((pMesh2->GetOptions() != dwOptions) 
        || (pMesh2->GetFVF() != dwFVF))
    {
        hr = pMesh2->CloneMeshFVF(dwOptions, dwFVF, pD3DDevice, &pTempMesh2);
        if (FAILED(hr))
            return hr;
        
        // NOTE: don't release pMesh2, owned by caller, just release pTempMesh2 on exit
        pMesh2 = pTempMesh2;
    }


    // had better have the same options
    GXASSERT((pMesh1->GetOptions() == pMesh2->GetOptions()) && (pMesh1->GetFVF() == pMesh2->GetFVF()));
    GXASSERT((pMesh1->GetOptions() == dwOptions) && (pMesh1->GetFVF() == dwFVF));
    GXASSERT(!b16BitIndex || ((cFacesOut < UNUSED16) && (cVerticesOut < UNUSED16)));
    GXASSERT((rgdwAdjacency1 != NULL) && (rgdwAdjacency2 != NULL) && (ppbufAdjacencyOut != NULL));


    hr = pMesh1->LockAttributeBuffer(D3DLOCK_READONLY, &rgdwAttribs1);
    if (FAILED(hr))
        goto e_Exit;

    hr = pMesh2->LockAttributeBuffer(D3DLOCK_READONLY, &rgdwAttribs2);
    if (FAILED(hr))
        goto e_Exit;

    hr = pMesh1->LockIndexBuffer(D3DLOCK_READONLY, &pFaces1);
    if (FAILED(hr))
        goto e_Exit;

    hr = pMesh2->LockIndexBuffer(D3DLOCK_READONLY, &pFaces2);
    if (FAILED(hr))
        goto e_Exit;

    if (b16BitIndex)
        cBytesPerIndex = sizeof(UINT16);
    else
        cBytesPerIndex = sizeof(UINT32);

    // generate a material buffer that is two material sets concated together
    hr = MergeMaterialBuffers(pbufMaterials1, cmat1, pbufMaterials2, cmat2, &pbufMaterialsOut);
    if (FAILED(hr))
        goto e_Exit;

    //create the mesh to fill
    hr = D3DXCreateMeshFVF(cFacesOut, cVerticesOut,
                                dwOptions, dwFVF,
                                pD3DDevice, &ptmMeshOut);
    if (FAILED(hr))
        goto e_Exit;

    hr = ptmMeshOut->LockIndexBuffer(0, &pFacesOut);
    if (FAILED(hr))
        goto e_Exit;

    hr = ptmMeshOut->LockAttributeBuffer(0, &rgdwAttribsOut);
    if (FAILED(hr))
        goto e_Exit;

    hr = D3DXCreateBuffer(cFacesOut * sizeof(DWORD) * 3, &pbufAdjacencyOut);
    if (FAILED(hr))
        goto e_Exit;
    rgdwAdjacencyOut = (PDWORD)pbufAdjacencyOut->GetBufferPointer();

    // now copy and remap the face data

    memcpy(pFacesOut, pFaces1, cBytesPerIndex * cFaces1 * 3);
    memcpy(rgdwAttribsOut, rgdwAttribs1, sizeof(DWORD) * cFaces1);
    for (iIndex = 0; iIndex < cFaces1*3; iIndex++)
    {
        if (rgdwAdjacency1 != NULL)
        {
            rgdwAdjacencyOut[iIndex] = rgdwAdjacency1[iIndex];
        }
        else
        {
            rgdwAdjacencyOut[iIndex] = UNUSED32;
        }
    }

    memcpy(pFacesOut + cBytesPerIndex * cFaces1 * 3, pFaces2, cBytesPerIndex * cFaces2 * 3);
    memcpy(rgdwAttribsOut + cFaces1, rgdwAttribs2, sizeof(DWORD) * cFaces2);
    for (iIndex = cFaces1 * 3, iIndex2 = 0; iIndex < cFacesOut*3; iIndex++, iIndex2++)
    {
        if (rgdwAdjacency2 != NULL)
        {
            if (rgdwAdjacency2[iIndex2] == UNUSED32)
                rgdwAdjacencyOut[iIndex] = UNUSED32;
            else
                rgdwAdjacencyOut[iIndex] = rgdwAdjacency2[iIndex2] + cFaces1;
        }
        else
        {
            rgdwAdjacencyOut[iIndex] = UNUSED32;
        }
    }


    if (b16BitIndex)
    {
        UINT16 *pFacesTemp;
        pFacesTemp = (UINT16*)pFacesOut;

        for (iIndex = cFaces1 * 3; iIndex < cFacesOut * 3; iIndex++)
        {
            if (pFacesTemp[iIndex] != UNUSED16)
                pFacesTemp[iIndex] += (UINT16)cVertices1;
        }
    }
    else
    {
        UINT32 *pFacesTemp;
        pFacesTemp = (UINT32*)pFacesOut;

        for (iIndex = cFaces1 * 3; iIndex < cFacesOut * 3; iIndex++)
        {
            if (pFacesTemp[iIndex] != UNUSED32)
                pFacesTemp[iIndex] += cVertices1;
        }
    }

    for (iIndex = cFaces1; iIndex < cFacesOut; iIndex++)
    {
        rgdwAttribsOut[iIndex] += cmat1;
    }

    // now copy the vertex data from the two buffers into the one

    hr = ptmMeshOut->LockVertexBuffer(0, &pvPointsOut);
    if (FAILED(hr))
        goto e_Exit;

    hr = pMesh1->LockVertexBuffer(D3DLOCK_READONLY, &pvPoints1);
    if (FAILED(hr))
        goto e_Exit;

    hr = pMesh2->LockVertexBuffer(D3DLOCK_READONLY, &pvPoints2);
    if (FAILED(hr))
        goto e_Exit;


    cfvf = DXCrackFVF(dwFVF);

    // finish by copying the two sets of vertex data into the destination buffer
    memcpy(pvPointsOut, pvPoints1, cfvf.m_cBytesPerVertex * cVertices1);
    memcpy((PBYTE)pvPointsOut + cfvf.m_cBytesPerVertex * cVertices1, pvPoints2,
                            cfvf.m_cBytesPerVertex * cVertices2);

    // all finished, setup return values
    *ppMeshOut = ptmMeshOut;
    ptmMeshOut->AddRef();
    if (ppbufAdjacencyOut != NULL)
    {
        *ppbufAdjacencyOut = pbufAdjacencyOut;
        pbufAdjacencyOut = NULL;
    }
    if (ppbufMaterialsOut != NULL)
    {
        *ppbufMaterialsOut = pbufMaterialsOut;
        pbufMaterialsOut = NULL;
    }
    if (pcmatOut != NULL)
        *pcmatOut = cmat1 + cmat2;

    GXASSERT(CheckAdjacency(rgdwAdjacencyOut, cFacesOut));

e_Exit:
    if (pFacesOut != NULL)
    {
        ptmMeshOut->UnlockIndexBuffer();
    }
    if (rgdwAttribsOut != NULL)
    {
        ptmMeshOut->UnlockAttributeBuffer();
    }
    if (rgdwAttribs1 != NULL)
    {
        pMesh1->UnlockAttributeBuffer();
    }
    if (rgdwAttribs2 != NULL)
    {
        pMesh2->UnlockAttributeBuffer();
    }

    if (pFaces1 != NULL)
    {
        pMesh1->UnlockIndexBuffer();
    }
    if (pFaces2 != NULL)
    {
        pMesh2->UnlockIndexBuffer();
    }

    if (pvPointsOut != NULL)
    {
        ptmMeshOut->UnlockVertexBuffer();
    }
    if (pvPoints1 != NULL)
    {
        pMesh1->UnlockVertexBuffer();
    }
    if (pvPoints2 != NULL)
    {
        pMesh2->UnlockVertexBuffer();
    }

    GXRELEASE(ptmMeshOut);
    GXRELEASE(pbufAdjacencyOut);
    GXRELEASE(pbufMaterialsOut);

    GXRELEASE(pTempMesh1);
    GXRELEASE(pTempMesh2);

    return hr;
}

HRESULT LoadMeshes
    (
    LPDIRECTXFILEDATA pxofobjCur,
    D3DXMATRIX &matCur,
    DWORD options,
    LPDIRECT3DDEVICE8 pD3DDevice,
    LPD3DXMESH *ppMesh,
    LPD3DXBUFFER *ppbufAdjacency,
    LPD3DXBUFFER *ppbufMaterials,
    LPDWORD pcmatOut
    )
{
    HRESULT hr = S_OK;
    LPDIRECTXFILEDATA pxofobjChild = NULL;
    LPDIRECTXFILEOBJECT pxofChild = NULL;
    const GUID *type;
    D3DXMATRIX matLocal;
    DWORD cbSize;
    D3DXMATRIX *pmatNew;
    LPDIRECT3DVERTEXBUFFER8 pVertexBuffer = NULL;
    PVOID pvPoints = NULL;
    LPD3DXMESH ptmMeshNew = NULL;
    LPD3DXBUFFER pbufAdjacencyNew = NULL;
    LPD3DXBUFFER pbufMaterialsNew = NULL;
    DWORD cmatNew;

    // Get the type of the object
    hr = pxofobjCur->GetType(&type);
    if (FAILED(hr))
        goto e_Exit;

    if (*type == TID_D3DRMMesh)
    {
        DXCrackFVF cfvf(D3DFVF_XYZ);
        D3DXVECTOR3 *pvVertexCur;
        UINT iVert;
        UINT cVertices;
        PVOID pvPoint;
        LPD3DXMESH ptmMeshTemp;
        LPD3DXBUFFER pbufAdjacencyTemp;
        LPD3DXBUFFER pbufMaterialsTemp = NULL;
        DWORD cmatTemp;

        hr = D3DXLoadMeshFromXofEx(pxofobjCur, options, pD3DDevice, &pbufAdjacencyNew, &pbufMaterialsNew, &cmatNew, &ptmMeshNew, NULL, NULL, NULL, NULL, NULL, NULL);
        if (FAILED(hr))
            goto e_Exit;

        // next apply the current frame transformation to the mesh

        cfvf = DXCrackFVF(ptmMeshNew->GetFVF());

        hr = ptmMeshNew->GetVertexBuffer(&pVertexBuffer);
        if (FAILED(hr))
            goto e_Exit;

        hr = pVertexBuffer->Lock(0,0, (PBYTE*)&pvPoints, 0 );
        if (FAILED(hr))
            goto e_Exit;

        cVertices = ptmMeshNew->GetNumVertices();

#if 1
        for (iVert = 0; iVert < cVertices; iVert++)
        {
            pvPoint = cfvf.GetArrayElem(pvPoints, iVert);

            pvVertexCur = cfvf.PvGetPosition(pvPoint);

            D3DXVec3TransformCoord(pvVertexCur, pvVertexCur, &matCur);

            if (cfvf.BNormal())
            {
                pvVertexCur = cfvf.PvGetNormal(pvPoint);

                D3DXVec3TransformNormal(pvVertexCur, pvVertexCur, &matCur);
                D3DXVec3Normalize(pvVertexCur, pvVertexCur);
            }
        }
#endif
        pVertexBuffer->Unlock();
        pvPoints = NULL;
        GXRELEASE(pVertexBuffer);

        if (*ppMesh == NULL)
        {
            *ppMesh = ptmMeshNew;
            *ppbufAdjacency = pbufAdjacencyNew;
            *ppbufMaterials = pbufMaterialsNew;
            *pcmatOut = cmatNew;
            ptmMeshNew = NULL;
            pbufAdjacencyNew = NULL;
            pbufMaterialsNew = NULL;
        }
        else
        {
            hr = D3DXMergeMeshes(*ppMesh, (PDWORD)((*ppbufAdjacency)->GetBufferPointer()),
                                                *ppbufMaterials, *pcmatOut,
                                        ptmMeshNew, (PDWORD)(pbufAdjacencyNew->GetBufferPointer()),
                                                pbufMaterialsNew, cmatNew,
                                        pD3DDevice, &ptmMeshTemp, &pbufAdjacencyTemp,
                                                &pbufMaterialsTemp, &cmatTemp);
            if (FAILED(hr))
                goto e_Exit;

            GXRELEASE(*ppMesh);
            GXRELEASE(*ppbufAdjacency);
            GXRELEASE(*ppbufMaterials);

            *ppMesh = ptmMeshTemp;
            *ppbufAdjacency = pbufAdjacencyTemp;
            *ppbufMaterials = pbufMaterialsTemp;
            *pcmatOut = cmatTemp;
        }
    }
    else if (*type == TID_D3DRMFrameTransformMatrix)
    {
        hr = pxofobjCur->GetData(NULL, &cbSize, (PVOID*)&pmatNew);
        if (FAILED(hr))
            goto e_Exit;

        // update the parents matrix with the new one
        //matCur *= *pmatNew;
        D3DXMatrixMultiply(&matCur, pmatNew, &matCur);
    }
    else if (*type == TID_D3DRMFrame)
    {
        matLocal = matCur;

        // Enumerate child objects.
        // Child object can be data, data reference or binary.
        // Use QueryInterface() to find what type of object a child is.
        while (SUCCEEDED(pxofobjCur->GetNextObject(&pxofChild)))
        {
            // Query the child for it's FileData
            hr = pxofChild->QueryInterface(IID_IDirectXFileData,
                                           (LPVOID *)&pxofobjChild);
            if (SUCCEEDED(hr))
            {
                hr = LoadMeshes(pxofobjChild, matLocal, options, pD3DDevice, ppMesh, ppbufAdjacency, ppbufMaterials, pcmatOut);
                if (FAILED(hr))
                    goto e_Exit;

                GXRELEASE(pxofobjChild);
            }

            GXRELEASE(pxofChild);
        }

    }

e_Exit:
    GXRELEASE(ptmMeshNew);
    GXRELEASE(pbufAdjacencyNew);
    GXRELEASE(pbufMaterialsNew);
    GXRELEASE(pxofobjChild);
    GXRELEASE(pxofChild);
    if (pvPoints != NULL)
        pVertexBuffer->Unlock();
    GXRELEASE(pVertexBuffer);
    return hr;
}

HRESULT WINAPI D3DXLoadMeshFromX
    (
    char *szFilename,
    DWORD options,
    LPDIRECT3DDEVICE8 pD3DDevice,
    LPD3DXBUFFER *ppbufAdjacency,
    LPD3DXBUFFER *ppbufMaterials,
    LPDWORD pcmatOut,
    LPD3DXMESH *ppMesh
    )
{
    HRESULT hr = S_OK;
    LPDIRECTXFILE pxofapi = NULL;
    LPDIRECTXFILEENUMOBJECT pxofenum = NULL;
    LPDIRECTXFILEDATA pxofobjCur = NULL;
    D3DXMATRIX matIdentity;
    LPD3DXBUFFER pbufAdjacencyDummy = NULL;
    LPD3DXBUFFER ppbufMaterialsDummy = NULL;
    DWORD cmatDummy;
    HINSTANCE hXof;
    LPDIRECTXFILECREATE pfnDirectXFileCreate;

    if ((ppMesh == NULL) || (szFilename == NULL))
    {
        hr = D3DERR_INVALIDCALL;
        goto e_Exit;
    }

    if (ppbufAdjacency == NULL)
        ppbufAdjacency = &pbufAdjacencyDummy;

    if (ppbufMaterials == NULL)
        ppbufMaterials = &ppbufMaterialsDummy;

    if (pcmatOut == NULL)
        pcmatOut = &cmatDummy;

#if 0
    // Create Xfile parser
    if(!(hXof = (HINSTANCE) GetModuleHandle("d3dxof.dll")) &&
       !(hXof = (HINSTANCE) LoadLibrary("d3dxof.dll")))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto e_Exit;
    }
#endif
    if(!(pfnDirectXFileCreate = (LPDIRECTXFILECREATE)DirectXFileCreate))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto e_Exit;
    }

    hr = pfnDirectXFileCreate(&pxofapi);
    if (FAILED(hr))
        goto e_Exit;

    // Registe templates for d3drm.
    hr = pxofapi->RegisterTemplates((LPVOID)D3DRM_XTEMPLATES,
                                    D3DRM_XTEMPLATE_BYTES);
    if (FAILED(hr))
        goto e_Exit;

    // Create enum object.
    hr = pxofapi->CreateEnumObject((LPVOID)szFilename,
                                   DXFILELOAD_FROMFILE,
                                   &pxofenum);
    if (FAILED(hr))
        goto e_Exit;

    // Enumerate top level objects.
    // Top level objects are always data object.
    *ppMesh = NULL;
    while (SUCCEEDED(pxofenum->GetNextDataObject(&pxofobjCur)))
    {
        D3DXMatrixIdentity(&matIdentity);

        hr = LoadMeshes(pxofobjCur, matIdentity, options, pD3DDevice,
                                ppMesh, ppbufAdjacency, ppbufMaterials, pcmatOut);
        if (FAILED(hr))
            goto e_Exit;

        GXRELEASE(pxofobjCur);
    }

    if (*ppMesh == NULL)
    {
        hr = E_FAIL;
        goto e_Exit;
    }

    // pointers are valid at this point, might be pointing to dummy variables
    if (*pcmatOut == 0)
    {
        GXASSERT(*ppbufMaterials == NULL);

        D3DXMATERIAL matGray;

        matGray.pTextureFilename = NULL;
        memset(&matGray.MatD3D, 0, sizeof(D3DMATERIAL8));
        matGray.MatD3D.Diffuse.r = 0.5f;
        matGray.MatD3D.Diffuse.g = 0.5f;
        matGray.MatD3D.Diffuse.b = 0.5f;
        matGray.MatD3D.Specular = matGray.MatD3D.Diffuse;

        hr = CreateMaterialBuffer(&matGray, 1, ppbufMaterials);
        if (FAILED(hr))
            goto e_Exit;

        *pcmatOut = 1;
    }


e_Exit:
    GXRELEASE(pbufAdjacencyDummy);
    GXRELEASE(ppbufMaterialsDummy);
    GXRELEASE(pxofobjCur);
    GXRELEASE(pxofenum);
    GXRELEASE(pxofapi);

    return hr;
}

HRESULT WINAPI D3DXLoadMeshFromXofEx
    (
    LPDIRECTXFILEDATA pxofobjMesh,
    DWORD options,
    LPDIRECT3DDEVICE8 pD3DDevice,
    LPD3DXBUFFER *ppbufAdjacency,
    LPD3DXBUFFER *ppbufMaterials,
    PDWORD pcMaterials,
    LPD3DXMESH *ppMesh,
    PBYTE *ppbPMData,
    DWORD *pcbPMData,
    LPD3DXBUFFER *ppBoneNames,
    LPD3DXBUFFER *ppBoneTransforms,
    LPBONE *ppBones,
    DWORD *pNumBones
    )
{
    HRESULT hr = S_OK;
    UINT cVertices;
    UINT cCorners;
    UINT cTriangles;
    UINT cPolygons;
    BOOL bNormalFound = FALSE;
    BOOL bTex1Found = FALSE;
    BOOL bVertexColorsFound = FALSE;
    UINT iVert;
    UINT iFace;
    UINT iTriangle;
    UINT iIndex;
    PBYTE pbCur;
    PBYTE pbMeshCur;
    PBYTE pbNormalCur;
    DWORD rgwIndicesCur[3];
    DWORD *rgwIndicesFile;
    DWORD cIndices;
    DWORD i;

    SLoadedFace        *rglfFaces = NULL;
    SLoadVertex *rglvLoaded = NULL;
    SCorner *rgCorners = NULL;
    LPDIRECTXFILEDATA pxofobjCur = NULL;
    LPDIRECTXFILEOBJECT pxofChild = NULL;
    LPDIRECTXFILEDATA pxofobjMaterial = NULL;
    LPDIRECTXFILEDATAREFERENCE pxofrefMaterial = NULL;
    LPDIRECTXFILEOBJECT pxofMaterial = NULL;
    LPDIRECTXFILEDATA pxofobjTexName = NULL;
    LPDIRECTXFILEOBJECT pxofTexName = NULL;
    PBYTE pbMeshData;
    PBYTE pbData;
    const GUID *type;
    DWORD cbSize;
    D3DXVECTOR3 *pvCurVertex;
    UINT iPoint;
    D3DXVECTOR3 *rgvNormals;
    UINT cNormals;
    UINT iCorner;
    UINT iNormal;
    DWORD *rgiMatID;
    UINT iMaterial;
    float *pfMaterialData;
    UINT cPolygonsDefined;
    D3DXMATERIAL *rgmatMaterials = NULL;
    UINT cMaterials = 0;
    char **pszTexName;
    UINT cbTexName;
    UINT cVertexIndices;
    DWORD dwFVF;
    DWORD cDWords;
    SFVFData *pFVFData = NULL;
    DWORD iColor;
    DWORD cVertexColors;
    D3DXCOLOR color;
    DWORD numBonesRead = 0;
    CD3DXStringBuffer* pBoneNames = NULL;
    LPBONE pBones = NULL;
    LPD3DXMATRIX pBoneTransforms = NULL;
    struct XSkinMeshHeader {
        WORD nMaxSkinWeightsPerVertex;
        WORD nMaxSkinWeightsPerFace;
        WORD numBones;
    } *header = NULL;
    BOOL bPointRepData = FALSE;

    // Initialize outputs
    if (ppbufAdjacency)
        *ppbufAdjacency = NULL;
    if (ppbufMaterials)
        *ppbufMaterials = NULL;
    if (ppMesh)
        *ppMesh = NULL;
    else
    {
        DPF(0, "ppMesh cannot be NULL");
        return D3DERR_INVALIDCALL;
    }
    if (ppbPMData)
        *ppbPMData = NULL;
    if (pcbPMData)
        *pcbPMData = NULL;
    if (ppBoneNames)
        *ppBoneNames = NULL;
    if (ppBoneTransforms)
        *ppBoneTransforms = NULL;
    if (ppBones)
        *ppBones = NULL;
    if (pNumBones)
        *pNumBones = 0;

    hr = pxofobjMesh->GetData(NULL, &cbSize, (PVOID*)&pbMeshData);
    if (FAILED(hr))
        goto e_Exit;

    cVertices = *(DWORD*)pbMeshData;
    cPolygons = *(DWORD*)(pbMeshData + sizeof(DWORD) + cVertices * 3 * sizeof(float));
    cCorners = 0;

    // make sure the size is correct
    if (cbSize < (sizeof(DWORD) * 2 + cVertices * 3 * sizeof(float) + sizeof(DWORD) * cPolygons))
    {
        hr = E_FAIL;
        goto e_Exit;
    }

    hr = InitVertices(rglvLoaded, cVertices);
    if (FAILED(hr))
        goto e_Exit;


    // load the positions of the verties,
    //     then load a decent default color
    pvCurVertex = (D3DXVECTOR3*)(pbMeshData + sizeof(DWORD));
    for (iVert = 0; iVert < cVertices; iVert++, pvCurVertex++)
    {
        rglvLoaded[iVert].m_vPos = *pvCurVertex;

        //rglvLoaded[iVert].m_color = D3DXCOLOR(0.9f, 0.6f, 0.4f, 0.0f);
        rglvLoaded[iVert].m_color = D3DXCOLOR(1.0f, 1.0f, 1.0f, 0.0f);
    }

    // calculate the number of triangle by doing a pass over the triangle buffer
    pbCur = (PBYTE)(pbMeshData + sizeof(DWORD) * 2 + cVertices * 3 * sizeof(float));
    cTriangles = 0;
    for (iFace = 0; iFace < cPolygons; iFace++)
    {
        cIndices = *(DWORD*)pbCur;
        if (cIndices < 3)
        {
            hr = E_FAIL;
            goto e_Exit;
        }

        // find out the number of triangles (if 3, then 1 if 4, then 2, etc, etc.)
        cTriangles += (cIndices - 2);

        // skip over the indices and the count of indices
        pbCur += sizeof(DWORD) * (cIndices + 1);
    }

    hr = InitFaces(rglfFaces, cTriangles);
    if (FAILED(hr))
        goto e_Exit;

    // now do a second pass to load the indices into the prepared array,
    //   and convert any polygons to triangles
    pbCur = (PBYTE)(pbMeshData + sizeof(DWORD) * 2 + cVertices * 3 * sizeof(float));
    for (iFace = 0, iTriangle = 0; iFace < cPolygons; iFace++)
    {
        cIndices = *(DWORD*)pbCur;
        rgwIndicesFile = (DWORD*)(pbCur + sizeof(DWORD));

        // already checked when calculating the number of vertices
        GXASSERT(cIndices >= 3);

        rgwIndicesCur[0] = rgwIndicesFile[0];
        for (iIndex = 0; iIndex < cIndices - 2; iIndex++)
        {
            rgwIndicesCur[1] = rgwIndicesFile[iIndex+1];
            rgwIndicesCur[2] = rgwIndicesFile[iIndex+2];

            // copy the indices, both are 32 bit
            for (iPoint = 0; iPoint < 3; iPoint++)
            {
                rglfFaces[iTriangle].m_wIndices[iPoint] = rgwIndicesCur[iPoint];
            }
            iTriangle++;
        }

        // skip over the indices and the count of indices
        pbCur += sizeof(DWORD) * (cIndices + 1);
    }

    // Enumerate child objects.
    // Child object can be data, data reference or binary.
    // Use QueryInterface() to find what type of object a child is.
    while (SUCCEEDED(pxofobjMesh->GetNextObject(&pxofChild)))
    {
        // Query the child for it's FileData
        hr = pxofChild->QueryInterface(IID_IDirectXFileData,
                                       (LPVOID *)&pxofobjCur);
        if (SUCCEEDED(hr))
        {
            // Get the type of the object
            hr = pxofobjCur->GetType(&type);
            if (FAILED(hr))
                goto e_Exit;

            hr = pxofobjCur->GetData(NULL, &cbSize, (PVOID*)&pbData);
            if (FAILED(hr))
                goto e_Exit;


            if (*type == TID_D3DRMMeshTextureCoords)
            {
                bTex1Found = TRUE;

                // had better be enough texture coordinates
                if (*(DWORD*)pbData != cVertices)
                {
                    hr = E_FAIL;
                    goto e_Exit;
                }
                pbData += sizeof(DWORD);

                for (iVert = 0; iVert < cVertices; iVert++)
                {
                    rglvLoaded[iVert].m_uvTex1 = *(D3DXVECTOR2*)pbData;
                    pbData += sizeof(D3DXVECTOR2);
                }
            }
            else if (*type == TID_D3DRMMeshVertexColors)
            {
                bVertexColorsFound = TRUE;
                cVertexColors = *(DWORD*)pbData;

                pbData += sizeof(DWORD);

                for (iColor = 0; iColor < cVertexColors; iColor++)
                {
                    iIndex = *(DWORD*)pbData;
                    pbData += sizeof(DWORD);

                    color.r = *(float*)pbData;
                    pbData += sizeof(DWORD);
                    color.g = *(float*)pbData;
                    pbData += sizeof(DWORD);
                    color.b = *(float*)pbData;
                    pbData += sizeof(DWORD);
                    color.a = *(float*)pbData;
                    pbData += sizeof(DWORD);

                    rglvLoaded[iColor].m_color = (DWORD)color;
                }
            }
            // if this is a pm, load the normals slightly differently
            else if ((*type == TID_D3DRMMeshNormals) && (ppbPMData != NULL))
            {
                cNormals = *(DWORD*)pbData;
                bNormalFound = TRUE;

                // nFaceNormals has to match cPolygons
                if (cPolygons != *(DWORD*)(pbData + sizeof(DWORD) + cNormals * 3 * sizeof(float)))
                {
                    hr = E_FAIL;
                    goto e_Exit;
                }

                // normals MUST be provided for each vertex if this is a PM
                if (cNormals != cVertices)
                {
                    hr = E_FAIL;
                    goto e_Exit;
                }

                rgvNormals = (D3DXVECTOR3*)(pbData + sizeof(DWORD));

                for (iVert = 0; iVert < cVertices; iVert++)
                {
                    rglvLoaded[iVert].m_vNormal = rgvNormals[iVert];
                }
            }
            else if (*type == TID_D3DRMMeshNormals)
            {
                cCorners = cTriangles * 3;
                hr = InitCorners(rgCorners, cCorners);
                if (FAILED(hr))
                    goto e_Exit;


                // load the number of normals
                cNormals = *(DWORD*)pbData;
                bNormalFound = TRUE;

                // nFaceNormals has to match cPolygons
                if (cPolygons != *(DWORD*)(pbData + sizeof(DWORD) + cNormals * 3 * sizeof(float)))
                {
                    hr = E_FAIL;
                    goto e_Exit;
                }

                rgvNormals = (D3DXVECTOR3*)(pbData + sizeof(DWORD));

                pbMeshCur = (PBYTE)(pbMeshData + sizeof(DWORD) * 2 + cVertices * 3 * sizeof(float));
                pbNormalCur = (PBYTE)(pbData + 2 * sizeof(DWORD) + cNormals * 3 * sizeof(float));
                for (iFace = 0, iTriangle = 0, iCorner = 0; iFace < cPolygons; iFace++, pbCur++)
                {
                    cIndices = *(DWORD*)pbNormalCur;
                    rgwIndicesFile = (DWORD*)(pbNormalCur + sizeof(DWORD));
                    if ((cIndices < 3) || (cIndices != *(DWORD*)pbMeshCur))
                    {
                        hr = E_FAIL;
                        goto e_Exit;
                    }

                    rgwIndicesCur[0] = rgwIndicesFile[0];
                    for (iIndex = 0; iIndex < cIndices - 2; iIndex++)
                    {
                        rgwIndicesCur[1] = rgwIndicesFile[iIndex+1];
                        rgwIndicesCur[2] = rgwIndicesFile[iIndex+2];

                        // copy the indices, both are 32 bit
                        for (iPoint = 0; iPoint < 3; iPoint++)
                        {
                            iNormal = rgwIndicesCur[iPoint];

                            // load the data into the corner, including the normal
                            //   at the given offset provided by the index in the MeshFace
                            rgCorners[iCorner].m_wFace = iTriangle;
                            rgCorners[iCorner].m_wPoint = rglfFaces[iTriangle].m_wIndices[iPoint];
                            rgCorners[iCorner].m_bNormalSpecified = true;
                            rgCorners[iCorner].m_vNormal = rgvNormals[iNormal];
                            iCorner++;
                        }
                        iTriangle++;
                    }

                    // skip over the indices and the count of indices
                    pbMeshCur += sizeof(DWORD) * (cIndices + 1);
                    pbNormalCur += sizeof(DWORD) * (cIndices + 1);
                }

                GXASSERT(iTriangle == cTriangles);
                GXASSERT(iCorner == cCorners);
            }
            else if (*type == DXFILEOBJ_VertexDuplicationIndices)
            {
                cVertexIndices = *(DWORD*)(pbData);
                pbData += sizeof(DWORD);

                bPointRepData = TRUE;

                if ((cVertexIndices != cVertices) || (*(DWORD*)(pbData) > cVertexIndices))
                {
                    hr = D3DERR_INVALIDCALL;
                    goto e_Exit;
                }
                pbData += sizeof(DWORD);

                for (iVert = 0; iVert < cVertices; iVert++)
                {
                    rglvLoaded[iVert].m_wPointRep = *(DWORD*)pbData;
                    pbData += sizeof(DWORD);

                    if (rglvLoaded[iVert].m_wPointRep != iVert)
                    {
                        rglvLoaded[iVert].m_wPointList = rglvLoaded[rglvLoaded[iVert].m_wPointRep].m_wPointList;
                        rglvLoaded[rglvLoaded[iVert].m_wPointRep].m_wPointList = iVert;
                    }
                }
            }
            else if (*type == TID_D3DRMMeshMaterialList)
            {
                cMaterials = *(DWORD*)(pbData);
                if (cMaterials > 0)
                {
                    cPolygonsDefined = *(DWORD*)(pbData + sizeof(DWORD));

                    rgmatMaterials = new D3DXMATERIAL[cMaterials];
                    if (rgmatMaterials == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                        goto e_Exit;
                    }

                    // get a pointer to the material index array
                    rgiMatID = (DWORD*)(pbData + 2 * sizeof(DWORD));

                    // need to do yet another pass over the mesh data to convert from
                    //  polygon to triangles
                    pbCur = (PBYTE)(pbMeshData + sizeof(DWORD) * 2 + cVertices * 3 * sizeof(float));
                    for (iFace = 0, iTriangle = 0; iFace < cPolygonsDefined; iFace++)
                    {
                        cIndices = *(DWORD*)pbCur;

                        // already checked when calculating the number of vertices
                        GXASSERT(cIndices >= 3);

                        for (iIndex = 0; iIndex < cIndices - 2; iIndex++)
                        {
                            rglfFaces[iTriangle].m_matid = rgiMatID[iFace];
                            iTriangle++;
                        }

                        // skip over the indices and the count of indices
                        pbCur += sizeof(DWORD) * (cIndices + 1);
                    }

                    // all triangles without a material id have a material id of zero
                    for ( ; iTriangle < cTriangles; iTriangle++)
                    {
                        rglfFaces[iTriangle].m_matid = 0;
                    }


                    iMaterial = 0;

                    // now load the materials
                    while (SUCCEEDED(pxofobjCur->GetNextObject(&pxofMaterial)))
                    {
                        // Query the child for it's FileData
                        hr = pxofMaterial->QueryInterface(IID_IDirectXFileData,
                                                       (LPVOID *)&pxofobjMaterial);

                        if (FAILED(hr))
                        {
                            hr = pxofMaterial->QueryInterface(IID_IDirectXFileDataReference,
                                                       (LPVOID *)&pxofrefMaterial);

                            // we had better be able to load each of the materials
                            if (FAILED(hr))
                                goto e_Exit;

                            hr = pxofrefMaterial->Resolve(&pxofobjMaterial);
                            if (FAILED(hr))
                                goto e_Exit;

                            GXRELEASE(pxofrefMaterial);
                        }

                        hr = pxofobjMaterial->GetData(NULL, &cbSize, (PVOID*)&pfMaterialData);
                        if (FAILED(hr))
                            goto e_Exit;

                        // load the material data from the child
                        rgmatMaterials[iMaterial].MatD3D.Diffuse.r = *pfMaterialData;
                        pfMaterialData++;
                        rgmatMaterials[iMaterial].MatD3D.Diffuse.g = *pfMaterialData;
                        pfMaterialData++;
                        rgmatMaterials[iMaterial].MatD3D.Diffuse.b = *pfMaterialData;
                        pfMaterialData++;
                        rgmatMaterials[iMaterial].MatD3D.Diffuse.a = *pfMaterialData;
                        pfMaterialData++;

                        rgmatMaterials[iMaterial].MatD3D.Power = *pfMaterialData;
                        pfMaterialData++;

                        rgmatMaterials[iMaterial].MatD3D.Specular.r = *pfMaterialData;
                        pfMaterialData++;
                        rgmatMaterials[iMaterial].MatD3D.Specular.g = *pfMaterialData;
                        pfMaterialData++;
                        rgmatMaterials[iMaterial].MatD3D.Specular.b = *pfMaterialData;
                        pfMaterialData++;
                        rgmatMaterials[iMaterial].MatD3D.Specular.a = 1.0f;

                        rgmatMaterials[iMaterial].MatD3D.Emissive.r = *pfMaterialData;
                        pfMaterialData++;
                        rgmatMaterials[iMaterial].MatD3D.Emissive.g = *pfMaterialData;
                        pfMaterialData++;
                        rgmatMaterials[iMaterial].MatD3D.Emissive.b = *pfMaterialData;
                        pfMaterialData++;
                        rgmatMaterials[iMaterial].MatD3D.Emissive.a = 1.0f;

                        rgmatMaterials[iMaterial].MatD3D.Ambient.r = 0.0f;
                        rgmatMaterials[iMaterial].MatD3D.Ambient.g = 0.0f;
                        rgmatMaterials[iMaterial].MatD3D.Ambient.b = 0.0f;

                        rgmatMaterials[iMaterial].pTextureFilename = NULL;

                        while (SUCCEEDED(pxofobjMaterial->GetNextObject(&pxofTexName)))
                        {
                            hr = pxofTexName->QueryInterface(IID_IDirectXFileData,
                                                           (LPVOID *)&pxofobjTexName);

                            if (FAILED(hr))
                            {
                                hr = pxofTexName->QueryInterface(IID_IDirectXFileDataReference,
                                                           (LPVOID *)&pxofrefMaterial);

                                // we had better be able to load each of the materials
                                if (FAILED(hr))
                                    goto e_Exit;

                                hr = pxofrefMaterial->Resolve(&pxofobjTexName);
                                if (FAILED(hr))
                                    goto e_Exit;

                                GXRELEASE(pxofrefMaterial);
                            }

                            hr = pxofobjTexName->GetType(&type);
                            if (FAILED(hr))
                                goto e_Exit;

                            if (*type == TID_D3DRMTextureFilename)
                            {
                                hr = pxofobjTexName->GetData(NULL, &cbSize, (PVOID*)&pszTexName);
                                if (FAILED(hr))
                                    goto e_Exit;

                                cbTexName = strlen(*pszTexName) + 1;

                                rgmatMaterials[iMaterial].pTextureFilename = new char[cbTexName];
                                if (rgmatMaterials[iMaterial].pTextureFilename == NULL)
                                {
                                    hr = E_OUTOFMEMORY;
                                    goto e_Exit;
                                }

                                memcpy(rgmatMaterials[iMaterial].pTextureFilename, *pszTexName, cbTexName);
                            }

                            GXRELEASE(pxofTexName);
                            GXRELEASE(pxofobjTexName);
                        }


                        GXRELEASE(pxofMaterial);
                        GXRELEASE(pxofobjMaterial);

                        iMaterial += 1;
                    }

                    // if we didn't find the correct number of materials, fail
                    if (iMaterial != cMaterials)
                    {
                        hr = E_FAIL;
                        goto e_Exit;
                    }

#if 1
                    for (iTriangle = 0; iTriangle < cTriangles; iTriangle++)
                    {
                        rglfFaces[iTriangle].m_attr = rglfFaces[iTriangle].m_matid;

                        rglfFaces[iTriangle].m_bAttributeSpecified = true;
                    }
#endif

#if 0
                    // UNDONE UNDONE - should make an options
                    // GXASSERT(0);
                    //   copy the material color to the face color
                    for (iTriangle = 0; iTriangle < cTriangles; iTriangle++)
                    {
                        rglfFaces[iTriangle].m_colorFace =
                            *(D3DXCOLOR*)&(rgmatMaterials[rglfFaces[iTriangle].m_matid].MatD3D.Diffuse);

                        rglfFaces[iTriangle].m_bColorSpecified = true;
                    }
#endif
                }
            }
            else if ((*type == DXFILEOBJ_PMInfo) && (ppbPMData != NULL))
            {
                // don't do anything with the PMInfo, just load it into an allocated buffer to return
                *pcbPMData = cbSize;
                *ppbPMData = new BYTE[cbSize];
                if (*ppbPMData == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto e_Exit;
                }

                memcpy(*ppbPMData, pbData, cbSize);
            }
            else if ((*type == DXFILEOBJ_XSkinMeshHeader) && (ppBones != NULL))
            {
                header = reinterpret_cast<struct XSkinMeshHeader*>(pbData);
				*pNumBones = header->numBones;
#define _D3DX_AVG_BONENAME 32
                pBones = new CBone[header->numBones];
                if (pBones == NULL)
                    goto e_Exit;
                *ppBones = pBones;
                hr = D3DXCreateStringBuffer(_D3DX_AVG_BONENAME * header->numBones, &pBoneNames);
                if (FAILED(hr))
                    goto e_Exit;
                *ppBoneNames = pBoneNames;
                hr = D3DXCreateBuffer(sizeof(D3DXMATRIX) * header->numBones, ppBoneTransforms);
                if (FAILED(hr))
                    goto e_Exit;
                pBoneTransforms = reinterpret_cast<LPD3DXMATRIX>((*ppBoneTransforms)->GetBufferPointer());
            }
            else if ((*type == DXFILEOBJ_SkinWeights) && (pBoneTransforms != NULL))
            {

                // Copy BoneName
                pBoneNames->AddString(*(char**)pbData);
                // Copy numWeights
                pBones[numBonesRead].m_numWeights = ((DWORD*)pbData)[1];
                GXASSERT(2 * sizeof(DWORD) + (sizeof(DWORD) + sizeof(float)) * pBones[numBonesRead].m_numWeights + sizeof(D3DXMATRIX) == cbSize);
                // Copy vertex indices
                pBones[numBonesRead].m_pVertIndices = new DWORD[pBones[numBonesRead].m_numWeights];
                if (pBones[numBonesRead].m_pVertIndices == NULL)
                    goto e_Exit;
                memcpy(pBones[numBonesRead].m_pVertIndices, (LPDWORD)pbData + 2, sizeof(DWORD) * pBones[numBonesRead].m_numWeights);
                // Copy vertex weights
                pBones[numBonesRead].m_pWeights = new float[pBones[numBonesRead].m_numWeights];
                if (pBones[numBonesRead].m_pWeights == NULL)
                {
                    numBonesRead++;
                    goto e_Exit;
                }
                memcpy(pBones[numBonesRead].m_pWeights, (LPDWORD)pbData + 2 + pBones[numBonesRead].m_numWeights, sizeof(float) * pBones[numBonesRead].m_numWeights);
                // Copy bone transforms
                pBoneTransforms[numBonesRead] = *(D3DXMATRIX*)(pbData + sizeof(DWORD)*2 + (sizeof(DWORD) + sizeof(float)) * pBones[numBonesRead].m_numWeights);

                ++numBonesRead;
                GXASSERT(numBonesRead <= *pNumBones);
            }
            else if (*type == DXFILEOBJ_FVFData)
            {
                pFVFData = new SFVFData;
                if (pFVFData == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto e_Exit;
                }

                pFVFData->dwFVF = *(DWORD*)pbData;
                pbData += sizeof(DWORD);

                cDWords = *(DWORD*)pbData;
                pbData += sizeof(DWORD);

                pFVFData->cBytesPerVertex = (cDWords * sizeof(DWORD)) / cVertices;

                pFVFData->rgiFVFData = new DWORD[cDWords];
                if (pFVFData->rgiFVFData == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto e_Exit;
                }

                memcpy(pFVFData->rgiFVFData, pbData, cDWords * sizeof(DWORD));
            }

            GXRELEASE(pxofobjCur);
        }

        GXRELEASE(pxofChild);
    }

    if (!bNormalFound)
    {
        for (iFace = 0; iFace < cTriangles; iFace++)
        {
            if (rglfFaces[iFace].m_wIndices[0] != UNUSED32)
            {
                rglfFaces[iFace].m_bSmoothingGroupSpecified = true;
                rglfFaces[iFace].m_iSmoothingGroup = 1;
            }
        }
    }

    if (pFVFData != NULL)
    {
        dwFVF = pFVFData->dwFVF;
        pFVFData->iTexCoordOffset = 0;
    }
    else
    {
        dwFVF = D3DFVF_XYZ;
    }

    if (bNormalFound)
    {
        dwFVF |= D3DFVF_NORMAL;
    }

    if (bVertexColorsFound)
    {
        dwFVF |= D3DFVF_DIFFUSE;
    }

    if (bTex1Found)
    {
        // if separate block specified, then use it as the first tex coord and other fvf data as later ones
        if (pFVFData)
            pFVFData->iTexCoordOffset = 1;

        if ((dwFVF & D3DFVF_TEXCOUNT_MASK) == 0x800) // D3DFVF_TEX8
        {
            hr = D3DERR_INVALIDCALL;
            goto e_Exit;
        }

        dwFVF += D3DFVF_TEX1;
    }

    // TODO: Can we reduce the copying done by this function ? We can extend the skin mesh header to contain
    // more information and appear before the mesh object.
    hr = SetMesh(rglfFaces, cTriangles, rglvLoaded, cVertices, rgCorners, cCorners, pFVFData, bPointRepData,
                                options, dwFVF, pD3DDevice, ppMesh, ppbufAdjacency);
    if (FAILED(hr))
        goto e_Exit;

    if (ppbufMaterials != NULL)
    {
        if (cMaterials == 0)
        {
            *ppbufMaterials = NULL;
        }
        else
        {
            hr = CreateMaterialBuffer(rgmatMaterials, cMaterials, ppbufMaterials);
            if (FAILED(hr))
                goto e_Exit;
        }
    }

    if (pcMaterials != NULL)
    {
        *pcMaterials = cMaterials;
    }
	goto s_Exit;

e_Exit: 
    for (i = 0; i < numBonesRead; ++i)
    {
        GXASSERT(pBones[i].m_pVertIndices != NULL);
        delete [] pBones[i].m_pVertIndices;
        delete [] pBones[i].m_pWeights;
    }
    if (ppBones)
        delete [] *ppBones;
    if (ppBoneNames)
        GXRELEASE(*ppBoneNames);
    if (ppBoneTransforms)
        GXRELEASE(*ppBoneTransforms);
s_Exit:    
    delete []rglfFaces;
    delete []rglvLoaded;
    delete []rgCorners;
    if (pFVFData != NULL)
    {
        delete []pFVFData->rgiFVFData;
    }
    delete []pFVFData;

    if (rgmatMaterials != NULL)
    {
        for (iMaterial = 0; iMaterial < cMaterials; iMaterial++)
        {
            delete []rgmatMaterials[iMaterial].pTextureFilename;
        }
    }

    delete []rgmatMaterials;
    GXRELEASE(pxofChild);
    GXRELEASE(pxofobjCur);
    GXRELEASE(pxofMaterial);
    GXRELEASE(pxofobjMaterial);
    GXRELEASE(pxofrefMaterial);
    GXRELEASE(pxofobjTexName);
    GXRELEASE(pxofTexName);

    return hr;
}


HRESULT WINAPI D3DXLoadMeshFromXof
    (
    LPDIRECTXFILEDATA pxofobjMesh,
    DWORD options,
    LPDIRECT3DDEVICE8 pD3DDevice,
    LPD3DXBUFFER *ppbufAdjacency,
    LPD3DXBUFFER *ppbufMaterials,
    PDWORD pcMaterials,
    LPD3DXMESH *ppMesh
    )
{
    return D3DXLoadMeshFromXofEx(pxofobjMesh, options, pD3DDevice, ppbufAdjacency, ppbufMaterials, pcMaterials, ppMesh, NULL, NULL, NULL, NULL, NULL, NULL);
}

HRESULT WINAPI
    D3DXCreatePMeshFromStream
    (
    IStream *pstream,
    DWORD dwOptions,
    LPDIRECT3DDEVICE8 pD3DDevice,
    LPD3DXBUFFER *ppbufMaterials,
    DWORD *pcMaterials,
    LPD3DXPMESH *ppPMesh
    )
{
    HRESULT hr = S_OK;
    LPD3DXBUFFER pbufAdjacency = NULL;
    LPDIRECTXFILE pxofapi = NULL;
    LPDIRECTXFILEENUMOBJECT pxofenum = NULL;
    LPDIRECTXFILEDATA pxofobjCur = NULL;
    LPD3DXMESH ptmMesh = NULL;
    const GUID *type;
    DXFILELOADMEMORY dxfilemem;
    STATSTG statstg;
    DWORD cbPMData;
    PBYTE pbPMData = NULL;
    LPD3DXPMESH ptmPMesh = NULL;
    HINSTANCE hXof;
    LPDIRECTXFILECREATE pfnDirectXFileCreate;
   
    const DWORD x_dwOptionsFull = D3DXMESH_SYSTEMMEM;

    if (((dwOptions & ~D3DXMESH_VALIDBITS) != 0)
        || ((dwOptions & D3DXMESH_32BIT) != 0))
    {
#ifdef DBG
        if ((dwOptions & ~D3DXMESH_VALIDBITS) != 0)
		    DPF(0, "D3DXCreatePMeshFromStream: Invalid mesh flag specified\n");
        else if ((dwOptions & D3DXMESH_32BIT) != 0)
		    DPF(0, "D3DXCreatePMeshFromStream: Cannot specify 32bit, will be determined by file data.\n");
#endif
        hr = D3DERR_INVALIDCALL;
        goto e_Exit;
    }
#if 0
    // Create Xfile parser
    if(!(hXof = (HINSTANCE) GetModuleHandle("d3dxof.dll")) &&
       !(hXof = (HINSTANCE) LoadLibrary("d3dxof.dll")))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto e_Exit;
    }
#endif
    if(!(pfnDirectXFileCreate = (LPDIRECTXFILECREATE)DirectXFileCreate))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto e_Exit;
    }

    hr = pfnDirectXFileCreate(&pxofapi);
    if (FAILED(hr))
        goto e_Exit;

    // Registe templates for d3drm.
    hr = pxofapi->RegisterTemplates((LPVOID)D3DRM_XTEMPLATES,
                                    D3DRM_XTEMPLATE_BYTES);
    if (FAILED(hr))
        goto e_Exit;

    hr = pstream->Stat(&statstg, STATFLAG_NONAME);
    if (FAILED(hr))
        goto e_Exit;

    // sort of too much memory to allocate in 32 bit....
    if (statstg.cbSize.HighPart != 0)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    // since we can't handle streams with the X file loader, just copy it all into memory
    dxfilemem.lpMemory = new BYTE[statstg.cbSize.LowPart];
    if (dxfilemem.lpMemory == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    hr = pstream->Read(dxfilemem.lpMemory, statstg.cbSize.LowPart, &dxfilemem.dSize);
    if (FAILED(hr))
        goto e_Exit;

    hr = pxofapi->CreateEnumObject((LPVOID)&dxfilemem,
                                   DXFILELOAD_FROMMEMORY,
                                   &pxofenum);
    if (FAILED(hr))
        goto e_Exit;

    // Enumerate top level objects.
    // Top level objects are always data object.
    ptmMesh = NULL;
    while (SUCCEEDED(pxofenum->GetNextDataObject(&pxofobjCur)))
    {
        hr = pxofobjCur->GetType(&type);
        if (FAILED(hr))
            goto e_Exit;

        if (*type == TID_D3DRMMesh)
        {
            hr = D3DXLoadMeshFromXofEx(pxofobjCur, x_dwOptionsFull, pD3DDevice, &pbufAdjacency, ppbufMaterials, pcMaterials, &ptmMesh, &pbPMData, &cbPMData, NULL, NULL, NULL, NULL);
            if (FAILED(hr))
                goto e_Exit;

            break;
        }

        GXRELEASE(pxofobjCur);
    }

    if ((ptmMesh == NULL) || (pbPMData == NULL) || (cbPMData == 0))
    {
        hr = E_FAIL;
        goto e_Exit;
    }

    // fill the pmesh from the data loaded from the file
    hr = D3DXCreatePMeshFromData(ptmMesh, dwOptions, (DWORD*)pbufAdjacency->GetBufferPointer(), pbPMData, cbPMData, &ptmPMesh);
    if (FAILED(hr))
        goto e_Exit;

    *ppPMesh = ptmPMesh;
    ptmPMesh = NULL;
e_Exit:
    GXRELEASE(pbufAdjacency);
    GXRELEASE(pxofobjCur);
    GXRELEASE(pxofenum);
    GXRELEASE(pxofapi);
    GXRELEASE(ptmMesh);
    GXRELEASE(ptmPMesh);
    delete []pbPMData;

    return hr;
}

// Prototype for func defined in skinmesh.cpp
HRESULT WINAPI
D3DXCreateSkinMeshFromMeshAndBones(LPD3DXMESH pMesh, DWORD numBones, LPBONE pBones, LPD3DXSKINMESH* ppMesh);

HRESULT WINAPI
    D3DXLoadSkinMeshFromXof
    (
    LPDIRECTXFILEDATA pxofobjMesh, 
    DWORD options,
    LPDIRECT3DDEVICE8 pD3D,
    LPD3DXBUFFER* ppAdjacency,
    LPD3DXBUFFER* ppMaterials,
    PDWORD pMatOut,
    LPD3DXBUFFER* ppBoneNames,
    LPD3DXBUFFER* ppBoneTransforms,
    LPD3DXSKINMESH* ppMesh
    )
{
    LPBONE pBones = NULL;
    DWORD numBones, i;
    LPD3DXMESH pMesh = NULL;
    LPD3DXSKINMESH pSkinMesh = NULL;
    *ppAdjacency = NULL;
    *ppMaterials = NULL;
    *ppBoneNames = NULL;
    *ppBoneTransforms = NULL;
    *ppMesh = NULL;

    HRESULT hr = D3DXLoadMeshFromXofEx(pxofobjMesh, D3DXMESH_SYSTEMMEM, pD3D, ppAdjacency, ppMaterials, pMatOut, 
        &pMesh, NULL, NULL, ppBoneNames, ppBoneTransforms, &pBones, &numBones);
    if (FAILED(hr))
    {
        goto e_Exit;
    }

    hr = D3DXCreateSkinMeshFromMeshAndBones(pMesh, numBones, pBones, &pSkinMesh);
    if (FAILED(hr))
    {
        goto e_Exit;
    }

    pMesh->Release();

    *ppMesh = pSkinMesh;
    return S_OK;

e_Exit:
    if (*ppAdjacency)
        (*ppAdjacency)->Release();
    if (*ppMaterials)
        (*ppMaterials)->Release();
    if (pMesh)
        pMesh->Release();
    if (*ppBoneNames)
        (*ppBoneNames)->Release();
    if (*ppBoneTransforms)
        (*ppBoneTransforms)->Release();
    if (pBones)
        delete [] pBones;
    if (pSkinMesh)
        pSkinMesh->Release();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\mesh\loadutil.cpp ===
/*//////////////////////////////////////////////////////////////////////////////
//
// File: loadutil.cpp
//
// Copyright (C) 1999 Microsoft Corporation. All Rights Reserved.
//
// @@BEGIN_MSINTERNAL
//
// History:
// -@-          (craigp)    - created 
// -@- 08/06/99 (mikemarr)  - prepend GX to all Luciform functions
//                          - started comment history
// -@- 08/26/99 (mikemarr)  - replace gxbasetype.h with gxmathcore.h
// -@- 09/23/99 (mikemarr)  - GXCross return D3DXVECTOR
//                          - added newline to the end of the file
//
// @@END_MSINTERNAL
//
//////////////////////////////////////////////////////////////////////////////*/

#include "pchmesh.h"

#include "loadutil.h"


/*
 * Template routine to handle dynamic allocation, based on Heap* Win32 APIs.
 *
 *  T **ppBase: base of array.
 *  const T& obj: object to add to end of array.
 *  UINT *pcNum: number of objects in array.
 *  UINT *pcMax: max. number of objects in array.
 *
 * ppBase, pcNum and pcMax point to values that usually get modified
 * by the call. The only case when they are not updated is if there
 * is insufficient memory for the initial allocation (if *pBase is NULL)
 * or a second allocation if *pcNum==*pcMax.
 *
 * Return value: TRUE if allocation was successful
 *               FALSE if there was insufficient memory
 *      FALSE means nothing was added to the array, but nothing
 *        was lost either. No weird realloc semantics allowed!
 */
template<class T>
BOOL
AddToDynamicArray( T **ppBase, const T& obj, DWORD *pcNum, DWORD *pcMax )
{
    T *pBase = *ppBase;
    if ( ! pBase )
    {
        HeapValidate( GetProcessHeap(), 0, NULL );
        pBase = new T[2];
        *pcNum = 0;
        *pcMax = 2;
    }
    if ( *pcNum == *pcMax )
    {
        DWORD cNewMax = *pcMax*2;
        T *newarr = new T[cNewMax];
        if ( ! newarr )
            return FALSE;
        for (DWORD i = 0; i < *pcNum; i++)
            newarr[i] = pBase[i];
        *pcMax = cNewMax;
        delete []pBase;
        pBase = newarr;
    }
    pBase[ (*pcNum)++ ] = obj;
    *ppBase = pBase;
    return TRUE;
}

HRESULT 
SetVertexColor(SLoadedFace *pface, DWORD iPoint, D3DXCOLOR &color, SLoadVertex **prglvLoaded, DWORD *pcVertices, DWORD *pcVerticesMax)
{
    HRESULT hr = S_OK;
    SLoadVertex *plvVertex;
    SLoadVertex lvVertexNew;
    DWORD iVertex;
    DWORD iVertexNew;
    DWORD wCur;
    DWORD wHead;
    SLoadVertex *plvCur;

    GXASSERT(pface != NULL && prglvLoaded != NULL && pcVertices != NULL && pcVerticesMax != NULL);

    iVertex = pface->m_wIndices[iPoint];
    GXASSERT(iVertex < *pcVertices);

    plvVertex = &(*prglvLoaded)[iVertex];

    // if the vertex is not currently owned, take ownership
    if (!plvVertex->m_bOwned)
    {
        plvVertex->m_bOwned = true;
        plvVertex->m_color = color;
    }
    // else if the vertex is owned but the color is not the same 
    //   NOTE: if the same, then just ignore the fact that the color was being set
    else if (plvVertex->m_color != color)
    {
        lvVertexNew = *plvVertex;
        GXASSERT(lvVertexNew.m_bOwned);

        // UNDONE - this is currently rechecking the first vertex, might be possible
        //   to skip depending on sematics of the mesh file
        wHead = iVertex;
        wCur = wHead;
        do
        {
            plvCur = &( (*prglvLoaded)[wCur] );

            if (plvCur->m_color == color)
            {
                // found an equivalent wedge, just point at it
                pface->m_wIndices[iPoint] = wCur;
                goto e_Exit;
            }

            // go to next wedge in the vertex
            wCur = (*prglvLoaded)[wCur].m_wPointList;
        } while (wCur != wHead);

        // set both the color and the representative point to create a new vertex that is 
        //   logically the same in the mesh, but has a different color attribute
        lvVertexNew.m_color = color;
        lvVertexNew.m_wPointRep = (*prglvLoaded)[iVertex].m_wPointRep;

        iVertexNew = (DWORD)*pcVertices;

        if ( ! AddToDynamicArray( prglvLoaded, lvVertexNew, pcVertices, pcVerticesMax ) )
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }

        (*prglvLoaded)[iVertexNew].m_wPointList = (*prglvLoaded)[lvVertexNew.m_wPointRep].m_wPointList;
        (*prglvLoaded)[lvVertexNew.m_wPointRep].m_wPointList = iVertexNew;

        // now update the face to refer to the new point with the correct attributes
        pface->m_wIndices[iPoint] = iVertexNew;
    }

e_Exit:
    return hr;
}

HRESULT 
SetVertexAttributes(SLoadedFace *pface, DWORD iPoint, D3DXVECTOR3 *pvNormal, D3DXVECTOR2 *puvTex1, SLoadVertex **prglvLoaded, DWORD *pcVertices, DWORD *pcVerticesMax)
{
    HRESULT hr = S_OK;
    SLoadVertex *plvVertex;
    SLoadVertex lvVertexNew;
    DWORD iVertex;
    DWORD iVertexNew;
    DWORD wCur;
    DWORD wHead;
    SLoadVertex *plvCur;

    GXASSERT(pface != NULL && prglvLoaded != NULL && pcVertices != NULL && pcVerticesMax != NULL);

    iVertex = pface->m_wIndices[iPoint];
    GXASSERT(iVertex < *pcVertices);

    plvVertex = &(*prglvLoaded)[iVertex];

    // UNDONE craigp - It might be useful to search all instances of a logical vertex
    //   in order to find another one to share with

    // if the vertex is not currently owned, take ownership
    if (!plvVertex->m_bOwned)
    {
        plvVertex->m_bOwned = true;

        if (pvNormal != NULL)
            plvVertex->m_vNormal = *pvNormal;

        if (puvTex1 != NULL)
            plvVertex->m_uvTex1 = *puvTex1;
    }
    else if (((pvNormal != NULL) && (plvVertex->m_vNormal != *pvNormal))
            || ((puvTex1 != NULL) && (plvVertex->m_uvTex1 != *puvTex1)))
    {
        lvVertexNew = *plvVertex;
        GXASSERT(lvVertexNew.m_bOwned);

        // set both the attributes and the representative point to create a new vertex that is 
        //   logically the same in the mesh, but has a different vertex attributes

        if (pvNormal != NULL)
            lvVertexNew.m_vNormal = *pvNormal;

        if (puvTex1 != NULL)
            plvVertex->m_uvTex1 = *puvTex1;

        // UNDONE - this is currently rechecking the first vertex, might be possible
        //   to skip depending on sematics of the mesh file
        wHead = iVertex;
        wCur = wHead;
        do
        {
            plvCur = &( (*prglvLoaded)[wCur] );

            if (BEqualWedges(*plvCur, lvVertexNew))
            {
                // found an equivalent wedge, just point at it
                pface->m_wIndices[iPoint] = wCur;
                goto e_Exit;
            }

            // go to next wedge in the vertex
            wCur = (*prglvLoaded)[wCur].m_wPointList;
        } while (wCur != wHead);

        lvVertexNew.m_wPointRep = (*prglvLoaded)[iVertex].m_wPointRep;

        iVertexNew = (DWORD)*pcVertices;

        if ( ! AddToDynamicArray( prglvLoaded, lvVertexNew, pcVertices, pcVerticesMax ) )
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }

        // link the vertex in to the vertex list
        (*prglvLoaded)[iVertexNew].m_wPointList = (*prglvLoaded)[lvVertexNew.m_wPointRep].m_wPointList;
        (*prglvLoaded)[lvVertexNew.m_wPointRep].m_wPointList = iVertexNew;

        // now update the face to refer to the new point with the correct attributes
        pface->m_wIndices[iPoint] = iVertexNew;
    }

e_Exit:
    return hr;
}

HRESULT 
SetSmoothingGroup(SLoadedFace *pface, DWORD iPoint, WORD iSmoothingGroup, D3DXVECTOR3 &vNormal, SLoadVertex **prglvLoaded, DWORD *pcVertices, DWORD *pcVerticesMax)
{
    HRESULT hr = S_OK;
    SLoadVertex *plvVertex;
    SLoadVertex lvVertexNew;
    DWORD iVertex;
    DWORD iVertexNew;
    DWORD wCur;
    DWORD wHead;
    DWORD wWedgeFound;
    SLoadVertex *plvCur;

    GXASSERT(pface != NULL && prglvLoaded != NULL && pcVertices != NULL && pcVerticesMax != NULL);

    iVertex = pface->m_wIndices[iPoint];
    GXASSERT(iVertex < *pcVertices);

    plvVertex = &(*prglvLoaded)[iVertex];

    // if the vertex is not currently owned, take ownership
    if (plvVertex->m_cSmoothingGroupFaces == 0)
    {
        GXASSERT(plvVertex->m_iSmoothingGroup == 0);

        plvVertex->m_cSmoothingGroupFaces = 1;
        plvVertex->m_iSmoothingGroup = iSmoothingGroup;

        plvVertex->m_vNormal = vNormal;
    }
    else
    {       

        if (iSmoothingGroup > 0)
        {
            wHead = iVertex;
            wCur = wHead;
            wWedgeFound = UNUSED32;
            do
            {
                plvCur = &( (*prglvLoaded)[wCur] );

                if (plvVertex->m_iSmoothingGroup == iSmoothingGroup)
                {
                    // found a wedge of this smoothing group
                    wWedgeFound = wCur;
                    break;
                }

                // go to next wedge in the vertex
                wCur = (*prglvLoaded)[wCur].m_wPointList;
            } while (wCur != wHead);
        }
        else  // in the 0 case, need to approximate flat shading so always
            //  insert a new wedge
        {           
            wHead = iVertex;
            wCur = wHead;
            wWedgeFound = UNUSED32;
            do
            {
                plvCur = &( (*prglvLoaded)[wCur] );

                if ((plvVertex->m_iSmoothingGroup == iSmoothingGroup) &&
                    (plvVertex->m_vNormal == vNormal))
                {
                    // found a wedge of this smoothing group
                    wWedgeFound = wCur;
                    break;
                }

                // go to next wedge in the vertex
                wCur = (*prglvLoaded)[wCur].m_wPointList;
            } while (wCur != wHead);
        }

        // if a wedge was found, add the current normal in to the wedge
        if (wWedgeFound != UNUSED32)
        {
            (*prglvLoaded)[wWedgeFound].m_cSmoothingGroupFaces += 1;
            (*prglvLoaded)[wWedgeFound].m_vNormal += vNormal;

            // now update the face to refer to the new point with the correct attributes
            pface->m_wIndices[iPoint] = wWedgeFound;
        }
        else  // if no matching wedge found.  add a new wedge
        {
            lvVertexNew = *plvVertex;

            lvVertexNew.m_wPointRep = (*prglvLoaded)[iVertex].m_wPointRep;

            lvVertexNew.m_iSmoothingGroup = iSmoothingGroup;
            lvVertexNew.m_cSmoothingGroupFaces = 1;
            lvVertexNew.m_vNormal = vNormal;

            iVertexNew = (DWORD)*pcVertices;

            if ( ! AddToDynamicArray( prglvLoaded, lvVertexNew, pcVertices, pcVerticesMax ) )
            {
                hr = E_OUTOFMEMORY;
                goto e_Exit;
            }

            // link the vertex in to the vertex list
            (*prglvLoaded)[iVertexNew].m_wPointList = (*prglvLoaded)[lvVertexNew.m_wPointRep].m_wPointList;
            (*prglvLoaded)[lvVertexNew.m_wPointRep].m_wPointList = iVertexNew;

            // now update the face to refer to the new point with the correct attributes
            pface->m_wIndices[iPoint] = iVertexNew;
        }

    }

e_Exit:
    return hr;
}

DWORD 
FindPoint(PDWORD pwIndices, DWORD iPointSearch, SLoadVertex *rglvVerts)
{
    DWORD iPoint;

    // get the representative for the point, so that we can compare
    //   them, this function compares the logical points in the mesh
    DWORD wPointSearchRep = rglvVerts[iPointSearch].m_wPointRep;

    for (iPoint = 0; iPoint < 3; iPoint++)
    {
        if (rglvVerts[pwIndices[iPoint]].m_wPointRep == wPointSearchRep)
        {
            break;
        }
    }

    return iPoint;
}

HRESULT  
InitVertices(SLoadVertex *&rglvVertices, DWORD cVertices)
{
    HRESULT hr = S_OK;
    DWORD iVertex;

    rglvVertices = new SLoadVertex[cVertices];
    if (rglvVertices == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    for (iVertex = 0; iVertex < cVertices; iVertex++)
    {
        rglvVertices[iVertex].m_vPos = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
        rglvVertices[iVertex].m_vNormal = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
//        rglvVertices[iVertex].m_color = D3DXCOLOR(0.9f, 0.6f, 0.4f, 0.0f);
        rglvVertices[iVertex].m_color = D3DXCOLOR(1.0f, 1.0f, 1.0f, 0.0f);
        rglvVertices[iVertex].m_uvTex1 = D3DXVECTOR2(0.0f, 0.0f);
        rglvVertices[iVertex].m_wPointRep = iVertex;
        rglvVertices[iVertex].m_wPointList = iVertex;
        rglvVertices[iVertex].m_bOwned = false;
        rglvVertices[iVertex].m_iFVFDataOffset = iVertex;

        rglvVertices[iVertex].m_iSmoothingGroup = 0;
        rglvVertices[iVertex].m_cSmoothingGroupFaces = 0;
    }

e_Exit:
    return hr;
}

HRESULT 
InitCorners(SCorner *&rgCorners, DWORD cCorners)
{
    HRESULT hr = S_OK;
    DWORD iCorner;

    rgCorners = new SCorner[cCorners];
    if (rgCorners == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    for (iCorner = 0; iCorner < cCorners; iCorner++)
    {
        rgCorners[iCorner].m_wPoint = UNUSED32;
        rgCorners[iCorner].m_wFace = UNUSED32;

        rgCorners[iCorner].m_vNormal = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
        rgCorners[iCorner].m_uvTex1 = D3DXVECTOR2(0.0f, 0.0f);

        rgCorners[iCorner].m_bNormalSpecified = false;
        rgCorners[iCorner].m_bUvSpecified = false;
    }

e_Exit:
    return hr;
}

HRESULT 
InitFaces(SLoadedFace *&rglfFaces, DWORD cFaces)
{
    HRESULT hr = S_OK;
    DWORD iFace;

    rglfFaces = new SLoadedFace[cFaces];
    if (rglfFaces == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    for (iFace = 0; iFace < cFaces; iFace++)
    {
        rglfFaces[iFace].InitEmpty();
    }

e_Exit:
    return hr;
}

bool
BEqualWedges(SLoadVertex &lv1, SLoadVertex &lv2)
{

    return (lv1.m_color == lv2.m_color) 
        && (lv1.m_uvTex1 == lv2.m_uvTex1)
        && (lv1.m_vNormal == lv2.m_vNormal);
}


D3DCOLOR
ConvertColor(D3DXCOLOR &color)
{
    DWORD _r, _g, _b;
    if (color.r < 0.0f) _r = 0;
    else if (color.r > 1.0f) _r = 0xff;
    else _r = (DWORD) (color.r*255.0f+0.5f);
    if (color.g < 0.0f) _g = 0;
    else if (color.g > 1.0f) _g = 0xff;
    else _g = (DWORD) (color.g*255.0f+0.5f);
    if (color.b < 0.0f) _b = 0;
    else if (color.b > 1.0f) _b = 0xff;
    else _b = (DWORD) (color.b*255.0f+0.5f);
    return D3DCOLOR_XRGB( _r, _g, _b );
}

HRESULT 
SetMesh(SLoadedFace *&rglfFaces, DWORD cFaces, 
                SLoadVertex *&rglvLoaded, DWORD cVertices, 
                SCorner *rgCorners, DWORD cCorners,
                SFVFData *pFVFData, BOOL bUsePointRepData,
                DWORD dwOptions, DWORD dwFVF, LPDIRECT3DDEVICE8 pD3DDevice, 
                LPD3DXMESH *ppMesh, LPD3DXBUFFER *ppbufAdjacency)
{
    HRESULT hr = S_OK;
    PBYTE pvPoints = NULL;
    D3DXVECTOR3 vNormal;

    DWORD iVertex;
    D3DXVECTOR3 *pvNormal;
    D3DXVECTOR2 *puvTex1;
    DWORD iPoint;
    DWORD iFace;
    DWORD iCorner;
    PBYTE pvCurPoint;
    DWORD iWeight;
    DWORD iTexCoord;
    DWORD iInitialTexCoord;
    PBYTE pbCur;
    DWORD cFacesActual;
    DWORD iFaceActual;

    ID3DXMesh *ptmMesh = NULL;
    DWORD *rgdwFaces = NULL;
    UINT16 *rgwFaces = NULL;
    DWORD *rgiAttribIds = NULL;
    DWORD *pdwFaceCur;
    UINT16 *pwFaceCur;
    PVOID pvFaces = NULL;

    DWORD cVerticesMax = cVertices;
    BOOL bSmoothingGroups;

    DWORD *rgdwPointRepsTemp = NULL;
    LPD3DXBUFFER pbufAdjacency = NULL;
    DWORD *pdwAdjacency;

    GXASSERT(ppMesh != NULL);
    GXASSERT(rglfFaces != NULL);
    GXASSERT(rglvLoaded != NULL);
    // Corners are allowed to be NULL
    DXCrackFVF  cfvf(dwFVF);                                
    DXCrackFVF  cfvfOtherData(pFVFData != NULL ? pFVFData->dwFVF : D3DFVF_XYZ);                                

    if ((cFaces == 0) || (cVertices == 0))
    {
        hr = D3DXERR_INVALIDDATA;
        goto e_Exit;
    }

    // handle smoothing groups
    bSmoothingGroups = false;
    for (iFace = 0; iFace < cFaces; iFace++)
    {
        if (rglfFaces[iFace].m_bSmoothingGroupSpecified)
        {
            bSmoothingGroups = true;
        }
    }

    // if there are smoothing groups, and the normals are there is a 
    //   reason to compute smoothing groups, then compute them.
    if (bSmoothingGroups && cfvf.BNormal())
    {
        SLoadedFace *plfFace;
        SLoadVertex *plvPos0;
        SLoadVertex *plvPos1;
        SLoadVertex *plvPos2;
        D3DXVECTOR3 vEdge1;
        D3DXVECTOR3 vEdge2;
        SLoadVertex *plvVert;
        DWORD iVert;

        for (iFace = 0 ; iFace < cFaces; iFace++)
        {
            plfFace = &rglfFaces[iFace];
            if (plfFace->m_bSmoothingGroupSpecified)
            {
                plvPos0 = &rglvLoaded[plfFace->m_wIndices[0]];
                plvPos1 = &rglvLoaded[plfFace->m_wIndices[1]];
                plvPos2 = &rglvLoaded[plfFace->m_wIndices[2]];

                vEdge1 = plvPos0->m_vPos - plvPos1->m_vPos;
                vEdge2 = plvPos0->m_vPos - plvPos2->m_vPos;

                // calculate the normal of the face from the two edge vectors
                D3DXVec3Cross(&vNormal, &vEdge1, &vEdge2);
                vNormal /= D3DXVec3Length(&vNormal);
                //vNormal *= -1;

                for (iPoint = 0; iPoint < 3; iPoint++)
                {
                    hr = SetSmoothingGroup(&rglfFaces[iFace], iPoint, rglfFaces[iFace].m_iSmoothingGroup, vNormal, &rglvLoaded, &cVertices, &cVerticesMax);
                    if (FAILED(hr))
                        goto e_Exit;
                }
            }
        }

        DWORD iTest;
        iTest = 0;
        // average and renormalize vertices shared among faces of the same smoothing group
        for (iVert = 0; iVert < cVertices; iVert++)
        {
            plvVert = &rglvLoaded[iVert];

            if (plvVert->m_cSmoothingGroupFaces > 1)
            {
                /*plvVert->m_vNormal /= plvVert->m_cSmoothingGroupFaces*/;
                plvVert->m_vNormal /= D3DXVec3Length(&plvVert->m_vNormal);
            }

            if (plvVert->m_iSmoothingGroup == 0)
            {
                iTest += 1;
            }
        }

    }

    if (cfvf.BDiffuse())
    {
        // propagate face color attributes into vertex attributes
        for (iFace = 0; iFace < cFaces; iFace++)
        {
            if (rglfFaces[iFace].m_bColorSpecified)
            {
                for (iPoint = 0; iPoint < 3; iPoint++)
                {
                    hr = SetVertexColor(&rglfFaces[iFace], iPoint, rglfFaces[iFace].m_colorFace, &rglvLoaded, &cVertices, &cVerticesMax);
                    if (FAILED(hr))
                        goto e_Exit;
                }
            }

        }
    }

    // after dealing face attributes, reset owned flags to false, and reprocess
    // the 
    for (iVertex = 0; iVertex < cVertices; iVertex++)
    {
        rglvLoaded[iVertex].m_bOwned = false;
    }

    // propogate corner attributes into vertex attributes
    for (iCorner = 0; iCorner < cCorners; iCorner++)
    {
        if (rgCorners[iCorner].m_bNormalSpecified || rgCorners[iCorner].m_bUvSpecified)
        {
            iFace = rgCorners[iCorner].m_wFace;
			if ((iFace >= cFaces) || (rglfFaces[iFace].m_wIndices[0] == UNUSED32))
				continue;

            iPoint = FindPoint(rglfFaces[iFace].m_wIndices, rgCorners[iCorner].m_wPoint, rglvLoaded);

            GXASSERT(iPoint < 3);

            pvNormal = NULL;
            if (rgCorners[iCorner].m_bNormalSpecified && cfvf.BNormal())
            {
                pvNormal = &rgCorners[iCorner].m_vNormal;
            }
            
            puvTex1 = NULL;
            if (rgCorners[iCorner].m_bUvSpecified && cfvf.BTex1())
            {
                puvTex1 = &rgCorners[iCorner].m_uvTex1;
            }

            hr = SetVertexAttributes(&rglfFaces[iFace], iPoint, pvNormal, puvTex1, &rglvLoaded, &cVertices, &cVerticesMax);
            if (FAILED(hr))
                goto e_Exit;
        }
    }


    if ((cFaces >= UNUSED16) || (cVertices >= UNUSED16))
    {
        dwOptions |= D3DXMESH_32BIT;
    }

    // need to remove degenerate triangles
    cFacesActual = 0;
    for (iFace = 0; iFace < cFaces; iFace++)
    {
        if ((rglfFaces[iFace].m_wIndices[0] == rglfFaces[iFace].m_wIndices[1])
            || (rglfFaces[iFace].m_wIndices[0] == rglfFaces[iFace].m_wIndices[2])
            || (rglfFaces[iFace].m_wIndices[1] == rglfFaces[iFace].m_wIndices[2]))
        {
            rglfFaces[iFace].m_wIndices[0] = UNUSED32;
            rglfFaces[iFace].m_wIndices[1] = UNUSED32;
            rglfFaces[iFace].m_wIndices[2] = UNUSED32;
        }
        else
        {
            cFacesActual += 1;
        }
    }

    // create the mesh now that we know the correct size
    hr = D3DXCreateMeshFVF(cFacesActual, cVertices, dwOptions, dwFVF, pD3DDevice, &ptmMesh);
    if (FAILED(hr))
        goto e_Exit;

    // get the vertex buffer, fill the vertices in place
    hr = ptmMesh->LockVertexBuffer(0, &pvPoints);
    if (FAILED(hr))
        goto e_Exit;

    // transform the points into the proper FVF format
    for (iPoint=0, pvCurPoint = pvPoints; iPoint < cVertices; iPoint++, pvCurPoint+=cfvf.m_cBytesPerVertex)
    {
        cfvf.SetPosition(pvCurPoint, &rglvLoaded[iPoint].m_vPos);

        cfvf.SetNormal(pvCurPoint, &rglvLoaded[iPoint].m_vNormal);
        cfvf.SetDiffuse(pvCurPoint, ConvertColor(rglvLoaded[iPoint].m_color));
        cfvf.SetTex1(pvCurPoint, &rglvLoaded[iPoint].m_uvTex1);

        if (pFVFData != NULL)
        {
            pbCur = (PBYTE)&pFVFData->rgiFVFData[pFVFData->cBytesPerVertex/sizeof(DWORD) * rglvLoaded[iPoint].m_iFVFDataOffset];

            if (cfvfOtherData.CWeights() > 0)
            {
                for (iWeight = 0; iWeight < cfvfOtherData.CWeights(); iWeight++)
                {
                    cfvf.SetWeight(pvCurPoint, iWeight, *(float*)pbCur);
                    pbCur += sizeof(float);
                }
            }

            if (cfvfOtherData.BNormal())
            {
                cfvf.SetNormal(pvCurPoint, (D3DXVECTOR3*)pbCur);
                pbCur += sizeof(D3DXVECTOR3);
            }

            if (cfvfOtherData.BDiffuse())
            {
                cfvf.SetDiffuse(pvCurPoint, *(D3DCOLOR*)pbCur);
                pbCur += sizeof(D3DCOLOR);
            }

            if (cfvfOtherData.BSpecular())
            {
                cfvf.SetSpecular(pvCurPoint, *(D3DCOLOR*)pbCur);
                pbCur += sizeof(D3DCOLOR);
            }

            if (cfvfOtherData.CTexCoords() > 0)
            {
                // UNDONE UNDONE - fix when 3d tex coords are handled
                //iInitialTexCoord = cfvf.BTex1() ? 1 : 0;
                iInitialTexCoord = pFVFData->iTexCoordOffset;

                for (iTexCoord = iInitialTexCoord; iTexCoord < iInitialTexCoord + cfvfOtherData.CTexCoords(); iTexCoord++)
                {
                    cfvf.SetTexCoord(pvCurPoint, iTexCoord, (D3DXVECTOR2*)pbCur);
                    pbCur += sizeof(D3DXVECTOR2);
                }
            }
        }
    }

    hr = ptmMesh->LockIndexBuffer(0, (PBYTE*)&pvFaces);
    if (FAILED(hr))
        goto e_Exit;

    hr = ptmMesh->LockAttributeBuffer(0, &rgiAttribIds);
    if (FAILED(hr))
        goto e_Exit;

    // copy the material data to arrays understood by ID3DXMesh::SetMesh
    for (iFace = iFaceActual = 0; iFace < cFaces; iFace++)
    {
        if (rglfFaces[iFace].m_wIndices[0] == UNUSED32)
            continue;

        if (rglfFaces[iFace].m_bAttributeSpecified)
        {
            rgiAttribIds[iFaceActual] = rglfFaces[iFace].m_attr;
        }
        else
        {
            //rgiAttribIds[iFace] = UNUSED32;
            rgiAttribIds[iFaceActual] = 0;
        }

        iFaceActual += 1;
    }

    if ( dwOptions & D3DXMESH_32BIT)
    {
        rgdwFaces = (DWORD*)pvFaces;

        for (iFace = 0, pdwFaceCur = rgdwFaces; iFace < cFaces; iFace++)
        {
            if (rglfFaces[iFace].m_wIndices[0] == UNUSED32)
                continue;

            pdwFaceCur[0] = rglfFaces[iFace].m_wIndices[0];
            pdwFaceCur[1] = rglfFaces[iFace].m_wIndices[1];
            pdwFaceCur[2] = rglfFaces[iFace].m_wIndices[2];
            pdwFaceCur += 3;
        }
    }
    else // 16 bit indices
    {
        rgwFaces = (UINT16*)pvFaces;

        for (iFace = 0, pwFaceCur = rgwFaces; iFace < cFaces; iFace++)
        {
            if (rglfFaces[iFace].m_wIndices[0] == UNUSED32)
                continue;

            pwFaceCur[0] = (UINT16)rglfFaces[iFace].m_wIndices[0];
            pwFaceCur[1] = (UINT16)rglfFaces[iFace].m_wIndices[1];
            pwFaceCur[2] = (UINT16)rglfFaces[iFace].m_wIndices[2];

            pwFaceCur += 3;
        }
    }

    ptmMesh->UnlockAttributeBuffer();
    rgiAttribIds = NULL;
    ptmMesh->UnlockIndexBuffer();
    pvFaces = NULL;
    ptmMesh->UnlockVertexBuffer();
    pvPoints = NULL;

    // if adjacency information is desired, generate it from point rep information
    if (ppbufAdjacency != NULL)
    {
        hr = D3DXCreateBuffer(cFacesActual * 3 * sizeof(DWORD), &pbufAdjacency);
        if (FAILED(hr))
            goto e_Exit;
        
        pdwAdjacency = (DWORD*)pbufAdjacency->GetBufferPointer();
        GXASSERT(cFacesActual * 3 * sizeof(DWORD) == pbufAdjacency->GetBufferSize());

        rgdwPointRepsTemp = new DWORD[cVertices];
        if (rgdwPointRepsTemp == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }

        // load the point reps into the temp array
        for (iPoint = 0; iPoint < cVertices; iPoint++)
        {
            rgdwPointRepsTemp[iPoint] = rglvLoaded[iPoint].m_wPointRep;
        }

        if (bUsePointRepData)
        {
            hr = ptmMesh->ConvertPointRepsToAdjacency(rgdwPointRepsTemp, pdwAdjacency);
            if (FAILED(hr))
                goto e_Exit;
        }
        else
        {
            hr = ptmMesh->GenerateAdjacency(1.0e-6f, pdwAdjacency);
            if (FAILED(hr))
                goto e_Exit;
        }

        *ppbufAdjacency = pbufAdjacency;
        pbufAdjacency = NULL;
    }

    *ppMesh = ptmMesh;
e_Exit:
    if (rgiAttribIds != NULL)
    {
        ptmMesh->UnlockAttributeBuffer();
    }
    if (pvFaces != NULL)
    {
        ptmMesh->UnlockIndexBuffer();
    }

    delete []rgdwPointRepsTemp;

    GXRELEASE(pbufAdjacency);

    if (pvPoints != NULL)
    {
        ptmMesh->UnlockVertexBuffer();
    }

    if (FAILED(hr))
        GXRELEASE(ptmMesh);

    return hr;
}


HRESULT
CreateMaterialBuffer(LPD3DXMATERIAL rgmat, DWORD cmat, LPD3DXBUFFER *ppbufMaterials)
{
    HRESULT hr = S_OK;
    DWORD cbTotalStringSize;
    DWORD iCurOffset;
    DWORD imat;
    LPD3DXBUFFER pbufMaterialsOut = NULL;
    LPD3DXMATERIAL rgmatOut;
    DWORD cbName;

    // first calculate the amount of memory needed for the string buffers
    cbTotalStringSize = 0;
    for (imat = 0; imat < cmat; imat++)
    {
        if (rgmat[imat].pTextureFilename != NULL)
        {
            cbTotalStringSize += strlen(rgmat[imat].pTextureFilename) + 1;
        }
    }

    hr = D3DXCreateBuffer(sizeof(D3DXMATERIAL) * cmat + cbTotalStringSize, &pbufMaterialsOut);
    if (FAILED(hr))
        goto e_Exit;

    rgmatOut = (LPD3DXMATERIAL)pbufMaterialsOut->GetBufferPointer();

    // fist copy the materials info into the new array (note: string pointers are now incorrect)
    memcpy(rgmatOut, rgmat, sizeof(D3DXMATERIAL) * cmat);

    // start allocating strings just after the last material
    iCurOffset = sizeof(D3DXMATERIAL) * cmat;
    for (imat = 0; imat < cmat; imat++)
    {
        if (rgmat[imat].pTextureFilename != NULL)
        {
            rgmatOut[imat].pTextureFilename = ((char*)rgmatOut) + iCurOffset;

            cbName = strlen(rgmat[imat].pTextureFilename) + 1;
            memcpy(rgmatOut[imat].pTextureFilename, rgmat[imat].pTextureFilename, cbName);

            iCurOffset += cbName;
        }
    }

    GXASSERT(iCurOffset == sizeof(D3DXMATERIAL) * cmat + cbTotalStringSize);

    *ppbufMaterials = pbufMaterialsOut;
    pbufMaterialsOut = NULL;

e_Exit:
    GXRELEASE(pbufMaterialsOut);
    return hr;
}

HRESULT
MergeMaterialBuffers(LPD3DXBUFFER pbufMat1, DWORD cmat1, LPD3DXBUFFER pbufMat2, DWORD cmat2, LPD3DXBUFFER *ppbufMaterials)
{
    HRESULT hr = S_OK;
    D3DXMATERIAL *rgmatTemp = NULL;
    D3DXMATERIAL *rgmat1;
    D3DXMATERIAL *rgmat2;

    if (pbufMat1 == NULL)
    {
        if (pbufMat2 == NULL)
        {
            *ppbufMaterials = NULL;
        }
        else
        {
            *ppbufMaterials = pbufMat2;
            pbufMat2->AddRef();
        }
    }
    else if (pbufMat2 == NULL)
    {
        *ppbufMaterials = pbufMat1;
        pbufMat1->AddRef();
    }
    else  // both have materials
    {
        rgmat1 = (LPD3DXMATERIAL)pbufMat1->GetBufferPointer();
        rgmat2 = (LPD3DXMATERIAL)pbufMat2->GetBufferPointer();

        // make an array contains the color info and pointers to the original strings
        //   that is the two arrays combined
        rgmatTemp = new D3DXMATERIAL[cmat1 + cmat2];
        if (rgmatTemp == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }

        memcpy(rgmatTemp, rgmat1, sizeof(D3DXMATERIAL) * cmat1);
        memcpy(rgmatTemp + cmat1, rgmat2, sizeof(D3DXMATERIAL) * cmat2);

        // then use the CreateMaterialBuffer call to take and make a buffer out of the "merged" array
        hr = CreateMaterialBuffer(rgmatTemp, cmat1 + cmat2, ppbufMaterials);
        if (FAILED(hr))
            goto e_Exit;
    }

e_Exit:
    delete []rgmatTemp;
    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\mesh\pchmesh.h ===
// templates generate names > 255 chars in debug info
// 4786: identifier was truncated to 'number' characters in the debug information
#pragma warning(disable : 4786)

#include <d3dx8seg.h>
#include <stdio.h>
#include <malloc.h>

#define NOD3D
#define NODSOUND
#include <xtl.h>
#undef  NOD3D
#undef NODSOUND

#include <d3d8.h>
#include "d3dx8p.h"
#include <d3d8types.h>
#include "common.h"
#include "gxcrackfvf.h"

#ifndef HeapValidate
#define HeapValidate
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\mesh\orbitvertex.h ===
const BYTE x_iAllFaces = 0;
const BYTE x_iClockwise = 1;
const BYTE x_iCounterClockwise = 2;

// -------------------------------------------------------------------------------
//  class    COrbitVertexIter
//
//   devnote    used to simplify orbiting a vertex
//
class COrbitVertexIter
{
public:
    COrbitVertexIter(CONST DWORD *rgdwAdjacency, PVOID rgIndices, UINT cbIndexSize)
        :m_iFace(UNUSED32), 
         m_wPoint(UNUSED32), 
         m_iCurFace(UNUSED32), 
         m_rgdwAdjacency(rgdwAdjacency), 
         m_rgIndices(rgIndices), 
         m_cbIndexSize(cbIndexSize),
         m_bClockwise(FALSE), 
         m_bStopOnBoundary(FALSE)
    {
        // used to allow creation on the stack, and then intialization later
    }

    void Init(DWORD iFace, DWORD wPoint, BYTE iWalkType)
    {
        GXASSERT(iWalkType >= 0 && iWalkType <= 2);

        m_iFace = iFace;
        m_wPoint = wPoint;
        m_iCurFace = iFace;
        m_bClockwise = (iWalkType != x_iCounterClockwise);
        m_bStopOnBoundary = (iWalkType != x_iAllFaces);

        // find the next edge to jump to the next triangle
        m_iNextEdge = FindWedge(m_iCurFace, m_wPoint);
        GXASSERT(m_iNextEdge < 3);

        if (!m_bClockwise)
        {
            m_iNextEdge = (m_iNextEdge + 2) % 3;
        }

        m_iCurEdge = m_iNextEdge;
    }

    DWORD FindWedge(DWORD iFace, DWORD dwPoint)
    {
        DWORD *rgdwIndices;
        WORD *rgwIndices;
        DWORD iEdge;

        if (m_cbIndexSize == 2)
        {
            rgwIndices = (WORD*)m_rgIndices;

            if (rgwIndices[iFace*3] == dwPoint)
            {
                iEdge = 0;
            }
            else if (rgwIndices[iFace*3+1] == dwPoint)
            {
                iEdge = 1;
            }
            else
            {
                GXASSERT(rgwIndices[iFace*3+2] == dwPoint);
                iEdge = 2;
            }
        }
        else
        {
            GXASSERT(m_cbIndexSize == 4);

            rgdwIndices = (DWORD*)m_rgIndices;

            if (rgdwIndices[iFace*3] == dwPoint)
            {
                iEdge = 0;
            }
            else if (rgdwIndices[iFace*3+1] == dwPoint)
            {
                iEdge = 1;
            }
            else
            {
                GXASSERT(rgdwIndices[iFace*3+2] == dwPoint);
                iEdge = 2;
            }
        }

        return iEdge;
    }

    BOOL BEndOfList() { return m_iCurFace == UNUSED32; }

    DWORD GetNextFace();
    //void GetNextEdgeFace(UINT_IDX &iEdge, UINT_IDX &iFace);
    BOOL MoveToCCWFace();

    DWORD IGetPointIndex() const { return m_bClockwise ? m_iCurEdge : (m_iCurEdge + 1) % 3; }

private:
    DWORD m_iFace;
    DWORD m_wPoint;

    DWORD m_iCurFace;
    DWORD m_iCurEdge;
    DWORD m_iNextEdge;

    CONST DWORD *m_rgdwAdjacency;
    PVOID m_rgIndices;
    DWORD m_cbIndexSize;

    BOOL m_bClockwise;
    BOOL m_bStopOnBoundary;
};


// -------------------------------------------------------------------------------
//  function    GetNextFace
//
//   devnote    returns the next face moving in the manner set in init/construction
//                  and as a side effect moves to the face beyond that.
//
//   returns    the index of the next face
//
DWORD COrbitVertexIter::GetNextFace()
{
    DWORD iRet;
    DWORD iPrevFace;

    GXASSERT(m_iCurFace != UNUSED32);
    iRet = m_iCurFace;
    m_iCurEdge = m_iNextEdge;

SwitchedDirectionRetry:

    // get the next face 
    iPrevFace = m_iCurFace;
    m_iCurFace = m_rgdwAdjacency[m_iCurFace * 3 + m_iNextEdge];

    
    // check to make sure that we haven't completely gone around the vertex
    if (m_iCurFace != m_iFace)
    {   
        // make sure that we haven't hit a boundary
        if (m_iCurFace != UNUSED32)
        {
            // find the next edge to jump to the next triangle
            if (m_rgdwAdjacency[m_iCurFace * 3] == iPrevFace)
            {
                m_iNextEdge = 0;
            }
            else if (m_rgdwAdjacency[m_iCurFace * 3 + 1] == iPrevFace)
            {
                m_iNextEdge = 1;
            }
            else
            {
                GXASSERT(m_rgdwAdjacency[m_iCurFace * 3 + 2] == iPrevFace);
                m_iNextEdge = 2;
            }
            GXASSERT(m_iNextEdge < 3);

            if (m_bClockwise)
            {
                m_iNextEdge = (m_iNextEdge + 1) % 3;
            }
            // if going counter clockwise, need to go to the other edge containing m_wPointRep;
            else  //if (!m_bClockwise)
            {
                m_iNextEdge = (m_iNextEdge + 2) % 3;
            }
        }
        else  // hit a boundary, either need to restart in the opposite direction, or we hit the end
        {
            // if going clockwise, need to try counter clockwise next
            if (m_bClockwise && !m_bStopOnBoundary)
            {
                m_bClockwise = false;

                m_iCurFace = m_iFace;

                // go back to the original face, and go counter clockwise
                m_iNextEdge = FindWedge(m_iCurFace, m_wPoint);
                GXASSERT(m_iNextEdge < 3);

                m_iNextEdge = (m_iNextEdge + 2) % 3;

				// modify iCurEdge to account for the fact that the direction has changed
				m_iCurEdge = (m_iCurEdge + 2) % 3;

                // now that it is setup to walk counter clockwise from the initial face, retry
                goto SwitchedDirectionRetry;
            }
            // else if counter clockwise, leave m_iCurFace as UNUSED to signify the end
        }
    }
    else  // wrapped around, need to set m_iCurFace to UNUSED to signify EOL
    {
        m_iCurFace = UNUSED32;
    }

    return iRet;
}

// Moves the starting position to be either at iFace if no boundaries, or the farthest
//   counter clockwise possible, so that one walk in the clockwise direction will hit
//   all the triangles in order
BOOL COrbitVertexIter::MoveToCCWFace()
{
    DWORD iPrevFace;
    DWORD iInitialNextEdge;
	BOOL bRet = FALSE;

    // start out at iFace and look for a boundary in the counter clockwise position
    m_iCurFace = m_iFace;

    // find the next edge to jump to the next triangle
    m_iNextEdge = FindWedge(m_iCurFace, m_wPoint);
    iInitialNextEdge = m_iNextEdge;
    GXASSERT(m_iNextEdge < 3);
    m_iNextEdge = (m_iNextEdge + 2) % 3;

    iPrevFace = m_iCurFace;
    do
    {
        // get the next face
        iPrevFace = m_iCurFace;
        m_iCurFace = m_rgdwAdjacency[m_iCurFace * 3 + m_iNextEdge];

        if (m_iCurFace != UNUSED32)
        {
            // find the next edge to jump to the next triangle
            if (m_rgdwAdjacency[m_iCurFace * 3] == iPrevFace)
            {
                m_iNextEdge = 0;
            }
            else if (m_rgdwAdjacency[m_iCurFace * 3 + 1] == iPrevFace)
            {
                m_iNextEdge = 1;
            }
            else
            {
                GXASSERT(m_rgdwAdjacency[m_iCurFace * 3 + 2] == iPrevFace);
                m_iNextEdge = 2;
            }
            GXASSERT(m_iNextEdge < 3);

            m_iNextEdge = (m_iNextEdge + 2) % 3;
        }
    }
    while ((m_iCurFace != m_iFace) && (m_iCurFace != UNUSED32));

    // if m_iCurFace is unused, hit counter clockwise most boundary, so start at the last face before boundary
    if (m_iCurFace == UNUSED32)
    {
        m_iCurFace = iPrevFace;

        m_iNextEdge = (m_iNextEdge + 1) % 3;

        // note: if choosing a new starting face, find the new wedge
        if (m_cbIndexSize == 2)
        {
            m_wPoint = ((WORD*)m_rgIndices)[m_iCurFace*3 + m_iNextEdge];
        }
        else
        {
            GXASSERT(m_cbIndexSize == 4);
            m_wPoint = ((DWORD*)m_rgIndices)[m_iCurFace*3 + m_iNextEdge];
        }

		// a CCW face was found, so return true
		bRet = TRUE;
    }
    else // m_iCurFace == iFace, which is as good a place to start as any
    {
        // Use the edge found before trying to go CCW
        m_iNextEdge = iInitialNextEdge;
    }

    m_bClockwise = TRUE;

    m_iCurEdge = m_iNextEdge;

	m_iFace = m_iCurFace;

	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\mesh\quadric.cpp ===
/*//////////////////////////////////////////////////////////////////////////////
//
// File: bezier.cpp
//
// Copyright (C) 1999 Microsoft Corporation. All Rights Reserved.
//
// @@BEGIN_MSINTERNAL
//
// History:
// -@-          (craigp)    - created 
// -@- 08/26/99 (mikemarr)  - started comment history
//                          - replace gxbasetype.h with gxmathcore.h
// -@- 09/23/99 (mikemarr)  - changed <> to "" on #includes
//
// @@END_MSINTERNAL
//
//////////////////////////////////////////////////////////////////////////////*/
#include "pchmesh.h"
#include "quadric.h"

#include "float.h"

CQuadric::CQuadric(const CQuadric &q)
{
    memcpy(m_el, q.m_el, sizeof(m_el));
}

CQuadric::CQuadric(double a, double b, double c, double d)
{
    Generate(a, b, c, d);
}

void CQuadric::Init()
{
    for(INT i = 0; i < 10; m_el[i++] = 0.0);
}

void CQuadric::Generate(double a, double b, double c, double d)
{
    m_el[0] = a * a;
    m_el[1] = a * b;
    m_el[2] = b * b;
    m_el[3] = a * c;
    m_el[4] = b * c;
    m_el[5] = c * c;
    m_el[6] = a * d;
    m_el[7] = b * d;
    m_el[8] = c * d;
    m_el[9] = d * d;

#ifdef _DEBUG
    for (int i = 0; i < 10; i++)
    {
        GXASSERT(!_isnan(m_el[i]));
    }
#endif
}

CQuadric& CQuadric::operator=(const CQuadric &q)
{
    memcpy(m_el, q.m_el, sizeof(m_el));
    return *this;
}

CQuadric& CQuadric::operator+=(const CQuadric &q)
{
    m_el[0] += q.m_el[0];
    m_el[1] += q.m_el[1];
    m_el[2] += q.m_el[2];
    m_el[3] += q.m_el[3];
    m_el[4] += q.m_el[4];
    m_el[5] += q.m_el[5];
    m_el[6] += q.m_el[6];
    m_el[7] += q.m_el[7];
    m_el[8] += q.m_el[8];
    m_el[9] += q.m_el[9];
    return *this;
}

void CQuadric::CalculatePosition(D3DXVECTOR3 &vNewPos, D3DXVECTOR3 &vValidPos)
{
    double idDenom = (e(0, 0) * e(1, 2) * e(1, 2) -
                       e(0, 0) * e(1, 1) * e(2, 2) +
                       e(0, 1) * e(0, 1) * e(2, 2) -
                       2.0 * e(0, 1) * e(1, 2) * e(0, 2) +
                       e(1, 1) * e(0, 2) * e(0, 2));

    if (idDenom == 0)
    {
        vNewPos = vValidPos;
    }
    else
    {
        double id = 1.0 / idDenom;


        vNewPos.x = float((e(0, 1) * e(1, 2) * e(2, 3) -
                        e(0, 1) * e(1, 3) * e(2, 2) -
                        e(1, 1) * e(0, 2) * e(2, 3) +
                        e(1, 1) * e(0, 3) * e(2, 2) +
                        e(1, 2) * e(0, 2) * e(1, 3) -
                        e(0, 3) * e(1, 2) * e(1, 2)) * id);

        vNewPos.y = float((e(0, 0) * e(1, 3) * e(2, 2) -
                        e(0, 0) * e(1, 2) * e(2, 3) +
                        e(0, 1) * e(0, 2) * e(2, 3) -
                        e(0, 1) * e(0, 3) * e(2, 2) -
                        e(0, 2) * e(0, 2) * e(1, 3) +
                        e(0, 2) * e(0, 3) * e(1, 2)) * id);


        vNewPos.z = float((e(0, 0) * e(1, 1) * e(2, 3) -
                        e(0, 1) * e(0, 1) * e(2, 3) -
                        e(0, 0) * e(1, 3) * e(1, 2) +
                        e(0, 1) * e(0, 3) * e(1, 2) + 
                        e(0, 2) * e(0, 1) * e(1, 3) -
                        e(0, 2) * e(0, 3) * e(1, 1)) * id);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\mesh\quadric.h ===
#ifndef QUADRIC_INCLUDED
#define QUADRIC_INCLUDED

// UNDONE documen e vs element, and rename

#if 0 && defined(__WIN32)
inline bool isnanf(float f) {
    return _isnan(f);
}
#else
// On SGI, adapted from <ieeefp.h>
inline bool isnanf(float f) {
    float f2=f;
    return (((*(unsigned *)&(f2) & 0x7f800000)==0x7f800000)&& \
            ((*(unsigned *)&(f2) & 0x007fffff)!=0x00000000) );
}
#endif

class CQuadric {

    double m_el[10];

public:

    CQuadric() {}
    CQuadric(const CQuadric &q);
    CQuadric(double a, double b, double c, double d);
    ~CQuadric() {}

    void Init();
    void Generate(double a, double b, double c, double d);
    inline void element(INT row, INT col, double el);
    inline void e(INT row, INT col, double el);

    inline float CalculateCost(D3DXVECTOR3 &vPos);
    void CalculatePosition(D3DXVECTOR3 &vNewPos, D3DXVECTOR3 &vValidPos);

    CQuadric& operator=(const CQuadric &q);
    CQuadric& operator+=(const CQuadric &q);

    inline double element(INT row, INT col) const;
    inline double e(INT row, INT col) const;
};

void CQuadric::element(INT row, INT col, double el)
{
    if(col <= row)
        m_el[(row * (row + 1)) / 2 + col] = el;
    else
        m_el[(col * (col + 1)) / 2 + row] = el;
}

double CQuadric::element(INT row, INT col) const
{
    return (col <= row) ? m_el[(row * (row + 1)) / 2 + col] : m_el[(col * (col + 1)) / 2 + row];
}

void CQuadric::e(INT row, INT col, double el)
{
    m_el[(col * (col + 1)) / 2 + row] = el;
}

double CQuadric::e(INT row, INT col) const
{
    return m_el[(col * (col + 1)) / 2 + row];
}

float CQuadric::CalculateCost(D3DXVECTOR3 &vPos)
{
	float fRet = (float)((e(0, 0) * vPos.x + e(0, 1) * vPos.y + e(0, 2) * vPos.z + e(0, 3)) * vPos.x +
           (e(0, 1) * vPos.x + e(1, 1) * vPos.y + e(1, 2) * vPos.z + e(1, 3)) * vPos.y +
           (e(0, 2) * vPos.x + e(1, 2) * vPos.y + e(2, 2) * vPos.z + e(2, 3)) * vPos.z +
           (e(0, 3) * vPos.x + e(1, 3) * vPos.y + e(2, 3) * vPos.z + e(3, 3)));

	//GXASSERT(fRet > -1.0e-4 && !isnanf(fRet));
	return fRet;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\mesh\savemesh.cpp ===
/*//////////////////////////////////////////////////////////////////////////////
//
// File: savemesh.cpp
//
// Copyright (C) 1999 Microsoft Corporation. All Rights Reserved.
//
// @@BEGIN_MSINTERNAL
//
// History:
// -@-          (craigp)    - created
//
// @@END_MSINTERNAL
//
//////////////////////////////////////////////////////////////////////////////*/

#if 0
#include "pchmesh.h"

#define D3DRM_XTEMPLATES _D3DX2_D3DRM_XTEMPLATES
#include "rmxfguid.h"
#include "rmxftmpl.h"  
#include "xskinexptemplates.h"
#endif

#define WRITE_DWORD(pbCur, dword) {*(DWORD*)pbCur = dword; pbCur += sizeof(DWORD); }
#define WRITE_FLOAT(pbCur, value) {*(float*)pbCur = value; pbCur += sizeof(float); }
#define WRITE_VECTOR3(pbCur, vPos) {*(D3DXVECTOR3*)pbCur = vPos; pbCur += sizeof(D3DXVECTOR3); }
#define WRITE_RGBA(pbCur, vPos) {*(D3DCOLORVALUE*)pbCur = vPos; pbCur += sizeof(D3DCOLORVALUE); }
#define WRITE_RGB(pbCur, vColor) { WRITE_FLOAT(pbCur, vColor.r); WRITE_FLOAT(pbCur, vColor.g); WRITE_FLOAT(pbCur, vColor.b);}

HRESULT
AddNormals
    (
    LPDIRECTXFILESAVEOBJECT pxofsave,
    PBYTE pbVertices,
    DWORD cVertices,
    PWORD rgwFaces,
    PDWORD rgdwFaces,
    DWORD cFaces,
    DXCrackFVF &cfvf,
    LPDIRECTXFILEDATA pParent
    )
{
    HRESULT        hr = S_OK;
    LPDIRECTXFILEDATA pDataObject = NULL;
    LPBYTE         pbData;
    LPBYTE         pbCur = NULL;
    DWORD          cbSize;
    PWORD          pwFace;
    PDWORD         pdwFace;
    DWORD          iFace;
    DWORD          iVertex;

    GXASSERT(pbVertices != NULL);
    GXASSERT(rgwFaces != NULL);
    GXASSERT(pParent != NULL);

    cbSize = sizeof(DWORD) // nNormals
             + 3*sizeof(float)*cVertices // normals
             + sizeof(DWORD) // nFaces
             + cFaces* // MeshFace array
                (sizeof(DWORD) //nFaceVertexIndices (number of normal indices)
                 + 3*sizeof(DWORD)); // faceVertexIndices (normal indices)

    pbCur = pbData = new BYTE[cbSize];
    if (pbData == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    // nNormals
    WRITE_DWORD(pbCur, cVertices);

    // normals
    for (iVertex = 0; iVertex < cVertices; iVertex++)
    {
        WRITE_VECTOR3(pbCur, *cfvf.PvGetNormal(cfvf.GetArrayElem(pbVertices, iVertex)));
    }

    // nFaces
    WRITE_DWORD(pbCur, cFaces);

    if (rgdwFaces != NULL)
    {
        // MeshFace array
        for( iFace = 0; iFace < cFaces; iFace++ )
        {
            WRITE_DWORD(pbCur, 3); // nFaceVertexIndices (number of normal indices)

            pdwFace = rgdwFaces + iFace * 3;
            WRITE_DWORD(pbCur, pdwFace[0]);
            WRITE_DWORD(pbCur, pdwFace[1]);
            WRITE_DWORD(pbCur, pdwFace[2]);
        }
    }
    else
    {
        // MeshFace array
        for( iFace = 0; iFace < cFaces; iFace++ )
        {
            WRITE_DWORD(pbCur, 3); // nFaceVertexIndices (number of normal indices)

            pwFace = rgwFaces + iFace * 3;
            WRITE_DWORD(pbCur, pwFace[0]);
            WRITE_DWORD(pbCur, pwFace[1]);
            WRITE_DWORD(pbCur, pwFace[2]);
        }
    }

    hr = pxofsave->CreateDataObject(TID_D3DRMMeshNormals,
                                    NULL,
                                    NULL,
                                    cbSize,
                                    pbData,
                                    &pDataObject
                                    );
    if (FAILED(hr))
    {
        OutputDebugString(L"Failed to create x file data object!");
        goto e_Exit;
    }

    hr = pParent->AddDataObject(pDataObject);
    if (FAILED(hr))
    {
        OutputDebugString(L"Failed to add x file data object!");
        goto e_Exit;
    }

    // falling through
e_Exit:
    GXRELEASE(pDataObject);
    delete []pbData;
    return hr;
}

HRESULT
AddMaterial
    (
    LPDIRECTXFILESAVEOBJECT pxofsave,
    CONST D3DXMATERIAL *pMaterial,
    DWORD xFormat,
    LPDIRECTXFILEDATA pParent
    )
{
    LPDIRECTXFILEDATA pDataObject = NULL;
    LPDIRECTXFILEDATA pTextureObject = NULL;
    LPBYTE pbData = NULL;
    DWORD          cbSize;
    LPBYTE pbCur = NULL;
    HRESULT    hr = S_OK;
    char *szTextureFilename = NULL;
    DWORD cchFilename;

    GXASSERT(pMaterial != NULL);
    GXASSERT(pxofsave != NULL);

    cbSize = 4*sizeof(float) // colorRGBA
             + sizeof(float) //power
             + 3*sizeof(float) //specularColor
             + 3*sizeof(float); //emissiveColor

    pbCur = pbData = new BYTE[cbSize];
    if (pbData == NULL)
    {
        OutputDebugString(L"Out of memory!");
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    //RGBA
    WRITE_RGBA(pbCur, pMaterial->MatD3D.Diffuse);
    //power
    WRITE_FLOAT(pbCur, pMaterial->MatD3D.Power);
    // specular color
    WRITE_RGB(pbCur, pMaterial->MatD3D.Specular);
    // emissiveColor (ambient in 3DS assumed.. is this valid?)
    WRITE_RGB(pbCur, pMaterial->MatD3D.Ambient);

    hr = pxofsave->CreateDataObject(TID_D3DRMMaterial,
                                    NULL,
                                    NULL,
                                    cbSize,
                                    pbData,
                                    &pDataObject
                                    );
    if (FAILED(hr))
    {
        OutputDebugString(L"Failed to create x file data object!");
        goto e_Exit;
    }

    hr = pParent->AddDataObject(pDataObject);
    if (FAILED(hr))
    {
        OutputDebugString(L"Failed to add x file data object!");
        goto e_Exit;
    }

    // if text format, insert '\\', else just add texture file name
    if (pMaterial->pTextureFilename != NULL)
    {
        char *pchCur;
        char *pchDest;
        DWORD cBackslashes;

        cchFilename = strlen(pMaterial->pTextureFilename) + 1;
        if (xFormat == DXFILEFORMAT_TEXT)
        {
            pchCur = pMaterial->pTextureFilename;
            cBackslashes = 0;
            while (*pchCur != '\0')
            {
                if (*pchCur == '\\')
                    cBackslashes++;

                pchCur += 1;
            }

            szTextureFilename = new char[cchFilename + cBackslashes];
            if (szTextureFilename == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto e_Exit;
            }

            pchDest = szTextureFilename;
            pchCur = pMaterial->pTextureFilename;
            while (*pchCur != '\0')
            {
                *pchDest = *pchCur;

                if (*pchCur == '\\')
                {
                    pchDest += 1;
                    *pchDest = *pchCur;
                }

                pchCur += 1;
                pchDest += 1;
            }
            *pchDest = '\0';
        }
        else  // binary, just copy the filename... technically doesn't need to be copied, but cleans up exit code
        {
            szTextureFilename = new char[cchFilename];
            if (szTextureFilename == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto e_Exit;
            }
            memcpy(szTextureFilename, pMaterial->pTextureFilename, sizeof(char) * cchFilename);
        }

        cbSize = sizeof(TCHAR**);

        hr = pxofsave->CreateDataObject(TID_D3DRMTextureFilename,
                                        NULL,
                                        NULL,
                                        cbSize,
                                        &szTextureFilename,
                                        &pTextureObject
                                        );
        if (FAILED(hr))
        {
            OutputDebugString(L"Failed to create x file data object!");
            goto e_Exit;
        }

        hr = pDataObject->AddDataObject(pTextureObject);
        if (FAILED(hr))
        {
            OutputDebugString(L"Failed to add x file data object!");
            goto e_Exit;
        }
    }


    // falling through
e_Exit:
    // UNDONE UNDONE - need to figure how how to delete the texturefilename later
    //delete []szTextureFilename;
    GXRELEASE(pTextureObject);
    GXRELEASE(pDataObject);
    delete []pbData;
    return hr;
}

HRESULT AddTextureCoordinates
    (
    LPDIRECTXFILESAVEOBJECT pxofsave,
    PBYTE pbVertices,
    DWORD cVertices,
    DXCrackFVF &cfvf,
    LPDIRECTXFILEDATA pParent
    )
{
    LPDIRECTXFILEDATA pDataObject = NULL;
    LPBYTE pbData = NULL;
    DWORD          cbSize;
    LPBYTE pbCur = NULL;
    HRESULT    hr = S_OK;
    DWORD iVertex;
    D3DXVECTOR2 *pvTexPos;

    GXASSERT(pxofsave != NULL);
    GXASSERT(pbVertices != NULL);
    GXASSERT(pParent != NULL);
    GXASSERT(cVertices > 0);

    cbSize = sizeof(DWORD) //nTextureCoords
             + cVertices * 2 * sizeof(float); //texture coords

    pbCur = pbData = new BYTE[cbSize];
    if (pbData == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    WRITE_DWORD(pbCur, cVertices); //nTextureCoords

    for (iVertex = 0; iVertex < cVertices; iVertex++)
    {
        pvTexPos = cfvf.PuvGetTex1(cfvf.GetArrayElem(pbVertices, iVertex));

        WRITE_FLOAT(pbCur, pvTexPos->x); //u
        WRITE_FLOAT(pbCur, pvTexPos->y); //v
    }

    hr = pxofsave->CreateDataObject(TID_D3DRMMeshTextureCoords,
                                    NULL,
                                    NULL,
                                    cbSize,
                                    pbData,
                                    &pDataObject
                                    );
    if (FAILED(hr))
    {
        OutputDebugString(L"Failed to create x file data object!");
        goto e_Exit;
    }

    hr = pParent->AddDataObject(pDataObject);
    if (FAILED(hr))
    {
        OutputDebugString(L"Failed to add x file data object!");
        goto e_Exit;
    }

    // falling through
e_Exit:
    GXRELEASE(pDataObject);
    delete []pbData;

    return hr;
}

HRESULT AddVertexColors
    (
    LPDIRECTXFILESAVEOBJECT pxofsave,
    PBYTE pbVertices,
    DWORD cVertices,
    DXCrackFVF &cfvf,
    LPDIRECTXFILEDATA pParent
    )
{
    LPDIRECTXFILEDATA pDataObject = NULL;
    LPBYTE pbData = NULL;
    DWORD cbSize;
    LPBYTE pbCur = NULL;
    HRESULT    hr = S_OK;
    DWORD iVertex;
    D3DXCOLOR color;

    GXASSERT(pxofsave != NULL);
    GXASSERT(pbVertices != NULL);
    GXASSERT(pParent != NULL);
    GXASSERT(cVertices > 0);

    cbSize = sizeof(DWORD) //cVertexColorEntries
             + cVertices * 5 * sizeof(float); //indexed color entries(index + RGBA)

    pbCur = pbData = new BYTE[cbSize];
    if (pbData == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    WRITE_DWORD(pbCur, cVertices); //cVertexColorEntries

    for (iVertex = 0; iVertex < cVertices; iVertex++)
    {
        color = D3DXCOLOR(cfvf.ColorGetDiffuse(cfvf.GetArrayElem(pbVertices, iVertex)));

        WRITE_DWORD(pbCur, iVertex); // index
        WRITE_FLOAT(pbCur, color.r); // r
        WRITE_FLOAT(pbCur, color.g); // g
        WRITE_FLOAT(pbCur, color.b); // b
        WRITE_FLOAT(pbCur, color.a); // a
    }

    hr = pxofsave->CreateDataObject(TID_D3DRMMeshVertexColors,
                                    NULL,
                                    NULL,
                                    cbSize,
                                    pbData,
                                    &pDataObject
                                    );
    if (FAILED(hr))
    {
        OutputDebugString(L"Failed to create x file data object!");
        goto e_Exit;
    }

    hr = pParent->AddDataObject(pDataObject);
    if (FAILED(hr))
    {
        OutputDebugString(L"Failed to add x file data object!");
        goto e_Exit;
    }

    // falling through
e_Exit:
    GXRELEASE(pDataObject);
    delete []pbData;

    return hr;
}

HRESULT AddVertexDuplicationIndices
    (
    LPDIRECTXFILESAVEOBJECT pxofsave,
    LPD3DXMESH ptmMesh,
    CONST DWORD *rgdwAdjacency,
    LPDIRECTXFILEDATA pParent
    )
{
    LPDIRECTXFILEDATA pDataObject = NULL;
    PBYTE          pbData = NULL;
    PBYTE          pbCur = NULL;
    DWORD          cbSize;
    DWORD          cVertices;
    DWORD          cVerticesBeforeDuplication;
    HRESULT        hr = S_OK;
    DWORD          *rgiPointRep;
    DWORD          iVertex;

    GXASSERT(pxofsave != NULL);
    GXASSERT(ptmMesh != NULL);
    GXASSERT(pParent != NULL);

    cVertices = ptmMesh->GetNumVertices();
    cbSize = sizeof(DWORD) //nIndices
             + sizeof(DWORD) //nVerticesBeforeDuplication
             + cVertices*sizeof(DWORD); // array of indices

    pbCur = pbData = new BYTE[cbSize];
    if (pbData == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    // the point reps go immediately after the two counts
    rgiPointRep = (DWORD*)(pbCur + sizeof(DWORD) * 2);

    // compute the point reps directly into the buffer
    hr = ptmMesh->ConvertAdjacencyToPointReps(rgdwAdjacency, rgiPointRep);
    if (FAILED(hr))
        goto e_Exit;

    // how many "logical" vertices are there
    cVerticesBeforeDuplication = 0;
    for (iVertex = 0; iVertex < cVertices; iVertex++)
    {
        if (rgiPointRep[iVertex] == iVertex)
        {
            cVerticesBeforeDuplication += 1;
        }
    }

    // if the point rep array is "identity", then there is no reason to save it
    if (cVerticesBeforeDuplication == cVertices)
    {
        // skip saving an identity point rep array
        goto e_Exit;
    }

    WRITE_DWORD(pbCur, cVertices) // nIndices;
    WRITE_DWORD(pbCur, cVerticesBeforeDuplication) // nVerticesBeforeDuplication

    hr = pxofsave->CreateDataObject(DXFILEOBJ_VertexDuplicationIndices,
                                    NULL,
                                    NULL,
                                    cbSize,
                                    pbData,
                                    &pDataObject
                                    );
    if (FAILED(hr))
    {
        OutputDebugString(L"Failed to create x file data object!");
        goto e_Exit;
    }

    hr = pParent->AddDataObject(pDataObject);
    if (FAILED(hr))
    {
        OutputDebugString(L"Failed to add x file data object!");
        goto e_Exit;
    }

    // falling through
e_Exit:
    GXRELEASE(pDataObject);

    delete []pbData;
    return hr;
}

HRESULT AddFaceMaterials
    (
    LPDIRECTXFILESAVEOBJECT pxofsave,
    PDWORD rgiAttribIds,
    DWORD cFaces,
    CONST D3DXMATERIAL *rgMaterials,
    DWORD cMaterials,
    DWORD xFormat,
    LPDIRECTXFILEDATA pParent
    )
{
    HRESULT     hr = S_OK;
    LPDIRECTXFILEDATA pDataObject = NULL;
    LPBYTE      pbData = NULL;
    LPBYTE      pbCur = NULL;
    DWORD       cbSize;
    DWORD       iFace;
    //DWORD       iVertex;
    DWORD       iMaterial;

    GXASSERT(pParent != NULL);
    GXASSERT(rgMaterials != NULL);
    GXASSERT(pxofsave != NULL);
    GXASSERT(rgiAttribIds != NULL);
    GXASSERT(cFaces > 0 && cMaterials > 0);

    cbSize = sizeof(DWORD) // nMaterials
                + sizeof(DWORD) // nFaceIndexes
                + cFaces * sizeof(DWORD); // face indexes

    pbCur = pbData = new BYTE[cbSize];
    if (pbData == NULL)
    {
        return E_OUTOFMEMORY;
    }

    WRITE_DWORD(pbCur, cMaterials); // nMaterials

    // face indexes
    WRITE_DWORD(pbCur, cFaces); // nFaceIndexes
    for( iFace = 0; iFace < cFaces; iFace++ )
    {
        WRITE_DWORD(pbCur, rgiAttribIds[iFace]);
    }

    hr = pxofsave->CreateDataObject(TID_D3DRMMeshMaterialList,
                                    NULL,
                                    NULL,
                                    cbSize,
                                    pbData,
                                    &pDataObject
                                    );
    if (FAILED(hr))
    {
        OutputDebugString(L"Failed to create x file data object!");
        goto e_Exit;
    }

    hr = pParent->AddDataObject(pDataObject);
    if (FAILED(hr))
    {
        OutputDebugString(L"Failed to add x file data object!");
        goto e_Exit;
    }

    for (iMaterial = 0; iMaterial < cMaterials; iMaterial++)
    {
        hr = AddMaterial(pxofsave, &rgMaterials[iMaterial], xFormat, pDataObject);
        if (FAILED(hr))
            goto e_Exit;
    }

    // falling through
e_Exit:
    GXRELEASE(pDataObject);

    delete []pbData;
    return hr;
}

HRESULT AddOtherFVFData
    (
    LPDIRECTXFILESAVEOBJECT pxofsave,
    PBYTE pbPoints,
    DWORD cVertices,
    DWORD dwFVF,
    DXCrackFVF &cfvfOrig,
    LPDIRECTXFILEDATA pParent
    )
{
    HRESULT     hr = S_OK;
    LPDIRECTXFILEDATA pDataObject = NULL;
    LPBYTE      pbData = NULL;
    LPBYTE      pbCur = NULL;
    DWORD       cbSize;
    DWORD       iVertex;
    DWORD       cbBytesPerVertex;
    DXCrackFVF  cfvf(D3DFVF_XYZ);
    DWORD       iWeight;
    DWORD       iTexCoord;
    DWORD       dwFVFOther;
    PBYTE       pbCurVertex;
    BOOL        bCopyTex1;
    DWORD       rgdwTexCoordSizes[8];

    GXASSERT(pxofsave != NULL);
    GXASSERT(pbPoints != NULL);
    GXASSERT(cVertices > 0);
    GXASSERT(pParent != NULL);

    dwFVFOther = dwFVF;

    // remove data added other places in the xfile
    dwFVFOther &= ~D3DFVF_NORMAL;
    dwFVFOther &= ~D3DFVF_DIFFUSE;

    // remove the texture if it is 2d
    bCopyTex1 = cfvfOrig.BTex1();
    if (cfvfOrig.BTex1() && (cfvfOrig.CbTexCoordSize(0) == 8))
    {
        dwFVFOther -= D3DFVF_TEX1;
        bCopyTex1 = FALSE;
    }
    cfvfOrig.GetTexCoordSizes(rgdwTexCoordSizes);

    cfvf = DXCrackFVF(dwFVFOther);

    // even though the position is specified by the FVF, it is not stored there
    cbBytesPerVertex = cfvf.m_cBytesPerVertex - 12;

    // if nothing left, skip adding this structure
    if (cbBytesPerVertex == 0)
    {
        goto e_Exit;
    }

    // had better be a multiple of 4
    if (cbBytesPerVertex % 4 != 0)
    {
        hr = D3DERR_INVALIDCALL;
        goto e_Exit;
    }

    cbSize = sizeof(DWORD) // nMaterials
                + sizeof(DWORD) // nFaceIndexes
                + cVertices * cbBytesPerVertex; // face indexes

    pbCur = pbData = new BYTE[cbSize];
    if (pbData == NULL)
    {
        return E_OUTOFMEMORY;
    }

    WRITE_DWORD(pbCur, dwFVFOther);
    WRITE_DWORD(pbCur, cVertices * cbBytesPerVertex / 4); // nFaceIndexes
    pbCurVertex = pbPoints;
    for( iVertex = 0; iVertex < cVertices; iVertex++ )
    {
        // skip position
        pbCurVertex += sizeof(D3DXVECTOR3);

        for (iWeight = 0; iWeight < cfvfOrig.CWeights(); iWeight++)
        {
            WRITE_DWORD(pbCur, *(DWORD*)pbCurVertex);
            pbCurVertex += sizeof(DWORD);
        }

        if (cfvfOrig.BNormal())
        {
            pbCurVertex += sizeof(D3DXVECTOR3);
        }

        if (cfvfOrig.BDiffuse())
        {
            if (cfvf.BDiffuse())
                WRITE_DWORD(pbCur, *(DWORD*)pbCurVertex);

            pbCurVertex += sizeof(DWORD);
        }

        if (cfvfOrig.BSpecular())
        {
            WRITE_DWORD(pbCur, *(DWORD*)pbCurVertex);
            pbCurVertex += sizeof(DWORD);
        }

        // first either skip or copy the first texture coordinate
        if (bCopyTex1)
        {
            memcpy(pbCur, pbCurVertex, rgdwTexCoordSizes[0]);
            pbCur += rgdwTexCoordSizes[0];
            pbCurVertex += rgdwTexCoordSizes[0];
        }
        else
        {
            pbCurVertex += rgdwTexCoordSizes[0];
        }

        // next copy the other texture coordinates
        if (cfvfOrig.CTexCoords() > 1)
        {
            for (iTexCoord = 1; iTexCoord < cfvfOrig.CTexCoords(); iTexCoord++)
            {
                memcpy(pbCur, pbCurVertex, rgdwTexCoordSizes[iTexCoord]);
                pbCur += rgdwTexCoordSizes[iTexCoord];
                pbCurVertex += rgdwTexCoordSizes[iTexCoord];
            }
        }
    }

    hr = pxofsave->CreateDataObject(DXFILEOBJ_FVFData,
                                    NULL,
                                    NULL,
                                    cbSize,
                                    pbData,
                                    &pDataObject
                                    );
    if (FAILED(hr))
    {
        OutputDebugString(L"Failed to create x file data object!");
        goto e_Exit;
    }

    hr = pParent->AddDataObject(pDataObject);
    if (FAILED(hr))
    {
        OutputDebugString(L"Failed to add x file data object!");
        goto e_Exit;
    }

    // falling through
e_Exit:
    GXRELEASE(pDataObject);

    delete []pbData;
    return hr;
}

const GUID* x_rgTemplateIds[] = {&DXFILEOBJ_VertexDuplicationIndices, &DXFILEOBJ_FVFData};
const GUID* x_rgPMTemplateIds[] = {&DXFILEOBJ_PMAttributeRange, &DXFILEOBJ_PMVSplitRecord, &DXFILEOBJ_PMInfo};

// implements mesh saving with pm data
//
HRESULT WINAPI D3DXSaveMeshToXEx
    (
    char *szFilename,
    LPD3DXMESH pMesh,
    CONST DWORD *rgdwAdjacency,
    CONST LPD3DXMATERIAL rgMaterials,
    DWORD cMaterials,
    DWORD xFormat,
    PBYTE pbPMData,
    DWORD cbPMData
    )
{
#if 1
    return E_NOTIMPL;
#else
    HRESULT hr = S_OK;

    DWORD cFaces;
    DWORD cVertices;
    DWORD iVertex;
    DWORD iFace;
    PBYTE pbPoints = NULL;
    PBYTE pbPoint;
    LPDIRECT3DVERTEXBUFFER8 pVertexBuffer = NULL;
    UINT16 *rgwFaces = NULL;
    DWORD *rgdwFaces = NULL;
    LPDIRECT3DINDEXBUFFER8 pIndexBuffer = NULL;
    LPDIRECTXFILEDATA pDataObject = NULL;
    LPDIRECTXFILEDATA pPMDataObject = NULL;
    LPDIRECTXFILE pxofapi = NULL;
    LPDIRECTXFILESAVEOBJECT pxofsave = NULL;
    PBYTE pbCur;
    PBYTE pbData = NULL;
    DWORD cbSize;
    DWORD *rgiAttribIds = NULL;
    DXCrackFVF cfvf(D3DFVF_XYZ);
    HINSTANCE hXof;
    LPDIRECTXFILECREATE pfnDirectXFileCreate;


    if ((pMesh == NULL) || ((rgMaterials == NULL) && (cMaterials > 0)))
    {
        hr = D3DERR_INVALIDCALL;
    }

    hr = pMesh->GetVertexBuffer(&pVertexBuffer);
    if (FAILED(hr))
        goto e_Exit;

    hr = pVertexBuffer->Lock(0,0, &pbPoints, 0 );
    if (FAILED(hr))
        goto e_Exit;

    hr = pMesh->GetIndexBuffer(&pIndexBuffer);
    if (FAILED(hr))
        goto e_Exit;

    hr = pMesh->LockAttributeBuffer(D3DLOCK_READONLY, &rgiAttribIds);
    if (FAILED(hr))
        goto e_Exit;

    hr = pIndexBuffer->Lock(0,0, (PBYTE*)&rgwFaces, 0 );
    if (FAILED(hr))
        goto e_Exit;

    if (pMesh->GetOptions() & D3DXMESH_32BIT)
    {
        rgdwFaces = (DWORD*)rgwFaces;
    }

    cVertices = pMesh->GetNumVertices();
    cFaces = pMesh->GetNumFaces();
    cbSize = sizeof(DWORD) // nVertices
             + cVertices*sizeof(float)*3 // vertices
             + sizeof(DWORD) // nFaces
             + cFaces*(sizeof(DWORD) /*nFaceVertexIndices*/
                            + sizeof(DWORD)*3 /*faceVertexIndices*/); // faces

    cfvf = DXCrackFVF(pMesh->GetFVF());

    pbCur = pbData = new BYTE[cbSize];
    if( NULL == pbData )
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;;
    }

    // write cVertices
    WRITE_DWORD(pbCur, cVertices);

    for (iVertex = 0; iVertex < cVertices; iVertex++)
    {
        pbPoint = cfvf.GetArrayElem(pbPoints, iVertex);
        WRITE_VECTOR3(pbCur, *cfvf.PvGetPosition(pbPoint));
    }

    // write cFaces
    WRITE_DWORD(pbCur, cFaces);

    if (rgdwFaces == NULL)
    {
        for (iFace = 0; iFace < cFaces; iFace++)
        {
            WRITE_DWORD(pbCur, 3);

            WRITE_DWORD(pbCur, (DWORD)rgwFaces[iFace * 3 + 0]);
            WRITE_DWORD(pbCur, (DWORD)rgwFaces[iFace * 3 + 1]);
            WRITE_DWORD(pbCur, (DWORD)rgwFaces[iFace * 3 + 2]);
        }
    }
    else
    {
        for (iFace = 0; iFace < cFaces; iFace++)
        {
            WRITE_DWORD(pbCur, 3);

            WRITE_DWORD(pbCur, rgdwFaces[iFace * 3 + 0]);
            WRITE_DWORD(pbCur, rgdwFaces[iFace * 3 + 1]);
            WRITE_DWORD(pbCur, rgdwFaces[iFace * 3 + 2]);
        }
    }

    // Create Xfile parser
    if(!(hXof = (HINSTANCE) GetModuleHandle("d3dxof.dll")) &&
       !(hXof = (HINSTANCE) LoadLibrary("d3dxof.dll")))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto e_Exit;
    }

    if(!(pfnDirectXFileCreate = (LPDIRECTXFILECREATE) GetProcAddress(hXof, "DirectXFileCreate")))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto e_Exit;
    }

    hr = pfnDirectXFileCreate(&pxofapi);
    if (FAILED(hr))
        goto e_Exit;

    // Register templates for d3drm.
    hr = pxofapi->RegisterTemplates((LPVOID)D3DRM_XTEMPLATES,
                                    D3DRM_XTEMPLATE_BYTES);
    if (FAILED(hr))
        goto e_Exit;

    hr = pxofapi->RegisterTemplates((LPVOID)XSKINEXP_TEMPLATES,
                                    strlen(XSKINEXP_TEMPLATES));
    if (FAILED(hr))
        goto e_Exit;

    hr = pxofapi->RegisterTemplates((LPVOID)XEXTENSIONS_TEMPLATES,
                                    strlen(XEXTENSIONS_TEMPLATES));
    if (FAILED(hr))
        goto e_Exit;

    hr = pxofapi->CreateSaveObject(szFilename,    // filename
                                   xFormat,  // binary or text
                                   &pxofsave);
    if (FAILED(hr))
        goto e_Exit;

    hr = pxofsave->SaveTemplates(2, x_rgTemplateIds);
    if (FAILED(hr))
        goto e_Exit;

    if (pbPMData != NULL)
    {
        hr = pxofsave->SaveTemplates(3, x_rgPMTemplateIds);
        if (FAILED(hr))
            goto e_Exit;
    }

    hr = pxofsave->CreateDataObject(TID_D3DRMMesh,
                                    NULL,
                                    NULL,
                                    cbSize,
                                    pbData,
                                    &pDataObject
                                    );
    if (FAILED(hr))
        goto e_Exit;

    if (cfvf.BNormal())
    {
        hr = AddNormals(pxofsave, pbPoints, cVertices, rgwFaces, rgdwFaces, cFaces, cfvf, pDataObject);
        if (FAILED(hr))
            goto e_Exit;
    }

    pIndexBuffer->Unlock();
    rgwFaces = NULL;

    // if there is a tex1 that has a sizeof 2 floats, then output it here, 
    //    otherwise it will go in the other fvf data section
    if (cfvf.BTex1() && (cfvf.CbTexCoordSize(0) == 8))
    {
        hr = AddTextureCoordinates(pxofsave, pbPoints, cVertices, cfvf, pDataObject);
        if (FAILED(hr))
            goto e_Exit;
    }

    if (cfvf.BDiffuse())
    {
        hr = AddVertexColors(pxofsave, pbPoints, cVertices, cfvf, pDataObject);
        if (FAILED(hr))
            goto e_Exit;
    }

    if (cMaterials > 0)
    {
        hr = AddFaceMaterials(pxofsave, rgiAttribIds, cFaces, rgMaterials, cMaterials, xFormat, pDataObject);
        if (FAILED(hr))
            goto e_Exit;
    }

    // add adjacency info if present
    if (rgdwAdjacency != NULL)
    {
        hr = AddVertexDuplicationIndices(pxofsave, pMesh, rgdwAdjacency, pDataObject);
        if (FAILED(hr))
            goto e_Exit;
    }

    hr = AddOtherFVFData(pxofsave, pbPoints, cVertices, pMesh->GetFVF(), cfvf, pDataObject);
    if (FAILED(hr))
        goto e_Exit;

    // if PM data provided, save it in a PMInfo group
    if (pbPMData != NULL)
    {
        GXASSERT(cbPMData > 0);

        hr = pxofsave->CreateDataObject(DXFILEOBJ_PMInfo,
                                        NULL,
                                        NULL,
                                        cbPMData,
                                        pbPMData,
                                        &pPMDataObject
                                        );
        if (FAILED(hr))
            goto e_Exit;

        hr = pDataObject->AddDataObject(pPMDataObject);
        if (FAILED(hr))
        {
            goto e_Exit;
        }
    }

    hr = pxofsave->SaveData(pDataObject);
    if (FAILED(hr))
        goto e_Exit;

e_Exit:
    if (pbPoints != NULL)
    {
        GXASSERT(pVertexBuffer != NULL);
        pVertexBuffer->Unlock();
    }
    GXRELEASE(pVertexBuffer);

    if (rgwFaces != NULL)
    {
        GXASSERT(pIndexBuffer != NULL);
        pIndexBuffer->Unlock();
    }
    GXRELEASE(pIndexBuffer);

    if (rgiAttribIds != NULL)
    {
        pMesh->UnlockAttributeBuffer();
    }

    delete []pbData;
    GXRELEASE(pDataObject);
    GXRELEASE(pPMDataObject);
    GXRELEASE(pxofapi);
    GXRELEASE(pxofsave);

    return hr;
#endif
}

// fall through to the extended save mesh, used to combine PM save and normal save
HRESULT WINAPI D3DXSaveMeshToX
    (
    char *szFilename,
    LPD3DXMESH pMesh,
    CONST DWORD *rgdwAdjacency,
    CONST LPD3DXMATERIAL rgMaterials,
    DWORD cMaterials,
    DWORD xFormat
    )
{
    return D3DXSaveMeshToXEx(szFilename, pMesh, rgdwAdjacency, rgMaterials, cMaterials, xFormat, NULL, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\mesh\simplify.h ===
#ifndef __SIMPLIFY_H__
#define __SIMPLIFY_H__

// Disable warnings of loss of data conversion assignments
#pragma warning(disable:4242)

class CQuadric;
template <class UINT_IDX> class CEdgeInfo;
template <class UINT_IDX> class CSimplificationHeap;
template <class UINT_IDX> struct SEdgeCollapseContext;

template <class UINT_IDX>
struct SFaceEdgeInfo
{
    CEdgeInfo<UINT_IDX> *m_rgpeiEdges[3];
};

template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
class GXSimplifyMesh : public ID3DXSPMesh
{
public:
    GXSimplifyMesh( LPDIRECT3DDEVICE8 pD3DDevice, DWORD dwFVF, DWORD dwOptions );
    ~GXSimplifyMesh();
    
    // IUnknown Methods
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP QueryInterface(REFIID, LPVOID FAR*);
    
    // ID3DXSPMesh
    STDMETHOD_(DWORD, GetNumFaces)(THIS);
    STDMETHOD_(DWORD, GetNumVertices)(THIS);
    STDMETHOD_(DWORD, GetFVF)(THIS)
            { return m_tmTriMesh.GetFVF();};
    STDMETHOD(GetDeclaration)(THIS_ DWORD Declaration[MAX_FVF_DECL_SIZE])
                    { return m_tmTriMesh.GetDeclaration(Declaration); }
    STDMETHOD_(DWORD, GetOptions)(THIS)
            { return m_tmTriMesh.GetOptions();};
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice)
                    { return m_tmTriMesh.GetDevice(ppDevice); }
    STDMETHOD(CloneMeshFVF)(THIS_ DWORD options, 
                DWORD fvf, LPDIRECT3DDEVICE8 pD3D, 
                DWORD *rgdwAdjacency, DWORD *rgdwVertexRemap, LPD3DXMESH* ppCloneMesh);
    STDMETHOD(CloneMesh)(THIS_ DWORD options, 
                CONST DWORD *pDeclaration, LPDIRECT3DDEVICE8 pD3DDevice, 
                DWORD *rgdwAdjacency, DWORD *rgdwVertexRemap, LPD3DXMESH* ppCloneMesh);
    STDMETHOD(ClonePMeshFVF)(THIS_ DWORD options, 
                DWORD fvf, LPDIRECT3DDEVICE8 pD3D, DWORD *rgdwVertexRemap, LPD3DXPMESH* ppCloneMesh);
    STDMETHOD(ClonePMesh)(THIS_ DWORD options, 
                CONST DWORD *pDeclaration, LPDIRECT3DDEVICE8 pD3D, DWORD *rgdwVertexRemap, LPD3DXPMESH* ppCloneMesh);
    STDMETHOD(ReduceFaces)(THIS_ DWORD faces);
    STDMETHOD(ReduceVertices)(THIS_ DWORD vertices);
    STDMETHOD_(DWORD, GetMaxFaces)(THIS);
    STDMETHOD_(DWORD, GetMaxVertices)(THIS);

    // used by D3DXCreateSPMesh to initialize with a given data source
    HRESULT SetupSimplification(GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED> *ptmSrcMesh, 
                CONST DWORD *rgdwAdjacency,CONST LPD3DXATTRIBUTEWEIGHTS pVertexAttributeWeights, CONST FLOAT *pVertexWeights);
    HRESULT ResetHeap();
private:
    
    // Private data
    DWORD m_cRef; // Reference count

    DXCrackFVF m_cfvf;
    GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED> m_tmTriMesh;
    float m_fMeshRadiusSq;

    SFaceEdgeInfo<UINT_IDX> *m_rgfeiEdges;
    UINT_IDX *m_rgiWedgeList;
    CQuadric *m_rgqVertexQuadrics;
    CQuadric *m_rgqFaceQuadrics;
    D3DXVECTOR3 *m_rgvFaceNormals;
    BYTE *m_rgbVertexSeen;

    UINT m_cLogicalVertices;
    UINT m_cCurrentFaces;
    UINT m_cCurrentWedges;
    UINT m_cMaxLogicalVertices;
    
    UINT m_cvsMax16BitPos;
    UINT m_cvsMaxFaces16BitPos;
    
    UINT m_cMaxFaces;
    UINT m_cMaxVertices;

    CSimplificationHeap<UINT_IDX> *m_pheapCosts;
            
    // vsplit record information
    CHalfEdgeVSplit *m_rgvsSplits;          // array of vsplits, are not true vsplits until combined with info
                                                // in m_rgiFaceIndex and m_rgiEdgeRemoved
    BYTE    *m_rgbRemappedVSplit;   // array of flags indicating whether FaceIndex has been used to remap iFLCLW in the split record
                                                // if this is false, then need to use the remap array from compact to adjust as well
    ULONG    m_cvsSplitsMax;        // total number of vsplit records allocated
    ULONG    m_cvsSplitCurFree;     // current offset of the next vsplit record (starts at end of array and moves to the beginning)

    UINT    *m_rgiFaceIndex;           // index of the face in the mesh when created from base mesh and 
                                            // vsplit records, calculated when an edge collapse occurs
    UINT_IDX *m_rgiEdgeAdjustment;      // the offset of the number of indexes in the triangle caused by 
                                            // being generated from a vsplit record
                                            // used to calculate the offsets in the triangle for other vsplits 
                                            // that reference this triangle

    PBYTE    m_pvHEVertexBuffer;    // array of points to append after the base mesh in a half edge PM to generate the correct vertex buffer
    DWORD    *m_rgiHEVertexBuffer;    // src position of this item in the he vertex buffer
    ULONG    *m_rgcvHEVertexBufferMax;      // maximum offset of the vertices for each material
    ULONG    *m_rgcvHEVertexBufferFree;     // current offset of the next vertex buffer (per material)
                                                        //(starts at end of array and moves to the beginning)

    D3DXATTRIBUTERANGE *m_rgaeAttributeTableOrig;
    D3DXATTRIBUTERANGE *m_rgaeAttributeTableCur;

    UINT16  *m_rgiMaterialNew;  // array of mispredicted faces (used to be stored in the vsplit records)
    ULONG    m_cMaterialNewMax;                // size of mispredicted face array
    ULONG    m_cMaterialNewFree;               // current offset of the next free attribute slot (starts at end of array and moves to the beginning)

    BYTE *m_rgbVertexDeleted;       // is the given vertex deleted from the mesh

    D3DXATTRIBUTEWEIGHTS m_AttributeWeights;        // user input on how to weight the vertex components
    float *m_rgfVertexWeights;                      // user provided per vertex importance
    float *m_rgfTexWeights;                         // per float weights to handle texture coords error metric
    DWORD m_cTexWeights;                            //  number of per float texture coordinate weights
    D3DXCOLOR *m_rgcolorDiffuse;                    // if using diffuse attribute, needs to be in floating point format
    D3DXCOLOR *m_rgcolorSpecular;                   // if using specular attribute, needs to be in floating point format

    // Private methods
    
    HRESULT CreateEmptyMesh();
    HRESULT CreateHeap(PBYTE pvPoints);
    HRESULT GenerateWedgeList();
    HRESULT ComputePointReps();
    HRESULT DefragmentWedges();    
    HRESULT AllocateVSplitRecords();
    HRESULT SetupWeightInfo(CONST LPD3DXATTRIBUTEWEIGHTS pVertexAttributeWeights, CONST FLOAT *rgfVertexWeights, PBYTE pvPoints);
    HRESULT CollapseEdge(CEdgeInfo<UINT_IDX> *peiInfo, PBYTE pvPoints);
    HRESULT GenerateInitialQuadrics(PBYTE pvPoints);
    void CalcEdgeQEMS_Plane(UINT_IDX iFace, UINT_IDX iEdge, PBYTE pvPoints);
    void RecalcEdgeQEMS_Plane(UINT_IDX iFacePresent, UINT_IDX iWedgePresent, PBYTE pvPoints);
    void RecalcEdgeQEMS_GH(UINT_IDX iPoint, UINT_IDX iPoint2, UINT_IDX iFacePresent, UINT_IDX iWedgePresent, D3DXVECTOR3 &vPosNew, PBYTE pvPoints);
    void RecalcEdgeQEMS_MemoryLess(UINT_IDX iPoint1, UINT_IDX iPoint2, UINT_IDX iFacePresent, D3DXVECTOR3 &vPosNew, PBYTE pvPoints);
    void GenerateFaceQEM(UINT_IDX iFace, PBYTE pvPoints, CQuadric &qemFace);
    void GenerateVertexQEM_MemoryLess(UINT_IDX iFace, UINT_IDX iVertex, UINT_IDX iPoint, PBYTE pvPoints, CQuadric &qemTemp);
    bool BGenerateBorderQem(UINT_IDX iFace, UINT_IDX iEdge, UINT_IDX iNeighbor, PBYTE pvPoints, CQuadric &qemBorder);
    double DGenerateBorderError(UINT_IDX iFace, UINT_IDX iEdge, D3DXVECTOR3 *pvPosNew, PBYTE pvPoints);
    HRESULT FixupVSplitRecords();
    HRESULT RemapVSplitRecords(UINT *rgiFaceRemap);
    HRESULT RemapWedgeList(UINT *rgiVertRemap, UINT_IDX cMaxVertices);
    HRESULT RemapHEPointReps(UINT *rgiVertRemap, UINT_IDX cMaxVertices);
    HRESULT RemapInternals(UINT *rgiVertRemap, UINT cVerticesPreRemap, UINT *rgiFaceIndex, UINT cFacesPreRemap);
    float CalculateNormalCost(UINT_IDX iVertex1, UINT_IDX iVertex2, PBYTE pvPoints);
    HRESULT CalculateVSplitRecord(SEdgeCollapseContext<UINT_IDX> &ecc, PBYTE pvPoints);
    HRESULT CalculateVSplitWads(SEdgeCollapseContext<UINT_IDX> &ecc, PBYTE pvPoints);
    HRESULT GatherEdgeCollapseData(SEdgeCollapseContext<UINT_IDX> &ecc, CEdgeInfo<UINT_IDX> *peiInfo, PBYTE pvPoints);
    bool    BValidEdgeCollapse(SEdgeCollapseContext<UINT_IDX> &ecc, PBYTE pvPoints);
    HRESULT PerformEdgeCollapse(SEdgeCollapseContext<UINT_IDX> &ecc, PBYTE pvPoints);
    HRESULT UpdateVSplitAdjustments(SEdgeCollapseContext<UINT_IDX> &ecc);
    HRESULT UpdateErrorMeasurements(SEdgeCollapseContext<UINT_IDX> &ecc, PBYTE pvPoints);

	void RemoveWedge(UINT_IDX wWedge, UINT16 iMaterial);
	void RemoveWedgeElement(UINT_IDX wHead, UINT_IDX wElement, UINT16 iMaterial);

	void AddHEPoint(PBYTE pvPoints, UINT_IDX iWedge, UINT16 iMaterial);

    HRESULT Compact(UINT *rgiVertRemap, UINT cVertexRemap, UINT *rgFaceRemap, UINT cFaceRemap);
    // Debug methods
#if DBG
    bool BValid();
    bool BFragmentedWedges();
    bool BFragmentedWedge(UINT_IDX iFace, UINT_IDX wPointRep, UINT &cWedges, UINT &cWedgesMax , UINT_IDX *&rgiWedgesSeen);
#endif    
};

// UNDONE currently UINT_IDX, should change to be a byte, only 4 possible values 
#define EDGEADJ_UNUSED UNUSED

#include "simplify.inl"

#pragma warning(default:4242)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\mesh\pmeshhe.h ===
#ifndef __PMESHHE_H__
#define __PMESHHE_H__

// Disable warnings of loss of data conversion assignments
#pragma warning(disable:4242)

template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED> class GXSimplifyMesh;

// Vertex split record.
// Records the information necessary to split a vertex of the mesh,
//  in order to add to the mesh 1 new vertex and 1/2 new faces.
class CHalfEdgeVSplit 
{
public:       
    
    inline DWORD CFaces() const {return ((m_oVlrOffset > 0) ? 2:1);}
    
    // This format provides these limits:
    // - maximum number of faces: 1<<32
    // - maximum vertex valence:  1<<16
    // - maximum number of materials: 1<<16
    // Encoding of vertices vs, vl, vr.
    // Face flclw is the face just CLW of vl from vs.
    //  vs is the vs_index\'th vertex of flclw
    //  (vl is the (vs_index+2)%3\'th vertex of face flclw)
    //  vr is the (vlr_offset1-1)\'th vertex when rotating CLW about vs from vl
    // Special cases:
    // - vlr_offset1==0 : no_vr and no_fr
    DWORD m_iFlclw;         // 0..(mesh.numFaces()-1)
    WORD m_oVlrOffset; // 0..(max_vertex_valence) (prob<valence/2)
    WORD m_code;        // (vs_index(2),ii(2),ws(3),wt(3),wl(2),wr(2),
    //  fl_matid>=0(1),fr_matid>=0(1))
    enum {
        B_STMASK=0x0007,
            B_LSAME=0x0001,
            B_RSAME=0x0002,
            B_CSAME=0x0004,
            //
            B_LRMASK=0x0003,
            B_ABOVE=0x0000,
            B_BELOW=0x0001,
            B_NEW  =0x0002,         // must be on separate bit.
    };
    enum {
        VSINDEX_SHIFT=0,
            VSINDEX_MASK=(0x0003<<VSINDEX_SHIFT),
            //
            S_SHIFT=4,
            S_MASK=(B_STMASK<<S_SHIFT),
            S_LSAME=(B_LSAME<<S_SHIFT),
            S_RSAME=(B_RSAME<<S_SHIFT),
            S_CSAME=(B_CSAME<<S_SHIFT),
            //
            T_SHIFT=7,
            T_MASK=(B_STMASK<<T_SHIFT),
            T_LSAME=(B_LSAME<<T_SHIFT),
            T_RSAME=(B_RSAME<<T_SHIFT),
            T_CSAME=(B_CSAME<<T_SHIFT),
            //
            L_SHIFT=10,
            L_MASK=(B_LRMASK<<L_SHIFT),
            L_ABOVE=(B_ABOVE<<L_SHIFT),
            L_BELOW=(B_BELOW<<L_SHIFT),
            L_NEW  =(B_NEW<<L_SHIFT),
            //
            R_SHIFT=12,
            R_MASK=(B_LRMASK<<R_SHIFT),
            R_ABOVE=(B_ABOVE<<R_SHIFT),
            R_BELOW=(B_BELOW<<R_SHIFT),
            R_NEW  =(B_NEW<<R_SHIFT),
            //
            FLN_SHIFT=14,
            FLN_MASK=(1<<FLN_SHIFT),
            //
            FRN_SHIFT=15,
            FRN_MASK=(1<<FRN_SHIFT),
    };
    //Documentation:
    // vs_index: 0..2: index of vs within flace flclw
    // Inside wedges
    //  {S,T}{LSAME}: if exists outside left wedge and if same
    //  {S,T}{RSAME}: if exists outside right wedge and if same
    //  {S,T}{CSAME}: if inside left and right wedges are same
    //  (when no_vr, {S,T}RSAME==1, {S,T}CSAME==0)
    // Outside wedges
    //  (when no_vr, RABOVE==1)
    // New face material identifiers
    //  {L,R}NF: if 1, face matids not predicted correctly using ii,
    //     so included in f{l,r}_matid
    //  (when no_vr, RNF==0 obviously)
    //
    //Probabilities:
    //  vs_index: 0..2 (prob. uniform)
    //  {S,T}LSAME: prob. high
    //  {S,T}RSAME: prob. high
    //  {S,T}CSAME: prob. low
    //  {L,R}ABOVE: prob. high
    //  {L,R}BELOW: prob. low
    //  {L,R}NEW:   prob. low
    // Note: wl, wr, ws, wt are correlated since scalar half-edge
    //  discontinuities usually match up at both ends of edges.
    // -> do entropy coding on (wl,wr,ws,wt) symbol as a whole.
    
    int CExpectedWad() const;
    int CWedgesAdded() const;

    inline BYTE IGetVsIndex() const { return (m_code & CHalfEdgeVSplit::VSINDEX_MASK) >> CHalfEdgeVSplit::VSINDEX_SHIFT; } 
};

// -------------------------------------------------------------------------------
//   Struct contained by HalfEdgePMesh to contain the data required to perform the
//      current vsplit operation.  Contained in the pmesh to not require memory
//      allocation at runtime
//
template <class UINT_IDX>
struct SVSplitInfo
{
    bool bIsFaceR;

    UINT_IDX iVertex1;      // current vertex
    //UINT_IDX iVertex2;      // vertex added

    UINT_IDX iWedgeVtfl;	
    UINT_IDX iWedgeVsfl;	

    UINT_IDX iWedgeVtfr;
    UINT_IDX iWedgeVsfr;

    UINT_IDX iWedgeL;      // left vertex for the new triangle
    UINT_IDX iWedgeR;      // right vertex for the new triangle

    UINT16 iMaterialIndexLeft;
    UINT16 iMaterialIndexRight;

    UINT_IDX iFaceL;
    UINT_IDX iFaceR;

    UINT_IDX iFaceLCLW;
    UINT_IDX iFaceLCCW;

    UINT_IDX iFaceRCLW;
    UINT_IDX iFaceRCCW;

    UINT_IDX iEdgeLCLW;
    UINT_IDX iEdgeRCLW;
    UINT_IDX iEdgeLCCW;
    UINT_IDX iEdgeRCCW;

    // a "list" of pointer to the wedges between LCLW and RCCW inclusive
    //   the only vertex indices that need to change in a vsplit
    UINT_IDX **rgpwLCLWtoRCCW;
    UINT_IDX cpwLCLWtoRCCW;

    UINT_IDX cpwLCLWtoRCCWMax;  // maximum number of entries possible in rgpwLCLWtoRCCW
                                        // the greater of: the maximum vlrOffset+1 in the pmesh
                                                // or the maximum valence in the highest level mesh
};

class CPMSharedData
{
public:
    CPMSharedData()
        :m_rgvsVsplits(NULL), m_rgiMaterialNew(NULL), m_cRef(1) {}

    ~CPMSharedData()
    {
        delete []m_rgvsVsplits;
        delete []m_rgiMaterialNew;
    }

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj)
    {
        return E_NOTIMPL;
    }

    virtual ULONG STDMETHODCALLTYPE AddRef( void) 
        
    {
        return InterlockedIncrement(&m_cRef);
    }

    virtual ULONG STDMETHODCALLTYPE Release( void) 
    {
        ULONG cRef;
            
        cRef = InterlockedDecrement(&m_cRef);

        if (cRef == 0)
            delete this;

        return cRef;
    }

    LONG m_cRef;

    CHalfEdgeVSplit *m_rgvsVsplits;        // Array of CHalfEdgeVSplit record, possibly shared
    UINT16 *m_rgiMaterialNew;              // array of attribute bundles for mispredicts
};


template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
class GXHalfEdgePMesh : public ID3DXPMesh
{
    friend class GXSimplifyMesh<tp32BitIndex>;
    friend class GXSimplifyMesh<tp16BitIndex>;
    friend class GXHalfEdgePMesh<tp32BitIndex>;
    friend class GXHalfEdgePMesh<tp16BitIndex>;
public:
    GXHalfEdgePMesh( LPDIRECT3DDEVICE8 pD3D, DWORD dwFVF, DWORD dwOptions );
    ~GXHalfEdgePMesh();
    
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    virtual ULONG STDMETHODCALLTYPE AddRef( void) 
        
    {
        m_cRef += 1;
        return m_cRef;
    }

    virtual ULONG STDMETHODCALLTYPE Release( void) 
    {
        ULONG cRef = m_cRef;
        m_cRef -= 1;

        if (cRef == 1)
            delete this;

        return cRef-1;
    }

    // ID3DXBaseMesh
    // ID3DXBaseMesh
    STDMETHOD(DrawSubset)(THIS_ DWORD attribId)
                    { return m_tmTriMesh.DrawSubset(attribId); }
    STDMETHOD_(DWORD, GetNumFaces)(THIS)
                    { return m_cCurrentFaces; }
    STDMETHOD_(DWORD, GetNumVertices)(THIS)
                    { return m_cCurrentWedges; }
    STDMETHOD_(DWORD, GetFVF)(THIS)
                    { return m_tmTriMesh.GetFVF(); }
    STDMETHOD(GetDeclaration)(THIS_ DWORD Declaration[MAX_FVF_DECL_SIZE])
                    { return m_tmTriMesh.GetDeclaration(Declaration); }
    STDMETHOD_(DWORD, GetOptions)(THIS)
                    { return m_tmTriMesh.GetOptions(); }
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice)
                    { return m_tmTriMesh.GetDevice(ppDevice); }

    STDMETHOD(CloneMeshFVF)(THIS_ DWORD options, 
                DWORD fvf, LPDIRECT3DDEVICE8 pD3DDevice, LPD3DXMESH* ppCloneMesh);
    STDMETHOD(CloneMesh)(THIS_ DWORD options, 
                CONST DWORD *pDeclaration, LPDIRECT3DDEVICE8 pD3DDevice, LPD3DXMESH* ppCloneMesh);
    STDMETHOD(GetVertexBuffer)(THIS_ LPDIRECT3DVERTEXBUFFER8* ppVB)
                    { return m_tmTriMesh.GetVertexBuffer(ppVB); }
    STDMETHOD(GetIndexBuffer)(THIS_ LPDIRECT3DINDEXBUFFER8* ppIB)
                    { return m_tmTriMesh.GetIndexBuffer(ppIB); }
	STDMETHOD(LockVertexBuffer)(THIS_ DWORD flags, BYTE** ppData)
                    { return m_tmTriMesh.LockVertexBuffer(flags, ppData); }
	STDMETHOD(UnlockVertexBuffer)(THIS)
                    { return m_tmTriMesh.UnlockVertexBuffer(); }
	STDMETHOD(LockIndexBuffer)(THIS_ DWORD flags, BYTE** ppData)
    {
        if (flags & D3DLOCK_READONLY)
            return m_tmTriMesh.LockIndexBuffer(flags, ppData);
        DPF(0, "The index buffer of a ID3DXPMesh object cannot be modified. "
               "Use D3DLOCK_READONLY when locking the index buffer");
        return D3DXERR_CANNOTMODIFYINDEXBUFFER;
    }
	STDMETHOD(UnlockIndexBuffer)(THIS)
                    { return m_tmTriMesh.UnlockIndexBuffer(); }
    STDMETHOD(GetAttributeTable)(
                THIS_ D3DXATTRIBUTERANGE *attribEntry, DWORD* attribTabSize)
                    { return m_tmTriMesh.GetAttributeTable(attribEntry, attribTabSize); }

    //ID3DXPMesh
    STDMETHOD(ClonePMeshFVF)(THIS_ DWORD options, 
                DWORD fvf, LPDIRECT3DDEVICE8 pD3D, LPD3DXPMESH* ppCloneMesh);
    STDMETHOD(ClonePMesh)(THIS_ DWORD options, 
                CONST DWORD *pDeclaration, LPDIRECT3DDEVICE8 pD3D, LPD3DXPMESH* ppCloneMesh);
    STDMETHOD(SetNumFaces)(THIS_ DWORD faces);
    STDMETHOD(SetNumVertices)(THIS_ DWORD vertices);
    STDMETHOD_(DWORD, GetMaxFaces)(THIS);
    STDMETHOD_(DWORD, GetMinFaces)(THIS);
    STDMETHOD_(DWORD, GetMaxVertices)(THIS);
    STDMETHOD_(DWORD, GetMinVertices)(THIS);
    STDMETHOD(Save)(THIS_ IStream *pstream, D3DXMATERIAL *rgMaterials, DWORD cMaterials);

    STDMETHOD(Optimize)(THIS_ DWORD Flags, DWORD* pAdjacencyOut, 
                     DWORD* pFaceRemap, LPD3DXBUFFER *ppVertexRemap,  
                     LPD3DXMESH* ppOptMesh);
    STDMETHOD(GetAdjacency)(THIS_ DWORD* pAdjacency);

    HRESULT LoadFromData(LPD3DXMESH ptmMesh, DWORD *rgdwAdjacency, PBYTE pbPMData, DWORD cbPMData);
private:
    STDMETHOD(CloneMeshInternal)(THIS_ DWORD options, 
                DWORD fvf, LPDIRECT3DDEVICE8 pD3DDevice, 
                BOOL bIgnoreVertices, DWORD dwFlags, DWORD* rgdwAdjacencyOut, 
                DWORD* faceRemap, LPD3DXBUFFER *ppbufVertexRemap,  LPD3DXMESH* ppCloneMesh);

    DWORD m_cRef; // Reference count

    GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED> m_tmTriMesh;  // mesh data
    CHalfEdgeVSplit *m_rgvsVsplits;        // Array of CHalfEdgeVSplit record, possibly shared
    DWORD m_cvsVsplits;                         // number of elements in the vsplit array
    UINT16 *m_rgiMaterialNew;              // array of attribute bundles for mispredicts
    DWORD m_cMaterialNewCur;               //  current position in the mispredict array
    DWORD m_cMaterialNewMax;               //  maximum size of the mispredict array
    CPMSharedData *m_pPMSharedData; //  actual owner of memory for vsplits and other data
    
    D3DXATTRIBUTERANGE *m_rgaeAttributeTableFull; // the attribute LOD if at full LOD
    
    // Mesh Values
    DWORD m_cBaseVertices;       // Number of vertices in the base mesh.
    DWORD m_cMaxVertices;        // Total number of vertices when at maximum level of detail	
    DWORD m_iCurPos;             // Current position in the Vsplit array
    DWORD m_cBaseFaces;			 // Number of faces in the base mesh
    DWORD m_cMaxFaces;	         // Total number of faces when at maximum level of detail
    DWORD m_cCurrentFaces;       // current number of faces in the mesh

    DWORD m_cMaxWedges;	         // Total number of wedges when at maximum level of detail
    DWORD m_cBaseWedges;		 // Number of wedges in the base mesh
    DWORD m_cCurrentWedges;      // current number of wedges in the mesh
    
    SVSplitInfo<UINT_IDX> m_vsi;
            
    // Private methods
    
    STDMETHODIMP CreateEmptyMesh();

    // Applying and undoing vsplits
    // these two call the common or uncommon equivalents based on vspl.IsCommon()
    void ApplyVSplit(CHalfEdgeVSplit &vsNext);
    void UndoVSplit(CHalfEdgeVSplit &vsPrev);

    // helper functions
    void GatherVSplitInfo(CHalfEdgeVSplit &vsNext);
    void GatherECollapseInfo(CHalfEdgeVSplit &vsLast);

    // Debug methods
#if DBG
    bool BValid();
    bool BFragmentedWedge(UINT_IDX iInitialFace, UINT_IDX wWedge, UINT &cWedges, UINT &cWedgesMax , UINT_IDX *&rgiWedgesSeen);
    bool BFragmentedWedges();

    BYTE *m_rgbVertexSeen;
#endif
	
	inline UINT_IDX GetNextWedge(UINT iae) 
		{ 
        m_cCurrentWedges += 1;
        // return the offset of the next wedge in the given material
		return (UINT_IDX)(m_tmTriMesh.m_rgaeAttributeTable[iae].VertexStart + m_tmTriMesh.m_rgaeAttributeTable[iae].VertexCount++);
		}
};

// currently defined in pmesh.h, but if we remove the old pmesh stuff it will
//   need to be reenabled here
#if 0
static const int x_rgmod3[6]={0,1,2,0,1,2};
inline int MOD3(int j)
{
    GXASSERT(j>=0 && j<6);
    return x_rgmod3[j];
}

// Pointer checking
#if DBG
inline BOOL DWORD_PTR_OK(DWORD *p) {return !IsBadWritePtr(p, sizeof(DWORD));}
#else
inline BOOL DWORD_PTR_OK(DWORD *p) {return (p? TRUE:FALSE);}
#endif
#endif

#include "pmeshhe.inl"

#pragma warning(default:4242)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\mesh\pmeshhe.inl ===
/*//////////////////////////////////////////////////////////////////////////////
//
// File: pmeshhe.cpp
//
// Copyright (C) 1999 Microsoft Corporation. All Rights Reserved.
//
// @@BEGIN_MSINTERNAL
//
// History:
// -@- 08/01/99 (craigp)    - created 
//
// @@END_MSINTERNAL
//
//////////////////////////////////////////////////////////////////////////////*/

// -------------------------------------------------------------------------------
//  function    GXHalfEdgePMesh constructor
//
//   devnote    initialize data members so that destruction is possible
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
GXHalfEdgePMesh<UINT_IDX,b16BitIndex,UNUSED>::GXHalfEdgePMesh
    ( 
    LPDIRECT3DDEVICE8 pD3DDevice, 
    DWORD dwFVF, 
    DWORD dwOptions
    )
    :m_cRef(1),
    m_tmTriMesh(pD3DDevice, dwFVF, dwOptions),
    m_rgvsVsplits(NULL),
    m_rgiMaterialNew(NULL),
    m_cMaterialNewCur(0),
    m_cMaterialNewMax(0),
    m_cBaseVertices(0),
    m_iCurPos(0),
    m_cMaxFaces(0),
    m_cMaxWedges(0),
    m_cBaseFaces(0),
    m_rgaeAttributeTableFull(0)
{
#ifdef _DEBUG
    m_rgbVertexSeen = NULL;
#endif

    // has material indices, but no attribute bundles per face
    m_tmTriMesh.m_dwOptionsInt |= D3DXMESHINT_FACEADJACENCY | D3DXMESHINT_ATTRIBINDEX
                                            | D3DXMESHINT_ATTRIBUTETABLE;
    m_tmTriMesh.m_dwOptionsInt &= ~D3DXMESHINT_ATTRIBID;

    m_vsi.rgpwLCLWtoRCCW = NULL;
    m_vsi.cpwLCLWtoRCCWMax = 0;  

    m_tmTriMesh.m_punkOuter = (IUnknown*)this;

}

// -------------------------------------------------------------------------------
//  function    GXHalfEdgePMesh destructor
//
//   devnote    frees all local data
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
GXHalfEdgePMesh<UINT_IDX,b16BitIndex,UNUSED>::~GXHalfEdgePMesh()
{

    // release the shared data - all happens inside the interlocked object
    //delete []m_rgvsVsplits;
    //delete []m_rgiMaterialNew;
    GXRELEASE(m_pPMSharedData);

    delete []m_vsi.rgpwLCLWtoRCCW;
    delete m_rgaeAttributeTableFull;
}

// -------------------------------------------------------------------------------
//  function    GetAdjacency
//
//   devnote    Converts internal adjacency into external in the buffer provided
//
//   returns    S_OK if successful, else failure code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT 
GXHalfEdgePMesh<UINT_IDX,b16BitIndex,UNUSED>::GetAdjacency
    (
    DWORD *rgdwAdjacency
    )
{
    DWORD iEntry;
    DWORD cEntries;
    UINT_IDX *pwSrc;
    DWORD *pdwDest;

    pwSrc = m_tmTriMesh.m_rgpniNeighbors[0].m_iNeighbors;
    pdwDest = rgdwAdjacency;

    cEntries = m_tmTriMesh.m_cFaces * 3;
    for (iEntry = 0; iEntry < cEntries; iEntry++)
    {
        if (*pwSrc != UNUSED)
            *pdwDest = (DWORD)*pwSrc;
        else
            *pdwDest = UNUSED32;

        pdwDest += 1;
        pwSrc += 1;
    }

    return S_OK;
}

// -------------------------------------------------------------------------------
//  function    OptimizeMesh
//
//   devnote    
//
//   returns    S_OK if successful, else failure code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT 
GXHalfEdgePMesh<UINT_IDX,b16BitIndex,UNUSED>::Optimize
    (
    DWORD dwFlags, 
    DWORD* rgdwAdjacencyOut, 
    DWORD* faceRemap, 
    LPD3DXBUFFER *ppbufVertexRemap,  
    LPD3DXMESH* ppOptMesh
    )
{
    return CloneMeshInternal(m_tmTriMesh.m_dwOptions, m_tmTriMesh.m_dwFVF, 
                                m_tmTriMesh.m_pD3DDevice, FALSE, 
                                dwFlags, rgdwAdjacencyOut, faceRemap, ppbufVertexRemap, ppOptMesh);
}

// -------------------------------------------------------------------------------
//  function    CloneMesh
//
//   devnote    
//
//   returns    S_OK if successful, else failure code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT 
GXHalfEdgePMesh<UINT_IDX,b16BitIndex,UNUSED>::CloneMesh
    (
    DWORD dwOptionsNew, 
    CONST DWORD *pDeclaration, 
    LPDIRECT3DDEVICE8 pD3DDevice, 
    LPD3DXMESH* ppCloneMesh
    )
{
    DWORD dwFVF;
    HRESULT hr;

    if (pDeclaration == NULL)
    {
        dwFVF = m_tmTriMesh.m_dwFVF;
    }
    else
    {
        hr = D3DXFVFFromDeclarator(pDeclaration, &dwFVF);
        if (FAILED(hr))
        {
            DPF(0,"CloneMesh: Declaration cannot be converted to FVF");
            return hr;
        }
    }

    return CloneMeshFVF(dwOptionsNew, dwFVF, pD3DDevice, ppCloneMesh);
}

// -------------------------------------------------------------------------------
//  function    ClonePM
//
//   devnote    Generate a sibling progressive mesh, sharing data when possible
//
//   returns    S_OK if successful, else failure code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT 
GXHalfEdgePMesh<UINT_IDX,b16BitIndex,UNUSED>::CloneMeshFVF
    (
    DWORD dwOptionsNew, 
    DWORD dwFVFNew, 
    LPDIRECT3DDEVICE8 pD3DDevice, 
    LPD3DXMESH* ppCloneMesh
    )
{
    if ((dwOptionsNew & ~D3DXMESH_VALIDCLONEBITS) != 0)
    {
        DPF(0, "CloneMeshFVF: Invalid options bit passed to CloneMesh\n");
        return D3DERR_INVALIDCALL;
    }

    if ((dwOptionsNew & D3DXMESH_VB_SHARE) && (dwFVFNew != m_tmTriMesh.m_dwFVF))
    {
        DPF(0, "CloneMeshFVF: VB_SHARE can only be specified if both meshes have identical FVF\n");
        return D3DERR_INVALIDCALL;
    }
    if ((dwOptionsNew & D3DXMESH_VB_SHARE) && (pD3DDevice != m_tmTriMesh.m_pD3DDevice))
    {
        DPF(0, "CloneMeshFVF: VB_SHARE can only be specified if both meshes are on the same device\n");
        return D3DERR_INVALIDCALL;
    }

    return CloneMeshInternal(dwOptionsNew, dwFVFNew, pD3DDevice, FALSE, 0, NULL, NULL, NULL, ppCloneMesh);
}

// -------------------------------------------------------------------------------
//  function    CloneMesh
//
//   devnote    Clones the current LOD of the pmesh
//
//   returns    S_OK if successful, else failure code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT 
GXHalfEdgePMesh<UINT_IDX,b16BitIndex,UNUSED>::CloneMeshInternal
    (
    DWORD dwOptionsNew, 
    DWORD dwFVFNew, 
    LPDIRECT3DDEVICE8 pD3DDevice, 
    BOOL bIgnoreVertices, 
    DWORD dwFlags, 
    DWORD* rgdwAdjacencyOut, 
    DWORD* faceRemap, 
    LPD3DXBUFFER *ppbufVertexRemap,  
    LPD3DXMESH* ppCloneMesh
    )
{	
    HRESULT hr = S_OK;
    LPD3DXMESH pTempMesh = NULL;
    DWORD iattr;
    DWORD iFaceEnd;
    DWORD iFace;
    DWORD *rgdwAdjacency = NULL;
    DWORD iFaceStart;

    hr = m_tmTriMesh.LockIB((PBYTE*)&m_tmTriMesh.m_pFaces);
    if (FAILED(hr))
        return hr;

    // need to set all unused faces to truly be unused for optimization purposes
    for (iattr = 0; iattr < m_tmTriMesh.m_caeAttributeTable; iattr++)
    {
        iFaceEnd = m_rgaeAttributeTableFull[iattr].FaceStart + m_rgaeAttributeTableFull[iattr].FaceCount;
        iFaceStart = m_rgaeAttributeTableFull[iattr].FaceStart + m_tmTriMesh.m_rgaeAttributeTable[iattr].FaceCount;
        for (iFace = iFaceStart; iFace < iFaceEnd; iFace++)
        {
            m_tmTriMesh.m_pFaces[iFace].m_wIndices[0] = UNUSED;
            m_tmTriMesh.m_pFaces[iFace].m_wIndices[1] = UNUSED;
            m_tmTriMesh.m_pFaces[iFace].m_wIndices[2] = UNUSED;
            m_tmTriMesh.m_rgpniNeighbors[iFace].m_iNeighbors[0] = UNUSED;
            m_tmTriMesh.m_rgpniNeighbors[iFace].m_iNeighbors[1] = UNUSED;
            m_tmTriMesh.m_rgpniNeighbors[iFace].m_iNeighbors[2] = UNUSED;
        }
    }

    hr = m_tmTriMesh.UnlockIB();
    if (FAILED(hr))
        return hr;

    // the ignore vertices path should never set dwFlags
    GXASSERT(!bIgnoreVertices || (dwFlags == 0));

    // expand the attribute indices into attribute ids
    m_tmTriMesh.m_rgiAttributeIds = new DWORD[m_tmTriMesh.m_cMaxFaces];
    if (m_tmTriMesh.m_rgiAttributeIds == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }
    m_tmTriMesh.m_dwOptionsInt &= ~D3DXMESHINT_ATTRIBINDEX;
    m_tmTriMesh.m_dwOptionsInt |= D3DXMESHINT_ATTRIBID;

    for (iattr = 0; iattr < m_tmTriMesh.m_caeAttributeTable; iattr++)
    {
        iFaceEnd = m_tmTriMesh.m_rgaeAttributeTable[iattr].FaceStart + m_tmTriMesh.m_rgaeAttributeTable[iattr].FaceCount;
        for (iFace = m_tmTriMesh.m_rgaeAttributeTable[iattr].FaceStart; iFace < iFaceEnd; iFace++)
        {
            m_tmTriMesh.m_rgiAttributeIds[iFace] = m_tmTriMesh.m_rgaeAttributeTable[iattr].AttribId;
        }
    }

    hr = m_tmTriMesh.CloneMeshFVF(dwOptionsNew, dwFVFNew, pD3DDevice, &pTempMesh);
    if (FAILED(hr))
        goto e_Exit;

    // if doing an optimization that needs adjacency, or the user wants adjacency back
    if ((rgdwAdjacencyOut != NULL) || (dwFlags & (D3DXMESHOPT_VERTEXCACHE | D3DXMESHOPT_STRIPREORDER)))
    {
        rgdwAdjacency = new DWORD[m_tmTriMesh.m_cFaces * 3];
        if (rgdwAdjacency == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }

        hr = GetAdjacency(rgdwAdjacency);
        if (FAILED(hr))
            goto e_Exit;
    }

    if (bIgnoreVertices)
    {
        // remove deadspace from the mesh, but leave the vertices as they are
        hr = pTempMesh->Optimize(D3DXMESHOPT_COMPACT | D3DXMESHOPT_ATTRSORT | D3DXMESHOPT_IGNOREVERTS, NULL, NULL, NULL, NULL, ppCloneMesh);
        if (FAILED(hr))
            goto e_Exit;
    }
    else
    {
        // if we should share the VB, make certain that the mesh with the unused faces removed still shares the VB
        if (dwOptionsNew & D3DXMESH_VB_SHARE)
        {
            // remove deadspace from the mesh
            hr = pTempMesh->Optimize(D3DXMESHOPT_COMPACT | D3DXMESHOPT_ATTRSORT | D3DXMESHOPT_SHAREVB | dwFlags, rgdwAdjacency, rgdwAdjacencyOut, faceRemap, ppbufVertexRemap, ppCloneMesh);
            if (FAILED(hr))
                goto e_Exit;
        }
        else
        {
            // remove deadspace from the mesh
            hr = pTempMesh->Optimize(D3DXMESHOPT_COMPACT | D3DXMESHOPT_ATTRSORT | dwFlags, rgdwAdjacency, rgdwAdjacencyOut, faceRemap, ppbufVertexRemap, ppCloneMesh);
            if (FAILED(hr))
                goto e_Exit;
        }
    }

    // make certain that the vertex buffer is shared if it should be
#ifdef _DEBUG
    if (dwOptionsNew & D3DXMESH_VB_SHARE)
    {
        LPDIRECT3DVERTEXBUFFER8 pVBTest;
        (*ppCloneMesh)->GetVertexBuffer(&pVBTest);
        GXASSERT(pVBTest == m_tmTriMesh.m_pVBVertices);
    }
#endif

e_Exit:
    // remove them, should be done on the temp mesh, but then need to work around mesh types, etc
    m_tmTriMesh.m_dwOptionsInt |= D3DXMESHINT_ATTRIBINDEX;
    m_tmTriMesh.m_dwOptionsInt &= ~D3DXMESHINT_ATTRIBID;
    delete []m_tmTriMesh.m_rgiAttributeIds;
    delete []rgdwAdjacency;
    m_tmTriMesh.m_rgiAttributeIds = NULL;
    
    GXRELEASE(pTempMesh);

    return hr;
}

// -------------------------------------------------------------------------------
//  function    ClonePM
//
//   devnote    Generate a sibling progressive mesh, sharing data when possible
//
//   returns    S_OK if successful, else failure code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT 
GXHalfEdgePMesh<UINT_IDX,b16BitIndex,UNUSED>::ClonePMesh
    (
    DWORD dwOptionsNew, 
    CONST DWORD *pDeclaration, 
    LPDIRECT3DDEVICE8 pD3DDevice, 
    LPD3DXPMESH* ppClonePMesh
    )
{
    DWORD dwFVF;
    HRESULT hr;

    if (pDeclaration == NULL)
    {
        dwFVF = m_tmTriMesh.m_dwFVF;
    }
    else
    {
        hr = D3DXFVFFromDeclarator(pDeclaration, &dwFVF);
        if (FAILED(hr))
        {
            DPF(0,"CloneMesh: Declaration cannot be converted to FVF");
            return hr;
        }
    }

    return ClonePMeshFVF(dwOptionsNew, dwFVF, pD3DDevice, ppClonePMesh);
}

// -------------------------------------------------------------------------------
//  function    ClonePM
//
//   devnote    Generate a sibling progressive mesh, sharing data when possible
//
//   returns    S_OK if successful, else failure code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT 
GXHalfEdgePMesh<UINT_IDX,b16BitIndex,UNUSED>::ClonePMeshFVF
    (
    DWORD dwOptionsNew, 
    DWORD dwFVFNew, 
    LPDIRECT3DDEVICE8 pD3DDevice, 
    LPD3DXPMESH* ppClonePMesh
    )
{	
    HRESULT hr = S_OK;
    GXHalfEdgePMesh<tp32BitIndex> *ptmNewPMesh32 = NULL;
    GXHalfEdgePMesh<tp16BitIndex> *ptmNewPMesh16 = NULL;
    ID3DXPMesh *ptmNewPMesh = NULL;
    LPDIRECT3DVERTEXBUFFER8 pVertexBuffer;

    if ((dwOptionsNew & ~D3DXMESH_VALIDCLONEBITS) != 0)
    {
        hr = D3DERR_INVALIDCALL;
        DPF(0, "ClonePMeshFVF: Invalid options bit passed to CloneMesh\n");
        goto e_Exit;
    }

    if ((dwOptionsNew & D3DXMESH_VB_SHARE) && (dwFVFNew != m_tmTriMesh.m_dwFVF))
    {
        hr = D3DERR_INVALIDCALL;
        DPF(0, "ClonePMeshFVF: VB_SHARE can only be specified if both meshes have identical FVF\n");
        goto e_Exit;
    }
    if ((dwOptionsNew & D3DXMESH_VB_SHARE) && (pD3DDevice != m_tmTriMesh.m_pD3DDevice))
    {
        DPF(0, "ClonePMeshFVF: VB_SHARE can only be specified if both pmeshes are on the same device\n");
        return D3DERR_INVALIDCALL;
    }

    if (dwOptionsNew & D3DXMESH_32BIT)
    {
        ptmNewPMesh32 = new GXHalfEdgePMesh<tp32BitIndex>(pD3DDevice, dwFVFNew, dwOptionsNew);
        if (ptmNewPMesh32 == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }

        // link up to the shared data
        ptmNewPMesh32->m_pPMSharedData = m_pPMSharedData;
        m_pPMSharedData->AddRef();

        hr = m_tmTriMesh.CloneHelper32(&ptmNewPMesh32->m_tmTriMesh);
        if (FAILED(hr))
            goto e_Exit;

        if (dwOptionsNew & D3DXMESH_VB_SHARE)
        {
            // mark this mesh as shared as well
            m_tmTriMesh.m_dwOptionsInt |= D3DXMESHINT_SHAREDVB;
            GXASSERT(ptmNewPMesh32->m_tmTriMesh.BSharedVB());

            // share the vertex buffer from this mesh with the other mesh
            ptmNewPMesh32->m_tmTriMesh.m_pVBVertices = m_tmTriMesh.m_pVBVertices;
            m_tmTriMesh.m_pVBVertices->AddRef();
        }

        // setup the mispredicted material array
        ptmNewPMesh32->m_cMaterialNewMax = m_cMaterialNewMax;
        ptmNewPMesh32->m_cMaterialNewCur = m_cMaterialNewCur;
        ptmNewPMesh32->m_rgiMaterialNew = ptmNewPMesh32->m_pPMSharedData->m_rgiMaterialNew;
    
        // make sure that the attribute table was copied
        GXASSERT(ptmNewPMesh32->m_tmTriMesh.BHasAttributeTable());
        GXASSERT(ptmNewPMesh32->m_tmTriMesh.m_rgaeAttributeTable != NULL);

        ptmNewPMesh32->m_cBaseVertices = m_cBaseVertices;
        ptmNewPMesh32->m_cMaxVertices = m_cMaxVertices;
        ptmNewPMesh32->m_cMaxWedges = m_cMaxWedges;
        ptmNewPMesh32->m_cBaseWedges = m_cBaseWedges;
        ptmNewPMesh32->m_cCurrentWedges = m_cCurrentWedges;
        ptmNewPMesh32->m_cBaseFaces = m_cBaseFaces;
        ptmNewPMesh32->m_cCurrentFaces = m_cCurrentFaces;
        ptmNewPMesh32->m_cMaxFaces = m_cMaxFaces;
        ptmNewPMesh32->m_iCurPos = m_iCurPos;


        // copy the array used for storing indices around the vertex collapsed
        ptmNewPMesh32->m_vsi.cpwLCLWtoRCCWMax = m_vsi.cpwLCLWtoRCCWMax;
        ptmNewPMesh32->m_vsi.rgpwLCLWtoRCCW = new UINT32*[ptmNewPMesh32->m_vsi.cpwLCLWtoRCCWMax];
        if (ptmNewPMesh32->m_vsi.rgpwLCLWtoRCCW == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }

        // allocate the vsplit records
        ptmNewPMesh32->m_cvsVsplits = m_cvsVsplits;
        ptmNewPMesh32->m_rgvsVsplits = ptmNewPMesh32->m_pPMSharedData->m_rgvsVsplits;

        pVertexBuffer = ptmNewPMesh32->m_tmTriMesh.m_pVBVertices;
        ptmNewPMesh = ptmNewPMesh32;
        ptmNewPMesh32 = NULL;
    }
    else
    {
        if ((m_tmTriMesh.m_cFaces > UNUSED16) || (m_tmTriMesh.m_cVertices > UNUSED16))
        {
            hr = D3DERR_INVALIDCALL;
            goto e_Exit;
        }

        ptmNewPMesh16 = new GXHalfEdgePMesh<tp16BitIndex>(pD3DDevice, dwFVFNew, dwOptionsNew);
        if (ptmNewPMesh16 == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }

        // link up to the shared data
        ptmNewPMesh16->m_pPMSharedData = m_pPMSharedData;
        m_pPMSharedData->AddRef();

        hr = m_tmTriMesh.CloneHelper16(&ptmNewPMesh16->m_tmTriMesh);
        if (FAILED(hr))
            goto e_Exit;

        if (dwOptionsNew & D3DXMESH_VB_SHARE)
        {
            // mark this mesh as shared as well
            m_tmTriMesh.m_dwOptionsInt |= D3DXMESHINT_SHAREDVB;
            GXASSERT(ptmNewPMesh16->m_tmTriMesh.BSharedVB());

            // share the vertex buffer from this mesh with the other mesh
            ptmNewPMesh16->m_tmTriMesh.m_pVBVertices = m_tmTriMesh.m_pVBVertices;
            m_tmTriMesh.m_pVBVertices->AddRef();
        }

        // setup the mispredicted material array
        ptmNewPMesh16->m_cMaterialNewMax = m_cMaterialNewMax;
        ptmNewPMesh16->m_cMaterialNewCur = m_cMaterialNewCur;
        ptmNewPMesh16->m_rgiMaterialNew = new UINT16[m_cMaterialNewMax];
        ptmNewPMesh16->m_rgiMaterialNew = ptmNewPMesh16->m_pPMSharedData->m_rgiMaterialNew;
    
        // make sure that the attribute table was copied
        GXASSERT(ptmNewPMesh16->m_tmTriMesh.BHasAttributeTable());
        GXASSERT(ptmNewPMesh16->m_tmTriMesh.m_rgaeAttributeTable != NULL);

        ptmNewPMesh16->m_cBaseVertices = m_cBaseVertices;
        ptmNewPMesh16->m_cMaxVertices = m_cMaxVertices;
        ptmNewPMesh16->m_cMaxWedges = m_cMaxWedges;
        ptmNewPMesh16->m_cBaseWedges = m_cBaseWedges;
        ptmNewPMesh16->m_cCurrentWedges = m_cCurrentWedges;
        ptmNewPMesh16->m_cBaseFaces = m_cBaseFaces;
        ptmNewPMesh16->m_cCurrentFaces = m_cCurrentFaces;
        ptmNewPMesh16->m_cMaxFaces = m_cMaxFaces;
        ptmNewPMesh16->m_iCurPos = m_iCurPos;


        // copy the array used for storing indices around the vertex collapsed
        ptmNewPMesh16->m_vsi.cpwLCLWtoRCCWMax = m_vsi.cpwLCLWtoRCCWMax;
        ptmNewPMesh16->m_vsi.rgpwLCLWtoRCCW = new UINT16*[ptmNewPMesh16->m_vsi.cpwLCLWtoRCCWMax];
        if (ptmNewPMesh16->m_vsi.rgpwLCLWtoRCCW == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }

        // link to shared vsplit records
        ptmNewPMesh16->m_cvsVsplits = m_cvsVsplits;
        ptmNewPMesh16->m_rgvsVsplits = ptmNewPMesh16->m_pPMSharedData->m_rgvsVsplits;

        pVertexBuffer = ptmNewPMesh16->m_tmTriMesh.m_pVBVertices;
        ptmNewPMesh = ptmNewPMesh16;
        ptmNewPMesh16 = NULL;
    }

    // only do a copy if the VBs aren't shared
    if ( !(dwOptionsNew & D3DXMESH_VB_SHARE))
    {
        // now that the internals and face index data are loaded, load/convert the vertex data
        hr = m_tmTriMesh.CloneVertexBuffer(dwFVFNew, pVertexBuffer);
        if (FAILED(hr))
            goto e_Exit;
    }

    *ppClonePMesh = ptmNewPMesh;
    ptmNewPMesh = NULL;

e_Exit:
    GXRELEASE(ptmNewPMesh);
    GXRELEASE(ptmNewPMesh16);
    GXRELEASE(ptmNewPMesh32);

    return hr;
}


// -------------------------------------------------------------------------------
//  method    QueryInterface
//
//  devnote     Returns the requested interface, assuming it is supported
//
//  returns     S_OK if suceeded, else error code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT 
GXHalfEdgePMesh<UINT_IDX,b16BitIndex,UNUSED>::QueryInterface
    (
    REFIID riid, 
    LPVOID FAR *ppv
    )
{	
    *ppv=NULL;
    if (riid == IID_IUnknown)
        *ppv=(IUnknown*)this;
    else if (riid == IID_ID3DXBaseMesh)
        *ppv=(ID3DXBaseMesh*)this;
    else if (riid == IID_ID3DXPMesh)
        *ppv=(ID3DXPMesh*)this;
    else
        return E_NOINTERFACE;
    ((LPUNKNOWN)*ppv)->AddRef();

    return S_OK;
}



// -------------------------------------------------------------------------------
//  method    SetNumVertices
//
//  devnote     Does either vsplits or edge collapses to move the current number
//                  of vertices to the desired number of vertices
//          NOTE: it will cap the input value at the upper and lower bounds
//
//  returns     S_OK if suceeded, else error code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT 
GXHalfEdgePMesh<UINT_IDX,b16BitIndex,UNUSED>::SetNumVertices
    (
    DWORD cWedges
    )
{
    HRESULT hr = S_OK;
    
    hr = m_tmTriMesh.LockIB((PBYTE*)&m_tmTriMesh.m_pFaces);
    if (FAILED(hr))
        return hr;

    // make certain that we have a valid goal to achieve
    cWedges = min(cWedges, m_cMaxWedges);
    cWedges = max(cWedges, m_cBaseWedges);
    //iEndPos = cVertices - m_cBaseVertices;

    // if more vertices, perform the required number of splits
    if (cWedges > m_cCurrentWedges)
    {
        DWORD iMaxPos = m_cMaxVertices - m_cBaseVertices;
        while ((cWedges > m_cCurrentWedges) && (m_iCurPos < iMaxPos))
        {
            ApplyVSplit(m_rgvsVsplits[m_iCurPos]);
            m_iCurPos += 1;
        }

        // if we overshot our goal, then take a step back
        if (cWedges < m_cCurrentWedges)
        {
            m_iCurPos -= 1;
            UndoVSplit(m_rgvsVsplits[m_iCurPos]);
        }
    }
    // else peform the required number of collapses
    else if (cWedges < m_cCurrentWedges)
    { 
        while ((cWedges < m_cCurrentWedges) && (m_iCurPos > 0))
        {
            m_iCurPos -= 1;
            UndoVSplit(m_rgvsVsplits[m_iCurPos]);
        }
    }

    if (m_tmTriMesh.m_pFaces != NULL)
    {
        m_tmTriMesh.m_pFaces = NULL;
        m_tmTriMesh.UnlockIB();
    }

    GXASSERT(BValid());

    return hr;
}


// -------------------------------------------------------------------------------
//  method    GetMaxVertices
//
//  devnote     Returns maximum number of vertices in the mesh
//                  NOTE: Vertices not WEDGES
//
//  returns     S_OK if suceeded, else error code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
DWORD
GXHalfEdgePMesh<UINT_IDX,b16BitIndex,UNUSED>::GetMaxVertices()
{
    return m_cMaxWedges;
}


// -------------------------------------------------------------------------------
//  method    GetMinVertices
//
//  devnote     Returns minimum number of vertices in the mesh
//                  NOTE: Vertices not WEDGES
//
//  returns     S_OK if suceeded, else error code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
DWORD
GXHalfEdgePMesh<UINT_IDX,b16BitIndex,UNUSED>::GetMinVertices()
{
    return m_cBaseWedges;
}

// -------------------------------------------------------------------------------
//  method    GetMaxFaces
//
//  devnote     Returns maximum number of faces in the mesh
//
//  returns     S_OK if suceeded, else error code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
DWORD
GXHalfEdgePMesh<UINT_IDX,b16BitIndex,UNUSED>::GetMaxFaces()
{
    return m_cMaxFaces;
}

// -------------------------------------------------------------------------------
//  method    GetMinFaces
//
//  devnote     Returns minimum number of faces in the mesh
//
//  returns     S_OK if suceeded, else error code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
DWORD
GXHalfEdgePMesh<UINT_IDX,b16BitIndex,UNUSED>::GetMinFaces()
{
    return m_cBaseFaces;    
}


// -------------------------------------------------------------------------------
//  method    SetNumFaces
//
//  devnote     Sets the current number of faces, or as close as possible
//                  NOTE: currently not implemented!
//
//  returns     S_OK if suceeded, else error code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT 
GXHalfEdgePMesh<UINT_IDX,b16BitIndex,UNUSED>::SetNumFaces
    (
    DWORD cFaces
    )
{
    HRESULT hr = S_OK;
    
    hr = m_tmTriMesh.LockIB((PBYTE*)&m_tmTriMesh.m_pFaces);
    if (FAILED(hr))
        return hr;

    // make certain that we have a valid goal to achieve
    cFaces = min(cFaces, m_cMaxFaces);
    cFaces = max(cFaces, m_cBaseFaces);

    // if more vertices, perform the required number of splits
    if (cFaces > m_cCurrentFaces)
    {
        DWORD iMaxPos = m_cMaxVertices - m_cBaseVertices;
        while ((cFaces > m_cCurrentFaces) && (m_iCurPos < iMaxPos))
        {
            ApplyVSplit(m_rgvsVsplits[m_iCurPos]);
            m_iCurPos += 1;
        }

        // if we overshot our goal, then take a step back
        if (cFaces < m_cCurrentFaces)
        {
            m_iCurPos -= 1;
            UndoVSplit(m_rgvsVsplits[m_iCurPos]);
        }
    }
    // else peform the required number of collapses
    else if (cFaces < m_cCurrentFaces)
    { 
        while ((cFaces < m_cCurrentFaces) && (m_iCurPos > 0))
        {
            m_iCurPos -= 1;
            UndoVSplit(m_rgvsVsplits[m_iCurPos]);
        }
    }

    if (m_tmTriMesh.m_pFaces != NULL)
    {
        m_tmTriMesh.m_pFaces = NULL;
        m_tmTriMesh.UnlockIB();
    }

    GXASSERT(BValid());

    return hr;
}

#ifdef _DEBUG
// -------------------------------------------------------------------------------
//  method    BValid
//
//  devnote     Does a validity check of the progressive mesh
//                  asserts if anything is fishy
//
//  returns     returns false if not valid
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
bool
GXHalfEdgePMesh<UINT_IDX,b16BitIndex,UNUSED>::BValid() 
{ 
    return m_tmTriMesh.BValid();
}
#endif

// -------------------------------------------------------------------------------
//   Load and Save code
// -------------------------------------------------------------------------------

inline READ_DWORD(PBYTE &pbCur) 
{
    DWORD dwTemp = *(DWORD*)pbCur;
    pbCur += sizeof(DWORD);
    return dwTemp;
}

inline READ_WORD(PBYTE &pbCur) 
{
    WORD wTemp = *(WORD*)pbCur;
    pbCur += sizeof(WORD);
    return wTemp;
}

#define WRITE_DWORD(pbCur, dword) {*(DWORD*)pbCur = dword; pbCur += sizeof(DWORD); }
#define WRITE_WORD(pbCur,  word) {*(DWORD*)pbCur = word;  pbCur += sizeof(WORD);  }

HRESULT WINAPI D3DXSaveMeshToXEx
    (
    char *szFilename,
    LPD3DXMESH pMesh,
    CONST DWORD *rgdwAdjacency,
    CONST LPD3DXMATERIAL rgMaterials,
    DWORD cMaterials,
    DWORD xFormat,
    PBYTE pbPMData,
    DWORD cbPMData
    );

// -------------------------------------------------------------------------------
//  method    Save
//
//  devnote     Save a half edge progressive mesh to the given stream
//                  NOTE: currently NOT IMPLEMENTED
//
//  returns     returns false if not valid
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT
GXHalfEdgePMesh<UINT_IDX,b16BitIndex,UNUSED>::Save
    (
    IStream *pstream, 
    D3DXMATERIAL *rgMaterials, 
    DWORD cMaterials
    )
{
#if 1
    return E_NOTIMPL;
#else
    HRESULT hr = S_OK;
    LPD3DXMESH ptmMesh = NULL;
    DWORD dwOptions;
    DWORD cVerticesOrig = m_cCurrentWedges;
    HANDLE hfile = INVALID_HANDLE_VALUE;
    DWORD cch;
    DWORD cbRead;
    DWORD cbWritten;
    DWORD iMat;
    DWORD iae;
    DWORD ivs;
    PBYTE pbData = NULL;
    PBYTE pbCur;
    DWORD cbData;
    //DWORD cTemp;

    char szTempPath[MAX_PATH];
    char *rgbBuffer = szTempPath;
    char szTempFileName[MAX_PATH];
    BOOL bFileCreated = FALSE;

    // goto the lowest LOD
    hr = SetNumVertices(1);
    if (FAILED(hr))
        goto e_Exit;

    // make a clone of the mesh, so that it is easier to save to a file
    dwOptions = m_tmTriMesh.m_dwOptions | D3DXMESH_SYSTEMMEM;
    GXASSERT(!(dwOptions & D3DXMESH_VB_SHARE));
    hr = CloneMeshInternal(dwOptions, m_tmTriMesh.m_dwFVF, m_tmTriMesh.m_pD3DDevice, TRUE, 0, NULL, NULL, NULL, &ptmMesh);
    if (FAILED(hr))
        goto e_Exit;

    cch = GetTempPath(sizeof(szTempPath), szTempPath);
    if ((cch == 0) || (cch > sizeof(szTempPath)))
    {
        hr = E_FAIL;
        goto e_Exit;
    }

    if (GetTempFileName(szTempPath, "pmx", 0, szTempFileName) == 0)
    {
        hr = E_FAIL;
        goto e_Exit;
    }
    bFileCreated = true;

    cbData = sizeof(DWORD) // nAttributes
             + m_tmTriMesh.m_caeAttributeTable*sizeof(DWORD)*6 // PM AttributeRanges
             + sizeof(DWORD) // nMaxValence
             + sizeof(DWORD) // nMinLogicalVertices
             + sizeof(DWORD) // nMaxLogicalVertices
             + sizeof(DWORD) // nVSplits
             + m_cvsVsplits * (sizeof(DWORD) + sizeof(DWORD) * 2) // rgVSplits
             + sizeof(DWORD) // nMaterial mispredicts
             + m_cMaterialNewMax * sizeof(DWORD);  // material mispredicts

    pbData = pbCur = new BYTE[cbData];
    if (pbData == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    // add the attribute table to the data
    WRITE_DWORD(pbCur, m_tmTriMesh.m_caeAttributeTable);
    for (iae = 0; iae < m_tmTriMesh.m_caeAttributeTable; iae++)
    {
        WRITE_DWORD(pbCur, m_tmTriMesh.m_rgaeAttributeTable[iae].FaceStart);
        WRITE_DWORD(pbCur, m_tmTriMesh.m_rgaeAttributeTable[iae].FaceCount);
        WRITE_DWORD(pbCur, m_rgaeAttributeTableFull[iae].FaceCount);

        WRITE_DWORD(pbCur, m_tmTriMesh.m_rgaeAttributeTable[iae].VertexStart);
        WRITE_DWORD(pbCur, m_tmTriMesh.m_rgaeAttributeTable[iae].VertexCount);
        WRITE_DWORD(pbCur, m_rgaeAttributeTableFull[iae].VertexCount);
    }

    // append the max valence used for internal buffer sizes
    WRITE_DWORD(pbCur, m_vsi.cpwLCLWtoRCCWMax);

    // write logical vertex values that are hard to recompute from data in attribute table
    WRITE_DWORD(pbCur, m_cBaseVertices);
    WRITE_DWORD(pbCur, m_cMaxVertices);

    WRITE_DWORD(pbCur, m_cvsVsplits);
    for (ivs = 0; ivs < m_cvsVsplits; ivs++)
    {
        WRITE_DWORD(pbCur, m_rgvsVsplits[ivs].m_iFlclw);
         WRITE_DWORD(pbCur, m_rgvsVsplits[ivs].m_oVlrOffset);
         WRITE_DWORD(pbCur, m_rgvsVsplits[ivs].m_code);
    }

    WRITE_DWORD(pbCur, m_cMaterialNewMax);
    for (iMat = 0; iMat < m_cMaterialNewMax; iMat++)
    {
        WRITE_DWORD(pbCur, m_rgiMaterialNew[iMat]);
    } 

    hr = D3DXSaveMeshToXEx(szTempFileName, ptmMesh, NULL, rgMaterials, cMaterials, DXFILEFORMAT_BINARY, pbData, cbData);
    if (FAILED(hr))
        goto e_Exit;


    // now reopen the file to write it to the stream
    hfile = CreateFile(szTempFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hfile == INVALID_HANDLE_VALUE)
    {
        hr = E_FAIL;
        goto e_Exit;
    }

    // copy the file into the stream
    while (1)
    {
        if (ReadFile(hfile, rgbBuffer, MAX_PATH, &cbRead, NULL) == 0)
        {
            hr = E_FAIL;
            goto e_Exit;
        }

        if (cbRead == 0)
            break;

        hr = pstream->Write(rgbBuffer, cbRead, &cbWritten);
        if (FAILED(hr))
            goto e_Exit;
        if (cbWritten < cbRead)
        {
            hr = E_FAIL;
            goto e_Exit;
        }
    }

e_Exit:
    GXRELEASE(ptmMesh);
    delete []pbData;

    // reset LOD on entry
    if (m_iCurPos != cVerticesOrig)
    {
        SetNumVertices(cVerticesOrig);
    }

    if (hfile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hfile);
    }

    if (bFileCreated)
    {
        DeleteFile(szTempFileName);
    }

    return hr;
#endif
}

// -------------------------------------------------------------------------------
//  method    LoadFromData
//
//  devnote     Load a half edge progressive mesh from the data provided
//                  NOTE: INTERNAL function, used by D3DXCreatePMeshFromStream
//
//  returns     returns false if not valid
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT
GXHalfEdgePMesh<UINT_IDX,b16BitIndex,UNUSED>::LoadFromData
    (
    LPD3DXMESH ptmD3DXMesh, 
    DWORD *rgdwAdjacency, 
    PBYTE pbPMData,
    DWORD cbPMData
    )
{
    HRESULT hr = S_OK;
    DWORD iMat;
    DWORD iae;
    DWORD ivs;
    DWORD iFace;
    DWORD iPoint;
    PBYTE pbCur = pbPMData;
    DWORD dwMaterial;
    DWORD *pdwAdjacency;
    LPDIRECT3DVERTEXBUFFER8 pvbSrc = NULL;
    LPDIRECT3DINDEXBUFFER8  pibSrc = NULL;
    PBYTE pbPointsSrc = NULL;
    PBYTE pbPointsDest = NULL;
    UINT_IDX *pwFaceSrc;
    UINT_IDX *rgwFacesSrc = NULL;
    GXTri3Face<UINT_IDX> *rgwFacesDest = NULL;
    D3DXATTRIBUTERANGE *pae;
    DWORD iFaceEnd;
    DWORD iCurEnd;
    DWORD iPrevEnd;
    DWORD iaeSearch;
    DWORD iCurFileAttribEnd;
    DWORD iPrevFileAttribEnd;


    GXASSERT(ptmD3DXMesh != NULL);
    GXASSERT(rgdwAdjacency != NULL);
    GXASSERT(pbPMData != NULL);
    GXASSERT(cbPMData > 0);

    // make certain that the mesh is the same from
    if ((ptmD3DXMesh->GetOptions() & D3DXMESH_32BIT) != (GetOptions() & D3DXMESH_32BIT))
    {
        hr = D3DERR_INVALIDCALL;
        goto e_Exit;
    }

    // allocate the object to handle shared data
    m_pPMSharedData = new CPMSharedData;
    if (m_pPMSharedData == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    // allocate the attribute tables
    m_tmTriMesh.m_caeAttributeTable = READ_DWORD(pbCur);
    m_tmTriMesh.m_rgaeAttributeTable = new D3DXATTRIBUTERANGE[m_tmTriMesh.m_caeAttributeTable];
    m_rgaeAttributeTableFull = new D3DXATTRIBUTERANGE[m_tmTriMesh.m_caeAttributeTable];
    if ((m_tmTriMesh.m_rgaeAttributeTable == NULL) || (m_rgaeAttributeTableFull == NULL))
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    // load the attribute tables
    m_cMaxWedges = 0;
    m_cMaxFaces = 0;
    m_cBaseWedges = 0;
    for (iae = 0; iae < m_tmTriMesh.m_caeAttributeTable; iae++)
    {
        m_tmTriMesh.m_rgaeAttributeTable[iae].AttribId = iae;
        m_rgaeAttributeTableFull[iae].AttribId = iae;

        m_tmTriMesh.m_rgaeAttributeTable[iae].FaceStart = READ_DWORD(pbCur);
        m_tmTriMesh.m_rgaeAttributeTable[iae].FaceCount = READ_DWORD(pbCur);
        m_rgaeAttributeTableFull[iae].FaceStart = m_tmTriMesh.m_rgaeAttributeTable[iae].FaceStart;
        m_rgaeAttributeTableFull[iae].FaceCount = READ_DWORD(pbCur);

        m_tmTriMesh.m_rgaeAttributeTable[iae].VertexStart = READ_DWORD(pbCur);
        m_tmTriMesh.m_rgaeAttributeTable[iae].VertexCount = READ_DWORD(pbCur);
        m_rgaeAttributeTableFull[iae].VertexStart = m_tmTriMesh.m_rgaeAttributeTable[iae].VertexStart;
        m_rgaeAttributeTableFull[iae].VertexCount = READ_DWORD(pbCur);

        m_cMaxWedges += m_rgaeAttributeTableFull[iae].VertexCount;
        m_cMaxFaces += m_rgaeAttributeTableFull[iae].FaceCount;
        m_cBaseWedges += m_tmTriMesh.m_rgaeAttributeTable[iae].VertexCount;
    }

    // init internal vars
    m_cBaseFaces = ptmD3DXMesh->GetNumFaces();
    m_cCurrentFaces = m_cBaseFaces;
    m_iCurPos = 0;
    m_cCurrentWedges = m_cBaseWedges;

    // read the max valence used for internal buffer sizes
    m_vsi.cpwLCLWtoRCCWMax = READ_DWORD(pbCur);
    m_vsi.rgpwLCLWtoRCCW = new UINT_IDX*[m_vsi.cpwLCLWtoRCCWMax];
    if (m_vsi.rgpwLCLWtoRCCW == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }
    
    m_cBaseVertices = READ_DWORD(pbCur);
    m_cMaxVertices = READ_DWORD(pbCur);

    // allocate the vsplit records
    m_cvsVsplits = READ_DWORD(pbCur);
    m_rgvsVsplits = new CHalfEdgeVSplit[m_cvsVsplits];
    m_pPMSharedData->m_rgvsVsplits = m_rgvsVsplits;
    if (m_rgvsVsplits == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    // load the vsplit records
    for (ivs = 0; ivs < m_cvsVsplits; ivs++)
    {
        m_rgvsVsplits[ivs].m_iFlclw = READ_DWORD(pbCur);
        m_rgvsVsplits[ivs].m_oVlrOffset = READ_DWORD(pbCur);
        m_rgvsVsplits[ivs].m_code = READ_DWORD(pbCur);
    }

    // allocate the material mispredict array
    m_cMaterialNewMax = READ_DWORD(pbCur);
    m_rgiMaterialNew = new UINT16[m_cMaterialNewMax];
    m_pPMSharedData->m_rgiMaterialNew = m_rgiMaterialNew;
    if (m_rgiMaterialNew == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    for (iMat = 0; iMat < m_cMaterialNewMax; iMat++)
    {
        dwMaterial = READ_DWORD(pbCur);

        if (dwMaterial > UNUSED16)
        {
            hr = D3DERR_INVALIDCALL;
            goto e_Exit;
        }

        m_rgiMaterialNew[iMat] = (UINT16)dwMaterial;
    } 
    
    // resize the mesh in the pm to be large enough for max LOD
    hr = m_tmTriMesh.Resize(m_cMaxFaces, m_cMaxWedges);
    if (FAILED(hr))
        goto e_Exit;

    // next get all the src/dest face and vertex pointers
    hr = ptmD3DXMesh->GetIndexBuffer(&pibSrc);
    if (FAILED(hr))
        goto e_Exit;

    hr = pibSrc->Lock(0, 0, (PBYTE*)&rgwFacesSrc, 0 );
    if (FAILED(hr))
        goto e_Exit;

    hr = m_tmTriMesh.LockIB((PBYTE*)&rgwFacesDest);
    if (FAILED(hr))
        goto e_Exit;

    hr = ptmD3DXMesh->GetVertexBuffer(&pvbSrc);
    if (FAILED(hr))
        goto e_Exit;

    hr = pvbSrc->Lock(0, 0, &pbPointsSrc, 0 );
    if (FAILED(hr))
        goto e_Exit;

    hr = m_tmTriMesh.LockVB(&pbPointsDest);
    if (FAILED(hr))
        goto e_Exit;

    // now copy the face data, splitting it into the various attribute pieces
    pdwAdjacency = rgdwAdjacency;
    pwFaceSrc = rgwFacesSrc;
    iPrevFileAttribEnd = 0;
    iCurFileAttribEnd = 0;
    for (iae = 0; iae < m_tmTriMesh.m_caeAttributeTable; iae++)
    {
        pae = &m_tmTriMesh.m_rgaeAttributeTable[iae];

        // first copy the data in the base mesh into the proper attribute section
        iFaceEnd = pae->FaceStart + pae->FaceCount;
        iPrevFileAttribEnd = iCurFileAttribEnd;
        iCurFileAttribEnd += pae->FaceCount;
        for (iFace = pae->FaceStart; iFace < iFaceEnd; iFace++)
        {
            // setup material indices
            m_tmTriMesh.m_rgiMaterialIndex[iFace] = (UINT16)iae;

            // now copy the neighbor and face data
            for (iPoint = 0; iPoint < 3; iPoint++)
            {
                if (*pdwAdjacency == UNUSED32)
                    m_tmTriMesh.m_rgpniNeighbors[iFace].m_iNeighbors[iPoint] = UNUSED;
                else if (((UINT_IDX)*pdwAdjacency >= iPrevFileAttribEnd) && ((UINT_IDX)*pdwAdjacency < iCurFileAttribEnd))
                    m_tmTriMesh.m_rgpniNeighbors[iFace].m_iNeighbors[iPoint] = (UINT_IDX)*pdwAdjacency - (UINT_IDX)iPrevFileAttribEnd + (UINT_IDX)m_rgaeAttributeTableFull[iae].FaceStart;
                else
                {
                    iCurEnd = 0;
                    for (iaeSearch = 0; iaeSearch < m_tmTriMesh.m_caeAttributeTable; iaeSearch++)
                    {
                        iPrevEnd = iCurEnd;
                        iCurEnd += m_tmTriMesh.m_rgaeAttributeTable[iaeSearch].FaceCount;

                        if ((UINT_IDX)*pdwAdjacency < iCurEnd)
                        {
                            m_tmTriMesh.m_rgpniNeighbors[iFace].m_iNeighbors[iPoint] = (UINT_IDX)(*pdwAdjacency - iPrevEnd + m_rgaeAttributeTableFull[iaeSearch].FaceStart);
                            break;
                        }

                    }
                    GXASSERT(iaeSearch < m_tmTriMesh.m_caeAttributeTable);


                }

                pdwAdjacency += 1;

                rgwFacesDest[iFace].m_wIndices[iPoint] = *pwFaceSrc;
                pwFaceSrc += 1;
            }
        }

        // now intialize the rest of the data for the skipped section
        iFaceEnd = pae->FaceStart + m_rgaeAttributeTableFull[iae].FaceCount;
        for (iFace = pae->FaceStart + pae->FaceCount; iFace < iFaceEnd; iFace++)
        {
            // same as before, just a lookup to see what attribute it is in
            m_tmTriMesh.m_rgiMaterialIndex[iFace] = (UINT16)iae;

            // initialize skipped faces to unused
            for (iPoint = 0; iPoint < 3; iPoint++)
            {
                m_tmTriMesh.m_rgpniNeighbors[iFace].m_iNeighbors[iPoint] = UNUSED;
                rgwFacesDest[iFace].m_wIndices[iPoint] = UNUSED;
            }
        }
    }

    // the vertices are already set up in the correct order, just copy them
    memcpy(pbPointsDest, pbPointsSrc, m_tmTriMesh.m_cBytesPerVertex * m_tmTriMesh.m_cVertices);

    GXASSERT(m_tmTriMesh.BValid());

e_Exit:

    if (rgwFacesDest != NULL)
    {
        m_tmTriMesh.UnlockIB();
    }

    if (rgwFacesSrc != NULL)
    {
        pibSrc->Unlock();
    }
    GXRELEASE(pibSrc);

    if (pbPointsDest != NULL)
    {
        m_tmTriMesh.UnlockVB();
    }

    if (pbPointsSrc != NULL)
    {
        pvbSrc->Unlock();
    }
    GXRELEASE(pvbSrc);


    return hr;
}

// -------------------------------------------------------------------------------
//   VSplit and ECollapse code
// -------------------------------------------------------------------------------

// -------------------------------------------------------------------------------
//  method    GatherVSplitInfo
//
//  devnote   Collects information required for an vsplit into m_vsi
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
void
GXHalfEdgePMesh<UINT_IDX,b16BitIndex,UNUSED>::GatherVSplitInfo
    (
    CHalfEdgeVSplit &vsNext
    )
{
    CFaceListIter<UINT_IDX,b16BitIndex,UNUSED> fli(&m_tmTriMesh);
    UINT_IDX iOffset;
    UINT_IDX iFace;
    int iTemp;
	WORD code = vsNext.m_code;
    D3DXATTRIBUTERANGE *pae;

#ifdef _DEBUG
	UINT_IDX iVertexTest = UNUSED;
	DWORD cVerticesStart = m_tmTriMesh.m_cVertices;
#endif

    m_vsi.cpwLCLWtoRCCW = 0;

    // if the offset to the RCCW is greater than zero, then there is an R face
    m_vsi.bIsFaceR = vsNext.m_oVlrOffset > 0;

    // first find iFlclw
    m_vsi.iFaceLCLW = (UINT_IDX)vsNext.m_iFlclw;
    m_vsi.iEdgeLCLW = vsNext.IGetVsIndex();

    // next find the wedge of the vertex
    m_vsi.iVertex1 = m_tmTriMesh.m_pFaces[m_vsi.iFaceLCLW].m_wIndices[m_vsi.iEdgeLCLW];

    // find iFlccw
    m_vsi.iFaceLCCW = m_tmTriMesh.m_rgpniNeighbors[m_vsi.iFaceLCLW].m_iNeighbors[MOD3(m_vsi.iEdgeLCLW+2)];
    if (m_vsi.iFaceLCCW != UNUSED)
    {
        m_vsi.iEdgeLCCW = FindEdge(m_tmTriMesh.m_rgpniNeighbors[m_vsi.iFaceLCCW].m_iNeighbors, m_vsi.iFaceLCLW);
    }

    // determine the face material for the left face
    if (!(code & CHalfEdgeVSplit::FLN_MASK))
    {
        m_vsi.iMaterialIndexLeft = m_tmTriMesh.m_rgiMaterialIndex[m_vsi.iFaceLCLW];
    }
    else
    {
        GXASSERT(m_cMaterialNewCur < m_cMaterialNewMax);
        m_vsi.iMaterialIndexLeft  = m_rgiMaterialNew[m_cMaterialNewCur];
        m_cMaterialNewCur += 1;
    }

    // the face index is the next in the given material
    pae = &m_tmTriMesh.m_rgaeAttributeTable[m_vsi.iMaterialIndexLeft];
    m_vsi.iFaceL = (UINT_IDX)pae->FaceStart + ((UINT_IDX)pae->FaceCount);
    pae->FaceCount += 1;
    m_cCurrentFaces += 1;

    // if there is a right face, collect the info
    if (m_vsi.bIsFaceR)
    {
        // start at iFlclw and walk to the ccw on for the right
        fli.Init(m_vsi.iFaceLCLW, m_vsi.iVertex1, x_iClockwise);
        for (iOffset = 0; iOffset < vsNext.m_oVlrOffset; iOffset++) 
        {
            GXASSERT(!fli.BEndOfList());
            iFace = fli.GetNextFace();

#ifdef _DEBUG
			// if another Wedge was not found yet, then see if we are still on the original one
			//    once we switch off of the original one, we must always be on the second one
			if (iVertexTest == UNUSED)
			{			
				if (m_tmTriMesh.m_pFaces[iFace].m_wIndices[fli.IGetPointIndex()] != m_vsi.iVertex1)
					iVertexTest = m_tmTriMesh.m_pFaces[iFace].m_wIndices[fli.IGetPointIndex()];
			}
			else
			{
				GXASSERT(m_tmTriMesh.m_pFaces[iFace].m_wIndices[fli.IGetPointIndex()] == iVertexTest);
			}
#endif

            // store off a pointer to the wedge for the current face
            m_vsi.rgpwLCLWtoRCCW[iOffset] = &(m_tmTriMesh.m_pFaces[iFace].m_wIndices[fli.IGetPointIndex()]);
        }
        m_vsi.iFaceRCCW = iFace;
        m_vsi.iEdgeRCCW = fli.IGetPointIndex();

        // setup the cpwLCLWtoRCCW from VlrOffset
        m_vsi.cpwLCLWtoRCCW = vsNext.m_oVlrOffset;
        GXASSERT(m_vsi.cpwLCLWtoRCCW <= m_vsi.cpwLCLWtoRCCWMax);


        // if we are at the end of the list, then there is no CLW face for the right
        //   else, retrieve it
        if (fli.BEndOfList())
        {
            m_vsi.iFaceRCLW = UNUSED;
        }
        else
        {
            fli.PeekNextFace(m_vsi.iFaceRCLW, iTemp);
            m_vsi.iEdgeRCLW = iTemp;
        }

        // determine the face material for the right face
        if (!(code & CHalfEdgeVSplit::FRN_MASK))
        {
            m_vsi.iMaterialIndexRight = m_tmTriMesh.m_rgiMaterialIndex[m_vsi.iFaceRCCW];
        }
        else
        {
            GXASSERT(m_cMaterialNewCur < m_cMaterialNewMax);
            m_vsi.iMaterialIndexRight = m_rgiMaterialNew[m_cMaterialNewCur];
            m_cMaterialNewCur += 1;
        }

        // the face index is the next in the given material
        pae = &m_tmTriMesh.m_rgaeAttributeTable[m_vsi.iMaterialIndexRight];
        m_vsi.iFaceR = (UINT_IDX)pae->FaceStart + ((UINT_IDX)pae->FaceCount);
        pae->FaceCount += 1;
        m_cCurrentFaces += 1;


        // now generate the values of the wedges

		m_vsi.iWedgeVtfl = GetNextWedge(m_vsi.iMaterialIndexLeft);

		if (!(code & CHalfEdgeVSplit::T_LSAME) && ! (code & CHalfEdgeVSplit::S_LSAME) && !( (code & CHalfEdgeVSplit::S_CSAME) && (code & CHalfEdgeVSplit::S_RSAME)) )
			m_vsi.iWedgeVsfl = GetNextWedge(m_vsi.iMaterialIndexLeft);
		else if (code & CHalfEdgeVSplit::T_LSAME)
			m_vsi.iWedgeVsfl = m_vsi.iVertex1;
		else 
			m_vsi.iWedgeVsfl = m_tmTriMesh.m_pFaces[m_vsi.iFaceLCCW].m_wIndices[m_vsi.iEdgeLCCW];


		if (code & CHalfEdgeVSplit::L_NEW)
			m_vsi.iWedgeL = GetNextWedge(m_vsi.iMaterialIndexLeft);
		else if ( !(code & CHalfEdgeVSplit::L_BELOW) )
			m_vsi.iWedgeL = m_tmTriMesh.m_pFaces[m_vsi.iFaceLCLW].m_wIndices[MOD3(m_vsi.iEdgeLCLW+2)];
		else // BELOW
			m_vsi.iWedgeL = m_tmTriMesh.m_pFaces[m_vsi.iFaceLCCW].m_wIndices[MOD3(m_vsi.iEdgeLCCW+1)];


		if (code & CHalfEdgeVSplit::T_CSAME)
			m_vsi.iWedgeVtfr = m_vsi.iWedgeVtfl;
		else 
			m_vsi.iWedgeVtfr = GetNextWedge(m_vsi.iMaterialIndexRight);

		if (code & CHalfEdgeVSplit::S_CSAME)
			m_vsi.iWedgeVsfr = m_vsi.iWedgeVsfl;
		else if (!(code & CHalfEdgeVSplit::T_RSAME) && !(code & CHalfEdgeVSplit::S_RSAME))
			m_vsi.iWedgeVsfr = GetNextWedge(m_vsi.iMaterialIndexRight);
		else if (code & CHalfEdgeVSplit::T_RSAME)
			m_vsi.iWedgeVsfr = m_tmTriMesh.m_pFaces[m_vsi.iFaceRCCW].m_wIndices[m_vsi.iEdgeRCCW];
		else 
			m_vsi.iWedgeVsfr = m_tmTriMesh.m_pFaces[m_vsi.iFaceRCLW].m_wIndices[m_vsi.iEdgeRCLW];


		if (code & CHalfEdgeVSplit::R_NEW)
			m_vsi.iWedgeR = GetNextWedge(m_vsi.iMaterialIndexRight);
		else if ( !(code & CHalfEdgeVSplit::R_BELOW) )
	        m_vsi.iWedgeR = m_tmTriMesh.m_pFaces[m_vsi.iFaceRCCW].m_wIndices[MOD3(m_vsi.iEdgeRCCW+1)];
		else // BELOW
			m_vsi.iWedgeR = m_tmTriMesh.m_pFaces[m_vsi.iFaceRCLW].m_wIndices[MOD3(m_vsi.iEdgeRCLW+2)];

		// if iFlclw shouldn't get iWedgeVtfl stamped on it (i.e. it should get iWedgeVtfr)
		//		then change iVertex1 so that the check when applying the vsplit fails
		//			The only time this is necessary is if iFlclw's wedge is different from Fl's
		if (! (code & CHalfEdgeVSplit::T_LSAME) )
			m_vsi.iVertex1 = UNUSED;


        // sanity checks
        GXASSERT((code & CHalfEdgeVSplit::S_CSAME) || (m_vsi.iWedgeVsfr != m_vsi.iWedgeVsfl));
        GXASSERT((code & CHalfEdgeVSplit::T_CSAME) || (m_vsi.iWedgeVtfr != m_vsi.iWedgeVtfl));
    }
    else  // just record UNUSED
    {
        m_vsi.iFaceRCLW = UNUSED;
        m_vsi.iFaceRCCW = UNUSED;
        m_vsi.iFaceR = UNUSED;

        // Rotate around and record all wedges CLW from iWedgeLCLW.
        fli.Init(m_vsi.iFaceLCLW, m_vsi.iVertex1, x_iClockwise);
        while (!fli.BEndOfList())
        {
            iFace = fli.GetNextFace();

			// can only be one wedge above
			GXASSERT(m_tmTriMesh.m_pFaces[iFace].m_wIndices[fli.IGetPointIndex()] == m_vsi.iVertex1);

            // store off a pointer to the wedge for the current face
            m_vsi.rgpwLCLWtoRCCW[m_vsi.cpwLCLWtoRCCW] = &(m_tmTriMesh.m_pFaces[iFace].m_wIndices[fli.IGetPointIndex()]);
            m_vsi.cpwLCLWtoRCCW += 1;
        }

		m_vsi.iWedgeVtfl = GetNextWedge(m_vsi.iMaterialIndexLeft);

		if (!(code & CHalfEdgeVSplit::T_LSAME) && !(code & CHalfEdgeVSplit::S_LSAME))
			m_vsi.iWedgeVsfl = GetNextWedge(m_vsi.iMaterialIndexLeft);
		else
			m_vsi.iWedgeVsfl = m_vsi.iVertex1;

		if (code & CHalfEdgeVSplit::L_NEW)
			m_vsi.iWedgeL = GetNextWedge(m_vsi.iMaterialIndexLeft);
		else if ( !(code & CHalfEdgeVSplit::L_BELOW) )
			m_vsi.iWedgeL = m_tmTriMesh.m_pFaces[m_vsi.iFaceLCLW].m_wIndices[MOD3(m_vsi.iEdgeLCLW+2)];
		else // BELOW
			m_vsi.iWedgeL = m_tmTriMesh.m_pFaces[m_vsi.iFaceLCCW].m_wIndices[MOD3(m_vsi.iEdgeLCCW+1)];

#ifdef _DEBUG
		m_vsi.iWedgeVtfr = UNUSED;
		m_vsi.iWedgeVsfr = UNUSED;
		m_vsi.iWedgeR = UNUSED;
#endif
    }

#ifdef _DEBUG
    if (!m_vsi.bIsFaceR)
        m_vsi.iWedgeR = UNUSED;
#endif
}

// -------------------------------------------------------------------------------
//  method    ApplyVSplit
//
//  devnote     Apply the given vsplit record
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
void
GXHalfEdgePMesh<UINT_IDX,b16BitIndex,UNUSED>::ApplyVSplit
    (
    CHalfEdgeVSplit &vsNext
    )
{
    UINT_IDX ipw;

    // gather info into m_vsi member variable
    GatherVSplitInfo(vsNext);

    // update the neighbors that need to use the new vertex to the new vertex
    for (ipw = 0; ipw < m_vsi.cpwLCLWtoRCCW; ipw++)
    {
		// UNDONE - sometimes neds to be Vtfl and sometimes Vtfr
		if (*m_vsi.rgpwLCLWtoRCCW[ipw] == m_vsi.iVertex1)
			*m_vsi.rgpwLCLWtoRCCW[ipw] = m_vsi.iWedgeVtfl;
		else
			*m_vsi.rgpwLCLWtoRCCW[ipw] = m_vsi.iWedgeVtfr;
    }

    // setup the new triangles
    //   NOTE: if we have already had the LOD this high, then the data
    //       should already be in place
    m_tmTriMesh.m_pFaces[m_vsi.iFaceL].m_wIndices[0] = m_vsi.iWedgeVsfl;
    m_tmTriMesh.m_pFaces[m_vsi.iFaceL].m_wIndices[1] = m_vsi.iWedgeVtfl;
    m_tmTriMesh.m_pFaces[m_vsi.iFaceL].m_wIndices[2] = m_vsi.iWedgeL;

    m_tmTriMesh.m_rgpniNeighbors[m_vsi.iFaceL].m_iNeighbors[0]=m_vsi.iFaceR;
    m_tmTriMesh.m_rgpniNeighbors[m_vsi.iFaceL].m_iNeighbors[1]=m_vsi.iFaceLCLW;
    m_tmTriMesh.m_rgpniNeighbors[m_vsi.iFaceL].m_iNeighbors[2]=m_vsi.iFaceLCCW;

    m_tmTriMesh.m_rgiMaterialIndex[m_vsi.iFaceL] = m_vsi.iMaterialIndexLeft;

    // update the adjanceny of other neighbors
    if (m_vsi.iFaceLCCW != UNUSED) 
        m_tmTriMesh.m_rgpniNeighbors[m_vsi.iFaceLCCW].m_iNeighbors[m_vsi.iEdgeLCCW]=m_vsi.iFaceL;

    if (m_vsi.iFaceLCLW != UNUSED) 
        m_tmTriMesh.m_rgpniNeighbors[m_vsi.iFaceLCLW].m_iNeighbors[MOD3(m_vsi.iEdgeLCLW+2)]=m_vsi.iFaceL;

    // add in the right face if present
    if (m_vsi.bIsFaceR)
    {
        m_tmTriMesh.m_pFaces[m_vsi.iFaceR].m_wIndices[0] = m_vsi.iWedgeVsfr;
        m_tmTriMesh.m_pFaces[m_vsi.iFaceR].m_wIndices[1] = m_vsi.iWedgeR;
        m_tmTriMesh.m_pFaces[m_vsi.iFaceR].m_wIndices[2] = m_vsi.iWedgeVtfr;

        m_tmTriMesh.m_rgpniNeighbors[m_vsi.iFaceR].m_iNeighbors[0]=m_vsi.iFaceRCLW;
        m_tmTriMesh.m_rgpniNeighbors[m_vsi.iFaceR].m_iNeighbors[1]=m_vsi.iFaceRCCW;
        m_tmTriMesh.m_rgpniNeighbors[m_vsi.iFaceR].m_iNeighbors[2]=m_vsi.iFaceL;

        m_tmTriMesh.m_rgiMaterialIndex[m_vsi.iFaceR] = m_vsi.iMaterialIndexRight;

        // update the adjanceny of other neighbors
        if (m_vsi.iFaceRCCW != UNUSED) 
            m_tmTriMesh.m_rgpniNeighbors[m_vsi.iFaceRCCW].m_iNeighbors[m_vsi.iEdgeRCCW]=m_vsi.iFaceR;

        if (m_vsi.iFaceRCLW != UNUSED) 
            m_tmTriMesh.m_rgpniNeighbors[m_vsi.iFaceRCLW].m_iNeighbors[MOD3(m_vsi.iEdgeRCLW+2)]=m_vsi.iFaceR;
    }    
}


// -------------------------------------------------------------------------------
//  method    GatherECollapseInfo
//
//  devnote   Collects information required for an edge collapse into m_vsi
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
void
GXHalfEdgePMesh<UINT_IDX,b16BitIndex,UNUSED>::GatherECollapseInfo
    (
    CHalfEdgeVSplit &vsLast
    )
{
	WORD code = vsLast.m_code;
    DWORD cVertexIndices;

    // if the offset to the RCCW is greater than zero, then there is an R face
    m_vsi.bIsFaceR = vsLast.m_oVlrOffset > 0;

    // update the mispredict array
    GXASSERT(((code & CHalfEdgeVSplit::FLN_MASK) >> CHalfEdgeVSplit::FLN_SHIFT) <= 1);
    m_cMaterialNewCur -= (code & CHalfEdgeVSplit::FLN_MASK) >> CHalfEdgeVSplit::FLN_SHIFT;

    // the flclw is in the vsplit record
    m_vsi.iFaceLCLW = (UINT_IDX)vsLast.m_iFlclw;
    m_vsi.iEdgeLCLW = vsLast.IGetVsIndex();

    // next find the wedge of the vertex
    m_vsi.iVertex1 = m_tmTriMesh.m_pFaces[m_vsi.iFaceLCLW].m_wIndices[m_vsi.iEdgeLCLW];

    // find iFaceL
    m_vsi.iFaceL = m_tmTriMesh.m_rgpniNeighbors[m_vsi.iFaceLCLW].m_iNeighbors[MOD3(m_vsi.iEdgeLCLW+2)];

    // get the material index and update the face count
    m_vsi.iMaterialIndexLeft = m_tmTriMesh.m_rgiMaterialIndex[m_vsi.iFaceL];
    m_tmTriMesh.m_rgaeAttributeTable[m_vsi.iMaterialIndexLeft].FaceCount -= 1;
    m_cCurrentFaces -= 1;

    m_vsi.iFaceR = m_tmTriMesh.m_rgpniNeighbors[m_vsi.iFaceL].m_iNeighbors[0];

    // if there is a right face, load the right info
    if (m_vsi.bIsFaceR)
    {
        GXASSERT(m_vsi.iFaceR != UNUSED);

        // get the material index and update the face count
        m_vsi.iMaterialIndexRight = m_tmTriMesh.m_rgiMaterialIndex[m_vsi.iFaceR];
        m_tmTriMesh.m_rgaeAttributeTable[m_vsi.iMaterialIndexRight].FaceCount -= 1;
        m_cCurrentFaces -= 1;

        // update the mispredict array
        GXASSERT(((code & CHalfEdgeVSplit::FRN_MASK) >> CHalfEdgeVSplit::FRN_SHIFT) <= 1);
        m_cMaterialNewCur -= (code & CHalfEdgeVSplit::FRN_MASK) >> CHalfEdgeVSplit::FRN_SHIFT;

        // known info from how the triangle was created
        m_vsi.iFaceRCLW = m_tmTriMesh.m_rgpniNeighbors[m_vsi.iFaceR].m_iNeighbors[0];
        m_vsi.iFaceRCCW = m_tmTriMesh.m_rgpniNeighbors[m_vsi.iFaceR].m_iNeighbors[1];

		m_vsi.iWedgeVsfr = m_tmTriMesh.m_pFaces[m_vsi.iFaceR].m_wIndices[0];
		m_vsi.iWedgeVtfr = m_tmTriMesh.m_pFaces[m_vsi.iFaceR].m_wIndices[2];

        // get the pointer to the left material vertex indices count
        //pcVertexIndices = &m_tmTriMesh.m_rgaeAttributeTable[m_vsi.iMaterialIndexLeft].VertexCount;
        cVertexIndices =1 ;

		if (!(code & CHalfEdgeVSplit::T_LSAME) && ! (code & CHalfEdgeVSplit::S_LSAME) && !( (code & CHalfEdgeVSplit::S_CSAME) && (code & CHalfEdgeVSplit::S_RSAME)) )
			cVertexIndices += 1;

		if (code & CHalfEdgeVSplit::L_NEW)
			cVertexIndices += 1;

        m_tmTriMesh.m_rgaeAttributeTable[m_vsi.iMaterialIndexLeft].VertexCount -= cVertexIndices; 
        m_cCurrentWedges -= cVertexIndices;

        // get the pointer to the right material vertex indices count
        //pcVertexIndices = &m_tmTriMesh.m_rgaeAttributeTable[m_vsi.iMaterialIndexRight].VertexCount;
        cVertexIndices = 0;

		if (!(code & CHalfEdgeVSplit::T_CSAME))
			cVertexIndices += 1;

		if ( !(code & CHalfEdgeVSplit::S_CSAME) && !(code & CHalfEdgeVSplit::T_RSAME) && !(code & CHalfEdgeVSplit::S_RSAME))
			cVertexIndices += 1;

		if (code & CHalfEdgeVSplit::R_NEW)
			cVertexIndices += 1;

        m_tmTriMesh.m_rgaeAttributeTable[m_vsi.iMaterialIndexRight].VertexCount -= cVertexIndices;
        m_cCurrentWedges -= cVertexIndices;
    }
    else
    {
        // get the pointer to the left material vertex indices count
        //pcVertexIndices = &m_tmTriMesh.m_rgaeAttributeTable[m_vsi.iMaterialIndexLeft].VertexCount;
        cVertexIndices = 1 ;

		if (!(code & CHalfEdgeVSplit::T_LSAME) && !(code & CHalfEdgeVSplit::S_LSAME))
			cVertexIndices += 1;

		if (code & CHalfEdgeVSplit::L_NEW)
			cVertexIndices += 1;

        m_tmTriMesh.m_rgaeAttributeTable[m_vsi.iMaterialIndexLeft].VertexCount -= cVertexIndices; 
        m_cCurrentWedges -= cVertexIndices;
    }

    // known info from how the triangle was created
    m_vsi.iFaceLCCW = m_tmTriMesh.m_rgpniNeighbors[m_vsi.iFaceL].m_iNeighbors[2];

	m_vsi.iWedgeVsfl = m_tmTriMesh.m_pFaces[m_vsi.iFaceL].m_wIndices[0];
	m_vsi.iWedgeVtfl = m_tmTriMesh.m_pFaces[m_vsi.iFaceL].m_wIndices[1];
}

// -------------------------------------------------------------------------------
//  method    UndoVSplit
//
//  devnote     Undo the given vsplit record
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
void
GXHalfEdgePMesh<UINT_IDX,b16BitIndex,UNUSED>::UndoVSplit
    (
    CHalfEdgeVSplit &vsLast
    )
{
    CFaceListIter<UINT_IDX,b16BitIndex,UNUSED> fli(&m_tmTriMesh);
    DWORD iEdge;
    DWORD iOffset;
    DWORD iFace;
	UINT_IDX *pwCur;

    // collect the info required for the edge collapse into m_vsi
    GatherECollapseInfo(vsLast);

    // UNDONE UNDONE craigp - could make this look like the vsplit version
    if (m_vsi.bIsFaceR)
    {
        // start at iFlclw and walk to the ccw on for the right
        //          to make things easier, I start at iFaceL and increment oVlrOffset by 1
        //              otherwise I need to know which wedge is present in iFlclw to rotate around
        fli.Init(m_vsi.iFaceL, m_vsi.iWedgeVtfl, x_iClockwise);
        for (iOffset = 0; iOffset < (DWORD)(vsLast.m_oVlrOffset+1); iOffset++) 
        {
            GXASSERT(!fli.BEndOfList());
            iFace = fli.GetNextFace();

			pwCur = &m_tmTriMesh.m_pFaces[iFace].m_wIndices[fli.IGetPointIndex()];

            // just update all references of iWedgeVtfl to iWedgeVsfl and the same for
				//								iWedgeVtfr to iWedgeVsfr
			if (*pwCur == m_vsi.iWedgeVtfl)
				*pwCur = m_vsi.iWedgeVsfl;
			else
				*pwCur = m_vsi.iWedgeVsfr;
        }
    }
    else // no FaceR, but might be other triangles sharing iWedgeVtfl with iFlclw
    {
        // Rotate around and record all wedges CLW from iWedgeLCLW.
        fli.Init(m_vsi.iFaceL, m_vsi.iWedgeVtfl, x_iClockwise);
        while (!fli.BEndOfList())
        {
            iFace = fli.GetNextFace();

			pwCur = &m_tmTriMesh.m_pFaces[iFace].m_wIndices[fli.IGetPointIndex()];

            // just update all references of iWedgeVtfl to iWedgeVsfl and the same for
				//								iWedgeVtfr to iWedgeVsfr
			if (*pwCur == m_vsi.iWedgeVtfl)
				*pwCur = m_vsi.iWedgeVsfl;
			else
				*pwCur = m_vsi.iWedgeVsfr;
        }
    }

    // update the neighborhood to link around iFaceL
    if (m_vsi.iFaceLCCW != UNUSED) 
    {
        iEdge = FindEdge(m_tmTriMesh.m_rgpniNeighbors[m_vsi.iFaceLCCW].m_iNeighbors, m_vsi.iFaceL);
        GXASSERT(iEdge < 3);

        m_tmTriMesh.m_rgpniNeighbors[m_vsi.iFaceLCCW].m_iNeighbors[iEdge] = m_vsi.iFaceLCLW;
    }

    if (m_vsi.iFaceLCLW != UNUSED) 
    {
        iEdge = FindEdge(m_tmTriMesh.m_rgpniNeighbors[m_vsi.iFaceLCLW].m_iNeighbors, m_vsi.iFaceL);
        GXASSERT(iEdge < 3);

        m_tmTriMesh.m_rgpniNeighbors[m_vsi.iFaceLCLW].m_iNeighbors[iEdge] = m_vsi.iFaceLCCW;
    }


    // update the neighborhood to link around iFaceR
    if (m_vsi.bIsFaceR)
    {
        if (m_vsi.iFaceRCCW != UNUSED) 
        {
            iEdge = FindEdge(m_tmTriMesh.m_rgpniNeighbors[m_vsi.iFaceRCCW].m_iNeighbors, m_vsi.iFaceR);
            GXASSERT(iEdge < 3);

            m_tmTriMesh.m_rgpniNeighbors[m_vsi.iFaceRCCW].m_iNeighbors[iEdge] = m_vsi.iFaceRCLW;
        }

        if (m_vsi.iFaceRCLW != UNUSED) 
        {
            iEdge = FindEdge(m_tmTriMesh.m_rgpniNeighbors[m_vsi.iFaceRCLW].m_iNeighbors, m_vsi.iFaceR);
            GXASSERT(iEdge < 3);

            m_tmTriMesh.m_rgpniNeighbors[m_vsi.iFaceRCLW].m_iNeighbors[iEdge] = m_vsi.iFaceRCCW;
        }
    }

#ifdef _DEBUG
    // to avoid asserts, mark the faces removed as unused in debug
    m_tmTriMesh.m_pFaces[m_vsi.iFaceL].m_wIndices[0] = UNUSED;
    m_tmTriMesh.m_pFaces[m_vsi.iFaceL].m_wIndices[1] = UNUSED;
    m_tmTriMesh.m_pFaces[m_vsi.iFaceL].m_wIndices[2] = UNUSED;
    m_tmTriMesh.m_rgpniNeighbors[m_vsi.iFaceL].m_iNeighbors[0] = UNUSED;
    m_tmTriMesh.m_rgpniNeighbors[m_vsi.iFaceL].m_iNeighbors[1] = UNUSED;
    m_tmTriMesh.m_rgpniNeighbors[m_vsi.iFaceL].m_iNeighbors[2] = UNUSED;

    if (m_vsi.bIsFaceR)
    {
        m_tmTriMesh.m_pFaces[m_vsi.iFaceR].m_wIndices[0] = UNUSED;
        m_tmTriMesh.m_pFaces[m_vsi.iFaceR].m_wIndices[1] = UNUSED;
        m_tmTriMesh.m_pFaces[m_vsi.iFaceR].m_wIndices[2] = UNUSED;
        m_tmTriMesh.m_rgpniNeighbors[m_vsi.iFaceR].m_iNeighbors[0] = UNUSED;
        m_tmTriMesh.m_rgpniNeighbors[m_vsi.iFaceR].m_iNeighbors[1] = UNUSED;
        m_tmTriMesh.m_rgpniNeighbors[m_vsi.iFaceR].m_iNeighbors[2] = UNUSED;
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\mesh\skinmesh.cpp ===
/*//////////////////////////////////////////////////////////////////////////////
//
// File: skinmesh.cpp
//
// Copyright (C) 2000 Microsoft Corporation. All Rights Reserved.
//
// @@BEGIN_MSINTERNAL
//
// History:
// -@- 03/17/99 (anujg)     - created 
//
// @@END_MSINTERNAL
//
//////////////////////////////////////////////////////////////////////////////*/

#include "pchmesh.h"

#include "skinmesh.h"
#include "cd3dxbitfield.h"

#define D3DX_MAX_BONES 256

const DWORD CD3DXBitField256::nibbleCount[] = { 0, // 0000
                                                1, // 0001
                                                1, // 0010
                                                2, // 0011
                                                1, // 0100
                                                2, // 0101
                                                2, // 0110
                                                3, // 0111
                                                1, // 1000
                                                2, // 1001
                                                2, // 1010
                                                3, // 1011
                                                2, // 1100
                                                3, // 1101
                                                3, // 1110
                                                4};// 1111

CBone::CBone()
{
	m_numWeights = 0;
	m_pVertIndices = NULL;
	m_pWeights = NULL;
}

CBone::~CBone()
{
	delete [] m_pVertIndices;
    m_pVertIndices = NULL;
	delete [] m_pWeights;
    m_pWeights = NULL;
}

CD3DXSkinMesh::CD3DXSkinMesh()
{
	m_pBones = NULL;
	m_pMesh = NULL;
    // used by GenerateSkinnedMesh
    m_fMinWeight        = 0.0f;
    m_bChangedWeights   = true;
    m_rgfCodes          = NULL;
    m_vertInfl = NULL;
    m_vertMatId = NULL;
    m_vertMatWeight = NULL;
    m_DataValid = 0;
}

CD3DXSkinMesh::~CD3DXSkinMesh()
{
	delete [] m_pBones;
    m_pBones = NULL;
    delete [] m_vertInfl;
    m_vertInfl = NULL;
    delete [] m_vertMatId;
    m_vertMatId = NULL;
    delete [] m_vertMatWeight;
    m_vertMatWeight = NULL;
	if (m_pMesh)
    {
		m_pMesh->Release();
        m_pMesh = NULL;
    }

    if (m_rgfCodes)
        delete[] m_rgfCodes;
}

HRESULT CD3DXSkinMesh::QueryInterface(REFIID riid, LPVOID *ppv)
{
    *ppv=NULL;
    if (riid == IID_IUnknown)
        *ppv=(IUnknown*)this;
    else if (riid == IID_ID3DXSkinMesh)
        *ppv=(ID3DXSkinMesh*)this;
    else
        return E_NOINTERFACE;
    ((LPUNKNOWN)*ppv)->AddRef();

    return S_OK;
}

DWORD CD3DXSkinMesh::AddRef()
{
	return ++m_refCnt;
}

DWORD CD3DXSkinMesh::Release()
{
	if (--m_refCnt != 0)
		return m_refCnt;
	delete this;
	return 0;
}

// Common initialization
HRESULT CD3DXSkinMesh::Init(DWORD numBones)
{
    m_refCnt = 1;
    if(numBones && (m_pBones == NULL))
    {
	    m_pBones = new CBone[numBones];
	    if (m_pBones == NULL)
		    return E_OUTOFMEMORY;
    }
	m_numBones = numBones;
    
    m_vertInfl = new DWORD[m_pMesh->m_cVertices];
	if (m_vertInfl == NULL)
		return E_OUTOFMEMORY;
    memset(m_vertInfl, 0, sizeof(DWORD) * m_pMesh->m_cVertices);
    m_faceClamp = 4; // D3D limit of per face influences in non-indexed skinning in SW
    m_bMixedDevice = FALSE;
    D3DCAPS8 caps;
    HRESULT hr = m_pMesh->m_pD3DDevice->GetDeviceCaps(&caps);
    if (hr != S_OK)
        return hr;

#if 0
    D3DDEVICE_CREATION_PARAMETERS cparams;
    hr = m_pMesh->m_pD3DDevice->GetCreationParameters(&cparams);
    if (hr != S_OK)
        return hr;
    if (cparams.BehaviorFlags & (D3DCREATE_PUREDEVICE | D3DCREATE_HARDWARE_VERTEXPROCESSING))
#endif
        m_faceClamp = caps.MaxVertexBlendMatrices;

#if 0
    if (cparams.BehaviorFlags & D3DCREATE_MIXED_VERTEXPROCESSING)
    {
        m_faceClamp = caps.MaxVertexBlendMatrices;
        m_bMixedDevice = TRUE;
    }
    if (m_faceClamp < 2) // minimum reqd for skinning
    {
        DPF(0, "This device does not support skinning");
        DPF(0, "Try using mixed or software vertex processing");
        return D3DXERR_SKINNINGNOTSUPPORTED;
    }
#endif 0
    return S_OK;
}

HRESULT CD3DXSkinMesh::Init(DWORD numFaces, DWORD numVertices, DWORD numBones, DWORD options, DWORD fvf, LPDIRECT3DDEVICE8 pD3DDevice)
{
    HRESULT hr;

    //TODO: remove this limitation
    if ((numFaces > UNUSED16) || (numVertices > UNUSED16) || (options & D3DXMESH_32BIT))
    {
        DPF(0, "ID3DXSkinMesh object currently does not support 32-bit indices");
        return E_NOTIMPL; 
    }
    m_pMesh = new GXTri3Mesh<tp16BitIndex>(pD3DDevice, fvf, options);
    if (m_pMesh == NULL)
        return E_OUTOFMEMORY;

    if ((hr  = m_pMesh->Resize(numFaces, numVertices)) != S_OK)
        return hr;
    return Init(numBones);
}

HRESULT CD3DXSkinMesh::Init(LPD3DXMESH pMesh, DWORD numBones)
{
    DWORD reqdOptions = D3DXMESH_SYSTEMMEM;
    if ((pMesh->GetOptions() & reqdOptions) != reqdOptions)
    {
        DPF(0, "The mesh must be created with D3DXMESH_SYSTEMMEM");
        return D3DERR_INVALIDCALL;
    }
    if (pMesh->GetOptions() & D3DXMESH_32BIT)
    {
        DPF(0, "ID3DXSkinMesh object currently does not support 32-bit indices");
        return E_NOTIMPL; 
    }

    // TODO: This is ugly. This may not work since it might not be safe to assume this is a 16-bit mesh
    m_pMesh = static_cast<GXTri3Mesh<tp16BitIndex> *>(pMesh);
    m_pMesh->AddRef();
    return Init(numBones);
}

HRESULT CD3DXSkinMesh::Init(LPD3DXMESH pMesh, LPBONE pBones, DWORD numBones)
{
    m_pBones = pBones;
    return Init(pMesh, numBones);
}

HRESULT WINAPI
D3DXCreateSkinMesh(DWORD numFaces, DWORD numVertices, DWORD numBones, DWORD options, CONST DWORD* pDeclaration, 
                   LPDIRECT3DDEVICE8 pD3D, LPD3DXSKINMESH* ppSkinMesh)
{
    DWORD fvf;
    HRESULT hr = D3DXFVFFromDeclarator(pDeclaration, &fvf);
    if (FAILED(hr))
    {
        DPF(0, "Cannot handle this declaration. Only a subset of legal declarations are allowed for this call");
        return D3DERR_INVALIDCALL;
    }
    return D3DXCreateSkinMeshFVF(numFaces, numVertices, numBones, options, fvf, pD3D, ppSkinMesh);
}

HRESULT WINAPI
D3DXCreateSkinMeshFVF(DWORD numFaces, DWORD numVertices, DWORD numBones, DWORD options, DWORD fvf, 
                      LPDIRECT3DDEVICE8 pD3D, LPD3DXSKINMESH* ppSkinMesh)
{
#if DBG
    if (numBones > D3DX_MAX_BONES)
    {
        DPF(0, "Too many bones. Cannot handle more than %d bones", D3DX_MAX_BONES);
        return D3DERR_INVALIDCALL;
    }
#endif
	CD3DXSkinMesh* pSkinMesh = new CD3DXSkinMesh;
	if (pSkinMesh == NULL)
		return E_OUTOFMEMORY;

    HRESULT hr = pSkinMesh->Init(numFaces, numVertices, numBones, options, fvf, pD3D);
	if (FAILED(hr))
	{
		DPF(0, "Could not initialize skin mesh");
		goto e_Exit;
	}

	*ppSkinMesh = pSkinMesh;
	return S_OK;

e_Exit:
	delete pSkinMesh;
	return hr;
}

//TODO: Should this copy the mesh instead of referring to it ?
HRESULT WINAPI
D3DXCreateSkinMeshFromMesh(LPD3DXMESH pMesh, DWORD numBones, LPD3DXSKINMESH* ppMesh)
{
#if DBG
    if (numBones > D3DX_MAX_BONES)
    {
        DPF(0, "Too many bones. Cannot handle more than %d bones", D3DX_MAX_BONES);
        return D3DERR_INVALIDCALL;
    }
#endif
	CD3DXSkinMesh* pSkinMesh = new CD3DXSkinMesh;
	if (pSkinMesh == NULL)
		return E_OUTOFMEMORY;

    HRESULT hr = pSkinMesh->Init(pMesh, numBones);
	if (FAILED(hr))
	{
		DPF(0, "Could not initialize skin mesh");
		goto e_Exit;
	}

	*ppMesh = pSkinMesh;
	return S_OK;

e_Exit:
	delete pSkinMesh;
	return hr;
}

HRESULT WINAPI
D3DXCreateSkinMeshFromMeshAndBones(LPD3DXMESH pMesh, DWORD numBones, LPBONE pBones, LPD3DXSKINMESH* ppMesh)
{
#if DBG
    if (numBones > D3DX_MAX_BONES)
    {
        DPF(0, "Too many bones. Cannot handle more than %d bones", D3DX_MAX_BONES);
        return D3DERR_INVALIDCALL;
    }
#endif
	CD3DXSkinMesh* pSkinMesh = new CD3DXSkinMesh;
	if (pSkinMesh == NULL)
		return E_OUTOFMEMORY;

    HRESULT hr = pSkinMesh->Init(pMesh, pBones, numBones);
	if (FAILED(hr))
	{
		DPF(0, "Could not initialize skin mesh");
		goto e_Exit;
	}

	*ppMesh = pSkinMesh;
	return S_OK;

e_Exit:
	delete pSkinMesh;
	return hr;
}

HRESULT CD3DXSkinMesh::SetBoneInfluence(DWORD boneNum, DWORD numInfluences, CONST DWORD* vertices, CONST float* weights)
{
	CBone& bone = m_pBones[boneNum];
	if (bone.m_numWeights)
	{
		D3DXASSERT(bone.m_pVertIndices);
		delete [] bone.m_pVertIndices;
		D3DXASSERT(bone.m_pWeights);
		delete [] bone.m_pWeights;
		bone.m_numWeights = 0;
	}
	bone.m_pVertIndices = new DWORD[numInfluences];
	if (bone.m_pVertIndices == NULL)
		return E_OUTOFMEMORY;
	bone.m_pWeights = new float[numInfluences];
	if (bone.m_pWeights == NULL)
	{
		delete [] bone.m_pVertIndices;
		return E_OUTOFMEMORY;
	}
	bone.m_numWeights = numInfluences;
	memcpy(bone.m_pVertIndices, vertices, sizeof(DWORD) * numInfluences);
	memcpy(bone.m_pWeights, weights, sizeof(float) * numInfluences);
    m_bChangedWeights   = true;
    m_DataValid &= ~(D3DXSM_VERTINFL | D3DXSM_FACEINFL | D3DXSM_VERTDATA);
    delete [] m_vertMatId;
    m_vertMatId = NULL;
    delete [] m_vertMatWeight;
    m_vertMatWeight = NULL;
	return S_OK;
}

HRESULT CD3DXSkinMesh::GetVertexBuffer(LPDIRECT3DVERTEXBUFFER8* ppVB)
{
	return m_pMesh->GetVertexBuffer(ppVB);
}

HRESULT CD3DXSkinMesh::GetIndexBuffer(LPDIRECT3DINDEXBUFFER8* ppIB)
{
	return m_pMesh->GetIndexBuffer(ppIB);
}

HRESULT CD3DXSkinMesh::LockVertexBuffer(DWORD flags, BYTE** ppData)
{
	return m_pMesh->LockVertexBuffer(flags, ppData);
}

HRESULT CD3DXSkinMesh::UnlockVertexBuffer()
{
	return m_pMesh->UnlockVertexBuffer();
}

HRESULT CD3DXSkinMesh::LockIndexBuffer(DWORD flags, BYTE** ppData)
{
    if (!(flags & D3DLOCK_READONLY))
        m_DataValid &= ~D3DXSM_FACEINFL;
	return m_pMesh->LockIndexBuffer(flags, ppData);
}

HRESULT CD3DXSkinMesh::UnlockIndexBuffer()
{
	return m_pMesh->UnlockIndexBuffer();
}

HRESULT CD3DXSkinMesh::LockAttributeBuffer(DWORD flags, DWORD** ppData)
{
	return m_pMesh->LockAttributeBuffer(flags, ppData);
}

HRESULT CD3DXSkinMesh::UnlockAttributeBuffer()
{
	return m_pMesh->UnlockAttributeBuffer();
}

HRESULT CD3DXSkinMesh::GetDevice(LPDIRECT3DDEVICE8 *ppDevice)
{
	return m_pMesh->GetDevice(ppDevice);
}

DWORD CD3DXSkinMesh::GetNumBones()
{
    return m_numBones;
}
HRESULT CD3DXSkinMesh::GetOriginalMesh(LPD3DXMESH* ppMesh)
{
    m_pMesh->AddRef();
    *ppMesh = m_pMesh;
    return S_OK;
}

DWORD CD3DXSkinMesh::GetNumFaces()
{
    return m_pMesh->GetNumFaces();
}

DWORD CD3DXSkinMesh::GetNumVertices()
{
    return m_pMesh->GetNumVertices();
}

DWORD CD3DXSkinMesh::GetFVF()
{
    return m_pMesh->GetFVF();
}

HRESULT CD3DXSkinMesh::GetDeclaration(DWORD Declaration[MAX_FVF_DECL_SIZE])
{
    return m_pMesh->GetDeclaration(Declaration);
}

DWORD CD3DXSkinMesh::GetOptions()
{
    return m_pMesh->GetOptions();
}

HRESULT CD3DXSkinMesh::CalcVertexSkinData()
{
    DWORD i, j;

    if (m_DataValid & D3DXSM_VERTDATA)
    {
        return S_OK;
    }
    HRESULT hr = GetMaxVertexInfluences(&m_maxVertInfl);

    if (FAILED(hr))
        return hr;

    if (m_vertMatId != NULL)
    {
        delete[] m_vertMatId;
        m_vertMatId = NULL;
    }

    if (m_vertMatWeight != NULL)
    {
        delete[] m_vertMatWeight;
        m_vertMatWeight = NULL;
    }

    m_vertMatId = new DWORD[m_pMesh->m_cVertices * m_maxVertInfl]; // per vertex list of matrix IDs
    m_vertMatWeight = new float[m_pMesh->m_cVertices * m_maxVertInfl]; // per vertex list matrix weights
    if (m_vertMatId == NULL || 
        m_vertMatWeight == NULL)
    {
        DPF(0, "Out of Memory");
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    // reuse vertInf[i] as the current num of influences per vertex
    memset(m_vertInfl, 0, sizeof(DWORD) * m_pMesh->m_cVertices);
    // Compute per vertex skin data
	for (i = 0; i < m_numBones; ++i)
    {
		CBone* pBone = &m_pBones[i];
        for (j = 0; j < pBone->m_numWeights; ++j)
        {
            DWORD v = pBone->m_pVertIndices[j];
            GXASSERT(v < m_pMesh->m_cVertices);
            m_vertMatId[v * m_maxVertInfl + m_vertInfl[v]] = i;
            m_vertMatWeight[v * m_maxVertInfl + m_vertInfl[v]] = pBone->m_pWeights[j];
            GXASSERT(m_vertInfl[v] <= m_maxVertInfl);
            m_vertInfl[v]++;
        }
    }
    // Initialize remaining m_vertMatId values
    for (i = 0; i < m_pMesh->m_cVertices; ++i)
    {
        for (j = m_vertInfl[i]; j < m_maxVertInfl; ++j)
        {
            m_vertMatId[i * m_maxVertInfl + j] = 0;
        }
    }

    m_DataValid |= D3DXSM_VERTDATA;
    return S_OK;

e_Exit:
    delete [] m_vertMatId;
    m_vertMatId = NULL;
    delete [] m_vertMatWeight;
    m_vertMatWeight = NULL;
    return hr;
}

// This function sorts vertex weight by importance only if the num infl for the vertex
// is greated than truncVertInfl. It does not guarantee that all vertex weights are sorted
HRESULT CD3DXSkinMesh::TruncVertexSkinData(DWORD truncVertInfl, LPDWORD pAdjacencyIn)
{
    HRESULT hr;
    DWORD i, j, k;

    if (!(m_DataValid & D3DXSM_VERTDATA))
    {
        hr = CalcVertexSkinData();
        if (hr != S_OK)
            return hr;
    }

    DWORD bPRep = FALSE;
    DWORD* pointRep = NULL;
#if DBG
    float maxTrunc = 0.0f;
#endif
    for (i = 0; i < m_pMesh->m_cVertices; ++i)
    {
        if (m_vertInfl[i] > truncVertInfl)
        {
            if ((!bPRep) && pAdjacencyIn)
            {
                pointRep = new DWORD[m_pMesh->m_cVertices];
                if (!pointRep)
                {
                    DPF(0, "Out of Memory");
                    return E_OUTOFMEMORY;
                }
                // Get Point reps for the original mesh
                hr = m_pMesh->ConvertAdjacencyToPointReps(pAdjacencyIn, pointRep);
                if (hr != S_OK)
                {
                    return hr;
                }
                bPRep = TRUE;
            }
            DWORD v = bPRep ? pointRep[i] : i;
            float* vertMatWeight = m_vertMatWeight + (v * m_maxVertInfl);
            DWORD* vertMatId = m_vertMatId + (v * m_maxVertInfl);
            float sum = 0.0f;
            // Sort vertex weights by importance
            for (j = 0; j < truncVertInfl; ++j)
            {
                DWORD max = 0;
                float maxWeight = 0.0f;
                for (k = j; k < m_vertInfl[v]; ++k)
                {
                    if (vertMatWeight[k] > maxWeight)
                    {
                        maxWeight = vertMatWeight[k];
                        max = k;
                    }
                }
                // Move jth largest element to its correct position in sorted array
                DWORD t1 = vertMatId[j];
                vertMatId[j] = vertMatId[max];
                vertMatId[max] = t1;
                float t2 = vertMatWeight[j];
                vertMatWeight[j] = vertMatWeight[max];
                sum += vertMatWeight[max];
                vertMatWeight[max] = t2;
            }
            double scale = 1.0 / sum;
            // Renormalize vertex weights
            for (j = 0; j < truncVertInfl; ++j)
            {
                vertMatWeight[j] = (float)(vertMatWeight[j] * scale);
            }
            for (; j < m_vertInfl[v]; ++j)
            {
#if DBG
                maxTrunc = max(maxTrunc, vertMatWeight[j]);
#endif
                vertMatWeight[j] = 0.0f;
            }
        }
    }

    if (bPRep)
    {
        DPF(1, "Mesh has upto %d infl per vertex, truncating to %d", m_maxVertInfl, m_faceClamp);
        DPF(1, "Max truncated vertex weight = %f", maxTrunc);
        // propogate changes to point reps to all replicated points
        for (i = 0; i < m_pMesh->m_cVertices; ++i)
        {
            if (pointRep[i] != i)
            {
                for (j = 0; j < m_vertInfl[i]; ++j)
                {
                    m_vertMatId[i * m_maxVertInfl + j] = m_vertMatId[pointRep[i] * m_maxVertInfl + j];
                    m_vertMatWeight[i * m_maxVertInfl + j] = m_vertMatWeight[pointRep[i] * m_maxVertInfl + j];
                }
            }
        }
    }
    return S_OK;
}





struct SBoneCombinationNode
{
    DWORD                   iBoneCombination;

    CD3DXBitField256        bitBones;
    DWORD                   iAttrib;

    SBoneCombinationNode*   pPrev;
    SBoneCombinationNode*   pNext;
}; 



HRESULT GreedyTSP
(
    SBoneCombinationNode*   pCandidatePool, 
    SBoneCombinationNode**  ppElected, 
    DWORD*                  pcCost,                 // ASSUMPTION:  *pcCost is initialized to starting cost
    DWORD*                  pcSavings               // ASSUMPTION:  *pcSavings is initialized to starting savings
)
{
    SBoneCombinationNode*   pElected;
    SBoneCombinationNode*   pCandidate;
    SBoneCombinationNode*   pBestCandidate;

    DWORD                   cMaxVote;
    DWORD                   cBestVote;
    DWORD                   cVote;


    HRESULT hr  = S_OK;

    const   DWORD           nAttributeWeighting = 1;


    // initialize elected

    *ppElected  = NULL;


    if (pCandidatePool == NULL || pCandidatePool->pNext == NULL)
    {
        *ppElected  = pCandidatePool;

        goto e_Exit;
    }

    // elect first candidate in line

    pElected        = pCandidatePool;

    pCandidatePool  = pElected->pNext;

    pElected->pNext         = NULL;

    pCandidatePool->pPrev   = NULL;


    // elect subsequent candidates greedily

    while (pCandidatePool)      // candidate pool is not empty
    {

        // calculate maximum possible vote (i.e. savings)

        cMaxVote    = pElected->bitBones.Count() + nAttributeWeighting;

    
        // initialize candidate & best vote

        pBestCandidate  = NULL;

        cBestVote       = -1;



        // search through candidates for best candidate

        for (pCandidate = pCandidatePool;   pCandidate != NULL;   pCandidate = pCandidate->pNext)
        {
            CD3DXBitField256    bitSharedBones;

            // calculate candidate's vote (as the number of shared bones & attributes with the elected bone combination)
            
            bitSharedBones.And(pElected->bitBones, pCandidate->bitBones);

            cVote = bitSharedBones.Count()
                  + nAttributeWeighting * (pElected->iAttrib == pCandidate->iAttrib);


            if (cVote + 1 > cBestVote + 1)      // this is the best vote yet
            {
                // update best candidate & vote

                pBestCandidate  = pCandidate;

                cBestVote       = cVote;


                if (cBestVote == cMaxVote)          // this is definitely the best possible vote
                {
                    break;
                }
            }
        }


        // update cost & savings

        *pcCost      += cMaxVote;

        *pcSavings   += cBestVote;


        // remove the best candidate from candidate pool

        if (pBestCandidate->pPrev)                              
        {
            pBestCandidate->pPrev->pNext    = pBestCandidate->pNext;    // INVARIANT:  pBestCandidate != NULL
        }

        if (pBestCandidate->pNext)                              
        {
            pBestCandidate->pNext->pPrev    = pBestCandidate->pPrev;    // INVARIANT:  pBestCandidate != NULL
        }

        if (pCandidatePool == pBestCandidate)
        {
            pCandidatePool  = pCandidatePool->pNext;
        }



        // elect the best candidate

        pBestCandidate->pPrev   = NULL;

        pBestCandidate->pNext   = pElected;

        pElected->pPrev = pBestCandidate;                               // INVARIANT: pElected != NULL

        pElected        = pBestCandidate;
    }


    // update cost

    *pcCost  += pElected->bitBones.Count() + nAttributeWeighting;
    

    // update elected

    *ppElected  = pElected;

e_Exit:

    return hr;
}

void CD3DXSkinMesh::CalcNumAttributes(LPDWORD pAttrMask, LPDWORD pAttrBits)
{
    DWORD attrMask = 0;
    DWORD attribBits = 0;

    m_pMesh->LockIB((PBYTE*)&m_pMesh->m_pFaces);
	// Count the number of attributes in the mesh
	m_pMesh->GetAttributeTable(NULL, &m_numAttrib);
	if (!m_numAttrib)
	{
		LPDWORD pAttrib;
		m_pMesh->CollectAttributeIds(&pAttrib, &m_numAttrib);
		delete [] pAttrib;
	}
    m_pMesh->UnlockIB();
    m_pMesh->m_pFaces = NULL;

    // Compute attribBits = log2(m_numAttrib)
    while ((m_numAttrib & attrMask) != m_numAttrib)
    {
        attribBits++;
        attrMask = (attrMask << 1) | 1;
    };
    *pAttrMask = attrMask;
    *pAttrBits = attribBits;
}

HRESULT CD3DXSkinMesh::ConvertToBlendedMesh(DWORD options, CONST LPDWORD pAdjacencyIn, LPDWORD pAdjacencyOut,
									DWORD* pNumBoneCombinations, LPD3DXBUFFER* ppBoneCombinationTable, LPD3DXMESH* ppMesh)
{
    DWORD stride;
    DWORD* faceMatId = NULL;
    // TODO: this needs to be extended to 32-bit
    WORD (*pFaces)[3] = NULL;
    DWORD* origAttribIds = NULL;
    DWORD fvf;
    DWORD* vertRemap1 = NULL;
    DWORD* vertRemap2 = NULL;
    LPD3DXATTRIBUTERANGE attrTable = NULL;
    LPD3DXBONECOMBINATION pBoneCombination = NULL;
    DWORD matidMask;
    BOOL bTruncWeights;
    BOOL bMixedDevice;
    float* faceWeights = NULL;
    DWORD faceClamp, faceClampHW;
    DWORD attribBits;
#if DBG
    float maxTrunc = 0.0f;
#endif
    DWORD numAttrib = 0;
    DWORD attrMask;
    BOOL bPRep = FALSE;
    GXTri3Mesh<tp16BitIndex>* pNewMesh4 = NULL;
    DWORD   cMaxFaceInfl;

#if DBG
    DWORD* pAdjTest = NULL;
#endif

    HRESULT hr = S_OK;

    bMixedDevice    = FALSE;
    faceClamp       = m_faceClamp;
    faceClampHW     = m_faceClamp;

    // TODO: remove this limitation
    if (options & D3DXMESH_32BIT)
    {
        DPF(0, "32-bit meshes are not yet supported");
        return E_NOTIMPL;
    }

    // Is there any skinning info ?
    if (m_numBones == 0)
    {
        hr = m_pMesh->CloneMeshFVF(options, m_pMesh->GetFVF(), m_pMesh->m_pD3DDevice, ppMesh);
        return hr;
    }

    if (m_bMixedDevice)
    {
        if (!(options & D3DXMESH_USEHWONLY))
        {
            bMixedDevice = TRUE;
            DPF(1, "Detected mixed device: faceClampHW = %d", faceClampHW);
            faceClamp = 4;
        }
    }
    DWORD numVerts = m_pMesh->GetNumVertices();
    DWORD numFaces = m_pMesh->GetNumFaces();
    LPDWORD faceInfl = new DWORD[numFaces];
    DWORD* faceAttr = new DWORD[numFaces]; // per face attribute
    DWORD* faceRemap = new DWORD[numFaces];
    DWORD* pointRep = new DWORD[numVerts];
    DWORD* pAdjacencyTemp = new DWORD[numFaces * 3];
    if (faceInfl == NULL ||
        faceAttr == NULL ||
        faceRemap == NULL ||
        pAdjacencyTemp == NULL ||
        pointRep == NULL)
    {
        DPF(0, "Out of Memory");
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }
    memset(faceInfl, 0, sizeof(DWORD) * numFaces);
    memset(faceAttr, 0, sizeof(DWORD) * numFaces);

    DWORD i,j;
//    DWORD cpattrOld;
    //IGXAttributeBundleDX7 **rgpattrOld = NULL;

    CalcNumAttributes(&attrMask, &attribBits);
    
    hr = CalcVertexSkinData();
    if (hr != S_OK)
    {
        goto e_Exit;
    }

    // Allocate per face strorage for skin data
    stride = m_maxVertInfl * 3;
    faceMatId = new DWORD[numFaces * stride]; // per face list of matrix IDs
    faceWeights = new float[stride]; // cumulative weights for a face for sorting
    if (faceMatId == NULL || 
        faceWeights == NULL)
    {
        DPF(0, "Out of Memory");
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

#if DBG
    // Verify weights add up to 1
    for (i = 0; i < numVerts; ++i)
    {
        float sum = 0.f;
        for (j = 0; j < m_vertInfl[i]; ++j)
            sum += m_vertMatWeight[i * m_maxVertInfl + j];
        GXASSERT(fabs(sum - 1.f) < 0.001);
    }
#endif

    // Get Faces
    m_pMesh->LockIB((PBYTE*)&m_pMesh->m_pFaces);
    pFaces = reinterpret_cast<WORD(*)[3]>(m_pMesh->m_pFaces);

    // Compute influences per face
    memset(faceMatId, 0xff, sizeof(DWORD) * numFaces * stride);
    cMaxFaceInfl = 0;
    for (i = 0; i < numFaces; ++i)
    {
        faceInfl[i] = 0;
        for (j = 0; j < 3; ++j)
        {
            DWORD v;
            if (bPRep)
                v = pointRep[pFaces[i][j]];
            else
                v = pFaces[i][j];
            for (DWORD k = 0; k < m_vertInfl[v]; ++k)
            {
                if (m_vertMatWeight[v * m_maxVertInfl + k] == 0.0f)
                    continue;
                for (DWORD l = 0; l < faceInfl[i]; ++l)
                {
                    if (faceMatId[i * stride + l] == m_vertMatId[v * m_maxVertInfl + k])
                    {
                        faceWeights[l] = max(faceWeights[l], m_vertMatWeight[v * m_maxVertInfl + k]);
                        break;
                    }
                }
                if (l == faceInfl[i])
                {
                    faceMatId[i * stride + l] = m_vertMatId[v * m_maxVertInfl + k];
                    faceWeights[l] = m_vertMatWeight[v * m_maxVertInfl + k];
                    faceInfl[i]++;
                }
            }
        }
        if (faceInfl[i] > cMaxFaceInfl)
        {
            cMaxFaceInfl = faceInfl[i];
        }
        if (faceInfl[i] > faceClamp) 
        {
            if (!bPRep)
            {
                // Get Point reps for the original mesh
                hr = m_pMesh->ConvertAdjacencyToPointReps(pAdjacencyIn, pointRep);
                if (hr != S_OK)
                {
                    goto e_Exit;
                }
                bPRep = TRUE;
            }
            if (faceClamp > 2)
            {
                // Sort face weights by importance
                for (j = 0; j < faceClamp; ++j)
                {
                    DWORD max = 0;
                    float maxWeight = 0.0f;
                    for (DWORD k = j; k < faceInfl[i]; ++k)
                    {
                        if (faceWeights[k] > maxWeight)
                        {
                            maxWeight = faceWeights[k];
                            max = k;
                        }
                    }
                    // Move jth largest element to its correct position in sorted array
                    DWORD t1 = faceMatId[i * stride + j];
                    faceMatId[i * stride +j] = faceMatId[i * stride + max];
                    faceMatId[i * stride + max] = t1;
                    float t2 = faceWeights[j];
                    faceWeights[j] = faceWeights[max];
                    faceWeights[max] = t2;
                }
                faceInfl[i] = faceClamp;
                bTruncWeights = TRUE;

                // Fix vertex weights too
                for (j = 0; j < 3; ++j)
                {
                    DWORD v = pointRep[pFaces[i][j]];
                    float trunc = 0.0f;
                    for (DWORD k = 0; k < m_vertInfl[v]; ++k)
                    {
                        for (DWORD l = 0; l < faceInfl[i]; ++l)
                        {
                            if (faceMatId[i * stride + l] == m_vertMatId[v * m_maxVertInfl + k])
                                break;
                        }
                        if (l == faceInfl[i]) // Not found, we must have trucated it
                        {
                            // Mark the corresponding vertex weight *of the representative vertex* to 0
                            GXASSERT(fabs(m_vertMatWeight[v * m_maxVertInfl + k] - 1.0f) > 0.001);
                            trunc += m_vertMatWeight[v * m_maxVertInfl + k];
#if DBG
                            maxTrunc = max(maxTrunc, m_vertMatWeight[v * m_maxVertInfl + k]);
#endif
                            m_vertMatWeight[v * m_maxVertInfl + k] = 0.0f;
                        }
                    }
                    if (trunc != 0.0f)
                    {
                        // Re-normalize the vertex weights
                        double scale = 1 / (1.0 - trunc);
                        for (DWORD k = 0; k < m_vertInfl[v]; ++k)
                        {
                            if (m_vertMatWeight[v * m_maxVertInfl + k] != 0.0f)
                                m_vertMatWeight[v * m_maxVertInfl + k] = (float)(m_vertMatWeight[v * m_maxVertInfl + k] * scale);
                        }
                    }
                }
            }
        }
    }

    delete [] faceWeights;
    faceWeights = NULL;

    if (cMaxFaceInfl > faceClamp)
    {
        if (faceClamp < 3)
        {
            DPF(0, "ConvertToBlendedMesh: The HW only supports 2 infl per tri.");
            DPF(0, "ConvertToBlendedMesh: This mesh has %d infl per tri and cannot be truncated", cMaxFaceInfl);
            DPF(0, "ConvertToBlendedMesh: Try using a mixed mode device to render this mesh");
            hr = D3DXERR_TOOMANYINFLUENCES;
            goto e_Exit;
        }
        DPF(1, "ConvertToBlendedMesh: Mesh has upto %d infl per tri, truncating to %d", cMaxFaceInfl, faceClamp);
        DPF(1, "ConvertToBlendedMesh: Max truncated vertex weight = %f", maxTrunc);
        cMaxFaceInfl = faceClamp;

        // Recompute face influences with new trucated vertex influences to avoid cracks
        memset(faceMatId, 0xff, sizeof(DWORD) * numFaces * stride);
        for (i = 0; i < numFaces; ++i)
        {
            faceInfl[i] = 0;
            for (j = 0; j < 3; ++j)
            {
                DWORD v = pointRep[pFaces[i][j]];
                for (DWORD k = 0; k < m_vertInfl[v]; ++k)
                {
                    if (m_vertMatWeight[v * m_maxVertInfl + k] == 0.0f)
                        continue;
                    for (DWORD l = 0; l < faceInfl[i]; ++l)
                    {
                        if (faceMatId[i * stride + l] == m_vertMatId[v * m_maxVertInfl + k])
                        {
                            break;
                        }
                    }
                    if (l == faceInfl[i])
                    {
                        faceMatId[i * stride + l] = m_vertMatId[v * m_maxVertInfl + k];
                        faceInfl[i]++;
                    }
                }
            }
            GXASSERT(faceInfl[i] <= faceClamp);
        }
    }

    // Done with original mesh's faces
    m_pMesh->UnlockIB();
    m_pMesh->m_pFaces = NULL;
    pFaces = NULL;

    GXASSERT(cMaxFaceInfl <= faceClamp); // DX7 API restriction

    // Allocate bits in DWORD for bone ID & AttribId
    m_matidShift = (32 - attribBits) / cMaxFaceInfl;
    matidMask = (1 << m_matidShift) - 1;
    GXASSERT((1i64 << m_matidShift) - 1 > m_numBones + 1);

    // Generate Unique attribute ids
    // An attribute ID uniquely identifies a combination of matrix IDs per face
    for (i = 0; i < numFaces; ++i)
    {
        // Generate unique face attribute
        for (j = 0; j < faceInfl[i]; ++j)
        {
            faceAttr[i] |= (faceMatId[i * stride + j] + 1) << (m_matidShift * j);
        }
        faceAttr[i] |= m_pMesh->m_rgiAttributeIds[i] << (m_matidShift * cMaxFaceInfl);
    }
    attrMask = attrMask << (m_matidShift * cMaxFaceInfl);

    // Evil Hack: Temporarily substitute the new attributes to optimize
    origAttribIds = m_pMesh->m_rgiAttributeIds;
    m_pMesh->m_rgiAttributeIds = faceAttr;

    // Optimize using new attribute IDs to new mesh
    GXTri3Mesh<tp16BitIndex>* pNewMesh1;
    LPD3DXBUFFER pVertRemapBuf1;
    // TODO: Is it worthwhile to reduce the fvf of the temporary mesh to have minimum vertex data.
    // We would then copy all vertex data later during the computation of per vertex weights ?
    hr = m_pMesh->Optimize2(D3DXMESH_SYSTEMMEM, D3DXMESHOPT_COMPACT | D3DXMESHOPT_ATTRSORT,
                            pAdjacencyIn, pAdjacencyTemp, faceRemap, &pVertRemapBuf1, m_pMesh->GetFVF(), &pNewMesh1);
    if (hr != S_OK)
    {
        goto e_Exit;
    }

    // Undo evil hack: Restore the original attribute Ids
    m_pMesh->m_rgiAttributeIds = origAttribIds;
    delete [] faceAttr;
    faceAttr = NULL;

    vertRemap1 = reinterpret_cast<DWORD*>(pVertRemapBuf1->GetBufferPointer());

#if 0//DBG // This no longer works since pFacesNew is not yet initialized
    // Verify the remap tables
    m_pMesh->LockIB((PBYTE*)&pFaces);
    for (i = 0; i < numFaces; ++i)
    {
        DWORD fold = faceRemap[i];
        for (j = 0; j < 3; ++j)
        {
            DWORD vnew = pFacesNew[i][j];
            if (vertRemap1[vnew] != pFaces[fold][j])
            {
                DPF(1, "Remap inconsistency:");
                DPF(1, "    NewFace[%d][%d] = %d", i, j, vnew);
                DPF(1, "    vertRemap1[%d] = %d, faceRemap[%d] = %d", vnew,
                    vertRemap1[vnew], i, fold);
                DPF(1, "    OldFace[%d][%d] = %d (!= %d)", fold, j, pFaces[fold][j], vertRemap1[vnew]);
            }
        }
    }
    // Done with original mesh's faces
    m_pMesh->UnlockIB();
    pFaces = NULL;
#endif

    // Get the new mesh's attribute table
    numAttrib = pNewMesh1->m_caeAttributeTable;
    //DPF(1, "Num Attributes before coalescing: %d", numAttrib);
    attrTable = new D3DXATTRIBUTERANGE[numAttrib];
    pNewMesh1->GetAttributeTable(attrTable, NULL);

    { // Silly indent to define pFaceInflBits after a goto and keep the compiler happy
        // TODO: Currently we merge combinations after an initial attribute sort to generate a table
        // of diffrent combinations. Is it ever better to merge combinations before attribute sort on
        // the faces ? Since this algorithm is n^2, this is a win if num combinations is smaller than
        // numFaces. This is should be mostly the case but when the difference is not large, the higher
        // constant overhead of an optimize call might make the current approach inefficient

        // Generate Bitfields for each bone combination
        CD3DXBitField256* pFaceInflBits = new CD3DXBitField256[numAttrib];
        DWORD* faceInflCount = new DWORD[numAttrib];
        if (pFaceInflBits == NULL || faceInflCount == NULL)
        {
            DPF(0, "Out of Memory");
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }
        memset(faceInflCount, 0, sizeof(DWORD) * numAttrib);
        for (i = 0; i < numAttrib; ++i)
        {
		    for (j = 0; j < cMaxFaceInfl; ++j)
		    {
                DWORD mat = (attrTable[i].AttribId >> (j * m_matidShift)) & matidMask;
			    if (mat)
                {
                    pFaceInflBits[i].Set(mat - 1);
                    faceInflCount[i]++;
                }
            }
        }

        // Merge subset influences
        for (i = 0; i < numAttrib; ++i)
        {
            for (j = 0; j < numAttrib; ++j)
            {
                if (pFaceInflBits[i].IsSubset(pFaceInflBits[j]))
                {
                    if ((faceInflCount[j] > faceClampHW) || (faceInflCount[i] <= faceClampHW))
                        pFaceInflBits[j] = pFaceInflBits[i];
                }
            }
        }

        // Rewrite update attributes into attribute table
        DWORD* pAttrib;
        pNewMesh1->LockAttributeBuffer(NULL, &pAttrib);
        for (i = 0; i < numAttrib; ++i)
        {
            // Convert bitfield back to attribIds
            // TODO: Can this be improved ?
            DWORD attribId = 0;
            DWORD k = 0;
            for (j = 0; j < m_numBones; ++j)
            {
                if (pFaceInflBits[i].IsSet(j))
                {
                    attribId |= (j + 1) << (m_matidShift * k);
                    ++k;
                }
            }
            // Copy the original attribute back into the new attribId
            attribId |= attrTable[i].AttribId & attrMask;
            // Fill per face attribute Ids
            for (j = 0; j < attrTable[i].FaceCount; ++j)
            {
                pAttrib[j + attrTable[i].FaceStart] = attribId;

            }
        }
        pNewMesh1->UnlockAttributeBuffer();
        pAttrib = NULL;
        delete [] pFaceInflBits;
        pFaceInflBits = NULL;
        delete [] attrTable;
        attrTable = NULL;
        delete [] faceInflCount;
        faceInflCount = NULL;
    }
    // Calculate fvf for new mesh
    fvf = D3DFVF_XYZ;
    if (cMaxFaceInfl - 1)
        fvf = D3DFVF_XYZRHW + (cMaxFaceInfl - 1) * 2; // hack to compute FVF
    fvf = (m_pMesh->GetFVF() & (~D3DFVF_POSITION_MASK)) | fvf; // new FVF

    GXTri3Mesh<tp16BitIndex>* pNewMesh2;
    LPD3DXBUFFER pVertRemapBuf2;
    
    hr = pNewMesh1->Optimize2(D3DXMESH_SYSTEMMEM, D3DXMESHOPT_COMPACT | D3DXMESHOPT_ATTRSORT,
                            pAdjacencyTemp, pAdjacencyOut, faceRemap, &pVertRemapBuf2, fvf, &pNewMesh2);

    pNewMesh1->Release();
    pNewMesh1 = NULL;
    // Get access to the new mesh's vertex data
    LPBYTE pVertOut;
    hr = pNewMesh2->LockVertexBuffer(0, &pVertOut);
    if (hr != S_OK)
    {
        goto e_Exit;
    }
    WORD (*pFacesNew)[3];
    hr = pNewMesh2->LockIndexBuffer(0, (LPBYTE*)&pFacesNew);
    if (hr != S_OK)
    {
        goto e_Exit;
    }
    vertRemap2 = reinterpret_cast<DWORD*>(pVertRemapBuf2->GetBufferPointer());

    // Get the new mesh's attribute table
    attrTable = pNewMesh2->m_rgaeAttributeTable;
    *pNumBoneCombinations = pNewMesh2->m_caeAttributeTable;
    //DPF(1, "Num Attributes after coalescing: %d", *pNumBoneCombinations);

    { // indent to define cfvfout after a goto and keep the compiler happy
        DXCrackFVF  cfvfout(fvf);
        // Generate vertex weights for the new mesh
        for (j = 0; j < *pNumBoneCombinations; ++j)
        {
            for (i = 0; i < attrTable[j].VertexCount; ++i) // For each vertex of a particular bone combination
            {
                DWORD v;
                // Original *representative* vertex corresponding to the new vertex
                if (bPRep)
                    v = pointRep[vertRemap1[vertRemap2[i + attrTable[j].VertexStart]]];
                else
                    v = vertRemap1[vertRemap2[i + attrTable[j].VertexStart]];
                LPBYTE pOut = (LPBYTE)cfvfout.GetArrayElem(pVertOut, i + attrTable[j].VertexStart);
                float sum = 0.0f;
                for (DWORD k = 0; k < cMaxFaceInfl - 1; ++k)
                { // For each face matrix, see if this vertex is affected by the matrix
                    ((float*)(pOut + sizeof(D3DVECTOR)))[k] = 0.0f;
                    DWORD mat = (attrTable[j].AttribId >> (k * m_matidShift)) & matidMask;
			        if (mat)
                    {
                        for (DWORD l = 0; l < m_vertInfl[v]; ++ l)
                        {
                            if (m_vertMatId[v * m_maxVertInfl + l] == mat - 1)
                            {
                                ((float*)(pOut + sizeof(D3DVECTOR)))[k] = m_vertMatWeight[v * m_maxVertInfl + l];
                                sum += m_vertMatWeight[v * m_maxVertInfl + l];
                                break;
                            }
                        }
                    }
                }
#if DBG
                // Verify new vertex weights
                float lastweight = 0.0f;
                DWORD mat = (attrTable[j].AttribId >> (k * m_matidShift)) & matidMask;
			    if (mat)
                {
                    for (DWORD l = 0; l < m_vertInfl[v]; ++ l)
                    {
                        if (m_vertMatId[v * m_maxVertInfl + l] == mat - 1)
                        {
                            lastweight = m_vertMatWeight[v * m_maxVertInfl + l];
                            sum += lastweight;
                            break;
                        }
                    }
                }
                // All weights should add up to 1
                if (fabs(sum - 1.f) > 0.001)
                {
                    GXASSERT(fabs(sum - 1.f) < 0.001);
					DPF(1, "Weights of vertex %d (orig. %d) do not add up (sum is %f)", i + attrTable[j].VertexStart, v, sum);
#if 0 // This no longer works since we have 2 face remap tables
                    // Find the faces referring to the offending vertex
                    for (DWORD k = 0; k < attrTable[j].FaceCount; ++k)
                    {
                        for (DWORD l = 0; l < 3; ++l)
                        {
                            if (pFacesNew[k + attrTable[j].FaceStart][l] == i + attrTable[j].VertexStart)
                                DPF(1, "Face %d (orig. %d) uses vertex %d", k + attrTable[j].FaceStart, 
                                    faceRemap[k + attrTable[j].FaceStart], i + attrTable[j].VertexStart);
                        }
                    }
#endif
                }
#if 0 // This verification is dangerous. It reads back from the dest VB which could be in vid mem
                for (DWORD l = 0; l < m_vertInfl[v]; ++l)
                {
                    for (k = 0; k < cMaxFaceInfl; ++k)
                    {
                        DWORD mat = (attrTable[j].AttribId >> (k * m_matidShift)) & matidMask;
			            if (mat)
                        {
                            if (m_vertMatId[v * m_maxVertInfl + l] == mat - 1)
                            {
                                if (k == cMaxFaceInfl - 1)
                                {
                                    GXASSERT(m_vertMatWeight[v * m_maxVertInfl + l] == lastweight);
                                }
                                else
                                {
                                    GXASSERT(m_vertMatWeight[v * m_maxVertInfl + l] == ((float*)(pOut + sizeof(D3DVECTOR)))[k]);
                                }
                            }
                        }
                    }
                }
#endif // 0
#endif // DBG
            }
        }

        // Free stuff not needed any more
        delete [] faceInfl;
        faceInfl = NULL;
        delete [] faceMatId;
        faceMatId = NULL;
        delete [] pointRep;
        pointRep = NULL;

        // Generate the bone combination table
	    hr = D3DXCreateBuffer((sizeof(D3DXBONECOMBINATION) + 4 * sizeof(DWORD))* *pNumBoneCombinations, ppBoneCombinationTable);
        if (hr != S_OK)
        {
            goto e_Exit;
        }
	    pBoneCombination = static_cast<LPD3DXBONECOMBINATION>((*ppBoneCombinationTable)->GetBufferPointer());

        // set up BoneId pointers inside the buffer
        DWORD (*pBoneIds)[4] = reinterpret_cast<DWORD(*)[4]>(pBoneCombination + *pNumBoneCombinations);
        for (i = 0; i < *pNumBoneCombinations; ++i)
        {
            pBoneCombination[i].BoneId = pBoneIds[i];
        }
        // Hack: Lie about read only even though we modify the attribute data since the vertices need not be reordered
        // by this change. attribute table has already been updated.
        DWORD* pAttrib;
        pNewMesh2->LockAttributeBuffer(D3DLOCK_READONLY, &pAttrib);

        for (i = 0; i < *pNumBoneCombinations; ++i)
        {
            for (j = 0; j < attrTable[i].FaceCount; ++j)
            {
                pAttrib[attrTable[i].FaceStart + j] = i;
            }
		    for (j = 0; j < cMaxFaceInfl; ++j)
		    {
			    pBoneCombination[i].BoneId[j] = (attrTable[i].AttribId >> (j * m_matidShift)) & matidMask;
                if (pBoneCombination[i].BoneId[j])
                {
                    pBoneCombination[i].BoneId[j]--;
                }
                else
                {
                    pBoneCombination[i].BoneId[j] = UINT_MAX;
                }
		    }
            for (; j < 4; ++j)
            {
                pBoneCombination[i].BoneId[j] = UINT_MAX;
            }
		    pBoneCombination[i].AttribId = attrTable[i].AttribId >> (cMaxFaceInfl * m_matidShift);
		    pBoneCombination[i].FaceCount = attrTable[i].FaceCount;
		    pBoneCombination[i].FaceStart = attrTable[i].FaceStart;
		    pBoneCombination[i].VertexCount = attrTable[i].VertexCount;
		    pBoneCombination[i].VertexStart = attrTable[i].VertexStart;
            attrTable[i].AttribId = i;
        }

        pNewMesh2->UnlockAttributeBuffer();
        pAttrib = NULL;




#if 1
        // MINIMIZE BONE ID & ATTRIBUTE CHANGES




        DWORD iInfl, iAttr, iPoint, i;

        pAttrib         = NULL;


        GXTri3Mesh<tp16BitIndex>* pNewMesh3     = NULL;

        LPDIRECT3DDEVICE8       pDevice         = NULL;

        LPD3DXBUFFER            pVertRemapBuf3  = NULL;
        LPD3DXBUFFER            pVertRemapBuf4  = NULL;

        PBYTE                   pbPoints        = NULL;

        DWORD*                  rgiOrder        = NULL;

        D3DXBONECOMBINATION*    rgbcOptimized   = NULL;


        SBoneCombinationNode*   rgNodes         = NULL;

        SBoneCombinationNode*   pNode;
        DWORD                   iNode;


        D3DCAPS8                caps;


        SBoneCombinationNode*   pCandidatePoolHW;
        SBoneCombinationNode*   pElectedHW;

        SBoneCombinationNode*   pCandidatePoolSW;
        SBoneCombinationNode*   pElectedSW;


        DWORD                   cCost;
        DWORD                   cSavings;


        DXCrackFVF              cfvf(pNewMesh2->GetFVF());      // since eventually, pNewMesh3->GetFVF() == pNewMesh2->GetFVF()

        DWORD                   cbPointSize;


        

 
        // don't optimize if there are less than 2 bone combinations

        if (*pNumBoneCombinations <= 1)     // there are less than two bone combinations
        {
            goto e_ExitTSP;
        }





        // allocate lump of bone combination nodes

        rgNodes = new SBoneCombinationNode[*pNumBoneCombinations];

        if (rgNodes == NULL)
        {
            hr  = E_OUTOFMEMORY;

            DPF(1, "ConvertToBlendedMesh:  not enough memory; aborting optimization");

            goto e_ExitTSP;
        }

    
        // allocate reordered bone combination table

        rgbcOptimized   = new D3DXBONECOMBINATION[*pNumBoneCombinations];

        if (rgbcOptimized == NULL)
        {
            hr  = E_OUTOFMEMORY;

            DPF(1, "ConvertToBlendedMesh:  not enough memory; aborting optimization");

            goto e_ExitTSP;
        }


        // allocate reordering array

        rgiOrder    = new DWORD[*pNumBoneCombinations];

        if (rgiOrder == NULL)
        {
            hr  = E_OUTOFMEMORY;

            DPF(1, "ConvertToBlendedMesh:  not enough memory; aborting optimization");

            goto e_ExitTSP;
        }

  
       

        // initialize bone combination node data

        for (iNode = 0; iNode < *pNumBoneCombinations; iNode++)
        {
            for (DWORD iBone = 0; iBone < 4; iBone++)
            {
                if (pBoneCombination[iNode].BoneId[iBone] != UINT_MAX)
                {
                    rgNodes[iNode].bitBones.Set(pBoneCombination[iNode].BoneId[iBone]);
                }
            }
            
            rgNodes[iNode].iBoneCombination = iNode;

            rgNodes[iNode].iAttrib          = pBoneCombination[iNode].AttribId;
        }




        // generate candidate pools

        pCandidatePoolHW    = NULL;

        pCandidatePoolSW    = NULL;


        for (iNode = 0; iNode < *pNumBoneCombinations; iNode++)
        {
            rgNodes[iNode].pPrev    = NULL;


            if (bMixedDevice && rgNodes[iNode].bitBones.Count() > faceClampHW)
            {
                // add node to software candidate pool

                rgNodes[iNode].pNext    = pCandidatePoolSW;

                pCandidatePoolSW        = rgNodes + iNode;

                if (pCandidatePoolSW->pNext)
                {
                    pCandidatePoolSW->pNext->pPrev  = pCandidatePoolSW;
                }
            }
            else
            {
                // add node to hardware candidate pool

                rgNodes[iNode].pNext    = pCandidatePoolHW;

                pCandidatePoolHW        = rgNodes + iNode;

                if (pCandidatePoolHW->pNext)
                {
                    pCandidatePoolHW->pNext->pPrev  = pCandidatePoolHW;
                }
            }
        }


        
        // initialize cost & savings

        cCost       = 0;

        cSavings    = 0;
    

        // generate election lists

        hr = GreedyTSP(pCandidatePoolHW, &pElectedHW, &cCost, &cSavings);

        if (FAILED(hr))
            goto e_ExitTSP;

        
        hr = GreedyTSP(pCandidatePoolSW, &pElectedSW, &cCost, &cSavings);

        if (FAILED(hr))
            goto e_ExitTSP;


 
        // calculate reordering array and reordered bone combination table

        iNode   = 0;


        for (pNode = pElectedHW; pNode != NULL; pNode = pNode->pNext, iNode++)
        {
            rgbcOptimized[iNode] = pBoneCombination[pNode->iBoneCombination];

            rgiOrder[pNode->iBoneCombination]    = iNode;
        }


        for (pNode = pElectedSW; pNode != NULL; pNode = pNode->pNext, iNode++)
        {
            rgbcOptimized[iNode] = pBoneCombination[pNode->iBoneCombination];

            rgiOrder[pNode->iBoneCombination]    = iNode;
        }




        

        // load the reordered bone combination table

        memcpy(pBoneCombination, rgbcOptimized, *pNumBoneCombinations * sizeof(D3DXBONECOMBINATION));


        // fill in reordered attributes

        pNewMesh2->LockAttributeBuffer(0, &pAttrib);

        for (iAttr = 0; iAttr < pNewMesh2->GetNumFaces(); iAttr++)
        {
            pAttrib[iAttr]  = rgiOrder[pAttrib[iAttr]];
        }


        // copy adjacency info into temporary adjacency array

        if (pAdjacencyOut != NULL)  // adjacency info exists
        {
            memcpy(pAdjacencyTemp, pAdjacencyOut, numFaces * 3 * sizeof(DWORD));
        }


        // sort attributes

        hr  = pNewMesh2->Optimize2
                         (
                              D3DXMESH_SYSTEMMEM,
                              D3DXMESHOPT_ATTRSORT,
                              pAdjacencyTemp, 
                              pAdjacencyOut, 
                              faceRemap, 
                              &pVertRemapBuf3, 
                              pNewMesh2->GetFVF(), 
                              &pNewMesh3
                         );                         // INVARIANT:  AttrTable count is same before and after Optimize
                                                    // INVARIANT:  pNewMesh3->GetFVF() == pNewMesh2->GetFVF()

        if (FAILED(hr))
            goto e_ExitTSP;

        
        // update bone combination face & vertex ranges

        attrTable   = pNewMesh3->m_rgaeAttributeTable;        // TODO:  use GetAttribTable instead
        
        for (iNode = 0; iNode < *pNumBoneCombinations; iNode++)
        {
            pBoneCombination[iNode].FaceStart   = attrTable[iNode].FaceStart;

            pBoneCombination[iNode].FaceCount   = attrTable[iNode].FaceCount;

            pBoneCombination[iNode].VertexStart = attrTable[iNode].VertexStart;

            pBoneCombination[iNode].VertexCount = attrTable[iNode].VertexCount;
        }


        // get the byte size of each point (i.e. vertex) in the mesh

        cbPointSize     = cfvf.m_cBytesPerVertex;



        pNewMesh3->LockVertexBuffer(0, &pbPoints);

        DWORD rgiBones[4];
        DWORD rgiWeightOrder[4];


        iNode = 0;

        for (iInfl = 0; iInfl < 4; iInfl++)
        {
            rgiBones[iInfl] = pBoneCombination[iNode].BoneId[iInfl];
        }


        for (iNode = 1; iNode < *pNumBoneCombinations; iNode++)
        {
            for (DWORD iWeight = 0; iWeight < 4; iWeight++)
            {
                rgiWeightOrder[iWeight] = iWeight;
            }

            for (iWeight = 0; iWeight < 4; iWeight++)
            {
                DWORD iBone = rgiBones[iWeight];

                for (DWORD i = 0; i < 4; i++)
                {
                    if (iBone != UINT_MAX && iBone == pBoneCombination[iNode].BoneId[rgiWeightOrder[i]])
                    {
                        DWORD   temp = rgiWeightOrder[i];
                        rgiWeightOrder[i] = rgiWeightOrder[iWeight];
                        rgiWeightOrder[iWeight] = temp;
                    }
                }
            }


            for (iInfl = 0; iInfl < 4; iInfl++)
            {
                rgiBones[iInfl] = pBoneCombination[iNode].BoneId[rgiWeightOrder[iInfl]];
            }


            PBYTE   pbCurrPoint = (PBYTE)cfvf.GetArrayElem(pbPoints, pBoneCombination[iNode].VertexStart);

//          DPF(1, "%3d %3d %3d %3d|%3d", rgiBones[0], rgiBones[1], rgiBones[2], rgiBones[3], pBoneCombination[iNode].AttribId);

            for (i = 0; i < 4; i++)
            {
                pBoneCombination[iNode].BoneId[i] = rgiBones[i];
            }


            for (iPoint = 0; iPoint < pBoneCombination[iNode].VertexCount; iPoint++)
            {
                float* rgfWeights = cfvf.PfGetWeights(pbCurrPoint);

                float rgfWeights1[4];
                
                rgfWeights1[3]  = 1.0f;

                for (DWORD i = 0; i < 3; i++)
                {
                    rgfWeights1[i] = rgfWeights[i];
                    rgfWeights1[3] -= rgfWeights[i];
                }

                for (i = 0; i < 3; i++)
                {
                    cfvf.SetWeight(pbCurrPoint, i, rgfWeights1[rgiWeightOrder[i]]);
                }


                pbCurrPoint += cbPointSize;
            }
        }
       

       

        // clone mesh with the correct options

        // TODO:  try to use clone instead of Optimize2 & then manually copy the attribute table

        hr  = pNewMesh3->Optimize2
                 (
                      options,
                      D3DXMESHOPT_ATTRSORT,
                      pAdjacencyOut, 
                      NULL, 
                      faceRemap, 
                      &pVertRemapBuf4, 
                      pNewMesh3->GetFVF(), 
                      &pNewMesh4
                 );

        if (FAILED(hr))
            goto e_ExitTSP;



//      DPF(1, "ConvertToBlendedMesh:  %d original cost - %d savings = %d new cost (%.1f%% savings)", cCost, cSavings, cCost - cSavings, 100.0 * (float)cSavings / (float)cCost);


e_ExitTSP:      // TSP stands for "Traveling Salesman Problem", which is essentially what this optimization tries to solve

        delete[] rgNodes;
        delete[] rgbcOptimized;
        delete[] rgiOrder;
        delete[] pAdjacencyTemp;

        if (pbPoints != NULL)
        {
            pNewMesh3->UnlockVertexBuffer();

            pbPoints = NULL;
        }

        if (pAttrib != NULL)
        {
            pNewMesh2->UnlockAttributeBuffer();

            pAttrib = NULL;
        }

        GXRELEASE(pVertRemapBuf3);

        GXRELEASE(pVertRemapBuf4);

        GXRELEASE(pDevice);

        GXRELEASE(pNewMesh3);

#endif






#if 0 // DBG this check no longer works
    
        // Verify replicated vertices have the same matrix & weights so that there are no cracks during skinning
        // This is a concern when truncating weights
        for (j = 0; j < *pNumBoneCombinations; ++j) // Cycle tru vertices via bone combination table
            for (i = 0; i < pBoneCombination[j].VertexCount; ++i) // For each vertex of a particular bone combination
            {
                DWORD v = i + pBoneCombination[j].VertexStart;
                if (pointRep[v] != v)
                {
                    // Find the table entry k of the representative vertex
                    for (DWORD k = 0; k < *pNumBoneCombinations; ++k)
                    {
                        if (pointRep[v] >= pBoneCombination[k].VertexStart && 
                            pointRep[v] < pBoneCombination[k].VertexStart + pBoneCombination[k].VertexCount)
                            break;
                    }
                    GXASSERT(k < *pNumBoneCombinations); // Must find k

                    LPBYTE pVert1 = (LPBYTE)cfvfout.GetArrayElem(pVertOut, v);
                    LPBYTE pVert2 = (LPBYTE)cfvfout.GetArrayElem(pVertOut, pointRep[v]);
                    for (DWORD l = 0; l < cMaxFaceInfl; ++l) // For each non-zero weight
                    {
                        float w1, w2;
                        if (l == cMaxFaceInfl - 1)
                        {
                            w1 = 1.0f;
                            for (DWORD m = 0; m < l; ++m)
                                w1 -= ((float*)(pVert1 + sizeof(D3DVECTOR)))[m];
                        }
                        else
                            w1 = ((float*)(pVert1 + sizeof(D3DVECTOR)))[l];
                        if (w1 > 0.0001f)
                        {
                            for (DWORD m = 0; m < cMaxFaceInfl; ++m) // Find a match in the representative vertex
                            {
                                if (pBoneCombination[j].BoneId[l] == pBoneCombination[k].BoneId[m])
                                {
                                    if (m == cMaxFaceInfl - 1)
                                    {
                                        w2 = 1.0f;
                                        for (DWORD n = 0; n < m; ++n)
                                            w2 -= ((float*)(pVert2 + sizeof(D3DVECTOR)))[n];
                                    }
                                    else
                                        w2 = ((float*)(pVert2 + sizeof(D3DVECTOR)))[m];
                                    if (fabs(w1 - w2) > 0.1)
                                        DPF(1, "Vert %d & Vert[Prep[%d]=%d] differ", v, v, pointRep[v]);
                                    break;
                                }
                            }
                            GXASSERT(m < cMaxFaceInfl); // Must find m that matches
                        }
                    }
                }
            }
        delete [] pointRep;
        pointRep = NULL;
#endif

    }
    // Free remap data
    delete [] faceRemap;
    faceRemap = NULL;
    vertRemap1 = NULL;
    vertRemap2 = NULL;
    pVertRemapBuf1->Release();
    pVertRemapBuf2->Release();

	pNewMesh2->UnlockVertexBuffer();
    pVertOut = NULL;
	pNewMesh2->UnlockIndexBuffer();
    pFacesNew = NULL;


    if (pNewMesh4)
    {
        pNewMesh2->Release();

        *ppMesh = pNewMesh4;
    }
    else
        *ppMesh = pNewMesh2;


    return hr;

e_Exit:
    // Error cleanup
    delete [] faceWeights;
    delete [] faceAttr;
    delete [] faceInfl;
    delete [] faceMatId;
    delete [] pointRep;
    delete [] faceRemap;
    delete [] pAdjacencyTemp;
    return hr;
}

DWORD CD3DXSkinMesh::GetNumBoneInfluences(DWORD bone)
{
    if (bone < m_numBones)
    {
        return m_pBones[bone].m_numWeights;
    }
    else
    {
        DPF(0, "Invalid bone nummber");
        return 0;
    }
}
	
HRESULT CD3DXSkinMesh::GetBoneInfluence(DWORD bone, 
							 DWORD* vertices,
							 float* weights)
{
    if (bone < m_numBones)
    {
        memcpy(vertices, m_pBones[bone].m_pVertIndices, m_pBones[bone].m_numWeights * sizeof(DWORD));
        memcpy(weights, m_pBones[bone].m_pWeights, m_pBones[bone].m_numWeights * sizeof(float));
        return S_OK;
    }
    else
    {
        DPF(0, "Invalid bone number");
        return D3DERR_INVALIDCALL;
    }
}
	
HRESULT CD3DXSkinMesh::GetMaxVertexInfluences(DWORD* maxVertexInfluences)
{
    *maxVertexInfluences = 0;

    if (!(m_DataValid & D3DXSM_VERTINFL))
    {
        // Compute max influences per vertex
        m_maxVertInfl = 0;


        memset(m_vertInfl, 0, m_pMesh->m_cVertices * sizeof(DWORD));

	    for (DWORD i = 0; i < m_numBones; ++i)
        {
		    CBone* pBone = &m_pBones[i];
            for (DWORD j = 0; j < pBone->m_numWeights; ++j)
            {
                m_vertInfl[pBone->m_pVertIndices[j]]++;
                if (m_vertInfl[pBone->m_pVertIndices[j]] > m_maxVertInfl)
                    m_maxVertInfl = m_vertInfl[pBone->m_pVertIndices[j]];
            }
        }
        m_DataValid |= D3DXSM_VERTINFL;
    }
    *maxVertexInfluences = m_maxVertInfl;
    return S_OK;
}
	
HRESULT CD3DXSkinMesh::GetMaxFaceInfluences(DWORD* maxFaceInfluences)
{
    if (!(m_DataValid & D3DXSM_FACEINFL))
    {
        WORD (*pFaces)[3] = NULL;
        HRESULT hr = CalcVertexSkinData();
        if (hr != S_OK)
        {
            return hr;
        }

        DWORD* faceMatId = new DWORD[m_maxVertInfl * 3]; // upper limit for maxFaceInfl
        if (faceMatId == NULL)
        {
            DPF(0, "Out of Memory");
            return E_OUTOFMEMORY;
        }

        m_maxFaceInfl = 0;
        m_pMesh->LockIB((PBYTE*)&pFaces);
        for (DWORD i = 0; i < m_pMesh->m_cFaces; ++i)
        {
            DWORD faceInfl = 0;
            memset(faceMatId, 0xff, sizeof(DWORD) * m_maxVertInfl * 3);

            for (DWORD j = 0; j < 3; ++j)
            {
                DWORD v = pFaces[i][j];
                for (DWORD k = 0; k < m_vertInfl[v]; ++k)
                {
                    for (DWORD l = 0; l < faceInfl; ++l)
                    {
                        if (faceMatId[l] == m_vertMatId[v * m_maxVertInfl + k])
                        {
                            break;
                        }
                    }
                    if (l == faceInfl)
                    {
                        faceMatId[l] = m_vertMatId[v * m_maxVertInfl + k];
                        faceInfl++;
                    }
                }
            }
            if (faceInfl > m_maxFaceInfl)
            {
                m_maxFaceInfl = faceInfl;
            }
        }
        m_pMesh->UnlockIB();
        pFaces = NULL;
        m_DataValid |= D3DXSM_FACEINFL;
    }
    *maxFaceInfluences = m_maxFaceInfl;
    return S_OK;
}


HRESULT CD3DXSkinMesh::GenerateCodes()
{
    HRESULT hr  = S_OK;


    // get the number of points (i.e. vertices) in the source mesh

    DWORD   cPoints = m_pMesh->GetNumVertices();

    
    DWORD   cMaxInfluencesPerVertex;


    // get the maximum number of influences per vertex

    hr = GetMaxVertexInfluences(&cMaxInfluencesPerVertex);

    if (FAILED(hr))
        return hr;


    float*	rgfCodeTable	= NULL;
    DWORD*  rgcInfluences   = NULL;


    // allocate memory for a temporary code table

    rgfCodeTable = new float[cPoints * cMaxInfluencesPerVertex];

	if (!rgfCodeTable)
    {
        hr  = E_OUTOFMEMORY;

        goto e_Exit1;
    }


    // initialize the code table to zeroes

	memset(rgfCodeTable, 0, cPoints * cMaxInfluencesPerVertex * sizeof(float));   // initialize weights to 0


    // allocate memory for a temporary per vertex influence count array

	rgcInfluences	= new DWORD[cPoints];

	if (!rgcInfluences)
    {
        hr  = E_OUTOFMEMORY;

        goto e_Exit1;
    }


    // initialize the influence count array to zero

	memset(rgcInfluences, 0, cPoints * sizeof(DWORD));    // initialize influence counts to 0


    
    CBone*  pBone;

    DWORD   cCodes;

    DWORD iWeight, iPoint, iBone;

    // initialize the bone pointer to point to the first bone

    pBone   = m_pBones;




    // FILL IN THE CODE TABLE



	for (iBone = 0; iBone < m_numBones; ++iBone)
	{
		float   f2xBone     = (float)(iBone << 1);


        for (iWeight = 0; iWeight < pBone->m_numWeights; ++iWeight)
		{
            // get the affected vertex

			DWORD   iVertex	= pBone->m_pVertIndices[iWeight];


            // code = boneID * 2 + weight

			float   fCode	= f2xBone + pBone->m_pWeights[iWeight];
				
			rgfCodeTable[iVertex * cMaxInfluencesPerVertex + rgcInfluences[iVertex]]	= fCode;


            // update the influence count array

			rgcInfluences[iVertex]++;
		}



        // increment the bone pointer 

        ++pBone;
	}





    // CLAMP THE WEIGHTS



    float*  rgfCodes;
    DWORD*  pcInfluences;


    // initialize total code count to zero

    cCodes  = 0;

    
    // intialize vertex code array pointer

    rgfCodes        = rgfCodeTable;


    // initialize influence count pointer

    pcInfluences    = rgcInfluences;


    // run through the vertices, clamping the weights

    for (iPoint = 0; iPoint < cPoints; ++iPoint)
    {
        // initialize vertex influence count

        DWORD   cInfluences = 0;


        // initialize vertex weight sum

        float   fWeightSum  = 0.0f;


        for (iWeight = 0; iWeight < *pcInfluences; iWeight++)
        {
            // decode weight

            float   fCode   = rgfCodes[iWeight];

            DWORD   iBone   = ((DWORD)fCode) >> 1;

            float   f2xBone = (float)(iBone << 1);

            float   fWeight = fCode - f2xBone;



            if (fWeight >= m_fMinWeight)     // if the weight is at least minimum allowed
            {
                // save the code

                rgfCodes[cInfluences]   = fCode;


                // update vertex weight sum

                fWeightSum  += fWeight;


                // update vertex influence count

                cInfluences++;
            }
        }


        if (cInfluences)        // there's at least one influence after clamping
        {
            // update influence count array

            *pcInfluences   = cInfluences;


            for (iWeight = 0; iWeight < cInfluences; iWeight++)
            {
                // decode weight

                float   fCode   = rgfCodes[iWeight];

                DWORD   iBone   = ((DWORD)fCode) >> 1;

                float   f2xBone = (float)(iBone << 1);

                float   fWeight = fCode - f2xBone;
    

                // save encoded normalized weight
            
                rgfCodes[iWeight]   = f2xBone + (fWeight / fWeightSum);
            }
        }


        // update the total code count

		cCodes  += *pcInfluences;

        
        // imcrement vertex code array pointer

        rgfCodes   += cMaxInfluencesPerVertex;


        // increment influence count pointer

        pcInfluences++;


    }





    // SAVE THE CODE TABLE INTO THE CODE ARRAY


    // reallocate memory for the code array

    if (m_rgfCodes)
        delete[] m_rgfCodes;

	m_rgfCodes	= new float[cCodes + cPoints];

	if (!m_rgfCodes)
    {
        hr  = E_OUTOFMEMORY;

        goto e_Exit1;
    }



    float*  pfCodeSrce;
    float*  pfCodeDest;


    // initialize influence count pointer

    pcInfluences    = rgcInfluences;


    // initialize source code pointer

    pfCodeSrce      = rgfCodeTable;


    // initialize destination code pointer

    pfCodeDest      = m_rgfCodes;


    // run through the vertices, filling in the codes from the code table

	for (iPoint = 0; iPoint < cPoints; ++iPoint)
	{
        if (*pcInfluences > 0)  // there is at least one influence
        {
            // copy codes from code table to code array

    		memcpy(pfCodeDest, pfCodeSrce, *pcInfluences * sizeof(float));


            // update destination code pointer

            pfCodeDest += *pcInfluences;
        }


        // set code to negative to indicate end of influences for this vertex

        *pfCodeDest = -1.0f;


        // increment influence count pointer

        pcInfluences++;


        // increment source code pointer

        pfCodeSrce  += cMaxInfluencesPerVertex;


        // increment destination code pointer

        pfCodeDest++;
    }

e_Exit1:

    // free memory from code table

    if (rgfCodeTable)
        delete[] rgfCodeTable;


    // free memory from influence count array

    if (rgcInfluences)
        delete[] rgcInfluences;


    // return if there were errors

    if (FAILED(hr))
        return hr;


    // indicate that the code array is up to date

    m_bChangedWeights	= false;


    return hr;
}


HRESULT CD3DXSkinMesh::GenerateSkinnedMesh(DWORD options, FLOAT fMinWeight, CONST LPDWORD rgiAdjacencyIn, LPDWORD rgiAdjacencyOut, LPD3DXMESH* ppMesh)
{
	HRESULT	hr	= S_OK;

    // get the number of points (i.e. vertices) in the source mesh

    DWORD   cPoints = m_pMesh->GetNumVertices();


    // TODO: remove this limitation
    if (options & D3DXMESH_32BIT)
    {
        DPF(0, "32-bit meshes are not yet supported");
        return E_NOTIMPL;
    }

    LPDIRECT3DDEVICE8   pDevice = NULL;
    
    DWORD*  rgiVertexRemap;

    GXTri3Mesh<tp16BitIndex>* pOptMesh    = NULL;

    DWORD*  rgcPointReps    = NULL;
    DWORD*  rgiPointReps    = NULL;
    DWORD** rgpPointReps    = NULL;

    float*  rgfWeights  = NULL;
    DWORD*  rgiIndices  = NULL;

    DWORD   cPoints_;
    DWORD   cWeights;
    DWORD   iWeight, iPoint, iBone, iPoint_, iWeight_;
    float   fWeight;


    DWORD*          rgiFaceRemap    = NULL;

    LPD3DXBUFFER    pVertexRemap    = NULL;

    // allocate face remap array

    rgiFaceRemap    = new DWORD[m_pMesh->GetNumFaces()];

    if (rgiFaceRemap == NULL)
    {
        hr  = E_OUTOFMEMORY;

        goto e_Exit0;
    }


    // attribute sort the original mesh
    
    hr = m_pMesh->Optimize2
                  (
                      m_pMesh->GetOptions(),
                      D3DXMESHOPT_ATTRSORT,
                      rgiAdjacencyIn,
                      rgiAdjacencyOut,
                      rgiFaceRemap,
                      &pVertexRemap,
                      m_pMesh->GetFVF(),
                      &pOptMesh
                  );

    if (FAILED(hr))
        goto e_Exit0;


    // get vertex remap array

    rgiVertexRemap  = reinterpret_cast<DWORD*>(pVertexRemap->GetBufferPointer()); 


    // save old point (i.e. vertex) count

    cPoints_    = cPoints;


    // load new point (i.e. vertex) count

    cPoints     = pOptMesh->GetNumVertices();



    // allocate rep count array

    rgcPointReps = new DWORD[cPoints_];

    if (rgcPointReps == NULL)
    {
        hr  = E_OUTOFMEMORY;

        goto e_Exit0;
    }


    // initialize rep count array to zeros

    memset(rgcPointReps, 0, cPoints_ * sizeof(DWORD));

    
    // allocate rep index array

    rgiPointReps = new DWORD[cPoints_];

    if (rgiPointReps == NULL)
    {
        hr  = E_OUTOFMEMORY;

        goto e_Exit0;
    }


    // initialize rep index array to zeros

    memset(rgiPointReps, 0, cPoints_ * sizeof(DWORD));

    
    // allocate rep pointer array

    rgpPointReps = new DWORD*[cPoints_];

    if (rgpPointReps == NULL)
    {
        hr  = E_OUTOFMEMORY;

        goto e_Exit0;
    }


    // initalize rep pointer array to NULL

    memset(rgpPointReps, 0, cPoints_ * sizeof(DWORD*));


    // calculate rep count array

    for (iPoint = 0; iPoint < cPoints; iPoint++)
    {
        rgcPointReps[rgiVertexRemap[iPoint]]++; 
    }


    // allocate rep arrays

    for (iPoint_ = 0; iPoint_ < cPoints_; iPoint_++)
    {
        rgpPointReps[iPoint_]   = new DWORD[rgcPointReps[iPoint_]]; 

        if (rgpPointReps[iPoint_] == NULL)
        {
            hr  = E_OUTOFMEMORY;

            goto e_Exit0;
        }
    }


    // fill in rep arrays

    for (iPoint = 0; iPoint < cPoints; iPoint++)
    {
        iPoint_ = rgiVertexRemap[iPoint];

        rgpPointReps[iPoint_][rgiPointReps[iPoint_]]    = iPoint;

        rgiPointReps[iPoint_]++;
    }


    // run through the bones

    for (iBone = 0; iBone < m_numBones; iBone++)
    {

        // initialize influence count to zero

        cWeights    = 0;

        for (iWeight_ = 0; iWeight_ < m_pBones[iBone].m_numWeights; iWeight_++)
        {
            cWeights    += rgcPointReps[m_pBones[iBone].m_pVertIndices[iWeight_]];
        }


        // allocate weight array

        rgfWeights  = new float[cWeights];  

        if (rgfWeights == NULL)
        {
            hr  = E_OUTOFMEMORY;

            goto e_Exit0;
        }


        // allocate vertex indices array

        rgiIndices  = new DWORD[cWeights];  

        if (rgiIndices == NULL)
        {
            hr  = E_OUTOFMEMORY;

            goto e_Exit0;
        }


        // fill in vertex indices and weight arrays

        iWeight = 0;

        for (iWeight_ = 0; iWeight_ < m_pBones[iBone].m_numWeights; iWeight_++)
        {
            fWeight = m_pBones[iBone].m_pWeights[iWeight_];

            for (DWORD iRep = 0; iRep < rgcPointReps[m_pBones[iBone].m_pVertIndices[iWeight_]]; iRep++)
            {
                rgfWeights[iWeight] = fWeight;
                rgiIndices[iWeight] = rgpPointReps[m_pBones[iBone].m_pVertIndices[iWeight_]][iRep];

                iWeight++;
            }
        }


        // free the old weight & vertex indices arrays

        delete[] m_pBones[iBone].m_pWeights;

        delete[] m_pBones[iBone].m_pVertIndices;


        // update the weight & vertex indices array pointers

        m_pBones[iBone].m_pWeights      = rgfWeights;

        m_pBones[iBone].m_pVertIndices  = rgiIndices;


        // update the weight count

        m_pBones[iBone].m_numWeights    = cWeights;


        // set the old pointers to NULL

        rgfWeights  = NULL;

        rgiIndices  = NULL;
    }


    // release the original mesh

    GXRELEASE(m_pMesh);


    // set the original mesh pointer to the optimized mesh

    m_pMesh = pOptMesh;


    // get the mesh's device

    hr  = m_pMesh->GetDevice(&pDevice);

    if (FAILED(hr))
        goto e_Exit0;


    // clone the mesh

    hr  = m_pMesh->CloneMeshFVF
                   (
                       options | D3DXMESH_VB_DYNAMIC,
                       m_pMesh->GetFVF(),
                       pDevice,
                       ppMesh
                   );

    if (FAILED(hr))
        goto e_Exit0;


    // reallocate m_vertInfl since number of vertices may have changed

    delete[] m_vertInfl;

    m_vertInfl  = new DWORD[m_pMesh->m_cVertices];

    if (m_vertInfl == NULL)
        goto e_Exit0;

    memset(m_vertInfl, 0, m_pMesh->m_cVertices * sizeof(DWORD));


    // INVARIANT:  m_maxVertInfl remains same

    // INVARIANT:  m_maxFaceInfl remains same

    // INVARIANT:  m_numAttrib remains same (TODO:  make sure of this)


    // free matrix id & matrix weight arrays

    if (m_vertMatId != NULL)
    {
        delete[] m_vertMatId;

        m_vertMatId     = NULL;
    }

    if (m_vertMatWeight != NULL)
    {
        delete[] m_vertMatWeight;

        m_vertMatWeight = NULL;
    }


    // recalculate matrix id & matrix weight arrays

    hr  = CalcVertexSkinData();

    if (FAILED(hr))
        goto e_Exit0;


    // set the min weight clamp

    m_fMinWeight    = fMinWeight;

    
    // recalculate codes

    hr  = GenerateCodes();

    if (FAILED(hr))
        goto e_Exit0;


    // indicate that codes have been calculated

    m_bChangedWeights   = false;


e_Exit0:

   
    // indicate that data needs to be recalculated

    m_DataValid     = 0;


    // cleanup

    if (rgpPointReps)
    {
        for (DWORD iPoint_ = 0; iPoint_ < cPoints_; iPoint_++)
        {
            delete[] rgpPointReps[iPoint_];
        }
    }

    delete[] rgpPointReps;

    delete[] rgcPointReps;

    delete[] rgiPointReps;

    
    delete[] rgiFaceRemap;


    delete[] rgfWeights;

    delete[] rgiIndices;


    rgiVertexRemap = NULL;

    GXRELEASE(pVertexRemap);


    GXRELEASE(pDevice);


    return hr;
}

HRESULT CD3DXSkinMesh::UpdateSkinnedMesh(CONST D3DXMATRIX* pBoneTransforms, LPD3DXMESH pMesh)
{
	HRESULT	hr	= S_OK;


    // recalulate codes if necessary

	if (m_bChangedWeights)	    // influence weights have changed
	{
        // reallocate & recalculate code array

        hr  = GenerateCodes();

        if (FAILED(hr))
            return hr;


        // indicate that the code array is up to date

        m_bChangedWeights	= false;
	}


    



    // SKIN THE MESH USING THE CODE ARRAY




    // get the number of points (i.e. vertices) in the source mesh

    DWORD   cPoints = m_pMesh->GetNumVertices();

    
    // create classes to read/write the source & destination mesh's vertex buffers

    DXCrackFVF  cfvfSrce(m_pMesh->GetFVF()),
                cfvfDest(pMesh->GetFVF());






    // calculate source and destination pointer increments

    DWORD   cbPointSizeSrce = cfvfSrce.m_cBytesPerVertex;
    DWORD   cbPointSizeDest = cfvfDest.m_cBytesPerVertex;




#if DBG     // check whether source & destination meshes are compatible


    // check whether source and destination meshes have same number of vertices

    if (pMesh->GetNumVertices() != cPoints)
    {
        DPF(0, "UpdateSkinnedMesh:  Vertex count mismatch (%d input vertices, %d output vertices)", cPoints, pMesh->GetNumVertices());

        return E_FAIL;
    }

    if (m_pMesh->GetFVF() != pMesh->GetFVF())
    {
        DPF(0, "UpdateSkinnedMesh:  FVF mismatch between source & destination meshes.");

        return E_FAIL;
    }


#endif







    PBYTE   pbData  = NULL;

    PBYTE   pbSrce  = NULL;
    PBYTE   pbDest  = NULL;
 
	PBYTE   pbCurrSrce;
	PBYTE   pbCurrDest;


    // lock source mesh vertex buffer for "read-only"

    hr  = m_pMesh->LockVertexBuffer(D3DLOCK_READONLY, &pbSrce);

    if (FAILED(hr))
        goto e_Exit;


    // lock destination mesh vertex buffer to "write"

    hr  = pMesh->LockVertexBuffer(0, &pbDest);

    if (FAILED(hr))
        goto e_Exit;


    // initialize source & destination mesh's current pointers

    pbCurrSrce  = pbSrce;
    pbCurrDest  = pbDest;


    // allocate temporary point data storage

    pbData  = new BYTE[cbPointSizeSrce];

    if (pbData == NULL)
    {
        hr = E_OUTOFMEMORY;

        goto e_Exit;
    }


    if (cfvfSrce.BNormal() && cfvfDest.BNormal())     // source mesh has normals
    {
        
        D3DXVECTOR3	    vVertexSrce;
        D3DXVECTOR3		vVertexDest;

        D3DXVECTOR3	    vNormalSrce;
        D3DXVECTOR3		vNormalDest;


        // initialize code pointer

        float*  pfCode  = m_rgfCodes;


        // run through each vertex, calculating the skinned position & normal

	    for (DWORD iPoint = 0; iPoint < cPoints; ++iPoint)
	    {
            // load point data

            memcpy(pbData, pbCurrSrce, cbPointSizeSrce * sizeof(BYTE));


            // read source position & normal

            vVertexSrce  = *cfvfSrce.PvGetPosition(pbData);
		    vNormalSrce  = *cfvfSrce.PvGetNormal(pbData);


            // initialize blend tranform to zero

            D3DXMATRIX mBoneTransform
                       (
                           0.0f, 0.0f, 0.0f, 0.0f,
                           0.0f, 0.0f, 0.0f, 0.0f,
                           0.0f, 0.0f, 0.0f, 0.0f,
                           0.0f, 0.0f, 0.0f, 0.0f
                       );


            // calculate blend transform

		    while (*pfCode >= 0.0f) 
		    {
                // decode bone and weight

                DWORD   iBone   = ((DWORD)(*pfCode)) >> 1;

                float   fWeight	= (*pfCode) - (float)(iBone << 1);


                // add weighted influence

                mBoneTransform  += pBoneTransforms[iBone] * fWeight;


                // increment code pointer

                ++pfCode;
		    }


            // calculate blended vertex

            D3DXVec3TransformCoord(&vVertexDest, &vVertexSrce, &mBoneTransform);


            // calculate blended normal

            D3DXVec3TransformNormal(&vNormalDest, &vNormalSrce, &mBoneTransform);


            // write output position & normal

		    cfvfDest.SetPosition(pbData, &vVertexDest);
		    cfvfDest.SetNormal(pbData, &vNormalDest);


            // save point data

            memcpy(pbCurrDest, pbData, cbPointSizeSrce * sizeof(BYTE));     // INVARIANT:  cbPointSizeSrce == cbPointSizeDest
            

            // increment source & destination pointers

            pbCurrSrce += cbPointSizeSrce;
            pbCurrDest += cbPointSizeDest; 


            // increment code pointer

            ++pfCode;
        }
	}
    else        // source mesh does not have normals
    {
        D3DXVECTOR3	    vVertexSrce;
        D3DXVECTOR3		vVertexDest;


        // initialize code pointer

        float*  pfCode  = m_rgfCodes;


        // run through each vertex, calculating the skinned position & normal

	    for (DWORD iPoint = 0; iPoint < cPoints; ++iPoint)
	    {
            // load point data

            memcpy(pbData, pbCurrSrce, cbPointSizeSrce * sizeof(BYTE));

            
            // read source position

            vVertexSrce  = *cfvfSrce.PvGetPosition(pbData);


            // initialize blend tranform to zero

            D3DXMATRIX mBoneTransform
                       (
                           0.0f, 0.0f, 0.0f, 0.0f,
                           0.0f, 0.0f, 0.0f, 0.0f,
                           0.0f, 0.0f, 0.0f, 0.0f,
                           0.0f, 0.0f, 0.0f, 0.0f
                       );


            // calculate blend transform

		    while (*pfCode >= 0.0f) 
		    {
                // decode bone and weight

                DWORD   iBone   = ((DWORD)(*pfCode)) >> 1;

                float   fWeight	= (*pfCode) - (float)(iBone << 1);


                // add weighted influence

                mBoneTransform  += pBoneTransforms[iBone] * fWeight;


                // increment code pointer

                ++pfCode;
		    }


            // calculate blended vertex

            D3DXVec3TransformCoord(&vVertexDest, &vVertexSrce, &mBoneTransform);


            // write output position

		    cfvfDest.SetPosition(pbData, &vVertexDest);


            // save point data

            memcpy(pbCurrDest, pbData, cbPointSizeSrce * sizeof(BYTE));     // INVARIANT:  cbPointSizeSrce == cbPointSizeDest

            
            // increment source & destination pointers

            pbCurrSrce += cbPointSizeSrce;
            pbCurrDest += cbPointSizeDest; 


            // increment code pointer

            pfCode++;
        }
    }


e_Exit:

    // unlock source mesh's vertex buffer

    if (pbSrce)
        m_pMesh->UnlockVertexBuffer();


    // unlock destination mesh's vertex buffer

    if (pbDest)
        pMesh->UnlockVertexBuffer();


    // release temporary point data storage

    if (pbData)
        delete[] pbData;



    return hr;
}

HRESULT CD3DXSkinMesh::ConvertToIndexedBlendedMesh(DWORD options,
						 CONST LPDWORD pAdjacencyIn,
                         DWORD paletteSize, 
						 LPDWORD pAdjacencyOut,
 					     DWORD* pNumBoneCombinations, 
                         LPD3DXBUFFER* ppBoneCombinationTable, 
						 LPD3DXMESH* ppMesh)
{
    GXTri3Mesh<tp16BitIndex>* pMeshOut = NULL;
    LPBYTE pVertOut = NULL;
    LPD3DXATTRIBUTERANGE attrTable = NULL;
    LPD3DXBONECOMBINATION pBoneCombination = NULL;
    DWORD* pBoneIds = NULL;
    DWORD i, j, k;
    DWORD numFaces = m_pMesh->m_cFaces;
    DWORD fvf = D3DFVF_XYZ;
    DWORD* origAttribIds = NULL;
    DWORD numMat = 0;
    DWORD attribBits;
    DWORD attrMask;
    HRESULT hr;

    // TODO: remove this limitation
    if (options & D3DXMESH_32BIT)
    {
        DPF(0, "32-bit meshes are not yet supported");
        return E_NOTIMPL;
    }

    // Is there any skinning info ?
    if (m_numBones == 0)
    {
        hr = m_pMesh->CloneMeshFVF(options, m_pMesh->GetFVF(), m_pMesh->m_pD3DDevice, ppMesh);
        return hr;
    }

    *ppBoneCombinationTable = NULL;
    *ppMesh = NULL;
    *pNumBoneCombinations = 0;

    CalcNumAttributes(&attrMask, &attribBits);

    hr = TruncVertexSkinData(m_faceClamp, pAdjacencyIn);
    if (hr != S_OK)
    {
        m_DataValid = 0;
        return hr;
    }
    DWORD maxVertInfl = min(m_maxVertInfl, m_faceClamp);

    if (paletteSize < maxVertInfl * 3)
    {
        DPF(0, "ConvertToIndexedBlendedMesh: Palette size %d too small. Need atleast %d", paletteSize, maxVertInfl * 3);
        m_DataValid = 0;
        return E_NOTIMPL;
    }

    DWORD* faceRemap = new DWORD[numFaces];
    if (faceRemap == NULL)
    {
        DPF(0, "Out of Memory");
        m_DataValid = 0;
        return E_OUTOFMEMORY;
    }

    DWORD numComb = 0;
    DWORD numUnassigned = numFaces;
    DWORD numCombAlloc = (DWORD)(m_numBones * 1.2 + paletteSize - 1) / paletteSize;
    WORD (*pFaces)[3] = NULL;
    WORD (*pFacesOut)[3] = NULL;
    LPD3DXBUFFER pVertRemapBuf = NULL;
    DWORD* matIdRemap;

    CD3DXBitField256* combBits = new CD3DXBitField256[numCombAlloc];
    CD3DXBitField256* faceInflBits = new CD3DXBitField256[numFaces];
    DWORD* faceAttr = new DWORD[numFaces];
    if (combBits == NULL ||
        faceInflBits == NULL ||
        faceAttr == NULL)
    {
        DPF(0, "Out of Memory");
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    // Initialize to "unassigned"
    memset(faceAttr, 0xff, sizeof(DWORD) * numFaces);

    // Generate per face bit fields
    m_pMesh->LockIndexBuffer(0, (PBYTE*)&pFaces);
    for (i = 0; i < numFaces; ++i)
    {
        for (j = 0; j < 3; ++j)
        {
            DWORD v = pFaces[i][j];
            DWORD vertInfl = min(m_vertInfl[v], maxVertInfl);
            for (k = 0; k < vertInfl; ++k)
            {
                faceInflBits[i].Set(m_vertMatId[v * m_maxVertInfl + k]);
            }
        }
        GXASSERT(faceInflBits[i].Count() <= paletteSize);
    }
    m_pMesh->UnlockIndexBuffer();
    pFaces = NULL;

    // Accumalate faces in to palettes 
    while (numUnassigned)
    {
        DWORD bMat = FALSE;
        DWORD combAttrib;
        if (numComb >= numCombAlloc)
        {
            numCombAlloc = (DWORD)(ceil(numCombAlloc * 1.2));
            CD3DXBitField256* newCombBits = new CD3DXBitField256[numCombAlloc];
            if (newCombBits == NULL)
            {
                DPF(0, "Out of Memory");
                hr = E_OUTOFMEMORY;
                goto e_Exit;
            }
            for (i = 0; i < numComb; ++i)
            {
                newCombBits[i] = combBits[i];
            }
            delete [] combBits;
            combBits = newCombBits;
        }
        // Pack as many faces as possible in this palette
        // as long they have the same attibute Ids
        for (i = 0; i < numFaces; ++i)
        {
            if (faceAttr[i] != UINT_MAX)
                continue;
            CD3DXBitField256 t;
            t.Or(combBits[numComb], faceInflBits[i]);
            if (t.Count() <= paletteSize)
            {
                if (!bMat) // If this is the first face, record attrib
                {
                    combAttrib = m_pMesh->m_rgiAttributeIds[i];
                    bMat = TRUE;
                }
                if (m_pMesh->m_rgiAttributeIds[i] == combAttrib) // make sure attrib matches
                {
                    faceAttr[i] = numComb;
                    --numUnassigned;
                    combBits[numComb] = t;
                }
            }
        }
        ++numComb;
    }

    DPF(1, "ConvertToIndexedBlendedMesh: Number of combinations = %d", numComb);
    // Evil Hack: Temporarily substitute the new attributes to optimize
    origAttribIds = m_pMesh->m_rgiAttributeIds;
    m_pMesh->m_rgiAttributeIds = faceAttr;

    // Calculate fvf for new mesh
    if (maxVertInfl - 1)
    {
        fvf = D3DFVF_XYZRHW + maxVertInfl * 2; // compute FVF
    }
    fvf = (m_pMesh->GetFVF() & (~D3DFVF_POSITION_MASK)) | fvf; // new FVF

    // Optimize using new attribute IDs to new mesh
    DWORD* vertRemap;
    
    hr = m_pMesh->Optimize2(options, D3DXMESHOPT_COMPACT | D3DXMESHOPT_ATTRSORT,
                            pAdjacencyIn, pAdjacencyOut, faceRemap, &pVertRemapBuf, fvf, &pMeshOut);
    if (hr != S_OK)
    {
        goto e_Exit;
    }

    // Undo evil hack: Restore the original attribute Ids
    m_pMesh->m_rgiAttributeIds = origAttribIds;

    // Get the new mesh's attribute table
    attrTable = pMeshOut->m_rgaeAttributeTable;
    *pNumBoneCombinations = pMeshOut->m_caeAttributeTable;
    GXASSERT(*pNumBoneCombinations == numComb);
    // Generate the bone combination table
	hr = D3DXCreateBuffer((sizeof(D3DXBONECOMBINATION) + paletteSize * sizeof(DWORD))* *pNumBoneCombinations, ppBoneCombinationTable);
    if (hr != S_OK)
    {
        goto e_Exit;
    }
	pBoneCombination = static_cast<LPD3DXBONECOMBINATION>((*ppBoneCombinationTable)->GetBufferPointer());

    // set up BoneId pointers inside the buffer
    pBoneIds = reinterpret_cast<DWORD*>(pBoneCombination + *pNumBoneCombinations);

    matIdRemap = new DWORD[m_numBones * numComb];
    if (matIdRemap == NULL)
    {
        DPF(0, "Out of Memory");
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

#if DBG
    DWORD* pAttrib;
    pMeshOut->LockAttributeBuffer(D3DLOCK_READONLY, &pAttrib);
#endif
    for (i = 0; i < *pNumBoneCombinations; ++i)
    {
#if DBG
        for (j = 0; j < attrTable[i].FaceCount; ++j)
        {
            GXASSERT(pAttrib[attrTable[i].FaceStart + j] == i);
        }
#endif
		pBoneCombination[i].AttribId = m_pMesh->m_rgiAttributeIds[faceRemap[attrTable[i].FaceStart]];
		pBoneCombination[i].FaceCount = attrTable[i].FaceCount;
		pBoneCombination[i].FaceStart = attrTable[i].FaceStart;
		pBoneCombination[i].VertexCount = attrTable[i].VertexCount;
		pBoneCombination[i].VertexStart = attrTable[i].VertexStart;
        pBoneCombination[i].BoneId = pBoneIds + i * paletteSize;
        k = 0;
        for (j = 0; j < m_numBones; ++j)
        {
            if (combBits[i].IsSet(j))
            {
                pBoneCombination[i].BoneId[k] = j;
                matIdRemap[i * m_numBones + j] = k;
                ++k;
            }
        }
        for (; k < paletteSize; ++k)
        {
            pBoneCombination[i].BoneId[k] = UINT_MAX;
        }
        GXASSERT(attrTable[i].AttribId == i);
    }

    vertRemap = reinterpret_cast<DWORD*>(pVertRemapBuf->GetBufferPointer());

    if (maxVertInfl - 1)
    {
        DWORD comb = 0;
        DWORD count = 0;
        // Fill in weights and indices
        pMeshOut->LockVertexBuffer(0, &pVertOut);
#if DBG
        pMeshOut->LockIndexBuffer(0, (PBYTE*)&pFacesOut);
#endif
        DXCrackFVF  cfvfout(fvf);
        for (i = 0; i < pMeshOut->m_cVertices; ++i)
        {
#if DBG
            for (j = 0; j < numFaces; ++j)
            {
                for (k = 0; k < 3; ++k)
                {
                    if (pFacesOut[j][k] == i)
                    {
                        GXASSERT(j >= pBoneCombination[comb].FaceStart);
                        GXASSERT(j < pBoneCombination[comb].FaceStart + pBoneCombination[comb].FaceCount);
                        DWORD attr = faceAttr[faceRemap[j]];
                        GXASSERT(attr == comb);
                        GXASSERT(combBits[comb].IsSubset(faceInflBits[faceRemap[j]]));
                        DWORD v = vertRemap[i];
                        DWORD vertInfl = min(m_vertInfl[v], maxVertInfl);
                        for (DWORD l = 0; l < vertInfl; ++l)
                        {
                            DWORD matId = m_vertMatId[v * m_maxVertInfl + l];
                            GXASSERT(faceInflBits[faceRemap[j]].IsSet(matId));
                        }
                    }
                }
            }
#endif
            float* pOut = cfvfout.PfGetWeights(cfvfout.GetArrayElem(pVertOut, i));
            LPBYTE matIndices = (LPBYTE)(pOut + maxVertInfl - 1);
            DWORD v = vertRemap[i];
#if DBG
            float sum = 0.0f;
#endif
            for (j = 0; j < maxVertInfl - 1; ++j)
            {
                pOut[j] = m_vertMatWeight[v * m_maxVertInfl + j];
#if DBG
                sum += m_vertMatWeight[v * m_maxVertInfl + j];
#endif
            }
#if DBG
            sum += m_vertMatWeight[v * m_maxVertInfl + j];
//            GXASSERT(fabs(sum - 1.f) < 0.001);
#endif
            DWORD vertInfl = min(m_vertInfl[v], maxVertInfl);
            for (j = 0; j < vertInfl; ++j)
            {
                DWORD matId = m_vertMatId[v * m_maxVertInfl + j];
                GXASSERT(matId < m_numBones);
                matIndices[j] = (BYTE)matIdRemap[comb * m_numBones + matId];
                GXASSERT(pBoneCombination[comb].BoneId[matIdRemap[comb * m_numBones + matId]] == matId);
            }
            ++count;
            // Are we done with all vertices of this particular palette ?
            if (pBoneCombination[comb].VertexCount <= count)
            {
                ++comb; // Move to the next palette
                count = 0;
            }
        }
        pMeshOut->UnlockVertexBuffer();
#if DBG
        pMeshOut->UnlockIndexBuffer();
#endif
    }

    delete [] faceInflBits;
    faceInflBits = NULL;
    delete [] combBits;
    combBits = NULL;
    delete [] faceAttr;
    faceAttr = NULL;
    delete [] faceRemap;
    faceRemap = NULL;
    delete [] matIdRemap;
    matIdRemap = NULL;

    *ppMesh = pMeshOut;
    m_DataValid = 0;
    return S_OK;
e_Exit:
    delete [] combBits;
    delete [] faceAttr;
    delete [] faceInflBits;
    delete [] faceRemap;
    delete [] matIdRemap;
    GXRELEASE(pMeshOut);
    m_DataValid = 0;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\mesh\skinmesh.h ===
#pragma once

#ifndef __SKINMESH_H__
#define __SKINMESH_H__

/*//////////////////////////////////////////////////////////////////////////////
//
// File: skinmesh.h
//
// Copyright (C) 2000 Microsoft Corporation. All Rights Reserved.
//
//
//////////////////////////////////////////////////////////////////////////////*/

#include "tri3mesh.h"

class CBone
{
public:
    DWORD m_numWeights;
    DWORD* m_pVertIndices;
    float* m_pWeights;
	CBone();
	~CBone();
};

typedef CBone* LPBONE;

// Defines for CD3DXSkinMesh::m_DataValid
enum {
    D3DXSM_VERTINFL = 1,
    D3DXSM_FACEINFL = 2,
    D3DXSM_VERTDATA = 4,
};

class CD3DXSkinMesh : public ID3DXSkinMesh
{
public:
    HRESULT WINAPI QueryInterface(REFIID iid, LPVOID *ppv);

    ULONG WINAPI AddRef();
    
	ULONG WINAPI Release();

    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice);
	
    STDMETHOD(GetVertexBuffer)(THIS_ LPDIRECT3DVERTEXBUFFER8* ppVB);

    STDMETHOD(GetIndexBuffer)(THIS_ LPDIRECT3DINDEXBUFFER8* ppIB);

	STDMETHOD(LockVertexBuffer)(THIS_ DWORD flags, BYTE** ppData);

	STDMETHOD(UnlockVertexBuffer)(THIS);

	STDMETHOD(LockIndexBuffer)(THIS_ DWORD flags, BYTE** ppData);

    STDMETHOD(UnlockIndexBuffer)(THIS);

	STDMETHOD(LockAttributeBuffer)(THIS_ DWORD flags, DWORD** ppData);

    STDMETHOD(UnlockAttributeBuffer)(THIS);

    STDMETHOD_(DWORD, GetNumBones)(THIS);

    STDMETHOD(GetOriginalMesh)(THIS_ LPD3DXMESH* ppMesh);

    STDMETHOD_(DWORD, GetNumFaces)(THIS);
    
    STDMETHOD_(DWORD, GetNumVertices)(THIS);
    
    STDMETHOD_(DWORD, GetFVF)(THIS);
    
    STDMETHOD(GetDeclaration)(THIS_ DWORD Declaration[MAX_FVF_DECL_SIZE]);
    
    STDMETHOD_(DWORD, GetOptions)(THIS);

    HRESULT WINAPI SetBoneInfluence(DWORD bone,
							 DWORD numInfluences,
							 CONST DWORD* vertices,
							 CONST float* weights);
	
	DWORD WINAPI GetNumBoneInfluences(DWORD bone);
	
	HRESULT WINAPI GetBoneInfluence(DWORD bone, 
							 DWORD* vertices,
							 float* weights);
	
	STDMETHOD(GetMaxVertexInfluences)(THIS_ DWORD* maxVertexInfluences);
	
	STDMETHOD(GetMaxFaceInfluences)(THIS_ DWORD* maxFaceInfluences);

	HRESULT WINAPI GenerateSkinnedMesh(DWORD options, 
                         FLOAT fMinWeight, 
                         CONST LPDWORD rgiAdjacencyIn, 
                         LPDWORD rgiAdjacencyOut, 
                         LPD3DXMESH* ppMesh);

    HRESULT WINAPI UpdateSkinnedMesh(CONST D3DXMATRIX* pBoneTransforms, LPD3DXMESH pMesh);

	HRESULT WINAPI ConvertToBlendedMesh(DWORD options,
						 CONST LPDWORD pAdjacencyIn,
						 LPDWORD pAdjacencyOut,
						 DWORD* pNumBoneCombinations,
						 LPD3DXBUFFER* ppBoneCombinationTable,
						 LPD3DXMESH* ppMesh);

	HRESULT WINAPI ConvertToIndexedBlendedMesh(DWORD options,
						 CONST LPDWORD pAdjacencyIn,
                         DWORD paletteSize, 
						 LPDWORD pAdjacencyOut,
                         DWORD* pNumBoneCombinations, 
                         LPD3DXBUFFER* ppBoneCombinationTable, 
						 LPD3DXMESH* ppMesh);
	CD3DXSkinMesh();
	~CD3DXSkinMesh();
	HRESULT Init(DWORD numFaces, DWORD numVertices, DWORD numBones, DWORD options, DWORD fvf, LPDIRECT3DDEVICE8 pD3DDevice);
    HRESULT Init(LPD3DXMESH pMesh, LPBONE pBones, DWORD numBones);
	HRESULT Init(LPD3DXMESH pMesh, DWORD numBones);
	HRESULT Init(DWORD numBones);
    HRESULT CalcVertexSkinData();
    HRESULT TruncVertexSkinData(DWORD truncVertInfl, LPDWORD pAdjacencyIn);
    void CalcNumAttributes(LPDWORD pAttrMask, LPDWORD pAttrBits);
private:
	// Changes with SetBoneInfluence or GenerateSkinnedMesh
	CBone* m_pBones;
	DWORD m_numBones;
	DWORD m_maxVertInfl;
    DWORD* m_vertInfl;
    DWORD* m_vertMatId;
    float* m_vertMatWeight;

	// Changes with SetMesh
	GXTri3Mesh<tp16BitIndex> *m_pMesh;
	DWORD m_numAttrib;

	// Changes with either SetBoneInfluence or SetMesh
    DWORD m_matidShift;
    DWORD m_maxFaceInfl;
    DWORD m_DataValid;

	// Invariants to SetBoneInfluence and SetMesh
	DWORD m_refCnt;
    D3DXMATRIX** m_pBoneMatrix;
    DWORD m_faceClamp; // max infl per face in output mesh. Any more infl in the input are ignored
    BOOL m_bMixedDevice;

    // Calculated during GenerateSkinnedMesh
    float*  m_rgfCodes;
    bool    m_bChangedWeights;
    float   m_fMinWeight;

    // Helper functions
    HRESULT GenerateCodes();    // reallocates & recalculates m_rgfCodes
};

#endif //__SKINMESH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\mesh\tri3mesh.h ===
#pragma once

#ifndef __TRI3MESH_H__
#define __TRI3MESH_H__

/*//////////////////////////////////////////////////////////////////////////////
//
// File: createmesh.cpp
//
// Copyright (C) 1999 Microsoft Corporation. All Rights Reserved.
//
// @@BEGIN_MSINTERNAL
//
// History:
// -@-          (craigp)    - created 
// -@- 08/19/99 (mikemarr)  - started comment history
//                          - added #include <limits.h>
//                          - added #pragma once
//
// @@END_MSINTERNAL
//
//////////////////////////////////////////////////////////////////////////////*/

#include "gxcrackfvf.h"

// Disable warnings of loss of data conversion assignments
#pragma warning(disable:4242)

template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED> class GXSimplifyMesh;
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED> class GXHalfEdgePMesh;
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED> class CFaceListIter;
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED> class CVertexCache;
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED> class CMeshStatus;
template <class UINT_IDX, unsigned int UNUSED> class CIndexQueue;
template <class UINT_IDX, unsigned int UNUSED> class CSimVertexCache;


#define UINT32UNUSED (0xffffffff)
#define UINT16UNUSED (0xffff)

// constants for use in template parameters
#define tp32BitIndex unsigned int, false, UINT32UNUSED
#define tp16BitIndex unsigned short, true, UINT16UNUSED

#define D3DXMESHINT_FACEADJACENCY         0x001
#define D3DXMESHINT_POINTREP              0x002
#define D3DXMESHINT_ATTRIBID              0x004
#define D3DXMESHINT_ATTRIBINDEX           0x008
#define D3DXMESHINT_ATTRIBUTETABLE        0x010
#define D3DXMESHINT_SHAREDVB              0x020

// @@BEGIN_MSINTERNAL
#define D3DXMESHINT_VALIDBITS             0x03f
// @@END_MSINTERNAL


struct SFaceCorner
{
    DWORD iFace;
    DWORD iPoint;

    SFaceCorner(DWORD iFaceNew, DWORD iPointNew)
        :iFace(iFaceNew), iPoint(iPointNew) {}
    SFaceCorner()
        :iFace(UNUSED32), iPoint(UNUSED32) {}
};

template <class UINT_IDX>
class NeighborInfo
{
public:
    NeighborInfo() { }
    NeighborInfo( UINT_IDX iNeighbor0, UINT_IDX iNeighbor1, UINT_IDX iNeighbor2 )
    {
        m_iNeighbors[0] = iNeighbor0;
        m_iNeighbors[1] = iNeighbor1;
        m_iNeighbors[2] = iNeighbor2;
    }
    NeighborInfo( UINT_IDX iNeighbors[3] )
    {
        m_iNeighbors[0] = iNeighbors[0];
        m_iNeighbors[1] = iNeighbors[1];
        m_iNeighbors[2] = iNeighbors[2];
    }
    UINT_IDX m_iNeighbors[3];
};


template <class UINT_IDX>
class GXTri3Face
{
public:
    GXTri3Face() { }
    GXTri3Face( UINT_IDX w0, UINT_IDX w1, UINT_IDX w2 )
    {
        m_wIndices[0] = w0;
        m_wIndices[1] = w1;
        m_wIndices[2] = w2;
    }
    GXTri3Face( UINT_IDX wIndices[3] )
    {
        m_wIndices[0] = wIndices[0];
        m_wIndices[1] = wIndices[1];
        m_wIndices[2] = wIndices[2];
    }
    UINT_IDX m_wIndices[3];
};

template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
class GXTri3Mesh : public ID3DXMesh
{
    friend class GXTri3Mesh<tp16BitIndex>;
    friend class GXTri3Mesh<tp32BitIndex>;
    friend class GXSimplifyMesh<tp16BitIndex>;
    friend class GXSimplifyMesh<tp32BitIndex>;
    friend class GXHalfEdgePMesh<tp16BitIndex>;
    friend class GXHalfEdgePMesh<tp32BitIndex>;
    friend class CFaceListIter<UINT_IDX, b16BitIndex, UNUSED>;
    friend class CVertexCache<UINT_IDX, b16BitIndex, UNUSED>;
	friend class CD3DXSkinMesh;
public:
    GXTri3Mesh( LPDIRECT3DDEVICE8 pD3DDevice, DWORD dwFVF, DWORD dwOptions );
    ~GXTri3Mesh( );

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    virtual ULONG STDMETHODCALLTYPE AddRef( void) 
        
    {
        // if this is contained in another object defer the call to that object
        if (m_punkOuter != NULL)
            return m_punkOuter->AddRef();

        m_cRef += 1;
        return m_cRef;
    }

    virtual ULONG STDMETHODCALLTYPE Release( void) 
    {
        // if this is contained in another object defer the call to that object
        if (m_punkOuter != NULL)
            return m_punkOuter->Release();

        ULONG cRef = m_cRef;
        m_cRef -= 1;

        if (cRef == 1)
            delete this;

        return cRef-1;
    }

    // ID3DXBaseMesh
    STDMETHOD(DrawSubset)(THIS_ DWORD attribId);
    STDMETHOD_(DWORD, GetNumFaces)(THIS);
    STDMETHOD_(DWORD, GetNumVertices)(THIS);
    STDMETHOD_(DWORD, GetFVF)(THIS);
    STDMETHOD(GetDeclaration)(THIS_ DWORD Declaration[MAX_FVF_DECL_SIZE]);
    STDMETHOD_(DWORD, GetOptions)(THIS);
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DDEVICE8* ppDevice)
                { 
                    if (ppDevice == NULL)
                    {
                        DPF(0, "ppDevice pointer is invalid");
                        return D3DERR_INVALIDCALL;
                    }
                    m_pD3DDevice->AddRef(); 
                    *ppDevice = m_pD3DDevice;
                    return S_OK; 
                }
    STDMETHOD(CloneMeshFVF)(THIS_ DWORD options, 
                DWORD fvf, LPDIRECT3DDEVICE8 pD3DDevice, LPD3DXMESH* ppCloneMesh);
    STDMETHOD(CloneMesh)(THIS_ DWORD options, 
                CONST DWORD *pDeclaration, LPDIRECT3DDEVICE8 pD3DDevice, LPD3DXMESH* ppCloneMesh);
    STDMETHOD(GetVertexBuffer)(THIS_ LPDIRECT3DVERTEXBUFFER8* ppVB);
    STDMETHOD(GetIndexBuffer)(THIS_ LPDIRECT3DINDEXBUFFER8* ppIB);
	STDMETHOD(LockVertexBuffer)(THIS_ DWORD flags, BYTE** ppData)
                { return m_pVBVertices->Lock(0, 0, ppData, flags ); }
	STDMETHOD(UnlockVertexBuffer)(THIS)
                { return m_pVBVertices->Unlock(); }
	STDMETHOD(LockIndexBuffer)(THIS_ DWORD flags, BYTE** ppData)
                { return m_pibFaces->Lock(0, 0, ppData, flags ); }
	STDMETHOD(UnlockIndexBuffer)(THIS)
                { return m_pibFaces->Unlock(); }
    STDMETHOD(GetAttributeTable)(
                THIS_ D3DXATTRIBUTERANGE *attribEntry, DWORD* attribTabSize);

    // ID3DXMesh
	STDMETHOD(LockAttributeBuffer)(THIS_ DWORD flags, DWORD** ppData)
                { 
                    // if not locked read only, remove the attribute table
                    if (!(flags & D3DLOCK_READONLY))
                    {
                        delete []m_rgaeAttributeTable;
                        m_rgaeAttributeTable = NULL;
                        m_caeAttributeTable = 0;
                        m_dwOptionsInt &= ~D3DXMESHINT_ATTRIBUTETABLE;
                    }

                    *ppData = m_rgiAttributeIds; 
                    return S_OK; 
                }
	STDMETHOD(UnlockAttributeBuffer)(THIS)
                { return S_OK; }

    STDMETHOD(ConvertPointRepsToAdjacency)(THIS_ CONST DWORD* PRep, DWORD* fAdjacency);
    STDMETHOD(ConvertAdjacencyToPointReps)(THIS_ CONST DWORD* fAdjacency, DWORD* PRep);
    STDMETHOD(GenerateAdjacency)(THIS_ FLOAT fEpsilon, DWORD* pAdjacency);

    STDMETHOD(Optimize)(THIS_ DWORD flags, CONST DWORD* adjacency, DWORD* optAdj, 
                     DWORD* faceRemap, LPD3DXBUFFER *ppbufVertexRemap,  
                     LPD3DXMESH* ppOptMesh);
    STDMETHOD(OptimizeInplace)(THIS_ DWORD Flags, CONST DWORD* pAdjacencyIn, DWORD* pAdjacencyOut, 
                     DWORD* pFaceRemap, LPD3DXBUFFER *ppVertexRemap);


    // internal
    inline HRESULT LockVB(PBYTE *ppvDest)
    {
        return m_pVBVertices->Lock(0,0, ppvDest, 0 );
    }

    inline HRESULT UnlockVB()
    {
        return m_pVBVertices->Unlock();
    }

    inline HRESULT LockIB(PBYTE *ppvDest)
    {
        return m_pibFaces->Lock(0,0, ppvDest, 0 );
    }

    inline HRESULT UnlockIB()
    {
        return m_pibFaces->Unlock();
    }

    HRESULT Resize(UINT cFaces, UINT cVertices);

private:

    virtual bool        BValid(GXTri3Face<UINT_IDX> *pwFacesLocked = NULL);
    bool BValidAttributeGroups(GXTri3Face<UINT_IDX> *pwFaces);

    // simplification support
    HRESULT CopyMesh(GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED> *ptmSrc);
    HRESULT CloneHelper16(GXTri3Mesh<tp16BitIndex> *ptmNewMesh16);
    HRESULT CloneHelper32(GXTri3Mesh<tp32BitIndex> *ptmNewMesh32);
    HRESULT CloneVertexBuffer(DWORD dwFVFNew, LPDIRECT3DVERTEXBUFFER8 pVertexBuffer);

    // optimization functions
    HRESULT Optimize2(DWORD options, DWORD flags, DWORD* adjacency, DWORD* optAdj, DWORD* faceRemap, 
                      LPD3DXBUFFER *ppbufVertexRemap, DWORD FVF, GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED>** ppOptMesh);
    HRESULT OptimizeInternal(DWORD dwFlags, CONST DWORD *rgdwNeighbors, DWORD* rgdwNeighborsOut, 
         DWORD* rgiFaceRemapInverseOut, LPD3DXBUFFER *ppbufVertexRemapInverseOut, LPDIRECT3DVERTEXBUFFER8 pOrigVertexBuffer, DWORD dwOrigFVF);
    HRESULT Compact(UINT *rgiFaceRemapUser, UINT *rgiFaceRemapInverse, UINT *rgiVertexRemapUser);
    HRESULT AttributeSort(UINT *rgiFaceRemapUser, UINT *rgiFaceRemapInverse, UINT *rgiVertexRemapUser, BOOL bIgnoreVerts);
    HRESULT VertexOptimize(UINT *rgiFaceRemapInverse, UINT *rgiVertRemap);
    HRESULT SplitSharedVertices(DWORD **prgdwNewVertexOrigin, UINT *pcNewVertices);
    //HRESULT VertexAttributeSort(UINT *rgiFaceRemapInverse, UINT *rgiVertexRemapUser);
    HRESULT StripReorder(DWORD dwOptions, UINT *rgiFaceRemap, UINT *rgiFaceRemapInverse, CONST DWORD *rgdwNeighbors);
    HRESULT ReorderVertexData(UINT *rgiVertRemap, PBYTE pvPoints);
    HRESULT ReorderFaceData(UINT *rgiFaceRemap, UINT *rgiVertRemap);

    // strip reorder optimizations
    HRESULT SGIStripReorder(CMeshStatus<UINT_IDX,b16BitIndex,UNUSED> *pmsMeshStatus, UINT *rgiFaceRemap, UINT *rgiFaceRemapInverse);
    HRESULT VCacheStripReorder(CMeshStatus<UINT_IDX,b16BitIndex,UNUSED> *pmsMeshStatus, UINT *rgiFaceRemap, UINT *rgiFaceRemapInverse);
    HRESULT OldVCacheStripReorder(CMeshStatus<UINT_IDX,b16BitIndex,UNUSED> *pmsMeshStatus, UINT *rgiFaceRemap, UINT *rgiFaceRemapInverse);
    

    // vertex cache simulations
    UINT_IDX IVCFindNextFace(UINT_IDX iFace, UINT_IDX &cFacesToContinueBest, UINT_IDX &cFacesInStrip, CIndexQueue<UINT_IDX,UNUSED> &iqPossibleRestarts, CIndexQueue<UINT_IDX,UNUSED> &iqTemp, CMeshStatus<UINT_IDX,b16BitIndex,UNUSED> *pmsMeshStatus, 
            CSimVertexCache<UINT_IDX,UNUSED> &svc, CSimVertexCache<UINT_IDX,UNUSED> &svcTemp);
    HRESULT VCSimulate(UINT cFacesToContinue, UINT_IDX iFace, UINT cFacesInStripOrig, CIndexQueue<UINT_IDX,UNUSED> &iqPossibleRestartsOrig, CIndexQueue<UINT_IDX,UNUSED> &iqPossibleRestarts, CMeshStatus<UINT_IDX,b16BitIndex,UNUSED> *pmsMeshStatus, 
                        CSimVertexCache<UINT_IDX,UNUSED> &svcOrig, CSimVertexCache<UINT_IDX,UNUSED> &svc,
                        UINT cMaxFacesPerStrip, float &fEstimate);
    UINT_IDX IVCRestartStrip(CIndexQueue<UINT_IDX,UNUSED> &iqPossibleRestarts, CMeshStatus<UINT_IDX,b16BitIndex,UNUSED> *pmsMeshStatus);
    HRESULT CalculateMissRate(UINT *rgiFaceRemapInverse, PUINT pcMisses);
    SFaceCorner ClwFaceCorner(SFaceCorner &cn);
    SFaceCorner CcwFaceCorner(SFaceCorner &cn);
    SFaceCorner CcwCorner(SFaceCorner &cn, CMeshStatus<UINT_IDX,b16BitIndex,UNUSED> *pmsMeshStatus);
    SFaceCorner ClwCorner(SFaceCorner &cn, CMeshStatus<UINT_IDX,b16BitIndex,UNUSED> *pmsMeshStatus);
    void TryStartingEarlier(SFaceCorner &cn, CMeshStatus<UINT_IDX,b16BitIndex,UNUSED> *pmsMeshStatus);

    // reorder methods, used by simplification only
    HRESULT Reorder(UINT *rgiVertRemap, UINT ciVertRemapUser, 
              UINT *rgiFaceRemap, UINT ciFaceRemapUser);
    void RemapVertex(UINT iVert, UINT *rgiVertRemap);
    void RemapFace(UINT iFace, UINT *rgiVertRemap, UINT *rgiFaceRemap);
    void SwapVertex(UINT iVertSrc, UINT iVertDest, PBYTE pvPoints);
    void SwapFace(UINT iFaceSrc, UINT iFaceDest);
    HRESULT CollectAttributeIds(DWORD **prgiAttribIds, LPDWORD pcattr);

    //HRESULT SplitTriangle( UINT_IDX iFace, UINT_IDX iEdge, UINT_IDX iNewPoint, UINT *pNewFace);
    HRESULT AddVertex( PBYTE pvPoint, UINT_IDX wPointRep);

    //HRESULT ChangeNeighbor(UINT_IDX iFace, UINT_IDX iOldNeighbor, UINT_IDX iNewNeighbor);
    void    MarkAsUnused(UINT_IDX iFace);

    //bool  BPointInFace(UINT_IDX *pwIndices, UINT iPointSearch) const;
    UINT  FindPoint(UINT_IDX *pwIndices, UINT iPointSearch) const;
    UINT  FindWedge(UINT_IDX *pwIndices, UINT iWedgeSearch) const;
    //UINT_IDX  FindPointOffset(UINT_IDX iPointSearch, UINT_IDX iFace) const { return FindPoint(m_pFaces[iFace].m_wIndices, iPointSearch); }
    //UINT  CalculateNewNeighbor(UINT iNeighbor, UINT_IDX *pwFace, UINT_IDX iPointShared) const;
    //bool  EquivalentAttributesOnEdge(UINT_IDX iFace1, UINT_IDX iEdge1, UINT_IDX iFace2, UINT_IDX iEdge2) const;

    HRESULT CreateEmptyMesh();


    // not exposed externally, but used in simplification
    inline UINT BHasNeighborData() const        { return m_dwOptionsInt & D3DXMESHINT_FACEADJACENCY; }
    inline UINT BHasPointRepData() const        { return m_dwOptionsInt & D3DXMESHINT_POINTREP; }

    // always present on a normal mesh, but not present for half edge pms
    inline UINT BHasPerFaceAttributeId()  const { return m_dwOptionsInt & D3DXMESHINT_ATTRIBID; }

    // only used for half edge PMs
    inline UINT BHasPerFaceAttributeIndex() const { return m_dwOptionsInt & D3DXMESHINT_ATTRIBINDEX; }

    inline UINT BHasAttributeTable() const { return m_dwOptionsInt & D3DXMESHINT_ATTRIBUTETABLE; }

	inline UINT BSharedVB() const               { return m_dwOptionsInt & D3DXMESHINT_SHAREDVB; }

    // are the two points logically equivalent, ignoring the color, uv, etc.
    inline bool  BEqualPoints(UINT_IDX iPoint1, UINT_IDX iPoint2) const
    {
        GXASSERT(BHasPointRepData());
        GXASSERT((iPoint1 < m_cVertices) && (iPoint2 < m_cVertices));

        return m_rgwPointReps[iPoint1] == m_rgwPointReps[iPoint2];
    }

    inline UINT_IDX  WGetPointRep(UINT_IDX iPoint) const
    {
        GXASSERT(iPoint < m_cVertices);
        GXASSERT(BHasPointRepData());

        return m_rgwPointReps[iPoint];
    }

    DWORD   m_dwFVF;
    DWORD   m_dwOptions;
    DWORD   m_dwOptionsInt;
    D3DPOOL m_dwPoolIB, m_dwPoolVB;
    DWORD   m_dwUsageIB, m_dwUsageVB;
    LPDIRECT3D8 m_pD3D;
    LPDIRECT3DDEVICE8 m_pD3DDevice;

    // Vertices
    LPDIRECT3DVERTEXBUFFER8 m_pVBVertices;

    UINT    m_cBytesPerVertex;
    UINT    m_cVertices, m_cMaxVertices;

    UINT_IDX *m_rgwPointReps;

    LPDIRECT3DINDEXBUFFER8 m_pibFaces;
    GXTri3Face<UINT_IDX> *m_pFaces;
    NeighborInfo<UINT_IDX> *m_rgpniNeighbors;
    
    DWORD *m_rgiAttributeIds;
    UINT16 *m_rgiMaterialIndex;                   // per face material index instead of attribId

    D3DXATTRIBUTERANGE *m_rgaeAttributeTable;
    UINT m_caeAttributeTable;

    UINT m_cFaces, m_cMaxFaces;
    UINT m_cRef;

    IUnknown *m_punkOuter;
};


// -------------------------------------------------------------------------------
//  function    FindPoint
//
//   devnote    Simple helper function to determine where a point is in a face
//                  the pwIndices array is a three element array specifiying 
//                  points in a triangle face  
//
//   returns    if < 3, then iPointSearch is the position in the given face
//                      else when >= 3, the point is not in the given array
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
inline UINT
GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED>::FindPoint(UINT_IDX *pwIndices, UINT iPointSearch) const
{
    // get the representative for the point, so that we can compare
    //   them, this function compares the logical points in the mesh
    UINT_IDX wPointSearchRep = WGetPointRep(iPointSearch);


	if (WGetPointRep(pwIndices[0])==wPointSearchRep)
		return 0;
	else if (WGetPointRep(pwIndices[1])==wPointSearchRep)
		return 1;
    else if (WGetPointRep(pwIndices[2])==wPointSearchRep)
	    return 2;
    else
        return 3;
}

// -------------------------------------------------------------------------------
//  function    FindWedge
//
//   devnote    Simple helper function to determine where a wedge is in a face
//                  the pwIndices array is a three element array specifiying 
//                  points in a triangle face  
//
//   returns    if < 3, then iWedgeSearch is the position in the given face
//                      else when >= 3, the point is not in the given array
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
inline UINT
GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED>::FindWedge(UINT_IDX *pwIndices, UINT iWedgeSearch) const
{
	if (pwIndices[0]==iWedgeSearch)
		return 0;
	else if (pwIndices[1]==iWedgeSearch)
		return 1;
    else if (pwIndices[2]==iWedgeSearch)
	    return 2;
    else
        return 3;
}


// -------------------------------------------------------------------------------
//  function    FindEdge
//
//   devnote    Simple helper function to determine which edge of a neighbor
//                  face, points back to the given face
//                  the pwIndices array is a three element array specifiying 
//                  neighbors to a triangle face  
//
//   returns    if < 3, then iFaceSearch is the position in the given neighbor posiistion
//                      else when >= 3, the face is not in the given array
//
template<class UINT_IDX>
inline UINT
FindEdge(UINT_IDX *rgiIndices, UINT_IDX iFaceSearch)
{
    UINT iNeighborEdge;

    // find the edge that points to this triangle in the neighbor
    for (iNeighborEdge = 0; iNeighborEdge < 3; iNeighborEdge++)
    {
        if (rgiIndices[iNeighborEdge] == iFaceSearch)
        {
            break;
        }
    }

    return iNeighborEdge;
}


const BYTE x_iAllFaces = 0;
const BYTE x_iClockwise = 1;
const BYTE x_iCounterClockwise = 2;

// -------------------------------------------------------------------------------
//  class    CFaceListIter
//
//   devnote    used to simplify orbiting a vertex
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
class CFaceListIter
{
public:
    CFaceListIter(GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED> *ptmTriMesh)
        :m_iFace(UNUSED), m_wPoint(UNUSED), m_iCurFace(UNUSED), 
                        m_ptmTriMesh(ptmTriMesh), m_bClockwise(false), 
                        m_bStopOnBoundary(false)
    {
        // used to allow creation of the stack, and then intialization later
    }

    CFaceListIter(UINT_IDX iFace, UINT_IDX wPoint, GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED> *ptmTriMesh, BYTE iWalkType)
        :m_iFace(iFace), m_wPoint(wPoint), m_iCurFace(iFace), 
                        m_ptmTriMesh(ptmTriMesh), m_bClockwise(iWalkType != x_iCounterClockwise), 
                        m_bStopOnBoundary(iWalkType != x_iAllFaces)
    { 
        GXASSERT(iWalkType >= 0 && iWalkType <= 2);

        // find the next edge to jump to the next triangle
        m_iNextEdge = m_ptmTriMesh->FindWedge(m_ptmTriMesh->m_pFaces[iFace].m_wIndices, wPoint);
        GXASSERT(m_iNextEdge < 3);

        if (!m_bClockwise)
        {
            m_iNextEdge = (m_iNextEdge + 2) % 3;
        }

        m_iCurEdge = m_iNextEdge;
    }

    void Init(UINT_IDX iFace, UINT_IDX wPoint, BYTE iWalkType)
    {
        GXASSERT(iWalkType >= 0 && iWalkType <= 2);

        m_iFace = iFace;
        m_wPoint = wPoint;
        m_iCurFace = iFace;
        m_bClockwise = (iWalkType != x_iCounterClockwise);
        m_bStopOnBoundary = (iWalkType != x_iAllFaces);

        // find the next edge to jump to the next triangle
        m_iNextEdge = m_ptmTriMesh->FindWedge(m_ptmTriMesh->m_pFaces[iFace].m_wIndices, wPoint);
        GXASSERT(m_iNextEdge < 3);
        if (!m_bClockwise)
        {
            m_iNextEdge = (m_iNextEdge + 2) % 3;
        }

        m_iCurEdge = m_iNextEdge;
    }

    bool BEndOfList() { return m_iCurFace == UNUSED; }

    UINT_IDX GetNextFace();
    void GetNextEdgeFace(UINT_IDX &iEdge, UINT_IDX &iFace);

    bool MoveToCCWFace();

    void PeekNextFace(UINT_IDX &iFace, int &iPointOffset) const 
        {
            iFace = m_iCurFace;
            iPointOffset = m_iNextEdge;
        }


    UINT_IDX IGetPointIndex() const { return m_bClockwise ? m_iCurEdge : (m_iCurEdge + 1) % 3; }


    void GetCCWFace(UINT_IDX iFace, UINT_IDX wPointRep, UINT_IDX &iFaceCCW, int &iPointOffset) const
    {
        UINT_IDX iNextEdge;

        iNextEdge = m_ptmTriMesh->FindPoint(m_ptmTriMesh->m_pFaces[iFace].m_wIndices, wPointRep);
        iNextEdge = (m_iNextEdge + 2) % 3;

        iFaceCCW = m_ptmTriMesh->m_rgpniNeighbors[iFace].m_iNeighbors[iNextEdge];
        if (iFaceCCW != UNUSED)
        {
            iPointOffset = m_ptmTriMesh->FindPoint(m_ptmTriMesh->m_pFaces[iFaceCCW].m_wIndices, wPointRep);
        }
    }

private:
    UINT_IDX m_iFace;
    UINT_IDX m_wPoint;

    UINT_IDX m_iCurFace;
    UINT_IDX m_iCurEdge;
    UINT_IDX m_iNextEdge;
    GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED> *m_ptmTriMesh;

    bool m_bClockwise;
    bool m_bStopOnBoundary;
};

#ifdef _DEBUG

inline BOOL
CheckAdjacency
    (
    CONST DWORD *rgdwAdjacency,
    DWORD cFaces
    )
{
    DWORD iIndex;

    if (rgdwAdjacency != NULL)
    {
        for (iIndex = 0; iIndex < cFaces * 3; iIndex++)
        {
            GXASSERT((rgdwAdjacency[iIndex] == UNUSED32) || (rgdwAdjacency[iIndex] < cFaces));      

            if (rgdwAdjacency[iIndex] != UNUSED32)
            {
                GXASSERT(FindEdge(&rgdwAdjacency[rgdwAdjacency[iIndex] * 3], iIndex / 3) < 3);
            }
        }
    }

    return TRUE;
}

#endif

// struct used to contain state for cross fvf vertex copies
struct SVertexCopyContext
{
    DXCrackFVF cfvfSrc;
    DWORD rgdwTexCoordSizesSrc[8];

    DXCrackFVF cfvfDest;
    DWORD rgdwTexCoordSizesDest[8];

    DWORD cTexCoordsToCopy;
    DWORD rgdwTexCoordMins[8];
    DWORD rgdwTexCoordZero[8];
    DWORD cWeightsToCopy;
    DWORD cWeightsToZero;

    BOOL bCopyNormals;
    BOOL bCopyDiffuse;
    BOOL bCopySpecular;
    BOOL bCopyPointSize;

    // setup info required for fvf conversion
    SVertexCopyContext(DWORD dwFVFSrc, DWORD dwFVFDest)
        :cfvfSrc(dwFVFSrc), cfvfDest(dwFVFDest)
    {
        DWORD iTexCoord;

        cfvfSrc.GetTexCoordSizes(rgdwTexCoordSizesSrc);
        cfvfDest.GetTexCoordSizes(rgdwTexCoordSizesDest);

        // setup texture coord copy info
        cTexCoordsToCopy = min(cfvfSrc.CTexCoords(), cfvfDest.CTexCoords());
        for (iTexCoord = 0; iTexCoord < cTexCoordsToCopy; iTexCoord++)
        {
            GXASSERT(rgdwTexCoordSizesDest[iTexCoord] != 0);
            GXASSERT(rgdwTexCoordSizesSrc[iTexCoord] != 0);
            rgdwTexCoordMins[iTexCoord] = min(rgdwTexCoordSizesDest[iTexCoord], rgdwTexCoordSizesSrc[iTexCoord]);
            rgdwTexCoordZero[iTexCoord] = rgdwTexCoordSizesDest[iTexCoord] - rgdwTexCoordMins[iTexCoord];
        }

        // setup copy flags
        bCopyNormals = cfvfSrc.BNormal() && cfvfDest.BNormal();
        bCopyDiffuse = cfvfSrc.BDiffuse() && cfvfDest.BDiffuse();
        bCopySpecular = cfvfSrc.BSpecular() && cfvfDest.BSpecular();
        bCopyPointSize = cfvfSrc.BPointSize() && cfvfDest.BPointSize();

        cWeightsToCopy = min(cfvfDest.CWeights(), cfvfSrc.CWeights());
        cWeightsToZero = cfvfDest.CWeights() - cWeightsToCopy;
    }

    // copy a vertex doing the fvf conversion in the process
    void CopyVertex(PBYTE pvCurPointSrc, PBYTE pvCurPointDest)
    {
        PBYTE pbTexCoordsSrc;
        PBYTE pbTexCoordsDest;
        DWORD iTexCoord;
        float *pfWeights;

        cfvfDest.SetPosition(pvCurPointDest, cfvfSrc.PvGetPosition(pvCurPointSrc));

        pfWeights = (float*)(pvCurPointDest + sizeof(D3DXVECTOR3));
        if (cWeightsToCopy > 0)
        {
            memcpy(pfWeights, pvCurPointSrc + sizeof(D3DXVECTOR3), sizeof(float) * cWeightsToCopy);
            pfWeights += cWeightsToCopy;
        }
        if (cWeightsToZero > 0)
        {
            memset(pfWeights, 0, sizeof(float) * cWeightsToZero);
        }

        if (bCopyNormals)
        {
            cfvfDest.SetNormal(pvCurPointDest, cfvfSrc.PvGetNormal(pvCurPointSrc));
        }
        else if (cfvfDest.BNormal())
        {
            memset(pvCurPointDest + cfvfDest.m_oNormal, 0, sizeof(D3DXVECTOR3));
        }

        if (bCopyPointSize)
        {
            cfvfDest.SetPointSize(pvCurPointDest, cfvfSrc.FGetPointSize(pvCurPointSrc));
        }
        else if (cfvfDest.BPointSize())
        {
            cfvfDest.SetPointSize(pvCurPointDest, 0.0);
        }

        if (bCopyDiffuse)
        {
            cfvfDest.SetDiffuse(pvCurPointDest, cfvfSrc.ColorGetDiffuse(pvCurPointSrc));
        }
        else if (cfvfDest.BDiffuse())
        {
            cfvfDest.SetDiffuse(pvCurPointDest, 0);
        }

        if (bCopySpecular)
        {
            cfvfDest.SetSpecular(pvCurPointDest, cfvfSrc.ColorGetSpecular(pvCurPointSrc));
        }
        else if (cfvfDest.BSpecular())
        {
            cfvfDest.SetSpecular(pvCurPointDest, 0);
        }

        // copy tex coord data to be saved
        pbTexCoordsSrc = (PBYTE)cfvfSrc.PuvGetTex1(pvCurPointSrc);
        pbTexCoordsDest = (PBYTE)cfvfDest.PuvGetTex1(pvCurPointDest);
        for (iTexCoord = 0; iTexCoord < cTexCoordsToCopy; iTexCoord++)
        {
            GXASSERT(rgdwTexCoordMins[iTexCoord] > 0);
            memcpy(pbTexCoordsDest, pbTexCoordsSrc, rgdwTexCoordMins[iTexCoord]);

            // set unavailable ones to 0
            if (rgdwTexCoordZero[iTexCoord] > 0)
            {
                memset(pbTexCoordsDest + rgdwTexCoordMins[iTexCoord], 0, rgdwTexCoordZero[iTexCoord]);
            }

            pbTexCoordsSrc += rgdwTexCoordSizesSrc[iTexCoord];
            pbTexCoordsDest += rgdwTexCoordSizesDest[iTexCoord];
        }

        // memset any tex coords unavailable in src to copy to zero
        for (iTexCoord = cTexCoordsToCopy; iTexCoord < cfvfDest.CTexCoords(); iTexCoord++)
        {
            memset(pbTexCoordsDest, 0, rgdwTexCoordSizesDest[iTexCoord]);

            pbTexCoordsDest += rgdwTexCoordSizesDest[iTexCoord];
        }
    }
};

#include "tri3drawmesh.inl"
#include "tri3optmesh.inl"
#include "tri3mesh.inl"
#include "tri3editmesh.inl"

#pragma warning(default:4242)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\mesh\simplify.inl ===
/*//////////////////////////////////////////////////////////////////////////////
//
// File: simplify.cpp
//
// Copyright (C) 1999 Microsoft Corporation. All Rights Reserved.
//
// @@BEGIN_MSINTERNAL
//
// History:
// -@-          (craigp)    - created 
// -@- 08/06/99 (mikemarr)  - prepend GX to all Luciform functions
//                          - started comment history
//
// @@END_MSINTERNAL
//
//////////////////////////////////////////////////////////////////////////////*/

#include "quadric.h"

const bool x_bGenerateHalfEdgePM = true;
const bool x_bRestrictForHalfEdgePM = true;

// maps of edge collapsed to how much index of points in triangle will
//   be after being generated from vsplit records
const int x_rgiLeftFaceEdgeAdjustment[3] = { 0, 2, 1 };
const int x_rgiRightFaceEdgeAdjustment[3] = { 2, 1, 0 };

const double x_fEpsilon = 1.0e-6;

// -------------------------------------------------------------------------------
//  class    CSimplificationHeap
//
//   devnote    implementation of a heap to priotize edges by cost
//
template <class UINT_IDX>
class CSimplificationHeap
{
public:
    CSimplificationHeap()
        :m_rgpeiHeap(NULL), m_cElements(0) {}

    ~CSimplificationHeap()
    {
        delete []m_rgpeiHeap;
    }

    HRESULT Init(UINT cElements);
    bool BValid();

    HRESULT Add(CEdgeInfo<UINT_IDX> *peiInfo);
    HRESULT Delete(CEdgeInfo<UINT_IDX> *peiInfo);
    HRESULT Update(CEdgeInfo<UINT_IDX> *peiInfo);
    CEdgeInfo<UINT_IDX> *PeiExtractMin();

#ifdef _DEBUG
    HRESULT DebugDump(NeighborInfo<UINT_IDX> *rgpniNeighbors);
#endif

private:
    void Switch(UINT iElement, UINT iOtherElement);
    void Adjust(UINT iElement, bool bUp, bool bDown);

    CEdgeInfo<UINT_IDX> **m_rgpeiHeap;
    UINT m_cElements;
    UINT m_cElementsMax;
};


// -------------------------------------------------------------------------------
//  struct    SEdgeCollapseContext
//
//   devnote    collection of data used to share between functions in GXSimplify::CollapseEdge
//
template <class UINT_IDX>
struct SEdgeCollapseContext
{
    UINT_IDX iFace1;
    UINT_IDX iEdge1;
    UINT_IDX iEdge1L;
    UINT_IDX iEdge1R;
    UINT_IDX iFace2;
    UINT_IDX iEdge2;
    UINT_IDX iEdge2L;
    UINT_IDX iEdge2R;
    UINT_IDX iNFace11;
    UINT_IDX iEdge11;
    UINT_IDX iNFace12;
    UINT_IDX iEdge12;
    UINT_IDX iNFace21;
    UINT_IDX iEdge21;
    UINT_IDX iNFace22;
    UINT_IDX iEdge22;
    UINT_IDX iPoint1;
    UINT_IDX iPoint2;
    UINT_IDX *pwNeighbors1;
    UINT_IDX *pwNeighbors2;
    D3DXVECTOR3 vPositionNew;
    UINT_IDX iWedge11;
    UINT_IDX iWedge12;
    UINT_IDX iWedge21;
    UINT_IDX iWedge22;
    UINT_IDX iWedgeL1;
    UINT_IDX iWedgeL2;
    UINT_IDX iWedgeR1;
    UINT_IDX iWedgeR2;
    UINT_IDX iWedgeRemove1;
    UINT_IDX iWedgeRemove2;
    UINT_IDX iWedgeRemove3;
    UINT_IDX iWedgeRemove4;
    UINT_IDX iWedgeRemove5;
    UINT_IDX iWedgeRemove6;
    UINT16 iMaterialLeft;
    UINT16 iMaterialRight;

    UINT ivsCurSplit;
};

// -------------------------------------------------------------------------------
//  class    CEdgeInfo
//
//   devnote    Encapsulate the idea of an edge in the mesh, used
//                  to put the edge in a priority heap and to access
//                  by the face/edge from the mesh
//
template <class UINT_IDX>
class CEdgeInfo
{

public:
    CEdgeInfo(UINT_IDX iEdge, UINT_IDX wFace, float dCost, D3DXVECTOR3 &vPosNew)
        :m_wFace(wFace), m_iEdge(iEdge), m_cost(dCost)
        {
        }

    UINT_IDX m_wFace;
    UINT_IDX m_iEdge;
    float m_cost;

    void SetHeapIndex(UINT iHeapIndex)      { m_iHeapIndex = iHeapIndex; }
    UINT IGetHeapIndex()                    { return m_iHeapIndex; }

    float DGetCost() { return m_cost; }

    // used to change ownership of the edge... i.e. two triangles are sharing
    //   an edge and one is removed.  the remaining one needs to make sure
    //   that the edge structure points at it.
    void SetOwner(UINT_IDX wFace, UINT_IDX iEdge)
    {
        m_wFace = wFace;
        m_iEdge = iEdge;
    }

private:
    UINT m_iHeapIndex;
};

// -------------------------------------------------------------------------------
//  function    Constructor for GXSimplifyMesh
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::GXSimplifyMesh( LPDIRECT3DDEVICE8 pD3DDevice, DWORD dwFVF, DWORD dwOptions)
   :m_cRef(1),
    m_cfvf(dwFVF),
    m_tmTriMesh(pD3DDevice, dwFVF, dwOptions | D3DXMESH_SYSTEMMEM),
    m_rgfeiEdges(NULL),
    m_rgiWedgeList(NULL),
    m_rgqVertexQuadrics(NULL),
    m_rgqFaceQuadrics(NULL),
    m_rgvFaceNormals(NULL),
    m_rgbVertexSeen(NULL),
    m_pheapCosts(NULL),
    m_rgvsSplits(NULL),
    m_rgbRemappedVSplit(NULL),
    m_cvsSplitsMax(0),
    m_cvsSplitCurFree(0),
    m_rgiFaceIndex(NULL),
    m_rgiEdgeAdjustment(NULL),
    m_pvHEVertexBuffer(NULL),
    m_rgiHEVertexBuffer(NULL),
    m_rgcvHEVertexBufferMax(NULL),
    m_rgcvHEVertexBufferFree(NULL),
    m_rgaeAttributeTableOrig(NULL),
    m_rgaeAttributeTableCur(NULL),
    m_rgiMaterialNew(NULL),
    m_cMaterialNewMax(0),
    m_cMaterialNewFree(0),
    m_rgbVertexDeleted(NULL),
    m_rgfVertexWeights(NULL),
    m_rgfTexWeights(NULL),
    m_cTexWeights(0),
    m_rgcolorDiffuse(NULL),
    m_rgcolorSpecular(NULL),
    m_cMaxFaces(0)
{
    m_tmTriMesh.m_punkOuter = (IUnknown*)this;

    m_tmTriMesh.m_dwOptionsInt |= D3DXMESHINT_FACEADJACENCY | D3DXMESHINT_POINTREP | D3DXMESHINT_ATTRIBID | D3DXMESHINT_ATTRIBINDEX;
}

// -------------------------------------------------------------------------------
//  function    destructor for GXSimplifyMesh
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::~GXSimplifyMesh()
{
    DWORD iFace;

    if (m_rgfeiEdges != NULL)
    {
        for (iFace = 0; iFace < m_cMaxFaces; iFace++)
        {
            delete m_rgfeiEdges[iFace].m_rgpeiEdges[0];
            delete m_rgfeiEdges[iFace].m_rgpeiEdges[1];
            delete m_rgfeiEdges[iFace].m_rgpeiEdges[2];
        }
        delete []m_rgfeiEdges;
    }

    delete m_pheapCosts;
    delete []m_rgiWedgeList;
    delete []m_rgqVertexQuadrics;
    delete []m_rgqFaceQuadrics;
    delete []m_rgvFaceNormals;

    delete []m_rgvsSplits;
    delete []m_pvHEVertexBuffer;
    delete []m_rgiHEVertexBuffer;
    delete []m_rgcvHEVertexBufferMax;
    delete []m_rgcvHEVertexBufferFree;
    delete []m_rgiMaterialNew;
    delete []m_rgaeAttributeTableOrig;
    delete []m_rgaeAttributeTableCur;
    delete []m_rgbRemappedVSplit;
    delete []m_rgiEdgeAdjustment;
    delete []m_rgiFaceIndex;
    delete []m_rgbVertexDeleted;
    delete []m_rgfVertexWeights;
    delete []m_rgfTexWeights;
    delete []m_rgcolorDiffuse;
    delete []m_rgcolorSpecular;

    delete []m_rgbVertexSeen;


}

template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
STDMETHODIMP_(ULONG) 
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::AddRef(void)
{
    return ++m_cRef;
}

template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
STDMETHODIMP_(ULONG) 
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::Release(void)
{
    if (--m_cRef != 0)
    {
        return m_cRef;
    }	
    
    delete this;
    return 0;
}


template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
STDMETHODIMP 
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{	
    *ppv=NULL;
    if (riid == IID_IUnknown)
        *ppv=(IUnknown*)this;
    else if (riid == IID_ID3DXSPMesh)
        *ppv=(ID3DXSPMesh*)this;
    else
        return E_NOINTERFACE;
    ((LPUNKNOWN)*ppv)->AddRef();

    return S_OK;
}

// -------------------------------------------------------------------------------
//  function    ReduceVertices
//
//   devnote    Set new number of current vertices
//              Since this is mesh simplify, only does anything if this number decreases
//                  Performs edge collapses until the current number of vertices
//                  reaches the requested number
//
//   returns    S_OK if successful, else failure code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT 
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::ReduceVertices
    (
    DWORD cVertices
    )
{
    HRESULT hr = S_OK;
    PBYTE pvPoints = NULL;
    CEdgeInfo<UINT_IDX> *peiInfo;

	unsigned int iFP;

    // make sure that we are in double precision
	iFP = _controlfp(0,0);
	_controlfp(_PC_53,_MCW_PC );

    hr = m_tmTriMesh.LockIB((PBYTE*)&m_tmTriMesh.m_pFaces);
    if (FAILED(hr))
        goto e_Exit;

#if 0
    if (0)
    {
        m_pheapCosts->DebugDump(m_tmTriMesh.m_rgpniNeighbors);
    }

    if (0)
    {
        delete []m_rgfeiEdges;
        m_rgfeiEdges = NULL;
        delete m_pheapCosts;
        m_pheapCosts = NULL;

        hr = CreateHeap();
        if (FAILED(hr))
            goto e_Exit;
    }
#endif

    // can't increase the number of vertices, so just return if asked to go back up
    if (cVertices >= m_cCurrentWedges)
    {
        // return success... they can ask for the number to go up, but is automatically
        //   "capped" just like with a PM
        goto e_Exit;
    }    

    // lock the points now to avoid looking for failures later
    hr = m_tmTriMesh.LockVB(&pvPoints);
    if (FAILED(hr))
    {
        goto e_Exit;
    }

    // collapsed edges until the number of vertices is correct
    while (m_cCurrentWedges > cVertices)
    {
#if 0
        DWORD cWedgesBefore = m_cCurrentWedges;
#endif
        peiInfo = m_pheapCosts->PeiExtractMin();

        if (peiInfo == NULL)
            break;

        hr = CollapseEdge(peiInfo, pvPoints);
        if (FAILED(hr))
            goto e_Exit;

#if 0
        if (cWedgesBefore != m_cCurrentWedges)
        {
            hr = ResetHeap();
            if (FAILED(hr))
                goto e_Exit;
        }
#endif
    }
    
    GXASSERT(BValid());
e_Exit:

    if (pvPoints != NULL)
    {
        HRESULT hrTest = m_tmTriMesh.UnlockVB();
        GXASSERT(!FAILED(hrTest));
        pvPoints = NULL;
    }

    if (m_tmTriMesh.m_pFaces != NULL)
    {
        m_tmTriMesh.UnlockIB();
    }

    // make sure that we restore the precision desired
	_controlfp(iFP,_MCW_PC );

    return hr;
}


// -------------------------------------------------------------------------------
//  function    GetMaxVertices
//
//   devnote    returns the maximum vertices possible in the mesh
//
//   returns    S_OK if successful, else failure code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
DWORD
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::GetMaxVertices()
{
    return m_cMaxVertices;
}

// -------------------------------------------------------------------------------
//  function    GetNumVertices
//
//   devnote    returns the current number of vertices in the mesh
//
//   returns    S_OK if successful, else failure code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
DWORD
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::GetNumVertices()
{
    return m_cCurrentWedges;
}

// -------------------------------------------------------------------------------
//  function    GetNumFaces
//
//   devnote    returns the current number of the facesin the mesh
//
//   returns    S_OK if successful, else failure code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
DWORD 
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::GetNumFaces()
{
    return m_cCurrentFaces;
}


// -------------------------------------------------------------------------------
//  function    GetMaxFaces
//
//   devnote    returns the maximum number of faces possible in the mesh
//                  with a Simplification mesh this is always the current number of faces
//
//   returns    S_OK if successful, else failure code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
DWORD 
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::GetMaxFaces()
{
    return m_cMaxFaces;
}

// -------------------------------------------------------------------------------
//  function    SetNumFaces
//
//   devnote    SetNumFaces, similar to SetNumVertices, sets the current number of faces
//
//   returns    S_OK if successful, else failure code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::ReduceFaces
    (
    DWORD cFaces
    )
{
    HRESULT hr = S_OK;
    PBYTE pvPoints = NULL;
    CEdgeInfo<UINT_IDX> *peiInfo;

	unsigned int iFP;

    // make sure that we are in double precision
	iFP = _controlfp(0,0);
	_controlfp(_PC_53,_MCW_PC );

    hr = m_tmTriMesh.LockIB((PBYTE*)&m_tmTriMesh.m_pFaces);
    if (FAILED(hr))
        goto e_Exit;

    // can't increase the number of vertices, so just return if asked to go back up
    if (cFaces >= m_cCurrentFaces)
    {
        // return success... they can ask for the number to go up, but is automatically
        //   "capped" just like with a PM
        goto e_Exit;
    }    

    // lock the points now to avoid looking for failures later
    hr = m_tmTriMesh.LockVB(&pvPoints);
    if (FAILED(hr))
    {
        goto e_Exit;
    }

    // collapsed edges until the number of vertices is correct
    while (m_cCurrentFaces > cFaces)
    {
        peiInfo = m_pheapCosts->PeiExtractMin();

        if (peiInfo == NULL)
            break;

        hr = CollapseEdge(peiInfo, pvPoints);
        if (FAILED(hr))
            goto e_Exit;
    }
    
    GXASSERT(BValid());
e_Exit:

    if (pvPoints != NULL)
    {
        HRESULT hrTest = m_tmTriMesh.UnlockVB();
        GXASSERT(!FAILED(hrTest));
        pvPoints = NULL;
    }

    if (m_tmTriMesh.m_pFaces != NULL)
    {
        m_tmTriMesh.UnlockIB();
    }

    // make sure that we restore the precision desired
	_controlfp(iFP,_MCW_PC );

    return hr;
}

// -------------------------------------------------------------------------------
//  function    CreateEmptyMesh
//
//   devnote    internal function used to get rid of existing information
//                  and start anew
//
//   returns    S_OK if successful, else failure code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT 
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::CreateEmptyMesh()
{
    delete []m_rgfeiEdges;
    m_rgfeiEdges = NULL;

    delete []m_rgiWedgeList;
    m_rgiWedgeList = NULL;

    delete []m_rgqVertexQuadrics;
    m_rgqVertexQuadrics = NULL;

    delete []m_rgqFaceQuadrics;
    m_rgqFaceQuadrics = NULL;

    delete []m_rgvFaceNormals;
    m_rgvFaceNormals = NULL;

    delete []m_rgvsSplits;
    m_rgvsSplits = NULL;

    delete []m_pvHEVertexBuffer;
    m_pvHEVertexBuffer = NULL;

    delete []m_rgiHEVertexBuffer;
    m_rgiHEVertexBuffer = NULL;

    delete []m_rgiMaterialNew;
    m_rgiMaterialNew = NULL;

    delete []m_rgaeAttributeTableOrig;
    m_rgaeAttributeTableOrig = NULL;

    delete []m_rgaeAttributeTableCur;
    m_rgaeAttributeTableCur = NULL;

    delete []m_rgbVertexDeleted;
    m_rgbVertexDeleted = NULL;

    delete []m_rgiFaceIndex;
    m_rgiFaceIndex = NULL;

    delete []m_rgiEdgeAdjustment;
    m_rgiEdgeAdjustment = NULL;

    delete []m_rgbVertexSeen;
    m_rgbVertexSeen = NULL;

    delete []m_rgfVertexWeights;
    m_rgfVertexWeights = NULL;

    delete []m_rgfTexWeights;
    m_rgfTexWeights = NULL;

    delete []m_rgcolorDiffuse;
    m_rgcolorDiffuse = NULL;

    delete []m_rgcolorSpecular;
    m_rgcolorSpecular = NULL;

    return m_tmTriMesh.CreateEmptyMesh();
}

// -------------------------------------------------------------------------------
//  function    ComputePointReps
//
//   devnote    Uses the face adjacency information to compute point reps for the mesh
//
//   returns    S_OK if successful, else failure code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::ComputePointReps()
{
    UINT cVertices = m_tmTriMesh.m_cVertices;
    UINT cFaces = m_tmTriMesh.m_cFaces;
    UINT_IDX wPointRep;
    UINT_IDX wWedge;
    UINT_IDX *pwFace;
    UINT_IDX iCurFace;
    UINT iFace;
    UINT iPoint;
    CFaceListIter<UINT_IDX,b16BitIndex,UNUSED> fli(&m_tmTriMesh);
    GXASSERT(m_tmTriMesh.BHasPointRepData());

    // first set all point reps to the UNUSED value to know whether or not we've seen
    //   a vertex before
    memset(m_tmTriMesh.m_rgwPointReps, 0xff, sizeof(UINT_IDX) * cVertices);

    for (iFace = 0; iFace < cFaces; iFace++)
    {
        pwFace = m_tmTriMesh.m_pFaces[iFace].m_wIndices;

        for (iPoint = 0; iPoint < 3; iPoint++)
        {
            wPointRep = pwFace[iPoint];
            if (wPointRep == UNUSED)
                continue;

            // if the point rep is unused, then we haven't circled this vertex yet
            if (m_tmTriMesh.m_rgwPointReps[wPointRep] == UNUSED)
            {
                // now that we need to setup the point rep, make a round of the 
                //     faces, marking all wedges of the given vertex with the new pointrep
                fli.Init(iFace, wPointRep, x_iAllFaces);
                while (!fli.BEndOfList())
                {
                    iCurFace = fli.GetNextFace();
                    
                    wWedge = m_tmTriMesh.m_pFaces[iCurFace].m_wIndices[fli.IGetPointIndex()];
                    m_tmTriMesh.m_rgwPointReps[wWedge] = wPointRep;
                }
            }
        }
    }

    return S_OK;
}


// -------------------------------------------------------------------------------
//  function    SetupWeightInfo
//
//   devnote    Use the user provided weights to setup simplification weight structures
//
//   returns    S_OK if successful, else failure code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::SetupWeightInfo
    (
    CONST LPD3DXATTRIBUTEWEIGHTS pVertexAttributeWeights,
    CONST FLOAT *rgfVertexWeights,
    PBYTE pvPoints
    )
{
    HRESULT hr = S_OK;
    DWORD iVertex;
    DWORD iTexCoord;
    DWORD iWeight;
    BOOL bFound;
    DWORD rgdwTexCoordSizes[8];
    float *pfTexWeightCur;

    m_rgfVertexWeights = new float[m_tmTriMesh.m_cVertices];
    if (m_rgfVertexWeights == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    // if the user provided vertex weights, then use them
    if (rgfVertexWeights != NULL)
    {
        memcpy(m_rgfVertexWeights, rgfVertexWeights, sizeof(float) * m_tmTriMesh.m_cVertices);
    }
    else  // no user provided weigthts, set tham all to 1
    {
        for (iVertex = 0; iVertex < m_tmTriMesh.m_cVertices; iVertex++)
        {
            m_rgfVertexWeights[iVertex] = 1.0f;
        }
    }

    // if the user specified component weights
    if (pVertexAttributeWeights != NULL)
    {
        memcpy(&m_AttributeWeights, pVertexAttributeWeights, sizeof(D3DXATTRIBUTEWEIGHTS));
    }
    else  // else use the default - just geometric and normal adjustment
    {
        memset(&m_AttributeWeights, 0, sizeof(D3DXATTRIBUTEWEIGHTS));

        m_AttributeWeights.Position = 1.0f;
        m_AttributeWeights.Normal = 1.0f;
        m_AttributeWeights.Boundary = 1.0f;
    }

    // include the internal weights for various components
    m_AttributeWeights.Normal *= (0.0004f * m_fMeshRadiusSq);
    m_AttributeWeights.Diffuse *= (0.01f * m_fMeshRadiusSq);
    m_AttributeWeights.Specular *= (0.01f * m_fMeshRadiusSq);
    m_AttributeWeights.Tex[0] *= (0.01f * m_fMeshRadiusSq);
    m_AttributeWeights.Tex[1] *= (0.01f * m_fMeshRadiusSq);
    m_AttributeWeights.Tex[2] *= (0.01f * m_fMeshRadiusSq);
    m_AttributeWeights.Tex[3] *= (0.01f * m_fMeshRadiusSq);
    m_AttributeWeights.Tex[4] *= (0.01f * m_fMeshRadiusSq);
    m_AttributeWeights.Tex[5] *= (0.01f * m_fMeshRadiusSq);
    m_AttributeWeights.Tex[6] *= (0.01f * m_fMeshRadiusSq);
    m_AttributeWeights.Tex[7] *= (0.01f * m_fMeshRadiusSq);

    // if there is a diffuse component, we need to convert to floating point
    if (m_cfvf.BDiffuse() && (m_AttributeWeights.Diffuse > 0.0f))
    {
        m_rgcolorDiffuse = new D3DXCOLOR[m_tmTriMesh.m_cVertices];
        if (m_rgcolorDiffuse == NULL)
        {
            hr = E_OUTOFMEMORY;
            return hr;
        }

        for (iVertex = 0; iVertex < m_tmTriMesh.m_cVertices; iVertex++)
        {
            m_rgcolorDiffuse[iVertex] = D3DXCOLOR(m_cfvf.ColorGetDiffuse(m_cfvf.GetArrayElem(pvPoints, iVertex)));
        }
    }

    // if there is a diffuse component, we need to convert to floating point
    if (m_cfvf.BSpecular() && (m_AttributeWeights.Specular > 0.0f))
    {
        m_rgcolorSpecular = new D3DXCOLOR[m_tmTriMesh.m_cVertices];
        if (m_rgcolorSpecular == NULL)
        {
            hr = E_OUTOFMEMORY;
            return hr;
        }

        for (iVertex = 0; iVertex < m_tmTriMesh.m_cVertices; iVertex++)
        {
            m_rgcolorSpecular[iVertex] = D3DXCOLOR(m_cfvf.ColorGetSpecular(m_cfvf.GetArrayElem(pvPoints, iVertex)));
        }
    }

    // if there are texture coordinates, might need to setup weight array
    if (m_cfvf.CTexCoords() > 0)
    {
        // see if there are any weights for the texture coordinates provided
        bFound = FALSE;
        for (iTexCoord = 0; iTexCoord < m_cfvf.CTexCoords(); iTexCoord++)
        {
            if (m_AttributeWeights.Tex[iTexCoord] > 0.0f)
            {
                bFound = TRUE;
                break;
            }
        }

        // if any weights found for existing texture coords, initialize internal arrays
        if (bFound)
        {
            m_cTexWeights = (m_cfvf.m_cBytesPerVertex - m_cfvf.m_oTex1) / sizeof(float);
            m_rgfTexWeights = new float[m_cTexWeights];
            if (m_rgfTexWeights == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto e_Exit;
            }
            memset(m_rgfTexWeights, 0, sizeof(float) * m_cTexWeights);

            m_cfvf.GetTexCoordSizes(rgdwTexCoordSizes);

            // now for each move tex coord level weights, to per float weights
            pfTexWeightCur = m_rgfTexWeights;
            for (iTexCoord = 0; iTexCoord < m_cfvf.CTexCoords(); iTexCoord++)
            {
                // convert from bytes to floats on individual sizes
                rgdwTexCoordSizes[iTexCoord] /= sizeof(float);

                for (iWeight = 0; iWeight < rgdwTexCoordSizes[iTexCoord]; iWeight++)
                {
                    *pfTexWeightCur = m_AttributeWeights.Tex[iTexCoord];
                    pfTexWeightCur += 1;
                }
            }

            GXASSERT(pfTexWeightCur == (m_rgfTexWeights + m_cTexWeights));
        }
    }

e_Exit:
    return hr;
}

// -------------------------------------------------------------------------------
//  function    ResetHeap
//
//   devnote    Reinitializes the priority heap from the current mesh
//
//   returns    S_OK if successful, else failure code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::ResetHeap()
{
    HRESULT hr = S_OK;
    PBYTE pvPoints = NULL;

    // lock the points now to avoid looking for failures later
    hr = m_tmTriMesh.LockVB(&pvPoints);
    if (FAILED(hr))
        goto e_Exit;

    delete m_pheapCosts;
    m_pheapCosts = NULL;
    delete []m_rgfeiEdges;
    m_rgfeiEdges = NULL;

    hr = CreateHeap(pvPoints);
    if (FAILED(hr))
        goto e_Exit;

e_Exit:
    if (pvPoints != NULL)
    {
        HRESULT hrTest = m_tmTriMesh.UnlockVB();
        GXASSERT(!FAILED(hrTest));
        pvPoints = NULL;
    }

    return hr;
}


// -------------------------------------------------------------------------------
//  function    SetupSimplfication
//
//   devnote    Sets up all information required to start simplification
//                  used after the mesh has been loaded with data
//
//   returns    S_OK if successful, else failure code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::SetupSimplification
    (
    GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED> *ptmSrcMesh, 
    CONST DWORD *rgdwAdjacency,
    CONST LPD3DXATTRIBUTEWEIGHTS pVertexAttributeWeights,
    CONST FLOAT *pVertexWeights
    )
{
    HRESULT hr = S_OK;
    PBYTE pvPoints = NULL;
    UINT iFace;
    UINT iae;
    UINT iPoint;
    UINT iEndFace;
	unsigned int iFP;
    UINT cFaces = ptmSrcMesh->GetNumFaces();
    UINT cVertices = ptmSrcMesh->GetNumVertices();
    CONST DWORD *pdwCurAdjacency;
    D3DXVECTOR3 vCenter;
    DWORD cVerticesBefore;

    // make sure that we are in double precision
	iFP = _controlfp(0,0);
	_controlfp(_PC_53,_MCW_PC );

    hr = CreateEmptyMesh();
    if (FAILED(hr))
        goto e_Exit;

    GXASSERT(ptmSrcMesh->BValid());

    // resize the buffers to copy the mesh into
    hr = m_tmTriMesh.Resize(cFaces, cVertices);
    if (FAILED(hr))
        goto e_Exit;

    // copy the data from the dest mesh locally;
    hr = m_tmTriMesh.CopyMesh(ptmSrcMesh);
    if (FAILED(hr))
        goto e_Exit;

    hr = m_tmTriMesh.LockIB((PBYTE*)&m_tmTriMesh.m_pFaces);
    if (FAILED(hr))
        goto e_Exit;

    //UNDONE UNDONE, if adjacency is changed to always be 32 bit, then 
    //   this is a memcpy
    for (iFace = 0, pdwCurAdjacency = rgdwAdjacency; iFace < cFaces; iFace++, pdwCurAdjacency+=3)
    {
        for (iPoint = 0; iPoint < 3; iPoint++)
        {
            m_tmTriMesh.m_rgpniNeighbors[iFace].m_iNeighbors[iPoint] = (UINT_IDX)pdwCurAdjacency[iPoint];
        }
    }

    // this must happen before defragmenting the wedges, requires adjacency info
    hr = ComputePointReps();
    if (FAILED(hr))
        goto e_Exit;

    // NOTE: this must happen before locking the vertex buffer
    hr = DefragmentWedges();
    if (FAILED(hr))
        goto e_Exit;

    // do after Defragment, so that the wedges can be assigned to materials
    cVerticesBefore = m_tmTriMesh.m_cVertices;
    hr = m_tmTriMesh.OptimizeInternal(D3DXMESHOPT_COMPACT | D3DXMESHOPT_ATTRSORT, NULL, NULL, NULL, NULL, NULL, m_tmTriMesh.m_dwFVF);
    if (FAILED(hr))
        goto e_Exit;

    if (cVerticesBefore < m_tmTriMesh.m_cVertices)
    {
        delete []m_rgbVertexSeen;
        m_rgbVertexSeen = new BYTE[m_tmTriMesh.m_cVertices];
        if (m_rgbVertexSeen == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }

        memset(m_rgbVertexSeen, 0,m_tmTriMesh.m_cVertices);
    }

    // even though we attribute sorted the mesh, it won't be optimal for long.  we want to
    //   maintain the attribute table to track the numbers of triangles left per attribute
    //   but it doesn't reflect the used vs unused parts of the mesh
    m_tmTriMesh.m_dwOptionsInt &= ~D3DXMESHINT_ATTRIBUTETABLE;

    // allocate a duplicate attribute table, to remember what the counts of the various
    //     entries were before simplification
    m_rgaeAttributeTableOrig = new D3DXATTRIBUTERANGE[m_tmTriMesh.m_caeAttributeTable];
    m_rgaeAttributeTableCur = new D3DXATTRIBUTERANGE[m_tmTriMesh.m_caeAttributeTable];
    if ((m_rgaeAttributeTableOrig == NULL) || (m_rgaeAttributeTableCur == NULL))
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }
    memcpy(m_rgaeAttributeTableOrig, m_tmTriMesh.m_rgaeAttributeTable, sizeof(D3DXATTRIBUTERANGE) * m_tmTriMesh.m_caeAttributeTable);
    memcpy(m_rgaeAttributeTableCur, m_tmTriMesh.m_rgaeAttributeTable, sizeof(D3DXATTRIBUTERANGE) * m_tmTriMesh.m_caeAttributeTable);

    // setup the material indices based on the attribute table.
    for (iae = 0; iae < m_tmTriMesh.m_caeAttributeTable; iae++)
    {
        iEndFace = m_tmTriMesh.m_rgaeAttributeTable[iae].FaceStart + (m_tmTriMesh.m_rgaeAttributeTable[iae].FaceCount);
        for (iFace = m_tmTriMesh.m_rgaeAttributeTable[iae].FaceStart; iFace < iEndFace; iFace++)
        {
            m_tmTriMesh.m_rgiMaterialIndex[iFace] = iae;
        }
    }

    hr = GenerateWedgeList();
    if (FAILED(hr))
        goto e_Exit;

    // call after GenerateWedgeList, so that we have the number of vertices
    //   in the mesh, to get a rough idea of the possible number of split records
    hr = AllocateVSplitRecords();
    if (FAILED(hr))
        goto e_Exit;

    // lock the points now to avoid looking for failures later
    hr = m_tmTriMesh.LockVB(&pvPoints);
    if (FAILED(hr))
        goto e_Exit;

    hr = D3DXComputeBoundingSphere(pvPoints, m_tmTriMesh.m_cVertices, m_tmTriMesh.m_dwFVF, &vCenter, &m_fMeshRadiusSq);
    if (FAILED(hr))
        goto e_Exit;
    m_fMeshRadiusSq *= m_fMeshRadiusSq;

    // this must happen after computing the bounding sphere, needs to include MeshRadiusSq
    hr = SetupWeightInfo(pVertexAttributeWeights, pVertexWeights, pvPoints);
    if (FAILED(hr))
        goto e_Exit;

#ifdef VERTEX_QUADRICS
    hr = GenerateInitialQuadrics(pvPoints);
    if (FAILED(hr))
        goto e_Exit;
#endif

    hr = CreateHeap(pvPoints);
    if (FAILED(hr))
        goto e_Exit;

    m_cCurrentFaces = 0;
    for (iFace = 0; iFace < m_tmTriMesh.m_cFaces; iFace++)
    {
        if (m_tmTriMesh.m_pFaces[iFace].m_wIndices[0] == UNUSED)
            continue;

        m_cCurrentFaces += 1;
    }

    m_cCurrentWedges = m_tmTriMesh.m_cVertices;
    m_cMaxLogicalVertices = m_cLogicalVertices;

    m_cMaxVertices = m_cCurrentWedges;
    m_cMaxFaces = m_cCurrentFaces;

    // if this mesh has more faces than allowable in a 16bit PM,
    //   then need to setup a variable to track the point in the simplification
    //   that we go below 2^16 faces to know how many vsplit records to copy in a ClonePM
    if (m_cCurrentFaces < UINT16UNUSED)
    {
        m_cvsMax16BitPos = m_cvsSplitCurFree;
        m_cvsMaxFaces16BitPos = m_cCurrentFaces;
    }
    else
    {
        m_cvsMax16BitPos = UINT32UNUSED;
        m_cvsMaxFaces16BitPos = UINT32UNUSED;
    }

    m_rgbVertexDeleted = new BYTE[m_tmTriMesh.m_cVertices];
    if (m_rgbVertexDeleted == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }
    memset(m_rgbVertexDeleted, 0, sizeof(BYTE) * m_tmTriMesh.m_cVertices);

    GXASSERT(BValid());
e_Exit:
    if (pvPoints != NULL)
    {
        HRESULT hrTest = m_tmTriMesh.UnlockVB();
        GXASSERT(!FAILED(hrTest));
        pvPoints = NULL;
    }

    if (FAILED(hr))
    {
        CreateEmptyMesh();
    }


    if (m_tmTriMesh.m_pFaces != NULL)
    {
        m_tmTriMesh.UnlockIB();
    }

    // make sure that we restore the precision desired
	_controlfp(iFP,_MCW_PC );

    return hr;
}

// -------------------------------------------------------------------------------
//  function    FixupVSplitRecords
//
//   devnote    For each vsplit, check to see if the face it references was removed
//                  in a subsequent edge collapse, if so remap both the iFlclw and
//                  adjust vs_index to match where the face will be generated
//
//   returns    S_OK if successful, else failure code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT 
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::FixupVSplitRecords()
{
    UINT cvs;
    UINT ivs;
    CHalfEdgeVSplit *pvs;
    UINT_IDX iPointOffset;

    // UNDONE - add a flag field to mark fixed up records, so that it is 
    //   possible to run this many times with only the fixups happening if required

    cvs = m_cvsSplitsMax - m_cvsSplitCurFree - 1;
    for (ivs = m_cvsSplitCurFree+1; ivs < m_cvsSplitsMax; ivs++)
    {
        pvs = &m_rgvsSplits[ivs];

        // fixup triangles that are no longer in the base mesh.  
        //   need to remap teh iFlclw to where the triangle will appear
        //   and change the vs_index field to be adjusted to where the points
        //   will be generated by a vsplit
        if (m_rgiFaceIndex[pvs->m_iFlclw] != UNUSED)
        {
            iPointOffset = ((pvs->m_code & CHalfEdgeVSplit::VSINDEX_MASK) >> CHalfEdgeVSplit::VSINDEX_SHIFT);
            iPointOffset = (iPointOffset + m_rgiEdgeAdjustment[pvs->m_iFlclw]) % 3;

            pvs->m_code &= ~CHalfEdgeVSplit::VSINDEX_MASK;
            pvs->m_code |= (iPointOffset) << CHalfEdgeVSplit::VSINDEX_SHIFT;

            pvs->m_iFlclw = m_rgiFaceIndex[pvs->m_iFlclw];

            m_rgbRemappedVSplit[ivs] = true;
        }
    }

    return S_OK;
}

// -------------------------------------------------------------------------------
//  function    RemapVSplitRecords
//
//   devnote    remap all vsplit records that reference faces in the "base" mesh
//                  a vsplit record refernces faces in the "base" mesh only
//                  if m_rgbRemappedVSplit[i] is false
//
//   returns    S_OK if successful, else failure code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT 
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::RemapVSplitRecords
    (
    UINT *rgiFaceRemap
    )
{
    UINT cvs;
    UINT ivs;
    CHalfEdgeVSplit *pvs;

    cvs = m_cvsSplitsMax - m_cvsSplitCurFree - 1;

    for (ivs = m_cvsSplitCurFree+1; ivs < m_cvsSplitsMax; ivs++)
    {
        pvs = &m_rgvsSplits[ivs];

        if (!m_rgbRemappedVSplit[ivs])
        {
            pvs->m_iFlclw = rgiFaceRemap[pvs->m_iFlclw];
        }
    }

    return S_OK;
}

// -------------------------------------------------------------------------------
//  function    RemapInternals
//
//   devnote    remap all arrays that are aligned with the face and vertex arrays
//                  NOTE: this is NOT a GENERIC remap, only handles compact style remaps
//
//   returns    S_OK if successful, else failure code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT 
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::RemapInternals
    (
    UINT *rgiVertRemap, 
    UINT cVerticesPreRemap, 
    UINT *rgiFaceRemap, 
    UINT cFacesPreRemap
    )
{
    UINT iFace;
    UINT iFaceNew;
    UINT iVertex;
    UINT iVertexNew;
    CEdgeInfo<UINT_IDX> *peiEdge;
    UINT iEdge;
    UINT_IDX *pwNeighbors;
    UINT iae;
    UINT iVertexLast;

    for (iFace = 0; iFace < cFacesPreRemap; iFace++)
    {
        iFaceNew = rgiFaceRemap[iFace];
        if ((iFaceNew != UNUSED) && (m_tmTriMesh.m_pFaces[iFaceNew].m_wIndices[0] != UNUSED))
        {
            if (iFaceNew == iFace)
                continue;

            // the face to be blown away should have had its edges freed already
            GXASSERT(m_rgfeiEdges[iFaceNew].m_rgpeiEdges[0] == NULL);
            GXASSERT(m_rgfeiEdges[iFaceNew].m_rgpeiEdges[1] == NULL);
            GXASSERT(m_rgfeiEdges[iFaceNew].m_rgpeiEdges[2] == NULL);

            m_rgfeiEdges[iFaceNew] = m_rgfeiEdges[iFace];
            pwNeighbors = m_tmTriMesh.m_rgpniNeighbors[iFaceNew].m_iNeighbors;
            for (iEdge = 0; iEdge < 3; iEdge++)
            {
                peiEdge = m_rgfeiEdges[iFaceNew].m_rgpeiEdges[iEdge];
                m_rgfeiEdges[iFace].m_rgpeiEdges[iEdge] = NULL;

                peiEdge->m_wFace = iFaceNew;
                peiEdge->m_iEdge = iEdge;
            }

#ifdef VERTEX_QUADRICS
            m_rgqFaceQuadrics[iFaceNew] = m_rgqFaceQuadrics[iFace];
            m_rgvFaceNormals[iFaceNew] = m_rgvFaceNormals[iFace];
#endif
        }
        else
        {
            for (iEdge = 0; iEdge < 3; iEdge++)
            {
                delete m_rgfeiEdges[iFace].m_rgpeiEdges[iEdge];
                m_rgfeiEdges[iFace].m_rgpeiEdges[iEdge] = NULL;
            }
        }
    }

    for (iVertex = 0; iVertex < cVerticesPreRemap; iVertex++)
    {
        iVertexNew = rgiVertRemap[iVertex];
        if ((iVertexNew != UNUSED) && (!m_rgbVertexDeleted[iVertex]))
        {
            m_rgbVertexSeen[iVertexNew] = m_rgbVertexSeen[iVertex];
#ifdef VERTEX_QUADRICS
            m_rgqVertexQuadrics[iVertexNew] = m_rgqVertexQuadrics[iVertex];
#endif
        }
    }

    // rebuild the vertex deleted array from the current attribute table
    memset(m_rgbVertexDeleted, 1, sizeof(BYTE) * m_tmTriMesh.m_cVertices);
    for (iae = 0; iae < m_tmTriMesh.m_caeAttributeTable; iae++)
    {
        iVertexLast = m_rgaeAttributeTableCur[iae].VertexStart + m_rgaeAttributeTableCur[iae].VertexCount;
        for (iVertex = m_rgaeAttributeTableCur[iae].VertexStart; iVertex < iVertexLast; iVertex++)
        {
            m_rgbVertexDeleted[iVertex] = 0;
        }
    }

    return S_OK;
}


// -------------------------------------------------------------------------------
//  function    RemapWedgeList
//
//   devnote    remap all the wedges lists using the given vertex map
//
//   returns    S_OK if successful, else failure code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT 
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::RemapWedgeList
    (
    UINT *rgiVertRemap, 
    UINT_IDX cVerts
    )
{
    UINT iVert;

    // remap all the wedge list pointers in the wedge list
    for (iVert = 0; iVert < cVerts; iVert++)
    {
        m_rgiWedgeList[iVert] = rgiVertRemap[m_rgiWedgeList[iVert]];
    }

    return S_OK;
}

// -------------------------------------------------------------------------------
//  function    CloneMesh
//
//   devnote    Generate a triangle mesh from the current level of the simplification mesh
//
//   returns    S_OK if successful, else failure code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT 
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::CloneMesh
    (
    DWORD dwOptions, 
    CONST DWORD *pDeclaration, 
    LPDIRECT3DDEVICE8 pD3DDevice, 
    DWORD *rgdwAdjacency, 
    DWORD *rgdwVertexRemap,
    LPD3DXMESH* ppCloneMesh
    )
{
    DWORD dwFVF;
    HRESULT hr;

    if (pDeclaration == NULL)
    {
        dwFVF = m_tmTriMesh.m_dwFVF;
    }
    else
    {
        hr = D3DXFVFFromDeclarator(pDeclaration, &dwFVF);
        if (FAILED(hr))
        {
            DPF(0,"CloneMesh: Declaration cannot be converted to FVF");
            return hr;
        }
    }

    return CloneMeshFVF(dwOptions, dwFVF, pD3DDevice, rgdwAdjacency, rgdwVertexRemap, ppCloneMesh);
}

// -------------------------------------------------------------------------------
//  function    CloneMesh
//
//   devnote    Generate a triangle mesh from the current level of the simplification mesh
//
//   returns    S_OK if successful, else failure code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT 
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::CloneMeshFVF
    (
    DWORD dwOptions, 
    DWORD dwFVF, 
    LPDIRECT3DDEVICE8 pD3DDevice, 
    DWORD *rgdwAdjacency,
    DWORD *rgdwVertexRemap,
    LPD3DXMESH* ppCloneMesh
    )
{
    HRESULT hr = S_OK;
    LPD3DXMESH ptmMesh = NULL;
    LPD3DXMESH ptmMeshTemp;
    DWORD iEntry;
    DWORD cEntries;
    UINT_IDX *pwSrc;
    DWORD *pdwDest;
    DWORD *rgdwAdjacencyIn = NULL;
    LPD3DXBUFFER *ppbufVertRemap = NULL;
    LPD3DXBUFFER pbufVertRemap = NULL;

    if ((dwOptions & ~D3DXMESH_VALIDCLONEBITS) != 0)
    {
        DPF(0, "CloneMeshFVF: Invalid mesh option specified");
        hr = D3DERR_INVALIDCALL;
        goto e_Exit;
    }
    if ((dwOptions & D3DXMESH_VB_SHARE) != 0)
    {
        DPF(0, "CloneMeshFVF: D3DXMESH_VB_SHARE is not a valid option for CloneMesh on a simplification mesh");
        hr = D3DERR_INVALIDCALL;
        goto e_Exit;
    }
    if (ppCloneMesh == NULL)
    {
        DPF(0, "CloneMeshFVF: A destination pointer for the new mesh must be specified");
        hr = D3DERR_INVALIDCALL;
        goto e_Exit;
    }
    if (pD3DDevice == NULL)
    {
        DPF(0, "CloneMeshFVF: A destination device for the new mesh must be specified");
        hr = D3DERR_INVALIDCALL;
        goto e_Exit;
    }


    // if output adjacency is desired, compute a form of adjacency convenient for optimization
    if (rgdwAdjacency != NULL)
    {
        rgdwAdjacencyIn = new DWORD[m_tmTriMesh.m_cFaces * 3];
        if (rgdwAdjacencyIn == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }

        pwSrc = m_tmTriMesh.m_rgpniNeighbors[0].m_iNeighbors;
        pdwDest = rgdwAdjacency;

        cEntries = m_tmTriMesh.m_cFaces * 3;
        for (iEntry = 0; iEntry < cEntries; iEntry++)
        {
            if (*pwSrc != UNUSED)
                *pdwDest = (DWORD)*pwSrc;
            else
                *pdwDest = UNUSED32;

            pdwDest += 1;
            pwSrc += 1;
        }
    }

    // if vertex remap desired, set the pbuf pointer so that optimize generates the info
    if (rgdwVertexRemap != NULL)
    {
        ppbufVertRemap = &pbufVertRemap;
    }

    // compact and create a clone at the same time
    hr = m_tmTriMesh.Optimize(D3DXMESHOPT_COMPACT | D3DXMESHOPT_ATTRSORT, 
                                rgdwAdjacencyIn, rgdwAdjacency, NULL, ppbufVertRemap, &ptmMesh);
    if (FAILED(hr))
        goto e_Exit;

    // if any options changed, then we need to do a clone, to convert the compacted mesh
    //   to the right format
    if ((dwOptions != m_tmTriMesh.m_dwOptions) || (dwFVF != m_tmTriMesh.m_dwOptions)
        || (m_tmTriMesh.m_pD3DDevice != pD3DDevice))
    {
        hr = ptmMesh->CloneMeshFVF(dwOptions, dwFVF, pD3DDevice, &ptmMeshTemp);
        if (FAILED(hr))
            goto e_Exit;

        GXRELEASE(ptmMesh);
        ptmMesh = ptmMeshTemp;
    }

    // if the vertex remap is desired, copy out the useful entries from the buffer
    if (rgdwVertexRemap != NULL)
    {
        GXASSERT(pbufVertRemap != NULL);

        memcpy(rgdwVertexRemap, pbufVertRemap->GetBufferPointer(), sizeof(DWORD) * ptmMesh->GetNumVertices());
    }

    *ppCloneMesh = ptmMesh;
    ptmMesh = NULL;

e_Exit:
    GXRELEASE(ptmMesh);
    GXRELEASE(pbufVertRemap);
    delete []rgdwAdjacencyIn;
    return hr;
}

// -------------------------------------------------------------------------------
//  function    Compact
//
//   devnote    Move all faces and vertices left to the front of the 
//                  material group that they are in
//
//   returns    S_OK if successful, else failure code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT 
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::Compact
    (
    UINT *rgiVertRemap, 
    UINT cVertexRemap, 
    UINT *rgiFaceRemap, 
    UINT cFaceRemap
    )
{
    HRESULT hr = S_OK;
    UINT *rgiFaceOffset = NULL;
    UINT *rgiVertexOffset = NULL;
    UINT iVert;
    UINT iae;
    UINT iFace;
    UINT_IDX *pwFace;
    UINT iOffset;
    UINT iEndOffset;

    // fixup the point reps, so that deleted points aren't misunderstood by Mesh.Reorder
    for (iVert = 0; iVert < m_tmTriMesh.m_cVertices; iVert++)
    {
        if (m_rgbVertexDeleted[iVert])
            m_tmTriMesh.m_rgwPointReps[iVert] = iVert;
    }

    // allocate arrays to store the next offset for each material (for both faces and vertices)
    rgiFaceOffset = new UINT[m_tmTriMesh.m_caeAttributeTable];
    rgiVertexOffset = new UINT[m_tmTriMesh.m_caeAttributeTable];
    if ((rgiFaceOffset == NULL) || (rgiVertexOffset == NULL))
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    // load the offset to start each material group at
    for (iae = 0; iae < m_tmTriMesh.m_caeAttributeTable; iae++)
    {
        rgiFaceOffset[iae] = m_rgaeAttributeTableOrig[iae].FaceStart;
        rgiVertexOffset[iae] = m_rgaeAttributeTableOrig[iae].VertexStart;
    }

   // only initialize the vertex array, the face array will be initialized
    //   by the first loop, which calculates where the faces move to
    for (iVert = 0; iVert < m_tmTriMesh.m_cVertices; iVert++)
    {
        rgiVertRemap[iVert] = UNUSED;
    }

    // first calculate how to remap the faces, and mark vertices 
    //   as used
    for (iFace = 0; iFace < m_tmTriMesh.m_cFaces; iFace++)
    {
        pwFace = m_tmTriMesh.m_pFaces[iFace].m_wIndices;

        if (pwFace[0] != UNUSED)
        {
            iae = m_tmTriMesh.m_rgiMaterialIndex[iFace];

            rgiFaceRemap[iFace] = rgiFaceOffset[iae];
            rgiFaceOffset[iae] += 1;

            // assert that only one material is using the vertices of this triangle
            GXASSERT((rgiVertRemap[pwFace[0]] == iae) || (rgiVertRemap[pwFace[0]] == UNUSED));
            GXASSERT((rgiVertRemap[pwFace[1]] == iae) || (rgiVertRemap[pwFace[1]] == UNUSED));
            GXASSERT((rgiVertRemap[pwFace[2]] == iae) || (rgiVertRemap[pwFace[2]] == UNUSED));

            // mark the vertices as in use
            rgiVertRemap[pwFace[0]] = iae;
            rgiVertRemap[pwFace[1]] = iae;
            rgiVertRemap[pwFace[2]] = iae;

        }
        else
        {
            rgiFaceRemap[iFace] = UNUSED;
        }
    }

    // next calculate the new positions of the vertices, and move them there
    for (iVert = 0; iVert < m_tmTriMesh.m_cVertices; iVert++)
    {
        if (rgiVertRemap[iVert] != UNUSED)
        {
            // stored the material for this index above
            iae = rgiVertRemap[iVert];

            rgiVertRemap[iVert] = rgiVertexOffset[iae];
            rgiVertexOffset[iae] += 1;

        }
    }

    // since Reorder doesn't allow "removed" vertices, remap all unused vertices
    //          to unused positions in the array
    iVert = 0;
    for (iae = 0; iae < m_tmTriMesh.m_caeAttributeTable; iae++)
    {       
        iEndOffset = m_rgaeAttributeTableOrig[iae].VertexStart + m_rgaeAttributeTableOrig[iae].VertexCount;
        for (iOffset = rgiVertexOffset[iae]; iOffset < iEndOffset; iOffset++)
        {
            while (rgiVertRemap[iVert] != UNUSED)
            {
                iVert += 1;
            }

            rgiVertRemap[iVert] = iOffset;
        }
    }

    // since Reorder doesn't allow "removed" faces, remap all unused faces
    //          to unused positions in the array
    iFace = 0;
    for (iae = 0; iae < m_tmTriMesh.m_caeAttributeTable; iae++)
    {       
        iEndOffset = m_rgaeAttributeTableOrig[iae].FaceStart + (m_rgaeAttributeTableOrig[iae].FaceCount);
        for (iOffset = rgiFaceOffset[iae]; iOffset < iEndOffset; iOffset++)
        {
            while (rgiFaceRemap[iFace] != UNUSED)
            {
                iFace += 1;
                GXASSERT(iFace < m_tmTriMesh.m_cFaces);
            }

            rgiFaceRemap[iFace] = iOffset;
        }
    }

    hr = m_tmTriMesh.Reorder(rgiVertRemap, cVertexRemap, rgiFaceRemap, cFaceRemap);
    if (FAILED(hr))
        goto e_Exit;

    // for a half edge PM, even UNUSED faces/vertices are "in" the mesh
    //   just not in the attribute table
    m_tmTriMesh.m_cFaces = cFaceRemap;
    m_tmTriMesh.m_cVertices = cVertexRemap;

#ifdef _DEBUG
    UINT cFacesNew;
    UINT cVerticesNew;

    // just check to make sure that the numbers of faces add up
    cFacesNew = 0;
    cVerticesNew = 0;
    for (iae = 0; iae < m_tmTriMesh.m_caeAttributeTable; iae++)
    {
        cFacesNew += (m_rgaeAttributeTableOrig[iae].FaceCount);
        cVerticesNew += m_rgaeAttributeTableOrig[iae].VertexCount;
    }

    GXASSERT(cFacesNew == cFaceRemap);
    GXASSERT(cVerticesNew == cVertexRemap);
#endif

e_Exit:
    delete []rgiFaceOffset;
    delete []rgiVertexOffset;

    return hr;
}

// -------------------------------------------------------------------------------
//  function    ClonePM
//
//   devnote    Generate a progressive mesh from this simplification mesh
//
//   returns    S_OK if successful, else failure code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT 
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::ClonePMesh
    (
    DWORD options, 
    CONST DWORD *pDeclaration, 
    LPDIRECT3DDEVICE8 pD3DDevice, 
    DWORD *rgdwVertexRemap,
    LPD3DXPMESH* ppPMesh
    )
{
    DWORD dwFVF;
    HRESULT hr;

    if (pDeclaration == NULL)
    {
        dwFVF = m_tmTriMesh.m_dwFVF;
    }
    else
    {
        hr = D3DXFVFFromDeclarator(pDeclaration, &dwFVF);
        if (FAILED(hr))
        {
            DPF(0,"CloneMesh: Declaration cannot be converted to FVF");
            return hr;
        }
    }

    return ClonePMeshFVF(options, dwFVF, pD3DDevice, rgdwVertexRemap, ppPMesh);
}

// -------------------------------------------------------------------------------
//  function    ClonePM
//
//   devnote    Generate a progressive mesh from this simplification mesh
//
//   returns    S_OK if successful, else failure code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT 
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::ClonePMeshFVF
    (
    DWORD options, 
    DWORD fvf, 
    LPDIRECT3DDEVICE8 pD3D, 
    DWORD *rgdwVertexRemapOut,
    LPD3DXPMESH* ppPMesh
    )
{
    HRESULT hr = S_OK;

    UINT *rgiVertRemap = NULL;
    DWORD cvsSplitsNew;
    CHalfEdgeVSplit *rgvsSplitsNew = NULL;
    DWORD cVerticesPreRemap;
    DWORD cFacesPreRemap;
    DWORD iFace;
    PBYTE pvPoints = NULL;
    DWORD iae;
    DWORD iEndFace;
    DWORD iOffset;
    DWORD iOffsetMax;
    DWORD iMaterial;
    GXHalfEdgePMesh<UINT_IDX,b16BitIndex,UNUSED> *ptmHalfEdge = NULL;
    DWORD iVertexIndex;
    DWORD iVertex;

    if ((options & ~D3DXMESH_VALIDCLONEBITS) != 0)
    {
        DPF(0, "ClonePMeshFVF: Invalid mesh option specified");
        hr = D3DERR_INVALIDCALL;
        goto e_Exit;
    }
    if ((options & D3DXMESH_VB_SHARE) != 0)
    {
        DPF(0, "ClonePMeshFVF: D3DXMESH_VB_SHARE is not a valid option for CloneMesh on a simplification mesh");
        hr = D3DERR_INVALIDCALL;
        goto e_Exit;
    }
    if (ppPMesh == NULL)
    {
        DPF(0, "ClonePMeshFVF: A destination pointer for the new mesh must be specified");
        hr = D3DERR_INVALIDCALL;
        goto e_Exit;
    }
    if (pD3D == NULL)
    {
        DPF(0, "ClonePMeshFVF: A destination device for the new mesh must be specified");
        hr = D3DERR_INVALIDCALL;
        goto e_Exit;
    }

    rgiVertRemap = new UINT[m_tmTriMesh.m_cVertices];
    if (rgiVertRemap == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    *ppPMesh = NULL;

    hr = FixupVSplitRecords();
    if (FAILED(hr))
        goto e_Exit;

    cVerticesPreRemap = m_tmTriMesh.m_cVertices;
    cFacesPreRemap = m_tmTriMesh.m_cFaces;

    hr = Compact(rgiVertRemap, cVerticesPreRemap, m_rgiFaceIndex, cFacesPreRemap);
    if (FAILED(hr))
        goto e_Exit;

    hr = RemapVSplitRecords(m_rgiFaceIndex);
    if (FAILED(hr))
        goto e_Exit;

    hr = RemapInternals(rgiVertRemap, cVerticesPreRemap, m_rgiFaceIndex, cFacesPreRemap);
    if (FAILED(hr))
        goto e_Exit;

    // reinitialize internal arrays for remaping future vsplit records

    // can't use a memset, since rgiFaceIndex is always 32bit, but UNUSED is
    //   sometimes 16 and sometimes 32 bit (0xffff or 0xffffffff)
    for (iFace = 0; iFace < m_tmTriMesh.m_cFaces; iFace++)
    {
        m_rgiFaceIndex[iFace] = UNUSED;
    }   
    memset(m_rgiEdgeAdjustment, 0xff, sizeof(UINT_IDX) * m_tmTriMesh.m_cFaces);

    // UNDONE currently there are unused vertices in the wedge list, fix so that this is not the case
    //hr = RemapWedgeList(rgiVertRemap, cMaxVertices);
    //if (FAILED(hr))
        //goto e_Exit;

    if (rgdwVertexRemapOut != NULL)
    {
        // reinitialize all inverse pointers to point to UNUSED
        for (iVertexIndex = 0; iVertexIndex < cVerticesPreRemap; iVertexIndex++)
        {
            rgdwVertexRemapOut[iVertexIndex] = UNUSED32;
        }

        // fixup the RemapInverse array by rebuilding it
        for (iVertexIndex = 0; iVertexIndex < cVerticesPreRemap; iVertexIndex++)
        {
            iVertex = rgiVertRemap[iVertexIndex];

            if (iVertex != UNUSED32)
            {
                rgdwVertexRemapOut[iVertex] = iVertexIndex;
            }
        }

        // copy the removed vertices of each material back into the vertex buffer
        //    in the area reserved for vertices of that material
        for (iMaterial = 0; iMaterial < m_tmTriMesh.m_caeAttributeTable; iMaterial++)
        {
            iOffset = m_rgcvHEVertexBufferFree[iMaterial] + 1;
            iOffsetMax = m_rgcvHEVertexBufferMax[iMaterial];

            GXASSERT(iOffset == (m_rgaeAttributeTableCur[iMaterial].VertexStart 
                                    + m_rgaeAttributeTableCur[iMaterial].VertexCount));
#ifdef _DEBUG
            for (iVertexIndex = m_rgaeAttributeTableCur[iMaterial].VertexStart; iVertexIndex < iOffset; iVertexIndex++)
            {
                GXASSERT(rgdwVertexRemapOut[iVertexIndex] != UNUSED32);
            }
#endif

            if (iOffset < iOffsetMax)
            {
                memcpy(rgdwVertexRemapOut + iOffset, m_rgiHEVertexBuffer + iOffset, sizeof(DWORD) * (iOffsetMax - iOffset));
            }
        }
    }


    ptmHalfEdge = new GXHalfEdgePMesh<UINT_IDX,b16BitIndex,UNUSED>(m_tmTriMesh.m_pD3DDevice, m_cfvf.m_dwFVF, m_tmTriMesh.m_dwOptions);
    if (ptmHalfEdge == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    // allocate the object to handle shared data
    ptmHalfEdge->m_pPMSharedData = new CPMSharedData;
    if (ptmHalfEdge->m_pPMSharedData == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    // both faces and vertices are constant and at max for a pm, just the 
    //   counts in the attribute table change
    hr = ptmHalfEdge->m_tmTriMesh.Resize(m_cMaxFaces, m_tmTriMesh.m_cVertices);
    if (FAILED(hr))
        goto e_Exit;

    // use the generic cloning function, to allow for 16/32 bit differences
    hr = ptmHalfEdge->m_tmTriMesh.CopyMesh(&m_tmTriMesh);
    if (FAILED(hr))
        goto e_Exit;

    // need to append the rest of the vertex buffer
    hr = ptmHalfEdge->m_tmTriMesh.LockVB(&pvPoints);
    if (FAILED(hr))
        goto e_Exit;

    // copy the removed vertices of each material back into the vertex buffer
    //    in the area reserved for vertices of that material
    for (iMaterial = 0; iMaterial < m_tmTriMesh.m_caeAttributeTable; iMaterial++)
    {
        iOffset = m_rgcvHEVertexBufferFree[iMaterial] + 1;
        iOffsetMax = m_rgcvHEVertexBufferMax[iMaterial];

        GXASSERT(iOffset == (m_rgaeAttributeTableCur[iMaterial].VertexStart 
                                + m_rgaeAttributeTableCur[iMaterial].VertexCount));

        if (iOffset < iOffsetMax)
        {
            // copy prepared vertices for the rest of the vertex buffer
            memcpy((PBYTE)pvPoints + (iOffset * m_cfvf.m_cBytesPerVertex), 
                (PBYTE)m_pvHEVertexBuffer + (iOffset * m_cfvf.m_cBytesPerVertex),
                 (iOffsetMax - iOffset) * m_cfvf.m_cBytesPerVertex);
        }
    }

    pvPoints = NULL;
    hr = ptmHalfEdge->m_tmTriMesh.UnlockVB();
    if (FAILED(hr))
        goto e_Exit;

    // setup the mispredicted material array
    ptmHalfEdge->m_cMaterialNewMax = m_cMaterialNewMax - (m_cMaterialNewFree + 1);
    ptmHalfEdge->m_cMaterialNewCur = 0;
    ptmHalfEdge->m_rgiMaterialNew = new UINT16[ptmHalfEdge->m_cMaterialNewMax];
    ptmHalfEdge->m_pPMSharedData->m_rgiMaterialNew = ptmHalfEdge->m_rgiMaterialNew;
    if (ptmHalfEdge->m_rgiMaterialNew == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    memcpy(ptmHalfEdge->m_rgiMaterialNew, m_rgiMaterialNew + (m_cMaterialNewFree + 1), 
                            sizeof(UINT16) * ptmHalfEdge->m_cMaterialNewMax);

    // setup the material indices based on the attribute table.
    //  NOTE: use the original table to do this, so that we can intialize it
    for (iae = 0; iae < m_tmTriMesh.m_caeAttributeTable; iae++)
    {
        iEndFace = m_rgaeAttributeTableOrig[iae].FaceStart + (m_rgaeAttributeTableOrig[iae].FaceCount);
        for (iFace = m_rgaeAttributeTableOrig[iae].FaceStart; iFace < iEndFace; iFace++)
        {
            ptmHalfEdge->m_tmTriMesh.m_rgiMaterialIndex[iFace] = (UINT16)iae;
        }
    }

    // create an attribute table for the half edge PM
    ptmHalfEdge->m_tmTriMesh.m_rgaeAttributeTable = new D3DXATTRIBUTERANGE[m_tmTriMesh.m_caeAttributeTable];
    ptmHalfEdge->m_rgaeAttributeTableFull = new D3DXATTRIBUTERANGE[m_tmTriMesh.m_caeAttributeTable];
    if ((ptmHalfEdge->m_tmTriMesh.m_rgaeAttributeTable == NULL) || (ptmHalfEdge->m_rgaeAttributeTableFull == NULL))
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    // copy the current table to the half edge pm
    memcpy(ptmHalfEdge->m_tmTriMesh.m_rgaeAttributeTable, m_rgaeAttributeTableCur, 
                            sizeof(D3DXATTRIBUTERANGE) * m_tmTriMesh.m_caeAttributeTable);
    ptmHalfEdge->m_tmTriMesh.m_caeAttributeTable = m_tmTriMesh.m_caeAttributeTable;

    // copy of the full LOD attribute table
    memcpy(ptmHalfEdge->m_rgaeAttributeTableFull, m_rgaeAttributeTableOrig, 
                            sizeof(D3DXATTRIBUTERANGE) * m_tmTriMesh.m_caeAttributeTable);

    // setup member variables
    ptmHalfEdge->m_cBaseVertices = m_cLogicalVertices;
    ptmHalfEdge->m_cMaxVertices = m_cMaxLogicalVertices;
    ptmHalfEdge->m_cMaxWedges = m_tmTriMesh.m_cVertices;
    ptmHalfEdge->m_cBaseWedges = m_cCurrentWedges;
    ptmHalfEdge->m_cCurrentWedges = m_cCurrentWedges;
    ptmHalfEdge->m_cBaseFaces = m_cCurrentFaces;
    ptmHalfEdge->m_cCurrentFaces = m_cCurrentFaces;
    ptmHalfEdge->m_cMaxFaces = m_cMaxFaces;
    ptmHalfEdge->m_iCurPos = 0;

    // setup array - UNDONE UNDONE need to figure out maximum size
    // GXASSERT(0)
    ptmHalfEdge->m_vsi.cpwLCLWtoRCCWMax = 200;

    // NOTE: must change to work for 16/32 differences, etc.
    ptmHalfEdge->m_vsi.rgpwLCLWtoRCCW = new UINT_IDX*[ptmHalfEdge->m_vsi.cpwLCLWtoRCCWMax];
    if (ptmHalfEdge->m_vsi.rgpwLCLWtoRCCW == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    // allocate the vsplit records
    cvsSplitsNew = m_cvsMax16BitPos - m_cvsSplitCurFree;
    ptmHalfEdge->m_cvsVsplits = cvsSplitsNew;
    ptmHalfEdge->m_rgvsVsplits = new CHalfEdgeVSplit[cvsSplitsNew];
    ptmHalfEdge->m_pPMSharedData->m_rgvsVsplits = ptmHalfEdge->m_rgvsVsplits;
    if (ptmHalfEdge->m_rgvsVsplits == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    // make a copy of the vsplit data
    memcpy(ptmHalfEdge->m_rgvsVsplits, m_rgvsSplits + (m_cvsSplitCurFree + 1),
                            sizeof(CHalfEdgeVSplit) * cvsSplitsNew);

    GXASSERT(ptmHalfEdge->BValid());

    if ((options != m_tmTriMesh.m_dwOptions) || (fvf != m_cfvf.m_dwFVF) || (pD3D != m_tmTriMesh.m_pD3DDevice))
    {
        hr = ptmHalfEdge->ClonePMeshFVF(options, fvf, pD3D, ppPMesh);
        if (FAILED(hr))
        {
            DPF(0, "ID3DXSPMesh::ClonePMeshFVF: ClonePMeshFVF failed");
            goto e_Exit;
        }
        // This is same as delete [] ptmHalfEdge;
        ptmHalfEdge->Release();
    }
    else
    {
        *ppPMesh = ptmHalfEdge;
    }

    // HACK HACK - satisfies later asserts
    delete []m_rgiWedgeList;
    m_rgiWedgeList = NULL;

    hr = GenerateWedgeList();
    if (FAILED(hr))
        goto e_Exit;

    GXASSERT(BValid());

e_Exit:
    if (FAILED(hr))
    {
        delete ptmHalfEdge;
    }

    delete []rgiVertRemap;

    return hr;
}


// -------------------------------------------------------------------------------
//  function    AllocateVSplitRecords
//
//   devnote    Helper function to allocate vsplit record arrays
//
//   returns    S_OK on success, FAILED(hr) on memory allocation failure
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::AllocateVSplitRecords()
{
    HRESULT hr = S_OK;
    UINT iFace;
    UINT iMaterial;

    GXASSERT(m_rgvsSplits == NULL);
    GXASSERT(m_rgiFaceIndex == NULL);
    GXASSERT(m_rgiEdgeAdjustment == NULL);

    m_cvsSplitsMax = m_cLogicalVertices;
    m_cvsSplitCurFree = m_cvsSplitsMax - 1;

    m_rgvsSplits = new CHalfEdgeVSplit[m_cvsSplitsMax];
    if (m_rgvsSplits == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }


    m_rgbRemappedVSplit = new BYTE[m_cvsSplitsMax];
    if (m_rgbRemappedVSplit == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }
    memset(m_rgbRemappedVSplit, 0, sizeof(BYTE) * m_cvsSplitsMax);


    m_rgiFaceIndex = new UINT[m_tmTriMesh.m_cFaces];
    if (m_rgiFaceIndex == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    // can't use a memset, since rgiFaceIndex is always 32bit, but UNUSED is
    //   sometimes 16 and sometimes 32 bit (0xffff or 0xffffffff)
    for (iFace = 0; iFace < m_tmTriMesh.m_cFaces; iFace++)
    {
        m_rgiFaceIndex[iFace] = UNUSED;
    }
    
    m_rgiEdgeAdjustment = new UINT_IDX[m_tmTriMesh.m_cFaces];
    if (m_rgiEdgeAdjustment == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }
    memset(m_rgiEdgeAdjustment, 0xff, sizeof(UINT_IDX) * m_tmTriMesh.m_cFaces);

    m_pvHEVertexBuffer = new BYTE[m_tmTriMesh.m_cVertices * m_cfvf.m_cBytesPerVertex];
    m_rgiHEVertexBuffer = new DWORD[m_tmTriMesh.m_cVertices];
    m_rgcvHEVertexBufferFree = new ULONG[m_tmTriMesh.m_caeAttributeTable];
    m_rgcvHEVertexBufferMax = new ULONG[m_tmTriMesh.m_caeAttributeTable];

    m_cMaterialNewMax = m_tmTriMesh.m_cFaces;
    m_cMaterialNewFree = m_cMaterialNewMax - 1;
    m_rgiMaterialNew = new UINT16[m_cMaterialNewMax];

    if ((m_pvHEVertexBuffer == NULL) || (m_rgiHEVertexBuffer == NULL) || (m_rgiMaterialNew == NULL) 
        || (m_rgcvHEVertexBufferFree == NULL) || (m_rgcvHEVertexBufferMax == NULL))
	{
		hr = E_OUTOFMEMORY;
		goto e_Exit;
	}

    // setup the free indices for each material
    for (iMaterial = 0; iMaterial < m_tmTriMesh.m_caeAttributeTable; iMaterial++)
    {
        m_rgcvHEVertexBufferMax[iMaterial] = 
            m_rgaeAttributeTableOrig[iMaterial].VertexStart +
            m_rgaeAttributeTableOrig[iMaterial].VertexCount;

        m_rgcvHEVertexBufferFree[iMaterial] = m_rgcvHEVertexBufferMax[iMaterial] - 1;
    }

e_Exit:
    return hr;
}

// -------------------------------------------------------------------------------
//  function    GenerateWedgeList
//
//   devnote    Simple helper function to generate circular linked lists of
//                  all wedges that make up a point, or physical instances
//                  of vertices that compose a single logical vertex in the mesh
//                      Generates the info using the vertex representative information
//
//   returns    S_OK on success, FAILED(hr) on failure
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT 
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::GenerateWedgeList()
{
    HRESULT hr = S_OK;
    UINT_IDX cVertices = m_tmTriMesh.m_cVertices;
    UINT_IDX iVertex;
    UINT_IDX wPointRep;

    GXASSERT( m_rgiWedgeList == NULL );
    m_rgiWedgeList = new UINT_IDX[cVertices];
    if (m_rgiWedgeList == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    m_cLogicalVertices = 0;

    // initialize all entries to point to themselves
    for (iVertex = 0; iVertex < cVertices; iVertex++)
    {
        m_rgiWedgeList[iVertex] = iVertex;
    }

    // now go back and link them up using the 
    for (iVertex = 0; iVertex < cVertices; iVertex++)
    {
        // get the representative for this set of wedges
        wPointRep = m_tmTriMesh.WGetPointRep(iVertex);

        if (wPointRep == iVertex)
        {
            m_cLogicalVertices += 1;
        }
        else
        {
            // link the new point in just after the representative vertex
            m_rgiWedgeList[iVertex] = m_rgiWedgeList[wPointRep];
            m_rgiWedgeList[wPointRep] = iVertex;
        }
    }

e_Exit:
    if (FAILED(hr))
    {
        delete m_rgiWedgeList;
    }

    return hr;
}

// -------------------------------------------------------------------------------
//  function    BInArray
//
//   devnote    Helper function for DefragmentWedges. returns true if the given
//                  wedge is in the array of wedges
//
//   returns    S_OK on success, FAILED(hr) on failure
//
template <class UINT_IDX>
bool
BInArray(UINT_IDX rgiWedgesSeen[], UINT cWedges, UINT_IDX wWedge)
{
    UINT iWedge;

    for (iWedge = 0; iWedge < cWedges; iWedge++)
    {
        if (rgiWedgesSeen[iWedge] == wWedge)
            return true;
    }

    return false;
}

// -------------------------------------------------------------------------------
//  function    DefragmentWedges
//
//   devnote    Update all wedges around a vertex to be continguous. 
//
//   returns    S_OK on success, FAILED(hr) on failure
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT 
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::DefragmentWedges()
{
    HRESULT hr = S_OK;
    UINT_IDX iFace;
    UINT_IDX cFaces = m_tmTriMesh.m_cFaces;
    UINT_IDX iPoint;
    UINT_IDX wPointRep;
    UINT_IDX *pwFace;
    UINT_IDX *rgiWedgesSeen = NULL;
    UINT cWedges = 0;
    UINT cWedgesMax = 0;
    UINT_IDX wCurWedge;
    UINT_IDX wPrevWedge;
    UINT_IDX iNextPoint;
    PBYTE pvCurWedge;
    PBYTE pvWedgeBuffer;
    UINT_IDX iCurFace;
    UINT_IDX wNewWedge;
    UINT cbVertexSeen;
	bool bCCWFace;
    DWORD attrCur;
    DWORD attrPrev;
    PBYTE pvPoints;

    // allocate a temporary buffer for new wedges
    pvWedgeBuffer = (PBYTE)_alloca(m_cfvf.m_cBytesPerVertex);
 
    // do after Wedge list generation, so that vertices with one wedge can be skipped
    //  UNDONE change to create wedge list before here
    GXASSERT(m_rgiWedgeList == NULL);

    cbVertexSeen = m_tmTriMesh.m_cVertices;
    m_rgbVertexSeen = new BYTE[cbVertexSeen];
    if (m_rgbVertexSeen == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    memset(m_rgbVertexSeen, 0, m_tmTriMesh.m_cVertices * sizeof(BYTE));

#if 1
    for (iFace = 0; iFace < cFaces; iFace++)
    {
        if (m_tmTriMesh.m_pFaces[iFace].m_wIndices[0] == UNUSED)
            continue;

        for (iPoint = 0; iPoint < 3; iPoint++)
        {
            wCurWedge = m_tmTriMesh.m_pFaces[iFace].m_wIndices[iPoint];
            wPointRep = m_tmTriMesh.WGetPointRep(wCurWedge);
            attrCur = m_tmTriMesh.m_rgiAttributeIds[iFace];

            if ((wPointRep == wCurWedge) && !m_rgbVertexSeen[wPointRep])
            {
                // in case another face points to this vertex, mark as seen to skip extra checks
                GXASSERT(wPointRep < m_tmTriMesh.m_cVertices);
                m_rgbVertexSeen[wPointRep] = true;

                cWedges = 0;
                CFaceListIter<UINT_IDX,b16BitIndex,UNUSED> fli(iFace, wCurWedge, &m_tmTriMesh, x_iAllFaces);

				// try to move to the CCW face
                bCCWFace = fli.MoveToCCWFace();

				// if no CCW face (i.e. complete circle)
				//   then we must find a wedge boundary to start on, to avoid the
				//   problem of starting and ending with the same wedge
				if (!bCCWFace)
				{
					// first look for a boundary starting at the initial face
					while(!fli.BEndOfList())
					{
						iCurFace = fli.GetNextFace();
						iNextPoint = fli.IGetPointIndex();

						// if we found a boundary, then break;
						if (attrCur != m_tmTriMesh.m_rgiAttributeIds[iCurFace])
							break;
					}

					// now that we found a boundary, restart the scan there
					fli.Init(iCurFace, m_tmTriMesh.m_pFaces[iCurFace].m_wIndices[iNextPoint], x_iAllFaces);
				}


                iCurFace = fli.GetNextFace();
                pwFace = m_tmTriMesh.m_pFaces[iCurFace].m_wIndices;

                iNextPoint = fli.IGetPointIndex();
                GXASSERT(iNextPoint < 3);

                wCurWedge = pwFace[iNextPoint];
                attrCur = m_tmTriMesh.m_rgiAttributeIds[iCurFace];

                // now look for the next face that has a different wedge
                //   and on the way update the wedge, if a new one was generated
                while (!fli.BEndOfList())
                {
                    iCurFace = fli.GetNextFace();
                    pwFace = m_tmTriMesh.m_pFaces[iCurFace].m_wIndices;

                    iNextPoint = m_tmTriMesh.FindPoint(pwFace, wPointRep);
                    GXASSERT(iNextPoint < 3);

                    attrPrev = attrCur;
                    attrCur = m_tmTriMesh.m_rgiAttributeIds[iCurFace];

                    wPrevWedge = wCurWedge;
                    wCurWedge = pwFace[iNextPoint];

                    if ((attrPrev != attrCur) && (wCurWedge == wPrevWedge))
                    {
AttrChangeDuringRemap:

                        wCurWedge = pwFace[iNextPoint];

                        hr = m_tmTriMesh.LockVB(&pvPoints);
                        if (FAILED(hr))
                            goto e_Exit;

                        // get the data for the shared wedge to duplicate
                        pvCurWedge = m_cfvf.GetArrayElem(pvPoints, wCurWedge);

                        // save off the index of the new vertex
                        wNewWedge = m_tmTriMesh.m_cVertices;

                        // make a copy on the heap, sine pvCurWedge will not be
                        //   valid after the vertex buffer is locked
                        memcpy(pvWedgeBuffer, pvCurWedge, m_cfvf.m_cBytesPerVertex);

                        // unlock the vertex buffer before trying to add to it
                        m_tmTriMesh.UnlockVB();

                        hr = m_tmTriMesh.AddVertex(pvWedgeBuffer, wPointRep);
                        if (FAILED(hr))
                            goto e_Exit;

                        // update the current point to the new wedge just created
                        pwFace[iNextPoint] = wNewWedge;

                        // update the previous attribute bundle, so that we 
                        //       can break out of the next loop if it changes
                        attrPrev = attrCur;

                        // update all similar wedges to the new wedge
                        while (!fli.BEndOfList())
                        {
                            iCurFace = fli.GetNextFace();
                            pwFace = m_tmTriMesh.m_pFaces[iCurFace].m_wIndices;
                            attrCur = m_tmTriMesh.m_rgiAttributeIds[iCurFace];

                            iNextPoint = m_tmTriMesh.FindPoint(pwFace, wPointRep);
                            GXASSERT(iNextPoint < 3);

                            if (pwFace[iNextPoint] != wCurWedge)
                                break;
                            else if (attrCur != attrPrev)
                                goto AttrChangeDuringRemap;

                            pwFace[iNextPoint] = wNewWedge;
                        }
                    
                    }
                }
            }
        }
    }

#endif
    // if wedges were added to defragment, then change the size of the array to match
    //   this doesn't have to be done in the loop above because it is only referenced
    //   by point representative, which in this case must be less than the original cbVertexSeen
    if (cbVertexSeen < m_tmTriMesh.m_cVertices)
    {
        delete []m_rgbVertexSeen;
        m_rgbVertexSeen = new BYTE[m_tmTriMesh.m_cVertices];
        if (m_rgbVertexSeen == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }

        cbVertexSeen = m_tmTriMesh.m_cVertices;
    }


    memset(m_rgbVertexSeen, 0, m_tmTriMesh.m_cVertices * sizeof(BYTE));

    for (iFace = 0; iFace < cFaces; iFace++)
    {
        if (m_tmTriMesh.m_pFaces[iFace].m_wIndices[0] == UNUSED)
            continue;

        for (iPoint = 0; iPoint < 3; iPoint++)
        {
            wCurWedge = m_tmTriMesh.m_pFaces[iFace].m_wIndices[iPoint];
            wPointRep = m_tmTriMesh.WGetPointRep(wCurWedge);

            // if the vertex has not been seen, and it is not the same as the representative
            //   then check for fragmentation.  if it is the same as the representative and
            //   there are other wedges on the vertex, then other triangles with the vertex
            //   will succeed on this check
            if (/*(wPointRep != wCurWedge) && */!m_rgbVertexSeen[wPointRep])
            {
                // in case another face points to this vertex, mark as seen to skip extra checks
                GXASSERT(wPointRep < m_tmTriMesh.m_cVertices);
                m_rgbVertexSeen[wPointRep] = true;

                cWedges = 0;
                CFaceListIter<UINT_IDX,b16BitIndex,UNUSED> fli(iFace, wCurWedge, &m_tmTriMesh, x_iAllFaces);

				// try to move to the CCW face
                bCCWFace = fli.MoveToCCWFace();

				// if no CCW face (i.e. complete circle)
				//   then we must find a wedge boundary to start on, to avoid the
				//   problem of starting and ending with the same wedge
				if (!bCCWFace)
				{
					// first look for a boundary starting at the initial face
					while(!fli.BEndOfList())
					{
						iCurFace = fli.GetNextFace();
						iNextPoint = fli.IGetPointIndex();

						// if we found a boundary, then break;
						if (wCurWedge != m_tmTriMesh.m_pFaces[iCurFace].m_wIndices[iNextPoint])
							break;
					}

					// now that we found a boundary, restart the scan there
					fli.Init(iCurFace, m_tmTriMesh.m_pFaces[iCurFace].m_wIndices[iNextPoint], x_iAllFaces);
				}


				wCurWedge = UNUSED;
                attrPrev = NULL;
                attrCur = NULL;

                // now look for the next face that has a different wedge
                //   and on the way update the wedge, if a new one was generated
                while (!fli.BEndOfList())
                {
                    iCurFace = fli.GetNextFace();
                    pwFace = m_tmTriMesh.m_pFaces[iCurFace].m_wIndices;

                    iNextPoint = m_tmTriMesh.FindPoint(pwFace, wPointRep);
                    GXASSERT(iNextPoint < 3);

                    attrPrev = attrCur;
                    attrCur = m_tmTriMesh.m_rgiAttributeIds[iCurFace];

                    // if first time thru loop, no attribute change yet
                    if (wCurWedge == UNUSED)
                        attrPrev = attrCur;

                    // if a new wedge, see if in the array
                    if ((pwFace[iNextPoint] != wCurWedge) )//|| (attrPrev != attrCur))
                    {
WedgeChangeDuringRemap:

                        wCurWedge = pwFace[iNextPoint];

                        // if we have seen this wedge before, a new wedge must
                        //  be generated and this run of triangles must be updated
                        //  to point to the new wedge
                        if (BInArray(rgiWedgesSeen, cWedges, wCurWedge) /* || (attrPrev != attrCur)*/)
                        {
                            hr = m_tmTriMesh.LockVB(&pvPoints);
                            if (FAILED(hr))
                                goto e_Exit;

                            // get the data for the shared wedge to duplicate
                            pvCurWedge = m_cfvf.GetArrayElem(pvPoints, wCurWedge);

                            // save off the index of the new vertex
                            wNewWedge = m_tmTriMesh.m_cVertices;

                            // make a copy on the heap, sine pvCurWedge will not be
                            //   valid after the vertex buffer is locked
                            memcpy(pvWedgeBuffer, pvCurWedge, m_cfvf.m_cBytesPerVertex);

                            // unlock the vertex buffer before trying to add to it
                            m_tmTriMesh.UnlockVB();

                            hr = m_tmTriMesh.AddVertex(pvWedgeBuffer, wPointRep);
                            if (FAILED(hr))
                                goto e_Exit;

                            // update the current point to the new wedge just created
                            pwFace[iNextPoint] = wNewWedge;

                            // update the previous attribute bundle, so that we 
                            //       can break out of the next loop if it changes
                            attrPrev = attrCur;

                            // update all similar wedges to the new wedge
                            while (!fli.BEndOfList())
                            {
                                iCurFace = fli.GetNextFace();
                                pwFace = m_tmTriMesh.m_pFaces[iCurFace].m_wIndices;
                                attrCur = m_tmTriMesh.m_rgiAttributeIds[iCurFace];

                                iNextPoint = m_tmTriMesh.FindPoint(pwFace, wPointRep);
                                GXASSERT(iNextPoint < 3);

                                if ((pwFace[iNextPoint] != wCurWedge) )//|| (attrCur != attrPrev))
                                    goto WedgeChangeDuringRemap;

                                pwFace[iNextPoint] = wNewWedge;
                            }
                    
                        }
                        else  // entirely new wedge, just add to array and keep going
                        {
                            // add the current wedge to the array of wedges seen
                            if (!AddToDynamicArray(&rgiWedgesSeen, wCurWedge, &cWedges, &cWedgesMax))
                            {
                                hr = E_OUTOFMEMORY;
                                goto e_Exit;
                            }
                        }
                    }
                }
            }
        }
    }

e_Exit:
    if (m_rgbVertexSeen != NULL)
    {
        // if wedges were added to defragment, then change the size of the array to match
        //   this doesn't have to be done in the loop above because it is only referenced
        //   by point representative, which in this case must be less than the original cbVertexSeen
        if (cbVertexSeen < m_tmTriMesh.m_cVertices)
        {
            delete []m_rgbVertexSeen;
            m_rgbVertexSeen = new BYTE[m_tmTriMesh.m_cVertices];
            if (m_rgbVertexSeen == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto e_Exit;
            }
        }

        memset(m_rgbVertexSeen, 0, m_tmTriMesh.m_cVertices * sizeof(BYTE));
    }

    if (rgiWedgesSeen != NULL)
    {
        delete []rgiWedgesSeen;
    }

    return hr;
}

// -------------------------------------------------------------------------------
//  function    GenerateFaceQEM
//
//   devnote    Generates the QEM for the given face and updates the face normal
//
//   returns    nothing
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
void 
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::GenerateFaceQEM
    (
    UINT_IDX iFace, 
    PBYTE pvPoints, 
    CQuadric &qemFace
    )
{
    float d;
    D3DXVECTOR3 *pvPos0;

    pvPos0 = m_cfvf.PvGetPosition(m_cfvf.GetArrayElem(pvPoints, m_tmTriMesh.m_pFaces[iFace].m_wIndices[0]));

    d = -(D3DXVec3Dot(&m_rgvFaceNormals[iFace], pvPos0));
    qemFace.Generate(m_rgvFaceNormals[iFace].x, m_rgvFaceNormals[iFace].y, m_rgvFaceNormals[iFace].z, d);
}

// -------------------------------------------------------------------------------
//  function    GenerateVertexQuadrics
//
//   devnote    Simple helper function to generate the initial error quadrics
//                  for all vertices in the initial mesh
//
//   returns    S_OK on success, FAILED(hr) on failure
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT 
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::GenerateInitialQuadrics
    (
    PBYTE pvPoints
    )
{
    HRESULT hr = S_OK;
    UINT_IDX cVertices = m_tmTriMesh.m_cVertices;
    UINT_IDX iVertex;
    UINT_IDX cFaces = m_tmTriMesh.m_cFaces;
    UINT_IDX iFace;
    D3DXVECTOR3 vEdge1;
    D3DXVECTOR3 vEdge2;
    CQuadric qemFace;
    UINT_IDX *pwFace;
    UINT_IDX iPoint;
    CQuadric qBorder;
    D3DXVECTOR3 vBorderNormal;
    UINT_IDX iNeighbor;
    UINT_IDX iEdge;
    UINT_IDX iEdge1;

    D3DXVECTOR3 *pvPos0;
    D3DXVECTOR3 *pvPos1;
    D3DXVECTOR3 *pvPos2;
    float fLength;


    GXASSERT( m_rgqVertexQuadrics == NULL );
    m_rgqVertexQuadrics = new CQuadric[cVertices];
    if (m_rgqVertexQuadrics == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    GXASSERT( m_rgqFaceQuadrics == NULL );
    m_rgqFaceQuadrics = new CQuadric[cFaces];
    if (m_rgqFaceQuadrics == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    GXASSERT( m_rgvFaceNormals == NULL );
    m_rgvFaceNormals = new D3DXVECTOR3[cFaces];
    if (m_rgvFaceNormals == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    // initialize all entries to point to themselves
    for (iVertex = 0; iVertex < cVertices; iVertex++)
    {
        m_rgqVertexQuadrics[iVertex].Init();
    }

    // generate the face normals for all the faces
    for (iFace = 0; iFace < cFaces; iFace++)
    {
        pwFace = m_tmTriMesh.m_pFaces[iFace].m_wIndices;

        if (pwFace[0] == UNUSED)
            continue;

        pvPos0 = m_cfvf.PvGetPosition(m_cfvf.GetArrayElem(pvPoints, pwFace[0]));
        pvPos1 = m_cfvf.PvGetPosition(m_cfvf.GetArrayElem(pvPoints, pwFace[1]));
        pvPos2 = m_cfvf.PvGetPosition(m_cfvf.GetArrayElem(pvPoints, pwFace[2]));

        // calculate the two of the edges of the face
        vEdge1 = *pvPos0 - *pvPos1;
        vEdge2 = *pvPos0 - *pvPos2;

        D3DXVec3Cross(&m_rgvFaceNormals[iFace], &vEdge1, &vEdge2);

        fLength = D3DXVec3Length(&m_rgvFaceNormals[iFace]);
        if (fLength > 0.0f)
        {
            // calculate the normal of the face from the two edge vectors
            m_rgvFaceNormals[iFace] /= fLength;
        }
    }

    //   generate the face lists per vertex, used for fast traversals
    //     of all affected faces
    for (iFace = 0; iFace < cFaces; iFace++)
    {
        pwFace = m_tmTriMesh.m_pFaces[iFace].m_wIndices;

        if (pwFace[0] == UNUSED)
            continue;

        // update the face normal and generate the face error quadric
        GenerateFaceQEM(iFace, pvPoints, qemFace);

        m_rgqFaceQuadrics[iFace] = qemFace;

        for (iPoint = 0; iPoint < 3; iPoint++)
        {
            m_rgqVertexQuadrics[pwFace[iPoint]] += qemFace;
        }

        for (iEdge = 0; iEdge < 3; iEdge++)
        {
            iEdge1 = (iEdge + 1) %3;

            iNeighbor = m_tmTriMesh.m_rgpniNeighbors[iFace].m_iNeighbors[iEdge];

            if (BGenerateBorderQem(iFace, iEdge, iNeighbor, pvPoints, qBorder))
            {
                m_rgqVertexQuadrics[pwFace[iEdge]] += qBorder;
                m_rgqVertexQuadrics[pwFace[iEdge1]] += qBorder;
            }
        }

    }

e_Exit:
    if (FAILED(hr))
    {
        delete m_rgqVertexQuadrics;
        delete m_rgvFaceNormals;
    }

    return hr;
}

// -------------------------------------------------------------------------------
//  function    CalculateNormalCost
//
//   devnote    
//
//   returns    S_OK on success, FAILED(hr) on failure
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
float 
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::CalculateNormalCost
    (
    UINT_IDX iVertex1,
    UINT_IDX iVertex2,
    PBYTE pvPoints
    )
{

    return 0;

    float fDot;
    D3DXVECTOR3 *pvNormal1 = m_cfvf.PvGetNormal(m_cfvf.GetArrayElem(pvPoints, iVertex1));
    D3DXVECTOR3 *pvNormal2 = m_cfvf.PvGetNormal(m_cfvf.GetArrayElem(pvPoints, iVertex2));

    // HACK HACK need to deal with no normal case as well
    GXASSERT(m_cfvf.BNormal());

    // need to handle the case with sharp edges, currently designed for smooth normals
    // GXASSERT(0);

    // calculate the dot product and the length
    fDot = D3DXVec3Dot(pvNormal1, pvNormal2);

    // reverse signifigance and make range between 2 and 0 (2 high error, 0 low error)
    fDot = 1 - fDot;

    // scale value into cost units (HACK HACK, just a guesstimate)
    //fDot *= 50;
    fDot *= 0.25;

    return fDot;
}

// -------------------------------------------------------------------------------
//  function    CreateHeap
//
//   devnote    Helper function to create the heap used to prioritize edge
//                  collapses... also generates a structure to track edges
//                  of triangles (stored both in the heap, and in a structure
//                  similar to NeighborInfo in the tri3mesh.
//
//   returns    S_OK on success, FAILED(hr) on failure
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT 
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::CreateHeap
    (
    PBYTE pvPoints
    )
{
    HRESULT hr = S_OK;
    CEdgeInfo<UINT_IDX> *peiInfo;
    UINT_IDX iFace;
    UINT_IDX iEdge;
    UINT_IDX iEdge1;
    UINT_IDX *pwFace;
    UINT_IDX *pwNeighbors;
    SFaceEdgeInfo<UINT_IDX> *pfei;
    UINT_IDX iNeighbor;
    UINT_IDX iNeighborEdge;
    UINT_IDX iVertex1;
    UINT_IDX iVertex2;
    PBYTE pvPoint;
    D3DXVECTOR3 *pvPos1;
    D3DXVECTOR3 *pvPos2;
    CQuadric qTemp;
    float fCost;
    float fNormalCost;
    UINT_IDX wHead;
    UINT_IDX wCur;

    // need to generate vertex quadrics before calling this function
#ifdef VERTEX_QUADRICS
    GXASSERT(m_rgqVertexQuadrics != NULL);
#endif

    GXASSERT( m_pheapCosts == NULL );
    m_pheapCosts = new CSimplificationHeap<UINT_IDX>();
    if (m_pheapCosts == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    hr = m_pheapCosts->Init(m_tmTriMesh.m_cFaces * 3);
    if (FAILED(hr))
        goto e_Exit;


    GXASSERT( m_rgfeiEdges == NULL );
    m_rgfeiEdges = new SFaceEdgeInfo<UINT_IDX>[m_tmTriMesh.m_cFaces];
    if (m_rgfeiEdges == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }
    memset(m_rgfeiEdges, 0, sizeof(SFaceEdgeInfo<UINT_IDX>) * m_tmTriMesh.m_cFaces);

#ifndef VERTEX_QUADRICS
    for(iFace = 0; iFace < m_tmTriMesh.m_cFaces; ++iFace) 
    {
        pwFace = m_tmTriMesh.m_pFaces[iFace].m_wIndices;
        pwNeighbors = m_tmTriMesh.m_rgpniNeighbors[iFace].m_iNeighbors;
        pfei = &m_rgfeiEdges[iFace];

        if (pwFace[0] == UNUSED)
            continue;

        for(iEdge = 0; iEdge < 3; ++iEdge) 
        {
            GXASSERT (pfei->m_rgpeiEdges[iEdge] == NULL);

            iVertex1 = pwFace[iEdge];

            pvPoint = m_cfvf.GetArrayElem(pvPoints, iVertex1);
            pvPos1 = m_cfvf.PvGetPosition(pvPoint);

            peiInfo = new CEdgeInfo<UINT_IDX>(iEdge, iFace, 0.0f, *pvPos1);
            if (peiInfo == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto e_Exit;
            }
            // set the edge of the triangle to point at the edge data structure
            m_rgfeiEdges[iFace].m_rgpeiEdges[iEdge] = peiInfo;

            // now actually calculate the error for the edge
            CalcEdgeQEMS_Plane(iFace, iEdge, pvPoints);

            // now add to the heap
            hr = m_pheapCosts->Add(peiInfo);
            if (FAILED(hr))
                goto e_Exit;
        }
    }
#else
    for(iFace = 0; iFace < m_tmTriMesh.m_cFaces; ++iFace) 
    {
        pwFace = m_tmTriMesh.m_pFaces[iFace].m_wIndices;
        pwNeighbors = m_tmTriMesh.m_rgpniNeighbors[iFace].m_iNeighbors;
        pfei = &m_rgfeiEdges[iFace];

        if (pwFace[0] == UNUSED)
            continue;

        for(iEdge = 0; iEdge < 3; ++iEdge) 
        {
            if(pfei->m_rgpeiEdges[iEdge] == NULL) 
            {
                iEdge1 = (iEdge + 1) % 3;

                iNeighbor = pwNeighbors[iEdge];
                iVertex1 = pwFace[iEdge];
                iVertex2 = pwFace[iEdge1];


                // calculate the error quadric for the edge from
                //   all the wedges in the two vertices that form the edge
                qTemp.Init();

                wHead = iVertex1;
                wCur = wHead;
                do
                {
                    qTemp += m_rgqVertexQuadrics[wCur];

                    // go to next wedge in the vertex
                    wCur = m_rgiWedgeList[wCur];
                } while (wCur != wHead);

                wHead = iVertex2;
                wCur = wHead;
                do
                {
                    qTemp += m_rgqVertexQuadrics[wCur];

                    // go to next wedge in the vertex
                    wCur = m_rgiWedgeList[wCur];
                } while (wCur != wHead);


                pvPoint = m_cfvf.GetArrayElem(pvPoints, iVertex1);
                pvPos1 = m_cfvf.PvGetPosition(pvPoint);

                // create an edge to remove pvPos2
                fCost = qTemp.CalculateCost(*pvPos1);
                fNormalCost = CalculateNormalCost(iVertex1, iVertex2, pvPoints);

                fCost += fNormalCost;
                peiInfo = new CEdgeInfo<UINT_IDX>(iEdge, iFace, fCost, *pvPos1);
                if (peiInfo == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto e_Exit;
                }

                hr = m_pheapCosts->Add(peiInfo);
                if (FAILED(hr))
                    goto e_Exit;

                // set the edge of the triangle to point at the edge data structure
                pfei->m_rgpeiEdges[iEdge] = peiInfo;

                // if there is a neighbor, create an edge to remove the other vertex
                if(iNeighbor != UNUSED)
                {
                    iNeighborEdge = FindEdge(m_tmTriMesh.m_rgpniNeighbors[iNeighbor].m_iNeighbors, iFace);
                    GXASSERT(iNeighborEdge < 3);

                    pvPoint = m_cfvf.GetArrayElem(pvPoints, iVertex2);
                    pvPos2 = m_cfvf.PvGetPosition(pvPoint);

                    fCost = qTemp.CalculateCost(*pvPos2);

                    fCost += fNormalCost;
                    peiInfo = new CEdgeInfo<UINT_IDX>(iNeighborEdge, iNeighbor, fCost, *pvPos2);
                    if (peiInfo == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                        goto e_Exit;
                    }

                    hr = m_pheapCosts->Add(peiInfo);
                    if (FAILED(hr))
                        goto e_Exit;

                    // set the edge of the triangle to point at the edge data structure
                    m_rgfeiEdges[iNeighbor].m_rgpeiEdges[iNeighborEdge] = peiInfo;

                }
            }
        }
    }
#endif

e_Exit:
    return hr;
}

// -------------------------------------------------------------------------------
//  function    RecalcEdgeQEMS_GH
//
//   devnote    Recalculate the costs/split positions of edges affected by a collapse
//                  uses the Garland and Heckbert form of QEMs formed from QEM of wedges
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
void 
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::RecalcEdgeQEMS_GH
    (
    UINT_IDX iPoint1, 
    UINT_IDX iPoint2, 
    UINT_IDX iFacePresent, 
    UINT_IDX iWedgePresent, 
    D3DXVECTOR3 &vPosNew, 
    PBYTE pvPoints
    )
{
    CQuadric qemNew;
    UINT_IDX iFace;
    UINT_IDX iEdge;
    UINT_IDX wHead;
    UINT_IDX wCur;
    UINT_IDX iVertex;
    float fNormalCost;

    //qemNew = m_rgqVertexQuadrics[iPoint1];
    //qemNew += m_rgqVertexQuadrics[iPoint2];

    qemNew.Init();

    wHead = m_tmTriMesh.WGetPointRep(iPoint1);
    wCur = wHead;
    do
    {
        qemNew += m_rgqVertexQuadrics[wCur];
        //m_rgqVertexQuadrics[wCur] = qemNew;

        // go to next wedge in the vertex
        wCur = m_rgiWedgeList[wCur];
    } while (wCur != wHead);



    CFaceListIter<UINT_IDX,b16BitIndex,UNUSED> fli(iFacePresent, iWedgePresent, &m_tmTriMesh, x_iAllFaces);
    D3DXVECTOR3 vTempPosNew;
    UINT_IDX iVertex1;
    UINT_IDX iVertex2;
    CEdgeInfo<UINT_IDX> *peiToUpdate1;
    CEdgeInfo<UINT_IDX> *peiToUpdate2;
    CQuadric qemTemp;
    UINT_IDX iNeighbor;
    UINT_IDX iNeighborEdge;
    float dCost;
    while (!fli.BEndOfList())
    {
        fli.GetNextEdgeFace(iEdge, iFace); 

        peiToUpdate1 = m_rgfeiEdges[iFace].m_rgpeiEdges[iEdge];

        // UNDONE not optimal!  could know the neighbor as part of the walk
        iNeighbor = m_tmTriMesh.m_rgpniNeighbors[iFace].m_iNeighbors[iEdge];
        if (iNeighbor != UNUSED)
        {
            iNeighborEdge = FindEdge(m_tmTriMesh.m_rgpniNeighbors[iNeighbor].m_iNeighbors, iFace);
            GXASSERT(iNeighborEdge < 3);

            peiToUpdate2 = m_rgfeiEdges[iNeighbor].m_rgpeiEdges[iNeighborEdge];
        }
        else
        {
            peiToUpdate2 = NULL;
        }

        iVertex1 = m_tmTriMesh.m_pFaces[iFace].m_wIndices[iEdge];
        iVertex2 = m_tmTriMesh.m_pFaces[iFace].m_wIndices[(iEdge+1)%3];

        iVertex = m_tmTriMesh.m_pFaces[iFace].m_wIndices[(fli.IGetPointIndex()+1)%3];
        GXASSERT(m_tmTriMesh.BEqualPoints(iPoint1, m_tmTriMesh.m_pFaces[iFace].m_wIndices[fli.IGetPointIndex()]));

        wHead = m_tmTriMesh.WGetPointRep(iVertex);
        wCur = wHead;
        qemTemp = qemNew;
        do
        {
            qemTemp += m_rgqVertexQuadrics[wCur];

            // go to next wedge in the vertex
            wCur = m_rgiWedgeList[wCur];
        } while (wCur != wHead);

        fNormalCost = CalculateNormalCost(iPoint1, iPoint2, pvPoints);

        D3DXVECTOR3 *pvPos1 = m_cfvf.PvGetPosition(m_cfvf.GetArrayElem(pvPoints, iVertex1));
        D3DXVECTOR3 *pvPos2 = m_cfvf.PvGetPosition(m_cfvf.GetArrayElem(pvPoints, iVertex2));

        //peiToUpdate1->m_vPosNew = *pvPos1;
        peiToUpdate1->m_cost = fNormalCost + qemTemp.CalculateCost(*pvPos1);
        m_pheapCosts->Update(peiToUpdate1);


        if (peiToUpdate2)
        {
            //peiToUpdate2->m_vPosNew = *pvPos2;
            peiToUpdate2->m_cost = fNormalCost + qemTemp.CalculateCost(*pvPos2);
            m_pheapCosts->Update(peiToUpdate2);
        }
    }
}

// -------------------------------------------------------------------------------
//  function    GenerateBorderQem
//
//   devnote    Calculate the QEM for a given border
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
bool 
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::BGenerateBorderQem
    (
    UINT_IDX iFace, 
    UINT_IDX iEdge, 
    UINT_IDX iNeighbor, 
    PBYTE pvPoints, 
    CQuadric &qemBorder
    )
{
    UINT_IDX *pwFace;
    D3DXVECTOR3 *pvPos0;
    D3DXVECTOR3 *pvPos1;
    D3DXVECTOR3 vEdge1;
    D3DXVECTOR3 vEdge2;
    D3DXVECTOR3 vBorderNormal;
    float d;
    UINT_IDX iEdge1;
    UINT_IDX iNeighborEdge;
    UINT_IDX iWedgeF1;
    UINT_IDX iWedgeF2;
    UINT_IDX iWedgeN1;
    UINT_IDX iWedgeN2;
    float fLength;

    iEdge1 = (iEdge + 1) % 3;
    pwFace = m_tmTriMesh.m_pFaces[iFace].m_wIndices;

    if (iNeighbor == UNUSED)
    {
        pvPos0 = m_cfvf.PvGetPosition(m_cfvf.GetArrayElem(pvPoints, pwFace[iEdge]));
        pvPos1 = m_cfvf.PvGetPosition(m_cfvf.GetArrayElem(pvPoints, pwFace[iEdge1]));

        // calculate the two of the edges of the face
        vEdge1 = *pvPos0 - *pvPos1;

        // calculate the normal of the face from the two edge vectors
        D3DXVec3Cross(&vBorderNormal, &vEdge1, &m_rgvFaceNormals[iFace]);

        fLength = D3DXVec3Length(&vBorderNormal);
        if (fLength > 0.0f)
        {
            vBorderNormal /= fLength;
        }

        d = -(D3DXVec3Dot(&vBorderNormal, pvPos0));
        qemBorder.Generate(vBorderNormal.x, vBorderNormal.y, vBorderNormal.z, d);

        qemBorder += qemBorder;
        return true;
    }
    else
    {
        iNeighborEdge = FindEdge(m_tmTriMesh.m_rgpniNeighbors[iNeighbor].m_iNeighbors, iFace);
        GXASSERT(iNeighborEdge < 3);

        iWedgeF1 = pwFace[iEdge];
        iWedgeF2 = pwFace[iEdge1];
        iWedgeN1 = m_tmTriMesh.m_pFaces[iNeighbor].m_wIndices[(iNeighborEdge+1) % 3];
        iWedgeN2 = m_tmTriMesh.m_pFaces[iNeighbor].m_wIndices[iNeighborEdge];

        // if the wedges are different, assume a border
            // if the materials are different also assume a border
        if ((iWedgeF1 != iWedgeN1) || (iWedgeF2 != iWedgeN2)
                )//|| (m_tmTriMesh.m_rgiAttributeIds[iNeighbor] != m_tmTriMesh.m_rgiAttributeIds[iFace]))
        {
            pvPos0 = m_cfvf.PvGetPosition(m_cfvf.GetArrayElem(pvPoints, pwFace[iEdge]));
            pvPos1 = m_cfvf.PvGetPosition(m_cfvf.GetArrayElem(pvPoints, pwFace[MOD3(iEdge+1)]));

            vEdge1 = *pvPos0 - *pvPos1;
            vEdge2 = m_rgvFaceNormals[iFace] + m_rgvFaceNormals[iNeighbor];

            D3DXVec3Cross(&vBorderNormal, &vEdge2, &vEdge1);
                
            fLength = D3DXVec3Length(&vBorderNormal);
            if (fLength > 0.0f)
            {
                vBorderNormal /= fLength;
            }
            else  // avoid divide by zero
            {
                vBorderNormal = m_rgvFaceNormals[iFace];
            }

            d = -(D3DXVec3Dot(&vBorderNormal, pvPos0));
            qemBorder.Generate(vBorderNormal.x, vBorderNormal.y, vBorderNormal.z, d);

            qemBorder += qemBorder;
        
            return true;
        }
        else  // no border, return false
        {
            GXASSERT(m_tmTriMesh.m_rgiAttributeIds[iNeighbor] == m_tmTriMesh.m_rgiAttributeIds[iFace]);
            return false;
        }
    }
    
//    qemBorder += qemBorder;
}

// -------------------------------------------------------------------------------
//  function    GenerateVertexQEM_MemoryLess
//
//   devnote    Calculate the QEM for a vertex in the memory less method
//                  adds up the qems for all faces that contain the point, and
//                  adds in the border qems if neccessary
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
void
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::GenerateVertexQEM_MemoryLess
    (
    UINT_IDX iFace, 
    UINT_IDX iVertex, 
    UINT_IDX iPoint, 
    PBYTE pvPoints, 
    CQuadric &qemTemp
    )
{
    UINT_IDX *pwNeighbors;
    CQuadric qemBorder;

    qemTemp.Init();

    CFaceListIter<UINT_IDX,b16BitIndex,UNUSED> fli(iFace, iVertex, &m_tmTriMesh, x_iAllFaces);
    while (!fli.BEndOfList())
    {
        iFace = fli.GetNextFace();

        qemTemp += m_rgqFaceQuadrics[iFace];
    }

    // now calculate the border qems

    pwNeighbors = m_tmTriMesh.m_rgpniNeighbors[iFace].m_iNeighbors;
    if (BGenerateBorderQem(iFace, iPoint, pwNeighbors[iPoint], pvPoints, qemBorder))
    {
        qemTemp += qemBorder;
    }

    if (BGenerateBorderQem(iFace, iPoint, pwNeighbors[(iPoint+2) %3], pvPoints, qemBorder))
    {
        qemTemp += qemBorder;
    }
}

// -------------------------------------------------------------------------------
//  function    RecalcEdgeQEMS_MemoryLess
//
//   devnote    Recalculate the costs/split positions of edges affected by a collapse
//                  uses the Garland and Heckbert form of QEMs formed from QEM of wedges
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
void 
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::RecalcEdgeQEMS_MemoryLess
    (
    UINT_IDX iPoint1, 
    UINT_IDX iPoint2, 
    UINT_IDX iFacePresent, 
    D3DXVECTOR3 &vPosNew, 
    PBYTE pvPoints
    )
{
    UINT_IDX iFace;
    CEdgeInfo<UINT_IDX> *peiInfo;
    CQuadric qemVertex1;
    CQuadric qemTemp;
    float dCost;
    UINT_IDX *pwFace;
    UINT_IDX iPoint;
    UINT_IDX iVertex;
    UINT_IDX iEdge;
    D3DXVECTOR3 vTempPosNew;

    qemVertex1.Init();

    // first update all the affected face normals and QEMs
    CFaceListIter<UINT_IDX,b16BitIndex,UNUSED> fli(iFacePresent, iPoint1, &m_tmTriMesh, x_iAllFaces);
    while (!fli.BEndOfList())
    {
        iFace = fli.GetNextFace();

        GenerateFaceQEM(iFace, pvPoints, m_rgqFaceQuadrics[iFace]);

        qemVertex1 += m_rgqFaceQuadrics[iFace];
    }

    fli.Init(iFacePresent, iPoint1, x_iAllFaces);
    while (!fli.BEndOfList())
    {
        fli.GetNextEdgeFace(iEdge, iFace);

        pwFace = m_tmTriMesh.m_pFaces[iFace].m_wIndices;
        peiInfo = m_rgfeiEdges[iFace].m_rgpeiEdges[iEdge];


        // find the other point on the edge
        if (m_tmTriMesh.BEqualPoints(iPoint1, pwFace[iEdge]))
        {
            iPoint = (iEdge+1) %3;
            iVertex = pwFace[iPoint];
        }
        else
        {
            GXASSERT(m_tmTriMesh.BEqualPoints(iPoint1, pwFace[(iEdge+1)%3]));

            iPoint = iEdge;
            iVertex = pwFace[iPoint];
        }

        GenerateVertexQEM_MemoryLess(iFace, iVertex, iPoint, pvPoints, qemTemp);

        qemTemp += qemVertex1;

        qemTemp.CalculatePosition(vTempPosNew, vPosNew);
        dCost = qemTemp.CalculateCost(vTempPosNew);
    
        peiInfo->m_cost = dCost;
        //peiInfo->m_vPosNew = vTempPosNew;

        m_pheapCosts->Update(peiInfo);
    }
}

// -------------------------------------------------------------------------------
//  function    GenerateBorderQem
//
//   devnote    Calculate the QEM for a given border
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
double 
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::DGenerateBorderError
    (
    UINT_IDX iFace, 
    UINT_IDX iEdge, 
    D3DXVECTOR3 *pvPosNew, 
    PBYTE pvPoints
    )
{
    UINT_IDX *pwFace;
    D3DXVECTOR3 *pvPos0;
    D3DXVECTOR3 *pvPos1;
    UINT_IDX iEdge1;
    UINT_IDX iNeighborEdge;
    UINT_IDX iWedgeF1;
    UINT_IDX iWedgeF2;
    UINT_IDX iWedgeN1;
    UINT_IDX iWedgeN2;
    float fLength;
    BOOL bBorder = FALSE;
    D3DXVECTOR3 vOut;
    D3DXVECTOR3 vTemp;
    D3DXVECTOR3 vDir;
    UINT_IDX iNeighbor;
    float fEdgeLenSq;
    float fDot;

    iEdge1 = (iEdge + 1) % 3;
    pwFace = m_tmTriMesh.m_pFaces[iFace].m_wIndices;

    iNeighbor = m_tmTriMesh.m_rgpniNeighbors[iFace].m_iNeighbors[iEdge];
    if (iNeighbor == UNUSED)
    {
        bBorder = TRUE;
    }
    else
    {
        iNeighborEdge = FindEdge(m_tmTriMesh.m_rgpniNeighbors[iNeighbor].m_iNeighbors, iFace);
        GXASSERT(iNeighborEdge < 3);

        iWedgeF1 = pwFace[iEdge];
        iWedgeF2 = pwFace[iEdge1];
        iWedgeN1 = m_tmTriMesh.m_pFaces[iNeighbor].m_wIndices[(iNeighborEdge+1) % 3];
        iWedgeN2 = m_tmTriMesh.m_pFaces[iNeighbor].m_wIndices[iNeighborEdge];

        // if the wedges are different, assume a border
            // if the materials are different also assume a border
        if ((iWedgeF1 != iWedgeN1) || (iWedgeF2 != iWedgeN2))
        {
            bBorder = TRUE;
        }
    }

    if (bBorder)
    {
        pvPos0 = m_cfvf.PvGetPosition(m_cfvf.GetArrayElem(pvPoints, pwFace[iEdge]));
        pvPos1 = m_cfvf.PvGetPosition(m_cfvf.GetArrayElem(pvPoints, pwFace[iEdge1]));

        // calculate the two of the edges of the face
        vDir = *pvPos0 - *pvPos1;
        fEdgeLenSq = D3DXVec3LengthSq(&vDir);

        //  d = mag( p - (A+at))
        //    = mag  (  (p-A) - a ( (p-A) dot a) / (a dot a)) )

        vTemp = *pvPosNew;
        vTemp -= *pvPos0;

        // avoid a divide by zero
        fDot = D3DXVec3Dot(&vDir, &vDir);
        if (fDot <= 1.0e-6f)
            return 0.0f;

        vDir *= D3DXVec3Dot(&vTemp, &vDir) / fDot;
        vOut = vTemp;
        vOut -= vDir;

        // return the length from the newpoint to the border
        return D3DXVec3LengthSq(&vOut) * fEdgeLenSq;
    }
    else
    {
        return 0.0f;
    }
    
}

void IntersectTriUnbounded 
(
    D3DXVECTOR3 *pv0,
    D3DXVECTOR3 *pv1,
    D3DXVECTOR3 *pv2,
    D3DXVECTOR3 *pfRayPos,            // ray origin
    D3DXVECTOR3 *pfRayDir,            // ray direction
    float *pfU,                       // Barycentric Hit Coordinates
    float *pfV,                       // Barycentric Hit Coordinates
    float *pfDist)                    // Ray-Intersection Parameter Distance
{
    D3DXVECTOR3 e1 (pv1->x - pv0->x, pv1->y - pv0->y, pv1->z - pv0->z);
    D3DXVECTOR3 e2 (pv2->x - pv0->x, pv2->y - pv0->y, pv2->z - pv0->z);
    D3DXVECTOR3 r;
    double a;
    double f;
    D3DXVECTOR3 s;
    D3DXVECTOR3 q;
    double u;
    double v;
    double t;

    D3DXVec3Cross(&r, pfRayDir, &e2);

    a = D3DXVec3Dot (&e1, &r);


    if (a > 0)
    {
        s = D3DXVECTOR3(pfRayPos->x - pv0->x, pfRayPos->y - pv0->y, pfRayPos->z - pv0->z);
    }
    else if (a < 0)
    {
        s = D3DXVECTOR3(pv0->x - pfRayPos->x, pv0->y - pfRayPos->y, pv0->z - pfRayPos->z);
        a = -a;
    }
    else
    {
        *pfDist = 0;
        return;
        //GXASSERT(0);
    }

    f = 1 / a;

    u = D3DXVec3Dot(&s, &r);
 
    D3DXVec3Cross(&q, &s, &e1);

    v = D3DXVec3Dot(pfRayDir, &q);

    t = D3DXVec3Dot(&e2, &q);

    t = t * f;
    u = u * f;
    v = v * f;

    *pfU = (float)u;
    *pfV = (float)v;
    *pfDist = (float)t;
}

// -------------------------------------------------------------------------------
//  function    CalcEdgeQEMS_Plane
//
//   devnote    Recalculate the costs/split positions of edges affected by a collapse
//                  uses the Garland and Heckbert form of QEMs formed from QEM of wedges
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
void 
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::CalcEdgeQEMS_Plane
    (
    UINT_IDX iFace, 
    UINT_IDX iEdge, 
    PBYTE pvPoints
    )
{
    CEdgeInfo<UINT_IDX> *peiInfo;
    UINT_IDX iNeighbor;
    UINT_IDX iWedge1;
    UINT_IDX iWedge2;
    double dError;
    double dFaceError;
    double dErrorTotal;
    double dBorderError;
    float fFaceArea;
    D3DXPLANE planeFace;
    D3DXVECTOR3 *pvPosWedge1;
    D3DXVECTOR3 *pvNormalWedge1;
    UINT_IDX iCurFace;
    UINT_IDX *pwCurFace;
    float fU;
    float fV;
    float fDist;
    D3DXVECTOR3 vInterp;
    D3DXVECTOR3 vDiff;
    D3DXVECTOR3 vNormal;
	float *pfTexCur0;
	float *pfTexCur1;
	float *pfTexCur2;
    float *pfTexWedge1;
    float fTexCur;
    float fDiff;
    DWORD iTexWeight;

    // first get the edge info to update
    peiInfo = m_rgfeiEdges[iFace].m_rgpeiEdges[iEdge];
    GXASSERT(peiInfo != NULL);

    iNeighbor = m_tmTriMesh.m_rgpniNeighbors[iFace].m_iNeighbors[iEdge];
    iWedge1 = m_tmTriMesh.m_pFaces[iFace].m_wIndices[iEdge];  // point to collapse to
    iWedge2 = m_tmTriMesh.m_pFaces[iFace].m_wIndices[(iEdge+1)%3];  // point to remove

    pvPosWedge1 = m_cfvf.PvGetPosition(m_cfvf.GetArrayElem(pvPoints, iWedge1));
    if (m_cfvf.BNormal())
        pvNormalWedge1 = m_cfvf.PvGetNormal(m_cfvf.GetArrayElem(pvPoints, iWedge1));
    else
        pvNormalWedge1 = NULL;

    // go to edge that will change to compute errors
    CFaceListIter<UINT_IDX,b16BitIndex,UNUSED> fli(iFace, iWedge2, &m_tmTriMesh, x_iClockwise);
    dErrorTotal = 0.0f;
    while (!fli.BEndOfList())
    {
        iCurFace = fli.GetNextFace(); 

        // don't count the face we are costing to remove into the collapse cost (should be zero anyhow, but...)
        if (iCurFace == iFace)
            continue;

        // NOTE: iNeighbor might be UNUSED, but then we will just hit the end of list which is what we want
        if (iCurFace == iNeighbor)
            break;

        pwCurFace = m_tmTriMesh.m_pFaces[iCurFace].m_wIndices;

        D3DXPlaneFromPoints(&planeFace, 
            m_cfvf.PvGetPosition(m_cfvf.GetArrayElem(pvPoints, pwCurFace[0])),
            m_cfvf.PvGetPosition(m_cfvf.GetArrayElem(pvPoints, pwCurFace[1])),
            m_cfvf.PvGetPosition(m_cfvf.GetArrayElem(pvPoints, pwCurFace[2])));

        IntersectTriUnbounded(
            m_cfvf.PvGetPosition(m_cfvf.GetArrayElem(pvPoints, pwCurFace[0])),
            m_cfvf.PvGetPosition(m_cfvf.GetArrayElem(pvPoints, pwCurFace[1])),
            m_cfvf.PvGetPosition(m_cfvf.GetArrayElem(pvPoints, pwCurFace[2])),
            pvPosWedge1,
            (D3DXVECTOR3*)&planeFace,
            &fU, &fV, &fDist);


        D3DXVec3Cross(&vNormal, 
            m_cfvf.PvGetPosition(m_cfvf.GetArrayElem(pvPoints, pwCurFace[0])),
            m_cfvf.PvGetPosition(m_cfvf.GetArrayElem(pvPoints, pwCurFace[1])));

        fFaceArea = D3DXVec3Length(&vNormal) / 2;

#if 0 //def DEBUG
        dFaceError = D3DXPlaneDotCoord(&planeFace, pvPosWedge1);
        double dTest = fabs((double)fabs(fDist) - fabs(dFaceError));
        GXASSERT(dTest < 1.0e-3f);
#endif

        dError = fFaceArea * m_AttributeWeights.Position * (fDist * fDist);

        if (pvNormalWedge1)
        {
            D3DXVec3BaryCentric(&vInterp,
                    m_cfvf.PvGetNormal(m_cfvf.GetArrayElem(pvPoints, pwCurFace[0])),
                    m_cfvf.PvGetNormal(m_cfvf.GetArrayElem(pvPoints, pwCurFace[1])),
                    m_cfvf.PvGetNormal(m_cfvf.GetArrayElem(pvPoints, pwCurFace[2])),
                    fU, fV);

            vDiff = *pvNormalWedge1;
            vDiff -= vInterp;

            dFaceError = (vDiff.x * vDiff.x);
            dFaceError += (vDiff.y * vDiff.y);
            dFaceError += (vDiff.z * vDiff.z);

            dError +=  dFaceError * (fFaceArea * m_AttributeWeights.Normal);  // adjust by normal weighting;
                //-> attrib_factor must have units of length^2 to make units = length^4 * attrib^2   and therefore be scale-invariant with respect to geometric errors above.
                //-> set attrib_factor= square(mesh_radius) * user_attrib_factor
               //(where user_attrib_factor=0.02f for vertex normals
//                 and  user_attrib_factor=0.1f for vertex colors    seem to work well)
        }

        if (m_rgcolorDiffuse != NULL)
        {
            GXASSERT(m_AttributeWeights.Diffuse > 0.0f);

            D3DXVec3BaryCentric(&vInterp,
                    (D3DXVECTOR3*)&m_rgcolorDiffuse[pwCurFace[0]],
                    (D3DXVECTOR3*)&m_rgcolorDiffuse[pwCurFace[1]],
                    (D3DXVECTOR3*)&m_rgcolorDiffuse[pwCurFace[2]],
                    fU, fV);

            vDiff = *(D3DXVECTOR3*)&m_rgcolorDiffuse[iWedge1];
            vDiff -= vInterp;

            dFaceError = (vDiff.x * vDiff.x);
            dFaceError += (vDiff.y * vDiff.y);
            dFaceError += (vDiff.z * vDiff.z);

            dError +=  dFaceError * (fFaceArea * m_AttributeWeights.Diffuse);  // adjust by normal weighting;
        }

        if (m_rgcolorSpecular != NULL)
        {
            GXASSERT(m_AttributeWeights.Specular > 0.0f);

            D3DXVec3BaryCentric(&vInterp,
                    (D3DXVECTOR3*)&m_rgcolorSpecular[pwCurFace[0]],
                    (D3DXVECTOR3*)&m_rgcolorSpecular[pwCurFace[1]],
                    (D3DXVECTOR3*)&m_rgcolorSpecular[pwCurFace[2]],
                    fU, fV);

            vDiff = *(D3DXVECTOR3*)&m_rgcolorSpecular[iWedge1];
            vDiff -= vInterp;

            dFaceError = (vDiff.x * vDiff.x);
            dFaceError += (vDiff.y * vDiff.y);
            dFaceError += (vDiff.z * vDiff.z);

            dError +=  dFaceError * (fFaceArea * m_AttributeWeights.Specular);  // adjust by normal weighting;
        }

        if (m_rgfTexWeights != NULL)
        {
            GXASSERT(m_cTexWeights > 0);
            GXASSERT(m_cfvf.CTexCoords() > 0);

		    pfTexCur0 = (float*)m_cfvf.PuvGetTex1(m_cfvf.GetArrayElem(pvPoints, pwCurFace[0]));
		    pfTexCur1 = (float*)m_cfvf.PuvGetTex1(m_cfvf.GetArrayElem(pvPoints, pwCurFace[1]));
		    pfTexCur2 = (float*)m_cfvf.PuvGetTex1(m_cfvf.GetArrayElem(pvPoints, pwCurFace[2]));
            pfTexWedge1 = (float*)m_cfvf.PuvGetTex1(m_cfvf.GetArrayElem(pvPoints, iWedge1));

            for (iTexWeight = 0; iTexWeight < m_cTexWeights; iTexWeight++)
            {

		        fTexCur = *pfTexCur0
									    + fU * (*pfTexCur1 - *pfTexCur0) 
									    + fV * (*pfTexCur2 - *pfTexCur0);

                fDiff = *pfTexWedge1 - fTexCur;

                dFaceError = (fDiff * fDiff);
                dError +=  dFaceError * (fFaceArea * m_rgfTexWeights[iTexWeight]);  // adjust by normal weighting;

			    pfTexCur0 += 1;
			    pfTexCur1 += 1;
			    pfTexCur2 += 1;
                pfTexWedge1 += 1;
            }
        }

        // add in the error for both the edges on this face
        iEdge = fli.IGetPointIndex();
        dBorderError = DGenerateBorderError(iCurFace, iEdge, pvPosWedge1, pvPoints);

        iEdge = (fli.IGetPointIndex()+2) % 3;
        dBorderError += DGenerateBorderError(iCurFace, iEdge, pvPosWedge1, pvPoints);

        dError += dBorderError * m_AttributeWeights.Boundary;

        // add the current error into the total, including the vertex weight in the result
        dErrorTotal += dError * m_rgfVertexWeights[m_tmTriMesh.WGetPointRep(pwCurFace[fli.IGetPointIndex()])];
    }

    peiInfo->m_cost = (float)dErrorTotal;
}

// -------------------------------------------------------------------------------
//  function    RecalcEdgeQEMS_Plane
//
//   devnote    Recalculate the costs/split positions of edges affected by a collapse
//                  uses the Garland and Heckbert form of QEMs formed from QEM of wedges
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
void 
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::RecalcEdgeQEMS_Plane
    (
    UINT_IDX iFacePresent, 
    UINT_IDX iWedgePresent, 
    PBYTE pvPoints
    )
{
    UINT_IDX iCurFace;
    UINT_IDX iEdge;

    CFaceListIter<UINT_IDX,b16BitIndex,UNUSED> fli(iFacePresent, iWedgePresent, &m_tmTriMesh, x_iAllFaces);
    while (!fli.BEndOfList())
    {
        iCurFace = fli.GetNextFace(); 

        // UNDONE - need a proper way to only touch faces that have changed
        //if (iCurFace == iNeighbor)
            //break;

        // recalculate both edges that use the point that changed
        iEdge = fli.IGetPointIndex();
        CalcEdgeQEMS_Plane(iCurFace, iEdge, pvPoints);
        m_pheapCosts->Update(m_rgfeiEdges[iCurFace].m_rgpeiEdges[iEdge]);

        iEdge = (fli.IGetPointIndex()+2) % 3;
        CalcEdgeQEMS_Plane(iCurFace, iEdge, pvPoints);
        m_pheapCosts->Update(m_rgfeiEdges[iCurFace].m_rgpeiEdges[iEdge]);
    }
}

// -------------------------------------------------------------------------------
//  function    ColapseEdge
//
//   devnote    Collapse the given edge in the mesh.  Does all the work necessary
//                  to remove the given edge (and specifed faces) from the mesh
//                  and maintain the error values in the heap
//
//   returns    S_OK on success, FAILED(hr) on failure
//                  NOTE: the edge may not have been collapsed in the case of S_OK
//                          i.e. if the mesh would be inverted, etc... so the edge
//                          is just skipped
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT 
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::CollapseEdge
    (
    CEdgeInfo<UINT_IDX> *peiInfo, 
    PBYTE pvPoints
    )
{
    HRESULT hr = S_OK;
    SEdgeCollapseContext<UINT_IDX> ecc;

    // fill in the ecc with the info required to process the edge collapse
    hr = GatherEdgeCollapseData(ecc, peiInfo, pvPoints);
    if (FAILED(hr))
        goto e_Exit;

    // perform checks to verify if the edge collapse is possible at this time
    //   if they fail, just exit (successfully)
    if (!BValidEdgeCollapse(ecc, pvPoints))
        goto e_Exit;  // NOTE: this exit is taken FREQUENTLY

#if 1
    // calculate thew new vsplit record, or at least as much as can be calculated at this time
    hr = CalculateVSplitRecord(ecc, pvPoints);
    if (FAILED(hr))
        goto e_Exit;
#endif

    // now actually perform the edge collapse
    hr = PerformEdgeCollapse(ecc, pvPoints);
    if (FAILED(hr))
        goto e_Exit;

#if 1
    // update the information used for fixing up vsplit records
    //   NOTE: must happen before m_cCurrentFaces is updated (or at least changed if so)
    hr = UpdateVSplitAdjustments(ecc);
    if (FAILED(hr))
        goto e_Exit;
#endif

    // removed a logical vertex
    m_cLogicalVertices -= 1;

    // remove one or two faces
    m_cCurrentFaces -= 1;
    if (ecc.iFace2 != UNUSED)
    {
        m_cCurrentFaces -= 1;
    }

    if ((m_cvsMax16BitPos == UINT32UNUSED) && (m_cCurrentFaces < UINT16UNUSED))
    {
        m_cvsMax16BitPos = m_cvsSplitCurFree;
        m_cMaxLogicalVertices = m_cLogicalVertices;
        m_cvsMaxFaces16BitPos = m_cCurrentFaces;
    }

    // now update the costs of the affected edges    
    hr = UpdateErrorMeasurements(ecc, pvPoints);
    if (FAILED(hr))
        goto e_Exit;

e_Exit:
    return hr;
}

// -------------------------------------------------------------------------------
//  function    GatherEdgeCollapseData
//
//   devnote    Generate the info required to process an edge collapse
//
//                  The faces involved, their edges, their wedges, etc
//
//   returns    S_OK if success, failed otherwise
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::GatherEdgeCollapseData
    (
    SEdgeCollapseContext<UINT_IDX> &ecc, 
    CEdgeInfo<UINT_IDX> *peiInfo, 
    PBYTE pvPoints
    )
{
    ecc.iWedgeRemove1 = UNUSED;
    ecc.iWedgeRemove2 = UNUSED;
    ecc.iWedgeRemove3 = UNUSED;
    ecc.iWedgeRemove4 = UNUSED;
    ecc.iWedgeRemove5 = UNUSED;
    ecc.iWedgeRemove6 = UNUSED;

    // first collect all the info on the first face and the faces above and below it
    ecc.iFace1 = peiInfo->m_wFace;
    ecc.iEdge1 = peiInfo->m_iEdge;
    ecc.iEdge1L = (ecc.iEdge1 + 2) % 3;
    ecc.iEdge1R = (ecc.iEdge1 + 1) % 3;
    ecc.iMaterialLeft = m_tmTriMesh.m_rgiMaterialIndex[ecc.iFace1];

    ecc.iPoint1 = m_tmTriMesh.m_pFaces[ecc.iFace1].m_wIndices[ecc.iEdge1];
    ecc.iPoint2 = m_tmTriMesh.m_pFaces[ecc.iFace1].m_wIndices[ecc.iEdge1R];

    ecc.vPositionNew = *m_cfvf.PvGetPosition(m_cfvf.GetArrayElem(pvPoints, ecc.iPoint1));

    ecc.iFace2 = m_tmTriMesh.m_rgpniNeighbors[ecc.iFace1].m_iNeighbors[ecc.iEdge1];

    ecc.pwNeighbors1 = m_tmTriMesh.m_rgpniNeighbors[ecc.iFace1].m_iNeighbors;
    ecc.pwNeighbors2 = NULL;

    ecc.iNFace11 = ecc.pwNeighbors1[ecc.iEdge1L];
    if(ecc.iNFace11 != UNUSED) 
    {
        ecc.iEdge11 = FindEdge(m_tmTriMesh.m_rgpniNeighbors[ecc.iNFace11].m_iNeighbors, ecc.iFace1);
        GXASSERT(ecc.iEdge11 < 3);
    }

    ecc.iNFace12 = ecc.pwNeighbors1[ecc.iEdge1R];
    if(ecc.iNFace12 != UNUSED) 
    {
        ecc.iEdge12 = FindEdge(m_tmTriMesh.m_rgpniNeighbors[ecc.iNFace12].m_iNeighbors, ecc.iFace1);
        GXASSERT(ecc.iEdge12 < 3);
    }

        // collect the wedges for the different corners of the face
    ecc.iWedgeL1 = m_tmTriMesh.m_pFaces[ecc.iFace1].m_wIndices[ecc.iEdge1];
    ecc.iWedgeL2 = m_tmTriMesh.m_pFaces[ecc.iFace1].m_wIndices[ecc.iEdge1R];
    ecc.iWedge11 = (ecc.iNFace11 == UNUSED) ? UNUSED : m_tmTriMesh.m_pFaces[ecc.iNFace11].m_wIndices[ecc.iEdge11];
    ecc.iWedge12 = (ecc.iNFace12 == UNUSED) ? UNUSED : m_tmTriMesh.m_pFaces[ecc.iNFace12].m_wIndices[(ecc.iEdge12 + 1) % 3];

    // next gather the same data on the second face if it exists
    if(ecc.iFace2 != UNUSED) 
    {
        ecc.iMaterialRight = m_tmTriMesh.m_rgiMaterialIndex[ecc.iFace2];
        ecc.pwNeighbors2 = m_tmTriMesh.m_rgpniNeighbors[ecc.iFace2].m_iNeighbors;

        ecc.iEdge2 = FindEdge(ecc.pwNeighbors2, ecc.iFace1);
        GXASSERT(ecc.iEdge2 < 3);

        ecc.iEdge2L = (ecc.iEdge2 + 2) % 3;
        ecc.iEdge2R = (ecc.iEdge2 + 1) % 3;

        ecc.iNFace21 = ecc.pwNeighbors2[ecc.iEdge2R];
        if(ecc.iNFace21 != UNUSED) 
        {
            ecc.iEdge21 = FindEdge(m_tmTriMesh.m_rgpniNeighbors[ecc.iNFace21].m_iNeighbors, ecc.iFace2);
            GXASSERT(ecc.iEdge21 < 3);
        }

        ecc.iNFace22 = ecc.pwNeighbors2[ecc.iEdge2L];
        if(ecc.iNFace22 != UNUSED) 
        {
            ecc.iEdge22 = FindEdge(m_tmTriMesh.m_rgpniNeighbors[ecc.iNFace22].m_iNeighbors, ecc.iFace2);
            GXASSERT(ecc.iEdge22 < 3);
        }

        // collect the wedges for the different corners of the face
        ecc.iWedgeR1 = m_tmTriMesh.m_pFaces[ecc.iFace2].m_wIndices[ecc.iEdge2R];
        ecc.iWedgeR2 = m_tmTriMesh.m_pFaces[ecc.iFace2].m_wIndices[ecc.iEdge2];

        ecc.iWedge21 = (ecc.iNFace21 == UNUSED) ? UNUSED : m_tmTriMesh.m_pFaces[ecc.iNFace21].m_wIndices[(ecc.iEdge21 +1) % 3];
        ecc.iWedge22 = (ecc.iNFace22 == UNUSED) ? UNUSED : m_tmTriMesh.m_pFaces[ecc.iNFace22].m_wIndices[ecc.iEdge22];
    }
    else
    {
        ecc.iNFace21 = UNUSED;
        ecc.iNFace22 = UNUSED;

        ecc.iWedgeR1 = ecc.iWedgeR2 = ecc.iWedge21 = ecc.iWedge22 = UNUSED;
    }

    return S_OK;
}

// -------------------------------------------------------------------------------
//  function    BValidEdgeCollapse
//
//   devnote    Perform checks verifying that the mesh would be valid after the
//                  specified edge collapse (i.e. mesh inversion, wedge fragmentation, etc)
//
//   returns    true if no problems, false if would cause an inconsistency
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
bool
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::BValidEdgeCollapse
    (
    SEdgeCollapseContext<UINT_IDX> &ecc, 
    PBYTE pvPoints
    )
{
    bool        bRet = false;
    UINT_IDX    iTestEdge;
    UINT_IDX    iFace;
    D3DXVECTOR3    rgvNewTri[3];
    D3DXVECTOR3    rgvOldTri[3];
    UINT_IDX    ifli;
    UINT_IDX    wCurPoint;
    UINT_IDX    iCurFace;
    D3DXVECTOR3   vEdge1;
    D3DXVECTOR3   vEdge2;
    D3DXVECTOR3 vNormal;
    D3DXVECTOR3 vFaceNormal;
    PBYTE       pvPoint;
    UINT_IDX   *pwFace;
    UINT_IDX    iPoint;
	float		fNewLength;
	float		fOldLength;
    CFaceListIter<UINT_IDX,b16BitIndex,UNUSED> fli(&m_tmTriMesh);

    // if doing half edge collapses and there is no iFlclw, then
    //   disallow the collapse, removing a case for code simplicity later
#if 1
    if ((ecc.iNFace12 == UNUSED))
    {
        goto e_Exit;
    }
#endif

    // Condition 0 - must still be manifold
    if ((ecc.iNFace12 != UNUSED) && (ecc.iNFace11 != UNUSED))
    {
        bool bFoundSharedVertex;

        bFoundSharedVertex = false;

        // mark all vertices off of iPoint2
        fli.Init(ecc.iNFace12, ecc.iWedge12, x_iClockwise);
        while(!fli.BEndOfList())
        {
            iFace = fli.GetNextFace();

            // don't want to count the point in iFace2 that is not on the edge being collapsed
            if (iFace == ecc.iNFace22)
                break;

            iPoint = (fli.IGetPointIndex() + 1) % 3;
            wCurPoint = m_tmTriMesh.WGetPointRep(m_tmTriMesh.m_pFaces[iFace].m_wIndices[iPoint]);

            m_rgbVertexSeen[wCurPoint] = true;
        }

        // now walk the other vertex, checking to see if any of the vertices are
        //      shared with edges off of iPoint2
        fli.Init(ecc.iNFace11, ecc.iWedge11, x_iCounterClockwise);
        while(!fli.BEndOfList())
        {
            iFace = fli.GetNextFace();

            // don't want to count the point in iFace2 that is not on the edge being collapsed
            if (iFace == ecc.iNFace21)
                break;

            iPoint = (fli.IGetPointIndex() + 2) % 3;
            wCurPoint = m_tmTriMesh.WGetPointRep(m_tmTriMesh.m_pFaces[iFace].m_wIndices[iPoint]);

            if (m_rgbVertexSeen[wCurPoint])
            {
                bFoundSharedVertex = true;
                break;;
            }
        }


        // now unmark all vertices that were marked above
        fli.Init(ecc.iNFace12, ecc.iWedge12, x_iClockwise);
        while(!fli.BEndOfList())
        {
            iFace = fli.GetNextFace();
            if (iFace == ecc.iNFace22)
                break;

            iPoint = (fli.IGetPointIndex() + 1) % 3;

            wCurPoint = m_tmTriMesh.WGetPointRep(m_tmTriMesh.m_pFaces[iFace].m_wIndices[iPoint]);
            m_rgbVertexSeen[wCurPoint] = false;
        }

        // wait until after cleanup to exit
        if (bFoundSharedVertex)
            goto e_Exit;
    }



    // Check condition 1: preserve holes and corners

    // UNDONE UNDONE... implement


    // Condition 1.5, For the vsplit records (can be disabled for non-PM generation)
    //      make sure that there is a path between flclw and frccw
    if (ecc.iFace2 != UNUSED)
    {
        GXASSERT(ecc.iFace1 != UNUSED);

        if (ecc.iNFace12 == UNUSED)
            goto e_Exit;

        // walk counter clockwise from iNFace12 to iNFace22 to verify that there is a path
        CFaceListIter<UINT_IDX,b16BitIndex,UNUSED> fli(ecc.iNFace12, ecc.iWedge12, &m_tmTriMesh, x_iClockwise);
    
        do 
        {
            iFace = fli.GetNextFace();
        
            if (fli.BEndOfList())
                goto e_Exit;
        }
        while (iFace != ecc.iNFace22);

        GXASSERT(iFace == ecc.iNFace22);
    }


    // Check condition 2: Don't create singularities

    if((ecc.pwNeighbors1[ecc.iEdge1L] == UNUSED) && (ecc.pwNeighbors1[ecc.iEdge1R] == UNUSED) 
                && (ecc.iFace2 != UNUSED))
    {
        goto e_Exit;
    }

    // if the two faces to link together are already connected, don't allow the collapse
    if ((ecc.iNFace11 != UNUSED) && (ecc.iNFace12 != UNUSED))
    {
        iTestEdge = FindEdge(m_tmTriMesh.m_rgpniNeighbors[ecc.iNFace11].m_iNeighbors, ecc.iNFace12);
        if (iTestEdge < 3)
            goto e_Exit;
    }

    // if the two faces to link together are already connected, don't allow the collapse
    if ((ecc.iNFace21 != UNUSED) && (ecc.iNFace22 != UNUSED))
    {
        iTestEdge = FindEdge(m_tmTriMesh.m_rgpniNeighbors[ecc.iNFace21].m_iNeighbors, ecc.iNFace22);
        if (iTestEdge < 3)
            goto e_Exit;
    }

    // Check condition 3: Don't collapse tetrahedrons and triangles

    // if all neighbors are unused, then classify as a triangle, and don't collapse
    if((ecc.pwNeighbors1[ecc.iEdge1L] == UNUSED) && (ecc.pwNeighbors1[ecc.iEdge1R] == UNUSED) 
                && (ecc.pwNeighbors1[ecc.iEdge1] == UNUSED))
    {
        goto e_Exit;
    }

    if (ecc.iFace2 != UNUSED)
    {
        // if sharing two edges with the other triangle, don't collapse
        if ((ecc.pwNeighbors1[ecc.iEdge1L] == ecc.pwNeighbors2[ecc.iEdge2R]) 
                && (ecc.pwNeighbors1[ecc.iEdge1R] == ecc.pwNeighbors2[ecc.iEdge2L]))
        {
            // will get here if no neighbors on the sides.
            if ((ecc.pwNeighbors1[ecc.iEdge1L] != UNUSED) && (ecc.pwNeighbors1[ecc.iEdge1R] != UNUSED))
                goto e_Exit;
        }
    }

    // Check for mesh inversion
    


    for (ifli = 0; ifli < 2; ifli++)
    {

        // first look at all faces around point1, making sure that they will not
        //   invert, then look at the faces around point2
        if (ifli == 0)
        {
            wCurPoint = ecc.iWedgeL1;
        }
        else
        {
            GXASSERT(ifli == 1);
            wCurPoint = ecc.iWedgeL2;
        }

        CFaceListIter<UINT_IDX,b16BitIndex,UNUSED> fli(ecc.iFace1, wCurPoint, &m_tmTriMesh, x_iAllFaces);

        while (!fli.BEndOfList())
        {
            iCurFace = fli.GetNextFace();

            // if the face is either of the two being removed, then skip it
            if ((iCurFace != ecc.iFace1) && (iCurFace != ecc.iFace2))
            {
                pwFace = m_tmTriMesh.m_pFaces[iCurFace].m_wIndices;

                // gather the new positions for the points
                for (iPoint = 0; iPoint < 3; iPoint++) 
                {
                    // if the current point is one of the ones being combined, substitute
                    //   the new position
                    if (m_tmTriMesh.BEqualPoints(pwFace[iPoint], wCurPoint)) 
                    {
                        rgvNewTri[iPoint] = ecc.vPositionNew;

                        // grab the original position
                        pvPoint = m_cfvf.GetArrayElem(pvPoints, pwFace[iPoint]);
                        rgvOldTri[iPoint] = *m_cfvf.PvGetPosition(pvPoint);
                    }
                    else  // otherwise just grab the current position
                    {
                        pvPoint = m_cfvf.GetArrayElem(pvPoints, pwFace[iPoint]);
                        rgvNewTri[iPoint] = *m_cfvf.PvGetPosition(pvPoint);
                        rgvOldTri[iPoint] = *m_cfvf.PvGetPosition(pvPoint);
                    }
                }

                vEdge1 = rgvNewTri[0] - rgvNewTri[1];
                vEdge2 = rgvNewTri[0] - rgvNewTri[2];

                // calculate the normal of the face from the two edge vectors
                D3DXVec3Cross(&vNormal, &vEdge1, &vEdge2);
                
                // UNDONE - if I cache face normals, I could just use that one, but it is easy to generate
                vEdge1 = rgvOldTri[0] - rgvOldTri[1];
                vEdge2 = rgvOldTri[0] - rgvOldTri[2];

                // calculate the normal of the face from the two edge vectors
                D3DXVec3Cross(&vFaceNormal, &vEdge1, &vEdge2);
                
                // if the dot product of the two normals is less than zero
                //    then the collapse would cause a mesh inversion, so skip this edge
				fNewLength = D3DXVec3LengthSq(&vNormal);
				fOldLength = D3DXVec3LengthSq(&vFaceNormal);
                if ( (fNewLength > x_fEpsilon) && (fOldLength > x_fEpsilon) 
                    && D3DXVec3Dot(&vNormal, &vFaceNormal) <= x_fEpsilon) 
                {
                    goto e_Exit;
                }  

				// don't introduce degenerate triangles (if not degenerate already)
                //if ((fNewLength <= x_fEpsilon) && (fOldLength > x_fEpsilon))
                //{
                    //goto e_Exit;
                //}        
            }    
        }
    }

    // Check that this collapse does not cause wedge fragmentation


    if ((ecc.iWedgeL1 == ecc.iWedge11) && (ecc.iWedgeL1 == ecc.iWedgeR1) && (ecc.iWedgeL1 == ecc.iWedge21))
    {
        CFaceListIter<UINT_IDX,b16BitIndex,UNUSED> fli(ecc.iFace1, ecc.iWedgeL1, &m_tmTriMesh, x_iCounterClockwise);
        do
        {
            iFace = fli.GetNextFace();
        }
        while (!fli.BEndOfList() && (iFace != ecc.iFace2));

        // if there is a boundary in between iFace1 and iFace2 or there
        //    is more then one wedge on this vertex
        if ((iFace != ecc.iFace2) || (m_rgiWedgeList[ecc.iWedgeL1] != ecc.iWedgeL1))
        {
            goto e_Exit;
        }
    }

    if ((ecc.iWedgeL2 == ecc.iWedge12) && (ecc.iWedgeL2 == ecc.iWedgeR2) && (ecc.iWedgeL2 == ecc.iWedge22))
    {
        CFaceListIter<UINT_IDX,b16BitIndex,UNUSED> fli(ecc.iFace1, ecc.iWedgeL2, &m_tmTriMesh, x_iClockwise);
        do
        {
            iFace = fli.GetNextFace();
        }
        while (!fli.BEndOfList() && (iFace != ecc.iFace2));

        // if there is a boundary in between iFace1 and iFace2 or there
        //    is more then one wedge on this vertex
        if ((iFace != ecc.iFace2 )  || (m_rgiWedgeList[ecc.iWedgeL2] != ecc.iWedgeL2))
        {
            goto e_Exit;
        }
    }    

    // dart check

    if (((ecc.iWedge11 == ecc.iWedgeL1) && (ecc.iWedge21 == ecc.iWedgeR1)
                        && (ecc.iWedgeL1 == ecc.iWedgeR1) 
                        && (ecc.iWedgeL2 != ecc.iWedgeR2))
        ||
        ((ecc.iWedge12 == ecc.iWedgeL2) && (ecc.iWedge22 == ecc.iWedgeR2) 
                        && (ecc.iWedgeL2 == ecc.iWedgeR2)
                        && (ecc.iWedgeL1 != ecc.iWedgeR1)))
    {
        // Problem is that there are two different attributes that
        //  resulting wedge could take on -> problem in encoding.
        goto e_Exit;
    }

    // unmaintanable wedges.  in half edges, the vertex being moved
    //    must not have any wedges that cannot be maintained, since
    //    we have to be able to do vsplits/edge collapses without affecting
    //    the actual vertex buffer

    if (x_bRestrictForHalfEdgePM)
    {
        // if the corner wedges are the same, then there can only be one
        //    wedge on the vertex.
        //          NOTE: if there is no face 2, then there can only be one wedge
        if ((ecc.iWedgeL2 == ecc.iWedgeR2) || (ecc.iWedgeR2 == UNUSED))
        {
            // if more than one wedge, cannot maintain them
            if (m_rgiWedgeList[ecc.iWedgeL2] != ecc.iWedgeL2)
            {
                goto e_Exit;
            }
        }
        else  // iWedgeL2 != iWedgeR2 and they both exist
        {
            GXASSERT((ecc.iWedgeL2 != UNUSED) && (ecc.iWedgeR2 != UNUSED));

            // first see if there is one wedge
            UINT_IDX iOtherWedge = m_rgiWedgeList[ecc.iWedgeL2];
            if (iOtherWedge != ecc.iWedgeL2)
            {
                // more than one wedge, so check the next item on the list to see
                //   if it points back to the first one, which is fine (max of 2 wedges)
                if (m_rgiWedgeList[iOtherWedge] != ecc.iWedgeL2)
                {
                    // nope, more wedges, not supported with half edge PM
                    goto e_Exit;
                }
                GXASSERT(iOtherWedge == ecc.iWedgeR2);
            }
            else
            {
                // if crease between R2 and L2, must be at least 2 wedges
                GXASSERT(0);
            }

			// two wedges can only be supported on the vertex to remove, if there
			//    are two on the other vertex
			if (ecc.iWedgeL1 == ecc.iWedgeR1)
				goto e_Exit;
        }
    }

    if (ecc.iNFace12 != UNUSED)
    {
        fli.Init(ecc.iNFace12, ecc.iWedge12, x_iClockwise);
        while (!fli.BEndOfList())
        {
            iFace = fli.GetNextFace();

            if (iFace == ecc.iFace2)
                break;

            iPoint = fli.IGetPointIndex();

            // if either of the other two points match the other point to be collapsed.. uh oh, don't collapse
            //    either a problem in the adjacency info (they probably should point to each other) or a weird
            //    issue with collapsing a hole
            if ((m_tmTriMesh.m_pFaces[iFace].m_wIndices[(iPoint+1)%3] == ecc.iWedgeL1)
                || (m_tmTriMesh.m_pFaces[iFace].m_wIndices[(iPoint+2)%3] == ecc.iWedgeL1))
            {
                goto e_Exit;
            }
        }
    }

    if (ecc.iNFace11 != UNUSED)
    {
        fli.Init(ecc.iNFace11, ecc.iWedge11, x_iCounterClockwise);
        while (!fli.BEndOfList())
        {
            iFace = fli.GetNextFace();

            if (iFace == ecc.iFace2)
                break;

            iPoint = fli.IGetPointIndex();

            // if either of the other two points match the other point to be collapsed.. uh oh, don't collapse
            //    either a problem in the adjacency info (they probably should point to each other) or a weird
            //    issue with collapsing a hole
            if ((m_tmTriMesh.m_pFaces[iFace].m_wIndices[(iPoint+1)%3] == ecc.iWedgeL2)
                || (m_tmTriMesh.m_pFaces[iFace].m_wIndices[(iPoint+2)%3] == ecc.iWedgeL2))
            {
                goto e_Exit;
            }
        }
    }

    // passed all checks with flying colors
    bRet = true;

e_Exit:
    return bRet;
}

// -------------------------------------------------------------------------------
//  function    CalculateVSplitRecord
//
//   devnote    Generates the vsplit record for the given edge collapse
//
//   NOTE: only information invalid in the built CHalfEdgeVSplit record is the final offset
//               of flclw, and vs_index was not filled in.  Both of these need to be filled
//               in once the base mesh has been decided.
//                      The vs_index is VALID assuming that flclw is in the base mesh, 
//                      but if not it needs to be adjusted.
//
//   returns    S_OK if success, failed otherwise
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT 
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::CalculateVSplitRecord
    (
    SEdgeCollapseContext<UINT_IDX> &ecc, 
    PBYTE pvPoints
    )
{
    CHalfEdgeVSplit *pvs;        
    D3DXVECTOR3 *pvVs;
    D3DXVECTOR3 *pvVt;
    UINT_IDX iPointOffset;
    PBYTE pvPoint;
    UINT_IDX iFace;
    HRESULT hr = S_OK;

    pvs = &m_rgvsSplits[m_cvsSplitCurFree];
    ecc.ivsCurSplit = m_cvsSplitCurFree;
    GXASSERT((m_cvsSplitCurFree > 0) && (m_cvsSplitCurFree < m_cvsSplitsMax));
    m_cvsSplitCurFree -= 1;



    if (ecc.iNFace12 != UNUSED)
    {
        pvs->m_iFlclw = ecc.iNFace12;
        iPointOffset = m_tmTriMesh.FindPoint(m_tmTriMesh.m_pFaces[ecc.iNFace12].m_wIndices, ecc.iPoint2);
    }
    else
    {
        GXASSERT(ecc.iNFace11 != UNUSED);
        pvs->m_iFlclw = ecc.iNFace11;
        iPointOffset = m_tmTriMesh.FindPoint(m_tmTriMesh.m_pFaces[ecc.iNFace11].m_wIndices, ecc.iPoint1);
    }
    GXASSERT(iPointOffset < 3);

    // calculate bits for new corners
    pvs->m_code = 0;

    // set the point offset in the triangle
    pvs->m_code |= (iPointOffset << CHalfEdgeVSplit::VSINDEX_SHIFT);

    if (m_tmTriMesh.m_rgiAttributeIds[pvs->m_iFlclw] != m_tmTriMesh.m_rgiAttributeIds[ecc.iFace1])
        pvs->m_code |= CHalfEdgeVSplit::FLN_MASK;

    if ((ecc.iFace2 != UNUSED) && (m_tmTriMesh.m_rgiAttributeIds[ecc.iNFace22] != m_tmTriMesh.m_rgiAttributeIds[ecc.iFace2]))
        pvs->m_code |= CHalfEdgeVSplit::FRN_MASK;

    pvPoint = m_cfvf.GetArrayElem(pvPoints, ecc.iPoint1);
    pvVs = m_cfvf.PvGetPosition(pvPoint);

    pvPoint = m_cfvf.GetArrayElem(pvPoints, ecc.iPoint2);
    pvVt = m_cfvf.PvGetPosition(pvPoint);

    if (ecc.iWedge11 == ecc.iWedgeL1)
    {
        pvs->m_code |= CHalfEdgeVSplit::S_LSAME;
    }

    if (ecc.iWedgeL1 == ecc.iWedgeR1)
    {
        pvs->m_code |= CHalfEdgeVSplit::S_CSAME;
    }

    if (ecc.iWedgeR1 == ecc.iWedge21)
    {
        pvs->m_code |= CHalfEdgeVSplit::S_RSAME;
    }

    if (ecc.iWedgeL2 == ecc.iWedge12)
    {
        pvs->m_code |= CHalfEdgeVSplit::T_LSAME;
    }

    if (ecc.iWedgeL2 == ecc.iWedgeR2)
    {
        pvs->m_code |= CHalfEdgeVSplit::T_CSAME;
    }

    if (ecc.iWedgeR2 == ecc.iWedge22)
    {
        pvs->m_code |= CHalfEdgeVSplit::T_RSAME;
    }

    // calculate other corners
    UINT_IDX iWedgeTop, iWedgeBottom, iWedgeMiddle;

    iWedgeTop = iWedgeBottom = UNUSED;

    iWedgeMiddle = m_tmTriMesh.m_pFaces[ecc.iFace1].m_wIndices[ecc.iEdge1L];
    if (ecc.iNFace12 != UNUSED)
    {
        iWedgeTop = m_tmTriMesh.m_pFaces[ecc.iNFace12].m_wIndices[ecc.iEdge12];
    }

    if (ecc.iNFace11 != UNUSED)
    {
        iWedgeBottom = m_tmTriMesh.m_pFaces[ecc.iNFace11].m_wIndices[(ecc.iEdge11+1)%3];
    }

    // if the top is not the same, then check to see which the bottom is
    if (iWedgeTop != iWedgeMiddle)
    {
        // if the bottom and top are not the same than a new wedge
        if (iWedgeMiddle != iWedgeBottom)
        {
            pvs->m_code |= CHalfEdgeVSplit::L_NEW;
        }
        else  // else if the top is different, but same as bottom
        {
            pvs->m_code |= CHalfEdgeVSplit::L_BELOW;
        }

    }
    // else  the top is the same, so L_ABOVE, which is a 0 bit, so don't set

    if (ecc.iFace2 != UNUSED)
    {
        iWedgeTop = iWedgeBottom = UNUSED;

        iWedgeMiddle = m_tmTriMesh.m_pFaces[ecc.iFace2].m_wIndices[ecc.iEdge2L];
        if (ecc.iNFace22 != UNUSED)
        {
            iWedgeTop = m_tmTriMesh.m_pFaces[ecc.iNFace22].m_wIndices[(ecc.iEdge22+1)%3];
        }

        if (ecc.iNFace21 != UNUSED)
        {
            iWedgeBottom = m_tmTriMesh.m_pFaces[ecc.iNFace21].m_wIndices[ecc.iEdge21];
        }

        // if the top is not the same, then check to see which the bottom is
        if (iWedgeTop != iWedgeMiddle)
        {
            // if the bottom and top are not the same than a new wedge
            if (iWedgeMiddle != iWedgeBottom)
            {
                pvs->m_code |= CHalfEdgeVSplit::R_NEW;
            }
            else  // else if the top is different, but same as bottom
            {
                pvs->m_code |= CHalfEdgeVSplit::R_BELOW;
            }

        }
        // else  the top is the same, so L_ABOVE, which is a 0 bit, so don't set
    }

    // should always be a iFlclw according to the edge collapse checks
    GXASSERT(ecc.iNFace12 != UNUSED);

    if (ecc.iFace2 == UNUSED)
    {
        pvs->m_oVlrOffset = 0;
    }
    else  // normal case with both iFace1 and iFace2
    {
        // walk counter clockwise from iNFace12 to iNFace22 counting number of moves
        CFaceListIter<UINT_IDX,b16BitIndex,UNUSED> fli(ecc.iNFace12, ecc.iWedge12, &m_tmTriMesh, x_iClockwise);
        
        // start vlroffset1 at 0, since it will be incremented once for iNFace12
        //    initial valid value is 1, which means that both flclw and frccw are the
        //    same triangle, 2 means that flclw and frccw are directly connected and so on
        pvs->m_oVlrOffset = 0;
        do 
        {
            iFace = fli.GetNextFace();
            pvs->m_oVlrOffset += 1;
            
            GXASSERT(!fli.BEndOfList());
        }
        while (iFace != ecc.iNFace22);

        GXASSERT(iFace == ecc.iNFace22);
    }

    if (pvs->m_code & CHalfEdgeVSplit::L_NEW)
    {
		ecc.iWedgeRemove3 = m_tmTriMesh.m_pFaces[ecc.iFace1].m_wIndices[ecc.iEdge1L];
    }

    if (pvs->m_code & CHalfEdgeVSplit::R_NEW)
    {
		ecc.iWedgeRemove6 = m_tmTriMesh.m_pFaces[ecc.iFace2].m_wIndices[ecc.iEdge2L];
    }

	if (ecc.iFace2 == UNUSED) 
	{
		if (!(pvs->m_code & CHalfEdgeVSplit::T_LSAME) && !(pvs->m_code & CHalfEdgeVSplit::S_LSAME))
			ecc.iWedgeRemove1 = ecc.iWedgeL1;

		//if (!(pvs->m_code & CHalfEdgeVSplit::T_LSAME) )
			ecc.iWedgeRemove2 = ecc.iWedgeL2;

		//if ( (pvs->m_code & CHalfEdgeVSplit::T_LSAME) && (pvs->m_code & CHalfEdgeVSplit::S_LSAME))
			//ecc.iWedgeRemove1 = ecc.iWedgeL2;
	}
	else
	{
		if (!(pvs->m_code & CHalfEdgeVSplit::T_LSAME) && !( (pvs->m_code & CHalfEdgeVSplit::S_CSAME) && (pvs->m_code & CHalfEdgeVSplit::S_RSAME)) && ! (pvs->m_code & CHalfEdgeVSplit::S_LSAME))
			ecc.iWedgeRemove1 = ecc.iWedgeL1;

		if (!(pvs->m_code & CHalfEdgeVSplit::T_LSAME) && !( (pvs->m_code & CHalfEdgeVSplit::T_CSAME) && (pvs->m_code & CHalfEdgeVSplit::T_RSAME)))
			ecc.iWedgeRemove2 = ecc.iWedgeL2;

		if ( (pvs->m_code & CHalfEdgeVSplit::T_LSAME) /*&& (pvs->m_code & CHalfEdgeVSplit::S_LSAME)*/)
			ecc.iWedgeRemove2 = ecc.iWedgeL2;

		if (!(pvs->m_code & CHalfEdgeVSplit::T_RSAME) && !(pvs->m_code & CHalfEdgeVSplit::S_CSAME) && ! (pvs->m_code & CHalfEdgeVSplit::S_RSAME))
			ecc.iWedgeRemove4 = ecc.iWedgeR1;

		if (!(pvs->m_code & CHalfEdgeVSplit::T_RSAME) && !(pvs->m_code & CHalfEdgeVSplit::T_CSAME))
			ecc.iWedgeRemove5 = ecc.iWedgeR2;

		if ( (pvs->m_code & CHalfEdgeVSplit::T_RSAME) /*&& (pvs->m_code & CHalfEdgeVSplit::S_RSAME)*/ && (ecc.iWedgeRemove2 != ecc.iWedgeR2))
			ecc.iWedgeRemove5 = ecc.iWedgeR2;
	}

	GXASSERT(ecc.iWedgeRemove2 != UNUSED);


    // maintain the vertex buffer for half edges PMs
    if ( x_bGenerateHalfEdgePM )
    {

		// NOTE:  need to add wedges to HE buffer in reverse order
		if (ecc.iWedgeRemove6 != UNUSED)
			AddHEPoint(pvPoints, ecc.iWedgeRemove6, ecc.iMaterialRight);
		if (ecc.iWedgeRemove4 != UNUSED)
			AddHEPoint(pvPoints, ecc.iWedgeRemove4, ecc.iMaterialRight);
		if (ecc.iWedgeRemove5 != UNUSED)
			AddHEPoint(pvPoints, ecc.iWedgeRemove5, ecc.iMaterialRight);

		if (ecc.iWedgeRemove3 != UNUSED)
			AddHEPoint(pvPoints, ecc.iWedgeRemove3, ecc.iMaterialLeft);
		if (ecc.iWedgeRemove1 != UNUSED)
			AddHEPoint(pvPoints, ecc.iWedgeRemove1, ecc.iMaterialLeft);
		if (ecc.iWedgeRemove2 != UNUSED)
			AddHEPoint(pvPoints, ecc.iWedgeRemove2, ecc.iMaterialLeft);

        if (pvs->m_code & CHalfEdgeVSplit::FRN_MASK)
        {
            GXASSERT((ecc.iFace2 != UNUSED) && (ecc.iNFace22 != UNUSED));
            GXASSERT(m_tmTriMesh.m_rgiAttributeIds[ecc.iNFace22] != m_tmTriMesh.m_rgiAttributeIds[ecc.iFace2]);
            GXASSERT(m_tmTriMesh.m_rgiMaterialIndex[ecc.iNFace22] != m_tmTriMesh.m_rgiMaterialIndex[ecc.iFace2]);
            GXASSERT((m_rgiMaterialNew != NULL) && (m_cMaterialNewFree > 0));

            m_rgiMaterialNew[m_cMaterialNewFree] = m_tmTriMesh.m_rgiMaterialIndex[ecc.iFace2];
            m_cMaterialNewFree -= 1;
        }

        if (pvs->m_code & CHalfEdgeVSplit::FLN_MASK)
        {
            GXASSERT((ecc.iFace1 != UNUSED) && (ecc.iNFace12 != UNUSED));
            GXASSERT(m_tmTriMesh.m_rgiAttributeIds[ecc.iNFace12] != m_tmTriMesh.m_rgiAttributeIds[ecc.iFace1]);
            GXASSERT(m_tmTriMesh.m_rgiMaterialIndex[ecc.iNFace12] != m_tmTriMesh.m_rgiMaterialIndex[ecc.iFace1]);
            GXASSERT((m_rgiMaterialNew != NULL) && (m_cMaterialNewFree > 0));

            m_rgiMaterialNew[m_cMaterialNewFree] = m_tmTriMesh.m_rgiMaterialIndex[ecc.iFace1];
            m_cMaterialNewFree -= 1;
        }
    }

    return hr;
}

// -------------------------------------------------------------------------------
//  function    AddHEPoint
//
//   devnote    Appends the given wedge to the list of vertices to append
//					for a half edge pm
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
void
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::AddHEPoint
    (
    PBYTE pvPoints, 
    UINT_IDX iWedge, 
    UINT16 iMaterial
    )
{
    PBYTE pvHEBufPoint;
    PBYTE pvPoint;

    GXASSERT((m_rgcvHEVertexBufferFree[iMaterial] > 0) && (m_rgcvHEVertexBufferFree[iMaterial] < m_rgcvHEVertexBufferMax[iMaterial]));

    pvHEBufPoint = m_cfvf.GetArrayElem(m_pvHEVertexBuffer, m_rgcvHEVertexBufferFree[iMaterial]);
    m_rgiHEVertexBuffer[m_rgcvHEVertexBufferFree[iMaterial]] = iWedge;

    pvPoint = m_cfvf.GetArrayElem(pvPoints, iWedge);
    memcpy(pvHEBufPoint, pvPoint, m_cfvf.m_cBytesPerVertex);
	
    m_rgcvHEVertexBufferFree[iMaterial] -= 1;
}


// -------------------------------------------------------------------------------
//  function    PerformEdgeCollapse
//
//   devnote    Collapse the edge specified by the edge collapse context
//                  maintain the heap, and defragment and remove wedges
//                  as well as the unused faces and edges
//
//   returns    S_OK if success, failed otherwise
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::PerformEdgeCollapse
    (
    SEdgeCollapseContext<UINT_IDX> &ecc, 
    PBYTE pvPoints
    )
{
    UINT_IDX wHead;
    UINT_IDX wCur;
    UINT_IDX wNext;
    UINT_IDX wNewRep;
    PBYTE pvPoint;
    UINT_IDX iWedge;
    UINT_IDX iPoint;
    UINT_IDX iFace;
    UINT_IDX iEdge;

    // link iNFace11 to iNFace12 and vice versa... only if present
    if(ecc.iNFace11 != UNUSED) 
    {
        m_tmTriMesh.m_rgpniNeighbors[ecc.iNFace11].m_iNeighbors[ecc.iEdge11] = ecc.iNFace12;
    }

    if(ecc.iNFace12 != UNUSED) 
    {
        m_tmTriMesh.m_rgpniNeighbors[ecc.iNFace12].m_iNeighbors[ecc.iEdge12] = ecc.iNFace11;
    }
    
    for (iEdge = 0; iEdge < 3; iEdge++)
    {
        m_pheapCosts->Delete(m_rgfeiEdges[ecc.iFace1].m_rgpeiEdges[iEdge]);
        //delete m_rgfeiEdges[ecc.iFace1].m_rgpeiEdges[iEdge];
    }

    // now deal with neigbhors of the second face being removed
    if(ecc.iFace2 != UNUSED) 
    {
        // link the two faces on the sides of iFace2 together, assume they exist of course
        if(ecc.iNFace21 != UNUSED) 
        {
            m_tmTriMesh.m_rgpniNeighbors[ecc.iNFace21].m_iNeighbors[ecc.iEdge21] = ecc.iNFace22;
        }
        if(ecc.iNFace22 != UNUSED) 
        {
            m_tmTriMesh.m_rgpniNeighbors[ecc.iNFace22].m_iNeighbors[ecc.iEdge22] = ecc.iNFace21;
        }
    
        for (iEdge = 0; iEdge < 3; iEdge++)
        {
            m_pheapCosts->Delete(m_rgfeiEdges[ecc.iFace2].m_rgpeiEdges[iEdge]);
            //delete m_rgfeiEdges[ecc.iFace2].m_rgpeiEdges[iEdge];
        }
    }



    wHead = m_tmTriMesh.WGetPointRep(ecc.iPoint1);
	if (ecc.iWedge11 != UNUSED)
	{
		wNewRep = ecc.iWedge11;
	}
	else if (ecc.iWedge21 != UNUSED) 
	{
		wNewRep = ecc.iWedge21;
	}
	else if (ecc.iWedgeRemove2 != ecc.iWedge12)
	{
		wNewRep = ecc.iWedge12;
	}
	else
	{
		GXASSERT(ecc.iWedgeRemove1 != ecc.iPoint1);
		wNewRep = ecc.iPoint1;
	}
    GXASSERT(wNewRep != UNUSED);

    wCur = wHead;
    do
    {
        pvPoint = m_cfvf.GetArrayElem(pvPoints, wCur);

        // update the position
        //m_cfvf.SetPosition(pvPoint, &ecc.vPositionNew);

        // update the representative points of the mesh
        m_tmTriMesh.m_rgwPointReps[wCur] = wNewRep;

        // go to next wedge in the vertex
        wCur = m_rgiWedgeList[wCur];
    } while (wCur != wHead);

    // now update the vertices/wedges of the two vertices together, modifying the 
    //  position at the same time
    wHead = m_tmTriMesh.WGetPointRep(ecc.iPoint2);
    wCur = wHead;
    do
    {
        pvPoint = m_cfvf.GetArrayElem(pvPoints, wCur);

        // update the representative points of the mesh
        m_tmTriMesh.m_rgwPointReps[wCur] = wNewRep;

        // update the position
        //m_cfvf.SetPosition(pvPoint, &ecc.vPositionNew);

        // go to next wedge in the vertex
        wCur = m_rgiWedgeList[wCur];
    } while (wCur != wHead);


    // merge wedges if necessary
    if (/*(ecc.iWedge11 == ecc.iWedgeL1) && */(ecc.iWedge12 == ecc.iWedgeL2)) 
    {
        iWedge = ecc.iWedge12;
        CFaceListIter<UINT_IDX,b16BitIndex,UNUSED> fli(ecc.iNFace12, iWedge, &m_tmTriMesh, x_iClockwise);
        while (!fli.BEndOfList())
        {
            iFace = fli.GetNextFace();
            iPoint = fli.IGetPointIndex();

            if (m_tmTriMesh.m_pFaces[iFace].m_wIndices[iPoint] != iWedge)
                break;

            m_tmTriMesh.m_pFaces[iFace].m_wIndices[iPoint] = ecc.iWedgeL1;
        }
    }



    // if there is a second face, and the wedge to be merged hasn't already been merged
    if ((ecc.iFace2 != UNUSED)  && (ecc.iWedgeRemove1 != ecc.iWedge22))
    {
        // NOTE: this has already been performed if there is only one wedge around R2
        if(/*(ecc.iWedge21 == ecc.iWedgeR1) && */(ecc.iWedge22 == ecc.iWedgeR2) && (m_rgiWedgeList[ecc.iWedge22] != ecc.iWedge22) )
        {
            iWedge = ecc.iWedge22;
            CFaceListIter<UINT_IDX,b16BitIndex,UNUSED> fli(ecc.iNFace22, iWedge, &m_tmTriMesh, x_iCounterClockwise);
            while (!fli.BEndOfList())
            {
                iFace = fli.GetNextFace();
                iPoint = fli.IGetPointIndex();

                if (m_tmTriMesh.m_pFaces[iFace].m_wIndices[iPoint] != iWedge)
                    break;

                m_tmTriMesh.m_pFaces[iFace].m_wIndices[iPoint] = ecc.iWedgeR1;
            }
        }

    }

    GXASSERT((ecc.iWedgeRemove1 != wNewRep) 
		&& (ecc.iWedgeRemove2 != wNewRep)
		&& (ecc.iWedgeRemove3 != wNewRep)
		&& (ecc.iWedgeRemove4 != wNewRep)
		&& (ecc.iWedgeRemove5 != wNewRep)
		&& (ecc.iWedgeRemove6 != wNewRep));


    // now merge to two lists and update the representative points
    //  UNDONE probably a more optimal solution

    wHead = ecc.iPoint2;
    wCur = wHead;
    do
    {
        // save of the next pointer, before overwriting it
        wNext = m_rgiWedgeList[wCur];

        // link the new point in just after the representative vertex
        m_rgiWedgeList[wCur] = m_rgiWedgeList[ecc.iPoint1];
        m_rgiWedgeList[ecc.iPoint1] = wCur;

        wCur = wNext;
    } while (wCur != wHead);

	// remove wedges that are no longer needed from the new wedge list
	RemoveWedgeElement(wNewRep, ecc.iWedgeRemove1, ecc.iMaterialLeft);
	RemoveWedgeElement(wNewRep, ecc.iWedgeRemove2, ecc.iMaterialLeft);
	RemoveWedgeElement(wNewRep, ecc.iWedgeRemove4, ecc.iMaterialRight);
	RemoveWedgeElement(wNewRep, ecc.iWedgeRemove5, ecc.iMaterialRight);

	// handle 3 and 6 separately, since they are on different wedges lists
	if (ecc.iWedgeRemove3 != UNUSED)
	{
		RemoveWedge(ecc.iWedgeRemove3, ecc.iMaterialLeft);
	}
	if (ecc.iWedgeRemove6 != UNUSED)
	{
		RemoveWedge(ecc.iWedgeRemove6, ecc.iMaterialRight);
	}

    // remove the faces from the mesh
    m_tmTriMesh.MarkAsUnused(ecc.iFace1);
    m_rgaeAttributeTableCur[ecc.iMaterialLeft].FaceCount -= 1;
    if (ecc.iFace2 != UNUSED)
    {
        m_tmTriMesh.MarkAsUnused(ecc.iFace2);
        m_rgaeAttributeTableCur[ecc.iMaterialRight].FaceCount -= 1;
    }

    return S_OK;
}

template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
void 
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::RemoveWedgeElement
    (
    UINT_IDX wHead, 
    UINT_IDX wElement, 
    UINT16 iMaterial
    )
{
	UINT_IDX wCur;
	UINT_IDX wNext;

	GXASSERT(wHead != wElement);

    if (wElement != UNUSED)
    {
        wCur = wHead;
        do
        {
            // save of the next pointer, before overwriting it
            wNext = m_rgiWedgeList[wCur];

		    // if found, remove from list and return
            if (wNext == wElement) 
		    {
			    m_rgiWedgeList[wCur] = m_rgiWedgeList[wNext];
			    m_rgiWedgeList[wNext] = wNext;
			    break;
		    }

            wCur = wNext;
        } while (wCur != wHead);

        // mark the vertex as being deleted for debug purposes
        m_rgbVertexDeleted[wElement] = 1;

        // maintain the attribute table vertex counts
        m_rgaeAttributeTableCur[iMaterial].VertexCount -= 1;

        m_cCurrentWedges -= 1;
    }
}

template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
void 
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::RemoveWedge
    (
    UINT_IDX wWedge, 
    UINT16 iMaterial
    )
{
	UINT_IDX wCur;
	UINT_IDX wHead;
	UINT_IDX wRep;

	wRep = m_tmTriMesh.WGetPointRep(wWedge);

	// if the wedge to be removed is the representative as well, jsut
	if (wRep == wWedge)
	{
		// get the new representative
		wRep = m_rgiWedgeList[wWedge];

		// had better be more than one wedge to be able to remove it
		GXASSERT(wRep != wWedge);

		wHead = wWedge;
		wCur = wHead;
		do
		{
			m_tmTriMesh.m_rgwPointReps[wCur] = wRep;

			wCur = m_rgiWedgeList[wCur];
		} while (wCur != wHead);
	}

	// now remove the element
	RemoveWedgeElement(wRep, wWedge, iMaterial);

}

// -------------------------------------------------------------------------------
//  function    UpdateVSplitAdjustments
//
//   devnote    Updates the face remap array and edge adjustment arrays
//                  required to fixup the vsplit elements that reference
//                  a face that has been collapsed (i.e. will be generated
//                  prior to being referenced).
//
//   returns    S_OK if success, failed otherwise
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::UpdateVSplitAdjustments
    (
    SEdgeCollapseContext<UINT_IDX> &ecc
    )
{
    // if no second face, then just setup the adjustment for face1
    if (ecc.iFace2 == UNUSED)
    {
        // current face indices already updated, so don't need to subtract one
        m_rgiFaceIndex[ecc.iFace1] = m_rgaeAttributeTableCur[ecc.iMaterialLeft].FaceStart + 
            (m_rgaeAttributeTableCur[ecc.iMaterialLeft].FaceCount);
            
        m_rgiEdgeAdjustment[ecc.iFace1] = x_rgiLeftFaceEdgeAdjustment[ecc.iEdge1];
    }
    else // else need to handle both face1 and face2, face2 should have a higher id
    {
        m_rgiEdgeAdjustment[ecc.iFace1] = x_rgiLeftFaceEdgeAdjustment[ecc.iEdge1];
        m_rgiEdgeAdjustment[ecc.iFace2] = x_rgiRightFaceEdgeAdjustment[ecc.iEdge2];

        // current face indices already updated, so don't need to subtract one
        m_rgiFaceIndex[ecc.iFace1] = m_rgaeAttributeTableCur[ecc.iMaterialLeft].FaceStart + 
            (m_rgaeAttributeTableCur[ecc.iMaterialLeft].FaceCount);

        // if same material, then one greater than left, otherwise it is last one in 
        //    other material
        if (ecc.iMaterialLeft == ecc.iMaterialRight)
        {
            m_rgiFaceIndex[ecc.iFace2] = m_rgiFaceIndex[ecc.iFace1] + 1;
        }
        else
        {
            m_rgiFaceIndex[ecc.iFace2] = m_rgaeAttributeTableCur[ecc.iMaterialRight].FaceStart + 
                (m_rgaeAttributeTableCur[ecc.iMaterialRight].FaceCount);
        }
    }

    return S_OK;
}

// -------------------------------------------------------------------------------
//  function    UpdateErrorMeasurements
//
//   devnote    Updates the entries in the heap that are changed by the
//                  edge collapse
//
//   returns    S_OK if success, failed otherwise
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT 
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::UpdateErrorMeasurements
    (
    SEdgeCollapseContext<UINT_IDX> &ecc, 
    PBYTE pvPoints
    )
{
    UINT_IDX iFacePresent;
    UINT_IDX iWedgePresent;

    // Moved from CalculateVSplitWads, could probably be simplified (if not removed)
    //  UNDONE UNDONE can this be removed?
    ecc.iWedge11 = (ecc.iNFace11 == UNUSED) ? UNUSED : m_tmTriMesh.m_pFaces[ecc.iNFace11].m_wIndices[ecc.iEdge11];
    ecc.iWedge12 = (ecc.iNFace12 == UNUSED) ? UNUSED : m_tmTriMesh.m_pFaces[ecc.iNFace12].m_wIndices[(ecc.iEdge12 + 1) % 3];
    if (ecc.iFace2 != UNUSED)
    {
        ecc.iWedge21 = (ecc.iNFace21 == UNUSED) ? UNUSED : m_tmTriMesh.m_pFaces[ecc.iNFace21].m_wIndices[(ecc.iEdge21 +1) % 3];
        ecc.iWedge22 = (ecc.iNFace22 == UNUSED) ? UNUSED : m_tmTriMesh.m_pFaces[ecc.iNFace22].m_wIndices[ecc.iEdge22];
    }

    // first figure out which of the faces is still present
    iFacePresent = UNUSED;
    if (ecc.iNFace11 != UNUSED) 
    {
        iFacePresent = ecc.iNFace11;
        iWedgePresent = ecc.iWedge11;
    }
    else if (ecc.iNFace12 != UNUSED) 
    {
        iFacePresent = ecc.iNFace12;
        iWedgePresent = ecc.iWedge12;
    }
    else if (ecc.iFace2 != UNUSED)
    {
        if (ecc.iNFace21 != UNUSED) 
        {
            iFacePresent = ecc.iNFace21;
            iWedgePresent = ecc.iWedge21;
        }
        else if (ecc.iNFace22 != UNUSED) 
        {
            iFacePresent = ecc.iNFace22;
            iWedgePresent = ecc.iWedge22;
        }
    }

    // if there are any triangles left around the collapsed vertex, update the error quadrics
    if (iFacePresent != UNUSED)
    {
#ifdef VERTEX_QUADRICS
        // if any wedges were removed, consolidate their error measurement into their representative
        if (ecc.iWedgeRemove1 != UNUSED)
        {
            m_rgqVertexQuadrics[m_tmTriMesh.WGetPointRep(ecc.iWedgeRemove1)] += m_rgqVertexQuadrics[ecc.iWedgeRemove1];
        }

        if (ecc.iWedgeRemove2 != UNUSED)
        {
            m_rgqVertexQuadrics[m_tmTriMesh.WGetPointRep(ecc.iWedgeRemove2)] += m_rgqVertexQuadrics[ecc.iWedgeRemove2];
        }

        if (ecc.iWedgeRemove3 != UNUSED)
        {
            m_rgqVertexQuadrics[m_tmTriMesh.WGetPointRep(ecc.iWedgeRemove3)] += m_rgqVertexQuadrics[ecc.iWedgeRemove3];
        }

        if (ecc.iWedgeRemove4 != UNUSED)
        {
            m_rgqVertexQuadrics[m_tmTriMesh.WGetPointRep(ecc.iWedgeRemove4)] += m_rgqVertexQuadrics[ecc.iWedgeRemove4];
        }

        if (ecc.iWedgeRemove5 != UNUSED)
        {
            m_rgqVertexQuadrics[m_tmTriMesh.WGetPointRep(ecc.iWedgeRemove5)] += m_rgqVertexQuadrics[ecc.iWedgeRemove5];
        }

        if (ecc.iWedgeRemove6 != UNUSED)
        {
            m_rgqVertexQuadrics[m_tmTriMesh.WGetPointRep(ecc.iWedgeRemove6)] += m_rgqVertexQuadrics[ecc.iWedgeRemove6];
        }

        RecalcEdgeQEMS_GH(ecc.iPoint1, ecc.iPoint2, iFacePresent, iWedgePresent, ecc.vPositionNew, pvPoints);
#elif 1
        RecalcEdgeQEMS_Plane(iFacePresent, iWedgePresent, pvPoints);
#else
        // hmmm Broken on flatsurf.m
        RecalcEdgeQEMS_MemoryLess(ecc.iPoint1, ecc.iPoint2, iFacePresent, ecc.vPositionNew, pvPoints);
#endif
    }

    return S_OK;
}
#ifdef _DEBUG

// -------------------------------------------------------------------------------
//  function    BFragmentedWedge
//
//   devnote    Helper function for BFragmentedWedges, verifys that the wedges
//                  around a given point are not fragmented
//
//   returns    true (and asserts) if fragmentation, false if no fragmentation
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
bool
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::BFragmentedWedge
    (
    UINT_IDX iInitialFace, 
    UINT_IDX wWedge, 
    UINT &cWedges, 
    UINT &cWedgesMax , 
    UINT_IDX *&rgiWedgesSeen
    )
{
    bool bRet = false;
    UINT_IDX wCurWedge;
    UINT_IDX wHeadWedge;
    UINT_IDX *pwFace;
    UINT_IDX iNextPoint;
    UINT_IDX iFace;

    cWedges = 0;
    CFaceListIter<UINT_IDX,b16BitIndex,UNUSED> fli(iInitialFace, wWedge, &m_tmTriMesh, x_iAllFaces);

    fli.MoveToCCWFace();

    // prime with the first face/wedge
    iFace = fli.GetNextFace();
    pwFace = m_tmTriMesh.m_pFaces[iFace].m_wIndices;
    wCurWedge = pwFace[fli.IGetPointIndex()];
	wHeadWedge = wCurWedge;

    // add the current wedge to the array of wedges seen
    if (!AddToDynamicArray(&rgiWedgesSeen, wCurWedge, &cWedges, &cWedgesMax))
    {
        GXASSERT(0);
        bRet = true;
        goto e_Exit;
    }

    // now look for the next face that has a different wedge
    //   and on the way update the wedge, if a new one was generated
    while (!fli.BEndOfList())
    {
        iFace = fli.GetNextFace();
        pwFace = m_tmTriMesh.m_pFaces[iFace].m_wIndices;

        iNextPoint = fli.IGetPointIndex();
        GXASSERT(iNextPoint < 3);

        // if a new wedge, see if in the array
        if (pwFace[iNextPoint] != wCurWedge)
        {
            wCurWedge = pwFace[iNextPoint];

            // if we have seen this before then we have fragmented wedges
            if (BInArray(rgiWedgesSeen, cWedges, wCurWedge))
            {
                // if it was the first wedge, then it is possible that we didn't
                //  start the search at the beginning of a wedge
                if (rgiWedgesSeen[0] == wCurWedge)
                {
                    // search the rest of the triangles, if we run out of triangles, then
                    //  the wedge is not fragmented
                    while (!fli.BEndOfList())
                    {
                        iFace = fli.GetNextFace();
                        pwFace = m_tmTriMesh.m_pFaces[iFace].m_wIndices;
                        iNextPoint = fli.IGetPointIndex();

                        // if not the first wedge, then assert that a fragment was found
                        if (pwFace[iNextPoint] != wCurWedge)
                        {
                            GXASSERT(0);

                            bRet = true;
                            goto e_Exit;
                        }
                    }

                }
                else  // not the first wedge, so it is definitely a fragmented wedge
                {
                    GXASSERT(0);

                    bRet = true;
                    goto e_Exit;
                }
            }

			// add the current wedge to the array of wedges seen
			if (!AddToDynamicArray(&rgiWedgesSeen, wCurWedge, &cWedges, &cWedgesMax))
			{
				GXASSERT(0);
				bRet = true;
				goto e_Exit;
			}
        }

    }

	// now that we know the wedges contained in triangles around the given vertex
	//   make sure that there are no extras in the wedge list
	wCurWedge = wHeadWedge;
    do
    {
		if (!BInArray(rgiWedgesSeen, cWedges, wCurWedge))
		{
			GXASSERT(0);
			bRet = true;
			goto e_Exit;
		}

        // go to next wedge in the vertex
        wCurWedge = m_rgiWedgeList[wCurWedge];
    } while (wCurWedge != wHeadWedge);

e_Exit:
    return bRet;
}

// -------------------------------------------------------------------------------
//  function    BFragmentedWedges
//
//   devnote    Asserts that there are no fragmented wedges
//
//   returns    true (and asserts) if fragmentation, false if no fragmentation
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
bool 
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::BFragmentedWedges()
{
    UINT_IDX iFace;
    UINT_IDX cFaces = m_tmTriMesh.m_cFaces;
    UINT_IDX iPoint;
    UINT_IDX wPointRep;
    UINT_IDX *rgiWedgesSeen = NULL;
    UINT_IDX wCurWedge;
    bool bRet = false;
    UINT cWedgesMax = 0;
    UINT cWedges = 0;
    UINT_IDX *pwFace;
    UINT ibVertexSeen;

    UINT_IDX iWedge;
    UINT_IDX wHead;
    UINT_IDX wCur;
    bool bFound;

    // seen array should be maintained as all zeros
    for (ibVertexSeen = 0; ibVertexSeen < m_tmTriMesh.m_cVertices; ibVertexSeen++)
    {
        GXASSERT(m_rgbVertexSeen[ibVertexSeen] == false);
    }

    for (iFace = 0; iFace < cFaces; iFace++)
    {
        pwFace = m_tmTriMesh.m_pFaces[iFace].m_wIndices;
        if (pwFace[0] == UNUSED)
            continue;

        for (iPoint = 0; iPoint < 3; iPoint++)
        {
            wCurWedge = pwFace[iPoint];
            wPointRep = m_tmTriMesh.WGetPointRep(wCurWedge);

            // if the vertex has not been seen, and it is not the same as the representative
            //   then check for fragmentation.  if it is the same as the representative and
            //   there are other wedges on the vertex, then other triangles with the vertex
            //   will succeed on this check
            if ((wPointRep != wCurWedge) && !m_rgbVertexSeen[wPointRep])
            {
                // in case another face points to this vertex, mark as seen to skip extra checks
                m_rgbVertexSeen[wPointRep] = true;

                bRet = BFragmentedWedge(iFace, wCurWedge, cWedges, cWedgesMax, rgiWedgesSeen);
                if (bRet)
                {
                    goto e_Exit;
                }

                for (iWedge=0; iWedge < cWedges; iWedge++)
                {

                    wHead = wPointRep;
                    wCur = wHead;
                    bFound = false;
                    do
                    {
                        if (wCur == rgiWedgesSeen[iWedge])
                        {
                            bFound = true;
                            break;
                        }

                        wCur = m_rgiWedgeList[wCur];
                    }
                    while (wHead != wCur);

                    GXASSERT(bFound);
                }
            }
        }
    }

e_Exit:
    // keep the array as zero, so it doesn't need to be cleared out per edge collapse
    memset(m_rgbVertexSeen, 0, m_tmTriMesh.m_cVertices * sizeof(BYTE));

    if (rgiWedgesSeen != NULL)
    {
        delete []rgiWedgesSeen;
    }

    return bRet;
}

// -------------------------------------------------------------------------------
//  function    BValid
//
//   devnote    Asserts that the mesh (both embedded and additional simplication info)
//                  are semantically correct.
//
//   returns    S_OK if successful, else failure code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
bool 
GXSimplifyMesh<UINT_IDX,b16BitIndex,UNUSED>::BValid() 
{ 
    UINT_IDX iFace;
    UINT_IDX cFaces = m_tmTriMesh.m_cFaces;
    UINT_IDX iPoint;
    UINT_IDX *pwFace;
    UINT_IDX iCurFace;
    UINT_IDX iVert;
    UINT_IDX wHead;
    UINT_IDX wCur;

    for (iVert = 0; iVert < m_tmTriMesh.m_cVertices; iVert++)
    {
        // if this is the representative of a vertex chain
        //   then check its wedge list
        if (m_tmTriMesh.WGetPointRep(iVert) == iVert)
        {
            wHead = iVert;
            wCur = iVert;
            do
            {
                GXASSERT(wCur < m_tmTriMesh.m_cVertices);
                GXASSERT(m_tmTriMesh.WGetPointRep(wCur) == iVert);

                wCur = m_rgiWedgeList[wCur];
            }
            while (wHead != wCur);
        }
    }

    if (m_pheapCosts != NULL)
    {
        GXASSERT(m_pheapCosts->BValid());
    }

    GXASSERT(!BFragmentedWedges());

    for (iFace = 0; iFace < cFaces; iFace++)
    {
        pwFace = m_tmTriMesh.m_pFaces[iFace].m_wIndices;

        if (pwFace[0] == UNUSED)
            continue;

        for (iPoint = 0; iPoint < 3; iPoint++)
        {
            CFaceListIter<UINT_IDX,b16BitIndex,UNUSED> fli(iFace, pwFace[iPoint], &m_tmTriMesh, x_iAllFaces);

            GXASSERT(!m_rgbVertexDeleted[pwFace[iPoint]]);

            while (!fli.BEndOfList())
            {
                iCurFace = fli.GetNextFace();
                GXASSERT(m_tmTriMesh.FindPoint(m_tmTriMesh.m_pFaces[iCurFace].m_wIndices, pwFace[iPoint]) < 3);
            }
        }
    }

    return m_tmTriMesh.BValid(); 
}
#endif

// -------------------------------------------------------------------------------
//  Implementation of CSimplificationHeap
// -------------------------------------------------------------------------------

// -------------------------------------------------------------------------------
//  function    Add
//
//   devnote    adds an edge to the priority heap
//
//   returns    S_OK if successful, else failure code
//
template <class UINT_IDX>
HRESULT 
CSimplificationHeap<UINT_IDX>::Add
    (
    CEdgeInfo<UINT_IDX> *peiInfo
    )
{
    GXASSERT(peiInfo->m_iEdge < 3);
    GXASSERT(!_isnan(peiInfo->DGetCost()));

    // add the element
    m_rgpeiHeap[m_cElements] = peiInfo;
    peiInfo->SetHeapIndex(m_cElements);

    m_cElements += 1;

    Adjust(m_cElements - 1, true, false);
    return S_OK;
}

// -------------------------------------------------------------------------------
//  function    Update
//
//   devnote    updates the priority of an edge in the heap.
//                  if the edge is currently not in the heap, it is added
//
//   returns    S_OK if successful, else failure code
//
template <class UINT_IDX>
HRESULT
CSimplificationHeap<UINT_IDX>::Update
    (
    CEdgeInfo<UINT_IDX> *peiInfo
    )
{
    UINT iElement;

    GXASSERT(peiInfo->m_iEdge < 3);
    GXASSERT(!_isnan(peiInfo->DGetCost()));

    iElement = peiInfo->IGetHeapIndex();
    if (iElement == UINT_MAX)
        return Add(peiInfo);
    else
    {
        Adjust(iElement, true, true);
    }

    return S_OK;
}

#ifdef _DEBUG
// -------------------------------------------------------------------------------
//  function    DebugDump
//
//   devnote    Dumps all info in the heap for debugging purposes
//
//   returns    S_OK if successful, else failure code
//
template <class UINT_IDX>
HRESULT
CSimplificationHeap<UINT_IDX>::DebugDump
    (
    NeighborInfo<UINT_IDX> *rgpniNeighbors
    )
{
    UINT iElement;
    CEdgeInfo<UINT_IDX> *peiEdgeInfo;
    UINT iNeighbor;
    UINT cElements;

    GXTRACE("Debug heap dump: %d elements\n", m_cElements);

    cElements = min(m_cElements, 40);

    for (iElement = 0; iElement < cElements; iElement++)
    {
        GXTRACE("Element #%d\n", iElement); 

        peiEdgeInfo = m_rgpeiHeap[iElement];
        GXTRACE("    Face %d  Edge %d  Cost %f\n",
                            peiEdgeInfo->m_wFace, peiEdgeInfo->m_iEdge, 
                            peiEdgeInfo->m_cost);
        if (rgpniNeighbors != NULL)
        {
            iNeighbor = rgpniNeighbors[peiEdgeInfo->m_wFace].m_iNeighbors[peiEdgeInfo->m_iEdge];
            GXTRACE("    Alt Face %d\n", iNeighbor);
        }

        GXTRACE("\n");
    }

    return S_OK;
}
#endif

// -------------------------------------------------------------------------------
//  function    Delete
//
//   devnote    Removes the given edge from the heap
//
//   returns    S_OK if successful, else failure code
//
template <class UINT_IDX>
HRESULT 
CSimplificationHeap<UINT_IDX>::Delete(CEdgeInfo<UINT_IDX> *peiInfo)
{
    UINT iElement;

    GXASSERT(peiInfo->m_iEdge < 3);
    iElement = peiInfo->IGetHeapIndex();

    if (iElement == UINT_MAX)
        return S_OK;

    // if not the last element, then switch with the last element, then remove last element
    if (iElement < (m_cElements - 1))
    {
        Switch(iElement, m_cElements - 1);
    }
    m_cElements -= 1;

    Adjust(iElement, true, true);

    peiInfo->SetHeapIndex(UINT_MAX);
    return S_OK;
}

// -------------------------------------------------------------------------------
//  function    PeiExtractMin
//
//   devnote    Removes the next edge with the lowest cost from the heap
//                  and updates the heap
//
//   returns    S_OK if successful, else failure code
//
template <class UINT_IDX>
CEdgeInfo<UINT_IDX> * 
CSimplificationHeap<UINT_IDX>::PeiExtractMin()
{
    CEdgeInfo<UINT_IDX> *peiRet;

    if (m_cElements == 0)
        return NULL;

    // returning the topmost node
    peiRet = m_rgpeiHeap[0];

    // move to tail of queue so it can be removed
    if (m_cElements > 1) 
    {
        Switch(0, m_cElements - 1);
    }

    m_cElements -= 1;
    
    // move the new head to its correct position
    if (m_cElements > 1) 
    {
        Adjust(0, false, true);
    }

    // set heap index to a known bad value
    peiRet->SetHeapIndex(UINT_MAX);
    GXASSERT(!_isnan(peiRet->DGetCost()));
    return peiRet;
}

// -------------------------------------------------------------------------------
//  function    Switch
//
//   devnote    swaps the position of two elements in the heap
//
template <class UINT_IDX>
void
CSimplificationHeap<UINT_IDX>::Switch
    (
    UINT iElement, 
    UINT iOtherElement
    )
{
    CEdgeInfo<UINT_IDX> *peiTemp;

    // swap the positions in the array
    peiTemp = m_rgpeiHeap[iElement];
    m_rgpeiHeap[iElement] = m_rgpeiHeap[iOtherElement];
    m_rgpeiHeap[iOtherElement] = peiTemp;

    // update the indexes in the edge elements
    m_rgpeiHeap[iOtherElement]->SetHeapIndex(iOtherElement);
    m_rgpeiHeap[iElement]->SetHeapIndex(iElement);
}

// -------------------------------------------------------------------------------
//  function    Adjust
//
//   devnote    Adjusts the given element to the proper position in the priority heap
//
template <class UINT_IDX>
void
CSimplificationHeap<UINT_IDX>::Adjust(UINT iElement, bool bUp, bool bDown)
{
    const float fPriority = m_rgpeiHeap[iElement]->DGetCost();

    UINT iNextElement = 0;
    UINT iLeftElement;
    UINT iRightElement;
    float fLeftPriority;
    float fRightPriority;


    for (;;Switch(iElement,iNextElement),iElement=iNextElement) 
    {
        // if can move up, see if the next element up has a lower priority
        //   than the element being adjusted
        if (bUp) 
        {
            iNextElement = (iElement - 1) / 2;
            if ((iElement > 0) && (fPriority < m_rgpeiHeap[iNextElement]->DGetCost())) 
                continue;
        }

        // only process this section if can try moving down
        //    otherwise done adjusting the node up
        if (!bDown) 
            break;

        // get the left node, if no left node then done, since hit bottom (can't have a right without a left)
        iLeftElement = (iElement * 2) + 1;           
        if (iLeftElement >= m_cElements) 
            break;    // no children

        fLeftPriority = m_rgpeiHeap[iLeftElement]->DGetCost();


        // get the right node, if no right node then hit bottom, but might need to switch with left
        iRightElement = (iElement * 2) + 2;           
        if (iRightElement >= m_cElements) 
        {
            // if the left has a lower priority, then we need to switch the two nodes
            //   otherwise done
            if (fLeftPriority < fPriority) 
            { 
                iNextElement = iLeftElement; 
                continue; 
            }
            break;
        }
        fRightPriority = m_rgpeiHeap[iRightElement]->DGetCost();

        // if left has a lower priority than fPriority and it is the lowest child, then 
        //   swap with it
        if ((fLeftPriority < fPriority) && (fLeftPriority < fRightPriority)) 
        { 
            iNextElement=iLeftElement; 
            continue; 
        }

        // else if the right is lower than the priority then switch with it
        if (fRightPriority < fPriority) 
        { 
            iNextElement=iRightElement; 
            continue; 
        }

        break;
    }

}

// -------------------------------------------------------------------------------
//  function    BValid
//
//   devnote    Asserts that the priority heap is maintained correctly
//
//   returns    true if the heap is valid, asserts if not
//
template <class UINT_IDX>
bool
CSimplificationHeap<UINT_IDX>::BValid()
{
    UINT iElement;
    UINT iLeftElement;
    UINT iRightElement;

    GXASSERT(m_cElements <= m_cElementsMax);

    for (iElement = 0; iElement < m_cElements; iElement++)
    {
        GXASSERT(!_isnan(m_rgpeiHeap[iElement]->DGetCost()));

        // should have the correct heap index
        GXASSERT(m_rgpeiHeap[iElement]->IGetHeapIndex() == iElement);
        GXASSERT(m_rgpeiHeap[iElement]->m_iEdge < 3);

        // verify that the priority of the current element is less than that of the left
        //      element
        iLeftElement = (iElement * 2) + 1;           
        if (iLeftElement < m_cElements) 
        {
            GXASSERT(m_rgpeiHeap[iElement]->DGetCost() <= m_rgpeiHeap[iLeftElement]->DGetCost());
        }


        // verify that the priority of the current element is less than that of the right
        //      element
        iRightElement = (iElement * 2) + 2;           
        if (iRightElement < m_cElements) 
        {
            GXASSERT(m_rgpeiHeap[iElement]->DGetCost() <= m_rgpeiHeap[iRightElement]->DGetCost());
        }
    }

    return true;
}

// -------------------------------------------------------------------------------
//  function    Init
//
//   devnote    initializes a heap with the given number of elements
//
//   returns    S_OK if successful, else failure code
//
template <class UINT_IDX>
HRESULT
CSimplificationHeap<UINT_IDX>::Init
    (
    UINT cElements
    )
{
    HRESULT hr = S_OK;

    delete []m_rgpeiHeap;
    m_cElements = 0;

    m_rgpeiHeap = new CEdgeInfo<UINT_IDX>*[cElements];
    if (m_rgpeiHeap == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    m_cElementsMax = cElements;

e_Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\mesh\tri3drawmesh.inl ===
/*//////////////////////////////////////////////////////////////////////////////
//
// File: tri3drawmesh.cpp
//
// Copyright (C) 1999 Microsoft Corporation. All Rights Reserved.
//
// @@BEGIN_MSINTERNAL
//
// History:
// -@-          (craigp)    - created 
// -@- 08/06/99 (mikemarr)  - prepend GX to all Luciform functions
//                          - started comment history
// -@- 08/19/99 (mikemarr)  - prepend GX to gxfmath functions
//
// @@END_MSINTERNAL
//
//////////////////////////////////////////////////////////////////////////////*/

// -------------------------------------------------------------------------------
//  function    DrawSubset
//
//   devnote    draws all the triangles in the mesh with the given attribute bundle
//                  NOTE: does NOT transform the vertices, assumes that it was done
//                      with a call to TransformVertices
//
//   returns    S_OK if success, failed otherwise
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT
GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED>::DrawSubset(DWORD attribId)
{
    HRESULT hr = S_OK;
    UINT iFace;
    UINT cTris;
    UINT iae;
    //DWORD dwVOP;
    PBYTE pbVerticesSrc = NULL;

    GXASSERT(m_pFaces == NULL);

    if (b16BitIndex)
    {
        // if no vertices, just return ok
        if (m_pVBVertices == NULL)
        {
            GXASSERT((m_cVertices == 0) && (m_cFaces == 0));
            goto e_Exit;
        }

        m_pD3DDevice->SetVertexShader(m_dwFVF);
        m_pD3DDevice->SetStreamSource(0, m_pVBVertices, m_cBytesPerVertex);
        m_pD3DDevice->SetIndices(m_pibFaces, 0);

        // if optimized, jump straight to the triangles of the given attribute bundle
        if (m_dwOptionsInt & D3DXMESHINT_ATTRIBUTETABLE)
        {

            if ((attribId < m_caeAttributeTable) && (m_rgaeAttributeTable[attribId].AttribId == attribId))
            {
                iae = attribId;
            }
            else
            {
                // look for the correct attribute table entry to draw
                for (iae = 0; iae < m_caeAttributeTable; iae++)
                {
                    if (m_rgaeAttributeTable[iae].AttribId == attribId)
                    {
                        break;
                    }
                }
            }

            // if present in the table, then draw it
            if ((iae < m_caeAttributeTable) && (m_rgaeAttributeTable[iae].FaceCount > 0))
            {

                m_pD3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 
                                             m_rgaeAttributeTable[iae].VertexStart, m_rgaeAttributeTable[iae].VertexCount,
                                             m_rgaeAttributeTable[iae].FaceStart * 3, m_rgaeAttributeTable[iae].FaceCount);

            }
        }
        else  // have to work around holes and triangles with a different attribute bundle than the one to draw
        {
            cTris = 0;
            for (iFace = 0; iFace < m_cFaces; iFace++)
            {
                // if not UINT max, then a triangle is present
                if (/*(m_pFaces[iFace].m_wIndices[0] != UNUSED) && */(m_rgiAttributeIds[iFace] == attribId))
                {
                    // add one to the count of tris in this "list"
                    cTris += 1;
                }
                else // found a "hole", draw any triangles and reset the counters
                {
                    // if there are any triangles, then draw them
                    if (cTris > 0)
                    {
                        m_pD3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 
                                                     0, m_cVertices,
                                                     (iFace - cTris) * 3, cTris);
                    }

                    cTris = 0;
                    GXASSERT( /*(m_pFaces[iFace].m_wIndices[0] == UNUSED) || */(m_rgiAttributeIds[iFace] != attribId));
                }
            }

            // draw the last set of triangles
            if (cTris  > 0)
            {
                m_pD3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 
                                             0, m_cVertices,
                                             (iFace - cTris) * 3, cTris);
            }
        }
    }
    else // 32 bit indices
    {
        //UNDONE UNDONE could make faster by gathering into one larger buffer,
        //                  but that is unnecessary once we have 32 bit index buffer


        // if no vertices, just return ok
        if (m_pVBVertices == NULL)
        {
            GXASSERT((m_cVertices == 0) && (m_cFaces == 0));
            goto e_Exit;
        }

        m_pD3DDevice->SetVertexShader(m_dwFVF);

        UINT_IDX *pwFace;
        bool bBracketed = false;
        UINT iStartFace = 0;
        UINT iEndFace = m_cFaces;
        UINT iStartVertex = 0;
        UINT iEndVertex = m_cVertices;

        PBYTE pbVertices;
        PBYTE pbCur;

        pbVertices = (PBYTE)_alloca(m_cBytesPerVertex * 3);

        if (BHasAttributeTable())
        {
            // look for the correct attribute table entry to draw
            for (iae = 0; iae < m_caeAttributeTable; iae++)
            {
                if (m_rgaeAttributeTable[iae].AttribId == attribId)
                {
                    break;
                }
            }

            // if not present, then just return
            if (iae == m_caeAttributeTable)
                return S_OK;

            iStartFace = m_rgaeAttributeTable[iae].FaceStart;
            iEndFace = m_rgaeAttributeTable[iae].FaceCount;
            iStartVertex = m_rgaeAttributeTable[iae].VertexStart;
            iEndVertex = m_rgaeAttributeTable[iae].VertexCount;

            bBracketed = true;
        }

        hr = LockVB(&pbVerticesSrc);
        if (FAILED(hr))
            goto e_Exit;

        hr = LockIB((PBYTE*)&m_pFaces);
        if (FAILED(hr))
            goto e_Exit;


        for (iFace = iStartFace; iFace < iEndFace; iFace++)
        {
            pwFace = m_pFaces[iFace].m_wIndices;

            GXASSERT(pwFace[0] != UNUSED);

            if (!bBracketed && m_rgiAttributeIds[iFace] != attribId)
                continue;

            pbCur = pbVertices;
            memcpy(pbCur, pbVerticesSrc + pwFace[0] * m_cBytesPerVertex, m_cBytesPerVertex);
            pbCur += m_cBytesPerVertex;
            memcpy(pbCur, pbVerticesSrc + pwFace[1] * m_cBytesPerVertex, m_cBytesPerVertex);
            pbCur += m_cBytesPerVertex;
            memcpy(pbCur, pbVerticesSrc + pwFace[2] * m_cBytesPerVertex, m_cBytesPerVertex);
            pbCur += m_cBytesPerVertex;
        
            hr = m_pD3DDevice->DrawPrimitiveUP(D3DPT_TRIANGLELIST, 1, pbVertices, m_cBytesPerVertex);
            if (FAILED(hr))
                goto e_Exit;                
        }
    }

e_Exit:
    if (!b16BitIndex)
    {
        if (pbVerticesSrc != NULL)
        {
            UnlockVB();
        }

        if (m_pFaces != NULL)
        {
            UnlockIB();
            m_pFaces = NULL;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\mesh\tri3mesh.inl ===
// identifier was truncated to '255' characters in the browser information
#pragma warning(disable: 4786)

/*
 * Template routine to handle dynamic allocation, based on Heap* Win32 APIs.
 *
 *  T **ppBase: base of array.
 *  const T& obj: object to add to end of array.
 *  UINT *pcNum: number of objects in array.
 *  UINT *pcMax: max. number of objects in array.
 *
 * ppBase, pcNum and pcMax point to values that usually get modified
 * by the call. The only case when they are not updated is if there
 * is insufficient memory for the initial allocation (if *pBase is NULL)
 * or a second allocation if *pcNum==*pcMax.
 *
 * Return value: TRUE if allocation was successful
 *               FALSE if there was insufficient memory
 *      FALSE means nothing was added to the array, but nothing
 *        was lost either. No weird realloc semantics allowed!
 */
template<class T>
BOOL
AddToDynamicArray( T **ppBase, const T& obj, UINT *pcNum, UINT *pcMax )
{
    T *pBase = *ppBase;
    if ( ! pBase )
    {
        HeapValidate( GetProcessHeap(), 0, NULL );
        pBase = new T[2];
        if ( ! pBase )
            return FALSE;

        *pcNum = 0;
        *pcMax = 2;
    }
    if ( *pcNum == *pcMax )
    {
        T *newarr = new T[*pcMax*2];
        if ( ! newarr )
            return FALSE;
        for (UINT i = 0; i < *pcNum; i++)
            newarr[i] = pBase[i];
        *pcMax *= 2;
        delete []pBase;
        pBase = newarr;
    }
    pBase[ (*pcNum)++ ] = obj;
    *ppBase = pBase;
    return TRUE;
}

/*
 * Template routine to handle dynamic allocation, based on Heap* Win32 APIs.
 *
 *  T **ppBase: base of array.
 *  UINT cNewMax:  size to grow the array to
 *  UINT *pcMax: max. number of objects in array.
 *
 * ppBase, pcNum and pcMax point to values that usually get modified
 * by the call. The only case when they are not updated is if there
 * is insufficient memory for the initial allocation (if *pBase is NULL)
 * or a second allocation if *pcNum==*pcMax.
 *
 * Return value: TRUE if allocation was successful
 *               FALSE if there was insufficient memory
 *      FALSE means nothing was added to the array, but nothing
 *        was lost either. No weird realloc semantics allowed!
 */
template<class T>
BOOL
ResizeDynamicArray( T **ppBase, UINT cNewMax, UINT cCur, UINT *pcMax )
{
    T *pBase = *ppBase;
    if ( ! pBase )
    {
        HeapValidate( GetProcessHeap(), 0, NULL );
        pBase = new T[cNewMax];
        *pcMax = cNewMax;
    }
    else if ( cNewMax > *pcMax )
    {
        T *newarr = new T[cNewMax];
        if ( ! newarr )
            return FALSE;
        for (UINT i = 0; i < cCur; i++)
            newarr[i] = pBase[i];
        *pcMax = cNewMax;
        delete []pBase;
        pBase = newarr;
    }
    *ppBase = pBase;
    return TRUE;
}

inline DWORD
TransformedFVF( DWORD dwFVF )
{
    dwFVF &= ~(D3DFVF_POSITION_MASK | D3DFVF_NORMAL);
    dwFVF |= D3DFVF_XYZRHW;
    dwFVF |= D3DFVF_DIFFUSE;    // always need diffuse in output
    dwFVF |= D3DFVF_SPECULAR;
    return dwFVF;
}

inline DWORD
FVFSize( DWORD dwFVF )
{
    DXCrackFVF cfvfTemp(dwFVF);

    return cfvfTemp.m_cBytesPerVertex;
}

template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED>::GXTri3Mesh(LPDIRECT3DDEVICE8 pD3DDevice, DWORD dwFVF, DWORD dwOptions)
    :m_dwFVF(dwFVF),
    m_dwOptions(dwOptions),
    m_dwOptionsInt(D3DXMESHINT_ATTRIBID),
    m_pD3D(NULL),
    m_pD3DDevice(NULL),
    m_pVBVertices(NULL),
    m_cBytesPerVertex(FVFSize(dwFVF)),
    m_cVertices(0),
    m_cMaxVertices(0),
    m_pibFaces(NULL),
    m_pFaces(0),
    m_cFaces(0),
    m_cMaxFaces(0),
    m_rgpniNeighbors(NULL),
    m_rgiAttributeIds(NULL),
    m_rgiMaterialIndex(NULL),
    m_rgaeAttributeTable(NULL),
    m_caeAttributeTable(0),
    m_rgwPointReps(NULL),
    m_cRef(1),
    m_punkOuter(NULL)
{
    m_pD3DDevice = pD3DDevice;

    // IB settings
    m_dwPoolIB = D3DPOOL_DEFAULT;
    m_dwUsageIB = 0;
    if (m_dwOptions & D3DXMESH_IB_MANAGED)
        m_dwPoolIB  = D3DPOOL_MANAGED;
    if (m_dwOptions & D3DXMESH_IB_SYSTEMMEM)
        m_dwPoolIB  = D3DPOOL_SYSTEMMEM;
    if (m_dwOptions & D3DXMESH_IB_WRITEONLY)
        m_dwUsageIB |= D3DUSAGE_WRITEONLY;
    if (m_dwOptions & D3DXMESH_POINTS)
        m_dwUsageIB |= D3DUSAGE_POINTS;
    if (m_dwOptions & D3DXMESH_RTPATCHES)
        m_dwUsageIB |= D3DUSAGE_RTPATCHES;
    if (m_dwOptions & D3DXMESH_IB_DYNAMIC)
        m_dwUsageIB |= D3DUSAGE_DYNAMIC;


    // VB settings
    m_dwPoolVB = D3DPOOL_DEFAULT;
    m_dwUsageVB = 0;
    if (m_dwOptions & D3DXMESH_VB_MANAGED)
        m_dwPoolVB  = D3DPOOL_MANAGED;
    if (m_dwOptions & D3DXMESH_VB_SYSTEMMEM)
        m_dwPoolVB  = D3DPOOL_SYSTEMMEM;
    if (m_dwOptions & D3DXMESH_VB_WRITEONLY)
        m_dwUsageVB |= D3DUSAGE_WRITEONLY;
    if (m_dwOptions & D3DXMESH_POINTS)
        m_dwUsageVB |= D3DUSAGE_POINTS;
    if (m_dwOptions & D3DXMESH_RTPATCHES)
        m_dwUsageVB |= D3DUSAGE_RTPATCHES;
    if (m_dwOptions & D3DXMESH_VB_DYNAMIC)
        m_dwUsageVB |= D3DUSAGE_DYNAMIC;

    if (m_dwOptions & D3DXMESH_VB_SHARE)
        m_dwOptionsInt |= D3DXMESHINT_SHAREDVB;


    m_pD3DDevice->AddRef();

    m_pD3DDevice->GetDirect3D(&m_pD3D);
}

template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED>::~GXTri3Mesh()
{
    GXRELEASE(m_pD3D);
    GXRELEASE(m_pD3DDevice);

    GXRELEASE(m_pVBVertices);

    GXRELEASE(m_pibFaces);

    delete []m_rgpniNeighbors;
    delete []m_rgiAttributeIds;
    delete []m_rgiMaterialIndex;
    delete []m_rgaeAttributeTable;
    delete []m_rgwPointReps;
}

// -------------------------------------------------------------------------------
//  method    CreateEmptyMesh
//
//  devnote
//              "empties" the mesh, but does not free the memory allocated
//                  for the various arrays
//
//  returns     S_OK if suceeded, else error code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT
GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED>::CreateEmptyMesh()
{
    m_dwOptionsInt &= ~D3DXMESHINT_ATTRIBUTETABLE;

    // zero out all counts
    m_cVertices = 0;
    m_cFaces = 0;

    return S_OK;
}

// -------------------------------------------------------------------------------
//  method    CloneHelper32
//
//  devnote
//            Shared code between GXTri3Mesh::CloneMesh and PMesh::ClonePMesh
//
//  returns     S_OK if suceeded, else error code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT
GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED>::CloneHelper32(
                GXTri3Mesh<tp32BitIndex> *ptmNewMesh32 )
{
    HRESULT hr = S_OK;
    UINT *pwFace32Dest;
    UINT_IDX *pwFace32Src;
    UINT iPoint;
    UINT iFace;

    GXTri3Face<UINT_IDX> *pwFacesSrc = NULL;
    GXTri3Face<UINT> *pwFacesDest = NULL;

   // now setup all internal data
    ptmNewMesh32->m_dwOptionsInt = (m_dwOptionsInt & (~D3DXMESHINT_SHAREDVB))  | (ptmNewMesh32->m_dwOptionsInt & D3DXMESHINT_SHAREDVB);

    hr = ptmNewMesh32->Resize(m_cFaces, m_cVertices);
    if (FAILED(hr))
        goto e_Exit;

    hr = ptmNewMesh32->LockIB((PBYTE*)&pwFacesDest);
    if (FAILED(hr))
        goto e_Exit;

    hr = LockIB((PBYTE*)&pwFacesSrc);
    if (FAILED(hr))
        goto e_Exit;

    if (BHasPerFaceAttributeId())
        memcpy(ptmNewMesh32->m_rgiAttributeIds, m_rgiAttributeIds, m_cFaces * sizeof(DWORD));

    if (BHasPerFaceAttributeIndex())
        memcpy(ptmNewMesh32->m_rgiMaterialIndex, m_rgiMaterialIndex, m_cFaces * sizeof(WORD));

    // copy the attribute table if present
    if (m_rgaeAttributeTable != NULL)
    {
        ptmNewMesh32->m_rgaeAttributeTable = new D3DXATTRIBUTERANGE[m_caeAttributeTable];
        if (ptmNewMesh32->m_rgaeAttributeTable == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }

        memcpy(ptmNewMesh32->m_rgaeAttributeTable, m_rgaeAttributeTable,
                            m_caeAttributeTable * sizeof(D3DXATTRIBUTERANGE));

        ptmNewMesh32->m_caeAttributeTable = m_caeAttributeTable;
    }

    // copy/convert the indices
    for (iFace = 0; iFace < m_cFaces; iFace++)
    {
        pwFace32Dest = pwFacesDest[iFace].m_wIndices;
        pwFace32Src = pwFacesSrc[iFace].m_wIndices;
        for (iPoint = 0; iPoint < 3; iPoint++)
        {
            if (pwFace32Src[iPoint] != UNUSED)
                pwFace32Dest[iPoint] = pwFace32Src[iPoint];
            else
                pwFace32Dest[iPoint] = UNUSED32;
        }
    }

    if (BHasNeighborData())
    {
        // copy the neighbor data
        for (iFace = 0; iFace < m_cFaces; iFace++)
        {
            pwFace32Dest = ptmNewMesh32->m_rgpniNeighbors[iFace].m_iNeighbors;
            pwFace32Src = m_rgpniNeighbors[iFace].m_iNeighbors;
            for (iPoint = 0; iPoint < 3; iPoint++)
            {
                if (pwFace32Src[iPoint] != UNUSED)
                    pwFace32Dest[iPoint] = pwFace32Src[iPoint];
                else
                    pwFace32Dest[iPoint] = UNUSED32;
            }
        }
    }

e_Exit:
    if (pwFacesSrc != NULL)
    {
        UnlockIB();
    }
    if (pwFacesDest != NULL)
    {
        ptmNewMesh32->UnlockIB();
    }

    return hr;
}

// -------------------------------------------------------------------------------
//  method    CloneHelper16
//
//  devnote
//            Shared code between GXTri3Mesh::CloneMesh and PMesh::ClonePMesh
//
//  returns     S_OK if suceeded, else error code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT
GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED>::CloneHelper16(
                GXTri3Mesh<tp16BitIndex> *ptmNewMesh16 )
{
    HRESULT hr = S_OK;
    UINT16 *pwFace16Dest;
    UINT_IDX *pwFace16Src;
    UINT iPoint;
    UINT iFace;

    GXTri3Face<UINT_IDX> *pwFacesSrc = NULL;
    GXTri3Face<UINT16> *pwFacesDest = NULL;

    // now setup all internal data
    ptmNewMesh16->m_dwOptionsInt = (m_dwOptionsInt & (~D3DXMESHINT_SHAREDVB)) | (ptmNewMesh16->m_dwOptionsInt & D3DXMESHINT_SHAREDVB);

    hr = ptmNewMesh16->Resize(m_cFaces, m_cVertices);
    if (FAILED(hr))
        goto e_Exit;

    hr = ptmNewMesh16->LockIB((PBYTE*)&pwFacesDest);
    if (FAILED(hr))
        goto e_Exit;

    hr = LockIB((PBYTE*)&pwFacesSrc);
    if (FAILED(hr))
        goto e_Exit;

    if (BHasPerFaceAttributeId())
        memcpy(ptmNewMesh16->m_rgiAttributeIds, m_rgiAttributeIds, m_cFaces * sizeof(DWORD));

    if (BHasPerFaceAttributeIndex())
        memcpy(ptmNewMesh16->m_rgiMaterialIndex, m_rgiMaterialIndex, m_cFaces * sizeof(WORD));

    // copy the attribute table if present
    if (m_rgaeAttributeTable != NULL)
    {
        ptmNewMesh16->m_rgaeAttributeTable = new D3DXATTRIBUTERANGE[m_caeAttributeTable];
        if (ptmNewMesh16->m_rgaeAttributeTable == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }

        memcpy(ptmNewMesh16->m_rgaeAttributeTable, m_rgaeAttributeTable,
                            m_caeAttributeTable * sizeof(D3DXATTRIBUTERANGE));

        ptmNewMesh16->m_caeAttributeTable = m_caeAttributeTable;
    }

    // copy/convert the indices
    for (iFace = 0; iFace < m_cFaces; iFace++)
    {
        pwFace16Dest = pwFacesDest[iFace].m_wIndices;
        pwFace16Src = pwFacesSrc[iFace].m_wIndices;
        for (iPoint = 0; iPoint < 3; iPoint++)
        {
            if (pwFace16Src[iPoint] != UNUSED)
                pwFace16Dest[iPoint] = pwFace16Src[iPoint];
            else
                pwFace16Dest[iPoint] = UNUSED16;
        }
    }

    if (BHasNeighborData())
    {
        // copy the neighbor data
        for (iFace = 0; iFace < m_cFaces; iFace++)
        {
            pwFace16Dest = ptmNewMesh16->m_rgpniNeighbors[iFace].m_iNeighbors;
            pwFace16Src = m_rgpniNeighbors[iFace].m_iNeighbors;
            for (iPoint = 0; iPoint < 3; iPoint++)
            {
                if (pwFace16Src[iPoint] != UNUSED)
                    pwFace16Dest[iPoint] = pwFace16Src[iPoint];
                else
                    pwFace16Dest[iPoint] = UNUSED16;
            }
        }
    }

e_Exit:
    if (pwFacesSrc != NULL)
    {
        UnlockIB();
    }
    if (pwFacesDest != NULL)
    {
        ptmNewMesh16->UnlockIB();
    }

    return hr;
}



// -------------------------------------------------------------------------------
//  method    CloneVertexBuffer
//
//  devnote
//            Copies the vertex buffer, does FVF conversion if required
//
//  returns     S_OK if suceeded, else error code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT
GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED>::CloneVertexBuffer
    (
    DWORD dwFVFNew, 
    LPDIRECT3DVERTEXBUFFER8 pVertexBuffer
    )
{
    HRESULT hr = S_OK;
    PBYTE pvPointsDest = NULL;
    PBYTE pvPointsSrc = NULL;
    UINT iVertex;

    // had better not be shared
    GXASSERT(pVertexBuffer != m_pVBVertices);

    hr = pVertexBuffer->Lock(0,0, &pvPointsDest, 0 );
    if (FAILED(hr))
        goto e_Exit;

    hr = LockVB(&pvPointsSrc);
    if (FAILED(hr))
        goto e_Exit;

    // if the same FVF, just copy all the vertices
    if (dwFVFNew == m_dwFVF)
    {
        memcpy(pvPointsDest, pvPointsSrc, m_cVertices * m_cBytesPerVertex);
    }
    else
    {
        PBYTE pvCurPointSrc;
        PBYTE pvCurPointDest;
        SVertexCopyContext vcc(m_dwFVF, dwFVFNew);

        pvCurPointSrc = (PBYTE)pvPointsSrc;
        pvCurPointDest = (PBYTE)pvPointsDest;
        for (iVertex = 0; iVertex < m_cVertices; iVertex++)
        {
            vcc.CopyVertex(pvCurPointSrc, pvCurPointDest);

            pvCurPointSrc += vcc.cfvfSrc.m_cBytesPerVertex;
            pvCurPointDest += vcc.cfvfDest.m_cBytesPerVertex;
        }
    }

e_Exit:
    if (pvPointsDest != NULL)
    {
        GXASSERT(pVertexBuffer != NULL);
        pVertexBuffer->Unlock();
    }

    if (pvPointsSrc != NULL)
    {
        UnlockVB();
    }

    return hr;
}

// -------------------------------------------------------------------------------
//  method    Clone (external version)
//
//  devnote
//            Makes an exact copy of the given mesh in the current mesh
//
//  returns     S_OK if suceeded, else error code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT
GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED>::CloneMesh(
                DWORD dwOptionsNew, CONST DWORD *pDeclaration,
                LPDIRECT3DDEVICE8 pD3DDevice, LPD3DXMESH* ppCloneMesh )
{
    DWORD dwFVF;
    HRESULT hr;

    if (pDeclaration == NULL)
    {
        dwFVF = m_dwFVF;
    }
    else
    {
        hr = D3DXFVFFromDeclarator(pDeclaration, &dwFVF);
        if (FAILED(hr))
        {
            DPF(0,"CloneMesh: Declaration cannot be converted to FVF");
            return hr;
        }
    }

    return CloneMeshFVF(dwOptionsNew, dwFVF, pD3DDevice, ppCloneMesh);
}

// -------------------------------------------------------------------------------
//  method    Clone (external version)
//
//  devnote
//            Makes an exact copy of the given mesh in the current mesh
//
//  returns     S_OK if suceeded, else error code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT
GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED>::CloneMeshFVF(
                DWORD dwOptionsNew, DWORD dwFVFNew,
                LPDIRECT3DDEVICE8 pD3DDevice, LPD3DXMESH* ppCloneMesh )
{
    HRESULT hr = S_OK;
    GXTri3Mesh<tp32BitIndex> *ptmNewMesh32 = NULL;
    GXTri3Mesh<tp16BitIndex> *ptmNewMesh16 = NULL;
    ID3DXMesh *ptmNewMesh = NULL;
    LPDIRECT3DVERTEXBUFFER8 pVertexBuffer;

    // untested code
    //GXASSERT(0);

    if ((dwOptionsNew & ~D3DXMESH_VALIDCLONEBITS) != 0)
    {
        hr = D3DERR_INVALIDCALL;
        DPF(0, "CloneMeshFVF: Invalid options bit passed to CloneMesh\n");
        goto e_Exit;
    }

    if ((dwOptionsNew & D3DXMESH_VB_SHARE) && (dwFVFNew != m_dwFVF))
    {
        hr = D3DERR_INVALIDCALL;
        DPF(0, "CloneMeshFVF: VB_SHARE can only be specified if both meshes have identical FVF\n");
        goto e_Exit;
    }

    if ((dwOptionsNew & D3DXMESH_VB_SHARE) && (pD3DDevice != m_pD3DDevice))
    {
        hr = D3DERR_INVALIDCALL;
        DPF(0, "CloneMeshFVF: VB_SHARE can only be specified if both meshes share the same device\n");
        goto e_Exit;
    }


    if (dwOptionsNew & D3DXMESH_32BIT)
    {
        ptmNewMesh32 = new GXTri3Mesh<tp32BitIndex>(pD3DDevice, dwFVFNew, dwOptionsNew);

        if (ptmNewMesh32 == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }

        hr = CloneHelper32(ptmNewMesh32);
        if (FAILED(hr))
            goto e_Exit;

        if (dwOptionsNew & D3DXMESH_VB_SHARE)
        {
            // mark this mesh as shared as well
            m_dwOptionsInt |= D3DXMESHINT_SHAREDVB;
            GXASSERT(ptmNewMesh32->BSharedVB());

            // share the vertex buffer from this mesh with the other mesh
            ptmNewMesh32->m_pVBVertices = m_pVBVertices;
            m_pVBVertices->AddRef();
        }

        pVertexBuffer = ptmNewMesh32->m_pVBVertices;
        ptmNewMesh = ptmNewMesh32;
        ptmNewMesh32 = NULL;
    }
    else
    {
        if ((m_cFaces > UNUSED16) || (m_cVertices > UNUSED16))
        {
            hr = D3DERR_INVALIDCALL;
            goto e_Exit;
        }

        ptmNewMesh16 = new GXTri3Mesh<tp16BitIndex>(pD3DDevice, dwFVFNew, dwOptionsNew);
        if (ptmNewMesh16 == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }

        hr = CloneHelper16(ptmNewMesh16);
        if (FAILED(hr))
            goto e_Exit;

        if (dwOptionsNew & D3DXMESH_VB_SHARE)
        {
            // mark this mesh as shared as well
            m_dwOptionsInt |= D3DXMESHINT_SHAREDVB;
            GXASSERT(ptmNewMesh16->BSharedVB());

            // share the vertex buffer from this mesh with the other mesh
            ptmNewMesh16->m_pVBVertices = m_pVBVertices;
            m_pVBVertices->AddRef();
        }

        pVertexBuffer = ptmNewMesh16->m_pVBVertices;
        ptmNewMesh = ptmNewMesh16;
        ptmNewMesh16 = NULL;
    }

    // only do a copy if the VBs aren't shared
    if ( !(dwOptionsNew & D3DXMESH_VB_SHARE))
    {
        // now that the internals and face index data are loaded, load/convert the vertex data
        hr = CloneVertexBuffer(dwFVFNew, pVertexBuffer);
        if (FAILED(hr))
            goto e_Exit;
    }

    *ppCloneMesh = ptmNewMesh;
    ptmNewMesh = NULL;

e_Exit:
    GXRELEASE(ptmNewMesh);
    GXRELEASE(ptmNewMesh16);
    GXRELEASE(ptmNewMesh32);

    return hr;
}


// -------------------------------------------------------------------------------
//  method    CopyMesh (internal)
//
//  devnote
//            Makes an exact copy of the given mesh in the current mesh
//                  No FVF or index size changes possible
//
//  returns     S_OK if suceeded, else error code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT
GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED>::CopyMesh(
                GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED> *ptmSrc)
{
    HRESULT hr = S_OK;

    PBYTE pvPointsDest = NULL;
    PBYTE pvPointsSrc = NULL;

    UINT_IDX *pwFacesSrc = NULL;
    UINT_IDX *pwFacesDest = NULL;

    // both meshes should be the same size
    GXASSERT((ptmSrc->m_cVertices == m_cVertices) || (m_cVertices == 0));
    GXASSERT(ptmSrc->m_cFaces == m_cFaces);
    GXASSERT((ptmSrc->m_dwFVF == m_dwFVF) || (m_cVertices == 0));
    GXASSERT((ptmSrc->m_dwOptions &~(D3DXMESH_SYSTEMMEM|D3DXMESH_VB_SHARE))== (m_dwOptions &~(D3DXMESH_SYSTEMMEM|D3DXMESH_VB_SHARE)));

    hr = LockIB((PBYTE*)&pwFacesDest);
    if (FAILED(hr))
        goto e_Exit;

    hr = ptmSrc->LockIB((PBYTE*)&pwFacesSrc);
    if (FAILED(hr))
        goto e_Exit;

    memcpy(pwFacesDest, pwFacesSrc, sizeof(GXTri3Face<UINT_IDX>) * m_cFaces);

    if (BHasNeighborData() && ptmSrc->BHasNeighborData())
    {
        memcpy(m_rgpniNeighbors, ptmSrc->m_rgpniNeighbors, sizeof(NeighborInfo<UINT_IDX>) * m_cFaces);
    }

    if (BHasPerFaceAttributeId() && ptmSrc->BHasPerFaceAttributeId())
    {
        memcpy(m_rgiAttributeIds, ptmSrc->m_rgiAttributeIds, sizeof(DWORD) * m_cFaces);
    }

    if (BHasPerFaceAttributeIndex() && ptmSrc->BHasPerFaceAttributeIndex())
    {
        memcpy(m_rgiMaterialIndex, ptmSrc->m_rgiMaterialIndex, sizeof(UINT16) * m_cFaces);
    }

    // treat the attribute table a little differently, create if not present locally
    if (ptmSrc->BHasAttributeTable())
    {
        if (!BHasAttributeTable() || (m_caeAttributeTable != ptmSrc->m_caeAttributeTable))
        {
            delete []m_rgaeAttributeTable;

            m_caeAttributeTable = ptmSrc->m_caeAttributeTable;
            m_rgaeAttributeTable = new D3DXATTRIBUTERANGE[m_caeAttributeTable];
            if (m_rgaeAttributeTable == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto e_Exit;
            }

            m_dwOptionsInt |= D3DXMESHINT_ATTRIBUTETABLE;
        }

        memcpy(m_rgaeAttributeTable, ptmSrc->m_rgaeAttributeTable, sizeof(D3DXATTRIBUTERANGE) * m_caeAttributeTable);
    }

    // if vertices should be copied, then do so
    if (m_cVertices > 0)
    {
        if (BHasPointRepData() && ptmSrc->BHasPointRepData())
        {
            memcpy(m_rgwPointReps, ptmSrc->m_rgwPointReps, sizeof(UINT_IDX) * m_cVertices);
        }

        // if the dest is not sharing the VB with the src, then copy it
        //  NOTE: the src could be sharing with someone though, so always check dest
        if (!BSharedVB())
        {
            // copy the vertices
            hr = ptmSrc->LockVB(&pvPointsSrc);
            if (FAILED(hr))
                goto e_Exit;

            hr = LockVB(&pvPointsDest);
            if (FAILED(hr))
                goto e_Exit;

            memcpy(pvPointsDest, pvPointsSrc, m_cVertices * m_cBytesPerVertex);
        }
    }

e_Exit:
    if (pvPointsDest != NULL)
    {
        UnlockVB();
    }

    if (pvPointsSrc != NULL)
    {
        ptmSrc->UnlockVB();
    }

    if (pwFacesSrc != NULL)
    {
        ptmSrc->UnlockIB();
    }
    if (pwFacesDest != NULL)
    {
        UnlockIB();
    }

    if (FAILED(hr))
    {
        CreateEmptyMesh();
    }

    return hr;
}

// -------------------------------------------------------------------------------
//  method    Resize
//
//  devnote
//            Resizes the arrays in the mesh to be of at least the size
//                  provided, otherwise it asserts
//
//  returns     S_OK if suceeded, else error code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT
GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED>::Resize(UINT cFacesNewMax, UINT cVerticesNewMax)
{
    PBYTE pInVertices = NULL;
    PBYTE pOutVertices = NULL;
    LPDIRECT3DVERTEXBUFFER8 pVBNew = NULL;
    D3DVERTEXBUFFER_DESC desc;
    HRESULT hr = S_OK;
    UINT cMaxNeighbors = m_cMaxFaces;
    UINT cMaxAttribs = m_cMaxFaces;
    UINT cMaxAttribIndices = m_cMaxFaces;
    UINT cMaxFUserData = m_cMaxFaces;
    UINT cwMaxPointReps = m_cMaxVertices;
    UINT cpvMaxVUserData = m_cMaxVertices;
    D3DFORMAT format;
    LPDIRECT3DINDEXBUFFER8 pibNew = NULL;
    PBYTE pInFaces = NULL;
    PBYTE pOutFaces = NULL;
    //D3DPOOL dwPool;

    memset(&desc, 0, sizeof(desc));

    if ((cFacesNewMax >= UNUSED) || (cVerticesNewMax >= UNUSED))
    {
        hr = D3DERR_INVALIDCALL;
        goto e_Exit;
    }

    if (m_cMaxFaces < cFacesNewMax)
    {
        if (b16BitIndex)
        {
            format = D3DFMT_INDEX16;
        }
        else
        {
            hr = D3DERR_INVALIDCALL;
            goto e_Exit;
        }


        hr = m_pD3DDevice->CreateIndexBuffer(sizeof(UINT_IDX) * 3 * cFacesNewMax, m_dwUsageIB, format, m_dwPoolIB, &pibNew);
        if ( FAILED(hr) )
            goto e_Exit;

        if (m_cFaces > 0)
        {
            hr = m_pibFaces->Lock(0,0, &pInFaces, 0 );
            if ( FAILED(hr) )
                goto e_Exit;
            hr = pibNew->Lock(0,0, &pOutFaces, 0 );
            if ( FAILED(hr) )
                goto e_Exit;

            memcpy( pOutFaces, pInFaces, m_cFaces * 3 * sizeof(UINT_IDX) );

            memset( (PBYTE)pOutFaces + m_cFaces * 3 * sizeof(UINT_IDX), 0,
                                        (cFacesNewMax - m_cFaces) * 3 * sizeof(UINT_IDX));

            hr = pibNew->Unlock( );
            if ( FAILED(hr) )
                goto e_Exit;
            pOutFaces = NULL;
            hr = m_pibFaces->Unlock( );
            if ( FAILED(hr) )
                goto e_Exit;
            pInFaces = NULL;
        }

        GXRELEASE( m_pibFaces );
        m_pibFaces = pibNew;
        pibNew = NULL;

        m_cMaxFaces = cFacesNewMax;

        if (BHasNeighborData())
        {
            if ( ! ResizeDynamicArray( &m_rgpniNeighbors, cFacesNewMax, m_cFaces, &cMaxNeighbors ) )
            {
                hr = E_OUTOFMEMORY;
                goto e_Exit;
            }
            GXASSERT(m_cMaxFaces == cMaxNeighbors);
        }

        if (BHasPerFaceAttributeId())
        {
            if ( ! ResizeDynamicArray( &m_rgiAttributeIds, cFacesNewMax, m_cFaces, &cMaxAttribs ) )
            {
                hr = E_OUTOFMEMORY;
                goto e_Exit;
            }
            GXASSERT(m_cMaxFaces == cMaxAttribs);

            memset(m_rgiAttributeIds + m_cFaces, 0, (cFacesNewMax - m_cFaces) * sizeof(DWORD));
        }

        if (BHasPerFaceAttributeIndex())
        {
            if ( ! ResizeDynamicArray( &m_rgiMaterialIndex, cFacesNewMax, m_cFaces, &cMaxAttribIndices ) )
            {
                hr = E_OUTOFMEMORY;
                goto e_Exit;
            }
            GXASSERT(m_cMaxFaces == cMaxAttribIndices);
        }

    }

    // only resize VB if not shared
    if ((m_cMaxVertices < cVerticesNewMax))
    {
        if ( BHasPointRepData() )
        {
            if ( ! ResizeDynamicArray( &m_rgwPointReps, cVerticesNewMax, m_cVertices, &cwMaxPointReps ) )
            {
                hr = E_OUTOFMEMORY;
                goto e_Exit;
            }
        }

        if (!BSharedVB())
        {
            hr = m_pD3DDevice->CreateVertexBuffer(cVerticesNewMax * m_cBytesPerVertex, m_dwUsageVB, m_dwFVF, m_dwPoolVB, &pVBNew);
            if ( FAILED(hr) )
                goto e_Exit;

            if (m_cVertices > 0)
            {
                hr = m_pVBVertices->Lock(0,0, &pInVertices, 0 );
                if ( FAILED(hr) )
                    goto e_Exit;
                hr = pVBNew->Lock(0,0, &pOutVertices, 0 );
                if ( FAILED(hr) )
                    goto e_Exit;

                memcpy( pOutVertices, pInVertices, m_cVertices * m_cBytesPerVertex );

                memset( (PBYTE)pOutVertices + m_cVertices * m_cBytesPerVertex, 0,
                                            (cVerticesNewMax - m_cVertices) * m_cBytesPerVertex );

                hr = pVBNew->Unlock( );
                if ( FAILED(hr) )
                    goto e_Exit;
                pOutVertices = NULL;
                hr = m_pVBVertices->Unlock( );
                if ( FAILED(hr) )
                    goto e_Exit;
                pInVertices = NULL;
            }

            GXRELEASE( m_pVBVertices );
            m_pVBVertices = pVBNew;
            pVBNew = NULL;

            m_cMaxVertices = cVerticesNewMax;
            GXASSERT(!BHasPointRepData() || cwMaxPointReps == m_cMaxVertices);

#ifdef _DEBUG
            // in debug, zero out unused vertices
            if (m_cVertices < m_cMaxVertices)
            {
                hr = m_pVBVertices->Lock(0,0, &pInVertices, 0 );
                if ( FAILED(hr) )
                    goto e_Exit;

                memset((BYTE*)pInVertices + m_cBytesPerVertex * m_cVertices, 0xff, m_cBytesPerVertex * (m_cMaxVertices - m_cVertices));

                pInVertices = NULL;
                hr = m_pVBVertices->Unlock();
                if ( FAILED(hr) )
                    goto e_Exit;
            }
#endif
        }
    }

    // setup info in mesh
    m_cFaces = cFacesNewMax;
    m_cVertices = cVerticesNewMax;




e_Exit:
    if (pOutFaces != NULL)
    {
        pibNew->Unlock( );
    }
    if (pInFaces != NULL)
    {
        m_pibFaces->Unlock( );
    }
    if (pOutVertices != NULL)
    {
        pVBNew->Unlock( );
    }
    if (pInVertices != NULL)
    {
        m_pVBVertices->Unlock( );
    }

    return hr;
}

// -------------------------------------------------------------------------------
//  method    AddVertex
//
//  devnote     Adds the given point to the vertex buffer and vertex info array
//
//  returns     S_OK if suceeded, else error code
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT
GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED>::AddVertex( PBYTE pvPoint, UINT_IDX wPointRep)
{
    PBYTE pInVertices = NULL;
    PBYTE pOutVertices = NULL;
    LPDIRECT3DVERTEXBUFFER8 pVBNew = NULL;
    D3DVERTEXBUFFER_DESC desc;
    HRESULT hr;
    UINT cNewMaxVertices;
    UINT cwPointReps = m_cVertices;
    UINT cwMaxPointReps = m_cMaxVertices;
    //D3DPOOL dwPool;

    // had better not be adding vertices to a shared vertex buffer
    GXASSERT(!BSharedVB());

    memset(&desc, 0, sizeof(desc));

    if (BHasPointRepData())
    {
        // add the vertex info to the vertex info array for this point
        if ( ! AddToDynamicArray( &m_rgwPointReps, wPointRep, &cwPointReps, &cwMaxPointReps ) )
            return E_OUTOFMEMORY;
    }

    if ( ! m_pVBVertices )
    {
        m_cVertices = 0;
        m_cMaxVertices = 2;

        hr = m_pD3DDevice->CreateVertexBuffer(m_cMaxVertices * m_cBytesPerVertex, m_dwUsageVB, m_dwFVF, m_dwPoolVB, &m_pVBVertices);
        if ( FAILED(hr) )
            goto e_Exit;
    }

    if ( m_cVertices == m_cMaxVertices )
    {

        cNewMaxVertices = min(2*m_cMaxVertices, 65535);

        hr = m_pD3DDevice->CreateVertexBuffer(cNewMaxVertices * m_cBytesPerVertex, m_dwUsageVB, m_dwFVF, m_dwPoolVB, &pVBNew);
        if ( FAILED(hr) )
            goto e_Exit;


        hr = m_pVBVertices->Lock(0,0, &pInVertices, 0 );
        if ( FAILED(hr) )
            goto e_Exit;
        hr = pVBNew->Lock(0,0, &pOutVertices, 0 );
        if ( FAILED(hr) )
            goto e_Exit;

        memcpy( pOutVertices, pInVertices, m_cVertices * m_cBytesPerVertex );

        hr = pVBNew->Unlock( );
        if ( FAILED(hr) )
            goto e_Exit;
        pOutVertices = NULL;
        hr = m_pVBVertices->Unlock( );
        if ( FAILED(hr) )
            goto e_Exit;
        pInVertices = NULL;

        GXRELEASE( m_pVBVertices );
        m_pVBVertices = pVBNew;
        pVBNew = NULL;

        m_cMaxVertices = cNewMaxVertices;
    }
    GXASSERT(!BHasPointRepData() || (cNewMaxVertices == UNUSED) || (cwMaxPointReps == m_cMaxVertices));

    hr = LockVB( &pInVertices );
    if ( FAILED(hr) )
        goto e_Exit;

    memcpy( ((PBYTE)pInVertices)+m_cVertices*m_cBytesPerVertex, pvPoint, m_cBytesPerVertex );
    m_cVertices += 1;

e_Exit:
    if (b16BitIndex)
    {
        if ( pInVertices )
            m_pVBVertices->Unlock( );
        if ( pOutVertices )
            pVBNew->Unlock( );
        GXRELEASE( pVBNew );
    }

    return hr;
}

// -------------------------------------------------------------------------------
//  function    BValid
//
//   devnote    Walks the triangle mesh structure verifying that the topology and point
//                  information is consistent
//
//   returns    returns true, if consistent, and ASSERTS if not consistent
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
bool
GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED>::BValidAttributeGroups(GXTri3Face<UINT_IDX> *pwFaces)
{
    UINT iae;
    UINT iFaceOffset;
    UINT cFacesSubset;
    DWORD attrCur;
    UINT iFace;
    UINT iPoint;

    for (iae = 0; iae < m_caeAttributeTable; iae++)
    {
        iFaceOffset = m_rgaeAttributeTable[iae].FaceStart;
        cFacesSubset = m_rgaeAttributeTable[iae].FaceCount + iFaceOffset;
        attrCur = m_rgaeAttributeTable[iae].AttribId;

        for (iFace = iFaceOffset; iFace < cFacesSubset; iFace++)
        {
            if (BHasPerFaceAttributeId() && m_rgiAttributeIds[iFace] != attrCur)
            {
                GXASSERT(0);
                return false;
            }

            //if (BHasPerFaceMaterialIndex() && m_rgiMaterialIndex[iFace] != iae)
            //{
                //GXASSERT(0);
                //return false;
            //}

            // had better not be an unused face
            GXASSERT(pwFaces[iFace].m_wIndices[0] != UNUSED);

            for (iPoint = 0; iPoint < 3; iPoint++)
            {
                GXASSERT(pwFaces[iFace].m_wIndices[iPoint] >= m_rgaeAttributeTable[iae].VertexStart);
                GXASSERT(pwFaces[iFace].m_wIndices[iPoint] < (m_rgaeAttributeTable[iae].VertexStart + m_rgaeAttributeTable[iae].VertexCount));
            }

        }
    }

    return true;
}

// -------------------------------------------------------------------------------
//  function    BValid
//
//   devnote    Walks the triangle mesh structure verifying that the topology and point
//                  information is consistent
//
//   returns    returns true, if consistent, and ASSERTS if not consistent
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
bool
GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED>::BValid(GXTri3Face<UINT_IDX> *pwFacesLocked)
{
    UINT iFace;
    UINT_IDX *pwFace;
    UINT_IDX *pwNeighbors;
    UINT_IDX *pwFaceNeighbor;
    UINT_IDX *pwNeighborsNeighbor;
    UINT iPoint1;
    UINT iPoint2;
    UINT iPointNeighbor1;
    UINT iPointNeighbor2;
    UINT iNeighborEdge;
    UINT iNeighborEdgeBack;
    GXTri3Face<UINT_IDX> *pwFaces;
    bool bRet = false;
    HRESULT hr;

    if (pwFacesLocked != NULL)
    {
        pwFaces = pwFacesLocked;
    }
    else if (m_pFaces != NULL)
    {
        pwFacesLocked = m_pFaces;
        pwFaces = m_pFaces;
    }
    else
    {
        hr = LockIB((PBYTE*)&pwFaces);
        if (FAILED(hr))
            goto e_Exit;
    }

    for (iFace = 0; iFace < m_cFaces; iFace++)
    {
        pwFace = pwFaces[iFace].m_wIndices;
        pwNeighbors = m_rgpniNeighbors[iFace].m_iNeighbors;

        // if the face is not present, skip checking the topology
        if (pwFace[0] == UNUSED)
        {
            // all three should be UINT max, if one is
            GXASSERT(pwFace[0] == pwFace[1] && pwFace[1] == pwFace[2]);
            if (!(pwFace[0] == pwFace[1] && pwFace[1] == pwFace[2]))
                goto e_Exit;

            if (BHasNeighborData())
            {
                GXASSERT(pwNeighbors[0] == UNUSED
                    && pwNeighbors[0] == pwNeighbors[1] && pwNeighbors[1] == pwNeighbors[2]);
                if (!(pwNeighbors[0] == UNUSED
                    && pwNeighbors[0] == pwNeighbors[1] && pwNeighbors[1] == pwNeighbors[2]))
                    goto e_Exit;
            }

            continue;
        }

        if (BHasPointRepData())
        {
            GXASSERT((WGetPointRep(pwFace[0]) != WGetPointRep(pwFace[1]))
                        && (WGetPointRep(pwFace[1]) != WGetPointRep(pwFace[2]))
                        && (WGetPointRep(pwFace[2]) != WGetPointRep(pwFace[0])));
        }
        else
        {
            GXASSERT(((pwFace[0]) != (pwFace[1]))
                        && ((pwFace[1]) != (pwFace[2]))
                        && ((pwFace[2]) != (pwFace[0])));
        }

        if (BHasNeighborData())
        {
            for (iNeighborEdge = 0; iNeighborEdge < 3; iNeighborEdge++)
            {

                iPoint1 = pwFace[iNeighborEdge];
                iPoint2 = pwFace[(iNeighborEdge + 1) % 3];

                GXASSERT(iPoint1 < m_cVertices);
                GXASSERT(iPoint2 < m_cVertices);
                if (!(iPoint1 < m_cVertices))
                    goto e_Exit;
                if (!(iPoint2 < m_cVertices))
                    goto e_Exit;

                if (pwNeighbors[iNeighborEdge] != UNUSED)
                {

                    // RESTRICTION: does not  support sharing a side with the same triangle more than once
                    for (UINT i = 0; i < 3; i++)
                    {
                        if (i != iNeighborEdge)
                            GXASSERT(pwNeighbors[iNeighborEdge] != pwNeighbors[i]);
                    }

                    // assert that it is a valid id
                    GXASSERT(pwNeighbors[iNeighborEdge] < m_cFaces);
                    if (!(pwNeighbors[iNeighborEdge] < m_cFaces))
                        goto e_Exit;

                    pwFaceNeighbor = pwFaces[pwNeighbors[iNeighborEdge]].m_wIndices;
                    pwNeighborsNeighbor = m_rgpniNeighbors[pwNeighbors[iNeighborEdge]].m_iNeighbors;

                    // find the edge that points to this triangle in the neighbor
                    iNeighborEdgeBack = FindEdge(pwNeighborsNeighbor, (UINT_IDX)iFace);

                    // the neighbor had better point back to this face
                    GXASSERT(iNeighborEdgeBack < 3);
                    if (!(iNeighborEdgeBack < 3))
                        goto e_Exit;

                    if (BHasPointRepData())
                    {
                        // get the two points on that neighbor's edge
                        iPointNeighbor1 = pwFaceNeighbor[iNeighborEdgeBack];
                        iPointNeighbor2 = pwFaceNeighbor[(iNeighborEdgeBack + 1) % 3];

                        UINT_IDX wPoint1Rep = WGetPointRep(iPoint1);
                        UINT_IDX wPoint2Rep = WGetPointRep(iPoint2);
                        UINT_IDX wPointNeighbor1Rep = WGetPointRep(iPointNeighbor1);
                        UINT_IDX wPointNeighbor2Rep = WGetPointRep(iPointNeighbor2);

                        GXASSERT(BEqualPoints(iPoint1, iPointNeighbor2) && BEqualPoints(iPoint2, iPointNeighbor1));

                        // the two points along the shared edge had better match up
                        GXASSERT((BEqualPoints(iPoint1, iPointNeighbor1) && BEqualPoints(iPoint2, iPointNeighbor2))
                                    || (BEqualPoints(iPoint2, iPointNeighbor1) && BEqualPoints(iPoint1, iPointNeighbor2)));
                        if (!((BEqualPoints(iPoint1, iPointNeighbor1) && BEqualPoints(iPoint2, iPointNeighbor2))
                                    || (BEqualPoints(iPoint2, iPointNeighbor1) && BEqualPoints(iPoint1, iPointNeighbor2))))
                            goto e_Exit;
                    }
                }
            }
        }
    }

    // if there is an attribute group table, then make sure it is valid
    if ((m_dwOptionsInt & D3DXMESHINT_ATTRIBUTETABLE) && (m_rgaeAttributeTable != NULL) && !BValidAttributeGroups(pwFaces))
        goto e_Exit;

    bRet = true;
e_Exit:
    if ((pwFaces != NULL) && (pwFacesLocked == NULL))
    {
        UnlockIB();
    }

    return bRet;
}





//const int x_cHashSize = 60;

struct hashentry
{
    DWORD v1;
    DWORD v2;
    DWORD f;
    hashentry* next;
};
typedef hashentry* PHASHENTRY;


inline void HashAdd(DWORD va, DWORD vb, DWORD f, PHASHENTRY* hashtable, PHASHENTRY hashentries, DWORD dwHashSize, int& freeptr)
{
    // UNDONE, replace with a halfway decent hash function
    DWORD v = va % dwHashSize;

    for (PHASHENTRY* t = &(hashtable[v]); *t; t = &((*t)->next));
    PHASHENTRY p = &(hashentries[freeptr++]);
    p->f = f;
    p->v1 = va;
    p->v2 = vb;
    p->next = NULL;
    *t=p;
}

inline DWORD HashFind(DWORD va, DWORD vb, PHASHENTRY* hashtable, DWORD dwHashSize, DWORD UNUSED)
{
    PHASHENTRY pheCur;
    PHASHENTRY phePrev;
    DWORD iFace;

    // UNDONE, replace with a halfway decent hash function
    DWORD v = va % dwHashSize;

    pheCur = hashtable[v];
    phePrev = NULL;

    iFace = UNUSED;
    while (pheCur != NULL)
    {
        if ((pheCur->v2 == vb) && (pheCur->v1 == va))
        {
            iFace = pheCur->f;
            break;
        }

        phePrev = pheCur;
        pheCur = pheCur->next;
    }

    if (iFace != UNUSED)
    {
        GXASSERT(pheCur != NULL);

        // if not the head, trim out pheCur
        if (phePrev != NULL)
        {
            phePrev->next = pheCur->next;
        }
        else
        {
            hashtable[v] = pheCur->next;
        }
    }

    return iFace;
}

template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED>::ConvertAdjacencyToPointReps
    (
    CONST DWORD* rgdwNeighbors, 
    DWORD* rgdwPointReps
    )
{
    UINT_IDX wPointRep;
    UINT_IDX wWedge;
    UINT_IDX *pwFace;
    UINT_IDX iCurFace;
    UINT iFace;
    UINT iPoint;
    UINT iVertex;
    UINT iIterated;
    CFaceListIter<UINT_IDX,b16BitIndex,UNUSED> fli(this);
    GXTri3Face<UINT_IDX> *pwFaces = NULL;
    CONST DWORD *pdwCur;
    HRESULT hr = S_OK;

    if (rgdwNeighbors == NULL)
    {
        DPF(0, "ConvertAdjacencyToPointReps: Failed because Adjacency array must not be NULL\n");
        hr = D3DERR_INVALIDCALL;
        goto e_Exit;
    }
    if (rgdwPointReps == NULL)
    {
        DPF(0, "ConvertAdjacencyToPointReps: Failed because PointRep output array must not be NULL\n");
        hr = D3DERR_INVALIDCALL;
        goto e_Exit;
    }

    // create a temporary array to enable facelistiter's to work
    m_rgpniNeighbors = new NeighborInfo<UINT_IDX>[m_cFaces];
    if (m_rgpniNeighbors == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    for (iFace = 0, pdwCur = rgdwNeighbors; iFace < m_cFaces; iFace++)
    {
        m_rgpniNeighbors[iFace].m_iNeighbors[0] = (UINT_IDX)*pdwCur;
        pdwCur++;
        m_rgpniNeighbors[iFace].m_iNeighbors[1] = (UINT_IDX)*pdwCur;
        pdwCur++;
        m_rgpniNeighbors[iFace].m_iNeighbors[2] = (UINT_IDX)*pdwCur;
        pdwCur++;
    }

    // first set all point reps to the UNUSED value to know whether or not we've seen
    //   a vertex before
    memset(rgdwPointReps, 0xff, sizeof(DWORD) * m_cVertices);

    hr = LockIB((PBYTE*)&pwFaces);
    if (FAILED(hr))
        goto e_Exit;
    m_pFaces = pwFaces;

    for (iFace = 0; iFace < m_cFaces; iFace++)
    {
        pwFace = pwFaces[iFace].m_wIndices;

        for (iPoint = 0; iPoint < 3; iPoint++)
        {
            wPointRep = pwFace[iPoint];
            if (wPointRep == UNUSED)
                continue;

            // if the point rep is unused, then we haven't circled this vertex yet
            if (rgdwPointReps[wPointRep] == UNUSED32)
            {
                // now that we need to setup the point rep, make a round of the
                //     faces, marking all wedges of the given vertex with the new pointrep
                fli.Init(iFace, wPointRep, x_iAllFaces);
                iIterated = 0;
                while (!fli.BEndOfList())
                {
                    iCurFace = fli.GetNextFace();

                    wWedge = pwFaces[iCurFace].m_wIndices[fli.IGetPointIndex()];
                    rgdwPointReps[wWedge] = wPointRep;

                    iIterated += 1;
                    if (iIterated > 10000)
                    {
                        DPF(0, "ConvertAdjacencyToPointReps: Possible bad adjacency loop found cannot continue");
                        DPF(0, "ConvertAdjacencyToPointReps:   Try calling D3DXValidMesh for more information");
                        hr = D3DXERR_INVALIDMESH;
                        goto e_Exit;
                    }
                }
            }
        }
    }

    for (iVertex = 0; iVertex < m_cVertices; iVertex++)
    {
        // if the point is present in the mesh but not used, just set it to point to itself
        if (rgdwPointReps[iVertex] == UNUSED32)
        {
            rgdwPointReps[iVertex] = iVertex;
        }
    }

e_Exit:
    if (pwFaces != NULL)
    {
        UnlockIB();
    }
    m_pFaces = NULL;

    delete []m_rgpniNeighbors;
    m_rgpniNeighbors = NULL;

    return hr;
}

struct SVertexHashEntry
{
    D3DXVECTOR3 v;
    DWORD iIndex;
    SVertexHashEntry* pNext;
};


template <class UINT_IDX>
BOOL BEdgePresent
    (
    DWORD iVertex1, 
    DWORD iVertex2, 
    DWORD *rgdwVertexToCorner, 
    DWORD *rgdwVertexCornerList, 
    GXTri3Face<UINT_IDX> *pwFaces
    )
{
    DWORD dwHead;
    UINT_IDX *pwFace;

    GXASSERT(iVertex1 != iVertex2);

    // look at all triangles that contain iVertex1 to see if they contain iVertex2 as well.
    dwHead = rgdwVertexToCorner[iVertex1];
    while (dwHead != UNUSED32)
    {
        pwFace = pwFaces[dwHead / 3].m_wIndices;

        // iVertex1 had better be in the face
        GXASSERT((pwFace[0] == iVertex1) || 
                 (pwFace[1] == iVertex1) || 
                 (pwFace[2] == iVertex1));

        // if the other vertex is in the triangle then there is an edge
        if ((pwFace[0] == iVertex2) || 
            (pwFace[1] == iVertex2) || 
            (pwFace[2] == iVertex2))
        {
            return TRUE;
        }

        // move to next entry
        dwHead = rgdwVertexCornerList[dwHead];
    }

    return FALSE;
}


 
template <class UINT_IDX>
BOOL VertexHashAdd
    (
    D3DXVECTOR3 *pv,
    DWORD iIndex, 
    SVertexHashEntry **rgpHashTable, 
    SVertexHashEntry *rgHashEntries, 
    DWORD dwHashSize, 
    DWORD *rgdwVertexToCorner, 
    DWORD *rgdwVertexCornerList, 
    GXTri3Face<UINT_IDX> *pwFaces, 
    DWORD *piFreeEntry, 
    DWORD *piFound
    )
{
    SVertexHashEntry *pCur;
    SVertexHashEntry *pNewEntry;
    //DWORD iHash = ((DWORD)pv->x * (17 * 17) + ((DWORD)pv->y * 17) + (DWORD)pv->z) % dwHashSize;
    DWORD iHash = (*(DWORD*)&pv->x + *(DWORD*)&pv->y + *(DWORD*)&pv->z) % dwHashSize;

    *piFound = UNUSED32;

    for (pCur = rgpHashTable[iHash]; pCur != NULL; pCur = pCur->pNext)
    {
        if ((pCur->v == *pv) && (!BEdgePresent(iIndex, pCur->iIndex, rgdwVertexToCorner, rgdwVertexCornerList, pwFaces)))
        {
            *piFound = pCur->iIndex;
            return TRUE;
        }
    }

    // if vertex not found, then add

    pNewEntry = &rgHashEntries[*piFreeEntry];
    *piFreeEntry += 1;

    pNewEntry->v = *pv;
    pNewEntry->iIndex = iIndex;
    pNewEntry->pNext = rgpHashTable[iHash];
    rgpHashTable[iHash] = pNewEntry;

    return FALSE;
}

template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED>::GenerateAdjacency
    (
    FLOAT fEpsilon, 
    DWORD* rgdwNeighbors
    )
{
    HRESULT hr = S_OK;
    DWORD *rgdwPointReps = NULL;
    float *rgfMinDist = NULL;
    DWORD iVertex;
    DWORD iVertexInner;
    PBYTE pbVertices = NULL;
    DXCrackFVF cfvf(m_dwFVF);
    float fEpsilonSq;
    float fDist;
    D3DXVECTOR3 *pvInner;
    D3DXVECTOR3 *pvOuter;
    D3DXVECTOR3 vDiff;
    PBYTE pbVertexCur;
    DWORD dwHashSize = m_cVertices / 3;
    SVertexHashEntry **rgpHashTable = NULL;
    // An entry for each 3 edges of each face in base mesh
    SVertexHashEntry *rgHashEntries = NULL;
    DWORD iFreeEntry = 0;
    DWORD iVertexMatch;
    DWORD *rgdwVertexToCorner = NULL;
    DWORD *rgdwVertexCornerList = NULL;
    GXTri3Face<UINT_IDX> *pwFaces = NULL;
    UINT_IDX *pwFace;
    DWORD iFace;
    DWORD iPoint;

    if (rgdwNeighbors == NULL)
    {
        DPF(0, "GenerateAdjacency: Adjacency out parameter must not be NULL\n");
        hr = D3DERR_INVALIDCALL;
        goto e_Exit;
    }

    rgpHashTable = new SVertexHashEntry*[dwHashSize];
    rgHashEntries = new SVertexHashEntry[m_cVertices];
    rgdwVertexToCorner = new DWORD[m_cVertices];
    rgdwVertexCornerList = new DWORD[m_cFaces * 3];
    rgdwPointReps = new DWORD[m_cVertices];
    if ((rgpHashTable == NULL)|| (rgHashEntries == NULL) 
        || (rgdwVertexToCorner == NULL) || (rgdwVertexCornerList == NULL)
        || (rgdwPointReps == NULL))
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }
    memset(rgpHashTable, 0, sizeof(SVertexHashEntry*) * dwHashSize);
    memset(rgdwVertexToCorner, 0xff, sizeof(DWORD) * m_cVertices);

    hr = LockIB((PBYTE*)&pwFaces);
    if (FAILED(hr))
    {
        goto e_Exit;
    }

    // generate a list for each vertex of faces touched by that vertex
    for (iFace = 0; iFace < m_cFaces; iFace++)
    {
        pwFace = pwFaces[iFace].m_wIndices;
        for (iPoint = 0; iPoint < 3; iPoint++)
        {
            // now add the current corner to the list (if no corner before, then it is an
            //    empty list setup above)

            rgdwVertexCornerList[iFace * 3 + iPoint] = rgdwVertexToCorner[pwFace[iPoint]];
            rgdwVertexToCorner[pwFace[iPoint]] = iFace * 3 + iPoint;
        }
    }

    hr = LockVB(&pbVertices);
    if (FAILED(hr))
        goto e_Exit;


    pbVertexCur = pbVertices;
    for (iVertex = 0; iVertex < m_cVertices; iVertex++)
    {
        if (VertexHashAdd(cfvf.PvGetPosition(pbVertexCur), iVertex, rgpHashTable, 
                                        rgHashEntries, dwHashSize,
                                        rgdwVertexToCorner, rgdwVertexCornerList, pwFaces,
                                        &iFreeEntry, &iVertexMatch))
        {
            rgdwPointReps[iVertex] = iVertexMatch;
        }
        else
        {
            rgdwPointReps[iVertex] = iVertex;
        }

        pbVertexCur += cfvf.m_cBytesPerVertex;
    }



    // N^2 algorithm to generate closest point info, needs a bit to generate point reps though
#if 0
    for (iVertex = 0; iVertex < m_cVertices; iVertex++)
    {
        pbVertexCur = pvVertices;
        pvOuter = cfvf.PvGetPosition(cfvf.GetArrayElem(pbVertices, iVertex));

        fDistMin = fEpsilonSq;
        rgdwPointReps[iVertex] = iVertex;

        for (iVertexInner = 0; iVertexInner < m_cVertices; iVertexInner++)
        {
            if (iVertex != iVertexInner)
            {
                pvInner = cfvf.PvGetPosition(pbVertexCur);

                vDiff = *pvInner;
                vDiff -= *pvOuter;
                fDist = D3DXVec3LengthSq(&vDiff);

                if (fDist < fDistMin)
                {
                    rgdwPointReps[iVertex] = iVertexInner;
                }
            }

            pbVertexCur += cfvf.m_cBytesPerVertex;
        }

#if 0
        if (rgdwPointReps[iVertex] == UNUSED32)
        {
            rgdwPointReps[iVertex] = iVertex;
            rgfMinDist[iVertex] = 0.0f;

            pbVertexCur = cfvf.GetArrayElem(pbVertices, iVertex);
            pvOuter = cfvf.PvGetPosition(pbVertexCur);

            for (iVertexInner = iVertex + 1; iVertexInner < m_cVertices; iVertexInner++)
            {
                pvInner = cfvf.PvGetPosition(pbVertexCur);

                vDiff = *pvInner;
                vDiff -= *pvOuter;
                fDist = D3DXVec3LengthSq(&vDiff);

                if (fDist < fEpsilonSq)
                {
                    if ((rgdwPointReps[iVertexInner] == UNUSED32) || (fDist < rgfMinDist[iVertex]))
                    {
                        rgdwPointReps[iVertexInner] = iVertex;
                        rgfMinDist[iVertex] = fDist;
                    }
                }

                pbVertexCur += cfvf.m_cBytesPerVertex;
            }
        }
#endif
    }
#endif

    // Will be implemented in a follow up checkin
    hr = ConvertPointRepsToAdjacency(rgdwPointReps, rgdwNeighbors);
    if (FAILED(hr)) 
        goto e_Exit;

e_Exit:
    delete []rgpHashTable;
    delete []rgHashEntries;
    delete []rgdwVertexToCorner;
    delete []rgdwVertexCornerList;

    delete []rgdwPointReps;
    if (pbVertices != NULL)
        UnlockVB();
    if (pwFaces != NULL)
        UnlockIB();

    return hr;
}


template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED>::ConvertPointRepsToAdjacency(CONST DWORD* rgdwPointReps, DWORD* rgdwNeighbors)
{
    HRESULT hr = S_OK;

    UINT_IDX *pwFace;
    DWORD *pdwNeighbors;
    DWORD rgPoint[3];
    DWORD iPoint;
    DWORD iNPoint;
    DWORD iCurNPoint;
    UINT iFace;
    GXTri3Face<UINT_IDX> *pwFaces = NULL;
    int freeptr = 0;
    int maxptr = m_cFaces*3;
    DWORD dwHashSize = m_cVertices / 3;
    PHASHENTRY *hashtable = NULL;
    // An entry for each 3 edges of each face in base mesh
    PHASHENTRY hashentries = NULL;

    if (rgdwNeighbors == NULL)
    {
        DPF(0, "ConvertPointRepsToAdjacency: Adjacency out parameter must not be NULL\n");
        hr = D3DERR_INVALIDCALL;
        goto e_Exit;
    }

    hashtable = new PHASHENTRY[dwHashSize];
    hashentries = new hashentry[maxptr];
    if ((hashtable == NULL)|| (hashentries == NULL))
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }


    hr = LockIB((PBYTE*)&pwFaces);
    if (FAILED(hr))
    {
        goto e_Exit;
    }

    memset(hashtable, 0, sizeof(PHASHENTRY)*dwHashSize);

    for (iFace = 0; iFace < m_cFaces; iFace++)
    {
        pwFace = pwFaces[iFace].m_wIndices;
        pdwNeighbors = &rgdwNeighbors[iFace * 3];

        if (pwFace[0] == UNUSED)
            continue;

        // For each face in group
        if (rgdwPointReps != NULL)
        {
            rgPoint[0] = rgdwPointReps[pwFace[0]];
            rgPoint[1] = rgdwPointReps[pwFace[1]];
            rgPoint[2] = rgdwPointReps[pwFace[2]];
        }
        else
        {
            rgPoint[0] = pwFace[0];
            rgPoint[1] = pwFace[1];
            rgPoint[2] = pwFace[2];
        }

        // don't include degenerate triangles in hashing
        if ((rgPoint[0] != rgPoint[1]) && (rgPoint[0] != rgPoint[2]) && (rgPoint[1] != rgPoint[2]))
        {
            for (iPoint = 0; iPoint < 3; iPoint++)
            {
                // lookup to see if edge already entered, if not enter it
                pdwNeighbors[iPoint] = HashFind(rgPoint[(iPoint+1)%3],rgPoint[iPoint],hashtable, dwHashSize, UNUSED32);

                // if matching edge found, mark neighbor to point back
                if (pdwNeighbors[iPoint] != UNUSED32)
                {
                    // now search for the edge in the neighbor triangle
                    for (iNPoint = 0; iNPoint < 3; iNPoint++)
                    {
                        // lookup the value of the current point
                        iCurNPoint = pwFaces[pdwNeighbors[iPoint]].m_wIndices[iNPoint];
                        if (rgdwPointReps != NULL)
                        {
                            iCurNPoint = rgdwPointReps[iCurNPoint];
                        }

                        if (iCurNPoint == rgPoint[(iPoint+1)%3])
                            break;
                    }
#ifdef DEBUG
                        // assert that the second point of the edge matches what we are looking for
                        DWORD iTestPoint;
                        iTestPoint = pwFaces[pdwNeighbors[iPoint]].m_wIndices[(iNPoint+1)%3];
                        if (rgdwPointReps != NULL)
                            iTestPoint = rgdwPointReps[iCurNPoint];
                        GXASSERT(iTestPoint == rgPoint[iPoint];
#endif

                    // the neighbor had better not point at someone else
                    GXASSERT(rgdwNeighbors[pdwNeighbors[iPoint] * 3 + iNPoint] == UNUSED32);

                    // update the neighbor to point back to this face on the matching edge
                    rgdwNeighbors[pdwNeighbors[iPoint] * 3 + iNPoint] = iFace;
                }
                else
                {
                    // lookup to see if edge already entered, if not enter it
                    HashAdd(rgPoint[iPoint],rgPoint[(iPoint+1)%3],iFace, hashtable, hashentries, dwHashSize, freeptr);

                    // Mark as UNUSED, if another edge matches this one, it will fix it up
                    pdwNeighbors[iPoint] = UNUSED32;
                }
            }
        }
        else
        {
            pdwNeighbors[0] = UNUSED32;
            pdwNeighbors[1] = UNUSED32;
            pdwNeighbors[2] = UNUSED32;
        }
    }
    if (freeptr > maxptr)
    {
        hr = E_FAIL;
        goto e_Exit;
    }

    GXASSERT(BValid(pwFaces));

    GXASSERT(CheckAdjacency(rgdwNeighbors, m_cFaces));

e_Exit:
    if (pwFaces != NULL)
    {
        UnlockIB();
    }

    delete [] hashtable;
    delete [] hashentries;
    return hr;
}


template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT
GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED>::GetVertexBuffer(LPDIRECT3DVERTEXBUFFER8* ppVB)
{

    if (ppVB == NULL)
    {
        DPF(0, "ppVB pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    *ppVB = m_pVBVertices;

    m_pVBVertices->AddRef();

    return S_OK;
}

template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
DWORD
GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED>::GetNumVertices()
{
    return m_cVertices;
}

template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT
GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED>::GetIndexBuffer(LPDIRECT3DINDEXBUFFER8 *ppIB)
{
    //HRESULT hr;

    if (ppIB == NULL)
    {
        DPF(0, "ppIB pointer is invalid");
        return D3DERR_INVALIDCALL;
    }

    *ppIB = m_pibFaces;
    m_pibFaces->AddRef();

    return S_OK;
}

template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
DWORD
GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED>::GetNumFaces()
{
    return m_cFaces;
}


template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
DWORD
GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED>::GetFVF()
{
    return m_dwFVF;
}

template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT
GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED>::GetDeclaration(DWORD Declaration[MAX_FVF_DECL_SIZE])
{
    return D3DXDeclaratorFromFVF(m_dwFVF, Declaration);
}

template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
DWORD
GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED>::GetOptions()
{
    return m_dwOptions;
}

template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
HRESULT
GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED>::GetAttributeTable(
          D3DXATTRIBUTERANGE *rgaeAttribTable, DWORD* pcAttribTableSize)
{
    // if count desired, provided it
    if (pcAttribTableSize != NULL)
    {
        *pcAttribTableSize = m_caeAttributeTable;
    }

    // if attribute table desired, provided it
    if ((rgaeAttribTable != NULL) && (m_rgaeAttributeTable != NULL))
    {
        memcpy(rgaeAttribTable, m_rgaeAttributeTable,
            sizeof(D3DXATTRIBUTERANGE) * m_caeAttributeTable);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\mesh\3ds\3dsftk.h ===
/****************************************************************************
 *
 * 3DSFTK.H - 3D Studio File Toolkit for Release 3 library header
 *
 *  (C) Copyright 1997 by Autodesk, Inc.
 *
 *  This program is copyrighted by Autodesk, Inc. and is licensed to you under
 *  the following conditions.  You may not distribute or publish the source
 *  code of this program in any form.  You may incorporate this code in object
 *  form in derivative works provided such derivative works are (i.) are de-
 *  signed and intended to work solely with Autodesk, Inc. products, and (ii.)
 *  contain Autodesk's copyright notice "(C) Copyright 1995 by Autodesk, Inc."
 *
 *  AUTODESK PROVIDES THIS PROGRAM "AS IS" AND WITH ALL FAULTS.  AUTODESK SPE-
 *  CIFICALLY DISCLAIMS ANY IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS FOR
 *  A PARTICULAR USE.  AUTODESK, INC.  DOES NOT WARRANT THAT THE OPERATION OF
 *  THE PROGRAM WILL BE UNINTERRUPTED OR ERROR FREE.
 *
 ***************************************************************************/


#ifndef FTK3DS_H
#define FTK3DS_H

#include <stdio.h>

#ifdef __cplusplus
extern "C" {
#endif
					
/* Note: Item's prefixed with a "Priv" comment are internally used, are not
   part of the toolkit's published interface, and should not be used
   by non-ftk library functions */


/* Data Type Synonyms For Portability */

#define char3ds char
#define uchar3ds unsigned char
#define byte3ds char
#define ubyte3ds unsigned char
#define short3ds short int
#define ushort3ds unsigned short int
#define long3ds long int
#define ulong3ds unsigned long int
#define float3ds float
#define double3ds double
#define int3ds   int
#define void3ds void

/* 3DS File Toolkit revision level.  Future revisions will increment this
   integer number */
#define FTKRevisionLevel3ds 2

/*------------------------------------
  Error reporting and testing macros
  ----------------------------------*/

/* Pending error flag values for ftkerr3ds global */
#define FTK_ERROR True3ds
#define FTK_NO_ERROR False3ds

/*--- If ftkerr3ds shows that an error has occured, return */
#define ON_ERROR_RETURN {if(ftkerr3ds && !ignoreftkerr3ds) return;}
#define ON_ERROR_RETURNR(rval) {if(ftkerr3ds && !ignoreftkerr3ds) return rval;}

/*--- If ftkerr3ds shows that an error has occured, push error and return */
#define ADD_ERROR_RETURN(id) {if(ftkerr3ds){PushErrList3ds(id); if (!ignoreftkerr3ds) return;}}
#define ADD_ERROR_RETURNR(id, rval) {if(ftkerr3ds){PushErrList3ds(id); if (!ignoreftkerr3ds) return rval;}}

/*--- If ftkerr3ds shows that an error has occured, push error */
#define ADD_ERROR(id) {if (ftkerr3ds){PushErrList3ds(id);}}

/*--- Reset the the error flag */
#define CLEAR_ERROR {if (ftkerr3ds){ClearErrList3ds();}}

/*--- Simply set the error state: Good if you need to clean-up before returning  */
#define SET_ERROR {ftkerr3ds=True3ds;}

/*--- Set error state, push an error ID and return */
#define SET_ERROR_RETURN(id) {PushErrList3ds(id); if (!ignoreftkerr3ds) return;}
#define SET_ERROR_RETURNR(id, rval) {PushErrList3ds(id); if (!ignoreftkerr3ds) return rval;}

/* Prints errors and exits application */
#define PRINT_ERRORS_EXIT(file) {if(ftkerr3ds && file){DumpErrList3ds(file); if (!ignoreftkerr3ds) exit(0x3D);}}

/*----------------------------------------
  Commonly used structures and constants
  --------------------------------------*/

/* Constants to define True and False in a compiler independant way. */
#define TRUE3DS (1==1)
#define FALSE3DS (1!=1)
static const byte3ds True3ds = (1==1);
static const byte3ds False3ds = (1!=1);

/* point3ds - 3D point structure */
typedef struct 
{
   float3ds x, y, z;
} point3ds;

/* fcolor3ds - Floating point color definition */
typedef struct {
   float3ds r;   /* RGB Color components */
   float3ds g;
   float3ds b;
} fcolor3ds;       

/* face3ds - Face list element */
typedef struct
{
   ushort3ds v1, v2, v3, flag;
} face3ds;

/* textvert3ds - Texture assignment coordinate */
typedef struct
{
   float3ds u, v;
} textvert3ds;
/* Priv */ /* trackheader3ds - Global track settings */
/* Priv */ typedef struct
/* Priv */ {
/* Priv */    ushort3ds flags;
/* Priv */    ulong3ds nu1, nu2;
/* Priv */    ulong3ds keycount; /* Number of keys in the track */
/* Priv */ } trackheader3ds;

/* keyheader3ds - Animation key settings */
typedef struct
{
   ulong3ds time;       /* Key's frame position */
   ushort3ds rflags;    /* Spline terms used flag */
   float3ds tension;    /* Flagged with 0x01 */
   float3ds continuity; /* Flagged with 0x02 */
   float3ds bias;       /* Flagged with 0x04 */
   float3ds easeto;     /* Flagged with 0x08 */
   float3ds easefrom;   /* Flagged with 0x10 */
} keyheader3ds;

/* kfrotkey3ds - Rotation key */
typedef struct {
   float3ds angle; /* angle of rotation */
   float3ds x;     /* rotation axis vector */
   float3ds y;
   float3ds z;
} kfrotkey3ds;

/* kfmorphkey3ds - Object morph key */
typedef struct {
   char3ds name[13]; /* name of target morph object */
} kfmorphkey3ds;


/* Error codes generated by toolkit */
typedef enum
{
   NO_FTK_ERRORS = 0, /* No errors are pending */
   ERR_NO_MEM, /* Not enough memory to complete operation */
   ERR_INVALID_ARG, /* The argument passed to the function invalid.  Usually */
		    /* caused by a NULL pointer or an out of range numeric */
		    /* argument. */
   ERR_INVALID_DATA, /* The structure passed as an argument to the function has */
                     /* invalid or out of range data in its fields. */
   ERR_INVALID_CHUNK, /* An invalid chunk structure was encountered while reading */
		      /* the database. Usually caused by a corrupt database or */
		      /* file */
   ERR_INVALID_DATABASE, /* The database passed as an argument has not be created */
			 /* yet. */
   ERR_WRONG_DATABASE, /* The database passed as an argument is the wrong kind of */
		       /* database for this function. */
   ERR_UNFOUND_CHUNK, /* The database is missing important file chunks needed to */
		      /* fill out the requested structure.  Usually caused by a */
		      /* corrupt database or file */
   ERR_WRONG_OBJECT, /* The name passed to the functions exists, but is not the */
		     /* type of object asked for.  For example, asking for a mesh */
		     /* object with the GetCameraByName3ds function. */
   ERR_NO_SUCH_FILE, /* The filename passed as an argument for reading does not exist */
   ERR_INIT_FAILED,  /* Failed to initialize structure passed as an argument */
   ERR_OPENING_FILE, /* Could not open requested file */
   ERR_CLOSING_FILE, /* Could not close requested file */
   ERR_READING_FILE, /* Error occured while reading file */
   ERR_CREATING_DATABASE, /* Error occured while creating database */
   ERR_READING_DATABASE, /* Error occured while reading database */
   ERR_WRITING_DATABASE, /* Error occured while writing database */
   ERR_WRITING_FILE, /* Error occured while writing file */
   ERR_STRING_TOO_LONG, /* String encountered in file, structure, or as an */
			/* argument was longer than expected.  Possibly caused by */
			/* an uninitialed pointer, corrupt file or database */
   ERR_TOO_MANY_FILES, /* The toolkit has reached its maximum open file limit of */
		       /* 252 files. */
   ERR_GET_FAIL, /* Failed to get new data from database */
   ERR_PUT_FAIL, /* Failed to add new data to the database */
   N_ERRORS
}errorid3ds;

typedef struct {
  errorid3ds  id;
  const char3ds *desc;
} ErrRec3ds;


/* Priv */ /* chunktag3ds - enumeration of all possible chunk type identifiers. See appendix for */
/* Priv */ /* more information concerning chunk structures */   
/* Priv */ typedef enum
/* Priv */ {
/* Priv */         /* Trick Chunk Flags For ChunkSyntax function */

/* Priv */    NULL_CHUNK             = 0x0000,
/* Priv */    ChunkType              = 0x0995,
/* Priv */    ChunkUnique            = 0x0996,
/* Priv */    NotChunk               = 0x0997,
/* Priv */    Container              = 0x0998,
/* Priv */    IsChunk                = 0x0999,

/* Priv */    /* Dummy Chunk that sometimes appears in 3ds files created by prerelease 3D Studio R2 */
/* Priv */    DUMMY = 0xFFFF,

/* Priv */    /* Trick Chunk Types For Open*, Write*, Close* functions */

/* Priv */    POINT_ARRAY_ENTRY      = 0xF110,
/* Priv */    POINT_FLAG_ARRAY_ENTRY = 0xF111,
/* Priv */    FACE_ARRAY_ENTRY       = 0xF120,
/* Priv */    MSH_MAT_GROUP_ENTRY    = 0xF130,
/* Priv */    TEX_VERTS_ENTRY        = 0xF140,
/* Priv */    SMOOTH_GROUP_ENTRY     = 0xF150,
/* Priv */    POS_TRACK_TAG_KEY      = 0xF020,
/* Priv */    ROT_TRACK_TAG_KEY      = 0xF021,
/* Priv */    SCL_TRACK_TAG_KEY      = 0xF022,
/* Priv */    FOV_TRACK_TAG_KEY      = 0xF023,
/* Priv */    ROLL_TRACK_TAG_KEY     = 0xF024,
/* Priv */    COL_TRACK_TAG_KEY      = 0xF025,
/* Priv */    MORPH_TRACK_TAG_KEY    = 0xF026,
/* Priv */    HOT_TRACK_TAG_KEY      = 0xF027,
/* Priv */    FALL_TRACK_TAG_KEY     = 0xF028,
/* Priv */    
/* Priv */    /* 3DS File Chunk IDs */

/* Priv */    M3DMAGIC               = 0x4D4D,
/* Priv */    SMAGIC                 = 0x2D2D,
/* Priv */    LMAGIC                 = 0x2D3D,
/* Priv */    MLIBMAGIC              = 0x3DAA,
/* Priv */    MATMAGIC               = 0x3DFF,
/* Priv */    M3D_VERSION            = 0x0002,
/* Priv */    M3D_KFVERSION          = 0x0005,

/* Priv */    /* Mesh Chunk Ids */

/* Priv */    MDATA                  = 0x3D3D,
/* Priv */    MESH_VERSION           = 0x3D3E,
/* Priv */    COLOR_F                = 0x0010,
/* Priv */    COLOR_24               = 0x0011,
/* Priv */    LIN_COLOR_24           = 0x0012,
/* Priv */    LIN_COLOR_F            = 0x0013,
/* Priv */    INT_PERCENTAGE         = 0x0030,
/* Priv */    FLOAT_PERCENTAGE       = 0x0031,

/* Priv */    MASTER_SCALE           = 0x0100,

/* Priv */    BIT_MAP                = 0x1100,
/* Priv */    USE_BIT_MAP            = 0x1101,
/* Priv */    SOLID_BGND             = 0x1200,
/* Priv */    USE_SOLID_BGND         = 0x1201,
/* Priv */    V_GRADIENT             = 0x1300,
/* Priv */    USE_V_GRADIENT         = 0x1301,

/* Priv */    LO_SHADOW_BIAS         = 0x1400,
/* Priv */    HI_SHADOW_BIAS         = 0x1410,
/* Priv */    SHADOW_MAP_SIZE        = 0x1420,
/* Priv */    SHADOW_SAMPLES         = 0x1430,
/* Priv */    SHADOW_RANGE           = 0x1440,
/* Priv */    SHADOW_FILTER          = 0x1450,
/* Priv */    RAY_BIAS               = 0x1460,
/* Priv */  
/* Priv */    O_CONSTS               = 0x1500,
/* Priv */  
/* Priv */    AMBIENT_LIGHT          = 0x2100,

/* Priv */    FOG                    = 0x2200,
/* Priv */    USE_FOG                = 0x2201,
/* Priv */    FOG_BGND               = 0x2210,
/* Priv */    DISTANCE_CUE           = 0x2300,
/* Priv */    USE_DISTANCE_CUE       = 0x2301,
/* Priv */    LAYER_FOG              = 0x2302,
/* Priv */    USE_LAYER_FOG          = 0x2303,
/* Priv */    DCUE_BGND              = 0x2310,

/* Priv */    DEFAULT_VIEW           = 0x3000,
/* Priv */    VIEW_TOP               = 0x3010,
/* Priv */    VIEW_BOTTOM            = 0x3020,
/* Priv */    VIEW_LEFT              = 0x3030,
/* Priv */    VIEW_RIGHT             = 0x3040,
/* Priv */    VIEW_FRONT             = 0x3050,
/* Priv */    VIEW_BACK              = 0x3060,
/* Priv */    VIEW_USER              = 0x3070,
/* Priv */    VIEW_CAMERA            = 0x3080,
/* Priv */    VIEW_WINDOW            = 0x3090,

/* Priv */    NAMED_OBJECT           = 0x4000,
/* Priv */    OBJ_HIDDEN             = 0x4010,
/* Priv */    OBJ_VIS_LOFTER         = 0x4011,
/* Priv */    OBJ_DOESNT_CAST        = 0x4012,
/* Priv */    OBJ_MATTE              = 0x4013,
/* Priv */    OBJ_FAST               = 0x4014,
/* Priv */    OBJ_PROCEDURAL         = 0x4015,
/* Priv */    OBJ_FROZEN             = 0x4016,
/* Priv */    OBJ_DONT_RCVSHADOW     = 0x4017,

/* Priv */    N_TRI_OBJECT           = 0x4100,

/* Priv */    POINT_ARRAY            = 0x4110,
/* Priv */    POINT_FLAG_ARRAY       = 0x4111,
/* Priv */    FACE_ARRAY             = 0x4120,
/* Priv */    MSH_MAT_GROUP          = 0x4130,
/* Priv */    OLD_MAT_GROUP          = 0x4131,
/* Priv */    TEX_VERTS              = 0x4140,
/* Priv */    SMOOTH_GROUP           = 0x4150,
/* Priv */    MESH_MATRIX            = 0x4160,
/* Priv */    MESH_COLOR             = 0x4165,   
/* Priv */    MESH_TEXTURE_INFO      = 0x4170,
/* Priv */    PROC_NAME              = 0x4181,
/* Priv */    PROC_DATA              = 0x4182,
/* Priv */    MSH_BOXMAP             = 0x4190,

/* Priv */    N_D_L_OLD              = 0x4400,

/* Priv */    N_CAM_OLD              = 0x4500,   

/* Priv */    N_DIRECT_LIGHT         = 0x4600,
/* Priv */    DL_SPOTLIGHT           = 0x4610,
/* Priv */    DL_OFF                 = 0x4620,
/* Priv */    DL_ATTENUATE           = 0x4625,
/* Priv */    DL_RAYSHAD             = 0x4627,
/* Priv */    DL_SHADOWED            = 0x4630,
/* Priv */    DL_LOCAL_SHADOW        = 0x4640,
/* Priv */    DL_LOCAL_SHADOW2       = 0x4641,
/* Priv */    DL_SEE_CONE            = 0x4650,
/* Priv */    DL_SPOT_RECTANGULAR    = 0x4651,
/* Priv */    DL_SPOT_OVERSHOOT      = 0x4652,
/* Priv */    DL_SPOT_PROJECTOR      = 0x4653,
/* Priv */    DL_EXCLUDE             = 0x4654,
/* Priv */    DL_RANGE               = 0x4655, /* Not used in R3 */
/* Priv */    DL_SPOT_ROLL           = 0x4656,
/* Priv */    DL_SPOT_ASPECT         = 0x4657,
/* Priv */    DL_RAY_BIAS            = 0x4658,
/* Priv */    DL_INNER_RANGE = 0x4659,
/* Priv */    DL_OUTER_RANGE = 0x465A,
/* Priv */    DL_MULTIPLIER = 0x465B,

/* Priv */    N_AMBIENT_LIGHT        = 0x4680,

/* Priv */    N_CAMERA               = 0x4700,
/* Priv */    CAM_SEE_CONE           = 0x4710,
/* Priv */    CAM_RANGES             = 0x4720,

/* Priv */    HIERARCHY              = 0x4F00,
/* Priv */    PARENT_OBJECT          = 0x4F10,
/* Priv */    PIVOT_OBJECT           = 0x4F20,
/* Priv */    PIVOT_LIMITS           = 0x4F30,
/* Priv */    PIVOT_ORDER            = 0x4F40,
/* Priv */    XLATE_RANGE            = 0x4F50,

/* Priv */    POLY_2D                = 0x5000,

/* Priv */    /* Flags in shaper file that tell whether polys make up an ok shape */

/* Priv */    SHAPE_OK               = 0x5010,
/* Priv */    SHAPE_NOT_OK           = 0x5011,

/* Priv */    SHAPE_HOOK             = 0x5020,

/* Priv */    PATH_3D                = 0x6000,
/* Priv */    PATH_MATRIX            = 0x6005,
/* Priv */    SHAPE_2D               = 0x6010,
/* Priv */    M_SCALE                = 0x6020,
/* Priv */    M_TWIST                = 0x6030,
/* Priv */    M_TEETER               = 0x6040,
/* Priv */    M_FIT                  = 0x6050,
/* Priv */    M_BEVEL                = 0x6060,
/* Priv */    XZ_CURVE               = 0x6070,
/* Priv */    YZ_CURVE               = 0x6080,
/* Priv */    INTERPCT               = 0x6090,
/* Priv */    DEFORM_LIMIT           = 0x60A0,

/* Priv */    /* Flags for Modeler options */

/* Priv */    USE_CONTOUR            = 0x6100,
/* Priv */    USE_TWEEN              = 0x6110,
/* Priv */    USE_SCALE              = 0x6120,
/* Priv */    USE_TWIST              = 0x6130,
/* Priv */    USE_TEETER             = 0x6140,
/* Priv */    USE_FIT                = 0x6150,
/* Priv */    USE_BEVEL              = 0x6160,

/* Priv */    /* Viewport description chunks */

/* Priv */    VIEWPORT_LAYOUT_OLD    = 0x7000,
/* Priv */    VIEWPORT_DATA_OLD      = 0x7010,
/* Priv */    VIEWPORT_LAYOUT        = 0x7001,
/* Priv */    VIEWPORT_DATA          = 0x7011,
/* Priv */    VIEWPORT_DATA_3        = 0x7012,
/* Priv */    VIEWPORT_SIZE          = 0x7020,
/* Priv */    NETWORK_VIEW           = 0x7030,

/* Priv */    /* External Application Data */

/* Priv */    XDATA_SECTION          = 0x8000,
/* Priv */    XDATA_ENTRY            = 0x8001,
/* Priv */    XDATA_APPNAME          = 0x8002,
/* Priv */    XDATA_STRING           = 0x8003,
/* Priv */    XDATA_FLOAT            = 0x8004,
/* Priv */    XDATA_DOUBLE           = 0x8005,
/* Priv */    XDATA_SHORT            = 0x8006,
/* Priv */    XDATA_LONG = 0x8007,
/* Priv */    XDATA_VOID = 0x8008,
/* Priv */    XDATA_GROUP = 0x8009,
/* Priv */    XDATA_RFU6 = 0x800A,
/* Priv */    XDATA_RFU5 = 0x800B,
/* Priv */    XDATA_RFU4 = 0x800C,
/* Priv */    XDATA_RFU3 = 0x800D,
/* Priv */    XDATA_RFU2 = 0x800E,
/* Priv */    XDATA_RFU1 = 0x800F,
/* Priv */    
/* Priv */    PARENT_NAME = 0x80F0,

/* Priv */    /* Material Chunk IDs */

/* Priv */    MAT_ENTRY              = 0xAFFF,
/* Priv */    MAT_NAME               = 0xA000,
/* Priv */    MAT_AMBIENT            = 0xA010,
/* Priv */    MAT_DIFFUSE            = 0xA020,
/* Priv */    MAT_SPECULAR           = 0xA030,
/* Priv */    MAT_SHININESS          = 0xA040,
/* Priv */    MAT_SHIN2PCT			  = 0xA041,
/* Priv */    MAT_SHIN3PCT		     = 0xA042,
/* Priv */    MAT_TRANSPARENCY  	  = 0xA050,
/* Priv */    MAT_XPFALL             = 0xA052,
/* Priv */    MAT_REFBLUR            = 0xA053,

/* Priv */    MAT_SELF_ILLUM         = 0xA080,
/* Priv */    MAT_TWO_SIDE           = 0xA081,
/* Priv */    MAT_DECAL              = 0xA082,
/* Priv */    MAT_ADDITIVE           = 0xA083,
/* Priv */    MAT_SELF_ILPCT  	  = 0xA084,
/* Priv */    MAT_WIRE		  = 0xA085,
/* Priv */    MAT_SUPERSMP		  = 0xA086,
/* Priv */    MAT_WIRESIZE		  = 0xA087,
/* Priv */    MAT_FACEMAP		  = 0xA088,
/* Priv */    MAT_XPFALLIN		  = 0xA08A,
/* Priv */    MAT_PHONGSOFT	  = 0xA08C,
/* Priv */    MAT_WIREABS  	= 0xA08E,

/* Priv */    MAT_SHADING            = 0xA100,

/* Priv */    MAT_TEXMAP             = 0xA200,
/* Priv */    MAT_OPACMAP            = 0xA210,
/* Priv */    MAT_REFLMAP            = 0xA220,
/* Priv */    MAT_BUMPMAP            = 0xA230,
/* Priv */    MAT_SPECMAP            = 0xA204,
/* Priv */    MAT_USE_XPFALL         = 0xA240,
/* Priv */    MAT_USE_REFBLUR        = 0xA250,
/* Priv */    MAT_BUMP_PERCENT       = 0xA252,

/* Priv */    MAT_MAPNAME            = 0xA300,
/* Priv */    MAT_ACUBIC             = 0xA310,

/* Priv */    MAT_SXP_TEXT_DATA      = 0xA320,
/* Priv */    MAT_SXP_TEXT2_DATA     = 0xA321,
/* Priv */    MAT_SXP_OPAC_DATA      = 0xA322,
/* Priv */    MAT_SXP_BUMP_DATA      = 0xA324,
/* Priv */    MAT_SXP_SPEC_DATA      = 0xA325,
/* Priv */    MAT_SXP_SHIN_DATA 	  = 0xA326,
/* Priv */    MAT_SXP_SELFI_DATA 	  = 0xA328,
/* Priv */    MAT_SXP_TEXT_MASKDATA  = 0xA32A,
/* Priv */    MAT_SXP_TEXT2_MASKDATA = 0xA32C,
/* Priv */    MAT_SXP_OPAC_MASKDATA  = 0xA32E,
/* Priv */    MAT_SXP_BUMP_MASKDATA  = 0xA330,
/* Priv */    MAT_SXP_SPEC_MASKDATA  = 0xA332,
/* Priv */    MAT_SXP_SHIN_MASKDATA  = 0xA334,
/* Priv */    MAT_SXP_SELFI_MASKDATA = 0xA336,
/* Priv */    MAT_SXP_REFL_MASKDATA  = 0xA338,
/* Priv */    MAT_TEX2MAP 		  = 0xA33A,
/* Priv */    MAT_SHINMAP 		  = 0xA33C,
/* Priv */    MAT_SELFIMAP 	  = 0xA33D,
/* Priv */    MAT_TEXMASK 		  = 0xA33E,
/* Priv */    MAT_TEX2MASK 	  = 0xA340,
/* Priv */    MAT_OPACMASK 	  = 0xA342,
/* Priv */    MAT_BUMPMASK 	  = 0xA344,
/* Priv */    MAT_SHINMASK 	  = 0xA346,
/* Priv */    MAT_SPECMASK 	  = 0xA348,
/* Priv */    MAT_SELFIMASK 	  = 0xA34A,
/* Priv */    MAT_REFLMASK 	  = 0xA34C,
/* Priv */    MAT_MAP_TILINGOLD 	  = 0xA350,
/* Priv */    MAT_MAP_TILING 	  = 0xA351,
/* Priv */    MAT_MAP_TEXBLUR_OLD 	  = 0xA352,
/* Priv */    MAT_MAP_TEXBLUR 	  = 0xA353,
/* Priv */    MAT_MAP_USCALE 	  = 0xA354,
/* Priv */    MAT_MAP_VSCALE 	  = 0xA356,
/* Priv */    MAT_MAP_UOFFSET 	  = 0xA358,
/* Priv */    MAT_MAP_VOFFSET 	  = 0xA35A,
/* Priv */    MAT_MAP_ANG 		  = 0xA35C,
/* Priv */    MAT_MAP_COL1 	  = 0xA360,
/* Priv */    MAT_MAP_COL2 	  = 0xA362,
/* Priv */    MAT_MAP_RCOL 	  = 0xA364,
/* Priv */    MAT_MAP_GCOL 	  = 0xA366,
/* Priv */    MAT_MAP_BCOL 	  = 0xA368,

/* Priv */         /* Keyframe Chunk IDs */

/* Priv */    KFDATA                 = 0xB000,
/* Priv */    KFHDR                  = 0xB00A,
/* Priv */    AMBIENT_NODE_TAG       = 0xB001,
/* Priv */    OBJECT_NODE_TAG        = 0xB002,
/* Priv */    CAMERA_NODE_TAG        = 0xB003,
/* Priv */    TARGET_NODE_TAG        = 0xB004,
/* Priv */    LIGHT_NODE_TAG         = 0xB005,
/* Priv */    L_TARGET_NODE_TAG      = 0xB006,
/* Priv */    SPOTLIGHT_NODE_TAG     = 0xB007,

/* Priv */    KFSEG                  = 0xB008,
/* Priv */    KFCURTIME              = 0xB009,
/* Priv */    NODE_HDR               = 0xB010,
/* Priv */    INSTANCE_NAME          = 0xB011,
/* Priv */    PRESCALE               = 0xB012,
/* Priv */    PIVOT                  = 0xB013,
/* Priv */    BOUNDBOX               = 0xB014,
/* Priv */    MORPH_SMOOTH           = 0xB015,
/* Priv */    POS_TRACK_TAG          = 0xB020,
/* Priv */    ROT_TRACK_TAG          = 0xB021,
/* Priv */    SCL_TRACK_TAG          = 0xB022,
/* Priv */    FOV_TRACK_TAG          = 0xB023,
/* Priv */    ROLL_TRACK_TAG         = 0xB024,
/* Priv */    COL_TRACK_TAG          = 0xB025,
/* Priv */    MORPH_TRACK_TAG        = 0xB026,
/* Priv */    HOT_TRACK_TAG          = 0xB027,
/* Priv */    FALL_TRACK_TAG         = 0xB028,
/* Priv */    HIDE_TRACK_TAG         = 0xB029,
/* Priv */    NODE_ID                = 0xB030,
/* Priv */    
/* Priv */    CMAGIC = 0xC23D,

/* Priv */    C_MDRAWER = 0xC010,
/* Priv */    C_TDRAWER = 0xC020,
/* Priv */    C_SHPDRAWER = 0xC030,
/* Priv */    C_MODDRAWER = 0xC040,
/* Priv */    C_RIPDRAWER = 0xC050,
/* Priv */    C_TXDRAWER = 0xC060,
/* Priv */    C_PDRAWER = 0xC062,
/* Priv */    C_MTLDRAWER = 0xC064,
/* Priv */    C_FLIDRAWER = 0xC066,
/* Priv */    C_CUBDRAWER = 0xC067,
/* Priv */    C_MFILE = 0xC070,
/* Priv */    C_SHPFILE = 0xC080,
/* Priv */    C_MODFILE = 0xC090,
/* Priv */    C_RIPFILE = 0xC0A0,
/* Priv */    C_TXFILE = 0xC0B0,
/* Priv */    C_PFILE = 0xC0B2,
/* Priv */    C_MTLFILE = 0xC0B4,
/* Priv */    C_FLIFILE = 0xC0B6,
/* Priv */    C_PALFILE = 0xC0B8,
/* Priv */    C_TX_STRING = 0xC0C0,
/* Priv */    C_CONSTS = 0xC0D0,
/* Priv */    C_SNAPS = 0xC0E0,
/* Priv */    C_GRIDS = 0xC0F0,
/* Priv */    C_ASNAPS = 0xC100,
/* Priv */    C_GRID_RANGE = 0xC110,
/* Priv */    C_RENDTYPE = 0xC120,
/* Priv */    C_PROGMODE = 0xC130,
/* Priv */    C_PREVMODE = 0xC140,
/* Priv */    C_MODWMODE = 0xC150,
/* Priv */    C_MODMODEL = 0xC160,
/* Priv */    C_ALL_LINES = 0xC170,
/* Priv */    C_BACK_TYPE = 0xC180,
/* Priv */    C_MD_CS = 0xC190,
/* Priv */    C_MD_CE = 0xC1A0,
/* Priv */    C_MD_SML = 0xC1B0,
/* Priv */    C_MD_SMW = 0xC1C0,
/* Priv */    C_LOFT_WITH_TEXTURE = 0xC1C3,
/* Priv */    C_LOFT_L_REPEAT = 0xC1C4,
/* Priv */    C_LOFT_W_REPEAT = 0xC1C5,
/* Priv */    C_LOFT_UV_NORMALIZE = 0xC1C6,
/* Priv */    C_WELD_LOFT = 0xC1C7,
/* Priv */    C_MD_PDET = 0xC1D0,
/* Priv */    C_MD_SDET = 0xC1E0,
/* Priv */    C_RGB_RMODE = 0xC1F0,
/* Priv */    C_RGB_HIDE = 0xC200,
/* Priv */    C_RGB_MAPSW = 0xC202,
/* Priv */    C_RGB_TWOSIDE = 0xC204,
/* Priv */    C_RGB_SHADOW = 0xC208,
/* Priv */    C_RGB_AA = 0xC210,
/* Priv */    C_RGB_OVW = 0xC220,
/* Priv */    C_RGB_OVH = 0xC230,
/* Priv */    C_RGB_PICTYPE = 0xC240,
/* Priv */    C_RGB_OUTPUT = 0xC250,
/* Priv */    C_RGB_TODISK = 0xC253,
/* Priv */    C_RGB_COMPRESS = 0xC254,
/* Priv */    C_JPEG_COMPRESSION = 0xC255,
/* Priv */    C_RGB_DISPDEV = 0xC256,
/* Priv */    C_RGB_HARDDEV = 0xC259,
/* Priv */    C_RGB_PATH = 0xC25A,
/* Priv */    C_BITMAP_DRAWER = 0xC25B,
/* Priv */    C_RGB_FILE = 0xC260,
/* Priv */    C_RGB_OVASPECT = 0xC270,

/* Priv */    C_RGB_ANIMTYPE = 0xC271,
/* Priv */    C_RENDER_ALL = 0xC272,
/* Priv */    C_REND_FROM = 0xC273,
/* Priv */    C_REND_TO = 0xC274,
/* Priv */    C_REND_NTH = 0xC275,
/* Priv */    C_PAL_TYPE = 0xC276,
/* Priv */    C_RND_TURBO = 0xC277,
/* Priv */    C_RND_MIP	= 0xC278,
/* Priv */    C_BGND_METHOD = 0xC279,
/* Priv */    C_AUTO_REFLECT = 0xC27A,
/* Priv */    C_VP_FROM = 0xC27B,
/* Priv */    C_VP_TO = 0xC27C,
/* Priv */    C_VP_NTH = 0xC27D,
/* Priv */    C_REND_TSTEP = 0xC27E,
/* Priv */    C_VP_TSTEP = 0xC27F,

/* Priv */    C_SRDIAM = 0xC280,
/* Priv */    C_SRDEG = 0xC290,
/* Priv */    C_SRSEG = 0xC2A0,
/* Priv */    C_SRDIR = 0xC2B0,
/* Priv */    C_HETOP = 0xC2C0,
/* Priv */    C_HEBOT = 0xC2D0,
/* Priv */    C_HEHT = 0xC2E0,
/* Priv */    C_HETURNS = 0xC2F0,
/* Priv */    C_HEDEG = 0xC300,
/* Priv */    C_HESEG = 0xC310,
/* Priv */    C_HEDIR = 0xC320,
/* Priv */    C_QUIKSTUFF = 0xC330,
/* Priv */    C_SEE_LIGHTS = 0xC340,
/* Priv */    C_SEE_CAMERAS = 0xC350,
/* Priv */    C_SEE_3D = 0xC360,
/* Priv */    C_MESHSEL = 0xC370,
/* Priv */    C_MESHUNSEL = 0xC380,
/* Priv */    C_POLYSEL = 0xC390,
/* Priv */    C_POLYUNSEL = 0xC3A0,
/* Priv */    C_SHPLOCAL = 0xC3A2,
/* Priv */    C_MSHLOCAL = 0xC3A4,
/* Priv */    C_NUM_FORMAT = 0xC3B0,
/* Priv */    C_ARCH_DENOM = 0xC3C0,
/* Priv */    C_IN_DEVICE = 0xC3D0,
/* Priv */    C_MSCALE = 0xC3E0,
/* Priv */    C_COMM_PORT = 0xC3F0,
/* Priv */    C_TAB_BASES = 0xC400,
/* Priv */    C_TAB_DIVS = 0xC410,
/* Priv */    C_MASTER_SCALES = 0xC420,
/* Priv */    C_SHOW_1STVERT = 0xC430,
/* Priv */    C_SHAPER_OK = 0xC440,
/* Priv */    C_LOFTER_OK = 0xC450,
/* Priv */    C_EDITOR_OK = 0xC460,
/* Priv */    C_KEYFRAMER_OK = 0xC470,
/* Priv */    C_PICKSIZE = 0xC480,
/* Priv */    C_MAPTYPE = 0xC490,
/* Priv */    C_MAP_DISPLAY = 0xC4A0,
/* Priv */    C_TILE_XY = 0xC4B0,
/* Priv */    C_MAP_XYZ = 0xC4C0,
/* Priv */    C_MAP_SCALE = 0xC4D0,
/* Priv */    C_MAP_MATRIX_OLD = 0xC4E0,
/* Priv */    C_MAP_MATRIX = 0xC4E1,
/* Priv */    C_MAP_WID_HT = 0xC4F0,
/* Priv */    C_OBNAME = 0xC500,
/* Priv */    C_CAMNAME = 0xC510,
/* Priv */    C_LTNAME = 0xC520,
/* Priv */    C_CUR_MNAME = 0xC525,
/* Priv */    C_CURMTL_FROM_MESH = 0xC526,
/* Priv */    C_GET_SHAPE_MAKE_FACES = 0xC527,
/* Priv */    C_DETAIL = 0xC530,
/* Priv */    C_VERTMARK = 0xC540,
/* Priv */    C_MSHAX = 0xC550,
/* Priv */    C_MSHCP = 0xC560,
/* Priv */    C_USERAX = 0xC570,
/* Priv */    C_SHOOK = 0xC580,
/* Priv */    C_RAX = 0xC590,
/* Priv */    C_STAPE = 0xC5A0,
/* Priv */    C_LTAPE = 0xC5B0,
/* Priv */    C_ETAPE = 0xC5C0,
/* Priv */    C_KTAPE = 0xC5C8,
/* Priv */    C_SPHSEGS = 0xC5D0,
/* Priv */    C_GEOSMOOTH = 0xC5E0,
/* Priv */    C_HEMISEGS = 0xC5F0,
/* Priv */    C_PRISMSEGS = 0xC600,
/* Priv */    C_PRISMSIDES = 0xC610,
/* Priv */    C_TUBESEGS = 0xC620,
/* Priv */    C_TUBESIDES = 0xC630,
/* Priv */    C_TORSEGS = 0xC640,
/* Priv */    C_TORSIDES = 0xC650,
/* Priv */    C_CONESIDES = 0xC660,
/* Priv */    C_CONESEGS = 0xC661,
/* Priv */    C_NGPARMS = 0xC670,
/* Priv */    C_PTHLEVEL = 0xC680,
/* Priv */    C_MSCSYM = 0xC690,
/* Priv */    C_MFTSYM = 0xC6A0,
/* Priv */    C_MTTSYM = 0xC6B0,
/* Priv */    C_SMOOTHING = 0xC6C0,
/* Priv */    C_MODICOUNT = 0xC6D0,
/* Priv */    C_FONTSEL = 0xC6E0,
/* Priv */    C_TESS_TYPE = 0xC6f0,
/* Priv */    C_TESS_TENSION = 0xC6f1,

/* Priv */    C_SEG_START = 0xC700,
/* Priv */    C_SEG_END = 0xC705,
/* Priv */    C_CURTIME = 0xC710,
/* Priv */    C_ANIMLENGTH = 0xC715,
/* Priv */    C_PV_FROM = 0xC720,
/* Priv */    C_PV_TO = 0xC725,
/* Priv */    C_PV_DOFNUM = 0xC730,
/* Priv */    C_PV_RNG = 0xC735,
/* Priv */    C_PV_NTH = 0xC740,
/* Priv */    C_PV_TYPE = 0xC745,
/* Priv */    C_PV_METHOD = 0xC750,
/* Priv */    C_PV_FPS = 0xC755,
/* Priv */    C_VTR_FRAMES = 0xC765,
/* Priv */    C_VTR_HDTL = 0xC770,
/* Priv */    C_VTR_HD = 0xC771,
/* Priv */    C_VTR_TL = 0xC772,
/* Priv */    C_VTR_IN = 0xC775,
/* Priv */    C_VTR_PK = 0xC780,
/* Priv */    C_VTR_SH = 0xC785,

/* Priv */ /* Material chunks */

/* Priv */    C_WORK_MTLS = 0xC790,	  /* Old-style -- now ignored */
/* Priv */    C_WORK_MTLS_2 = 0xC792, /* Old-style -- now ignored */
/* Priv */    C_WORK_MTLS_3 = 0xC793, /* Old-style -- now ignored */
/* Priv */    C_WORK_MTLS_4 = 0xC794, /* Old-style -- now ignored */
/* Priv */    C_WORK_MTLS_5 = 0xCB00, /* Old-style -- now ignored */
/* Priv */    C_WORK_MTLS_6 = 0xCB01, /* Old-style -- now ignored */
/* Priv */    C_WORK_MTLS_7 = 0xCB02, /* Old-style -- now ignored */
/* Priv */    C_WORK_MTLS_8 = 0xCB03, /* Old-style -- now ignored */
/* Priv */    C_WORKMTL = 0xCB04,
/* Priv */    C_SXP_TEXT_DATA = 0xCB10,
/* Priv */    C_SXP_TEXT2_DATA = 0xCB20,
/* Priv */    C_SXP_OPAC_DATA = 0xCB11,
/* Priv */    C_SXP_BUMP_DATA = 0xCB12,
/* Priv */    C_SXP_SPEC_DATA = 0xCB24,
/* Priv */    C_SXP_SHIN_DATA = 0xCB13,
/* Priv */    C_SXP_SELFI_DATA = 0xCB28,
/* Priv */    C_SXP_TEXT_MASKDATA = 0xCB30,
/* Priv */    C_SXP_TEXT2_MASKDATA = 0xCB32,
/* Priv */    C_SXP_OPAC_MASKDATA = 0xCB34,
/* Priv */    C_SXP_BUMP_MASKDATA = 0xCB36,
/* Priv */    C_SXP_SPEC_MASKDATA = 0xCB38,
/* Priv */    C_SXP_SHIN_MASKDATA = 0xCB3A,
/* Priv */    C_SXP_SELFI_MASKDATA = 0xC3C,
/* Priv */    C_SXP_REFL_MASKDATA = 0xCB3E,

/* Priv */    C_BGTYPE = 0xC7A1,
/* Priv */    C_MEDTILE = 0xC7B0,

/* Priv */ /* Contrast */

/* Priv */    C_LO_CONTRAST = 0xC7D0,
/* Priv */    C_HI_CONTRAST = 0xC7D1,

/* Priv */ /* 3d frozen display */

/* Priv */    C_FROZ_DISPLAY = 0xC7E0,

/* Priv */ /* Booleans */
/* Priv */    C_BOOLWELD = 0xc7f0,
/* Priv */    C_BOOLTYPE = 0xc7f1,

/* Priv */    C_ANG_THRESH = 0xC900,
/* Priv */    C_SS_THRESH = 0xC901,
/* Priv */    C_TEXTURE_BLUR_DEFAULT = 0xC903,

/* Priv */    C_MAPDRAWER = 0xCA00,
/* Priv */    C_MAPDRAWER1 = 0xCA01,
/* Priv */    C_MAPDRAWER2 = 0xCA02,
/* Priv */    C_MAPDRAWER3 = 0xCA03,
/* Priv */    C_MAPDRAWER4 = 0xCA04,
/* Priv */    C_MAPDRAWER5 = 0xCA05,
/* Priv */    C_MAPDRAWER6 = 0xCA06,
/* Priv */    C_MAPDRAWER7 = 0xCA07,
/* Priv */    C_MAPDRAWER8 = 0xCA08,
/* Priv */    C_MAPDRAWER9 = 0xCA09,
/* Priv */    C_MAPDRAWER_ENTRY = 0xCA10,

/* Priv */ /* system options */
/* Priv */    C_BACKUP_FILE = 0xCA20,
/* Priv */    C_DITHER_256 = 0xCA21,
/* Priv */    C_SAVE_LAST = 0xCA22,
/* Priv */    C_USE_ALPHA = 0xCA23,
/* Priv */    C_TGA_DEPTH = 0xCA24,
/* Priv */    C_REND_FIELDS = 0xCA25,
/* Priv */    C_REFLIP = 0xCA26,
/* Priv */    C_SEL_ITEMTOG = 0xCA27,
/* Priv */    C_SEL_RESET = 0xCA28,
/* Priv */    C_STICKY_KEYINF = 0xCA29,
/* Priv */    C_WELD_THRESHOLD = 0xCA2A,
/* Priv */    C_ZCLIP_POINT = 0xCA2B,
/* Priv */    C_ALPHA_SPLIT = 0xCA2C,
/* Priv */    C_KF_SHOW_BACKFACE = 0xCA30,
/* Priv */    C_OPTIMIZE_LOFT = 0xCA40,
/* Priv */    C_TENS_DEFAULT = 0xCA42,
/* Priv */    C_CONT_DEFAULT = 0xCA44,
/* Priv */    C_BIAS_DEFAULT = 0xCA46,

/* Priv */    C_DXFNAME_SRC  = 0xCA50,
/* Priv */    C_AUTO_WELD  = 0xCA60,
/* Priv */    C_AUTO_UNIFY  = 0xCA70,
/* Priv */    C_AUTO_SMOOTH  = 0xCA80,
/* Priv */    C_DXF_SMOOTH_ANG  = 0xCA90,
/* Priv */    C_SMOOTH_ANG  = 0xCAA0,

/* Priv */ /* Special network-use chunks */

/* Priv */    C_NET_USE_VPOST = 0xCC00,
/* Priv */    C_NET_USE_GAMMA = 0xCC10,
/* Priv */    C_NET_FIELD_ORDER = 0xCC20,

/* Priv */    C_BLUR_FRAMES = 0xCD00,
/* Priv */    C_BLUR_SAMPLES = 0xCD10,
/* Priv */    C_BLUR_DUR = 0xCD20,
/* Priv */    C_HOT_METHOD = 0xCD30,
/* Priv */    C_HOT_CHECK = 0xCD40,
/* Priv */    C_PIXEL_SIZE = 0xCD50,
/* Priv */    C_DISP_GAMMA = 0xCD60,
/* Priv */    C_FBUF_GAMMA = 0xCD70,
/* Priv */    C_FILE_OUT_GAMMA = 0xCD80,
/* Priv */    C_FILE_IN_GAMMA = 0xCD82,
/* Priv */    C_GAMMA_CORRECT = 0xCD84,
/* Priv */    C_APPLY_DISP_GAMMA = 0xCD90  /* OBSOLETE */,
/* Priv */    C_APPLY_FBUF_GAMMA = 0xCDA0  /* OBSOLETE */,
/* Priv */    C_APPLY_FILE_GAMMA = 0xCDB0  /* OBSOLETE */,
/* Priv */    C_FORCE_WIRE = 0xCDC0,
/* Priv */    C_RAY_SHADOWS = 0xCDD0,
/* Priv */    C_MASTER_AMBIENT = 0xCDE0,
/* Priv */    C_SUPER_SAMPLE = 0xCDF0,
/* Priv */    C_OBJECT_MBLUR = 0xCE00,
/* Priv */    C_MBLUR_DITHER = 0xCE10,
/* Priv */    C_DITHER_24 = 0xCE20,
/* Priv */    C_SUPER_BLACK = 0xCE30,
/* Priv */    C_SAFE_FRAME = 0xCE40,
/* Priv */    C_VIEW_PRES_RATIO = 0xCE50,
/* Priv */    C_BGND_PRES_RATIO = 0xCE60,
/* Priv */    C_NTH_SERIAL_NUM = 0xCE70,

/* Priv */    /* Video Post */
/* Priv */    VPDATA = 0xd000,

/* Priv */    P_QUEUE_ENTRY = 0xd100,
/* Priv */    P_QUEUE_IMAGE = 0xd110,
/* Priv */    P_QUEUE_USEIGAMMA = 0xd114,
/* Priv */    P_QUEUE_PROC = 0xd120,
/* Priv */    P_QUEUE_SOLID = 0xd130,
/* Priv */    P_QUEUE_GRADIENT = 0xd140,
/* Priv */    P_QUEUE_KF = 0xd150,
/* Priv */    P_QUEUE_MOTBLUR = 0xd152,
/* Priv */    P_QUEUE_MB_REPEAT = 0xd153,
/* Priv */    P_QUEUE_NONE = 0xd160,

/* Priv */    P_QUEUE_RESIZE = 0xd180,
/* Priv */    P_QUEUE_OFFSET = 0xd185,
/* Priv */    P_QUEUE_ALIGN = 0xd190,

/* Priv */    P_CUSTOM_SIZE = 0xd1a0,

/* Priv */    P_ALPH_NONE = 0xd210,
/* Priv */    P_ALPH_PSEUDO = 0xd220	/* Old chunk */,
/* Priv */    P_ALPH_OP_PSEUDO = 0xd221	/* Old chunk */,
/* Priv */    P_ALPH_BLUR = 0xd222		/* Replaces pseudo */,
/* Priv */    P_ALPH_PCOL = 0xd225,
/* Priv */    P_ALPH_C0 = 0xd230,
/* Priv */    P_ALPH_OP_KEY = 0xd231,
/* Priv */    P_ALPH_KCOL = 0xd235,
/* Priv */    P_ALPH_OP_NOCONV = 0xd238,
/* Priv */    P_ALPH_IMAGE = 0xd240,
/* Priv */    P_ALPH_ALPHA = 0xd250,
/* Priv */    P_ALPH_QUES = 0xd260,
/* Priv */    P_ALPH_QUEIMG = 0xd265,
/* Priv */    P_ALPH_CUTOFF = 0xd270,
/* Priv */    P_ALPHANEG = 0xd280,

/* Priv */    P_TRAN_NONE = 0xd300,
/* Priv */    P_TRAN_IMAGE = 0xd310,
/* Priv */    P_TRAN_FRAMES = 0xd312,
/* Priv */    P_TRAN_FADEIN = 0xd320,
/* Priv */    P_TRAN_FADEOUT = 0xd330,
/* Priv */    P_TRANNEG = 0xd340,

/* Priv */    P_RANGES = 0xd400,

/* Priv */    P_PROC_DATA = 0xd500

/* Priv */ } chunktag3ds;


/* Priv */ /* chunk3ds - Internal database representation of file information */
/* Priv */ typedef struct chunk3ds {
/* Priv */    chunktag3ds tag;           /* Type of chunk */
/* Priv */    ulong3ds     size;         /* Number of bytes used by chunk */
/* Priv */    ulong3ds     position;     /* Offset in source file */
/* Priv */    void        *data;         /* Memory copy of file data */
/* Priv */    struct chunk3ds *sibling;  /* Next chunk in database */
/* Priv */    struct chunk3ds *children; /* Chunks contained within this chunk */
/* Priv */    ubyte3ds readindex;        /* Index of source file in file table */
/* Priv */    ubyte3ds writeindex;       /* Index of destination file in file table */
/* Priv */ } chunk3ds;

/* Priv */ /* chunklistentry3ds - Cross reference between name and chunk */
/* Priv */ typedef struct {
/* Priv */    char3ds *name;                  /* Chunk Name list */
/* Priv */    chunk3ds *chunk;                /* Corresponding Pos */
/* Priv */ } chunklistentry3ds;

/* Priv */ /* chunklist3ds - List of cross references */
/* Priv */ typedef struct 
/* Priv */ {
/* Priv */    ulong3ds count; /* Number of entries in list */
/* Priv */    chunklistentry3ds *list; /* Contents of list */
/* Priv */ } chunklist3ds;


/* namelistentry3ds - Name of database object */
typedef struct 
{
   char3ds *name; /* Name of object */
} namelistentry3ds;

/* namelist3ds - List of database object names */
typedef struct
{
   ulong3ds count;          /*--- How many entries are in list */
   ulong3ds spaces;         /*--- How much space for entries */
   namelistentry3ds *list;  /*--- char ** to access pointers */
} namelist3ds;


/* Priv */ /* filestate3ds - Read/write state of a file */
/* Priv */ typedef enum 
/* Priv */ {
/* Priv */    StateNotKnown = 0, /* No state determined yet, file not open */
/* Priv */    ReadFromFile = 1,  /* Open for read */
/* Priv */    WriteToFile = 2,   /* Open for write */
/* Priv */    ReadWriteFile = 3  /* Open for read and write, not used by toolkit */
/* Priv */ } filestate3ds;

/* file3ds - Handle to 3D Studio files */
typedef struct
{
   FILE *file;         /* stdio file pointer */
   char3ds *filename;  /* name of file */
   filestate3ds state; /* file open state */
   ubyte3ds index;     /* Position of pointer in the FileContextList, if the
                          index eq InvalidFileContext3ds, then it is not in the
                          list */
   void *buffer;       /* Buffered I/O buffer */
   ulong3ds buffersize;
   byte3ds istempfile; /* True3ds if file is a temp file */
} file3ds;

/* Priv */ /* dbtype3ds - Database type settings */
/* Priv */ typedef enum
/* Priv */ {
/* Priv */    Unknown,      /* Database has not be created yet */
/* Priv */    MeshFile,     /* 3D Studio .3DS file */
/* Priv */    ProjectFile,  /* 3D STudio .PRJ file */
/* Priv */    MaterialFile  /* 3D Studio .MLI file */
/* Priv */ } dbtype3ds;

/* database3ds - File database */
typedef struct
{
   chunk3ds *topchunk; /* top chunk in the file */
   byte3ds objlistdirty; /* If true, than *objlist needs to be recreated */
   byte3ds matlistdirty;
   byte3ds nodelistdirty;
   chunklist3ds *objlist; /* Quick Cross references between names and database chunks */
   chunklist3ds *matlist;
   chunklist3ds *nodelist;
} database3ds;
typedef enum
{
   NoView3ds,
   TopView3ds,
   BottomView3ds,
   LeftView3ds,
   RightView3ds,
   FrontView3ds,
   BackView3ds,
   UserView3ds,
   CameraView3ds,
   SpotlightView3ds
} viewtype3ds;

typedef struct
{
   ushort3ds xpos;
   ushort3ds ypos;
   ushort3ds width;
   ushort3ds height;
} viewsize3ds;

/* Used to describe top, bottom, left, right, front and back views */
typedef struct
{
   point3ds center; /* Center of orthagonal view */
   float3ds zoom; /* View zoom factor */
} orthoview3ds;

/* Used to describe user views */
typedef struct
{
   point3ds center; /* Center of user view */
   float3ds zoom; /* View zoom factor */
   float3ds horang; /* Horizontal angle of view */
   float3ds verang; /* Veritical angle of view */
} userview3ds;

/* Used to describe camera views */
typedef struct
{
   char3ds name[11]; /* Name of the camera used in the view */
} cameraview3ds;

/* Viewport structure details the kind of view in a viewport */
typedef struct
{
   viewtype3ds type; /* top, bottom, left, right, front, back, user and camera */
   viewsize3ds size; /* Size of the viewport */
   orthoview3ds ortho; /* used for top, bottom, left, right, front, and back views */
   userview3ds user; /* Used for user views */
   cameraview3ds camera; /* Used for camera views */
} viewport3ds;
typedef enum 
{
   UseShadowMap,
   UseRayTraceShadow
} shadowstyle3ds;

typedef struct { /* global shadow settings */
   shadowstyle3ds type; /* Either UseShadowMaps or UseRayTraceShadows */
   float3ds bias; /* shadow bias factor. */
   float3ds raybias; /* shadow ray bais factor. Used in R3 */
   short3ds mapsize; /* shadow map size */
   float3ds filter; /* shadow filter */
} shadowsets3ds;
   
typedef struct {
   float3ds masterscale; /* Master mesh scale factor */
   shadowsets3ds shadow; /* Global shadow settings */
   fcolor3ds ambientlight;  /* ambient light color */
   point3ds oconsts; /* default object constructing axis */
} meshset3ds;
typedef enum
{
   NoAtmo, /* no active astmospherics */
   UseFog, /* fog astmostpheric */
   UseLayerFog, /* layer fog astmostpheric */
   UseDistanceCue /* distance cue astmostpheric */
} atmospheretype3ds;

typedef enum
{
   NoFall, /* no falloff */
   TopFall, /* falloff to the top */
   BottomFall /* falloff to the bottom */
} layerfogfalloff3ds;

typedef struct /* fog atmosphere parameters */
{
   float3ds nearplane; /* near radius of fog effect */
   float3ds neardensity; /* near fog density */
   float3ds farplane; /* far radius of fog effect */
   float3ds fardensity; /* far fog density */
   fcolor3ds     fogcolor; /* color of fog effect */
   byte3ds    fogbgnd; /* True3ds / False3ds "fog background" flag */
} fogsettings3ds;

typedef struct /* layered fog atmosphere parameters */
{
   float3ds zmin; /* lower bounds of fog */
   float3ds zmax; /* upper bounds of fog */
   float3ds density; /* fog density */
   fcolor3ds fogcolor; /* fog color */
   layerfogfalloff3ds falloff; /* falloff style */
   byte3ds fogbgnd; /* True3ds / False3ds "fog background" flag */
} layerfogsettings3ds;

typedef struct /* distance cue atmosphere parameters */
{
   float3ds nearplane; /* near radius of effect */
   float3ds neardim; /* near dimming factor */
   float3ds farplane; /* far radius of effect */
   float3ds fardim; /* far dimming factor */
   byte3ds dcuebgnd; /* True3ds / False3ds effect the background flag */
} dcuesettings3ds;

typedef struct {
   fogsettings3ds fog; /* fog atmostphere settings */
   layerfogsettings3ds layerfog;  /* layered fog atmosphere parameters */
   dcuesettings3ds dcue;  /* distance cue atmosphere parameters */
   atmospheretype3ds activeatmo; /* The active astmospheric */
} atmosphere3ds;

/* enumerate list of possible backgrounds used in file */
typedef enum
{
   NoBgnd,
   UseSolidBgnd,
   UseVGradientBgnd, 
   UseBitmapBgnd
} backgroundtype3ds;

typedef struct 
{
   char3ds *name; /* name of background bitmap */
} bitmapbgnd3ds;

typedef struct 
{
   fcolor3ds color; /* color of solid background */
} solidbgnd3ds;

typedef struct 
{
   float3ds gradpercent; /* Placement of mid color band, ranges from 0-1 */ 
   fcolor3ds  top; /* color of top band */
   fcolor3ds  mid; /* color of mid background band */
   fcolor3ds  bottom; /* color of bottom band */
} vgradientbgnd3ds;

typedef struct {
   bitmapbgnd3ds bitmap;
   solidbgnd3ds solid;
   vgradientbgnd3ds vgradient;
   backgroundtype3ds bgndused; /* background in effect */
} background3ds;

/* Used for shading field in material3ds structure */
typedef enum
{
   Wire = 0,
   Flat = 1,
   Gouraud = 2,
   Phong = 3,
   Metal = 4
} shadetype3ds;

/* Used for tiling field in bitmap3ds structure */
typedef enum 
{
   Tile = 1,
   Decal = 2,
   Both = 3
} tiletype3ds;

typedef enum
{
   Pyramidal,
   SummedArea
} filtertype3ds;

typedef enum
{
   RGB,
   Alpha,
   RGBLumaTint,
   AlphaTint,
   RGBTint
} tinttype3ds;


/* Used By AddMaterial3ds */

typedef struct {
   ubyte3ds firstframe; /* True for First Frame Only */
   ubyte3ds flat; /* True for flat mirror reflection */
   ulong3ds size;     /* Map resolution */
   ulong3ds nthframe; /* Map update period */
} acubic3ds;          /* Cubic reflection map defintion */

typedef struct {
   char3ds  name[13];  /* Bitmap file name */
   float3ds percent;  /* Strength percentage */
   tiletype3ds tiling;  /* Tile/Decal/Both */
   byte3ds ignorealpha;
   filtertype3ds filter; /* Pyramidal/Summed Area */
   float3ds blur;
   byte3ds mirror;
   byte3ds negative;
   float3ds uscale, vscale;
   float3ds uoffset, voffset;
   float3ds rotation;
   tinttype3ds source; /* RGB/RGB Luma Tint/Alpha Tint/RGB Tint */
   fcolor3ds tint1;
   fcolor3ds tint2;
   fcolor3ds redtint;
   fcolor3ds greentint;
   fcolor3ds bluetint;
   ulong3ds datasize; /* Size of procedural data */
   void3ds *data;     /* Procedural data */
} bitmap3ds;          /* Bit map definition */

/* Structure to all map settings */
typedef struct {
   bitmap3ds map; /* The map settings */
   bitmap3ds mask; /* The mask settings */
} mapset3ds;

typedef struct {
   bitmap3ds map; /* The map settings */
   byte3ds useauto; /* True3ds if automatic reflections are being used */
   acubic3ds automap; /* Automatic reflection definitions */
   bitmap3ds mask; /* The mask settings */
} rmapset3ds;
   
typedef struct {
   char3ds name[17];      /* Name */
   fcolor3ds ambient;     /* Ambient light color */
   fcolor3ds diffuse;     /* Diffuse light color */
   fcolor3ds specular;    /* Specular light color */
   float3ds shininess;    /* Shininess factor */
   float3ds shinstrength; /* Shininess strength */
   float3ds blur;         /* Blur factor */
   float3ds transparency; /* Trasparency factor */
   float3ds transfalloff; /* Fallof factor */
   float3ds selfillumpct;     /* Self illumination percentage */
   float3ds wiresize;     /* Width of wireframe */
   shadetype3ds shading;      /* Shading type */
   byte3ds useblur;       /* Blurring flag */
   byte3ds usefall;       /* Transparency falloff flag */
   byte3ds twosided;      /* Two sided material flag */
   byte3ds selfillum;     /* Self illumination flag */
   byte3ds additive;      /* Additive transparency flag */
   byte3ds usewire;       /* Use wireframe rendering */
   byte3ds usewireabs;    /* Wire size is in units, not pixels. */
   byte3ds facemap;       /* Face mapping switch */
   byte3ds soften;        /* Soften switch */
   mapset3ds texture;     /* Texture map settings */
   mapset3ds texture2;    /* Second texture map settings */
   mapset3ds opacity;     /* Opacity map settings */
   mapset3ds bump;       /* Bump map settings */
   mapset3ds specmap;     /* Specularity map settings */
   mapset3ds shinmap;     /* Shininess map settings */
   mapset3ds illummap;    /* Self illumination map settings */
   rmapset3ds reflect;    /* Reflection map settings */
} material3ds;            /* Material definition */

/* mapinfo3ds - Texture map icon placement */
typedef struct {
   ushort3ds maptype;    /* Icon type */
   float3ds tilex;       /* Tiling */
   float3ds tiley;
   float3ds cenx;        /* Position of center */
   float3ds ceny;
   float3ds cenz;
   float3ds scale;       /* Icon scaling factor */
   float3ds matrix[12];  /* Orientation matrix */
   float3ds pw;          /* Planar icon width */
   float3ds ph;          /* Planar icon height */
   float3ds ch;          /* Cylinder icon height */
} mapinfo3ds;            

/* objmat3ds - Material assignments by face */
typedef struct {
   char3ds name[17];     /* Material name */
   ushort3ds nfaces;     /* Number of faces using material */
   ushort3ds *faceindex; /* List of faces using material */
} objmat3ds;             

/* mesh3ds - Mesh object definition */
typedef struct {
   char3ds name[11];       /* Object name */
   byte3ds ishidden;       /* Hidden object flag */
   byte3ds isvislofter;    /* Lofter visibility flag */
   byte3ds ismatte;        /* Matte object flag */
   byte3ds isnocast;       /* Doesn't cast shadow's flag */
   byte3ds isfast;         /* Fast display flag */
   byte3ds isnorcvshad;    /* Doesn't recieve shadows */
   byte3ds isfrozen;       /* Frozen object flag */
   ushort3ds nvertices;    /* Vertice count */
   point3ds *vertexarray;  /* List of vertices */
   ushort3ds nvflags;      /* Number of vertex flags */
   ushort3ds *vflagarray;  /* List of vertex flags */
   ushort3ds ntextverts;   /* Number of texture vertices */   
   textvert3ds *textarray; /* List of texture coordinates */
   byte3ds usemapinfo;     /* Boolean for use of mapping icon information */
   mapinfo3ds map;         /* Mapping icon info */
   float3ds locmatrix[12]; /* Object orientation matrix */
   ushort3ds nfaces;       /* Face count */
   face3ds *facearray;     /* List of faces */
   ulong3ds *smootharray;  /* Smoothing group assignment list */
   byte3ds useboxmap;     /* Boolean used to indicate the use of box mapping */
   char3ds boxmap[6][17];  /* Material names used in boxmapping */
   ubyte3ds meshcolor;     /* UI color assigned to the mesh */
   ushort3ds nmats;        /* Assigned materials count */
   objmat3ds *matarray;    /* Material assignment list */
   byte3ds useproc;        /* Use animated stand-in flag */
   ulong3ds procsize;      /* Size of animated stand-in data */
   char3ds procname[13];   /* Name of animated stand-in procedure */
   void3ds *procdata;      /* Animated stand-in data */
} mesh3ds;                  

/* conestyle3ds - Spolight projection cone shape. */
typedef enum
{
   Circular,
   Rectangular
} conestyle3ds;

/* spotshadow - Spotlight shadow settings */
typedef struct {
   byte3ds cast; /* True if spotlight casts shadows */
   shadowstyle3ds type; /* UseShadow or UseRayTrace */
   byte3ds local; /* True if local shadow settings are being used */
   float3ds bias; /* Shadow bias */
   float3ds filter; /* Shadow filter */
   ushort3ds mapsize; /* Shadow map size */
   float3ds raybias; /* Ray tracing shadow bias */
} spotshadow3ds; 

/* spotcond3ds - cone visability settings */
typedef struct {
   conestyle3ds type; /* Circular or rectangular light cone */
   byte3ds show; /* True if cone is visable */
   byte3ds overshoot;  /* True if cone overshoot is on */
} spotcone3ds;

/* spotproject3ds - spotlight projectio bitmap */
typedef struct {
   byte3ds use; /* True if using projector */
   char3ds *bitmap; /* Name of projector bitmap */
} spotprojector3ds;

/* spotlight3ds - spotlight settings */
typedef struct
{
   point3ds target;  /* Spotlight target */
   float3ds hotspot; /* Hotspot angle */
   float3ds falloff; /* Hotspot falloff */
   float3ds roll;    /* Roll angle */
   float3ds aspect;  /* Aspect ratio */
   spotshadow3ds shadows; 
   spotcone3ds cone;
   spotprojector3ds projector;
} spotlight3ds;

/* liteattenuate3ds - Light attenuation settings */
typedef struct {
   byte3ds on; /* True if light attenuation is on */
   float3ds inner; /* Inner range of attenuation */
   float3ds outer; /* Outer range of attenuation */ 
} liteattenuate3ds;

/* light3ds - omni and spotlight settings */
typedef struct {
   char3ds name[11];   /* Light name */
   point3ds pos; /* Light position */
   fcolor3ds color; /* Light color */
   float3ds multiplier;/* Light intensity multiplier */
   byte3ds dloff; /* True if light is off */
   liteattenuate3ds attenuation;
   namelist3ds *exclude;
   spotlight3ds *spot; /* If not null, then struct is a spotlight, else omni. */
} light3ds;

/* camrange3ds - Camera atomosphere ranges */
typedef struct {
   float3ds cam_near; /* Nearest effect radiu */
   float3ds cam_far; /* Farthest effect radius */
} camranges3ds;

typedef struct 
{
   char3ds name[11];
   point3ds position;
   point3ds target;
   float3ds roll;
   float3ds fov;
   byte3ds showcone;
   camranges3ds ranges;
} camera3ds;

typedef struct {
  ulong3ds length;
  ulong3ds curframe;
} kfkeyinfo3ds;

typedef struct {
  byte3ds use;
  ulong3ds begin;
  ulong3ds end;
} kfsegment3ds;

typedef struct
{
  kfkeyinfo3ds anim;
  kfsegment3ds seg;
} kfsets3ds;


typedef struct {
  char3ds name[11];    /* Name of camera object */
  char3ds parent[22];  /* Name of parent object */
  
  ushort3ds flags1;    /* flags field from node header -fixup later */
  ushort3ds flags2;    /* flags2 field from node header -fixup later */
  
  ulong3ds npkeys;     /* Number of camera position keys */
  ushort3ds npflag;    /* Loop control flag for camera position keys */
  keyheader3ds *pkeys; /* Spline values for camera position keys */
  point3ds *pos;       /* Camera position keys */
  
  ulong3ds nfkeys;     /* Number of camera FOV keys */
  ushort3ds nfflag;    /* Loop control flag for camera FOV keys */
  keyheader3ds *fkeys; /* Spline values for camera FOV keys */
  float3ds *fov;       /* Camera FOV keys */
  
  ulong3ds nrkeys;     /* Number of camera roll keys */
  ushort3ds nrflag;    /* Loop control flag for camera roll keys */
  keyheader3ds *rkeys; /* Spline values for camera roll keys */
  float3ds *roll;      /* Camera roll keys */
  
  char3ds tparent[22]; /* Index of parent object for target */
  ulong3ds ntkeys;     /* Number of target position keys */
  ushort3ds ntflag;    /* Loop control flag for target position keys */
  keyheader3ds *tkeys; /* Spline values for target position keys */
  point3ds *tpos;      /* Target position keys */
  ushort3ds tflags1;   /* flags field from target node header */
  ushort3ds tflags2;   /* flags field from target node header */
} kfcamera3ds;

/* kfambient3ds - Ambient light animation */
typedef struct {
   ushort3ds flags1;    /* flags field from node header -fixup later     */
   ushort3ds flags2;    /* flags2 field from node header -fixup later    */

   ulong3ds nckeys;     /* Number of color keys                          */
   ushort3ds ncflag;    /* Loop control flag for color keys              */
   keyheader3ds *ckeys; /* Spline values for position keys               */
   fcolor3ds *color;    /* Color keys                                    */
} kfambient3ds;
/* Used By ObjectMotion3ds */

typedef struct {
   char3ds name[11];     /* Name of mesh */
   char3ds parent[22];   /* Name of parent object */
   ushort3ds flags1;     /* flags field from node header  */
   ushort3ds flags2;     /* flags2 field from node header  */

   point3ds pivot;       /* Object pivot point */
   char3ds instance[11]; /* Object instance name */
   point3ds boundmin;    /* Minimum bounding box point for dummy objects */
   point3ds boundmax;    /* Maximum bounding box point for dummy objects */

   ulong3ds npkeys;      /* Number of position keys */
   short3ds npflag;      /* Loop control flag for position keys */
   keyheader3ds *pkeys;  /* Spline values for position keys */
   point3ds *pos;        /* Mesh position keys */

   ulong3ds nrkeys;      /* Number of rotation keys */
   short3ds nrflag;      /* Loop control flag for rotation keys */
   keyheader3ds *rkeys;  /* Spline values for rotation keys */
   kfrotkey3ds *rot;     /* Rotation keys */

   ulong3ds nskeys;      /* Number of scaling keys */
   short3ds nsflag;      /* Loop control flag for scaling keys */
   keyheader3ds *skeys;  /* Spline values for scaling */
   point3ds *scale;      /* Mesh scaling keys */

   ulong3ds nmkeys;      /* Number of morph keys */
   short3ds nmflag;      /* Loop control flag for morph keys */
   keyheader3ds *mkeys;  /* Spline values for morph keys */
   kfmorphkey3ds *morph; /* Morph keys */

   ulong3ds nhkeys;      /* Number of hide keys */
   short3ds nhflag;      /* Loop control flag for hide keys */
   keyheader3ds *hkeys;  /* Spline values for hide keys */
   float3ds msangle;     /* Morph smoothing group angle */
} kfmesh3ds;

/* Used By OmnilightMotion3ds */

typedef struct {
   char3ds name[11];    /* Name of the light object node */
   char3ds parent[22];  /* Name of the parent object */

   ushort3ds flags1;    /* flags field from node header -fixup later */
   ushort3ds flags2;    /* flags2 field from node header -fixup later */

   ulong3ds npkeys;     /* Number of position keys */
   ushort3ds npflag;     /* Loop control flag for position keys */
   keyheader3ds *pkeys; /* Spline values for position keys */
   point3ds *pos;       /* Position keys */

   ulong3ds nckeys;     /* Number of color keys */
   ushort3ds ncflag;     /* Loop control flag for color keys */
   keyheader3ds *ckeys; /* Spline values for position keys */
   fcolor3ds *color;   /* Color keys */

} kfomni3ds;

typedef struct {
   char3ds name[11];    /* Name of camera object */
   char3ds parent[22];  /* Parent name */

   ushort3ds flags1;    /* flags field from node header -fixup later */
   ushort3ds flags2;    /* flags2 field from node header -fixup later */

#ifdef broken
   short3ds visable;    /* Flags to control visability */
#endif
   ulong3ds npkeys;     /* Number of light position keys */
   ushort3ds npflag;     /* Loop control flag for position keys */
   keyheader3ds *pkeys; /* Spline values for light position keys */
   point3ds *pos;       /* Light position keys */

   ulong3ds nckeys;     /* Number of color keys */
   ushort3ds ncflag;     /* Loop control flag color keys */
   keyheader3ds *ckeys; /* Spline values for color keys */
   fcolor3ds *color;    /* Color keys */

   ulong3ds nhkeys;     /* Number of hotspot angle keys */
   ushort3ds nhflag;     /* Loop control flag for hotspot angle keys */
   keyheader3ds *hkeys; /* Spline values for hotspot angle keys */
   float3ds *hot;       /* Hotspot angle keys */

   ulong3ds nfkeys;     /* Number of falloff angle keys */
   ushort3ds nfflag;     /* Loop control flag for falloff angle keys */
   keyheader3ds *fkeys; /* Spline values for falloff angle keys */
   float3ds *fall;      /* Falloff angle keys */

   ulong3ds nrkeys;     /* Number of light roll keys */
   ushort3ds nrflag;     /* Loop control flag for light roll keys */
   keyheader3ds *rkeys; /* Spline values for light roll keys */
   float3ds *roll;      /* Light roll keys */

   char3ds tparent[22];    /* Name of target's parent object */
   ulong3ds ntkeys;     /* Number of target position keys */
   ushort3ds ntflag;     /* Loop control flag for target position keys */
   keyheader3ds *tkeys; /* Spline values for target position keys */
   point3ds *tpos;      /* Target position keys */
   ushort3ds tflags1;   /* flags field from target node header */
   ushort3ds tflags2;   /* flags field from target node header */

} kfspot3ds;
typedef struct {
   long3ds size;
   void3ds *data;
} xdataraw3ds;


/*----------------------------------------
  Constants for commonly used structures
  --------------------------------------*/

/* 3DS File Toolkit revision level.  Future revisions will increment this
   integer number */
static const long3ds __FTKRevisionLevel3ds = FTKRevisionLevel3ds; 

/* Flags used by the flag field of the mesh3ds structure */
static const ushort3ds FaceCAVisable3ds = 0x0001;  /* Flags the CA edge as visable */
static const ushort3ds FaceBCVisable3ds = 0x0002;  /* Flags the BC edge as visable */
static const ushort3ds FaceABVisable3ds = 0x0004;  /* Flags the AB edge as visable */
static const ushort3ds FaceUWrap3ds     = 0x0008;  /* Flags the face as being at
						      a texture coord u wrap
						      seam */
static const ushort3ds FaceVWrap3ds     = 0x0010;  /* Flags the face as being at
						      a texture coord v wrap
						      seam */

/* Flags used by the rflags field of the keyheader3ds structure */
static const ushort3ds KeyUsesTension3ds = 0x01;
static const ushort3ds KeyUsesCont3ds    = 0x02;
static const ushort3ds KeyUsesBias3ds    = 0x04;
static const ushort3ds KeyUsesEaseTo3ds  = 0x08;
static const ushort3ds KeyUsesEaseFrom3ds= 0x10;

/* Flags used by the track flags field */
static const ushort3ds TrackSingle3ds  = 0x0000;
static const ushort3ds TrackLoops3ds   = 0x0003;
static const ushort3ds TrackRepeats3ds = 0x0002;
static const ushort3ds TrackLockX3ds   = 0x0008;
static const ushort3ds TrackLockY3ds   = 0x0010;
static const ushort3ds TrackLockZ3ds   = 0x0020;
static const ushort3ds TrackNoLinkX3ds = 0x0100;
static const ushort3ds TrackNoLinkY3ds = 0x0200;
static const ushort3ds TrackNoLinkZ3ds = 0x0400;

/* Basic structure default contents for ease of initialization */
static const point3ds DefPoint3ds = {0.0F, 0.0F, 0.0F};
static const textvert3ds DefTextVert3ds = {0.0F, 0.0F};
static const face3ds DefFace3ds = {0, 1, 2, 0};
static const trackheader3ds DefTrackHeader3ds = {0, 0, 0, 1};
static const keyheader3ds DefKeyHeader3ds = {0, 0, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F};
/* Last toolkit error */
extern byte3ds ftkerr3ds; /* True3ds if error is pending */
extern byte3ds ignoreftkerr3ds; /* True3ds if errors are being ignored by toolkit */
/* Fog flags */
static const ulong3ds LayerFogBgnd = 0x100000;
static const ulong3ds NoFalloff = 0x0;
static const ulong3ds TopFalloff = 0x2;
static const ulong3ds BottomFalloff = 0x1;


/* Flags for initflags parameter */
static const ushort3ds InitNoExtras3ds    = 0x0000;
static const ushort3ds InitVertexArray3ds = 0x0001;
static const ushort3ds InitTextArray3ds   = 0x0002;
static const ushort3ds InitFaceArray3ds   = 0x0004;
static const ushort3ds InitMatArray3ds    = 0x0008;
static const ushort3ds InitSmoothArray3ds = 0x0010;
static const ushort3ds InitProcData3ds    = 0x0020;
static const ushort3ds InitVFlagArray3ds  = 0x0040;


/* Smoothing group flags used in the smootharray field of the mesh3ds structure */
static const ulong3ds Smooth01Group3ds = 0x00000001;
static const ulong3ds Smooth02Group3ds = 0x00000002;
static const ulong3ds Smooth03Group3ds = 0x00000004;
static const ulong3ds Smooth04Group3ds = 0x00000008;
static const ulong3ds Smooth05Group3ds = 0x00000010;
static const ulong3ds Smooth06Group3ds = 0x00000020;
static const ulong3ds Smooth07Group3ds = 0x00000030;
static const ulong3ds Smooth08Group3ds = 0x00000080;
static const ulong3ds Smooth09Group3ds = 0x00000100;
static const ulong3ds Smooth10Group3ds = 0x00000200;
static const ulong3ds Smooth11Group3ds = 0x00000400;
static const ulong3ds Smooth12Group3ds = 0x00000800;
static const ulong3ds Smooth13Group3ds = 0x00001000;
static const ulong3ds Smooth14Group3ds = 0x00002000;
static const ulong3ds Smooth15Group3ds = 0x00004000;
static const ulong3ds Smooth16Group3ds = 0x00008000;
static const ulong3ds Smooth17Group3ds = 0x00010000;
static const ulong3ds Smooth18Group3ds = 0x00020000;
static const ulong3ds Smooth19Group3ds = 0x00040000;
static const ulong3ds Smooth20Group3ds = 0x00080000;
static const ulong3ds Smooth21Group3ds = 0x00100000;
static const ulong3ds Smooth22Group3ds = 0x00200000;
static const ulong3ds Smooth23Group3ds = 0x00400000;
static const ulong3ds Smooth24Group3ds = 0x00800000;
static const ulong3ds Smooth25Group3ds = 0x01000000;
static const ulong3ds Smooth26Group3ds = 0x02000000;
static const ulong3ds Smooth27Group3ds = 0x04000000;
static const ulong3ds Smooth28Group3ds = 0x08000000;
static const ulong3ds Smooth29Group3ds = 0x10000000;
static const ulong3ds Smooth30Group3ds = 0x20000000;
static const ulong3ds Smooth31Group3ds = 0x40000000;
static const ulong3ds Smooth32Group3ds = 0x80000000;
static const char3ds *DummyName3ds = "$$$DUMMY";
/* Flag settings for kfmesh3ds, kfomni3ds, kfcamera3ds, kfambient, and kfspot3ds */

/* For the flags field */
static const ushort3ds KfNodeOff3ds = 1<<3;
static const ushort3ds KfHideNode3ds = 1<<11;
static const ushort3ds KfFastNode3ds = 1<<12;

/* For the flags2 field */
static const ushort3ds KfNodeHasPath3ds = 1;
static const ushort3ds KfNodeAutoSmooth3ds = 1<<1;
static const ushort3ds KfNodeFrozen3ds = 1<<2;
static const ushort3ds KfMotionBlur3ds = 1<<4;
static const ushort3ds KfBlurBranch3ds = 1<<5;
static const ushort3ds KfMorphMtl3ds   = 1<<6;
static const ushort3ds KfMorphOb       = 1<<7;

typedef enum
{
  LightTarget,
  CameraTarget
} targettype3ds;

static const long3ds  TerseDump3ds = 0; /* Just the chunk headers */
static const long3ds MediumDump3ds = 1; /* Selected bits of data (usually not array dumps) */
static const long3ds MaximumDump3ds = 2; /* Everything */
/* Priv */ void PushErrList3ds(errorid3ds id);
/* Priv */ const char3ds *ErrCodeToString3ds(errorid3ds err);
void DumpErrList3ds(FILE *outfile);
void ClearErrList3ds();
const ErrRec3ds *ReturnErrorList3ds();


/* Functions to use with namelist3ds structures */
void InitNameList3ds(namelist3ds **chunk, ulong3ds count);
void ReleaseNameList3ds(namelist3ds **chunk);
void AddToNameList3ds(namelist3ds **list, char3ds *name);

/* File control functions */
file3ds *OpenFile3ds(const char3ds *filename, const char *attrib);
void CloseAllFiles3ds();
void CloseFile3ds(file3ds *file);


/* Database functions */
void InitDatabase3ds(database3ds **db);
void ReleaseDatabase3ds(database3ds **db);
void CreateDatabase3ds(file3ds *file, database3ds *db);
void CreateNewDatabase3ds(database3ds *db, dbtype3ds type);
dbtype3ds GetDatabaseType3ds(database3ds *db);
void CopyDatabase3ds(database3ds *idb, database3ds *odb);
void DisconnectDatabase3ds(database3ds *db);
void WriteDatabase3ds(file3ds *file, database3ds *db);
void InitViewport3ds(viewport3ds **vp);
void ReleaseViewport3ds(viewport3ds **vp);
void GetViewport3ds(database3ds *db, viewport3ds **vp);
void PutViewport3ds(database3ds *db, viewport3ds *vp);
void CopyViewport3ds(database3ds *destdb, database3ds *srcdb);
void InitMeshSet3ds(meshset3ds **);
void ReleaseMeshSet3ds(meshset3ds **);
void GetMeshSet3ds(database3ds *, meshset3ds **);
void PutMeshSet3ds(database3ds *db, meshset3ds *settings);
void CopyMeshSet3ds(database3ds *destdb, database3ds *srcdb);

void InitAtmosphere3ds(atmosphere3ds **atmo);
void ReleaseAtmosphere3ds(atmosphere3ds **atmo);
void GetAtmosphere3ds(database3ds *db, atmosphere3ds **atmo);
void PutAtmosphere3ds(database3ds *db, atmosphere3ds *atmo);
void CopyAtmosphere3ds(database3ds *destdb, database3ds *srcdb);

void InitBackground3ds(background3ds **bgnd);
void ReleaseBackground3ds(background3ds **bgnd);
void GetBackground3ds(database3ds *db, background3ds **bgnd);
void PutBackground3ds(database3ds *db, background3ds *bgnd);
void CopyBackground3ds(database3ds *destdb, database3ds *srcdb);

short3ds AddMaterial3ds(const material3ds *mat);
void InitBitmap3ds(bitmap3ds *map);
short3ds InitMaterial3ds(material3ds **mat);
void ReleaseMaterial3ds(material3ds **mat);
ulong3ds GetMaterialCount3ds(database3ds *db);
void GetMaterialNameList3ds(database3ds *db, namelist3ds **list);
void GetMaterialByIndex3ds(database3ds *db, ulong3ds index, material3ds **mat);
void GetMaterialByName3ds(database3ds *db, char3ds *name, material3ds **mat);
void PutMaterial3ds(database3ds *db, material3ds *mat);
void CopyMaterialByName3ds(database3ds *destdb, database3ds *srcdb, char3ds *name);
void CopyMaterialByIndex3ds(database3ds *destdb, database3ds *srcdb, ulong3ds index);
void DeleteMaterialByName3ds(database3ds *db, char3ds *name);
void DeleteMaterialByIndex3ds(database3ds *db, ulong3ds index);
void InitMeshObj3ds(mesh3ds **obj, ushort3ds nvertices, ushort3ds nfaces, ushort3ds iniflags);
void InitMeshObjField3ds(mesh3ds *obj, ushort3ds const initflags);
void InitMatArrayIndex3ds (mesh3ds *obj, ushort3ds mat, ushort3ds nfaces);

/* Mesh object functions */
ulong3ds GetMeshCount3ds(database3ds *db);
void GetMeshNameList3ds(database3ds *db, namelist3ds **list);
void GetMeshByIndex3ds(database3ds *db, ulong3ds index, mesh3ds **mesh);
void GetMeshByName3ds(database3ds *db, char3ds *name, mesh3ds **mesh);
void PutMesh3ds(database3ds *db, mesh3ds *mesh);
void CopyMeshByName3ds(database3ds *destdb, database3ds *srcdb, char3ds *name);
void CopyMeshByIndex3ds(database3ds *destdb, database3ds *srcdb, ulong3ds index);
void DeleteMeshByName3ds(database3ds *db, char3ds *name);
void DeleteMeshByIndex3ds(database3ds *db, ulong3ds index);
void RelMeshObj3ds(mesh3ds **obj);

/* Light related functions */
void InitLight3ds(light3ds **light);
void InitSpotlight3ds(light3ds **spotlight);
void ReleaseLight3ds(light3ds **light);
ulong3ds GetOmnilightCount3ds(database3ds *db);
ulong3ds GetSpotlightCount3ds(database3ds *db);
void GetOmnilightNameList3ds(database3ds *db, namelist3ds **list);
void GetSpotlightNameList3ds(database3ds *db, namelist3ds **list);
void GetSpotlightByIndex3ds(database3ds *db, long3ds index, light3ds **light);
void GetOmnilightByIndex3ds(database3ds *db, long3ds index, light3ds **light);
void GetSpotlightByName3ds(database3ds *db, char3ds *name, light3ds **light);
void GetOmnilightByName3ds(database3ds *db, char3ds *name, light3ds **light);
void PutSpotlight3ds(database3ds *db, light3ds *light);
void PutOmnilight3ds(database3ds *db, light3ds *light);
void CopySpotlightByName3ds(database3ds *destdb, database3ds *srcdb, char3ds *name);
void CopySpotlightByIndex3ds(database3ds *destdb, database3ds *srcdb, ulong3ds index);
void CopyOmnilightByName3ds(database3ds *destdb, database3ds *srcdb, char3ds *name);
void CopyOmnilightByIndex3ds(database3ds *destdb, database3ds *srcdb, ulong3ds index);
void DeleteSpotlightByIndex3ds(database3ds *db, ulong3ds index);
void DeleteOmnilightByIndex3ds(database3ds *db, ulong3ds index);
void DeleteSpotlightByName3ds(database3ds *db, char3ds *name);
void DeleteOmnilightByName3ds(database3ds *db, char3ds *name);
void InitCamera3ds(camera3ds **cam);
void ReleaseCamera3ds(camera3ds **cam);
ulong3ds GetCameraCount3ds(database3ds *db);
void GetCameraNameList3ds(database3ds *db, namelist3ds **list);
void GetCameraByIndex3ds(database3ds *db, ulong3ds index, camera3ds **cam);
void GetCameraByName3ds(database3ds *db, char3ds *name, camera3ds **cam);
void PutCamera3ds(database3ds *db, camera3ds *cam);

void CopyCameraByName3ds(database3ds *destdb, database3ds *srcdb, char3ds *name);
void CopyCameraByIndex3ds(database3ds *destdb, database3ds *srcdb, ulong3ds index);

void DeleteCameraByName3ds(database3ds *db, char3ds *name);
void DeleteCameraByIndex3ds(database3ds *db, ulong3ds index);

void InitKfSets3ds(kfsets3ds **key);
void ReleaseKfSets3ds(kfsets3ds **key);
void PutKfSets3ds(database3ds *db, kfsets3ds *key);
void GetKfSets3ds(database3ds *db, kfsets3ds **key);
void CopyKfSets3ds(database3ds *destdb, database3ds *srcdb);


void InitCameraMotion3ds(kfcamera3ds **cam, ulong3ds npkeys, ulong3ds nfkeys,
                             ulong3ds nrkeys, ulong3ds ntkeys);

void GetCameraMotionByName3ds(database3ds *db, 
			      const char3ds *name, 
			      kfcamera3ds **kfcam);

void GetCameraMotionByIndex3ds(database3ds *db, 
			       ulong3ds index,
			       kfcamera3ds **kfcam);

void PutCameraMotion3ds(database3ds *db, kfcamera3ds *kfcam);


void ReleaseCameraMotion3ds(kfcamera3ds **cam);

ulong3ds GetCameraNodeCount3ds(database3ds *db);

void GetCameraNodeNameList3ds(database3ds *db, namelist3ds **list);

void DeleteCameraMotionByIndex3ds(database3ds *db, ulong3ds index);
void DeleteCameraMotionByName3ds(database3ds *db, char3ds *name);
void CopyCameraMotionByIndex3ds(database3ds *destdb, database3ds *srcdb, ulong3ds index);
void CopyCameraMotionByName3ds(database3ds *destdb, database3ds *srcdb, char3ds *name);


/* Ambient Light Animation Functions */
void InitAmbientLightMotion3ds(kfambient3ds **light, ulong3ds nckeys);
void ReleaseAmbientLightMotion3ds(kfambient3ds **light);
void GetAmbientLightMotion3ds(database3ds *db, kfambient3ds **kfambient);
void PutAmbientLightMotion3ds(database3ds *db, kfambient3ds *kfambient);
void DeleteAmbientLightMotion3ds(database3ds *db);
void CopyAmbientLightMotion3ds(database3ds *destdb, database3ds *srcdb);
void InitObjectMotion3ds(kfmesh3ds **obj, 
			 ulong3ds npkeys, 
			 ulong3ds nrkeys, 
			 ulong3ds nskeys, 
			 ulong3ds nmkeys,
			 ulong3ds nhkeys);

void ReleaseObjectMotion3ds(kfmesh3ds **obj);

void GetObjectNodeNameList3ds(database3ds *db, 
			      namelist3ds **list);

ulong3ds GetObjectNodeCount3ds(database3ds *db);

void GetObjectMotionByName3ds(database3ds *db, 
			      char3ds *name, 
			      kfmesh3ds **kfmesh);

void GetObjectMotionByIndex3ds(database3ds *db, 
			       ulong3ds index,
			       kfmesh3ds **kfmesh);

void PutObjectMotion3ds(database3ds *db,
			kfmesh3ds *kfmesh);

void DeleteObjectMotionByIndex3ds(database3ds *db, ulong3ds index);
void DeleteObjectMotionByName3ds(database3ds *db, char3ds *name);
void CopyObjectMotionByIndex3ds(database3ds *destdb, database3ds *srcdb, ulong3ds index);
void CopyObjectMotionByName3ds(database3ds *destdb, database3ds *srcdb, char3ds *name);
void InitOmnilightMotion3ds(kfomni3ds **light, 
			    ulong3ds npkeys, 
			    ulong3ds nckeys);

void ReleaseOmnilightMotion3ds(kfomni3ds **light);

void GetOmnilightNodeNameList3ds(database3ds *db, 
				 namelist3ds **list);

void GetOmnilightMotionByName3ds(database3ds *db, 
				 char3ds *name, 
				 kfomni3ds **kfomni);

void GetOmnilightMotionByIndex3ds(database3ds *db, 
				  ulong3ds index,
				  kfomni3ds **kfomni);

ulong3ds GetOmnilightNodeCount3ds(database3ds *db);

void PutOmnilightMotion3ds(database3ds *db, 
			   kfomni3ds *kfomni);

void PutOmnilightMotion3ds(database3ds *db, 
			   kfomni3ds *kfomni);

void DeleteOmnilightMotionByIndex3ds(database3ds *db, ulong3ds index);
void DeleteOmnilightMotionByName3ds(database3ds *db, char3ds *name);
void CopyOmnilightMotionByIndex3ds(database3ds *destdb, database3ds *srcdb, ulong3ds index);
void CopyOmnilightMotionByName3ds(database3ds *destdb, database3ds *srcdb, char3ds *name);
void InitSpotlightMotion3ds(kfspot3ds **spot, 
                ulong3ds npkeys, 
                ulong3ds nckeys, 
                ulong3ds nhkeys, 
                ulong3ds nfkeys, 
                ulong3ds nrkeys, 
                ulong3ds ntkeys);

void ReleaseSpotlightMotion3ds(kfspot3ds **spot);

void GetSpotlightNodeNameList3ds(database3ds *db, 
				 namelist3ds **list);

ulong3ds GetSpotlightNodeCount3ds(database3ds *db);

void GetSpotlightMotionByName3ds(database3ds *db, 
                 char3ds *name, 
                 kfspot3ds **kfspot);

void PutSpotlightMotion3ds(database3ds *db, 
			   kfspot3ds *kfspot);

void GetSpotlightMotionByIndex3ds(database3ds *db, 
		  ulong3ds index,
		  kfspot3ds **kfspot);

void DeleteSpotlightMotionByIndex3ds(database3ds *db, ulong3ds index);
void DeleteSpotlightMotionByName3ds(database3ds *db, char3ds *name);
void CopySpotlightMotionByIndex3ds(database3ds *destdb, database3ds *srcdb, ulong3ds index);
void CopySpotlightMotionByName3ds(database3ds *destdb, database3ds *srcdb, char3ds *name);

void FillMatrix3ds(mesh3ds *obj);
void SetBoundBox3ds(const mesh3ds *mobj, kfmesh3ds *kobj );
void DumpMapInfo3ds(FILE *out, mapinfo3ds *map, long3ds dumplevel);
void DumpMesh3ds(FILE *out, mesh3ds *mesh, long3ds dumplevel);
void DumpMaterial3ds(FILE *out, material3ds *mat, long3ds dumplevel);
void DumpBitmap3ds(FILE *out, bitmap3ds *map, long3ds dumplevel);
void SetDumpLevel3ds(long3ds newlevel);
void DumpDatabase3ds(FILE *outfile, database3ds *db);
void GetMeshXDataByName3ds(database3ds *db, char3ds *meshname, char3ds *appname, xdataraw3ds **data);
ulong3ds GetMeshXDataCount3ds(database3ds *db, char3ds *meshname);
#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\mesh\tri3editmesh.inl ===
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
void
// mark the face as unused
GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED>::MarkAsUnused(UINT_IDX iFace)
{
    UINT iEdge;

    // for each edge, mark the points and neighbors as UNUSED
    for (iEdge = 0; iEdge < 3; iEdge++)
    {
        m_pFaces[iFace].m_wIndices[iEdge] = UNUSED;
        m_rgpniNeighbors[iFace].m_iNeighbors[iEdge] = UNUSED;
    }
}


// -------------------------------------------------------------------------------
//  Implementation of CFaceListIter
// -------------------------------------------------------------------------------

// -------------------------------------------------------------------------------
//  function    GetNextFace
//
//   devnote    returns the next face moving in the manner set in init/construction
//                  and as a side effect moves to the face beyond that.
//
//   returns    the index of the next face
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
UINT_IDX 
CFaceListIter<UINT_IDX,b16BitIndex,UNUSED>::GetNextFace()
{
    UINT_IDX iRet;
    UINT_IDX iPrevFace;

    GXASSERT(m_iCurFace != UNUSED);
    iRet = m_iCurFace;
    m_iCurEdge = m_iNextEdge;

SwitchedDirectionRetry:

    // get the next face 
    iPrevFace = m_iCurFace;
    m_iCurFace = m_ptmTriMesh->m_rgpniNeighbors[m_iCurFace].m_iNeighbors[m_iNextEdge];

    
    // check to make sure that we haven't completely gone around the vertex
    if (m_iCurFace != m_iFace)
    {   
        // make sure that we haven't hit a boundary
        if (m_iCurFace != UNUSED)
        {
            // find the next edge to jump to the next triangle
            m_iNextEdge = FindEdge(m_ptmTriMesh->m_rgpniNeighbors[m_iCurFace].m_iNeighbors, iPrevFace);
            GXASSERT(m_iNextEdge < 3);

            if (m_bClockwise)
            {
                m_iNextEdge = (m_iNextEdge + 1) % 3;
            }
            // if going counter clockwise, need to go to the other edge containing m_wPointRep;
            else  //if (!m_bClockwise)
            {
                m_iNextEdge = (m_iNextEdge + 2) % 3;
            }
        }
        else  // hit a boundary, either need to restart in the opposite direction, or we hit the end
        {
            // if going clockwise, need to try counter clockwise next
            if (m_bClockwise && !m_bStopOnBoundary)
            {
                m_bClockwise = false;

                m_iCurFace = m_iFace;

                // go back to the original face, and go counter clockwise
                m_iNextEdge = m_ptmTriMesh->FindWedge(m_ptmTriMesh->m_pFaces[m_iCurFace].m_wIndices, m_wPoint);
                GXASSERT(m_iNextEdge < 3);

                m_iNextEdge = (m_iNextEdge + 2) % 3;

				// modify iCurEdge to account for the fact that the direction has changed
				m_iCurEdge = (m_iCurEdge + 2) % 3;

                // now that it is setup to walk counter clockwise from the initial face, retry
                goto SwitchedDirectionRetry;
            }
            // else if counter clockwise, leave m_iCurFace as UNUSED to signify the end
        }
    }
    else  // wrapped around, need to set m_iCurFace to UNUSED to signify EOL
    {
        m_iCurFace = UNUSED;
    }

    return iRet;
}

// -------------------------------------------------------------------------------
//  function    GetNextEdgeFace
//
//   devnote    returns the next edge moving in the manner set in init/construction
//                  and as a side effect moves to the face beyond that.
//
//              NOTE: the difference between this and GetNextFace is that a face
//                  may be returned more than once in order to visit all the edges
//
//   returns    the index of the next face
//
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
void
CFaceListIter<UINT_IDX,b16BitIndex,UNUSED>::GetNextEdgeFace(UINT_IDX &iEdge, UINT_IDX &iFace)
{
    UINT_IDX iPrevFace;
    GXASSERT(m_iCurFace != UNUSED);

    iFace = m_iCurFace;
    iEdge = m_iNextEdge;
    m_iCurEdge = iEdge;

    // get the next face 
    iPrevFace = m_iCurFace;
    m_iCurFace = m_ptmTriMesh->m_rgpniNeighbors[m_iCurFace].m_iNeighbors[m_iNextEdge];

    
    // check to make sure that we haven't completely gone around the vertex
    if (m_iCurFace != m_iFace)
    {   
        // make sure that we haven't hit a boundary
        if (m_iCurFace != UNUSED)
        {
            // find the next edge to jump to the next triangle
            m_iNextEdge = FindEdge(m_ptmTriMesh->m_rgpniNeighbors[m_iCurFace].m_iNeighbors, iPrevFace);
            GXASSERT(m_iNextEdge < 3);

            if (m_bClockwise)
            {
                m_iNextEdge = (m_iNextEdge + 1) % 3;
            }
            // if going counter clockwise, need to go to the other edge containing m_wPointRep;
            else  //if (!m_bClockwise)
            {
                m_iNextEdge = (m_iNextEdge + 2) % 3;
            }
        }
        else  // hit a boundary, either need to restart in the opposite direction, or we hit the end
        {
            // if going clockwise, need to try counter clockwise next
            if (m_bClockwise && !m_bStopOnBoundary)
            {
                m_bClockwise = false;

                m_iCurFace = m_iFace;

                // go back to the original face, and go counter clockwise
                m_iNextEdge = m_ptmTriMesh->FindWedge(m_ptmTriMesh->m_pFaces[m_iCurFace].m_wIndices, m_wPoint);
                GXASSERT(m_iNextEdge < 3);

                m_iNextEdge = (m_iNextEdge + 2) % 3;

				// modify iCurEdge to account for the fact that the direction has changed
				m_iCurEdge = (m_iCurEdge + 2) % 3;
            }
            // else if counter clockwise, leave m_iCurFace as UNUSED to signify the end
        }
    }
    else  // wrapped around, need to set m_iCurFace to UNUSED to signify EOL
    {
        m_iCurFace = UNUSED;
    }
}


// Moves the starting position to be either at iFace if no boundaries, or the farthest
//   counter clockwise possible, so that one walk in the clockwise direction will hit
//   all the triangles in order
template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
bool 
CFaceListIter<UINT_IDX,b16BitIndex,UNUSED>::MoveToCCWFace()
{
    UINT_IDX iPrevFace;
    UINT_IDX iInitialNextEdge;
	bool bRet = false;

    // start out at iFace and look for a boundary in the counter clockwise position
    m_iCurFace = m_iFace;

    // find the next edge to jump to the next triangle
    m_iNextEdge = m_ptmTriMesh->FindWedge(m_ptmTriMesh->m_pFaces[m_iCurFace].m_wIndices, m_wPoint);
    iInitialNextEdge = m_iNextEdge;
    GXASSERT(m_iNextEdge < 3);
    m_iNextEdge = (m_iNextEdge + 2) % 3;

    iPrevFace = m_iCurFace;
    do
    {
        // get the next face
        iPrevFace = m_iCurFace;
        m_iCurFace = m_ptmTriMesh->m_rgpniNeighbors[m_iCurFace].m_iNeighbors[m_iNextEdge];

        if (m_iCurFace != UNUSED)
        {
            // find the next edge to jump to the next triangle
            m_iNextEdge = FindEdge(m_ptmTriMesh->m_rgpniNeighbors[m_iCurFace].m_iNeighbors, iPrevFace);
            GXASSERT(m_iNextEdge < 3);

            m_iNextEdge = (m_iNextEdge + 2) % 3;
        }
    }
    while ((m_iCurFace != m_iFace) && (m_iCurFace != UNUSED));

    // if m_iCurFace is unused, hit counter clockwise most boundary, so start at the last face before boundary
    if (m_iCurFace == UNUSED)
    {
        m_iCurFace = iPrevFace;

        m_iNextEdge = (m_iNextEdge + 1) % 3;

        // note: if choosing a new starting face, find the new wedge
        m_wPoint = m_ptmTriMesh->m_pFaces[m_iCurFace].m_wIndices[m_iNextEdge];

		// a CCW face was found, so return true
		bRet = true;
    }
    else // m_iCurFace == iFace, which is as good a place to start as any
    {
        // Use the edge found before trying to go CCW
        m_iNextEdge = iInitialNextEdge;
    }

    m_bClockwise = true;

    m_iCurEdge = m_iNextEdge;

	m_iFace = m_iCurFace;

	return bRet;
}




// IUnknown method implementations


template <class UINT_IDX, int b16BitIndex, unsigned int UNUSED>
STDMETHODIMP 
GXTri3Mesh<UINT_IDX,b16BitIndex,UNUSED>::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // if this is contained in another object defer the call to that object
    if (m_punkOuter != NULL)
        return m_punkOuter->QueryInterface(riid, ppv);

    *ppv=NULL;
    if (riid == IID_IUnknown)
        *ppv=(IUnknown*)(ID3DXBaseMesh*)this;
    else if (riid == IID_ID3DXBaseMesh)
        *ppv=(ID3DXBaseMesh*)this;
    else if (riid == IID_ID3DXMesh)
        *ppv=(ID3DXMesh*)this;
    else
        return E_NOINTERFACE;

    ((LPUNKNOWN)*ppv)->AddRef();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\flex\config.h ===
/* config.h.  Generated automatically by configure.  */
/* $Header: /home/daffy/u0/vern/flex/RCS/conf.in,v 1.2 95/01/09 
12:11:51 vern Exp $ */

/* Define to empty if the keyword does not work.  */
/* #undef const */

/* Define to `unsigned' if <sys/types.h> doesn't define.  */
/* #undef size_t */

/* Define if you have the ANSI C header files.  */
#define STDC_HEADERS 1

/* Define if you have the <malloc.h> header file.  */
#define HAVE_MALLOC_H 1

/* Define if you have the <string.h> header file.  */
#define HAVE_STRING_H 1

/* Define if you have the <sys/types.h> header file.  */
#define HAVE_SYS_TYPES_H 1

/* Define if you have <alloca.h> and it should be used (not on 
Ultrix).  */
#define HAVE_ALLOCA_H 0

/* Define if platform-specific command line handling is necessary.  */
/* #undef NEED_ARGV_FIXUP */

/* Define if you use FAT file system, leave undefined for NTFS */
#undef SHORT_FILE_NAMES 
/* #define SHORT_FILE_NAMES 1 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\flex\ccl.c ===
/* ccl - routines for character classes */

/*-
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Vern Paxson.
 * 
 * The United States Government has rights in this work pursuant
 * to contract no. DE-AC03-76SF00098 between the United States
 * Department of Energy and the University of California.
 *
 * Redistribution and use in source and binary forms with or without
 * modification are permitted provided that: (1) source distributions retain
 * this entire copyright notice and comment, and (2) distributions including
 * binaries display the following acknowledgement:  ``This product includes
 * software developed by the University of California, Berkeley and its
 * contributors'' in the documentation or other materials provided with the
 * distribution and in all advertising materials mentioning features or use
 * of this software.  Neither the name of the University nor the names of
 * its contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

/* $Header: \\VIA-SOURCE\RELEASE21\dev\RCS\Tools\flex-2.5.4a\ccl.c,v 1.1 1999/12/08 23:39:58 wayneg Exp $ */

#include "flexdef.h"

/* ccladd - add a single character to a ccl */

void ccladd( cclp, ch )
int cclp;
int ch;
	{
	int ind, len, newpos, i;

	check_char( ch );

	len = ccllen[cclp];
	ind = cclmap[cclp];

	/* check to see if the character is already in the ccl */

	for ( i = 0; i < len; ++i )
		if ( ccltbl[ind + i] == ch )
			return;

	newpos = ind + len;

	if ( newpos >= current_max_ccl_tbl_size )
		{
		current_max_ccl_tbl_size += MAX_CCL_TBL_SIZE_INCREMENT;

		++num_reallocs;

		ccltbl = reallocate_Character_array( ccltbl,
						current_max_ccl_tbl_size );
		}

	ccllen[cclp] = len + 1;
	ccltbl[newpos] = ch;
	}


/* cclinit - return an empty ccl */

int cclinit()
	{
	if ( ++lastccl >= current_maxccls )
		{
		current_maxccls += MAX_CCLS_INCREMENT;

		++num_reallocs;

		cclmap = reallocate_integer_array( cclmap, current_maxccls );
		ccllen = reallocate_integer_array( ccllen, current_maxccls );
		cclng = reallocate_integer_array( cclng, current_maxccls );
		}

	if ( lastccl == 1 )
		/* we're making the first ccl */
		cclmap[lastccl] = 0;

	else
		/* The new pointer is just past the end of the last ccl.
		 * Since the cclmap points to the \first/ character of a
		 * ccl, adding the length of the ccl to the cclmap pointer
		 * will produce a cursor to the first free space.
		 */
		cclmap[lastccl] = cclmap[lastccl - 1] + ccllen[lastccl - 1];

	ccllen[lastccl] = 0;
	cclng[lastccl] = 0;	/* ccl's start out life un-negated */

	return lastccl;
	}


/* cclnegate - negate the given ccl */

void cclnegate( cclp )
int cclp;
	{
	cclng[cclp] = 1;
	}


/* list_character_set - list the members of a set of characters in CCL form
 *
 * Writes to the given file a character-class representation of those
 * characters present in the given CCL.  A character is present if it
 * has a non-zero value in the cset array.
 */

void list_character_set( file, cset )
FILE *file;
int cset[];
	{
	register int i;

	putc( '[', file );

	for ( i = 0; i < csize; ++i )
		{
		if ( cset[i] )
			{
			register int start_char = i;

			putc( ' ', file );

			fputs( readable_form( i ), file );

			while ( ++i < csize && cset[i] )
				;

			if ( i - 1 > start_char )
				/* this was a run */
				fprintf( file, "-%s", readable_form( i - 1 ) );

			putc( ' ', file );
			}
		}

	putc( ']', file );
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\3ds\3dsftk.h ===
/****************************************************************************
 *
 * 3DSFTK.H - 3D Studio File Toolkit for Release 3 library header
 *
 *  (C) Copyright 1997 by Autodesk, Inc.
 *
 *  This program is copyrighted by Autodesk, Inc. and is licensed to you under
 *  the following conditions.  You may not distribute or publish the source
 *  code of this program in any form.  You may incorporate this code in object
 *  form in derivative works provided such derivative works are (i.) are de-
 *  signed and intended to work solely with Autodesk, Inc. products, and (ii.)
 *  contain Autodesk's copyright notice "(C) Copyright 1995 by Autodesk, Inc."
 *
 *  AUTODESK PROVIDES THIS PROGRAM "AS IS" AND WITH ALL FAULTS.  AUTODESK SPE-
 *  CIFICALLY DISCLAIMS ANY IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS FOR
 *  A PARTICULAR USE.  AUTODESK, INC.  DOES NOT WARRANT THAT THE OPERATION OF
 *  THE PROGRAM WILL BE UNINTERRUPTED OR ERROR FREE.
 *
 ***************************************************************************/


#ifndef FTK3DS_H
#define FTK3DS_H

#include <stdio.h>

#ifdef __cplusplus
extern "C" {
#endif
					
/* Note: Item's prefixed with a "Priv" comment are internally used, are not
   part of the toolkit's published interface, and should not be used
   by non-ftk library functions */


/* Data Type Synonyms For Portability */

#define char3ds char
#define uchar3ds unsigned char
#define byte3ds char
#define ubyte3ds unsigned char
#define short3ds short int
#define ushort3ds unsigned short int
#define long3ds long int
#define ulong3ds unsigned long int
#define float3ds float
#define double3ds double
#define int3ds   int
#define void3ds void

/* 3DS File Toolkit revision level.  Future revisions will increment this
   integer number */
#define FTKRevisionLevel3ds 2

/*------------------------------------
  Error reporting and testing macros
  ----------------------------------*/

/* Pending error flag values for ftkerr3ds global */
#define FTK_ERROR True3ds
#define FTK_NO_ERROR False3ds

/*--- If ftkerr3ds shows that an error has occured, return */
#define ON_ERROR_RETURN {if(ftkerr3ds && !ignoreftkerr3ds) return;}
#define ON_ERROR_RETURNR(rval) {if(ftkerr3ds && !ignoreftkerr3ds) return rval;}

/*--- If ftkerr3ds shows that an error has occured, push error and return */
#define ADD_ERROR_RETURN(id) {if(ftkerr3ds){PushErrList3ds(id); if (!ignoreftkerr3ds) return;}}
#define ADD_ERROR_RETURNR(id, rval) {if(ftkerr3ds){PushErrList3ds(id); if (!ignoreftkerr3ds) return rval;}}

/*--- If ftkerr3ds shows that an error has occured, push error */
#define ADD_ERROR(id) {if (ftkerr3ds){PushErrList3ds(id);}}

/*--- Reset the the error flag */
#define CLEAR_ERROR {if (ftkerr3ds){ClearErrList3ds();}}

/*--- Simply set the error state: Good if you need to clean-up before returning  */
#define SET_ERROR {ftkerr3ds=True3ds;}

/*--- Set error state, push an error ID and return */
#define SET_ERROR_RETURN(id) {PushErrList3ds(id); if (!ignoreftkerr3ds) return;}
#define SET_ERROR_RETURNR(id, rval) {PushErrList3ds(id); if (!ignoreftkerr3ds) return rval;}

/* Prints errors and exits application */
#define PRINT_ERRORS_EXIT(file) {if(ftkerr3ds && file){DumpErrList3ds(file); if (!ignoreftkerr3ds) exit(0x3D);}}

/*----------------------------------------
  Commonly used structures and constants
  --------------------------------------*/

/* Constants to define True and False in a compiler independant way. */
#define TRUE3DS (1==1)
#define FALSE3DS (1!=1)
static const byte3ds True3ds = (1==1);
static const byte3ds False3ds = (1!=1);

/* point3ds - 3D point structure */
typedef struct 
{
   float3ds x, y, z;
} point3ds;

/* fcolor3ds - Floating point color definition */
typedef struct {
   float3ds r;   /* RGB Color components */
   float3ds g;
   float3ds b;
} fcolor3ds;       

/* face3ds - Face list element */
typedef struct
{
   ushort3ds v1, v2, v3, flag;
} face3ds;

/* textvert3ds - Texture assignment coordinate */
typedef struct
{
   float3ds u, v;
} textvert3ds;
/* Priv */ /* trackheader3ds - Global track settings */
/* Priv */ typedef struct
/* Priv */ {
/* Priv */    ushort3ds flags;
/* Priv */    ulong3ds nu1, nu2;
/* Priv */    ulong3ds keycount; /* Number of keys in the track */
/* Priv */ } trackheader3ds;

/* keyheader3ds - Animation key settings */
typedef struct
{
   ulong3ds time;       /* Key's frame position */
   ushort3ds rflags;    /* Spline terms used flag */
   float3ds tension;    /* Flagged with 0x01 */
   float3ds continuity; /* Flagged with 0x02 */
   float3ds bias;       /* Flagged with 0x04 */
   float3ds easeto;     /* Flagged with 0x08 */
   float3ds easefrom;   /* Flagged with 0x10 */
} keyheader3ds;

/* kfrotkey3ds - Rotation key */
typedef struct {
   float3ds angle; /* angle of rotation */
   float3ds x;     /* rotation axis vector */
   float3ds y;
   float3ds z;
} kfrotkey3ds;

/* kfmorphkey3ds - Object morph key */
typedef struct {
   char3ds name[13]; /* name of target morph object */
} kfmorphkey3ds;


/* Error codes generated by toolkit */
typedef enum
{
   NO_FTK_ERRORS = 0, /* No errors are pending */
   ERR_NO_MEM, /* Not enough memory to complete operation */
   ERR_INVALID_ARG, /* The argument passed to the function invalid.  Usually */
		    /* caused by a NULL pointer or an out of range numeric */
		    /* argument. */
   ERR_INVALID_DATA, /* The structure passed as an argument to the function has */
                     /* invalid or out of range data in its fields. */
   ERR_INVALID_CHUNK, /* An invalid chunk structure was encountered while reading */
		      /* the database. Usually caused by a corrupt database or */
		      /* file */
   ERR_INVALID_DATABASE, /* The database passed as an argument has not be created */
			 /* yet. */
   ERR_WRONG_DATABASE, /* The database passed as an argument is the wrong kind of */
		       /* database for this function. */
   ERR_UNFOUND_CHUNK, /* The database is missing important file chunks needed to */
		      /* fill out the requested structure.  Usually caused by a */
		      /* corrupt database or file */
   ERR_WRONG_OBJECT, /* The name passed to the functions exists, but is not the */
		     /* type of object asked for.  For example, asking for a mesh */
		     /* object with the GetCameraByName3ds function. */
   ERR_NO_SUCH_FILE, /* The filename passed as an argument for reading does not exist */
   ERR_INIT_FAILED,  /* Failed to initialize structure passed as an argument */
   ERR_OPENING_FILE, /* Could not open requested file */
   ERR_CLOSING_FILE, /* Could not close requested file */
   ERR_READING_FILE, /* Error occured while reading file */
   ERR_CREATING_DATABASE, /* Error occured while creating database */
   ERR_READING_DATABASE, /* Error occured while reading database */
   ERR_WRITING_DATABASE, /* Error occured while writing database */
   ERR_WRITING_FILE, /* Error occured while writing file */
   ERR_STRING_TOO_LONG, /* String encountered in file, structure, or as an */
			/* argument was longer than expected.  Possibly caused by */
			/* an uninitialed pointer, corrupt file or database */
   ERR_TOO_MANY_FILES, /* The toolkit has reached its maximum open file limit of */
		       /* 252 files. */
   ERR_GET_FAIL, /* Failed to get new data from database */
   ERR_PUT_FAIL, /* Failed to add new data to the database */
   N_ERRORS
}errorid3ds;

typedef struct {
  errorid3ds  id;
  const char3ds *desc;
} ErrRec3ds;


/* Priv */ /* chunktag3ds - enumeration of all possible chunk type identifiers. See appendix for */
/* Priv */ /* more information concerning chunk structures */   
/* Priv */ typedef enum
/* Priv */ {
/* Priv */         /* Trick Chunk Flags For ChunkSyntax function */

/* Priv */    NULL_CHUNK             = 0x0000,
/* Priv */    ChunkType              = 0x0995,
/* Priv */    ChunkUnique            = 0x0996,
/* Priv */    NotChunk               = 0x0997,
/* Priv */    Container              = 0x0998,
/* Priv */    IsChunk                = 0x0999,

/* Priv */    /* Dummy Chunk that sometimes appears in 3ds files created by prerelease 3D Studio R2 */
/* Priv */    DUMMY = 0xFFFF,

/* Priv */    /* Trick Chunk Types For Open*, Write*, Close* functions */

/* Priv */    POINT_ARRAY_ENTRY      = 0xF110,
/* Priv */    POINT_FLAG_ARRAY_ENTRY = 0xF111,
/* Priv */    FACE_ARRAY_ENTRY       = 0xF120,
/* Priv */    MSH_MAT_GROUP_ENTRY    = 0xF130,
/* Priv */    TEX_VERTS_ENTRY        = 0xF140,
/* Priv */    SMOOTH_GROUP_ENTRY     = 0xF150,
/* Priv */    POS_TRACK_TAG_KEY      = 0xF020,
/* Priv */    ROT_TRACK_TAG_KEY      = 0xF021,
/* Priv */    SCL_TRACK_TAG_KEY      = 0xF022,
/* Priv */    FOV_TRACK_TAG_KEY      = 0xF023,
/* Priv */    ROLL_TRACK_TAG_KEY     = 0xF024,
/* Priv */    COL_TRACK_TAG_KEY      = 0xF025,
/* Priv */    MORPH_TRACK_TAG_KEY    = 0xF026,
/* Priv */    HOT_TRACK_TAG_KEY      = 0xF027,
/* Priv */    FALL_TRACK_TAG_KEY     = 0xF028,
/* Priv */    
/* Priv */    /* 3DS File Chunk IDs */

/* Priv */    M3DMAGIC               = 0x4D4D,
/* Priv */    SMAGIC                 = 0x2D2D,
/* Priv */    LMAGIC                 = 0x2D3D,
/* Priv */    MLIBMAGIC              = 0x3DAA,
/* Priv */    MATMAGIC               = 0x3DFF,
/* Priv */    M3D_VERSION            = 0x0002,
/* Priv */    M3D_KFVERSION          = 0x0005,

/* Priv */    /* Mesh Chunk Ids */

/* Priv */    MDATA                  = 0x3D3D,
/* Priv */    MESH_VERSION           = 0x3D3E,
/* Priv */    COLOR_F                = 0x0010,
/* Priv */    COLOR_24               = 0x0011,
/* Priv */    LIN_COLOR_24           = 0x0012,
/* Priv */    LIN_COLOR_F            = 0x0013,
/* Priv */    INT_PERCENTAGE         = 0x0030,
/* Priv */    FLOAT_PERCENTAGE       = 0x0031,

/* Priv */    MASTER_SCALE           = 0x0100,

/* Priv */    BIT_MAP                = 0x1100,
/* Priv */    USE_BIT_MAP            = 0x1101,
/* Priv */    SOLID_BGND             = 0x1200,
/* Priv */    USE_SOLID_BGND         = 0x1201,
/* Priv */    V_GRADIENT             = 0x1300,
/* Priv */    USE_V_GRADIENT         = 0x1301,

/* Priv */    LO_SHADOW_BIAS         = 0x1400,
/* Priv */    HI_SHADOW_BIAS         = 0x1410,
/* Priv */    SHADOW_MAP_SIZE        = 0x1420,
/* Priv */    SHADOW_SAMPLES         = 0x1430,
/* Priv */    SHADOW_RANGE           = 0x1440,
/* Priv */    SHADOW_FILTER          = 0x1450,
/* Priv */    RAY_BIAS               = 0x1460,
/* Priv */  
/* Priv */    O_CONSTS               = 0x1500,
/* Priv */  
/* Priv */    AMBIENT_LIGHT          = 0x2100,

/* Priv */    FOG                    = 0x2200,
/* Priv */    USE_FOG                = 0x2201,
/* Priv */    FOG_BGND               = 0x2210,
/* Priv */    DISTANCE_CUE           = 0x2300,
/* Priv */    USE_DISTANCE_CUE       = 0x2301,
/* Priv */    LAYER_FOG              = 0x2302,
/* Priv */    USE_LAYER_FOG          = 0x2303,
/* Priv */    DCUE_BGND              = 0x2310,

/* Priv */    DEFAULT_VIEW           = 0x3000,
/* Priv */    VIEW_TOP               = 0x3010,
/* Priv */    VIEW_BOTTOM            = 0x3020,
/* Priv */    VIEW_LEFT              = 0x3030,
/* Priv */    VIEW_RIGHT             = 0x3040,
/* Priv */    VIEW_FRONT             = 0x3050,
/* Priv */    VIEW_BACK              = 0x3060,
/* Priv */    VIEW_USER              = 0x3070,
/* Priv */    VIEW_CAMERA            = 0x3080,
/* Priv */    VIEW_WINDOW            = 0x3090,

/* Priv */    NAMED_OBJECT           = 0x4000,
/* Priv */    OBJ_HIDDEN             = 0x4010,
/* Priv */    OBJ_VIS_LOFTER         = 0x4011,
/* Priv */    OBJ_DOESNT_CAST        = 0x4012,
/* Priv */    OBJ_MATTE              = 0x4013,
/* Priv */    OBJ_FAST               = 0x4014,
/* Priv */    OBJ_PROCEDURAL         = 0x4015,
/* Priv */    OBJ_FROZEN             = 0x4016,
/* Priv */    OBJ_DONT_RCVSHADOW     = 0x4017,

/* Priv */    N_TRI_OBJECT           = 0x4100,

/* Priv */    POINT_ARRAY            = 0x4110,
/* Priv */    POINT_FLAG_ARRAY       = 0x4111,
/* Priv */    FACE_ARRAY             = 0x4120,
/* Priv */    MSH_MAT_GROUP          = 0x4130,
/* Priv */    OLD_MAT_GROUP          = 0x4131,
/* Priv */    TEX_VERTS              = 0x4140,
/* Priv */    SMOOTH_GROUP           = 0x4150,
/* Priv */    MESH_MATRIX            = 0x4160,
/* Priv */    MESH_COLOR             = 0x4165,   
/* Priv */    MESH_TEXTURE_INFO      = 0x4170,
/* Priv */    PROC_NAME              = 0x4181,
/* Priv */    PROC_DATA              = 0x4182,
/* Priv */    MSH_BOXMAP             = 0x4190,

/* Priv */    N_D_L_OLD              = 0x4400,

/* Priv */    N_CAM_OLD              = 0x4500,   

/* Priv */    N_DIRECT_LIGHT         = 0x4600,
/* Priv */    DL_SPOTLIGHT           = 0x4610,
/* Priv */    DL_OFF                 = 0x4620,
/* Priv */    DL_ATTENUATE           = 0x4625,
/* Priv */    DL_RAYSHAD             = 0x4627,
/* Priv */    DL_SHADOWED            = 0x4630,
/* Priv */    DL_LOCAL_SHADOW        = 0x4640,
/* Priv */    DL_LOCAL_SHADOW2       = 0x4641,
/* Priv */    DL_SEE_CONE            = 0x4650,
/* Priv */    DL_SPOT_RECTANGULAR    = 0x4651,
/* Priv */    DL_SPOT_OVERSHOOT      = 0x4652,
/* Priv */    DL_SPOT_PROJECTOR      = 0x4653,
/* Priv */    DL_EXCLUDE             = 0x4654,
/* Priv */    DL_RANGE               = 0x4655, /* Not used in R3 */
/* Priv */    DL_SPOT_ROLL           = 0x4656,
/* Priv */    DL_SPOT_ASPECT         = 0x4657,
/* Priv */    DL_RAY_BIAS            = 0x4658,
/* Priv */    DL_INNER_RANGE = 0x4659,
/* Priv */    DL_OUTER_RANGE = 0x465A,
/* Priv */    DL_MULTIPLIER = 0x465B,

/* Priv */    N_AMBIENT_LIGHT        = 0x4680,

/* Priv */    N_CAMERA               = 0x4700,
/* Priv */    CAM_SEE_CONE           = 0x4710,
/* Priv */    CAM_RANGES             = 0x4720,

/* Priv */    HIERARCHY              = 0x4F00,
/* Priv */    PARENT_OBJECT          = 0x4F10,
/* Priv */    PIVOT_OBJECT           = 0x4F20,
/* Priv */    PIVOT_LIMITS           = 0x4F30,
/* Priv */    PIVOT_ORDER            = 0x4F40,
/* Priv */    XLATE_RANGE            = 0x4F50,

/* Priv */    POLY_2D                = 0x5000,

/* Priv */    /* Flags in shaper file that tell whether polys make up an ok shape */

/* Priv */    SHAPE_OK               = 0x5010,
/* Priv */    SHAPE_NOT_OK           = 0x5011,

/* Priv */    SHAPE_HOOK             = 0x5020,

/* Priv */    PATH_3D                = 0x6000,
/* Priv */    PATH_MATRIX            = 0x6005,
/* Priv */    SHAPE_2D               = 0x6010,
/* Priv */    M_SCALE                = 0x6020,
/* Priv */    M_TWIST                = 0x6030,
/* Priv */    M_TEETER               = 0x6040,
/* Priv */    M_FIT                  = 0x6050,
/* Priv */    M_BEVEL                = 0x6060,
/* Priv */    XZ_CURVE               = 0x6070,
/* Priv */    YZ_CURVE               = 0x6080,
/* Priv */    INTERPCT               = 0x6090,
/* Priv */    DEFORM_LIMIT           = 0x60A0,

/* Priv */    /* Flags for Modeler options */

/* Priv */    USE_CONTOUR            = 0x6100,
/* Priv */    USE_TWEEN              = 0x6110,
/* Priv */    USE_SCALE              = 0x6120,
/* Priv */    USE_TWIST              = 0x6130,
/* Priv */    USE_TEETER             = 0x6140,
/* Priv */    USE_FIT                = 0x6150,
/* Priv */    USE_BEVEL              = 0x6160,

/* Priv */    /* Viewport description chunks */

/* Priv */    VIEWPORT_LAYOUT_OLD    = 0x7000,
/* Priv */    VIEWPORT_DATA_OLD      = 0x7010,
/* Priv */    VIEWPORT_LAYOUT        = 0x7001,
/* Priv */    VIEWPORT_DATA          = 0x7011,
/* Priv */    VIEWPORT_DATA_3        = 0x7012,
/* Priv */    VIEWPORT_SIZE          = 0x7020,
/* Priv */    NETWORK_VIEW           = 0x7030,

/* Priv */    /* External Application Data */

/* Priv */    XDATA_SECTION          = 0x8000,
/* Priv */    XDATA_ENTRY            = 0x8001,
/* Priv */    XDATA_APPNAME          = 0x8002,
/* Priv */    XDATA_STRING           = 0x8003,
/* Priv */    XDATA_FLOAT            = 0x8004,
/* Priv */    XDATA_DOUBLE           = 0x8005,
/* Priv */    XDATA_SHORT            = 0x8006,
/* Priv */    XDATA_LONG = 0x8007,
/* Priv */    XDATA_VOID = 0x8008,
/* Priv */    XDATA_GROUP = 0x8009,
/* Priv */    XDATA_RFU6 = 0x800A,
/* Priv */    XDATA_RFU5 = 0x800B,
/* Priv */    XDATA_RFU4 = 0x800C,
/* Priv */    XDATA_RFU3 = 0x800D,
/* Priv */    XDATA_RFU2 = 0x800E,
/* Priv */    XDATA_RFU1 = 0x800F,
/* Priv */    
/* Priv */    PARENT_NAME = 0x80F0,

/* Priv */    /* Material Chunk IDs */

/* Priv */    MAT_ENTRY              = 0xAFFF,
/* Priv */    MAT_NAME               = 0xA000,
/* Priv */    MAT_AMBIENT            = 0xA010,
/* Priv */    MAT_DIFFUSE            = 0xA020,
/* Priv */    MAT_SPECULAR           = 0xA030,
/* Priv */    MAT_SHININESS          = 0xA040,
/* Priv */    MAT_SHIN2PCT			  = 0xA041,
/* Priv */    MAT_SHIN3PCT		     = 0xA042,
/* Priv */    MAT_TRANSPARENCY  	  = 0xA050,
/* Priv */    MAT_XPFALL             = 0xA052,
/* Priv */    MAT_REFBLUR            = 0xA053,

/* Priv */    MAT_SELF_ILLUM         = 0xA080,
/* Priv */    MAT_TWO_SIDE           = 0xA081,
/* Priv */    MAT_DECAL              = 0xA082,
/* Priv */    MAT_ADDITIVE           = 0xA083,
/* Priv */    MAT_SELF_ILPCT  	  = 0xA084,
/* Priv */    MAT_WIRE		  = 0xA085,
/* Priv */    MAT_SUPERSMP		  = 0xA086,
/* Priv */    MAT_WIRESIZE		  = 0xA087,
/* Priv */    MAT_FACEMAP		  = 0xA088,
/* Priv */    MAT_XPFALLIN		  = 0xA08A,
/* Priv */    MAT_PHONGSOFT	  = 0xA08C,
/* Priv */    MAT_WIREABS  	= 0xA08E,

/* Priv */    MAT_SHADING            = 0xA100,

/* Priv */    MAT_TEXMAP             = 0xA200,
/* Priv */    MAT_OPACMAP            = 0xA210,
/* Priv */    MAT_REFLMAP            = 0xA220,
/* Priv */    MAT_BUMPMAP            = 0xA230,
/* Priv */    MAT_SPECMAP            = 0xA204,
/* Priv */    MAT_USE_XPFALL         = 0xA240,
/* Priv */    MAT_USE_REFBLUR        = 0xA250,
/* Priv */    MAT_BUMP_PERCENT       = 0xA252,

/* Priv */    MAT_MAPNAME            = 0xA300,
/* Priv */    MAT_ACUBIC             = 0xA310,

/* Priv */    MAT_SXP_TEXT_DATA      = 0xA320,
/* Priv */    MAT_SXP_TEXT2_DATA     = 0xA321,
/* Priv */    MAT_SXP_OPAC_DATA      = 0xA322,
/* Priv */    MAT_SXP_BUMP_DATA      = 0xA324,
/* Priv */    MAT_SXP_SPEC_DATA      = 0xA325,
/* Priv */    MAT_SXP_SHIN_DATA 	  = 0xA326,
/* Priv */    MAT_SXP_SELFI_DATA 	  = 0xA328,
/* Priv */    MAT_SXP_TEXT_MASKDATA  = 0xA32A,
/* Priv */    MAT_SXP_TEXT2_MASKDATA = 0xA32C,
/* Priv */    MAT_SXP_OPAC_MASKDATA  = 0xA32E,
/* Priv */    MAT_SXP_BUMP_MASKDATA  = 0xA330,
/* Priv */    MAT_SXP_SPEC_MASKDATA  = 0xA332,
/* Priv */    MAT_SXP_SHIN_MASKDATA  = 0xA334,
/* Priv */    MAT_SXP_SELFI_MASKDATA = 0xA336,
/* Priv */    MAT_SXP_REFL_MASKDATA  = 0xA338,
/* Priv */    MAT_TEX2MAP 		  = 0xA33A,
/* Priv */    MAT_SHINMAP 		  = 0xA33C,
/* Priv */    MAT_SELFIMAP 	  = 0xA33D,
/* Priv */    MAT_TEXMASK 		  = 0xA33E,
/* Priv */    MAT_TEX2MASK 	  = 0xA340,
/* Priv */    MAT_OPACMASK 	  = 0xA342,
/* Priv */    MAT_BUMPMASK 	  = 0xA344,
/* Priv */    MAT_SHINMASK 	  = 0xA346,
/* Priv */    MAT_SPECMASK 	  = 0xA348,
/* Priv */    MAT_SELFIMASK 	  = 0xA34A,
/* Priv */    MAT_REFLMASK 	  = 0xA34C,
/* Priv */    MAT_MAP_TILINGOLD 	  = 0xA350,
/* Priv */    MAT_MAP_TILING 	  = 0xA351,
/* Priv */    MAT_MAP_TEXBLUR_OLD 	  = 0xA352,
/* Priv */    MAT_MAP_TEXBLUR 	  = 0xA353,
/* Priv */    MAT_MAP_USCALE 	  = 0xA354,
/* Priv */    MAT_MAP_VSCALE 	  = 0xA356,
/* Priv */    MAT_MAP_UOFFSET 	  = 0xA358,
/* Priv */    MAT_MAP_VOFFSET 	  = 0xA35A,
/* Priv */    MAT_MAP_ANG 		  = 0xA35C,
/* Priv */    MAT_MAP_COL1 	  = 0xA360,
/* Priv */    MAT_MAP_COL2 	  = 0xA362,
/* Priv */    MAT_MAP_RCOL 	  = 0xA364,
/* Priv */    MAT_MAP_GCOL 	  = 0xA366,
/* Priv */    MAT_MAP_BCOL 	  = 0xA368,

/* Priv */         /* Keyframe Chunk IDs */

/* Priv */    KFDATA                 = 0xB000,
/* Priv */    KFHDR                  = 0xB00A,
/* Priv */    AMBIENT_NODE_TAG       = 0xB001,
/* Priv */    OBJECT_NODE_TAG        = 0xB002,
/* Priv */    CAMERA_NODE_TAG        = 0xB003,
/* Priv */    TARGET_NODE_TAG        = 0xB004,
/* Priv */    LIGHT_NODE_TAG         = 0xB005,
/* Priv */    L_TARGET_NODE_TAG      = 0xB006,
/* Priv */    SPOTLIGHT_NODE_TAG     = 0xB007,

/* Priv */    KFSEG                  = 0xB008,
/* Priv */    KFCURTIME              = 0xB009,
/* Priv */    NODE_HDR               = 0xB010,
/* Priv */    INSTANCE_NAME          = 0xB011,
/* Priv */    PRESCALE               = 0xB012,
/* Priv */    PIVOT                  = 0xB013,
/* Priv */    BOUNDBOX               = 0xB014,
/* Priv */    MORPH_SMOOTH           = 0xB015,
/* Priv */    POS_TRACK_TAG          = 0xB020,
/* Priv */    ROT_TRACK_TAG          = 0xB021,
/* Priv */    SCL_TRACK_TAG          = 0xB022,
/* Priv */    FOV_TRACK_TAG          = 0xB023,
/* Priv */    ROLL_TRACK_TAG         = 0xB024,
/* Priv */    COL_TRACK_TAG          = 0xB025,
/* Priv */    MORPH_TRACK_TAG        = 0xB026,
/* Priv */    HOT_TRACK_TAG          = 0xB027,
/* Priv */    FALL_TRACK_TAG         = 0xB028,
/* Priv */    HIDE_TRACK_TAG         = 0xB029,
/* Priv */    NODE_ID                = 0xB030,
/* Priv */    
/* Priv */    CMAGIC = 0xC23D,

/* Priv */    C_MDRAWER = 0xC010,
/* Priv */    C_TDRAWER = 0xC020,
/* Priv */    C_SHPDRAWER = 0xC030,
/* Priv */    C_MODDRAWER = 0xC040,
/* Priv */    C_RIPDRAWER = 0xC050,
/* Priv */    C_TXDRAWER = 0xC060,
/* Priv */    C_PDRAWER = 0xC062,
/* Priv */    C_MTLDRAWER = 0xC064,
/* Priv */    C_FLIDRAWER = 0xC066,
/* Priv */    C_CUBDRAWER = 0xC067,
/* Priv */    C_MFILE = 0xC070,
/* Priv */    C_SHPFILE = 0xC080,
/* Priv */    C_MODFILE = 0xC090,
/* Priv */    C_RIPFILE = 0xC0A0,
/* Priv */    C_TXFILE = 0xC0B0,
/* Priv */    C_PFILE = 0xC0B2,
/* Priv */    C_MTLFILE = 0xC0B4,
/* Priv */    C_FLIFILE = 0xC0B6,
/* Priv */    C_PALFILE = 0xC0B8,
/* Priv */    C_TX_STRING = 0xC0C0,
/* Priv */    C_CONSTS = 0xC0D0,
/* Priv */    C_SNAPS = 0xC0E0,
/* Priv */    C_GRIDS = 0xC0F0,
/* Priv */    C_ASNAPS = 0xC100,
/* Priv */    C_GRID_RANGE = 0xC110,
/* Priv */    C_RENDTYPE = 0xC120,
/* Priv */    C_PROGMODE = 0xC130,
/* Priv */    C_PREVMODE = 0xC140,
/* Priv */    C_MODWMODE = 0xC150,
/* Priv */    C_MODMODEL = 0xC160,
/* Priv */    C_ALL_LINES = 0xC170,
/* Priv */    C_BACK_TYPE = 0xC180,
/* Priv */    C_MD_CS = 0xC190,
/* Priv */    C_MD_CE = 0xC1A0,
/* Priv */    C_MD_SML = 0xC1B0,
/* Priv */    C_MD_SMW = 0xC1C0,
/* Priv */    C_LOFT_WITH_TEXTURE = 0xC1C3,
/* Priv */    C_LOFT_L_REPEAT = 0xC1C4,
/* Priv */    C_LOFT_W_REPEAT = 0xC1C5,
/* Priv */    C_LOFT_UV_NORMALIZE = 0xC1C6,
/* Priv */    C_WELD_LOFT = 0xC1C7,
/* Priv */    C_MD_PDET = 0xC1D0,
/* Priv */    C_MD_SDET = 0xC1E0,
/* Priv */    C_RGB_RMODE = 0xC1F0,
/* Priv */    C_RGB_HIDE = 0xC200,
/* Priv */    C_RGB_MAPSW = 0xC202,
/* Priv */    C_RGB_TWOSIDE = 0xC204,
/* Priv */    C_RGB_SHADOW = 0xC208,
/* Priv */    C_RGB_AA = 0xC210,
/* Priv */    C_RGB_OVW = 0xC220,
/* Priv */    C_RGB_OVH = 0xC230,
/* Priv */    C_RGB_PICTYPE = 0xC240,
/* Priv */    C_RGB_OUTPUT = 0xC250,
/* Priv */    C_RGB_TODISK = 0xC253,
/* Priv */    C_RGB_COMPRESS = 0xC254,
/* Priv */    C_JPEG_COMPRESSION = 0xC255,
/* Priv */    C_RGB_DISPDEV = 0xC256,
/* Priv */    C_RGB_HARDDEV = 0xC259,
/* Priv */    C_RGB_PATH = 0xC25A,
/* Priv */    C_BITMAP_DRAWER = 0xC25B,
/* Priv */    C_RGB_FILE = 0xC260,
/* Priv */    C_RGB_OVASPECT = 0xC270,

/* Priv */    C_RGB_ANIMTYPE = 0xC271,
/* Priv */    C_RENDER_ALL = 0xC272,
/* Priv */    C_REND_FROM = 0xC273,
/* Priv */    C_REND_TO = 0xC274,
/* Priv */    C_REND_NTH = 0xC275,
/* Priv */    C_PAL_TYPE = 0xC276,
/* Priv */    C_RND_TURBO = 0xC277,
/* Priv */    C_RND_MIP	= 0xC278,
/* Priv */    C_BGND_METHOD = 0xC279,
/* Priv */    C_AUTO_REFLECT = 0xC27A,
/* Priv */    C_VP_FROM = 0xC27B,
/* Priv */    C_VP_TO = 0xC27C,
/* Priv */    C_VP_NTH = 0xC27D,
/* Priv */    C_REND_TSTEP = 0xC27E,
/* Priv */    C_VP_TSTEP = 0xC27F,

/* Priv */    C_SRDIAM = 0xC280,
/* Priv */    C_SRDEG = 0xC290,
/* Priv */    C_SRSEG = 0xC2A0,
/* Priv */    C_SRDIR = 0xC2B0,
/* Priv */    C_HETOP = 0xC2C0,
/* Priv */    C_HEBOT = 0xC2D0,
/* Priv */    C_HEHT = 0xC2E0,
/* Priv */    C_HETURNS = 0xC2F0,
/* Priv */    C_HEDEG = 0xC300,
/* Priv */    C_HESEG = 0xC310,
/* Priv */    C_HEDIR = 0xC320,
/* Priv */    C_QUIKSTUFF = 0xC330,
/* Priv */    C_SEE_LIGHTS = 0xC340,
/* Priv */    C_SEE_CAMERAS = 0xC350,
/* Priv */    C_SEE_3D = 0xC360,
/* Priv */    C_MESHSEL = 0xC370,
/* Priv */    C_MESHUNSEL = 0xC380,
/* Priv */    C_POLYSEL = 0xC390,
/* Priv */    C_POLYUNSEL = 0xC3A0,
/* Priv */    C_SHPLOCAL = 0xC3A2,
/* Priv */    C_MSHLOCAL = 0xC3A4,
/* Priv */    C_NUM_FORMAT = 0xC3B0,
/* Priv */    C_ARCH_DENOM = 0xC3C0,
/* Priv */    C_IN_DEVICE = 0xC3D0,
/* Priv */    C_MSCALE = 0xC3E0,
/* Priv */    C_COMM_PORT = 0xC3F0,
/* Priv */    C_TAB_BASES = 0xC400,
/* Priv */    C_TAB_DIVS = 0xC410,
/* Priv */    C_MASTER_SCALES = 0xC420,
/* Priv */    C_SHOW_1STVERT = 0xC430,
/* Priv */    C_SHAPER_OK = 0xC440,
/* Priv */    C_LOFTER_OK = 0xC450,
/* Priv */    C_EDITOR_OK = 0xC460,
/* Priv */    C_KEYFRAMER_OK = 0xC470,
/* Priv */    C_PICKSIZE = 0xC480,
/* Priv */    C_MAPTYPE = 0xC490,
/* Priv */    C_MAP_DISPLAY = 0xC4A0,
/* Priv */    C_TILE_XY = 0xC4B0,
/* Priv */    C_MAP_XYZ = 0xC4C0,
/* Priv */    C_MAP_SCALE = 0xC4D0,
/* Priv */    C_MAP_MATRIX_OLD = 0xC4E0,
/* Priv */    C_MAP_MATRIX = 0xC4E1,
/* Priv */    C_MAP_WID_HT = 0xC4F0,
/* Priv */    C_OBNAME = 0xC500,
/* Priv */    C_CAMNAME = 0xC510,
/* Priv */    C_LTNAME = 0xC520,
/* Priv */    C_CUR_MNAME = 0xC525,
/* Priv */    C_CURMTL_FROM_MESH = 0xC526,
/* Priv */    C_GET_SHAPE_MAKE_FACES = 0xC527,
/* Priv */    C_DETAIL = 0xC530,
/* Priv */    C_VERTMARK = 0xC540,
/* Priv */    C_MSHAX = 0xC550,
/* Priv */    C_MSHCP = 0xC560,
/* Priv */    C_USERAX = 0xC570,
/* Priv */    C_SHOOK = 0xC580,
/* Priv */    C_RAX = 0xC590,
/* Priv */    C_STAPE = 0xC5A0,
/* Priv */    C_LTAPE = 0xC5B0,
/* Priv */    C_ETAPE = 0xC5C0,
/* Priv */    C_KTAPE = 0xC5C8,
/* Priv */    C_SPHSEGS = 0xC5D0,
/* Priv */    C_GEOSMOOTH = 0xC5E0,
/* Priv */    C_HEMISEGS = 0xC5F0,
/* Priv */    C_PRISMSEGS = 0xC600,
/* Priv */    C_PRISMSIDES = 0xC610,
/* Priv */    C_TUBESEGS = 0xC620,
/* Priv */    C_TUBESIDES = 0xC630,
/* Priv */    C_TORSEGS = 0xC640,
/* Priv */    C_TORSIDES = 0xC650,
/* Priv */    C_CONESIDES = 0xC660,
/* Priv */    C_CONESEGS = 0xC661,
/* Priv */    C_NGPARMS = 0xC670,
/* Priv */    C_PTHLEVEL = 0xC680,
/* Priv */    C_MSCSYM = 0xC690,
/* Priv */    C_MFTSYM = 0xC6A0,
/* Priv */    C_MTTSYM = 0xC6B0,
/* Priv */    C_SMOOTHING = 0xC6C0,
/* Priv */    C_MODICOUNT = 0xC6D0,
/* Priv */    C_FONTSEL = 0xC6E0,
/* Priv */    C_TESS_TYPE = 0xC6f0,
/* Priv */    C_TESS_TENSION = 0xC6f1,

/* Priv */    C_SEG_START = 0xC700,
/* Priv */    C_SEG_END = 0xC705,
/* Priv */    C_CURTIME = 0xC710,
/* Priv */    C_ANIMLENGTH = 0xC715,
/* Priv */    C_PV_FROM = 0xC720,
/* Priv */    C_PV_TO = 0xC725,
/* Priv */    C_PV_DOFNUM = 0xC730,
/* Priv */    C_PV_RNG = 0xC735,
/* Priv */    C_PV_NTH = 0xC740,
/* Priv */    C_PV_TYPE = 0xC745,
/* Priv */    C_PV_METHOD = 0xC750,
/* Priv */    C_PV_FPS = 0xC755,
/* Priv */    C_VTR_FRAMES = 0xC765,
/* Priv */    C_VTR_HDTL = 0xC770,
/* Priv */    C_VTR_HD = 0xC771,
/* Priv */    C_VTR_TL = 0xC772,
/* Priv */    C_VTR_IN = 0xC775,
/* Priv */    C_VTR_PK = 0xC780,
/* Priv */    C_VTR_SH = 0xC785,

/* Priv */ /* Material chunks */

/* Priv */    C_WORK_MTLS = 0xC790,	  /* Old-style -- now ignored */
/* Priv */    C_WORK_MTLS_2 = 0xC792, /* Old-style -- now ignored */
/* Priv */    C_WORK_MTLS_3 = 0xC793, /* Old-style -- now ignored */
/* Priv */    C_WORK_MTLS_4 = 0xC794, /* Old-style -- now ignored */
/* Priv */    C_WORK_MTLS_5 = 0xCB00, /* Old-style -- now ignored */
/* Priv */    C_WORK_MTLS_6 = 0xCB01, /* Old-style -- now ignored */
/* Priv */    C_WORK_MTLS_7 = 0xCB02, /* Old-style -- now ignored */
/* Priv */    C_WORK_MTLS_8 = 0xCB03, /* Old-style -- now ignored */
/* Priv */    C_WORKMTL = 0xCB04,
/* Priv */    C_SXP_TEXT_DATA = 0xCB10,
/* Priv */    C_SXP_TEXT2_DATA = 0xCB20,
/* Priv */    C_SXP_OPAC_DATA = 0xCB11,
/* Priv */    C_SXP_BUMP_DATA = 0xCB12,
/* Priv */    C_SXP_SPEC_DATA = 0xCB24,
/* Priv */    C_SXP_SHIN_DATA = 0xCB13,
/* Priv */    C_SXP_SELFI_DATA = 0xCB28,
/* Priv */    C_SXP_TEXT_MASKDATA = 0xCB30,
/* Priv */    C_SXP_TEXT2_MASKDATA = 0xCB32,
/* Priv */    C_SXP_OPAC_MASKDATA = 0xCB34,
/* Priv */    C_SXP_BUMP_MASKDATA = 0xCB36,
/* Priv */    C_SXP_SPEC_MASKDATA = 0xCB38,
/* Priv */    C_SXP_SHIN_MASKDATA = 0xCB3A,
/* Priv */    C_SXP_SELFI_MASKDATA = 0xC3C,
/* Priv */    C_SXP_REFL_MASKDATA = 0xCB3E,

/* Priv */    C_BGTYPE = 0xC7A1,
/* Priv */    C_MEDTILE = 0xC7B0,

/* Priv */ /* Contrast */

/* Priv */    C_LO_CONTRAST = 0xC7D0,
/* Priv */    C_HI_CONTRAST = 0xC7D1,

/* Priv */ /* 3d frozen display */

/* Priv */    C_FROZ_DISPLAY = 0xC7E0,

/* Priv */ /* Booleans */
/* Priv */    C_BOOLWELD = 0xc7f0,
/* Priv */    C_BOOLTYPE = 0xc7f1,

/* Priv */    C_ANG_THRESH = 0xC900,
/* Priv */    C_SS_THRESH = 0xC901,
/* Priv */    C_TEXTURE_BLUR_DEFAULT = 0xC903,

/* Priv */    C_MAPDRAWER = 0xCA00,
/* Priv */    C_MAPDRAWER1 = 0xCA01,
/* Priv */    C_MAPDRAWER2 = 0xCA02,
/* Priv */    C_MAPDRAWER3 = 0xCA03,
/* Priv */    C_MAPDRAWER4 = 0xCA04,
/* Priv */    C_MAPDRAWER5 = 0xCA05,
/* Priv */    C_MAPDRAWER6 = 0xCA06,
/* Priv */    C_MAPDRAWER7 = 0xCA07,
/* Priv */    C_MAPDRAWER8 = 0xCA08,
/* Priv */    C_MAPDRAWER9 = 0xCA09,
/* Priv */    C_MAPDRAWER_ENTRY = 0xCA10,

/* Priv */ /* system options */
/* Priv */    C_BACKUP_FILE = 0xCA20,
/* Priv */    C_DITHER_256 = 0xCA21,
/* Priv */    C_SAVE_LAST = 0xCA22,
/* Priv */    C_USE_ALPHA = 0xCA23,
/* Priv */    C_TGA_DEPTH = 0xCA24,
/* Priv */    C_REND_FIELDS = 0xCA25,
/* Priv */    C_REFLIP = 0xCA26,
/* Priv */    C_SEL_ITEMTOG = 0xCA27,
/* Priv */    C_SEL_RESET = 0xCA28,
/* Priv */    C_STICKY_KEYINF = 0xCA29,
/* Priv */    C_WELD_THRESHOLD = 0xCA2A,
/* Priv */    C_ZCLIP_POINT = 0xCA2B,
/* Priv */    C_ALPHA_SPLIT = 0xCA2C,
/* Priv */    C_KF_SHOW_BACKFACE = 0xCA30,
/* Priv */    C_OPTIMIZE_LOFT = 0xCA40,
/* Priv */    C_TENS_DEFAULT = 0xCA42,
/* Priv */    C_CONT_DEFAULT = 0xCA44,
/* Priv */    C_BIAS_DEFAULT = 0xCA46,

/* Priv */    C_DXFNAME_SRC  = 0xCA50,
/* Priv */    C_AUTO_WELD  = 0xCA60,
/* Priv */    C_AUTO_UNIFY  = 0xCA70,
/* Priv */    C_AUTO_SMOOTH  = 0xCA80,
/* Priv */    C_DXF_SMOOTH_ANG  = 0xCA90,
/* Priv */    C_SMOOTH_ANG  = 0xCAA0,

/* Priv */ /* Special network-use chunks */

/* Priv */    C_NET_USE_VPOST = 0xCC00,
/* Priv */    C_NET_USE_GAMMA = 0xCC10,
/* Priv */    C_NET_FIELD_ORDER = 0xCC20,

/* Priv */    C_BLUR_FRAMES = 0xCD00,
/* Priv */    C_BLUR_SAMPLES = 0xCD10,
/* Priv */    C_BLUR_DUR = 0xCD20,
/* Priv */    C_HOT_METHOD = 0xCD30,
/* Priv */    C_HOT_CHECK = 0xCD40,
/* Priv */    C_PIXEL_SIZE = 0xCD50,
/* Priv */    C_DISP_GAMMA = 0xCD60,
/* Priv */    C_FBUF_GAMMA = 0xCD70,
/* Priv */    C_FILE_OUT_GAMMA = 0xCD80,
/* Priv */    C_FILE_IN_GAMMA = 0xCD82,
/* Priv */    C_GAMMA_CORRECT = 0xCD84,
/* Priv */    C_APPLY_DISP_GAMMA = 0xCD90  /* OBSOLETE */,
/* Priv */    C_APPLY_FBUF_GAMMA = 0xCDA0  /* OBSOLETE */,
/* Priv */    C_APPLY_FILE_GAMMA = 0xCDB0  /* OBSOLETE */,
/* Priv */    C_FORCE_WIRE = 0xCDC0,
/* Priv */    C_RAY_SHADOWS = 0xCDD0,
/* Priv */    C_MASTER_AMBIENT = 0xCDE0,
/* Priv */    C_SUPER_SAMPLE = 0xCDF0,
/* Priv */    C_OBJECT_MBLUR = 0xCE00,
/* Priv */    C_MBLUR_DITHER = 0xCE10,
/* Priv */    C_DITHER_24 = 0xCE20,
/* Priv */    C_SUPER_BLACK = 0xCE30,
/* Priv */    C_SAFE_FRAME = 0xCE40,
/* Priv */    C_VIEW_PRES_RATIO = 0xCE50,
/* Priv */    C_BGND_PRES_RATIO = 0xCE60,
/* Priv */    C_NTH_SERIAL_NUM = 0xCE70,

/* Priv */    /* Video Post */
/* Priv */    VPDATA = 0xd000,

/* Priv */    P_QUEUE_ENTRY = 0xd100,
/* Priv */    P_QUEUE_IMAGE = 0xd110,
/* Priv */    P_QUEUE_USEIGAMMA = 0xd114,
/* Priv */    P_QUEUE_PROC = 0xd120,
/* Priv */    P_QUEUE_SOLID = 0xd130,
/* Priv */    P_QUEUE_GRADIENT = 0xd140,
/* Priv */    P_QUEUE_KF = 0xd150,
/* Priv */    P_QUEUE_MOTBLUR = 0xd152,
/* Priv */    P_QUEUE_MB_REPEAT = 0xd153,
/* Priv */    P_QUEUE_NONE = 0xd160,

/* Priv */    P_QUEUE_RESIZE = 0xd180,
/* Priv */    P_QUEUE_OFFSET = 0xd185,
/* Priv */    P_QUEUE_ALIGN = 0xd190,

/* Priv */    P_CUSTOM_SIZE = 0xd1a0,

/* Priv */    P_ALPH_NONE = 0xd210,
/* Priv */    P_ALPH_PSEUDO = 0xd220	/* Old chunk */,
/* Priv */    P_ALPH_OP_PSEUDO = 0xd221	/* Old chunk */,
/* Priv */    P_ALPH_BLUR = 0xd222		/* Replaces pseudo */,
/* Priv */    P_ALPH_PCOL = 0xd225,
/* Priv */    P_ALPH_C0 = 0xd230,
/* Priv */    P_ALPH_OP_KEY = 0xd231,
/* Priv */    P_ALPH_KCOL = 0xd235,
/* Priv */    P_ALPH_OP_NOCONV = 0xd238,
/* Priv */    P_ALPH_IMAGE = 0xd240,
/* Priv */    P_ALPH_ALPHA = 0xd250,
/* Priv */    P_ALPH_QUES = 0xd260,
/* Priv */    P_ALPH_QUEIMG = 0xd265,
/* Priv */    P_ALPH_CUTOFF = 0xd270,
/* Priv */    P_ALPHANEG = 0xd280,

/* Priv */    P_TRAN_NONE = 0xd300,
/* Priv */    P_TRAN_IMAGE = 0xd310,
/* Priv */    P_TRAN_FRAMES = 0xd312,
/* Priv */    P_TRAN_FADEIN = 0xd320,
/* Priv */    P_TRAN_FADEOUT = 0xd330,
/* Priv */    P_TRANNEG = 0xd340,

/* Priv */    P_RANGES = 0xd400,

/* Priv */    P_PROC_DATA = 0xd500

/* Priv */ } chunktag3ds;


/* Priv */ /* chunk3ds - Internal database representation of file information */
/* Priv */ typedef struct chunk3ds {
/* Priv */    chunktag3ds tag;           /* Type of chunk */
/* Priv */    ulong3ds     size;         /* Number of bytes used by chunk */
/* Priv */    ulong3ds     position;     /* Offset in source file */
/* Priv */    void        *data;         /* Memory copy of file data */
/* Priv */    struct chunk3ds *sibling;  /* Next chunk in database */
/* Priv */    struct chunk3ds *children; /* Chunks contained within this chunk */
/* Priv */    ubyte3ds readindex;        /* Index of source file in file table */
/* Priv */    ubyte3ds writeindex;       /* Index of destination file in file table */
/* Priv */ } chunk3ds;

/* Priv */ /* chunklistentry3ds - Cross reference between name and chunk */
/* Priv */ typedef struct {
/* Priv */    char3ds *name;                  /* Chunk Name list */
/* Priv */    chunk3ds *chunk;                /* Corresponding Pos */
/* Priv */ } chunklistentry3ds;

/* Priv */ /* chunklist3ds - List of cross references */
/* Priv */ typedef struct 
/* Priv */ {
/* Priv */    ulong3ds count; /* Number of entries in list */
/* Priv */    chunklistentry3ds *list; /* Contents of list */
/* Priv */ } chunklist3ds;


/* namelistentry3ds - Name of database object */
typedef struct 
{
   char3ds *name; /* Name of object */
} namelistentry3ds;

/* namelist3ds - List of database object names */
typedef struct
{
   ulong3ds count;          /*--- How many entries are in list */
   ulong3ds spaces;         /*--- How much space for entries */
   namelistentry3ds *list;  /*--- char ** to access pointers */
} namelist3ds;


/* Priv */ /* filestate3ds - Read/write state of a file */
/* Priv */ typedef enum 
/* Priv */ {
/* Priv */    StateNotKnown = 0, /* No state determined yet, file not open */
/* Priv */    ReadFromFile = 1,  /* Open for read */
/* Priv */    WriteToFile = 2,   /* Open for write */
/* Priv */    ReadWriteFile = 3  /* Open for read and write, not used by toolkit */
/* Priv */ } filestate3ds;

/* file3ds - Handle to 3D Studio files */
typedef struct
{
   FILE *file;         /* stdio file pointer */
   char3ds *filename;  /* name of file */
   filestate3ds state; /* file open state */
   ubyte3ds index;     /* Position of pointer in the FileContextList, if the
                          index eq InvalidFileContext3ds, then it is not in the
                          list */
   void *buffer;       /* Buffered I/O buffer */
   ulong3ds buffersize;
   byte3ds istempfile; /* True3ds if file is a temp file */
} file3ds;

/* Priv */ /* dbtype3ds - Database type settings */
/* Priv */ typedef enum
/* Priv */ {
/* Priv */    Unknown,      /* Database has not be created yet */
/* Priv */    MeshFile,     /* 3D Studio .3DS file */
/* Priv */    ProjectFile,  /* 3D STudio .PRJ file */
/* Priv */    MaterialFile  /* 3D Studio .MLI file */
/* Priv */ } dbtype3ds;

/* database3ds - File database */
typedef struct
{
   chunk3ds *topchunk; /* top chunk in the file */
   byte3ds objlistdirty; /* If true, than *objlist needs to be recreated */
   byte3ds matlistdirty;
   byte3ds nodelistdirty;
   chunklist3ds *objlist; /* Quick Cross references between names and database chunks */
   chunklist3ds *matlist;
   chunklist3ds *nodelist;
} database3ds;
typedef enum
{
   NoView3ds,
   TopView3ds,
   BottomView3ds,
   LeftView3ds,
   RightView3ds,
   FrontView3ds,
   BackView3ds,
   UserView3ds,
   CameraView3ds,
   SpotlightView3ds
} viewtype3ds;

typedef struct
{
   ushort3ds xpos;
   ushort3ds ypos;
   ushort3ds width;
   ushort3ds height;
} viewsize3ds;

/* Used to describe top, bottom, left, right, front and back views */
typedef struct
{
   point3ds center; /* Center of orthagonal view */
   float3ds zoom; /* View zoom factor */
} orthoview3ds;

/* Used to describe user views */
typedef struct
{
   point3ds center; /* Center of user view */
   float3ds zoom; /* View zoom factor */
   float3ds horang; /* Horizontal angle of view */
   float3ds verang; /* Veritical angle of view */
} userview3ds;

/* Used to describe camera views */
typedef struct
{
   char3ds name[11]; /* Name of the camera used in the view */
} cameraview3ds;

/* Viewport structure details the kind of view in a viewport */
typedef struct
{
   viewtype3ds type; /* top, bottom, left, right, front, back, user and camera */
   viewsize3ds size; /* Size of the viewport */
   orthoview3ds ortho; /* used for top, bottom, left, right, front, and back views */
   userview3ds user; /* Used for user views */
   cameraview3ds camera; /* Used for camera views */
} viewport3ds;
typedef enum 
{
   UseShadowMap,
   UseRayTraceShadow
} shadowstyle3ds;

typedef struct { /* global shadow settings */
   shadowstyle3ds type; /* Either UseShadowMaps or UseRayTraceShadows */
   float3ds bias; /* shadow bias factor. */
   float3ds raybias; /* shadow ray bais factor. Used in R3 */
   short3ds mapsize; /* shadow map size */
   float3ds filter; /* shadow filter */
} shadowsets3ds;
   
typedef struct {
   float3ds masterscale; /* Master mesh scale factor */
   shadowsets3ds shadow; /* Global shadow settings */
   fcolor3ds ambientlight;  /* ambient light color */
   point3ds oconsts; /* default object constructing axis */
} meshset3ds;
typedef enum
{
   NoAtmo, /* no active astmospherics */
   UseFog, /* fog astmostpheric */
   UseLayerFog, /* layer fog astmostpheric */
   UseDistanceCue /* distance cue astmostpheric */
} atmospheretype3ds;

typedef enum
{
   NoFall, /* no falloff */
   TopFall, /* falloff to the top */
   BottomFall /* falloff to the bottom */
} layerfogfalloff3ds;

typedef struct /* fog atmosphere parameters */
{
   float3ds nearplane; /* near radius of fog effect */
   float3ds neardensity; /* near fog density */
   float3ds farplane; /* far radius of fog effect */
   float3ds fardensity; /* far fog density */
   fcolor3ds     fogcolor; /* color of fog effect */
   byte3ds    fogbgnd; /* True3ds / False3ds "fog background" flag */
} fogsettings3ds;

typedef struct /* layered fog atmosphere parameters */
{
   float3ds zmin; /* lower bounds of fog */
   float3ds zmax; /* upper bounds of fog */
   float3ds density; /* fog density */
   fcolor3ds fogcolor; /* fog color */
   layerfogfalloff3ds falloff; /* falloff style */
   byte3ds fogbgnd; /* True3ds / False3ds "fog background" flag */
} layerfogsettings3ds;

typedef struct /* distance cue atmosphere parameters */
{
   float3ds nearplane; /* near radius of effect */
   float3ds neardim; /* near dimming factor */
   float3ds farplane; /* far radius of effect */
   float3ds fardim; /* far dimming factor */
   byte3ds dcuebgnd; /* True3ds / False3ds effect the background flag */
} dcuesettings3ds;

typedef struct {
   fogsettings3ds fog; /* fog atmostphere settings */
   layerfogsettings3ds layerfog;  /* layered fog atmosphere parameters */
   dcuesettings3ds dcue;  /* distance cue atmosphere parameters */
   atmospheretype3ds activeatmo; /* The active astmospheric */
} atmosphere3ds;

/* enumerate list of possible backgrounds used in file */
typedef enum
{
   NoBgnd,
   UseSolidBgnd,
   UseVGradientBgnd, 
   UseBitmapBgnd
} backgroundtype3ds;

typedef struct 
{
   char3ds *name; /* name of background bitmap */
} bitmapbgnd3ds;

typedef struct 
{
   fcolor3ds color; /* color of solid background */
} solidbgnd3ds;

typedef struct 
{
   float3ds gradpercent; /* Placement of mid color band, ranges from 0-1 */ 
   fcolor3ds  top; /* color of top band */
   fcolor3ds  mid; /* color of mid background band */
   fcolor3ds  bottom; /* color of bottom band */
} vgradientbgnd3ds;

typedef struct {
   bitmapbgnd3ds bitmap;
   solidbgnd3ds solid;
   vgradientbgnd3ds vgradient;
   backgroundtype3ds bgndused; /* background in effect */
} background3ds;

/* Used for shading field in material3ds structure */
typedef enum
{
   Wire = 0,
   Flat = 1,
   Gouraud = 2,
   Phong = 3,
   Metal = 4
} shadetype3ds;

/* Used for tiling field in bitmap3ds structure */
typedef enum 
{
   Tile = 1,
   Decal = 2,
   Both = 3
} tiletype3ds;

typedef enum
{
   Pyramidal,
   SummedArea
} filtertype3ds;

typedef enum
{
   RGB,
   Alpha,
   RGBLumaTint,
   AlphaTint,
   RGBTint
} tinttype3ds;


/* Used By AddMaterial3ds */

typedef struct {
   ubyte3ds firstframe; /* True for First Frame Only */
   ubyte3ds flat; /* True for flat mirror reflection */
   ulong3ds size;     /* Map resolution */
   ulong3ds nthframe; /* Map update period */
} acubic3ds;          /* Cubic reflection map defintion */

typedef struct {
   char3ds  name[13];  /* Bitmap file name */
   float3ds percent;  /* Strength percentage */
   tiletype3ds tiling;  /* Tile/Decal/Both */
   byte3ds ignorealpha;
   filtertype3ds filter; /* Pyramidal/Summed Area */
   float3ds blur;
   byte3ds mirror;
   byte3ds negative;
   float3ds uscale, vscale;
   float3ds uoffset, voffset;
   float3ds rotation;
   tinttype3ds source; /* RGB/RGB Luma Tint/Alpha Tint/RGB Tint */
   fcolor3ds tint1;
   fcolor3ds tint2;
   fcolor3ds redtint;
   fcolor3ds greentint;
   fcolor3ds bluetint;
   ulong3ds datasize; /* Size of procedural data */
   void3ds *data;     /* Procedural data */
} bitmap3ds;          /* Bit map definition */

/* Structure to all map settings */
typedef struct {
   bitmap3ds map; /* The map settings */
   bitmap3ds mask; /* The mask settings */
} mapset3ds;

typedef struct {
   bitmap3ds map; /* The map settings */
   byte3ds useauto; /* True3ds if automatic reflections are being used */
   acubic3ds automap; /* Automatic reflection definitions */
   bitmap3ds mask; /* The mask settings */
} rmapset3ds;
   
typedef struct {
   char3ds name[17];      /* Name */
   fcolor3ds ambient;     /* Ambient light color */
   fcolor3ds diffuse;     /* Diffuse light color */
   fcolor3ds specular;    /* Specular light color */
   float3ds shininess;    /* Shininess factor */
   float3ds shinstrength; /* Shininess strength */
   float3ds blur;         /* Blur factor */
   float3ds transparency; /* Trasparency factor */
   float3ds transfalloff; /* Fallof factor */
   float3ds selfillumpct;     /* Self illumination percentage */
   float3ds wiresize;     /* Width of wireframe */
   shadetype3ds shading;      /* Shading type */
   byte3ds useblur;       /* Blurring flag */
   byte3ds usefall;       /* Transparency falloff flag */
   byte3ds twosided;      /* Two sided material flag */
   byte3ds selfillum;     /* Self illumination flag */
   byte3ds additive;      /* Additive transparency flag */
   byte3ds usewire;       /* Use wireframe rendering */
   byte3ds usewireabs;    /* Wire size is in units, not pixels. */
   byte3ds facemap;       /* Face mapping switch */
   byte3ds soften;        /* Soften switch */
   mapset3ds texture;     /* Texture map settings */
   mapset3ds texture2;    /* Second texture map settings */
   mapset3ds opacity;     /* Opacity map settings */
   mapset3ds bump;       /* Bump map settings */
   mapset3ds specmap;     /* Specularity map settings */
   mapset3ds shinmap;     /* Shininess map settings */
   mapset3ds illummap;    /* Self illumination map settings */
   rmapset3ds reflect;    /* Reflection map settings */
} material3ds;            /* Material definition */

/* mapinfo3ds - Texture map icon placement */
typedef struct {
   ushort3ds maptype;    /* Icon type */
   float3ds tilex;       /* Tiling */
   float3ds tiley;
   float3ds cenx;        /* Position of center */
   float3ds ceny;
   float3ds cenz;
   float3ds scale;       /* Icon scaling factor */
   float3ds matrix[12];  /* Orientation matrix */
   float3ds pw;          /* Planar icon width */
   float3ds ph;          /* Planar icon height */
   float3ds ch;          /* Cylinder icon height */
} mapinfo3ds;            

/* objmat3ds - Material assignments by face */
typedef struct {
   char3ds name[17];     /* Material name */
   ushort3ds nfaces;     /* Number of faces using material */
   ushort3ds *faceindex; /* List of faces using material */
} objmat3ds;             

/* mesh3ds - Mesh object definition */
typedef struct {
   char3ds name[11];       /* Object name */
   byte3ds ishidden;       /* Hidden object flag */
   byte3ds isvislofter;    /* Lofter visibility flag */
   byte3ds ismatte;        /* Matte object flag */
   byte3ds isnocast;       /* Doesn't cast shadow's flag */
   byte3ds isfast;         /* Fast display flag */
   byte3ds isnorcvshad;    /* Doesn't recieve shadows */
   byte3ds isfrozen;       /* Frozen object flag */
   ushort3ds nvertices;    /* Vertice count */
   point3ds *vertexarray;  /* List of vertices */
   ushort3ds nvflags;      /* Number of vertex flags */
   ushort3ds *vflagarray;  /* List of vertex flags */
   ushort3ds ntextverts;   /* Number of texture vertices */   
   textvert3ds *textarray; /* List of texture coordinates */
   byte3ds usemapinfo;     /* Boolean for use of mapping icon information */
   mapinfo3ds map;         /* Mapping icon info */
   float3ds locmatrix[12]; /* Object orientation matrix */
   ushort3ds nfaces;       /* Face count */
   face3ds *facearray;     /* List of faces */
   ulong3ds *smootharray;  /* Smoothing group assignment list */
   byte3ds useboxmap;     /* Boolean used to indicate the use of box mapping */
   char3ds boxmap[6][17];  /* Material names used in boxmapping */
   ubyte3ds meshcolor;     /* UI color assigned to the mesh */
   ushort3ds nmats;        /* Assigned materials count */
   objmat3ds *matarray;    /* Material assignment list */
   byte3ds useproc;        /* Use animated stand-in flag */
   ulong3ds procsize;      /* Size of animated stand-in data */
   char3ds procname[13];   /* Name of animated stand-in procedure */
   void3ds *procdata;      /* Animated stand-in data */
} mesh3ds;                  

/* conestyle3ds - Spolight projection cone shape. */
typedef enum
{
   Circular,
   Rectangular
} conestyle3ds;

/* spotshadow - Spotlight shadow settings */
typedef struct {
   byte3ds cast; /* True if spotlight casts shadows */
   shadowstyle3ds type; /* UseShadow or UseRayTrace */
   byte3ds local; /* True if local shadow settings are being used */
   float3ds bias; /* Shadow bias */
   float3ds filter; /* Shadow filter */
   ushort3ds mapsize; /* Shadow map size */
   float3ds raybias; /* Ray tracing shadow bias */
} spotshadow3ds; 

/* spotcond3ds - cone visability settings */
typedef struct {
   conestyle3ds type; /* Circular or rectangular light cone */
   byte3ds show; /* True if cone is visable */
   byte3ds overshoot;  /* True if cone overshoot is on */
} spotcone3ds;

/* spotproject3ds - spotlight projectio bitmap */
typedef struct {
   byte3ds use; /* True if using projector */
   char3ds *bitmap; /* Name of projector bitmap */
} spotprojector3ds;

/* spotlight3ds - spotlight settings */
typedef struct
{
   point3ds target;  /* Spotlight target */
   float3ds hotspot; /* Hotspot angle */
   float3ds falloff; /* Hotspot falloff */
   float3ds roll;    /* Roll angle */
   float3ds aspect;  /* Aspect ratio */
   spotshadow3ds shadows; 
   spotcone3ds cone;
   spotprojector3ds projector;
} spotlight3ds;

/* liteattenuate3ds - Light attenuation settings */
typedef struct {
   byte3ds on; /* True if light attenuation is on */
   float3ds inner; /* Inner range of attenuation */
   float3ds outer; /* Outer range of attenuation */ 
} liteattenuate3ds;

/* light3ds - omni and spotlight settings */
typedef struct {
   char3ds name[11];   /* Light name */
   point3ds pos; /* Light position */
   fcolor3ds color; /* Light color */
   float3ds multiplier;/* Light intensity multiplier */
   byte3ds dloff; /* True if light is off */
   liteattenuate3ds attenuation;
   namelist3ds *exclude;
   spotlight3ds *spot; /* If not null, then struct is a spotlight, else omni. */
} light3ds;

/* camrange3ds - Camera atomosphere ranges */
typedef struct {
   float3ds cam_near; /* Nearest effect radiu */
   float3ds cam_far; /* Farthest effect radius */
} camranges3ds;

typedef struct 
{
   char3ds name[11];
   point3ds position;
   point3ds target;
   float3ds roll;
   float3ds fov;
   byte3ds showcone;
   camranges3ds ranges;
} camera3ds;

typedef struct {
  ulong3ds length;
  ulong3ds curframe;
} kfkeyinfo3ds;

typedef struct {
  byte3ds use;
  ulong3ds begin;
  ulong3ds end;
} kfsegment3ds;

typedef struct
{
  kfkeyinfo3ds anim;
  kfsegment3ds seg;
} kfsets3ds;


typedef struct {
  char3ds name[11];    /* Name of camera object */
  char3ds parent[22];  /* Name of parent object */
  
  ushort3ds flags1;    /* flags field from node header -fixup later */
  ushort3ds flags2;    /* flags2 field from node header -fixup later */
  
  ulong3ds npkeys;     /* Number of camera position keys */
  ushort3ds npflag;    /* Loop control flag for camera position keys */
  keyheader3ds *pkeys; /* Spline values for camera position keys */
  point3ds *pos;       /* Camera position keys */
  
  ulong3ds nfkeys;     /* Number of camera FOV keys */
  ushort3ds nfflag;    /* Loop control flag for camera FOV keys */
  keyheader3ds *fkeys; /* Spline values for camera FOV keys */
  float3ds *fov;       /* Camera FOV keys */
  
  ulong3ds nrkeys;     /* Number of camera roll keys */
  ushort3ds nrflag;    /* Loop control flag for camera roll keys */
  keyheader3ds *rkeys; /* Spline values for camera roll keys */
  float3ds *roll;      /* Camera roll keys */
  
  char3ds tparent[22]; /* Index of parent object for target */
  ulong3ds ntkeys;     /* Number of target position keys */
  ushort3ds ntflag;    /* Loop control flag for target position keys */
  keyheader3ds *tkeys; /* Spline values for target position keys */
  point3ds *tpos;      /* Target position keys */
  ushort3ds tflags1;   /* flags field from target node header */
  ushort3ds tflags2;   /* flags field from target node header */
} kfcamera3ds;

/* kfambient3ds - Ambient light animation */
typedef struct {
   ushort3ds flags1;    /* flags field from node header -fixup later     */
   ushort3ds flags2;    /* flags2 field from node header -fixup later    */

   ulong3ds nckeys;     /* Number of color keys                          */
   ushort3ds ncflag;    /* Loop control flag for color keys              */
   keyheader3ds *ckeys; /* Spline values for position keys               */
   fcolor3ds *color;    /* Color keys                                    */
} kfambient3ds;
/* Used By ObjectMotion3ds */

typedef struct {
   char3ds name[11];     /* Name of mesh */
   char3ds parent[22];   /* Name of parent object */
   ushort3ds flags1;     /* flags field from node header  */
   ushort3ds flags2;     /* flags2 field from node header  */

   point3ds pivot;       /* Object pivot point */
   char3ds instance[11]; /* Object instance name */
   point3ds boundmin;    /* Minimum bounding box point for dummy objects */
   point3ds boundmax;    /* Maximum bounding box point for dummy objects */

   ulong3ds npkeys;      /* Number of position keys */
   short3ds npflag;      /* Loop control flag for position keys */
   keyheader3ds *pkeys;  /* Spline values for position keys */
   point3ds *pos;        /* Mesh position keys */

   ulong3ds nrkeys;      /* Number of rotation keys */
   short3ds nrflag;      /* Loop control flag for rotation keys */
   keyheader3ds *rkeys;  /* Spline values for rotation keys */
   kfrotkey3ds *rot;     /* Rotation keys */

   ulong3ds nskeys;      /* Number of scaling keys */
   short3ds nsflag;      /* Loop control flag for scaling keys */
   keyheader3ds *skeys;  /* Spline values for scaling */
   point3ds *scale;      /* Mesh scaling keys */

   ulong3ds nmkeys;      /* Number of morph keys */
   short3ds nmflag;      /* Loop control flag for morph keys */
   keyheader3ds *mkeys;  /* Spline values for morph keys */
   kfmorphkey3ds *morph; /* Morph keys */

   ulong3ds nhkeys;      /* Number of hide keys */
   short3ds nhflag;      /* Loop control flag for hide keys */
   keyheader3ds *hkeys;  /* Spline values for hide keys */
   float3ds msangle;     /* Morph smoothing group angle */
} kfmesh3ds;

/* Used By OmnilightMotion3ds */

typedef struct {
   char3ds name[11];    /* Name of the light object node */
   char3ds parent[22];  /* Name of the parent object */

   ushort3ds flags1;    /* flags field from node header -fixup later */
   ushort3ds flags2;    /* flags2 field from node header -fixup later */

   ulong3ds npkeys;     /* Number of position keys */
   ushort3ds npflag;     /* Loop control flag for position keys */
   keyheader3ds *pkeys; /* Spline values for position keys */
   point3ds *pos;       /* Position keys */

   ulong3ds nckeys;     /* Number of color keys */
   ushort3ds ncflag;     /* Loop control flag for color keys */
   keyheader3ds *ckeys; /* Spline values for position keys */
   fcolor3ds *color;   /* Color keys */

} kfomni3ds;

typedef struct {
   char3ds name[11];    /* Name of camera object */
   char3ds parent[22];  /* Parent name */

   ushort3ds flags1;    /* flags field from node header -fixup later */
   ushort3ds flags2;    /* flags2 field from node header -fixup later */

#ifdef broken
   short3ds visable;    /* Flags to control visability */
#endif
   ulong3ds npkeys;     /* Number of light position keys */
   ushort3ds npflag;     /* Loop control flag for position keys */
   keyheader3ds *pkeys; /* Spline values for light position keys */
   point3ds *pos;       /* Light position keys */

   ulong3ds nckeys;     /* Number of color keys */
   ushort3ds ncflag;     /* Loop control flag color keys */
   keyheader3ds *ckeys; /* Spline values for color keys */
   fcolor3ds *color;    /* Color keys */

   ulong3ds nhkeys;     /* Number of hotspot angle keys */
   ushort3ds nhflag;     /* Loop control flag for hotspot angle keys */
   keyheader3ds *hkeys; /* Spline values for hotspot angle keys */
   float3ds *hot;       /* Hotspot angle keys */

   ulong3ds nfkeys;     /* Number of falloff angle keys */
   ushort3ds nfflag;     /* Loop control flag for falloff angle keys */
   keyheader3ds *fkeys; /* Spline values for falloff angle keys */
   float3ds *fall;      /* Falloff angle keys */

   ulong3ds nrkeys;     /* Number of light roll keys */
   ushort3ds nrflag;     /* Loop control flag for light roll keys */
   keyheader3ds *rkeys; /* Spline values for light roll keys */
   float3ds *roll;      /* Light roll keys */

   char3ds tparent[22];    /* Name of target's parent object */
   ulong3ds ntkeys;     /* Number of target position keys */
   ushort3ds ntflag;     /* Loop control flag for target position keys */
   keyheader3ds *tkeys; /* Spline values for target position keys */
   point3ds *tpos;      /* Target position keys */
   ushort3ds tflags1;   /* flags field from target node header */
   ushort3ds tflags2;   /* flags field from target node header */

} kfspot3ds;
typedef struct {
   long3ds size;
   void3ds *data;
} xdataraw3ds;


/*----------------------------------------
  Constants for commonly used structures
  --------------------------------------*/

/* 3DS File Toolkit revision level.  Future revisions will increment this
   integer number */
static const long3ds __FTKRevisionLevel3ds = FTKRevisionLevel3ds; 

/* Flags used by the flag field of the mesh3ds structure */
static const ushort3ds FaceCAVisable3ds = 0x0001;  /* Flags the CA edge as visable */
static const ushort3ds FaceBCVisable3ds = 0x0002;  /* Flags the BC edge as visable */
static const ushort3ds FaceABVisable3ds = 0x0004;  /* Flags the AB edge as visable */
static const ushort3ds FaceUWrap3ds     = 0x0008;  /* Flags the face as being at
						      a texture coord u wrap
						      seam */
static const ushort3ds FaceVWrap3ds     = 0x0010;  /* Flags the face as being at
						      a texture coord v wrap
						      seam */

/* Flags used by the rflags field of the keyheader3ds structure */
static const ushort3ds KeyUsesTension3ds = 0x01;
static const ushort3ds KeyUsesCont3ds    = 0x02;
static const ushort3ds KeyUsesBias3ds    = 0x04;
static const ushort3ds KeyUsesEaseTo3ds  = 0x08;
static const ushort3ds KeyUsesEaseFrom3ds= 0x10;

/* Flags used by the track flags field */
static const ushort3ds TrackSingle3ds  = 0x0000;
static const ushort3ds TrackLoops3ds   = 0x0003;
static const ushort3ds TrackRepeats3ds = 0x0002;
static const ushort3ds TrackLockX3ds   = 0x0008;
static const ushort3ds TrackLockY3ds   = 0x0010;
static const ushort3ds TrackLockZ3ds   = 0x0020;
static const ushort3ds TrackNoLinkX3ds = 0x0100;
static const ushort3ds TrackNoLinkY3ds = 0x0200;
static const ushort3ds TrackNoLinkZ3ds = 0x0400;

/* Basic structure default contents for ease of initialization */
static const point3ds DefPoint3ds = {0.0F, 0.0F, 0.0F};
static const textvert3ds DefTextVert3ds = {0.0F, 0.0F};
static const face3ds DefFace3ds = {0, 1, 2, 0};
static const trackheader3ds DefTrackHeader3ds = {0, 0, 0, 1};
static const keyheader3ds DefKeyHeader3ds = {0, 0, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F};
/* Last toolkit error */
extern byte3ds ftkerr3ds; /* True3ds if error is pending */
extern byte3ds ignoreftkerr3ds; /* True3ds if errors are being ignored by toolkit */
/* Fog flags */
static const ulong3ds LayerFogBgnd = 0x100000;
static const ulong3ds NoFalloff = 0x0;
static const ulong3ds TopFalloff = 0x2;
static const ulong3ds BottomFalloff = 0x1;


/* Flags for initflags parameter */
static const ushort3ds InitNoExtras3ds    = 0x0000;
static const ushort3ds InitVertexArray3ds = 0x0001;
static const ushort3ds InitTextArray3ds   = 0x0002;
static const ushort3ds InitFaceArray3ds   = 0x0004;
static const ushort3ds InitMatArray3ds    = 0x0008;
static const ushort3ds InitSmoothArray3ds = 0x0010;
static const ushort3ds InitProcData3ds    = 0x0020;
static const ushort3ds InitVFlagArray3ds  = 0x0040;


/* Smoothing group flags used in the smootharray field of the mesh3ds structure */
static const ulong3ds Smooth01Group3ds = 0x00000001;
static const ulong3ds Smooth02Group3ds = 0x00000002;
static const ulong3ds Smooth03Group3ds = 0x00000004;
static const ulong3ds Smooth04Group3ds = 0x00000008;
static const ulong3ds Smooth05Group3ds = 0x00000010;
static const ulong3ds Smooth06Group3ds = 0x00000020;
static const ulong3ds Smooth07Group3ds = 0x00000030;
static const ulong3ds Smooth08Group3ds = 0x00000080;
static const ulong3ds Smooth09Group3ds = 0x00000100;
static const ulong3ds Smooth10Group3ds = 0x00000200;
static const ulong3ds Smooth11Group3ds = 0x00000400;
static const ulong3ds Smooth12Group3ds = 0x00000800;
static const ulong3ds Smooth13Group3ds = 0x00001000;
static const ulong3ds Smooth14Group3ds = 0x00002000;
static const ulong3ds Smooth15Group3ds = 0x00004000;
static const ulong3ds Smooth16Group3ds = 0x00008000;
static const ulong3ds Smooth17Group3ds = 0x00010000;
static const ulong3ds Smooth18Group3ds = 0x00020000;
static const ulong3ds Smooth19Group3ds = 0x00040000;
static const ulong3ds Smooth20Group3ds = 0x00080000;
static const ulong3ds Smooth21Group3ds = 0x00100000;
static const ulong3ds Smooth22Group3ds = 0x00200000;
static const ulong3ds Smooth23Group3ds = 0x00400000;
static const ulong3ds Smooth24Group3ds = 0x00800000;
static const ulong3ds Smooth25Group3ds = 0x01000000;
static const ulong3ds Smooth26Group3ds = 0x02000000;
static const ulong3ds Smooth27Group3ds = 0x04000000;
static const ulong3ds Smooth28Group3ds = 0x08000000;
static const ulong3ds Smooth29Group3ds = 0x10000000;
static const ulong3ds Smooth30Group3ds = 0x20000000;
static const ulong3ds Smooth31Group3ds = 0x40000000;
static const ulong3ds Smooth32Group3ds = 0x80000000;
static const char3ds *DummyName3ds = "$$$DUMMY";
/* Flag settings for kfmesh3ds, kfomni3ds, kfcamera3ds, kfambient, and kfspot3ds */

/* For the flags field */
static const ushort3ds KfNodeOff3ds = 1<<3;
static const ushort3ds KfHideNode3ds = 1<<11;
static const ushort3ds KfFastNode3ds = 1<<12;

/* For the flags2 field */
static const ushort3ds KfNodeHasPath3ds = 1;
static const ushort3ds KfNodeAutoSmooth3ds = 1<<1;
static const ushort3ds KfNodeFrozen3ds = 1<<2;
static const ushort3ds KfMotionBlur3ds = 1<<4;
static const ushort3ds KfBlurBranch3ds = 1<<5;
static const ushort3ds KfMorphMtl3ds   = 1<<6;
static const ushort3ds KfMorphOb       = 1<<7;

typedef enum
{
  LightTarget,
  CameraTarget
} targettype3ds;

static const long3ds  TerseDump3ds = 0; /* Just the chunk headers */
static const long3ds MediumDump3ds = 1; /* Selected bits of data (usually not array dumps) */
static const long3ds MaximumDump3ds = 2; /* Everything */
/* Priv */ void PushErrList3ds(errorid3ds id);
/* Priv */ const char3ds *ErrCodeToString3ds(errorid3ds err);
void DumpErrList3ds(FILE *outfile);
void ClearErrList3ds();
const ErrRec3ds *ReturnErrorList3ds();


/* Functions to use with namelist3ds structures */
void InitNameList3ds(namelist3ds **chunk, ulong3ds count);
void ReleaseNameList3ds(namelist3ds **chunk);
void AddToNameList3ds(namelist3ds **list, char3ds *name);

/* File control functions */
file3ds *OpenFile3ds(const char3ds *filename, const char *attrib);
void CloseAllFiles3ds();
void CloseFile3ds(file3ds *file);


/* Database functions */
void InitDatabase3ds(database3ds **db);
void ReleaseDatabase3ds(database3ds **db);
void CreateDatabase3ds(file3ds *file, database3ds *db);
void CreateNewDatabase3ds(database3ds *db, dbtype3ds type);
dbtype3ds GetDatabaseType3ds(database3ds *db);
void CopyDatabase3ds(database3ds *idb, database3ds *odb);
void DisconnectDatabase3ds(database3ds *db);
void WriteDatabase3ds(file3ds *file, database3ds *db);
void InitViewport3ds(viewport3ds **vp);
void ReleaseViewport3ds(viewport3ds **vp);
void GetViewport3ds(database3ds *db, viewport3ds **vp);
void PutViewport3ds(database3ds *db, viewport3ds *vp);
void CopyViewport3ds(database3ds *destdb, database3ds *srcdb);
void InitMeshSet3ds(meshset3ds **);
void ReleaseMeshSet3ds(meshset3ds **);
void GetMeshSet3ds(database3ds *, meshset3ds **);
void PutMeshSet3ds(database3ds *db, meshset3ds *settings);
void CopyMeshSet3ds(database3ds *destdb, database3ds *srcdb);

void InitAtmosphere3ds(atmosphere3ds **atmo);
void ReleaseAtmosphere3ds(atmosphere3ds **atmo);
void GetAtmosphere3ds(database3ds *db, atmosphere3ds **atmo);
void PutAtmosphere3ds(database3ds *db, atmosphere3ds *atmo);
void CopyAtmosphere3ds(database3ds *destdb, database3ds *srcdb);

void InitBackground3ds(background3ds **bgnd);
void ReleaseBackground3ds(background3ds **bgnd);
void GetBackground3ds(database3ds *db, background3ds **bgnd);
void PutBackground3ds(database3ds *db, background3ds *bgnd);
void CopyBackground3ds(database3ds *destdb, database3ds *srcdb);

short3ds AddMaterial3ds(const material3ds *mat);
void InitBitmap3ds(bitmap3ds *map);
short3ds InitMaterial3ds(material3ds **mat);
void ReleaseMaterial3ds(material3ds **mat);
ulong3ds GetMaterialCount3ds(database3ds *db);
void GetMaterialNameList3ds(database3ds *db, namelist3ds **list);
void GetMaterialByIndex3ds(database3ds *db, ulong3ds index, material3ds **mat);
void GetMaterialByName3ds(database3ds *db, char3ds *name, material3ds **mat);
void PutMaterial3ds(database3ds *db, material3ds *mat);
void CopyMaterialByName3ds(database3ds *destdb, database3ds *srcdb, char3ds *name);
void CopyMaterialByIndex3ds(database3ds *destdb, database3ds *srcdb, ulong3ds index);
void DeleteMaterialByName3ds(database3ds *db, char3ds *name);
void DeleteMaterialByIndex3ds(database3ds *db, ulong3ds index);
void InitMeshObj3ds(mesh3ds **obj, ushort3ds nvertices, ushort3ds nfaces, ushort3ds iniflags);
void InitMeshObjField3ds(mesh3ds *obj, ushort3ds const initflags);
void InitMatArrayIndex3ds (mesh3ds *obj, ushort3ds mat, ushort3ds nfaces);

/* Mesh object functions */
ulong3ds GetMeshCount3ds(database3ds *db);
void GetMeshNameList3ds(database3ds *db, namelist3ds **list);
void GetMeshByIndex3ds(database3ds *db, ulong3ds index, mesh3ds **mesh);
void GetMeshByName3ds(database3ds *db, char3ds *name, mesh3ds **mesh);
void PutMesh3ds(database3ds *db, mesh3ds *mesh);
void CopyMeshByName3ds(database3ds *destdb, database3ds *srcdb, char3ds *name);
void CopyMeshByIndex3ds(database3ds *destdb, database3ds *srcdb, ulong3ds index);
void DeleteMeshByName3ds(database3ds *db, char3ds *name);
void DeleteMeshByIndex3ds(database3ds *db, ulong3ds index);
void RelMeshObj3ds(mesh3ds **obj);

/* Light related functions */
void InitLight3ds(light3ds **light);
void InitSpotlight3ds(light3ds **spotlight);
void ReleaseLight3ds(light3ds **light);
ulong3ds GetOmnilightCount3ds(database3ds *db);
ulong3ds GetSpotlightCount3ds(database3ds *db);
void GetOmnilightNameList3ds(database3ds *db, namelist3ds **list);
void GetSpotlightNameList3ds(database3ds *db, namelist3ds **list);
void GetSpotlightByIndex3ds(database3ds *db, long3ds index, light3ds **light);
void GetOmnilightByIndex3ds(database3ds *db, long3ds index, light3ds **light);
void GetSpotlightByName3ds(database3ds *db, char3ds *name, light3ds **light);
void GetOmnilightByName3ds(database3ds *db, char3ds *name, light3ds **light);
void PutSpotlight3ds(database3ds *db, light3ds *light);
void PutOmnilight3ds(database3ds *db, light3ds *light);
void CopySpotlightByName3ds(database3ds *destdb, database3ds *srcdb, char3ds *name);
void CopySpotlightByIndex3ds(database3ds *destdb, database3ds *srcdb, ulong3ds index);
void CopyOmnilightByName3ds(database3ds *destdb, database3ds *srcdb, char3ds *name);
void CopyOmnilightByIndex3ds(database3ds *destdb, database3ds *srcdb, ulong3ds index);
void DeleteSpotlightByIndex3ds(database3ds *db, ulong3ds index);
void DeleteOmnilightByIndex3ds(database3ds *db, ulong3ds index);
void DeleteSpotlightByName3ds(database3ds *db, char3ds *name);
void DeleteOmnilightByName3ds(database3ds *db, char3ds *name);
void InitCamera3ds(camera3ds **cam);
void ReleaseCamera3ds(camera3ds **cam);
ulong3ds GetCameraCount3ds(database3ds *db);
void GetCameraNameList3ds(database3ds *db, namelist3ds **list);
void GetCameraByIndex3ds(database3ds *db, ulong3ds index, camera3ds **cam);
void GetCameraByName3ds(database3ds *db, char3ds *name, camera3ds **cam);
void PutCamera3ds(database3ds *db, camera3ds *cam);

void CopyCameraByName3ds(database3ds *destdb, database3ds *srcdb, char3ds *name);
void CopyCameraByIndex3ds(database3ds *destdb, database3ds *srcdb, ulong3ds index);

void DeleteCameraByName3ds(database3ds *db, char3ds *name);
void DeleteCameraByIndex3ds(database3ds *db, ulong3ds index);

void InitKfSets3ds(kfsets3ds **key);
void ReleaseKfSets3ds(kfsets3ds **key);
void PutKfSets3ds(database3ds *db, kfsets3ds *key);
void GetKfSets3ds(database3ds *db, kfsets3ds **key);
void CopyKfSets3ds(database3ds *destdb, database3ds *srcdb);


void InitCameraMotion3ds(kfcamera3ds **cam, ulong3ds npkeys, ulong3ds nfkeys,
                             ulong3ds nrkeys, ulong3ds ntkeys);

void GetCameraMotionByName3ds(database3ds *db, 
			      const char3ds *name, 
			      kfcamera3ds **kfcam);

void GetCameraMotionByIndex3ds(database3ds *db, 
			       ulong3ds index,
			       kfcamera3ds **kfcam);

void PutCameraMotion3ds(database3ds *db, kfcamera3ds *kfcam);


void ReleaseCameraMotion3ds(kfcamera3ds **cam);

ulong3ds GetCameraNodeCount3ds(database3ds *db);

void GetCameraNodeNameList3ds(database3ds *db, namelist3ds **list);

void DeleteCameraMotionByIndex3ds(database3ds *db, ulong3ds index);
void DeleteCameraMotionByName3ds(database3ds *db, char3ds *name);
void CopyCameraMotionByIndex3ds(database3ds *destdb, database3ds *srcdb, ulong3ds index);
void CopyCameraMotionByName3ds(database3ds *destdb, database3ds *srcdb, char3ds *name);


/* Ambient Light Animation Functions */
void InitAmbientLightMotion3ds(kfambient3ds **light, ulong3ds nckeys);
void ReleaseAmbientLightMotion3ds(kfambient3ds **light);
void GetAmbientLightMotion3ds(database3ds *db, kfambient3ds **kfambient);
void PutAmbientLightMotion3ds(database3ds *db, kfambient3ds *kfambient);
void DeleteAmbientLightMotion3ds(database3ds *db);
void CopyAmbientLightMotion3ds(database3ds *destdb, database3ds *srcdb);
void InitObjectMotion3ds(kfmesh3ds **obj, 
			 ulong3ds npkeys, 
			 ulong3ds nrkeys, 
			 ulong3ds nskeys, 
			 ulong3ds nmkeys,
			 ulong3ds nhkeys);

void ReleaseObjectMotion3ds(kfmesh3ds **obj);

void GetObjectNodeNameList3ds(database3ds *db, 
			      namelist3ds **list);

ulong3ds GetObjectNodeCount3ds(database3ds *db);

void GetObjectMotionByName3ds(database3ds *db, 
			      char3ds *name, 
			      kfmesh3ds **kfmesh);

void GetObjectMotionByIndex3ds(database3ds *db, 
			       ulong3ds index,
			       kfmesh3ds **kfmesh);

void PutObjectMotion3ds(database3ds *db,
			kfmesh3ds *kfmesh);

void DeleteObjectMotionByIndex3ds(database3ds *db, ulong3ds index);
void DeleteObjectMotionByName3ds(database3ds *db, char3ds *name);
void CopyObjectMotionByIndex3ds(database3ds *destdb, database3ds *srcdb, ulong3ds index);
void CopyObjectMotionByName3ds(database3ds *destdb, database3ds *srcdb, char3ds *name);
void InitOmnilightMotion3ds(kfomni3ds **light, 
			    ulong3ds npkeys, 
			    ulong3ds nckeys);

void ReleaseOmnilightMotion3ds(kfomni3ds **light);

void GetOmnilightNodeNameList3ds(database3ds *db, 
				 namelist3ds **list);

void GetOmnilightMotionByName3ds(database3ds *db, 
				 char3ds *name, 
				 kfomni3ds **kfomni);

void GetOmnilightMotionByIndex3ds(database3ds *db, 
				  ulong3ds index,
				  kfomni3ds **kfomni);

ulong3ds GetOmnilightNodeCount3ds(database3ds *db);

void PutOmnilightMotion3ds(database3ds *db, 
			   kfomni3ds *kfomni);

void PutOmnilightMotion3ds(database3ds *db, 
			   kfomni3ds *kfomni);

void DeleteOmnilightMotionByIndex3ds(database3ds *db, ulong3ds index);
void DeleteOmnilightMotionByName3ds(database3ds *db, char3ds *name);
void CopyOmnilightMotionByIndex3ds(database3ds *destdb, database3ds *srcdb, ulong3ds index);
void CopyOmnilightMotionByName3ds(database3ds *destdb, database3ds *srcdb, char3ds *name);
void InitSpotlightMotion3ds(kfspot3ds **spot, 
                ulong3ds npkeys, 
                ulong3ds nckeys, 
                ulong3ds nhkeys, 
                ulong3ds nfkeys, 
                ulong3ds nrkeys, 
                ulong3ds ntkeys);

void ReleaseSpotlightMotion3ds(kfspot3ds **spot);

void GetSpotlightNodeNameList3ds(database3ds *db, 
				 namelist3ds **list);

ulong3ds GetSpotlightNodeCount3ds(database3ds *db);

void GetSpotlightMotionByName3ds(database3ds *db, 
                 char3ds *name, 
                 kfspot3ds **kfspot);

void PutSpotlightMotion3ds(database3ds *db, 
			   kfspot3ds *kfspot);

void GetSpotlightMotionByIndex3ds(database3ds *db, 
		  ulong3ds index,
		  kfspot3ds **kfspot);

void DeleteSpotlightMotionByIndex3ds(database3ds *db, ulong3ds index);
void DeleteSpotlightMotionByName3ds(database3ds *db, char3ds *name);
void CopySpotlightMotionByIndex3ds(database3ds *destdb, database3ds *srcdb, ulong3ds index);
void CopySpotlightMotionByName3ds(database3ds *destdb, database3ds *srcdb, char3ds *name);

void FillMatrix3ds(mesh3ds *obj);
void SetBoundBox3ds(const mesh3ds *mobj, kfmesh3ds *kobj );
void DumpMapInfo3ds(FILE *out, mapinfo3ds *map, long3ds dumplevel);
void DumpMesh3ds(FILE *out, mesh3ds *mesh, long3ds dumplevel);
void DumpMaterial3ds(FILE *out, material3ds *mat, long3ds dumplevel);
void DumpBitmap3ds(FILE *out, bitmap3ds *map, long3ds dumplevel);
void SetDumpLevel3ds(long3ds newlevel);
void DumpDatabase3ds(FILE *outfile, database3ds *db);
void GetMeshXDataByName3ds(database3ds *db, char3ds *meshname, char3ds *appname, xdataraw3ds **data);
ulong3ds GetMeshXDataCount3ds(database3ds *db, char3ds *meshname);
#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\flex\dfa.c ===
/* dfa - DFA construction routines */

/*-
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Vern Paxson.
 * 
 * The United States Government has rights in this work pursuant
 * to contract no. DE-AC03-76SF00098 between the United States
 * Department of Energy and the University of California.
 *
 * Redistribution and use in source and binary forms with or without
 * modification are permitted provided that: (1) source distributions retain
 * this entire copyright notice and comment, and (2) distributions including
 * binaries display the following acknowledgement:  ``This product includes
 * software developed by the University of California, Berkeley and its
 * contributors'' in the documentation or other materials provided with the
 * distribution and in all advertising materials mentioning features or use
 * of this software.  Neither the name of the University nor the names of
 * its contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

/* $Header: \\VIA-SOURCE\RELEASE21\dev\RCS\Tools\flex-2.5.4a\dfa.c,v 1.1 1999/12/08 23:40:20 wayneg Exp $ */

#include "flexdef.h"


/* declare functions that have forward references */

void dump_associated_rules PROTO((FILE*, int));
void dump_transitions PROTO((FILE*, int[]));
void sympartition PROTO((int[], int, int[], int[]));
int symfollowset PROTO((int[], int, int, int[]));


/* check_for_backing_up - check a DFA state for backing up
 *
 * synopsis
 *     void check_for_backing_up( int ds, int state[numecs] );
 *
 * ds is the number of the state to check and state[] is its out-transitions,
 * indexed by equivalence class.
 */

void check_for_backing_up( ds, state )
int ds;
int state[];
	{
	if ( (reject && ! dfaacc[ds].dfaacc_set) ||
	     (! reject && ! dfaacc[ds].dfaacc_state) )
		{ /* state is non-accepting */
		++num_backing_up;

		if ( backing_up_report )
			{
			fprintf( backing_up_file,
				_( "State #%d is non-accepting -\n" ), ds );

			/* identify the state */
			dump_associated_rules( backing_up_file, ds );

			/* Now identify it further using the out- and
			 * jam-transitions.
			 */
			dump_transitions( backing_up_file, state );

			putc( '\n', backing_up_file );
			}
		}
	}


/* check_trailing_context - check to see if NFA state set constitutes
 *                          "dangerous" trailing context
 *
 * synopsis
 *    void check_trailing_context( int nfa_states[num_states+1], int num_states,
 *				int accset[nacc+1], int nacc );
 *
 * NOTES
 *  Trailing context is "dangerous" if both the head and the trailing
 *  part are of variable size \and/ there's a DFA state which contains
 *  both an accepting state for the head part of the rule and NFA states
 *  which occur after the beginning of the trailing context.
 *
 *  When such a rule is matched, it's impossible to tell if having been
 *  in the DFA state indicates the beginning of the trailing context or
 *  further-along scanning of the pattern.  In these cases, a warning
 *  message is issued.
 *
 *    nfa_states[1 .. num_states] is the list of NFA states in the DFA.
 *    accset[1 .. nacc] is the list of accepting numbers for the DFA state.
 */

void check_trailing_context( nfa_states, num_states, accset, nacc )
int *nfa_states, num_states;
int *accset;
int nacc;
	{
	register int i, j;

	for ( i = 1; i <= num_states; ++i )
		{
		int ns = nfa_states[i];
		register int type = state_type[ns];
		register int ar = assoc_rule[ns];

		if ( type == STATE_NORMAL || rule_type[ar] != RULE_VARIABLE )
			{ /* do nothing */
			}

		else if ( type == STATE_TRAILING_CONTEXT )
			{
			/* Potential trouble.  Scan set of accepting numbers
			 * for the one marking the end of the "head".  We
			 * assume that this looping will be fairly cheap
			 * since it's rare that an accepting number set
			 * is large.
			 */
			for ( j = 1; j <= nacc; ++j )
				if ( accset[j] & YY_TRAILING_HEAD_MASK )
					{
					line_warning(
					_( "dangerous trailing context" ),
						rule_linenum[ar] );
					return;
					}
			}
		}
	}


/* dump_associated_rules - list the rules associated with a DFA state
 *
 * Goes through the set of NFA states associated with the DFA and
 * extracts the first MAX_ASSOC_RULES unique rules, sorts them,
 * and writes a report to the given file.
 */

void dump_associated_rules( file, ds )
FILE *file;
int ds;
	{
	register int i, j;
	register int num_associated_rules = 0;
	int rule_set[MAX_ASSOC_RULES + 1];
	int *dset = dss[ds];
	int size = dfasiz[ds];

	for ( i = 1; i <= size; ++i )
		{
		register int rule_num = rule_linenum[assoc_rule[dset[i]]];

		for ( j = 1; j <= num_associated_rules; ++j )
			if ( rule_num == rule_set[j] )
				break;

		if ( j > num_associated_rules )
			{ /* new rule */
			if ( num_associated_rules < MAX_ASSOC_RULES )
				rule_set[++num_associated_rules] = rule_num;
			}
		}

	bubble( rule_set, num_associated_rules );

	fprintf( file, _( " associated rule line numbers:" ) );

	for ( i = 1; i <= num_associated_rules; ++i )
		{
		if ( i % 8 == 1 )
			putc( '\n', file );

		fprintf( file, "\t%d", rule_set[i] );
		}

	putc( '\n', file );
	}


/* dump_transitions - list the transitions associated with a DFA state
 *
 * synopsis
 *     dump_transitions( FILE *file, int state[numecs] );
 *
 * Goes through the set of out-transitions and lists them in human-readable
 * form (i.e., not as equivalence classes); also lists jam transitions
 * (i.e., all those which are not out-transitions, plus EOF).  The dump
 * is done to the given file.
 */

void dump_transitions( file, state )
FILE *file;
int state[];
	{
	register int i, ec;
	int out_char_set[CSIZE];

	for ( i = 0; i < csize; ++i )
		{
		ec = ABS( ecgroup[i] );
		out_char_set[i] = state[ec];
		}

	fprintf( file, _( " out-transitions: " ) );

	list_character_set( file, out_char_set );

	/* now invert the members of the set to get the jam transitions */
	for ( i = 0; i < csize; ++i )
		out_char_set[i] = ! out_char_set[i];

	fprintf( file, _( "\n jam-transitions: EOF " ) );

	list_character_set( file, out_char_set );

	putc( '\n', file );
	}


/* epsclosure - construct the epsilon closure of a set of ndfa states
 *
 * synopsis
 *    int *epsclosure( int t[num_states], int *numstates_addr,
 *			int accset[num_rules+1], int *nacc_addr,
 *			int *hashval_addr );
 *
 * NOTES
 *  The epsilon closure is the set of all states reachable by an arbitrary
 *  number of epsilon transitions, which themselves do not have epsilon
 *  transitions going out, unioned with the set of states which have non-null
 *  accepting numbers.  t is an array of size numstates of nfa state numbers.
 *  Upon return, t holds the epsilon closure and *numstates_addr is updated.
 *  accset holds a list of the accepting numbers, and the size of accset is
 *  given by *nacc_addr.  t may be subjected to reallocation if it is not
 *  large enough to hold the epsilon closure.
 *
 *  hashval is the hash value for the dfa corresponding to the state set.
 */

int *epsclosure( t, ns_addr, accset, nacc_addr, hv_addr )
int *t, *ns_addr, accset[], *nacc_addr, *hv_addr;
	{
	register int stkpos, ns, tsp;
	int numstates = *ns_addr, nacc, hashval, transsym, nfaccnum;
	int stkend, nstate;
	static int did_stk_init = false, *stk; 

#define MARK_STATE(state) \
trans1[state] = trans1[state] - MARKER_DIFFERENCE;

#define IS_MARKED(state) (trans1[state] < 0)

#define UNMARK_STATE(state) \
trans1[state] = trans1[state] + MARKER_DIFFERENCE;

#define CHECK_ACCEPT(state) \
{ \
nfaccnum = accptnum[state]; \
if ( nfaccnum != NIL ) \
accset[++nacc] = nfaccnum; \
}

#define DO_REALLOCATION \
{ \
current_max_dfa_size += MAX_DFA_SIZE_INCREMENT; \
++num_reallocs; \
t = reallocate_integer_array( t, current_max_dfa_size ); \
stk = reallocate_integer_array( stk, current_max_dfa_size ); \
} \

#define PUT_ON_STACK(state) \
{ \
if ( ++stkend >= current_max_dfa_size ) \
DO_REALLOCATION \
stk[stkend] = state; \
MARK_STATE(state) \
}

#define ADD_STATE(state) \
{ \
if ( ++numstates >= current_max_dfa_size ) \
DO_REALLOCATION \
t[numstates] = state; \
hashval += state; \
}

#define STACK_STATE(state) \
{ \
PUT_ON_STACK(state) \
CHECK_ACCEPT(state) \
if ( nfaccnum != NIL || transchar[state] != SYM_EPSILON ) \
ADD_STATE(state) \
}


	if ( ! did_stk_init )
		{
		stk = allocate_integer_array( current_max_dfa_size );
		did_stk_init = true;
		}

	nacc = stkend = hashval = 0;

	for ( nstate = 1; nstate <= numstates; ++nstate )
		{
		ns = t[nstate];

		/* The state could be marked if we've already pushed it onto
		 * the stack.
		 */
		if ( ! IS_MARKED(ns) )
			{
			PUT_ON_STACK(ns)
			CHECK_ACCEPT(ns)
			hashval += ns;
			}
		}

	for ( stkpos = 1; stkpos <= stkend; ++stkpos )
		{
		ns = stk[stkpos];
		transsym = transchar[ns];

		if ( transsym == SYM_EPSILON )
			{
			tsp = trans1[ns] + MARKER_DIFFERENCE;

			if ( tsp != NO_TRANSITION )
				{
				if ( ! IS_MARKED(tsp) )
					STACK_STATE(tsp)

				tsp = trans2[ns];

				if ( tsp != NO_TRANSITION && ! IS_MARKED(tsp) )
					STACK_STATE(tsp)
				}
			}
		}

	/* Clear out "visit" markers. */

	for ( stkpos = 1; stkpos <= stkend; ++stkpos )
		{
		if ( IS_MARKED(stk[stkpos]) )
			UNMARK_STATE(stk[stkpos])
		else
			flexfatal(
			_( "consistency check failed in epsclosure()" ) );
		}

	*ns_addr = numstates;
	*hv_addr = hashval;
	*nacc_addr = nacc;

	return t;
	}


/* increase_max_dfas - increase the maximum number of DFAs */

void increase_max_dfas()
	{
	current_max_dfas += MAX_DFAS_INCREMENT;

	++num_reallocs;

	base = reallocate_integer_array( base, current_max_dfas );
	def = reallocate_integer_array( def, current_max_dfas );
	dfasiz = reallocate_integer_array( dfasiz, current_max_dfas );
	accsiz = reallocate_integer_array( accsiz, current_max_dfas );
	dhash = reallocate_integer_array( dhash, current_max_dfas );
	dss = reallocate_int_ptr_array( dss, current_max_dfas );
	dfaacc = reallocate_dfaacc_union( dfaacc, current_max_dfas );

	if ( nultrans )
		nultrans =
			reallocate_integer_array( nultrans, current_max_dfas );
	}


/* ntod - convert an ndfa to a dfa
 *
 * Creates the dfa corresponding to the ndfa we've constructed.  The
 * dfa starts out in state #1.
 */

void ntod()
	{
	int *accset, ds, nacc, newds;
	int sym, hashval, numstates, dsize;
	int num_full_table_rows;	/* used only for -f */
	int *nset, *dset;
	int targptr, totaltrans, i, comstate, comfreq, targ;
	int symlist[CSIZE + 1];
	int num_start_states;
	int todo_head, todo_next;

	/* Note that the following are indexed by *equivalence classes*
	 * and not by characters.  Since equivalence classes are indexed
	 * beginning with 1, even if the scanner accepts NUL's, this
	 * means that (since every character is potentially in its own
	 * equivalence class) these arrays must have room for indices
	 * from 1 to CSIZE, so their size must be CSIZE + 1.
	 */
	int duplist[CSIZE + 1], state[CSIZE + 1];
	int targfreq[CSIZE + 1], targstate[CSIZE + 1];

	accset = allocate_integer_array( num_rules + 1 );
	nset = allocate_integer_array( current_max_dfa_size );

	/* The "todo" queue is represented by the head, which is the DFA
	 * state currently being processed, and the "next", which is the
	 * next DFA state number available (not in use).  We depend on the
	 * fact that snstods() returns DFA's \in increasing order/, and thus
	 * need only know the bounds of the dfas to be processed.
	 */
	todo_head = todo_next = 0;

	for ( i = 0; i <= csize; ++i )
		{
		duplist[i] = NIL;
		symlist[i] = false;
		}

	for ( i = 0; i <= num_rules; ++i )
		accset[i] = NIL;

	if ( trace )
		{
		dumpnfa( scset[1] );
		fputs( _( "\n\nDFA Dump:\n\n" ), stderr );
		}

	inittbl();

	/* Check to see whether we should build a separate table for
	 * transitions on NUL characters.  We don't do this for full-speed
	 * (-F) scanners, since for them we don't have a simple state
	 * number lying around with which to index the table.  We also
	 * don't bother doing it for scanners unless (1) NUL is in its own
	 * equivalence class (indicated by a positive value of
	 * ecgroup[NUL]), (2) NUL's equivalence class is the last
	 * equivalence class, and (3) the number of equivalence classes is
	 * the same as the number of characters.  This latter case comes
	 * about when useecs is false or when it's true but every character
	 * still manages to land in its own class (unlikely, but it's
	 * cheap to check for).  If all these things are true then the
	 * character code needed to represent NUL's equivalence class for
	 * indexing the tables is going to take one more bit than the
	 * number of characters, and therefore we won't be assured of
	 * being able to fit it into a YY_CHAR variable.  This rules out
	 * storing the transitions in a compressed table, since the code
	 * for interpreting them uses a YY_CHAR variable (perhaps it
	 * should just use an integer, though; this is worth pondering ...
	 * ###).
	 *
	 * Finally, for full tables, we want the number of entries in the
	 * table to be a power of two so the array references go fast (it
	 * will just take a shift to compute the major index).  If
	 * encoding NUL's transitions in the table will spoil this, we
	 * give it its own table (note that this will be the case if we're
	 * not using equivalence classes).
	 */

	/* Note that the test for ecgroup[0] == numecs below accomplishes
	 * both (1) and (2) above
	 */
	if ( ! fullspd && ecgroup[0] == numecs )
		{
		/* NUL is alone in its equivalence class, which is the
		 * last one.
		 */
		int use_NUL_table = (numecs == csize);

		if ( fulltbl && ! use_NUL_table )
			{
			/* We still may want to use the table if numecs
			 * is a power of 2.
			 */
			int power_of_two;

			for ( power_of_two = 1; power_of_two <= csize;
			      power_of_two *= 2 )
				if ( numecs == power_of_two )
					{
					use_NUL_table = true;
					break;
					}
			}

		if ( use_NUL_table )
			nultrans = allocate_integer_array( current_max_dfas );

		/* From now on, nultrans != nil indicates that we're
		 * saving null transitions for later, separate encoding.
		 */
		}


	if ( fullspd )
		{
		for ( i = 0; i <= numecs; ++i )
			state[i] = 0;

		place_state( state, 0, 0 );
		dfaacc[0].dfaacc_state = 0;
		}

	else if ( fulltbl )
		{
		if ( nultrans )
			/* We won't be including NUL's transitions in the
			 * table, so build it for entries from 0 .. numecs - 1.
			 */
			num_full_table_rows = numecs;

		else
			/* Take into account the fact that we'll be including
			 * the NUL entries in the transition table.  Build it
			 * from 0 .. numecs.
			 */
			num_full_table_rows = numecs + 1;

		/* Unless -Ca, declare it "short" because it's a real
		 * long-shot that that won't be large enough.
		 */
		out_str_dec( "static yyconst %s yy_nxt[][%d] =\n    {\n",
			/* '}' so vi doesn't get too confused */
			long_align ? "long" : "short", num_full_table_rows );

		outn( "    {" );

		/* Generate 0 entries for state #0. */
		for ( i = 0; i < num_full_table_rows; ++i )
			mk2data( 0 );

		dataflush();
		outn( "    },\n" );
		}

	/* Create the first states. */

	num_start_states = lastsc * 2;

	for ( i = 1; i <= num_start_states; ++i )
		{
		numstates = 1;

		/* For each start condition, make one state for the case when
		 * we're at the beginning of the line (the '^' operator) and
		 * one for the case when we're not.
		 */
		if ( i % 2 == 1 )
			nset[numstates] = scset[(i / 2) + 1];
		else
			nset[numstates] =
				mkbranch( scbol[i / 2], scset[i / 2] );

		nset = epsclosure( nset, &numstates, accset, &nacc, &hashval );

		if ( snstods( nset, numstates, accset, nacc, hashval, &ds ) )
			{
			numas += nacc;
			totnst += numstates;
			++todo_next;

			if ( variable_trailing_context_rules && nacc > 0 )
				check_trailing_context( nset, numstates,
							accset, nacc );
			}
		}

	if ( ! fullspd )
		{
		if ( ! snstods( nset, 0, accset, 0, 0, &end_of_buffer_state ) )
			flexfatal(
			_( "could not create unique end-of-buffer state" ) );

		++numas;
		++num_start_states;
		++todo_next;
		}

	while ( todo_head < todo_next )
		{
		targptr = 0;
		totaltrans = 0;

		for ( i = 1; i <= numecs; ++i )
			state[i] = 0;

		ds = ++todo_head;

		dset = dss[ds];
		dsize = dfasiz[ds];

		if ( trace )
			fprintf( stderr, _( "state # %d:\n" ), ds );

		sympartition( dset, dsize, symlist, duplist );

		for ( sym = 1; sym <= numecs; ++sym )
			{
			if ( symlist[sym] )
				{
				symlist[sym] = 0;

				if ( duplist[sym] == NIL )
					{
					/* Symbol has unique out-transitions. */
					numstates = symfollowset( dset, dsize,
								sym, nset );
					nset = epsclosure( nset, &numstates,
						accset, &nacc, &hashval );

					if ( snstods( nset, numstates, accset,
						nacc, hashval, &newds ) )
						{
						totnst = totnst + numstates;
						++todo_next;
						numas += nacc;

						if (
					variable_trailing_context_rules &&
							nacc > 0 )
							check_trailing_context(
								nset, numstates,
								accset, nacc );
						}

					state[sym] = newds;

					if ( trace )
						fprintf( stderr, "\t%d\t%d\n",
							sym, newds );

					targfreq[++targptr] = 1;
					targstate[targptr] = newds;
					++numuniq;
					}

				else
					{
					/* sym's equivalence class has the same
					 * transitions as duplist(sym)'s
					 * equivalence class.
					 */
					targ = state[duplist[sym]];
					state[sym] = targ;

					if ( trace )
						fprintf( stderr, "\t%d\t%d\n",
							sym, targ );

					/* Update frequency count for
					 * destination state.
					 */

					i = 0;
					while ( targstate[++i] != targ )
						;

					++targfreq[i];
					++numdup;
					}

				++totaltrans;
				duplist[sym] = NIL;
				}
			}

		if ( caseins && ! useecs )
			{
			register int j;

			for ( i = 'A', j = 'a'; i <= 'Z'; ++i, ++j )
				{
				if ( state[i] == 0 && state[j] != 0 )
					/* We're adding a transition. */
					++totaltrans;

				else if ( state[i] != 0 && state[j] == 0 )
					/* We're taking away a transition. */
					--totaltrans;

				state[i] = state[j];
				}
			}

		numsnpairs += totaltrans;

		if ( ds > num_start_states )
			check_for_backing_up( ds, state );

		if ( nultrans )
			{
			nultrans[ds] = state[NUL_ec];
			state[NUL_ec] = 0;	/* remove transition */
			}

		if ( fulltbl )
			{
			outn( "    {" );

			/* Supply array's 0-element. */
			if ( ds == end_of_buffer_state )
				mk2data( -end_of_buffer_state );
			else
				mk2data( end_of_buffer_state );

			for ( i = 1; i < num_full_table_rows; ++i )
				/* Jams are marked by negative of state
				 * number.
				 */
				mk2data( state[i] ? state[i] : -ds );

			dataflush();
			outn( "    },\n" );
			}

		else if ( fullspd )
			place_state( state, ds, totaltrans );

		else if ( ds == end_of_buffer_state )
			/* Special case this state to make sure it does what
			 * it's supposed to, i.e., jam on end-of-buffer.
			 */
			stack1( ds, 0, 0, JAMSTATE );

		else /* normal, compressed state */
			{
			/* Determine which destination state is the most
			 * common, and how many transitions to it there are.
			 */

			comfreq = 0;
			comstate = 0;

			for ( i = 1; i <= targptr; ++i )
				if ( targfreq[i] > comfreq )
					{
					comfreq = targfreq[i];
					comstate = targstate[i];
					}

			bldtbl( state, ds, totaltrans, comstate, comfreq );
			}
		}

	if ( fulltbl )
		dataend();

	else if ( ! fullspd )
		{
		cmptmps();  /* create compressed template entries */

		/* Create tables for all the states with only one
		 * out-transition.
		 */
		while ( onesp > 0 )
			{
			mk1tbl( onestate[onesp], onesym[onesp], onenext[onesp],
			onedef[onesp] );
			--onesp;
			}

		mkdeftbl();
		}

	flex_free( (void *) accset );
	flex_free( (void *) nset );
	}


/* snstods - converts a set of ndfa states into a dfa state
 *
 * synopsis
 *    is_new_state = snstods( int sns[numstates], int numstates,
 *				int accset[num_rules+1], int nacc,
 *				int hashval, int *newds_addr );
 *
 * On return, the dfa state number is in newds.
 */

int snstods( sns, numstates, accset, nacc, hashval, newds_addr )
int sns[], numstates, accset[], nacc, hashval, *newds_addr;
	{
	int didsort = 0;
	register int i, j;
	int newds, *oldsns;

	for ( i = 1; i <= lastdfa; ++i )
		if ( hashval == dhash[i] )
			{
			if ( numstates == dfasiz[i] )
				{
				oldsns = dss[i];

				if ( ! didsort )
					{
					/* We sort the states in sns so we
					 * can compare it to oldsns quickly.
					 * We use bubble because there probably
					 * aren't very many states.
					 */
					bubble( sns, numstates );
					didsort = 1;
					}

				for ( j = 1; j <= numstates; ++j )
					if ( sns[j] != oldsns[j] )
						break;

				if ( j > numstates )
					{
					++dfaeql;
					*newds_addr = i;
					return 0;
					}

				++hshcol;
				}

			else
				++hshsave;
			}

	/* Make a new dfa. */

	if ( ++lastdfa >= current_max_dfas )
		increase_max_dfas();

	newds = lastdfa;

	dss[newds] = allocate_integer_array( numstates + 1 );

	/* If we haven't already sorted the states in sns, we do so now,
	 * so that future comparisons with it can be made quickly.
	 */

	if ( ! didsort )
		bubble( sns, numstates );

	for ( i = 1; i <= numstates; ++i )
		dss[newds][i] = sns[i];

	dfasiz[newds] = numstates;
	dhash[newds] = hashval;

	if ( nacc == 0 )
		{
		if ( reject )
			dfaacc[newds].dfaacc_set = (int *) 0;
		else
			dfaacc[newds].dfaacc_state = 0;

		accsiz[newds] = 0;
		}

	else if ( reject )
		{
		/* We sort the accepting set in increasing order so the
		 * disambiguating rule that the first rule listed is considered
		 * match in the event of ties will work.  We use a bubble
		 * sort since the list is probably quite small.
		 */

		bubble( accset, nacc );

		dfaacc[newds].dfaacc_set = allocate_integer_array( nacc + 1 );

		/* Save the accepting set for later */
		for ( i = 1; i <= nacc; ++i )
			{
			dfaacc[newds].dfaacc_set[i] = accset[i];

			if ( accset[i] <= num_rules )
				/* Who knows, perhaps a REJECT can yield
				 * this rule.
				 */
				rule_useful[accset[i]] = true;
			}

		accsiz[newds] = nacc;
		}

	else
		{
		/* Find lowest numbered rule so the disambiguating rule
		 * will work.
		 */
		j = num_rules + 1;

		for ( i = 1; i <= nacc; ++i )
			if ( accset[i] < j )
				j = accset[i];

		dfaacc[newds].dfaacc_state = j;

		if ( j <= num_rules )
			rule_useful[j] = true;
		}

	*newds_addr = newds;

	return 1;
	}


/* symfollowset - follow the symbol transitions one step
 *
 * synopsis
 *    numstates = symfollowset( int ds[current_max_dfa_size], int dsize,
 *				int transsym, int nset[current_max_dfa_size] );
 */

int symfollowset( ds, dsize, transsym, nset )
int ds[], dsize, transsym, nset[];
	{
	int ns, tsp, sym, i, j, lenccl, ch, numstates, ccllist;

	numstates = 0;

	for ( i = 1; i <= dsize; ++i )
		{ /* for each nfa state ns in the state set of ds */
		ns = ds[i];
		sym = transchar[ns];
		tsp = trans1[ns];

		if ( sym < 0 )
			{ /* it's a character class */
			sym = -sym;
			ccllist = cclmap[sym];
			lenccl = ccllen[sym];

			if ( cclng[sym] )
				{
				for ( j = 0; j < lenccl; ++j )
					{
					/* Loop through negated character
					 * class.
					 */
					ch = ccltbl[ccllist + j];

					if ( ch == 0 )
						ch = NUL_ec;

					if ( ch > transsym )
						/* Transsym isn't in negated
						 * ccl.
						 */
						break;

					else if ( ch == transsym )
						/* next 2 */ goto bottom;
					}

				/* Didn't find transsym in ccl. */
				nset[++numstates] = tsp;
				}

			else
				for ( j = 0; j < lenccl; ++j )
					{
					ch = ccltbl[ccllist + j];

					if ( ch == 0 )
						ch = NUL_ec;

					if ( ch > transsym )
						break;
					else if ( ch == transsym )
						{
						nset[++numstates] = tsp;
						break;
						}
					}
			}

		else if ( sym >= 'A' && sym <= 'Z' && caseins )
			flexfatal(
			_( "consistency check failed in symfollowset" ) );

		else if ( sym == SYM_EPSILON )
			{ /* do nothing */
			}

		else if ( ABS( ecgroup[sym] ) == transsym )
			nset[++numstates] = tsp;

		bottom: ;
		}

	return numstates;
	}


/* sympartition - partition characters with same out-transitions
 *
 * synopsis
 *    sympartition( int ds[current_max_dfa_size], int numstates,
 *			int symlist[numecs], int duplist[numecs] );
 */

void sympartition( ds, numstates, symlist, duplist )
int ds[], numstates;
int symlist[], duplist[];
	{
	int tch, i, j, k, ns, dupfwd[CSIZE + 1], lenccl, cclp, ich;

	/* Partitioning is done by creating equivalence classes for those
	 * characters which have out-transitions from the given state.  Thus
	 * we are really creating equivalence classes of equivalence classes.
	 */

	for ( i = 1; i <= numecs; ++i )
		{ /* initialize equivalence class list */
		duplist[i] = i - 1;
		dupfwd[i] = i + 1;
		}

	duplist[1] = NIL;
	dupfwd[numecs] = NIL;

	for ( i = 1; i <= numstates; ++i )
		{
		ns = ds[i];
		tch = transchar[ns];

		if ( tch != SYM_EPSILON )
			{
			if ( tch < -lastccl || tch >= csize )
				{
				flexfatal(
		_( "bad transition character detected in sympartition()" ) );
				}

			if ( tch >= 0 )
				{ /* character transition */
				int ec = ecgroup[tch];

				mkechar( ec, dupfwd, duplist );
				symlist[ec] = 1;
				}

			else
				{ /* character class */
				tch = -tch;

				lenccl = ccllen[tch];
				cclp = cclmap[tch];
				mkeccl( ccltbl + cclp, lenccl, dupfwd,
					duplist, numecs, NUL_ec );

				if ( cclng[tch] )
					{
					j = 0;

					for ( k = 0; k < lenccl; ++k )
						{
						ich = ccltbl[cclp + k];

						if ( ich == 0 )
							ich = NUL_ec;

						for ( ++j; j < ich; ++j )
							symlist[j] = 1;
						}

					for ( ++j; j <= numecs; ++j )
						symlist[j] = 1;
					}

				else
					for ( k = 0; k < lenccl; ++k )
						{
						ich = ccltbl[cclp + k];

						if ( ich == 0 )
							ich = NUL_ec;

						symlist[ich] = 1;
						}
				}
			}
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\flex\ecs.c ===
/* ecs - equivalence class routines */

/*-
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Vern Paxson.
 * 
 * The United States Government has rights in this work pursuant
 * to contract no. DE-AC03-76SF00098 between the United States
 * Department of Energy and the University of California.
 *
 * Redistribution and use in source and binary forms with or without
 * modification are permitted provided that: (1) source distributions retain
 * this entire copyright notice and comment, and (2) distributions including
 * binaries display the following acknowledgement:  ``This product includes
 * software developed by the University of California, Berkeley and its
 * contributors'' in the documentation or other materials provided with the
 * distribution and in all advertising materials mentioning features or use
 * of this software.  Neither the name of the University nor the names of
 * its contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

/* $Header: \\VIA-SOURCE\RELEASE21\dev\RCS\Tools\flex-2.5.4a\ecs.c,v 1.1 1999/12/08 23:40:20 wayneg Exp $ */

#include "flexdef.h"

/* ccl2ecl - convert character classes to set of equivalence classes */

void ccl2ecl()
	{
	int i, ich, newlen, cclp, ccls, cclmec;

	for ( i = 1; i <= lastccl; ++i )
		{
		/* We loop through each character class, and for each character
		 * in the class, add the character's equivalence class to the
		 * new "character" class we are creating.  Thus when we are all
		 * done, character classes will really consist of collections
		 * of equivalence classes
		 */

		newlen = 0;
		cclp = cclmap[i];

		for ( ccls = 0; ccls < ccllen[i]; ++ccls )
			{
			ich = ccltbl[cclp + ccls];
			cclmec = ecgroup[ich];

			if ( cclmec > 0 )
				{
				ccltbl[cclp + newlen] = cclmec;
				++newlen;
				}
			}

		ccllen[i] = newlen;
		}
	}


/* cre8ecs - associate equivalence class numbers with class members
 *
 * fwd is the forward linked-list of equivalence class members.  bck
 * is the backward linked-list, and num is the number of class members.
 *
 * Returned is the number of classes.
 */

int cre8ecs( fwd, bck, num )
int fwd[], bck[], num;
	{
	int i, j, numcl;

	numcl = 0;

	/* Create equivalence class numbers.  From now on, ABS( bck(x) )
	 * is the equivalence class number for object x.  If bck(x)
	 * is positive, then x is the representative of its equivalence
	 * class.
	 */
	for ( i = 1; i <= num; ++i )
		if ( bck[i] == NIL )
			{
			bck[i] = ++numcl;
			for ( j = fwd[i]; j != NIL; j = fwd[j] )
				bck[j] = -numcl;
			}

	return numcl;
	}


/* mkeccl - update equivalence classes based on character class xtions
 *
 * synopsis
 *    Char ccls[];
 *    int lenccl, fwd[llsiz], bck[llsiz], llsiz, NUL_mapping;
 *    void mkeccl( Char ccls[], int lenccl, int fwd[llsiz], int bck[llsiz],
 *			int llsiz, int NUL_mapping );
 *
 * ccls contains the elements of the character class, lenccl is the
 * number of elements in the ccl, fwd is the forward link-list of equivalent
 * characters, bck is the backward link-list, and llsiz size of the link-list.
 *
 * NUL_mapping is the value which NUL (0) should be mapped to.
 */

void mkeccl( ccls, lenccl, fwd, bck, llsiz, NUL_mapping )
Char ccls[];
int lenccl, fwd[], bck[], llsiz, NUL_mapping;
	{
	int cclp, oldec, newec;
	int cclm, i, j;
	static unsigned char cclflags[CSIZE];	/* initialized to all '\0' */

	/* Note that it doesn't matter whether or not the character class is
	 * negated.  The same results will be obtained in either case.
	 */

	cclp = 0;

	while ( cclp < lenccl )
		{
		cclm = ccls[cclp];

		if ( NUL_mapping && cclm == 0 )
			cclm = NUL_mapping;

		oldec = bck[cclm];
		newec = cclm;

		j = cclp + 1;

		for ( i = fwd[cclm]; i != NIL && i <= llsiz; i = fwd[i] )
			{ /* look for the symbol in the character class */
			for ( ; j < lenccl; ++j )
				{
				register int ccl_char;

				if ( NUL_mapping && ccls[j] == 0 )
					ccl_char = NUL_mapping;
				else
					ccl_char = ccls[j];

				if ( ccl_char > i )
					break;

				if ( ccl_char == i && ! cclflags[j] )
					{
					/* We found an old companion of cclm
					 * in the ccl.  Link it into the new
					 * equivalence class and flag it as
					 * having been processed.
					 */

					bck[i] = newec;
					fwd[newec] = i;
					newec = i;
					/* Set flag so we don't reprocess. */
					cclflags[j] = 1;

					/* Get next equivalence class member. */
					/* continue 2 */
					goto next_pt;
					}
				}

			/* Symbol isn't in character class.  Put it in the old
			 * equivalence class.
			 */

			bck[i] = oldec;

			if ( oldec != NIL )
				fwd[oldec] = i;

			oldec = i;

			next_pt: ;
			}

		if ( bck[cclm] != NIL || oldec != bck[cclm] )
			{
			bck[cclm] = NIL;
			fwd[oldec] = NIL;
			}

		fwd[newec] = NIL;

		/* Find next ccl member to process. */

		for ( ++cclp; cclflags[cclp] && cclp < lenccl; ++cclp )
			{
			/* Reset "doesn't need processing" flag. */
			cclflags[cclp] = 0;
			}
		}
	}


/* mkechar - create equivalence class for single character */

void mkechar( tch, fwd, bck )
int tch, fwd[], bck[];
	{
	/* If until now the character has been a proper subset of
	 * an equivalence class, break it away to create a new ec
	 */

	if ( fwd[tch] != NIL )
		bck[fwd[tch]] = bck[tch];

	if ( bck[tch] != NIL )
		fwd[bck[tch]] = fwd[tch];

	fwd[tch] = NIL;
	bck[tch] = NIL;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\flex\flexdef.h ===
/* flexdef - definitions file for flex */

/*-
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Vern Paxson.
 * 
 * The United States Government has rights in this work pursuant
 * to contract no. DE-AC03-76SF00098 between the United States
 * Department of Energy and the University of California.
 *
 * Redistribution and use in source and binary forms with or without
 * modification are permitted provided that: (1) source distributions retain
 * this entire copyright notice and comment, and (2) distributions including
 * binaries display the following acknowledgement:  ``This product includes
 * software developed by the University of California, Berkeley and its
 * contributors'' in the documentation or other materials provided with the
 * distribution and in all advertising materials mentioning features or use
 * of this software.  Neither the name of the University nor the names of
 * its contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

/* @(#) $Header: \\VIA-SOURCE\RELEASE21\dev\RCS\Tools\flex-2.5.4a\flexdef.h,v 1.1 1999/12/08 23:40:22 wayneg Exp $ (LBL) */

#include <stdio.h>
#include <ctype.h>

#include "config.h"

#ifdef __TURBOC__
#define HAVE_STRING_H 1
#define MS_DOS 1
#ifndef __STDC__
#define __STDC__ 1
#endif
 #pragma warn -pro
 #pragma warn -rch
 #pragma warn -use
 #pragma warn -aus
 #pragma warn -par
 #pragma warn -pia
#endif

#ifdef HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif

#ifdef HAVE_MALLOC_H
#include <malloc.h>
#endif

#ifdef STDC_HEADERS
#include <stdlib.h>
#endif

/* As an aid for the internationalization patch to flex, which
 * is maintained outside this distribution for copyright reasons.
 */
#define _(String) (String)

/* Always be prepared to generate an 8-bit scanner. */
#define CSIZE 256
#define Char unsigned char

/* Size of input alphabet - should be size of ASCII set. */
#ifndef DEFAULT_CSIZE
#define DEFAULT_CSIZE 128
#endif

#ifndef PROTO
#if __STDC__
#define PROTO(proto) proto
#else
#define PROTO(proto) ()
#endif
#endif

#ifdef VMS
#ifndef __VMS_POSIX
#define unlink remove
#define SHORT_FILE_NAMES
#endif
#endif

#ifdef MS_DOS
#define SHORT_FILE_NAMES
#endif


/* Maximum line length we'll have to deal with. */
#define MAXLINE 2048

#ifndef MIN
#define MIN(x,y) ((x) < (y) ? (x) : (y))
#endif
#ifndef MAX
#define MAX(x,y) ((x) > (y) ? (x) : (y))
#endif
#ifndef ABS
#define ABS(x) ((x) < 0 ? -(x) : (x))
#endif


/* ANSI C does not guarantee that isascii() is defined */
#ifndef isascii
#define isascii(c) ((c) <= 0177)
#endif


#define true 1
#define false 0
#define unspecified -1


/* Special chk[] values marking the slots taking by end-of-buffer and action
 * numbers.
 */
#define EOB_POSITION -1
#define ACTION_POSITION -2

/* Number of data items per line for -f output. */
#define NUMDATAITEMS 10

/* Number of lines of data in -f output before inserting a blank line for
 * readability.
 */
#define NUMDATALINES 10

/* transition_struct_out() definitions. */
#define TRANS_STRUCT_PRINT_LENGTH 14

/* Returns true if an nfa state has an epsilon out-transition slot
 * that can be used.  This definition is currently not used.
 */
#define FREE_EPSILON(state) \
	(transchar[state] == SYM_EPSILON && \
	 trans2[state] == NO_TRANSITION && \
	 finalst[state] != state)

/* Returns true if an nfa state has an epsilon out-transition character
 * and both slots are free
 */
#define SUPER_FREE_EPSILON(state) \
	(transchar[state] == SYM_EPSILON && \
	 trans1[state] == NO_TRANSITION) \

/* Maximum number of NFA states that can comprise a DFA state.  It's real
 * big because if there's a lot of rules, the initial state will have a
 * huge epsilon closure.
 */
#define INITIAL_MAX_DFA_SIZE 750
#define MAX_DFA_SIZE_INCREMENT 750


/* A note on the following masks.  They are used to mark accepting numbers
 * as being special.  As such, they implicitly limit the number of accepting
 * numbers (i.e., rules) because if there are too many rules the rule numbers
 * will overload the mask bits.  Fortunately, this limit is \large/ (0x2000 ==
 * 8192) so unlikely to actually cause any problems.  A check is made in
 * new_rule() to ensure that this limit is not reached.
 */

/* Mask to mark a trailing context accepting number. */
#define YY_TRAILING_MASK 0x2000

/* Mask to mark the accepting number of the "head" of a trailing context
 * rule.
 */
#define YY_TRAILING_HEAD_MASK 0x4000

/* Maximum number of rules, as outlined in the above note. */
#define MAX_RULE (YY_TRAILING_MASK - 1)


/* NIL must be 0.  If not, its special meaning when making equivalence classes
 * (it marks the representative of a given e.c.) will be unidentifiable.
 */
#define NIL 0

#define JAM -1	/* to mark a missing DFA transition */
#define NO_TRANSITION NIL
#define UNIQUE -1	/* marks a symbol as an e.c. representative */
#define INFINITY -1	/* for x{5,} constructions */

#define INITIAL_MAX_CCLS 100	/* max number of unique character classes */
#define MAX_CCLS_INCREMENT 100

/* Size of table holding members of character classes. */
#define INITIAL_MAX_CCL_TBL_SIZE 500
#define MAX_CCL_TBL_SIZE_INCREMENT 250

#define INITIAL_MAX_RULES 100	/* default maximum number of rules */
#define MAX_RULES_INCREMENT 100

#define INITIAL_MNS 2000	/* default maximum number of nfa states */
#define MNS_INCREMENT 1000	/* amount to bump above by if it's not enough */

#define INITIAL_MAX_DFAS 1000	/* default maximum number of dfa states */
#define MAX_DFAS_INCREMENT 1000

#define JAMSTATE -32766	/* marks a reference to the state that always jams */

/* Maximum number of NFA states. */
#define MAXIMUM_MNS 31999

/* Enough so that if it's subtracted from an NFA state number, the result
 * is guaranteed to be negative.
 */
#define MARKER_DIFFERENCE (MAXIMUM_MNS+2)

/* Maximum number of nxt/chk pairs for non-templates. */
#define INITIAL_MAX_XPAIRS 2000
#define MAX_XPAIRS_INCREMENT 2000

/* Maximum number of nxt/chk pairs needed for templates. */
#define INITIAL_MAX_TEMPLATE_XPAIRS 2500
#define MAX_TEMPLATE_XPAIRS_INCREMENT 2500

#define SYM_EPSILON (CSIZE + 1)	/* to mark transitions on the symbol epsilon */

#define INITIAL_MAX_SCS 40	/* maximum number of start conditions */
#define MAX_SCS_INCREMENT 40	/* amount to bump by if it's not enough */

#define ONE_STACK_SIZE 500	/* stack of states with only one out-transition */
#define SAME_TRANS -1	/* transition is the same as "default" entry for state */

/* The following percentages are used to tune table compression:

 * The percentage the number of out-transitions a state must be of the
 * number of equivalence classes in order to be considered for table
 * compaction by using protos.
 */
#define PROTO_SIZE_PERCENTAGE 15

/* The percentage the number of homogeneous out-transitions of a state
 * must be of the number of total out-transitions of the state in order
 * that the state's transition table is first compared with a potential 
 * template of the most common out-transition instead of with the first
 * proto in the proto queue.
 */
#define CHECK_COM_PERCENTAGE 50

/* The percentage the number of differences between a state's transition
 * table and the proto it was first compared with must be of the total
 * number of out-transitions of the state in order to keep the first
 * proto as a good match and not search any further.
 */
#define FIRST_MATCH_DIFF_PERCENTAGE 10

/* The percentage the number of differences between a state's transition
 * table and the most similar proto must be of the state's total number
 * of out-transitions to use the proto as an acceptable close match.
 */
#define ACCEPTABLE_DIFF_PERCENTAGE 50

/* The percentage the number of homogeneous out-transitions of a state
 * must be of the number of total out-transitions of the state in order
 * to consider making a template from the state.
 */
#define TEMPLATE_SAME_PERCENTAGE 60

/* The percentage the number of differences between a state's transition
 * table and the most similar proto must be of the state's total number
 * of out-transitions to create a new proto from the state.
 */
#define NEW_PROTO_DIFF_PERCENTAGE 20

/* The percentage the total number of out-transitions of a state must be
 * of the number of equivalence classes in order to consider trying to
 * fit the transition table into "holes" inside the nxt/chk table.
 */
#define INTERIOR_FIT_PERCENTAGE 15

/* Size of region set aside to cache the complete transition table of
 * protos on the proto queue to enable quick comparisons.
 */
#define PROT_SAVE_SIZE 2000

#define MSP 50	/* maximum number of saved protos (protos on the proto queue) */

/* Maximum number of out-transitions a state can have that we'll rummage
 * around through the interior of the internal fast table looking for a
 * spot for it.
 */
#define MAX_XTIONS_FULL_INTERIOR_FIT 4

/* Maximum number of rules which will be reported as being associated
 * with a DFA state.
 */
#define MAX_ASSOC_RULES 100

/* Number that, if used to subscript an array, has a good chance of producing
 * an error; should be small enough to fit into a short.
 */
#define BAD_SUBSCRIPT -32767

/* Absolute value of largest number that can be stored in a short, with a
 * bit of slop thrown in for general paranoia.
 */
#define MAX_SHORT 32700


/* Declarations for global variables. */

/* Variables for symbol tables:
 * sctbl - start-condition symbol table
 * ndtbl - name-definition symbol table
 * ccltab - character class text symbol table
 */

struct hash_entry
	{
	struct hash_entry *prev, *next;
	char *name;
	char *str_val;
	int int_val;
	} ;

typedef struct hash_entry **hash_table;

#define NAME_TABLE_HASH_SIZE 101
#define START_COND_HASH_SIZE 101
#define CCL_HASH_SIZE 101

extern struct hash_entry *ndtbl[NAME_TABLE_HASH_SIZE]; 
extern struct hash_entry *sctbl[START_COND_HASH_SIZE];
extern struct hash_entry *ccltab[CCL_HASH_SIZE];


/* Variables for flags:
 * printstats - if true (-v), dump statistics
 * syntaxerror - true if a syntax error has been found
 * eofseen - true if we've seen an eof in the input file
 * ddebug - if true (-d), make a "debug" scanner
 * trace - if true (-T), trace processing
 * nowarn - if true (-w), do not generate warnings
 * spprdflt - if true (-s), suppress the default rule
 * interactive - if true (-I), generate an interactive scanner
 * caseins - if true (-i), generate a case-insensitive scanner
 * lex_compat - if true (-l), maximize compatibility with AT&T lex
 * do_yylineno - if true, generate code to maintain yylineno
 * useecs - if true (-Ce flag), use equivalence classes
 * fulltbl - if true (-Cf flag), don't compress the DFA state table
 * usemecs - if true (-Cm flag), use meta-equivalence classes
 * fullspd - if true (-F flag), use Jacobson method of table representation
 * gen_line_dirs - if true (i.e., no -L flag), generate #line directives
 * performance_report - if > 0 (i.e., -p flag), generate a report relating
 *   to scanner performance; if > 1 (-p -p), report on minor performance
 *   problems, too
 * backing_up_report - if true (i.e., -b flag), generate "lex.backup" file
 *   listing backing-up states
 * C_plus_plus - if true (i.e., -+ flag), generate a C++ scanner class;
 *   otherwise, a standard C scanner
 * long_align - if true (-Ca flag), favor long-word alignment.
 * use_read - if true (-f, -F, or -Cr) then use read() for scanner input;
 *   otherwise, use fread().
 * yytext_is_array - if true (i.e., %array directive), then declare
 *   yytext as a array instead of a character pointer.  Nice and inefficient.
 * do_yywrap - do yywrap() processing on EOF.  If false, EOF treated as
 *   "no more files".
 * csize - size of character set for the scanner we're generating;
 *   128 for 7-bit chars and 256 for 8-bit
 * yymore_used - if true, yymore() is used in input rules
 * reject - if true, generate back-up tables for REJECT macro
 * real_reject - if true, scanner really uses REJECT (as opposed to just
 *   having "reject" set for variable trailing context)
 * continued_action - true if this rule's action is to "fall through" to
 *   the next rule's action (i.e., the '|' action)
 * in_rule - true if we're inside an individual rule, false if not.
 * yymore_really_used - whether to treat yymore() as really used, regardless
 *   of what we think based on references to it in the user's actions.
 * reject_really_used - same for REJECT
 */

extern int printstats, syntaxerror, eofseen, ddebug, trace, nowarn, spprdflt;
extern int interactive, caseins, lex_compat, do_yylineno;
extern int useecs, fulltbl, usemecs, fullspd;
extern int gen_line_dirs, performance_report, backing_up_report;
extern int C_plus_plus, long_align, use_read, yytext_is_array, do_yywrap;
extern int csize;
extern int yymore_used, reject, real_reject, continued_action, in_rule;

extern int yymore_really_used, reject_really_used;


/* Variables used in the flex input routines:
 * datapos - characters on current output line
 * dataline - number of contiguous lines of data in current data
 * 	statement.  Used to generate readable -f output
 * linenum - current input line number
 * out_linenum - current output line number
 * skelfile - the skeleton file
 * skel - compiled-in skeleton array
 * skel_ind - index into "skel" array, if skelfile is nil
 * yyin - input file
 * backing_up_file - file to summarize backing-up states to
 * infilename - name of input file
 * outfilename - name of output file
 * did_outfilename - whether outfilename was explicitly set
 * prefix - the prefix used for externally visible names ("yy" by default)
 * yyclass - yyFlexLexer subclass to use for YY_DECL
 * do_stdinit - whether to initialize yyin/yyout to stdin/stdout
 * use_stdout - the -t flag
 * input_files - array holding names of input files
 * num_input_files - size of input_files array
 * program_name - name with which program was invoked 
 *
 * action_array - array to hold the rule actions
 * action_size - size of action_array
 * defs1_offset - index where the user's section 1 definitions start
 *	in action_array
 * prolog_offset - index where the prolog starts in action_array
 * action_offset - index where the non-prolog starts in action_array
 * action_index - index where the next action should go, with respect
 * 	to "action_array"
 */

extern int datapos, dataline, linenum, out_linenum;
extern FILE *skelfile, *yyin, *backing_up_file;
extern const char *skel[];
extern int skel_ind;
extern char *infilename, *outfilename;
extern int did_outfilename;
extern char *prefix, *yyclass;
extern int do_stdinit, use_stdout;
extern char **input_files;
extern int num_input_files;
extern char *program_name;

extern char *action_array;
extern int action_size;
extern int defs1_offset, prolog_offset, action_offset, action_index;


/* Variables for stack of states having only one out-transition:
 * onestate - state number
 * onesym - transition symbol
 * onenext - target state
 * onedef - default base entry
 * onesp - stack pointer
 */

extern int onestate[ONE_STACK_SIZE], onesym[ONE_STACK_SIZE];
extern int onenext[ONE_STACK_SIZE], onedef[ONE_STACK_SIZE], onesp;


/* Variables for nfa machine data:
 * current_mns - current maximum on number of NFA states
 * num_rules - number of the last accepting state; also is number of
 * 	rules created so far
 * num_eof_rules - number of <<EOF>> rules
 * default_rule - number of the default rule
 * current_max_rules - current maximum number of rules
 * lastnfa - last nfa state number created
 * firstst - physically the first state of a fragment
 * lastst - last physical state of fragment
 * finalst - last logical state of fragment
 * transchar - transition character
 * trans1 - transition state
 * trans2 - 2nd transition state for epsilons
 * accptnum - accepting number
 * assoc_rule - rule associated with this NFA state (or 0 if none)
 * state_type - a STATE_xxx type identifying whether the state is part
 * 	of a normal rule, the leading state in a trailing context
 * 	rule (i.e., the state which marks the transition from
 * 	recognizing the text-to-be-matched to the beginning of
 * 	the trailing context), or a subsequent state in a trailing
 * 	context rule
 * rule_type - a RULE_xxx type identifying whether this a ho-hum
 * 	normal rule or one which has variable head & trailing
 * 	context
 * rule_linenum - line number associated with rule
 * rule_useful - true if we've determined that the rule can be matched
 */

extern int current_mns, current_max_rules;
extern int num_rules, num_eof_rules, default_rule, lastnfa;
extern int *firstst, *lastst, *finalst, *transchar, *trans1, *trans2;
extern int *accptnum, *assoc_rule, *state_type;
extern int *rule_type, *rule_linenum, *rule_useful;

/* Different types of states; values are useful as masks, as well, for
 * routines like check_trailing_context().
 */
#define STATE_NORMAL 0x1
#define STATE_TRAILING_CONTEXT 0x2

/* Global holding current type of state we're making. */

extern int current_state_type;

/* Different types of rules. */
#define RULE_NORMAL 0
#define RULE_VARIABLE 1

/* True if the input rules include a rule with both variable-length head
 * and trailing context, false otherwise.
 */
extern int variable_trailing_context_rules;


/* Variables for protos:
 * numtemps - number of templates created
 * numprots - number of protos created
 * protprev - backlink to a more-recently used proto
 * protnext - forward link to a less-recently used proto
 * prottbl - base/def table entry for proto
 * protcomst - common state of proto
 * firstprot - number of the most recently used proto
 * lastprot - number of the least recently used proto
 * protsave contains the entire state array for protos
 */

extern int numtemps, numprots, protprev[MSP], protnext[MSP], prottbl[MSP];
extern int protcomst[MSP], firstprot, lastprot, protsave[PROT_SAVE_SIZE];


/* Variables for managing equivalence classes:
 * numecs - number of equivalence classes
 * nextecm - forward link of Equivalence Class members
 * ecgroup - class number or backward link of EC members
 * nummecs - number of meta-equivalence classes (used to compress
 *   templates)
 * tecfwd - forward link of meta-equivalence classes members
 * tecbck - backward link of MEC's
 */

/* Reserve enough room in the equivalence class arrays so that we
 * can use the CSIZE'th element to hold equivalence class information
 * for the NUL character.  Later we'll move this information into
 * the 0th element.
 */
extern int numecs, nextecm[CSIZE + 1], ecgroup[CSIZE + 1], nummecs;

/* Meta-equivalence classes are indexed starting at 1, so it's possible
 * that they will require positions from 1 .. CSIZE, i.e., CSIZE + 1
 * slots total (since the arrays are 0-based).  nextecm[] and ecgroup[]
 * don't require the extra position since they're indexed from 1 .. CSIZE - 1.
 */
extern int tecfwd[CSIZE + 1], tecbck[CSIZE + 1];


/* Variables for start conditions:
 * lastsc - last start condition created
 * current_max_scs - current limit on number of start conditions
 * scset - set of rules active in start condition
 * scbol - set of rules active only at the beginning of line in a s.c.
 * scxclu - true if start condition is exclusive
 * sceof - true if start condition has EOF rule
 * scname - start condition name
 */

extern int lastsc, *scset, *scbol, *scxclu, *sceof;
extern int current_max_scs;
extern char **scname;


/* Variables for dfa machine data:
 * current_max_dfa_size - current maximum number of NFA states in DFA
 * current_max_xpairs - current maximum number of non-template xtion pairs
 * current_max_template_xpairs - current maximum number of template pairs
 * current_max_dfas - current maximum number DFA states
 * lastdfa - last dfa state number created
 * nxt - state to enter upon reading character
 * chk - check value to see if "nxt" applies
 * tnxt - internal nxt table for templates
 * base - offset into "nxt" for given state
 * def - where to go if "chk" disallows "nxt" entry
 * nultrans - NUL transition for each state
 * NUL_ec - equivalence class of the NUL character
 * tblend - last "nxt/chk" table entry being used
 * firstfree - first empty entry in "nxt/chk" table
 * dss - nfa state set for each dfa
 * dfasiz - size of nfa state set for each dfa
 * dfaacc - accepting set for each dfa state (if using REJECT), or accepting
 *	number, if not
 * accsiz - size of accepting set for each dfa state
 * dhash - dfa state hash value
 * numas - number of DFA accepting states created; note that this
 *	is not necessarily the same value as num_rules, which is the analogous
 *	value for the NFA
 * numsnpairs - number of state/nextstate transition pairs
 * jambase - position in base/def where the default jam table starts
 * jamstate - state number corresponding to "jam" state
 * end_of_buffer_state - end-of-buffer dfa state number
 */

extern int current_max_dfa_size, current_max_xpairs;
extern int current_max_template_xpairs, current_max_dfas;
extern int lastdfa, *nxt, *chk, *tnxt;
extern int *base, *def, *nultrans, NUL_ec, tblend, firstfree, **dss, *dfasiz;
extern union dfaacc_union
	{
	int *dfaacc_set;
	int dfaacc_state;
	} *dfaacc;
extern int *accsiz, *dhash, numas;
extern int numsnpairs, jambase, jamstate;
extern int end_of_buffer_state;

/* Variables for ccl information:
 * lastccl - ccl index of the last created ccl
 * current_maxccls - current limit on the maximum number of unique ccl's
 * cclmap - maps a ccl index to its set pointer
 * ccllen - gives the length of a ccl
 * cclng - true for a given ccl if the ccl is negated
 * cclreuse - counts how many times a ccl is re-used
 * current_max_ccl_tbl_size - current limit on number of characters needed
 *	to represent the unique ccl's
 * ccltbl - holds the characters in each ccl - indexed by cclmap
 */

extern int lastccl, *cclmap, *ccllen, *cclng, cclreuse;
extern int current_maxccls, current_max_ccl_tbl_size;
extern Char *ccltbl;


/* Variables for miscellaneous information:
 * nmstr - last NAME scanned by the scanner
 * sectnum - section number currently being parsed
 * nummt - number of empty nxt/chk table entries
 * hshcol - number of hash collisions detected by snstods
 * dfaeql - number of times a newly created dfa was equal to an old one
 * numeps - number of epsilon NFA states created
 * eps2 - number of epsilon states which have 2 out-transitions
 * num_reallocs - number of times it was necessary to realloc() a group
 *	  of arrays
 * tmpuses - number of DFA states that chain to templates
 * totnst - total number of NFA states used to make DFA states
 * peakpairs - peak number of transition pairs we had to store internally
 * numuniq - number of unique transitions
 * numdup - number of duplicate transitions
 * hshsave - number of hash collisions saved by checking number of states
 * num_backing_up - number of DFA states requiring backing up
 * bol_needed - whether scanner needs beginning-of-line recognition
 */

extern char nmstr[MAXLINE];
extern int sectnum, nummt, hshcol, dfaeql, numeps, eps2, num_reallocs;
extern int tmpuses, totnst, peakpairs, numuniq, numdup, hshsave;
extern int num_backing_up, bol_needed;

void *allocate_array PROTO((int, size_t));
void *reallocate_array PROTO((void*, int, size_t));

void *flex_alloc PROTO((size_t));
void *flex_realloc PROTO((void*, size_t));
void flex_free PROTO((void*));

#define allocate_integer_array(size) \
	(int *) allocate_array( size, sizeof( int ) )

#define reallocate_integer_array(array,size) \
	(int *) reallocate_array( (void *) array, size, sizeof( int ) )

#define allocate_int_ptr_array(size) \
	(int **) allocate_array( size, sizeof( int * ) )

#define allocate_char_ptr_array(size) \
	(char **) allocate_array( size, sizeof( char * ) )

#define allocate_dfaacc_union(size) \
	(union dfaacc_union *) \
		allocate_array( size, sizeof( union dfaacc_union ) )

#define reallocate_int_ptr_array(array,size) \
	(int **) reallocate_array( (void *) array, size, sizeof( int * ) )

#define reallocate_char_ptr_array(array,size) \
	(char **) reallocate_array( (void *) array, size, sizeof( char * ) )

#define reallocate_dfaacc_union(array, size) \
	(union dfaacc_union *) \
	reallocate_array( (void *) array, size, sizeof( union dfaacc_union ) )

#define allocate_character_array(size) \
	(char *) allocate_array( size, sizeof( char ) )

#define reallocate_character_array(array,size) \
	(char *) reallocate_array( (void *) array, size, sizeof( char ) )

#define allocate_Character_array(size) \
	(Char *) allocate_array( size, sizeof( Char ) )

#define reallocate_Character_array(array,size) \
	(Char *) reallocate_array( (void *) array, size, sizeof( Char ) )


/* Used to communicate between scanner and parser.  The type should really
 * be YYSTYPE, but we can't easily get our hands on it.
 */
extern int yylval;


/* External functions that are cross-referenced among the flex source files. */


/* from file ccl.c */

extern void ccladd PROTO((int, int));	/* add a single character to a ccl */
extern int cclinit PROTO((void));	/* make an empty ccl */
extern void cclnegate PROTO((int));	/* negate a ccl */

/* List the members of a set of characters in CCL form. */
extern void list_character_set PROTO((FILE*, int[]));


/* from file dfa.c */

/* Check a DFA state for backing up. */
extern void check_for_backing_up PROTO((int, int[]));

/* Check to see if NFA state set constitutes "dangerous" trailing context. */
extern void check_trailing_context PROTO((int*, int, int*, int));

/* Construct the epsilon closure of a set of ndfa states. */
extern int *epsclosure PROTO((int*, int*, int[], int*, int*));

/* Increase the maximum number of dfas. */
extern void increase_max_dfas PROTO((void));

extern void ntod PROTO((void));	/* convert a ndfa to a dfa */

/* Converts a set of ndfa states into a dfa state. */
extern int snstods PROTO((int[], int, int[], int, int, int*));


/* from file ecs.c */

/* Convert character classes to set of equivalence classes. */
extern void ccl2ecl PROTO((void));

/* Associate equivalence class numbers with class members. */
extern int cre8ecs PROTO((int[], int[], int));

/* Update equivalence classes based on character class transitions. */
extern void mkeccl PROTO((Char[], int, int[], int[], int, int));

/* Create equivalence class for single character. */
extern void mkechar PROTO((int, int[], int[]));


/* from file gen.c */

extern void do_indent PROTO((void));	/* indent to the current level */

/* Generate the code to keep backing-up information. */
extern void gen_backing_up PROTO((void));

/* Generate the code to perform the backing up. */
extern void gen_bu_action PROTO((void));

/* Generate full speed compressed transition table. */
extern void genctbl PROTO((void));

/* Generate the code to find the action number. */
extern void gen_find_action PROTO((void));

extern void genftbl PROTO((void));	/* generate full transition table */

/* Generate the code to find the next compressed-table state. */
extern void gen_next_compressed_state PROTO((char*));

/* Generate the code to find the next match. */
extern void gen_next_match PROTO((void));

/* Generate the code to find the next state. */
extern void gen_next_state PROTO((int));

/* Generate the code to make a NUL transition. */
extern void gen_NUL_trans PROTO((void));

/* Generate the code to find the start state. */
extern void gen_start_state PROTO((void));

/* Generate data statements for the transition tables. */
extern void gentabs PROTO((void));

/* Write out a formatted string at the current indentation level. */
extern void indent_put2s PROTO((char[], char[]));

/* Write out a string + newline at the current indentation level. */
extern void indent_puts PROTO((char[]));

extern void make_tables PROTO((void));	/* generate transition tables */


/* from file main.c */

extern void check_options PROTO((void));
extern void flexend PROTO((int));
extern void usage PROTO((void));


/* from file misc.c */

/* Add a #define to the action file. */
extern void action_define PROTO(( char *defname, int value ));

/* Add the given text to the stored actions. */
extern void add_action PROTO(( char *new_text ));

/* True if a string is all lower case. */
extern int all_lower PROTO((register char *));

/* True if a string is all upper case. */
extern int all_upper PROTO((register char *));

/* Bubble sort an integer array. */
extern void bubble PROTO((int [], int));

/* Check a character to make sure it's in the expected range. */
extern void check_char PROTO((int c));

/* Replace upper-case letter to lower-case. */
extern Char clower PROTO((int));

/* Returns a dynamically allocated copy of a string. */
extern char *copy_string PROTO((register const char *));

/* Returns a dynamically allocated copy of a (potentially) unsigned string. */
extern Char *copy_unsigned_string PROTO((register Char *));

/* Shell sort a character array. */
extern void cshell PROTO((Char [], int, int));

/* Finish up a block of data declarations. */
extern void dataend PROTO((void));

/* Flush generated data statements. */
extern void dataflush PROTO((void));

/* Report an error message and terminate. */
extern void flexerror PROTO((const char[]));

/* Report a fatal error message and terminate. */
extern void flexfatal PROTO((const char[]));

/* Convert a hexadecimal digit string to an integer value. */
extern int htoi PROTO((Char[]));

/* Report an error message formatted with one integer argument. */
extern void lerrif PROTO((const char[], int));

/* Report an error message formatted with one string argument. */
extern void lerrsf PROTO((const char[], const char[]));

/* Spit out a "#line" statement. */
extern void line_directive_out PROTO((FILE*, int));

/* Mark the current position in the action array as the end of the section 1
 * user defs.
 */
extern void mark_defs1 PROTO((void));

/* Mark the current position in the action array as the end of the prolog. */
extern void mark_prolog PROTO((void));

/* Generate a data statment for a two-dimensional array. */
extern void mk2data PROTO((int));

extern void mkdata PROTO((int));	/* generate a data statement */

/* Return the integer represented by a string of digits. */
extern int myctoi PROTO((char []));

/* Return character corresponding to escape sequence. */
extern Char myesc PROTO((Char[]));

/* Convert an octal digit string to an integer value. */
extern int otoi PROTO((Char [] ));

/* Output a (possibly-formatted) string to the generated scanner. */
extern void out PROTO((const char []));
extern void out_dec PROTO((const char [], int));
extern void out_dec2 PROTO((const char [], int, int));
extern void out_hex PROTO((const char [], unsigned int));
extern void out_line_count PROTO((const char []));
extern void out_str PROTO((const char [], const char []));
extern void out_str3
	PROTO((const char [], const char [], const char [], const char []));
extern void out_str_dec PROTO((const char [], const char [], int));
extern void outc PROTO((int));
extern void outn PROTO((const char []));

/* Return a printable version of the given character, which might be
 * 8-bit.
 */
extern char *readable_form PROTO((int));

/* Write out one section of the skeleton file. */
extern void skelout PROTO((void));

/* Output a yy_trans_info structure. */
extern void transition_struct_out PROTO((int, int));

/* Only needed when using certain broken versions of bison to build parse.c. */
extern void *yy_flex_xmalloc PROTO(( int ));

/* Set a region of memory to 0. */
extern void zero_out PROTO((char *, size_t));


/* from file nfa.c */

/* Add an accepting state to a machine. */
extern void add_accept PROTO((int, int));

/* Make a given number of copies of a singleton machine. */
extern int copysingl PROTO((int, int));

/* Debugging routine to write out an nfa. */
extern void dumpnfa PROTO((int));

/* Finish up the processing for a rule. */
extern void finish_rule PROTO((int, int, int, int));

/* Connect two machines together. */
extern int link_machines PROTO((int, int));

/* Mark each "beginning" state in a machine as being a "normal" (i.e.,
 * not trailing context associated) state.
 */
extern void mark_beginning_as_normal PROTO((register int));

/* Make a machine that branches to two machines. */
extern int mkbranch PROTO((int, int));

extern int mkclos PROTO((int));	/* convert a machine into a closure */
extern int mkopt PROTO((int));	/* make a machine optional */

/* Make a machine that matches either one of two machines. */
extern int mkor PROTO((int, int));

/* Convert a machine into a positive closure. */
extern int mkposcl PROTO((int));

extern int mkrep PROTO((int, int, int));	/* make a replicated machine */

/* Create a state with a transition on a given symbol. */
extern int mkstate PROTO((int));

extern void new_rule PROTO((void));	/* initialize for a new rule */


/* from file parse.y */

/* Build the "<<EOF>>" action for the active start conditions. */
extern void build_eof_action PROTO((void));

/* Write out a message formatted with one string, pinpointing its location. */
extern void format_pinpoint_message PROTO((char[], char[]));

/* Write out a message, pinpointing its location. */
extern void pinpoint_message PROTO((char[]));

/* Write out a warning, pinpointing it at the given line. */
extern void line_warning PROTO(( char[], int ));

/* Write out a message, pinpointing it at the given line. */
extern void line_pinpoint PROTO(( char[], int ));

/* Report a formatted syntax error. */
extern void format_synerr PROTO((char [], char[]));
extern void synerr PROTO((char []));	/* report a syntax error */
extern void format_warn PROTO((char [], char[]));
extern void warn PROTO((char []));	/* report a warning */
extern void yyerror PROTO((char []));	/* report a parse error */
extern int yyparse PROTO((void));	/* the YACC parser */


/* from file scan.l */

/* The Flex-generated scanner for flex. */
extern int flexscan PROTO((void));

/* Open the given file (if NULL, stdin) for scanning. */
extern void set_input_file PROTO((char*));

/* Wrapup a file in the lexical analyzer. */
extern int yywrap PROTO((void));


/* from file sym.c */

/* Add symbol and definitions to symbol table. */
extern int addsym PROTO((register char[], char*, int, hash_table, int));

/* Save the text of a character class. */
extern void cclinstal PROTO ((Char [], int));

/* Lookup the number associated with character class. */
extern int ccllookup PROTO((Char []));

/* Find symbol in symbol table. */
extern struct hash_entry *findsym PROTO((register char[], hash_table, int ));

extern void ndinstal PROTO((char[], Char[]));	/* install a name definition */
extern Char *ndlookup PROTO((char[]));	/* lookup a name definition */

/* Increase maximum number of SC's. */
extern void scextend PROTO((void));
extern void scinstal PROTO((char[], int));	/* make a start condition */

/* Lookup the number associated with a start condition. */
extern int sclookup PROTO((char[]));


/* from file tblcmp.c */

/* Build table entries for dfa state. */
extern void bldtbl PROTO((int[], int, int, int, int));

extern void cmptmps PROTO((void));	/* compress template table entries */
extern void expand_nxt_chk PROTO((void));	/* increase nxt/chk arrays */
/* Finds a space in the table for a state to be placed. */
extern int find_table_space PROTO((int*, int));
extern void inittbl PROTO((void));	/* initialize transition tables */
/* Make the default, "jam" table entries. */
extern void mkdeftbl PROTO((void));

/* Create table entries for a state (or state fragment) which has
 * only one out-transition.
 */
extern void mk1tbl PROTO((int, int, int, int));

/* Place a state into full speed transition table. */
extern void place_state PROTO((int*, int, int));

/* Save states with only one out-transition to be processed later. */
extern void stack1 PROTO((int, int, int, int));


/* from file yylex.c */

extern int yylex PROTO((void));
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\flex\gen.c ===
/* gen - actual generation (writing) of flex scanners */

/*-
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Vern Paxson.
 * 
 * The United States Government has rights in this work pursuant
 * to contract no. DE-AC03-76SF00098 between the United States
 * Department of Energy and the University of California.
 *
 * Redistribution and use in source and binary forms with or without
 * modification are permitted provided that: (1) source distributions retain
 * this entire copyright notice and comment, and (2) distributions including
 * binaries display the following acknowledgement:  ``This product includes
 * software developed by the University of California, Berkeley and its
 * contributors'' in the documentation or other materials provided with the
 * distribution and in all advertising materials mentioning features or use
 * of this software.  Neither the name of the University nor the names of
 * its contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

/* $Header: \\VIA-SOURCE\RELEASE21\dev\RCS\Tools\flex-2.5.4a\gen.c,v 1.1 1999/12/08 23:40:23 wayneg Exp $ */

#include "flexdef.h"


/* declare functions that have forward references */

void gen_next_state PROTO((int));
void genecs PROTO((void));
void indent_put2s PROTO((char [], char []));
void indent_puts PROTO((char []));


static int indent_level = 0; /* each level is 8 spaces */

#define indent_up() (++indent_level)
#define indent_down() (--indent_level)
#define set_indent(indent_val) indent_level = indent_val

/* Almost everything is done in terms of ar