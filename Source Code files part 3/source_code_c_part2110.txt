nterface IXpsOMImageResource */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMImageResource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3db8417d-ae50-485e-9a44-d7758f78a23f")
    IXpsOMImageResource : public IXpsOMResource
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStream( 
            /* [retval][out] */ __RPC__deref_out_opt IStream **readerStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContent( 
            /* [in] */ __RPC__in_opt IStream *sourceStream,
            /* [in] */ XPS_IMAGE_TYPE imageType,
            /* [in] */ __RPC__in_opt IOpcPartUri *partName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImageType( 
            /* [retval][out] */ __RPC__out XPS_IMAGE_TYPE *imageType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMImageResourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMImageResource * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMImageResource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMImageResource * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPartName )( 
            __RPC__in IXpsOMImageResource * This,
            /* [retval][out] */ __RPC__deref_out_opt IOpcPartUri **partUri);
        
        HRESULT ( STDMETHODCALLTYPE *SetPartName )( 
            __RPC__in IXpsOMImageResource * This,
            /* [in] */ __RPC__in_opt IOpcPartUri *partUri);
        
        HRESULT ( STDMETHODCALLTYPE *GetStream )( 
            __RPC__in IXpsOMImageResource * This,
            /* [retval][out] */ __RPC__deref_out_opt IStream **readerStream);
        
        HRESULT ( STDMETHODCALLTYPE *SetContent )( 
            __RPC__in IXpsOMImageResource * This,
            /* [in] */ __RPC__in_opt IStream *sourceStream,
            /* [in] */ XPS_IMAGE_TYPE imageType,
            /* [in] */ __RPC__in_opt IOpcPartUri *partName);
        
        HRESULT ( STDMETHODCALLTYPE *GetImageType )( 
            __RPC__in IXpsOMImageResource * This,
            /* [retval][out] */ __RPC__out XPS_IMAGE_TYPE *imageType);
        
        END_INTERFACE
    } IXpsOMImageResourceVtbl;

    interface IXpsOMImageResource
    {
        CONST_VTBL struct IXpsOMImageResourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMImageResource_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMImageResource_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMImageResource_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMImageResource_GetPartName(This,partUri)	\
    ( (This)->lpVtbl -> GetPartName(This,partUri) ) 

#define IXpsOMImageResource_SetPartName(This,partUri)	\
    ( (This)->lpVtbl -> SetPartName(This,partUri) ) 



#define IXpsOMImageResource_GetStream(This,readerStream)	\
    ( (This)->lpVtbl -> GetStream(This,readerStream) ) 

#define IXpsOMImageResource_SetContent(This,sourceStream,imageType,partName)	\
    ( (This)->lpVtbl -> SetContent(This,sourceStream,imageType,partName) ) 

#define IXpsOMImageResource_GetImageType(This,imageType)	\
    ( (This)->lpVtbl -> GetImageType(This,imageType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMImageResource_INTERFACE_DEFINED__ */


#ifndef __IXpsOMImageResourceCollection_INTERFACE_DEFINED__
#define __IXpsOMImageResourceCollection_INTERFACE_DEFINED__

/* interface IXpsOMImageResourceCollection */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMImageResourceCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7A4A1A71-9CDE-4B71-B33F-62DE843EABFE")
    IXpsOMImageResourceCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [retval][out] */ __RPC__out UINT32 *count) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMImageResource **object) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertAt( 
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMImageResource *object) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAt( 
            /* [in] */ UINT32 index) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAt( 
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMImageResource *object) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Append( 
            /* [in] */ __RPC__in_opt IXpsOMImageResource *object) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetByPartName( 
            /* [in] */ __RPC__in_opt IOpcPartUri *partName,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMImageResource **part) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMImageResourceCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMImageResourceCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMImageResourceCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMImageResourceCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IXpsOMImageResourceCollection * This,
            /* [retval][out] */ __RPC__out UINT32 *count);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            __RPC__in IXpsOMImageResourceCollection * This,
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMImageResource **object);
        
        HRESULT ( STDMETHODCALLTYPE *InsertAt )( 
            __RPC__in IXpsOMImageResourceCollection * This,
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMImageResource *object);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
            __RPC__in IXpsOMImageResourceCollection * This,
            /* [in] */ UINT32 index);
        
        HRESULT ( STDMETHODCALLTYPE *SetAt )( 
            __RPC__in IXpsOMImageResourceCollection * This,
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMImageResource *object);
        
        HRESULT ( STDMETHODCALLTYPE *Append )( 
            __RPC__in IXpsOMImageResourceCollection * This,
            /* [in] */ __RPC__in_opt IXpsOMImageResource *object);
        
        HRESULT ( STDMETHODCALLTYPE *GetByPartName )( 
            __RPC__in IXpsOMImageResourceCollection * This,
            /* [in] */ __RPC__in_opt IOpcPartUri *partName,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMImageResource **part);
        
        END_INTERFACE
    } IXpsOMImageResourceCollectionVtbl;

    interface IXpsOMImageResourceCollection
    {
        CONST_VTBL struct IXpsOMImageResourceCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMImageResourceCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMImageResourceCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMImageResourceCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMImageResourceCollection_GetCount(This,count)	\
    ( (This)->lpVtbl -> GetCount(This,count) ) 

#define IXpsOMImageResourceCollection_GetAt(This,index,object)	\
    ( (This)->lpVtbl -> GetAt(This,index,object) ) 

#define IXpsOMImageResourceCollection_InsertAt(This,index,object)	\
    ( (This)->lpVtbl -> InsertAt(This,index,object) ) 

#define IXpsOMImageResourceCollection_RemoveAt(This,index)	\
    ( (This)->lpVtbl -> RemoveAt(This,index) ) 

#define IXpsOMImageResourceCollection_SetAt(This,index,object)	\
    ( (This)->lpVtbl -> SetAt(This,index,object) ) 

#define IXpsOMImageResourceCollection_Append(This,object)	\
    ( (This)->lpVtbl -> Append(This,object) ) 

#define IXpsOMImageResourceCollection_GetByPartName(This,partName,part)	\
    ( (This)->lpVtbl -> GetByPartName(This,partName,part) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMImageResourceCollection_INTERFACE_DEFINED__ */


#ifndef __IXpsOMLinearGradientBrush_INTERFACE_DEFINED__
#define __IXpsOMLinearGradientBrush_INTERFACE_DEFINED__

/* interface IXpsOMLinearGradientBrush */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMLinearGradientBrush;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("005E279F-C30D-40FF-93EC-1950D3C528DB")
    IXpsOMLinearGradientBrush : public IXpsOMGradientBrush
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStartPoint( 
            /* [retval][out] */ __RPC__out XPS_POINT *startPoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStartPoint( 
            /* [in] */ __RPC__in const XPS_POINT *startPoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEndPoint( 
            /* [retval][out] */ __RPC__out XPS_POINT *endPoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEndPoint( 
            /* [in] */ __RPC__in const XPS_POINT *endPoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMLinearGradientBrush **linearGradientBrush) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMLinearGradientBrushVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMLinearGradientBrush * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMLinearGradientBrush * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **owner);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [retval][out] */ __RPC__out XPS_OBJECT_TYPE *type);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpacity )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [retval][out] */ __RPC__out FLOAT *opacity);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpacity )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [in] */ FLOAT opacity);
        
        HRESULT ( STDMETHODCALLTYPE *GetGradientStops )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGradientStopCollection **gradientStops);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransform )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **transform);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransformLocal )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **transform);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransformLocal )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [in] */ __RPC__in_opt IXpsOMMatrixTransform *transform);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransformLookup )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *key);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransformLookup )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [string][in] */ __RPC__in_string LPCWSTR key);
        
        HRESULT ( STDMETHODCALLTYPE *GetSpreadMethod )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [retval][out] */ __RPC__out XPS_SPREAD_METHOD *spreadMethod);
        
        HRESULT ( STDMETHODCALLTYPE *SetSpreadMethod )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [in] */ XPS_SPREAD_METHOD spreadMethod);
        
        HRESULT ( STDMETHODCALLTYPE *GetColorInterpolationMode )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [retval][out] */ __RPC__out XPS_COLOR_INTERPOLATION *colorInterpolationMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetColorInterpolationMode )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [in] */ XPS_COLOR_INTERPOLATION colorInterpolationMode);
        
        HRESULT ( STDMETHODCALLTYPE *GetStartPoint )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [retval][out] */ __RPC__out XPS_POINT *startPoint);
        
        HRESULT ( STDMETHODCALLTYPE *SetStartPoint )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [in] */ __RPC__in const XPS_POINT *startPoint);
        
        HRESULT ( STDMETHODCALLTYPE *GetEndPoint )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [retval][out] */ __RPC__out XPS_POINT *endPoint);
        
        HRESULT ( STDMETHODCALLTYPE *SetEndPoint )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [in] */ __RPC__in const XPS_POINT *endPoint);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IXpsOMLinearGradientBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMLinearGradientBrush **linearGradientBrush);
        
        END_INTERFACE
    } IXpsOMLinearGradientBrushVtbl;

    interface IXpsOMLinearGradientBrush
    {
        CONST_VTBL struct IXpsOMLinearGradientBrushVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMLinearGradientBrush_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMLinearGradientBrush_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMLinearGradientBrush_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMLinearGradientBrush_GetOwner(This,owner)	\
    ( (This)->lpVtbl -> GetOwner(This,owner) ) 

#define IXpsOMLinearGradientBrush_GetType(This,type)	\
    ( (This)->lpVtbl -> GetType(This,type) ) 


#define IXpsOMLinearGradientBrush_GetOpacity(This,opacity)	\
    ( (This)->lpVtbl -> GetOpacity(This,opacity) ) 

#define IXpsOMLinearGradientBrush_SetOpacity(This,opacity)	\
    ( (This)->lpVtbl -> SetOpacity(This,opacity) ) 


#define IXpsOMLinearGradientBrush_GetGradientStops(This,gradientStops)	\
    ( (This)->lpVtbl -> GetGradientStops(This,gradientStops) ) 

#define IXpsOMLinearGradientBrush_GetTransform(This,transform)	\
    ( (This)->lpVtbl -> GetTransform(This,transform) ) 

#define IXpsOMLinearGradientBrush_GetTransformLocal(This,transform)	\
    ( (This)->lpVtbl -> GetTransformLocal(This,transform) ) 

#define IXpsOMLinearGradientBrush_SetTransformLocal(This,transform)	\
    ( (This)->lpVtbl -> SetTransformLocal(This,transform) ) 

#define IXpsOMLinearGradientBrush_GetTransformLookup(This,key)	\
    ( (This)->lpVtbl -> GetTransformLookup(This,key) ) 

#define IXpsOMLinearGradientBrush_SetTransformLookup(This,key)	\
    ( (This)->lpVtbl -> SetTransformLookup(This,key) ) 

#define IXpsOMLinearGradientBrush_GetSpreadMethod(This,spreadMethod)	\
    ( (This)->lpVtbl -> GetSpreadMethod(This,spreadMethod) ) 

#define IXpsOMLinearGradientBrush_SetSpreadMethod(This,spreadMethod)	\
    ( (This)->lpVtbl -> SetSpreadMethod(This,spreadMethod) ) 

#define IXpsOMLinearGradientBrush_GetColorInterpolationMode(This,colorInterpolationMode)	\
    ( (This)->lpVtbl -> GetColorInterpolationMode(This,colorInterpolationMode) ) 

#define IXpsOMLinearGradientBrush_SetColorInterpolationMode(This,colorInterpolationMode)	\
    ( (This)->lpVtbl -> SetColorInterpolationMode(This,colorInterpolationMode) ) 


#define IXpsOMLinearGradientBrush_GetStartPoint(This,startPoint)	\
    ( (This)->lpVtbl -> GetStartPoint(This,startPoint) ) 

#define IXpsOMLinearGradientBrush_SetStartPoint(This,startPoint)	\
    ( (This)->lpVtbl -> SetStartPoint(This,startPoint) ) 

#define IXpsOMLinearGradientBrush_GetEndPoint(This,endPoint)	\
    ( (This)->lpVtbl -> GetEndPoint(This,endPoint) ) 

#define IXpsOMLinearGradientBrush_SetEndPoint(This,endPoint)	\
    ( (This)->lpVtbl -> SetEndPoint(This,endPoint) ) 

#define IXpsOMLinearGradientBrush_Clone(This,linearGradientBrush)	\
    ( (This)->lpVtbl -> Clone(This,linearGradientBrush) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMLinearGradientBrush_INTERFACE_DEFINED__ */


#ifndef __IXpsOMMatrixTransform_INTERFACE_DEFINED__
#define __IXpsOMMatrixTransform_INTERFACE_DEFINED__

/* interface IXpsOMMatrixTransform */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMMatrixTransform;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B77330FF-BB37-4501-A93E-F1B1E50BFC46")
    IXpsOMMatrixTransform : public IXpsOMShareable
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMatrix( 
            /* [retval][out] */ __RPC__out XPS_MATRIX *matrix) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMatrix( 
            /* [in] */ __RPC__in const XPS_MATRIX *matrix) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **matrixTransform) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMMatrixTransformVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMMatrixTransform * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMMatrixTransform * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMMatrixTransform * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMMatrixTransform * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **owner);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            __RPC__in IXpsOMMatrixTransform * This,
            /* [retval][out] */ __RPC__out XPS_OBJECT_TYPE *type);
        
        HRESULT ( STDMETHODCALLTYPE *GetMatrix )( 
            __RPC__in IXpsOMMatrixTransform * This,
            /* [retval][out] */ __RPC__out XPS_MATRIX *matrix);
        
        HRESULT ( STDMETHODCALLTYPE *SetMatrix )( 
            __RPC__in IXpsOMMatrixTransform * This,
            /* [in] */ __RPC__in const XPS_MATRIX *matrix);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IXpsOMMatrixTransform * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **matrixTransform);
        
        END_INTERFACE
    } IXpsOMMatrixTransformVtbl;

    interface IXpsOMMatrixTransform
    {
        CONST_VTBL struct IXpsOMMatrixTransformVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMMatrixTransform_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMMatrixTransform_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMMatrixTransform_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMMatrixTransform_GetOwner(This,owner)	\
    ( (This)->lpVtbl -> GetOwner(This,owner) ) 

#define IXpsOMMatrixTransform_GetType(This,type)	\
    ( (This)->lpVtbl -> GetType(This,type) ) 


#define IXpsOMMatrixTransform_GetMatrix(This,matrix)	\
    ( (This)->lpVtbl -> GetMatrix(This,matrix) ) 

#define IXpsOMMatrixTransform_SetMatrix(This,matrix)	\
    ( (This)->lpVtbl -> SetMatrix(This,matrix) ) 

#define IXpsOMMatrixTransform_Clone(This,matrixTransform)	\
    ( (This)->lpVtbl -> Clone(This,matrixTransform) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMMatrixTransform_INTERFACE_DEFINED__ */


#ifndef __IXpsOMPartResources_INTERFACE_DEFINED__
#define __IXpsOMPartResources_INTERFACE_DEFINED__

/* interface IXpsOMPartResources */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMPartResources;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f4cf7729-4864-4275-99b3-a8717163ecaf")
    IXpsOMPartResources : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFontResources( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMFontResourceCollection **fontResources) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImageResources( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMImageResourceCollection **imageResources) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColorProfileResources( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMColorProfileResourceCollection **colorProfileResources) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRemoteDictionaryResources( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMRemoteDictionaryResourceCollection **dictionaryResources) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMPartResourcesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMPartResources * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMPartResources * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMPartResources * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetFontResources )( 
            __RPC__in IXpsOMPartResources * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMFontResourceCollection **fontResources);
        
        HRESULT ( STDMETHODCALLTYPE *GetImageResources )( 
            __RPC__in IXpsOMPartResources * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMImageResourceCollection **imageResources);
        
        HRESULT ( STDMETHODCALLTYPE *GetColorProfileResources )( 
            __RPC__in IXpsOMPartResources * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMColorProfileResourceCollection **colorProfileResources);
        
        HRESULT ( STDMETHODCALLTYPE *GetRemoteDictionaryResources )( 
            __RPC__in IXpsOMPartResources * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMRemoteDictionaryResourceCollection **dictionaryResources);
        
        END_INTERFACE
    } IXpsOMPartResourcesVtbl;

    interface IXpsOMPartResources
    {
        CONST_VTBL struct IXpsOMPartResourcesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMPartResources_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMPartResources_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMPartResources_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMPartResources_GetFontResources(This,fontResources)	\
    ( (This)->lpVtbl -> GetFontResources(This,fontResources) ) 

#define IXpsOMPartResources_GetImageResources(This,imageResources)	\
    ( (This)->lpVtbl -> GetImageResources(This,imageResources) ) 

#define IXpsOMPartResources_GetColorProfileResources(This,colorProfileResources)	\
    ( (This)->lpVtbl -> GetColorProfileResources(This,colorProfileResources) ) 

#define IXpsOMPartResources_GetRemoteDictionaryResources(This,dictionaryResources)	\
    ( (This)->lpVtbl -> GetRemoteDictionaryResources(This,dictionaryResources) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMPartResources_INTERFACE_DEFINED__ */


#ifndef __IXpsOMPath_INTERFACE_DEFINED__
#define __IXpsOMPath_INTERFACE_DEFINED__

/* interface IXpsOMPath */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMPath;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("37D38BB6-3EE9-4110-9312-14B194163337")
    IXpsOMPath : public IXpsOMVisual
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetGeometry( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGeometry **geometry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGeometryLocal( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGeometry **geometry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetGeometryLocal( 
            /* [in] */ __RPC__in_opt IXpsOMGeometry *geometry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGeometryLookup( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *lookup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetGeometryLookup( 
            /* [string][in] */ __RPC__in_string LPCWSTR lookup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAccessibilityShortDescription( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *shortDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAccessibilityShortDescription( 
            /* [string][in] */ __RPC__in_string LPCWSTR shortDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAccessibilityLongDescription( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *longDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAccessibilityLongDescription( 
            /* [string][in] */ __RPC__in_string LPCWSTR longDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSnapsToPixels( 
            /* [retval][out] */ __RPC__out BOOL *snapsToPixels) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSnapsToPixels( 
            /* [in] */ BOOL snapsToPixels) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStrokeBrush( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMBrush **brush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStrokeBrushLocal( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMBrush **brush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStrokeBrushLocal( 
            /* [in] */ __RPC__in_opt IXpsOMBrush *brush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStrokeBrushLookup( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *lookup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStrokeBrushLookup( 
            /* [string][in] */ __RPC__in_string LPCWSTR lookup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStrokeDashes( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDashCollection **strokeDashes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStrokeDashCap( 
            /* [retval][out] */ __RPC__out XPS_DASH_CAP *strokeDashCap) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStrokeDashCap( 
            /* [in] */ XPS_DASH_CAP strokeDashCap) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStrokeDashOffset( 
            /* [retval][out] */ __RPC__out FLOAT *strokeDashOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStrokeDashOffset( 
            /* [in] */ FLOAT strokeDashOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStrokeStartLineCap( 
            /* [retval][out] */ __RPC__out XPS_LINE_CAP *strokeStartLineCap) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStrokeStartLineCap( 
            /* [in] */ XPS_LINE_CAP strokeStartLineCap) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStrokeEndLineCap( 
            /* [retval][out] */ __RPC__out XPS_LINE_CAP *strokeEndLineCap) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStrokeEndLineCap( 
            /* [in] */ XPS_LINE_CAP strokeEndLineCap) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStrokeLineJoin( 
            /* [retval][out] */ __RPC__out XPS_LINE_JOIN *strokeLineJoin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStrokeLineJoin( 
            /* [in] */ XPS_LINE_JOIN strokeLineJoin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStrokeMiterLimit( 
            /* [retval][out] */ __RPC__out FLOAT *strokeMiterLimit) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStrokeMiterLimit( 
            /* [in] */ FLOAT strokeMiterLimit) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStrokeThickness( 
            /* [retval][out] */ __RPC__out FLOAT *strokeThickness) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStrokeThickness( 
            /* [in] */ FLOAT strokeThickness) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFillBrush( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMBrush **brush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFillBrushLocal( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMBrush **brush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFillBrushLocal( 
            /* [in] */ __RPC__in_opt IXpsOMBrush *brush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFillBrushLookup( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *lookup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFillBrushLookup( 
            /* [string][in] */ __RPC__in_string LPCWSTR lookup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPath **path) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMPathVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMPath * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMPath * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMPath * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **owner);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__out XPS_OBJECT_TYPE *type);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransform )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **matrixTransform);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransformLocal )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **matrixTransform);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransformLocal )( 
            __RPC__in IXpsOMPath * This,
            /* [in] */ __RPC__in_opt IXpsOMMatrixTransform *matrixTransform);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransformLookup )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *key);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransformLookup )( 
            __RPC__in IXpsOMPath * This,
            /* [string][in] */ __RPC__in_string LPCWSTR key);
        
        HRESULT ( STDMETHODCALLTYPE *GetClipGeometry )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGeometry **clipGeometry);
        
        HRESULT ( STDMETHODCALLTYPE *GetClipGeometryLocal )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGeometry **clipGeometry);
        
        HRESULT ( STDMETHODCALLTYPE *SetClipGeometryLocal )( 
            __RPC__in IXpsOMPath * This,
            /* [in] */ __RPC__in_opt IXpsOMGeometry *clipGeometry);
        
        HRESULT ( STDMETHODCALLTYPE *GetClipGeometryLookup )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *key);
        
        HRESULT ( STDMETHODCALLTYPE *SetClipGeometryLookup )( 
            __RPC__in IXpsOMPath * This,
            /* [string][in] */ __RPC__in_string LPCWSTR key);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpacity )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__out FLOAT *opacity);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpacity )( 
            __RPC__in IXpsOMPath * This,
            /* [in] */ FLOAT opacity);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpacityMaskBrush )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMBrush **opacityMaskBrush);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpacityMaskBrushLocal )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMBrush **opacityMaskBrush);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpacityMaskBrushLocal )( 
            __RPC__in IXpsOMPath * This,
            /* [in] */ __RPC__in_opt IXpsOMBrush *opacityMaskBrush);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpacityMaskBrushLookup )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *key);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpacityMaskBrushLookup )( 
            __RPC__in IXpsOMPath * This,
            /* [string][in] */ __RPC__in_string LPCWSTR key);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *name);
        
        HRESULT ( STDMETHODCALLTYPE *SetName )( 
            __RPC__in IXpsOMPath * This,
            /* [string][in] */ __RPC__in_string LPCWSTR name);
        
        HRESULT ( STDMETHODCALLTYPE *GetIsHyperlinkTarget )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__out BOOL *isHyperlink);
        
        HRESULT ( STDMETHODCALLTYPE *SetIsHyperlinkTarget )( 
            __RPC__in IXpsOMPath * This,
            /* [in] */ BOOL isHyperlink);
        
        HRESULT ( STDMETHODCALLTYPE *GetHyperlinkNavigateUri )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__deref_out_opt IUri **hyperlinkUri);
        
        HRESULT ( STDMETHODCALLTYPE *SetHyperlinkNavigateUri )( 
            __RPC__in IXpsOMPath * This,
            /* [in] */ __RPC__in_opt IUri *hyperlinkUri);
        
        HRESULT ( STDMETHODCALLTYPE *GetLanguage )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *language);
        
        HRESULT ( STDMETHODCALLTYPE *SetLanguage )( 
            __RPC__in IXpsOMPath * This,
            /* [string][in] */ __RPC__in_string LPCWSTR language);
        
        HRESULT ( STDMETHODCALLTYPE *GetGeometry )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGeometry **geometry);
        
        HRESULT ( STDMETHODCALLTYPE *GetGeometryLocal )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGeometry **geometry);
        
        HRESULT ( STDMETHODCALLTYPE *SetGeometryLocal )( 
            __RPC__in IXpsOMPath * This,
            /* [in] */ __RPC__in_opt IXpsOMGeometry *geometry);
        
        HRESULT ( STDMETHODCALLTYPE *GetGeometryLookup )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *lookup);
        
        HRESULT ( STDMETHODCALLTYPE *SetGeometryLookup )( 
            __RPC__in IXpsOMPath * This,
            /* [string][in] */ __RPC__in_string LPCWSTR lookup);
        
        HRESULT ( STDMETHODCALLTYPE *GetAccessibilityShortDescription )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *shortDescription);
        
        HRESULT ( STDMETHODCALLTYPE *SetAccessibilityShortDescription )( 
            __RPC__in IXpsOMPath * This,
            /* [string][in] */ __RPC__in_string LPCWSTR shortDescription);
        
        HRESULT ( STDMETHODCALLTYPE *GetAccessibilityLongDescription )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *longDescription);
        
        HRESULT ( STDMETHODCALLTYPE *SetAccessibilityLongDescription )( 
            __RPC__in IXpsOMPath * This,
            /* [string][in] */ __RPC__in_string LPCWSTR longDescription);
        
        HRESULT ( STDMETHODCALLTYPE *GetSnapsToPixels )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__out BOOL *snapsToPixels);
        
        HRESULT ( STDMETHODCALLTYPE *SetSnapsToPixels )( 
            __RPC__in IXpsOMPath * This,
            /* [in] */ BOOL snapsToPixels);
        
        HRESULT ( STDMETHODCALLTYPE *GetStrokeBrush )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMBrush **brush);
        
        HRESULT ( STDMETHODCALLTYPE *GetStrokeBrushLocal )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMBrush **brush);
        
        HRESULT ( STDMETHODCALLTYPE *SetStrokeBrushLocal )( 
            __RPC__in IXpsOMPath * This,
            /* [in] */ __RPC__in_opt IXpsOMBrush *brush);
        
        HRESULT ( STDMETHODCALLTYPE *GetStrokeBrushLookup )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *lookup);
        
        HRESULT ( STDMETHODCALLTYPE *SetStrokeBrushLookup )( 
            __RPC__in IXpsOMPath * This,
            /* [string][in] */ __RPC__in_string LPCWSTR lookup);
        
        HRESULT ( STDMETHODCALLTYPE *GetStrokeDashes )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDashCollection **strokeDashes);
        
        HRESULT ( STDMETHODCALLTYPE *GetStrokeDashCap )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__out XPS_DASH_CAP *strokeDashCap);
        
        HRESULT ( STDMETHODCALLTYPE *SetStrokeDashCap )( 
            __RPC__in IXpsOMPath * This,
            /* [in] */ XPS_DASH_CAP strokeDashCap);
        
        HRESULT ( STDMETHODCALLTYPE *GetStrokeDashOffset )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__out FLOAT *strokeDashOffset);
        
        HRESULT ( STDMETHODCALLTYPE *SetStrokeDashOffset )( 
            __RPC__in IXpsOMPath * This,
            /* [in] */ FLOAT strokeDashOffset);
        
        HRESULT ( STDMETHODCALLTYPE *GetStrokeStartLineCap )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__out XPS_LINE_CAP *strokeStartLineCap);
        
        HRESULT ( STDMETHODCALLTYPE *SetStrokeStartLineCap )( 
            __RPC__in IXpsOMPath * This,
            /* [in] */ XPS_LINE_CAP strokeStartLineCap);
        
        HRESULT ( STDMETHODCALLTYPE *GetStrokeEndLineCap )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__out XPS_LINE_CAP *strokeEndLineCap);
        
        HRESULT ( STDMETHODCALLTYPE *SetStrokeEndLineCap )( 
            __RPC__in IXpsOMPath * This,
            /* [in] */ XPS_LINE_CAP strokeEndLineCap);
        
        HRESULT ( STDMETHODCALLTYPE *GetStrokeLineJoin )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__out XPS_LINE_JOIN *strokeLineJoin);
        
        HRESULT ( STDMETHODCALLTYPE *SetStrokeLineJoin )( 
            __RPC__in IXpsOMPath * This,
            /* [in] */ XPS_LINE_JOIN strokeLineJoin);
        
        HRESULT ( STDMETHODCALLTYPE *GetStrokeMiterLimit )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__out FLOAT *strokeMiterLimit);
        
        HRESULT ( STDMETHODCALLTYPE *SetStrokeMiterLimit )( 
            __RPC__in IXpsOMPath * This,
            /* [in] */ FLOAT strokeMiterLimit);
        
        HRESULT ( STDMETHODCALLTYPE *GetStrokeThickness )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__out FLOAT *strokeThickness);
        
        HRESULT ( STDMETHODCALLTYPE *SetStrokeThickness )( 
            __RPC__in IXpsOMPath * This,
            /* [in] */ FLOAT strokeThickness);
        
        HRESULT ( STDMETHODCALLTYPE *GetFillBrush )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMBrush **brush);
        
        HRESULT ( STDMETHODCALLTYPE *GetFillBrushLocal )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMBrush **brush);
        
        HRESULT ( STDMETHODCALLTYPE *SetFillBrushLocal )( 
            __RPC__in IXpsOMPath * This,
            /* [in] */ __RPC__in_opt IXpsOMBrush *brush);
        
        HRESULT ( STDMETHODCALLTYPE *GetFillBrushLookup )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *lookup);
        
        HRESULT ( STDMETHODCALLTYPE *SetFillBrushLookup )( 
            __RPC__in IXpsOMPath * This,
            /* [string][in] */ __RPC__in_string LPCWSTR lookup);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IXpsOMPath * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPath **path);
        
        END_INTERFACE
    } IXpsOMPathVtbl;

    interface IXpsOMPath
    {
        CONST_VTBL struct IXpsOMPathVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMPath_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMPath_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMPath_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMPath_GetOwner(This,owner)	\
    ( (This)->lpVtbl -> GetOwner(This,owner) ) 

#define IXpsOMPath_GetType(This,type)	\
    ( (This)->lpVtbl -> GetType(This,type) ) 


#define IXpsOMPath_GetTransform(This,matrixTransform)	\
    ( (This)->lpVtbl -> GetTransform(This,matrixTransform) ) 

#define IXpsOMPath_GetTransformLocal(This,matrixTransform)	\
    ( (This)->lpVtbl -> GetTransformLocal(This,matrixTransform) ) 

#define IXpsOMPath_SetTransformLocal(This,matrixTransform)	\
    ( (This)->lpVtbl -> SetTransformLocal(This,matrixTransform) ) 

#define IXpsOMPath_GetTransformLookup(This,key)	\
    ( (This)->lpVtbl -> GetTransformLookup(This,key) ) 

#define IXpsOMPath_SetTransformLookup(This,key)	\
    ( (This)->lpVtbl -> SetTransformLookup(This,key) ) 

#define IXpsOMPath_GetClipGeometry(This,clipGeometry)	\
    ( (This)->lpVtbl -> GetClipGeometry(This,clipGeometry) ) 

#define IXpsOMPath_GetClipGeometryLocal(This,clipGeometry)	\
    ( (This)->lpVtbl -> GetClipGeometryLocal(This,clipGeometry) ) 

#define IXpsOMPath_SetClipGeometryLocal(This,clipGeometry)	\
    ( (This)->lpVtbl -> SetClipGeometryLocal(This,clipGeometry) ) 

#define IXpsOMPath_GetClipGeometryLookup(This,key)	\
    ( (This)->lpVtbl -> GetClipGeometryLookup(This,key) ) 

#define IXpsOMPath_SetClipGeometryLookup(This,key)	\
    ( (This)->lpVtbl -> SetClipGeometryLookup(This,key) ) 

#define IXpsOMPath_GetOpacity(This,opacity)	\
    ( (This)->lpVtbl -> GetOpacity(This,opacity) ) 

#define IXpsOMPath_SetOpacity(This,opacity)	\
    ( (This)->lpVtbl -> SetOpacity(This,opacity) ) 

#define IXpsOMPath_GetOpacityMaskBrush(This,opacityMaskBrush)	\
    ( (This)->lpVtbl -> GetOpacityMaskBrush(This,opacityMaskBrush) ) 

#define IXpsOMPath_GetOpacityMaskBrushLocal(This,opacityMaskBrush)	\
    ( (This)->lpVtbl -> GetOpacityMaskBrushLocal(This,opacityMaskBrush) ) 

#define IXpsOMPath_SetOpacityMaskBrushLocal(This,opacityMaskBrush)	\
    ( (This)->lpVtbl -> SetOpacityMaskBrushLocal(This,opacityMaskBrush) ) 

#define IXpsOMPath_GetOpacityMaskBrushLookup(This,key)	\
    ( (This)->lpVtbl -> GetOpacityMaskBrushLookup(This,key) ) 

#define IXpsOMPath_SetOpacityMaskBrushLookup(This,key)	\
    ( (This)->lpVtbl -> SetOpacityMaskBrushLookup(This,key) ) 

#define IXpsOMPath_GetName(This,name)	\
    ( (This)->lpVtbl -> GetName(This,name) ) 

#define IXpsOMPath_SetName(This,name)	\
    ( (This)->lpVtbl -> SetName(This,name) ) 

#define IXpsOMPath_GetIsHyperlinkTarget(This,isHyperlink)	\
    ( (This)->lpVtbl -> GetIsHyperlinkTarget(This,isHyperlink) ) 

#define IXpsOMPath_SetIsHyperlinkTarget(This,isHyperlink)	\
    ( (This)->lpVtbl -> SetIsHyperlinkTarget(This,isHyperlink) ) 

#define IXpsOMPath_GetHyperlinkNavigateUri(This,hyperlinkUri)	\
    ( (This)->lpVtbl -> GetHyperlinkNavigateUri(This,hyperlinkUri) ) 

#define IXpsOMPath_SetHyperlinkNavigateUri(This,hyperlinkUri)	\
    ( (This)->lpVtbl -> SetHyperlinkNavigateUri(This,hyperlinkUri) ) 

#define IXpsOMPath_GetLanguage(This,language)	\
    ( (This)->lpVtbl -> GetLanguage(This,language) ) 

#define IXpsOMPath_SetLanguage(This,language)	\
    ( (This)->lpVtbl -> SetLanguage(This,language) ) 


#define IXpsOMPath_GetGeometry(This,geometry)	\
    ( (This)->lpVtbl -> GetGeometry(This,geometry) ) 

#define IXpsOMPath_GetGeometryLocal(This,geometry)	\
    ( (This)->lpVtbl -> GetGeometryLocal(This,geometry) ) 

#define IXpsOMPath_SetGeometryLocal(This,geometry)	\
    ( (This)->lpVtbl -> SetGeometryLocal(This,geometry) ) 

#define IXpsOMPath_GetGeometryLookup(This,lookup)	\
    ( (This)->lpVtbl -> GetGeometryLookup(This,lookup) ) 

#define IXpsOMPath_SetGeometryLookup(This,lookup)	\
    ( (This)->lpVtbl -> SetGeometryLookup(This,lookup) ) 

#define IXpsOMPath_GetAccessibilityShortDescription(This,shortDescription)	\
    ( (This)->lpVtbl -> GetAccessibilityShortDescription(This,shortDescription) ) 

#define IXpsOMPath_SetAccessibilityShortDescription(This,shortDescription)	\
    ( (This)->lpVtbl -> SetAccessibilityShortDescription(This,shortDescription) ) 

#define IXpsOMPath_GetAccessibilityLongDescription(This,longDescription)	\
    ( (This)->lpVtbl -> GetAccessibilityLongDescription(This,longDescription) ) 

#define IXpsOMPath_SetAccessibilityLongDescription(This,longDescription)	\
    ( (This)->lpVtbl -> SetAccessibilityLongDescription(This,longDescription) ) 

#define IXpsOMPath_GetSnapsToPixels(This,snapsToPixels)	\
    ( (This)->lpVtbl -> GetSnapsToPixels(This,snapsToPixels) ) 

#define IXpsOMPath_SetSnapsToPixels(This,snapsToPixels)	\
    ( (This)->lpVtbl -> SetSnapsToPixels(This,snapsToPixels) ) 

#define IXpsOMPath_GetStrokeBrush(This,brush)	\
    ( (This)->lpVtbl -> GetStrokeBrush(This,brush) ) 

#define IXpsOMPath_GetStrokeBrushLocal(This,brush)	\
    ( (This)->lpVtbl -> GetStrokeBrushLocal(This,brush) ) 

#define IXpsOMPath_SetStrokeBrushLocal(This,brush)	\
    ( (This)->lpVtbl -> SetStrokeBrushLocal(This,brush) ) 

#define IXpsOMPath_GetStrokeBrushLookup(This,lookup)	\
    ( (This)->lpVtbl -> GetStrokeBrushLookup(This,lookup) ) 

#define IXpsOMPath_SetStrokeBrushLookup(This,lookup)	\
    ( (This)->lpVtbl -> SetStrokeBrushLookup(This,lookup) ) 

#define IXpsOMPath_GetStrokeDashes(This,strokeDashes)	\
    ( (This)->lpVtbl -> GetStrokeDashes(This,strokeDashes) ) 

#define IXpsOMPath_GetStrokeDashCap(This,strokeDashCap)	\
    ( (This)->lpVtbl -> GetStrokeDashCap(This,strokeDashCap) ) 

#define IXpsOMPath_SetStrokeDashCap(This,strokeDashCap)	\
    ( (This)->lpVtbl -> SetStrokeDashCap(This,strokeDashCap) ) 

#define IXpsOMPath_GetStrokeDashOffset(This,strokeDashOffset)	\
    ( (This)->lpVtbl -> GetStrokeDashOffset(This,strokeDashOffset) ) 

#define IXpsOMPath_SetStrokeDashOffset(This,strokeDashOffset)	\
    ( (This)->lpVtbl -> SetStrokeDashOffset(This,strokeDashOffset) ) 

#define IXpsOMPath_GetStrokeStartLineCap(This,strokeStartLineCap)	\
    ( (This)->lpVtbl -> GetStrokeStartLineCap(This,strokeStartLineCap) ) 

#define IXpsOMPath_SetStrokeStartLineCap(This,strokeStartLineCap)	\
    ( (This)->lpVtbl -> SetStrokeStartLineCap(This,strokeStartLineCap) ) 

#define IXpsOMPath_GetStrokeEndLineCap(This,strokeEndLineCap)	\
    ( (This)->lpVtbl -> GetStrokeEndLineCap(This,strokeEndLineCap) ) 

#define IXpsOMPath_SetStrokeEndLineCap(This,strokeEndLineCap)	\
    ( (This)->lpVtbl -> SetStrokeEndLineCap(This,strokeEndLineCap) ) 

#define IXpsOMPath_GetStrokeLineJoin(This,strokeLineJoin)	\
    ( (This)->lpVtbl -> GetStrokeLineJoin(This,strokeLineJoin) ) 

#define IXpsOMPath_SetStrokeLineJoin(This,strokeLineJoin)	\
    ( (This)->lpVtbl -> SetStrokeLineJoin(This,strokeLineJoin) ) 

#define IXpsOMPath_GetStrokeMiterLimit(This,strokeMiterLimit)	\
    ( (This)->lpVtbl -> GetStrokeMiterLimit(This,strokeMiterLimit) ) 

#define IXpsOMPath_SetStrokeMiterLimit(This,strokeMiterLimit)	\
    ( (This)->lpVtbl -> SetStrokeMiterLimit(This,strokeMiterLimit) ) 

#define IXpsOMPath_GetStrokeThickness(This,strokeThickness)	\
    ( (This)->lpVtbl -> GetStrokeThickness(This,strokeThickness) ) 

#define IXpsOMPath_SetStrokeThickness(This,strokeThickness)	\
    ( (This)->lpVtbl -> SetStrokeThickness(This,strokeThickness) ) 

#define IXpsOMPath_GetFillBrush(This,brush)	\
    ( (This)->lpVtbl -> GetFillBrush(This,brush) ) 

#define IXpsOMPath_GetFillBrushLocal(This,brush)	\
    ( (This)->lpVtbl -> GetFillBrushLocal(This,brush) ) 

#define IXpsOMPath_SetFillBrushLocal(This,brush)	\
    ( (This)->lpVtbl -> SetFillBrushLocal(This,brush) ) 

#define IXpsOMPath_GetFillBrushLookup(This,lookup)	\
    ( (This)->lpVtbl -> GetFillBrushLookup(This,lookup) ) 

#define IXpsOMPath_SetFillBrushLookup(This,lookup)	\
    ( (This)->lpVtbl -> SetFillBrushLookup(This,lookup) ) 

#define IXpsOMPath_Clone(This,path)	\
    ( (This)->lpVtbl -> Clone(This,path) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMPath_INTERFACE_DEFINED__ */


#ifndef __IXpsOMPartUriCollection_INTERFACE_DEFINED__
#define __IXpsOMPartUriCollection_INTERFACE_DEFINED__

/* interface IXpsOMPartUriCollection */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMPartUriCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("57C650D4-067C-4893-8C33-F62A0633730F")
    IXpsOMPartUriCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [retval][out] */ __RPC__out UINT32 *count) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IOpcPartUri **partUri) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertAt( 
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IOpcPartUri *partUri) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAt( 
            /* [in] */ UINT32 index) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAt( 
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IOpcPartUri *partUri) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Append( 
            /* [in] */ __RPC__in_opt IOpcPartUri *partUri) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMPartUriCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMPartUriCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMPartUriCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMPartUriCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IXpsOMPartUriCollection * This,
            /* [retval][out] */ __RPC__out UINT32 *count);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            __RPC__in IXpsOMPartUriCollection * This,
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IOpcPartUri **partUri);
        
        HRESULT ( STDMETHODCALLTYPE *InsertAt )( 
            __RPC__in IXpsOMPartUriCollection * This,
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IOpcPartUri *partUri);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
            __RPC__in IXpsOMPartUriCollection * This,
            /* [in] */ UINT32 index);
        
        HRESULT ( STDMETHODCALLTYPE *SetAt )( 
            __RPC__in IXpsOMPartUriCollection * This,
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IOpcPartUri *partUri);
        
        HRESULT ( STDMETHODCALLTYPE *Append )( 
            __RPC__in IXpsOMPartUriCollection * This,
            /* [in] */ __RPC__in_opt IOpcPartUri *partUri);
        
        END_INTERFACE
    } IXpsOMPartUriCollectionVtbl;

    interface IXpsOMPartUriCollection
    {
        CONST_VTBL struct IXpsOMPartUriCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMPartUriCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMPartUriCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMPartUriCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMPartUriCollection_GetCount(This,count)	\
    ( (This)->lpVtbl -> GetCount(This,count) ) 

#define IXpsOMPartUriCollection_GetAt(This,index,partUri)	\
    ( (This)->lpVtbl -> GetAt(This,index,partUri) ) 

#define IXpsOMPartUriCollection_InsertAt(This,index,partUri)	\
    ( (This)->lpVtbl -> InsertAt(This,index,partUri) ) 

#define IXpsOMPartUriCollection_RemoveAt(This,index)	\
    ( (This)->lpVtbl -> RemoveAt(This,index) ) 

#define IXpsOMPartUriCollection_SetAt(This,index,partUri)	\
    ( (This)->lpVtbl -> SetAt(This,index,partUri) ) 

#define IXpsOMPartUriCollection_Append(This,partUri)	\
    ( (This)->lpVtbl -> Append(This,partUri) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMPartUriCollection_INTERFACE_DEFINED__ */


#ifndef __IXpsOMRadialGradientBrush_INTERFACE_DEFINED__
#define __IXpsOMRadialGradientBrush_INTERFACE_DEFINED__

/* interface IXpsOMRadialGradientBrush */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMRadialGradientBrush;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("75F207E5-08BF-413C-96B1-B82B4064176B")
    IXpsOMRadialGradientBrush : public IXpsOMGradientBrush
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCenter( 
            /* [retval][out] */ __RPC__out XPS_POINT *center) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCenter( 
            /* [in] */ __RPC__in const XPS_POINT *center) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRadiiSizes( 
            /* [retval][out] */ __RPC__out XPS_SIZE *radiiSizes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRadiiSizes( 
            /* [in] */ __RPC__in const XPS_SIZE *radiiSizes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGradientOrigin( 
            /* [retval][out] */ __RPC__out XPS_POINT *origin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetGradientOrigin( 
            /* [in] */ __RPC__in const XPS_POINT *origin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMRadialGradientBrush **radialGradientBrush) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMRadialGradientBrushVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMRadialGradientBrush * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMRadialGradientBrush * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **owner);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [retval][out] */ __RPC__out XPS_OBJECT_TYPE *type);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpacity )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [retval][out] */ __RPC__out FLOAT *opacity);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpacity )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [in] */ FLOAT opacity);
        
        HRESULT ( STDMETHODCALLTYPE *GetGradientStops )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMGradientStopCollection **gradientStops);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransform )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **transform);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransformLocal )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **transform);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransformLocal )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [in] */ __RPC__in_opt IXpsOMMatrixTransform *transform);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransformLookup )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *key);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransformLookup )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [string][in] */ __RPC__in_string LPCWSTR key);
        
        HRESULT ( STDMETHODCALLTYPE *GetSpreadMethod )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [retval][out] */ __RPC__out XPS_SPREAD_METHOD *spreadMethod);
        
        HRESULT ( STDMETHODCALLTYPE *SetSpreadMethod )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [in] */ XPS_SPREAD_METHOD spreadMethod);
        
        HRESULT ( STDMETHODCALLTYPE *GetColorInterpolationMode )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [retval][out] */ __RPC__out XPS_COLOR_INTERPOLATION *colorInterpolationMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetColorInterpolationMode )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [in] */ XPS_COLOR_INTERPOLATION colorInterpolationMode);
        
        HRESULT ( STDMETHODCALLTYPE *GetCenter )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [retval][out] */ __RPC__out XPS_POINT *center);
        
        HRESULT ( STDMETHODCALLTYPE *SetCenter )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [in] */ __RPC__in const XPS_POINT *center);
        
        HRESULT ( STDMETHODCALLTYPE *GetRadiiSizes )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [retval][out] */ __RPC__out XPS_SIZE *radiiSizes);
        
        HRESULT ( STDMETHODCALLTYPE *SetRadiiSizes )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [in] */ __RPC__in const XPS_SIZE *radiiSizes);
        
        HRESULT ( STDMETHODCALLTYPE *GetGradientOrigin )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [retval][out] */ __RPC__out XPS_POINT *origin);
        
        HRESULT ( STDMETHODCALLTYPE *SetGradientOrigin )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [in] */ __RPC__in const XPS_POINT *origin);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IXpsOMRadialGradientBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMRadialGradientBrush **radialGradientBrush);
        
        END_INTERFACE
    } IXpsOMRadialGradientBrushVtbl;

    interface IXpsOMRadialGradientBrush
    {
        CONST_VTBL struct IXpsOMRadialGradientBrushVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMRadialGradientBrush_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMRadialGradientBrush_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMRadialGradientBrush_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMRadialGradientBrush_GetOwner(This,owner)	\
    ( (This)->lpVtbl -> GetOwner(This,owner) ) 

#define IXpsOMRadialGradientBrush_GetType(This,type)	\
    ( (This)->lpVtbl -> GetType(This,type) ) 


#define IXpsOMRadialGradientBrush_GetOpacity(This,opacity)	\
    ( (This)->lpVtbl -> GetOpacity(This,opacity) ) 

#define IXpsOMRadialGradientBrush_SetOpacity(This,opacity)	\
    ( (This)->lpVtbl -> SetOpacity(This,opacity) ) 


#define IXpsOMRadialGradientBrush_GetGradientStops(This,gradientStops)	\
    ( (This)->lpVtbl -> GetGradientStops(This,gradientStops) ) 

#define IXpsOMRadialGradientBrush_GetTransform(This,transform)	\
    ( (This)->lpVtbl -> GetTransform(This,transform) ) 

#define IXpsOMRadialGradientBrush_GetTransformLocal(This,transform)	\
    ( (This)->lpVtbl -> GetTransformLocal(This,transform) ) 

#define IXpsOMRadialGradientBrush_SetTransformLocal(This,transform)	\
    ( (This)->lpVtbl -> SetTransformLocal(This,transform) ) 

#define IXpsOMRadialGradientBrush_GetTransformLookup(This,key)	\
    ( (This)->lpVtbl -> GetTransformLookup(This,key) ) 

#define IXpsOMRadialGradientBrush_SetTransformLookup(This,key)	\
    ( (This)->lpVtbl -> SetTransformLookup(This,key) ) 

#define IXpsOMRadialGradientBrush_GetSpreadMethod(This,spreadMethod)	\
    ( (This)->lpVtbl -> GetSpreadMethod(This,spreadMethod) ) 

#define IXpsOMRadialGradientBrush_SetSpreadMethod(This,spreadMethod)	\
    ( (This)->lpVtbl -> SetSpreadMethod(This,spreadMethod) ) 

#define IXpsOMRadialGradientBrush_GetColorInterpolationMode(This,colorInterpolationMode)	\
    ( (This)->lpVtbl -> GetColorInterpolationMode(This,colorInterpolationMode) ) 

#define IXpsOMRadialGradientBrush_SetColorInterpolationMode(This,colorInterpolationMode)	\
    ( (This)->lpVtbl -> SetColorInterpolationMode(This,colorInterpolationMode) ) 


#define IXpsOMRadialGradientBrush_GetCenter(This,center)	\
    ( (This)->lpVtbl -> GetCenter(This,center) ) 

#define IXpsOMRadialGradientBrush_SetCenter(This,center)	\
    ( (This)->lpVtbl -> SetCenter(This,center) ) 

#define IXpsOMRadialGradientBrush_GetRadiiSizes(This,radiiSizes)	\
    ( (This)->lpVtbl -> GetRadiiSizes(This,radiiSizes) ) 

#define IXpsOMRadialGradientBrush_SetRadiiSizes(This,radiiSizes)	\
    ( (This)->lpVtbl -> SetRadiiSizes(This,radiiSizes) ) 

#define IXpsOMRadialGradientBrush_GetGradientOrigin(This,origin)	\
    ( (This)->lpVtbl -> GetGradientOrigin(This,origin) ) 

#define IXpsOMRadialGradientBrush_SetGradientOrigin(This,origin)	\
    ( (This)->lpVtbl -> SetGradientOrigin(This,origin) ) 

#define IXpsOMRadialGradientBrush_Clone(This,radialGradientBrush)	\
    ( (This)->lpVtbl -> Clone(This,radialGradientBrush) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMRadialGradientBrush_INTERFACE_DEFINED__ */


#ifndef __IXpsOMRemoteDictionaryResource_INTERFACE_DEFINED__
#define __IXpsOMRemoteDictionaryResource_INTERFACE_DEFINED__

/* interface IXpsOMRemoteDictionaryResource */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMRemoteDictionaryResource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c9bd7cd4-e16a-4bf8-8c84-c950af7a3061")
    IXpsOMRemoteDictionaryResource : public IXpsOMResource
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDictionary( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDictionary **dictionary) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDictionary( 
            /* [in] */ __RPC__in_opt IXpsOMDictionary *dictionary) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMRemoteDictionaryResourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMRemoteDictionaryResource * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMRemoteDictionaryResource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMRemoteDictionaryResource * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPartName )( 
            __RPC__in IXpsOMRemoteDictionaryResource * This,
            /* [retval][out] */ __RPC__deref_out_opt IOpcPartUri **partUri);
        
        HRESULT ( STDMETHODCALLTYPE *SetPartName )( 
            __RPC__in IXpsOMRemoteDictionaryResource * This,
            /* [in] */ __RPC__in_opt IOpcPartUri *partUri);
        
        HRESULT ( STDMETHODCALLTYPE *GetDictionary )( 
            __RPC__in IXpsOMRemoteDictionaryResource * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDictionary **dictionary);
        
        HRESULT ( STDMETHODCALLTYPE *SetDictionary )( 
            __RPC__in IXpsOMRemoteDictionaryResource * This,
            /* [in] */ __RPC__in_opt IXpsOMDictionary *dictionary);
        
        END_INTERFACE
    } IXpsOMRemoteDictionaryResourceVtbl;

    interface IXpsOMRemoteDictionaryResource
    {
        CONST_VTBL struct IXpsOMRemoteDictionaryResourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMRemoteDictionaryResource_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMRemoteDictionaryResource_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMRemoteDictionaryResource_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMRemoteDictionaryResource_GetPartName(This,partUri)	\
    ( (This)->lpVtbl -> GetPartName(This,partUri) ) 

#define IXpsOMRemoteDictionaryResource_SetPartName(This,partUri)	\
    ( (This)->lpVtbl -> SetPartName(This,partUri) ) 



#define IXpsOMRemoteDictionaryResource_GetDictionary(This,dictionary)	\
    ( (This)->lpVtbl -> GetDictionary(This,dictionary) ) 

#define IXpsOMRemoteDictionaryResource_SetDictionary(This,dictionary)	\
    ( (This)->lpVtbl -> SetDictionary(This,dictionary) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMRemoteDictionaryResource_INTERFACE_DEFINED__ */


#ifndef __IXpsOMRemoteDictionaryResourceCollection_INTERFACE_DEFINED__
#define __IXpsOMRemoteDictionaryResourceCollection_INTERFACE_DEFINED__

/* interface IXpsOMRemoteDictionaryResourceCollection */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMRemoteDictionaryResourceCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5C38DB61-7FEC-464A-87BD-41E3BEF018BE")
    IXpsOMRemoteDictionaryResourceCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [retval][out] */ __RPC__out UINT32 *count) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMRemoteDictionaryResource **object) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertAt( 
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMRemoteDictionaryResource *object) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAt( 
            /* [in] */ UINT32 index) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAt( 
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMRemoteDictionaryResource *object) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Append( 
            /* [in] */ __RPC__in_opt IXpsOMRemoteDictionaryResource *object) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetByPartName( 
            /* [in] */ __RPC__in_opt IOpcPartUri *partName,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMRemoteDictionaryResource **remoteDictionaryResource) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMRemoteDictionaryResourceCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMRemoteDictionaryResourceCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMRemoteDictionaryResourceCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMRemoteDictionaryResourceCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IXpsOMRemoteDictionaryResourceCollection * This,
            /* [retval][out] */ __RPC__out UINT32 *count);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            __RPC__in IXpsOMRemoteDictionaryResourceCollection * This,
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMRemoteDictionaryResource **object);
        
        HRESULT ( STDMETHODCALLTYPE *InsertAt )( 
            __RPC__in IXpsOMRemoteDictionaryResourceCollection * This,
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMRemoteDictionaryResource *object);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
            __RPC__in IXpsOMRemoteDictionaryResourceCollection * This,
            /* [in] */ UINT32 index);
        
        HRESULT ( STDMETHODCALLTYPE *SetAt )( 
            __RPC__in IXpsOMRemoteDictionaryResourceCollection * This,
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMRemoteDictionaryResource *object);
        
        HRESULT ( STDMETHODCALLTYPE *Append )( 
            __RPC__in IXpsOMRemoteDictionaryResourceCollection * This,
            /* [in] */ __RPC__in_opt IXpsOMRemoteDictionaryResource *object);
        
        HRESULT ( STDMETHODCALLTYPE *GetByPartName )( 
            __RPC__in IXpsOMRemoteDictionaryResourceCollection * This,
            /* [in] */ __RPC__in_opt IOpcPartUri *partName,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMRemoteDictionaryResource **remoteDictionaryResource);
        
        END_INTERFACE
    } IXpsOMRemoteDictionaryResourceCollectionVtbl;

    interface IXpsOMRemoteDictionaryResourceCollection
    {
        CONST_VTBL struct IXpsOMRemoteDictionaryResourceCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMRemoteDictionaryResourceCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMRemoteDictionaryResourceCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMRemoteDictionaryResourceCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMRemoteDictionaryResourceCollection_GetCount(This,count)	\
    ( (This)->lpVtbl -> GetCount(This,count) ) 

#define IXpsOMRemoteDictionaryResourceCollection_GetAt(This,index,object)	\
    ( (This)->lpVtbl -> GetAt(This,index,object) ) 

#define IXpsOMRemoteDictionaryResourceCollection_InsertAt(This,index,object)	\
    ( (This)->lpVtbl -> InsertAt(This,index,object) ) 

#define IXpsOMRemoteDictionaryResourceCollection_RemoveAt(This,index)	\
    ( (This)->lpVtbl -> RemoveAt(This,index) ) 

#define IXpsOMRemoteDictionaryResourceCollection_SetAt(This,index,object)	\
    ( (This)->lpVtbl -> SetAt(This,index,object) ) 

#define IXpsOMRemoteDictionaryResourceCollection_Append(This,object)	\
    ( (This)->lpVtbl -> Append(This,object) ) 

#define IXpsOMRemoteDictionaryResourceCollection_GetByPartName(This,partName,remoteDictionaryResource)	\
    ( (This)->lpVtbl -> GetByPartName(This,partName,remoteDictionaryResource) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMRemoteDictionaryResourceCollection_INTERFACE_DEFINED__ */


#ifndef __IXpsOMDictionary_INTERFACE_DEFINED__
#define __IXpsOMDictionary_INTERFACE_DEFINED__

/* interface IXpsOMDictionary */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMDictionary;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("897C86B8-8EAF-4AE3-BDDE-56419FCF4236")
    IXpsOMDictionary : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOwner( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **owner) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [retval][out] */ __RPC__out UINT32 *count) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ UINT32 index,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *key,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMShareable **entry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetByKey( 
            /* [string][in] */ __RPC__in_string LPCWSTR key,
            /* [in] */ __RPC__in_opt IXpsOMShareable *beforeEntry,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMShareable **entry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIndex( 
            /* [in] */ __RPC__in_opt IXpsOMShareable *entry,
            /* [retval][out] */ __RPC__out UINT32 *index) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Append( 
            /* [string][in] */ __RPC__in_string LPCWSTR key,
            /* [in] */ __RPC__in_opt IXpsOMShareable *entry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertAt( 
            /* [in] */ UINT32 index,
            /* [string][in] */ __RPC__in_string LPCWSTR key,
            /* [in] */ __RPC__in_opt IXpsOMShareable *entry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAt( 
            /* [in] */ UINT32 index) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAt( 
            /* [in] */ UINT32 index,
            /* [string][in] */ __RPC__in_string LPCWSTR key,
            /* [in] */ __RPC__in_opt IXpsOMShareable *entry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDictionary **dictionary) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMDictionaryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMDictionary * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMDictionary * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMDictionary * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMDictionary * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **owner);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IXpsOMDictionary * This,
            /* [retval][out] */ __RPC__out UINT32 *count);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            __RPC__in IXpsOMDictionary * This,
            /* [in] */ UINT32 index,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *key,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMShareable **entry);
        
        HRESULT ( STDMETHODCALLTYPE *GetByKey )( 
            __RPC__in IXpsOMDictionary * This,
            /* [string][in] */ __RPC__in_string LPCWSTR key,
            /* [in] */ __RPC__in_opt IXpsOMShareable *beforeEntry,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMShareable **entry);
        
        HRESULT ( STDMETHODCALLTYPE *GetIndex )( 
            __RPC__in IXpsOMDictionary * This,
            /* [in] */ __RPC__in_opt IXpsOMShareable *entry,
            /* [retval][out] */ __RPC__out UINT32 *index);
        
        HRESULT ( STDMETHODCALLTYPE *Append )( 
            __RPC__in IXpsOMDictionary * This,
            /* [string][in] */ __RPC__in_string LPCWSTR key,
            /* [in] */ __RPC__in_opt IXpsOMShareable *entry);
        
        HRESULT ( STDMETHODCALLTYPE *InsertAt )( 
            __RPC__in IXpsOMDictionary * This,
            /* [in] */ UINT32 index,
            /* [string][in] */ __RPC__in_string LPCWSTR key,
            /* [in] */ __RPC__in_opt IXpsOMShareable *entry);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
            __RPC__in IXpsOMDictionary * This,
            /* [in] */ UINT32 index);
        
        HRESULT ( STDMETHODCALLTYPE *SetAt )( 
            __RPC__in IXpsOMDictionary * This,
            /* [in] */ UINT32 index,
            /* [string][in] */ __RPC__in_string LPCWSTR key,
            /* [in] */ __RPC__in_opt IXpsOMShareable *entry);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IXpsOMDictionary * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDictionary **dictionary);
        
        END_INTERFACE
    } IXpsOMDictionaryVtbl;

    interface IXpsOMDictionary
    {
        CONST_VTBL struct IXpsOMDictionaryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMDictionary_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMDictionary_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMDictionary_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMDictionary_GetOwner(This,owner)	\
    ( (This)->lpVtbl -> GetOwner(This,owner) ) 

#define IXpsOMDictionary_GetCount(This,count)	\
    ( (This)->lpVtbl -> GetCount(This,count) ) 

#define IXpsOMDictionary_GetAt(This,index,key,entry)	\
    ( (This)->lpVtbl -> GetAt(This,index,key,entry) ) 

#define IXpsOMDictionary_GetByKey(This,key,beforeEntry,entry)	\
    ( (This)->lpVtbl -> GetByKey(This,key,beforeEntry,entry) ) 

#define IXpsOMDictionary_GetIndex(This,entry,index)	\
    ( (This)->lpVtbl -> GetIndex(This,entry,index) ) 

#define IXpsOMDictionary_Append(This,key,entry)	\
    ( (This)->lpVtbl -> Append(This,key,entry) ) 

#define IXpsOMDictionary_InsertAt(This,index,key,entry)	\
    ( (This)->lpVtbl -> InsertAt(This,index,key,entry) ) 

#define IXpsOMDictionary_RemoveAt(This,index)	\
    ( (This)->lpVtbl -> RemoveAt(This,index) ) 

#define IXpsOMDictionary_SetAt(This,index,key,entry)	\
    ( (This)->lpVtbl -> SetAt(This,index,key,entry) ) 

#define IXpsOMDictionary_Clone(This,dictionary)	\
    ( (This)->lpVtbl -> Clone(This,dictionary) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMDictionary_INTERFACE_DEFINED__ */


#ifndef __IXpsOMSolidColorBrush_INTERFACE_DEFINED__
#define __IXpsOMSolidColorBrush_INTERFACE_DEFINED__

/* interface IXpsOMSolidColorBrush */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMSolidColorBrush;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A06F9F05-3BE9-4763-98A8-094FC672E488")
    IXpsOMSolidColorBrush : public IXpsOMBrush
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetColor( 
            /* [out] */ __RPC__out XPS_COLOR *color,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMColorProfileResource **colorProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetColor( 
            /* [in] */ __RPC__in const XPS_COLOR *color,
            /* [in] */ __RPC__in_opt IXpsOMColorProfileResource *colorProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMSolidColorBrush **solidColorBrush) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMSolidColorBrushVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMSolidColorBrush * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMSolidColorBrush * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMSolidColorBrush * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMSolidColorBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **owner);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            __RPC__in IXpsOMSolidColorBrush * This,
            /* [retval][out] */ __RPC__out XPS_OBJECT_TYPE *type);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpacity )( 
            __RPC__in IXpsOMSolidColorBrush * This,
            /* [retval][out] */ __RPC__out FLOAT *opacity);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpacity )( 
            __RPC__in IXpsOMSolidColorBrush * This,
            /* [in] */ FLOAT opacity);
        
        HRESULT ( STDMETHODCALLTYPE *GetColor )( 
            __RPC__in IXpsOMSolidColorBrush * This,
            /* [out] */ __RPC__out XPS_COLOR *color,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMColorProfileResource **colorProfile);
        
        HRESULT ( STDMETHODCALLTYPE *SetColor )( 
            __RPC__in IXpsOMSolidColorBrush * This,
            /* [in] */ __RPC__in const XPS_COLOR *color,
            /* [in] */ __RPC__in_opt IXpsOMColorProfileResource *colorProfile);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IXpsOMSolidColorBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMSolidColorBrush **solidColorBrush);
        
        END_INTERFACE
    } IXpsOMSolidColorBrushVtbl;

    interface IXpsOMSolidColorBrush
    {
        CONST_VTBL struct IXpsOMSolidColorBrushVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMSolidColorBrush_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMSolidColorBrush_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMSolidColorBrush_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMSolidColorBrush_GetOwner(This,owner)	\
    ( (This)->lpVtbl -> GetOwner(This,owner) ) 

#define IXpsOMSolidColorBrush_GetType(This,type)	\
    ( (This)->lpVtbl -> GetType(This,type) ) 


#define IXpsOMSolidColorBrush_GetOpacity(This,opacity)	\
    ( (This)->lpVtbl -> GetOpacity(This,opacity) ) 

#define IXpsOMSolidColorBrush_SetOpacity(This,opacity)	\
    ( (This)->lpVtbl -> SetOpacity(This,opacity) ) 


#define IXpsOMSolidColorBrush_GetColor(This,color,colorProfile)	\
    ( (This)->lpVtbl -> GetColor(This,color,colorProfile) ) 

#define IXpsOMSolidColorBrush_SetColor(This,color,colorProfile)	\
    ( (This)->lpVtbl -> SetColor(This,color,colorProfile) ) 

#define IXpsOMSolidColorBrush_Clone(This,solidColorBrush)	\
    ( (This)->lpVtbl -> Clone(This,solidColorBrush) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMSolidColorBrush_INTERFACE_DEFINED__ */


#ifndef __IXpsOMVisualBrush_INTERFACE_DEFINED__
#define __IXpsOMVisualBrush_INTERFACE_DEFINED__

/* interface IXpsOMVisualBrush */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMVisualBrush;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("97E294AF-5B37-46B4-8057-874D2F64119B")
    IXpsOMVisualBrush : public IXpsOMTileBrush
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetVisual( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMVisual **visual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVisualLocal( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMVisual **visual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVisualLocal( 
            /* [in] */ __RPC__in_opt IXpsOMVisual *visual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVisualLookup( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *lookup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVisualLookup( 
            /* [string][in] */ __RPC__in_string LPCWSTR lookup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMVisualBrush **visualBrush) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMVisualBrushVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMVisualBrush * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMVisualBrush * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **owner);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [retval][out] */ __RPC__out XPS_OBJECT_TYPE *type);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpacity )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [retval][out] */ __RPC__out FLOAT *opacity);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpacity )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [in] */ FLOAT opacity);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransform )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **transform);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransformLocal )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMMatrixTransform **transform);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransformLocal )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [in] */ __RPC__in_opt IXpsOMMatrixTransform *transform);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransformLookup )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *key);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransformLookup )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [string][in] */ __RPC__in_string LPCWSTR key);
        
        HRESULT ( STDMETHODCALLTYPE *GetViewbox )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [retval][out] */ __RPC__out XPS_RECT *viewbox);
        
        HRESULT ( STDMETHODCALLTYPE *SetViewbox )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [in] */ __RPC__in const XPS_RECT *viewbox);
        
        HRESULT ( STDMETHODCALLTYPE *GetViewport )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [retval][out] */ __RPC__out XPS_RECT *viewport);
        
        HRESULT ( STDMETHODCALLTYPE *SetViewport )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [in] */ __RPC__in const XPS_RECT *viewport);
        
        HRESULT ( STDMETHODCALLTYPE *GetTileMode )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [retval][out] */ __RPC__out XPS_TILE_MODE *tileMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetTileMode )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [in] */ XPS_TILE_MODE tileMode);
        
        HRESULT ( STDMETHODCALLTYPE *GetVisual )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMVisual **visual);
        
        HRESULT ( STDMETHODCALLTYPE *GetVisualLocal )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMVisual **visual);
        
        HRESULT ( STDMETHODCALLTYPE *SetVisualLocal )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [in] */ __RPC__in_opt IXpsOMVisual *visual);
        
        HRESULT ( STDMETHODCALLTYPE *GetVisualLookup )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *lookup);
        
        HRESULT ( STDMETHODCALLTYPE *SetVisualLookup )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [string][in] */ __RPC__in_string LPCWSTR lookup);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IXpsOMVisualBrush * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMVisualBrush **visualBrush);
        
        END_INTERFACE
    } IXpsOMVisualBrushVtbl;

    interface IXpsOMVisualBrush
    {
        CONST_VTBL struct IXpsOMVisualBrushVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMVisualBrush_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMVisualBrush_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMVisualBrush_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMVisualBrush_GetOwner(This,owner)	\
    ( (This)->lpVtbl -> GetOwner(This,owner) ) 

#define IXpsOMVisualBrush_GetType(This,type)	\
    ( (This)->lpVtbl -> GetType(This,type) ) 


#define IXpsOMVisualBrush_GetOpacity(This,opacity)	\
    ( (This)->lpVtbl -> GetOpacity(This,opacity) ) 

#define IXpsOMVisualBrush_SetOpacity(This,opacity)	\
    ( (This)->lpVtbl -> SetOpacity(This,opacity) ) 


#define IXpsOMVisualBrush_GetTransform(This,transform)	\
    ( (This)->lpVtbl -> GetTransform(This,transform) ) 

#define IXpsOMVisualBrush_GetTransformLocal(This,transform)	\
    ( (This)->lpVtbl -> GetTransformLocal(This,transform) ) 

#define IXpsOMVisualBrush_SetTransformLocal(This,transform)	\
    ( (This)->lpVtbl -> SetTransformLocal(This,transform) ) 

#define IXpsOMVisualBrush_GetTransformLookup(This,key)	\
    ( (This)->lpVtbl -> GetTransformLookup(This,key) ) 

#define IXpsOMVisualBrush_SetTransformLookup(This,key)	\
    ( (This)->lpVtbl -> SetTransformLookup(This,key) ) 

#define IXpsOMVisualBrush_GetViewbox(This,viewbox)	\
    ( (This)->lpVtbl -> GetViewbox(This,viewbox) ) 

#define IXpsOMVisualBrush_SetViewbox(This,viewbox)	\
    ( (This)->lpVtbl -> SetViewbox(This,viewbox) ) 

#define IXpsOMVisualBrush_GetViewport(This,viewport)	\
    ( (This)->lpVtbl -> GetViewport(This,viewport) ) 

#define IXpsOMVisualBrush_SetViewport(This,viewport)	\
    ( (This)->lpVtbl -> SetViewport(This,viewport) ) 

#define IXpsOMVisualBrush_GetTileMode(This,tileMode)	\
    ( (This)->lpVtbl -> GetTileMode(This,tileMode) ) 

#define IXpsOMVisualBrush_SetTileMode(This,tileMode)	\
    ( (This)->lpVtbl -> SetTileMode(This,tileMode) ) 


#define IXpsOMVisualBrush_GetVisual(This,visual)	\
    ( (This)->lpVtbl -> GetVisual(This,visual) ) 

#define IXpsOMVisualBrush_GetVisualLocal(This,visual)	\
    ( (This)->lpVtbl -> GetVisualLocal(This,visual) ) 

#define IXpsOMVisualBrush_SetVisualLocal(This,visual)	\
    ( (This)->lpVtbl -> SetVisualLocal(This,visual) ) 

#define IXpsOMVisualBrush_GetVisualLookup(This,lookup)	\
    ( (This)->lpVtbl -> GetVisualLookup(This,lookup) ) 

#define IXpsOMVisualBrush_SetVisualLookup(This,lookup)	\
    ( (This)->lpVtbl -> SetVisualLookup(This,lookup) ) 

#define IXpsOMVisualBrush_Clone(This,visualBrush)	\
    ( (This)->lpVtbl -> Clone(This,visualBrush) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMVisualBrush_INTERFACE_DEFINED__ */


#ifndef __IXpsOMVisualCollection_INTERFACE_DEFINED__
#define __IXpsOMVisualCollection_INTERFACE_DEFINED__

/* interface IXpsOMVisualCollection */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IXpsOMVisualCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("94D8ABDE-AB91-46A8-82B7-F5B05EF01A96")
    IXpsOMVisualCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [retval][out] */ __RPC__out UINT32 *count) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMVisual **object) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertAt( 
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMVisual *object) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAt( 
            /* [in] */ UINT32 index) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAt( 
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMVisual *object) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Append( 
            /* [in] */ __RPC__in_opt IXpsOMVisual *object) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMVisualCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMVisualCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMVisualCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMVisualCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IXpsOMVisualCollection * This,
            /* [retval][out] */ __RPC__out UINT32 *count);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            __RPC__in IXpsOMVisualCollection * This,
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMVisual **object);
        
        HRESULT ( STDMETHODCALLTYPE *InsertAt )( 
            __RPC__in IXpsOMVisualCollection * This,
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMVisual *object);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
            __RPC__in IXpsOMVisualCollection * This,
            /* [in] */ UINT32 index);
        
        HRESULT ( STDMETHODCALLTYPE *SetAt )( 
            __RPC__in IXpsOMVisualCollection * This,
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMVisual *object);
        
        HRESULT ( STDMETHODCALLTYPE *Append )( 
            __RPC__in IXpsOMVisualCollection * This,
            /* [in] */ __RPC__in_opt IXpsOMVisual *object);
        
        END_INTERFACE
    } IXpsOMVisualCollectionVtbl;

    interface IXpsOMVisualCollection
    {
        CONST_VTBL struct IXpsOMVisualCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMVisualCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMVisualCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMVisualCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMVisualCollection_GetCount(This,count)	\
    ( (This)->lpVtbl -> GetCount(This,count) ) 

#define IXpsOMVisualCollection_GetAt(This,index,object)	\
    ( (This)->lpVtbl -> GetAt(This,index,object) ) 

#define IXpsOMVisualCollection_InsertAt(This,index,object)	\
    ( (This)->lpVtbl -> InsertAt(This,index,object) ) 

#define IXpsOMVisualCollection_RemoveAt(This,index)	\
    ( (This)->lpVtbl -> RemoveAt(This,index) ) 

#define IXpsOMVisualCollection_SetAt(This,index,object)	\
    ( (This)->lpVtbl -> SetAt(This,index,object) ) 

#define IXpsOMVisualCollection_Append(This,object)	\
    ( (This)->lpVtbl -> Append(This,object) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMVisualCollection_INTERFACE_DEFINED__ */


#ifndef __IXpsOMPageReference_INTERFACE_DEFINED__
#define __IXpsOMPageReference_INTERFACE_DEFINED__

/* interface IXpsOMPageReference */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IXpsOMPageReference;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ED360180-6F92-4998-890D-2F208531A0A0")
    IXpsOMPageReference : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetOwner( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDocument **document) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPage( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPage **page) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetPage( 
            /* [in] */ __RPC__in_opt IXpsOMPage *page) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DiscardPage( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsPageLoaded( 
            /* [retval][out] */ __RPC__out BOOL *isPageLoaded) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAdvisoryPageDimensions( 
            /* [retval][out] */ __RPC__out XPS_SIZE *pageDimensions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAdvisoryPageDimensions( 
            /* [in] */ __RPC__in const XPS_SIZE *pageDimensions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStoryFragmentsResource( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMStoryFragmentsResource **storyFragmentsResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStoryFragmentsResource( 
            /* [in] */ __RPC__in_opt IXpsOMStoryFragmentsResource *storyFragmentsResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPrintTicketResource( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPrintTicketResource **printTicketResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPrintTicketResource( 
            /* [in] */ __RPC__in_opt IXpsOMPrintTicketResource *printTicketResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThumbnailResource( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMImageResource **imageResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetThumbnailResource( 
            /* [in] */ __RPC__in_opt IXpsOMImageResource *imageResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CollectLinkTargets( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMNameCollection **linkTargets) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CollectPartResources( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPartResources **partResources) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HasRestrictedFonts( 
            /* [retval][out] */ __RPC__out BOOL *restrictedFonts) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPageReference **pageReference) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMPageReferenceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMPageReference * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMPageReference * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMPageReference * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMPageReference * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDocument **document);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPage )( 
            __RPC__in IXpsOMPageReference * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPage **page);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetPage )( 
            __RPC__in IXpsOMPageReference * This,
            /* [in] */ __RPC__in_opt IXpsOMPage *page);
        
        HRESULT ( STDMETHODCALLTYPE *DiscardPage )( 
            __RPC__in IXpsOMPageReference * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsPageLoaded )( 
            __RPC__in IXpsOMPageReference * This,
            /* [retval][out] */ __RPC__out BOOL *isPageLoaded);
        
        HRESULT ( STDMETHODCALLTYPE *GetAdvisoryPageDimensions )( 
            __RPC__in IXpsOMPageReference * This,
            /* [retval][out] */ __RPC__out XPS_SIZE *pageDimensions);
        
        HRESULT ( STDMETHODCALLTYPE *SetAdvisoryPageDimensions )( 
            __RPC__in IXpsOMPageReference * This,
            /* [in] */ __RPC__in const XPS_SIZE *pageDimensions);
        
        HRESULT ( STDMETHODCALLTYPE *GetStoryFragmentsResource )( 
            __RPC__in IXpsOMPageReference * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMStoryFragmentsResource **storyFragmentsResource);
        
        HRESULT ( STDMETHODCALLTYPE *SetStoryFragmentsResource )( 
            __RPC__in IXpsOMPageReference * This,
            /* [in] */ __RPC__in_opt IXpsOMStoryFragmentsResource *storyFragmentsResource);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrintTicketResource )( 
            __RPC__in IXpsOMPageReference * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPrintTicketResource **printTicketResource);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrintTicketResource )( 
            __RPC__in IXpsOMPageReference * This,
            /* [in] */ __RPC__in_opt IXpsOMPrintTicketResource *printTicketResource);
        
        HRESULT ( STDMETHODCALLTYPE *GetThumbnailResource )( 
            __RPC__in IXpsOMPageReference * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMImageResource **imageResource);
        
        HRESULT ( STDMETHODCALLTYPE *SetThumbnailResource )( 
            __RPC__in IXpsOMPageReference * This,
            /* [in] */ __RPC__in_opt IXpsOMImageResource *imageResource);
        
        HRESULT ( STDMETHODCALLTYPE *CollectLinkTargets )( 
            __RPC__in IXpsOMPageReference * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMNameCollection **linkTargets);
        
        HRESULT ( STDMETHODCALLTYPE *CollectPartResources )( 
            __RPC__in IXpsOMPageReference * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPartResources **partResources);
        
        HRESULT ( STDMETHODCALLTYPE *HasRestrictedFonts )( 
            __RPC__in IXpsOMPageReference * This,
            /* [retval][out] */ __RPC__out BOOL *restrictedFonts);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IXpsOMPageReference * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPageReference **pageReference);
        
        END_INTERFACE
    } IXpsOMPageReferenceVtbl;

    interface IXpsOMPageReference
    {
        CONST_VTBL struct IXpsOMPageReferenceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMPageReference_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMPageReference_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMPageReference_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMPageReference_GetOwner(This,document)	\
    ( (This)->lpVtbl -> GetOwner(This,document) ) 

#define IXpsOMPageReference_GetPage(This,page)	\
    ( (This)->lpVtbl -> GetPage(This,page) ) 

#define IXpsOMPageReference_SetPage(This,page)	\
    ( (This)->lpVtbl -> SetPage(This,page) ) 

#define IXpsOMPageReference_DiscardPage(This)	\
    ( (This)->lpVtbl -> DiscardPage(This) ) 

#define IXpsOMPageReference_IsPageLoaded(This,isPageLoaded)	\
    ( (This)->lpVtbl -> IsPageLoaded(This,isPageLoaded) ) 

#define IXpsOMPageReference_GetAdvisoryPageDimensions(This,pageDimensions)	\
    ( (This)->lpVtbl -> GetAdvisoryPageDimensions(This,pageDimensions) ) 

#define IXpsOMPageReference_SetAdvisoryPageDimensions(This,pageDimensions)	\
    ( (This)->lpVtbl -> SetAdvisoryPageDimensions(This,pageDimensions) ) 

#define IXpsOMPageReference_GetStoryFragmentsResource(This,storyFragmentsResource)	\
    ( (This)->lpVtbl -> GetStoryFragmentsResource(This,storyFragmentsResource) ) 

#define IXpsOMPageReference_SetStoryFragmentsResource(This,storyFragmentsResource)	\
    ( (This)->lpVtbl -> SetStoryFragmentsResource(This,storyFragmentsResource) ) 

#define IXpsOMPageReference_GetPrintTicketResource(This,printTicketResource)	\
    ( (This)->lpVtbl -> GetPrintTicketResource(This,printTicketResource) ) 

#define IXpsOMPageReference_SetPrintTicketResource(This,printTicketResource)	\
    ( (This)->lpVtbl -> SetPrintTicketResource(This,printTicketResource) ) 

#define IXpsOMPageReference_GetThumbnailResource(This,imageResource)	\
    ( (This)->lpVtbl -> GetThumbnailResource(This,imageResource) ) 

#define IXpsOMPageReference_SetThumbnailResource(This,imageResource)	\
    ( (This)->lpVtbl -> SetThumbnailResource(This,imageResource) ) 

#define IXpsOMPageReference_CollectLinkTargets(This,linkTargets)	\
    ( (This)->lpVtbl -> CollectLinkTargets(This,linkTargets) ) 

#define IXpsOMPageReference_CollectPartResources(This,partResources)	\
    ( (This)->lpVtbl -> CollectPartResources(This,partResources) ) 

#define IXpsOMPageReference_HasRestrictedFonts(This,restrictedFonts)	\
    ( (This)->lpVtbl -> HasRestrictedFonts(This,restrictedFonts) ) 

#define IXpsOMPageReference_Clone(This,pageReference)	\
    ( (This)->lpVtbl -> Clone(This,pageReference) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMPageReference_INTERFACE_DEFINED__ */


#ifndef __IXpsOMDocumentSequence_INTERFACE_DEFINED__
#define __IXpsOMDocumentSequence_INTERFACE_DEFINED__

/* interface IXpsOMDocumentSequence */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IXpsOMDocumentSequence;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56492EB4-D8D5-425e-8256-4C2B64AD0264")
    IXpsOMDocumentSequence : public IXpsOMPart
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOwner( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPackage **package) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDocuments( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDocumentCollection **documents) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPrintTicketResource( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPrintTicketResource **printTicketResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPrintTicketResource( 
            /* [in] */ __RPC__in_opt IXpsOMPrintTicketResource *printTicketResource) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMDocumentSequenceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMDocumentSequence * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMDocumentSequence * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMDocumentSequence * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPartName )( 
            __RPC__in IXpsOMDocumentSequence * This,
            /* [retval][out] */ __RPC__deref_out_opt IOpcPartUri **partUri);
        
        HRESULT ( STDMETHODCALLTYPE *SetPartName )( 
            __RPC__in IXpsOMDocumentSequence * This,
            /* [in] */ __RPC__in_opt IOpcPartUri *partUri);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMDocumentSequence * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPackage **package);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDocuments )( 
            __RPC__in IXpsOMDocumentSequence * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDocumentCollection **documents);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrintTicketResource )( 
            __RPC__in IXpsOMDocumentSequence * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPrintTicketResource **printTicketResource);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrintTicketResource )( 
            __RPC__in IXpsOMDocumentSequence * This,
            /* [in] */ __RPC__in_opt IXpsOMPrintTicketResource *printTicketResource);
        
        END_INTERFACE
    } IXpsOMDocumentSequenceVtbl;

    interface IXpsOMDocumentSequence
    {
        CONST_VTBL struct IXpsOMDocumentSequenceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMDocumentSequence_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMDocumentSequence_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMDocumentSequence_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMDocumentSequence_GetPartName(This,partUri)	\
    ( (This)->lpVtbl -> GetPartName(This,partUri) ) 

#define IXpsOMDocumentSequence_SetPartName(This,partUri)	\
    ( (This)->lpVtbl -> SetPartName(This,partUri) ) 


#define IXpsOMDocumentSequence_GetOwner(This,package)	\
    ( (This)->lpVtbl -> GetOwner(This,package) ) 

#define IXpsOMDocumentSequence_GetDocuments(This,documents)	\
    ( (This)->lpVtbl -> GetDocuments(This,documents) ) 

#define IXpsOMDocumentSequence_GetPrintTicketResource(This,printTicketResource)	\
    ( (This)->lpVtbl -> GetPrintTicketResource(This,printTicketResource) ) 

#define IXpsOMDocumentSequence_SetPrintTicketResource(This,printTicketResource)	\
    ( (This)->lpVtbl -> SetPrintTicketResource(This,printTicketResource) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMDocumentSequence_INTERFACE_DEFINED__ */


#ifndef __IXpsOMSignatureBlockResource_INTERFACE_DEFINED__
#define __IXpsOMSignatureBlockResource_INTERFACE_DEFINED__

/* interface IXpsOMSignatureBlockResource */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IXpsOMSignatureBlockResource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4776ad35-2e04-4357-8743-ebf6c171a905")
    IXpsOMSignatureBlockResource : public IXpsOMResource
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOwner( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDocument **owner) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStream( 
            /* [retval][out] */ __RPC__deref_out_opt IStream **stream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContent( 
            /* [in] */ __RPC__in_opt IStream *sourceStream,
            /* [in] */ __RPC__in_opt IOpcPartUri *partName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMSignatureBlockResourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMSignatureBlockResource * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMSignatureBlockResource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMSignatureBlockResource * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPartName )( 
            __RPC__in IXpsOMSignatureBlockResource * This,
            /* [retval][out] */ __RPC__deref_out_opt IOpcPartUri **partUri);
        
        HRESULT ( STDMETHODCALLTYPE *SetPartName )( 
            __RPC__in IXpsOMSignatureBlockResource * This,
            /* [in] */ __RPC__in_opt IOpcPartUri *partUri);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMSignatureBlockResource * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDocument **owner);
        
        HRESULT ( STDMETHODCALLTYPE *GetStream )( 
            __RPC__in IXpsOMSignatureBlockResource * This,
            /* [retval][out] */ __RPC__deref_out_opt IStream **stream);
        
        HRESULT ( STDMETHODCALLTYPE *SetContent )( 
            __RPC__in IXpsOMSignatureBlockResource * This,
            /* [in] */ __RPC__in_opt IStream *sourceStream,
            /* [in] */ __RPC__in_opt IOpcPartUri *partName);
        
        END_INTERFACE
    } IXpsOMSignatureBlockResourceVtbl;

    interface IXpsOMSignatureBlockResource
    {
        CONST_VTBL struct IXpsOMSignatureBlockResourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMSignatureBlockResource_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMSignatureBlockResource_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMSignatureBlockResource_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMSignatureBlockResource_GetPartName(This,partUri)	\
    ( (This)->lpVtbl -> GetPartName(This,partUri) ) 

#define IXpsOMSignatureBlockResource_SetPartName(This,partUri)	\
    ( (This)->lpVtbl -> SetPartName(This,partUri) ) 



#define IXpsOMSignatureBlockResource_GetOwner(This,owner)	\
    ( (This)->lpVtbl -> GetOwner(This,owner) ) 

#define IXpsOMSignatureBlockResource_GetStream(This,stream)	\
    ( (This)->lpVtbl -> GetStream(This,stream) ) 

#define IXpsOMSignatureBlockResource_SetContent(This,sourceStream,partName)	\
    ( (This)->lpVtbl -> SetContent(This,sourceStream,partName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMSignatureBlockResource_INTERFACE_DEFINED__ */


#ifndef __IXpsOMSignatureBlockResourceCollection_INTERFACE_DEFINED__
#define __IXpsOMSignatureBlockResourceCollection_INTERFACE_DEFINED__

/* interface IXpsOMSignatureBlockResourceCollection */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMSignatureBlockResourceCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AB8F5D8E-351B-4D33-AAED-FA56F0022931")
    IXpsOMSignatureBlockResourceCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [retval][out] */ __RPC__out UINT32 *count) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMSignatureBlockResource **signatureBlockResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertAt( 
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMSignatureBlockResource *signatureBlockResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAt( 
            /* [in] */ UINT32 index) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAt( 
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMSignatureBlockResource *signatureBlockResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Append( 
            /* [in] */ __RPC__in_opt IXpsOMSignatureBlockResource *signatureBlockResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetByPartName( 
            /* [in] */ __RPC__in_opt IOpcPartUri *partName,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMSignatureBlockResource **signatureBlockResource) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMSignatureBlockResourceCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMSignatureBlockResourceCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMSignatureBlockResourceCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMSignatureBlockResourceCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IXpsOMSignatureBlockResourceCollection * This,
            /* [retval][out] */ __RPC__out UINT32 *count);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            __RPC__in IXpsOMSignatureBlockResourceCollection * This,
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMSignatureBlockResource **signatureBlockResource);
        
        HRESULT ( STDMETHODCALLTYPE *InsertAt )( 
            __RPC__in IXpsOMSignatureBlockResourceCollection * This,
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMSignatureBlockResource *signatureBlockResource);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
            __RPC__in IXpsOMSignatureBlockResourceCollection * This,
            /* [in] */ UINT32 index);
        
        HRESULT ( STDMETHODCALLTYPE *SetAt )( 
            __RPC__in IXpsOMSignatureBlockResourceCollection * This,
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMSignatureBlockResource *signatureBlockResource);
        
        HRESULT ( STDMETHODCALLTYPE *Append )( 
            __RPC__in IXpsOMSignatureBlockResourceCollection * This,
            /* [in] */ __RPC__in_opt IXpsOMSignatureBlockResource *signatureBlockResource);
        
        HRESULT ( STDMETHODCALLTYPE *GetByPartName )( 
            __RPC__in IXpsOMSignatureBlockResourceCollection * This,
            /* [in] */ __RPC__in_opt IOpcPartUri *partName,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMSignatureBlockResource **signatureBlockResource);
        
        END_INTERFACE
    } IXpsOMSignatureBlockResourceCollectionVtbl;

    interface IXpsOMSignatureBlockResourceCollection
    {
        CONST_VTBL struct IXpsOMSignatureBlockResourceCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMSignatureBlockResourceCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMSignatureBlockResourceCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMSignatureBlockResourceCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMSignatureBlockResourceCollection_GetCount(This,count)	\
    ( (This)->lpVtbl -> GetCount(This,count) ) 

#define IXpsOMSignatureBlockResourceCollection_GetAt(This,index,signatureBlockResource)	\
    ( (This)->lpVtbl -> GetAt(This,index,signatureBlockResource) ) 

#define IXpsOMSignatureBlockResourceCollection_InsertAt(This,index,signatureBlockResource)	\
    ( (This)->lpVtbl -> InsertAt(This,index,signatureBlockResource) ) 

#define IXpsOMSignatureBlockResourceCollection_RemoveAt(This,index)	\
    ( (This)->lpVtbl -> RemoveAt(This,index) ) 

#define IXpsOMSignatureBlockResourceCollection_SetAt(This,index,signatureBlockResource)	\
    ( (This)->lpVtbl -> SetAt(This,index,signatureBlockResource) ) 

#define IXpsOMSignatureBlockResourceCollection_Append(This,signatureBlockResource)	\
    ( (This)->lpVtbl -> Append(This,signatureBlockResource) ) 

#define IXpsOMSignatureBlockResourceCollection_GetByPartName(This,partName,signatureBlockResource)	\
    ( (This)->lpVtbl -> GetByPartName(This,partName,signatureBlockResource) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMSignatureBlockResourceCollection_INTERFACE_DEFINED__ */


#ifndef __IXpsOMNameCollection_INTERFACE_DEFINED__
#define __IXpsOMNameCollection_INTERFACE_DEFINED__

/* interface IXpsOMNameCollection */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMNameCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4BDDF8EC-C915-421B-A166-D173D25653D2")
    IXpsOMNameCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [retval][out] */ __RPC__out UINT32 *count) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ UINT32 index,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *name) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMNameCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMNameCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMNameCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMNameCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IXpsOMNameCollection * This,
            /* [retval][out] */ __RPC__out UINT32 *count);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            __RPC__in IXpsOMNameCollection * This,
            /* [in] */ UINT32 index,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *name);
        
        END_INTERFACE
    } IXpsOMNameCollectionVtbl;

    interface IXpsOMNameCollection
    {
        CONST_VTBL struct IXpsOMNameCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMNameCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMNameCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMNameCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMNameCollection_GetCount(This,count)	\
    ( (This)->lpVtbl -> GetCount(This,count) ) 

#define IXpsOMNameCollection_GetAt(This,index,name)	\
    ( (This)->lpVtbl -> GetAt(This,index,name) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMNameCollection_INTERFACE_DEFINED__ */


#ifndef __IXpsOMDocument_INTERFACE_DEFINED__
#define __IXpsOMDocument_INTERFACE_DEFINED__

/* interface IXpsOMDocument */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IXpsOMDocument;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2C2C94CB-AC5F-4254-8EE9-23948309D9F0")
    IXpsOMDocument : public IXpsOMPart
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOwner( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDocumentSequence **documentSequence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPageReferences( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPageReferenceCollection **pageReferences) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPrintTicketResource( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPrintTicketResource **printTicketResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPrintTicketResource( 
            /* [in] */ __RPC__in_opt IXpsOMPrintTicketResource *printTicketResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDocumentStructureResource( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDocumentStructureResource **documentStructureResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDocumentStructureResource( 
            /* [in] */ __RPC__in_opt IXpsOMDocumentStructureResource *documentStructureResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSignatureBlockResources( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMSignatureBlockResourceCollection **signatureBlockResources) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDocument **document) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMDocumentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMDocument * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMDocument * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMDocument * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPartName )( 
            __RPC__in IXpsOMDocument * This,
            /* [retval][out] */ __RPC__deref_out_opt IOpcPartUri **partUri);
        
        HRESULT ( STDMETHODCALLTYPE *SetPartName )( 
            __RPC__in IXpsOMDocument * This,
            /* [in] */ __RPC__in_opt IOpcPartUri *partUri);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMDocument * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDocumentSequence **documentSequence);
        
        HRESULT ( STDMETHODCALLTYPE *GetPageReferences )( 
            __RPC__in IXpsOMDocument * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPageReferenceCollection **pageReferences);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrintTicketResource )( 
            __RPC__in IXpsOMDocument * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPrintTicketResource **printTicketResource);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrintTicketResource )( 
            __RPC__in IXpsOMDocument * This,
            /* [in] */ __RPC__in_opt IXpsOMPrintTicketResource *printTicketResource);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocumentStructureResource )( 
            __RPC__in IXpsOMDocument * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDocumentStructureResource **documentStructureResource);
        
        HRESULT ( STDMETHODCALLTYPE *SetDocumentStructureResource )( 
            __RPC__in IXpsOMDocument * This,
            /* [in] */ __RPC__in_opt IXpsOMDocumentStructureResource *documentStructureResource);
        
        HRESULT ( STDMETHODCALLTYPE *GetSignatureBlockResources )( 
            __RPC__in IXpsOMDocument * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMSignatureBlockResourceCollection **signatureBlockResources);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IXpsOMDocument * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDocument **document);
        
        END_INTERFACE
    } IXpsOMDocumentVtbl;

    interface IXpsOMDocument
    {
        CONST_VTBL struct IXpsOMDocumentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMDocument_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMDocument_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMDocument_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMDocument_GetPartName(This,partUri)	\
    ( (This)->lpVtbl -> GetPartName(This,partUri) ) 

#define IXpsOMDocument_SetPartName(This,partUri)	\
    ( (This)->lpVtbl -> SetPartName(This,partUri) ) 


#define IXpsOMDocument_GetOwner(This,documentSequence)	\
    ( (This)->lpVtbl -> GetOwner(This,documentSequence) ) 

#define IXpsOMDocument_GetPageReferences(This,pageReferences)	\
    ( (This)->lpVtbl -> GetPageReferences(This,pageReferences) ) 

#define IXpsOMDocument_GetPrintTicketResource(This,printTicketResource)	\
    ( (This)->lpVtbl -> GetPrintTicketResource(This,printTicketResource) ) 

#define IXpsOMDocument_SetPrintTicketResource(This,printTicketResource)	\
    ( (This)->lpVtbl -> SetPrintTicketResource(This,printTicketResource) ) 

#define IXpsOMDocument_GetDocumentStructureResource(This,documentStructureResource)	\
    ( (This)->lpVtbl -> GetDocumentStructureResource(This,documentStructureResource) ) 

#define IXpsOMDocument_SetDocumentStructureResource(This,documentStructureResource)	\
    ( (This)->lpVtbl -> SetDocumentStructureResource(This,documentStructureResource) ) 

#define IXpsOMDocument_GetSignatureBlockResources(This,signatureBlockResources)	\
    ( (This)->lpVtbl -> GetSignatureBlockResources(This,signatureBlockResources) ) 

#define IXpsOMDocument_Clone(This,document)	\
    ( (This)->lpVtbl -> Clone(This,document) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMDocument_INTERFACE_DEFINED__ */


#ifndef __IXpsOMPage_INTERFACE_DEFINED__
#define __IXpsOMPage_INTERFACE_DEFINED__

/* interface IXpsOMPage */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IXpsOMPage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d3e18888-f120-4fee-8c68-35296eae91d4")
    IXpsOMPage : public IXpsOMPart
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOwner( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPageReference **pageReference) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVisuals( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMVisualCollection **visuals) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPageDimensions( 
            /* [retval][out] */ __RPC__out XPS_SIZE *pageDimensions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPageDimensions( 
            /* [in] */ __RPC__in const XPS_SIZE *pageDimensions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContentBox( 
            /* [retval][out] */ __RPC__out XPS_RECT *contentBox) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContentBox( 
            /* [in] */ __RPC__in const XPS_RECT *contentBox) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBleedBox( 
            /* [retval][out] */ __RPC__out XPS_RECT *bleedBox) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBleedBox( 
            /* [in] */ __RPC__in const XPS_RECT *bleedBox) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLanguage( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *language) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLanguage( 
            /* [string][in] */ __RPC__in_string LPCWSTR language) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *name) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [string][in] */ __RPC__in_string LPCWSTR name) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIsHyperlinkTarget( 
            /* [retval][out] */ __RPC__out BOOL *isHyperlinkTarget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIsHyperlinkTarget( 
            /* [in] */ BOOL isHyperlinkTarget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDictionary( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDictionary **resourceDictionary) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDictionaryLocal( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDictionary **resourceDictionary) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDictionaryLocal( 
            /* [in] */ __RPC__in_opt IXpsOMDictionary *resourceDictionary) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDictionaryResource( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMRemoteDictionaryResource **remoteDictionaryResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDictionaryResource( 
            /* [in] */ __RPC__in_opt IXpsOMRemoteDictionaryResource *remoteDictionaryResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Write( 
            /* [in] */ __RPC__in_opt ISequentialStream *stream,
            /* [in] */ BOOL optimizeMarkupSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GenerateUnusedLookupKey( 
            /* [in] */ XPS_OBJECT_TYPE type,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *key) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPage **page) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMPageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMPage * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMPage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMPage * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPartName )( 
            __RPC__in IXpsOMPage * This,
            /* [retval][out] */ __RPC__deref_out_opt IOpcPartUri **partUri);
        
        HRESULT ( STDMETHODCALLTYPE *SetPartName )( 
            __RPC__in IXpsOMPage * This,
            /* [in] */ __RPC__in_opt IOpcPartUri *partUri);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMPage * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPageReference **pageReference);
        
        HRESULT ( STDMETHODCALLTYPE *GetVisuals )( 
            __RPC__in IXpsOMPage * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMVisualCollection **visuals);
        
        HRESULT ( STDMETHODCALLTYPE *GetPageDimensions )( 
            __RPC__in IXpsOMPage * This,
            /* [retval][out] */ __RPC__out XPS_SIZE *pageDimensions);
        
        HRESULT ( STDMETHODCALLTYPE *SetPageDimensions )( 
            __RPC__in IXpsOMPage * This,
            /* [in] */ __RPC__in const XPS_SIZE *pageDimensions);
        
        HRESULT ( STDMETHODCALLTYPE *GetContentBox )( 
            __RPC__in IXpsOMPage * This,
            /* [retval][out] */ __RPC__out XPS_RECT *contentBox);
        
        HRESULT ( STDMETHODCALLTYPE *SetContentBox )( 
            __RPC__in IXpsOMPage * This,
            /* [in] */ __RPC__in const XPS_RECT *contentBox);
        
        HRESULT ( STDMETHODCALLTYPE *GetBleedBox )( 
            __RPC__in IXpsOMPage * This,
            /* [retval][out] */ __RPC__out XPS_RECT *bleedBox);
        
        HRESULT ( STDMETHODCALLTYPE *SetBleedBox )( 
            __RPC__in IXpsOMPage * This,
            /* [in] */ __RPC__in const XPS_RECT *bleedBox);
        
        HRESULT ( STDMETHODCALLTYPE *GetLanguage )( 
            __RPC__in IXpsOMPage * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *language);
        
        HRESULT ( STDMETHODCALLTYPE *SetLanguage )( 
            __RPC__in IXpsOMPage * This,
            /* [string][in] */ __RPC__in_string LPCWSTR language);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            __RPC__in IXpsOMPage * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *name);
        
        HRESULT ( STDMETHODCALLTYPE *SetName )( 
            __RPC__in IXpsOMPage * This,
            /* [string][in] */ __RPC__in_string LPCWSTR name);
        
        HRESULT ( STDMETHODCALLTYPE *GetIsHyperlinkTarget )( 
            __RPC__in IXpsOMPage * This,
            /* [retval][out] */ __RPC__out BOOL *isHyperlinkTarget);
        
        HRESULT ( STDMETHODCALLTYPE *SetIsHyperlinkTarget )( 
            __RPC__in IXpsOMPage * This,
            /* [in] */ BOOL isHyperlinkTarget);
        
        HRESULT ( STDMETHODCALLTYPE *GetDictionary )( 
            __RPC__in IXpsOMPage * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDictionary **resourceDictionary);
        
        HRESULT ( STDMETHODCALLTYPE *GetDictionaryLocal )( 
            __RPC__in IXpsOMPage * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDictionary **resourceDictionary);
        
        HRESULT ( STDMETHODCALLTYPE *SetDictionaryLocal )( 
            __RPC__in IXpsOMPage * This,
            /* [in] */ __RPC__in_opt IXpsOMDictionary *resourceDictionary);
        
        HRESULT ( STDMETHODCALLTYPE *GetDictionaryResource )( 
            __RPC__in IXpsOMPage * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMRemoteDictionaryResource **remoteDictionaryResource);
        
        HRESULT ( STDMETHODCALLTYPE *SetDictionaryResource )( 
            __RPC__in IXpsOMPage * This,
            /* [in] */ __RPC__in_opt IXpsOMRemoteDictionaryResource *remoteDictionaryResource);
        
        HRESULT ( STDMETHODCALLTYPE *Write )( 
            __RPC__in IXpsOMPage * This,
            /* [in] */ __RPC__in_opt ISequentialStream *stream,
            /* [in] */ BOOL optimizeMarkupSize);
        
        HRESULT ( STDMETHODCALLTYPE *GenerateUnusedLookupKey )( 
            __RPC__in IXpsOMPage * This,
            /* [in] */ XPS_OBJECT_TYPE type,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *key);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IXpsOMPage * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPage **page);
        
        END_INTERFACE
    } IXpsOMPageVtbl;

    interface IXpsOMPage
    {
        CONST_VTBL struct IXpsOMPageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMPage_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMPage_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMPage_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMPage_GetPartName(This,partUri)	\
    ( (This)->lpVtbl -> GetPartName(This,partUri) ) 

#define IXpsOMPage_SetPartName(This,partUri)	\
    ( (This)->lpVtbl -> SetPartName(This,partUri) ) 


#define IXpsOMPage_GetOwner(This,pageReference)	\
    ( (This)->lpVtbl -> GetOwner(This,pageReference) ) 

#define IXpsOMPage_GetVisuals(This,visuals)	\
    ( (This)->lpVtbl -> GetVisuals(This,visuals) ) 

#define IXpsOMPage_GetPageDimensions(This,pageDimensions)	\
    ( (This)->lpVtbl -> GetPageDimensions(This,pageDimensions) ) 

#define IXpsOMPage_SetPageDimensions(This,pageDimensions)	\
    ( (This)->lpVtbl -> SetPageDimensions(This,pageDimensions) ) 

#define IXpsOMPage_GetContentBox(This,contentBox)	\
    ( (This)->lpVtbl -> GetContentBox(This,contentBox) ) 

#define IXpsOMPage_SetContentBox(This,contentBox)	\
    ( (This)->lpVtbl -> SetContentBox(This,contentBox) ) 

#define IXpsOMPage_GetBleedBox(This,bleedBox)	\
    ( (This)->lpVtbl -> GetBleedBox(This,bleedBox) ) 

#define IXpsOMPage_SetBleedBox(This,bleedBox)	\
    ( (This)->lpVtbl -> SetBleedBox(This,bleedBox) ) 

#define IXpsOMPage_GetLanguage(This,language)	\
    ( (This)->lpVtbl -> GetLanguage(This,language) ) 

#define IXpsOMPage_SetLanguage(This,language)	\
    ( (This)->lpVtbl -> SetLanguage(This,language) ) 

#define IXpsOMPage_GetName(This,name)	\
    ( (This)->lpVtbl -> GetName(This,name) ) 

#define IXpsOMPage_SetName(This,name)	\
    ( (This)->lpVtbl -> SetName(This,name) ) 

#define IXpsOMPage_GetIsHyperlinkTarget(This,isHyperlinkTarget)	\
    ( (This)->lpVtbl -> GetIsHyperlinkTarget(This,isHyperlinkTarget) ) 

#define IXpsOMPage_SetIsHyperlinkTarget(This,isHyperlinkTarget)	\
    ( (This)->lpVtbl -> SetIsHyperlinkTarget(This,isHyperlinkTarget) ) 

#define IXpsOMPage_GetDictionary(This,resourceDictionary)	\
    ( (This)->lpVtbl -> GetDictionary(This,resourceDictionary) ) 

#define IXpsOMPage_GetDictionaryLocal(This,resourceDictionary)	\
    ( (This)->lpVtbl -> GetDictionaryLocal(This,resourceDictionary) ) 

#define IXpsOMPage_SetDictionaryLocal(This,resourceDictionary)	\
    ( (This)->lpVtbl -> SetDictionaryLocal(This,resourceDictionary) ) 

#define IXpsOMPage_GetDictionaryResource(This,remoteDictionaryResource)	\
    ( (This)->lpVtbl -> GetDictionaryResource(This,remoteDictionaryResource) ) 

#define IXpsOMPage_SetDictionaryResource(This,remoteDictionaryResource)	\
    ( (This)->lpVtbl -> SetDictionaryResource(This,remoteDictionaryResource) ) 

#define IXpsOMPage_Write(This,stream,optimizeMarkupSize)	\
    ( (This)->lpVtbl -> Write(This,stream,optimizeMarkupSize) ) 

#define IXpsOMPage_GenerateUnusedLookupKey(This,type,key)	\
    ( (This)->lpVtbl -> GenerateUnusedLookupKey(This,type,key) ) 

#define IXpsOMPage_Clone(This,page)	\
    ( (This)->lpVtbl -> Clone(This,page) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMPage_INTERFACE_DEFINED__ */


#ifndef __IXpsOMPackageWriter_INTERFACE_DEFINED__
#define __IXpsOMPackageWriter_INTERFACE_DEFINED__

/* interface IXpsOMPackageWriter */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMPackageWriter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4E2AA182-A443-42c6-B41B-4F8E9DE73FF9")
    IXpsOMPackageWriter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartNewDocument( 
            /* [in] */ __RPC__in_opt IOpcPartUri *documentPartName,
            /* [in] */ __RPC__in_opt IXpsOMPrintTicketResource *documentPrintTicket,
            /* [in] */ __RPC__in_opt IXpsOMDocumentStructureResource *documentStructure,
            /* [in] */ __RPC__in_opt IXpsOMSignatureBlockResourceCollection *signatureBlockResources,
            /* [in] */ __RPC__in_opt IXpsOMPartUriCollection *restrictedFonts) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddPage( 
            /* [in] */ __RPC__in_opt IXpsOMPage *page,
            /* [in] */ __RPC__in const XPS_SIZE *advisoryPageDimensions,
            /* [in] */ __RPC__in_opt IXpsOMPartUriCollection *discardableResourceParts,
            /* [in] */ __RPC__in_opt IXpsOMStoryFragmentsResource *storyFragments,
            /* [in] */ __RPC__in_opt IXpsOMPrintTicketResource *pagePrintTicket,
            /* [in] */ __RPC__in_opt IXpsOMImageResource *pageThumbnail) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddResource( 
            /* [in] */ __RPC__in_opt IXpsOMResource *resource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsClosed( 
            /* [retval][out] */ __RPC__out BOOL *isClosed) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMPackageWriterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMPackageWriter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMPackageWriter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMPackageWriter * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartNewDocument )( 
            __RPC__in IXpsOMPackageWriter * This,
            /* [in] */ __RPC__in_opt IOpcPartUri *documentPartName,
            /* [in] */ __RPC__in_opt IXpsOMPrintTicketResource *documentPrintTicket,
            /* [in] */ __RPC__in_opt IXpsOMDocumentStructureResource *documentStructure,
            /* [in] */ __RPC__in_opt IXpsOMSignatureBlockResourceCollection *signatureBlockResources,
            /* [in] */ __RPC__in_opt IXpsOMPartUriCollection *restrictedFonts);
        
        HRESULT ( STDMETHODCALLTYPE *AddPage )( 
            __RPC__in IXpsOMPackageWriter * This,
            /* [in] */ __RPC__in_opt IXpsOMPage *page,
            /* [in] */ __RPC__in const XPS_SIZE *advisoryPageDimensions,
            /* [in] */ __RPC__in_opt IXpsOMPartUriCollection *discardableResourceParts,
            /* [in] */ __RPC__in_opt IXpsOMStoryFragmentsResource *storyFragments,
            /* [in] */ __RPC__in_opt IXpsOMPrintTicketResource *pagePrintTicket,
            /* [in] */ __RPC__in_opt IXpsOMImageResource *pageThumbnail);
        
        HRESULT ( STDMETHODCALLTYPE *AddResource )( 
            __RPC__in IXpsOMPackageWriter * This,
            /* [in] */ __RPC__in_opt IXpsOMResource *resource);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            __RPC__in IXpsOMPackageWriter * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsClosed )( 
            __RPC__in IXpsOMPackageWriter * This,
            /* [retval][out] */ __RPC__out BOOL *isClosed);
        
        END_INTERFACE
    } IXpsOMPackageWriterVtbl;

    interface IXpsOMPackageWriter
    {
        CONST_VTBL struct IXpsOMPackageWriterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMPackageWriter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMPackageWriter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMPackageWriter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMPackageWriter_StartNewDocument(This,documentPartName,documentPrintTicket,documentStructure,signatureBlockResources,restrictedFonts)	\
    ( (This)->lpVtbl -> StartNewDocument(This,documentPartName,documentPrintTicket,documentStructure,signatureBlockResources,restrictedFonts) ) 

#define IXpsOMPackageWriter_AddPage(This,page,advisoryPageDimensions,discardableResourceParts,storyFragments,pagePrintTicket,pageThumbnail)	\
    ( (This)->lpVtbl -> AddPage(This,page,advisoryPageDimensions,discardableResourceParts,storyFragments,pagePrintTicket,pageThumbnail) ) 

#define IXpsOMPackageWriter_AddResource(This,resource)	\
    ( (This)->lpVtbl -> AddResource(This,resource) ) 

#define IXpsOMPackageWriter_Close(This)	\
    ( (This)->lpVtbl -> Close(This) ) 

#define IXpsOMPackageWriter_IsClosed(This,isClosed)	\
    ( (This)->lpVtbl -> IsClosed(This,isClosed) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMPackageWriter_INTERFACE_DEFINED__ */


#ifndef __IXpsOMGlyphsEditor_INTERFACE_DEFINED__
#define __IXpsOMGlyphsEditor_INTERFACE_DEFINED__

/* interface IXpsOMGlyphsEditor */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMGlyphsEditor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A5AB8616-5B16-4B9F-9629-89B323ED7909")
    IXpsOMGlyphsEditor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ApplyEdits( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUnicodeString( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *unicodeString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUnicodeString( 
            /* [string][in] */ __RPC__in_string LPCWSTR unicodeString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGlyphIndexCount( 
            /* [retval][out] */ __RPC__out UINT32 *indexCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGlyphIndices( 
            /* [out][in] */ __RPC__inout UINT32 *indexCount,
            /* [out] */ __RPC__out XPS_GLYPH_INDEX *glyphIndices) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetGlyphIndices( 
            /* [in] */ UINT32 indexCount,
            /* [in] */ __RPC__in const XPS_GLYPH_INDEX *glyphIndices) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGlyphMappingCount( 
            /* [retval][out] */ __RPC__out UINT32 *glyphMappingCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGlyphMappings( 
            /* [out][in] */ __RPC__inout UINT32 *glyphMappingCount,
            /* [out] */ __RPC__out XPS_GLYPH_MAPPING *glyphMappings) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetGlyphMappings( 
            /* [in] */ UINT32 glyphMappingCount,
            /* [in] */ __RPC__in const XPS_GLYPH_MAPPING *glyphMappings) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProhibitedCaretStopCount( 
            /* [retval][out] */ __RPC__out UINT32 *prohibitedCaretStopCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProhibitedCaretStops( 
            /* [out][in] */ __RPC__inout UINT32 *count,
            /* [out] */ __RPC__out UINT32 *prohibitedCaretStops) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProhibitedCaretStops( 
            /* [in] */ UINT32 count,
            /* [in] */ __RPC__in const UINT32 *prohibitedCaretStops) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBidiLevel( 
            /* [retval][out] */ __RPC__out UINT32 *bidiLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBidiLevel( 
            /* [in] */ UINT32 bidiLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIsSideways( 
            /* [retval][out] */ __RPC__out BOOL *isSideways) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIsSideways( 
            /* [in] */ BOOL isSideways) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeviceFontName( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *deviceFontName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDeviceFontName( 
            /* [string][in] */ __RPC__in_string LPCWSTR deviceFontName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMGlyphsEditorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMGlyphsEditor * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMGlyphsEditor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMGlyphsEditor * This);
        
        HRESULT ( STDMETHODCALLTYPE *ApplyEdits )( 
            __RPC__in IXpsOMGlyphsEditor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnicodeString )( 
            __RPC__in IXpsOMGlyphsEditor * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *unicodeString);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnicodeString )( 
            __RPC__in IXpsOMGlyphsEditor * This,
            /* [string][in] */ __RPC__in_string LPCWSTR unicodeString);
        
        HRESULT ( STDMETHODCALLTYPE *GetGlyphIndexCount )( 
            __RPC__in IXpsOMGlyphsEditor * This,
            /* [retval][out] */ __RPC__out UINT32 *indexCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetGlyphIndices )( 
            __RPC__in IXpsOMGlyphsEditor * This,
            /* [out][in] */ __RPC__inout UINT32 *indexCount,
            /* [out] */ __RPC__out XPS_GLYPH_INDEX *glyphIndices);
        
        HRESULT ( STDMETHODCALLTYPE *SetGlyphIndices )( 
            __RPC__in IXpsOMGlyphsEditor * This,
            /* [in] */ UINT32 indexCount,
            /* [in] */ __RPC__in const XPS_GLYPH_INDEX *glyphIndices);
        
        HRESULT ( STDMETHODCALLTYPE *GetGlyphMappingCount )( 
            __RPC__in IXpsOMGlyphsEditor * This,
            /* [retval][out] */ __RPC__out UINT32 *glyphMappingCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetGlyphMappings )( 
            __RPC__in IXpsOMGlyphsEditor * This,
            /* [out][in] */ __RPC__inout UINT32 *glyphMappingCount,
            /* [out] */ __RPC__out XPS_GLYPH_MAPPING *glyphMappings);
        
        HRESULT ( STDMETHODCALLTYPE *SetGlyphMappings )( 
            __RPC__in IXpsOMGlyphsEditor * This,
            /* [in] */ UINT32 glyphMappingCount,
            /* [in] */ __RPC__in const XPS_GLYPH_MAPPING *glyphMappings);
        
        HRESULT ( STDMETHODCALLTYPE *GetProhibitedCaretStopCount )( 
            __RPC__in IXpsOMGlyphsEditor * This,
            /* [retval][out] */ __RPC__out UINT32 *prohibitedCaretStopCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetProhibitedCaretStops )( 
            __RPC__in IXpsOMGlyphsEditor * This,
            /* [out][in] */ __RPC__inout UINT32 *count,
            /* [out] */ __RPC__out UINT32 *prohibitedCaretStops);
        
        HRESULT ( STDMETHODCALLTYPE *SetProhibitedCaretStops )( 
            __RPC__in IXpsOMGlyphsEditor * This,
            /* [in] */ UINT32 count,
            /* [in] */ __RPC__in const UINT32 *prohibitedCaretStops);
        
        HRESULT ( STDMETHODCALLTYPE *GetBidiLevel )( 
            __RPC__in IXpsOMGlyphsEditor * This,
            /* [retval][out] */ __RPC__out UINT32 *bidiLevel);
        
        HRESULT ( STDMETHODCALLTYPE *SetBidiLevel )( 
            __RPC__in IXpsOMGlyphsEditor * This,
            /* [in] */ UINT32 bidiLevel);
        
        HRESULT ( STDMETHODCALLTYPE *GetIsSideways )( 
            __RPC__in IXpsOMGlyphsEditor * This,
            /* [retval][out] */ __RPC__out BOOL *isSideways);
        
        HRESULT ( STDMETHODCALLTYPE *SetIsSideways )( 
            __RPC__in IXpsOMGlyphsEditor * This,
            /* [in] */ BOOL isSideways);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeviceFontName )( 
            __RPC__in IXpsOMGlyphsEditor * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *deviceFontName);
        
        HRESULT ( STDMETHODCALLTYPE *SetDeviceFontName )( 
            __RPC__in IXpsOMGlyphsEditor * This,
            /* [string][in] */ __RPC__in_string LPCWSTR deviceFontName);
        
        END_INTERFACE
    } IXpsOMGlyphsEditorVtbl;

    interface IXpsOMGlyphsEditor
    {
        CONST_VTBL struct IXpsOMGlyphsEditorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMGlyphsEditor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMGlyphsEditor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMGlyphsEditor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMGlyphsEditor_ApplyEdits(This)	\
    ( (This)->lpVtbl -> ApplyEdits(This) ) 

#define IXpsOMGlyphsEditor_GetUnicodeString(This,unicodeString)	\
    ( (This)->lpVtbl -> GetUnicodeString(This,unicodeString) ) 

#define IXpsOMGlyphsEditor_SetUnicodeString(This,unicodeString)	\
    ( (This)->lpVtbl -> SetUnicodeString(This,unicodeString) ) 

#define IXpsOMGlyphsEditor_GetGlyphIndexCount(This,indexCount)	\
    ( (This)->lpVtbl -> GetGlyphIndexCount(This,indexCount) ) 

#define IXpsOMGlyphsEditor_GetGlyphIndices(This,indexCount,glyphIndices)	\
    ( (This)->lpVtbl -> GetGlyphIndices(This,indexCount,glyphIndices) ) 

#define IXpsOMGlyphsEditor_SetGlyphIndices(This,indexCount,glyphIndices)	\
    ( (This)->lpVtbl -> SetGlyphIndices(This,indexCount,glyphIndices) ) 

#define IXpsOMGlyphsEditor_GetGlyphMappingCount(This,glyphMappingCount)	\
    ( (This)->lpVtbl -> GetGlyphMappingCount(This,glyphMappingCount) ) 

#define IXpsOMGlyphsEditor_GetGlyphMappings(This,glyphMappingCount,glyphMappings)	\
    ( (This)->lpVtbl -> GetGlyphMappings(This,glyphMappingCount,glyphMappings) ) 

#define IXpsOMGlyphsEditor_SetGlyphMappings(This,glyphMappingCount,glyphMappings)	\
    ( (This)->lpVtbl -> SetGlyphMappings(This,glyphMappingCount,glyphMappings) ) 

#define IXpsOMGlyphsEditor_GetProhibitedCaretStopCount(This,prohibitedCaretStopCount)	\
    ( (This)->lpVtbl -> GetProhibitedCaretStopCount(This,prohibitedCaretStopCount) ) 

#define IXpsOMGlyphsEditor_GetProhibitedCaretStops(This,count,prohibitedCaretStops)	\
    ( (This)->lpVtbl -> GetProhibitedCaretStops(This,count,prohibitedCaretStops) ) 

#define IXpsOMGlyphsEditor_SetProhibitedCaretStops(This,count,prohibitedCaretStops)	\
    ( (This)->lpVtbl -> SetProhibitedCaretStops(This,count,prohibitedCaretStops) ) 

#define IXpsOMGlyphsEditor_GetBidiLevel(This,bidiLevel)	\
    ( (This)->lpVtbl -> GetBidiLevel(This,bidiLevel) ) 

#define IXpsOMGlyphsEditor_SetBidiLevel(This,bidiLevel)	\
    ( (This)->lpVtbl -> SetBidiLevel(This,bidiLevel) ) 

#define IXpsOMGlyphsEditor_GetIsSideways(This,isSideways)	\
    ( (This)->lpVtbl -> GetIsSideways(This,isSideways) ) 

#define IXpsOMGlyphsEditor_SetIsSideways(This,isSideways)	\
    ( (This)->lpVtbl -> SetIsSideways(This,isSideways) ) 

#define IXpsOMGlyphsEditor_GetDeviceFontName(This,deviceFontName)	\
    ( (This)->lpVtbl -> GetDeviceFontName(This,deviceFontName) ) 

#define IXpsOMGlyphsEditor_SetDeviceFontName(This,deviceFontName)	\
    ( (This)->lpVtbl -> SetDeviceFontName(This,deviceFontName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMGlyphsEditor_INTERFACE_DEFINED__ */


#ifndef __IXpsOMPrintTicketResource_INTERFACE_DEFINED__
#define __IXpsOMPrintTicketResource_INTERFACE_DEFINED__

/* interface IXpsOMPrintTicketResource */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMPrintTicketResource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e7ff32d2-34aa-499b-bbe9-9cd4ee6c59f7")
    IXpsOMPrintTicketResource : public IXpsOMResource
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStream( 
            /* [retval][out] */ __RPC__deref_out_opt IStream **stream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContent( 
            /* [in] */ __RPC__in_opt IStream *sourceStream,
            /* [in] */ __RPC__in_opt IOpcPartUri *partName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMPrintTicketResourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMPrintTicketResource * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMPrintTicketResource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMPrintTicketResource * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPartName )( 
            __RPC__in IXpsOMPrintTicketResource * This,
            /* [retval][out] */ __RPC__deref_out_opt IOpcPartUri **partUri);
        
        HRESULT ( STDMETHODCALLTYPE *SetPartName )( 
            __RPC__in IXpsOMPrintTicketResource * This,
            /* [in] */ __RPC__in_opt IOpcPartUri *partUri);
        
        HRESULT ( STDMETHODCALLTYPE *GetStream )( 
            __RPC__in IXpsOMPrintTicketResource * This,
            /* [retval][out] */ __RPC__deref_out_opt IStream **stream);
        
        HRESULT ( STDMETHODCALLTYPE *SetContent )( 
            __RPC__in IXpsOMPrintTicketResource * This,
            /* [in] */ __RPC__in_opt IStream *sourceStream,
            /* [in] */ __RPC__in_opt IOpcPartUri *partName);
        
        END_INTERFACE
    } IXpsOMPrintTicketResourceVtbl;

    interface IXpsOMPrintTicketResource
    {
        CONST_VTBL struct IXpsOMPrintTicketResourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMPrintTicketResource_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMPrintTicketResource_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMPrintTicketResource_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMPrintTicketResource_GetPartName(This,partUri)	\
    ( (This)->lpVtbl -> GetPartName(This,partUri) ) 

#define IXpsOMPrintTicketResource_SetPartName(This,partUri)	\
    ( (This)->lpVtbl -> SetPartName(This,partUri) ) 



#define IXpsOMPrintTicketResource_GetStream(This,stream)	\
    ( (This)->lpVtbl -> GetStream(This,stream) ) 

#define IXpsOMPrintTicketResource_SetContent(This,sourceStream,partName)	\
    ( (This)->lpVtbl -> SetContent(This,sourceStream,partName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMPrintTicketResource_INTERFACE_DEFINED__ */


#ifndef __IXpsOMDocumentStructureResource_INTERFACE_DEFINED__
#define __IXpsOMDocumentStructureResource_INTERFACE_DEFINED__

/* interface IXpsOMDocumentStructureResource */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMDocumentStructureResource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85febc8a-6b63-48a9-af07-7064e4ecff30")
    IXpsOMDocumentStructureResource : public IXpsOMResource
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOwner( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDocument **owner) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStream( 
            /* [retval][out] */ __RPC__deref_out_opt IStream **stream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContent( 
            /* [in] */ __RPC__in_opt IStream *sourceStream,
            /* [in] */ __RPC__in_opt IOpcPartUri *partName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMDocumentStructureResourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMDocumentStructureResource * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMDocumentStructureResource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMDocumentStructureResource * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPartName )( 
            __RPC__in IXpsOMDocumentStructureResource * This,
            /* [retval][out] */ __RPC__deref_out_opt IOpcPartUri **partUri);
        
        HRESULT ( STDMETHODCALLTYPE *SetPartName )( 
            __RPC__in IXpsOMDocumentStructureResource * This,
            /* [in] */ __RPC__in_opt IOpcPartUri *partUri);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMDocumentStructureResource * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDocument **owner);
        
        HRESULT ( STDMETHODCALLTYPE *GetStream )( 
            __RPC__in IXpsOMDocumentStructureResource * This,
            /* [retval][out] */ __RPC__deref_out_opt IStream **stream);
        
        HRESULT ( STDMETHODCALLTYPE *SetContent )( 
            __RPC__in IXpsOMDocumentStructureResource * This,
            /* [in] */ __RPC__in_opt IStream *sourceStream,
            /* [in] */ __RPC__in_opt IOpcPartUri *partName);
        
        END_INTERFACE
    } IXpsOMDocumentStructureResourceVtbl;

    interface IXpsOMDocumentStructureResource
    {
        CONST_VTBL struct IXpsOMDocumentStructureResourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMDocumentStructureResource_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMDocumentStructureResource_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMDocumentStructureResource_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMDocumentStructureResource_GetPartName(This,partUri)	\
    ( (This)->lpVtbl -> GetPartName(This,partUri) ) 

#define IXpsOMDocumentStructureResource_SetPartName(This,partUri)	\
    ( (This)->lpVtbl -> SetPartName(This,partUri) ) 



#define IXpsOMDocumentStructureResource_GetOwner(This,owner)	\
    ( (This)->lpVtbl -> GetOwner(This,owner) ) 

#define IXpsOMDocumentStructureResource_GetStream(This,stream)	\
    ( (This)->lpVtbl -> GetStream(This,stream) ) 

#define IXpsOMDocumentStructureResource_SetContent(This,sourceStream,partName)	\
    ( (This)->lpVtbl -> SetContent(This,sourceStream,partName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMDocumentStructureResource_INTERFACE_DEFINED__ */


#ifndef __IXpsOMStoryFragmentsResource_INTERFACE_DEFINED__
#define __IXpsOMStoryFragmentsResource_INTERFACE_DEFINED__

/* interface IXpsOMStoryFragmentsResource */
/* [uuid][object] */ 


EXTERN_C const IID IID_IXpsOMStoryFragmentsResource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c2b3ca09-0473-4282-87ae-1780863223f0")
    IXpsOMStoryFragmentsResource : public IXpsOMResource
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOwner( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPageReference **owner) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStream( 
            /* [retval][out] */ __RPC__deref_out_opt IStream **stream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContent( 
            /* [in] */ __RPC__in_opt IStream *sourceStream,
            /* [in] */ __RPC__in_opt IOpcPartUri *partName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMStoryFragmentsResourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMStoryFragmentsResource * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMStoryFragmentsResource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMStoryFragmentsResource * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPartName )( 
            __RPC__in IXpsOMStoryFragmentsResource * This,
            /* [retval][out] */ __RPC__deref_out_opt IOpcPartUri **partUri);
        
        HRESULT ( STDMETHODCALLTYPE *SetPartName )( 
            __RPC__in IXpsOMStoryFragmentsResource * This,
            /* [in] */ __RPC__in_opt IOpcPartUri *partUri);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMStoryFragmentsResource * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPageReference **owner);
        
        HRESULT ( STDMETHODCALLTYPE *GetStream )( 
            __RPC__in IXpsOMStoryFragmentsResource * This,
            /* [retval][out] */ __RPC__deref_out_opt IStream **stream);
        
        HRESULT ( STDMETHODCALLTYPE *SetContent )( 
            __RPC__in IXpsOMStoryFragmentsResource * This,
            /* [in] */ __RPC__in_opt IStream *sourceStream,
            /* [in] */ __RPC__in_opt IOpcPartUri *partName);
        
        END_INTERFACE
    } IXpsOMStoryFragmentsResourceVtbl;

    interface IXpsOMStoryFragmentsResource
    {
        CONST_VTBL struct IXpsOMStoryFragmentsResourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMStoryFragmentsResource_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMStoryFragmentsResource_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMStoryFragmentsResource_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMStoryFragmentsResource_GetPartName(This,partUri)	\
    ( (This)->lpVtbl -> GetPartName(This,partUri) ) 

#define IXpsOMStoryFragmentsResource_SetPartName(This,partUri)	\
    ( (This)->lpVtbl -> SetPartName(This,partUri) ) 



#define IXpsOMStoryFragmentsResource_GetOwner(This,owner)	\
    ( (This)->lpVtbl -> GetOwner(This,owner) ) 

#define IXpsOMStoryFragmentsResource_GetStream(This,stream)	\
    ( (This)->lpVtbl -> GetStream(This,stream) ) 

#define IXpsOMStoryFragmentsResource_SetContent(This,sourceStream,partName)	\
    ( (This)->lpVtbl -> SetContent(This,sourceStream,partName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMStoryFragmentsResource_INTERFACE_DEFINED__ */


#ifndef __IXpsOMPageReferenceCollection_INTERFACE_DEFINED__
#define __IXpsOMPageReferenceCollection_INTERFACE_DEFINED__

/* interface IXpsOMPageReferenceCollection */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IXpsOMPageReferenceCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CA16BA4D-E7B9-45C5-958B-F98022473745")
    IXpsOMPageReferenceCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [retval][out] */ __RPC__out UINT32 *count) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPageReference **pageReference) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertAt( 
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMPageReference *pageReference) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAt( 
            /* [in] */ UINT32 index) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAt( 
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMPageReference *pageReference) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Append( 
            /* [in] */ __RPC__in_opt IXpsOMPageReference *pageReference) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMPageReferenceCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMPageReferenceCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMPageReferenceCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMPageReferenceCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IXpsOMPageReferenceCollection * This,
            /* [retval][out] */ __RPC__out UINT32 *count);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            __RPC__in IXpsOMPageReferenceCollection * This,
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPageReference **pageReference);
        
        HRESULT ( STDMETHODCALLTYPE *InsertAt )( 
            __RPC__in IXpsOMPageReferenceCollection * This,
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMPageReference *pageReference);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
            __RPC__in IXpsOMPageReferenceCollection * This,
            /* [in] */ UINT32 index);
        
        HRESULT ( STDMETHODCALLTYPE *SetAt )( 
            __RPC__in IXpsOMPageReferenceCollection * This,
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMPageReference *pageReference);
        
        HRESULT ( STDMETHODCALLTYPE *Append )( 
            __RPC__in IXpsOMPageReferenceCollection * This,
            /* [in] */ __RPC__in_opt IXpsOMPageReference *pageReference);
        
        END_INTERFACE
    } IXpsOMPageReferenceCollectionVtbl;

    interface IXpsOMPageReferenceCollection
    {
        CONST_VTBL struct IXpsOMPageReferenceCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMPageReferenceCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMPageReferenceCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMPageReferenceCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMPageReferenceCollection_GetCount(This,count)	\
    ( (This)->lpVtbl -> GetCount(This,count) ) 

#define IXpsOMPageReferenceCollection_GetAt(This,index,pageReference)	\
    ( (This)->lpVtbl -> GetAt(This,index,pageReference) ) 

#define IXpsOMPageReferenceCollection_InsertAt(This,index,pageReference)	\
    ( (This)->lpVtbl -> InsertAt(This,index,pageReference) ) 

#define IXpsOMPageReferenceCollection_RemoveAt(This,index)	\
    ( (This)->lpVtbl -> RemoveAt(This,index) ) 

#define IXpsOMPageReferenceCollection_SetAt(This,index,pageReference)	\
    ( (This)->lpVtbl -> SetAt(This,index,pageReference) ) 

#define IXpsOMPageReferenceCollection_Append(This,pageReference)	\
    ( (This)->lpVtbl -> Append(This,pageReference) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMPageReferenceCollection_INTERFACE_DEFINED__ */


#ifndef __IXpsOMDocumentCollection_INTERFACE_DEFINED__
#define __IXpsOMDocumentCollection_INTERFACE_DEFINED__

/* interface IXpsOMDocumentCollection */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IXpsOMDocumentCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D1C87F0D-E947-4754-8A25-971478F7E83E")
    IXpsOMDocumentCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [retval][out] */ __RPC__out UINT32 *count) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDocument **document) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertAt( 
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMDocument *document) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAt( 
            /* [in] */ UINT32 index) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAt( 
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMDocument *document) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Append( 
            /* [in] */ __RPC__in_opt IXpsOMDocument *document) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMDocumentCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMDocumentCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMDocumentCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMDocumentCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IXpsOMDocumentCollection * This,
            /* [retval][out] */ __RPC__out UINT32 *count);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            __RPC__in IXpsOMDocumentCollection * This,
            /* [in] */ UINT32 index,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMDocument **document);
        
        HRESULT ( STDMETHODCALLTYPE *InsertAt )( 
            __RPC__in IXpsOMDocumentCollection * This,
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMDocument *document);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
            __RPC__in IXpsOMDocumentCollection * This,
            /* [in] */ UINT32 index);
        
        HRESULT ( STDMETHODCALLTYPE *SetAt )( 
            __RPC__in IXpsOMDocumentCollection * This,
            /* [in] */ UINT32 index,
            /* [in] */ __RPC__in_opt IXpsOMDocument *document);
        
        HRESULT ( STDMETHODCALLTYPE *Append )( 
            __RPC__in IXpsOMDocumentCollection * This,
            /* [in] */ __RPC__in_opt IXpsOMDocument *document);
        
        END_INTERFACE
    } IXpsOMDocumentCollectionVtbl;

    interface IXpsOMDocumentCollection
    {
        CONST_VTBL struct IXpsOMDocumentCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMDocumentCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMDocumentCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMDocumentCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMDocumentCollection_GetCount(This,count)	\
    ( (This)->lpVtbl -> GetCount(This,count) ) 

#define IXpsOMDocumentCollection_GetAt(This,index,document)	\
    ( (This)->lpVtbl -> GetAt(This,index,document) ) 

#define IXpsOMDocumentCollection_InsertAt(This,index,document)	\
    ( (This)->lpVtbl -> InsertAt(This,index,document) ) 

#define IXpsOMDocumentCollection_RemoveAt(This,index)	\
    ( (This)->lpVtbl -> RemoveAt(This,index) ) 

#define IXpsOMDocumentCollection_SetAt(This,index,document)	\
    ( (This)->lpVtbl -> SetAt(This,index,document) ) 

#define IXpsOMDocumentCollection_Append(This,document)	\
    ( (This)->lpVtbl -> Append(This,document) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMDocumentCollection_INTERFACE_DEFINED__ */


#ifndef __IXpsOMCoreProperties_INTERFACE_DEFINED__
#define __IXpsOMCoreProperties_INTERFACE_DEFINED__

/* interface IXpsOMCoreProperties */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IXpsOMCoreProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3340FE8F-4027-4aa1-8F5F-D35AE45FE597")
    IXpsOMCoreProperties : public IXpsOMPart
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOwner( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPackage **package) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCategory( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *category) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCategory( 
            /* [string][in] */ __RPC__in_string LPCWSTR category) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContentStatus( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *contentStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContentStatus( 
            /* [string][in] */ __RPC__in_string LPCWSTR contentStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContentType( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *contentType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContentType( 
            /* [string][in] */ __RPC__in_string LPCWSTR contentType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCreated( 
            /* [retval][out] */ __RPC__out SYSTEMTIME *created) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCreated( 
            /* [in] */ __RPC__in const SYSTEMTIME *created) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCreator( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *creator) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCreator( 
            /* [string][in] */ __RPC__in_string LPCWSTR creator) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescription( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *description) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDescription( 
            /* [string][in] */ __RPC__in_string LPCWSTR description) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIdentifier( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *identifier) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIdentifier( 
            /* [string][in] */ __RPC__in_string LPCWSTR identifier) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKeywords( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *keywords) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetKeywords( 
            /* [string][in] */ __RPC__in_string LPCWSTR keywords) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLanguage( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *language) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLanguage( 
            /* [string][in] */ __RPC__in_string LPCWSTR language) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLastModifiedBy( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *lastModifiedBy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLastModifiedBy( 
            /* [string][in] */ __RPC__in_string LPCWSTR lastModifiedBy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLastPrinted( 
            /* [retval][out] */ __RPC__out SYSTEMTIME *lastPrinted) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLastPrinted( 
            /* [in] */ __RPC__in const SYSTEMTIME *lastPrinted) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetModified( 
            /* [retval][out] */ __RPC__out SYSTEMTIME *modified) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetModified( 
            /* [in] */ __RPC__in const SYSTEMTIME *modified) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRevision( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *revision) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRevision( 
            /* [string][in] */ __RPC__in_string LPCWSTR revision) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSubject( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *subject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSubject( 
            /* [string][in] */ __RPC__in_string LPCWSTR subject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTitle( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *title) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTitle( 
            /* [string][in] */ __RPC__in_string LPCWSTR title) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersion( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *version) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVersion( 
            /* [string][in] */ __RPC__in_string LPCWSTR version) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMCoreProperties **coreProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMCorePropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXpsOMCoreProperties * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXpsOMCoreProperties * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPartName )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [retval][out] */ __RPC__deref_out_opt IOpcPartUri **partUri);
        
        HRESULT ( STDMETHODCALLTYPE *SetPartName )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [in] */ __RPC__in_opt IOpcPartUri *partUri);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMPackage **package);
        
        HRESULT ( STDMETHODCALLTYPE *GetCategory )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *category);
        
        HRESULT ( STDMETHODCALLTYPE *SetCategory )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [string][in] */ __RPC__in_string LPCWSTR category);
        
        HRESULT ( STDMETHODCALLTYPE *GetContentStatus )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *contentStatus);
        
        HRESULT ( STDMETHODCALLTYPE *SetContentStatus )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [string][in] */ __RPC__in_string LPCWSTR contentStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetContentType )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *contentType);
        
        HRESULT ( STDMETHODCALLTYPE *SetContentType )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [string][in] */ __RPC__in_string LPCWSTR contentType);
        
        HRESULT ( STDMETHODCALLTYPE *GetCreated )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [retval][out] */ __RPC__out SYSTEMTIME *created);
        
        HRESULT ( STDMETHODCALLTYPE *SetCreated )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [in] */ __RPC__in const SYSTEMTIME *created);
        
        HRESULT ( STDMETHODCALLTYPE *GetCreator )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *creator);
        
        HRESULT ( STDMETHODCALLTYPE *SetCreator )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [string][in] */ __RPC__in_string LPCWSTR creator);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescription )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *description);
        
        HRESULT ( STDMETHODCALLTYPE *SetDescription )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [string][in] */ __RPC__in_string LPCWSTR description);
        
        HRESULT ( STDMETHODCALLTYPE *GetIdentifier )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *identifier);
        
        HRESULT ( STDMETHODCALLTYPE *SetIdentifier )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [string][in] */ __RPC__in_string LPCWSTR identifier);
        
        HRESULT ( STDMETHODCALLTYPE *GetKeywords )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *keywords);
        
        HRESULT ( STDMETHODCALLTYPE *SetKeywords )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [string][in] */ __RPC__in_string LPCWSTR keywords);
        
        HRESULT ( STDMETHODCALLTYPE *GetLanguage )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *language);
        
        HRESULT ( STDMETHODCALLTYPE *SetLanguage )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [string][in] */ __RPC__in_string LPCWSTR language);
        
        HRESULT ( STDMETHODCALLTYPE *GetLastModifiedBy )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *lastModifiedBy);
        
        HRESULT ( STDMETHODCALLTYPE *SetLastModifiedBy )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [string][in] */ __RPC__in_string LPCWSTR lastModifiedBy);
        
        HRESULT ( STDMETHODCALLTYPE *GetLastPrinted )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [retval][out] */ __RPC__out SYSTEMTIME *lastPrinted);
        
        HRESULT ( STDMETHODCALLTYPE *SetLastPrinted )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [in] */ __RPC__in const SYSTEMTIME *lastPrinted);
        
        HRESULT ( STDMETHODCALLTYPE *GetModified )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [retval][out] */ __RPC__out SYSTEMTIME *modified);
        
        HRESULT ( STDMETHODCALLTYPE *SetModified )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [in] */ __RPC__in const SYSTEMTIME *modified);
        
        HRESULT ( STDMETHODCALLTYPE *GetRevision )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *revision);
        
        HRESULT ( STDMETHODCALLTYPE *SetRevision )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [string][in] */ __RPC__in_string LPCWSTR revision);
        
        HRESULT ( STDMETHODCALLTYPE *GetSubject )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *subject);
        
        HRESULT ( STDMETHODCALLTYPE *SetSubject )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [string][in] */ __RPC__in_string LPCWSTR subject);
        
        HRESULT ( STDMETHODCALLTYPE *GetTitle )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *title);
        
        HRESULT ( STDMETHODCALLTYPE *SetTitle )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [string][in] */ __RPC__in_string LPCWSTR title);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersion )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string LPWSTR *version);
        
        HRESULT ( STDMETHODCALLTYPE *SetVersion )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [string][in] */ __RPC__in_string LPCWSTR version);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IXpsOMCoreProperties * This,
            /* [retval][out] */ __RPC__deref_out_opt IXpsOMCoreProperties **coreProperties);
        
        END_INTERFACE
    } IXpsOMCorePropertiesVtbl;

    interface IXpsOMCoreProperties
    {
        CONST_VTBL struct IXpsOMCorePropertiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMCoreProperties_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMCoreProperties_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMCoreProperties_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMCoreProperties_GetPartName(This,partUri)	\
    ( (This)->lpVtbl -> GetPartName(This,partUri) ) 

#define IXpsOMCoreProperties_SetPartName(This,partUri)	\
    ( (This)->lpVtbl -> SetPartName(This,partUri) ) 


#define IXpsOMCoreProperties_GetOwner(This,package)	\
    ( (This)->lpVtbl -> GetOwner(This,package) ) 

#define IXpsOMCoreProperties_GetCategory(This,category)	\
    ( (This)->lpVtbl -> GetCategory(This,category) ) 

#define IXpsOMCoreProperties_SetCategory(This,category)	\
    ( (This)->lpVtbl -> SetCategory(This,category) ) 

#define IXpsOMCoreProperties_GetContentStatus(This,contentStatus)	\
    ( (This)->lpVtbl -> GetContentStatus(This,contentStatus) ) 

#define IXpsOMCoreProperties_SetContentStatus(This,contentStatus)	\
    ( (This)->lpVtbl -> SetContentStatus(This,contentStatus) ) 

#define IXpsOMCoreProperties_GetContentType(This,contentType)	\
    ( (This)->lpVtbl -> GetContentType(This,contentType) ) 

#define IXpsOMCoreProperties_SetContentType(This,contentType)	\
    ( (This)->lpVtbl -> SetContentType(This,contentType) ) 

#define IXpsOMCoreProperties_GetCreated(This,created)	\
    ( (This)->lpVtbl -> GetCreated(This,created) ) 

#define IXpsOMCoreProperties_SetCreated(This,created)	\
    ( (This)->lpVtbl -> SetCreated(This,created) ) 

#define IXpsOMCoreProperties_GetCreator(This,creator)	\
    ( (This)->lpVtbl -> GetCreator(This,creator) ) 

#define IXpsOMCoreProperties_SetCreator(This,creator)	\
    ( (This)->lpVtbl -> SetCreator(This,creator) ) 

#define IXpsOMCoreProperties_GetDescription(This,description)	\
    ( (This)->lpVtbl -> GetDescription(This,description) ) 

#define IXpsOMCoreProperties_SetDescription(This,description)	\
    ( (This)->lpVtbl -> SetDescription(This,description) ) 

#define IXpsOMCoreProperties_GetIdentifier(This,identifier)	\
    ( (This)->lpVtbl -> GetIdentifier(This,identifier) ) 

#define IXpsOMCoreProperties_SetIdentifier(This,identifier)	\
    ( (This)->lpVtbl -> SetIdentifier(This,identifier) ) 

#define IXpsOMCoreProperties_GetKeywords(This,keywords)	\
    ( (This)->lpVtbl -> GetKeywords(This,keywords) ) 

#define IXpsOMCoreProperties_SetKeywords(This,keywords)	\
    ( (This)->lpVtbl -> SetKeywords(This,keywords) ) 

#define IXpsOMCoreProperties_GetLanguage(This,language)	\
    ( (This)->lpVtbl -> GetLanguage(This,language) ) 

#define IXpsOMCoreProperties_SetLanguage(This,language)	\
    ( (This)->lpVtbl -> SetLanguage(This,language) ) 

#define IXpsOMCoreProperties_GetLastModifiedBy(This,lastModifiedBy)	\
    ( (This)->lpVtbl -> GetLastModifiedBy(This,lastModifiedBy) ) 

#define IXpsOMCoreProperties_SetLastModifiedBy(This,lastModifiedBy)	\
    ( (This)->lpVtbl -> SetLastModifiedBy(This,lastModifiedBy) ) 

#define IXpsOMCoreProperties_GetLastPrinted(This,lastPrinted)	\
    ( (This)->lpVtbl -> GetLastPrinted(This,lastPrinted) ) 

#define IXpsOMCoreProperties_SetLastPrinted(This,lastPrinted)	\
    ( (This)->lpVtbl -> SetLastPrinted(This,lastPrinted) ) 

#define IXpsOMCoreProperties_GetModified(This,modified)	\
    ( (This)->lpVtbl -> GetModified(This,modified) ) 

#define IXpsOMCoreProperties_SetModified(This,modified)	\
    ( (This)->lpVtbl -> SetModified(This,modified) ) 

#define IXpsOMCoreProperties_GetRevision(This,revision)	\
    ( (This)->lpVtbl -> GetRevision(This,revision) ) 

#define IXpsOMCoreProperties_SetRevision(This,revision)	\
    ( (This)->lpVtbl -> SetRevision(This,revision) ) 

#define IXpsOMCoreProperties_GetSubject(This,subject)	\
    ( (This)->lpVtbl -> GetSubject(This,subject) ) 

#define IXpsOMCoreProperties_SetSubject(This,subject)	\
    ( (This)->lpVtbl -> SetSubject(This,subject) ) 

#define IXpsOMCoreProperties_GetTitle(This,title)	\
    ( (This)->lpVtbl -> GetTitle(This,title) ) 

#define IXpsOMCoreProperties_SetTitle(This,title)	\
    ( (This)->lpVtbl -> SetTitle(This,title) ) 

#define IXpsOMCoreProperties_GetVersion(This,version)	\
    ( (This)->lpVtbl -> GetVersion(This,version) ) 

#define IXpsOMCoreProperties_SetVersion(This,version)	\
    ( (This)->lpVtbl -> SetVersion(This,version) ) 

#define IXpsOMCoreProperties_Clone(This,coreProperties)	\
    ( (This)->lpVtbl -> Clone(This,coreProperties) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMCoreProperties_INTERFACE_DEFINED__ */


#ifndef __IXpsOMObjectFactory_INTERFACE_DEFINED__
#define __IXpsOMObjectFactory_INTERFACE_DEFINED__

/* interface IXpsOMObjectFactory */
/* [local][ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IXpsOMObjectFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f9b2a685-a50d-4fc2-b764-b56e093ea0ca")
    IXpsOMObjectFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreatePackage( 
            /* [retval][out] */ IXpsOMPackage **package) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePackageFromFile( 
            /* [string][in] */ LPCWSTR filename,
            /* [in] */ BOOL reuseObjects,
            /* [retval][out] */ IXpsOMPackage **package) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePackageFromStream( 
            /* [in] */ IStream *stream,
            /* [in] */ BOOL reuseObjects,
            /* [retval][out] */ IXpsOMPackage **package) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateStoryFragmentsResource( 
            /* [in] */ IStream *acquiredStream,
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMStoryFragmentsResource **storyFragmentsResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateDocumentStructureResource( 
            /* [in] */ IStream *acquiredStream,
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMDocumentStructureResource **documentStructureResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateSignatureBlockResource( 
            /* [in] */ IStream *acquiredStream,
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMSignatureBlockResource **signatureBlockResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateRemoteDictionaryResource( 
            /* [in] */ IXpsOMDictionary *dictionary,
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMRemoteDictionaryResource **remoteDictionaryResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateRemoteDictionaryResourceFromStream( 
            /* [in] */ IStream *dictionaryMarkupStream,
            /* [in] */ IOpcPartUri *dictionaryPartUri,
            /* [in] */ IXpsOMPartResources *resources,
            /* [retval][out] */ IXpsOMRemoteDictionaryResource **dictionaryResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePartResources( 
            /* [retval][out] */ IXpsOMPartResources **partResources) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateDocumentSequence( 
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMDocumentSequence **documentSequence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateDocument( 
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMDocument **document) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePageReference( 
            /* [in] */ const XPS_SIZE *advisoryPageDimensions,
            /* [retval][out] */ IXpsOMPageReference **pageReference) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePage( 
            /* [in] */ const XPS_SIZE *pageDimensions,
            /* [string][in] */ LPCWSTR language,
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMPage **page) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePageFromStream( 
            /* [in] */ IStream *pageMarkupStream,
            /* [in] */ IOpcPartUri *partUri,
            /* [in] */ IXpsOMPartResources *resources,
            /* [in] */ BOOL reuseObjects,
            /* [retval][out] */ IXpsOMPage **page) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateCanvas( 
            /* [retval][out] */ IXpsOMCanvas **canvas) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateGlyphs( 
            /* [in] */ IXpsOMFontResource *fontResource,
            /* [retval][out] */ IXpsOMGlyphs **glyphs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePath( 
            /* [retval][out] */ IXpsOMPath **path) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateGeometry( 
            /* [retval][out] */ IXpsOMGeometry **geometry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateGeometryFigure( 
            /* [in] */ const XPS_POINT *startPoint,
            /* [retval][out] */ IXpsOMGeometryFigure **figure) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateMatrixTransform( 
            /* [in] */ const XPS_MATRIX *matrix,
            /* [retval][out] */ IXpsOMMatrixTransform **transform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateSolidColorBrush( 
            /* [in] */ const XPS_COLOR *color,
            /* [in] */ IXpsOMColorProfileResource *colorProfile,
            /* [retval][out] */ IXpsOMSolidColorBrush **solidColorBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateColorProfileResource( 
            /* [in] */ IStream *acquiredStream,
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMColorProfileResource **colorProfileResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateImageBrush( 
            /* [in] */ IXpsOMImageResource *image,
            /* [in] */ const XPS_RECT *viewBox,
            /* [in] */ const XPS_RECT *viewPort,
            /* [retval][out] */ IXpsOMImageBrush **imageBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateVisualBrush( 
            /* [in] */ const XPS_RECT *viewBox,
            /* [in] */ const XPS_RECT *viewPort,
            /* [retval][out] */ IXpsOMVisualBrush **visualBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateImageResource( 
            /* [in] */ IStream *acquiredStream,
            /* [in] */ XPS_IMAGE_TYPE contentType,
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMImageResource **imageResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePrintTicketResource( 
            /* [in] */ IStream *acquiredStream,
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMPrintTicketResource **printTicketResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateFontResource( 
            /* [in] */ IStream *acquiredStream,
            /* [in] */ XPS_FONT_EMBEDDING fontEmbedding,
            /* [in] */ IOpcPartUri *partUri,
            /* [in] */ BOOL isObfSourceStream,
            /* [retval][out] */ IXpsOMFontResource **fontResource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateGradientStop( 
            /* [in] */ const XPS_COLOR *color,
            /* [in] */ IXpsOMColorProfileResource *colorProfile,
            /* [in] */ FLOAT offset,
            /* [retval][out] */ IXpsOMGradientStop **gradientStop) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateLinearGradientBrush( 
            /* [in] */ IXpsOMGradientStop *gradStop1,
            /* [in] */ IXpsOMGradientStop *gradStop2,
            /* [in] */ const XPS_POINT *startPoint,
            /* [in] */ const XPS_POINT *endPoint,
            /* [retval][out] */ IXpsOMLinearGradientBrush **linearGradientBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateRadialGradientBrush( 
            /* [in] */ IXpsOMGradientStop *gradStop1,
            /* [in] */ IXpsOMGradientStop *gradStop2,
            /* [in] */ const XPS_POINT *centerPoint,
            /* [in] */ const XPS_POINT *gradientOrigin,
            /* [in] */ const XPS_SIZE *radiiSizes,
            /* [retval][out] */ IXpsOMRadialGradientBrush **radialGradientBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateCoreProperties( 
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMCoreProperties **coreProperties) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateDictionary( 
            /* [retval][out] */ IXpsOMDictionary **dictionary) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePartUriCollection( 
            /* [retval][out] */ IXpsOMPartUriCollection **partUriCollection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePackageWriterOnFile( 
            /* [string][in] */ LPCWSTR fileName,
            /* [unique][in] */ LPSECURITY_ATTRIBUTES securityAttributes,
            /* [in] */ DWORD flagsAndAttributes,
            /* [in] */ BOOL optimizeMarkupSize,
            /* [in] */ XPS_INTERLEAVING interleaving,
            /* [in] */ IOpcPartUri *documentSequencePartName,
            /* [in] */ IXpsOMCoreProperties *coreProperties,
            /* [in] */ IXpsOMImageResource *packageThumbnail,
            /* [in] */ IXpsOMPrintTicketResource *documentSequencePrintTicket,
            /* [in] */ IOpcPartUri *discardControlPartName,
            /* [retval][out] */ IXpsOMPackageWriter **packageWriter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePackageWriterOnStream( 
            /* [in] */ ISequentialStream *outputStream,
            /* [in] */ BOOL optimizeMarkupSize,
            /* [in] */ XPS_INTERLEAVING interleaving,
            /* [in] */ IOpcPartUri *documentSequencePartName,
            /* [in] */ IXpsOMCoreProperties *coreProperties,
            /* [in] */ IXpsOMImageResource *packageThumbnail,
            /* [in] */ IXpsOMPrintTicketResource *documentSequencePrintTicket,
            /* [in] */ IOpcPartUri *discardControlPartName,
            /* [retval][out] */ IXpsOMPackageWriter **packageWriter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePartUri( 
            /* [string][in] */ LPCWSTR uri,
            /* [retval][out] */ IOpcPartUri **partUri) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateReadOnlyStreamOnFile( 
            /* [string][in] */ LPCWSTR filename,
            /* [retval][out] */ IStream **stream) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMObjectFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXpsOMObjectFactory * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXpsOMObjectFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXpsOMObjectFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePackage )( 
            IXpsOMObjectFactory * This,
            /* [retval][out] */ IXpsOMPackage **package);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePackageFromFile )( 
            IXpsOMObjectFactory * This,
            /* [string][in] */ LPCWSTR filename,
            /* [in] */ BOOL reuseObjects,
            /* [retval][out] */ IXpsOMPackage **package);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePackageFromStream )( 
            IXpsOMObjectFactory * This,
            /* [in] */ IStream *stream,
            /* [in] */ BOOL reuseObjects,
            /* [retval][out] */ IXpsOMPackage **package);
        
        HRESULT ( STDMETHODCALLTYPE *CreateStoryFragmentsResource )( 
            IXpsOMObjectFactory * This,
            /* [in] */ IStream *acquiredStream,
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMStoryFragmentsResource **storyFragmentsResource);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDocumentStructureResource )( 
            IXpsOMObjectFactory * This,
            /* [in] */ IStream *acquiredStream,
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMDocumentStructureResource **documentStructureResource);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSignatureBlockResource )( 
            IXpsOMObjectFactory * This,
            /* [in] */ IStream *acquiredStream,
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMSignatureBlockResource **signatureBlockResource);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRemoteDictionaryResource )( 
            IXpsOMObjectFactory * This,
            /* [in] */ IXpsOMDictionary *dictionary,
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMRemoteDictionaryResource **remoteDictionaryResource);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRemoteDictionaryResourceFromStream )( 
            IXpsOMObjectFactory * This,
            /* [in] */ IStream *dictionaryMarkupStream,
            /* [in] */ IOpcPartUri *dictionaryPartUri,
            /* [in] */ IXpsOMPartResources *resources,
            /* [retval][out] */ IXpsOMRemoteDictionaryResource **dictionaryResource);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePartResources )( 
            IXpsOMObjectFactory * This,
            /* [retval][out] */ IXpsOMPartResources **partResources);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDocumentSequence )( 
            IXpsOMObjectFactory * This,
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMDocumentSequence **documentSequence);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDocument )( 
            IXpsOMObjectFactory * This,
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMDocument **document);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePageReference )( 
            IXpsOMObjectFactory * This,
            /* [in] */ const XPS_SIZE *advisoryPageDimensions,
            /* [retval][out] */ IXpsOMPageReference **pageReference);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePage )( 
            IXpsOMObjectFactory * This,
            /* [in] */ const XPS_SIZE *pageDimensions,
            /* [string][in] */ LPCWSTR language,
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMPage **page);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePageFromStream )( 
            IXpsOMObjectFactory * This,
            /* [in] */ IStream *pageMarkupStream,
            /* [in] */ IOpcPartUri *partUri,
            /* [in] */ IXpsOMPartResources *resources,
            /* [in] */ BOOL reuseObjects,
            /* [retval][out] */ IXpsOMPage **page);
        
        HRESULT ( STDMETHODCALLTYPE *CreateCanvas )( 
            IXpsOMObjectFactory * This,
            /* [retval][out] */ IXpsOMCanvas **canvas);
        
        HRESULT ( STDMETHODCALLTYPE *CreateGlyphs )( 
            IXpsOMObjectFactory * This,
            /* [in] */ IXpsOMFontResource *fontResource,
            /* [retval][out] */ IXpsOMGlyphs **glyphs);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePath )( 
            IXpsOMObjectFactory * This,
            /* [retval][out] */ IXpsOMPath **path);
        
        HRESULT ( STDMETHODCALLTYPE *CreateGeometry )( 
            IXpsOMObjectFactory * This,
            /* [retval][out] */ IXpsOMGeometry **geometry);
        
        HRESULT ( STDMETHODCALLTYPE *CreateGeometryFigure )( 
            IXpsOMObjectFactory * This,
            /* [in] */ const XPS_POINT *startPoint,
            /* [retval][out] */ IXpsOMGeometryFigure **figure);
        
        HRESULT ( STDMETHODCALLTYPE *CreateMatrixTransform )( 
            IXpsOMObjectFactory * This,
            /* [in] */ const XPS_MATRIX *matrix,
            /* [retval][out] */ IXpsOMMatrixTransform **transform);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSolidColorBrush )( 
            IXpsOMObjectFactory * This,
            /* [in] */ const XPS_COLOR *color,
            /* [in] */ IXpsOMColorProfileResource *colorProfile,
            /* [retval][out] */ IXpsOMSolidColorBrush **solidColorBrush);
        
        HRESULT ( STDMETHODCALLTYPE *CreateColorProfileResource )( 
            IXpsOMObjectFactory * This,
            /* [in] */ IStream *acquiredStream,
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMColorProfileResource **colorProfileResource);
        
        HRESULT ( STDMETHODCALLTYPE *CreateImageBrush )( 
            IXpsOMObjectFactory * This,
            /* [in] */ IXpsOMImageResource *image,
            /* [in] */ const XPS_RECT *viewBox,
            /* [in] */ const XPS_RECT *viewPort,
            /* [retval][out] */ IXpsOMImageBrush **imageBrush);
        
        HRESULT ( STDMETHODCALLTYPE *CreateVisualBrush )( 
            IXpsOMObjectFactory * This,
            /* [in] */ const XPS_RECT *viewBox,
            /* [in] */ const XPS_RECT *viewPort,
            /* [retval][out] */ IXpsOMVisualBrush **visualBrush);
        
        HRESULT ( STDMETHODCALLTYPE *CreateImageResource )( 
            IXpsOMObjectFactory * This,
            /* [in] */ IStream *acquiredStream,
            /* [in] */ XPS_IMAGE_TYPE contentType,
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMImageResource **imageResource);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePrintTicketResource )( 
            IXpsOMObjectFactory * This,
            /* [in] */ IStream *acquiredStream,
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMPrintTicketResource **printTicketResource);
        
        HRESULT ( STDMETHODCALLTYPE *CreateFontResource )( 
            IXpsOMObjectFactory * This,
            /* [in] */ IStream *acquiredStream,
            /* [in] */ XPS_FONT_EMBEDDING fontEmbedding,
            /* [in] */ IOpcPartUri *partUri,
            /* [in] */ BOOL isObfSourceStream,
            /* [retval][out] */ IXpsOMFontResource **fontResource);
        
        HRESULT ( STDMETHODCALLTYPE *CreateGradientStop )( 
            IXpsOMObjectFactory * This,
            /* [in] */ const XPS_COLOR *color,
            /* [in] */ IXpsOMColorProfileResource *colorProfile,
            /* [in] */ FLOAT offset,
            /* [retval][out] */ IXpsOMGradientStop **gradientStop);
        
        HRESULT ( STDMETHODCALLTYPE *CreateLinearGradientBrush )( 
            IXpsOMObjectFactory * This,
            /* [in] */ IXpsOMGradientStop *gradStop1,
            /* [in] */ IXpsOMGradientStop *gradStop2,
            /* [in] */ const XPS_POINT *startPoint,
            /* [in] */ const XPS_POINT *endPoint,
            /* [retval][out] */ IXpsOMLinearGradientBrush **linearGradientBrush);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRadialGradientBrush )( 
            IXpsOMObjectFactory * This,
            /* [in] */ IXpsOMGradientStop *gradStop1,
            /* [in] */ IXpsOMGradientStop *gradStop2,
            /* [in] */ const XPS_POINT *centerPoint,
            /* [in] */ const XPS_POINT *gradientOrigin,
            /* [in] */ const XPS_SIZE *radiiSizes,
            /* [retval][out] */ IXpsOMRadialGradientBrush **radialGradientBrush);
        
        HRESULT ( STDMETHODCALLTYPE *CreateCoreProperties )( 
            IXpsOMObjectFactory * This,
            /* [in] */ IOpcPartUri *partUri,
            /* [retval][out] */ IXpsOMCoreProperties **coreProperties);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDictionary )( 
            IXpsOMObjectFactory * This,
            /* [retval][out] */ IXpsOMDictionary **dictionary);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePartUriCollection )( 
            IXpsOMObjectFactory * This,
            /* [retval][out] */ IXpsOMPartUriCollection **partUriCollection);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePackageWriterOnFile )( 
            IXpsOMObjectFactory * This,
            /* [string][in] */ LPCWSTR fileName,
            /* [unique][in] */ LPSECURITY_ATTRIBUTES securityAttributes,
            /* [in] */ DWORD flagsAndAttributes,
            /* [in] */ BOOL optimizeMarkupSize,
            /* [in] */ XPS_INTERLEAVING interleaving,
            /* [in] */ IOpcPartUri *documentSequencePartName,
            /* [in] */ IXpsOMCoreProperties *coreProperties,
            /* [in] */ IXpsOMImageResource *packageThumbnail,
            /* [in] */ IXpsOMPrintTicketResource *documentSequencePrintTicket,
            /* [in] */ IOpcPartUri *discardControlPartName,
            /* [retval][out] */ IXpsOMPackageWriter **packageWriter);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePackageWriterOnStream )( 
            IXpsOMObjectFactory * This,
            /* [in] */ ISequentialStream *outputStream,
            /* [in] */ BOOL optimizeMarkupSize,
            /* [in] */ XPS_INTERLEAVING interleaving,
            /* [in] */ IOpcPartUri *documentSequencePartName,
            /* [in] */ IXpsOMCoreProperties *coreProperties,
            /* [in] */ IXpsOMImageResource *packageThumbnail,
            /* [in] */ IXpsOMPrintTicketResource *documentSequencePrintTicket,
            /* [in] */ IOpcPartUri *discardControlPartName,
            /* [retval][out] */ IXpsOMPackageWriter **packageWriter);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePartUri )( 
            IXpsOMObjectFactory * This,
            /* [string][in] */ LPCWSTR uri,
            /* [retval][out] */ IOpcPartUri **partUri);
        
        HRESULT ( STDMETHODCALLTYPE *CreateReadOnlyStreamOnFile )( 
            IXpsOMObjectFactory * This,
            /* [string][in] */ LPCWSTR filename,
            /* [retval][out] */ IStream **stream);
        
        END_INTERFACE
    } IXpsOMObjectFactoryVtbl;

    interface IXpsOMObjectFactory
    {
        CONST_VTBL struct IXpsOMObjectFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMObjectFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMObjectFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMObjectFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMObjectFactory_CreatePackage(This,package)	\
    ( (This)->lpVtbl -> CreatePackage(This,package) ) 

#define IXpsOMObjectFactory_CreatePackageFromFile(This,filename,reuseObjects,package)	\
    ( (This)->lpVtbl -> CreatePackageFromFile(This,filename,reuseObjects,package) ) 

#define IXpsOMObjectFactory_CreatePackageFromStream(This,stream,reuseObjects,package)	\
    ( (This)->lpVtbl -> CreatePackageFromStream(This,stream,reuseObjects,package) ) 

#define IXpsOMObjectFactory_CreateStoryFragmentsResource(This,acquiredStream,partUri,storyFragmentsResource)	\
    ( (This)->lpVtbl -> CreateStoryFragmentsResource(This,acquiredStream,partUri,storyFragmentsResource) ) 

#define IXpsOMObjectFactory_CreateDocumentStructureResource(This,acquiredStream,partUri,documentStructureResource)	\
    ( (This)->lpVtbl -> CreateDocumentStructureResource(This,acquiredStream,partUri,documentStructureResource) ) 

#define IXpsOMObjectFactory_CreateSignatureBlockResource(This,acquiredStream,partUri,signatureBlockResource)	\
    ( (This)->lpVtbl -> CreateSignatureBlockResource(This,acquiredStream,partUri,signatureBlockResource) ) 

#define IXpsOMObjectFactory_CreateRemoteDictionaryResource(This,dictionary,partUri,remoteDictionaryResource)	\
    ( (This)->lpVtbl -> CreateRemoteDictionaryResource(This,dictionary,partUri,remoteDictionaryResource) ) 

#define IXpsOMObjectFactory_CreateRemoteDictionaryResourceFromStream(This,dictionaryMarkupStream,dictionaryPartUri,resources,dictionaryResource)	\
    ( (This)->lpVtbl -> CreateRemoteDictionaryResourceFromStream(This,dictionaryMarkupStream,dictionaryPartUri,resources,dictionaryResource) ) 

#define IXpsOMObjectFactory_CreatePartResources(This,partResources)	\
    ( (This)->lpVtbl -> CreatePartResources(This,partResources) ) 

#define IXpsOMObjectFactory_CreateDocumentSequence(This,partUri,documentSequence)	\
    ( (This)->lpVtbl -> CreateDocumentSequence(This,partUri,documentSequence) ) 

#define IXpsOMObjectFactory_CreateDocument(This,partUri,document)	\
    ( (This)->lpVtbl -> CreateDocument(This,partUri,document) ) 

#define IXpsOMObjectFactory_CreatePageReference(This,advisoryPageDimensions,pageReference)	\
    ( (This)->lpVtbl -> CreatePageReference(This,advisoryPageDimensions,pageReference) ) 

#define IXpsOMObjectFactory_CreatePage(This,pageDimensions,language,partUri,page)	\
    ( (This)->lpVtbl -> CreatePage(This,pageDimensions,language,partUri,page) ) 

#define IXpsOMObjectFactory_CreatePageFromStream(This,pageMarkupStream,partUri,resources,reuseObjects,page)	\
    ( (This)->lpVtbl -> CreatePageFromStream(This,pageMarkupStream,partUri,resources,reuseObjects,page) ) 

#define IXpsOMObjectFactory_CreateCanvas(This,canvas)	\
    ( (This)->lpVtbl -> CreateCanvas(This,canvas) ) 

#define IXpsOMObjectFactory_CreateGlyphs(This,fontResource,glyphs)	\
    ( (This)->lpVtbl -> CreateGlyphs(This,fontResource,glyphs) ) 

#define IXpsOMObjectFactory_CreatePath(This,path)	\
    ( (This)->lpVtbl -> CreatePath(This,path) ) 

#define IXpsOMObjectFactory_CreateGeometry(This,geometry)	\
    ( (This)->lpVtbl -> CreateGeometry(This,geometry) ) 

#define IXpsOMObjectFactory_CreateGeometryFigure(This,startPoint,figure)	\
    ( (This)->lpVtbl -> CreateGeometryFigure(This,startPoint,figure) ) 

#define IXpsOMObjectFactory_CreateMatrixTransform(This,matrix,transform)	\
    ( (This)->lpVtbl -> CreateMatrixTransform(This,matrix,transform) ) 

#define IXpsOMObjectFactory_CreateSolidColorBrush(This,color,colorProfile,solidColorBrush)	\
    ( (This)->lpVtbl -> CreateSolidColorBrush(This,color,colorProfile,solidColorBrush) ) 

#define IXpsOMObjectFactory_CreateColorProfileResource(This,acquiredStream,partUri,colorProfileResource)	\
    ( (This)->lpVtbl -> CreateColorProfileResource(This,acquiredStream,partUri,colorProfileResource) ) 

#define IXpsOMObjectFactory_CreateImageBrush(This,image,viewBox,viewPort,imageBrush)	\
    ( (This)->lpVtbl -> CreateImageBrush(This,image,viewBox,viewPort,imageBrush) ) 

#define IXpsOMObjectFactory_CreateVisualBrush(This,viewBox,viewPort,visualBrush)	\
    ( (This)->lpVtbl -> CreateVisualBrush(This,viewBox,viewPort,visualBrush) ) 

#define IXpsOMObjectFactory_CreateImageResource(This,acquiredStream,contentType,partUri,imageResource)	\
    ( (This)->lpVtbl -> CreateImageResource(This,acquiredStream,contentType,partUri,imageResource) ) 

#define IXpsOMObjectFactory_CreatePrintTicketResource(This,acquiredStream,partUri,printTicketResource)	\
    ( (This)->lpVtbl -> CreatePrintTicketResource(This,acquiredStream,partUri,printTicketResource) ) 

#define IXpsOMObjectFactory_CreateFontResource(This,acquiredStream,fontEmbedding,partUri,isObfSourceStream,fontResource)	\
    ( (This)->lpVtbl -> CreateFontResource(This,acquiredStream,fontEmbedding,partUri,isObfSourceStream,fontResource) ) 

#define IXpsOMObjectFactory_CreateGradientStop(This,color,colorProfile,offset,gradientStop)	\
    ( (This)->lpVtbl -> CreateGradientStop(This,color,colorProfile,offset,gradientStop) ) 

#define IXpsOMObjectFactory_CreateLinearGradientBrush(This,gradStop1,gradStop2,startPoint,endPoint,linearGradientBrush)	\
    ( (This)->lpVtbl -> CreateLinearGradientBrush(This,gradStop1,gradStop2,startPoint,endPoint,linearGradientBrush) ) 

#define IXpsOMObjectFactory_CreateRadialGradientBrush(This,gradStop1,gradStop2,centerPoint,gradientOrigin,radiiSizes,radialGradientBrush)	\
    ( (This)->lpVtbl -> CreateRadialGradientBrush(This,gradStop1,gradStop2,centerPoint,gradientOrigin,radiiSizes,radialGradientBrush) ) 

#define IXpsOMObjectFactory_CreateCoreProperties(This,partUri,coreProperties)	\
    ( (This)->lpVtbl -> CreateCoreProperties(This,partUri,coreProperties) ) 

#define IXpsOMObjectFactory_CreateDictionary(This,dictionary)	\
    ( (This)->lpVtbl -> CreateDictionary(This,dictionary) ) 

#define IXpsOMObjectFactory_CreatePartUriCollection(This,partUriCollection)	\
    ( (This)->lpVtbl -> CreatePartUriCollection(This,partUriCollection) ) 

#define IXpsOMObjectFactory_CreatePackageWriterOnFile(This,fileName,securityAttributes,flagsAndAttributes,optimizeMarkupSize,interleaving,documentSequencePartName,coreProperties,packageThumbnail,documentSequencePrintTicket,discardControlPartName,packageWriter)	\
    ( (This)->lpVtbl -> CreatePackageWriterOnFile(This,fileName,securityAttributes,flagsAndAttributes,optimizeMarkupSize,interleaving,documentSequencePartName,coreProperties,packageThumbnail,documentSequencePrintTicket,discardControlPartName,packageWriter) ) 

#define IXpsOMObjectFactory_CreatePackageWriterOnStream(This,outputStream,optimizeMarkupSize,interleaving,documentSequencePartName,coreProperties,packageThumbnail,documentSequencePrintTicket,discardControlPartName,packageWriter)	\
    ( (This)->lpVtbl -> CreatePackageWriterOnStream(This,outputStream,optimizeMarkupSize,interleaving,documentSequencePartName,coreProperties,packageThumbnail,documentSequencePrintTicket,discardControlPartName,packageWriter) ) 

#define IXpsOMObjectFactory_CreatePartUri(This,uri,partUri)	\
    ( (This)->lpVtbl -> CreatePartUri(This,uri,partUri) ) 

#define IXpsOMObjectFactory_CreateReadOnlyStreamOnFile(This,filename,stream)	\
    ( (This)->lpVtbl -> CreateReadOnlyStreamOnFile(This,filename,stream) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMObjectFactory_INTERFACE_DEFINED__ */


#ifndef __IXpsOMThumbnailGenerator_INTERFACE_DEFINED__
#define __IXpsOMThumbnailGenerator_INTERFACE_DEFINED__

/* interface IXpsOMThumbnailGenerator */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IXpsOMThumbnailGenerator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("15B873D5-1971-41E8-83A3-6578403064C7")
    IXpsOMThumbnailGenerator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GenerateThumbnail( 
            /* [in] */ IXpsOMPage *page,
            /* [in] */ XPS_IMAGE_TYPE thumbnailType,
            /* [in] */ XPS_THUMBNAIL_SIZE thumbnailSize,
            /* [in] */ IOpcPartUri *imageResourcePartName,
            /* [retval][out] */ IXpsOMImageResource **imageResource) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXpsOMThumbnailGeneratorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXpsOMThumbnailGenerator * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXpsOMThumbnailGenerator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXpsOMThumbnailGenerator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GenerateThumbnail )( 
            IXpsOMThumbnailGenerator * This,
            /* [in] */ IXpsOMPage *page,
            /* [in] */ XPS_IMAGE_TYPE thumbnailType,
            /* [in] */ XPS_THUMBNAIL_SIZE thumbnailSize,
            /* [in] */ IOpcPartUri *imageResourcePartName,
            /* [retval][out] */ IXpsOMImageResource **imageResource);
        
        END_INTERFACE
    } IXpsOMThumbnailGeneratorVtbl;

    interface IXpsOMThumbnailGenerator
    {
        CONST_VTBL struct IXpsOMThumbnailGeneratorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXpsOMThumbnailGenerator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXpsOMThumbnailGenerator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXpsOMThumbnailGenerator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXpsOMThumbnailGenerator_GenerateThumbnail(This,page,thumbnailType,thumbnailSize,imageResourcePartName,imageResource)	\
    ( (This)->lpVtbl -> GenerateThumbnail(This,page,thumbnailType,thumbnailSize,imageResourcePartName,imageResource) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXpsOMThumbnailGenerator_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_XpsOMObjectFactory;

#ifdef __cplusplus

class DECLSPEC_UUID("E974D26D-3D9B-4D47-88CC-3872F2DC3585")
XpsOMObjectFactory;
#endif

EXTERN_C const CLSID CLSID_XpsOMThumbnailGenerator;

#ifdef __cplusplus

class DECLSPEC_UUID("7E4A23E2-B969-4761-BE35-1A8CED58E323")
XpsOMThumbnailGenerator;
#endif
#endif /* __MSXPS_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_xpsobjectmodel_0001_0116 */
/* [local] */ 

#define XPS_E_INVALID_LANGUAGE                           MAKE_HRESULT(1, FACILITY_XPS, 0x000) 
#define XPS_E_INVALID_NAME                               MAKE_HRESULT(1, FACILITY_XPS, 0x001) 
#define XPS_E_INVALID_RESOURCE_KEY                       MAKE_HRESULT(1, FACILITY_XPS, 0x002) 
#define XPS_E_INVALID_PAGE_SIZE                          MAKE_HRESULT(1, FACILITY_XPS, 0x003) 
#define XPS_E_INVALID_BLEED_BOX                          MAKE_HRESULT(1, FACILITY_XPS, 0x004) 
#define XPS_E_INVALID_THUMBNAIL_IMAGE_TYPE               MAKE_HRESULT(1, FACILITY_XPS, 0x005) 
#define XPS_E_INVALID_LOOKUP_TYPE                        MAKE_HRESULT(1, FACILITY_XPS, 0x006) 
#define XPS_E_INVALID_FLOAT                              MAKE_HRESULT(1, FACILITY_XPS, 0x007) 
#define XPS_E_UNEXPECTED_CONTENT_TYPE                    MAKE_HRESULT(1, FACILITY_XPS, 0x008) 
#define XPS_E_INVALID_FONT_URI                           MAKE_HRESULT(1, FACILITY_XPS, 0x00a) 
#define XPS_E_INVALID_CONTENT_BOX                        MAKE_HRESULT(1, FACILITY_XPS, 0x00b) 
#define XPS_E_INVALID_MARKUP                             MAKE_HRESULT(1, FACILITY_XPS, 0x00c) 
#define XPS_E_INVALID_XML_ENCODING                       MAKE_HRESULT(1, FACILITY_XPS, 0x00d) 
#define XPS_E_INVALID_CONTENT_TYPE                       MAKE_HRESULT(1, FACILITY_XPS, 0x00e) 
#define XPS_E_INVALID_OBFUSCATED_FONT_URI                MAKE_HRESULT(1, FACILITY_XPS, 0x00f) 
#define XPS_E_UNEXPECTED_RELATIONSHIP_TYPE               MAKE_HRESULT(1, FACILITY_XPS, 0x010) 
#define XPS_E_UNEXPECTED_RESTRICTED_FONT_RELATIONSHIP    MAKE_HRESULT(1, FACILITY_XPS, 0x011) 
#define XPS_E_MISSING_NAME                               MAKE_HRESULT(1, FACILITY_XPS, 0x100) 
#define XPS_E_MISSING_LOOKUP                             MAKE_HRESULT(1, FACILITY_XPS, 0x101) 
#define XPS_E_MISSING_GLYPHS                             MAKE_HRESULT(1, FACILITY_XPS, 0x102) 
#define XPS_E_MISSING_SEGMENT_DATA                       MAKE_HRESULT(1, FACILITY_XPS, 0x103) 
#define XPS_E_MISSING_COLORPROFILE                       MAKE_HRESULT(1, FACILITY_XPS, 0x104) 
#define XPS_E_MISSING_RELATIONSHIP_TARGET                MAKE_HRESULT(1, FACILITY_XPS, 0x105) 
#define XPS_E_MISSING_RESOURCE_RELATIONSHIP              MAKE_HRESULT(1, FACILITY_XPS, 0x106) 
#define XPS_E_MISSING_FONTURI                            MAKE_HRESULT(1, FACILITY_XPS, 0x107) 
#define XPS_E_MISSING_DOCUMENTSEQUENCE_RELATIONSHIP      MAKE_HRESULT(1, FACILITY_XPS, 0x108) 
#define XPS_E_MISSING_DOCUMENT                           MAKE_HRESULT(1, FACILITY_XPS, 0x109) 
#define XPS_E_MISSING_REFERRED_DOCUMENT                  MAKE_HRESULT(1, FACILITY_XPS, 0x10a) 
#define XPS_E_MISSING_REFERRED_PAGE                      MAKE_HRESULT(1, FACILITY_XPS, 0x10b) 
#define XPS_E_MISSING_PAGE_IN_DOCUMENT                   MAKE_HRESULT(1, FACILITY_XPS, 0x10c) 
#define XPS_E_MISSING_PAGE_IN_PAGEREFERENCE              MAKE_HRESULT(1, FACILITY_XPS, 0x10d) 
#define XPS_E_MISSING_IMAGE_IN_IMAGEBRUSH                MAKE_HRESULT(1, FACILITY_XPS, 0x10e) 
#define XPS_E_MISSING_RESOURCE_KEY                       MAKE_HRESULT(1, FACILITY_XPS, 0x10f) 
#define XPS_E_MISSING_PART_REFERENCE                     MAKE_HRESULT(1, FACILITY_XPS, 0x110) 
#define XPS_E_MISSING_RESTRICTED_FONT_RELATIONSHIP       MAKE_HRESULT(1, FACILITY_XPS, 0x111) 
#define XPS_E_MISSING_DISCARDCONTROL                     MAKE_HRESULT(1, FACILITY_XPS, 0x112) 
#define XPS_E_MISSING_PART_STREAM                        MAKE_HRESULT(1, FACILITY_XPS, 0x113) 
#define XPS_E_UNAVAILABLE_PACKAGE                        MAKE_HRESULT(1, FACILITY_XPS, 0x114) 
#define XPS_E_DUPLICATE_RESOURCE_KEYS                    MAKE_HRESULT(1, FACILITY_XPS, 0x200) 
#define XPS_E_MULTIPLE_RESOURCES                         MAKE_HRESULT(1, FACILITY_XPS, 0x201) 
#define XPS_E_MULTIPLE_DOCUMENTSEQUENCE_RELATIONSHIPS    MAKE_HRESULT(1, FACILITY_XPS, 0x202) 
#define XPS_E_MULTIPLE_THUMBNAILS_ON_PAGE                MAKE_HRESULT(1, FACILITY_XPS, 0x203) 
#define XPS_E_MULTIPLE_THUMBNAILS_ON_PACKAGE             MAKE_HRESULT(1, FACILITY_XPS, 0x204) 
#define XPS_E_MULTIPLE_PRINTTICKETS_ON_PAGE              MAKE_HRESULT(1, FACILITY_XPS, 0x205) 
#define XPS_E_MULTIPLE_PRINTTICKETS_ON_DOCUMENT          MAKE_HRESULT(1, FACILITY_XPS, 0x206) 
#define XPS_E_MULTIPLE_PRINTTICKETS_ON_DOCUMENTSEQUENCE  MAKE_HRESULT(1, FACILITY_XPS, 0x207) 
#define XPS_E_MULTIPLE_REFERENCES_TO_PART                MAKE_HRESULT(1, FACILITY_XPS, 0x208) 
#define XPS_E_DUPLICATE_NAMES                            MAKE_HRESULT(1, FACILITY_XPS, 0x209) 
#define XPS_E_STRING_TOO_LONG                            MAKE_HRESULT(1, FACILITY_XPS, 0x300) 
#define XPS_E_TOO_MANY_INDICES                           MAKE_HRESULT(1, FACILITY_XPS, 0x301) 
#define XPS_E_MAPPING_OUT_OF_ORDER                       MAKE_HRESULT(1, FACILITY_XPS, 0x302) 
#define XPS_E_MAPPING_OUTSIDE_STRING                     MAKE_HRESULT(1, FACILITY_XPS, 0x303) 
#define XPS_E_MAPPING_OUTSIDE_INDICES                    MAKE_HRESULT(1, FACILITY_XPS, 0x304) 
#define XPS_E_CARET_OUTSIDE_STRING                       MAKE_HRESULT(1, FACILITY_XPS, 0x305) 
#define XPS_E_CARET_OUT_OF_ORDER                         MAKE_HRESULT(1, FACILITY_XPS, 0x306) 
#define XPS_E_ODD_BIDILEVEL                              MAKE_HRESULT(1, FACILITY_XPS, 0x307) 
#define XPS_E_ONE_TO_ONE_MAPPING_EXPECTED                MAKE_HRESULT(1, FACILITY_XPS, 0x308) 
#define XPS_E_RESTRICTED_FONT_NOT_OBFUSCATED             MAKE_HRESULT(1, FACILITY_XPS, 0x309) 
#define XPS_E_NEGATIVE_FLOAT                             MAKE_HRESULT(1, FACILITY_XPS, 0x30a) 
#define XPS_E_XKEY_ATTR_PRESENT_OUTSIDE_RES_DICT         MAKE_HRESULT(1, FACILITY_XPS, 0x400) 
#define XPS_E_DICTIONARY_ITEM_NAMED                      MAKE_HRESULT(1, FACILITY_XPS, 0x401) 
#define XPS_E_NESTED_REMOTE_DICTIONARY                   MAKE_HRESULT(1, FACILITY_XPS, 0x402) 
#define XPS_E_INDEX_OUT_OF_RANGE                         MAKE_HRESULT(1, FACILITY_XPS, 0x500) 
#define XPS_E_VISUAL_CIRCULAR_REF                        MAKE_HRESULT(1, FACILITY_XPS, 0x501) 
#define XPS_E_NO_CUSTOM_OBJECTS                          MAKE_HRESULT(1, FACILITY_XPS, 0x502) 
#define XPS_E_ALREADY_OWNED                              MAKE_HRESULT(1, FACILITY_XPS, 0x503) 
#define XPS_E_RESOURCE_NOT_OWNED                         MAKE_HRESULT(1, FACILITY_XPS, 0x504) 
#define XPS_E_UNEXPECTED_COLORPROFILE                    MAKE_HRESULT(1, FACILITY_XPS, 0x505) 
#define XPS_E_COLOR_COMPONENT_OUT_OF_RANGE               MAKE_HRESULT(1, FACILITY_XPS, 0x506) 
#define XPS_E_BOTH_PATHFIGURE_AND_ABBR_SYNTAX_PRESENT    MAKE_HRESULT(1, FACILITY_XPS, 0x507) 
#define XPS_E_BOTH_RESOURCE_AND_SOURCEATTR_PRESENT       MAKE_HRESULT(1, FACILITY_XPS, 0x508) 
#define XPS_E_BLEED_BOX_PAGE_DIMENSIONS_NOT_IN_SYNC      MAKE_HRESULT(1, FACILITY_XPS, 0x509) 
#define XPS_E_RELATIONSHIP_EXTERNAL                      MAKE_HRESULT(1, FACILITY_XPS, 0x50a) 
#define XPS_E_NOT_ENOUGH_GRADIENT_STOPS                  MAKE_HRESULT(1, FACILITY_XPS, 0x50b) 
#define XPS_E_PACKAGE_WRITER_NOT_CLOSED                  MAKE_HRESULT(1, FACILITY_XPS, 0x50c) 
#endif // (NTDDI >= NTDDI_WIN7)


extern RPC_IF_HANDLE __MIDL_itf_xpsobjectmodel_0001_0116_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_xpsobjectmodel_0001_0116_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\_dbdao.h ===
/************************************************************************
**	_ D B D A O . H													*
**																		*
*************************************************************************
** Copyright (C) 1996 by Microsoft Corporation		 			*
**		   All Rights Reserved					 						*
************************************************************************/
/*
	_DBDAO.H

	Internal definitions and prototypes for dbdao C++ classes
*/
#ifndef __DBDAO_H_
#define __DBDAO_H_


/*****************************************************************************
* Forwards
*/
class COleVariant;
class CdbBookmark;
class CdbException;
class CdbOleObject;
class CdbObject;
class CdbError;
class CdbProperty;
class CdbDBEngine;
class CdbWorkspace;
class CdbDatabase;
class CdbConnection;
class CdbRecordset;
class CdbGetRowsEx;
class CdbQueryDef;
class CdbTableDef;
class CdbField;
class CdbRelation;
class CdbIndex;
class CdbUser;
class CdbGroup;
class CdbDocument;
class CdbContainer;
class CdbParameter;
class CdbCollection;
class CdbErrors;
class CdbProperties;
class CdbWorkspaces;
class CdbDatabases;
class CdbConnections;
class CdbRecordsets;
class CdbQueryDefs;
class CdbTableDefs;
class CdbFields;
class CdbRelations;
class CdbIndexes;
class CdbUsers;
class CdbGroups;
class CdbDocuments;
class CdbContainers;
class CdbParameters;
class CdbBStr;

/*****************************************************************************
* DAO runtime key
*/
const char szKEY[] = "mbmabptebkjcdlgtjmskjwtsdhjbmkmwtrak";

/*****************************************************************************
* Miscellaneous defines
*/
#define DAO_MAXSEEKFIELDS 13


/*****************************************************************************
* CdbBSTR (OLE BSTR helper)
*/
class DLLEXPORT CdbBSTR
	{
	public:
	CONSTRUCTOR			CdbBSTR				(BSTR=NULL);
	DESTRUCTOR			~CdbBSTR			(VOID);

	operator			BSTR *				(VOID);
	operator			LPCTSTR				(VOID);

	private:
	BSTR				m_bstr;
	};

/*****************************************************************************
* CdbVariant (OLE Variant helper)
*/
class CdbVariant : public COleVariant
	{
	public:
	CONSTRUCTOR						CdbVariant						(LONG l);
	CONSTRUCTOR                     CdbVariant                      (VOID);
	CONSTRUCTOR                     CdbVariant                      (LPCTSTR pstr);
	CONSTRUCTOR                     CdbVariant                      (SHORT s, BOOL bIsBool = FALSE);
	CONSTRUCTOR                     CdbVariant                      (LPVARIANT pv);
	CONSTRUCTOR                     CdbVariant                      (LPSAFEARRAY psa);

	VOID                            operator =                      (LPVARIANT pv);
	VOID                            operator =                      (LPCTSTR pstr);
	VOID                            operator =                      (SHORT s);
	VOID                            operator =                      (const int i);
	VOID                            operator =                      (LONG l);
	};

inline CONSTRUCTOR	CdbVariant::CdbVariant(
	VOID) : COleVariant()
	{
	vt		= VT_ERROR;
	scode	= DISP_E_PARAMNOTFOUND;
	}

inline CdbVariant::CdbVariant (LONG l)
{
		if (l == -1)		
			{	
			vt		= VT_ERROR;
			scode	= DISP_E_PARAMNOTFOUND;
			}
		else
			{
			vt		= VT_I4;
			lVal	= l;
			}
}


inline CONSTRUCTOR	CdbVariant::CdbVariant(
	LPCTSTR pstr): COleVariant(pstr,VT_BSTRT)
	{
	if (!pstr)
		{
		VariantClear(this);
		vt		= VT_ERROR;
		scode	= DISP_E_PARAMNOTFOUND;
		}
	}


inline CONSTRUCTOR	CdbVariant::CdbVariant(
	SHORT s, BOOL bIsBool) : COleVariant(s)
	{
	if (bIsBool)
		{
		vt		= VT_BOOL;
		boolVal	= s;
		}
	else if (s==-1)
		{
		vt		= VT_ERROR;
		scode	= DISP_E_PARAMNOTFOUND;
		}
	}

inline CONSTRUCTOR	CdbVariant::CdbVariant(
	LPVARIANT	pv)
	{
	if (!pv)
		{
		vt		= VT_ERROR;
		scode	= DISP_E_PARAMNOTFOUND;
		}
	else
		VariantCopy(this, pv);
	}

inline CONSTRUCTOR	CdbVariant::CdbVariant(
	LPSAFEARRAY psa)
	{
	if (!psa)
		{
		vt		= VT_ERROR;
		scode	= DISP_E_PARAMNOTFOUND;
		}
	else
		{
		vt		= VT_ARRAY|VT_UI1;
		parray	= psa;
		}
	}

inline VOID	CdbVariant::operator =(
	LPVARIANT pv)
	{
	if (!pv)
		{
		vt		= VT_ERROR;
		scode	= DISP_E_PARAMNOTFOUND;
		}
	else
		VariantCopy(this, pv);
	}

inline VOID	CdbVariant::operator =(
	LPCTSTR pstr) 
	{
	if (!pstr)
		{
		VariantClear(this);
		vt		= VT_ERROR;
		scode	= DISP_E_PARAMNOTFOUND;
		}
	else
		{
#ifdef UNICODE
		bstrVal = SysAllocString(pstr);
#else
		bstrVal = SysAllocStringByteLen(pstr, strlen(pstr));
#endif
		vt = VT_BSTR;
		}
	}


inline VOID	CdbVariant::operator =(
	SHORT s)
	{
	if (s==-1)
		{
		vt		= VT_ERROR;
		scode	= DISP_E_PARAMNOTFOUND;
		}
	else
		{
		vt		= VT_I2;
		iVal	= s;
		}
	}

inline VOID	CdbVariant::operator =(
	const int i)
	{
	if (i==-1)
		{
		vt		= VT_ERROR;
		scode	= DISP_E_PARAMNOTFOUND;
		}
	else
		{
		vt		= VT_I2;
		iVal	= (SHORT)i;
		}
	}


inline VOID	CdbVariant::operator =(
	LONG 	l)
	{
	if (l==-1)
		{
		vt 		= VT_ERROR;
		scode	= DISP_E_PARAMNOTFOUND;
		}
	else
		{
		vt		= VT_I4;
		lVal	= l;
		}
	}


/*****************************************************************************
* CdbWide
*/
HRESULT	CdbWideFromAnsi(LPSTR, unsigned int, BSTR *);

class CdbWide
	{
	public:
	CONSTRUCTOR			CdbWide				(LPSTR pstr, unsigned int cb=0)
		{
		CdbWideFromAnsi(pstr, (pstr ? (cb==0 ? strlen(pstr) : cb) : 0), &m_bstr);
		}
	DESTRUCTOR			~CdbWide			()
		{
		SysFreeString(m_bstr);
		}

	operator			LPWSTR					()
		{
		return (LPWSTR)m_bstr;
		}
	operator			LPSTR					()
		{
		return (LPSTR)m_bstr;
		}

	ULONG				cBytes					()
		{
		return SysStringByteLen(m_bstr);
		}

	private:
	BSTR				m_bstr;
	};


/*****************************************************************************
* CdbOleObject
*/
class DLLEXPORT CdbOleObject : public CObject
	{
	public:
	CONSTRUCTOR                             CdbOleObject            (VOID);
	virtual DESTRUCTOR						~CdbOleObject           (VOID);
	BOOL                                    Exists                  (VOID);
	CdbOleObject &							operator =              (CdbOleObject &o);
											operator LPUNKNOWN		(){ return GetInterface();}
	VOID                                    SetInterface            (LPUNKNOWN punk, BOOL bAddRef=FALSE);
	VOID                                    SetInterface            (REFIID riidClass, REFIID riidInterface);
	VOID                                    SetInterfaceLic         (REFIID riidClass, REFIID riidInterface);
	LPUNKNOWN								GetInterface            (BOOL bAddRef=FALSE, BOOL bThrowException=TRUE) const;

	virtual VOID							OnInterfaceChange       (VOID);
	VOID                                    SetRichErrorInfo        (LPOLESTR pstrSource, LPOLESTR pstrDescription, LPOLESTR pstrHelpFile, ULONG ulHelpID) const;

	protected:
	BOOL                                    StartOLE                        (VOID);
	LPUNKNOWN                               m_punkInterface;
	};



/*****************************************************************************
* CdbCollection
*/
class DLLEXPORT CdbCollection : public CdbOleObject
	{
	public:

	// Methods
	virtual CdbObject               ObItem                  (LONG i) = 0;
	virtual CdbObject               ObItem                  (LPCTSTR pstr) = 0;
	virtual LONG                    GetCount                (VOID) = 0;
	virtual VOID                    ObAppend                (CdbObject &obj) = 0;
	virtual VOID                    Delete                  (LPCTSTR pstr) = 0;
	virtual VOID                    Refresh                 (VOID) = 0;
	};

class DLLEXPORT CdbStaticCollection : public CdbCollection
	{
	public:
	CdbObject                               ObItem                  (LONG i);
	CdbObject                               ObItem                  (LPCTSTR pstr);
	LONG                                    GetCount                (VOID);
	VOID                                    ObAppend                (CdbObject &obj);
	VOID                                    Delete                  (LPCTSTR pstr);
	VOID                                    Refresh                 (VOID) ;
	};

class DLLEXPORT CdbDynamicCollection : public CdbCollection
	{
	public:
	CdbObject                               ObItem                  (LONG i);
	CdbObject                               ObItem                  (LPCTSTR pstr);
	LONG                                    GetCount                (VOID);
	VOID                                    ObAppend                (CdbObject &obj);
	VOID                                    Delete                  (LPCTSTR pstr);
	VOID                                    Refresh                 (VOID);
	};

#define DAOMFC_STATIC_COLLECTION_DECL(objColl, objSingle, intSingle)    \
	class DLLEXPORT objColl : public CdbStaticCollection                                                    \
		{                                                                                                                               \
		public:                                                                                                                 \
																		\
		objSingle                       Item                            (LONG i);                               \
		objSingle                       Item                            (LPCTSTR pstr);                 \
		objSingle                       operator[]                      (LONG i);                               \
		objSingle                       operator[]                      (LPCTSTR pstr);                 \
		}

#define DAOMFC_DYNAMIC_COLLECTION_DECL(objColl, objSingle, intSingle)   \
	class DLLEXPORT objColl : public CdbDynamicCollection                                                   \
		{                                                                                                                               \
		public:                                                                                                                 \
																		\
		objSingle                       Item                            (LONG i);                               \
		objSingle                       Item                            (LPCTSTR pstr);                 \
		VOID                            Append                          (objSingle &o);                 \
		objSingle                       operator[]                      (LONG i);                               \
		objSingle                       operator[]                      (LPCTSTR pstr);                 \
		}

DAOMFC_STATIC_COLLECTION_DECL(CdbErrors, CdbError, DAOError);
DAOMFC_STATIC_COLLECTION_DECL(CdbDatabases, CdbDatabase, DAODatabase);
//Connections are special cased so we can trap the copy constructor
DAOMFC_STATIC_COLLECTION_DECL(CdbRecordsets, CdbRecordset, DAORecordset);
DAOMFC_STATIC_COLLECTION_DECL(CdbParameters, CdbParameter, DAOParameter);
DAOMFC_STATIC_COLLECTION_DECL(CdbDocuments, CdbDocument, DAODocument);
DAOMFC_STATIC_COLLECTION_DECL(CdbContainers, CdbContainer, DAOContainer);

DAOMFC_DYNAMIC_COLLECTION_DECL(CdbProperties, CdbProperty, DAOProperty);
DAOMFC_DYNAMIC_COLLECTION_DECL(CdbFields, CdbField, DAOField);
DAOMFC_DYNAMIC_COLLECTION_DECL(CdbQueryDefs, CdbQueryDef, DAOQueryDef);
DAOMFC_DYNAMIC_COLLECTION_DECL(CdbTableDefs, CdbTableDef, DAOTableDef);
DAOMFC_DYNAMIC_COLLECTION_DECL(CdbIndexes, CdbIndex, DAOIndex);
DAOMFC_DYNAMIC_COLLECTION_DECL(CdbRelations, CdbRelation, DAORelation);
DAOMFC_DYNAMIC_COLLECTION_DECL(CdbUsers, CdbUser, DAOUser);
DAOMFC_DYNAMIC_COLLECTION_DECL(CdbGroups, CdbGroup, DAOGroup);

//Need some extra functions in CdbWorkspaces to support the delay in creating the 
//default workspace needed to support the JET/ODBC option.
class DLLEXPORT CdbWorkspaces : public CdbDynamicCollection
	{        
	friend CdbDBEngine;
	private:
	DAODBEngine	*					pDBEng;
	BOOL							m_bDontStart;

	public:                                                                                                                 
	CONSTRUCTOR                     CdbWorkspaces			(VOID){pDBEng = NULL;}
	CdbWorkspace                    Item                    (LONG i);                               
	CdbWorkspace                    Item                    (LPCTSTR pstr);                 
	VOID                            Append                  (CdbWorkspace &o);                 
	CdbWorkspace                    operator[]              (LONG i);                         
	CdbWorkspace                    operator[]              (LPCTSTR pstr);                
	VOID                            SetDBEngine	            (DAODBEngine	*peng){pDBEng = peng;}
	VOID	                        GetDelayedInterface     ();
	};

//Need to trap Connections in the copy constructor so the user can't
//get a "sorta-kinda" working Connections collection on a Jet workspace
class DLLEXPORT CdbConnections : public CdbStaticCollection
	{        
	public:
	CONSTRUCTOR						CdbConnections			(CdbConnections &Connections);
	CONSTRUCTOR						CdbConnections			(){pwrk = NULL;}
	CdbConnection                   Item                    (LONG i);                               
	CdbConnection                   Item                    (LPCTSTR pstr);                 
	CdbConnection                   operator[]              (LONG i);                               
	CdbConnection                   operator[]              (LPCTSTR pstr);               
	CdbConnections	&				operator =				(CdbConnections &o);
	LONG                            GetCount                (VOID);
	VOID                            Refresh                 (VOID) ;
	VOID							SetWorkspace			(DAOWorkspace * pParent){pwrk = pParent;}			

	private:
	VOID							CheckInterface();
	DAOWorkspace *					pwrk;
	};

/*****************************************************************************
* CdbObject
*/
class DLLEXPORT CdbObject : public CdbOleObject
	{
	public:
	CONSTRUCTOR                             CdbObject                       (VOID);
	CONSTRUCTOR                             CdbObject                       (LPUNKNOWN punk, BOOL bAddRef=FALSE);

	virtual CString                 GetName                         (VOID); 
	virtual VOID                    SetName                         (LPCTSTR pstr);

	CdbProperties                   Properties;
	};



/*****************************************************************************
* CdbGetRowsEx  (holds GetRowsEx for Recordset)
*/

class DLLEXPORT CdbGetRowsEx : public CdbObject
	{
	public:

	// Administration
	CONSTRUCTOR                     CdbGetRowsEx            (VOID);
	CONSTRUCTOR                     CdbGetRowsEx            (ICDAORecordset *pGetRows, BOOL bAddRef=FALSE);
	CONSTRUCTOR                     CdbGetRowsEx            (const CdbGetRowsEx &);
	CdbGetRowsEx &          operator =                      (const CdbGetRowsEx &);
	VOID                            OnInterfaceChange       (VOID);

	};

/*****************************************************************************
* Helper macros
*/

//Initialize a variant
#define DAOVINIT(var)						\
	do										\
		{									\
		(var).vt	= VT_ERROR;				\
		(var).scode	= DISP_E_PARAMNOTFOUND;	\
		}									\
	while (0)


// LPTSTR to VARIANT
#define STV(pstr)	CdbVariant(pstr)

// LPTSTR to BSTR
#define STB(pstr)	V_BSTR(((LPVARIANT)STV(pstr)))

// LONG to VARIANT
#define LTV(l)		CdbVariant(l)

// Optional LONG to VARIANT
#define OLTV(l)		CdbVariant((l))

// C/C++ bool to DAO bool
#define BTB(b)		((VARIANT_BOOL)(b?-1:0))

// C/C++ bool to VARIANT
#define BTV(b)		CdbVariant(BTB(b), TRUE)

// C/C++ short to VARIANT
#define SHTV(s)		CdbVariant((SHORT)s)

// OLE variant to VARIANT
#define VTV(pv)		CdbVariant(pv)

// SAFEARRAY to VARIANT
#define ATV(psa, var)								\
	do												\
		{											\
		if (!psa)									\
			{										\
			var.vt		= VT_ERROR;					\
			var.scode	= DISP_E_PARAMNOTFOUND;		\
			}										\
		else										\
			{										\
			var.vt		= VT_ARRAY|VT_UI1;			\
			SafeArrayCopy(psa, &var.parray);	\
			}										\
		}											\
	while (0)

#define DAOMFC_CALL(hr)						\
	do \
	{ \
    HRESULT  hresult = (hr);           \
		if(FAILED(hresult)) \
		{ \
			TRACE0("\nDBDAO Call Failed.\n\t"); \
			TRACE2("\nIn file %s on line %d\n", _T("DBDAO.CPP"), __LINE__); \
			TRACE1("hResult = %X\n", hresult); \
			if (GetScode(hresult) == E_OUTOFMEMORY) \
				AfxThrowMemoryException(); \
			else \
				throw CdbException(hresult); \
		} \
	} while (0)


/*****************************************************************************
* Property Set/Get helper macros
*/

// Get a LONG property
#define LPROPGET(intDAO, meth)						\
	do												\
		{											\
		intDAO *	p	= (intDAO *)GetInterface();	\
		LONG		l	= 0;						\
													\
		DAOMFC_CALL(p->meth(&l));					\
													\
		return l;									\
		}											\
	while (0)

// Set a LONG property
#define LPROPSET(intDAO, meth, l)					\
	do												\
		{											\
		intDAO *	p = (intDAO *)GetInterface();	\
													\
		DAOMFC_CALL(p->meth(l));					\
		}											\
	while(0)

// Get a SHORT property
#define WPROPGET(intDAO, meth)						\
	do												\
		{											\
		intDAO *	p	= (intDAO *)GetInterface();	\
		SHORT		s	= 0;						\
													\
		DAOMFC_CALL(p->meth(&s));					\
													\
		return s;									\
		}											\
	while (0)

// Set a SHORT property
#define WPROPSET(intDAO, meth, s)					\
	do												\
		{											\
		intDAO *	p = (intDAO *)GetInterface();	\
													\
		DAOMFC_CALL(p->meth(s));					\
		}											\
	while(0)

// Get a STRING property
#define SPROPGET(intDAO, meth)						\
	do												\
		{											\
		intDAO *	p	= (intDAO *)GetInterface();	\
		CdbBSTR		bstr;							\
													\
		DAOMFC_CALL(p->meth(bstr));					\
													\
		return bstr;								\
		}											\
	while (0)

// Set a STRING property
#define SPROPSET(intDAO, meth, s)					\
	do												\
		{											\
		intDAO *	p = (intDAO *)GetInterface();	\
													\
		DAOMFC_CALL(p->meth(STB(s)));				\
		}											\
	while(0)

// Get a DATETIME property
#define DPROPGET(intDAO, meth)						\
	do												\
		{											\
		intDAO *	p	= (intDAO *)GetInterface();	\
		VARIANT 	Var;								\
													\
		VariantInit(&Var);							\
		DAOMFC_CALL(p->meth(&Var));					\
		return Var;									\
		}											\
	while (0)

// Set a DATETIME property
#define DPROPSET(intDAO, meth, pv)					\
	do												\
		{											\
		intDAO *	p = (intDAO *)GetInterface();	\
													\
		DAOMFC_CALL(p->meth(*pv));					\
		}											\
	while(0)

// Get a BOOLEAN property
#define BPROPGET(intDAO, meth)							\
	do													\
		{												\
		intDAO *		p	= (intDAO *)GetInterface();	\
		VARIANT_BOOL	vb	= 0;						\
														\
		DAOMFC_CALL(p->meth(&vb));						\
														\
		return (BOOL)vb;								\
		}												\
	while (0)

// Set a BOOLEAN property
#define BPROPSET(intDAO, meth, b)						\
	do													\
		{												\
		intDAO *	p = (intDAO *)GetInterface();		\
														\
		DAOMFC_CALL(p->meth(BTB(b)));					\
		}												\
	while(0)

// Get a VARIANT property
#define VPROPGET(intDAO, meth)						\
	do												\
		{											\
		intDAO *	p	= (intDAO *)GetInterface();	\
		COleVariant 	v;								\
													\
		VariantInit(&v);							\
		DAOMFC_CALL(p->meth(&v));					\
													\
		return &v;									\
		}											\
	while (0)

// Set a VARIANT property
#define VPROPSET(intDAO, meth, pv)					\
	do												\
		{											\
		intDAO *	p = (intDAO *)GetInterface();	\
													\
		DAOMFC_CALL(p->meth(*pv));					\
		}											\
	while(0)

// Get a DWORD property
#define DWPROPGET(intDAO, meth)						\
	do												\
		{											\
		intDAO *	p	= (intDAO *)GetInterface();	\
		DWORD		dw	= 0;						\
													\
		DAOMFC_CALL(p->meth(&dw));					\
													\
		return dw;									\
		}											\
	while (0)


#define DAOMFC_STATIC_COLLECTION_IMPL(objColl, objSingle, intColl, intSingle)													 \
		objSingle			objColl::Item				(LONG i) 		{ return (intSingle *)(ObItem(i).GetInterface(TRUE)); }	 \
		objSingle			objColl::Item				(LPCTSTR pstr)	{ return (intSingle *)(ObItem(pstr).GetInterface(TRUE)); } \
		objSingle			objColl::operator[]			(LONG i)		{ return (intSingle *)(Item(i).GetInterface(TRUE)); } \
		objSingle			objColl::operator[]			(LPCTSTR pstr)	{ return (intSingle *)(Item(pstr).GetInterface(TRUE)); }

#define DAOMFC_DYNAMIC_COLLECTION_IMPL(objColl, objSingle, intColl, intSingle)													 \
		objSingle			objColl::Item				(LONG i) 		{ return (intSingle *)(ObItem(i).GetInterface(TRUE)); }	 \
		objSingle			objColl::Item				(LPCTSTR pstr)	{ return (intSingle *)(ObItem(pstr).GetInterface(TRUE)); } \
		VOID				objColl::Append				(objSingle &o)	{ ObAppend(o); } \
		objSingle			objColl::operator[]			(LONG i)		{ return (intSingle *)(Item(i).GetInterface(TRUE)); } \
		objSingle			objColl::operator[]			(LPCTSTR pstr)	{ return (intSingle *)(Item(pstr).GetInterface(TRUE)); }

DECLARE_INTERFACE_(DAOMFCSCollection, _DAOCollection)
{
STDMETHOD(get_Item)		(VARIANT index, LPUNKNOWN *ppunk);
};

DECLARE_INTERFACE_(DAOMFCDCollection, _DAODynaCollection)
{
STDMETHOD(get_Item)		(VARIANT index, LPUNKNOWN *ppunk);
};


#endif // __DBDAO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\gl\GLU.h ===
/*++ BUILD Version: 0004    // Increment this if a change has global effects

Copyright (c) 1985-95, Microsoft Corporation

Module Name:

    glu.h

Abstract:

    Procedure declarations, constant definitions and macros for the OpenGL
    Utility Library.

--*/

#ifndef __glu_h__
#ifndef __GLU_H__

#define __glu_h__
#define __GLU_H__

#include <GL/gl.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** Return the error string associated with a particular error code.
** This will return 0 for an invalid error code.
**
** The generic function prototype that can be compiled for ANSI or Unicode
** is defined as follows:
**
** LPCTSTR APIENTRY gluErrorStringWIN (GLenum errCode);
*/
#ifdef UNICODE
#define gluErrorStringWIN(errCode) ((LPCSTR)  gluErrorUnicodeStringEXT(errCode))
#else
#define gluErrorStringWIN(errCode) ((LPCWSTR) gluErrorString(errCode))
#endif

const GLubyte* APIENTRY gluErrorString (
    GLenum   errCode);

const wchar_t* APIENTRY gluErrorUnicodeStringEXT (
    GLenum   errCode);

const GLubyte* APIENTRY gluGetString (
    GLenum   name);

void APIENTRY gluOrtho2D (
    GLdouble left, 
    GLdouble right, 
    GLdouble bottom, 
    GLdouble top);

void APIENTRY gluPerspective (
    GLdouble fovy, 
    GLdouble aspect, 
    GLdouble zNear, 
    GLdouble zFar);

void APIENTRY gluPickMatrix (
    GLdouble x, 
    GLdouble y, 
    GLdouble width, 
    GLdouble height, 
    GLint    viewport[4]);

void APIENTRY gluLookAt (
    GLdouble eyex, 
    GLdouble eyey, 
    GLdouble eyez, 
    GLdouble centerx, 
    GLdouble centery, 
    GLdouble centerz, 
    GLdouble upx, 
    GLdouble upy, 
    GLdouble upz);

int APIENTRY gluProject (
    GLdouble        objx, 
    GLdouble        objy, 
    GLdouble        objz,  
    const GLdouble  modelMatrix[16], 
    const GLdouble  projMatrix[16], 
    const GLint     viewport[4], 
    GLdouble        *winx, 
    GLdouble        *winy, 
    GLdouble        *winz);

int APIENTRY gluUnProject (
    GLdouble       winx, 
    GLdouble       winy, 
    GLdouble       winz, 
    const GLdouble modelMatrix[16], 
    const GLdouble projMatrix[16], 
    const GLint    viewport[4], 
    GLdouble       *objx, 
    GLdouble       *objy, 
    GLdouble       *objz);


int APIENTRY gluScaleImage (
    GLenum      format, 
    GLint       widthin, 
    GLint       heightin, 
    GLenum      typein, 
    const void  *datain, 
    GLint       widthout, 
    GLint       heightout, 
    GLenum      typeout, 
    void        *dataout);


int APIENTRY gluBuild1DMipmaps (
    GLenum      target, 
    GLint       components, 
    GLint       width, 
    GLenum      format, 
    GLenum      type, 
    const void  *data);

int APIENTRY gluBuild2DMipmaps (
    GLenum      target, 
    GLint       components, 
    GLint       width, 
    GLint       height, 
    GLenum      format, 
    GLenum      type, 
    const void  *data);

#ifdef __cplusplus

class GLUnurbs;
class GLUquadric;
class GLUtesselator;

/* backwards compatibility: */
typedef class GLUnurbs GLUnurbsObj;
typedef class GLUquadric GLUquadricObj;
typedef class GLUtesselator GLUtesselatorObj;
typedef class GLUtesselator GLUtriangulatorObj;

#else

typedef struct GLUnurbs GLUnurbs;
typedef struct GLUquadric GLUquadric;
typedef struct GLUtesselator GLUtesselator;

/* backwards compatibility: */
typedef struct GLUnurbs GLUnurbsObj;
typedef struct GLUquadric GLUquadricObj;
typedef struct GLUtesselator GLUtesselatorObj;
typedef struct GLUtesselator GLUtriangulatorObj;

#endif


GLUquadric* APIENTRY gluNewQuadric (void);
void APIENTRY gluDeleteQuadric (
    GLUquadric          *state);

void APIENTRY gluQuadricNormals (
    GLUquadric          *quadObject, 
    GLenum              normals);

void APIENTRY gluQuadricTexture (
    GLUquadric          *quadObject, 
    GLboolean           textureCoords);

void APIENTRY gluQuadricOrientation (
    GLUquadric          *quadObject, 
    GLenum              orientation);

void APIENTRY gluQuadricDrawStyle (
    GLUquadric          *quadObject, 
    GLenum              drawStyle);

void APIENTRY gluCylinder (
    GLUquadric          *qobj, 
    GLdouble            baseRadius, 
    GLdouble            topRadius, 
    GLdouble            height, 
    GLint               slices, 
    GLint               stacks);

void APIENTRY gluDisk (
    GLUquadric          *qobj, 
    GLdouble            innerRadius, 
    GLdouble            outerRadius, 
    GLint               slices, 
    GLint               loops);

void APIENTRY gluPartialDisk (
    GLUquadric          *qobj, 
    GLdouble            innerRadius, 
    GLdouble            outerRadius, 
    GLint               slices, 
    GLint               loops, 
    GLdouble            startAngle, 
    GLdouble            sweepAngle);

void APIENTRY gluSphere (
    GLUquadric          *qobj, 
    GLdouble            radius, 
    GLint               slices, 
    GLint               stacks);

void APIENTRY gluQuadricCallback (
    GLUquadric          *qobj, 
    GLenum              which, 
    void                (CALLBACK* fn)());

GLUtesselator* APIENTRY  gluNewTess(          
    void );

void APIENTRY  gluDeleteTess(       
    GLUtesselator       *tess );

void APIENTRY  gluTessBeginPolygon( 
    GLUtesselator       *tess,
    void                *polygon_data );

void APIENTRY  gluTessBeginContour( 
    GLUtesselator       *tess );

void APIENTRY  gluTessVertex(       
    GLUtesselator       *tess,
    GLdouble            coords[3], 
    void                *data );

void APIENTRY  gluTessEndContour(   
    GLUtesselator       *tess );

void APIENTRY  gluTessEndPolygon(   
    GLUtesselator       *tess );

void APIENTRY  gluTessProperty(     
    GLUtesselator       *tess,
    GLenum              which, 
    GLdouble            value );
 
void APIENTRY  gluTessNormal(       
    GLUtesselator       *tess, 
    GLdouble            x,
    GLdouble            y, 
    GLdouble            z );

void APIENTRY  gluTessCallback(     
    GLUtesselator       *tess,
    GLenum              which, 
    void                (CALLBACK *fn)());

void APIENTRY  gluGetTessProperty(  
    GLUtesselator       *tess,
    GLenum              which, 
    GLdouble            *value );
 
GLUnurbs* APIENTRY gluNewNurbsRenderer (void);

void APIENTRY gluDeleteNurbsRenderer (
    GLUnurbs            *nobj);

void APIENTRY gluBeginSurface (
    GLUnurbs            *nobj);

void APIENTRY gluBeginCurve (
    GLUnurbs            *nobj);

void APIENTRY gluEndCurve (
    GLUnurbs            *nobj);

void APIENTRY gluEndSurface (
    GLUnurbs            *nobj);

void APIENTRY gluBeginTrim (
    GLUnurbs            *nobj);

void APIENTRY gluEndTrim (
    GLUnurbs            *nobj);

void APIENTRY gluPwlCurve (
    GLUnurbs            *nobj, 
    GLint               count, 
    GLfloat             *array, 
    GLint               stride, 
    GLenum              type);

void APIENTRY gluNurbsCurve (
    GLUnurbs            *nobj, 
    GLint               nknots, 
    GLfloat             *knot, 
    GLint               stride, 
    GLfloat             *ctlarray, 
    GLint               order, 
    GLenum              type);

void APIENTRY 
gluNurbsSurface(     
    GLUnurbs            *nobj, 
    GLint               sknot_count, 
    float               *sknot, 
    GLint               tknot_count, 
    GLfloat             *tknot, 
    GLint               s_stride, 
    GLint               t_stride, 
    GLfloat             *ctlarray, 
    GLint               sorder, 
    GLint               torder, 
    GLenum              type);

void APIENTRY 
gluLoadSamplingMatrices (
    GLUnurbs            *nobj, 
    const GLfloat       modelMatrix[16], 
    const GLfloat       projMatrix[16], 
    const GLint         viewport[4] );

void APIENTRY 
gluNurbsProperty (
    GLUnurbs            *nobj, 
    GLenum              property, 
    GLfloat             value );

void APIENTRY 
gluGetNurbsProperty (
    GLUnurbs            *nobj, 
    GLenum              property, 
    GLfloat             *value );

void APIENTRY 
gluNurbsCallback (
    GLUnurbs            *nobj, 
    GLenum              which, 
    void                (CALLBACK* fn)() );


/****           Callback function prototypes    ****/

/* gluQuadricCallback */
typedef void (CALLBACK* GLUquadricErrorProc) (GLenum);

/* gluTessCallback */
typedef void (CALLBACK* GLUtessBeginProc)        (GLenum);
typedef void (CALLBACK* GLUtessEdgeFlagProc)     (GLboolean);
typedef void (CALLBACK* GLUtessVertexProc)       (void *);
typedef void (CALLBACK* GLUtessEndProc)          (void);
typedef void (CALLBACK* GLUtessErrorProc)        (GLenum);
typedef void (CALLBACK* GLUtessCombineProc)      (GLdouble[3],
                                                  void*[4], 
                                                  GLfloat[4],
                                                  void** );
typedef void (CALLBACK* GLUtessBeginDataProc)    (GLenum, void *);
typedef void (CALLBACK* GLUtessEdgeFlagDataProc) (GLboolean, void *);
typedef void (CALLBACK* GLUtessVertexDataProc)   (void *, void *);
typedef void (CALLBACK* GLUtessEndDataProc)      (void *);
typedef void (CALLBACK* GLUtessErrorDataProc)    (GLenum, void *);
typedef void (CALLBACK* GLUtessCombineDataProc)  (GLdouble[3],
                                                  void*[4], 
                                                  GLfloat[4],
                                                  void**,
                                                  void* );

/* gluNurbsCallback */
typedef void (CALLBACK* GLUnurbsErrorProc)   (GLenum);


/****           Generic constants               ****/

/* Version */
#define GLU_VERSION_1_1                 1
#define GLU_VERSION_1_2                 1

/* Errors: (return value 0 = no error) */
#define GLU_INVALID_ENUM        100900
#define GLU_INVALID_VALUE       100901
#define GLU_OUT_OF_MEMORY       100902
#define GLU_INCOMPATIBLE_GL_VERSION     100903

/* StringName */
#define GLU_VERSION             100800
#define GLU_EXTENSIONS          100801

/* Boolean */
#define GLU_TRUE                GL_TRUE
#define GLU_FALSE               GL_FALSE


/****           Quadric constants               ****/

/* QuadricNormal */
#define GLU_SMOOTH              100000
#define GLU_FLAT                100001
#define GLU_NONE                100002

/* QuadricDrawStyle */
#define GLU_POINT               100010
#define GLU_LINE                100011
#define GLU_FILL                100012
#define GLU_SILHOUETTE          100013

/* QuadricOrientation */
#define GLU_OUTSIDE             100020
#define GLU_INSIDE              100021

/* Callback types: */
/*      GLU_ERROR               100103 */


/****           Tesselation constants           ****/

#define GLU_TESS_MAX_COORD              1.0e150

/* TessProperty */
#define GLU_TESS_WINDING_RULE           100140
#define GLU_TESS_BOUNDARY_ONLY          100141
#define GLU_TESS_TOLERANCE              100142

/* TessWinding */
#define GLU_TESS_WINDING_ODD            100130
#define GLU_TESS_WINDING_NONZERO        100131
#define GLU_TESS_WINDING_POSITIVE       100132
#define GLU_TESS_WINDING_NEGATIVE       100133
#define GLU_TESS_WINDING_ABS_GEQ_TWO    100134

/* TessCallback */
#define GLU_TESS_BEGIN          100100  /* void (CALLBACK*)(GLenum    type)  */
#define GLU_TESS_VERTEX         100101  /* void (CALLBACK*)(void      *data) */
#define GLU_TESS_END            100102  /* void (CALLBACK*)(void)            */
#define GLU_TESS_ERROR          100103  /* void (CALLBACK*)(GLenum    errno) */
#define GLU_TESS_EDGE_FLAG      100104  /* void (CALLBACK*)(GLboolean boundaryEdge)  */
#define GLU_TESS_COMBINE        100105  /* void (CALLBACK*)(GLdouble  coords[3],
                                                            void      *data[4],
                                                            GLfloat   weight[4],
                                                            void      **dataOut)     */
#define GLU_TESS_BEGIN_DATA     100106  /* void (CALLBACK*)(GLenum    type,  
                                                            void      *polygon_data) */
#define GLU_TESS_VERTEX_DATA    100107  /* void (CALLBACK*)(void      *data, 
                                                            void      *polygon_data) */
#define GLU_TESS_END_DATA       100108  /* void (CALLBACK*)(void      *polygon_data) */
#define GLU_TESS_ERROR_DATA     100109  /* void (CALLBACK*)(GLenum    errno, 
                                                            void      *polygon_data) */
#define GLU_TESS_EDGE_FLAG_DATA 100110  /* void (CALLBACK*)(GLboolean boundaryEdge,
                                                            void      *polygon_data) */
#define GLU_TESS_COMBINE_DATA   100111  /* void (CALLBACK*)(GLdouble  coords[3],
                                                            void      *data[4],
                                                            GLfloat   weight[4],
                                                            void      **dataOut,
                                                            void      *polygon_data) */

/* TessError */
#define GLU_TESS_ERROR1     100151
#define GLU_TESS_ERROR2     100152
#define GLU_TESS_ERROR3     100153
#define GLU_TESS_ERROR4     100154
#define GLU_TESS_ERROR5     100155
#define GLU_TESS_ERROR6     100156
#define GLU_TESS_ERROR7     100157
#define GLU_TESS_ERROR8     100158

#define GLU_TESS_MISSING_BEGIN_POLYGON  GLU_TESS_ERROR1
#define GLU_TESS_MISSING_BEGIN_CONTOUR  GLU_TESS_ERROR2
#define GLU_TESS_MISSING_END_POLYGON    GLU_TESS_ERROR3
#define GLU_TESS_MISSING_END_CONTOUR    GLU_TESS_ERROR4
#define GLU_TESS_COORD_TOO_LARGE        GLU_TESS_ERROR5
#define GLU_TESS_NEED_COMBINE_CALLBACK  GLU_TESS_ERROR6

/****           NURBS constants                 ****/

/* NurbsProperty */
#define GLU_AUTO_LOAD_MATRIX    100200
#define GLU_CULLING             100201
#define GLU_SAMPLING_TOLERANCE  100203
#define GLU_DISPLAY_MODE        100204
#define GLU_PARAMETRIC_TOLERANCE        100202
#define GLU_SAMPLING_METHOD             100205
#define GLU_U_STEP                      100206
#define GLU_V_STEP                      100207

/* NurbsSampling */
#define GLU_PATH_LENGTH                 100215
#define GLU_PARAMETRIC_ERROR            100216
#define GLU_DOMAIN_DISTANCE             100217


/* NurbsTrim */
#define GLU_MAP1_TRIM_2         100210
#define GLU_MAP1_TRIM_3         100211

/* NurbsDisplay */
/*      GLU_FILL                100012 */
#define GLU_OUTLINE_POLYGON     100240
#define GLU_OUTLINE_PATCH       100241

/* NurbsCallback */
/*      GLU_ERROR               100103 */

/* NurbsErrors */
#define GLU_NURBS_ERROR1        100251
#define GLU_NURBS_ERROR2        100252
#define GLU_NURBS_ERROR3        100253
#define GLU_NURBS_ERROR4        100254
#define GLU_NURBS_ERROR5        100255
#define GLU_NURBS_ERROR6        100256
#define GLU_NURBS_ERROR7        100257
#define GLU_NURBS_ERROR8        100258
#define GLU_NURBS_ERROR9        100259
#define GLU_NURBS_ERROR10       100260
#define GLU_NURBS_ERROR11       100261
#define GLU_NURBS_ERROR12       100262
#define GLU_NURBS_ERROR13       100263
#define GLU_NURBS_ERROR14       100264
#define GLU_NURBS_ERROR15       100265
#define GLU_NURBS_ERROR16       100266
#define GLU_NURBS_ERROR17       100267
#define GLU_NURBS_ERROR18       100268
#define GLU_NURBS_ERROR19       100269
#define GLU_NURBS_ERROR20       100270
#define GLU_NURBS_ERROR21       100271
#define GLU_NURBS_ERROR22       100272
#define GLU_NURBS_ERROR23       100273
#define GLU_NURBS_ERROR24       100274
#define GLU_NURBS_ERROR25       100275
#define GLU_NURBS_ERROR26       100276
#define GLU_NURBS_ERROR27       100277
#define GLU_NURBS_ERROR28       100278
#define GLU_NURBS_ERROR29       100279
#define GLU_NURBS_ERROR30       100280
#define GLU_NURBS_ERROR31       100281
#define GLU_NURBS_ERROR32       100282
#define GLU_NURBS_ERROR33       100283
#define GLU_NURBS_ERROR34       100284
#define GLU_NURBS_ERROR35       100285
#define GLU_NURBS_ERROR36       100286
#define GLU_NURBS_ERROR37       100287

/****           Backwards compatibility for old tesselator           ****/

void APIENTRY   gluBeginPolygon( GLUtesselator *tess );

void APIENTRY   gluNextContour(  GLUtesselator *tess, 
                                 GLenum        type );

void APIENTRY   gluEndPolygon(   GLUtesselator *tess );

/* Contours types -- obsolete! */
#define GLU_CW          100120
#define GLU_CCW         100121
#define GLU_INTERIOR    100122
#define GLU_EXTERIOR    100123
#define GLU_UNKNOWN     100124

/* Names without "TESS_" prefix */
#define GLU_BEGIN       GLU_TESS_BEGIN
#define GLU_VERTEX      GLU_TESS_VERTEX
#define GLU_END         GLU_TESS_END
#define GLU_ERROR       GLU_TESS_ERROR
#define GLU_EDGE_FLAG   GLU_TESS_EDGE_FLAG

#ifdef __cplusplus
}
#endif

#endif /* __GLU_H__ */
#endif /* __glu_h__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\gl\GL.h ===
/*++ BUILD Version: 0004    // Increment this if a change has global effects

Copyright (c) 1985-96, Microsoft Corporation

Module Name:

    gl.h

Abstract:

    Procedure declarations, constant definitions and macros for the OpenGL
    component.

--*/

#ifndef __gl_h_
#ifndef __GL_H__

#define __gl_h_
#define __GL_H__

#ifdef __cplusplus
extern "C" {
#endif

/*
** Copyright 1996 Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

typedef unsigned int GLenum;
typedef unsigned char GLboolean;
typedef unsigned int GLbitfield;
typedef signed char GLbyte;
typedef short GLshort;
typedef int GLint;
typedef int GLsizei;
typedef unsigned char GLubyte;
typedef unsigned short GLushort;
typedef unsigned int GLuint;
typedef float GLfloat;
typedef float GLclampf;
typedef double GLdouble;
typedef double GLclampd;
typedef void GLvoid;

/*************************************************************/

/* Version */
#define GL_VERSION_1_1                    1

/* AccumOp */
#define GL_ACCUM                          0x0100
#define GL_LOAD                           0x0101
#define GL_RETURN                         0x0102
#define GL_MULT                           0x0103
#define GL_ADD                            0x0104

/* AlphaFunction */
#define GL_NEVER                          0x0200
#define GL_LESS                           0x0201
#define GL_EQUAL                          0x0202
#define GL_LEQUAL                         0x0203
#define GL_GREATER                        0x0204
#define GL_NOTEQUAL                       0x0205
#define GL_GEQUAL                         0x0206
#define GL_ALWAYS                         0x0207

/* AttribMask */
#define GL_CURRENT_BIT                    0x00000001
#define GL_POINT_BIT                      0x00000002
#define GL_LINE_BIT                       0x00000004
#define GL_POLYGON_BIT                    0x00000008
#define GL_POLYGON_STIPPLE_BIT            0x00000010
#define GL_PIXEL_MODE_BIT                 0x00000020
#define GL_LIGHTING_BIT                   0x00000040
#define GL_FOG_BIT                        0x00000080
#define GL_DEPTH_BUFFER_BIT               0x00000100
#define GL_ACCUM_BUFFER_BIT               0x00000200
#define GL_STENCIL_BUFFER_BIT             0x00000400
#define GL_VIEWPORT_BIT                   0x00000800
#define GL_TRANSFORM_BIT                  0x00001000
#define GL_ENABLE_BIT                     0x00002000
#define GL_COLOR_BUFFER_BIT               0x00004000
#define GL_HINT_BIT                       0x00008000
#define GL_EVAL_BIT                       0x00010000
#define GL_LIST_BIT                       0x00020000
#define GL_TEXTURE_BIT                    0x00040000
#define GL_SCISSOR_BIT                    0x00080000
#define GL_ALL_ATTRIB_BITS                0x000fffff

/* BeginMode */
#define GL_POINTS                         0x0000
#define GL_LINES                          0x0001
#define GL_LINE_LOOP                      0x0002
#define GL_LINE_STRIP                     0x0003
#define GL_TRIANGLES                      0x0004
#define GL_TRIANGLE_STRIP                 0x0005
#define GL_TRIANGLE_FAN                   0x0006
#define GL_QUADS                          0x0007
#define GL_QUAD_STRIP                     0x0008
#define GL_POLYGON                        0x0009

/* BlendingFactorDest */
#define GL_ZERO                           0
#define GL_ONE                            1
#define GL_SRC_COLOR                      0x0300
#define GL_ONE_MINUS_SRC_COLOR            0x0301
#define GL_SRC_ALPHA                      0x0302
#define GL_ONE_MINUS_SRC_ALPHA            0x0303
#define GL_DST_ALPHA                      0x0304
#define GL_ONE_MINUS_DST_ALPHA            0x0305

/* BlendingFactorSrc */
/*      GL_ZERO */
/*      GL_ONE */
#define GL_DST_COLOR                      0x0306
#define GL_ONE_MINUS_DST_COLOR            0x0307
#define GL_SRC_ALPHA_SATURATE             0x0308
/*      GL_SRC_ALPHA */
/*      GL_ONE_MINUS_SRC_ALPHA */
/*      GL_DST_ALPHA */
/*      GL_ONE_MINUS_DST_ALPHA */

/* Boolean */
#define GL_TRUE                           1
#define GL_FALSE                          0

/* ClearBufferMask */
/*      GL_COLOR_BUFFER_BIT */
/*      GL_ACCUM_BUFFER_BIT */
/*      GL_STENCIL_BUFFER_BIT */
/*      GL_DEPTH_BUFFER_BIT */

/* ClientArrayType */
/*      GL_VERTEX_ARRAY */
/*      GL_NORMAL_ARRAY */
/*      GL_COLOR_ARRAY */
/*      GL_INDEX_ARRAY */
/*      GL_TEXTURE_COORD_ARRAY */
/*      GL_EDGE_FLAG_ARRAY */

/* ClipPlaneName */
#define GL_CLIP_PLANE0                    0x3000
#define GL_CLIP_PLANE1                    0x3001
#define GL_CLIP_PLANE2                    0x3002
#define GL_CLIP_PLANE3                    0x3003
#define GL_CLIP_PLANE4                    0x3004
#define GL_CLIP_PLANE5                    0x3005

/* ColorMaterialFace */
/*      GL_FRONT */
/*      GL_BACK */
/*      GL_FRONT_AND_BACK */

/* ColorMaterialParameter */
/*      GL_AMBIENT */
/*      GL_DIFFUSE */
/*      GL_SPECULAR */
/*      GL_EMISSION */
/*      GL_AMBIENT_AND_DIFFUSE */

/* ColorPointerType */
/*      GL_BYTE */
/*      GL_UNSIGNED_BYTE */
/*      GL_SHORT */
/*      GL_UNSIGNED_SHORT */
/*      GL_INT */
/*      GL_UNSIGNED_INT */
/*      GL_FLOAT */
/*      GL_DOUBLE */

/* CullFaceMode */
/*      GL_FRONT */
/*      GL_BACK */
/*      GL_FRONT_AND_BACK */

/* DataType */
#define GL_BYTE                           0x1400
#define GL_UNSIGNED_BYTE                  0x1401
#define GL_SHORT                          0x1402
#define GL_UNSIGNED_SHORT                 0x1403
#define GL_INT                            0x1404
#define GL_UNSIGNED_INT                   0x1405
#define GL_FLOAT                          0x1406
#define GL_2_BYTES                        0x1407
#define GL_3_BYTES                        0x1408
#define GL_4_BYTES                        0x1409
#define GL_DOUBLE                         0x140A

/* DepthFunction */
/*      GL_NEVER */
/*      GL_LESS */
/*      GL_EQUAL */
/*      GL_LEQUAL */
/*      GL_GREATER */
/*      GL_NOTEQUAL */
/*      GL_GEQUAL */
/*      GL_ALWAYS */

/* DrawBufferMode */
#define GL_NONE                           0
#define GL_FRONT_LEFT                     0x0400
#define GL_FRONT_RIGHT                    0x0401
#define GL_BACK_LEFT                      0x0402
#define GL_BACK_RIGHT                     0x0403
#define GL_FRONT                          0x0404
#define GL_BACK                           0x0405
#define GL_LEFT                           0x0406
#define GL_RIGHT                          0x0407
#define GL_FRONT_AND_BACK                 0x0408
#define GL_AUX0                           0x0409
#define GL_AUX1                           0x040A
#define GL_AUX2                           0x040B
#define GL_AUX3                           0x040C

/* Enable */
/*      GL_FOG */
/*      GL_LIGHTING */
/*      GL_TEXTURE_1D */
/*      GL_TEXTURE_2D */
/*      GL_LINE_STIPPLE */
/*      GL_POLYGON_STIPPLE */
/*      GL_CULL_FACE */
/*      GL_ALPHA_TEST */
/*      GL_BLEND */
/*      GL_INDEX_LOGIC_OP */
/*      GL_COLOR_LOGIC_OP */
/*      GL_DITHER */
/*      GL_STENCIL_TEST */
/*      GL_DEPTH_TEST */
/*      GL_CLIP_PLANE0 */
/*      GL_CLIP_PLANE1 */
/*      GL_CLIP_PLANE2 */
/*      GL_CLIP_PLANE3 */
/*      GL_CLIP_PLANE4 */
/*      GL_CLIP_PLANE5 */
/*      GL_LIGHT0 */
/*      GL_LIGHT1 */
/*      GL_LIGHT2 */
/*      GL_LIGHT3 */
/*      GL_LIGHT4 */
/*      GL_LIGHT5 */
/*      GL_LIGHT6 */
/*      GL_LIGHT7 */
/*      GL_TEXTURE_GEN_S */
/*      GL_TEXTURE_GEN_T */
/*      GL_TEXTURE_GEN_R */
/*      GL_TEXTURE_GEN_Q */
/*      GL_MAP1_VERTEX_3 */
/*      GL_MAP1_VERTEX_4 */
/*      GL_MAP1_COLOR_4 */
/*      GL_MAP1_INDEX */
/*      GL_MAP1_NORMAL */
/*      GL_MAP1_TEXTURE_COORD_1 */
/*      GL_MAP1_TEXTURE_COORD_2 */
/*      GL_MAP1_TEXTURE_COORD_3 */
/*      GL_MAP1_TEXTURE_COORD_4 */
/*      GL_MAP2_VERTEX_3 */
/*      GL_MAP2_VERTEX_4 */
/*      GL_MAP2_COLOR_4 */
/*      GL_MAP2_INDEX */
/*      GL_MAP2_NORMAL */
/*      GL_MAP2_TEXTURE_COORD_1 */
/*      GL_MAP2_TEXTURE_COORD_2 */
/*      GL_MAP2_TEXTURE_COORD_3 */
/*      GL_MAP2_TEXTURE_COORD_4 */
/*      GL_POINT_SMOOTH */
/*      GL_LINE_SMOOTH */
/*      GL_POLYGON_SMOOTH */
/*      GL_SCISSOR_TEST */
/*      GL_COLOR_MATERIAL */
/*      GL_NORMALIZE */
/*      GL_AUTO_NORMAL */
/*      GL_VERTEX_ARRAY */
/*      GL_NORMAL_ARRAY */
/*      GL_COLOR_ARRAY */
/*      GL_INDEX_ARRAY */
/*      GL_TEXTURE_COORD_ARRAY */
/*      GL_EDGE_FLAG_ARRAY */
/*      GL_POLYGON_OFFSET_POINT */
/*      GL_POLYGON_OFFSET_LINE */
/*      GL_POLYGON_OFFSET_FILL */

/* ErrorCode */
#define GL_NO_ERROR                       0
#define GL_INVALID_ENUM                   0x0500
#define GL_INVALID_VALUE                  0x0501
#define GL_INVALID_OPERATION              0x0502
#define GL_STACK_OVERFLOW                 0x0503
#define GL_STACK_UNDERFLOW                0x0504
#define GL_OUT_OF_MEMORY                  0x0505

/* FeedBackMode */
#define GL_2D                             0x0600
#define GL_3D                             0x0601
#define GL_3D_COLOR                       0x0602
#define GL_3D_COLOR_TEXTURE               0x0603
#define GL_4D_COLOR_TEXTURE               0x0604

/* FeedBackToken */
#define GL_PASS_THROUGH_TOKEN             0x0700
#define GL_POINT_TOKEN                    0x0701
#define GL_LINE_TOKEN                     0x0702
#define GL_POLYGON_TOKEN                  0x0703
#define GL_BITMAP_TOKEN                   0x0704
#define GL_DRAW_PIXEL_TOKEN               0x0705
#define GL_COPY_PIXEL_TOKEN               0x0706
#define GL_LINE_RESET_TOKEN               0x0707

/* FogMode */
/*      GL_LINEAR */
#define GL_EXP                            0x0800
#define GL_EXP2                           0x0801


/* FogParameter */
/*      GL_FOG_COLOR */
/*      GL_FOG_DENSITY */
/*      GL_FOG_END */
/*      GL_FOG_INDEX */
/*      GL_FOG_MODE */
/*      GL_FOG_START */

/* FrontFaceDirection */
#define GL_CW                             0x0900
#define GL_CCW                            0x0901

/* GetMapTarget */
#define GL_COEFF                          0x0A00
#define GL_ORDER                          0x0A01
#define GL_DOMAIN                         0x0A02

/* GetPixelMap */
/*      GL_PIXEL_MAP_I_TO_I */
/*      GL_PIXEL_MAP_S_TO_S */
/*      GL_PIXEL_MAP_I_TO_R */
/*      GL_PIXEL_MAP_I_TO_G */
/*      GL_PIXEL_MAP_I_TO_B */
/*      GL_PIXEL_MAP_I_TO_A */
/*      GL_PIXEL_MAP_R_TO_R */
/*      GL_PIXEL_MAP_G_TO_G */
/*      GL_PIXEL_MAP_B_TO_B */
/*      GL_PIXEL_MAP_A_TO_A */

/* GetPointerTarget */
/*      GL_VERTEX_ARRAY_POINTER */
/*      GL_NORMAL_ARRAY_POINTER */
/*      GL_COLOR_ARRAY_POINTER */
/*      GL_INDEX_ARRAY_POINTER */
/*      GL_TEXTURE_COORD_ARRAY_POINTER */
/*      GL_EDGE_FLAG_ARRAY_POINTER */

/* GetTarget */
#define GL_CURRENT_COLOR                  0x0B00
#define GL_CURRENT_INDEX                  0x0B01
#define GL_CURRENT_NORMAL                 0x0B02
#define GL_CURRENT_TEXTURE_COORDS         0x0B03
#define GL_CURRENT_RASTER_COLOR           0x0B04
#define GL_CURRENT_RASTER_INDEX           0x0B05
#define GL_CURRENT_RASTER_TEXTURE_COORDS  0x0B06
#define GL_CURRENT_RASTER_POSITION        0x0B07
#define GL_CURRENT_RASTER_POSITION_VALID  0x0B08
#define GL_CURRENT_RASTER_DISTANCE        0x0B09
#define GL_POINT_SMOOTH                   0x0B10
#define GL_POINT_SIZE                     0x0B11
#define GL_POINT_SIZE_RANGE               0x0B12
#define GL_POINT_SIZE_GRANULARITY         0x0B13
#define GL_LINE_SMOOTH                    0x0B20
#define GL_LINE_WIDTH                     0x0B21
#define GL_LINE_WIDTH_RANGE               0x0B22
#define GL_LINE_WIDTH_GRANULARITY         0x0B23
#define GL_LINE_STIPPLE                   0x0B24
#define GL_LINE_STIPPLE_PATTERN           0x0B25
#define GL_LINE_STIPPLE_REPEAT            0x0B26
#define GL_LIST_MODE                      0x0B30
#define GL_MAX_LIST_NESTING               0x0B31
#define GL_LIST_BASE                      0x0B32
#define GL_LIST_INDEX                     0x0B33
#define GL_POLYGON_MODE                   0x0B40
#define GL_POLYGON_SMOOTH                 0x0B41
#define GL_POLYGON_STIPPLE                0x0B42
#define GL_EDGE_FLAG                      0x0B43
#define GL_CULL_FACE                      0x0B44
#define GL_CULL_FACE_MODE                 0x0B45
#define GL_FRONT_FACE                     0x0B46
#define GL_LIGHTING                       0x0B50
#define GL_LIGHT_MODEL_LOCAL_VIEWER       0x0B51
#define GL_LIGHT_MODEL_TWO_SIDE           0x0B52
#define GL_LIGHT_MODEL_AMBIENT            0x0B53
#define GL_SHADE_MODEL                    0x0B54
#define GL_COLOR_MATERIAL_FACE            0x0B55
#define GL_COLOR_MATERIAL_PARAMETER       0x0B56
#define GL_COLOR_MATERIAL                 0x0B57
#define GL_FOG                            0x0B60
#define GL_FOG_INDEX                      0x0B61
#define GL_FOG_DENSITY                    0x0B62
#define GL_FOG_START                      0x0B63
#define GL_FOG_END                        0x0B64
#define GL_FOG_MODE                       0x0B65
#define GL_FOG_COLOR                      0x0B66
#define GL_DEPTH_RANGE                    0x0B70
#define GL_DEPTH_TEST                     0x0B71
#define GL_DEPTH_WRITEMASK                0x0B72
#define GL_DEPTH_CLEAR_VALUE              0x0B73
#define GL_DEPTH_FUNC                     0x0B74
#define GL_ACCUM_CLEAR_VALUE              0x0B80
#define GL_STENCIL_TEST                   0x0B90
#define GL_STENCIL_CLEAR_VALUE            0x0B91
#define GL_STENCIL_FUNC                   0x0B92
#define GL_STENCIL_VALUE_MASK             0x0B93
#define GL_STENCIL_FAIL                   0x0B94
#define GL_STENCIL_PASS_DEPTH_FAIL        0x0B95
#define GL_STENCIL_PASS_DEPTH_PASS        0x0B96
#define GL_STENCIL_REF                    0x0B97
#define GL_STENCIL_WRITEMASK              0x0B98
#define GL_MATRIX_MODE                    0x0BA0
#define GL_NORMALIZE                      0x0BA1
#define GL_VIEWPORT                       0x0BA2
#define GL_MODELVIEW_STACK_DEPTH          0x0BA3
#define GL_PROJECTION_STACK_DEPTH         0x0BA4
#define GL_TEXTURE_STACK_DEPTH            0x0BA5
#define GL_MODELVIEW_MATRIX               0x0BA6
#define GL_PROJECTION_MATRIX              0x0BA7
#define GL_TEXTURE_MATRIX                 0x0BA8
#define GL_ATTRIB_STACK_DEPTH             0x0BB0
#define GL_CLIENT_ATTRIB_STACK_DEPTH      0x0BB1
#define GL_ALPHA_TEST                     0x0BC0
#define GL_ALPHA_TEST_FUNC                0x0BC1
#define GL_ALPHA_TEST_REF                 0x0BC2
#define GL_DITHER                         0x0BD0
#define GL_BLEND_DST                      0x0BE0
#define GL_BLEND_SRC                      0x0BE1
#define GL_BLEND                          0x0BE2
#define GL_LOGIC_OP_MODE                  0x0BF0
#define GL_INDEX_LOGIC_OP                 0x0BF1
#define GL_COLOR_LOGIC_OP                 0x0BF2
#define GL_AUX_BUFFERS                    0x0C00
#define GL_DRAW_BUFFER                    0x0C01
#define GL_READ_BUFFER                    0x0C02
#define GL_SCISSOR_BOX                    0x0C10
#define GL_SCISSOR_TEST                   0x0C11
#define GL_INDEX_CLEAR_VALUE              0x0C20
#define GL_INDEX_WRITEMASK                0x0C21
#define GL_COLOR_CLEAR_VALUE              0x0C22
#define GL_COLOR_WRITEMASK                0x0C23
#define GL_INDEX_MODE                     0x0C30
#define GL_RGBA_MODE                      0x0C31
#define GL_DOUBLEBUFFER                   0x0C32
#define GL_STEREO                         0x0C33
#define GL_RENDER_MODE                    0x0C40
#define GL_PERSPECTIVE_CORRECTION_HINT    0x0C50
#define GL_POINT_SMOOTH_HINT              0x0C51
#define GL_LINE_SMOOTH_HINT               0x0C52
#define GL_POLYGON_SMOOTH_HINT            0x0C53
#define GL_FOG_HINT                       0x0C54
#define GL_TEXTURE_GEN_S                  0x0C60
#define GL_TEXTURE_GEN_T                  0x0C61
#define GL_TEXTURE_GEN_R                  0x0C62
#define GL_TEXTURE_GEN_Q                  0x0C63
#define GL_PIXEL_MAP_I_TO_I               0x0C70
#define GL_PIXEL_MAP_S_TO_S               0x0C71
#define GL_PIXEL_MAP_I_TO_R               0x0C72
#define GL_PIXEL_MAP_I_TO_G               0x0C73
#define GL_PIXEL_MAP_I_TO_B               0x0C74
#define GL_PIXEL_MAP_I_TO_A               0x0C75
#define GL_PIXEL_MAP_R_TO_R               0x0C76
#define GL_PIXEL_MAP_G_TO_G               0x0C77
#define GL_PIXEL_MAP_B_TO_B               0x0C78
#define GL_PIXEL_MAP_A_TO_A               0x0C79
#define GL_PIXEL_MAP_I_TO_I_SIZE          0x0CB0
#define GL_PIXEL_MAP_S_TO_S_SIZE          0x0CB1
#define GL_PIXEL_MAP_I_TO_R_SIZE          0x0CB2
#define GL_PIXEL_MAP_I_TO_G_SIZE          0x0CB3
#define GL_PIXEL_MAP_I_TO_B_SIZE          0x0CB4
#define GL_PIXEL_MAP_I_TO_A_SIZE          0x0CB5
#define GL_PIXEL_MAP_R_TO_R_SIZE          0x0CB6
#define GL_PIXEL_MAP_G_TO_G_SIZE          0x0CB7
#define GL_PIXEL_MAP_B_TO_B_SIZE          0x0CB8
#define GL_PIXEL_MAP_A_TO_A_SIZE          0x0CB9
#define GL_UNPACK_SWAP_BYTES              0x0CF0
#define GL_UNPACK_LSB_FIRST               0x0CF1
#define GL_UNPACK_ROW_LENGTH              0x0CF2
#define GL_UNPACK_SKIP_ROWS               0x0CF3
#define GL_UNPACK_SKIP_PIXELS             0x0CF4
#define GL_UNPACK_ALIGNMENT               0x0CF5
#define GL_PACK_SWAP_BYTES                0x0D00
#define GL_PACK_LSB_FIRST                 0x0D01
#define GL_PACK_ROW_LENGTH                0x0D02
#define GL_PACK_SKIP_ROWS                 0x0D03
#define GL_PACK_SKIP_PIXELS               0x0D04
#define GL_PACK_ALIGNMENT                 0x0D05
#define GL_MAP_COLOR                      0x0D10
#define GL_MAP_STENCIL                    0x0D11
#define GL_INDEX_SHIFT                    0x0D12
#define GL_INDEX_OFFSET                   0x0D13
#define GL_RED_SCALE                      0x0D14
#define GL_RED_BIAS                       0x0D15
#define GL_ZOOM_X                         0x0D16
#define GL_ZOOM_Y                         0x0D17
#define GL_GREEN_SCALE                    0x0D18
#define GL_GREEN_BIAS                     0x0D19
#define GL_BLUE_SCALE                     0x0D1A
#define GL_BLUE_BIAS                      0x0D1B
#define GL_ALPHA_SCALE                    0x0D1C
#define GL_ALPHA_BIAS                     0x0D1D
#define GL_DEPTH_SCALE                    0x0D1E
#define GL_DEPTH_BIAS                     0x0D1F
#define GL_MAX_EVAL_ORDER                 0x0D30
#define GL_MAX_LIGHTS                     0x0D31
#define GL_MAX_CLIP_PLANES                0x0D32
#define GL_MAX_TEXTURE_SIZE               0x0D33
#define GL_MAX_PIXEL_MAP_TABLE            0x0D34
#define GL_MAX_ATTRIB_STACK_DEPTH         0x0D35
#define GL_MAX_MODELVIEW_STACK_DEPTH      0x0D36
#define GL_MAX_NAME_STACK_DEPTH           0x0D37
#define GL_MAX_PROJECTION_STACK_DEPTH     0x0D38
#define GL_MAX_TEXTURE_STACK_DEPTH        0x0D39
#define GL_MAX_VIEWPORT_DIMS              0x0D3A
#define GL_MAX_CLIENT_ATTRIB_STACK_DEPTH  0x0D3B
#define GL_SUBPIXEL_BITS                  0x0D50
#define GL_INDEX_BITS                     0x0D51
#define GL_RED_BITS                       0x0D52
#define GL_GREEN_BITS                     0x0D53
#define GL_BLUE_BITS                      0x0D54
#define GL_ALPHA_BITS                     0x0D55
#define GL_DEPTH_BITS                     0x0D56
#define GL_STENCIL_BITS                   0x0D57
#define GL_ACCUM_RED_BITS                 0x0D58
#define GL_ACCUM_GREEN_BITS               0x0D59
#define GL_ACCUM_BLUE_BITS                0x0D5A
#define GL_ACCUM_ALPHA_BITS               0x0D5B
#define GL_NAME_STACK_DEPTH               0x0D70
#define GL_AUTO_NORMAL                    0x0D80
#define GL_MAP1_COLOR_4                   0x0D90
#define GL_MAP1_INDEX                     0x0D91
#define GL_MAP1_NORMAL                    0x0D92
#define GL_MAP1_TEXTURE_COORD_1           0x0D93
#define GL_MAP1_TEXTURE_COORD_2           0x0D94
#define GL_MAP1_TEXTURE_COORD_3           0x0D95
#define GL_MAP1_TEXTURE_COORD_4           0x0D96
#define GL_MAP1_VERTEX_3                  0x0D97
#define GL_MAP1_VERTEX_4                  0x0D98
#define GL_MAP2_COLOR_4                   0x0DB0
#define GL_MAP2_INDEX                     0x0DB1
#define GL_MAP2_NORMAL                    0x0DB2
#define GL_MAP2_TEXTURE_COORD_1           0x0DB3
#define GL_MAP2_TEXTURE_COORD_2           0x0DB4
#define GL_MAP2_TEXTURE_COORD_3           0x0DB5
#define GL_MAP2_TEXTURE_COORD_4           0x0DB6
#define GL_MAP2_VERTEX_3                  0x0DB7
#define GL_MAP2_VERTEX_4                  0x0DB8
#define GL_MAP1_GRID_DOMAIN               0x0DD0
#define GL_MAP1_GRID_SEGMENTS             0x0DD1
#define GL_MAP2_GRID_DOMAIN               0x0DD2
#define GL_MAP2_GRID_SEGMENTS             0x0DD3
#define GL_TEXTURE_1D                     0x0DE0
#define GL_TEXTURE_2D                     0x0DE1
#define GL_FEEDBACK_BUFFER_POINTER        0x0DF0
#define GL_FEEDBACK_BUFFER_SIZE           0x0DF1
#define GL_FEEDBACK_BUFFER_TYPE           0x0DF2
#define GL_SELECTION_BUFFER_POINTER       0x0DF3
#define GL_SELECTION_BUFFER_SIZE          0x0DF4
/*      GL_TEXTURE_BINDING_1D */
/*      GL_TEXTURE_BINDING_2D */
/*      GL_VERTEX_ARRAY */
/*      GL_NORMAL_ARRAY */
/*      GL_COLOR_ARRAY */
/*      GL_INDEX_ARRAY */
/*      GL_TEXTURE_COORD_ARRAY */
/*      GL_EDGE_FLAG_ARRAY */
/*      GL_VERTEX_ARRAY_SIZE */
/*      GL_VERTEX_ARRAY_TYPE */
/*      GL_VERTEX_ARRAY_STRIDE */
/*      GL_NORMAL_ARRAY_TYPE */
/*      GL_NORMAL_ARRAY_STRIDE */
/*      GL_COLOR_ARRAY_SIZE */
/*      GL_COLOR_ARRAY_TYPE */
/*      GL_COLOR_ARRAY_STRIDE */
/*      GL_INDEX_ARRAY_TYPE */
/*      GL_INDEX_ARRAY_STRIDE */
/*      GL_TEXTURE_COORD_ARRAY_SIZE */
/*      GL_TEXTURE_COORD_ARRAY_TYPE */
/*      GL_TEXTURE_COORD_ARRAY_STRIDE */
/*      GL_EDGE_FLAG_ARRAY_STRIDE */
/*      GL_POLYGON_OFFSET_FACTOR */
/*      GL_POLYGON_OFFSET_UNITS */

/* GetTextureParameter */
/*      GL_TEXTURE_MAG_FILTER */
/*      GL_TEXTURE_MIN_FILTER */
/*      GL_TEXTURE_WRAP_S */
/*      GL_TEXTURE_WRAP_T */
#define GL_TEXTURE_WIDTH                  0x1000
#define GL_TEXTURE_HEIGHT                 0x1001
#define GL_TEXTURE_INTERNAL_FORMAT        0x1003
#define GL_TEXTURE_BORDER_COLOR           0x1004
#define GL_TEXTURE_BORDER                 0x1005
/*      GL_TEXTURE_RED_SIZE */
/*      GL_TEXTURE_GREEN_SIZE */
/*      GL_TEXTURE_BLUE_SIZE */
/*      GL_TEXTURE_ALPHA_SIZE */
/*      GL_TEXTURE_LUMINANCE_SIZE */
/*      GL_TEXTURE_INTENSITY_SIZE */
/*      GL_TEXTURE_PRIORITY */
/*      GL_TEXTURE_RESIDENT */

/* HintMode */
#define GL_DONT_CARE                      0x1100
#define GL_FASTEST                        0x1101
#define GL_NICEST                         0x1102

/* HintTarget */
/*      GL_PERSPECTIVE_CORRECTION_HINT */
/*      GL_POINT_SMOOTH_HINT */
/*      GL_LINE_SMOOTH_HINT */
/*      GL_POLYGON_SMOOTH_HINT */
/*      GL_FOG_HINT */
/*      GL_PHONG_HINT */

/* IndexPointerType */
/*      GL_SHORT */
/*      GL_INT */
/*      GL_FLOAT */
/*      GL_DOUBLE */

/* LightModelParameter */
/*      GL_LIGHT_MODEL_AMBIENT */
/*      GL_LIGHT_MODEL_LOCAL_VIEWER */
/*      GL_LIGHT_MODEL_TWO_SIDE */

/* LightName */
#define GL_LIGHT0                         0x4000
#define GL_LIGHT1                         0x4001
#define GL_LIGHT2                         0x4002
#define GL_LIGHT3                         0x4003
#define GL_LIGHT4                         0x4004
#define GL_LIGHT5                         0x4005
#define GL_LIGHT6                         0x4006
#define GL_LIGHT7                         0x4007

/* LightParameter */
#define GL_AMBIENT                        0x1200
#define GL_DIFFUSE                        0x1201
#define GL_SPECULAR                       0x1202
#define GL_POSITION                       0x1203
#define GL_SPOT_DIRECTION                 0x1204
#define GL_SPOT_EXPONENT                  0x1205
#define GL_SPOT_CUTOFF                    0x1206
#define GL_CONSTANT_ATTENUATION           0x1207
#define GL_LINEAR_ATTENUATION             0x1208
#define GL_QUADRATIC_ATTENUATION          0x1209

/* InterleavedArrays */
/*      GL_V2F */
/*      GL_V3F */
/*      GL_C4UB_V2F */
/*      GL_C4UB_V3F */
/*      GL_C3F_V3F */
/*      GL_N3F_V3F */
/*      GL_C4F_N3F_V3F */
/*      GL_T2F_V3F */
/*      GL_T4F_V4F */
/*      GL_T2F_C4UB_V3F */
/*      GL_T2F_C3F_V3F */
/*      GL_T2F_N3F_V3F */
/*      GL_T2F_C4F_N3F_V3F */
/*      GL_T4F_C4F_N3F_V4F */

/* ListMode */
#define GL_COMPILE                        0x1300
#define GL_COMPILE_AND_EXECUTE            0x1301

/* ListNameType */
/*      GL_BYTE */
/*      GL_UNSIGNED_BYTE */
/*      GL_SHORT */
/*      GL_UNSIGNED_SHORT */
/*      GL_INT */
/*      GL_UNSIGNED_INT */
/*      GL_FLOAT */
/*      GL_2_BYTES */
/*      GL_3_BYTES */
/*      GL_4_BYTES */

/* LogicOp */
#define GL_CLEAR                          0x1500
#define GL_AND                            0x1501
#define GL_AND_REVERSE                    0x1502
#define GL_COPY                           0x1503
#define GL_AND_INVERTED                   0x1504
#define GL_NOOP                           0x1505
#define GL_XOR                            0x1506
#define GL_OR                             0x1507
#define GL_NOR                            0x1508
#define GL_EQUIV                          0x1509
#define GL_INVERT                         0x150A
#define GL_OR_REVERSE                     0x150B
#define GL_COPY_INVERTED                  0x150C
#define GL_OR_INVERTED                    0x150D
#define GL_NAND                           0x150E
#define GL_SET                            0x150F

/* MapTarget */
/*      GL_MAP1_COLOR_4 */
/*      GL_MAP1_INDEX */
/*      GL_MAP1_NORMAL */
/*      GL_MAP1_TEXTURE_COORD_1 */
/*      GL_MAP1_TEXTURE_COORD_2 */
/*      GL_MAP1_TEXTURE_COORD_3 */
/*      GL_MAP1_TEXTURE_COORD_4 */
/*      GL_MAP1_VERTEX_3 */
/*      GL_MAP1_VERTEX_4 */
/*      GL_MAP2_COLOR_4 */
/*      GL_MAP2_INDEX */
/*      GL_MAP2_NORMAL */
/*      GL_MAP2_TEXTURE_COORD_1 */
/*      GL_MAP2_TEXTURE_COORD_2 */
/*      GL_MAP2_TEXTURE_COORD_3 */
/*      GL_MAP2_TEXTURE_COORD_4 */
/*      GL_MAP2_VERTEX_3 */
/*      GL_MAP2_VERTEX_4 */

/* MaterialFace */
/*      GL_FRONT */
/*      GL_BACK */
/*      GL_FRONT_AND_BACK */

/* MaterialParameter */
#define GL_EMISSION                       0x1600
#define GL_SHININESS                      0x1601
#define GL_AMBIENT_AND_DIFFUSE            0x1602
#define GL_COLOR_INDEXES                  0x1603
/*      GL_AMBIENT */
/*      GL_DIFFUSE */
/*      GL_SPECULAR */

/* MatrixMode */
#define GL_MODELVIEW                      0x1700
#define GL_PROJECTION                     0x1701
#define GL_TEXTURE                        0x1702

/* MeshMode1 */
/*      GL_POINT */
/*      GL_LINE */

/* MeshMode2 */
/*      GL_POINT */
/*      GL_LINE */
/*      GL_FILL */

/* NormalPointerType */
/*      GL_BYTE */
/*      GL_SHORT */
/*      GL_INT */
/*      GL_FLOAT */
/*      GL_DOUBLE */

/* PixelCopyType */
#define GL_COLOR                          0x1800
#define GL_DEPTH                          0x1801
#define GL_STENCIL                        0x1802

/* PixelFormat */
#define GL_COLOR_INDEX                    0x1900
#define GL_STENCIL_INDEX                  0x1901
#define GL_DEPTH_COMPONENT                0x1902
#define GL_RED                            0x1903
#define GL_GREEN                          0x1904
#define GL_BLUE                           0x1905
#define GL_ALPHA                          0x1906
#define GL_RGB                            0x1907
#define GL_RGBA                           0x1908
#define GL_LUMINANCE                      0x1909
#define GL_LUMINANCE_ALPHA                0x190A

/* PixelMap */
/*      GL_PIXEL_MAP_I_TO_I */
/*      GL_PIXEL_MAP_S_TO_S */
/*      GL_PIXEL_MAP_I_TO_R */
/*      GL_PIXEL_MAP_I_TO_G */
/*      GL_PIXEL_MAP_I_TO_B */
/*      GL_PIXEL_MAP_I_TO_A */
/*      GL_PIXEL_MAP_R_TO_R */
/*      GL_PIXEL_MAP_G_TO_G */
/*      GL_PIXEL_MAP_B_TO_B */
/*      GL_PIXEL_MAP_A_TO_A */

/* PixelStore */
/*      GL_UNPACK_SWAP_BYTES */
/*      GL_UNPACK_LSB_FIRST */
/*      GL_UNPACK_ROW_LENGTH */
/*      GL_UNPACK_SKIP_ROWS */
/*      GL_UNPACK_SKIP_PIXELS */
/*      GL_UNPACK_ALIGNMENT */
/*      GL_PACK_SWAP_BYTES */
/*      GL_PACK_LSB_FIRST */
/*      GL_PACK_ROW_LENGTH */
/*      GL_PACK_SKIP_ROWS */
/*      GL_PACK_SKIP_PIXELS */
/*      GL_PACK_ALIGNMENT */

/* PixelTransfer */
/*      GL_MAP_COLOR */
/*      GL_MAP_STENCIL */
/*      GL_INDEX_SHIFT */
/*      GL_INDEX_OFFSET */
/*      GL_RED_SCALE */
/*      GL_RED_BIAS */
/*      GL_GREEN_SCALE */
/*      GL_GREEN_BIAS */
/*      GL_BLUE_SCALE */
/*      GL_BLUE_BIAS */
/*      GL_ALPHA_SCALE */
/*      GL_ALPHA_BIAS */
/*      GL_DEPTH_SCALE */
/*      GL_DEPTH_BIAS */

/* PixelType */
#define GL_BITMAP                         0x1A00
/*      GL_BYTE */
/*      GL_UNSIGNED_BYTE */
/*      GL_SHORT */
/*      GL_UNSIGNED_SHORT */
/*      GL_INT */
/*      GL_UNSIGNED_INT */
/*      GL_FLOAT */

/* PolygonMode */
#define GL_POINT                          0x1B00
#define GL_LINE                           0x1B01
#define GL_FILL                           0x1B02

/* ReadBufferMode */
/*      GL_FRONT_LEFT */
/*      GL_FRONT_RIGHT */
/*      GL_BACK_LEFT */
/*      GL_BACK_RIGHT */
/*      GL_FRONT */
/*      GL_BACK */
/*      GL_LEFT */
/*      GL_RIGHT */
/*      GL_AUX0 */
/*      GL_AUX1 */
/*      GL_AUX2 */
/*      GL_AUX3 */

/* RenderingMode */
#define GL_RENDER                         0x1C00
#define GL_FEEDBACK                       0x1C01
#define GL_SELECT                         0x1C02

/* ShadingModel */
#define GL_FLAT                           0x1D00
#define GL_SMOOTH                         0x1D01


/* StencilFunction */
/*      GL_NEVER */
/*      GL_LESS */
/*      GL_EQUAL */
/*      GL_LEQUAL */
/*      GL_GREATER */
/*      GL_NOTEQUAL */
/*      GL_GEQUAL */
/*      GL_ALWAYS */

/* StencilOp */
/*      GL_ZERO */
#define GL_KEEP                           0x1E00
#define GL_REPLACE                        0x1E01
#define GL_INCR                           0x1E02
#define GL_DECR                           0x1E03
/*      GL_INVERT */

/* StringName */
#define GL_VENDOR                         0x1F00
#define GL_RENDERER                       0x1F01
#define GL_VERSION                        0x1F02
#define GL_EXTENSIONS                     0x1F03

/* TextureCoordName */
#define GL_S                              0x2000
#define GL_T                              0x2001
#define GL_R                              0x2002
#define GL_Q                              0x2003

/* TexCoordPointerType */
/*      GL_SHORT */
/*      GL_INT */
/*      GL_FLOAT */
/*      GL_DOUBLE */

/* TextureEnvMode */
#define GL_MODULATE                       0x2100
#define GL_DECAL                          0x2101
/*      GL_BLEND */
/*      GL_REPLACE */

/* TextureEnvParameter */
#define GL_TEXTURE_ENV_MODE               0x2200
#define GL_TEXTURE_ENV_COLOR              0x2201

/* TextureEnvTarget */
#define GL_TEXTURE_ENV                    0x2300

/* TextureGenMode */
#define GL_EYE_LINEAR                     0x2400
#define GL_OBJECT_LINEAR                  0x2401
#define GL_SPHERE_MAP                     0x2402

/* TextureGenParameter */
#define GL_TEXTURE_GEN_MODE               0x2500
#define GL_OBJECT_PLANE                   0x2501
#define GL_EYE_PLANE                      0x2502

/* TextureMagFilter */
#define GL_NEAREST                        0x2600
#define GL_LINEAR                         0x2601

/* TextureMinFilter */
/*      GL_NEAREST */
/*      GL_LINEAR */
#define GL_NEAREST_MIPMAP_NEAREST         0x2700
#define GL_LINEAR_MIPMAP_NEAREST          0x2701
#define GL_NEAREST_MIPMAP_LINEAR          0x2702
#define GL_LINEAR_MIPMAP_LINEAR           0x2703

/* TextureParameterName */
#define GL_TEXTURE_MAG_FILTER             0x2800
#define GL_TEXTURE_MIN_FILTER             0x2801
#define GL_TEXTURE_WRAP_S                 0x2802
#define GL_TEXTURE_WRAP_T                 0x2803
/*      GL_TEXTURE_BORDER_COLOR */
/*      GL_TEXTURE_PRIORITY */

/* TextureTarget */
/*      GL_TEXTURE_1D */
/*      GL_TEXTURE_2D */
/*      GL_PROXY_TEXTURE_1D */
/*      GL_PROXY_TEXTURE_2D */

/* TextureWrapMode */
#define GL_CLAMP                          0x2900
#define GL_REPEAT                         0x2901

/* VertexPointerType */
/*      GL_SHORT */
/*      GL_INT */
/*      GL_FLOAT */
/*      GL_DOUBLE */

/* ClientAttribMask */
#define GL_CLIENT_PIXEL_STORE_BIT         0x00000001
#define GL_CLIENT_VERTEX_ARRAY_BIT        0x00000002
#define GL_CLIENT_ALL_ATTRIB_BITS         0xffffffff

/* polygon_offset */
#define GL_POLYGON_OFFSET_FACTOR          0x8038
#define GL_POLYGON_OFFSET_UNITS           0x2A00
#define GL_POLYGON_OFFSET_POINT           0x2A01
#define GL_POLYGON_OFFSET_LINE            0x2A02
#define GL_POLYGON_OFFSET_FILL            0x8037

/* texture */
#define GL_ALPHA4                         0x803B
#define GL_ALPHA8                         0x803C
#define GL_ALPHA12                        0x803D
#define GL_ALPHA16                        0x803E
#define GL_LUMINANCE4                     0x803F
#define GL_LUMINANCE8                     0x8040
#define GL_LUMINANCE12                    0x8041
#define GL_LUMINANCE16                    0x8042
#define GL_LUMINANCE4_ALPHA4              0x8043
#define GL_LUMINANCE6_ALPHA2              0x8044
#define GL_LUMINANCE8_ALPHA8              0x8045
#define GL_LUMINANCE12_ALPHA4             0x8046
#define GL_LUMINANCE12_ALPHA12            0x8047
#define GL_LUMINANCE16_ALPHA16            0x8048
#define GL_INTENSITY                      0x8049
#define GL_INTENSITY4                     0x804A
#define GL_INTENSITY8                     0x804B
#define GL_INTENSITY12                    0x804C
#define GL_INTENSITY16                    0x804D
#define GL_R3_G3_B2                       0x2A10
#define GL_RGB4                           0x804F
#define GL_RGB5                           0x8050
#define GL_RGB8                           0x8051
#define GL_RGB10                          0x8052
#define GL_RGB12                          0x8053
#define GL_RGB16                          0x8054
#define GL_RGBA2                          0x8055
#define GL_RGBA4                          0x8056
#define GL_RGB5_A1                        0x8057
#define GL_RGBA8                          0x8058
#define GL_RGB10_A2                       0x8059
#define GL_RGBA12                         0x805A
#define GL_RGBA16                         0x805B
#define GL_TEXTURE_RED_SIZE               0x805C
#define GL_TEXTURE_GREEN_SIZE             0x805D
#define GL_TEXTURE_BLUE_SIZE              0x805E
#define GL_TEXTURE_ALPHA_SIZE             0x805F
#define GL_TEXTURE_LUMINANCE_SIZE         0x8060
#define GL_TEXTURE_INTENSITY_SIZE         0x8061
#define GL_PROXY_TEXTURE_1D               0x8063
#define GL_PROXY_TEXTURE_2D               0x8064

/* texture_object */
#define GL_TEXTURE_PRIORITY               0x8066
#define GL_TEXTURE_RESIDENT               0x8067
#define GL_TEXTURE_BINDING_1D             0x8068
#define GL_TEXTURE_BINDING_2D             0x8069

/* vertex_array */
#define GL_VERTEX_ARRAY                   0x8074
#define GL_NORMAL_ARRAY                   0x8075
#define GL_COLOR_ARRAY                    0x8076
#define GL_INDEX_ARRAY                    0x8077
#define GL_TEXTURE_COORD_ARRAY            0x8078
#define GL_EDGE_FLAG_ARRAY                0x8079
#define GL_VERTEX_ARRAY_SIZE              0x807A
#define GL_VERTEX_ARRAY_TYPE              0x807B
#define GL_VERTEX_ARRAY_STRIDE            0x807C
#define GL_NORMAL_ARRAY_TYPE              0x807E
#define GL_NORMAL_ARRAY_STRIDE            0x807F
#define GL_COLOR_ARRAY_SIZE               0x8081
#define GL_COLOR_ARRAY_TYPE               0x8082
#define GL_COLOR_ARRAY_STRIDE             0x8083
#define GL_INDEX_ARRAY_TYPE               0x8085
#define GL_INDEX_ARRAY_STRIDE             0x8086
#define GL_TEXTURE_COORD_ARRAY_SIZE       0x8088
#define GL_TEXTURE_COORD_ARRAY_TYPE       0x8089
#define GL_TEXTURE_COORD_ARRAY_STRIDE     0x808A
#define GL_EDGE_FLAG_ARRAY_STRIDE         0x808C
#define GL_VERTEX_ARRAY_POINTER           0x808E
#define GL_NORMAL_ARRAY_POINTER           0x808F
#define GL_COLOR_ARRAY_POINTER            0x8090
#define GL_INDEX_ARRAY_POINTER            0x8091
#define GL_TEXTURE_COORD_ARRAY_POINTER    0x8092
#define GL_EDGE_FLAG_ARRAY_POINTER        0x8093
#define GL_V2F                            0x2A20
#define GL_V3F                            0x2A21
#define GL_C4UB_V2F                       0x2A22
#define GL_C4UB_V3F                       0x2A23
#define GL_C3F_V3F                        0x2A24
#define GL_N3F_V3F                        0x2A25
#define GL_C4F_N3F_V3F                    0x2A26
#define GL_T2F_V3F                        0x2A27
#define GL_T4F_V4F                        0x2A28
#define GL_T2F_C4UB_V3F                   0x2A29
#define GL_T2F_C3F_V3F                    0x2A2A
#define GL_T2F_N3F_V3F                    0x2A2B
#define GL_T2F_C4F_N3F_V3F                0x2A2C
#define GL_T4F_C4F_N3F_V4F                0x2A2D

/* Extensions */
#define GL_EXT_vertex_array               1
#define GL_EXT_bgra                       1
#define GL_EXT_paletted_texture           1
#define GL_WIN_swap_hint                  1
#define GL_WIN_draw_range_elements        1
// #define GL_WIN_phong_shading              1
// #define GL_WIN_specular_fog               1

/* EXT_vertex_array */
#define GL_VERTEX_ARRAY_EXT               0x8074
#define GL_NORMAL_ARRAY_EXT               0x8075
#define GL_COLOR_ARRAY_EXT                0x8076
#define GL_INDEX_ARRAY_EXT                0x8077
#define GL_TEXTURE_COORD_ARRAY_EXT        0x8078
#define GL_EDGE_FLAG_ARRAY_EXT            0x8079
#define GL_VERTEX_ARRAY_SIZE_EXT          0x807A
#define GL_VERTEX_ARRAY_TYPE_EXT          0x807B
#define GL_VERTEX_ARRAY_STRIDE_EXT        0x807C
#define GL_VERTEX_ARRAY_COUNT_EXT         0x807D
#define GL_NORMAL_ARRAY_TYPE_EXT          0x807E
#define GL_NORMAL_ARRAY_STRIDE_EXT        0x807F
#define GL_NORMAL_ARRAY_COUNT_EXT         0x8080
#define GL_COLOR_ARRAY_SIZE_EXT           0x8081
#define GL_COLOR_ARRAY_TYPE_EXT           0x8082
#define GL_COLOR_ARRAY_STRIDE_EXT         0x8083
#define GL_COLOR_ARRAY_COUNT_EXT          0x8084
#define GL_INDEX_ARRAY_TYPE_EXT           0x8085
#define GL_INDEX_ARRAY_STRIDE_EXT         0x8086
#define GL_INDEX_ARRAY_COUNT_EXT          0x8087
#define GL_TEXTURE_COORD_ARRAY_SIZE_EXT   0x8088
#define GL_TEXTURE_COORD_ARRAY_TYPE_EXT   0x8089
#define GL_TEXTURE_COORD_ARRAY_STRIDE_EXT 0x808A
#define GL_TEXTURE_COORD_ARRAY_COUNT_EXT  0x808B
#define GL_EDGE_FLAG_ARRAY_STRIDE_EXT     0x808C
#define GL_EDGE_FLAG_ARRAY_COUNT_EXT      0x808D
#define GL_VERTEX_ARRAY_POINTER_EXT       0x808E
#define GL_NORMAL_ARRAY_POINTER_EXT       0x808F
#define GL_COLOR_ARRAY_POINTER_EXT        0x8090
#define GL_INDEX_ARRAY_POINTER_EXT        0x8091
#define GL_TEXTURE_COORD_ARRAY_POINTER_EXT 0x8092
#define GL_EDGE_FLAG_ARRAY_POINTER_EXT    0x8093
#define GL_DOUBLE_EXT                     GL_DOUBLE

/* EXT_bgra */
#define GL_BGR_EXT                        0x80E0
#define GL_BGRA_EXT                       0x80E1

/* EXT_paletted_texture */

/* These must match the GL_COLOR_TABLE_*_SGI enumerants */
#define GL_COLOR_TABLE_FORMAT_EXT         0x80D8
#define GL_COLOR_TABLE_WIDTH_EXT          0x80D9
#define GL_COLOR_TABLE_RED_SIZE_EXT       0x80DA
#define GL_COLOR_TABLE_GREEN_SIZE_EXT     0x80DB
#define GL_COLOR_TABLE_BLUE_SIZE_EXT      0x80DC
#define GL_COLOR_TABLE_ALPHA_SIZE_EXT     0x80DD
#define GL_COLOR_TABLE_LUMINANCE_SIZE_EXT 0x80DE
#define GL_COLOR_TABLE_INTENSITY_SIZE_EXT 0x80DF

#define GL_COLOR_INDEX1_EXT               0x80E2
#define GL_COLOR_INDEX2_EXT               0x80E3
#define GL_COLOR_INDEX4_EXT               0x80E4
#define GL_COLOR_INDEX8_EXT               0x80E5
#define GL_COLOR_INDEX12_EXT              0x80E6
#define GL_COLOR_INDEX16_EXT              0x80E7

/* WIN_draw_range_elements */
#define GL_MAX_ELEMENTS_VERTICES_WIN      0x80E8
#define GL_MAX_ELEMENTS_INDICES_WIN       0x80E9

/* WIN_phong_shading */
#define GL_PHONG_WIN                      0x80EA 
#define GL_PHONG_HINT_WIN                 0x80EB 

/* WIN_specular_fog */
#define GL_FOG_SPECULAR_TEXTURE_WIN       0x80EC

/* For compatibility with OpenGL v1.0 */
#define GL_LOGIC_OP GL_INDEX_LOGIC_OP
#define GL_TEXTURE_COMPONENTS GL_TEXTURE_INTERNAL_FORMAT

/*************************************************************/

WINGDIAPI void APIENTRY glAccum (GLenum op, GLfloat value);
WINGDIAPI void APIENTRY glAlphaFunc (GLenum func, GLclampf ref);
WINGDIAPI GLboolean APIENTRY glAreTexturesResident (GLsizei n, const GLuint *textures, GLboolean *residences);
WINGDIAPI void APIENTRY glArrayElement (GLint i);
WINGDIAPI void APIENTRY glBegin (GLenum mode);
WINGDIAPI void APIENTRY glBindTexture (GLenum target, GLuint texture);
WINGDIAPI void APIENTRY glBitmap (GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap);
WINGDIAPI void APIENTRY glBlendFunc (GLenum sfactor, GLenum dfactor);
WINGDIAPI void APIENTRY glCallList (GLuint list);
WINGDIAPI void APIENTRY glCallLists (GLsizei n, GLenum type, const GLvoid *lists);
WINGDIAPI void APIENTRY glClear (GLbitfield mask);
WINGDIAPI void APIENTRY glClearAccum (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
WINGDIAPI void APIENTRY glClearColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
WINGDIAPI void APIENTRY glClearDepth (GLclampd depth);
WINGDIAPI void APIENTRY glClearIndex (GLfloat c);
WINGDIAPI void APIENTRY glClearStencil (GLint s);
WINGDIAPI void APIENTRY glClipPlane (GLenum plane, const GLdouble *equation);
WINGDIAPI void APIENTRY glColor3b (GLbyte red, GLbyte green, GLbyte blue);
WINGDIAPI void APIENTRY glColor3bv (const GLbyte *v);
WINGDIAPI void APIENTRY glColor3d (GLdouble red, GLdouble green, GLdouble blue);
WINGDIAPI void APIENTRY glColor3dv (const GLdouble *v);
WINGDIAPI void APIENTRY glColor3f (GLfloat red, GLfloat green, GLfloat blue);
WINGDIAPI void APIENTRY glColor3fv (const GLfloat *v);
WINGDIAPI void APIENTRY glColor3i (GLint red, GLint green, GLint blue);
WINGDIAPI void APIENTRY glColor3iv (const GLint *v);
WINGDIAPI void APIENTRY glColor3s (GLshort red, GLshort green, GLshort blue);
WINGDIAPI void APIENTRY glColor3sv (const GLshort *v);
WINGDIAPI void APIENTRY glColor3ub (GLubyte red, GLubyte green, GLubyte blue);
WINGDIAPI void APIENTRY glColor3ubv (const GLubyte *v);
WINGDIAPI void APIENTRY glColor3ui (GLuint red, GLuint green, GLuint blue);
WINGDIAPI void APIENTRY glColor3uiv (const GLuint *v);
WINGDIAPI void APIENTRY glColor3us (GLushort red, GLushort green, GLushort blue);
WINGDIAPI void APIENTRY glColor3usv (const GLushort *v);
WINGDIAPI void APIENTRY glColor4b (GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha);
WINGDIAPI void APIENTRY glColor4bv (const GLbyte *v);
WINGDIAPI void APIENTRY glColor4d (GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);
WINGDIAPI void APIENTRY glColor4dv (const GLdouble *v);
WINGDIAPI void APIENTRY glColor4f (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
WINGDIAPI void APIENTRY glColor4fv (const GLfloat *v);
WINGDIAPI void APIENTRY glColor4i (GLint red, GLint green, GLint blue, GLint alpha);
WINGDIAPI void APIENTRY glColor4iv (const GLint *v);
WINGDIAPI void APIENTRY glColor4s (GLshort red, GLshort green, GLshort blue, GLshort alpha);
WINGDIAPI void APIENTRY glColor4sv (const GLshort *v);
WINGDIAPI void APIENTRY glColor4ub (GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
WINGDIAPI void APIENTRY glColor4ubv (const GLubyte *v);
WINGDIAPI void APIENTRY glColor4ui (GLuint red, GLuint green, GLuint blue, GLuint alpha);
WINGDIAPI void APIENTRY glColor4uiv (const GLuint *v);
WINGDIAPI void APIENTRY glColor4us (GLushort red, GLushort green, GLushort blue, GLushort alpha);
WINGDIAPI void APIENTRY glColor4usv (const GLushort *v);
WINGDIAPI void APIENTRY glColorMask (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
WINGDIAPI void APIENTRY glColorMaterial (GLenum face, GLenum mode);
WINGDIAPI void APIENTRY glColorPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
WINGDIAPI void APIENTRY glCopyPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);
WINGDIAPI void APIENTRY glCopyTexImage1D (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border);
WINGDIAPI void APIENTRY glCopyTexImage2D (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
WINGDIAPI void APIENTRY glCopyTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
WINGDIAPI void APIENTRY glCopyTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
WINGDIAPI void APIENTRY glCullFace (GLenum mode);
WINGDIAPI void APIENTRY glDeleteLists (GLuint list, GLsizei range);
WINGDIAPI void APIENTRY glDeleteTextures (GLsizei n, const GLuint *textures);
WINGDIAPI void APIENTRY glDepthFunc (GLenum func);
WINGDIAPI void APIENTRY glDepthMask (GLboolean flag);
WINGDIAPI void APIENTRY glDepthRange (GLclampd zNear, GLclampd zFar);
WINGDIAPI void APIENTRY glDisable (GLenum cap);
WINGDIAPI void APIENTRY glDisableClientState (GLenum array);
WINGDIAPI void APIENTRY glDrawArrays (GLenum mode, GLint first, GLsizei count);
WINGDIAPI void APIENTRY glDrawBuffer (GLenum mode);
WINGDIAPI void APIENTRY glDrawElements (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
WINGDIAPI void APIENTRY glDrawPixels (GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
WINGDIAPI void APIENTRY glEdgeFlag (GLboolean flag);
WINGDIAPI void APIENTRY glEdgeFlagPointer (GLsizei stride, const GLvoid *pointer);
WINGDIAPI void APIENTRY glEdgeFlagv (const GLboolean *flag);
WINGDIAPI void APIENTRY glEnable (GLenum cap);
WINGDIAPI void APIENTRY glEnableClientState (GLenum array);
WINGDIAPI void APIENTRY glEnd (void);
WINGDIAPI void APIENTRY glEndList (void);
WINGDIAPI void APIENTRY glEvalCoord1d (GLdouble u);
WINGDIAPI void APIENTRY glEvalCoord1dv (const GLdouble *u);
WINGDIAPI void APIENTRY glEvalCoord1f (GLfloat u);
WINGDIAPI void APIENTRY glEvalCoord1fv (const GLfloat *u);
WINGDIAPI void APIENTRY glEvalCoord2d (GLdouble u, GLdouble v);
WINGDIAPI void APIENTRY glEvalCoord2dv (const GLdouble *u);
WINGDIAPI void APIENTRY glEvalCoord2f (GLfloat u, GLfloat v);
WINGDIAPI void APIENTRY glEvalCoord2fv (const GLfloat *u);
WINGDIAPI void APIENTRY glEvalMesh1 (GLenum mode, GLint i1, GLint i2);
WINGDIAPI void APIENTRY glEvalMesh2 (GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);
WINGDIAPI void APIENTRY glEvalPoint1 (GLint i);
WINGDIAPI void APIENTRY glEvalPoint2 (GLint i, GLint j);
WINGDIAPI void APIENTRY glFeedbackBuffer (GLsizei size, GLenum type, GLfloat *buffer);
WINGDIAPI void APIENTRY glFinish (void);
WINGDIAPI void APIENTRY glFlush (void);
WINGDIAPI void APIENTRY glFogf (GLenum pname, GLfloat param);
WINGDIAPI void APIENTRY glFogfv (GLenum pname, const GLfloat *params);
WINGDIAPI void APIENTRY glFogi (GLenum pname, GLint param);
WINGDIAPI void APIENTRY glFogiv (GLenum pname, const GLint *params);
WINGDIAPI void APIENTRY glFrontFace (GLenum mode);
WINGDIAPI void APIENTRY glFrustum (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
WINGDIAPI GLuint APIENTRY glGenLists (GLsizei range);
WINGDIAPI void APIENTRY glGenTextures (GLsizei n, GLuint *textures);
WINGDIAPI void APIENTRY glGetBooleanv (GLenum pname, GLboolean *params);
WINGDIAPI void APIENTRY glGetClipPlane (GLenum plane, GLdouble *equation);
WINGDIAPI void APIENTRY glGetDoublev (GLenum pname, GLdouble *params);
WINGDIAPI GLenum APIENTRY glGetError (void);
WINGDIAPI void APIENTRY glGetFloatv (GLenum pname, GLfloat *params);
WINGDIAPI void APIENTRY glGetIntegerv (GLenum pname, GLint *params);
WINGDIAPI void APIENTRY glGetLightfv (GLenum light, GLenum pname, GLfloat *params);
WINGDIAPI void APIENTRY glGetLightiv (GLenum light, GLenum pname, GLint *params);
WINGDIAPI void APIENTRY glGetMapdv (GLenum target, GLenum query, GLdouble *v);
WINGDIAPI void APIENTRY glGetMapfv (GLenum target, GLenum query, GLfloat *v);
WINGDIAPI void APIENTRY glGetMapiv (GLenum target, GLenum query, GLint *v);
WINGDIAPI void APIENTRY glGetMaterialfv (GLenum face, GLenum pname, GLfloat *params);
WINGDIAPI void APIENTRY glGetMaterialiv (GLenum face, GLenum pname, GLint *params);
WINGDIAPI void APIENTRY glGetPixelMapfv (GLenum map, GLfloat *values);
WINGDIAPI void APIENTRY glGetPixelMapuiv (GLenum map, GLuint *values);
WINGDIAPI void APIENTRY glGetPixelMapusv (GLenum map, GLushort *values);
WINGDIAPI void APIENTRY glGetPointerv (GLenum pname, GLvoid* *params);
WINGDIAPI void APIENTRY glGetPolygonStipple (GLubyte *mask);
WINGDIAPI const GLubyte * APIENTRY glGetString (GLenum name);
WINGDIAPI void APIENTRY glGetTexEnvfv (GLenum target, GLenum pname, GLfloat *params);
WINGDIAPI void APIENTRY glGetTexEnviv (GLenum target, GLenum pname, GLint *params);
WINGDIAPI void APIENTRY glGetTexGendv (GLenum coord, GLenum pname, GLdouble *params);
WINGDIAPI void APIENTRY glGetTexGenfv (GLenum coord, GLenum pname, GLfloat *params);
WINGDIAPI void APIENTRY glGetTexGeniv (GLenum coord, GLenum pname, GLint *params);
WINGDIAPI void APIENTRY glGetTexImage (GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
WINGDIAPI void APIENTRY glGetTexLevelParameterfv (GLenum target, GLint level, GLenum pname, GLfloat *params);
WINGDIAPI void APIENTRY glGetTexLevelParameteriv (GLenum target, GLint level, GLenum pname, GLint *params);
WINGDIAPI void APIENTRY glGetTexParameterfv (GLenum target, GLenum pname, GLfloat *params);
WINGDIAPI void APIENTRY glGetTexParameteriv (GLenum target, GLenum pname, GLint *params);
WINGDIAPI void APIENTRY glHint (GLenum target, GLenum mode);
WINGDIAPI void APIENTRY glIndexMask (GLuint mask);
WINGDIAPI void APIENTRY glIndexPointer (GLenum type, GLsizei stride, const GLvoid *pointer);
WINGDIAPI void APIENTRY glIndexd (GLdouble c);
WINGDIAPI void APIENTRY glIndexdv (const GLdouble *c);
WINGDIAPI void APIENTRY glIndexf (GLfloat c);
WINGDIAPI void APIENTRY glIndexfv (const GLfloat *c);
WINGDIAPI void APIENTRY glIndexi (GLint c);
WINGDIAPI void APIENTRY glIndexiv (const GLint *c);
WINGDIAPI void APIENTRY glIndexs (GLshort c);
WINGDIAPI void APIENTRY glIndexsv (const GLshort *c);
WINGDIAPI void APIENTRY glIndexub (GLubyte c);
WINGDIAPI void APIENTRY glIndexubv (const GLubyte *c);
WINGDIAPI void APIENTRY glInitNames (void);
WINGDIAPI void APIENTRY glInterleavedArrays (GLenum format, GLsizei stride, const GLvoid *pointer);
WINGDIAPI GLboolean APIENTRY glIsEnabled (GLenum cap);
WINGDIAPI GLboolean APIENTRY glIsList (GLuint list);
WINGDIAPI GLboolean APIENTRY glIsTexture (GLuint texture);
WINGDIAPI void APIENTRY glLightModelf (GLenum pname, GLfloat param);
WINGDIAPI void APIENTRY glLightModelfv (GLenum pname, const GLfloat *params);
WINGDIAPI void APIENTRY glLightModeli (GLenum pname, GLint param);
WINGDIAPI void APIENTRY glLightModeliv (GLenum pname, const GLint *params);
WINGDIAPI void APIENTRY glLightf (GLenum light, GLenum pname, GLfloat param);
WINGDIAPI void APIENTRY glLightfv (GLenum light, GLenum pname, const GLfloat *params);
WINGDIAPI void APIENTRY glLighti (GLenum light, GLenum pname, GLint param);
WINGDIAPI void APIENTRY glLightiv (GLenum light, GLenum pname, const GLint *params);
WINGDIAPI void APIENTRY glLineStipple (GLint factor, GLushort pattern);
WINGDIAPI void APIENTRY glLineWidth (GLfloat width);
WINGDIAPI void APIENTRY glListBase (GLuint base);
WINGDIAPI void APIENTRY glLoadIdentity (void);
WINGDIAPI void APIENTRY glLoadMatrixd (const GLdouble *m);
WINGDIAPI void APIENTRY glLoadMatrixf (const GLfloat *m);
WINGDIAPI void APIENTRY glLoadName (GLuint name);
WINGDIAPI void APIENTRY glLogicOp (GLenum opcode);
WINGDIAPI void APIENTRY glMap1d (GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
WINGDIAPI void APIENTRY glMap1f (GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
WINGDIAPI void APIENTRY glMap2d (GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
WINGDIAPI void APIENTRY glMap2f (GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);
WINGDIAPI void APIENTRY glMapGrid1d (GLint un, GLdouble u1, GLdouble u2);
WINGDIAPI void APIENTRY glMapGrid1f (GLint un, GLfloat u1, GLfloat u2);
WINGDIAPI void APIENTRY glMapGrid2d (GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2);
WINGDIAPI void APIENTRY glMapGrid2f (GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2);
WINGDIAPI void APIENTRY glMaterialf (GLenum face, GLenum pname, GLfloat param);
WINGDIAPI void APIENTRY glMaterialfv (GLenum face, GLenum pname, const GLfloat *params);
WINGDIAPI void APIENTRY glMateriali (GLenum face, GLenum pname, GLint param);
WINGDIAPI void APIENTRY glMaterialiv (GLenum face, GLenum pname, const GLint *params);
WINGDIAPI void APIENTRY glMatrixMode (GLenum mode);
WINGDIAPI void APIENTRY glMultMatrixd (const GLdouble *m);
WINGDIAPI void APIENTRY glMultMatrixf (const GLfloat *m);
WINGDIAPI void APIENTRY glNewList (GLuint list, GLenum mode);
WINGDIAPI void APIENTRY glNormal3b (GLbyte nx, GLbyte ny, GLbyte nz);
WINGDIAPI void APIENTRY glNormal3bv (const GLbyte *v);
WINGDIAPI void APIENTRY glNormal3d (GLdouble nx, GLdouble ny, GLdouble nz);
WINGDIAPI void APIENTRY glNormal3dv (const GLdouble *v);
WINGDIAPI void APIENTRY glNormal3f (GLfloat nx, GLfloat ny, GLfloat nz);
WINGDIAPI void APIENTRY glNormal3fv (const GLfloat *v);
WINGDIAPI void APIENTRY glNormal3i (GLint nx, GLint ny, GLint nz);
WINGDIAPI void APIENTRY glNormal3iv (const GLint *v);
WINGDIAPI void APIENTRY glNormal3s (GLshort nx, GLshort ny, GLshort nz);
WINGDIAPI void APIENTRY glNormal3sv (const GLshort *v);
WINGDIAPI void APIENTRY glNormalPointer (GLenum type, GLsizei stride, const GLvoid *pointer);
WINGDIAPI void APIENTRY glOrtho (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
WINGDIAPI void APIENTRY glPassThrough (GLfloat token);
WINGDIAPI void APIENTRY glPixelMapfv (GLenum map, GLsizei mapsize, const GLfloat *values);
WINGDIAPI void APIENTRY glPixelMapuiv (GLenum map, GLsizei mapsize, const GLuint *values);
WINGDIAPI void APIENTRY glPixelMapusv (GLenum map, GLsizei mapsize, const GLushort *values);
WINGDIAPI void APIENTRY glPixelStoref (GLenum pname, GLfloat param);
WINGDIAPI void APIENTRY glPixelStorei (GLenum pname, GLint param);
WINGDIAPI void APIENTRY glPixelTransferf (GLenum pname, GLfloat param);
WINGDIAPI void APIENTRY glPixelTransferi (GLenum pname, GLint param);
WINGDIAPI void APIENTRY glPixelZoom (GLfloat xfactor, GLfloat yfactor);
WINGDIAPI void APIENTRY glPointSize (GLfloat size);
WINGDIAPI void APIENTRY glPolygonMode (GLenum face, GLenum mode);
WINGDIAPI void APIENTRY glPolygonOffset (GLfloat factor, GLfloat units);
WINGDIAPI void APIENTRY glPolygonStipple (const GLubyte *mask);
WINGDIAPI void APIENTRY glPopAttrib (void);
WINGDIAPI void APIENTRY glPopClientAttrib (void);
WINGDIAPI void APIENTRY glPopMatrix (void);
WINGDIAPI void APIENTRY glPopName (void);
WINGDIAPI void APIENTRY glPrioritizeTextures (GLsizei n, const GLuint *textures, const GLclampf *priorities);
WINGDIAPI void APIENTRY glPushAttrib (GLbitfield mask);
WINGDIAPI void APIENTRY glPushClientAttrib (GLbitfield mask);
WINGDIAPI void APIENTRY glPushMatrix (void);
WINGDIAPI void APIENTRY glPushName (GLuint name);
WINGDIAPI void APIENTRY glRasterPos2d (GLdouble x, GLdouble y);
WINGDIAPI void APIENTRY glRasterPos2dv (const GLdouble *v);
WINGDIAPI void APIENTRY glRasterPos2f (GLfloat x, GLfloat y);
WINGDIAPI void APIENTRY glRasterPos2fv (const GLfloat *v);
WINGDIAPI void APIENTRY glRasterPos2i (GLint x, GLint y);
WINGDIAPI void APIENTRY glRasterPos2iv (const GLint *v);
WINGDIAPI void APIENTRY glRasterPos2s (GLshort x, GLshort y);
WINGDIAPI void APIENTRY glRasterPos2sv (const GLshort *v);
WINGDIAPI void APIENTRY glRasterPos3d (GLdouble x, GLdouble y, GLdouble z);
WINGDIAPI void APIENTRY glRasterPos3dv (const GLdouble *v);
WINGDIAPI void APIENTRY glRasterPos3f (GLfloat x, GLfloat y, GLfloat z);
WINGDIAPI void APIENTRY glRasterPos3fv (const GLfloat *v);
WINGDIAPI void APIENTRY glRasterPos3i (GLint x, GLint y, GLint z);
WINGDIAPI void APIENTRY glRasterPos3iv (const GLint *v);
WINGDIAPI void APIENTRY glRasterPos3s (GLshort x, GLshort y, GLshort z);
WINGDIAPI void APIENTRY glRasterPos3sv (const GLshort *v);
WINGDIAPI void APIENTRY glRasterPos4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
WINGDIAPI void APIENTRY glRasterPos4dv (const GLdouble *v);
WINGDIAPI void APIENTRY glRasterPos4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
WINGDIAPI void APIENTRY glRasterPos4fv (const GLfloat *v);
WINGDIAPI void APIENTRY glRasterPos4i (GLint x, GLint y, GLint z, GLint w);
WINGDIAPI void APIENTRY glRasterPos4iv (const GLint *v);
WINGDIAPI void APIENTRY glRasterPos4s (GLshort x, GLshort y, GLshort z, GLshort w);
WINGDIAPI void APIENTRY glRasterPos4sv (const GLshort *v);
WINGDIAPI void APIENTRY glReadBuffer (GLenum mode);
WINGDIAPI void APIENTRY glReadPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
WINGDIAPI void APIENTRY glRectd (GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);
WINGDIAPI void APIENTRY glRectdv (const GLdouble *v1, const GLdouble *v2);
WINGDIAPI void APIENTRY glRectf (GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);
WINGDIAPI void APIENTRY glRectfv (const GLfloat *v1, const GLfloat *v2);
WINGDIAPI void APIENTRY glRecti (GLint x1, GLint y1, GLint x2, GLint y2);
WINGDIAPI void APIENTRY glRectiv (const GLint *v1, const GLint *v2);
WINGDIAPI void APIENTRY glRects (GLshort x1, GLshort y1, GLshort x2, GLshort y2);
WINGDIAPI void APIENTRY glRectsv (const GLshort *v1, const GLshort *v2);
WINGDIAPI GLint APIENTRY glRenderMode (GLenum mode);
WINGDIAPI void APIENTRY glRotated (GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
WINGDIAPI void APIENTRY glRotatef (GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
WINGDIAPI void APIENTRY glScaled (GLdouble x, GLdouble y, GLdouble z);
WINGDIAPI void APIENTRY glScalef (GLfloat x, GLfloat y, GLfloat z);
WINGDIAPI void APIENTRY glScissor (GLint x, GLint y, GLsizei width, GLsizei height);
WINGDIAPI void APIENTRY glSelectBuffer (GLsizei size, GLuint *buffer);
WINGDIAPI void APIENTRY glShadeModel (GLenum mode);
WINGDIAPI void APIENTRY glStencilFunc (GLenum func, GLint ref, GLuint mask);
WINGDIAPI void APIENTRY glStencilMask (GLuint mask);
WINGDIAPI void APIENTRY glStencilOp (GLenum fail, GLenum zfail, GLenum zpass);
WINGDIAPI void APIENTRY glTexCoord1d (GLdouble s);
WINGDIAPI void APIENTRY glTexCoord1dv (const GLdouble *v);
WINGDIAPI void APIENTRY glTexCoord1f (GLfloat s);
WINGDIAPI void APIENTRY glTexCoord1fv (const GLfloat *v);
WINGDIAPI void APIENTRY glTexCoord1i (GLint s);
WINGDIAPI void APIENTRY glTexCoord1iv (const GLint *v);
WINGDIAPI void APIENTRY glTexCoord1s (GLshort s);
WINGDIAPI void APIENTRY glTexCoord1sv (const GLshort *v);
WINGDIAPI void APIENTRY glTexCoord2d (GLdouble s, GLdouble t);
WINGDIAPI void APIENTRY glTexCoord2dv (const GLdouble *v);
WINGDIAPI void APIENTRY glTexCoord2f (GLfloat s, GLfloat t);
WINGDIAPI void APIENTRY glTexCoord2fv (const GLfloat *v);
WINGDIAPI void APIENTRY glTexCoord2i (GLint s, GLint t);
WINGDIAPI void APIENTRY glTexCoord2iv (const GLint *v);
WINGDIAPI void APIENTRY glTexCoord2s (GLshort s, GLshort t);
WINGDIAPI void APIENTRY glTexCoord2sv (const GLshort *v);
WINGDIAPI void APIENTRY glTexCoord3d (GLdouble s, GLdouble t, GLdouble r);
WINGDIAPI void APIENTRY glTexCoord3dv (const GLdouble *v);
WINGDIAPI void APIENTRY glTexCoord3f (GLfloat s, GLfloat t, GLfloat r);
WINGDIAPI void APIENTRY glTexCoord3fv (const GLfloat *v);
WINGDIAPI void APIENTRY glTexCoord3i (GLint s, GLint t, GLint r);
WINGDIAPI void APIENTRY glTexCoord3iv (const GLint *v);
WINGDIAPI void APIENTRY glTexCoord3s (GLshort s, GLshort t, GLshort r);
WINGDIAPI void APIENTRY glTexCoord3sv (const GLshort *v);
WINGDIAPI void APIENTRY glTexCoord4d (GLdouble s, GLdouble t, GLdouble r, GLdouble q);
WINGDIAPI void APIENTRY glTexCoord4dv (const GLdouble *v);
WINGDIAPI void APIENTRY glTexCoord4f (GLfloat s, GLfloat t, GLfloat r, GLfloat q);
WINGDIAPI void APIENTRY glTexCoord4fv (const GLfloat *v);
WINGDIAPI void APIENTRY glTexCoord4i (GLint s, GLint t, GLint r, GLint q);
WINGDIAPI void APIENTRY glTexCoord4iv (const GLint *v);
WINGDIAPI void APIENTRY glTexCoord4s (GLshort s, GLshort t, GLshort r, GLshort q);
WINGDIAPI void APIENTRY glTexCoord4sv (const GLshort *v);
WINGDIAPI void APIENTRY glTexCoordPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
WINGDIAPI void APIENTRY glTexEnvf (GLenum target, GLenum pname, GLfloat param);
WINGDIAPI void APIENTRY glTexEnvfv (GLenum target, GLenum pname, const GLfloat *params);
WINGDIAPI void APIENTRY glTexEnvi (GLenum target, GLenum pname, GLint param);
WINGDIAPI void APIENTRY glTexEnviv (GLenum target, GLenum pname, const GLint *params);
WINGDIAPI void APIENTRY glTexGend (GLenum coord, GLenum pname, GLdouble param);
WINGDIAPI void APIENTRY glTexGendv (GLenum coord, GLenum pname, const GLdouble *params);
WINGDIAPI void APIENTRY glTexGenf (GLenum coord, GLenum pname, GLfloat param);
WINGDIAPI void APIENTRY glTexGenfv (GLenum coord, GLenum pname, const GLfloat *params);
WINGDIAPI void APIENTRY glTexGeni (GLenum coord, GLenum pname, GLint param);
WINGDIAPI void APIENTRY glTexGeniv (GLenum coord, GLenum pname, const GLint *params);
WINGDIAPI void APIENTRY glTexImage1D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
WINGDIAPI void APIENTRY glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
WINGDIAPI void APIENTRY glTexParameterf (GLenum target, GLenum pname, GLfloat param);
WINGDIAPI void APIENTRY glTexParameterfv (GLenum target, GLenum pname, const GLfloat *params);
WINGDIAPI void APIENTRY glTexParameteri (GLenum target, GLenum pname, GLint param);
WINGDIAPI void APIENTRY glTexParameteriv (GLenum target, GLenum pname, const GLint *params);
WINGDIAPI void APIENTRY glTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
WINGDIAPI void APIENTRY glTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
WINGDIAPI void APIENTRY glTranslated (GLdouble x, GLdouble y, GLdouble z);
WINGDIAPI void APIENTRY glTranslatef (GLfloat x, GLfloat y, GLfloat z);
WINGDIAPI void APIENTRY glVertex2d (GLdouble x, GLdouble y);
WINGDIAPI void APIENTRY glVertex2dv (const GLdouble *v);
WINGDIAPI void APIENTRY glVertex2f (GLfloat x, GLfloat y);
WINGDIAPI void APIENTRY glVertex2fv (const GLfloat *v);
WINGDIAPI void APIENTRY glVertex2i (GLint x, GLint y);
WINGDIAPI void APIENTRY glVertex2iv (const GLint *v);
WINGDIAPI void APIENTRY glVertex2s (GLshort x, GLshort y);
WINGDIAPI void APIENTRY glVertex2sv (const GLshort *v);
WINGDIAPI void APIENTRY glVertex3d (GLdouble x, GLdouble y, GLdouble z);
WINGDIAPI void APIENTRY glVertex3dv (const GLdouble *v);
WINGDIAPI void APIENTRY glVertex3f (GLfloat x, GLfloat y, GLfloat z);
WINGDIAPI void APIENTRY glVertex3fv (const GLfloat *v);
WINGDIAPI void APIENTRY glVertex3i (GLint x, GLint y, GLint z);
WINGDIAPI void APIENTRY glVertex3iv (const GLint *v);
WINGDIAPI void APIENTRY glVertex3s (GLshort x, GLshort y, GLshort z);
WINGDIAPI void APIENTRY glVertex3sv (const GLshort *v);
WINGDIAPI void APIENTRY glVertex4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
WINGDIAPI void APIENTRY glVertex4dv (const GLdouble *v);
WINGDIAPI void APIENTRY glVertex4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
WINGDIAPI void APIENTRY glVertex4fv (const GLfloat *v);
WINGDIAPI void APIENTRY glVertex4i (GLint x, GLint y, GLint z, GLint w);
WINGDIAPI void APIENTRY glVertex4iv (const GLint *v);
WINGDIAPI void APIENTRY glVertex4s (GLshort x, GLshort y, GLshort z, GLshort w);
WINGDIAPI void APIENTRY glVertex4sv (const GLshort *v);
WINGDIAPI void APIENTRY glVertexPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
WINGDIAPI void APIENTRY glViewport (GLint x, GLint y, GLsizei width, GLsizei height);

/* EXT_vertex_array */
typedef void (APIENTRY * PFNGLARRAYELEMENTEXTPROC) (GLint i);
typedef void (APIENTRY * PFNGLDRAWARRAYSEXTPROC) (GLenum mode, GLint first, GLsizei count);
typedef void (APIENTRY * PFNGLVERTEXPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (APIENTRY * PFNGLNORMALPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (APIENTRY * PFNGLCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (APIENTRY * PFNGLINDEXPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (APIENTRY * PFNGLTEXCOORDPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (APIENTRY * PFNGLEDGEFLAGPOINTEREXTPROC) (GLsizei stride, GLsizei count, const GLboolean *pointer);
typedef void (APIENTRY * PFNGLGETPOINTERVEXTPROC) (GLenum pname, GLvoid* *params);
typedef void (APIENTRY * PFNGLARRAYELEMENTARRAYEXTPROC)(GLenum mode, GLsizei count, const GLvoid* pi);

/* WIN_draw_range_elements */
typedef void (APIENTRY * PFNGLDRAWRANGEELEMENTSWINPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);

/* WIN_swap_hint */
typedef void (APIENTRY * PFNGLADDSWAPHINTRECTWINPROC)  (GLint x, GLint y, GLsizei width, GLsizei height);

/* EXT_paletted_texture */
typedef void (APIENTRY * PFNGLCOLORTABLEEXTPROC)
    (GLenum target, GLenum internalFormat, GLsizei width, GLenum format,
     GLenum type, const GLvoid *data);
typedef void (APIENTRY * PFNGLCOLORSUBTABLEEXTPROC)
    (GLenum target, GLsizei start, GLsizei count, GLenum format,
     GLenum type, const GLvoid *data);
typedef void (APIENTRY * PFNGLGETCOLORTABLEEXTPROC)
    (GLenum target, GLenum format, GLenum type, GLvoid *data);
typedef void (APIENTRY * PFNGLGETCOLORTABLEPARAMETERIVEXTPROC)
    (GLenum target, GLenum pname, GLint *params);
typedef void (APIENTRY * PFNGLGETCOLORTABLEPARAMETERFVEXTPROC)
    (GLenum target, GLenum pname, GLfloat *params);

#ifdef __cplusplus
}
#endif

#endif /* __GL_H__ */
#endif /* __gl_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afx.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFX_H__
#define __AFX_H__

#ifndef __cplusplus
	#error MFC requires C++ compilation (use a .cpp suffix)
#endif

#pragma once

/////////////////////////////////////////////////////////////////////////////

#ifdef _DLL
#ifndef _AFXDLL
#error Building MFC application with /MD[d] (CRT dll version) requires MFC shared dll version. Please #define _AFXDLL or do not use /MD[d]
#endif
#endif

#if !defined(_M_IX86) && !defined(_M_AMD64)
	#error Compiling for unsupported platform.  Only x86 and x64 platforms are supported by MFC.
#endif

// Since MFC itself is built with wchar_t as a native type, it will not have
// the correct type info for types built with wchar_t typedef'd to unsigned
// short.  Make sure that the user's app builds this type info in this case.
#ifndef _NATIVE_WCHAR_T_DEFINED
#define _AFX_FULLTYPEINFO
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 
 
#ifdef __ATLDBGMEM_H__
#error <atldbgmem.h> cannot be used in MFC projects. See AfxEnableMemoryTracking
#endif

#if defined(_MFC_DLL_BLD) && defined(_DEBUG)
#ifndef _CRTDBG_MAP_ALLOC
#define _CRTDBG_MAP_ALLOC
#endif
#endif

#ifndef _INC_NEW
	#include <new.h>
#endif

#include <afxver_.h>        // Target version control

#ifdef _WIN64
#ifndef _AFX_NO_DAO_SUPPORT
#define _AFX_NO_DAO_SUPPORT
#endif
#endif

#ifndef _AFX_NOFORCE_LIBS

/////////////////////////////////////////////////////////////////////////////
// Win32 libraries

#ifndef _AFXDLL
	#ifndef _UNICODE
		#ifdef _DEBUG
			#pragma comment(lib, "nafxcwd.lib")
		#else
			#pragma comment(lib, "nafxcw.lib")
		#endif
	#else
		#ifdef _DEBUG
			#pragma comment(lib, "uafxcwd.lib")
		#else
			#pragma comment(lib, "uafxcw.lib")
		#endif
	#endif
#else
	#ifndef _UNICODE
		#ifdef _DEBUG
			#pragma comment(lib, "mfc" _MFC_FILENAME_VER "d.lib")
			#pragma comment(lib, "mfcs" _MFC_FILENAME_VER "d.lib")
		#else
			#pragma comment(lib, "mfc" _MFC_FILENAME_VER ".lib")
			#pragma comment(lib, "mfcs" _MFC_FILENAME_VER ".lib")
		#endif
	#else
		#ifdef _DEBUG
			#pragma comment(lib, "mfc" _MFC_FILENAME_VER "ud.lib")
			#pragma comment(lib, "mfcs" _MFC_FILENAME_VER "ud.lib")
		#else
			#pragma comment(lib, "mfc" _MFC_FILENAME_VER "u.lib")
			#pragma comment(lib, "mfcs" _MFC_FILENAME_VER "u.lib")
		#endif
	#endif
#endif

#ifdef _DLL
	#if !defined(_AFX_NO_DEBUG_CRT) && defined(_DEBUG)
		#pragma comment(lib, "msvcrtd.lib")
	#else
		#pragma comment(lib, "msvcrt.lib")
	#endif
#else
	#if !defined(_AFX_NO_DEBUG_CRT) && defined(_DEBUG)
		#pragma comment(lib, "libcmtd.lib")
	#else
		#pragma comment(lib, "libcmt.lib")
	#endif
#endif

#pragma comment(lib, "kernel32.lib")
#pragma comment(lib, "user32.lib")
#pragma comment(lib, "gdi32.lib")
#pragma comment(lib, "msimg32.lib")
#pragma comment(lib, "comdlg32.lib")
#pragma comment(lib, "winspool.lib")
#pragma comment(lib, "advapi32.lib")
#pragma comment(lib, "shell32.lib")
#pragma comment(lib, "comctl32.lib")
#pragma comment(lib, "shlwapi.lib")

// force inclusion of NOLIB.OBJ for /disallowlib directives
#pragma comment(linker, "/include:__afxForceEXCLUDE")

// force inclusion of DLLMODUL.OBJ for _USRDLL
#ifdef _USRDLL
#pragma comment(linker, "/include:__afxForceUSRDLL")
#endif

// force inclusion of STDAFX.OBJ for precompiled types
#ifdef _AFXDLL
#pragma comment(linker, "/include:__afxForceSTDAFX")
#endif

#endif //!_AFX_NOFORCE_LIBS

#ifdef _MANAGED

#ifndef AFX_NO_CLR_COINIT_STA
#pragma comment(linker, "/CLRTHREADATTRIBUTE:STA")
#endif 

#endif //_MANAGED
/////////////////////////////////////////////////////////////////////////////
// Classes declared in this file
//   in addition to standard primitive data types and various helper macros

struct CRuntimeClass;          // object type information

class CObject;                        // the root of all objects classes

	class CException;                 // the root of all exceptions
		class CArchiveException;      // archive exception
		class CFileException;         // file exception
		class CSimpleException;
			class CMemoryException;       // out-of-memory exception
			class CNotSupportedException; // feature not supported exception
			class CInvalidArgException;	  // one of the parameters to the function is invalid

	class CFile;                      // raw binary file
		class CStdioFile;             // buffered stdio text/binary file
		class CMemFile;               // memory based file

// Non CObject classes
struct CFileStatus;                   // file status information
struct CMemoryState;                  // diagnostic memory support

class CArchive;                       // object persistence tool
class CDumpContext;                   // object diagnostic dumping

/////////////////////////////////////////////////////////////////////////////
// Other includes from standard "C" runtimes

#ifndef _INC_STRING
	#include <string.h>
#endif
#ifndef _INC_STDIO
	#include <stdio.h>
#endif
#ifndef _INC_STDLIB
	#include <stdlib.h>
#endif
#ifndef _INC_TIME
	#include <time.h>
#endif
#ifndef _INC_LIMITS
	#include <limits.h>
#endif
#ifndef _INC_STDDEF
	#include <stddef.h>
#endif
#ifndef _INC_STDARG
	#include <stdarg.h>
#endif
#ifndef _INC_ERRNO 
#include <errno.h>
#endif

#include <malloc.h>

#ifndef _AFX_NO_DEBUG_CRT
#ifndef _INC_CRTDBG
	#include <crtdbg.h>
#endif
#endif // _AFX_NO_DEBUG_CRT

#ifdef _AFX_OLD_EXCEPTIONS
#error MFC no longer supports setjmp/longjmp exception handling.
#endif

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// Basic types
// abstract iteration position
struct __POSITION {};
typedef __POSITION* POSITION;

// Standard constants
#undef FALSE
#undef TRUE
#undef NULL

#define FALSE   0
#define TRUE    1
#define NULL    0

/////////////////////////////////////////////////////////////////////////////
// _AFX_FUNCNAME definition
#ifdef UNICODE
#define _AFX_FUNCNAME(_Name) _Name##W
#else
#define _AFX_FUNCNAME(_Name) _Name##A
#endif

/////////////////////////////////////////////////////////////////////////////
// Turn off warnings for /W4
// To resume any of these warning: #pragma warning(default: 4xxx)
// which should be placed after the AFX include files

#pragma warning(disable: 4505)  // unreferenced local function has been removed
#pragma warning(disable: 4511)  // private copy constructors are good to have
#pragma warning(disable: 4512)  // private operator= are good to have
#pragma warning(disable: 4514)  // unreferenced inlines are common
#pragma warning(disable: 4710)  // function not inlined
#pragma warning(disable: 4127)  // constant expression used in macros do while(0);

// warnings specific to _AFXDLL version
#ifdef _AFXDLL
#pragma warning(disable: 4275)  // deriving exported class from non-exported
#pragma warning(disable: 4251)  // using non-exported as public in exported
#endif

#ifdef _AFX_ALL_WARNINGS
#pragma warning( push )
#endif

// warnings generated with common MFC/Windows code
#pragma warning(disable: 4201)  // nameless unions are part of C++
#pragma warning(disable: 4191)  // pointer-to-function casting
// warnings caused by normal optimizations
#ifndef _DEBUG
#pragma warning(disable: 4701)  // local variable *may* be used without init
#pragma warning(disable: 4702)  // unreachable code caused by optimizations
#pragma warning(disable: 4189)  // initialized but unused variable
#pragma warning(disable: 4390)  // empty controlled statement
#endif
// warnings specific to _AFXDLL version
#ifdef _AFXDLL
#pragma warning(disable: 4204)  // non-constant aggregate initializer
#endif
#pragma warning(disable: 4263 4264)  // base class method is hidden

/////////////////////////////////////////////////////////////////////////////
// Diagnostic support

#ifdef _DEBUG

BOOL AFXAPI AfxAssertFailedLine(LPCSTR lpszFileName, int nLine);

void AFX_CDECL AfxTrace(LPCTSTR lpszFormat, ...);
// Note: file names are still ANSI strings (filenames rarely need UNICODE)
void AFXAPI AfxAssertValidObject(const CObject* pOb,
				LPCSTR lpszFileName, int nLine);
void AFXAPI AfxDump(const CObject* pOb); // Dump an object from CodeView

#include <atltrace.h>

// extern ATL::CTrace TRACE;
#define TRACE ATLTRACE

#define THIS_FILE          __FILE__
#define VERIFY(f)          ASSERT(f)
#define DEBUG_ONLY(f)      (f)

// The following trace macros are provided for backward compatiblity
//  (they also take a fixed number of parameters which provides
//   some amount of extra error checking)
#define TRACE0(sz)              TRACE(_T("%s"), _T(sz))
#define TRACE1(sz, p1)          TRACE(_T(sz), p1)
#define TRACE2(sz, p1, p2)      TRACE(_T(sz), p1, p2)
#define TRACE3(sz, p1, p2, p3)  TRACE(_T(sz), p1, p2, p3)

// These AFX_DUMP macros also provided for backward compatibility
#define AFX_DUMP0(dc, sz)   dc << _T(sz)
#define AFX_DUMP1(dc, sz, p1) dc << _T(sz) << p1

#else   // _DEBUG

#define VERIFY(f)          ((void)(f))
#define DEBUG_ONLY(f)      ((void)0)
#pragma warning(push)
#pragma warning(disable : 4793)
inline void AFX_CDECL AfxTrace(...) { }
#pragma warning(pop)
#define TRACE              __noop
#define TRACE0(sz)
#define TRACE1(sz, p1)
#define TRACE2(sz, p1, p2)
#define TRACE3(sz, p1, p2, p3)

#endif // !_DEBUG

#define ASSERT(f)          DEBUG_ONLY((void) ((f) || !::AfxAssertFailedLine(THIS_FILE, __LINE__) || (AfxDebugBreak(), 0)))
/* see ATL headers for commentary on this */
/* We use the name AFXASSUME to avoid name clashes */

#if defined(_PREFAST_) || defined (_DEBUG)
#define AFXASSUME(cond)			do { bool __afx_condVal=!!(cond); ASSERT(__afx_condVal); __analysis_assume(__afx_condVal); } while(0) 
#else
#define AFXASSUME(cond)			((void)0)
#endif

#define ASSERT_VALID(pOb)  DEBUG_ONLY((::AfxAssertValidObject(pOb, THIS_FILE, __LINE__)))

// Debug ASSERTs then throws. Retail throws if condition not met
#define ENSURE_THROW(cond, exception)	\
	do { int __afx_condVal=!!(cond); ASSERT(__afx_condVal); if (!(__afx_condVal)){exception;} } while (false)
#define ENSURE(cond)		ENSURE_THROW(cond, ::AfxThrowInvalidArgException() )
#define ENSURE_ARG(cond)	ENSURE_THROW(cond, ::AfxThrowInvalidArgException() )

// Debug ASSERT_VALIDs then throws. Retail throws if pOb is NULL
#define ENSURE_VALID_THROW(pOb, exception)	\
	do { ASSERT_VALID(pOb); if (!(pOb)){exception;} } while (false)
#define ENSURE_VALID(pOb)	ENSURE_VALID_THROW(pOb, ::AfxThrowInvalidArgException() )

#define ASSERT_POINTER(p, type) \
	ASSERT(((p) != NULL) && AfxIsValidAddress((p), sizeof(type), FALSE))

#define ASSERT_NULL_OR_POINTER(p, type) \
	ASSERT(((p) == NULL) || AfxIsValidAddress((p), sizeof(type), FALSE))

#ifdef _DEBUG
#define UNUSED(x)
#else
#define UNUSED(x) UNREFERENCED_PARAMETER(x)
#endif
#define UNUSED_ALWAYS(x) UNREFERENCED_PARAMETER(x)

#ifdef _DEBUG
#define REPORT_EXCEPTION(pException, szMsg) \
	do { \
		TCHAR szErrorMessage[512]; \
		if (pException->GetErrorMessage(szErrorMessage, sizeof(szErrorMessage)/sizeof(*szErrorMessage), 0)) \
			TRACE(traceAppMsg, 0, _T("%s (%s:%d)\n%s\n"), szMsg, _T(__FILE__), __LINE__, szErrorMessage); \
		else \
			TRACE(traceAppMsg, 0, _T("%s (%s:%d)\n"), szMsg, _T(__FILE__), __LINE__); \
		ASSERT(FALSE); \
	} while (0)
#else
#define REPORT_EXCEPTION(pException, szMsg) \
	do { \
		CString strMsg; \
		TCHAR  szErrorMessage[512]; \
		if (pException->GetErrorMessage(szErrorMessage, sizeof(szErrorMessage)/sizeof(*szErrorMessage), 0)) \
			strMsg.Format(_T("%s (%s:%d)\n%s"), szMsg, _T(__FILE__), __LINE__, szErrorMessage); \
		else \
			strMsg.Format(_T("%s (%s:%d)"), szMsg, _T(__FILE__), __LINE__); \
		AfxMessageBox(strMsg); \
	} while (0)
#endif

#define EXCEPTION_IN_DTOR(pException) \
	do { \
		REPORT_EXCEPTION((pException), _T("Exception thrown in destructor")); \
		delete pException; \
	} while (0)
	
#define AFX_BEGIN_DESTRUCTOR try {
#define AFX_END_DESTRUCTOR   } catch (CException *pException) { EXCEPTION_IN_DTOR(pException); }

/////////////////////////////////////////////////////////////////////////////
// Other implementation helpers

#define BEFORE_START_POSITION ((POSITION)-1L)

/////////////////////////////////////////////////////////////////////////////
// explicit initialization for general purpose classes

BOOL AFXAPI AfxInitialize(BOOL bDLL = FALSE, DWORD dwVersion = _MFC_VER);

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

/////////////////////////////////////////////////////////////////////////////
// Basic object model

// generate static object constructor for class registration
void AFXAPI AfxClassInit(CRuntimeClass* pNewClass);
struct AFX_CLASSINIT
	{ AFX_CLASSINIT(CRuntimeClass* pNewClass) { AfxClassInit(pNewClass); } };

struct CRuntimeClass
{
// Attributes
	LPCSTR m_lpszClassName;
	int m_nObjectSize;
	UINT m_wSchema; // schema number of the loaded class
	CObject* (PASCAL* m_pfnCreateObject)(); // NULL => abstract class
#ifdef _AFXDLL
	CRuntimeClass* (PASCAL* m_pfnGetBaseClass)();
#else
	CRuntimeClass* m_pBaseClass;
#endif

// Operations
	CObject* CreateObject();
	BOOL IsDerivedFrom(const CRuntimeClass* pBaseClass) const;

	// dynamic name lookup and creation
	static CRuntimeClass* PASCAL FromName(LPCSTR lpszClassName);
	static CRuntimeClass* PASCAL FromName(LPCWSTR lpszClassName);
	static CObject* PASCAL CreateObject(LPCSTR lpszClassName);
	static CObject* PASCAL CreateObject(LPCWSTR lpszClassName);

// Implementation
	void Store(CArchive& ar) const;
	static CRuntimeClass* PASCAL Load(CArchive& ar, UINT* pwSchemaNum);

	// CRuntimeClass objects linked together in simple list
	CRuntimeClass* m_pNextClass;       // linked list of registered classes
	const AFX_CLASSINIT* m_pClassInit;
};

/////////////////////////////////////////////////////////////////////////////
// Standard exception throws

void __declspec(noreturn) AFXAPI AfxThrowMemoryException();
void __declspec(noreturn) AFXAPI AfxThrowNotSupportedException();
void __declspec(noreturn) AFXAPI AfxThrowInvalidArgException();
void __declspec(noreturn) AFXAPI AfxThrowArchiveException(int cause,
	LPCTSTR lpszArchiveName = NULL);
void __declspec(noreturn) AFXAPI AfxThrowFileException(int cause, LONG lOsError = -1,
	LPCTSTR lpszFileName = NULL);
void __declspec(noreturn) AFXAPI AfxThrowOleException(LONG sc);

/////////////////////////////////////////////////////////////////////////////
// CRT functions

inline errno_t AfxCrtErrorCheck(errno_t error)
{
	switch(error)
	{
	case ENOMEM:
		AfxThrowMemoryException();
		break;
	case EINVAL:
	case ERANGE:
		AfxThrowInvalidArgException();
		break;
	case STRUNCATE:
	case 0:
		break;
	default:
		AfxThrowInvalidArgException();
		break;
	}
	return error;
}

#define AFX_CRT_ERRORCHECK(expr) \
	AfxCrtErrorCheck(expr)

inline void __cdecl Afx_clearerr_s(FILE *stream)
{
	AFX_CRT_ERRORCHECK(::clearerr_s(stream));
}

/////////////////////////////////////////////////////////////////////////////
// Strings

#ifndef _OLEAUTO_H_
	typedef LPWSTR BSTR;// must (semantically) match typedef in oleauto.h
#endif

/////////////////////////////////////////////////////////////////////////////
// class CObject is the root of all compliant objects

class AFX_NOVTABLE CObject
{
public:

// Object model (types, destruction, allocation)
	virtual CRuntimeClass* GetRuntimeClass() const;
	virtual ~CObject() = 0;  // virtual destructors are necessary

	// Diagnostic allocations
	void* PASCAL operator new(size_t nSize);
	void* PASCAL operator new(size_t, void* p);
	void PASCAL operator delete(void* p);
	void PASCAL operator delete(void* p, void* pPlace);

#if defined(_DEBUG) && !defined(_AFX_NO_DEBUG_CRT)
	// for file name/line number tracking using DEBUG_NEW
	void* PASCAL operator new(size_t nSize, LPCSTR lpszFileName, int nLine);
	void PASCAL operator delete(void *p, LPCSTR lpszFileName, int nLine);
#endif

	// Disable the copy constructor and assignment by default so you will get
	//   compiler errors instead of unexpected behaviour if you pass objects
	//   by value or assign objects.
protected:
	CObject();
private:
	CObject(const CObject& objectSrc);              // no implementation
	void operator=(const CObject& objectSrc);       // no implementation

// Attributes
public:
	BOOL IsSerializable() const;
	BOOL IsKindOf(const CRuntimeClass* pClass) const;

// Overridables
	virtual void Serialize(CArchive& ar);

#if defined(_DEBUG) || defined(_AFXDLL)
	// Diagnostic Support
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Implementation
public:
	static const CRuntimeClass classCObject;
#ifdef _AFXDLL
	static CRuntimeClass* PASCAL _GetBaseClass();
	static CRuntimeClass* PASCAL GetThisClass();
#endif
};

// Helper macros
#define _RUNTIME_CLASS(class_name) ((CRuntimeClass*)(&class_name::class##class_name))
#ifdef _AFXDLL
#define RUNTIME_CLASS(class_name) (class_name::GetThisClass())
#else
#define RUNTIME_CLASS(class_name) _RUNTIME_CLASS(class_name)
#endif
#define ASSERT_KINDOF(class_name, object) \
	ASSERT((object)->IsKindOf(RUNTIME_CLASS(class_name)))

// RTTI helper macros/functions
const CObject* AFX_CDECL AfxDynamicDownCast(CRuntimeClass* pClass, const CObject* pObject);
CObject* AFX_CDECL AfxDynamicDownCast(CRuntimeClass* pClass, CObject* pObject);
#define DYNAMIC_DOWNCAST(class_name, object) \
	(class_name*)AfxDynamicDownCast(RUNTIME_CLASS(class_name), object)

#ifdef _DEBUG
const CObject* AFX_CDECL AfxStaticDownCast(CRuntimeClass* pClass, const CObject* pObject);
CObject* AFX_CDECL AfxStaticDownCast(CRuntimeClass* pClass, CObject* pObject);
#define STATIC_DOWNCAST(class_name, object) \
	(static_cast<class_name*>(AfxStaticDownCast(RUNTIME_CLASS(class_name), object)))
#else
#define STATIC_DOWNCAST(class_name, object) (static_cast<class_name*>(object))
#endif

//////////////////////////////////////////////////////////////////////////////
// Helper macros for declaring CRuntimeClass compatible classes

#ifdef _AFXDLL
#define DECLARE_DYNAMIC(class_name) \
protected: \
	static CRuntimeClass* PASCAL _GetBaseClass(); \
public: \
	static const CRuntimeClass class##class_name; \
	static CRuntimeClass* PASCAL GetThisClass(); \
	virtual CRuntimeClass* GetRuntimeClass() const; \

#define _DECLARE_DYNAMIC(class_name) \
protected: \
	static CRuntimeClass* PASCAL _GetBaseClass(); \
public: \
	static CRuntimeClass class##class_name; \
	static CRuntimeClass* PASCAL GetThisClass(); \
	virtual CRuntimeClass* GetRuntimeClass() const; \

#else
#define DECLARE_DYNAMIC(class_name) \
public: \
	static const CRuntimeClass class##class_name; \
	virtual CRuntimeClass* GetRuntimeClass() const; \

#define _DECLARE_DYNAMIC(class_name) \
public: \
	static CRuntimeClass class##class_name; \
	virtual CRuntimeClass* GetRuntimeClass() const; \

#endif

// not serializable, but dynamically constructable
#define DECLARE_DYNCREATE(class_name) \
	DECLARE_DYNAMIC(class_name) \
	static CObject* PASCAL CreateObject();

#define _DECLARE_DYNCREATE(class_name) \
	_DECLARE_DYNAMIC(class_name) \
	static CObject* PASCAL CreateObject();

#define DECLARE_SERIAL(class_name) \
	_DECLARE_DYNCREATE(class_name) \
	AFX_API friend CArchive& AFXAPI operator>>(CArchive& ar, class_name* &pOb);

#ifdef _AFXDLL
#define IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, wSchema, pfnNew, class_init) \
	CRuntimeClass* PASCAL class_name::_GetBaseClass() \
		{ return RUNTIME_CLASS(base_class_name); } \
	AFX_COMDAT const CRuntimeClass class_name::class##class_name = { \
		#class_name, sizeof(class class_name), wSchema, pfnNew, \
			&class_name::_GetBaseClass, NULL, class_init }; \
	CRuntimeClass* PASCAL class_name::GetThisClass() \
		{ return _RUNTIME_CLASS(class_name); } \
	CRuntimeClass* class_name::GetRuntimeClass() const \
		{ return _RUNTIME_CLASS(class_name); }

#define _IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, wSchema, pfnNew, class_init) \
	CRuntimeClass* PASCAL class_name::_GetBaseClass() \
		{ return RUNTIME_CLASS(base_class_name); } \
	AFX_COMDAT CRuntimeClass class_name::class##class_name = { \
		#class_name, sizeof(class class_name), wSchema, pfnNew, \
			&class_name::_GetBaseClass, NULL, class_init }; \
	CRuntimeClass* PASCAL class_name::GetThisClass() \
		{ return _RUNTIME_CLASS(class_name); } \
	CRuntimeClass* class_name::GetRuntimeClass() const \
		{ return _RUNTIME_CLASS(class_name); }

#else
#define IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, wSchema, pfnNew, class_init) \
	AFX_COMDAT const CRuntimeClass class_name::class##class_name = { \
		#class_name, sizeof(class class_name), wSchema, pfnNew, \
			RUNTIME_CLASS(base_class_name), NULL, class_init }; \
	CRuntimeClass* class_name::GetRuntimeClass() const \
		{ return RUNTIME_CLASS(class_name); }

#define _IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, wSchema, pfnNew, class_init) \
	AFX_COMDAT CRuntimeClass class_name::class##class_name = { \
		#class_name, sizeof(class class_name), wSchema, pfnNew, \
			RUNTIME_CLASS(base_class_name), NULL, class_init }; \
	CRuntimeClass* class_name::GetRuntimeClass() const \
		{ return RUNTIME_CLASS(class_name); }

#endif

#define IMPLEMENT_DYNAMIC(class_name, base_class_name) \
	IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, 0xFFFF, NULL, NULL)

#define IMPLEMENT_DYNCREATE(class_name, base_class_name) \
	CObject* PASCAL class_name::CreateObject() \
		{ return new class_name; } \
	IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, 0xFFFF, \
		class_name::CreateObject, NULL)

#define IMPLEMENT_SERIAL(class_name, base_class_name, wSchema) \
	CObject* PASCAL class_name::CreateObject() \
		{ return new class_name; } \
	extern AFX_CLASSINIT _init_##class_name; \
	_IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, wSchema, \
		class_name::CreateObject, &_init_##class_name) \
	AFX_CLASSINIT _init_##class_name(RUNTIME_CLASS(class_name)); \
	CArchive& AFXAPI operator>>(CArchive& ar, class_name* &pOb) \
		{ pOb = (class_name*) ar.ReadObject(RUNTIME_CLASS(class_name)); \
			return ar; }

// optional bit for schema number that enables object versioning
#define VERSIONABLE_SCHEMA  (0x80000000)

/////////////////////////////////////////////////////////////////////////////
// Exceptions

class AFX_NOVTABLE CException : public CObject
{
	// abstract class for dynamic type checking
	DECLARE_DYNAMIC(CException)

public:
// Constructors
	CException();   // sets m_bAutoDelete = TRUE
	explicit CException(BOOL bAutoDelete);   // sets m_bAutoDelete = bAutoDelete

// Operations
	void Delete();  // use to delete exception in 'catch' block

	virtual BOOL GetErrorMessage(_Out_z_cap_(nMaxError) LPTSTR lpszError, _In_ UINT nMaxError,
		_Out_opt_ PUINT pnHelpContext = NULL) const ;
	virtual BOOL GetErrorMessage(_Out_z_cap_(nMaxError) LPTSTR lpszError, _In_ UINT nMaxError,
		_Out_opt_ PUINT pnHelpContext = NULL);
	virtual int ReportError(UINT nType = MB_OK, UINT nMessageID = 0);

// Implementation (setting m_bAutoDelete to FALSE is advanced)
public:
	virtual ~CException() = 0;
	BOOL m_bAutoDelete;
#ifdef _DEBUG
	void PASCAL operator delete(void* pbData);
	void PASCAL operator delete(void* pbData, LPCSTR lpszFileName, int nLine);
protected:
	BOOL m_bReadyForDelete;
#endif
};

#include <afxstr.h>

// ATL Classes

class CSimpleException : public CException
{
	DECLARE_DYNAMIC(CSimpleException)
	
	// base class for resource-critical MFC exceptions
	// handles ownership and initialization of an error message

public:
// Constructors
	CSimpleException();
	explicit CSimpleException(BOOL bAutoDelete);

// Operations
	virtual BOOL GetErrorMessage(_Out_z_cap_(nMaxError) LPTSTR lpszError, _In_ UINT nMaxError,
		_Out_opt_ PUINT pnHelpContext = NULL) const;

// Implementation (setting m_bAutoDelete to FALSE is advanced)
public:
	virtual ~CSimpleException() = 0;
	BOOL m_bAutoDelete;

	void InitString();      // used during MFC initialization

protected:
	BOOL m_bInitialized;
	BOOL m_bLoaded;
	TCHAR m_szMessage[128];
	UINT m_nResourceID;

#ifdef _DEBUG
	BOOL m_bReadyForDelete;
#endif
};

// helper routines for non-C++ EH implementations
	// for THROW_LAST auto-delete backward compatiblity
	void AFXAPI AfxThrowLastCleanup();

// other out-of-line helper functions
void AFXAPI AfxTryCleanup();

#ifndef _AFX_JUMPBUF
// Use portable 'jmp_buf' defined by ANSI by default.
#define _AFX_JUMPBUF jmp_buf
#endif

// Placed on frame for EXCEPTION linkage, or CException cleanup
struct AFX_EXCEPTION_LINK
{
	AFX_EXCEPTION_LINK* m_pLinkPrev;    // previous top, next in handler chain
	CException* m_pException;   // current exception (NULL in TRY block)

	AFX_EXCEPTION_LINK();       // for initialization and linking
	~AFX_EXCEPTION_LINK()       // for cleanup and unlinking
		{ AfxTryCleanup(); };
};

// Exception global state - never access directly
struct AFX_EXCEPTION_CONTEXT
{
	AFX_EXCEPTION_LINK* m_pLinkTop;

	// Note: most of the exception context is now in the AFX_EXCEPTION_LINK
};

#ifndef _PNH_DEFINED
typedef int (__cdecl * _PNH)( size_t );
#define _PNH_DEFINED
#endif

_PNH AFXAPI AfxGetNewHandler();
_PNH AFXAPI AfxSetNewHandler(_PNH pfnNewHandler);
int AFX_CDECL AfxNewHandler(size_t nSize);

void AFXAPI AfxAbort();


/////////////////////////////////////////////////////////////////////////////
// Exception macros using try, catch and throw
//  (for backward compatibility to previous versions of MFC)

#define TRY { AFX_EXCEPTION_LINK _afxExceptionLink; try {

#define CATCH(class, e) } catch (class* e) \
	{ ASSERT(e->IsKindOf(RUNTIME_CLASS(class))); \
		_afxExceptionLink.m_pException = e;

#define AND_CATCH(class, e) } catch (class* e) \
	{ ASSERT(e->IsKindOf(RUNTIME_CLASS(class))); \
		_afxExceptionLink.m_pException = e;

#define END_CATCH } }

#define THROW(e) throw e
#define THROW_LAST() (AfxThrowLastCleanup(), throw)

// Advanced macros for smaller code
#define CATCH_ALL(e) } catch (CException* e) \
	{ { ASSERT(e->IsKindOf(RUNTIME_CLASS(CException))); \
		_afxExceptionLink.m_pException = e;

#define AND_CATCH_ALL(e) } catch (CException* e) \
	{ { ASSERT(e->IsKindOf(RUNTIME_CLASS(CException))); \
		_afxExceptionLink.m_pException = e;

#define END_CATCH_ALL } } }

#define END_TRY } catch (CException* e) \
	{ ASSERT(e->IsKindOf(RUNTIME_CLASS(CException))); \
		_afxExceptionLink.m_pException = e; } }


/////////////////////////////////////////////////////////////////////////////
// Standard Exception classes

class CMemoryException : public CSimpleException
{
	DECLARE_DYNAMIC(CMemoryException)
public:
	CMemoryException();

// Implementation
public:
	explicit CMemoryException(BOOL bAutoDelete);
	CMemoryException(BOOL bAutoDelete, UINT nResourceID);
	virtual ~CMemoryException();
};

class CNotSupportedException : public CSimpleException
{
	DECLARE_DYNAMIC(CNotSupportedException)
public:
	CNotSupportedException();

// Implementation
public:
	explicit CNotSupportedException(BOOL bAutoDelete);
	CNotSupportedException(BOOL bAutoDelete, UINT nResourceID);
	virtual ~CNotSupportedException();
};
class CInvalidArgException : public CSimpleException
{
	DECLARE_DYNAMIC(CInvalidArgException)
public:
	CInvalidArgException();

// Implementation
public:
	CInvalidArgException(BOOL bAutoDelete);
	CInvalidArgException(BOOL bAutoDelete, UINT nResourceID);
	virtual ~CInvalidArgException();
};

class CArchiveException : public CException
{
	DECLARE_DYNAMIC(CArchiveException)
public:
	enum {
		none,
		genericException,
		readOnly,
		endOfFile,
		writeOnly,
		badIndex,
		badClass,
		badSchema,
		bufferFull
	};

#pragma warning(push)
#pragma warning(disable:4996)
	AFX_DEPRECATED("CArchiveException::generic clashes with future language keyword generic and should not be used. Use CArchiveException::genericException instead.") static const int __identifier(generic) = genericException;
#pragma warning(pop)

// Constructor
	/* explicit */ CArchiveException(int cause = CArchiveException::none,
		LPCTSTR lpszArchiveName = NULL);

// Attributes
	int m_cause;
	CString m_strFileName;

// Implementation
public:
	virtual ~CArchiveException();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual BOOL GetErrorMessage(_Out_z_cap_(nMaxError) LPTSTR lpszError, _In_ UINT nMaxError,
		_Out_opt_ PUINT pnHelpContext = NULL) const;
};

class CFileException : public CException
{
	DECLARE_DYNAMIC(CFileException)

public:
	enum {
		none,
		genericException,
		fileNotFound,
		badPath,
		tooManyOpenFiles,
		accessDenied,
		invalidFile,
		removeCurrentDir,
		directoryFull,
		badSeek,
		hardIO,
		sharingViolation,
		lockViolation,
		diskFull,
		endOfFile
	};

#pragma warning(push)
#pragma warning(disable:4996)
	AFX_DEPRECATED("CFileException::generic clashes with future language keyword generic and should not be used. Use CFileException::genericException instead.") static const int __identifier(generic) = genericException;
#pragma warning(pop)

// Constructor
	/* explicit */ CFileException(int cause = CFileException::none, LONG lOsError = -1,
		LPCTSTR lpszArchiveName = NULL);

// Attributes
	int     m_cause;
	LONG    m_lOsError;
	CString m_strFileName;

// Operations
	// convert a OS dependent error code to a Cause
	static int PASCAL OsErrorToException(LONG lOsError);
	static int PASCAL ErrnoToException(int nErrno);

	// helper functions to throw exception after converting to a Cause
	static void PASCAL ThrowOsError(LONG lOsError, LPCTSTR lpszFileName = NULL);
	static void PASCAL ThrowErrno(int nErrno, LPCTSTR lpszFileName = NULL);

// Implementation
public:
	virtual ~CFileException();
#ifdef _DEBUG
	virtual void Dump(CDumpContext&) const;
#endif
	virtual BOOL GetErrorMessage(_Out_z_cap_(nMaxError) LPTSTR lpszError, _In_ UINT nMaxError,
		_Out_opt_ PUINT pnHelpContext = NULL) const;
};

/////////////////////////////////////////////////////////////////////////////
// File - raw unbuffered disk file I/O

#ifndef __ATLTRANSACTIONMANAGER_H__
#include <atltransactionmanager.h>
#endif

using ATL::CAtlTransactionManager;

class CFile : public CObject
{
	DECLARE_DYNAMIC(CFile)

public:
// Flag values
	enum OpenFlags {
		modeRead =         (int) 0x00000,
		modeWrite =        (int) 0x00001,
		modeReadWrite =    (int) 0x00002,
		shareCompat =      (int) 0x00000,
		shareExclusive =   (int) 0x00010,
		shareDenyWrite =   (int) 0x00020,
		shareDenyRead =    (int) 0x00030,
		shareDenyNone =    (int) 0x00040,
		modeNoInherit =    (int) 0x00080,
		modeCreate =       (int) 0x01000,
		modeNoTruncate =   (int) 0x02000,
		typeText =         (int) 0x04000, // typeText and typeBinary are
		typeBinary =       (int) 0x08000, // used in derived classes only
		osNoBuffer =       (int) 0x10000,
		osWriteThrough =   (int) 0x20000,
		osRandomAccess =   (int) 0x40000,
		osSequentialScan = (int) 0x80000,
		};

	enum Attribute {
		normal =    0x00,
		readOnly =  0x01,
		hidden =    0x02,
		system =    0x04,
		volume =    0x08,
		directory = 0x10,
		archive =   0x20
		};

	enum SeekPosition { begin = 0x0, current = 0x1, end = 0x2 };

	static AFX_DATA const HANDLE hFileNull;

// Constructors
	CFile();

	/// <summary>
	/// CFile constructor</summary>
	/// <param name="pTM">Pointer to CAtlTransactionManager object</param>
	CFile(CAtlTransactionManager* pTM);

	CFile(HANDLE hFile);
	CFile(LPCTSTR lpszFileName, UINT nOpenFlags);

	/// <summary>
	/// CFile constructor</summary>
	/// <param name="lpszFileName">A string that is the path to the desired file. The path can be relative or absolute.</param>
	/// <param name="nOpenFlags">Sharing and access mode. Specifies the action to take when opening the file. You can combine options listed below by using the bitwise-OR (|) operator. One access permission and one share option are required; the modeCreate and modeNoInherit modes are optional.</param>
	/// <param name="pTM">Pointer to CAtlTransactionManager object</param>
	CFile(LPCTSTR lpszFileName, UINT nOpenFlags, CAtlTransactionManager* pTM);

// Attributes
	HANDLE m_hFile;
	operator HANDLE() const;

	virtual ULONGLONG GetPosition() const;
	BOOL GetStatus(CFileStatus& rStatus) const;
	virtual CString GetFileName() const;
	virtual CString GetFileTitle() const;
	virtual CString GetFilePath() const;
	virtual void SetFilePath(LPCTSTR lpszNewName);

// Operations
	virtual BOOL Open(LPCTSTR lpszFileName, UINT nOpenFlags, CFileException* pError = NULL);

	/// <summary>
	/// Open is designed for use with the default CFile constructor</summary>
	/// <returns> 
	/// TRUE if succeeds; otherwise FALSE.</returns>
	/// <param name="lpszFileName">A string that is the path to the desired file. The path can be relative or absolute.</param>
	/// <param name="nOpenFlags">Sharing and access mode. Specifies the action to take when opening the file. You can combine options listed below by using the bitwise-OR (|) operator. One access permission and one share option are required; the modeCreate and modeNoInherit modes are optional.</param>
	/// <param name="pTM">Pointer to CAtlTransactionManager object</param>
	/// <param name="pError">A pointer to an existing file-exception object that will receive the status of a failed operation</param>
	virtual BOOL Open(LPCTSTR lpszFileName, UINT nOpenFlags, CAtlTransactionManager* pTM, CFileException* pError);

	/// <summary>
	/// This static function renames the specified file.</summary>
	/// <param name="lpszOldName">The old path.</param>
	/// <param name="lpszNewName">The new path.</param>
	/// <param name="pTM">Pointer to CAtlTransactionManager object</param>
	static void PASCAL Rename(LPCTSTR lpszOldName, LPCTSTR lpszNewName, CAtlTransactionManager* pTM = NULL);

	/// <summary>
	/// This static function deletes the file specified by the path.</summary>
	/// <param name="lpszFileName">A string that is the path to the desired file. The path can be relative or absolute.</param>
	/// <param name="pTM">Pointer to CAtlTransactionManager object</param>
	static void PASCAL Remove(LPCTSTR lpszFileName, CAtlTransactionManager* pTM = NULL); 

	/// <summary>
	/// This method retrieves status information related to a given CFile object instance or a given file path.</summary>
	/// <returns> 
	/// TRUE if succeeds; otherwise FALSE.</returns>
	/// <param name="lpszFileName">A string that is the path to the desired file. The path can be relative or absolute.</param>
	/// <param name="rStatus">A reference to a user-supplied CFileStatus structure that will receive the status information.</param>
	/// <param name="pTM">Pointer to CAtlTransactionManager object</param>
	static BOOL PASCAL GetStatus(LPCTSTR lpszFileName, CFileStatus& rStatus, CAtlTransactionManager* pTM = NULL);

	/// <summary>
	/// Sets the status of the file associated with this file location.</summary>
	/// <param name="lpszFileName">A string that is the path to the desired file. The path can be relative or absolute.</param>
	/// <param name="rStatus">The buffer containing the new status information.</param>
	/// <param name="pTM">Pointer to CAtlTransactionManager object</param>
	static void PASCAL SetStatus(LPCTSTR lpszFileName, const CFileStatus& status, CAtlTransactionManager* pTM = NULL);

	ULONGLONG SeekToEnd();
	void SeekToBegin();

// Overridables
	virtual CFile* Duplicate() const;

	virtual ULONGLONG Seek(LONGLONG lOff, UINT nFrom);
	virtual void SetLength(ULONGLONG dwNewLen);
	virtual ULONGLONG GetLength() const;

	virtual UINT Read(void* lpBuf, UINT nCount);
	virtual void Write(const void* lpBuf, UINT nCount);

	virtual void LockRange(ULONGLONG dwPos, ULONGLONG dwCount);
	virtual void UnlockRange(ULONGLONG dwPos, ULONGLONG dwCount);

	virtual void Abort();
	virtual void Flush();
	virtual void Close();

// Implementation
public:
	virtual ~CFile();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	enum BufferCommand { bufferRead, bufferWrite, bufferCommit, bufferCheck };
	enum BufferFlags 
	{ 
		bufferDirect = 0x01,
		bufferBlocking = 0x02
	};
	virtual UINT GetBufferPtr(UINT nCommand, UINT nCount = 0,
		void** ppBufStart = NULL, void** ppBufMax = NULL);

protected:
	void CommonBaseInit(HANDLE hFile, CAtlTransactionManager* pTM);
	void CommonInit(LPCTSTR lpszFileName, UINT nOpenFlags, CAtlTransactionManager* pTM);

	BOOL m_bCloseOnDelete;
	CString m_strFileName;
	
	/// <summary>
	/// Pointer to CAtlTransactionManager object</summary>
	CAtlTransactionManager* m_pTM;
};

/////////////////////////////////////////////////////////////////////////////
// STDIO file implementation

class CStdioFile : public CFile
{
	DECLARE_DYNAMIC(CStdioFile)

public:
// Constructors
	CStdioFile();

	/// <summary>
	/// CStdioFile constructor</summary>
	/// <param name="pTM">Pointer to CAtlTransactionManager object</param>
	CStdioFile(CAtlTransactionManager* pTM);

	CStdioFile(FILE* pOpenStream);
	CStdioFile(LPCTSTR lpszFileName, UINT nOpenFlags);
	
	/// <summary>
	/// CStdioFile constructor</summary>
	/// <param name="lpszFileName">A string that is the path to the desired file. The path can be relative or absolute.</param>
	/// <param name="nOpenFlags">Sharing and access mode. Specifies the action to take when opening the file. You can combine options listed below by using the bitwise-OR (|) operator. One access permission and one share option are required; the modeCreate and modeNoInherit modes are optional.</param>
	/// <param name="pTM">Pointer to CAtlTransactionManager object</param>
	CStdioFile(LPCTSTR lpszFileName, UINT nOpenFlags, CAtlTransactionManager* pTM);

// Attributes
	FILE* m_pStream;    // stdio FILE
						// m_hFile from base class is _fileno(m_pStream)

// Operations
	// reading and writing strings
	virtual void WriteString(LPCTSTR lpsz);
	virtual LPTSTR ReadString(_Out_z_cap_(nMax) LPTSTR lpsz, _In_ UINT nMax);
	virtual BOOL ReadString(CString& rString);

// Implementation
public:
	virtual ~CStdioFile();
#ifdef _DEBUG
	void Dump(CDumpContext& dc) const;
#endif
	virtual ULONGLONG GetPosition() const;
	virtual ULONGLONG GetLength() const;
	virtual BOOL Open(LPCTSTR lpszFileName, UINT nOpenFlags, CFileException* pError = NULL);

	/// <summary>
	/// Open is designed for use with the default CStdioFile constructor</summary>
	/// <returns> 
	/// TRUE if succeeds; otherwise FALSE.</returns>
	/// <param name="lpszFileName">A string that is the path to the desired file. The path can be relative or absolute.</param>
	/// <param name="nOpenFlags">Sharing and access mode. Specifies the action to take when opening the file. You can combine options listed below by using the bitwise-OR (|) operator. One access permission and one share option are required; the modeCreate and modeNoInherit modes are optional.</param>
	/// <param name="pTM">Pointer to CAtlTransactionManager object</param>
	/// <param name="pError">A pointer to an existing file-exception object that will receive the status of a failed operation</param>
	virtual BOOL Open(LPCTSTR lpszFileName, UINT nOpenFlags, CAtlTransactionManager* pTM, CFileException* pError);

	virtual UINT Read(void* lpBuf, UINT nCount);
	virtual void Write(const void* lpBuf, UINT nCount);
	virtual ULONGLONG Seek(LONGLONG lOff, UINT nFrom);
	virtual void Abort();
	virtual void Flush();
	virtual void Close();

	// Unsupported APIs
	virtual CFile* Duplicate() const;
	virtual void LockRange(ULONGLONG dwPos, ULONGLONG dwCount);
	virtual void UnlockRange(ULONGLONG dwPos, ULONGLONG dwCount);

protected:
	void CommonBaseInit(FILE* pOpenStream, CAtlTransactionManager* pTM);
	void CommonInit(LPCTSTR lpszFileName, UINT nOpenFlags, CAtlTransactionManager* pTM);
};

////////////////////////////////////////////////////////////////////////////
// Memory based file implementation

class CMemFile : public CFile
{
	DECLARE_DYNAMIC(CMemFile)

public:
// Constructors
	/* explicit */ CMemFile(UINT nGrowBytes = 1024);
	CMemFile(BYTE* lpBuffer, UINT nBufferSize, UINT nGrowBytes = 0);

// Operations
	void Attach(BYTE* lpBuffer, UINT nBufferSize, UINT nGrowBytes = 0);
	BYTE* Detach();

// Advanced Overridables
protected:
	virtual BYTE* Alloc(SIZE_T nBytes);
	virtual BYTE* Realloc(BYTE* lpMem, SIZE_T nBytes);
	virtual BYTE* Memcpy(BYTE* lpMemTarget, const BYTE* lpMemSource, SIZE_T nBytes);
	virtual void Free(BYTE* lpMem);
	virtual void GrowFile(SIZE_T dwNewLen);

// Implementation
protected:
	SIZE_T m_nGrowBytes;
	SIZE_T m_nPosition;
	SIZE_T m_nBufferSize;
	SIZE_T m_nFileSize;
	BYTE* m_lpBuffer;
	BOOL m_bAutoDelete;

public:
	virtual ~CMemFile();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
	virtual void AssertValid() const;
#endif
	virtual ULONGLONG GetPosition() const;
	BOOL GetStatus(CFileStatus& rStatus) const;
	virtual ULONGLONG Seek(LONGLONG lOff, UINT nFrom);
	virtual void SetLength(ULONGLONG dwNewLen);
	virtual UINT Read(void* lpBuf, UINT nCount);
	virtual void Write(const void* lpBuf, UINT nCount);
	virtual void Abort();
	virtual void Flush();
	virtual void Close();
	virtual UINT GetBufferPtr(UINT nCommand, UINT nCount = 0,
		void** ppBufStart = NULL, void** ppBufMax = NULL);
	virtual ULONGLONG GetLength() const;

	// Unsupported APIs
	virtual CFile* Duplicate() const;
	virtual void LockRange(ULONGLONG dwPos, ULONGLONG dwCount);
	virtual void UnlockRange(ULONGLONG dwPos, ULONGLONG dwCount);
};

////////////////////////////////////////////////////////////////////////////
// Local file searches

#include <atltime.h>
using ATL::CTime;
using ATL::CTimeSpan;

class CFileFind : public CObject
{
public:
	CFileFind();

	/// <summary>
	/// CFileFind constructor</summary>
	/// <param name="pTM">Pointer to CAtlTransactionManager object</param>
	CFileFind(CAtlTransactionManager* pTM);
	virtual ~CFileFind();

// Attributes
public:
	ULONGLONG GetLength() const;
	virtual CString GetFileName() const;
	virtual CString GetFilePath() const;
	virtual CString GetFileTitle() const;
	virtual CString GetFileURL() const;
	virtual CString GetRoot() const;

	virtual BOOL GetLastWriteTime(FILETIME* pTimeStamp) const;
	virtual BOOL GetLastAccessTime(FILETIME* pTimeStamp) const;
	virtual BOOL GetCreationTime(FILETIME* pTimeStamp) const;
	virtual BOOL GetLastWriteTime(CTime& refTime) const;
	virtual BOOL GetLastAccessTime(CTime& refTime) const;
	virtual BOOL GetCreationTime(CTime& refTime) const;

	virtual BOOL MatchesMask(DWORD dwMask) const;

	virtual BOOL IsDots() const;
	// these aren't virtual because they all use MatchesMask(), which is
	BOOL IsReadOnly() const;
	BOOL IsDirectory() const;
	BOOL IsCompressed() const;
	BOOL IsSystem() const;
	BOOL IsHidden() const;
	BOOL IsTemporary() const;
	BOOL IsNormal() const;
	BOOL IsArchived() const;

// Operations
	void Close();
	virtual BOOL FindFile(LPCTSTR pstrName = NULL, DWORD dwUnused = 0);
	virtual BOOL FindNextFile();

protected:
	virtual void CloseContext();

// Implementation
protected:
	void* m_pFoundInfo;
	void* m_pNextInfo;
	HANDLE m_hContext;
	CString m_strRoot;
	TCHAR m_chDirSeparator;     // not '\\' for Internet classes

	/// <summary>
	/// Pointer to CAtlTransactionManager object</summary>
	CAtlTransactionManager* m_pTM;

#ifdef _DEBUG
	void Dump(CDumpContext& dc) const;
	void AssertValid() const;
#endif

	DECLARE_DYNAMIC(CFileFind)
};

// CTimeSpan diagnostics and serialization
#ifdef _DEBUG
CDumpContext& AFXAPI operator<<(CDumpContext& dc,CTimeSpan dateSpanSrc);
#endif
CArchive& AFXAPI operator<<(CArchive& ar, CTimeSpan dateSpanSrc);
CArchive& AFXAPI operator>>(CArchive& ar, CTimeSpan& dateSpanSrc);

// CTime diagnostics and serialization
#ifdef _DEBUG
CDumpContext& AFXAPI operator<<(CDumpContext& dc, CTime dateSrc);
#endif
CArchive& AFXAPI operator<<(CArchive& ar, CTime dateSrc);
CArchive& AFXAPI operator>>(CArchive& ar, CTime& dateSrc);

/////////////////////////////////////////////////////////////////////////////
// File status

struct CFileStatus
{
	CTime m_ctime;          // creation date/time of file
	CTime m_mtime;          // last modification date/time of file
	CTime m_atime;          // last access date/time of file
	ULONGLONG m_size;            // logical size of file in bytes
	BYTE m_attribute;       // logical OR of CFile::Attribute enum values
	BYTE _m_padding;        // pad the structure to a WORD
	TCHAR m_szFullName[_MAX_PATH]; // absolute path name

#ifdef _DEBUG
	void Dump(CDumpContext& dc) const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// Diagnostic memory management routines

// Low level sanity checks for memory blocks
BOOL AFXAPI AfxIsValidAddress(const void* lp,
			UINT_PTR nBytes, BOOL bReadWrite = TRUE);
BOOL AFXAPI AfxIsValidString(LPCWSTR lpsz, int nLength = -1);
BOOL AFXAPI AfxIsValidString(LPCSTR lpsz, int nLength = -1);

// Sanity checks for ATOMs
BOOL AfxIsValidAtom(ATOM nAtom);
BOOL AfxIsValidAtom(LPCTSTR psz);

#if defined(_DEBUG) && !defined(_AFX_NO_DEBUG_CRT)

// Memory tracking allocation
void* AFX_CDECL operator new(size_t nSize, LPCSTR lpszFileName, int nLine);
#define DEBUG_NEW new(THIS_FILE, __LINE__)
void AFX_CDECL operator delete(void* p, LPCSTR lpszFileName, int nLine);

void * __cdecl operator new[](size_t);
void* __cdecl operator new[](size_t nSize, LPCSTR lpszFileName, int nLine);
void __cdecl operator delete[](void* p, LPCSTR lpszFileName, int nLine);
void __cdecl operator delete[](void *);

void* AFXAPI AfxAllocMemoryDebug(size_t nSize, BOOL bIsObject,
	LPCSTR lpszFileName, int nLine);
void AFXAPI AfxFreeMemoryDebug(void* pbData, BOOL bIsObject);

// Dump any memory leaks since program started
BOOL AFXAPI AfxDumpMemoryLeaks();

// Return TRUE if valid memory block of nBytes
BOOL AFXAPI AfxIsMemoryBlock(const void* p, UINT nBytes,
	LONG* plRequestNumber = NULL);

// Return TRUE if memory is sane or print out what is wrong
BOOL AFXAPI AfxCheckMemory();

#define afxMemDF _crtDbgFlag

enum AfxMemDF // memory debug/diagnostic flags
{
	allocMemDF          = _CRTDBG_ALLOC_MEM_DF,         // turn on debugging allocator
	delayFreeMemDF      = _CRTDBG_DELAY_FREE_MEM_DF,         // delay freeing memory
	checkAlwaysMemDF    = _CRTDBG_CHECK_ALWAYS_DF,          // AfxCheckMemory on every alloc/free
	checkEvery16MemDF	= _CRTDBG_CHECK_EVERY_16_DF,
	checkEvery128MemDF	= _CRTDBG_CHECK_EVERY_128_DF,
	checkEvery1024MemDF	= _CRTDBG_CHECK_EVERY_1024_DF,
	checkDefaultMemDF	= _CRTDBG_CHECK_DEFAULT_DF
};

#define AfxOutputDebugString TRACE

// turn on/off tracking for a short while
BOOL AFXAPI AfxEnableMemoryTracking(BOOL bTrack);

// turn on/off memory leak dump in _AFX_DEBUG_STATE destructor
BOOL AFXAPI AfxEnableMemoryLeakDump(BOOL bDump);

// Turn on/off the global flag _afxMemoryLeakOverride. if bEnable is TRUE
// then further calls to AfxEnableMemoryTracking() wont change the current
// memory tracking state, until AfxEnableMemoryLeakOverride(BOOL bEnable)
// is called again with bEnable == FALSE.
BOOL AFXAPI AfxEnableMemoryLeakOverride(BOOL bEnable);

// Advanced initialization: for overriding default diagnostics
BOOL AFXAPI AfxDiagnosticInit(void);

// A failure hook returns whether to permit allocation
typedef BOOL (AFXAPI* AFX_ALLOC_HOOK)(size_t nSize, BOOL bObject, LONG lRequestNumber);

// Set new hook, return old (never NULL)
AFX_ALLOC_HOOK AFXAPI AfxSetAllocHook(AFX_ALLOC_HOOK pfnAllocHook);

// Debugger hook on specified allocation request - Obsolete
void AFXAPI AfxSetAllocStop(LONG lRequestNumber);

// Memory state for snapshots/leak detection
struct CMemoryState
{
// Attributes
	enum blockUsage
	{
		freeBlock,    // memory not used
		objectBlock,  // contains a CObject derived class object
		bitBlock,     // contains ::operator new data
		crtBlock,
		ignoredBlock,
		nBlockUseMax  // total number of usages
	};

	_CrtMemState m_memState;
	LONG_PTR m_lCounts[nBlockUseMax];
	LONG_PTR m_lSizes[nBlockUseMax];
	LONG_PTR m_lHighWaterCount;
	LONG_PTR m_lTotalCount;

	CMemoryState();

// Operations
	void Checkpoint();  // fill with current state
	BOOL Difference(const CMemoryState& oldState,
					const CMemoryState& newState);  // fill with difference
	void UpdateData();

	// Output to afxDump
	void DumpStatistics() const;
	void DumpAllObjectsSince() const;
};

// Enumerate allocated objects or runtime classes
void AFXAPI AfxDoForAllObjects(void (AFX_CDECL *pfn)(CObject* pObject, void* pContext),
	void* pContext);
void AFXAPI AfxDoForAllClasses(void (AFX_CDECL *pfn)(const CRuntimeClass* pClass,
	void* pContext), void* pContext);

#else

// non-_DEBUG_ALLOC version that assume everything is OK
#define DEBUG_NEW new
#define AfxCheckMemory() TRUE
#define AfxIsMemoryBlock(p, nBytes) TRUE
#define AfxEnableMemoryTracking(bTrack) FALSE
#define AfxEnableMemoryLeakOverride(bEnable) TRUE
#define AfxOutputDebugString(lpsz) ::OutputDebugString(lpsz)

// diagnostic initialization
#ifndef _DEBUG
#define AfxDiagnosticInit() TRUE
#else
BOOL AFXAPI AfxDiagnosticInit(void);
#endif

#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// Archives for serializing CObject data

// needed for implementation
template<class TYPE, class ARG_TYPE>
class CArray;
class CPtrArray;
class CMapPtrToPtr;
class CDocument;

class CArchive
{
protected:
	enum SchemaMapReservedRefs { objTypeArrayRef = 1 };
	enum LoadArrayObjType{ typeUndefined = 0, typeCRuntimeClass = 1, typeCObject = 2 };	
public:
// Flag values
	enum Mode { store = 0, load = 1, bNoFlushOnDelete = 2, bNoByteSwap = 4 };

	CArchive(CFile* pFile, UINT nMode, int nBufSize = 4096, void* lpBuf = NULL);
	~CArchive();

// Attributes
	BOOL IsLoading() const;
	BOOL IsStoring() const;
	BOOL IsByteSwapping() const;
	BOOL IsBufferEmpty() const;

	CFile* GetFile() const;
	UINT GetObjectSchema(); // only valid when reading a CObject*
	void SetObjectSchema(UINT nSchema);

	// pointer to document being serialized -- must set to serialize
	//  COleClientItems in a document!
	CDocument* m_pDocument;

// Operations
	UINT Read(void* lpBuf, UINT nMax);
	void EnsureRead(void *lpBuf, UINT nCount);
	void Write(const void* lpBuf, UINT nMax);
	void Flush();
	void Close();
	void Abort();   // close and shutdown without exceptions

	// reading and writing strings
	void WriteString(LPCTSTR lpsz);
	LPTSTR ReadString(_Out_z_cap_(nMax+1) LPTSTR lpsz, _In_ UINT nMax);
	BOOL ReadString(CString& rString);

public:
	// Object I/O is pointer based to avoid added construction overhead.
	// Use the Serialize member function directly for embedded objects.
	friend CArchive& AFXAPI operator<<(CArchive& ar, const CObject* pOb);

	friend CArchive& AFXAPI operator>>(CArchive& ar, CObject*& pOb);
	friend CArchive& AFXAPI operator>>(CArchive& ar, const CObject*& pOb);

	// insertion operations
	CArchive& operator<<(BYTE by);
	CArchive& operator<<(WORD w);
	CArchive& operator<<(LONG l);
	CArchive& operator<<(DWORD dw);
	CArchive& operator<<(float f);
	CArchive& operator<<(double d);
	CArchive& operator<<(LONGLONG dwdw);
	CArchive& operator<<(ULONGLONG dwdw);

	CArchive& operator<<(int i);
	CArchive& operator<<(short w);
	CArchive& operator<<(char ch);
#ifdef _NATIVE_WCHAR_T_DEFINED
	CArchive& operator<<(wchar_t ch);
#endif
	CArchive& operator<<(unsigned u);

	template < typename BaseType , bool t_bMFCDLL>
	CArchive& operator<<(const ATL::CSimpleStringT<BaseType, t_bMFCDLL>& str);

	template< typename BaseType, class StringTraits >	
	CArchive& operator<<(const ATL::CStringT<BaseType, StringTraits>& str);
	
	template < typename BaseType , bool t_bMFCDLL>
	CArchive& operator>>(ATL::CSimpleStringT<BaseType, t_bMFCDLL>& str);

	template< typename BaseType, class StringTraits >
	CArchive& operator>>(ATL::CStringT<BaseType, StringTraits>& str);

	CArchive& operator<<(bool b);

	// extraction operations
	CArchive& operator>>(BYTE& by);
	CArchive& operator>>(WORD& w);
	CArchive& operator>>(DWORD& dw);
	CArchive& operator>>(LONG& l);
	CArchive& operator>>(float& f);
	CArchive& operator>>(double& d);
	CArchive& operator>>(LONGLONG& dwdw);
	CArchive& operator>>(ULONGLONG& dwdw);

	CArchive& operator>>(int& i);
	CArchive& operator>>(short& w);
	CArchive& operator>>(char& ch);
#ifdef _NATIVE_WCHAR_T_DEFINED
	CArchive& operator>>(wchar_t& ch);
#endif
	CArchive& operator>>(unsigned& u);
	CArchive& operator>>(bool& b);

	// object read/write
	CObject* ReadObject(const CRuntimeClass* pClass);
	void WriteObject(const CObject* pOb);
	// advanced object mapping (used for forced references)
	void MapObject(const CObject* pOb);

	// advanced versioning support
	void WriteClass(const CRuntimeClass* pClassRef);
	CRuntimeClass* ReadClass(const CRuntimeClass* pClassRefRequested = NULL,
		UINT* pSchema = NULL, DWORD* pObTag = NULL);
	void SerializeClass(const CRuntimeClass* pClassRef);

	// advanced operations (used when storing/loading many objects)
	void SetStoreParams(UINT nHashSize = 2053, UINT nBlockSize = 128);
	void SetLoadParams(UINT nGrowBy = 1024);

	void EnsureSchemaMapExists(CArray<LoadArrayObjType, const LoadArrayObjType&>** ppObjTypeArray = NULL);
// Implementation
public:
	BOOL m_bForceFlat;  // for COleClientItem implementation (default TRUE)
	BOOL m_bDirectBuffer;   // TRUE if m_pFile supports direct buffering
	BOOL m_bBlocking;  // TRUE if m_pFile can block for unbounded periods of time
	void FillBuffer(UINT nAdditionalBytesNeeded);
	void CheckCount();  // throw exception if m_nMapCount is too large

	// special functions for reading and writing (16-bit compatible) counts
	DWORD_PTR ReadCount();
	void WriteCount(DWORD_PTR dwCount);

	// public for advanced use
	UINT m_nObjectSchema;
	CString m_strFileName;

protected:
	// archive objects cannot be copied or assigned
	CArchive(const CArchive& arSrc);
	void operator=(const CArchive& arSrc);

	BOOL m_nMode;
	BOOL m_bUserBuf;
	int m_nBufSize;
	CFile* m_pFile;
	BYTE* m_lpBufCur;
	BYTE* m_lpBufMax;
	BYTE* m_lpBufStart;

	// array/map for CObject* and CRuntimeClass* load/store
	UINT m_nMapCount;
	union
	{
		CPtrArray* m_pLoadArray;
		CMapPtrToPtr* m_pStoreMap;
	};
	// map to keep track of mismatched schemas
	CMapPtrToPtr* m_pSchemaMap;

	// advanced parameters (controls performance with large archives)
	UINT m_nGrowSize;
	UINT m_nHashSize;
};

/////////////////////////////////////////////////////////////////////////////
// Diagnostic dumping

// Note: AfxDumpStack is available in release builds, although it is always
//      statically linked so as to not negatively affect the size of MFCXX.DLL.

#define AFX_STACK_DUMP_TARGET_TRACE                     0x0001
#define AFX_STACK_DUMP_TARGET_CLIPBOARD 0x0002
#define AFX_STACK_DUMP_TARGET_BOTH                      0x0003
#define AFX_STACK_DUMP_TARGET_ODS                       0x0004
#ifdef _DEBUG
#define AFX_STACK_DUMP_TARGET_DEFAULT           AFX_STACK_DUMP_TARGET_TRACE
#else
#define AFX_STACK_DUMP_TARGET_DEFAULT           AFX_STACK_DUMP_TARGET_CLIPBOARD
#endif

void AFXAPI AfxDumpStack(DWORD dwFlags = AFX_STACK_DUMP_TARGET_DEFAULT);

class CDumpContext
{
public:
	CDumpContext(CFile* pFile = NULL);

// Attributes
	int GetDepth() const;      // 0 => this object, 1 => children objects
	void SetDepth(int nNewDepth);

// Operations
	CDumpContext& operator<<(LPCTSTR lpsz);
#ifdef _UNICODE
	CDumpContext& operator<<(LPCSTR lpsz);  // automatically widened
#else
	CDumpContext& operator<<(LPCWSTR lpsz); // automatically thinned
#endif
	template< typename BaseType, class StringTraits >
	CDumpContext& operator<<(const ATL::CStringT<BaseType, 
		StringTraits>& str)
	{
		*this << static_cast< const BaseType* >( str );
		return *this;
	}
	CDumpContext& operator<<(const void* lp);
	CDumpContext& operator<<(const CObject* pOb);
	CDumpContext& operator<<(const CObject& ob);
	CDumpContext& operator<<(BYTE by);
	CDumpContext& operator<<(WORD w);
	CDumpContext& DumpAsHex(BYTE b);
	CDumpContext& DumpAsHex(WORD w);
#ifdef _WIN64
	CDumpContext& operator<<(LONG l);
	CDumpContext& operator<<(DWORD dw);
	CDumpContext& operator<<(int n);
	CDumpContext& operator<<(UINT u);
	CDumpContext& DumpAsHex(LONG l);
	CDumpContext& DumpAsHex(DWORD dw);
	CDumpContext& DumpAsHex(int n);
	CDumpContext& DumpAsHex(UINT u);
#else
	CDumpContext& operator<<(LONG_PTR l);
	CDumpContext& operator<<(DWORD_PTR dw);
	CDumpContext& operator<<(INT_PTR n);
	CDumpContext& operator<<(UINT_PTR u);
	CDumpContext& DumpAsHex(LONG_PTR l);
	CDumpContext& DumpAsHex(DWORD_PTR dw);
	CDumpContext& DumpAsHex(INT_PTR n);
	CDumpContext& DumpAsHex(UINT_PTR u);
#endif
	CDumpContext& operator<<(float f);
	CDumpContext& operator<<(double d);
	CDumpContext& operator<<(LONGLONG n);
	CDumpContext& operator<<(ULONGLONG n);
	CDumpContext& DumpAsHex(LONGLONG n);
	CDumpContext& DumpAsHex(ULONGLONG n);
	CDumpContext& operator<<(HWND h);
	CDumpContext& operator<<(HDC h);
	CDumpContext& operator<<(HMENU h);
	CDumpContext& operator<<(HACCEL h);
	CDumpContext& operator<<(HFONT h);
	void HexDump(LPCTSTR lpszLine, BYTE* pby, int nBytes, int nWidth);
	void Flush();

// Implementation
protected:
	// dump context objects cannot be copied or assigned
	CDumpContext(const CDumpContext& dcSrc);
	void operator=(const CDumpContext& dcSrc);
	void OutputString(LPCTSTR lpsz);

	int m_nDepth;

public:
	CFile* m_pFile;
};

/////////////////////////////////////////////////////////////////////////////
int __cdecl _AfxInitManaged();

#ifdef _DEBUG
extern AFX_DATA CDumpContext afxDump;
extern AFX_DATA BOOL afxTraceEnabled;
#endif

#ifdef _DEBUG
#define AFXDUMP( exp ) (void)(afxDump<<exp)
#else
#define AFXDUMP( exp )
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifndef __AFXCOLL_H__
	#include <afxcoll.h>
	#ifndef __AFXSTATE_H__
		#include <afxstat_.h> // for _AFX_APP_STATE and _AFX_THREAD_STATE
	#endif
#endif

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_ENABLE_INLINES
#define _AFX_INLINE AFX_INLINE

#if !defined(_AFX_CORE_IMPL) || !defined(_AFXDLL) || defined(_DEBUG)
#define _AFX_PUBLIC_INLINE AFX_INLINE
#else
#define _AFX_PUBLIC_INLINE
#endif

#endif

#include <afx.inl>


#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_ALL_WARNINGS
#pragma warning( pop )
#endif

#endif // __AFX_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afx.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFX.H

#ifndef AFX_H_TEMPLATE_INCLUDE_GUARD
#define AFX_H_TEMPLATE_INCLUDE_GUARD
//Used CStringT to serialize CSimpleStringT because it supports conversions (char <--> wchar_t).
template < typename BaseType , bool t_bMFCDLL>
CArchive& CArchive::operator<<(const ATL::CSimpleStringT<BaseType, t_bMFCDLL>& str)
{
	ATL::CStringT< BaseType, StrTraitMFC_DLL< BaseType > > cstrT(str);
	*this << cstrT;
	return *this;
}	

template< typename BaseType, class StringTraits >
CArchive& CArchive::operator<<(const ATL::CStringT<BaseType, StringTraits>& str)
{
	AfxWriteStringLength(*this, str.GetLength(), sizeof(BaseType) == sizeof(wchar_t));
	Write(str, str.GetLength()*sizeof(BaseType));
	return *this;
}   

template < typename BaseType , bool t_bMFCDLL>
CArchive& CArchive::operator>>(ATL::CSimpleStringT<BaseType, t_bMFCDLL>& str)
{
	ATL::CStringT< BaseType, StrTraitMFC_DLL< BaseType > > cstrT;
	*this >> cstrT;
	str = cstrT;
	return *this;
}

template< typename BaseType, class StringTraits >
CArchive& CArchive::operator>>(ATL::CStringT<BaseType, StringTraits>& str)
{
	int nCharSize;  // 1 = char, 2 = wchar_t
	UINT nLength = UINT( AfxReadStringLength(*this, nCharSize) );
	if (nCharSize == sizeof(char))
	{
		ATL::CTempBuffer< char > pszBufferA(nLength);

		UINT nBytesRead = Read(pszBufferA, nLength*sizeof(char));
		if (nBytesRead != (nLength*sizeof(char)))
			AfxThrowArchiveException(CArchiveException::endOfFile);
		str = ATL::CStringT<BaseType, StringTraits>(pszBufferA, nLength);
	}
	else
	{
		ASSERT(nCharSize == sizeof(wchar_t));

		ATL::CTempBuffer< wchar_t > pszBufferW(nLength);

		UINT nBytesRead = Read(pszBufferW, nLength*sizeof(wchar_t));
		if (nBytesRead != (nLength*sizeof(wchar_t)))
			AfxThrowArchiveException(CArchiveException::endOfFile);
		str = ATL::CStringT<BaseType, StringTraits>(pszBufferW, nLength);
	}

	return *this;
}

#endif //AFX_H_TEMPLATE_INCLUDE_GUARD

#ifndef AFX_INL_MANAGED_INIT_INCLUDE_GUARD
#define AFX_INL_MANAGED_INIT_INCLUDE_GUARD
#if !defined(_AFX_MFCS) && !defined(_AFX_ISAPI)
__declspec( noinline ) inline int __cdecl  _AfxInitManaged()
{
	return 0;
}
#endif // !_AFX_MFCS && !_AFX_ISAPI
extern "C"
{
__declspec(selectany) void* _pIncludeInitManaged = (void*)_AfxInitManaged;
}
#endif  // AFX_INL_MANAGED_INIT_INCLUDE_GUARD

#ifdef _AFX_INLINE
#ifndef AFX_INL_INCLUDE_GUARD
#define AFX_INL_INCLUDE_GUARD

// CObject
_AFX_INLINE CObject::CObject()
	{ }
_AFX_INLINE CObject::~CObject()
	{ }
_AFX_INLINE void CObject::Serialize(CArchive&)
	{ /* CObject does not serialize anything by default */ }
_AFX_INLINE void* PASCAL CObject::operator new(size_t, void* p)
	{ return p; }
#ifndef _DEBUG
// _DEBUG versions in afxmem.cpp
_AFX_INLINE void PASCAL CObject::operator delete(void* p)
	{ ::operator delete(p); }
_AFX_INLINE void PASCAL CObject::operator delete(void* p, void*)
	{ ::operator delete(p); }
_AFX_INLINE void* PASCAL CObject::operator new(size_t nSize)
	{ return ::operator new(nSize); }
// _DEBUG versions in objcore.cpp
#ifdef _AFXDLL
_AFX_INLINE void CObject::AssertValid() const
	{ /* no asserts in release builds */ }
_AFX_INLINE void CObject::Dump(CDumpContext&) const
	{ /* no dumping in release builds */ }
#endif //_AFXDLL
#endif //!_DEBUG
_AFX_INLINE const CObject* AFX_CDECL AfxDynamicDownCast(CRuntimeClass* pClass, const CObject* pObject)
	{ return (const CObject*)AfxDynamicDownCast(pClass, (CObject*)pObject); }
#ifdef _DEBUG
_AFX_INLINE const CObject* AFX_CDECL AfxStaticDownCast(CRuntimeClass* pClass, const CObject* pObject)
	{ return (const CObject*)AfxStaticDownCast(pClass, (CObject*)pObject); }
#endif

// exceptions
_AFX_INLINE CException::~CException()
	{ }
_AFX_INLINE CSimpleException::CSimpleException()
	{ m_bInitialized = FALSE; m_bLoaded = FALSE; }
_AFX_INLINE CSimpleException::CSimpleException(BOOL bAutoDelete)
	: CException(bAutoDelete) { m_bInitialized = FALSE; m_bLoaded = FALSE; }
_AFX_INLINE CSimpleException::~CSimpleException()
	{ }

_AFX_INLINE CMemoryException::CMemoryException()
	: CSimpleException() { }
_AFX_INLINE CMemoryException::CMemoryException(BOOL bAutoDelete, UINT nResourceID)
	: CSimpleException(bAutoDelete) { m_nResourceID = nResourceID; }
_AFX_INLINE CMemoryException::~CMemoryException()
	{ }
_AFX_INLINE CNotSupportedException::CNotSupportedException()
	: CSimpleException() { }
_AFX_INLINE CNotSupportedException::CNotSupportedException(BOOL bAutoDelete, UINT nResourceID)
	: CSimpleException(bAutoDelete) { m_nResourceID = nResourceID; }
_AFX_INLINE CNotSupportedException::~CNotSupportedException()
	{ }
_AFX_INLINE CInvalidArgException::CInvalidArgException()
	: CSimpleException() { }
_AFX_INLINE CInvalidArgException::CInvalidArgException(BOOL bAutoDelete, UINT nResourceID)
	: CSimpleException(bAutoDelete) { m_nResourceID = nResourceID; }
_AFX_INLINE CInvalidArgException::~CInvalidArgException()
	{ }
_AFX_INLINE CArchiveException::CArchiveException(int cause,
	LPCTSTR lpszFileName /* = NULL */)
	{ m_cause = cause; m_strFileName = lpszFileName; }
	
_AFX_INLINE CArchiveException::~CArchiveException()
	{ }
_AFX_INLINE CFileException::CFileException(int cause, LONG lOsError,
	LPCTSTR pstrFileName /* = NULL */)
	{ m_cause = cause; m_lOsError = lOsError; m_strFileName = pstrFileName; }
_AFX_INLINE CFileException::~CFileException()
	{ }

// CFile
_AFX_INLINE CFile::operator HANDLE() const
	{ return m_hFile; }
_AFX_INLINE ULONGLONG CFile::SeekToEnd()
	{ return Seek(0, CFile::end); }
_AFX_INLINE void CFile::SeekToBegin()
	{ Seek(0, CFile::begin); }
_AFX_INLINE void CFile::SetFilePath(LPCTSTR lpszNewName)
{
	ASSERT_VALID(this);
	ASSERT(AfxIsValidString(lpszNewName));
	if(lpszNewName != NULL)
		m_strFileName = lpszNewName;
	else
		AfxThrowInvalidArgException();  

}

// CFileFind
_AFX_INLINE BOOL CFileFind::IsReadOnly() const
	{ return MatchesMask(FILE_ATTRIBUTE_READONLY); }
_AFX_INLINE BOOL CFileFind::IsDirectory() const
	{ return MatchesMask(FILE_ATTRIBUTE_DIRECTORY); }
_AFX_INLINE BOOL CFileFind::IsCompressed() const
	{ return MatchesMask(FILE_ATTRIBUTE_COMPRESSED); }
_AFX_INLINE BOOL CFileFind::IsSystem() const
	{ return MatchesMask(FILE_ATTRIBUTE_SYSTEM); }
_AFX_INLINE BOOL CFileFind::IsHidden() const
	{ return MatchesMask(FILE_ATTRIBUTE_HIDDEN); }
_AFX_INLINE BOOL CFileFind::IsTemporary() const
	{ return MatchesMask(FILE_ATTRIBUTE_TEMPORARY); }
_AFX_INLINE BOOL CFileFind::IsNormal() const
	{ return MatchesMask(FILE_ATTRIBUTE_NORMAL); }
_AFX_INLINE BOOL CFileFind::IsArchived() const
	{ return MatchesMask(FILE_ATTRIBUTE_ARCHIVE); }

// CArchive
_AFX_INLINE BOOL CArchive::IsLoading() const
	{ return (m_nMode & CArchive::load) != 0; }
_AFX_INLINE BOOL CArchive::IsStoring() const
	{ return (m_nMode & CArchive::load) == 0; }
_AFX_INLINE BOOL CArchive::IsByteSwapping() const
	{ return FALSE; }
_AFX_INLINE BOOL CArchive::IsBufferEmpty() const
	{ return m_lpBufCur == m_lpBufMax; }
_AFX_INLINE CFile* CArchive::GetFile() const
	{ return m_pFile; }
_AFX_INLINE void CArchive::SetObjectSchema(UINT nSchema)
	{ m_nObjectSchema = nSchema; }
_AFX_INLINE void CArchive::SetStoreParams(UINT nHashSize, UINT nBlockSize)
{
	ASSERT(IsStoring());
	ASSERT(m_pStoreMap == NULL);    // must be before first object written
	m_nHashSize = nHashSize;
	m_nGrowSize = nBlockSize;
}
_AFX_INLINE void CArchive::SetLoadParams(UINT nGrowBy)
{
	ASSERT(IsLoading());
	ASSERT(m_pLoadArray == NULL);   // must be before first object read
	m_nGrowSize = nGrowBy;
}
_AFX_INLINE CArchive& CArchive::operator<<(int i)
	{ return CArchive::operator<<((LONG)i); }
_AFX_INLINE CArchive& CArchive::operator<<(unsigned u)
	{ return CArchive::operator<<((LONG)u); }
_AFX_INLINE CArchive& CArchive::operator<<(short w)
	{ return CArchive::operator<<((WORD)w); }
_AFX_INLINE CArchive& CArchive::operator<<(char ch)
	{ return CArchive::operator<<((BYTE)ch); }
#ifdef _NATIVE_WCHAR_T_DEFINED
_AFX_INLINE CArchive& CArchive::operator<<(wchar_t ch)
	{ return CArchive::operator<<((WORD)ch); }
#endif
_AFX_INLINE CArchive& CArchive::operator<<(bool b)
	{ return CArchive::operator <<((BYTE)(b ? 1 : 0)); }
_AFX_INLINE CArchive& CArchive::operator<<(BYTE by)
{ 
	if(!IsStoring())
		AfxThrowArchiveException(CArchiveException::readOnly,m_strFileName);
	if (m_lpBufCur + sizeof(BYTE) > m_lpBufMax) Flush();
		*(UNALIGNED BYTE*)m_lpBufCur = by; m_lpBufCur += sizeof(BYTE); return *this; 
}

_AFX_INLINE CArchive& CArchive::operator<<(LONGLONG dwdw)
{ 
	if(!IsStoring())
		AfxThrowArchiveException(CArchiveException::readOnly,m_strFileName);
	if (m_lpBufCur + sizeof(LONGLONG) > m_lpBufMax) Flush();
		*(UNALIGNED LONGLONG*)m_lpBufCur = dwdw; m_lpBufCur += sizeof(LONGLONG); return *this; 
}
_AFX_INLINE CArchive& CArchive::operator<<(ULONGLONG dwdw)
{ 
	if(!IsStoring())
		AfxThrowArchiveException(CArchiveException::readOnly,m_strFileName);
	if (m_lpBufCur + sizeof(ULONGLONG) > m_lpBufMax) Flush();
		*(UNALIGNED ULONGLONG*)m_lpBufCur = dwdw; m_lpBufCur += sizeof(ULONGLONG); return *this; 
}
_AFX_INLINE CArchive& CArchive::operator<<(WORD w)
{ 
	if(!IsStoring())
		AfxThrowArchiveException(CArchiveException::readOnly,m_strFileName);
	if (m_lpBufCur + sizeof(WORD) > m_lpBufMax) Flush();
			*(UNALIGNED WORD*)m_lpBufCur = w; m_lpBufCur += sizeof(WORD); return *this; 
}
_AFX_INLINE CArchive& CArchive::operator<<(LONG l)
{ 
	if(!IsStoring())
		AfxThrowArchiveException(CArchiveException::readOnly,m_strFileName);
	if (m_lpBufCur + sizeof(LONG) > m_lpBufMax) Flush();
		*(UNALIGNED LONG*)m_lpBufCur = l; m_lpBufCur += sizeof(LONG); return *this; 
}
_AFX_INLINE CArchive& CArchive::operator<<(DWORD dw)
{ 
	if(!IsStoring())
		AfxThrowArchiveException(CArchiveException::readOnly,m_strFileName);
	if (m_lpBufCur + sizeof(DWORD) > m_lpBufMax) Flush();
		*(UNALIGNED DWORD*)m_lpBufCur = dw; m_lpBufCur += sizeof(DWORD); return *this; 
}
_AFX_INLINE CArchive& CArchive::operator<<(float f)
{ 
	if(!IsStoring())
		AfxThrowArchiveException(CArchiveException::readOnly,m_strFileName);
	if (m_lpBufCur + sizeof(float) > m_lpBufMax) Flush();
		*(UNALIGNED float*)m_lpBufCur = f; m_lpBufCur += sizeof(float); return *this;
}
_AFX_INLINE CArchive& CArchive::operator<<(double d)
{
	if(!IsStoring())
		AfxThrowArchiveException(CArchiveException::readOnly,m_strFileName);
	if (m_lpBufCur + sizeof(double) > m_lpBufMax) Flush();
		*(UNALIGNED double*)m_lpBufCur = d; m_lpBufCur += sizeof(double); return *this; 
}

_AFX_INLINE CArchive& CArchive::operator>>(int& i)
	{ return CArchive::operator>>((LONG&)i); }
_AFX_INLINE CArchive& CArchive::operator>>(unsigned& u)
	{ return CArchive::operator>>((LONG&)u); }
_AFX_INLINE CArchive& CArchive::operator>>(short& w)
	{ return CArchive::operator>>((WORD&)w); }
_AFX_INLINE CArchive& CArchive::operator>>(char& ch)
	{ return CArchive::operator>>((BYTE&)ch); }
#ifdef _NATIVE_WCHAR_T_DEFINED
_AFX_INLINE CArchive& CArchive::operator>>(wchar_t& ch)
	{ return CArchive::operator>>((WORD&)ch); }
#endif
_AFX_INLINE CArchive& CArchive::operator>>(bool& b)
	{ BYTE by; CArchive& ar = CArchive::operator>>(by); b = (by ? true : false); return ar; }
_AFX_INLINE CArchive& CArchive::operator>>(BYTE& by)
{ 
	if(!IsLoading())
		AfxThrowArchiveException(CArchiveException::writeOnly,m_strFileName);
	if (m_lpBufCur + sizeof(BYTE) > m_lpBufMax)
		FillBuffer(UINT(sizeof(BYTE) - (m_lpBufMax - m_lpBufCur)));
	by = *(UNALIGNED BYTE*)m_lpBufCur; m_lpBufCur += sizeof(BYTE); return *this; 
}

_AFX_INLINE CArchive& CArchive::operator>>(LONGLONG& dwdw)
{ 
	if(!IsLoading())
		AfxThrowArchiveException(CArchiveException::writeOnly,m_strFileName);
	if (m_lpBufCur + sizeof(LONGLONG) > m_lpBufMax)
		FillBuffer(sizeof(LONGLONG) - (UINT)(m_lpBufMax - m_lpBufCur));
	dwdw = *(UNALIGNED LONGLONG*)m_lpBufCur; m_lpBufCur += sizeof(LONGLONG); return *this; 
}
_AFX_INLINE CArchive& CArchive::operator>>(ULONGLONG& dwdw)
{ 
	if(!IsLoading())
		AfxThrowArchiveException(CArchiveException::writeOnly,m_strFileName);
	if (m_lpBufCur + sizeof(ULONGLONG) > m_lpBufMax)
		FillBuffer(sizeof(ULONGLONG) - (UINT)(m_lpBufMax - m_lpBufCur));
	dwdw = *(UNALIGNED ULONGLONG*)m_lpBufCur; m_lpBufCur += sizeof(ULONGLONG); return *this; 
}
_AFX_INLINE CArchive& CArchive::operator>>(WORD& w)
{ 
	if(!IsLoading())
		AfxThrowArchiveException(CArchiveException::writeOnly,m_strFileName);
	if (m_lpBufCur + sizeof(WORD) > m_lpBufMax)
		FillBuffer(UINT(sizeof(WORD) - (m_lpBufMax - m_lpBufCur)));
	w = *(UNALIGNED WORD*)m_lpBufCur; m_lpBufCur += sizeof(WORD); return *this; 
}
_AFX_INLINE CArchive& CArchive::operator>>(DWORD& dw)
{ 
	if(!IsLoading())
		AfxThrowArchiveException(CArchiveException::writeOnly,m_strFileName);
	if (m_lpBufCur + sizeof(DWORD) > m_lpBufMax)
		FillBuffer(UINT(sizeof(DWORD) - (m_lpBufMax - m_lpBufCur)));
	dw = *(UNALIGNED DWORD*)m_lpBufCur; m_lpBufCur += sizeof(DWORD); return *this; 
}
_AFX_INLINE CArchive& CArchive::operator>>(float& f)
{ 
	if(!IsLoading())
		AfxThrowArchiveException(CArchiveException::writeOnly,m_strFileName);
	if (m_lpBufCur + sizeof(float) > m_lpBufMax)
		FillBuffer(UINT(sizeof(float) - (m_lpBufMax - m_lpBufCur)));
	f = *(UNALIGNED float*)m_lpBufCur; m_lpBufCur += sizeof(float); return *this; 
}
_AFX_INLINE CArchive& CArchive::operator>>(double& d)
{ 
	if(!IsLoading())
		AfxThrowArchiveException(CArchiveException::writeOnly,m_strFileName);
	if (m_lpBufCur + sizeof(double) > m_lpBufMax)
		FillBuffer(UINT(sizeof(double) - (m_lpBufMax - m_lpBufCur)));
	d = *(UNALIGNED double*)m_lpBufCur; m_lpBufCur += sizeof(double); return *this; 
}
_AFX_INLINE CArchive& CArchive::operator>>(LONG& l)
{ 
	if(!IsLoading())
		AfxThrowArchiveException(CArchiveException::writeOnly,m_strFileName);
	if (m_lpBufCur + sizeof(LONG) > m_lpBufMax)
		FillBuffer(UINT(sizeof(LONG) - (m_lpBufMax - m_lpBufCur)));
	l = *(UNALIGNED LONG*)m_lpBufCur; m_lpBufCur += sizeof(LONG); return *this; 
}

_AFX_INLINE CArchive::CArchive(const CArchive& /* arSrc */)
	{ }
_AFX_INLINE void CArchive::operator=(const CArchive& /* arSrc */)
	{ }
_AFX_INLINE CArchive& AFXAPI operator<<(CArchive& ar, const CObject* pOb)
	{ ar.WriteObject(pOb); return ar; }
_AFX_INLINE CArchive& AFXAPI operator>>(CArchive& ar, CObject*& pOb)
	{ pOb = ar.ReadObject(NULL); return ar; }
_AFX_INLINE CArchive& AFXAPI operator>>(CArchive& ar, const CObject*& pOb)
	{ pOb = ar.ReadObject(NULL); return ar; }

_AFX_INLINE void CArchive::EnsureRead(void *lpBuf, UINT nCount)
{
	UINT nRead=Read(lpBuf, nCount);
	if(nRead!=nCount)
	{
		AfxThrowArchiveException(CArchiveException::endOfFile);
	}
}

// CDumpContext
_AFX_INLINE int CDumpContext::GetDepth() const
	{ return m_nDepth; }
_AFX_INLINE void CDumpContext::SetDepth(int nNewDepth)
	{ m_nDepth = nNewDepth; }
_AFX_INLINE CDumpContext::CDumpContext(const CDumpContext& /* dcSrc */)
	{ }
_AFX_INLINE void CDumpContext::operator=(const CDumpContext& /* dcSrc */)
	{ }

/////////////////////////////////////////////////////////////////////////////
#endif //AFX_INL_INCLUDE_GUARD
#endif //_AFX_INLINE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxacceleratorkey.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCAcceleratorKey : public CObject
{
public:
	CMFCAcceleratorKey();
	CMFCAcceleratorKey(LPACCEL lpAccel);
	virtual ~CMFCAcceleratorKey();

// Operations:
public:
	void Format(CString& str) const;

protected:
	void AddVirtKeyStr(CString& str, UINT uiVirtKey, BOOL bLast = FALSE) const;

// Atttributes:
public:
	void SetAccelerator(LPACCEL lpAccel)
	{
		m_lpAccel = lpAccel;
	}

protected:
	LPACCEL m_lpAccel;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxaccessibility.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#ifndef STATE_SYSTEM_NORMAL
#define STATE_SYSTEM_NORMAL  0x0000
#endif 

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

// CAccessibilityData

class CAccessibilityData
{
public:
	CAccessibilityData()
	{
		Clear();
	}

	void Clear()
	{
		m_nAccRole = 0;
		m_bAccState = 0;
		m_nAccHit = 0;
		m_rectAccLocation = CRect(0, 0, 0, 0);
		m_ptAccHit = CPoint(0, 0);

		m_strAccName.Empty();
		m_strAccValue.Empty();
		m_strDescription.Empty();
		m_strAccKeys.Empty();
		m_strAccHelp.Empty();
		m_strAccName.Empty();
		m_strAccDefAction.Empty();
	}

	CString m_strAccName;
	CString m_strAccValue;
	CString m_strDescription;
	CString m_strAccKeys;
	CString m_strAccHelp;
	CString m_strAccDefAction;

	int    m_nAccRole;
	UINT   m_bAccState;
	UINT   m_nAccHit;
	CRect  m_rectAccLocation;
	CPoint m_ptAccHit;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxacceleratorkeyassignctrl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxacceleratorkey.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCAcceleratorKeyAssignCtrl window

class CMFCAcceleratorKeyAssignCtrl : public CEdit
{
// Construction
public:
	CMFCAcceleratorKeyAssignCtrl();

// Attributes
public:
	BOOL IsKeyDefined() const { return m_bIsDefined; }
	BOOL IsFocused() const { return m_bIsFocused; }
	ACCEL const* GetAccel() const { return &m_Accel; }

protected:
	BOOL  m_bIsDefined;
	ACCEL m_Accel;
	CMFCAcceleratorKey m_Helper;
	BOOL  m_bIsFocused;

// Operations
public:
	void ResetKey();

protected:
	void SetAccelFlag(BYTE bFlag, BOOL bOn);

// Overrides
public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);

// Implementation
public:
	virtual ~CMFCAcceleratorKeyAssignCtrl();

protected:
	//{{AFX_MSG(CMFCAcceleratorKeyAssignCtrl)
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxadv.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Note: This header file contains useful classes that are documented only
//  in the MFC Technical Notes.  These classes may change from version to
//  version, so be prepared to change your code accordingly if you utilize
//  this header.  In the future, commonly used portions of this header
//  may be moved and officially documented.

#ifndef __AFXADV_H__
#define __AFXADV_H__

#ifndef __AFXWIN_H__
	#include <afxwin.h>
#endif

#ifndef __AFXTEMPL_H__
	#include <afxtempl.h>
#endif

#ifndef __objectarray_h__
	#include <ObjectArray.h>
#endif

#ifndef __shobjidl_h__
	#include <shobjidl.h>
#endif

#pragma once

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// AFXADV - MFC Advanced Classes

// Classes declared in this file

//CObject
	//CFile
		//CMemFile
			class CSharedFile;          // Shared memory file

	class CRecentFileList;              // used in CWinApp for MRU list
	class CDockState;                   // state of docking toolbars
	class CJumpList;                    // Windows7 custom jump list implementation
	class CAppDestinations;             // Windows7 IApplicationDestinations implementation
/////////////////////////////////////////////////////////////////////////////

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

/////////////////////////////////////////////////////////////////////////////
// Shared file support

class CSharedFile : public CMemFile
{
	DECLARE_DYNAMIC(CSharedFile)

public:
// Constructors
	/* explicit */ CSharedFile(UINT nAllocFlags = GMEM_MOVEABLE,
		UINT nGrowBytes = 4096);

// Attributes
	HGLOBAL Detach();
	void SetHandle(HGLOBAL hGlobalMemory, BOOL bAllowGrow = TRUE);

// Implementation
public:
	virtual ~CSharedFile();
protected:
	virtual BYTE* Alloc(SIZE_T nBytes);
	virtual BYTE* Realloc(BYTE* lpMem, SIZE_T nBytes);
	virtual void Free(BYTE* lpMem);

	UINT m_nAllocFlags;
	HGLOBAL m_hGlobalMemory;
	BOOL m_bAllowGrow;
};

/////////////////////////////////////////////////////////////////////////////
// CRecentFileList

#define AFX_ABBREV_FILENAME_LEN 30

class CRecentFileList
{
// Constructors
public:
	CRecentFileList(UINT nStart, LPCTSTR lpszSection,
		LPCTSTR lpszEntryFormat, int nSize,
		int nMaxDispLen = AFX_ABBREV_FILENAME_LEN);

// Attributes
	int GetSize() const;
	CString& operator[](int nIndex);

// Operations
	virtual void Remove(int nIndex);
	virtual void Add(LPCTSTR lpszPathName);

	/// <summary>
	/// Adds a file to the MRU file list.</summary>
	/// <param name="lpszPathName"> Pathname to be added to the list.</param>
	/// <param name="lpszAppID"> Specifies Application User Model ID for the application.</param>
	virtual void Add(LPCTSTR lpszPathName, LPCTSTR lpszAppID);
	virtual BOOL GetDisplayName(CString& strName, int nIndex,
		LPCTSTR lpszCurDir, int nCurDir, BOOL bAtLeastName = TRUE) const;
	virtual void UpdateMenu(CCmdUI* pCmdUI);
	virtual void ReadList();    // reads from registry or ini file
	virtual void WriteList();   // writes to registry or ini file

	/// <summary>
	/// Adds a file to the MRU file list.</summary>
	/// <param name="pItem"> Specifies a pointer to Shell Item to be added to the list.</param>
	/// <param name="lpszAppID"> Specifies Application User Model ID for the application.</param>
	void Add(IShellItem* pItem, LPCTSTR lpszAppID);

	/// <summary>
	/// Adds a file to the MRU file list.</summary>
	/// <param name="pLink"> Specifies a pointer to Shell Link to be added to the list.</param>
	/// <param name="lpszAppID"> Specifies Application User Model ID for the application.</param>
	void Add(IShellLink* pLink, LPCTSTR lpszAppID);

	/// <summary>
	/// Adds a file to the MRU file list.</summary>
	/// <param name="pidl"> Specifies the IDLIST for the shell item that should be added to the recent docs folder.</param>
	/// <param name="lpszAppID"> Specifies Application User Model ID for the application.</param>
	void Add(PIDLIST_ABSOLUTE pidl, LPCTSTR lpszAppID);

// Implementation
	virtual ~CRecentFileList();

	int m_nSize;                // contents of the MRU list
	CString* m_arrNames;
	CString m_strSectionName;   // for saving
	CString m_strEntryFormat;
	UINT m_nStart;              // for displaying
	int m_nMaxDisplayLength;
	CString m_strOriginal;      // original menu item contents
};

AFX_INLINE int CRecentFileList::GetSize() const
	{ return m_nSize; }
AFX_INLINE CString& CRecentFileList::operator[](int nIndex)
{ ENSURE_ARG(nIndex >=0 && nIndex < m_nSize); return m_arrNames[nIndex]; }

/////////////////////////////////////////////////////////////////////////////
// CDockState - used for docking serialization

class CDockState : public CObject
{
	DECLARE_SERIAL(CDockState)
	CDockState();

public:
// Attributes
	CPtrArray m_arrBarInfo;

public:
// Operations
	void LoadState(LPCTSTR lpszProfileName);
	void SaveState(LPCTSTR lpszProfileName);
	void Clear(); //deletes all the barinfo's
	DWORD GetVersion();

// Implementation
protected:
	BOOL m_bScaling;
	CRect m_rectDevice;
	CRect m_rectClip;
	CSize m_sizeLogical;
	DWORD m_dwVersion;

public:
	~CDockState();
	virtual void Serialize(CArchive& ar);

	// scaling implementation
	void ScalePoint(CPoint& pt);
	void ScaleRectPos(CRect& rect);
	CSize GetScreenSize();
	void SetScreenSize(CSize& size);
};

#if (WINVER >= 0x0601)
class CJumpList
{
public:
	/// <summary>
	/// Constructs a CJumpList object.  </summary> 
	/// <param name="bAutoCommit"> If this parameter is FALSE the list is not automatically committed in 
	/// destructor. </param>
	CJumpList(BOOL bAutoCommit = TRUE);
	~CJumpList();

	/// <summary>
	/// Begins a list-building transaction.  </summary> 
	/// <remarks>
	/// You don't need to call this method explicitly unless you wish to retrieve a pointer to 
	/// ICustomDestinationList using GetDestinationList, the number of available slots using GetMaxSlots, or 
	/// list of removed items using GetRemovedItems.</remarks>
	BOOL InitializeList();

	/// <summary>
	/// Sets the Application User Model ID for the list that will be built. </summary>
	/// <param name="strAppID"> A string that specifies the Application User Model ID./param>
	void SetAppID(LPCTSTR strAppID)
	{
		m_strAppID = strAppID;
		if (m_bInitialized)
		{
			TRACE0("Jump list has been initialized, therefore AppID setting has no effect.");
		}
	}

	/// <summary>
	/// Retrieves the maximum number of items, including category headers that can display in 
	/// the calling applications destination menu. </summary>
	/// <remarks>
	/// Applications may only report a number of items and category headers combined up to this value.  
	/// If calls to AppendCategory, AppendKnownCategory, or AddUserTasks exceed this number, they will 
	/// return failure. </remarks>
	UINT GetMaxSlots() const;

	/// <summary>
	/// Retrieves an interface pointer to destination list.</summary>
	/// <remarks>
	/// If the jump list has not been initialized, or has been committed or aborted, the 
	/// returned value will be NULL. </remarks>
	ICustomDestinationList* GetDestinationList()
	{
		return m_destListPtr;
	}

	/// <summary>
	/// Returns array of items that represent removed destinations.
	/// </summary>
	/// <remarks>
	/// The removed destinations are retrieved during initialization of jump list. 
	/// When generating a new destination list, applications are expected to first process the removed 
	/// destinations list, clearing their tracking data for any item returned by the removed list enumerator.  
	/// If an application attempts to provide an item that was just removed in the transaction that the 
	/// current call to BeginList started, the method call that re-added that item will fail, 
	/// to ensure that applications are respecting the removed list.  </remarks>
	IObjectArray* GetRemovedItems()
	{
		return m_removedItemsPtr;
	}

	/// <summary>
	/// Aborts a list-building transaction without committing. </summary>
	/// <remarks>
	/// Calling this method has the same effect as destroying CJumpList without calling CommitList. </remarks>
	void AbortList()
	{
		if (m_bInitialized)
		{
			ASSERT(m_destListPtr != NULL);
			m_destListPtr->AbortList();
			ClearAll();
			m_bInitialized = FALSE;
		}
	}

	/// <summary>
	/// Adds destination to the list.</summary>
	/// <remarks>
	/// The instance of CJumpList internally accumulates added destinations and then commits them
	/// in CommitList.</remarks>
	/// <param name="lpcszCategoryName"> Specifies a category name. If the specified category does not exist, it will be created. </param>
	/// <param name="strDestinationPath"> Specifies a path to destination file. </param>
	BOOL AddDestination(LPCTSTR lpcszCategoryName, LPCTSTR strDestinationPath);

	/// <summary>
	/// Adds destination to the list.</summary>
	/// <remarks>
	/// The instance of CJumpList internally accumulates added destinations and then commits them
	/// in CommitList.</remarks>
	/// <param name="lpcszCategoryName"> Specifies a category name. If the specified category does not exist, it will be created. </param>
	/// <param name="pShellItem"> Specifies a Shell Item representing the destination being added. </param>
	BOOL AddDestination(LPCTSTR strCategoryName, IShellItem* pShellItem);


	/// <summary>
	/// Adds destination to the list.</summary>
	/// <remarks>
	/// The instance of CJumpList internally accumulates added destinations and then commits them
	/// in CommitList.</remarks>
	/// <param name="lpcszCategoryName"> Specifies a category name. If the specified category does not exist, it will be created. </param>
	/// <param name="pShellLink"> Specifies a Shell Link representing the destination being added. </param>
	BOOL AddDestination(LPCTSTR strCategoryName, IShellLink* pShellLink);

	/// <summary>
	/// Appends a Known Category to the list.</remarks>  
	/// <remarks>
	/// Known Categories are the Frequent and Recent categories that we will automatically calculate for every 
	/// application that utilizes SHAddToRecentDocs (or indirectly uses it as the shell will call it on the 
	/// applications behalf in some scenarios).</remarks>
	/// <param name="category"> Specifies a known category type. Can be either KDC_RECENT, or KDC_KNOWN. </param>
	BOOL AddKnownCategory(KNOWNDESTCATEGORY category);

	/// <summary>
	/// Adds items to the canonical Tasks category. </summary>
	/// <remarks>
	/// The instance of CJumpList accumulates specified tasks and adds them to the Destination List 
	/// during CommitList.
	/// Task items will appear in a category at the bottom of the applications destination menu.  
	/// This category takes precedence over all other categories when it is filled in the UI. </remarks>
	/// <param name="strTargetExecutablePath"> Specifies the target task path.</param>
	/// <param name="strCommandLineArgs"> Specifies command line arguments of the executable specified by strTargetExecutablePath.</param>
	/// <param name="strTitle"> Task name that will be displayed in the Destination List.</param>
	/// <param name="strIconLocation"> Location of icon that will be displayed in the Destination List along with the title.</param>
	/// <param name="iIconIndex"> Icon index.</param>
	BOOL AddTask(LPCTSTR strTargetExecutablePath, LPCTSTR strCommandLineArgs, LPCTSTR strTitle, LPCTSTR strIconLocation, int iIconIndex);
	/// <summary>
	/// Adds items to the canonical Tasks category. </summary>
	/// <remarks>
	/// The instance of CJumpList accumulates specified tasks and adds them to the Destination List 
	/// during CommitList.
	/// Task items will appear in a category at the bottom of the applications destination menu.  
	/// This category takes precedence over all other categories when it is filled in the UI. </remarks>
	/// <param name="pShellLink"> Shell Link that represents a task to be added.</param>
	BOOL AddTask(IShellLink* pShellLink);

	/// <summary>
	/// Adds items to the canonical Tasks category. </summary>
	/// <remarks>
	/// The instance of CJumpList accumulates specified tasks and adds them to the Destination List 
	/// during CommitList.
	/// Task items will appear in a category at the bottom of the applications destination menu.  
	/// This category takes precedence over all other categories when it is filled in the UI. </remarks>
	/// <param name="pObjectCollection"> A collection of tasks to be added.</param>
	BOOL AddTasks(IObjectArray* pObjectCollection);

	/// <summary>
	/// Adds a separator between tasks. </summary>
	BOOL AddTaskSeparator();

	/// <summary>
	/// Removes all destinations that have been added to the current instance of CJumpList so far.</summary>
	/// <remarks>
	/// Call this function if you need to remove all destinations that have been added so far in the current session
	/// of destination list building and add other destinations again. If the internal ICustomDestinationList
	/// has been initialized, it's left alive.</remarks>
	void ClearAllDestinations();

	/// <summary>
	/// Removes all tasks and destinations that have been added to the current instance of CJumpList so far.</summary>
	/// <remarks>
	/// This method clears and releases all data and internal interfaces. </remarks>
	void ClearAll();

	/// <summary>
	/// Ends a list-building transaction and commits the reported list to the associated 
	/// store (the registry in this case.) </summary>
	/// <remarks> 
	/// The commit is atomic.  An error will be returned if the commit fails.  When CommitList is called, 
	/// the current list of removed items will be cleaned up.
	/// Calling this method resets the object so that it does not have an active list-building transaction.  
	/// To update the list, BeginList needs to be called again. </remarks> 
	BOOL CommitList();

protected:
	IObjectCollection* CheckRemovedItems(IObjectCollection* pColl);
	void ReleaseObjectArray(IObjectArray* pColl, BOOL bReleaseItemsOnly = FALSE);
	IObjectCollection* GetObjectCollection(LPCTSTR lpcszCategoryName);

protected:
	CString		m_strAppID;
	BOOL		m_bInitialized;
	UINT		m_nMaxSlots;
	BOOL		m_bAutoCommit; // Automatically call commit in destructor

	::ATL::CComPtr<IObjectArray>           m_removedItemsPtr;
	::ATL::CComPtr<ICustomDestinationList> m_destListPtr;
	::ATL::CComPtr<IObjectCollection>      m_tasksPtr;

	CMap<CString, LPCTSTR, IObjectCollection*, IObjectCollection*> m_mapDestinations;
};

class CAppDestinations
{
public:
	/// <summary>
	/// The default constructor. </summary>
	CAppDestinations();

	/// <summary>
	/// The constructor. </summary>
	/// <param name="strAppID"> A string that specifies the Application User Model ID.</param>
	CAppDestinations(LPCTSTR lpszAppID);

	// operations

	/// <summary>
	/// Sets the Application User Model ID for the list that will be built. </summary>
	/// <param name="strAppID"> A string that specifies the Application User Model ID.</param>
	void SetAppID(LPCTSTR lpszAppID);

	/// <summary>
	/// Removes a destination. </summary>
	/// <param name="pUnk"> IShellItem or IShellLink that specifies a destination to remove.</param>
	BOOL RemoveDestination(IUnknown* pUnk);

	/// <summary>
	/// Removes all destinations. </summary>
	BOOL RemoveAllDestinations();

protected:
	BOOL Init();

protected:
	::ATL::CComPtr<IApplicationDestinations> m_appDests;
	CStringW  m_strAppID;
};

#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif // __AFXADV_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxautohidebutton.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

class CMFCAutoHideBar;
class CDockablePane;

#include "afxcontrolbarutil.h"
#include "afxautohidebar.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCAutoHideButton : public CObject
{
	DECLARE_DYNCREATE(CMFCAutoHideButton)
public:
	CMFCAutoHideButton();
	virtual ~CMFCAutoHideButton();

	virtual BOOL Create(CMFCAutoHideBar* pParentBar, CDockablePane* pAutoHideWnd, DWORD dwAlignment);

	void ShowAttachedWindow(BOOL bShow);

	void BringToTop() {m_bTop = TRUE;}
	void Move(int nOffset);

	virtual void ShowButton(BOOL bShow); 
	virtual BOOL IsVisible() const {return m_bVisible;}

	/// <summary>
	/// Highlights auto hide button.</summary>
	/// <param name="bHighlight">Specifies the new auto hide button state: TRUE - button is highlighted, FALSE- button is not highlighted.</param>
	virtual void HighlightButton(BOOL bHighlight);
	/// <summary>
	/// Returns highlight state of auto hide button.</summary>
	/// <returns> Returns TRUE if auto hide button is highlighted; otherwise FALSE.</returns>
	virtual BOOL IsHighlighted() const { return m_bHighlighted; }

	BOOL IsTop() const {return m_bTop;}
	BOOL IsActive() const { return m_pParentBar != NULL && m_pParentBar->m_bActiveInGroup; }

	virtual void OnDraw(CDC* pDC);
	virtual void OnFillBackground(CDC* pDC, CRect rect);
	virtual void OnDrawBorder(CDC* pDC, CRect rectBounds, CRect rectBorderSize);

	virtual void UnSetAutoHideMode(CDockablePane* pFirstBarInGroup);

	CSize GetSize() const;
	CRect GetRect() const {return m_rect;}
	virtual CSize GetTextSize() const;

	BOOL IsHorizontal() const;

	DWORD GetAlignment() const { return m_dwAlignment; }

	CDockablePane* GetAutoHideWindow() const {return m_pAutoHideWindow;}
	CMFCAutoHideBar* GetParentToolBar() {return m_pParentBar;}

	void ReplacePane(CDockablePane* pNewBar);

	AFX_IMPORT_DATA static int m_nBorderSize;
	AFX_IMPORT_DATA static int m_nMarginSize;
	AFX_IMPORT_DATA static int m_nTextMargin;
	AFX_IMPORT_DATA static int m_nTextSizeNoIcon;

	AFX_IMPORT_DATA static BOOL m_bOverlappingTabs;

protected:
	BOOL  m_bTop;
	BOOL  m_bVisible;
	BOOL  m_bHighlighted;
	DWORD m_dwAlignment;
	int   m_nOffset;  // offset from the left bound of the parent bar for the horz buttons and from left bound for vert buttons

	CRect m_rect;
	CMFCAutoHideBar* m_pParentBar;
	CDockablePane* m_pAutoHideWindow;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxautohidedocksite.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxdocksite.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCAutoHideBar;

/////////////////////////////////////////////////////////////////////////////
// CAutoHideDockSite window

class CAutoHideDockSite : public CDockSite
{
	DECLARE_DYNCREATE(CAutoHideDockSite)
// Construction
public:
	CAutoHideDockSite();

// Attributes
public:
	void SetOffsetLeft(int nOffset) { m_nOffsetLeft = nOffset; }
	void SetOffsetRight(int nOffset) { m_nOffsetRight = nOffset; }

	void GetAlignRect(CRect& rect) const;
	virtual BOOL CanAcceptPane(const CBasePane* pBar) const;

// Operations
public:
	virtual void DockPane(CPane* pWnd, AFX_DOCK_METHOD dockMethod, LPCRECT lpRect = NULL);
	virtual void RepositionPanes(CRect& rectNewClientArea);

	void UnSetAutoHideMode(CMFCAutoHideBar* pAutohideToolbar);

	virtual BOOL AllowShowOnPaneMenu() const { return FALSE; }

// Implementation
public:
	virtual ~CAutoHideDockSite();

	// Generated message map functions
protected:
	//{{AFX_MSG(CAutoHideDockSite)
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	int m_nOffsetLeft;
	int m_nOffsetRight;

	AFX_IMPORT_DATA static int m_nExtraSpace;
};

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxautohidebar.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxpane.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCAutoHideButton;
class CDockablePane;

/////////////////////////////////////////////////////////////////////////////
// CMFCAutoHideBar window

class CMFCAutoHideBar : public CPane
{
	friend class CMFCVisualManagerVS2008;

	DECLARE_DYNCREATE(CMFCAutoHideBar)

// Construction
public:
	CMFCAutoHideBar();

// Attributes
public:
	AFX_IMPORT_DATA static int m_nShowAHWndDelay;

// Operations
public:
	CMFCAutoHideButton* AddAutoHideWindow(CDockablePane* pAutoHideWnd, DWORD dwAlignment);
	BOOL RemoveAutoHideWindow(CDockablePane* pAutoHideWnd);
	BOOL ShowAutoHideWindow(CDockablePane* pAutoHideWnd, BOOL bShow, BOOL bDelay);

	void UpdateVisibleState();
	int GetVisibleCount();

	virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);
	virtual CSize StretchPane(int nLength, BOOL bVert);

	virtual void SetActiveInGroup(BOOL bActive);

	void SetRecentVisibleState(BOOL bState) { m_bRecentVisibleState = bState; }
	void UnSetAutoHideMode(CDockablePane* pFirstBarInGroup);

	CDockablePane* GetFirstAHWindow();

	AFX_IMPORT_DATA static CRuntimeClass* m_pAutoHideButtonRTS;
	
	virtual BOOL OnShowControlBarMenu(CPoint /*point*/) { return FALSE; }
	virtual BOOL AllowShowOnPaneMenu() const { return FALSE; }

// Overrides
public:
	virtual BOOL Create(LPCTSTR lpszClassName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, DWORD dwControlBarStyle = AFX_DEFAULT_PANE_STYLE, CCreateContext* pContext = NULL);

// Implementation
public:
	virtual ~CMFCAutoHideBar();

protected:
	//{{AFX_MSG(CMFCAutoHideBar)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnNcDestroy();
	afx_msg void OnTimer(UINT_PTR nIDEvent);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	//}}AFX_MSG
	afx_msg LRESULT OnMouseLeave(WPARAM,LPARAM);
	DECLARE_MESSAGE_MAP()

	CMFCAutoHideButton* ButtonFromPoint (CPoint pt);
	CMFCAutoHideButton* ButtonFromAutoHideWindow (CDockablePane* pWnd);
	void CleanUpAutoHideButtons();

	virtual void DoPaint(CDC* pDC);

protected:
	CObList          m_lstAutoHideButtons;
	CMFCAutoHideButton* m_pLastActiveButton;
	CMFCAutoHideButton* m_pHighlightedButton;

	BOOL     m_bReadyToDisplayAHWnd;
	UINT_PTR m_nDisplayAHWndTimerID;

private:
	BOOL m_bTracked;
};

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxbaseribbonelement.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CAccessibilityData;
class CMFCRibbonCategory;
class CMFCRibbonPanel;
class CMFCRibbonCmdUI;
class CMFCPopupMenu;
class CMFCRibbonButtonsGroup;
class CMFCRibbonPanelMenuBar;
class CMFCRibbonCommandsListBox;
class CMFCPopupMenu;
class CMFCRibbonQuickAccessToolBar;
class CMFCRibbonKeyTip;

class CMFCRibbonBaseElement : public CObject
{
	friend class CMFCRibbonPanel;
	friend class CMFCRibbonBar;
	friend class CMFCRibbonCmdUI;
	friend class CMFCRibbonButtonsGroup;
	friend class CMFCPopupMenu;
	friend class CMFCRibbonPanelMenuBar;
	friend class CMFCRibbonCategory;
	friend class CMFCPopupMenuBar;
	friend class CMFCRibbonQuickAccessToolBar;
	friend class CMFCRibbonGallery;
	friend class CMFCRibbonStatusBar;
	friend class CMFCRibbonCommandsListBox;
	friend class CMFCRibbonCollector;
	friend class CMFCRibbonConstructor;

	DECLARE_DYNAMIC(CMFCRibbonBaseElement)

// Construction
public:
	CMFCRibbonBaseElement();
	virtual ~CMFCRibbonBaseElement();

// Attributes
public:
	enum RibbonElementLocation
	{
		RibbonElementNotInGroup,
		RibbonElementSingleInGroup,
		RibbonElementFirstInGroup,
		RibbonElementLastInGroup,
		RibbonElementMiddleInGroup,
	};

	enum RibbonImageType
	{
		RibbonImageLarge,
		RibbonImageSmall
	};

	RibbonElementLocation GetLocationInGroup() const
	{
		return m_Location;
	}

	virtual void SetID(UINT nID);
	UINT GetID() const { return m_nID; }

	virtual void SetText(LPCTSTR lpszText);
	LPCTSTR GetText() const { return m_strText; }

	virtual void SetKeys(LPCTSTR lpszKeys, LPCTSTR lpszMenuKeys = NULL);
	LPCTSTR GetKeys() const { return m_strKeys; }
	LPCTSTR GetMenuKeys() const { return m_strMenuKeys; }

	virtual void SetTextAlwaysOnRight(BOOL bSet = TRUE);
	BOOL IsTextAlwaysOnRight() const { return m_bTextAlwaysOnRight; }

	void SetRect(CRect rect) { m_rect = rect; }
	CRect GetRect() const { return m_rect; }

	DWORD_PTR GetData() const { return m_dwData; }
	void SetData(DWORD_PTR dwData) { m_dwData = dwData; }

	BOOL IsDefaultMenuLook() const { return m_bIsDefaultMenuLook; }
	void SetDefaultMenuLook(BOOL bIsDefaultMenuLook = TRUE) { m_bIsDefaultMenuLook = bIsDefaultMenuLook; }

	virtual CString GetToolTipText() const;
	virtual CString GetDescription() const;

	virtual void SetToolTipText(LPCTSTR lpszText);
	virtual void SetDescription(LPCTSTR lpszText);

	virtual BOOL IsHighlighted() const { return m_bIsHighlighted; }
	virtual BOOL IsFocused() const { return m_bIsFocused; }
	virtual BOOL IsPressed() const { return m_bIsPressed; }
	virtual BOOL IsDisabled() const { return m_bIsDisabled; }
	virtual BOOL IsChecked() const { return m_bIsChecked; }
	virtual BOOL IsDroppedDown() const { return  m_bIsDroppedDown; }

	BOOL IsLargeMode() const { return !m_bCompactMode && !m_bIntermediateMode; }
	BOOL IsCompactMode() const { return m_bCompactMode; }
	BOOL IsIntermediateMode() const { return m_bIntermediateMode; }

	BOOL IsVisible() const { return m_bIsVisible; }
	void SetVisible(BOOL bIsVisible) { m_bIsVisible = bIsVisible; }

	virtual BOOL IsAlwaysLargeImage() const { return m_bIsAlwaysLarge; }

	virtual void SetCompactMode(BOOL bCompactMode = TRUE)
	{
		if(!bCompactMode)
		{
			if (m_bCompactMode)
			{
				if (HasIntermediateMode())
				{
					m_bIntermediateMode = TRUE;
					m_bCompactMode = FALSE;
				}
				else
				{
					m_bIntermediateMode = FALSE;
					m_bCompactMode = FALSE;
				}
			}
		}
		else
		{
			if (m_bCompactMode)
			{
				return;
			}

			if (m_bIntermediateMode)
			{
				if (HasCompactMode())
				{
					m_bCompactMode = TRUE;
					m_bIntermediateMode = FALSE;
				}
			}
			else
			{
				if (HasIntermediateMode())
				{
					m_bCompactMode = FALSE;
					m_bIntermediateMode = TRUE;
				}
			}
		}
	}

	virtual BOOL CanBeCompacted() const
	{
		if (IsAlwaysLargeImage() || m_bCompactMode)
		{
			return FALSE;
		}

		return m_bIntermediateMode ? HasCompactMode() : HasIntermediateMode();
	}

	virtual CSize GetSize(CDC* pDC)
	{
		return m_bIntermediateMode ? 
					GetIntermediateSize(pDC) : 
				m_bCompactMode ? 
					GetCompactSize(pDC) : 
					GetRegularSize(pDC);
	}

	virtual CSize GetRegularSize(CDC* pDC) = 0;
	virtual CSize GetCompactSize(CDC* pDC) { return GetRegularSize(pDC); }
	virtual CSize GetIntermediateSize(CDC* pDC) { return GetRegularSize(pDC); }

	virtual BOOL HasLargeMode() const { return FALSE; }
	virtual BOOL HasIntermediateMode() const { return TRUE; }
	virtual BOOL HasCompactMode() const { return FALSE; }

	virtual void SetInitialMode(BOOL bOneRow = FALSE)
	{
		m_bIntermediateMode = FALSE;
		m_bCompactMode = FALSE;

		if (m_pParentGroup != NULL || bOneRow)
		{
			if (HasCompactMode())
			{
				m_bCompactMode = TRUE;
			}
			else if (HasIntermediateMode())
			{
				m_bIntermediateMode = TRUE;
			}
		}
		else
		{
			if (HasLargeMode())
			{
			}
			else if (HasIntermediateMode())
			{
				m_bIntermediateMode = TRUE;
			}
			else
			{
				m_bIntermediateMode = FALSE;
			}
		}
	}

	virtual CSize GetImageSize(RibbonImageType /*type*/) const { return CSize(0, 0); }
	virtual BOOL IsSeparator() const { return FALSE; }
	virtual BOOL IsTabStop() const { return TRUE; }
	BOOL IsShowGroupBorder() const { return m_bShowGroupBorder; }

	virtual void DrawImage(CDC* /*pDC*/, RibbonImageType /*type*/, CRect /*rectImage*/) {}

	virtual void OnAfterChangeRect(CDC* pDC);
	virtual void OnShow(BOOL /*bShow*/) {}

	virtual CMFCRibbonBaseElement* HitTest(CPoint point);

	CMFCRibbonCategory* GetParentCategory() const { return m_pParent; }
	virtual CMFCRibbonPanel* GetParentPanel() const;
	virtual CWnd* GetParentWnd() const;

	CMFCRibbonBar* GetParentRibbonBar() const { return m_pRibbonBar; }
	virtual void SetParentRibbonBar(CMFCRibbonBar* pRibbonBar) { m_pRibbonBar = pRibbonBar; }
	CMFCRibbonButtonsGroup* GetParentGroup() const { return m_pParentGroup; }

	CMFCRibbonBar* GetTopLevelRibbonBar() const;

	BOOL IsMenuMode() const;
	virtual BOOL HasMenu() const { return FALSE; }

	virtual void OnShowPopupMenu();

	virtual BOOL CanBeAddedToQuickAccessToolBar() const;
	BOOL IsQATMode() const { return m_bQuickAccessMode; }

	virtual BOOL IsWholeRowHeight() const { return FALSE; }
	virtual UINT GetNotifyID() { return m_nID; }
	virtual BOOL IsAutoRepeatMode(int& /*nDelay*/ /* ms */) const { return FALSE; }
	virtual BOOL OnAutoRepeat() { return FALSE; }

	virtual BOOL StretchToWholeRow(CDC* pDC, int nHeight);

	virtual BOOL OnDrawMenuImage(CDC* pDC, CRect rect)
	{
		DrawImage(pDC, RibbonImageSmall, rect);
		return TRUE;
	}

	CMFCRibbonBaseElement*	GetOriginal() const { return m_pOriginal; }

	virtual BOOL SetACCData(CWnd* pParent, CAccessibilityData& data);

	/// <summary>
	/// Indicates whether the parent element has keyboard focus</summary>
	/// <returns> 
	/// TRUE if the ribbon element is focused; otherwise FALSE.</returns>
	virtual BOOL HasFocus() const {	return FALSE; }

// Overrides
public:
	virtual void SetParentCategory(CMFCRibbonCategory* pParent);
	virtual void CopyFrom(const CMFCRibbonBaseElement& src);
	virtual void SetParentMenu(CMFCRibbonPanelMenuBar* pMenuBar);
	virtual void SetOriginal(CMFCRibbonBaseElement* pOriginal);

	virtual int AddToListBox(CMFCRibbonCommandsListBox* pWndListBox, BOOL bDeep);
	virtual void OnDrawOnList(CDC* pDC, CString strText, int nTextOffset, CRect rect, BOOL bIsSelected, BOOL bHighlighted);

	virtual void OnDraw(CDC* pDC) = 0;
	virtual void OnCalcTextSize(CDC* /*pDC*/) {}
	virtual void CleanUpSizes() {}

	virtual BOOL CanBeStretched() {
		return TRUE;
	}

	virtual BOOL CanBeStretchedHorizontally() { return FALSE; }
	virtual void StretchHorizontally() { ASSERT(FALSE); }
	virtual BOOL IsAlignByColumn() const { return TRUE; }

	virtual void ClosePopupMenu();
	virtual CMFCRibbonBaseElement* Find(const CMFCRibbonBaseElement* pElement);
	virtual CMFCRibbonBaseElement* FindByID(UINT uiCmdID);
	virtual CMFCRibbonBaseElement* FindByData(DWORD_PTR dwData);
	virtual CMFCRibbonBaseElement* FindByOriginal(CMFCRibbonBaseElement* pOriginal);
	virtual void UpdateTooltipInfo();

	virtual BOOL OnAddToQAToolbar(CMFCRibbonQuickAccessToolBar& qat);
	virtual UINT GetQuickAccessToolBarID() const { return m_nID; }

	virtual void Redraw();
	virtual void DestroyCtrl() {}

	virtual CMFCRibbonBaseElement* GetPressed();
	virtual CMFCRibbonBaseElement* GetDroppedDown();
	virtual CMFCRibbonBaseElement* GetHighlighted();
	virtual CMFCRibbonBaseElement* GetFocused();

	virtual void OnDrawKeyTip(CDC* pDC, const CRect& rect, BOOL bIsMenu);
	virtual CSize GetKeyTipSize(CDC* pDC);
	virtual CRect GetKeyTipRect(CDC* /*pDC*/, BOOL /*bIsMenu*/)	{	return CRect(0, 0, 0, 0);	}
	virtual BOOL OnKey(BOOL bIsMenuKey);
	virtual void AddToKeyList(CArray<CMFCRibbonKeyTip*,CMFCRibbonKeyTip*>& arElems);
	virtual BOOL OnMenuKey(UINT /*nUpperChar*/)	{	return FALSE;	}

	virtual void GetElementsByID(UINT uiCmdID, CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arElements);

	virtual void GetElements(CArray <CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arElements)
	{
		arElements.Add(this);
	}

	virtual void GetVisibleElements(CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arElements);

	virtual void OnRTLChanged(BOOL /*bIsRTL*/) {}

	virtual BOOL IsShowTooltipOnBottom() const { return m_pRibbonBar == NULL; }

	virtual void OnChangeMenuHighlight(CMFCRibbonPanelMenuBar* /*pPanelMenuBar*/, CMFCRibbonBaseElement* /*pHot*/)	{}
	virtual void NotifyHighlightListItem(int nIndex);

	virtual BOOL IsGalleryIcon() const { return FALSE; }

	virtual CMFCRibbonBaseElement* GetFirstTabStop()
	{
		if (IsTabStop() && !m_rect.IsRectEmpty())
		{
			return this;
		}

		return NULL;
	}

	virtual CMFCRibbonBaseElement* GetLastTabStop()
	{
		if (IsTabStop() && !m_rect.IsRectEmpty())
		{
			return this;
		}

		return NULL;
	}

protected:
	virtual void OnLButtonDown(CPoint point);
	virtual void OnLButtonUp(CPoint /*point*/) {}
	virtual void OnMouseMove(CPoint /*point*/) {}
	virtual void OnLButtonDblClk(CPoint /*point*/) {}
	virtual void OnHighlight(BOOL /*bHighlight*/) {}
	virtual void OnSetFocus(BOOL /*bSet*/) {}

	virtual void OnUpdateCmdUI(CMFCRibbonCmdUI* pCmdUI, CFrameWnd* pTarget, BOOL bDisableIfNoHndler);
	virtual BOOL NotifyControlCommand(BOOL bAccelerator, int nNotifyCode, WPARAM wParam, LPARAM lParam);

	virtual BOOL ReplaceByID(UINT uiCmdID, CMFCRibbonBaseElement* pElem);

	virtual void GetItemIDsList(CList<UINT,UINT>& lstItems) const;
	
	virtual void OnEnable(BOOL /*bEnable*/) {}
	virtual void OnCheck(BOOL /*bCheck*/) {}

	virtual int GetDropDownImageWidth() const;

	virtual BOOL OnProcessKey(UINT /*nChar*/) { return FALSE; }

// Operations
public:
	BOOL NotifyCommand(BOOL bWithDelay = FALSE);
	void PostMenuCommand(UINT uiCmdId);
	void EnableUpdateTooltipInfo(BOOL bEnable = TRUE);
	void EnableTooltipInfoShortcut(BOOL bEnable = TRUE);

protected:
	void SetDroppedDown(CMFCPopupMenu* pPopupMenu);

// Attributes
protected:
	CString m_strText;
	CString m_strKeys;
	CString m_strMenuKeys;
	CString m_strToolTip;
	CString m_strDescription;

	CRect m_rect;
	CMFCRibbonBar* m_pRibbonBar;
	CMFCRibbonCategory* m_pParent;
	CMFCRibbonBaseElement* m_pOriginal;
	CMFCRibbonButtonsGroup* m_pParentGroup;
	CMFCRibbonPanelMenuBar* m_pParentMenu;
	RibbonElementLocation m_Location;
	CMFCPopupMenu* m_pPopupMenu;

	DWORD_PTR m_dwData;

	UINT m_nID;

	int m_nRow;
	int m_nImageOffset;

	BOOL m_bTextAlwaysOnRight;
	BOOL m_bDontNotify;
	BOOL m_bCompactMode;
	BOOL m_bIntermediateMode;
	BOOL m_bFloatyMode;
	BOOL m_bQuickAccessMode;
	BOOL m_bIsHighlighted;
	BOOL m_bIsFocused;
	BOOL m_bIsPressed;
	BOOL m_bIsDisabled;
	BOOL m_bIsChecked;
	BOOL m_bIsRadio;
	BOOL m_bIsDroppedDown;
	BOOL m_bShowGroupBorder;
	BOOL m_bIsVisible;
	BOOL m_bIsDefaultMenuLook;
	BOOL m_bIsAlwaysLarge;
	BOOL m_bDrawDefaultIcon;
	BOOL m_bIsOnPaletteTop;
	BOOL m_bOnBeforeShowItemMenuIsSent;
	BOOL m_bEnableUpdateTooltipInfo;
	BOOL m_bEnableTooltipInfoShortcut;
};

class CMFCRibbonSeparator : public CMFCRibbonBaseElement
{
	DECLARE_DYNCREATE(CMFCRibbonSeparator)

public:
	CMFCRibbonSeparator(BOOL bIsHoriz = FALSE);

protected:

	virtual BOOL IsSeparator() const { return TRUE; }
	virtual BOOL IsTabStop() const { return FALSE; }

public:
	virtual int AddToListBox(CMFCRibbonCommandsListBox* pWndListBox, BOOL bDeep);
	BOOL IsHorizontal() const { return m_bIsHoriz; }

protected:
	virtual void OnDraw(CDC* pDC);
	virtual CSize GetRegularSize(CDC* pDC);
	virtual void CopyFrom(const CMFCRibbonBaseElement& src);
	virtual void OnDrawOnList(CDC* pDC, CString strText, int nTextOffset, CRect rect, BOOL bIsSelected, BOOL bHighlighted);

	BOOL m_bIsHoriz;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxbasetabbedpane.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxdockablepane.h"
#include "afxbasetabctrl.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CBaseTabbedPane window

class CBaseTabbedPane : public CDockablePane
{
	DECLARE_DYNAMIC(CBaseTabbedPane)

// Construction
public:
	CBaseTabbedPane(BOOL bAutoDestroy = FALSE);

// Attributes
public:
	virtual CMFCBaseTabCtrl* GetUnderlyingWindow()
	{
		return m_pTabWnd;
	}

	virtual void GetTabArea(CRect& rectTabAreaTop, CRect& rectTabAreaBottom) const = 0;
	virtual HICON GetPaneIcon(BOOL bBigIcon);

	void SetAutoDestroy(BOOL bAutoDestroy = TRUE)
	{
		// should be called after dynamic creation (by CreateObject)
		m_bAutoDestroy = bAutoDestroy;
	}

	virtual BOOL HasAutoHideMode() const
	{
		return FALSE;
	}

	virtual int GetTabsNum() const
	{
		if (m_pTabWnd != NULL)
		{
			return m_pTabWnd->GetTabsNum();
		}

		return 0;
	}

	virtual int GetVisibleTabsNum() const
	{
		if (m_pTabWnd != NULL)
		{
			return m_pTabWnd->GetVisibleTabsNum();
		}

		return 0;
	}

	virtual BOOL IsHideSingleTab() const
	{
		if (m_pTabWnd != NULL)
		{
			return m_pTabWnd->IsHideSingleTab();
		}

		return FALSE;
	}

	virtual BOOL CanFloat() const;
	virtual BOOL AllowDestroyEmptyTabbedPane() const {return TRUE;}

	const CArray<int,int>& GetDefaultTabsOrder()
	{
		if (m_arDefaultTabsOrder.GetSize() == 0)
		{
			FillDefaultTabsOrderArray();
		}

		return m_arDefaultTabsOrder;
	}

	void FillDefaultTabsOrderArray();

	virtual void GetMinSize(CSize& size) const;
	
// Operations
public:
	virtual BOOL AddTab(CWnd* pNewBar, BOOL bVisible = TRUE, BOOL bSetActive = TRUE, BOOL bDetachable = TRUE);
	
	virtual BOOL FloatTab(CWnd* pBar, int nTabID, AFX_DOCK_METHOD dockMethod, BOOL bHide = FALSE);
	virtual BOOL DetachPane(CWnd* pBar, BOOL bHide = FALSE);
	virtual BOOL RemovePane(CWnd* pBar);
	virtual BOOL ShowTab(CWnd* pBar, BOOL bShow, BOOL bDelay, BOOL bActivate);

	virtual CWnd* FindPaneByID(UINT uBarID);
	virtual CWnd* FindBarByTabNumber(int nTabNum, BOOL bGetWrappedBar = FALSE);

	virtual CMFCAutoHideBar* SetAutoHideMode(BOOL bMode, DWORD dwAlignment, CMFCAutoHideBar* pCurrAutoHideBar = NULL, BOOL bUseTimer = TRUE);


	virtual CWnd* GetFirstVisibleTab(int& iTabNum);
	virtual void RecalcLayout();

	virtual void ApplyRestoredTabInfo(BOOL bUseTabIndexes = FALSE);
	virtual void Serialize(CArchive& ar);
	virtual void SerializeTabWindow(CArchive& ar);
	virtual void SaveSiblingBarIDs(CArchive& ar);

	virtual void EnableSetCaptionTextToTabName(BOOL bEnable) { m_bSetCaptionTextToTabName = bEnable; }
	virtual BOOL CanSetCaptionTextToTabName() const { return m_bSetCaptionTextToTabName; }

	virtual void GetPaneList(CObList& lst, CRuntimeClass* pRTCFilter = NULL);
	virtual void ConvertToTabbedDocument(BOOL bActiveTabOnly = TRUE);

	// it should be static because it may be called before the tab bar has been created
	static  void __stdcall LoadSiblingPaneIDs(CArchive& ar, CList<UINT, UINT>& lstBarIDs);

// Implementation
public:
	virtual ~CBaseTabbedPane();

protected:
	//{{AFX_MSG(CBaseTabbedPane)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnNcDestroy();
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg LRESULT OnChangeActiveTab(WPARAM,LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	virtual BOOL FloatPane(CRect rectFloat, AFX_DOCK_METHOD dockMethod = DM_UNKNOWN, bool bShow = true);

	virtual BOOL SaveState(LPCTSTR lpszProfileName, int nIndex = -1, UINT uiID = (UINT) -1);
	virtual BOOL LoadState(LPCTSTR lpszProfileName = NULL, int nIndex = -1, UINT uiID = (UINT) -1);

	virtual void StoreRecentDockSiteInfo();

	virtual BOOL Dock(CBasePane* pTargetBar, LPCRECT lpRect, AFX_DOCK_METHOD dockMethod);

	virtual void OnActivateTab(int /*iTabNum*/) {}

protected:
	BOOL m_bAutoDestroy;
	BOOL m_bSetCaptionTextToTabName;

	CMFCBaseTabCtrl*    m_pTabWnd;
	CArray<int,int> m_arDefaultTabsOrder;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxbasetabctrl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxbasepane.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

extern AFX_IMPORT_DATA UINT AFX_WM_ON_RENAME_TAB;
extern AFX_IMPORT_DATA UINT AFX_WM_ON_MOVE_TAB;
extern AFX_IMPORT_DATA UINT AFX_WM_CHANGE_ACTIVE_TAB;
extern AFX_IMPORT_DATA UINT AFX_WM_CHANGING_ACTIVE_TAB;
extern AFX_IMPORT_DATA UINT AFX_WM_ON_GET_TAB_TOOLTIP;

/////////////////////////////////////////////////////////////////////////////
// CMFCTabDropTarget command target

class CMFCBaseTabCtrl;

class CMFCTabDropTarget : public COleDropTarget
{
public:
	CMFCTabDropTarget()
	{
		m_pOwner = NULL;
	}

// Attributes
protected:
	CMFCBaseTabCtrl* m_pOwner;

// Operations
public:
	BOOL Register(CMFCBaseTabCtrl *pOwner);

// Overrides
public:
	virtual DROPEFFECT OnDragEnter(CWnd* pWnd, COleDataObject* pDataObject, DWORD dwKeyState, CPoint point);
	virtual void OnDragLeave(CWnd* pWnd);
	virtual DROPEFFECT OnDragOver(CWnd* pWnd, COleDataObject* pDataObject, DWORD dwKeyState, CPoint point);
	virtual DROPEFFECT OnDropEx(CWnd* pWnd, COleDataObject* pDataObject, DROPEFFECT dropEffect, DROPEFFECT dropList, CPoint point);
};

/////////////////////////////////////////////////////////////////////////////
// CMFCTabInfo

class CMFCTabInfo : public CObject
{
	friend class CMFCTabCtrl;
	friend class CMFCBaseTabCtrl;
	friend class CMFCOutlookBarTabCtrl;

	CMFCTabInfo(const CString& strText, const UINT uiIcon, CWnd* pWnd, const int iTabID, BOOL bDetachable) :
		m_pWnd(pWnd), m_uiIcon(uiIcon), m_iTabID(iTabID), m_bIsDetachable(bDetachable)
	{
		m_strText = strText;
		m_rect.SetRectEmpty();
		m_bVisible = TRUE;
		m_nFullWidth = 0;
		m_hIcon = NULL;
		m_bIconOnly = FALSE;
		m_bAlwaysShowToolTip = FALSE;

		m_clrText = (COLORREF) -1;
		m_clrBack = (COLORREF) -1;

		if (m_pWnd != NULL)
		{
			TCHAR szClass [256];
			::GetClassName(m_pWnd->GetSafeHwnd(), szClass, 255);

			CString strClass = szClass;
			m_bIsListView = (strClass == _T("SysListView32"));
		}
		else
		{
			m_bIsListView = FALSE;
		}
	}

	~CMFCTabInfo()
	{
		if (m_hIcon != NULL)
		{
			::DestroyIcon(m_hIcon);
		}
	}

	CString   m_strText;
	UINT      m_uiIcon;
	HICON     m_hIcon;
	CRect     m_rect;
	CWnd*     m_pWnd;
	int       m_nFullWidth;
	const int m_iTabID;

	COLORREF m_clrText;
	COLORREF m_clrBack;

	BOOL m_bVisible;
	BOOL m_bIsListView;
	BOOL m_bIconOnly;
	BOOL m_bAlwaysShowToolTip;
	BOOL m_bIsDetachable;

public:
	CRect GetRect() const { return m_rect; }
	void SetRect(CRect rect) { m_rect = rect; }
};

struct CMFCRestoredTabInfo
{
	CString  m_strText;
	BOOL     m_bVisible;
	int      m_nControlBarID;
	BOOL     m_bDetachable;
	COLORREF m_clrText;
	COLORREF m_clrBack;
};

struct CMFCTabToolTipInfo
{
	CString      m_strText;
	CMFCBaseTabCtrl* m_pTabWnd;
	int          m_nTabIndex;
};

/////////////////////////////////////////////////////////////////////////////
// CMFCBaseTabCtrl window

class CMFCBaseTabCtrl : public CWnd
{
	friend class CMFCOutlookBar;

	DECLARE_DYNAMIC(CMFCBaseTabCtrl)

// Construction
public:
	CMFCBaseTabCtrl();

	enum Location
	{
		LOCATION_BOTTOM = 0,
		LOCATION_TOP = 1
	};

// Attributes
public:
	virtual BOOL IsPtInTabArea(CPoint point) const = 0;
	virtual void GetTabArea(CRect& rectTabAreaTop, CRect& rectTabAreaBottom) const = 0;

	static int AFX_TAB_TEXT_MARGIN;
	static int AFX_TAB_IMAGE_MARGIN;

// Operations
public:
	virtual BOOL SetImageList(UINT uiID, int cx = 15, COLORREF clrTransp = RGB(255, 0, 255));
	virtual BOOL SetImageList(HIMAGELIST hImageList);
	virtual void ClearImageList();
	
	virtual void SetTabsHeight();
	virtual int GetTabsHeight() const { return m_nTabsHeight; }
	virtual void GetTabsRect(CRect& rect) const { rect.SetRectEmpty(); }

	virtual void RecalcLayout() = 0;
	
	// Tab access:
	virtual void AddTab(CWnd* pTabWnd, LPCTSTR lpszTabLabel, UINT uiImageId = (UINT)-1, BOOL bDetachable = TRUE);
	virtual void AddTab(CWnd* pTabWnd, UINT uiResTabLabel, UINT uiImageId = (UINT)-1, BOOL bDetachable = TRUE);

	virtual void InsertTab(CWnd* pNewWnd, LPCTSTR lpszTabLabel, int nInsertAt, UINT uiImageId = (UINT)-1, BOOL bDetachable = TRUE);
	virtual void InsertTab(CWnd* pNewWnd, UINT uiResTabLabel, int nInsertAt, UINT uiImageId = (UINT)-1, BOOL bDetachable = TRUE);

	virtual BOOL RemoveTab(int iTab, BOOL bRecalcLayout = TRUE);
	virtual void RemoveAllTabs();

	virtual BOOL DetachTab(AFX_DOCK_METHOD dockMethod, int nTabNum = -1, BOOL bHide = FALSE);

	virtual int GetVisibleTabsNum() const;
	virtual BOOL ShowTab(int iTab, BOOL bShow = TRUE, BOOL bRecalcLayout = TRUE, BOOL bActivate = FALSE);

	virtual int GetTabsNum() const { return m_iTabsNum; }

	// Tab properties:
	virtual CWnd* GetTabWnd(int iTab) const;
	virtual CWnd* GetTabWndNoWrapper(int iTab) const;
	virtual BOOL GetTabRect(int iTab, CRect& rect) const;
	int GetTabID(int iTab) const;

	virtual BOOL GetTabLabel(int iTab, CString& strLabel) const;
	virtual BOOL SetTabLabel(int iTab, const CString& strLabel);

	virtual UINT GetTabIcon(int iTab) const;
	virtual BOOL SetTabIcon(int iTab, UINT uiIcon);

	virtual BOOL IsTabIconOnly(int iTab) const;
	virtual BOOL SetTabIconOnly(int iTab, BOOL bIconOnly = TRUE, BOOL bShowTooltipAlways = FALSE);

	virtual BOOL SetTabHicon(int iTab, HICON hIcon);
	virtual HICON GetTabHicon(int iTab) const;

	virtual COLORREF GetTabBkColor(int iTab) const;
	virtual BOOL SetTabBkColor(int iTab, COLORREF color = (COLORREF)-1);

	virtual COLORREF GetTabTextColor(int iTab) const;
	virtual BOOL SetTabTextColor(int iTab, COLORREF color = (COLORREF)-1);

	virtual int GetTabFullWidth(int iTab) const;

	void EnableAutoColor(BOOL bEnable = TRUE);
	BOOL IsAutoColor() const { return m_bIsAutoColor; }

	void SetAutoColors(const CArray<COLORREF, COLORREF>& arColors);
	const CArray<COLORREF, COLORREF>& GetAutoColors() const { return m_arAutoColors; }

	virtual BOOL IsTabDetachable(int iTab) const;
	virtual BOOL EnableTabDetach(int iTab, BOOL bEnable);

	virtual BOOL StartRenameTab(int iTab);
	virtual BOOL RenameTab();
	virtual BOOL OnRenameTab(int /*iTab*/, CString& /*strName*/) { return TRUE; }

	virtual void EnableInPlaceEdit(BOOL bEnable) = 0;
	virtual void CalcRectEdit(CRect& rectEdit) = 0;
 
	void SetDrawNoPrefix(BOOL bNoPrefix, BOOL bRedraw = TRUE);
	BOOL IsDrawNoPrefix() const { return m_bLabelNoPrefix; }

	// Tab activation:
	virtual int GetActiveTab() const { return m_iActiveTab; }

	virtual CWnd* GetActiveWnd() const;
	virtual BOOL SetActiveTab(int iTab) = 0;

	virtual int GetTabFromPoint(CPoint& pt) const;
	virtual int GetTabFromHwnd(HWND hwnd) const;

	virtual int GetTabByID(int id) const;

	virtual BOOL EnsureVisible(int /*iTab*/) { return FALSE; }

	// Active tab color operations:
	virtual void SetActiveTabColor(COLORREF clr);
	virtual void SetActiveTabTextColor(COLORREF clr);

	virtual COLORREF GetActiveTabColor() const
	{
		return m_clrActiveTabBk == (COLORREF) -1 ? afxGlobalData.clrWindow : m_clrActiveTabBk;
	}

	virtual COLORREF GetActiveTabTextColor() const
	{
		return m_clrActiveTabFg == (COLORREF) -1 ? afxGlobalData.clrWindowText : m_clrActiveTabFg;
	}

	virtual CSize GetImageSize() const { return m_sizeImage; }

	virtual const CImageList* GetImageList() const
	{
		return (m_Images.GetSafeHandle() != NULL) ? &m_Images : m_hImageList != NULL ? CImageList::FromHandle(m_hImageList) : NULL;
	}

	virtual BOOL HasImage(int iTab) const;
	virtual void SetTabBorderSize(int nTabBorderSize, BOOL bRepaint = TRUE);

	virtual int GetTabBorderSize() const
	{
		return GetTabsHeight() > 0 ? m_nTabBorderSize : 0;
	}

	virtual CWnd* FindTargetWnd(const CPoint& pt) = 0;

	void InvalidateTab(int iTab);

	virtual void Serialize(CArchive& ar);
	virtual void ApplyRestoredTabInfo(BOOL bUseTabIndexes = FALSE);
	virtual CWnd* GetFirstVisibleTab(int& iTabNum);
	virtual CWnd* GetFirstVisibleTab(int iStartFrom, int& iTabNum);
	virtual CWnd* GetLastVisibleTab(int& iTabNum);

	void EnableTabSwap(BOOL bEnable) { m_bEnableTabSwap = bEnable ;}
	BOOL IsTabSwapEnabled() const { return m_bEnableTabSwap; }

	virtual void SwapTabs(int nFisrtTabID, int nSecondTabID);
	virtual void MoveTab(int nSource, int nDest);

	BOOL SetTabsOrder(const CArray<int,int>& arOrder);

	void EnterDragMode();

	virtual CSize GetMaxWindowSize() const;

	void AutoDestroyWindow(BOOL bAutoDestroy = TRUE) { m_bAutoDestroyWindow = bAutoDestroy; }
	BOOL IsAutoDestroyWindow() const { return m_bAutoDestroyWindow; }

	void EnableActivateLastActive(BOOL bLastActive = TRUE) { m_bActivateLastActiveTab = bLastActive; }

	virtual void OnChangeTabs() {}
	virtual void FireChangeActiveTab(int nNewTab);
	virtual BOOL FireChangingActiveTab(int nNewTab);

	void ResetImageList();
	BOOL IsIconAdded(HICON hIcon, int& iIcon) { return (m_mapAddedIcons.Lookup(hIcon, iIcon)); }
	void AddIcon(HICON hIcon, int iIcon) {m_mapAddedIcons.SetAt(hIcon, iIcon);}
	
	BOOL EnableCustomToolTips(BOOL bEnable = TRUE);

// Attributes
public:
	Location GetLocation() const { return m_location; }
	virtual void SetLocation(Location location);

	virtual BOOL IsTabVisible(int iTab) const;
	virtual BOOL IsFlatTab() const { return FALSE; }
	virtual BOOL IsActiveTabCloseButton() const { return FALSE; }
	virtual BOOL IsOneNoteStyle() const { return FALSE; }
	virtual BOOL IsVS2005Style() const { return FALSE; }
	virtual BOOL IsLeftRightRounded() const { return FALSE; }
	virtual BOOL IsFlatFrame() const { return FALSE; }
	virtual BOOL IsInPlaceEdit() const { return m_bIsInPlaceEdit; }
	virtual int  GetFirstVisibleTabNum() const { return -1;}

	virtual BOOL IsHideSingleTab() const { return m_bHideSingleTab; }
	virtual void HideSingleTab(BOOL bHide = TRUE);

	int GetHighlightedTab() const { return m_iHighlighted; }

	BOOL IsDialogControl() const { return m_bIsDlgControl; }

	virtual BOOL IsColored() const;

	BOOL IsMDITab() const { return m_bIsMDITab; }

	CToolTipCtrl& GetToolTipCtrl() const
	{
		if (m_pToolTip == NULL)
		{
			static CToolTipCtrl _afxEmptyToolTip;
			return _afxEmptyToolTip;
		}

		ASSERT_VALID(m_pToolTip);
		return (CToolTipCtrl&)*m_pToolTip;
	}

	BOOL IsTabCloseButtonHighlighted() const { return m_bTabCloseButtonHighlighted; }
	BOOL IsTabCloseButtonPressed() const { return m_bTabCloseButtonPressed; }
	CRect GetTabCloseButton() const { return m_rectCloseButton; }

	// detachable tabs support
	void SetDockingBarWrapperRTC(CRuntimeClass* pRTC) {m_pDockingBarWrapperRTC = pRTC;}
	BOOL m_bEnableWrapping;

// Overrides
	virtual BOOL PreTranslateMessage(MSG* pMsg);

	virtual BOOL OnDrop(COleDataObject* /*pDataObject*/, DROPEFFECT /*dropEffect*/, CPoint /*point*/) { return FALSE; }
	virtual DROPEFFECT OnDragEnter(COleDataObject* /*pDataObject*/, DWORD /*dwKeyState*/, CPoint /*point*/) { return DROPEFFECT_NONE; }
	virtual void OnDragLeave() {}
	virtual DROPEFFECT OnDragOver(COleDataObject* /*pDataObject*/, DWORD /*dwKeyState*/, CPoint /*point*/) { return DROPEFFECT_NONE; }

	BOOL m_bActivateLastVisibleTab;
	BOOL m_bHighLightTabs;
	BOOL m_bActivateTabOnRightClick;

// Implementation
public:
	virtual ~CMFCBaseTabCtrl();
	virtual void CleanUp();

protected:
	//{{AFX_MSG(CMFCBaseTabCtrl)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnCancelMode();
	afx_msg void OnDestroy();
	afx_msg int  OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSysColorChange();
	afx_msg void OnWindowPosChanged(WINDOWPOS FAR* lpwndpos);
	afx_msg BOOL OnNeedTipText(UINT id, NMHDR* pNMH, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	virtual int GetTabNumberToDetach(int nTabNum = -1) const;
	virtual CWnd* CreateWrapper(CWnd* pWndToWrap, LPCTSTR lpszTabLabel, BOOL bDetachable);

	virtual void InitAutoColors();

	virtual BOOL ActivateOnBtnUp() const { return m_bActivateOnBtnUp; }

protected:
	int CMFCBaseTabCtrl::FindTabInfo(int nBarID, CMFCTabInfo** ppTabInfo);

	Location   m_location; // Tabs location
	CPtrArray  m_arTabs;   // Array of CMFCTabInfo objects
	int m_iTabsNum;        // m_arTabs size
	int m_iActiveTab;      // Active tab number
	int m_iTabBeforeDrag;  // tab before drag

	CImageList m_Images;      // Tab images (for 3d tabs only)
	HIMAGELIST m_hImageList;  // External tab images
	CSize m_sizeImage;        // Tab image size

	CMap<HICON,HICON,int,int> m_mapAddedIcons; // Icons already loaded into the image list

	CToolTipCtrl* m_pToolTip;
	CToolTipCtrl* m_pToolTipClose; // Tooltip for active tab "close" button
	BOOL m_bCustomToolTips;

	int m_iCurTab;
	int m_nNextTabID;
	int m_nTabBorderSize;
	int m_nTabsHeight;    // Tabs area height
	int m_iHighlighted;   // Highlighted tab number
	int m_iPressed;       // Pressed tab number

	BOOL m_bAutoDestroyWindow;// Auto-destroy tab windows
	BOOL m_bHideInactiveWnd;  // Is inactive window should be invisible?
	BOOL m_bActivateOnBtnUp;  // Active tab changed on WM_LBUTTONUP
	BOOL m_bEnableTabSwap;
	BOOL m_bHideSingleTab;    // Hide tabs when only one tab is available
	BOOL m_bLabelNoPrefix;    // Draw tab label with DT_NOPREFIX flag
	BOOL m_bIsDlgControl;     // Tab is created on the dialog
	BOOL m_bIsMDITab;         // Tab is created for switching MDI windows

	COLORREF m_clrActiveTabBk; // Active tab backgound color
	COLORREF m_clrActiveTabFg; // Active tab foreground color

	CBrush m_brActiveTab;  // Active tab background brush
	CFont  m_fntTabs;      // Tab font (flat tabs only)
	CFont  m_fntTabsBold;  // Active tab font (flat tabs only)

	// in-place editing
	int m_iEditedTab;
	CEdit* m_pInPlaceEdit;
	BOOL m_bIsInPlaceEdit;

	/// detachable bars support
	BOOL m_bReadyToDetach;
	CPoint m_ptHot;
	int m_nOffsetFromTabLeft;

	// save/restore state support
	CList<CMFCRestoredTabInfo, CMFCRestoredTabInfo> m_lstRestoredTabInfo;
	int      m_nRestoredActiveTabID;

	CRuntimeClass* m_pDockingBarWrapperRTC;

	// Drag/drop toolbar buttons support:
	CMFCTabDropTarget m_DropTarget;

	// Auto-colors support
	CArray<COLORREF, COLORREF> m_arAutoColors;
	BOOL m_bIsAutoColor;
	BOOL m_bIsDefaultAutoColor;

	// VS.NET Activation support
	int  m_iLastActiveTab;
	BOOL m_bActivateLastActiveTab;
	BOOL m_bSetActiveTabFired;
	BOOL m_bSetActiveTabByMouseClick;

	// needed to prevent unnesessary capturing during LButtonDown
	// in case tab activation leads to adjust layout and moving of tab window.
	BOOL m_bWindowPosChanged;

	// Active tab "Close" button support:
	BOOL  m_bTabCloseButtonHighlighted;
	BOOL  m_bTabCloseButtonPressed;
	CRect m_rectCloseButton;

public:
	BOOL  m_bUserSelectedTab;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxbasepane.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#ifndef __AFXMT_H__
	#include <afxmt.h>
#endif

#include "afxcontrolbarutil.h"
#include "afxglobals.h"
#include "afxaccessibility.h"

#pragma warning( disable : 4100 34 )

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CPaneDivider;
class CPaneFrameWnd;
class CDockSite;
class CDockingPanesRow;
class CTabbedPane;
class CMFCBaseTabCtrl;
class CBaseTabbedPane;

// DM - dock method
typedef enum AFX_DOCK_METHOD
{
	DM_UNKNOWN,
	DM_MOUSE,
	DM_DBL_CLICK,
	DM_SHOW,
	DM_RECT,
	DM_STANDARD
};

// DT - dock type
typedef enum AFX_DOCK_TYPES
{
	DT_DOCK_FIRST,
	DT_DOCK_LAST,
	DT_DOCK_BEFORE,
	DT_DOCK_AFTER,
	DT_DOCK_BY_INDEX
};

static const DWORD AFX_CBRS_FLOAT        = 0x1;
static const DWORD AFX_CBRS_AUTOHIDE     = 0x2;
static const DWORD AFX_CBRS_RESIZE       = 0x4;
static const DWORD AFX_CBRS_CLOSE        = 0x8;
static const DWORD AFX_CBRS_AUTO_ROLLUP  = 0x10;

static const DWORD AFX_CBRS_REGULAR_TABS = 0x20;
static const DWORD AFX_CBRS_OUTLOOK_TABS = 0x40;

/////////////////////////////////////////////////////////////////////////////
// CBasePane window

class CBasePane : public CWnd
{
	friend class CDockingManager;
	friend class CMDIChildWndEx;
	friend class CMFCTabCtrl;

DECLARE_DYNAMIC(CBasePane)

// Construction
public:
	CBasePane();

// Attributes
public:
	virtual BOOL IsHorizontal() const;
	virtual BOOL IsDocked() const;
	virtual BOOL IsTabbed() const;
	virtual BOOL IsFloating() const { return !IsDocked(); }
	virtual BOOL IsMDITabbed() const;
	virtual BOOL IsResizable() const { return TRUE; }
	virtual BOOL IsVisible() const;
	virtual BOOL DoesAllowDynInsertBefore() const { return CanFloat(); }
	virtual BOOL CanAcceptPane(const CBasePane* pBar) const;
	virtual BOOL CanBeDocked(CBasePane* /*pDockBar*/) const { return FALSE; }
	virtual BOOL CanBeAttached() const { return FALSE; }
	virtual BOOL CanBeTabbedDocument() const { return FALSE; }
	virtual DWORD GetCurrentAlignment() const;
	virtual DWORD GetEnabledAlignment() const { return m_dwEnabledAlignment; }
	virtual CWnd* GetDockSiteFrameWnd() const;
	virtual CDockSite* GetParentDockSite() const { return m_pParentDockBar; }
	virtual int GetCaptionHeight() const { return 0; }
	virtual BOOL IsInFloatingMultiPaneFrameWnd() const { return FALSE; }
	
	virtual BOOL GetRecentVisibleState() const { return m_bRecentVisibleState ;}
	virtual BOOL IsRestoredFromRegistry() const { return m_bIsRestoredFromRegistry; }

	// use when loading from registry was partial (due to exception) to clean the state
	virtual void SetRestoredFromRegistry(BOOL bState) {m_bIsRestoredFromRegistry = bState;}

	virtual AFX_DOCK_TYPE GetDockingMode() const;
	virtual HICON GetPaneIcon(BOOL bBigIcon) {return CWnd::GetIcon(bBigIcon);}

	BOOL IsPaneVisible() const { return ((GetStyle() & WS_VISIBLE) != 0); }

	void SetDockingMode(AFX_DOCK_TYPE dockModeNew) { m_dockMode = dockModeNew; }
	void SetMDITabbed(BOOL bValue) { m_bIsMDITabbed = bValue; }

	virtual DWORD GetPaneStyle() const { return m_dwStyle; }
	virtual DWORD GetControlBarStyle() const { return m_dwControlBarStyle; }
	virtual BOOL CanBeClosed() const { return m_dwControlBarStyle & AFX_CBRS_CLOSE; }
	virtual BOOL CanFloat() const;
	virtual BOOL CanBeResized() const { return m_dwControlBarStyle & AFX_CBRS_RESIZE; }
	virtual BOOL CanAutoHide() const { return m_dwControlBarStyle & AFX_CBRS_AUTOHIDE; }
	virtual BOOL CanFocus() const { return TRUE; }

	virtual BOOL IsAutoHideMode() const { return FALSE; }

	CDockingPanesRow* GetPaneRow() {return m_pDockBarRow;}

	static BOOL __stdcall IsTooltipTopmost() { return m_bSetTooltipTopmost; }

	AFX_IMPORT_DATA static BOOL m_bSetTooltipTopmost;
	AFX_IMPORT_DATA static BOOL m_bMultiThreaded;

// Operations
public:
	virtual void SetPaneAlignment(DWORD dwAlignment)
	{
		m_dwStyle &= ~(CBRS_ALIGN_ANY);
		m_dwStyle |= dwAlignment;
	}

	virtual void SetPaneStyle(DWORD dwNewStyle) { m_dwStyle = dwNewStyle; }
	virtual void SetControlBarStyle(DWORD dwNewStyle) { m_dwControlBarStyle = dwNewStyle; }
	virtual void EnableDocking(DWORD dwAlignment) { m_dwEnabledAlignment = dwAlignment; }
	virtual void EnableGripper(BOOL bEnable) {}
	virtual void OnDrawCaption() {}
	virtual BOOL DockPane(CBasePane* pDockBar, LPCRECT lpRect, AFX_DOCK_METHOD dockMethod) { return FALSE; }
	virtual BOOL FloatPane(CRect rectFloat, AFX_DOCK_METHOD dockMethod = DM_UNKNOWN, bool bShow = true) { return FALSE; }

	virtual BOOL DockToFrameWindow(DWORD dwAlignment, LPCRECT lpRect = NULL, DWORD dwDockFlags = DT_DOCK_LAST,
		CBasePane* pRelativeBar = NULL, int nRelativeIndex = -1, BOOL bOuterEdge = FALSE)
	{
		return FALSE;
	}
	
	virtual void OnMovePaneDivider(CPaneDivider* /*pSlider*/) {}
	virtual CSize StretchPane(int nLength, BOOL bVert) { return CSize(0, 0); }

	void DockPaneUsingRTTI(BOOL bUseDockSite);

	virtual void AdjustLayout() {}
	virtual void RecalcLayout() {}

	virtual CPaneFrameWnd* CreateDefaultMiniframe(CRect rectInitial) { return NULL; }
	virtual void OnRemoveFromMiniFrame(CPaneFrameWnd* pMiniFrame) {}

	virtual void OnBeforeChangeParent(CWnd* pWndNewParent, BOOL bDelay = FALSE) {}
	virtual void OnAfterChangeParent(CWnd* pWndOldParent) {}

	virtual void ShowPane(BOOL bShow, BOOL bDelay, BOOL bActivate/* = TRUE*/);

	virtual CPaneFrameWnd* GetParentMiniFrame(BOOL bNoAssert = FALSE) const;

	virtual void Serialize(CArchive& ar);
	virtual BOOL LoadState(LPCTSTR lpszProfileName = NULL, int nIndex = -1, UINT uiID = (UINT) -1);
	virtual BOOL SaveState(LPCTSTR lpszProfileName = NULL, int nIndex = -1, UINT uiID = (UINT) -1);

	virtual HDWP MoveWindow(CRect& rect, BOOL bRepaint = TRUE, HDWP hdwp = NULL);
	virtual HDWP SetWindowPos(const CWnd* pWndInsertAfter, int x, int y, int cx, int cy, UINT nFlags, HDWP hdwp = NULL);

	virtual void CopyState(CBasePane* pOrgBar);

	CMFCBaseTabCtrl* GetParentTabWnd(HWND& hWndTab) const;
	CBaseTabbedPane* GetParentTabbedPane() const;
	virtual void UndockPane(BOOL bDelay = FALSE) {}

	virtual void OnUpdateCmdUI(CFrameWnd* /*pTarget*/, BOOL /*bDisableIfNoHndler*/) {}

	const CRect& GetPaneRect() const { return m_rectBar; }
	void SetPaneRect(const CRect& rect) { m_rectBar = rect; }
	void FillWindowRect() { GetWindowRect(m_rectBar); }

	virtual void OnPaneContextMenu(CWnd* pParentFrame, CPoint point);

	virtual BOOL HideInPrintPreviewMode() const { return TRUE; }

// Overrides
public:
	virtual BOOL CreateEx(DWORD dwStyleEx, LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, DWORD dwControlBarStyle = 0, CCreateContext* pContext = NULL);
	virtual BOOL PreTranslateMessage(MSG* pMsg);

// Accessibility
public:
	virtual BOOL OnSetAccData(long lVal);
	virtual BOOL IsAccessibilityCompatible() { return TRUE; }
	virtual void AccNotifyObjectFocusEvent(int /*iButton*/) {};

	virtual HRESULT get_accChildCount(long *pcountChildren);
	virtual HRESULT get_accChild(VARIANT varChild, IDispatch **ppdispChild);
	virtual HRESULT get_accName(VARIANT varChild, BSTR *pszName);
	virtual HRESULT get_accDescription(VARIANT varChild, BSTR *pszDescription);
	virtual HRESULT get_accRole(VARIANT varChild, VARIANT *pvarRole);
	virtual HRESULT get_accState(VARIANT varChild, VARIANT *pvarState);
	virtual HRESULT get_accHelp(VARIANT varChild, BSTR *pszHelp);
	virtual HRESULT get_accFocus(VARIANT *pvarChild);
	virtual HRESULT get_accSelection(VARIANT *pvarChildren);
	virtual HRESULT get_accHelpTopic(BSTR *pszHelpFile, VARIANT varChild, long *pidTopic);
	virtual HRESULT get_accKeyboardShortcut(VARIANT varChild, BSTR *pszKeyboardShortcut);
	virtual HRESULT get_accValue(VARIANT varChild, BSTR *pszValue);
	virtual HRESULT get_accParent(IDispatch **ppdispParent);
	virtual HRESULT get_accDefaultAction(VARIANT varChild, BSTR *pszDefaultAction);

	virtual HRESULT accSelect(long flagsSelect, VARIANT varChild);
	virtual HRESULT accLocation(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild);
	virtual HRESULT accHitTest(long xLeft, long yTop, VARIANT *pvarChild);

protected:
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);

// Implementation
public:
	virtual ~CBasePane();

	virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz)
	{
		CSize size;
		size.cx = (bStretch && bHorz ? 32767 : 0);
		size.cy = (bStretch && !bHorz ? 32767 : 0);
		return size;
	}

protected:
	virtual void DoPaint(CDC* pDC);

	//{{AFX_MSG(CBasePane)
	afx_msg void OnPaint();
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
	afx_msg LRESULT OnIdleUpdateCmdUI(WPARAM wParam, LPARAM);
	afx_msg LRESULT OnHelpHitTest(WPARAM, LPARAM lParam);
	afx_msg LRESULT HandleInitDialog(WPARAM, LPARAM);
	afx_msg LRESULT OnSetIcon(WPARAM,LPARAM);
	afx_msg LRESULT OnGetObject(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnPrintClient(WPARAM wp, LPARAM lp);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	BOOL m_bVisible; // use this status instead of IsWindowVisible
	BOOL m_bRecentVisibleState;
	BOOL m_bIsRestoredFromRegistry;
	BOOL m_bIsDlgControl;
	BOOL m_bIsMDITabbed;
	BOOL m_bEnableIDChecking;

	DWORD m_dwEnabledAlignment;
	DWORD m_dwStyle;
	DWORD m_dwControlBarStyle;

	CWnd*              m_pDockSite;
	CRect              m_rectBar;
	CDockSite*    m_pParentDockBar;
	CDockingPanesRow* m_pDockBarRow;

	AFX_DOCK_TYPE m_dockMode;

	// Dialog bar-specific:
	LPTSTR m_lpszBarTemplateName;
	CSize  m_sizeDialog;

	// Accessibility attributes:
	CAccessibilityData m_AccData;

	static CCriticalSection m_CriticalSection;

public:
	////------------ for frame mapping ---------------------------
	void AddPane(CBasePane* pBar);
	BOOL InsertPane	(CBasePane* pControlBar, CBasePane* pTarget, BOOL bAfter = TRUE);
	void RemovePaneFromDockManager(CBasePane* pBar, BOOL bDestroy = TRUE, BOOL bAdjustLayout = FALSE, BOOL bAutoHide = FALSE, CBasePane* pBarReplacement = NULL);
	BOOL IsPointNearDockSite(CPoint point, DWORD& dwBarAlignment, BOOL& bOuterEdge) const;
	CBasePane* PaneFromPoint(CPoint point, int nSensitivity, bool bExactBar = false, CRuntimeClass* pRTCBarType = NULL) const;
	virtual void AdjustDockingLayout(HDWP hdwp = NULL);

	BOOL IsDialogControl() const { return m_bIsDlgControl; }

	CFont* SelectDefaultFont(CDC* pDC)
	{
		if (m_bIsDlgControl)
		{
			return(CFont*) pDC->SelectStockObject(DEFAULT_GUI_FONT);
		}
		else
		{
			return pDC->SelectObject(&afxGlobalData.fontRegular);
		}
	}
};

_inline BOOL CBasePane::IsHorizontal() const
{
	ASSERT_VALID(this);
	return(GetCurrentAlignment() & CBRS_ORIENT_HORZ);
}

_inline BOOL CBasePane::CanAcceptPane(const CBasePane* /* pBar */) const
{
	return FALSE;
}

#pragma warning( default : 4100 34 )

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxcaptionbar.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#include "afxbutton.h"
#include "afxtoolbarimages.h"
#include "afxpane.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCCaptionBar : public CPane
{
	DECLARE_DYNCREATE(CMFCCaptionBar)

public:
	CMFCCaptionBar();
	virtual ~CMFCCaptionBar();

	BOOL Create(DWORD dwStyle, CWnd* pParentWnd, UINT uID, int nHeight = -1, BOOL bIsMessageBarMode = FALSE);

protected:
	//{{AFX_MSG(CMFCCaptionBar)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnPaint();
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnSysColorChange();
	afx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp);
	afx_msg void OnNcPaint();
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnDestroy();
	afx_msg LRESULT OnSetFont(WPARAM, LPARAM);
	afx_msg LRESULT OnGetFont(WPARAM, LPARAM);
	afx_msg LRESULT OnMouseLeave(WPARAM,LPARAM);
	afx_msg LRESULT OnUpdateToolTips(WPARAM, LPARAM);
	afx_msg BOOL OnNeedTipText(UINT id, NMHDR* pNMH, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

//Attributes
public:
	enum BarElement
	{
		ELEM_BUTTON,
		ELEM_TEXT,
		ELEM_ICON
	};

	enum BarElementAlignment
	{
		ALIGN_INVALID,
		ALIGN_LEFT,
		ALIGN_RIGHT,
		ALIGN_CENTER
	};

	BOOL IsMessageBarMode() const { return m_bIsMessageBarMode; }
	void SetFlatBorder(BOOL bFlat = TRUE) { m_bFlatBorder = bFlat; }

	void SetButton(LPCTSTR lpszLabel, UINT uiCmdUI, BarElementAlignment btnAlignment = ALIGN_LEFT, BOOL bHasDropDownArrow = TRUE);
	void SetButtonToolTip(LPCTSTR lpszToolTip, LPCTSTR lpszDescription = NULL);
	void RemoveButton();
	void EnableButton(BOOL bEnable = TRUE);
	void SetButtonPressed(BOOL bPresed = TRUE);

	void SetIcon(HICON hIcon, BarElementAlignment iconAlignment = ALIGN_RIGHT);
	void RemoveIcon();

	void SetBitmap(HBITMAP hBitmap, COLORREF clrTransparent, BOOL bStretch = FALSE, BarElementAlignment bmpAlignment = ALIGN_RIGHT);
	void SetBitmap(UINT uiBmpResID, COLORREF clrTransparent, BOOL bStretch = FALSE, BarElementAlignment bmpAlignment = ALIGN_RIGHT);
	void RemoveBitmap();
	void SetImageToolTip(LPCTSTR lpszToolTip, LPCTSTR lpszDescription = NULL);

	void SetText(const CString& strText, BarElementAlignment textAlignment = ALIGN_RIGHT);
	void RemoveText();

	void SetBorderSize(int nSize) { m_nBorderSize = nSize; }
	int  GetBorderSize() const { return m_nBorderSize; }

	void SetMargin(int nMargin) { m_nMargin = nMargin; }
	int  GetMargin() const { return m_nMargin; }

	BarElementAlignment GetAlignment(BarElement elem);

	COLORREF m_clrBarText;
	COLORREF m_clrBarBackground;
	COLORREF m_clrBarBorder;

	CRect GetButtonRect() const { return m_rectButton; }

	virtual BOOL DoesAllowDynInsertBefore() const {return FALSE;}

protected:
// Overridables
	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);
	virtual BOOL PreTranslateMessage(MSG* pMsg);

	virtual void OnDrawBackground(CDC* pDC, CRect rect);
	virtual void OnDrawBorder(CDC* pDC, CRect rect);
	virtual void OnDrawText(CDC* pDC, CRect rect, const CString& strText);
	virtual void OnDrawImage(CDC* pDC, CRect rect);
	virtual void OnDrawButton(CDC* pDC, CRect rect, const CString& strButton, BOOL bEnabled);

	virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);

	virtual CSize GetTextSize(CDC* pDC, const CString& strText);

	virtual void AdjustLayout();
	virtual void RecalcLayout();

	virtual BOOL OnShowControlBarMenu(CPoint /*point*/) { return FALSE; }

	BOOL m_bIsMessageBarMode;
	CToolTipCtrl* m_pToolTip;

	//------------------
	// Image attributes:
	//------------------
	HICON               m_hIcon;
	CMFCToolBarImages      m_Bitmap;
	BOOL                m_bStretchImage;
	BarElementAlignment m_iconAlignment;
	CRect               m_rectImage;
	CString             m_strImageToolTip;
	CString             m_strImageDescription;

	//-----------------------
	// Text label attributes:
	//-----------------------
	HFONT               m_hFont;
	CString             m_strText;
	CStringArray        m_arTextParts;
	BarElementAlignment m_textAlignment;
	CRect               m_rectText;
	CRect               m_rectDrawText;
	BOOL                m_bTextIsTruncated;

	//-------------------
	// Button attributes:
	//-------------------
	CString             m_strBtnText;
	CString             m_strButtonToolTip;
	CString             m_strButtonDescription;
	UINT                m_uiBtnID;
	BarElementAlignment m_btnAlignnment;
	CRect               m_rectButton;
	BOOL                m_bIsBtnPressed;
	BOOL                m_bIsBtnHighlighted;
	BOOL                m_bIsBtnForcePressed;
	BOOL                m_bTracked;
	BOOL                m_bBtnEnabled;
	BOOL                m_bBtnHasDropDownArrow;
	BOOL                m_bFlatBorder;

	int                 m_nBorderSize;
	int                 m_nMargin;
	int                 m_nHorzElementOffset;
	int                 m_nDefaultHeight;
	int                 m_nCurrentHeight;

	//-------------------------
	// Close Button attributes:
	//-------------------------
	BOOL                m_bIsCloseBtnPressed;
	BOOL                m_bIsCloseBtnHighlighted;
	BOOL                m_bCloseTracked;
	CRect               m_rectClose;

	CSize GetImageSize() const;

	BOOL CheckRectangle(CRect& rectSrc, const CRect& rectOther, BOOL bLeftOf);
	void AdjustRectToMargin(CRect& rectSrc, const CRect& rectClient, int nMargin, BOOL bRetainSize = FALSE);

	void UpdateTooltips();

	BOOL IsImageSet() const { return (m_hIcon != NULL || m_Bitmap.GetCount() > 0); }
};



#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxbutton.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxmenuimages.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCButton window

class CMFCButton : public CButton
{
	DECLARE_DYNCREATE(CMFCButton)

// Construction
public:
	CMFCButton();

// Attributes
public:
	enum FlatStyle
	{
		BUTTONSTYLE_3D,
		BUTTONSTYLE_FLAT,
		BUTTONSTYLE_SEMIFLAT,
		BUTTONSTYLE_NOBORDERS
	};

	enum AlignStyle
	{
		ALIGN_LEFT,
		ALIGN_RIGHT,
		ALIGN_CENTER
	};
	
	FlatStyle  m_nFlatStyle;
	AlignStyle m_nAlignStyle;

	BOOL m_bRightImage; // Is image on the right side?
	BOOL m_bTopImage;  // Is image on top?
	BOOL m_bTransparent;
	BOOL m_bDrawFocus;
	BOOL m_bHighlightChecked;
	BOOL m_bGrayDisabled;
	BOOL m_bResponseOnButtonDown;
	BOOL m_bDontUseWinXPTheme;
	BOOL m_bWasDblClk;

	CToolTipCtrl& GetToolTipCtrl()
	{
		if (m_pToolTip == NULL)
		{
			static CToolTipCtrl _afxEmptyToolTip;
			return _afxEmptyToolTip;
		}
		return (*m_pToolTip);
	}

	BOOL IsPressed() const { return m_bPushed && m_bHighlighted; }
	BOOL IsPushed() const { return m_bPushed; }
	BOOL IsHighlighted() const { return m_bHighlighted; }
	BOOL IsCheckBox() const { return m_bCheckButton; }
	BOOL IsRadioButton() const { return m_bRadioButton; }
	BOOL IsAutoCheck() const { return m_bAutoCheck; }
	BOOL IsChecked() const { return  m_bChecked; }

protected:
	BOOL m_bPushed;
	BOOL m_bClickiedInside;
	BOOL m_bHighlighted;
	BOOL m_bCaptured;
	BOOL m_bHover;
	BOOL m_bChecked;
	BOOL m_bCheckButton;
	BOOL m_bRadioButton;
	BOOL m_bAutoCheck;
	BOOL m_bAutoDestroyImage;
	BOOL m_bFullTextTooltip;
	BOOL m_bDelayFullTextTooltipSet;
	int  m_nAutoRepeatTimeDelay;

	CSize m_sizeImage;
	CSize m_sizePushOffset;

	CMFCToolBarImages m_Image;
	CMFCToolBarImages m_ImageHot;
	CMFCToolBarImages m_ImageDisabled;
	CMFCToolBarImages m_ImageChecked;
	CMFCToolBarImages m_ImageCheckedHot;
	CMFCToolBarImages m_ImageCheckedDisabled;

	CMenuImages::IMAGES_IDS  m_nStdImageId;
	CMenuImages::IMAGES_IDS  m_nStdImageDisabledId;
	CMenuImages::IMAGE_STATE m_StdImageState;

	CToolTipCtrl* m_pToolTip;

	HFONT   m_hFont;
	HCURSOR m_hCursor;

	COLORREF m_clrRegular;
	COLORREF m_clrHover;
	COLORREF m_clrFace;

	AFX_IMPORT_DATA static BOOL m_bWinXPTheme;
	AFX_IMPORT_DATA static BOOL m_bWinXPThemeWasChecked;

// Operations
public:
	void SetImage(HICON hIcon, BOOL bAutoDestroy = TRUE, HICON hIconHot = NULL, HICON hIconDisabled = NULL, BOOL bAlphaBlend = FALSE);
	void SetImage(HBITMAP hBitmap, BOOL bAutoDestroy = TRUE, HBITMAP hBitmapHot = NULL, BOOL bMap3dColors = TRUE, HBITMAP hBitmapDisabled = NULL);
	void SetImage(UINT uiBmpResId, UINT uiBmpHotResId = 0, UINT uiBmpDsblResID = 0);

	void SetCheckedImage(HICON hIcon, BOOL bAutoDestroy = TRUE, HICON hIconHot = NULL, HICON hIconDisabled = NULL, BOOL bAlphaBlend = FALSE);
	void SetCheckedImage(HBITMAP hBitmap, BOOL bAutoDestroy = TRUE, HBITMAP hBitmapHot = NULL, BOOL bMap3dColors = TRUE, HBITMAP hBitmapDisabled = NULL);
	void SetCheckedImage(UINT uiBmpResId, UINT uiBmpHotResId = 0, UINT uiBmpDsblResID = 0);

	void SetStdImage(CMenuImages::IMAGES_IDS id, CMenuImages::IMAGE_STATE state = CMenuImages::ImageBlack, CMenuImages::IMAGES_IDS idDisabled = (CMenuImages::IMAGES_IDS) 0);

	void SetTooltip(LPCTSTR lpszToolTipText); // lpszToolTip == NULL: disable tooltip

	void SetMouseCursor(HCURSOR hcursor);
	void SetMouseCursorHand();

	void SetTextColor(COLORREF clrText) { m_clrRegular = clrText; }
	void SetTextHotColor(COLORREF clrTextHot) { m_clrHover = clrTextHot; }

	void SetFaceColor(COLORREF crFace, BOOL bRedraw = TRUE);

	void EnableMenuFont(BOOL bOn = TRUE, BOOL bRedraw = TRUE);
	void EnableFullTextTooltip(BOOL bOn = TRUE);

	void SetAutorepeatMode(int nTimeDelay = 500 /* ms */);
	BOOL IsAutorepeatCommandMode() const { return m_nAutoRepeatTimeDelay > 0; }

	// Allow to draw button borders using current WinXP theme.
	// CMFCVisualManagerWindows should be active visual manager:
	static void __stdcall EnableWindowsTheming(BOOL bEnable = TRUE);
	static BOOL __stdcall IsWindowsThemingEnabled() { return m_bWinXPTheme; }

// Overrides
public:
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual HRESULT get_accState(VARIANT varChild, VARIANT *pvarState);

protected:
	virtual void PreSubclassWindow();
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

// Implementation
public:
	virtual ~CMFCButton();
	virtual void CleanUp();

	virtual CSize SizeToContent(BOOL bCalcOnly = FALSE);
	virtual void OnDrawParentBackground(CDC* pDC, CRect rectClient);

protected:
	virtual void OnFillBackground(CDC* pDC, const CRect& rectClient);
	virtual void OnDrawBorder(CDC* pDC, CRect& rectClient, UINT uiState);
	virtual void OnDrawFocusRect(CDC* pDC, const CRect& rectClient);
	virtual void OnDraw(CDC* pDC, const CRect& rect, UINT uiState);

	virtual void OnDrawText(CDC* pDC, const CRect& rect, const CString& strText, UINT uiDTFlags, UINT uiState);

	virtual CFont* SelectFont(CDC* pDC);

	virtual int GetImageHorzMargin() const;
	virtual int GetVertMargin() const;

protected:
	//{{AFX_MSG(CMFCButton)
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnCancelMode();
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnEnable(BOOL bEnable);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnTimer(UINT_PTR nIDEvent);
	afx_msg void OnDestroy();
	afx_msg LRESULT OnSetFont(WPARAM, LPARAM);
	afx_msg LRESULT OnGetFont(WPARAM, LPARAM);
	afx_msg LRESULT OnGetCheck(WPARAM, LPARAM);
	afx_msg LRESULT OnSetCheck(WPARAM, LPARAM);
	afx_msg LRESULT OnSetImage(WPARAM, LPARAM);
	afx_msg LRESULT OnGetImage(WPARAM, LPARAM);
	afx_msg LRESULT OnUpdateToolTips(WPARAM, LPARAM);
	afx_msg LRESULT OnInitControl(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

	void InitStyle(DWORD dwStyle);

	BOOL CheckNextPrevRadioButton(BOOL bNext);
	void UncheckRadioButtonsInGroup();

	void SetImageInternal(HICON hIcon, BOOL bAutoDestroy, HICON hIconHot, BOOL bChecked, HICON hIconDisabled = NULL, BOOL bAlphaBlend = FALSE);
	void SetImageInternal(HBITMAP hBitmap, BOOL bAutoDestroy, HBITMAP hBitmapHot, BOOL bMap3dColors, BOOL bChecked, HBITMAP hBitmapDisabled = NULL);
	void SetImageInternal(UINT uiBmpResId, UINT uiBmpHotResId, BOOL bChecked, UINT uiBmpDsblResId = 0);

	void ClearImages(BOOL bChecked);
	void DrawBorder(CDC* pDC, CRect& rectClient, UINT uiState);
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxcaptionbutton.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxmenuimages.h"
#include "afxvisualmanager.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#define AFX_HTCLOSE       HTOBJECT	// To prevent standard Windows 98/2000 close tooltip
#define AFX_HTLEFTBUTTON  HTHELP + 2
#define AFX_HTRIGHTBUTTON HTHELP + 3
#define AFX_HTMENU        HTHELP + 4
#define AFX_HTMAXBUTTON   HTHELP + 5
#define AFX_HTMINBUTTON   HTHELP + 6

class CMFCCaptionButton : public CObject
{
public:
	CMFCCaptionButton();
	CMFCCaptionButton(UINT nHit, BOOL bLeftAlign = FALSE);
	virtual ~CMFCCaptionButton();

	void Move (const CPoint& ptTo, BOOL bHide = FALSE)
	{
		m_ptOrg = ptTo;
		m_bHidden = bHide;
	}

	virtual CRect GetRect () const
	{
		return CRect (m_ptOrg, m_bHidden ? CSize (0, 0) : GetSize ());
	}

	static CSize __stdcall GetSize ()
	{
		return CMenuImages::Size () + CSize (2 * m_nButtonMargin, 2 * m_nButtonMarginVert) +
			CMFCVisualManager::GetInstance ()->GetCaptionButtonExtraBorder ();
	}

	virtual void OnDraw (CDC* pDC, BOOL bActive, BOOL bHorz = TRUE, BOOL bMaximized = TRUE, BOOL bDisabled = FALSE);

	UINT GetHit () const;

	virtual CMenuImages::IMAGES_IDS GetIconID (BOOL bHorz, BOOL bMaximized = FALSE) const;

	void SetMiniFrameButton (BOOL bSet = TRUE) { m_bIsMiniFrameButton = bSet; }
	BOOL IsMiniFrameButton () const { return m_bIsMiniFrameButton; }

	BOOL m_bPushed;
	BOOL m_bFocused;
	BOOL m_bHidden;
	BOOL m_bEnabled;
	BOOL m_bDroppedDown;
	BOOL m_bLeftAlign;
	UINT m_nHit;

	COLORREF m_clrForeground;

	AFX_IMPORT_DATA static int m_nButtonMargin;
	AFX_IMPORT_DATA static int m_nButtonMarginVert;

protected:
	CPoint m_ptOrg;
	BOOL   m_bIsMiniFrameButton;
};

class CMFCCaptionButtonEx : public CMFCCaptionButton
{
public:
	CMFCCaptionButtonEx (UINT nHit);
	~CMFCCaptionButtonEx();

	void SetRect (const CRect& rect) { m_rect = rect; }
	virtual CRect GetRect () const { return m_rect; }

protected:
	CRect m_rect;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxbasetoolbar.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxpane.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCBaseToolBar window

class CMFCBaseToolBar : public CPane
{
	DECLARE_DYNCREATE(CMFCBaseToolBar)

// Construction
public:
	CMFCBaseToolBar();

// Attributes
public:
	virtual AFX_DOCK_TYPE GetDockingMode() const { return DT_IMMEDIATE; }

// Operations
public:

	virtual void OnAfterChangeParent(CWnd* pWndOldParent);
	virtual void GetMinSize(CSize& size) const  
	{
		if (IsHorizontal())
		{
			size.cx = 40; size.cy = 16;
		}
		else
		{
			size.cy = 40; size.cx = 16;
		}
	}

// Implementation
public:
	virtual ~CMFCBaseToolBar();

protected:
	//{{AFX_MSG(CMFCBaseToolBar)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	virtual void OnAfterStretch(int nStretchSize);
	virtual BOOL OnShowControlBarMenu(CPoint /*point*/) { return FALSE; }
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxcaptionmenubutton.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxcaptionbutton.h"
#include "afxmenuimages.h"
#include "afxvisualmanager.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCCaptionMenuButton : public CMFCCaptionButton
{
public:
	CMFCCaptionMenuButton();
	CMFCCaptionMenuButton(UINT nHit, BOOL bLeftAlign = FALSE);
	virtual ~CMFCCaptionMenuButton();

// Attributes
public:
	int  m_nMenuResult;
	BOOL m_bOSMenu;       // User standard Windows menu either than library
	BOOL m_bMenuIsActive;

// Operations
public:
	void ShowMenu(HMENU hMenu, CWnd* pWnd);
	virtual void OnDraw(CDC* pDC, BOOL bActive, BOOL bHorz = TRUE, BOOL bMaximized = TRUE, BOOL bDisabled = FALSE);
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxcmdusagecount.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCCmdUsageCount : public CObject
{
public:
	CMFCCmdUsageCount();
	virtual ~CMFCCmdUsageCount();

	virtual void Serialize(CArchive& ar);

	void AddCmd(UINT uiCmd);
	void Reset();

	UINT GetCount(UINT uiCmd) const;
	BOOL HasEnoughInformation() const;

	BOOL IsFreqeuntlyUsedCmd(UINT uiCmd) const;

	static BOOL __stdcall SetOptions(UINT nStartCount, UINT nMinUsagePercentage);

protected:
	CMap<UINT, UINT, UINT, UINT> m_CmdUsage;
	UINT                         m_nTotalUsage;

	AFX_IMPORT_DATA static UINT m_nStartCount;
	AFX_IMPORT_DATA static UINT m_nMinUsagePercentage;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxcmn.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXCMN_H__
#define __AFXCMN_H__

#ifdef _AFX_NO_AFXCMN_SUPPORT
	#error Windows Common Control classes not supported in this library variant.
#endif

#ifndef __AFXWIN_H__
	#include <afxwin.h>
#endif

#pragma once

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifndef IMAGE_BITMAP
#define IMAGE_BITMAP 0
#endif

#ifndef HDSIL_NORMAL
#define HDSIL_NORMAL 0
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#if (_WIN32_WINNT >= 0x0501)
	#include <uxtheme.h>
#endif	// _WIN32_WINNT >= 0x0501

#ifndef _AFX_NO_RICHEDIT_SUPPORT
	#ifndef _RICHEDIT_
		#include <richedit.h>
	#endif
	#ifdef __AFXOLE_H__  // only include richole if OLE support is included
		#ifndef _RICHOLE_
			#include <richole.h>
			#define _RICHOLE_
		#endif
	#else
		struct IRichEditOle;
		struct IRichEditOleCallback;
	#endif
#endif

#ifdef _AFX_ALL_WARNINGS
#pragma warning(push)
#endif

#pragma warning(disable: 4263 4264)  // base class method is hidden

/////////////////////////////////////////////////////////////////////////////
// AFXCMN - MFC COMCTL32 Control Classes

// Classes declared in this file

//TOOLINFO
	class CToolInfo;

//CObject
	//CCmdTarget;
		//CWnd
			// class CListBox;
				class CDragListBox;
			class CStatusBarCtrl;
			class CListCtrl;
			class CTreeCtrl;
			class CSpinButtonCtrl;
			class CSliderCtrl;
			class CProgressCtrl;
			// class CComboBox;
				class CComboBoxEx;
			class CHeaderCtrl;
			class CHotKeyCtrl;
			class CToolTipCtrl;
			class CTabCtrl;
			class CAnimateCtrl;
			class CToolBarCtrl;
			class CReBarCtrl;
			class CRichEditCtrl;
			class CIPAddressCtrl;
			class CPagerCtrl;
			class CLinkCtrl;

#if (NTDDI_VERSION >= NTDDI_LONGHORN) && defined(UNICODE)
			class CNetAddressCtrl;
#endif

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

/////////////////////////////////////////////////////////////////////////////
// CToolInfo

#ifdef _UNICODE
class CToolInfo : public tagTOOLINFOW
#else
class CToolInfo : public tagTOOLINFOA
#endif
{
public:
	TCHAR szText[256];
};

/////////////////////////////////////////////////////////////////////////////
// CDragListBox

class CDragListBox : public CListBox
{
	DECLARE_DYNAMIC(CDragListBox)

// Constructors
public:
	CDragListBox();

// Attributes

	// find item index at given point
	int ItemFromPt(_In_ CPoint pt, _In_ BOOL bAutoScroll = TRUE) const;

// Operations

	// draws insertion line
	virtual void DrawInsert(_In_ int nItem);

// Overridables

	// Override to respond to beginning of drag event.
	virtual BOOL BeginDrag(_In_ CPoint pt);

	// Overrdie to react to user cancelling drag.
	virtual void CancelDrag(_In_ CPoint pt);

	// Called as user drags. Return constant indicating cursor.
	virtual UINT Dragging(_In_ CPoint pt);

	// Called when user releases mouse button to end drag event.
	virtual void Dropped(_In_ int nSrcIndex, _In_ CPoint pt);

// Implementation
public:
	int m_nLast;
	void DrawSingle(_In_ int nIndex);
	virtual void PreSubclassWindow();
	virtual ~CDragListBox();

protected:
	virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);
};

/////////////////////////////////////////////////////////////////////////////
// CStatusBarCtrl

// NOTE: This class must remain a binary-compatible subset
// of CStatusBar. Do not add data members or virtual functions
// directly to this class.
class CStatusBarCtrl : public CWnd
{
	// DECLARE_DYNAMIC virtual OK here - CWnd has DECLARE_DYNAMIC
	DECLARE_DYNAMIC(CStatusBarCtrl)

// Constructors
public:
	CStatusBarCtrl();

	// Generic creator
	BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes

	// Sets text in a particular pane.
	BOOL SetText(_In_z_ LPCTSTR lpszText, _In_ int nPane, _In_ int nType);

	// Retrieves text from a particular pane.
	CString GetText(_In_ int nPane, _In_ int* pType = NULL) const;
	int GetText(_Pre_notnull_ _Post_z_ LPTSTR lpszText, _In_ int nPane, _Out_ int* pType = NULL) const;

	// Gets the legnth of text in a particular pane without
	// retreiving the actual text.
	int GetTextLength(_In_ int nPane, _Out_ int* pType = NULL) const;

	// Sets size of individual panes within the control.
	BOOL SetParts(_In_ int nParts, _In_ int* pWidths);

	// Returns sizes of each pane within the control.
	int GetParts(_In_ int nParts, _Out_ int* pParts) const;

	// Get sizes of all borders in on control.
	BOOL GetBorders(_Out_ int* pBorders) const;
	BOOL GetBorders(_Out_ int& nHorz, _Out_ int& nVert, _Out_ int& nSpacing) const;

	// Sets the minimum allowable height for the control.
	void SetMinHeight(_In_ int nMin);

	// Sets the control to have one single pane and no subdivisions.
	BOOL SetSimple(_In_ BOOL bSimple = TRUE);

	// Gets the bounding rectangle of a specific pane.
	BOOL GetRect(_In_ int nPane, _Out_ LPRECT lpRect) const;

	// Determines if the control has one single pane.
	BOOL IsSimple() const;

	// Returns tooltip text for the given pane.
	CString GetTipText(_In_ int nPane) const;

	// Sets tooltip text for the given pane.
	void SetTipText(_In_ int nPane, _In_z_ LPCTSTR pszTipText);

	// Sets background color for all panes in the control.
	COLORREF SetBkColor(_In_ COLORREF cr);

	// Sets icon for the given part.
	BOOL SetIcon(_In_ int iPart, _In_ HICON hIcon);

	// Retrieves icon for the given part.
	HICON GetIcon(_In_ int iPart) const;

// Overridables
	// Override to perform owner draw. Control must
	// have the owner draw style.
	virtual void DrawItem(_In_ LPDRAWITEMSTRUCT lpDrawItemStruct);

// Implementation
public:
	// virtual OK here - ~CWnd is virtual
	virtual ~CStatusBarCtrl();
protected:
	// virtual OK here - CWnd makes this virtual
	virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);
};

/////////////////////////////////////////////////////////////////////////////
// CListCtrl

// NOTE: This class must remain a binary-compatible subset
// of CListView. Do not add data members or virtual functions
// directly to this class.
class CListCtrl : public CWnd
{
	// DECLARE_DYNAMIC virtual is OK here - CWnd has DECLARE_DYNAMIC
	DECLARE_DYNAMIC(CListCtrl)

// Constructors
public:
	CListCtrl();

	// Generic creator
	BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
	// Retrieves the background color for the control.
	COLORREF GetBkColor() const;

	// Sets background color for the control.
	BOOL SetBkColor(_In_ COLORREF cr);

	// Retrieves the image list associated with the control.
	CImageList* GetImageList(_In_ int nImageList) const;

	// Sets the image list associated with this control.
	CImageList* SetImageList(_In_ CImageList* pImageList, _In_ int nImageList);

	// Retrieves the tool tip control associated with this control.
	CToolTipCtrl* GetToolTips() const;

	// Sets the tool tip control to be used by this control.
	CToolTipCtrl* SetToolTips(_In_ CToolTipCtrl* pWndTip);

	// Retrieves the number of items in the control.
	int GetItemCount() const;

	// Retrieves a description of a particular item in the control.
	BOOL GetItem(_Out_ LVITEM* pItem) const;

	// Sets information to an existing item in the control.
	BOOL SetItem(_In_ const LVITEM* pItem);
	BOOL SetItem(_In_ int nItem, _In_ int nSubItem, _In_ UINT nMask, _In_opt_z_ LPCTSTR lpszItem,
		_In_ int nImage, _In_ UINT nState, _In_ UINT nStateMask, _In_ LPARAM lParam);
	BOOL SetItem(_In_ int nItem, _In_ int nSubItem, _In_ UINT nMask, _In_opt_z_ LPCTSTR lpszItem,
		_In_ int nImage, _In_ UINT nState, _In_ UINT nStateMask, _In_ LPARAM lParam, _In_ int nIndent);

	// Determines which item attributes are maintained by the application
	// instead of the control itself.
	UINT GetCallbackMask() const;

	// Specifies which item attributes are maintained by the application
	// instead of the control itself.
	BOOL SetCallbackMask(_In_ UINT nMask);

	// Get the next item after nItem matching flags in nFlags.
	int GetNextItem(_In_ int nItem, _In_ int nFlags) const;

	// Gets first item selected in the control and prepares for
	// finding other selected items (if the control has the multiple
	// selection style).
	POSITION GetFirstSelectedItemPosition() const;

	// Finds the next selected item, after a previous call
	// to GetFirstSelectedItemPosition().
	int GetNextSelectedItem(_Inout_ POSITION& pos) const;

	// Retrieves the bounding rectangle for a particular item.
	BOOL GetItemRect(_In_ int nItem, _Out_ LPRECT lpRect, _In_ UINT nCode) const;

	// Find the location of a particular item in the control,
	// relative to the control's client area.
	BOOL SetItemPosition(_In_ int nItem, _In_ POINT pt);
	BOOL GetItemPosition(_In_ int nItem, _Out_ LPPOINT lpPoint) const;

	// Determines the width of a string as displayed in report mode.
	int GetStringWidth(_In_z_ LPCTSTR lpsz) const;

	// Retrieves the edit control associated with the currently edited
	// item in the control.
	CEdit* GetEditControl() const;

	// Retrieves information about a column in a report-mode control.
	BOOL GetColumn(_In_ int nCol, _Out_ LVCOLUMN* pColumn) const;

	// Sets information about a column in a report-mode control.
	BOOL SetColumn(_In_ int nCol, _In_ const LVCOLUMN* pColumn);

	// Retrieves the width of a column in a report-mode control.
	int GetColumnWidth(_In_ int nCol) const;

	// Sets the width of a column in a report-mode control.
	BOOL SetColumnWidth(_In_ int nCol, _In_ int cx);

	BOOL GetViewRect(_Out_ LPRECT lpRect) const;

	// Retrieves foreground color of text labels in the control.
	COLORREF GetTextColor() const;

	// Sets foreground color of text labels in the control.
	BOOL SetTextColor(_In_ COLORREF cr);

	// Retrieves background color of text labels in the control.
	COLORREF GetTextBkColor() const;

	// Sets background color of text labels in the control.
	BOOL SetTextBkColor(_In_ COLORREF cr);

	// Retrieves the index of the topmost visible item in the control.
	int GetTopIndex() const;

	// Retrieves the number of items displayed at one time
	// the control's client area.
	int GetCountPerPage() const;

	// Retrieves the current origin of the client area.
	BOOL GetOrigin(_Out_ LPPOINT lpPoint) const;

	// Sets the state of a particular item.
	BOOL SetItemState(_In_ int nItem, _In_ LVITEM* pItem);
	BOOL SetItemState(_In_ int nItem, _In_ UINT nState, _In_ UINT nMask);

	// Retrieves the state of a particular item.
	UINT GetItemState(_In_ int nItem, _In_ UINT nMask) const;

	// Retrieves the text associated with a particular item.
	CString GetItemText(_In_ int nItem, _In_ int nSubItem) const;
	int GetItemText(_In_ int nItem, _In_ int nSubItem, _Out_z_cap_post_count_(nLen, return + 1) LPTSTR lpszText, _In_ int nLen) const;

	// Sets the text associated with a particular item.
	BOOL SetItemText(_In_ int nItem, _In_ int nSubItem, _In_z_ LPCTSTR lpszText);

	// Sets the count of items in the control. The control will use
	// this value to preallocate memory for its own storage; you may
	// exceed the item count at any time, but accurate preallocation
	// can help performance.
	void SetItemCount(_In_ int nItems);

	// Sets the data (lParam) associated with a particular item.
	BOOL SetItemData(_In_ int nItem, _In_ DWORD_PTR dwData);

	// Retrieves the data (lParam) associated with a particular item.
	DWORD_PTR GetItemData(_In_ int nItem) const;

	// Retrieves the number of selected items in the control.
	UINT GetSelectedCount() const;

	// Retrieves the spacing between items in the control.
	BOOL GetItemSpacing(_In_ BOOL fSmall, _Out_ int* pnHorzSpacing, _Out_ int* pnVertSpacing) const;

	BOOL SetColumnOrderArray(_In_ int iCount, _In_ LPINT piArray);
	BOOL GetColumnOrderArray(_Out_ LPINT piArray, _In_ int iCount = -1) const;

	// Sets minimum spacing of items in the icon view.
	CSize SetIconSpacing(_In_ CSize size);
	CSize SetIconSpacing(_In_ int cx, _In_ int cy);

	// Retrieves a reference to the header control in
	// a report-mode control.
	CHeaderCtrl* GetHeaderCtrl() const;

	// Retrieves the cursor used over hot items. (Only valid for
	// controls with the LVS_EX_TRACKSELECT style.)
	HCURSOR GetHotCursor() const;

	// Sets cursor to be used over hot items. (Only used in controls
	// with the LVS_EX_TRACKSELECT style.)
	HCURSOR SetHotCursor(_In_ HCURSOR hc);

	BOOL GetSubItemRect(_In_ int iItem, _In_ int iSubItem, _In_ int nArea, _Out_ CRect& ref) const;

	// Retrieves the item currently hot-selected, or -1 if none.
	int GetHotItem() const;

	// Sets the item to be currently hot-selected.
	int SetHotItem(_In_ int iIndex);

	// Retrieves the item with the selection mark, or -1 if none.
	int GetSelectionMark() const;

	// Sets the item with the selection mark.
	int SetSelectionMark(_In_ int iIndex);

	// Retrieves the control-specific extended style bits.
	DWORD GetExtendedStyle() const;

	// Sets the control-specific extended style bits.
	DWORD SetExtendedStyle(_In_ DWORD dwNewStyle);

	// Determines the visual feature of a subitem control under
	// the specified point.
	int SubItemHitTest(_In_ LPLVHITTESTINFO pInfo);

	// Sets up virtual work areas within the control.
	void SetWorkAreas(_In_ int nWorkAreas, _In_ LPRECT lpRect);

	// Updates expected item count for a virtual control.
	BOOL SetItemCountEx(_In_ int iCount, _In_ DWORD dwFlags = LVSICF_NOINVALIDATEALL);

	// Calculates the approximate minimum size required to
	// display the passed number of items.
	CSize ApproximateViewRect(_In_ CSize sz = CSize(-1, -1),
		int iCount = -1) const;

	// Retrieves information about the background image in the control.
	BOOL GetBkImage(_Out_ LVBKIMAGE* plvbkImage) const;

	// Retrieves the delay (in milliseconds) for the mouse to hover
	// over an item before it is selected.
	DWORD GetHoverTime() const;

	// Retrieves the rectangles defining the workareas in the control.
	void GetWorkAreas(_In_ int nWorkAreas, _Out_ LPRECT prc) const;

	// Sets the image used in the background of the control.
   BOOL SetBkImage(_In_ HBITMAP hbm, _In_ BOOL fTile = TRUE,
		_In_ int xOffsetPercent = 0, _In_ int yOffsetPercent = 0);
   BOOL SetBkImage(_In_z_ LPTSTR pszUrl, _In_ BOOL fTile = TRUE,
		_In_ int xOffsetPercent = 0, _In_ int yOffsetPercent = 0);
   BOOL SetBkImage(_In_ LVBKIMAGE* plvbkImage);

	// Sets the delay (in milliseconds) for the mouse to hover
	// over an item before it is selected.
	DWORD SetHoverTime(_In_ DWORD dwHoverTime = (DWORD)-1);

	// Returns the number of work areas in the control.
	UINT GetNumberOfWorkAreas() const;

	// Retrieves the checked state of a particular item. Only useful
	// on controls with the LVS_EX_CHECKBOXES style.
	BOOL GetCheck(_In_ int nItem) const;

	// Sets the checked state of a particular item. Only useful
	// on controls with the LVS_EX_CHECKBOXES style.
	BOOL SetCheck(_In_ int nItem, _In_ BOOL fCheck = TRUE);

// Operations

	// Adds an item to the control.
	int InsertItem(_In_ const LVITEM* pItem);
	int InsertItem(_In_ int nItem, _In_z_ LPCTSTR lpszItem);
	int InsertItem(_In_ int nItem, _In_z_ LPCTSTR lpszItem, _In_ int nImage);

	// Removes a single item from the control.
	BOOL DeleteItem(_In_ int nItem);

	// Removes all items from the control.
	BOOL DeleteAllItems();

	// Finds an item in the control matching the specified criteria.
	int FindItem(_In_ LVFINDINFO* pFindInfo, _In_ int nStart = -1) const;

	// Determines the visual feature of the control under
	// the specified point.
	int HitTest(_In_ LVHITTESTINFO* pHitTestInfo) const;
	int HitTest(_In_ CPoint pt, _In_opt_ UINT* pFlags = NULL) const;

	// Causes the control to scroll its content so the specified item
	// is completely (or at least partially, depending on the
	// bPartialOK parameter) visible.
	BOOL EnsureVisible(_In_ int nItem, _In_ BOOL bPartialOK);

	// Forces the control to scroll its client area
	// by the specified amount.
	BOOL Scroll(_In_ CSize size);

	// Forces the control to repaint a specific range of items.
	BOOL RedrawItems(_In_ int nFirst, _In_ int nLast);

	// Causes the control to rearrange items within its client area.
	BOOL Arrange(_In_ UINT nCode);

	// Causes the control to enter edit mode on the speficied item.
	CEdit* EditLabel(_In_ int nItem);

	// Inserts a column into a report-mode control.
	int InsertColumn(_In_ int nCol, _In_ const LVCOLUMN* pColumn);
	int InsertColumn(_In_ int nCol, _In_z_ LPCTSTR lpszColumnHeading,
		_In_ int nFormat = LVCFMT_LEFT, _In_ int nWidth = -1, _In_ int nSubItem = -1);

	// Deletes a column from a report-mode control.
	BOOL DeleteColumn(_In_ int nCol);

	// Creates a drag-time image from a particular item in the control.
	CImageList* CreateDragImage(_In_ int nItem, _In_ LPPOINT lpPoint);

	// Forces the control to repaint a specific item.
	BOOL Update(_In_ int nItem);

	// Call to sort items using a custom comparison function.
	BOOL SortItems(_In_ PFNLVCOMPARE pfnCompare, _In_ DWORD_PTR dwData);
	BOOL SortItemsEx(_In_ PFNLVCOMPARE pfnCompare, _In_ DWORD_PTR dwData);

#if (_WIN32_WINNT >= 0x0501)

	// Sets the selected column in a report-mode control.
	AFX_ANSI_DEPRECATED void SetSelectedColumn(_In_ int iCol);

	AFX_ANSI_DEPRECATED DWORD SetView(_In_ int iView);
	AFX_ANSI_DEPRECATED DWORD GetView() const;

	// Adds a group to the control.
	AFX_ANSI_DEPRECATED int InsertGroup(_In_ int index, _In_ PLVGROUP pgrp);

	// Sets information about the specified group (by ID) in the control.
	AFX_ANSI_DEPRECATED int SetGroupInfo(_In_ int iGroupId, _In_ PLVGROUP pGroup);

	// Retrieves information for the specified group in the control.
	AFX_ANSI_DEPRECATED int GetGroupInfo(_In_ int iGroupId, _Out_ PLVGROUP pgrp) const;

	// Removes a group from the control.
	AFX_ANSI_DEPRECATED int RemoveGroup(_In_ int iGroupId);

	// Moves a group in the control.
	AFX_ANSI_DEPRECATED void MoveGroup(_In_ int iGroupId, _In_ int toIndex);

	// Moves an item to a different group in the control.
	AFX_ANSI_DEPRECATED void MoveItemToGroup(_In_ int idItemFrom, _In_ int idGroupTo);

	// Sets group metric information to a group in the control.
	AFX_ANSI_DEPRECATED void SetGroupMetrics(_In_ PLVGROUPMETRICS pGroupMetrics);

	// Retrieves group metric information for a group in the control.
	AFX_ANSI_DEPRECATED void GetGroupMetrics(_Out_ PLVGROUPMETRICS pGroupMetrics) const;

	// Enables group view in the control.
	AFX_ANSI_DEPRECATED int EnableGroupView(_In_ BOOL fEnable);

	// Uses an application-defined comparison function to sort groups by ID within the list-view control.
	AFX_ANSI_DEPRECATED BOOL SortGroups(_In_ PFNLVGROUPCOMPARE _pfnGroupCompare, _In_ LPVOID _plv);

	// Inserts a group into an ordered list of groups in the control.
	AFX_ANSI_DEPRECATED void InsertGroupSorted(_In_ PLVINSERTGROUPSORTED pStructInsert);

	// Removes all groups from the control.
	AFX_ANSI_DEPRECATED void RemoveAllGroups();

	// Determines if the control has a group with the specified ID.
	AFX_ANSI_DEPRECATED BOOL HasGroup(_In_ int iGroupId) const;

	// Sets information that the list-view control uses in tile view.
	AFX_ANSI_DEPRECATED BOOL SetTileViewInfo(_In_ PLVTILEVIEWINFO ptvi);

	// Retrieves information about the list-view control in tile view.
	AFX_ANSI_DEPRECATED BOOL GetTileViewInfo(_Out_ PLVTILEVIEWINFO ptvi) const;

	// Sets information for a tile of the list-view control.
	AFX_ANSI_DEPRECATED BOOL SetTileInfo(_In_ PLVTILEINFO pti);

	// Retrieves information about a tile in the list-view control.
	AFX_ANSI_DEPRECATED BOOL GetTileInfo(_Out_ PLVTILEINFO pti) const;

	// Sets the insertion point in the control to the defined position.
	AFX_ANSI_DEPRECATED BOOL SetInsertMark(_In_ LPLVINSERTMARK lvim);

	// Retrieves the position of the insertion point in the control.
	AFX_ANSI_DEPRECATED BOOL GetInsertMark(_Out_ LPLVINSERTMARK lvim) const;

	// Retrieves the insertion point closest to a specified point.
	AFX_ANSI_DEPRECATED int InsertMarkHitTest(_In_ LPPOINT pPoint, _In_ LPLVINSERTMARK lvim) const;

	// Retrieves the rectangle that bounds the insertion point in the control.
	AFX_ANSI_DEPRECATED int GetInsertMarkRect(_Out_ LPRECT pRect) const;

	// Sets the color of the insertion point in the control.
	AFX_ANSI_DEPRECATED COLORREF SetInsertMarkColor(_In_ COLORREF color);

	// Retrieves the color of the insertion point in the control.
	AFX_ANSI_DEPRECATED COLORREF GetInsertMarkColor() const;

	// Sets ToolTip text for the control.
	AFX_ANSI_DEPRECATED BOOL SetInfoTip(_In_ PLVSETINFOTIP plvInfoTip);

	// Retrieves the selected column in a report-mode control.
	AFX_ANSI_DEPRECATED UINT GetSelectedColumn() const;

	// Determines if group view is enabled for the control.
	AFX_ANSI_DEPRECATED BOOL IsGroupViewEnabled() const;

	// Retrieves the color of the border of the list-view control.
	AFX_ANSI_DEPRECATED COLORREF GetOutlineColor() const;

	// Sets the color of the border of the list-view control.
	AFX_ANSI_DEPRECATED COLORREF SetOutlineColor(_In_ COLORREF color);

	// Cancels an item text editing operation in the control.
	AFX_ANSI_DEPRECATED void CancelEditLabel();

#endif	// _WIN32_WINNT >= 0x0501

#if (_WIN32_WINNT >= 0x0600) && defined(UNICODE)
	// REVIEW: Retrieves the string displayed when the list-view is empty.
	CString GetEmptyText() const;

	// REVIEW: Retrieves the rectangle for the specified item in the list-view (by group/item index).
	BOOL GetItemIndexRect(_In_ PLVITEMINDEX pItemIndex, _In_ int iColumn, _In_ int rectType, _Out_ LPRECT pRect) const;

	// REVIEW: Sets state for the specified item in the list-view (by group/item index).
	HRESULT SetItemIndexState(_In_ PLVITEMINDEX pItemIndex, _In_ DWORD dwState, _In_ DWORD dwMask);

	// REVIEW: Retrieves the next item in the list-view (by group/item index) based on the flags.
	BOOL GetNextItemIndex(_In_ PLVITEMINDEX pItemIndex, _In_ int nFlags) const;
	
	// Retrieves the number of groups in the control.
	int GetGroupCount() const;
	
	// REVIEW: Retrieves information about the specified group (by index) in the control.
	BOOL GetGroupInfoByIndex(_In_ int iIndex, _Out_ PLVGROUP pGroup) const;

	// Sets state information to the specified group in the control.
	void SetGroupState(_In_ int iGroupId, _In_ DWORD dwMask, _In_ DWORD dwState);

	// Retrieves state information for the specified group in the control.
	UINT GetGroupState(_In_ int iGroupId, _In_ DWORD dwMask) const;

	// REVIEW: Gets the group that has the focus in the control.
	int GetFocusedGroup() const;

	// REVIEW: Gets the rectangle for the specified group in the control.
	BOOL GetGroupRect(_In_ int iGroupId, _Out_ LPRECT lpRect, _In_ int iType = LVGGR_GROUP) const;

	// Maps the index of an item in the control to a unique ID.
	UINT MapIndexToID(_In_ UINT index) const;

	// Maps the unique ID of an item in the control to an index.
	UINT MapIDToIndex(_In_ UINT id) const;
	
	// Indicates if an item in the list-view control is visible.
	BOOL IsItemVisible(_In_ int index) const;

#endif	// _WIN32_WINNT >= 0x0600 && defined(UNICODE)

// Overridables
	// Override to perform owner draw. Control must
	// have the owner draw style.
	virtual void DrawItem(_In_ LPDRAWITEMSTRUCT lpDrawItemStruct);

// Implementation
public:
	int InsertItem(_In_ UINT nMask, _In_ int nItem, _In_z_ LPCTSTR lpszItem, _In_ UINT nState,
		_In_ UINT nStateMask, _In_ int nImage, _In_ LPARAM lParam);
	// virtual OK here - ~CWnd is virtual
	virtual ~CListCtrl();
protected:
	void RemoveImageList(_In_ int nImageList);
	// virtual OK here - CWnd makes this virtual
	virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);
protected:
	//{{AFX_MSG(CListCtrl)
	afx_msg void OnNcDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CTreeCtrl

// NOTE: This class must remain a binary-compatible subset
// of CTreeView. Do not add data members or virtual functions
// directly to this class.
class CTreeCtrl : public CWnd
{
	// DECLARE_DYNAMIC virtual OK - CWnd has DECLARE_DYNAMIC
	DECLARE_DYNAMIC(CTreeCtrl)

// Constructors
public:
	CTreeCtrl();

	// Generic creator
	BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes

	// Retrieves the bounding rectangle for the specified item.
	BOOL GetItemRect(_In_ HTREEITEM hItem, _Out_ LPRECT lpRect, _In_ BOOL bTextOnly) const;

	// Gets the count of items in the control.
	UINT GetCount() const;

	// Returns the level-to-level indentation (in pixels).
	UINT GetIndent() const;

	// Sets the level-to-level indentation (in pixels).
	void SetIndent(_In_ UINT nIndent);

	// Retrieves the image list associated with the control.
	CImageList* GetImageList(_In_ int nImageList) const;

	// Sets the image list associated with this control.
	CImageList* SetImageList(_In_ CImageList* pImageList, _In_ int nImageList);

	// Retrieves the next item having the given relationship with the
	// specified item.
	HTREEITEM GetNextItem(_In_ HTREEITEM hItem, _In_ UINT nCode) const;

	// Retrieves the next child item after the specified item.
	HTREEITEM GetChildItem(_In_ HTREEITEM hItem) const;

	// Retrieves the next sibling item after the specified item.
	HTREEITEM GetNextSiblingItem(_In_ HTREEITEM hItem) const;

	// Retrieves the previous sibling item of the specified item.
	HTREEITEM GetPrevSiblingItem(_In_ HTREEITEM hItem) const;

	// Retrieves the parent of the specified item.
	HTREEITEM GetParentItem(_In_ HTREEITEM hItem) const;

	// Retrieves the topmost visible item in the control.
	HTREEITEM GetFirstVisibleItem() const;

	// Retrieves the next visible item after the specified item.
	HTREEITEM GetNextVisibleItem(_In_ HTREEITEM hItem) const;

	// Retrieves the previous visible item before the specified item.
	HTREEITEM GetPrevVisibleItem(_In_ HTREEITEM hItem) const;

	// Retrieves the last expanded item in the tree. This does not retrieve the last item visible in the tree-view window.
	HTREEITEM GetLastVisibleItem() const;

	// Retrieves the higlighted item, NULL if none.
	HTREEITEM GetSelectedItem() const;

	// Retrieves the currently drop-highlighted item, NULL if none.
	HTREEITEM GetDropHilightItem() const;

	// Retrieves the root item of the control, NULL if none.
	HTREEITEM GetRootItem() const;

	// Retrieves information about a particular item in the control.
	BOOL GetItem(_Out_ TVITEM* pItem) const;

	// Retrieves the text associated with the given item.
	CString GetItemText(_In_ HTREEITEM hItem) const;

	// Retrieves the images associated with the given item.
	BOOL GetItemImage(_In_ HTREEITEM hItem, _Out_ int& nImage,
		_Out_ int& nSelectedImage) const;

	// Retrieves the state of the given item.
	UINT GetItemState(_In_ HTREEITEM hItem, _In_ UINT nStateMask) const;

	// Retrieves the user-supplied data associated with the given item.
	DWORD_PTR GetItemData(_In_ HTREEITEM hItem) const;

	// Sets the state of the an item.
	BOOL SetItem(_In_ TVITEM* pItem);
	BOOL SetItem(_In_ HTREEITEM hItem, _In_ UINT nMask, _In_opt_z_ LPCTSTR lpszItem, _In_ int nImage,
		_In_ int nSelectedImage, _In_ UINT nState, _In_ UINT nStateMask, _In_ LPARAM lParam);

#if (_WIN32_IE >= 0x0600)
	BOOL SetItemEx(_In_ HTREEITEM hItem, _In_ UINT nMask, _In_opt_z_ LPCTSTR lpszItem, _In_ int nImage,
		_In_ int nSelectedImage, _In_ UINT nState, _In_ UINT nStateMask, _In_ LPARAM lParam,
		_In_ UINT uStateEx, _In_opt_ HWND hWnd, _In_ int iExpandedImage);
#endif

	// Sets the text of the specified item.
	BOOL SetItemText(_In_ HTREEITEM hItem, _In_z_ LPCTSTR lpszItem);

	// Sets the image on the specified item.
	BOOL SetItemImage(_In_ HTREEITEM hItem, _In_ int nImage, _In_ int nSelectedImage);

	// Sets the state of the specified item.
	BOOL SetItemState(_In_ HTREEITEM hItem, _In_ UINT nState, _In_ UINT nStateMask);

	// Sets the user data on the specified item.
	BOOL SetItemData(_In_ HTREEITEM hItem, _In_ DWORD_PTR dwData);

	// Determines if the specified item has children.
	BOOL ItemHasChildren(_In_ HTREEITEM hItem) const;

	// Retrieves the edit control used to perform in-place editing.
	CEdit* GetEditControl() const;

	// Gets the count of items presently visible in the control.
	UINT GetVisibleCount() const;

	// Retrieves the tool tip control associated with this control.
	CToolTipCtrl* GetToolTips() const;

	// Sets the tool tip control to be used by this control.
	CToolTipCtrl* SetToolTips(_In_ CToolTipCtrl* pWndTip);

	// Retrieves the background colour used throughout the control.
	COLORREF GetBkColor() const;

	// Sets the background color to be used throughout the control.
	COLORREF SetBkColor(_In_ COLORREF clr);

	// Retrieves the height of items in the control.
	SHORT GetItemHeight() const;

	// Sets the height of items in the control.
	SHORT SetItemHeight(_In_ SHORT cyHeight);

	// Retrieves the text color used for all items in the control.
	COLORREF GetTextColor() const;

	// Sets the text color used for all items in the control.
	COLORREF SetTextColor(_In_ COLORREF clr);

	// Sets the insertion mark to the specified item in the control.
	BOOL SetInsertMark(_In_ HTREEITEM hItem, _In_ BOOL fAfter = TRUE);

	// Gets the checked state of the specified item in the control.
	// (Only useful on a control with the TVS_CHECKBOXES style.)
	BOOL GetCheck(_In_ HTREEITEM hItem) const;

	// Sets the checked state of the specified item in the control.
	// (Only useful on a control with the TVS_CHECKBOXES style.)
	BOOL SetCheck(_In_ HTREEITEM hItem, _In_ BOOL fCheck = TRUE);

	COLORREF GetInsertMarkColor() const;
	COLORREF SetInsertMarkColor(_In_ COLORREF clrNew);

	// Sets the maximum time (in milliseconds) the control will
	// spend smooth scrolling its content.
	UINT SetScrollTime(_In_ UINT uScrollTime);

	// Retrieves the maximum time (in milliseconds) the control will
	// spend smooth scrolling its content.
	UINT GetScrollTime() const;

#if _WIN32_IE >= 0x0500
	COLORREF GetLineColor() const;
	COLORREF SetLineColor(_In_ COLORREF clrNew = CLR_DEFAULT);
#endif

#if (_WIN32_IE >= 0x0600)
#endif

#if (_WIN32_WINNT >= 0x0501) && defined(UNICODE)
	// Maps treeview item id to accessibility identifier.
	UINT MapItemToAccId(HTREEITEM hItem) const;

	// Maps accessibility identifier id to treeview item.
	HTREEITEM MapAccIdToItem(UINT uAccId) const;

	// Set autoscrolling rate and delay (?).
	BOOL SetAutoscrollInfo(UINT uPixelsPerSec, UINT uUpdateTime);
#endif

#if (_WIN32_WINNT >= 0x0600) && defined(UNICODE)
	// Get count of selected items in the tree control.
	UINT GetSelectedCount();

	// Get rectangle for the specified part of the specified item.
	BOOL GetItemPartRect(HTREEITEM hItem, TVITEMPART nPart, LPRECT lpRect);

	// Get the extended state of the item
	UINT GetItemStateEx(HTREEITEM hItem) const;
	
	// Set the extended state of the item
	BOOL SetItemStateEx(HTREEITEM hItem, UINT uStateEx);

	// Get the expanded image index for the specified item
	int GetItemExpandedImageIndex(HTREEITEM hItem) const;
	
	// Set the expanded image index for the specified item
	BOOL SetItemExpandedImageIndex(HTREEITEM hItem, int nIndex);

	// Get extended styles for the tree control.
	DWORD GetExtendedStyle() const;

	// Set extended styles on the tree control.
	DWORD SetExtendedStyle(DWORD dwExMask, DWORD dwExStyles);
#endif

// Operations

	// Inserts a new item to the control.
	HTREEITEM InsertItem(_In_ LPTVINSERTSTRUCT lpInsertStruct);
	HTREEITEM InsertItem(_In_ UINT nMask, _In_z_ LPCTSTR lpszItem, _In_ int nImage,
		_In_ int nSelectedImage, _In_ UINT nState, _In_ UINT nStateMask, _In_ LPARAM lParam,
		_In_ HTREEITEM hParent, _In_ HTREEITEM hInsertAfter);
	HTREEITEM InsertItem(_In_z_ LPCTSTR lpszItem, _In_ HTREEITEM hParent = TVI_ROOT,
		_In_ HTREEITEM hInsertAfter = TVI_LAST);
	HTREEITEM InsertItem(_In_z_ LPCTSTR lpszItem, _In_ int nImage, _In_ int nSelectedImage,
		_In_ HTREEITEM hParent = TVI_ROOT, _In_ HTREEITEM hInsertAfter = TVI_LAST);

	// Removes the specified item from the control.
	BOOL DeleteItem(_In_ HTREEITEM hItem);

	// Removes all items from the control.
	BOOL DeleteAllItems();

	// Expands the children of the specified item.
	BOOL Expand(_In_ HTREEITEM hItem, _In_ UINT nCode);

	// Selects the specified item.
	BOOL Select(_In_ HTREEITEM hItem, _In_ UINT nCode);

	// Selects the specified item.
	BOOL SelectItem(_In_opt_ HTREEITEM hItem);

	// Selects an item to be the drop target in the control.
	BOOL SelectDropTarget(_In_opt_ HTREEITEM hItem);

	// Draws the specified item as the drop target for the control.
	BOOL SelectSetFirstVisible(_In_ HTREEITEM hItem);

	// Begins editing the label of the specified item.
	CEdit* EditLabel(_In_ HTREEITEM hItem);

	// Determines the visual feature of the control under
	// the specified point.
	HTREEITEM HitTest(_In_ CPoint pt, _In_opt_ UINT* pFlags = NULL) const;
	HTREEITEM HitTest(_In_ TVHITTESTINFO* pHitTestInfo) const;

	// Create a drag image for the specified item.
	CImageList* CreateDragImage(_In_ HTREEITEM hItem);

	// Sorts all children of the specified item.
	BOOL SortChildren(_In_opt_ HTREEITEM hItem);

	// Scrolls the control to ensure the specified item is visible.
	BOOL EnsureVisible(_In_ HTREEITEM hItem);

	// Sorts items in the control using the provided callback function.
	BOOL SortChildrenCB(_In_ LPTVSORTCB pSort);

	// Terminates label editing operation.
	BOOL EndEditLabelNow(BOOL fCancelWithoutSave);

#if (_WIN32_WINNT >= 0x0600) && defined(UNICODE)
	// Shows information tooltip on the specified item.
	void ShowInfoTip(HTREEITEM hItem);
#endif

// Implementation
protected:
	void RemoveImageList(_In_ int nImageList);

public:
	// virtual OK here - ~CWnd is virtual
	virtual ~CTreeCtrl();
	//{{AFX_MSG(CTreeCtrl)
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CSpinButtonCtrl

class CSpinButtonCtrl : public CWnd
{
	DECLARE_DYNAMIC(CSpinButtonCtrl)

// Constructors
public:
	CSpinButtonCtrl();

	// Generic creator
	virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	virtual BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
	// Sets acceleration information for the up-down control.
	BOOL SetAccel(_In_ int nAccel, _In_ UDACCEL* pAccel);

	// Retrieves acceleration information for the up-down control.
	UINT GetAccel(_In_ int nAccel, _Out_ UDACCEL* pAccel) const;

	// Sets the radix base for the up-down control.
	int SetBase(_In_ int nBase);

	// Retrieves the current radix base for the up-down control.
	UINT GetBase() const;

	// Sets the up-down control's buddy window.
	CWnd* SetBuddy(_In_ CWnd* pWndBuddy);

	// Retrieves the up-down control's current buddy window.
	CWnd* GetBuddy() const;

	// Sets the current position of an up-down control with 16-bit precision.
	int SetPos(_In_ int nPos);

	// Retrieves the current position of an up-down control with 16-bit precision.
	int GetPos() const;

	// Sets the minimum and maximum positions (range) for the up-down control.
	void SetRange(_In_ short nLower, _In_ short nUpper);
	void SetRange32(_In_ int nLower, _In_ int nUpper);

	// Retrieves the minimum and maximum positions (range) for the up-down control.
	DWORD GetRange() const;
	void GetRange(_Out_ int &lower, _Out_ int& upper) const;
	void GetRange32(_Out_ int &lower, _Out_ int& upper) const;

#if _WIN32_IE >= 0x0500
	// Retrieves the current position of the up-down control with 32-bit precision.
	int GetPos32(_Out_opt_ LPBOOL lpbError = NULL) const;

	// Sets the current position of an up-down control with 32-bit precision.
	int SetPos32(_In_ int nPos);
#endif

// Implementation
public:
	virtual ~CSpinButtonCtrl();
};

/////////////////////////////////////////////////////////////////////////////
// CSliderCtrl

class CSliderCtrl : public CWnd
{
	DECLARE_DYNAMIC(CSliderCtrl)

// Constructors
public:
	CSliderCtrl();

	// Generic creator
	virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	virtual BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
	// Retrieves the number of logical positions the trackbar control's slider
	// moves in response to keyboard input from the up/down arrow keys.
	int GetLineSize() const;

	// Sets the number of logical positions the trackbar control's slider
	// moves in response to keyboard input from the up/down arrow keys.
	int SetLineSize(_In_ int nSize);

	// Retrieves the number of logical positions the trackbar control's slider
	// moves in response to keyboard input from the PgUp/PgDn keys.
	int GetPageSize() const;

	// Sets the number of logical positions the trackbar control's slider
	// moves in response to keyboard input from the PgUp/PgDn keys.
	int SetPageSize(_In_ int nSize);

	// Retrieves the maximum position for the slider in the trackbar control.
	int GetRangeMax() const;

	// Retrieves the minimum position for the slider in the trackbar control.
	int GetRangeMin() const;

	// Retrieves the minimum and maximum positions for the slider in the trackbar control.
	void GetRange(_Out_ int& nMin, _Out_ int& nMax) const;

	// Sets the minimum position for the slider in the trackbar control.
	void SetRangeMin(_In_ int nMin, _In_ BOOL bRedraw = FALSE);

	// Sets the maximum position for the slider in the trackbar control.
	void SetRangeMax(_In_ int nMax, _In_ BOOL bRedraw = FALSE);

	// Sets the minimum and maximum positions for the slider in the trackbar control.
	void SetRange(_In_ int nMin, _In_ int nMax, _In_ BOOL bRedraw = FALSE);

	// Retrieves the starting and ending positions of the selection in the trackbar control.
	void GetSelection(_Out_ int& nMin, _Out_ int& nMax) const;

	// Sets the starting and ending positions of the selection in the trackbar control.
	void SetSelection(_In_ int nMin, _In_ int nMax);

	// Retrieves the bounding rectangle for the trackbar control's channel.
	void GetChannelRect(_Out_ LPRECT lprc) const;

	// Retrieves the bounding rectangle for the slider in the trackbar control.
	void GetThumbRect(_Out_ LPRECT lprc) const;

	// Retrieves the current logical position of the slider in the trackbar control.
	int GetPos() const;

	// Sets the current logical position of the slider in the trackbar control.
	void SetPos(_In_ int nPos);

	// Retrieves the number of tick marks in a trackbar control.
	UINT GetNumTics() const;

	// Retrieves an array of positions of tick marks in the trackbar control.
	DWORD* GetTicArray() const;

	// Retrieves the logical position of the specified tick mark in the trackbar control.
	int GetTic(_In_ int nTic) const;

	// Retrieves the current physical position of the specified tick mark in the trackbar control.
	int GetTicPos(_In_ int nTic) const;

	// Sets a tick mark in the trackbar control at the specified logical position.
	BOOL SetTic(_In_ int nTic);

	// Sets the interval frequency for tick marks in the trackbar control.
	void SetTicFreq(_In_ int nFreq);

	// Retrieves the trackbar control buddy window at the specified location.
	CWnd* GetBuddy(_In_ BOOL fLocation = TRUE) const;

	// Assigns the specified window as the buddy window for the trackbar control.
	CWnd* SetBuddy(_In_ CWnd* pWndBuddy, _In_ BOOL fLocation = TRUE);

	// Retrieves the ToolTip control assigned to the trackbar control.
	CToolTipCtrl* GetToolTips() const;

	// Assigns a ToolTip control to the trackbar control.
	void SetToolTips(_In_ CToolTipCtrl* pWndTip);

	// Positions the ToolTip control used by the trackbar control.
	int SetTipSide(_In_ int nLocation);

	// Sets the length of the slider in the trackbar control.
	void SetThumbLength(_In_ int nLength);

	// Retrieves the length of the slider in the trackbar control.
	int GetThumbLength() const;

// Operations
	// Clears the current selection range in the trackbar control.
	void ClearSel(_In_ BOOL bRedraw = FALSE);

	// Removes the current tick marks from the trackbar control.
	void ClearTics(_In_ BOOL bRedraw = FALSE);

// Implementation
public:
	virtual ~CSliderCtrl();
};

/////////////////////////////////////////////////////////////////////////////
// CProgressCtrl

class CProgressCtrl : public CWnd
{
	DECLARE_DYNAMIC(CProgressCtrl)

// Constructors
public:
	CProgressCtrl();

	// Generic creator
	virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	virtual BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes

	// Sets range of values for the control. (16-bit limit)
	void SetRange(_In_ short nLower, _In_ short nUpper);

	// Sets range of values for the control. (32-bit limit)
	void SetRange32(_In_ int nLower, _In_ int nUpper);

	// Retrieves range of values for the control. (32-bit limit)
	void GetRange(_Out_ int& nLower, _Out_ int& nUpper) const;

	// Gets the current position within the set range of the control.
	int GetPos() const;

	// Sets the current position within the set range of the control.
	int SetPos(_In_ int nPos);

	// Displaces the current position within the set range of the
	// control by the passed value.
	int OffsetPos(_In_ int nPos);

	// Sets the step by which increments happen with a call to StepIt().
	int SetStep(_In_ int nStep);

	// Sets the control's background color.
	COLORREF SetBkColor(_In_ COLORREF clrNew);

#if (_WIN32_IE >= 0x0400)
	// Sets the color of the progress indicator bar in the progress bar control.
	COLORREF SetBarColor(_In_ COLORREF clrBar);
#endif	// _WIN32_IE >= 0x0400

#if (_WIN32_WINNT >= 0x0501) && defined(UNICODE)
	// Sets the progress bar control to marquee mode.
	BOOL SetMarquee(_In_ BOOL fMarqueeMode, _In_ int nInterval);
#endif	// _WIN32_WINNT >= 0x0501 && defined(UNICODE)

#if (_WIN32_WINNT >= 0x0600) && defined(UNICODE)
	// REVIEW: Retrieves the step increment for the progress bar control.
	int GetStep() const;

	// REVIEW: Retrieves the background color of the progress bar control.
	COLORREF GetBkColor() const;

	// REVIEW: Retrieves the color of the progress bar control.
	COLORREF GetBarColor() const;

	// REVIEW: Sets the state of the progress bar.
	int SetState(_In_ int iState);

	// REVIEW: Retrieves the state of the progress bar.
	int GetState() const;
#endif	// _WIN32_WINNT >= 0x0600 && defined(UNICODE)

// Operations

	// Steps the control by the value set with SetStep().
	int StepIt();

// Implementation
public:
	virtual ~CProgressCtrl();
};

/////////////////////////////////////////////////////////////////////////////
// CComboBoxEx

class CComboBoxEx : public CComboBox
{
	DECLARE_DYNAMIC(CComboBoxEx)

// Constructors
public:
	CComboBoxEx();

	// Generic creator
	virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	virtual BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Operations
	using CComboBox::DeleteItem;
	int DeleteItem(_In_ int iIndex);
	BOOL GetItem(_Out_ COMBOBOXEXITEM* pCBItem);
	int InsertItem(_In_ const COMBOBOXEXITEM* pCBItem);
	BOOL SetItem(_In_ const COMBOBOXEXITEM* pCBItem);

// Attributes
	BOOL HasEditChanged();
	DWORD GetExtendedStyle() const;
	DWORD SetExtendedStyle(_In_ DWORD dwExMask, _In_ DWORD dwExStyles);
	CEdit* GetEditCtrl() const;
	CComboBox* GetComboBoxCtrl() const;
	CImageList* GetImageList() const;
	CImageList* SetImageList(_In_ CImageList* pImageList);

#if (_WIN32_WINNT >= 0x0501)
	AFX_ANSI_DEPRECATED HRESULT SetWindowTheme(_In_z_ LPCWSTR pszSubAppName);
#endif

	// These functions are supported by the Windows ComboBox control,
	// but not supported by the Windows ComboBoxEx control.

	int Dir(_In_ UINT attr, _In_z_ LPCTSTR lpszWildCard);
	int FindString(_In_ int nIndexStart, _In_z_ LPCTSTR lpszFind) const;
	int AddString(_In_z_ LPCTSTR lpszString);
	BOOL SetEditSel(_In_ int nStartChar, _In_ int nEndChar);
	int InsertString(_In_ int nIndex, _In_z_ LPCTSTR lpszString);

// Implementation
public:
	virtual ~CComboBoxEx();
};

/////////////////////////////////////////////////////////////////////////////
// CHeaderCtrl

class CHeaderCtrl : public CWnd
{
	DECLARE_DYNAMIC(CHeaderCtrl)

// Constructors
public:
	CHeaderCtrl();

	// Generic creator
	virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	virtual BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
	// Retrieves a count of the items in the header control.
	int GetItemCount() const;

	// Retrieves information about an item in the header control.
	BOOL GetItem(_In_ int nPos, _Out_ HDITEM* pHeaderItem) const;

	// Sets the attributes of the specified item in the header control.
	BOOL SetItem(_In_ int nPos, _In_ HDITEM* pHeaderItem);

	// Retrieves the image list assigned to the header control.
	CImageList* GetImageList(_In_ int nImageList = HDSIL_NORMAL) const;

	// Assigns an image list to the header control.
	CImageList* SetImageList(_In_ CImageList* pImageList, _In_ int nImageList = HDSIL_NORMAL);

	// Retrieves the bounding rectangle for the specified item in the header control.
	BOOL GetItemRect(_In_ int nIndex, _Out_ LPRECT lpRect) const;

	// Retrieves the current left-to-right order of items in the header control.
	BOOL GetOrderArray(_In_ LPINT piArray, _In_ int iCount) const;

	// Sets the left-to-right order of items in the header control.
	BOOL SetOrderArray(_In_ int iCount, _In_ LPINT piArray);

	// Retrieves an index value for an item based on its order in the header control.
	int OrderToIndex(_In_ int nOrder) const;

	// Determines which header item, if any, is at the specified point.
	int HitTest(_Inout_ LPHDHITTESTINFO pHeaderHitTestInfo);

#if _WIN32_IE >= 0x0500
	// Retrieves the width of the bitmap margin for the header control.
	int GetBitmapMargin() const;

	// Sets the width of the bitmap margin for the header control.
	int SetBitmapMargin(_In_ int nWidth);
#endif

#if (_WIN32_WINNT >= 0x600) && defined(UNICODE)
	// REVIEW:
	BOOL GetItemDropDownRect(_In_ int iItem, _Out_ LPRECT lpRect) const;

	// REVIEW: 
	BOOL GetOverflowRect(_Out_ LPRECT lpRect) const;

	// REVIEW: Gets the item in the header control that has the focus.
	int GetFocusedItem() const;

	// Sets the focus to the specified item in the header control.
	BOOL SetFocusedItem(_In_ int iItem);
#endif // _WIN32_WINNT >= 0x600 && defined(UNICODE)

// Operations
	// Inserts a new item into the header control.
	int InsertItem(_In_ int nPos, _In_ HDITEM* phdi);

	// Deletes an item from a header control.
	BOOL DeleteItem(_In_ int nPos);

	// Retrieves the correct size and position of the header control within the parent window.
	BOOL Layout(_In_ HDLAYOUT* pHeaderLayout);

	// Creates a semi-transparent version of an item's image for use as a dragging image.
	CImageList* CreateDragImage(_In_ int nIndex);

	// Changes the color of a divider between header items to indicate
	// the destination of an external drag-and-drop operation.
	int SetHotDivider(_In_ CPoint pt);
	int SetHotDivider(_In_ int nIndex);

#if _WIN32_IE >= 0x0500
	// Sets the timeout interval between the time a change takes place in the
	// filter attributes and the posting of an HDN_FILTERCHANGE notification.
	int SetFilterChangeTimeout(_In_ DWORD dwTimeOut);

	// Starts editing the filter for the specified column.
	int EditFilter(_In_ int nColumn, _In_ BOOL bDiscardChanges);

	// Clears the filter for the specified column in the header control.
	BOOL ClearFilter(_In_ int nColumn);

	// Clears all filters for all columns in the header control.
	BOOL ClearAllFilters();
#endif

// Overridables
	virtual void DrawItem(_In_ LPDRAWITEMSTRUCT lpDrawItemStruct);

// Implementation
public:
	virtual ~CHeaderCtrl();
protected:
	virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);

};

/////////////////////////////////////////////////////////////////////////////
// CHotKeyCtrl

class CHotKeyCtrl : public CWnd
{
	DECLARE_DYNAMIC(CHotKeyCtrl)

// Constructors
public:
	CHotKeyCtrl();

	// Generic creator
	virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	virtual BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
	// Sets the hot key combination for the hot key control.
	void SetHotKey(_In_ WORD wVirtualKeyCode, _In_ WORD wModifiers);

	// Retrieves the virtual key code and modifier flags of the hot key from the hot key control.
	DWORD GetHotKey() const;

	// Retrieves the virtual key code and modifier flags of the hot key from the hot key control.
	void GetHotKey(_Out_ WORD &wVirtualKeyCode, _Out_ WORD &wModifiers) const;

	// Retrieves a string representation of the hot key code and flags.
	CString GetHotKeyName() const;

// Operations
	// Defines the invalid combinations and the default modifier combination for the hot key control.
	void SetRules(_In_ WORD wInvalidComb, _In_ WORD wModifiers);

	// Retrieves a string representation of the virtual key.
	static CString GetKeyName(_In_ UINT vk, _In_ BOOL fExtended);

// Implementation
public:
	virtual ~CHotKeyCtrl();

};

/////////////////////////////////////////////////////////////////////////////
// CToolTipCtrl

class CToolTipCtrl : public CWnd
{
	DECLARE_DYNAMIC(CToolTipCtrl)

// Constructors
public:
	CToolTipCtrl();

	// Generic creator
	virtual BOOL Create(_In_ CWnd* pParentWnd, _In_ DWORD dwStyle = 0);

	// Generic creator allowing extended style bits
	virtual BOOL CreateEx(_In_ CWnd* pParentWnd, _In_ DWORD dwStyle = 0, _In_ DWORD dwStyleEx = 0);

// Attributes
	// Retrieves the text for a tool in the ToolTip control .
	void GetText(_Out_ CString& str, _In_ CWnd* pWnd, _In_ UINT_PTR nIDTool = 0) const;

	// Retrieves the information that the ToolTip control maintains about a tool.
	BOOL GetToolInfo(_Out_ CToolInfo& ToolInfo, _In_ CWnd* pWnd, _In_ UINT_PTR nIDTool = 0) const;

	// Sets the information that the ToolTip control maintains about a tool.
	void SetToolInfo(_In_ LPTOOLINFO lpToolInfo);

	// Sets a new bounding rectangle for a tool.
	void SetToolRect(_In_ CWnd* pWnd, _In_ UINT_PTR nIDTool, _In_ LPCRECT lpRect);

	// Retrieves a count of the tools maintained by the ToolTip control.
	int GetToolCount() const;

	// Retrieves the initial, pop-up, or reshow duration currently set for the ToolTip control.
	int GetDelayTime(_In_ DWORD dwDuration) const;

	// Sets the initial, pop-up, or reshow duration for the ToolTip control.
	void SetDelayTime(_In_ DWORD dwDuration, _In_ int iTime);

	// Retrieves the top, left, bottom, and right margins set for the ToolTip window.
	void GetMargin(_Out_ LPRECT lprc) const;

	// Sets the top, left, bottom, and right margins for the ToolTip window.
	void SetMargin(_In_ LPRECT lprc);

	// Retrieves the maximum width for the ToolTip window.
	int GetMaxTipWidth() const;

	// Sets the maximum width for the ToolTip window.
	int SetMaxTipWidth(_In_ int iWidth);

	// Retrieves the background color in the ToolTip window.
	COLORREF GetTipBkColor() const;

	// Sets the background color in the ToolTip window.
	void SetTipBkColor(_In_ COLORREF clr);

	// Retrieves the text color in the ToolTip window.
	COLORREF GetTipTextColor() const;

	// Sets the text color in the ToolTip window.
	void SetTipTextColor(_In_ COLORREF clr);

	// Retrieves the information for the current tool in the ToolTip control.
	BOOL GetCurrentTool(_Out_ LPTOOLINFO lpToolInfo) const;

#if _WIN32_IE >= 0x0500
	// Returns the width and height of the ToolTip control.
	CSize GetBubbleSize(_In_ LPTOOLINFO lpToolInfo) const;
#endif

#if (_WIN32_WINNT >= 0x0501)
	// Sets the visual style of the ToolTip control.
	AFX_ANSI_DEPRECATED HRESULT SetWindowTheme(_In_z_ LPCWSTR pszSubAppName);
#endif

// Operations
	// Activates or deactivates the ToolTip control.
	void Activate(_In_ BOOL bActivate);

	// Registers a tool with the ToolTip control.
	BOOL AddTool(_In_ CWnd* pWnd, _In_ UINT nIDText, _In_opt_ LPCRECT lpRectTool = NULL,
		_In_ UINT_PTR nIDTool = 0);
	BOOL AddTool(_In_ CWnd* pWnd, _In_z_ LPCTSTR lpszText = LPSTR_TEXTCALLBACK,
		_In_opt_ LPCRECT lpRectTool = NULL, _In_ UINT_PTR nIDTool = 0);

	// Removes a tool from the ToolTip control.
	void DelTool(_In_ CWnd* pWnd, _In_ UINT_PTR nIDTool = 0);

	// Tests a point to determine whether it is within the bounding rectangle of
	// the specified tool and, if it is, retrieves information about the tool.
	BOOL HitTest(_In_ CWnd* pWnd, _In_ CPoint pt, _In_ LPTOOLINFO lpToolInfo) const;

	// Passes a mouse message to the ToolTip control for processing.
	void RelayEvent(_In_ LPMSG lpMsg);

	void SetDelayTime(_In_ UINT nDelay);

	// Sets the ToolTip text for a tool.
	void UpdateTipText(_In_z_ LPCTSTR lpszText, _In_ CWnd* pWnd, _In_ UINT_PTR nIDTool = 0);
	void UpdateTipText(_In_ UINT nIDText, _In_ CWnd* pWnd, _In_ UINT_PTR nIDTool = 0);

	// Forces the current tool to be redrawn.
	void Update();

	// Removes the displayed ToolTip window from view.
	void Pop();

#if _WIN32_IE >= 0x0500
	// Calculates a ToolTip control's text display rectangle
	// from its window rectangle, or the ToolTip window rectangle
	// needed to display a specified text display rectangle.
	BOOL AdjustRect(_Out_ LPRECT lprc, _In_ BOOL bLarger = TRUE);

	// Adds a standard icon and title string to the ToolTip.
	BOOL SetTitle(_In_ UINT uIcon, _In_z_ LPCTSTR lpstrTitle);
#endif

#if (_WIN32_WINNT >= 0x0501) && defined(UNICODE)
	// Causes the ToolTip to display at the coordinates of the last mouse message.
	void Popup();

	// Retrieves information concerning the title of a tooltip control.
	void GetTitle(_Out_ PTTGETTITLE pTTGetTitle) const;
#endif

// Implementation
public:
	void FillInToolInfo(_Out_ TOOLINFO& ti, _In_ CWnd* pWnd, _In_ UINT_PTR nIDTool) const;
	virtual ~CToolTipCtrl();
#ifndef _AFXDLL
	virtual BOOL DestroyToolTipCtrl();
#else
	BOOL DestroyToolTipCtrl();
#endif

protected:
	//{{AFX_MSG(CToolTipCtrl)
	afx_msg LRESULT OnDisableModal(WPARAM, LPARAM);
	afx_msg LRESULT OnWindowFromPoint(WPARAM, LPARAM);
	afx_msg LRESULT OnAddTool(WPARAM, LPARAM);
	afx_msg void OnEnable(BOOL bEnable);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	CMapStringToPtr m_mapString;

	friend class CWnd;
	friend class CToolBar;
};

/////////////////////////////////////////////////////////////////////////////
// CTabCtrl

class CTabCtrl : public CWnd
{
	DECLARE_DYNAMIC(CTabCtrl)

// Constructors
public:
	CTabCtrl();

	// Generic creator
	virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	virtual BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
	// Retrieves the image list associated with the tab control.
	CImageList* GetImageList() const;

	// Assigns an image list to the tab control.
	CImageList* SetImageList(_In_ CImageList* pImageList);

	// Retrieves the number of tabs in the tab control.
	int GetItemCount() const;

	// Retrieves information about the specified tab in the tab control.
	BOOL GetItem(_In_ int nItem, _Out_ TCITEM* pTabCtrlItem) const;

	// Sets some or all attributes of the specified tab in the tab control.
	BOOL SetItem(_In_ int nItem, _In_ TCITEM* pTabCtrlItem);

	// Sets the number of bytes per tab reserved for application-defined data in the tab control.
	BOOL SetItemExtra(_In_ int nBytes);

	// Retrieves the bounding rectangle for the specified tab in the tab control.
	BOOL GetItemRect(_In_ int nItem, _Out_ LPRECT lpRect) const;

	// Determines the currently selected tab in the tab control.
	int GetCurSel() const;

	// Selects the specified tab in the tab control.
	int SetCurSel(_In_ int nItem);

	// Sets the focus to the specified tab in the tab control.
	void SetCurFocus(_In_ int nItem);

	// Sets the width and height of tabs in a fixed-width or owner-drawn tab control.
	CSize SetItemSize(_In_ CSize size);

	// Sets the amount of space (padding) around each tab's icon and label in the tab control.
	void SetPadding(_In_ CSize size);

	// Retrieves the current number of rows of tabs in the tab control.
	int GetRowCount() const;

	// Retrieves the ToolTip control associated with the tab control.
	CToolTipCtrl* GetToolTips() const;

	// Assigns a ToolTip control to the tab control.
	void SetToolTips(_In_ CToolTipCtrl* pWndTip);

	// Returns the index of the tab that has the focus in a tab control.
	int GetCurFocus() const;

	// Sets the minimum width of tabs in the tab control.
	int SetMinTabWidth(_In_ int cx);

	// Retrieves the extended styles that are currently in use for the tab control.
	DWORD GetExtendedStyle() const;

	// Sets the extended styles that the tab control will use.
	DWORD SetExtendedStyle(_In_ DWORD dwNewStyle, _In_ DWORD dwExMask = 0);

	// Retrieves state of a tab in the tab control.
	DWORD GetItemState(_In_ int nItem, _In_ DWORD dwMask) const;

	// Sets state for a tab in the tab control.
	BOOL SetItemState(_In_ int nItem, _In_ DWORD dwMask, _In_ DWORD dwState);

// Operations
	// Inserts a new tab in the tab control.
	LONG InsertItem(_In_ int nItem, _In_ TCITEM* pTabCtrlItem);
	LONG InsertItem(_In_ int nItem, _In_z_ LPCTSTR lpszItem);
	LONG InsertItem(_In_ int nItem, _In_z_ LPCTSTR lpszItem, _In_ int nImage);
	LONG InsertItem(_In_ UINT nMask, _In_ int nItem, _In_z_ LPCTSTR lpszItem,
		_In_ int nImage, _In_ LPARAM lParam);
	LONG InsertItem(_In_ UINT nMask, _In_ int nItem, _In_z_ LPCTSTR lpszItem,
		_In_ int nImage, _In_ LPARAM lParam, _In_ DWORD dwState, _In_ DWORD dwStateMask);

	// Removes a tab from the tab control.
	BOOL DeleteItem(_In_ int nItem);

	// Removes all tabs from the tab control.
	BOOL DeleteAllItems();

	// Calculates the tab control's display area given a window rectangle.
	void AdjustRect(_In_ BOOL bLarger, _Inout_ LPRECT lpRect);

	// Removes an image from the tab control's image list.
	void RemoveImage(_In_ int nImage);

	// Determines which tab, if any, is at a specified screen position.
	int HitTest(_In_ TCHITTESTINFO* pHitTestInfo) const;

	// Resets tabs in the tab control, clearing any that were in the pressed state.
	void DeselectAll(_In_ BOOL fExcludeFocus);

	// Sets the highlight state of a tab in the tab control.
	BOOL HighlightItem(_In_ int idItem, _In_ BOOL fHighlight = TRUE);

// Overridables
	virtual void DrawItem(_In_ LPDRAWITEMSTRUCT lpDrawItemStruct);

// Implementation
public:
	virtual ~CTabCtrl();
protected:
	virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);
	//{{AFX_MSG(CTabCtrl)
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CAnimateCtrl

class CAnimateCtrl : public CWnd
{
	DECLARE_DYNAMIC(CAnimateCtrl)

// Constructors
public:
	CAnimateCtrl();

	// Generic creator
	virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	virtual BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Operations
	// Opens an AVI clip and displays its first frame in the animation control.
	BOOL Open(_In_z_ LPCTSTR lpszFileName);
	BOOL Open(_In_ UINT nID);

	// Plays the AVI clip opened in the animation control.
	BOOL Play(_In_ UINT nFrom, _In_ UINT nTo, _In_ UINT nRep);

	// Stops playing the AVI clip opened in the animation control.
	BOOL Stop();

	// Closes the AVI clip opened in the animation control.
	BOOL Close();

	// Displays the specified frame of the AVI clip opened in the animation control.
	BOOL Seek(_In_ UINT nTo);

#if (_WIN32_WINNT >= 0x600) && defined(UNICODE)
	// REVIEW: Determines whether the animation control is playing a clip.
	BOOL IsPlaying() const;
#endif

// Implementation
public:
	virtual ~CAnimateCtrl();
};

/////////////////////////////////////////////////////////////////////////////
// CToolBarCtrl

struct IDropTarget; // forward declaration

// NOTE: This class must remain a binary-compatible subset
// of CToolBar. Do not add data members or virtual functions
// directly to this class.
class CToolBarCtrl : public CWnd
{
	// DECLARE_DYNAMIC OK here - CWnd already has virtual from DECLARE_DYNAMIC
	DECLARE_DYNAMIC(CToolBarCtrl)

// Construction
public:
	CToolBarCtrl();

	// Generic creator
	BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
public:
	// Determines whether the specified button in the toolbar is enabled.
	BOOL IsButtonEnabled(_In_ int nID) const;

	// Determines whether the specified button in the toolbar is checked.
	BOOL IsButtonChecked(_In_ int nID) const;

	// Determines whether the specified button in the toolbar is pressed.
	BOOL IsButtonPressed(_In_ int nID) const;

	// Determines whether the specified button in the toolbar is hidden.
	BOOL IsButtonHidden(_In_ int nID) const;

	// Determines whether the specified button in the toolbar is indeterminate.
	BOOL IsButtonIndeterminate(_In_ int nID) const;

	// Sets the state for the specified button in the toolbar.
	BOOL SetState(_In_ int nID, _In_ UINT nState);

	// Retrieves the state of the specified button in the toolbar.
	int GetState(_In_ int nID) const;

	// Retrieves information about the specified button in the toolbar.
	BOOL GetButton(_In_ int nIndex, _Out_ LPTBBUTTON lpButton) const;

	// Retrieves a count of the buttons currently in the toolbar control.
	int GetButtonCount() const;

	// Retrieves the bounding rectangle of the specified button in the toolbar (by index).
	BOOL GetItemRect(_In_ int nIndex, _Out_ LPRECT lpRect) const;

	// Retrieves the bounding rectangle for the specified button in the toolbar (by command).
	BOOL GetRect(_In_ int nID, _Out_ LPRECT lpRect) const;

	// Specifies the size of the TBBUTTON structure to the toolbar control.
	void SetButtonStructSize(_In_ int nSize);

	// Retrieves the current width and height of toolbar buttons, in pixels.
	DWORD GetButtonSize() const;

	// Sets the size of the buttons to be added to the toolbar.
	BOOL SetButtonSize(_In_ CSize size);

	// Sets the size of the bitmapped images to be added to the toolbar.
	BOOL SetBitmapSize(_In_ CSize size);

	// Retrieves the ToolTip control associated with the toolbar.
	CToolTipCtrl* GetToolTips() const;

	// Associates a ToolTip control with the toolbar.
	void SetToolTips(_In_ CToolTipCtrl* pTip);

	// Sets the window to which the toolbar control sends notification messages.
	void SetOwner(_In_ CWnd* pWnd);

	// Sets the number of rows of buttons in the toolbar.
	void SetRows(_In_ int nRows, _In_ BOOL bLarger, _In_ LPRECT lpRect);

	// Retrieves the number of rows of buttons in the toolbar.
	int GetRows() const;

	// Sets the command identifier of the specified toolbar button.
	BOOL SetCmdID(_In_ int nIndex, _In_ UINT nID);

	// Retrieves the flags that describe the type of bitmap to be used.
	UINT GetBitmapFlags() const;

	// Retrieves the index of the bitmap associated with the specified button in the toolbar.
	int GetBitmap(_In_ int nID) const;

	// Replaces one bitmap in the toolbar control with another bitmap.
	BOOL ReplaceBitmap(_In_ LPTBREPLACEBITMAP pReplaceBitmap);

	// Changes the bitmap for the specified button in the toolbar control.
	BOOL ChangeBitmap(_In_ int idButton, _In_ int iBitmap);

	// Retrieves the image list that the toolbar control uses to display inactive buttons.
	CImageList* GetDisabledImageList() const;

	// Retrieves the image list that the toolbar control uses to display hot buttons.
	CImageList* GetHotImageList() const;

	// Retrieves the image list that the toolbar control uses to display buttons in their default state
	CImageList* GetImageList() const;

	// Retrieves the styles currently in use for the toolbar control.
	DWORD GetStyle() const;

	// Retrieves the maximum number of text rows that can be displayed on a toolbar button.
	int GetMaxTextRows() const;

	// Determines whether the specified button in the toolbar is highlighted.
	BOOL IsButtonHighlighted(_In_ int nID) const;

	// Sets the minimum and maximum button widths in the toolbar control.
	BOOL SetButtonWidth(_In_ int cxMin, _In_ int cxMax);

	// Sets the image list that the toolbar control will use to display disabled buttons.
	CImageList* SetDisabledImageList(_In_ CImageList* pImageList);

	// Sets the image list that the toolbar control will use to display hot buttons.
	CImageList* SetHotImageList(_In_ CImageList* pImageList);

	// Sets the image list that the toolbar control will use to display buttons in their default state.
	CImageList* SetImageList(_In_ CImageList* pImageList);

	// Retrieves the IDropTarget for the toolbar control.
	HRESULT GetDropTarget(_Out_ IDropTarget** ppDropTarget) const;

	// Sets the indentation for the first button in the toolbar control.
	BOOL SetIndent(_In_ int iIndent);

	// Sets the maximum number of text rows that can be displayed on a toolbar button.
	BOOL SetMaxTextRows(_In_ int iMaxRows);

	// Sets the styles for the toolbar control.
	void SetStyle(_In_ DWORD dwStyle);

	// Retrieves extended information for the specified button in the toolbar.
	int GetButtonInfo(_In_ int nID, _Out_ TBBUTTONINFO* ptbbi) const;

	// Sets the information for the specified button in the toolbar.
	BOOL SetButtonInfo(_In_ int nID, _In_ TBBUTTONINFO* ptbbi);

	// Sets the text drawing flags for the toolbar.
	DWORD SetDrawTextFlags(_In_ DWORD dwMask, _In_ DWORD dwDTFlags);

	// Retrieves the anchor highlight setting for the toolbar.
	BOOL GetAnchorHighlight() const;

	// Sets the anchor highlight setting for the toolbar.
	BOOL SetAnchorHighlight(_In_ BOOL fAnchor = TRUE);

	// Retrieves the index of the hot item in the toolbar.
	int GetHotItem() const;

	// Sets the index of the hot item in the toolbar.
	int SetHotItem(_In_ int nHot);

	// Retrieves the current insertion mark for the toolbar.
	void GetInsertMark(_Out_ TBINSERTMARK* ptbim) const;

	// Sets the current insertion mark for the toolbar.
	void SetInsertMark(_In_ TBINSERTMARK* ptbim);

	// Retrieves the total size of all of the visible buttons and separators in the toolbar.
	BOOL GetMaxSize(_Out_ LPSIZE pSize) const;

	// Retrieves the insertion mark information for a point in the toolbar.
	BOOL InsertMarkHitTest(_In_ LPPOINT ppt, _In_ LPTBINSERTMARK ptbim) const;

	// Retrieves the extended styles for the toolbar control.
	DWORD GetExtendedStyle() const;

	// Sets the extended styles for the toolbar control.
	DWORD SetExtendedStyle(_In_ DWORD dwExStyle);

	// Retrieves the padding for the toolbar control.
	void GetPadding(_Out_ int& nHorzPadding, _Out_ int& nVertPadding) const;

	// Sets the padding for the toolbar control.
	DWORD SetPadding(_In_ int nHorzPadding, _In_ int nVertPadding);

	// Retrieves the color used to draw the insertion mark for the toolbar.
	COLORREF GetInsertMarkColor() const;

	// Sets the color used to draw the insertion mark for the toolbar.
	COLORREF SetInsertMarkColor(_In_ COLORREF clrNew);

	// Retrieves the color scheme information from the toolbar control.
	BOOL GetColorScheme(_Out_ COLORSCHEME* lpcs) const;

	// Sets the color scheme information for the toolbar control.
	void SetColorScheme(_In_ const COLORSCHEME* lpcs);

#if (_WIN32_WINNT >= 0x0501)
	// Retrieves the metrics of the toolbar control.
	AFX_ANSI_DEPRECATED void GetMetrics(_Out_ LPTBMETRICS ptbm) const;

	// Sets the metrics of the toolbar control.
	AFX_ANSI_DEPRECATED void SetMetrics(_In_ LPTBMETRICS ptbm);

	// Sets the visual style of the toolbar control.
	AFX_ANSI_DEPRECATED HRESULT SetWindowTheme(_In_z_ LPCWSTR pszSubAppName);
#endif

#if (_WIN32_WINNT >= 0x600) && defined(UNICODE)
	// REVIEW: Sets the image list that the toolbar control uses to display buttons in a pressed state.
	CImageList* SetPressedImageList(_In_ int iImageID, _In_ CImageList* pImageList);

	// REVIEW: Retrieves the image list that the toolbar control uses to display buttons in a pressed state.
	CImageList* GetPressedImageList() const;
#endif // _WIN32_WINNT >= 0x600 && defined(UNICODE)

// Operations
public:
	// Enables or disables the specified button in the toolbar.
	BOOL EnableButton(_In_ int nID, _In_ BOOL bEnable = TRUE);

	// Checks or unchecks the specified button in the toolbar.
	BOOL CheckButton(_In_ int nID, _In_ BOOL bCheck = TRUE);

	// Presses or releases the specified button in the toolbar.
	BOOL PressButton(_In_ int nID, _In_ BOOL bPress = TRUE);

	// Hides or shows the specified button in the toolbar.
	BOOL HideButton(_In_ int nID, _In_ BOOL bHide = TRUE);

	// Sets or clears the indeterminate state of the specified button in the toolbar.
	BOOL Indeterminate(_In_ int nID, _In_ BOOL bIndeterminate = TRUE);

	// Adds one or more images to the list of button images available for the toolbar control.
	int AddBitmap(_In_ int nNumButtons, _In_ UINT nBitmapID);
	int AddBitmap(_In_ int nNumButtons, _In_ CBitmap* pBitmap);

	// Adds one or more buttons to the toolbar control.
	BOOL AddButtons(_In_ int nNumButtons, _In_ LPTBBUTTON lpButtons);

	// Inserts a button into the toolbar control.
	BOOL InsertButton(_In_ int nIndex, _In_ LPTBBUTTON lpButton);

	// Deletes a button from the toolbar control.
	BOOL DeleteButton(_In_ int nIndex);

	// Retrieves the zero-based index for the button associated with the specified command identifier.
	UINT CommandToIndex(_In_ UINT nID) const;

	// Saves state for the toolbar control.
	void SaveState(_In_ HKEY hKeyRoot, _In_z_ LPCTSTR lpszSubKey,
		_In_z_ LPCTSTR lpszValueName);

	// Restores state for the toolbar control.
	void RestoreState(_In_ HKEY hKeyRoot, _In_z_ LPCTSTR lpszSubKey,
		_In_z_ LPCTSTR lpszValueName);

	// Loads system-defined button images into the toolbar control's image list.
	void LoadImages(_In_ int iBitmapID, _In_ HINSTANCE hinst);

	// Determines the ID of the button that corresponds to the specified accelerator character.
	BOOL MapAccelerator(_In_ TCHAR chAccel, _In_ UINT* pIDBtn);

	// Sets the highlight state of the specified button in the toolbar control.
	BOOL MarkButton(_In_ int nID, _In_ BOOL fHighlight = TRUE);

	// Moves a button from one index to another in the toolbar control.
	BOOL MoveButton(_In_ UINT nOldPos, _In_ UINT nNewPos);

	// Determines where a point lies in the toolbar control..
	int HitTest(_In_ LPPOINT ppt) const;

	// Displays the Customize Toolbar dialog box.
	void Customize();

	// Adds one or more strings to the toolbar control's string pool.
	int AddString(_In_ UINT nStringID);
	int AddStrings(_In_z_ LPCTSTR lpszStrings);

	// Causes the toolbar control to be resized.
	void AutoSize();

#if _WIN32_IE >= 0x0500
	int GetString(_In_ int nString, _Out_z_cap_post_count_(cchMaxLen, return + 1) LPTSTR lpstrString, _In_ size_t cchMaxLen) const;
	int GetString(_In_ int nString, _Out_ CString& str) const;
#endif

// Implementation
public:
	// virtual OK here: ~CWnd() is already virtual
	virtual ~CToolBarCtrl();

protected:
	//{{AFX_MSG(CToolBarCtrl)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CReBarCtrl

// NOTE: This class must remain a binary-compatible subset
// of CReBar. Do not add data members or virtual functions
// directly to this class.
class CReBarCtrl : public CWnd
{
	// DECLARE_DYNAMIC virtual is OK here - CWnd already has DECLARE_DYNAMIC
	DECLARE_DYNAMIC(CReBarCtrl)

// Construction
public:
	CReBarCtrl();

	// Generic creator
	BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
public:
	// Retrieves the count of bands currently in the rebar control.
	UINT GetBandCount() const;

	// Retrieves information about the specified band in the rebar control.
	BOOL GetBandInfo(_In_ UINT uBand, _Out_ REBARBANDINFO* prbbi) const;

	// Retrieves the height of the rebar control.
	UINT GetBarHeight() const;

	// Retrieves information about the rebar control and the image list it uses.
	BOOL GetBarInfo(_Out_ REBARINFO* prbi) const;

	// Retrieves the rebar control's default background color.
	COLORREF GetBkColor() const;

	// Retrieves the rebar control's IDropTarget interface pointer.
	IDropTarget* GetDropTarget() const;

	// Retrieves the bounding rectangle for the specified band in the rebar control.
	BOOL GetRect(_In_ UINT uBand, _Out_ LPRECT prc) const;

	// Retrieves the number of rows of bands in the rebar control.
	UINT GetRowCount() const;

	// Retrieves the height of the specified row in the rebar control.
	UINT GetRowHeight(_In_ UINT uRow) const;

	// Retrieves the rebar control's default text color.
	COLORREF GetTextColor() const;

	// Retrieves the ToolTip control associated with the rebar control.
	CToolTipCtrl* GetToolTips() const;

	// Converts the specified band identifier to a band index in the rebar control.
	int IDToIndex(_In_ UINT uBandID) const;

	// Sets characteristics of the specified band in the rebar control.
	BOOL SetBandInfo(_In_ UINT uBand, _In_ REBARBANDINFO* prbbi);

	// Sets the characteristics of the rebar control.
	BOOL SetBarInfo(_In_ REBARINFO* prbi);

	// Sets the rebar control's default background color.
	COLORREF SetBkColor(_In_ COLORREF clr);

	// Sets the rebar control's parent window.
	CWnd* SetOwner(_In_ CWnd* pWnd);

	// Sets the rebar control's default text color.
	COLORREF SetTextColor(_In_ COLORREF clr);

	// Associates the ToolTip control with the rebar control.
	void SetToolTips(_In_ CToolTipCtrl* pToolTip);

	// Retrieves the image list associated with the rebar control.
	CImageList* GetImageList() const;

	// Associates an image list with the rebar control.
	BOOL SetImageList(_In_ CImageList* pImageList);

	// Retrieves the borders of a band in the rebar control.
	void GetBandBorders(_In_ UINT uBand, _Out_ LPRECT prc) const;

	// Retrieves the rebar control's current palette.
	CPalette* GetPalette() const;

	// Sets the rebar control's current palette.
	CPalette* SetPalette(_In_ HPALETTE hPal);

	// Retrieves the color scheme information from the rebar control.
	BOOL GetColorScheme(_Out_ COLORSCHEME* lpcs) const;

	// Sets the color scheme information for the rebar control.
	void SetColorScheme(_In_ const COLORSCHEME* lpcs);

#if (_WIN32_WINNT >= 0x0501)
	// Retrieves the margins of a band in the rebar control.
	AFX_ANSI_DEPRECATED void GetBandMargins(_Out_ PMARGINS pMargins) const;

	// Sets the visual style of the rebar control.
	AFX_ANSI_DEPRECATED HRESULT SetWindowTheme(_In_z_ LPCWSTR pszSubAppName);
#endif

#if (_WIN32_WINNT >= 0x0600) && defined(UNICODE)
	// REVIEW: Sets the width for a docked band in the rebar control.
	BOOL SetBandWidth(_In_ UINT uBand, _In_ int cxWidth);

	// REVIEW: Sets the extended style of the rebar control.
	DWORD SetExtendedStyle(_In_ DWORD dwMask, _In_ DWORD dwStyleEx);

	// REVIEW: Retrieves the extended style of the rebar control.
	DWORD GetExtendedStyle() const;
#endif // _WIN32_WINNT >= 0x0600 && defined(UNICODE)

// Operations
public:
	// Puts the rebar control in drag-and-drop mode.
	void BeginDrag(_In_ UINT uBand, _In_ DWORD dwPos = (DWORD)-1);

	// Deletes a band from the rebar control.
	BOOL DeleteBand(_In_ UINT uBand);

	// Updates the drag position in the rebar control.
	void DragMove(_In_ DWORD dwPos = (DWORD)-1);

	// Terminates the rebar control's drag-and-drop operation.
	void EndDrag();

	// Determines which portion of a rebar band is at a given
	// point on the screen, if a rebar band exists at that point.
	int HitTest(_In_ RBHITTESTINFO* prbht);

	// Inserts a new band in the rebar control.
	BOOL InsertBand(_In_ UINT uIndex, _In_ REBARBANDINFO* prbbi);

	// Resizes a band in the rebar control to its largest size.
	void MaximizeBand(_In_ UINT uBand);

	// Resizes a band in the rebar control to its smallest size.
	void MinimizeBand(_In_ UINT uBand);

	// Resizes a band in the rebar control to its ideal size.
	void RestoreBand(_In_ UINT uBand);

	// Shows or hides the specified band in the rebar control.
	BOOL ShowBand(_In_ UINT uBand, _In_ BOOL fShow = TRUE);

	// Attempts to find the best layout of the bands for the given rectangle.
	BOOL SizeToRect(_Out_ CRect& rect);

	// Moves the specified band from one index to another in the rebar control.
	BOOL MoveBand(_In_ UINT uFrom, _In_ UINT uTo);

#if _WIN32_IE >= 0x0500
	// Programmatically push a chevron in the rebar control.
	void PushChevron(_In_ UINT uBand, _In_ LPARAM lAppValue);
#endif

// Implementation
public:
	// virtual OK here: ~CWnd() is already virtual
	virtual ~CReBarCtrl();
};

#ifndef _AFX_NO_RICHEDIT_SUPPORT
/////////////////////////////////////////////////////////////////////////////
// CRichEditCtrl

// NOTE: This class must remain a binary-compatible subset
// of CRichEditView. Do not add data members or virtual functions
// directly to this class.
class CRichEditCtrl : public CWnd
{
	// DECLARE_DYNAMIC virtual OK here - CWnd has DECLARE_DYNAMIC
	DECLARE_DYNAMIC(CRichEditCtrl)

// Constructors
public:
	CRichEditCtrl();

	// Generic creator
	BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
	BOOL CanUndo() const;
	BOOL CanRedo() const;
	UNDONAMEID GetUndoName() const;
	UNDONAMEID GetRedoName() const;
	int GetLineCount() const;
	BOOL GetModify() const;
	void SetModify(_In_ BOOL bModified = TRUE);
	BOOL SetTextMode(_In_ UINT fMode);
	UINT GetTextMode() const;
	void GetRect(_Out_ LPRECT lpRect) const;
	CPoint GetCharPos(_In_ long lChar) const;
	UINT GetOptions() const;
	void SetOptions(_In_ WORD wOp, _In_ DWORD dwFlags);
	BOOL SetAutoURLDetect(_In_ BOOL bEnable = TRUE);
	UINT GetWordWrapMode() const;
	UINT SetWordWrapMode(_In_ UINT uFlags) const;
	BOOL GetPunctuation(_In_ UINT fType, _Out_ PUNCTUATION* lpPunc) const;
	BOOL SetPunctuation(_In_ UINT fType, _In_ PUNCTUATION* lpPunc);

	// NOTE: first word in lpszBuffer must contain the size of the buffer!
	// NOTE: Copied line does not contain null character!
	int GetLine(_In_ int nIndex, _Pre_notnull_ _Post_z_ LPTSTR lpszBuffer) const;
	// NOTE: Copied line does not contain null character!
	int GetLine(_In_ int nIndex, _Out_cap_post_count_(nMaxLength, return) LPTSTR lpszBuffer, _In_ int nMaxLength) const;

	BOOL CanPaste(_In_ UINT nFormat = 0) const;
	void GetSel(_Out_ long& nStartChar, _Out_ long& nEndChar) const;
	void GetSel(_Out_ CHARRANGE &cr) const;
	void LimitText(_In_ long nChars = 0);
	long LineFromChar(_In_ long nIndex) const;
	CPoint PosFromChar(_In_ UINT nChar) const;
	int CharFromPos(_In_ CPoint pt) const;

	void SetSel(_In_ long nStartChar, _In_ long nEndChar);
	void SetSel(_In_ CHARRANGE &cr);
	DWORD GetDefaultCharFormat(_Out_ CHARFORMAT &cf) const;
	DWORD GetDefaultCharFormat(_Out_ CHARFORMAT2 &cf) const;
	DWORD GetSelectionCharFormat(_Out_ CHARFORMAT &cf) const;
	DWORD GetSelectionCharFormat(_Out_ CHARFORMAT2 &cf) const;
	long GetEventMask() const;
	long GetLimitText() const;
	DWORD GetParaFormat(_Out_ PARAFORMAT &pf) const;
	DWORD GetParaFormat(_Out_ PARAFORMAT2 &pf) const;
	// richedit EM_GETSELTEXT is ANSI
	_AFX_INSECURE_DEPRECATE("GetSelText(char *) is unsafe. Instead, use GetSelText(void) returning CString") 
	long GetSelText(_Pre_notnull_ _Post_z_ LPSTR lpBuf) const;
	int GetTextRange(_In_ int nFirst, _In_ int nLast, _Out_ CString& refString) const;
	CString GetSelText() const;
	WORD GetSelectionType() const;
	COLORREF SetBackgroundColor(_In_ BOOL bSysColor, _In_ COLORREF cr);
	BOOL SetDefaultCharFormat(_In_ CHARFORMAT &cf);
	BOOL SetDefaultCharFormat(_In_ CHARFORMAT2 &cf);
	BOOL SetSelectionCharFormat(_In_ CHARFORMAT &cf);
	BOOL SetSelectionCharFormat(_In_ CHARFORMAT2 &cf);
	BOOL SetWordCharFormat(_In_ CHARFORMAT &cf);
	BOOL SetWordCharFormat(_In_ CHARFORMAT2 &cf);
	DWORD SetEventMask(_In_ DWORD dwEventMask);
	BOOL SetParaFormat(_In_ PARAFORMAT &pf);
	BOOL SetParaFormat(_In_ PARAFORMAT2 &pf);
	BOOL SetTargetDevice(_In_ HDC hDC, _In_ long lLineWidth);
	BOOL SetTargetDevice(_In_ CDC &dc, _In_ long lLineWidth);
	long GetTextLength() const;
	long GetTextLengthEx(_In_ DWORD dwFlags, _In_ UINT uCodePage = -1) const;
	BOOL SetReadOnly(_In_ BOOL bReadOnly = TRUE);
	int GetFirstVisibleLine() const;

// Operations
	void EmptyUndoBuffer();
	void StopGroupTyping();
	UINT SetUndoLimit(_In_ UINT nLimit);

	int LineIndex(_In_ int nLine = -1) const;
	int LineLength(_In_ int nLine = -1) const;
	void LineScroll(_In_ int nLines, _In_ int nChars = 0);
	void ReplaceSel(_In_z_ LPCTSTR lpszNewText, _In_ BOOL bCanUndo = FALSE);
	void SetRect(_In_ LPCRECT lpRect);

	BOOL DisplayBand(_In_ LPRECT pDisplayRect);
	long FindText(_In_ DWORD dwFlags, _Out_ FINDTEXTEX* pFindText) const;
	DWORD FindWordBreak(_In_ UINT nCode, _In_ DWORD nStart) const;
	long FormatRange(_In_ FORMATRANGE* pfr, _In_ BOOL bDisplay = TRUE);
	void HideSelection(_In_ BOOL bHide, _In_ BOOL bPerm);
	void PasteSpecial(_In_ UINT nClipFormat, _In_ DWORD dvAspect = 0, _In_ HMETAFILE hMF = 0);
	void RequestResize();
	long StreamIn(_In_ int nFormat, EDITSTREAM &es);
	long StreamOut(_In_ int nFormat, EDITSTREAM &es);

	// Clipboard operations
	BOOL Undo();
	BOOL Redo();
	void Clear();
	void Copy();
	void Cut();
	void Paste();

// OLE support
	IRichEditOle* GetIRichEditOle() const;
	BOOL SetOLECallback(IRichEditOleCallback* pCallback);

// Implementation
public:
	// virtual OK here - ~CWnd is already virtual
	virtual ~CRichEditCtrl();
};
#endif //!_AFX_NO_RICHEDIT_SUPPORT


/////////////////////////////////////////////////////////////////////////////
// CIPAddressCtrl

class CIPAddressCtrl : public CWnd
{
	DECLARE_DYNAMIC(CIPAddressCtrl)

public:
// Constructors
	CIPAddressCtrl();

	// Generic creator
	virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	virtual BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
	// Determines if all fields in the IP address control are blank.
	BOOL IsBlank() const;

	// Clears the contents of the IP address control.
	void ClearAddress();

	// Retrieves the address values for all four fields in the IP address control.
	int GetAddress(_Out_ BYTE& nField0, _Out_ BYTE& nField1, _Out_ BYTE& nField2, _Out_ BYTE& nField3) const;
	int GetAddress(_Out_ DWORD& dwAddress) const;

	// Sets the address values for all four fields in the IP address control.
	void SetAddress(_In_ DWORD dwAddress);
	void SetAddress(_In_ BYTE nField0, _In_ BYTE nField1, _In_ BYTE nField2, _In_ BYTE nField3);

	// Sets the keyboard focus to the specified field in the IP address control.
	void SetFieldFocus(_In_ WORD nField);

	// Sets the valid range for the specified field in the IP address control.
	void SetFieldRange(_In_ int nField, _In_ BYTE nLower, _In_ BYTE nUpper);

// Implementation
public:
	virtual ~CIPAddressCtrl();
};

/////////////////////////////////////////////////////////////////////////////
// CPagerCtrl

class CPagerCtrl : public CWnd
{
	DECLARE_DYNAMIC(CPagerCtrl)

// Constructors
public:
	CPagerCtrl();

	// Generic creator
	virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	virtual BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
	// Sets the contained window for the pager control.
	void SetChild(_In_ HWND hwndChild);

	// Sets the current background color for the pager control.
	COLORREF SetBkColor(_In_ COLORREF clrBk);

	// Retrieves the current background color for the pager control.
	COLORREF GetBkColor() const;

	// Sets the current border size for the pager control.
	int SetBorder(_In_ int iBorder);

	// Retrieves the current border size for the pager control.
	int GetBorder() const;

	// Sets the current scroll position for the pager control.
	void SetScrollPos(_In_ int iPos);

	// Retrieves the current scroll position of the pager control.
	int GetScrollPos() const;

	// Sets the current button size for the pager control.
	int SetButtonSize(_In_ int iButtonSize);

	// Retrieves the current button size for the pager control.
	int GetButtonSize() const;

	// Determines whether the specified button in the pager control is invisible.
	BOOL IsButtonInvisible(_In_ int iButton) const;

	// Determines whether the specified button in the pager control is normal.
	BOOL IsButtonNormal(_In_ int iButton) const;

	// Determines whether the specified button in the pager control is grayed.
	BOOL IsButtonGrayed(_In_ int iButton) const;

	// Determines whether the specified button in the pager control is depressed.
	BOOL IsButtonDepressed(_In_ int iButton) const;

	// Determines whether the specified button in the pager control is hot.
	BOOL IsButtonHot(_In_ int iButton) const;

	// Retrieves the state of the specified button in a pager control.
	DWORD GetButtonState(_In_ int iButton) const;

	// Retrieves a pager control's IDropTarget interface pointer.
	IDropTarget* GetDropTarget() const;

// Operations

	// Forces the pager control to recalculate the size of the contained window.
	void RecalcSize();

	// Enables or disables mouse forwarding for the pager control.
	void ForwardMouse(_In_ BOOL bForward);

// Implementation
public:
	virtual ~CPagerCtrl();
};

#if (_WIN32_WINNT >= 0x0501)
/////////////////////////////////////////////////////////////////////////////
// CLinkCtrl

AFX_ANSI_DEPRECATED class CLinkCtrl : public CWnd
{
	DECLARE_DYNAMIC(CLinkCtrl)

// Constructors
public:
	CLinkCtrl();

	// Generic creator
	AFX_DEPRECATED("CLinkCtrl::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID) is no longer supported as the Link Control does not get initialized correctly using this method. Instead, use CLinkCtrl::Create(LPCTSTR lpszLinkMarkup, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID)")
		virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);
	virtual BOOL Create(_In_z_ LPCTSTR lpszLinkMarkup, _In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	AFX_DEPRECATED("CLinkCtrl::CreateEx(DWORD dwExStyle, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID) is no longer supported as the Link Control does not get initialized correctly using this method. Instead, use CLinkCtrl::CreateEx(LPCTSTR lpszLinkMarkup, DWORD dwExStyle, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID)")
		virtual BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
			_In_ CWnd* pParentWnd, _In_ UINT nID);
	virtual BOOL CreateEx(_In_z_ LPCTSTR lpszLinkMarkup, _In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
	// Retrieves the preferred height of a link for the control's current width.
	int GetIdealHeight() const;

#if (_WIN32_WINNT >= 0x0600) && defined(UNICODE)
	// REVIEW: Retrieves the preferred size of a link for the specified width.
	int GetIdealSize(_In_ int cxMaxWidth, _Out_ SIZE* pSize) const;
#endif // (_WIN32_WINNT >= 0x0600) && defined(UNICODE)

// Operations
	// Set the states and attributes of an item.
	BOOL SetItem(_In_ PLITEM pItem);
	BOOL SetItemID(_In_ int iLink, _In_z_ LPCWSTR szID);
	BOOL SetItemUrl(_In_ int iLink, _In_z_ LPCWSTR szUrl);
	BOOL SetItemState(_In_ int iLink, _In_ UINT state, _In_ UINT stateMask = LIS_FOCUSED | LIS_ENABLED | LIS_VISITED);

	// Retrieve the states and attributes of an item.
	BOOL GetItem(_Out_ PLITEM pItem) const;
	BOOL GetItemID(_In_ int iLink, _Out_ CString& strID) const;
	BOOL GetItemID(_In_ int iLink, _Out_z_cap_(cchID) LPWSTR szID, _In_ UINT cchID) const;
	BOOL GetItemUrl(_In_ int iLink, _Out_ CString& strUrl) const;
	BOOL GetItemUrl(_In_ int iLink, _Out_z_cap_(cchUrl) LPWSTR szUrl, _In_ UINT cchUrl) const;
	BOOL GetItemState(_In_ int iLink, _Out_ UINT *pnState, _In_ UINT stateMask = LIS_FOCUSED | LIS_ENABLED | LIS_VISITED) const;

	// Determines whether the user clicked the specified link.
	BOOL HitTest(_In_ PLHITTESTINFO phti) const;

// Implementation
public:
	virtual ~CLinkCtrl();
};

#endif	// _WIN32_WINNT >= 0x0501

#if (NTDDI_VERSION >= NTDDI_LONGHORN) && defined(UNICODE)

/////////////////////////////////////////////////////////////////////////////
// CNetAddressCtrl

class CNetAddressCtrl : public CEdit
{
	DECLARE_DYNAMIC(CNetAddressCtrl)

public:
// Constructors
	CNetAddressCtrl();

	// Generic creator
	virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

	// Generic creator allowing extended style bits
	virtual BOOL CreateEx(_In_ DWORD dwExStyle, _In_ DWORD dwStyle, _In_ const RECT& rect,
		_In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
	// Retrieves the address in the control.
	HRESULT GetAddress(_Out_ PNC_ADDRESS pAddress) const;

	// Sets the allowed address types for the control.
	HRESULT SetAllowType(_In_ DWORD dwAddrMask);

	// Retrieves the allowed address types for the control.
	DWORD GetAllowType() const;

// Operations
	// Displays the error tip for the control.
	HRESULT DisplayErrorTip();

// Implementation
public:
	virtual ~CNetAddressCtrl();
};

#endif // (NTDDI_VERSION >= NTDDI_LONGHORN) && defined(UNICODE)

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_ALL_WARNINGS
#pragma warning(pop)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXCMN_INLINE AFX_INLINE
#include <afxcmn.inl>
#include <afxcmn2.inl>
#undef _AFXCMN_INLINE
#endif
#include <afxcmn3.inl>

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXCMN_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxcmn.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXCMN.H

#pragma once

#ifdef _AFXCMN_INLINE

_AFXCMN_INLINE CDragListBox::CDragListBox()
	{ m_nLast = -1;}
_AFXCMN_INLINE int CDragListBox::ItemFromPt(CPoint pt, BOOL bAutoScroll) const
	{ASSERT(::IsWindow(m_hWnd)); return ::AfxLBItemFromPt(m_hWnd, pt, bAutoScroll); }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CToolBarCtrl::CToolBarCtrl()
	{ }
_AFXCMN_INLINE BOOL CToolBarCtrl::EnableButton(int nID, BOOL bEnable)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_ENABLEBUTTON, nID, MAKELPARAM(bEnable, 0)); }
_AFXCMN_INLINE BOOL CToolBarCtrl::CheckButton(int nID, BOOL bCheck)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_CHECKBUTTON, nID, MAKELPARAM(bCheck, 0)); }
_AFXCMN_INLINE BOOL CToolBarCtrl::PressButton(int nID, BOOL bPress)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_PRESSBUTTON, nID, MAKELPARAM(bPress, 0)); }
_AFXCMN_INLINE BOOL CToolBarCtrl::HideButton(int nID, BOOL bHide)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_HIDEBUTTON, nID, MAKELPARAM(bHide, 0)); }
_AFXCMN_INLINE BOOL CToolBarCtrl::Indeterminate(int nID, BOOL bIndeterminate)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_INDETERMINATE, nID, MAKELPARAM(bIndeterminate, 0)); }
_AFXCMN_INLINE BOOL CToolBarCtrl::IsButtonEnabled(int nID) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_ISBUTTONENABLED, nID, 0); }
_AFXCMN_INLINE BOOL CToolBarCtrl::IsButtonChecked(int nID) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_ISBUTTONCHECKED, nID, 0); }
_AFXCMN_INLINE BOOL CToolBarCtrl::IsButtonPressed(int nID) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_ISBUTTONPRESSED, nID, 0); }
_AFXCMN_INLINE BOOL CToolBarCtrl::IsButtonHidden(int nID) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_ISBUTTONHIDDEN, nID, 0); }
_AFXCMN_INLINE BOOL CToolBarCtrl::IsButtonIndeterminate(int nID) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_ISBUTTONINDETERMINATE, nID, 0); }
_AFXCMN_INLINE BOOL CToolBarCtrl::SetState(int nID, UINT nState)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_SETSTATE, nID, MAKELPARAM(nState, 0)); }
_AFXCMN_INLINE int CToolBarCtrl::GetState(int nID) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TB_GETSTATE, nID, 0L); }
_AFXCMN_INLINE BOOL CToolBarCtrl::AddButtons(int nNumButtons, LPTBBUTTON lpButtons)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_ADDBUTTONS, nNumButtons, (LPARAM)lpButtons); }
_AFXCMN_INLINE BOOL CToolBarCtrl::InsertButton(int nIndex, LPTBBUTTON lpButton)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_INSERTBUTTON, nIndex, (LPARAM)lpButton); }
_AFXCMN_INLINE BOOL CToolBarCtrl::DeleteButton(int nIndex)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_DELETEBUTTON, nIndex, 0); }
_AFXCMN_INLINE BOOL CToolBarCtrl::GetButton(int nIndex, LPTBBUTTON lpButton) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_GETBUTTON, nIndex, (LPARAM)lpButton); }
_AFXCMN_INLINE int CToolBarCtrl::GetButtonCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TB_BUTTONCOUNT, 0, 0L); }
_AFXCMN_INLINE UINT CToolBarCtrl::CommandToIndex(UINT nID) const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, TB_COMMANDTOINDEX, nID, 0L); }
_AFXCMN_INLINE void CToolBarCtrl::Customize()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TB_CUSTOMIZE, 0, 0L); }
// lpszStrings are separated by zeroes, last one is marked by two zeroes
_AFXCMN_INLINE int CToolBarCtrl::AddStrings(LPCTSTR lpszStrings)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TB_ADDSTRING, 0, (LPARAM)lpszStrings); }
_AFXCMN_INLINE BOOL CToolBarCtrl::GetItemRect(int nIndex, LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_GETITEMRECT, nIndex, (LPARAM)lpRect); }
_AFXCMN_INLINE void CToolBarCtrl::SetButtonStructSize(int nSize)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TB_BUTTONSTRUCTSIZE, nSize, 0L); }
_AFXCMN_INLINE BOOL CToolBarCtrl::SetButtonSize(CSize size)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_SETBUTTONSIZE, 0, MAKELPARAM(size.cx, size.cy)); }
_AFXCMN_INLINE BOOL CToolBarCtrl::SetBitmapSize(CSize size)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_SETBITMAPSIZE, 0, MAKELPARAM(size.cx, size.cy)); }
_AFXCMN_INLINE void CToolBarCtrl::AutoSize()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TB_AUTOSIZE, 0, 0L); }
_AFXCMN_INLINE CToolTipCtrl* CToolBarCtrl::GetToolTips() const
	{ ASSERT(::IsWindow(m_hWnd)); return (CToolTipCtrl*)CWnd::FromHandle((HWND)::SendMessage(m_hWnd, TB_GETTOOLTIPS, 0, 0L)); }
_AFXCMN_INLINE void CToolBarCtrl::SetToolTips(CToolTipCtrl* pTip)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TB_SETTOOLTIPS, (WPARAM)pTip->GetSafeHwnd(), 0L); }
_AFXCMN_INLINE void CToolBarCtrl::SetOwner(CWnd* pWnd)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TB_SETPARENT, (WPARAM)pWnd->GetSafeHwnd(), 0L); }
_AFXCMN_INLINE void CToolBarCtrl::SetRows(int nRows, BOOL bLarger, LPRECT lpRect)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TB_SETROWS, MAKEWPARAM(nRows, bLarger), (LPARAM)lpRect); }
_AFXCMN_INLINE int CToolBarCtrl::GetRows() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TB_GETROWS, 0, 0L); }
_AFXCMN_INLINE BOOL CToolBarCtrl::SetCmdID(int nIndex, UINT nID)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_SETCMDID, nIndex, nID); }
_AFXCMN_INLINE UINT CToolBarCtrl::GetBitmapFlags() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, TB_GETBITMAPFLAGS, 0, 0L); }
_AFXCMN_INLINE int CToolBarCtrl::GetBitmap(int nID) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TB_GETBITMAP, nID, 0L); }
_AFXCMN_INLINE BOOL CToolBarCtrl::ReplaceBitmap(_In_ LPTBREPLACEBITMAP pReplaceBitmap)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TB_REPLACEBITMAP, 0, (LPARAM)pReplaceBitmap); }
_AFXCMN_INLINE BOOL CToolBarCtrl::ChangeBitmap(int idButton, int iBitmap)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_CHANGEBITMAP, idButton, (LPARAM)MAKELPARAM(iBitmap, 0)); }
_AFXCMN_INLINE int CToolBarCtrl::HitTest(LPPOINT ppt) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TB_HITTEST, 0, (LPARAM)ppt); }
_AFXCMN_INLINE DWORD CToolBarCtrl::GetExtendedStyle() const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, TB_GETEXTENDEDSTYLE, 0, 0L); }
_AFXCMN_INLINE DWORD CToolBarCtrl::SetExtendedStyle(DWORD dwExStyle)
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, TB_SETEXTENDEDSTYLE, 0, dwExStyle); }
_AFXCMN_INLINE void CToolBarCtrl::GetPadding(int& nHorzPadding, int& nVertPadding) const
	{ ASSERT(::IsWindow(m_hWnd)); DWORD dwPadding = (DWORD)::SendMessage(m_hWnd, TB_GETPADDING, 0, 0L); nHorzPadding = (int)LOWORD(dwPadding); nVertPadding = (int)HIWORD(dwPadding); }
_AFXCMN_INLINE DWORD CToolBarCtrl::SetPadding(int nHorzPadding, int nVertPadding)
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, TB_SETPADDING, 0, (LPARAM)MAKELPARAM(nHorzPadding, nVertPadding)); }
_AFXCMN_INLINE COLORREF CToolBarCtrl::GetInsertMarkColor() const
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, TB_GETINSERTMARKCOLOR, 0, 0); }
_AFXCMN_INLINE COLORREF CToolBarCtrl::SetInsertMarkColor(COLORREF clrNew)
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, TB_SETINSERTMARKCOLOR, 0, (LPARAM) clrNew); }
_AFXCMN_INLINE BOOL CToolBarCtrl::GetColorScheme(COLORSCHEME* lpcs) const
	{ ASSERT(::IsWindow(m_hWnd)); lpcs->dwSize = ULONG(sizeof(COLORSCHEME)); return (BOOL)(::SendMessage(m_hWnd, TB_GETCOLORSCHEME, 0, (LPARAM)lpcs) != 0); }
_AFXCMN_INLINE void CToolBarCtrl::SetColorScheme(const COLORSCHEME* lpcs)
	{ ASSERT(::IsWindow(m_hWnd)); ((COLORSCHEME*)lpcs)->dwSize = sizeof(COLORSCHEME); ::SendMessage(m_hWnd, TB_SETCOLORSCHEME, 0, (LPARAM)lpcs); }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CStatusBarCtrl::CStatusBarCtrl()
	{ }
_AFXCMN_INLINE BOOL CStatusBarCtrl::SetText(LPCTSTR lpszText, int nPane, int nType)
	{ ASSERT(::IsWindow(m_hWnd)); ASSERT(nPane < 256); return (BOOL) ::SendMessage(m_hWnd, SB_SETTEXT, (nPane|nType), (LPARAM)lpszText); }
_AFXCMN_INLINE BOOL CStatusBarCtrl::SetParts(int nParts, int* pWidths)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, SB_SETPARTS, nParts, (LPARAM)pWidths); }
_AFXCMN_INLINE int CStatusBarCtrl::GetParts(int nParts, int* pParts) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, SB_GETPARTS, nParts, (LPARAM)pParts); }
_AFXCMN_INLINE BOOL CStatusBarCtrl::GetBorders(int* pBorders) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, SB_GETBORDERS, 0, (LPARAM)pBorders); }
_AFXCMN_INLINE void CStatusBarCtrl::SetMinHeight(int nMin)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, SB_SETMINHEIGHT, nMin, 0L); }
_AFXCMN_INLINE BOOL CStatusBarCtrl::SetSimple(BOOL bSimple)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, SB_SIMPLE, bSimple, 0L); }
_AFXCMN_INLINE BOOL CStatusBarCtrl::GetRect(int nPane, LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, SB_GETRECT, nPane, (LPARAM)lpRect); }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CListCtrl::CListCtrl()
	{ }
_AFXCMN_INLINE CToolTipCtrl* CListCtrl::GetToolTips() const
	{ ASSERT(::IsWindow(m_hWnd)); return (CToolTipCtrl*)CWnd::FromHandle((HWND)::SendMessage(m_hWnd, LVM_GETTOOLTIPS, 0, 0L)); }
_AFXCMN_INLINE CToolTipCtrl* CListCtrl::SetToolTips(CToolTipCtrl* pTip)
	{ ASSERT(::IsWindow(m_hWnd)); return (CToolTipCtrl*)CWnd::FromHandle((HWND)::SendMessage(m_hWnd, LVM_SETTOOLTIPS, 0, (LPARAM) pTip->GetSafeHwnd())); }
_AFXCMN_INLINE COLORREF CListCtrl::GetBkColor() const
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, LVM_GETBKCOLOR, 0, 0L); }
_AFXCMN_INLINE BOOL CListCtrl::SetBkColor(COLORREF cr)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_SETBKCOLOR, 0, cr); }
_AFXCMN_INLINE CImageList* CListCtrl::GetImageList(int nImageList) const
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, LVM_GETIMAGELIST, nImageList, 0L)); }
_AFXCMN_INLINE CImageList* CListCtrl::SetImageList(CImageList* pImageList, int nImageList)
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, LVM_SETIMAGELIST, nImageList, (LPARAM)pImageList->GetSafeHandle())); }
_AFXCMN_INLINE int CListCtrl::GetItemCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_GETITEMCOUNT, 0, 0L); }
_AFXCMN_INLINE BOOL CListCtrl::GetItem(LVITEM* pItem) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_GETITEM, 0, (LPARAM)pItem); }
_AFXCMN_INLINE BOOL CListCtrl::SetItem(const LVITEM* pItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_SETITEM, 0, (LPARAM)pItem); }
_AFXCMN_INLINE BOOL CListCtrl::SetItemData(int nItem, DWORD_PTR dwData)
	{ ASSERT(::IsWindow(m_hWnd)); return SetItem(nItem, 0, LVIF_PARAM, NULL, 0, 0, 0, (LPARAM)dwData); }
_AFXCMN_INLINE int CListCtrl::InsertItem(const LVITEM* pItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_INSERTITEM, 0, (LPARAM)pItem); }
_AFXCMN_INLINE int CListCtrl::InsertItem(int nItem, LPCTSTR lpszItem)
	{ ASSERT(::IsWindow(m_hWnd)); return InsertItem(LVIF_TEXT, nItem, lpszItem, 0, 0, 0, 0); }
_AFXCMN_INLINE int CListCtrl::InsertItem(int nItem, LPCTSTR lpszItem, int nImage)
	{ ASSERT(::IsWindow(m_hWnd)); return InsertItem(LVIF_TEXT|LVIF_IMAGE, nItem, lpszItem, 0, 0, nImage, 0); }
_AFXCMN_INLINE BOOL CListCtrl::DeleteItem(int nItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_DELETEITEM, nItem, 0L); }
_AFXCMN_INLINE BOOL CListCtrl::DeleteAllItems()
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_DELETEALLITEMS, 0, 0L); }
_AFXCMN_INLINE UINT CListCtrl::GetCallbackMask() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, LVM_GETCALLBACKMASK, 0, 0); }
_AFXCMN_INLINE BOOL CListCtrl::SetCallbackMask(UINT nMask)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_SETCALLBACKMASK, nMask, 0); }
_AFXCMN_INLINE int CListCtrl::GetNextItem(int nItem, int nFlags) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_GETNEXTITEM, nItem, MAKELPARAM(nFlags, 0)); }
_AFXCMN_INLINE POSITION CListCtrl::GetFirstSelectedItemPosition() const
	{ ASSERT(::IsWindow(m_hWnd)); return (POSITION)(DWORD_PTR)(1+GetNextItem(-1, LVIS_SELECTED)); }
_AFXCMN_INLINE int CListCtrl::GetNextSelectedItem(POSITION& pos) const
	{ ASSERT(::IsWindow(m_hWnd)); DWORD_PTR nOldPos = (DWORD_PTR)pos-1; pos = (POSITION)(DWORD_PTR)(1+GetNextItem((UINT)nOldPos, LVIS_SELECTED)); return (UINT)nOldPos; }
_AFXCMN_INLINE int CListCtrl::FindItem(LVFINDINFO* pFindInfo, int nStart) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_FINDITEM, nStart, (LPARAM)pFindInfo); }
_AFXCMN_INLINE int CListCtrl::HitTest(LVHITTESTINFO* pHitTestInfo) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_HITTEST, 0, (LPARAM)pHitTestInfo); }
_AFXCMN_INLINE BOOL CListCtrl::SetItemPosition(int nItem, POINT pt)  // LVM_SETITEMPOSITION is not supported, only LVM_SETITEMPOSITION32 is.
	{ ASSERT(::IsWindow(m_hWnd)); ASSERT((GetStyle() & LVS_OWNERDATA)==0); return (BOOL) ::SendMessage(m_hWnd, LVM_SETITEMPOSITION32, nItem, (LPARAM)&pt); }
_AFXCMN_INLINE BOOL CListCtrl::GetItemPosition(int nItem, LPPOINT lpPoint) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_GETITEMPOSITION, nItem, (LPARAM)lpPoint); }
_AFXCMN_INLINE int CListCtrl::GetStringWidth(LPCTSTR lpsz) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_GETSTRINGWIDTH, 0, (LPARAM)lpsz); }
_AFXCMN_INLINE BOOL CListCtrl::EnsureVisible(int nItem, BOOL bPartialOK)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_ENSUREVISIBLE, nItem, MAKELPARAM(bPartialOK, 0)); }
_AFXCMN_INLINE BOOL CListCtrl::Scroll(CSize size)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_SCROLL, size.cx, size.cy); }
_AFXCMN_INLINE BOOL CListCtrl::RedrawItems(int nFirst, int nLast)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_REDRAWITEMS, nFirst, nLast); }
_AFXCMN_INLINE BOOL CListCtrl::Arrange(UINT nCode)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_ARRANGE, nCode, 0L); }
_AFXCMN_INLINE CEdit* CListCtrl::EditLabel(int nItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (CEdit*)CWnd::FromHandle( (HWND)::SendMessage(m_hWnd, LVM_EDITLABEL, nItem, 0L)); }
_AFXCMN_INLINE CEdit* CListCtrl::GetEditControl() const
	{ ASSERT(::IsWindow(m_hWnd)); return (CEdit*)CWnd::FromHandle( (HWND)::SendMessage(m_hWnd, LVM_GETEDITCONTROL, 0, 0L)); }
_AFXCMN_INLINE BOOL CListCtrl::GetColumn(int nCol, LVCOLUMN* pColumn) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_GETCOLUMN, nCol, (LPARAM)pColumn); }
_AFXCMN_INLINE BOOL CListCtrl::SetColumn(int nCol, const LVCOLUMN* pColumn)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_SETCOLUMN, nCol, (LPARAM)pColumn); }
_AFXCMN_INLINE int CListCtrl::InsertColumn(int nCol, const LVCOLUMN* pColumn)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_INSERTCOLUMN, nCol, (LPARAM)pColumn); }
_AFXCMN_INLINE BOOL CListCtrl::DeleteColumn(int nCol)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_DELETECOLUMN, nCol, 0); }
_AFXCMN_INLINE int CListCtrl::GetColumnWidth(int nCol) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_GETCOLUMNWIDTH, nCol, 0); }
_AFXCMN_INLINE BOOL CListCtrl::SetColumnWidth(int nCol, int cx)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_SETCOLUMNWIDTH, nCol, MAKELPARAM(cx, 0)); }
_AFXCMN_INLINE BOOL CListCtrl::GetViewRect(LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_GETVIEWRECT, 0, (LPARAM)lpRect); }
_AFXCMN_INLINE COLORREF CListCtrl::GetTextColor() const
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, LVM_GETTEXTCOLOR, 0, 0L); }
_AFXCMN_INLINE BOOL CListCtrl::SetTextColor(COLORREF cr)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_SETTEXTCOLOR, 0, cr); }
_AFXCMN_INLINE COLORREF CListCtrl::GetTextBkColor() const
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, LVM_GETTEXTBKCOLOR, 0, 0L); }
_AFXCMN_INLINE BOOL CListCtrl::SetTextBkColor(COLORREF cr)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_SETTEXTBKCOLOR, 0, cr); }
_AFXCMN_INLINE int CListCtrl::GetTopIndex() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_GETTOPINDEX, 0, 0); }
_AFXCMN_INLINE int CListCtrl::GetCountPerPage() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_GETCOUNTPERPAGE, 0, 0); }
_AFXCMN_INLINE BOOL CListCtrl::GetOrigin(LPPOINT lpPoint) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_GETORIGIN, 0, (LPARAM)lpPoint); }
_AFXCMN_INLINE BOOL CListCtrl::Update(int nItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_UPDATE, nItem, 0L); }
_AFXCMN_INLINE BOOL CListCtrl::SetItemState(int nItem, LVITEM* pItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_SETITEMSTATE, nItem, (LPARAM)pItem); }
_AFXCMN_INLINE UINT CListCtrl::GetItemState(int nItem, UINT nMask) const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, LVM_GETITEMSTATE, nItem, nMask); }
_AFXCMN_INLINE void CListCtrl::SetItemCount(int nItems)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, LVM_SETITEMCOUNT, nItems, 0); }
_AFXCMN_INLINE BOOL CListCtrl::SortItems(PFNLVCOMPARE pfnCompare, DWORD_PTR dwData)
	{ ASSERT(::IsWindow(m_hWnd)); ASSERT((GetStyle() & LVS_OWNERDATA)==0); return (BOOL) ::SendMessage(m_hWnd, LVM_SORTITEMS, dwData, (LPARAM)pfnCompare); }
_AFXCMN_INLINE BOOL CListCtrl::SortItemsEx(PFNLVCOMPARE pfnCompare, DWORD_PTR dwData)
	{ ASSERT(::IsWindow(m_hWnd)); ASSERT((GetStyle() & LVS_OWNERDATA)==0); return (BOOL) ::SendMessage(m_hWnd, LVM_SORTITEMSEX, dwData, (LPARAM)pfnCompare); }
_AFXCMN_INLINE UINT CListCtrl::GetSelectedCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, LVM_GETSELECTEDCOUNT, 0, 0L); }
_AFXCMN_INLINE BOOL CListCtrl::GetItemSpacing(BOOL fSmall, int* pnHorzSpacing, int* pnVertSpacing) const
{ 
	ASSERT(::IsWindow(m_hWnd)); 
	ASSERT(pnHorzSpacing != NULL);
	ASSERT(pnVertSpacing != NULL);
        if (pnHorzSpacing == NULL || pnVertSpacing == NULL)
        {
            return FALSE;
        }
	DWORD dwSpacing = (DWORD)::SendMessage(m_hWnd, LVM_GETITEMSPACING, (WPARAM)fSmall, 0L); 
	*pnHorzSpacing = (int)LOWORD(dwSpacing); 
	*pnVertSpacing = (int)HIWORD(dwSpacing); 
        return TRUE;
}

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CTreeCtrl::CTreeCtrl()
	{ }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::InsertItem(LPTVINSERTSTRUCT lpInsertStruct)
	{ ASSERT(::IsWindow(m_hWnd));  return (HTREEITEM)::SendMessage(m_hWnd, TVM_INSERTITEM, 0, (LPARAM)lpInsertStruct); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::InsertItem(LPCTSTR lpszItem, int nImage,
	int nSelectedImage, HTREEITEM hParent, HTREEITEM hInsertAfter)
	{ ASSERT(::IsWindow(m_hWnd)); return InsertItem(TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE, lpszItem, nImage, nSelectedImage, 0, 0, 0, hParent, hInsertAfter); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::InsertItem(LPCTSTR lpszItem, HTREEITEM hParent, HTREEITEM hInsertAfter)
	{ ASSERT(::IsWindow(m_hWnd)); return InsertItem(TVIF_TEXT, lpszItem, 0, 0, 0, 0, 0, hParent, hInsertAfter); }
_AFXCMN_INLINE BOOL CTreeCtrl::DeleteItem(HTREEITEM hItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TVM_DELETEITEM, 0, (LPARAM)hItem); }
#pragma warning(disable: 4310)
_AFXCMN_INLINE BOOL CTreeCtrl::DeleteAllItems()
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TVM_DELETEITEM, 0, (LPARAM)TVI_ROOT); }
#pragma warning(default: 4310)
_AFXCMN_INLINE BOOL CTreeCtrl::Expand(HTREEITEM hItem, UINT nCode)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TVM_EXPAND, nCode, (LPARAM)hItem); }
_AFXCMN_INLINE UINT CTreeCtrl::GetCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT)::SendMessage(m_hWnd, TVM_GETCOUNT, 0, 0); }
_AFXCMN_INLINE UINT CTreeCtrl::GetIndent() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT)::SendMessage(m_hWnd, TVM_GETINDENT, 0, 0); }
_AFXCMN_INLINE void CTreeCtrl::SetIndent(UINT nIndent)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TVM_SETINDENT, nIndent, 0); }
_AFXCMN_INLINE CImageList* CTreeCtrl::GetImageList(int nImageList) const
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST)::SendMessage(m_hWnd, TVM_GETIMAGELIST, (WPARAM)nImageList, 0)); }
_AFXCMN_INLINE CImageList* CTreeCtrl::SetImageList(CImageList* pImageList, int nImageList)
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST)::SendMessage(m_hWnd, TVM_SETIMAGELIST, (WPARAM)nImageList, (LPARAM)pImageList->GetSafeHandle())); }
_AFXCMN_INLINE UINT CTreeCtrl::SetScrollTime(UINT uScrollTime)
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, TVM_SETSCROLLTIME, (WPARAM) uScrollTime, 0); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::GetNextItem(HTREEITEM hItem, UINT nCode) const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, nCode, (LPARAM)hItem); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::GetChildItem(HTREEITEM hItem) const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_CHILD, (LPARAM)hItem); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::GetNextSiblingItem(HTREEITEM hItem) const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_NEXT, (LPARAM)hItem); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::GetPrevSiblingItem(HTREEITEM hItem) const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_PREVIOUS, (LPARAM)hItem); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::GetParentItem(HTREEITEM hItem) const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_PARENT, (LPARAM)hItem); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::GetFirstVisibleItem() const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_FIRSTVISIBLE, 0); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::GetNextVisibleItem(HTREEITEM hItem) const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_NEXTVISIBLE, (LPARAM)hItem); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::GetPrevVisibleItem(HTREEITEM hItem) const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_PREVIOUSVISIBLE, (LPARAM)hItem); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::GetLastVisibleItem() const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_LASTVISIBLE, 0); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::GetSelectedItem() const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_CARET, 0); }
_AFXCMN_INLINE UINT CTreeCtrl::GetScrollTime() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, TVM_GETSCROLLTIME, 0, 0); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::GetDropHilightItem() const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_DROPHILITE, 0); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::GetRootItem() const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_ROOT, 0); }
_AFXCMN_INLINE BOOL CTreeCtrl::Select(HTREEITEM hItem, UINT nCode)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TVM_SELECTITEM, nCode, (LPARAM)hItem); }
_AFXCMN_INLINE BOOL CTreeCtrl::SelectItem(HTREEITEM hItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TVM_SELECTITEM, TVGN_CARET, (LPARAM)hItem); }
_AFXCMN_INLINE BOOL CTreeCtrl::SelectDropTarget(HTREEITEM hItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TVM_SELECTITEM, TVGN_DROPHILITE, (LPARAM)hItem); }
_AFXCMN_INLINE BOOL CTreeCtrl::SelectSetFirstVisible(HTREEITEM hItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TVM_SELECTITEM, TVGN_FIRSTVISIBLE, (LPARAM)hItem); }
_AFXCMN_INLINE BOOL CTreeCtrl::GetItem(TVITEM* pItem) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)pItem); }
_AFXCMN_INLINE BOOL CTreeCtrl::SetItem(TVITEM* pItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TVM_SETITEM, 0, (LPARAM)pItem); }
_AFXCMN_INLINE BOOL CTreeCtrl::SetItemText(HTREEITEM hItem, LPCTSTR lpszItem)
	{ ASSERT(::IsWindow(m_hWnd)); return SetItem(hItem, TVIF_TEXT, lpszItem, 0, 0, 0, 0, NULL); }
_AFXCMN_INLINE BOOL CTreeCtrl::SetItemImage(HTREEITEM hItem, int nImage, int nSelectedImage)
	{ ASSERT(::IsWindow(m_hWnd)); return SetItem(hItem, TVIF_IMAGE|TVIF_SELECTEDIMAGE, NULL, nImage, nSelectedImage, 0, 0, NULL); }
_AFXCMN_INLINE BOOL CTreeCtrl::SetItemState(HTREEITEM hItem, UINT nState, UINT nStateMask)
	{ ASSERT(::IsWindow(m_hWnd)); return SetItem(hItem, TVIF_STATE, NULL, 0, 0, nState, nStateMask, NULL); }
_AFXCMN_INLINE BOOL CTreeCtrl::SetItemData(HTREEITEM hItem, DWORD_PTR dwData)
	{ ASSERT(::IsWindow(m_hWnd)); return SetItem(hItem, TVIF_PARAM, NULL, 0, 0, 0, 0, (LPARAM)dwData); }
_AFXCMN_INLINE CEdit* CTreeCtrl::EditLabel(HTREEITEM hItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (CEdit*)CWnd::FromHandle((HWND)::SendMessage(m_hWnd, TVM_EDITLABEL, 0, (LPARAM)hItem)); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::HitTest(TVHITTESTINFO* pHitTestInfo) const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM)::SendMessage(m_hWnd, TVM_HITTEST, 0, (LPARAM)pHitTestInfo); }
_AFXCMN_INLINE CEdit* CTreeCtrl::GetEditControl() const
	{ ASSERT(::IsWindow(m_hWnd)); return (CEdit*)CWnd::FromHandle((HWND)::SendMessage(m_hWnd, TVM_GETEDITCONTROL, 0, 0)); }
_AFXCMN_INLINE UINT CTreeCtrl::GetVisibleCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT)::SendMessage(m_hWnd, TVM_GETVISIBLECOUNT, 0, 0); }
_AFXCMN_INLINE BOOL CTreeCtrl::SortChildren(HTREEITEM hItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TVM_SORTCHILDREN, 0, (LPARAM)hItem); }
_AFXCMN_INLINE BOOL CTreeCtrl::EnsureVisible(HTREEITEM hItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TVM_ENSUREVISIBLE, 0, (LPARAM)hItem); }
_AFXCMN_INLINE BOOL CTreeCtrl::SortChildrenCB(LPTVSORTCB pSort)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TVM_SORTCHILDRENCB, 0, (LPARAM)pSort); }
_AFXCMN_INLINE CToolTipCtrl* CTreeCtrl::GetToolTips() const
	{ ASSERT(::IsWindow(m_hWnd)); return (CToolTipCtrl*)CWnd::FromHandle((HWND)::SendMessage(m_hWnd, TVM_GETTOOLTIPS, 0, 0L)); }
_AFXCMN_INLINE CToolTipCtrl* CTreeCtrl::SetToolTips(CToolTipCtrl* pWndTip)
	{ ASSERT(::IsWindow(m_hWnd)); return (CToolTipCtrl*)CWnd::FromHandle((HWND)::SendMessage(m_hWnd, TVM_SETTOOLTIPS, (WPARAM)pWndTip->GetSafeHwnd(), 0L)); }
_AFXCMN_INLINE COLORREF CTreeCtrl::GetBkColor() const
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, TVM_GETBKCOLOR, 0, 0L); }
_AFXCMN_INLINE COLORREF CTreeCtrl::SetBkColor(COLORREF clr)
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, TVM_SETBKCOLOR, 0, (LPARAM)clr); }
_AFXCMN_INLINE SHORT CTreeCtrl::GetItemHeight() const
	{ ASSERT(::IsWindow(m_hWnd)); return (SHORT) ::SendMessage(m_hWnd, TVM_GETITEMHEIGHT, 0, 0L); }
_AFXCMN_INLINE SHORT CTreeCtrl::SetItemHeight(SHORT cyHeight)
	{ ASSERT(::IsWindow(m_hWnd)); return (SHORT) ::SendMessage(m_hWnd, TVM_SETITEMHEIGHT, cyHeight, 0L); }
_AFXCMN_INLINE COLORREF CTreeCtrl::GetTextColor() const
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, TVM_GETTEXTCOLOR, 0, 0L); }
_AFXCMN_INLINE COLORREF CTreeCtrl::SetTextColor(COLORREF clr)
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, TVM_SETTEXTCOLOR, 0, (LPARAM)clr); }
_AFXCMN_INLINE BOOL CTreeCtrl::SetInsertMark(HTREEITEM hItem, BOOL fAfter)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TVM_SETINSERTMARK, fAfter, (LPARAM)hItem); }
_AFXCMN_INLINE COLORREF CTreeCtrl::GetInsertMarkColor() const
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, TVM_GETINSERTMARKCOLOR, 0, 0L); }
_AFXCMN_INLINE COLORREF CTreeCtrl::SetInsertMarkColor(COLORREF clrNew)
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, TVM_SETINSERTMARKCOLOR, 0, (LPARAM)clrNew); }
_AFXCMN_INLINE BOOL CTreeCtrl::EndEditLabelNow(BOOL fCancelWithoutSave)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TVM_ENDEDITLABELNOW, (WPARAM)fCancelWithoutSave, 0); }

#if _WIN32_IE >= 0x0500
_AFXCMN_INLINE COLORREF CTreeCtrl::GetLineColor() const
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF)::SendMessage(m_hWnd, TVM_GETLINECOLOR, 0, 0L); }
_AFXCMN_INLINE COLORREF CTreeCtrl::SetLineColor(COLORREF clrNew /*= CLR_DEFAULT*/)
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF)::SendMessage(m_hWnd, TVM_SETLINECOLOR, 0, (LPARAM)clrNew); }
#endif

#if (_WIN32_WINNT >= 0x0501) && defined(UNICODE)
_AFXCMN_INLINE UINT CTreeCtrl::MapItemToAccId(HTREEITEM hItem) const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, TVM_MAPHTREEITEMTOACCID, (WPARAM)hItem, 0); }
_AFXCMN_INLINE HTREEITEM CTreeCtrl::MapAccIdToItem(UINT uAccId) const
	{ ASSERT(::IsWindow(m_hWnd)); return (HTREEITEM) ::SendMessage(m_hWnd, TVM_MAPACCIDTOHTREEITEM, (WPARAM)uAccId, 0); }
#endif

#if (_WIN32_WINNT >= 0x0600) && defined(UNICODE)
_AFXCMN_INLINE UINT CTreeCtrl::GetSelectedCount()
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, TVM_GETSELECTEDCOUNT, 0, 0); }
_AFXCMN_INLINE void CTreeCtrl::ShowInfoTip(HTREEITEM hItem)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TVM_SHOWINFOTIP, 0, (LPARAM)hItem); }
_AFXCMN_INLINE BOOL CTreeCtrl::SetItemStateEx(HTREEITEM hItem, UINT uStateEx)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)SetItemEx(hItem, TVIF_STATEEX, 0, 0, 0, 0, 0, 0, uStateEx, 0, 0); }
_AFXCMN_INLINE BOOL CTreeCtrl::SetItemExpandedImageIndex(HTREEITEM hItem, int nIndex)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)SetItemEx(hItem, TVIF_EXPANDEDIMAGE, 0, 0, 0, 0, 0, 0, TVIF_EXPANDEDIMAGE, 0, nIndex); }
_AFXCMN_INLINE DWORD CTreeCtrl::GetExtendedStyle() const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, TVM_GETEXTENDEDSTYLE, (WPARAM)0, 0); }
_AFXCMN_INLINE DWORD CTreeCtrl::SetExtendedStyle(DWORD dwExMask, DWORD dwExStyles)
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, TVM_SETEXTENDEDSTYLE, (WPARAM)dwExMask, (LPARAM)dwExStyles); }
_AFXCMN_INLINE BOOL CTreeCtrl::SetAutoscrollInfo(UINT uPixelsPerSec, UINT uUpdateTime)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TVM_SETAUTOSCROLLINFO, (WPARAM)uPixelsPerSec, (LPARAM)uUpdateTime); }
#endif

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CHotKeyCtrl::CHotKeyCtrl()
	{ }
_AFXCMN_INLINE void CHotKeyCtrl::SetHotKey(WORD wVirtualKeyCode, WORD wModifiers)
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, HKM_SETHOTKEY, MAKEWORD(wVirtualKeyCode, wModifiers), 0L); }
_AFXCMN_INLINE DWORD CHotKeyCtrl::GetHotKey() const
	{ ASSERT(::IsWindow(m_hWnd)); return DWORD(::SendMessage(m_hWnd, HKM_GETHOTKEY, 0, 0L)); }
_AFXCMN_INLINE void CHotKeyCtrl::SetRules(WORD wInvalidComb, WORD wModifiers)
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, HKM_SETRULES, wInvalidComb, MAKELPARAM(wModifiers, 0)); }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE void CToolTipCtrl::Activate(BOOL bActivate)
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_ACTIVATE, bActivate, 0L); }
_AFXCMN_INLINE void CToolTipCtrl::SetToolInfo(LPTOOLINFO lpToolInfo)
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_SETTOOLINFO, 0, (LPARAM)lpToolInfo); }
_AFXCMN_INLINE void CToolTipCtrl::RelayEvent(LPMSG lpMsg)
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_RELAYEVENT, 0, (LPARAM)lpMsg); }
_AFXCMN_INLINE int CToolTipCtrl::GetToolCount() const
	{ ASSERT(::IsWindow(m_hWnd));  return (int) ::SendMessage(m_hWnd, TTM_GETTOOLCOUNT, 0, 0L); }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CSpinButtonCtrl::CSpinButtonCtrl()
 	{ }
_AFXCMN_INLINE UINT CSpinButtonCtrl::GetAccel(int nAccel, UDACCEL* pAccel) const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) LOWORD(::SendMessage(m_hWnd, UDM_GETACCEL, nAccel, (LPARAM)pAccel)); }
_AFXCMN_INLINE UINT CSpinButtonCtrl::GetBase() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) LOWORD(::SendMessage(m_hWnd, UDM_GETBASE, 0, 0l)); }
_AFXCMN_INLINE CWnd* CSpinButtonCtrl::GetBuddy() const
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle((HWND) ::SendMessage(m_hWnd, UDM_GETBUDDY, 0, 0l)); }
_AFXCMN_INLINE int CSpinButtonCtrl::GetPos() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) (::SendMessage(m_hWnd, UDM_GETPOS, 0, 0l)); }
_AFXCMN_INLINE DWORD CSpinButtonCtrl::GetRange() const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, UDM_GETRANGE, 0, 0l); }
_AFXCMN_INLINE BOOL CSpinButtonCtrl::SetAccel(int nAccel, UDACCEL* pAccel)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) LOWORD(::SendMessage(m_hWnd, UDM_SETACCEL, nAccel, (LPARAM)pAccel)); }
_AFXCMN_INLINE int CSpinButtonCtrl::SetBase(int nBase)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, UDM_SETBASE, nBase, 0L); }
_AFXCMN_INLINE CWnd* CSpinButtonCtrl::SetBuddy(CWnd* pWndBuddy)
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle((HWND) ::SendMessage(m_hWnd, UDM_SETBUDDY, (WPARAM)pWndBuddy->GetSafeHwnd(), 0L)); }
_AFXCMN_INLINE int CSpinButtonCtrl::SetPos(int nPos)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) (short) LOWORD(::SendMessage(m_hWnd, UDM_SETPOS, 0, MAKELPARAM(nPos, 0))); }
_AFXCMN_INLINE void CSpinButtonCtrl::SetRange(short nLower, short nUpper)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, UDM_SETRANGE, 0, MAKELPARAM(nUpper, nLower)); }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CSliderCtrl::CSliderCtrl()
	{ }
_AFXCMN_INLINE int CSliderCtrl::GetLineSize() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TBM_GETLINESIZE, 0, 0l); }
_AFXCMN_INLINE int CSliderCtrl::SetLineSize(int nSize)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TBM_SETLINESIZE, 0, nSize); }
_AFXCMN_INLINE int CSliderCtrl::GetPageSize() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TBM_GETPAGESIZE, 0, 0l); }
_AFXCMN_INLINE int CSliderCtrl::SetPageSize(int nSize)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TBM_SETPAGESIZE, 0, nSize); }
_AFXCMN_INLINE int CSliderCtrl::GetRangeMax() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TBM_GETRANGEMAX, 0, 0l); }
_AFXCMN_INLINE int CSliderCtrl::GetRangeMin() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TBM_GETRANGEMIN, 0, 0l); }
_AFXCMN_INLINE void CSliderCtrl::SetRangeMin(int nMin, BOOL bRedraw)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TBM_SETRANGEMIN, bRedraw, nMin); }
_AFXCMN_INLINE void CSliderCtrl::SetRangeMax(int nMax, BOOL bRedraw)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TBM_SETRANGEMAX, bRedraw, nMax); }
_AFXCMN_INLINE void CSliderCtrl::ClearSel(BOOL bRedraw)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TBM_CLEARSEL, bRedraw, 0l); }
_AFXCMN_INLINE void CSliderCtrl::GetChannelRect(LPRECT lprc) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TBM_GETCHANNELRECT, 0, (LPARAM)lprc); }
_AFXCMN_INLINE void CSliderCtrl::GetThumbRect(LPRECT lprc) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TBM_GETTHUMBRECT, 0, (LPARAM)lprc); }
_AFXCMN_INLINE int CSliderCtrl::GetPos() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TBM_GETPOS, 0, 0l); }
_AFXCMN_INLINE void CSliderCtrl::SetPos(int nPos)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TBM_SETPOS, TRUE, nPos); }
_AFXCMN_INLINE void CSliderCtrl::ClearTics(BOOL bRedraw)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TBM_CLEARTICS, bRedraw, 0l); }
_AFXCMN_INLINE UINT CSliderCtrl::GetNumTics() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, TBM_GETNUMTICS, 0, 0l); }
_AFXCMN_INLINE DWORD* CSliderCtrl::GetTicArray() const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD*) ::SendMessage(m_hWnd, TBM_GETPTICS, 0, 0l); }
_AFXCMN_INLINE int CSliderCtrl::GetTic(int nTic) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TBM_GETTIC, nTic, 0L); }
_AFXCMN_INLINE int CSliderCtrl::GetTicPos(int nTic) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TBM_GETTICPOS, nTic, 0L); }
_AFXCMN_INLINE BOOL CSliderCtrl::SetTic(int nTic)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TBM_SETTIC, 0, nTic); }
_AFXCMN_INLINE void CSliderCtrl::SetTicFreq(int nFreq)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TBM_SETTICFREQ, nFreq, 0L); }
_AFXCMN_INLINE CWnd* CSliderCtrl::GetBuddy(BOOL fLocation) const
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle((HWND) ::SendMessage(m_hWnd, TBM_GETBUDDY, fLocation, 0l)); }
_AFXCMN_INLINE CWnd* CSliderCtrl::SetBuddy(CWnd* pWndBuddy, BOOL fLocation)
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle((HWND) ::SendMessage(m_hWnd, TBM_SETBUDDY, fLocation, (LPARAM)pWndBuddy->GetSafeHwnd())); }
_AFXCMN_INLINE CToolTipCtrl* CSliderCtrl::GetToolTips() const
	{ ASSERT(::IsWindow(m_hWnd)); return (CToolTipCtrl*)CWnd::FromHandle((HWND)::SendMessage(m_hWnd, TBM_GETTOOLTIPS, 0, 0L)); }
_AFXCMN_INLINE void CSliderCtrl::SetToolTips(CToolTipCtrl* pTip)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TBM_SETTOOLTIPS, (WPARAM)pTip->GetSafeHwnd(), 0L); }
_AFXCMN_INLINE int CSliderCtrl::SetTipSide(int nLocation)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, TBM_SETTIPSIDE, nLocation, 0L); }
_AFXCMN_INLINE void CSliderCtrl::SetThumbLength(int nLength)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TBM_SETTHUMBLENGTH, (WPARAM)nLength, 0L); }
_AFXCMN_INLINE int CSliderCtrl::GetThumbLength() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TBM_GETTHUMBLENGTH, 0, 0L); }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CProgressCtrl::CProgressCtrl()
	{ }
_AFXCMN_INLINE COLORREF CProgressCtrl::SetBkColor(COLORREF clrNew)
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, PBM_SETBKCOLOR, 0, (LPARAM) clrNew); }
_AFXCMN_INLINE void CProgressCtrl::SetRange(short nLower, short nUpper)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, PBM_SETRANGE, 0, MAKELPARAM(nLower, nUpper)); }
_AFXCMN_INLINE void CProgressCtrl::SetRange32(int nLower, int nUpper)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, PBM_SETRANGE32, (WPARAM) nLower, (LPARAM) nUpper); }
_AFXCMN_INLINE int CProgressCtrl::GetPos() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, PBM_GETPOS, 0, 0); }
_AFXCMN_INLINE int CProgressCtrl::OffsetPos(int nPos)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, PBM_DELTAPOS, nPos, 0L); }
_AFXCMN_INLINE int CProgressCtrl::SetStep(int nStep)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, PBM_SETSTEP, nStep, 0L); }
_AFXCMN_INLINE int CProgressCtrl::StepIt()
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, PBM_STEPIT, 0, 0L); }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CHeaderCtrl::CHeaderCtrl()
	{ }
_AFXCMN_INLINE int CHeaderCtrl::GetItemCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, HDM_GETITEMCOUNT, 0, 0L); }
_AFXCMN_INLINE int CHeaderCtrl::InsertItem(int nPos, HDITEM* phdi)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, HDM_INSERTITEM, nPos, (LPARAM)phdi); }
_AFXCMN_INLINE BOOL CHeaderCtrl::DeleteItem(int nPos)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, HDM_DELETEITEM, nPos, 0L); }
_AFXCMN_INLINE BOOL CHeaderCtrl::GetItem(int nPos, HDITEM* pHeaderItem) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, HDM_GETITEM, nPos, (LPARAM)pHeaderItem); }
_AFXCMN_INLINE BOOL CHeaderCtrl::SetItem(int nPos, HDITEM* pHeaderItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, HDM_SETITEM, nPos, (LPARAM)pHeaderItem); }
_AFXCMN_INLINE BOOL CHeaderCtrl::Layout(HDLAYOUT* pHeaderLayout)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, HDM_LAYOUT, 0, (LPARAM)pHeaderLayout); }
_AFXCMN_INLINE int CHeaderCtrl::HitTest(_Inout_ LPHDHITTESTINFO pHeaderHitTestInfo)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, HDM_HITTEST, 0, (LPARAM)pHeaderHitTestInfo); }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CTabCtrl::CTabCtrl()
	{ }
_AFXCMN_INLINE CImageList* CTabCtrl::GetImageList() const
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST)::SendMessage(m_hWnd, TCM_GETIMAGELIST, 0, 0L)); }
_AFXCMN_INLINE CImageList* CTabCtrl::SetImageList(CImageList* pImageList)
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST)::SendMessage(m_hWnd, TCM_SETIMAGELIST, 0, (LPARAM)pImageList->GetSafeHandle())); }
_AFXCMN_INLINE int CTabCtrl::GetItemCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, TCM_GETITEMCOUNT, 0, 0L); }
_AFXCMN_INLINE BOOL CTabCtrl::GetItem(int nItem, TCITEM* pTabCtrlItem) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TCM_GETITEM, nItem, (LPARAM)pTabCtrlItem); }
_AFXCMN_INLINE BOOL CTabCtrl::SetItem(int nItem, TCITEM* pTabCtrlItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TCM_SETITEM, nItem, (LPARAM)pTabCtrlItem); }
_AFXCMN_INLINE BOOL CTabCtrl::SetItemExtra(int nBytes)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TCM_SETITEMEXTRA, (WPARAM) nBytes, 0); }
_AFXCMN_INLINE void CTabCtrl::SetCurFocus(int nItem)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TCM_SETCURFOCUS, (WPARAM) nItem, 0); }
_AFXCMN_INLINE LONG CTabCtrl::InsertItem(int nItem, TCITEM* pTabCtrlItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (LONG)::SendMessage(m_hWnd, TCM_INSERTITEM, nItem, (LPARAM)pTabCtrlItem); }
_AFXCMN_INLINE LONG CTabCtrl::InsertItem(int nItem, LPCTSTR lpszItem)
	{ ASSERT(::IsWindow(m_hWnd)); return CTabCtrl::InsertItem(TCIF_TEXT, nItem, lpszItem, 0, 0); }
_AFXCMN_INLINE LONG CTabCtrl::InsertItem(int nItem, LPCTSTR lpszItem, int nImage)
	{ ASSERT(::IsWindow(m_hWnd)); return CTabCtrl::InsertItem(TCIF_TEXT|TCIF_IMAGE, nItem, lpszItem, nImage, 0); }
_AFXCMN_INLINE BOOL CTabCtrl::DeleteItem(int nItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TCM_DELETEITEM, nItem, 0L); }
_AFXCMN_INLINE BOOL CTabCtrl::DeleteAllItems()
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TCM_DELETEALLITEMS, 0, 0L); }
_AFXCMN_INLINE BOOL CTabCtrl::GetItemRect(int nItem, LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TCM_GETITEMRECT, nItem, (LPARAM)lpRect); }
_AFXCMN_INLINE int CTabCtrl::GetCurSel() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, TCM_GETCURSEL, 0, 0L); }
_AFXCMN_INLINE int CTabCtrl::SetCurSel(int nItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, TCM_SETCURSEL, nItem, 0L); }
_AFXCMN_INLINE int CTabCtrl::HitTest(TCHITTESTINFO* pHitTestInfo) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, TCM_HITTEST, 0, (LPARAM) pHitTestInfo); }
_AFXCMN_INLINE void CTabCtrl::AdjustRect(BOOL bLarger, LPRECT lpRect)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TCM_ADJUSTRECT, bLarger, (LPARAM)lpRect); }
_AFXCMN_INLINE CSize CTabCtrl::SetItemSize(CSize size)
	{ ASSERT(::IsWindow(m_hWnd)); return (CSize)DWORD(::SendMessage(m_hWnd, TCM_SETITEMSIZE, 0, MAKELPARAM(size.cx,size.cy))); }
_AFXCMN_INLINE void CTabCtrl::RemoveImage(int nImage)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TCM_REMOVEIMAGE, nImage, 0L); }
_AFXCMN_INLINE void CTabCtrl::SetPadding(CSize size)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TCM_SETPADDING, 0, MAKELPARAM(size.cx, size.cy)); }
_AFXCMN_INLINE int CTabCtrl::GetRowCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, TCM_GETROWCOUNT, 0, 0L); }
_AFXCMN_INLINE CToolTipCtrl* CTabCtrl::GetToolTips() const
	{ ASSERT(::IsWindow(m_hWnd)); return (CToolTipCtrl*)CWnd::FromHandle((HWND)::SendMessage(m_hWnd, TCM_GETTOOLTIPS, 0, 0L)); }
_AFXCMN_INLINE void CTabCtrl::SetToolTips(CToolTipCtrl* pWndTip)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TCM_SETTOOLTIPS, (WPARAM)pWndTip->GetSafeHwnd(), 0L); }
_AFXCMN_INLINE int CTabCtrl::GetCurFocus() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, TCM_GETCURFOCUS, 0, 0L); }
_AFXCMN_INLINE int CTabCtrl::SetMinTabWidth(int cx)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, TCM_SETMINTABWIDTH, 0, (LPARAM)cx); }
_AFXCMN_INLINE void CTabCtrl::DeselectAll(BOOL fExcludeFocus)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TCM_DESELECTALL, fExcludeFocus, 0); }
_AFXCMN_INLINE BOOL CTabCtrl::HighlightItem(int idItem, BOOL fHighlight /*= TRUE*/)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, TCM_HIGHLIGHTITEM, idItem, MAKELPARAM(fHighlight, 0)); }
_AFXCMN_INLINE DWORD CTabCtrl::GetExtendedStyle() const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, TCM_GETEXTENDEDSTYLE, 0, 0); }
_AFXCMN_INLINE DWORD CTabCtrl::SetExtendedStyle(DWORD dwNewStyle, DWORD dwExMask /*= 0*/)
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, TCM_SETEXTENDEDSTYLE, dwExMask, dwNewStyle); }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CAnimateCtrl::CAnimateCtrl()
	{ }
_AFXCMN_INLINE BOOL CAnimateCtrl::Open(LPCTSTR lpszName)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, ACM_OPEN,
		(WPARAM) ::AfxFindResourceHandle(lpszName, _T("AVI")), (LPARAM)lpszName); }
_AFXCMN_INLINE BOOL CAnimateCtrl::Open(UINT nID)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, ACM_OPEN,
		(WPARAM) ::AfxFindResourceHandle(MAKEINTRESOURCE(nID), _T("AVI")), (LPARAM) nID); }
_AFXCMN_INLINE BOOL CAnimateCtrl::Play(UINT nFrom, UINT nTo, UINT nRep)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, ACM_PLAY, nRep, MAKELPARAM(nFrom, nTo)); }
_AFXCMN_INLINE BOOL CAnimateCtrl::Stop()
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, ACM_STOP, 0, 0L); }
_AFXCMN_INLINE BOOL CAnimateCtrl::Close()
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, ACM_OPEN, 0, 0L); }
_AFXCMN_INLINE BOOL CAnimateCtrl::Seek(UINT nTo)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, ACM_PLAY, 0, MAKELPARAM(nTo, nTo)); }
#if (_WIN32_WINNT >= 0x600) && defined(UNICODE)
_AFXCMN_INLINE BOOL CAnimateCtrl::IsPlaying() const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, ACM_ISPLAYING, 0, 0L); }
#endif

/////////////////////////////////////////////////////////////////////////////

#ifndef _AFX_NO_RICHEDIT_SUPPORT
_AFXCMN_INLINE CRichEditCtrl::CRichEditCtrl()
	{ }
_AFXCMN_INLINE BOOL CRichEditCtrl::CanUndo() const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_CANUNDO, 0, 0); }
_AFXCMN_INLINE BOOL CRichEditCtrl::CanRedo() const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_CANREDO, 0, 0); }
_AFXCMN_INLINE UNDONAMEID CRichEditCtrl::GetUndoName() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UNDONAMEID) ::SendMessage(m_hWnd, EM_GETUNDONAME, 0, 0); }
_AFXCMN_INLINE UNDONAMEID CRichEditCtrl::GetRedoName() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UNDONAMEID) ::SendMessage(m_hWnd, EM_GETREDONAME, 0, 0); }
_AFXCMN_INLINE int CRichEditCtrl::GetLineCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, EM_GETLINECOUNT, 0, 0); }
_AFXCMN_INLINE BOOL CRichEditCtrl::GetModify() const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_GETMODIFY, 0, 0); }
_AFXCMN_INLINE void CRichEditCtrl::SetModify(BOOL bModified /* = TRUE */)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETMODIFY, bModified, 0);}
_AFXCMN_INLINE BOOL CRichEditCtrl::SetTextMode(UINT fMode)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, EM_SETTEXTMODE, (WPARAM) fMode, 0); }
_AFXCMN_INLINE UINT CRichEditCtrl::GetTextMode() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, EM_GETTEXTMODE, 0, 0); }
_AFXCMN_INLINE void CRichEditCtrl::GetRect(LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_GETRECT, 0, (LPARAM)lpRect); }
_AFXCMN_INLINE CPoint CRichEditCtrl::GetCharPos(long lChar) const
	{ ASSERT(::IsWindow(m_hWnd)); CPoint pt; ::SendMessage(m_hWnd, EM_POSFROMCHAR, (WPARAM)&pt, (LPARAM)lChar); return pt;}
_AFXCMN_INLINE UINT CRichEditCtrl::GetOptions() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, EM_GETOPTIONS, 0, 0); }
_AFXCMN_INLINE void CRichEditCtrl::SetOptions(WORD wOp, DWORD dwFlags)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETOPTIONS, (WPARAM)wOp, (LPARAM)dwFlags); }
_AFXCMN_INLINE BOOL CRichEditCtrl::SetAutoURLDetect(BOOL bEnable /* = TRUE */)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, EM_AUTOURLDETECT, (WPARAM) bEnable, 0); }
_AFXCMN_INLINE void CRichEditCtrl::EmptyUndoBuffer()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_EMPTYUNDOBUFFER, 0, 0); }
_AFXCMN_INLINE UINT CRichEditCtrl::SetUndoLimit(UINT nLimit)
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, EM_SETUNDOLIMIT, (WPARAM) nLimit, 0); }
_AFXCMN_INLINE void CRichEditCtrl::ReplaceSel(LPCTSTR lpszNewText, BOOL bCanUndo)
	{ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_REPLACESEL, (WPARAM) bCanUndo, (LPARAM)lpszNewText); }
_AFXCMN_INLINE void CRichEditCtrl::SetRect(LPCRECT lpRect)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETRECT, 0, (LPARAM)lpRect); }
_AFXCMN_INLINE void CRichEditCtrl::StopGroupTyping()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_STOPGROUPTYPING, 0, 0); }
_AFXCMN_INLINE BOOL CRichEditCtrl::Redo()
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, EM_REDO, 0, 0); }
_AFXCMN_INLINE BOOL CRichEditCtrl::Undo()
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_UNDO, 0, 0); }
_AFXCMN_INLINE void CRichEditCtrl::Clear()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_CLEAR, 0, 0); }
_AFXCMN_INLINE void CRichEditCtrl::Copy()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_COPY, 0, 0); }
_AFXCMN_INLINE void CRichEditCtrl::Cut()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_CUT, 0, 0); }
_AFXCMN_INLINE void CRichEditCtrl::Paste()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_PASTE, 0, 0); }
_AFXCMN_INLINE BOOL CRichEditCtrl::SetReadOnly(BOOL bReadOnly /* = TRUE */ )
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_SETREADONLY, bReadOnly, 0L); }
_AFXCMN_INLINE int CRichEditCtrl::GetFirstVisibleLine() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, EM_GETFIRSTVISIBLELINE, 0, 0L); }
_AFXCMN_INLINE BOOL CRichEditCtrl::DisplayBand(LPRECT pDisplayRect)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_DISPLAYBAND, 0, (LPARAM)pDisplayRect); }
_AFXCMN_INLINE void CRichEditCtrl::GetSel(CHARRANGE &cr) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_EXGETSEL, 0, (LPARAM)&cr); }
_AFXCMN_INLINE BOOL CRichEditCtrl::GetPunctuation(UINT fType, PUNCTUATION* lpPunc) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, EM_GETPUNCTUATION, (WPARAM) fType, (LPARAM) lpPunc); }
_AFXCMN_INLINE BOOL CRichEditCtrl::SetPunctuation(UINT fType, PUNCTUATION* lpPunc)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, EM_SETPUNCTUATION, (WPARAM) fType, (LPARAM) lpPunc); }
_AFXCMN_INLINE void CRichEditCtrl::LimitText(long nChars)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_EXLIMITTEXT, 0, nChars); }
_AFXCMN_INLINE long CRichEditCtrl::LineFromChar(long nIndex) const
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_EXLINEFROMCHAR, 0, nIndex); }
_AFXCMN_INLINE CPoint CRichEditCtrl::PosFromChar(UINT nChar) const
	{ ASSERT(::IsWindow(m_hWnd)); POINTL pt; ::SendMessage(m_hWnd, EM_POSFROMCHAR, (WPARAM)&pt, nChar); return CPoint(pt.x, pt.y); }
_AFXCMN_INLINE int CRichEditCtrl::CharFromPos(CPoint pt) const
	{ ASSERT(::IsWindow(m_hWnd)); POINTL ptl = {pt.x, pt.y}; return (int)::SendMessage(m_hWnd, EM_CHARFROMPOS, 0, (LPARAM)&ptl); }
_AFXCMN_INLINE void CRichEditCtrl::SetSel(CHARRANGE &cr)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_EXSETSEL, 0, (LPARAM)&cr); }
_AFXCMN_INLINE DWORD CRichEditCtrl::FindWordBreak(UINT nCode, DWORD nStart) const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD)::SendMessage(m_hWnd, EM_FINDWORDBREAK, (WPARAM) nCode, (LPARAM) nStart); }

_AFXCMN_INLINE long CRichEditCtrl::FindText(DWORD dwFlags, FINDTEXTEX* pFindText) const
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_FINDTEXTEX, dwFlags, (LPARAM)pFindText); }

_AFXCMN_INLINE long CRichEditCtrl::FormatRange(FORMATRANGE* pfr, BOOL bDisplay)
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_FORMATRANGE, (WPARAM)bDisplay, (LPARAM)pfr); }

_AFXCMN_INLINE long CRichEditCtrl::GetEventMask() const
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_GETEVENTMASK, 0, 0L); }

_AFXCMN_INLINE long CRichEditCtrl::GetLimitText() const
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_GETLIMITTEXT, 0, 0L); }

_AFXCMN_INLINE long CRichEditCtrl::GetSelText(_Pre_notnull_ _Post_z_ LPSTR lpBuf) const
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_GETSELTEXT, 0, (LPARAM)lpBuf); }

_AFXCMN_INLINE void CRichEditCtrl::HideSelection(BOOL bHide, BOOL bPerm)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_HIDESELECTION, bHide, bPerm); }

_AFXCMN_INLINE void CRichEditCtrl::RequestResize()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_REQUESTRESIZE, 0, 0L); }

_AFXCMN_INLINE WORD CRichEditCtrl::GetSelectionType() const
	{ ASSERT(::IsWindow(m_hWnd)); return (WORD)::SendMessage(m_hWnd, EM_SELECTIONTYPE, 0, 0L); }

_AFXCMN_INLINE UINT CRichEditCtrl::GetWordWrapMode() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, EM_GETWORDWRAPMODE, 0, 0); }

_AFXCMN_INLINE UINT CRichEditCtrl::SetWordWrapMode(UINT uFlags) const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, EM_SETWORDWRAPMODE, (WPARAM) uFlags, 0); }

_AFXCMN_INLINE COLORREF CRichEditCtrl::SetBackgroundColor(BOOL bSysColor, COLORREF cr)
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF)::SendMessage(m_hWnd, EM_SETBKGNDCOLOR, bSysColor, cr); }

_AFXCMN_INLINE DWORD CRichEditCtrl::SetEventMask(DWORD dwEventMask)
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD)::SendMessage(m_hWnd, EM_SETEVENTMASK, 0, dwEventMask); }

_AFXCMN_INLINE BOOL CRichEditCtrl::SetOLECallback(IRichEditOleCallback* pCallback)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_SETOLECALLBACK, 0, (LPARAM)pCallback); }

_AFXCMN_INLINE BOOL CRichEditCtrl::SetTargetDevice(HDC hDC, long lLineWidth)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_SETTARGETDEVICE, (WPARAM)hDC, lLineWidth); }

_AFXCMN_INLINE BOOL CRichEditCtrl::SetTargetDevice(CDC &dc, long lLineWidth)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_SETTARGETDEVICE, (WPARAM)dc.m_hDC, lLineWidth); }

_AFXCMN_INLINE long CRichEditCtrl::StreamIn(int nFormat, EDITSTREAM &es)
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_STREAMIN, nFormat, (LPARAM)&es); }

_AFXCMN_INLINE long CRichEditCtrl::StreamOut(int nFormat, EDITSTREAM &es)
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_STREAMOUT, nFormat, (LPARAM)&es); }

_AFXCMN_INLINE long CRichEditCtrl::GetTextLength() const
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, WM_GETTEXTLENGTH, NULL, NULL); }

#endif //!_AFX_NO_RICHEDIT_SUPPORT
/////////////////////////////////////////////////////////////////////////////

#endif //_AFXCMN_INLINE

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxcmn2.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXCMN.H (via WINCTRL6.CPP)

#pragma once

#ifdef _AFXCMN_INLINE

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE BOOL CStatusBarCtrl::IsSimple() const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, SB_ISSIMPLE, 0, 0); }
_AFXCMN_INLINE void CStatusBarCtrl::SetTipText(int nPane, LPCTSTR pszTipText)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, SB_SETTIPTEXT, nPane, (LPARAM)pszTipText); }
_AFXCMN_INLINE COLORREF CStatusBarCtrl::SetBkColor(COLORREF cr)
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, SB_SETBKCOLOR, 0, (LPARAM)cr); }
_AFXCMN_INLINE BOOL CStatusBarCtrl::SetIcon(int iPart, HICON hIcon)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, SB_SETICON, iPart, (LPARAM)hIcon); }
_AFXCMN_INLINE HICON CStatusBarCtrl::GetIcon(int iPart) const
	{ ASSERT(::IsWindow(m_hWnd)); return (HICON) ::SendMessage(m_hWnd, SB_GETICON, iPart, 0L); }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE void CSpinButtonCtrl::SetRange32(int nLower, int nUpper)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, UDM_SETRANGE32, (WPARAM) nLower, (LPARAM) nUpper); }
_AFXCMN_INLINE void CSpinButtonCtrl::GetRange32(int& nLower, int& nUpper) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, UDM_GETRANGE32, (WPARAM) &nLower, (LPARAM) &nUpper); }

#if _WIN32_IE >= 0x0500
_AFXCMN_INLINE int CSpinButtonCtrl::GetPos32(LPBOOL lpbError /*= NULL*/) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, UDM_GETPOS32, 0, (LPARAM)lpbError); }
_AFXCMN_INLINE int CSpinButtonCtrl::SetPos32(int nPos)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, UDM_SETPOS32, 0, (LPARAM)nPos); }
#endif

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE DWORD CToolBarCtrl::GetButtonSize() const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, TB_GETBUTTONSIZE, 0, 0L); }
_AFXCMN_INLINE CImageList* CToolBarCtrl::GetDisabledImageList() const
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, TB_GETDISABLEDIMAGELIST, 0, 0)); }
_AFXCMN_INLINE CImageList* CToolBarCtrl::GetHotImageList() const
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, TB_GETHOTIMAGELIST, 0, 0)); }
_AFXCMN_INLINE CImageList* CToolBarCtrl::GetImageList() const
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, TB_GETIMAGELIST, 0, 0)); }
_AFXCMN_INLINE DWORD CToolBarCtrl::GetStyle() const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, TB_GETSTYLE, 0, 0L); }
_AFXCMN_INLINE INT CToolBarCtrl::GetMaxTextRows() const
	{ ASSERT(::IsWindow(m_hWnd)); return (INT) ::SendMessage(m_hWnd, TB_GETTEXTROWS, 0, 0L); }
_AFXCMN_INLINE BOOL CToolBarCtrl::GetRect(int nID, LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_GETRECT, nID, (LPARAM)lpRect); }
_AFXCMN_INLINE BOOL CToolBarCtrl::IsButtonHighlighted(int nID) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_ISBUTTONHIGHLIGHTED, nID, 0); }
_AFXCMN_INLINE void CToolBarCtrl::LoadImages(int iBitmapID, HINSTANCE hinst)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TB_LOADIMAGES, iBitmapID, (LPARAM)hinst); }
_AFXCMN_INLINE BOOL CToolBarCtrl::SetButtonWidth(int cxMin, int cxMax)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_SETBUTTONWIDTH, 0, MAKELPARAM(cxMin, cxMax)); }
_AFXCMN_INLINE CImageList* CToolBarCtrl::SetDisabledImageList(CImageList* pImageList)
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, TB_SETDISABLEDIMAGELIST, 0, (LPARAM)pImageList->GetSafeHandle())); }
_AFXCMN_INLINE CImageList* CToolBarCtrl::SetHotImageList(CImageList* pImageList)
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, TB_SETHOTIMAGELIST, 0, (LPARAM)pImageList->GetSafeHandle())); }
_AFXCMN_INLINE CImageList* CToolBarCtrl::SetImageList(CImageList* pImageList)
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, TB_SETIMAGELIST, 0, (LPARAM)pImageList->GetSafeHandle())); }
_AFXCMN_INLINE BOOL CToolBarCtrl::SetIndent(int iIndent)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_SETINDENT, iIndent, 0L); }
_AFXCMN_INLINE BOOL CToolBarCtrl::SetMaxTextRows(int iMaxRows)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_SETMAXTEXTROWS, iMaxRows, 0L); }
_AFXCMN_INLINE void CToolBarCtrl::SetStyle(DWORD dwStyle)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TB_SETSTYLE, 0, dwStyle); }
_AFXCMN_INLINE int CToolBarCtrl::GetButtonInfo(int nID, TBBUTTONINFO* ptbbi) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TB_GETBUTTONINFO, nID, (LPARAM)ptbbi); }
_AFXCMN_INLINE BOOL CToolBarCtrl::SetButtonInfo(int nID, TBBUTTONINFO* ptbbi)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_SETBUTTONINFO, nID, (LPARAM)ptbbi); }
_AFXCMN_INLINE DWORD CToolBarCtrl::SetDrawTextFlags(DWORD dwMask, DWORD dwDTFlags)
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, TB_SETDRAWTEXTFLAGS, dwMask, dwDTFlags); }
_AFXCMN_INLINE BOOL CToolBarCtrl::GetAnchorHighlight() const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_GETANCHORHIGHLIGHT, 0, 0); }
_AFXCMN_INLINE BOOL CToolBarCtrl::SetAnchorHighlight(BOOL fAnchor)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_SETANCHORHIGHLIGHT, fAnchor, 0); }
_AFXCMN_INLINE int CToolBarCtrl::GetHotItem() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TB_GETHOTITEM, 0, 0); }
_AFXCMN_INLINE int CToolBarCtrl::SetHotItem(int nHot)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TB_SETHOTITEM, nHot, 0); }
_AFXCMN_INLINE void CToolBarCtrl::GetInsertMark(TBINSERTMARK* ptbim) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TB_GETINSERTMARK, 0, (LPARAM)ptbim); }
_AFXCMN_INLINE void CToolBarCtrl::SetInsertMark(TBINSERTMARK* ptbim)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, TB_SETINSERTMARK, 0, (LPARAM)ptbim); }
_AFXCMN_INLINE BOOL CToolBarCtrl::GetMaxSize(LPSIZE pSize) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_GETMAXSIZE, 0, (LPARAM)pSize); }
_AFXCMN_INLINE BOOL CToolBarCtrl::InsertMarkHitTest(LPPOINT ppt, LPTBINSERTMARK ptbim) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_INSERTMARKHITTEST, (WPARAM)ppt, (LPARAM)ptbim); }
_AFXCMN_INLINE BOOL CToolBarCtrl::MapAccelerator(TCHAR chAccel, UINT* pIDBtn)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_MAPACCELERATOR, (WPARAM)chAccel, (LPARAM)pIDBtn); }
_AFXCMN_INLINE BOOL CToolBarCtrl::MarkButton(int nID, BOOL bHighlight)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_MARKBUTTON, nID, MAKELPARAM(bHighlight, 0)); }
_AFXCMN_INLINE BOOL CToolBarCtrl::MoveButton(UINT nOldPos, UINT nNewPos)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TB_MOVEBUTTON, nOldPos, nNewPos); }

#if _WIN32_IE >= 0x0500
_AFXCMN_INLINE int CToolBarCtrl::GetString(_In_ int nString, _Out_z_cap_post_count_(cchMaxLen, return + 1) LPTSTR lpstrString, _In_ size_t cchMaxLen) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, TB_GETSTRING, MAKEWPARAM(cchMaxLen, nString), (LPARAM)lpstrString); lpstrString[cchMaxLen]=_T('\0'); }
#endif

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE DWORD CListCtrl::SetExtendedStyle(DWORD dwNewStyle)
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, (LPARAM) dwNewStyle); }
_AFXCMN_INLINE HCURSOR CListCtrl::SetHotCursor(HCURSOR hc)
	{ ASSERT(::IsWindow(m_hWnd) && hc != NULL); return (HCURSOR) ::SendMessage(m_hWnd, LVM_SETHOTCURSOR, 0, (LPARAM) hc); }
_AFXCMN_INLINE int CListCtrl::SetHotItem(int iIndex)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_SETHOTITEM, (WPARAM) iIndex, 0); }
_AFXCMN_INLINE void CListCtrl::SetWorkAreas(int nWorkAreas, LPRECT lpRect)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, LVM_SETWORKAREAS, nWorkAreas, (LPARAM) lpRect); }
_AFXCMN_INLINE int CListCtrl::SubItemHitTest(LPLVHITTESTINFO pInfo)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_SUBITEMHITTEST, 0, (LPARAM) pInfo); }
_AFXCMN_INLINE HCURSOR CListCtrl::GetHotCursor() const
	{ ASSERT(::IsWindow(m_hWnd)); return (HCURSOR) ::SendMessage(m_hWnd, LVM_GETHOTCURSOR, 0, 0); }
_AFXCMN_INLINE int CListCtrl::GetHotItem() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_GETHOTITEM, 0, 0); }
_AFXCMN_INLINE DWORD CListCtrl::GetExtendedStyle() const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0); }
_AFXCMN_INLINE CSize CListCtrl::ApproximateViewRect(CSize sz, int iCount) const
	{ ASSERT(::IsWindow(m_hWnd)); return CSize((DWORD) ::SendMessage(m_hWnd, LVM_APPROXIMATEVIEWRECT, iCount, MAKELPARAM(sz.cx, sz.cy))); }
_AFXCMN_INLINE BOOL CListCtrl::GetBkImage(LVBKIMAGE* plvbkImage) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, LVM_GETBKIMAGE, 0, (LPARAM)plvbkImage); }
_AFXCMN_INLINE DWORD CListCtrl::GetHoverTime() const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, LVM_GETHOVERTIME, 0, 0); }
_AFXCMN_INLINE void CListCtrl::GetWorkAreas(int nWorkAreas, LPRECT prc) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, LVM_GETWORKAREAS, nWorkAreas, (LPARAM)prc); }
_AFXCMN_INLINE BOOL CListCtrl::SetBkImage(LVBKIMAGE* plvbkImage)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, LVM_SETBKIMAGE, 0, (LPARAM)plvbkImage); }
_AFXCMN_INLINE DWORD CListCtrl::SetHoverTime(DWORD dwHoverTime)
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD)::SendMessage(m_hWnd, LVM_SETHOVERTIME, 0, dwHoverTime); }
_AFXCMN_INLINE UINT CListCtrl::GetNumberOfWorkAreas() const
	{ ASSERT(::IsWindow(m_hWnd)); UINT nWorkAreas; ::SendMessage(m_hWnd, LVM_GETNUMBEROFWORKAREAS, 0, (LPARAM)&nWorkAreas); return nWorkAreas; }
_AFXCMN_INLINE int CListCtrl::SetSelectionMark(int iIndex)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_SETSELECTIONMARK, 0, (LPARAM) iIndex); }
_AFXCMN_INLINE int CListCtrl::GetSelectionMark() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, LVM_GETSELECTIONMARK, 0, 0); }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE BOOL CHeaderCtrl::GetItemRect(int nIndex, LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); ASSERT(lpRect != NULL); return (BOOL)::SendMessage(m_hWnd, HDM_GETITEMRECT, nIndex, (LPARAM)lpRect); }
_AFXCMN_INLINE int CHeaderCtrl::OrderToIndex(int nOrder) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, HDM_ORDERTOINDEX, nOrder, 0); }
_AFXCMN_INLINE int CHeaderCtrl::SetHotDivider(CPoint pt)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, HDM_SETHOTDIVIDER, TRUE, MAKELPARAM(pt.x, pt.y)); }
_AFXCMN_INLINE int CHeaderCtrl::SetHotDivider(int nIndex)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, HDM_SETHOTDIVIDER, FALSE, nIndex); }
_AFXCMN_INLINE CImageList* CHeaderCtrl::GetImageList(_In_ int nImageList /* = HDSIL_NORMAL */) const
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, HDM_GETIMAGELIST, nImageList, 0L)); }
_AFXCMN_INLINE CImageList* CHeaderCtrl::SetImageList(CImageList* pImageList, _In_ int nImageList /* = HDSIL_NORMAL */)
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, HDM_SETIMAGELIST, nImageList, (LPARAM)pImageList->GetSafeHandle())); }
_AFXCMN_INLINE CImageList* CHeaderCtrl::CreateDragImage(int nIndex)
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, HDM_CREATEDRAGIMAGE, nIndex, 0L)); }

#if _WIN32_IE >= 0x0500
_AFXCMN_INLINE int CHeaderCtrl::GetBitmapMargin() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, HDM_GETBITMAPMARGIN, 0, 0L); }
_AFXCMN_INLINE int CHeaderCtrl::SetBitmapMargin(int nWidth)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, HDM_SETBITMAPMARGIN, nWidth, 0L); }
_AFXCMN_INLINE int CHeaderCtrl::SetFilterChangeTimeout(DWORD dwTimeOut)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, HDM_SETFILTERCHANGETIMEOUT, 0, dwTimeOut); }
_AFXCMN_INLINE int CHeaderCtrl::EditFilter(int nColumn, BOOL bDiscardChanges)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, HDM_EDITFILTER, nColumn, MAKELPARAM(bDiscardChanges, 0)); }
_AFXCMN_INLINE BOOL CHeaderCtrl::ClearFilter(int nColumn)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, HDM_CLEARFILTER, nColumn, 0L); }
_AFXCMN_INLINE BOOL CHeaderCtrl::ClearAllFilters()
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, HDM_CLEARFILTER, (WPARAM)-1, 0L); }
#endif

#if (_WIN32_WINNT >= 0x600) && defined(UNICODE)
_AFXCMN_INLINE BOOL CHeaderCtrl::GetItemDropDownRect(int iItem, LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); return Header_GetItemDropDownRect(m_hWnd, iItem, lpRect); } // HDM_GETITEMDROPDOWNRECT
_AFXCMN_INLINE BOOL CHeaderCtrl::GetOverflowRect(LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); return Header_GetOverflowRect(m_hWnd, lpRect); } // HDM_GETOVERFLOWRECT
_AFXCMN_INLINE int CHeaderCtrl::GetFocusedItem() const
	{ ASSERT(::IsWindow(m_hWnd)); return Header_GetFocusedItem(m_hWnd); } // HDM_GETFOCUSEDITEM
_AFXCMN_INLINE BOOL CHeaderCtrl::SetFocusedItem(int iItem)
	{ ASSERT(::IsWindow(m_hWnd)); return Header_SetFocusedItem(m_hWnd, iItem); } // HDM_SETFOCUSEDITEM
#endif // _WIN32_WINNT >= 0x600 && defined(UNICODE)

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CReBarCtrl::CReBarCtrl()
	{ }
_AFXCMN_INLINE UINT CReBarCtrl::GetBandCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, RB_GETBANDCOUNT, 0, 0L); }
_AFXCMN_INLINE BOOL CReBarCtrl::GetBandInfo(UINT uBand, REBARBANDINFO* prbbi) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, RB_GETBANDINFO, uBand, (LPARAM)prbbi); }
_AFXCMN_INLINE UINT CReBarCtrl::GetBarHeight() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, RB_GETBARHEIGHT, 0, 0L); }
_AFXCMN_INLINE BOOL CReBarCtrl::GetBarInfo(REBARINFO* prbi) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, RB_GETBARINFO, 0, (LPARAM)prbi); }
_AFXCMN_INLINE COLORREF CReBarCtrl::GetBkColor() const
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, RB_GETBKCOLOR, 0, 0L); }
_AFXCMN_INLINE IDropTarget* CReBarCtrl::GetDropTarget() const
	{ ASSERT(::IsWindow(m_hWnd)); IDropTarget* pdt; ::SendMessage(m_hWnd, RB_GETDROPTARGET, 0, (LPARAM)&pdt); return pdt; }
_AFXCMN_INLINE BOOL CReBarCtrl::GetRect(UINT uBand, LPRECT prc) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, RB_GETRECT, uBand, (LPARAM)prc); }
_AFXCMN_INLINE UINT CReBarCtrl::GetRowCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, RB_GETROWCOUNT, 0, 0L); }
_AFXCMN_INLINE UINT CReBarCtrl::GetRowHeight(UINT uRow) const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT) ::SendMessage(m_hWnd, RB_GETROWHEIGHT, uRow, 0L); }
_AFXCMN_INLINE COLORREF CReBarCtrl::GetTextColor() const
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, RB_GETTEXTCOLOR, 0, 0L); }
_AFXCMN_INLINE CToolTipCtrl* CReBarCtrl::GetToolTips() const
	{ ASSERT(::IsWindow(m_hWnd)); return (CToolTipCtrl*)CWnd::FromHandle((HWND)::SendMessage(m_hWnd, RB_GETTOOLTIPS, 0, 0L)); }
_AFXCMN_INLINE int CReBarCtrl::IDToIndex(UINT uBandID) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, RB_IDTOINDEX, uBandID, 0L); }
_AFXCMN_INLINE BOOL CReBarCtrl::SetBandInfo(UINT uBand, REBARBANDINFO* prbbi)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, RB_SETBANDINFO, uBand, (LPARAM)prbbi); }
_AFXCMN_INLINE BOOL CReBarCtrl::SetBarInfo(REBARINFO* prbi)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, RB_SETBARINFO, 0, (LPARAM)prbi); }
_AFXCMN_INLINE COLORREF CReBarCtrl::SetBkColor(COLORREF clr)
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, RB_SETBKCOLOR, 0, (LPARAM)clr); }
_AFXCMN_INLINE CWnd* CReBarCtrl::SetOwner(CWnd* pWnd)
	{ ASSERT(::IsWindow(m_hWnd)); CWnd::SetOwner(pWnd);  return CWnd::FromHandle((HWND)::SendMessage(m_hWnd, RB_SETPARENT, (WPARAM)pWnd->m_hWnd, 0L)); }
_AFXCMN_INLINE COLORREF CReBarCtrl::SetTextColor(COLORREF clr)
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, RB_SETTEXTCOLOR, 0, (LPARAM)clr); }
_AFXCMN_INLINE void CReBarCtrl::SetToolTips(CToolTipCtrl* pTip)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, RB_SETTOOLTIPS, (WPARAM)pTip->m_hWnd, 0L); }
_AFXCMN_INLINE void CReBarCtrl::BeginDrag(UINT uBand, DWORD dwPos)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, RB_BEGINDRAG, uBand, dwPos); }
_AFXCMN_INLINE BOOL CReBarCtrl::DeleteBand(UINT uBand)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, RB_DELETEBAND, uBand, 0L); }
_AFXCMN_INLINE void CReBarCtrl::DragMove(DWORD dwPos)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, RB_DRAGMOVE, 0, dwPos); }
_AFXCMN_INLINE void CReBarCtrl::EndDrag()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, RB_ENDDRAG, 0, 0L); }
_AFXCMN_INLINE int CReBarCtrl::HitTest(RBHITTESTINFO* prbht)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, RB_HITTEST, 0, (LPARAM)prbht); }
_AFXCMN_INLINE BOOL CReBarCtrl::InsertBand(UINT uIndex, REBARBANDINFO* prbbi)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, RB_INSERTBAND, uIndex, (LPARAM)prbbi); }
_AFXCMN_INLINE void CReBarCtrl::MaximizeBand(UINT uBand)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, RB_MAXIMIZEBAND, uBand, 0L); }
_AFXCMN_INLINE void CReBarCtrl::MinimizeBand(UINT uBand)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, RB_MINIMIZEBAND, uBand, 0L); }
_AFXCMN_INLINE void CReBarCtrl::RestoreBand(UINT uBand)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, RB_MAXIMIZEBAND, uBand, 1L); }
_AFXCMN_INLINE BOOL CReBarCtrl::SizeToRect(CRect& rect)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, RB_SIZETORECT, 0, (LPARAM)&rect); }
_AFXCMN_INLINE BOOL CReBarCtrl::ShowBand(UINT uBand, BOOL fShow /*= TRUE*/)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, RB_SHOWBAND, uBand, fShow); }
_AFXCMN_INLINE void CReBarCtrl::GetBandBorders(UINT uBand, LPRECT prc) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, RB_GETBANDBORDERS, uBand, (LPARAM)prc); }
_AFXCMN_INLINE CPalette* CReBarCtrl::GetPalette() const
	{ ASSERT(::IsWindow(m_hWnd)); return CPalette::FromHandle((HPALETTE)::SendMessage(m_hWnd, RB_GETPALETTE, 0, 0L)); }
_AFXCMN_INLINE CPalette* CReBarCtrl::SetPalette(HPALETTE hPal)
	{ ASSERT(::IsWindow(m_hWnd)); return CPalette::FromHandle((HPALETTE)::SendMessage(m_hWnd, RB_SETPALETTE, 0, (LPARAM)hPal)); }
_AFXCMN_INLINE BOOL CReBarCtrl::MoveBand(UINT uFrom, UINT uTo)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, RB_MOVEBAND, uFrom, uTo); }

#if _WIN32_IE >= 0x0500
_AFXCMN_INLINE void CReBarCtrl::PushChevron(UINT uBand, LPARAM lAppValue)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, RB_PUSHCHEVRON, uBand, lAppValue); }
#endif

#if (_WIN32_WINNT >= 0x0600) && defined(UNICODE)
_AFXCMN_INLINE BOOL CReBarCtrl::SetBandWidth(UINT uBand, int cxWidth)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, RB_SETBANDWIDTH, (WPARAM)uBand, (LPARAM)cxWidth); }
_AFXCMN_INLINE DWORD CReBarCtrl::SetExtendedStyle(DWORD dwMask, DWORD dwStyleEx)
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, RB_SETEXTENDEDSTYLE, dwMask, dwStyleEx); }
_AFXCMN_INLINE DWORD CReBarCtrl::GetExtendedStyle() const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, RB_GETEXTENDEDSTYLE, 0, 0L); }
#endif // _WIN32_WINNT >= 0x0600 && defined(UNICODE)

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE void CToolTipCtrl::SetDelayTime(UINT nDelay)
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_SETDELAYTIME, 0, nDelay); }
_AFXCMN_INLINE int CToolTipCtrl::GetDelayTime(DWORD dwDuration) const
	{ ASSERT(::IsWindow(m_hWnd));  return (int) ::SendMessage(m_hWnd, TTM_GETDELAYTIME, dwDuration, 0L); }
_AFXCMN_INLINE void CToolTipCtrl::GetMargin(LPRECT lprc) const
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_GETMARGIN, 0, (LPARAM)lprc); }
_AFXCMN_INLINE int CToolTipCtrl::GetMaxTipWidth() const
	{ ASSERT(::IsWindow(m_hWnd));  return (int) ::SendMessage(m_hWnd, TTM_GETMAXTIPWIDTH, 0, 0L); }
_AFXCMN_INLINE COLORREF CToolTipCtrl::GetTipBkColor() const
	{ ASSERT(::IsWindow(m_hWnd));  return (COLORREF) ::SendMessage(m_hWnd, TTM_GETTIPBKCOLOR, 0, 0L); }
_AFXCMN_INLINE COLORREF CToolTipCtrl::GetTipTextColor() const
	{ ASSERT(::IsWindow(m_hWnd));  return (COLORREF) ::SendMessage(m_hWnd, TTM_GETTIPTEXTCOLOR, 0, 0L); }
_AFXCMN_INLINE void CToolTipCtrl::Pop()
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_POP, 0, 0L); }
_AFXCMN_INLINE void CToolTipCtrl::SetDelayTime(DWORD dwDuration, int iTime)
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_SETDELAYTIME, dwDuration, MAKELPARAM(iTime, 0)); }
_AFXCMN_INLINE void CToolTipCtrl::SetMargin(LPRECT lprc)
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_SETMARGIN, 0, (LPARAM)lprc); }
_AFXCMN_INLINE int CToolTipCtrl::SetMaxTipWidth(int iWidth)
	{ ASSERT(::IsWindow(m_hWnd));  return (int) ::SendMessage(m_hWnd, TTM_SETMAXTIPWIDTH, 0, iWidth); }
_AFXCMN_INLINE void CToolTipCtrl::SetTipBkColor(COLORREF clr)
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_SETTIPBKCOLOR, clr, 0L); }
_AFXCMN_INLINE void CToolTipCtrl::SetTipTextColor(COLORREF clr)
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_SETTIPTEXTCOLOR, clr, 0L); }
_AFXCMN_INLINE void CToolTipCtrl::Update()
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_UPDATE, 0, 0L); }
_AFXCMN_INLINE BOOL CToolTipCtrl::GetCurrentTool(LPTOOLINFO lpToolInfo) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, TTM_GETCURRENTTOOL, 0, (LPARAM)lpToolInfo); }

#if _WIN32_IE >= 0x0500
_AFXCMN_INLINE CSize CToolTipCtrl::GetBubbleSize(LPTOOLINFO lpToolInfo) const
	{ ASSERT(::IsWindow(m_hWnd));  return CSize((DWORD)::SendMessage(m_hWnd, TTM_GETBUBBLESIZE, 0, (LPARAM)lpToolInfo)); }
_AFXCMN_INLINE BOOL CToolTipCtrl::AdjustRect(LPRECT lprc, BOOL bLarger /*= TRUE*/)
	{ ASSERT(::IsWindow(m_hWnd));  return (BOOL)::SendMessage(m_hWnd, TTM_ADJUSTRECT, bLarger, (LPARAM)lprc); }
_AFXCMN_INLINE BOOL CToolTipCtrl::SetTitle(UINT uIcon, LPCTSTR lpstrTitle)
	{ ASSERT(::IsWindow(m_hWnd));  return (BOOL)::SendMessage(m_hWnd, TTM_SETTITLE, uIcon, (LPARAM)lpstrTitle); }
#endif

#if (_WIN32_WINNT >= 0x0501) && defined(UNICODE)
_AFXCMN_INLINE void CToolTipCtrl::Popup()
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_POPUP, 0, 0L); }
_AFXCMN_INLINE void CToolTipCtrl::GetTitle(PTTGETTITLE pTTGetTitle) const
	{ ASSERT(::IsWindow(m_hWnd));  ::SendMessage(m_hWnd, TTM_GETTITLE, 0, (LPARAM)pTTGetTitle); }
#endif
/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CComboBoxEx::CComboBoxEx()
	{ }
_AFXCMN_INLINE DWORD CComboBoxEx::GetExtendedStyle() const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, CBEM_GETEXTENDEDSTYLE, 0, 0); }
_AFXCMN_INLINE DWORD CComboBoxEx::SetExtendedStyle(DWORD dwExMask, DWORD dwExStyles)
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, CBEM_SETEXTENDEDSTYLE, (DWORD) dwExMask, (LPARAM) dwExStyles); }
_AFXCMN_INLINE BOOL CComboBoxEx::HasEditChanged()
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, CBEM_HASEDITCHANGED, 0, 0); }
_AFXCMN_INLINE CEdit* CComboBoxEx::GetEditCtrl() const
	{ ASSERT(::IsWindow(m_hWnd)); return (CEdit*) CEdit::FromHandle((HWND) ::SendMessage(m_hWnd, CBEM_GETEDITCONTROL, 0, 0)); }
_AFXCMN_INLINE CComboBox* CComboBoxEx::GetComboBoxCtrl() const
	{ ASSERT(::IsWindow(m_hWnd)); return (CComboBox*) CComboBox::FromHandle((HWND) ::SendMessage(m_hWnd, CBEM_GETCOMBOCONTROL, 0, 0)); }
_AFXCMN_INLINE CImageList* CComboBoxEx::SetImageList(CImageList* pImageList)
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, CBEM_SETIMAGELIST, 0, (LPARAM)pImageList->GetSafeHandle())); }
_AFXCMN_INLINE CImageList* CComboBoxEx::GetImageList() const
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, CBEM_GETIMAGELIST, 0, 0)); }

// While CComboBoxEx derives from CComboBox, there are some
// CB_messages the underlying ComboBoxEx control doesn't support.

_AFXCMN_INLINE int CComboBoxEx::Dir(UINT attr, LPCTSTR lpszWildCard)
	{ UNUSED_ALWAYS(attr); UNUSED_ALWAYS(lpszWildCard);
		ASSERT(FALSE); return CB_ERR; }
_AFXCMN_INLINE int CComboBoxEx::FindString(int nIndexStart, LPCTSTR lpszFind) const
	{ UNUSED_ALWAYS(nIndexStart); UNUSED_ALWAYS(lpszFind);
		ASSERT(FALSE); return CB_ERR; }
_AFXCMN_INLINE int CComboBoxEx::AddString(LPCTSTR lpszString)
	{ UNUSED_ALWAYS(lpszString); ASSERT(FALSE); return CB_ERR;}
_AFXCMN_INLINE BOOL CComboBoxEx::SetEditSel(int nStartChar, int nEndChar)
	{ UNUSED_ALWAYS(nStartChar); UNUSED_ALWAYS(nEndChar);
		ASSERT(FALSE); return FALSE; }
_AFXCMN_INLINE int CComboBoxEx::InsertString(int nIndex, LPCTSTR lpszString)
	{ UNUSED_ALWAYS(nIndex); UNUSED_ALWAYS(lpszString);
		ASSERT(FALSE); return CB_ERR; }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE int CProgressCtrl::SetPos(int nPos)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, PBM_SETPOS, nPos, 0L); }

#if (_WIN32_IE >= 0x0400)
_AFXCMN_INLINE COLORREF CProgressCtrl::SetBarColor(COLORREF clrBar)
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, PBM_SETBARCOLOR, 0, clrBar); }
#endif	// _WIN32_IE >= 0x0400

#if (_WIN32_WINNT >= 0x0501) && defined(UNICODE)
_AFXCMN_INLINE BOOL CProgressCtrl::SetMarquee(BOOL fMarqueeMode, int nInterval)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, PBM_SETMARQUEE, (WPARAM)fMarqueeMode, (LPARAM)nInterval); }
#endif	// _WIN32_WINNT >= 0x0501 && defined(UNICODE)

#if (_WIN32_WINNT >= 0x0600) && defined(UNICODE)
_AFXCMN_INLINE int CProgressCtrl::GetStep() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, PBM_GETSTEP, 0, 0L); }
_AFXCMN_INLINE COLORREF CProgressCtrl::GetBkColor() const
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, PBM_GETBKCOLOR, 0, 0L); }
_AFXCMN_INLINE COLORREF CProgressCtrl::GetBarColor() const
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, PBM_GETBARCOLOR, 0, 0L); }
_AFXCMN_INLINE int CProgressCtrl::SetState(int iState)
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, PBM_SETSTATE, (WPARAM)iState, 0L); }
_AFXCMN_INLINE int CProgressCtrl::GetState() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, PBM_GETSTATE, 0, 0L); }
#endif	// _WIN32_WINNT >= 0x0600 && defined(UNICODE)

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE CIPAddressCtrl::CIPAddressCtrl()
	{ }
_AFXCMN_INLINE void CIPAddressCtrl::ClearAddress()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, IPM_CLEARADDRESS, 0, 0L); }
_AFXCMN_INLINE BOOL CIPAddressCtrl::IsBlank() const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, IPM_ISBLANK, 0, 0L); }
_AFXCMN_INLINE int CIPAddressCtrl::GetAddress(DWORD& dwAddress) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int) ::SendMessage(m_hWnd, IPM_GETADDRESS, 0, (LPARAM) &dwAddress); }
_AFXCMN_INLINE void CIPAddressCtrl::SetAddress(DWORD dwAddress)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, IPM_SETADDRESS, 0, (LPARAM) dwAddress); }
_AFXCMN_INLINE void CIPAddressCtrl::SetAddress(BYTE nField0, BYTE nField1, BYTE nField2, BYTE nField3)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, IPM_SETADDRESS, 0, (LPARAM) MAKEIPADDRESS(nField0, nField1, nField2, nField3)); }
_AFXCMN_INLINE void CIPAddressCtrl::SetFieldFocus(WORD nField)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, IPM_SETFOCUS, (WPARAM) nField, 0); }
_AFXCMN_INLINE void CIPAddressCtrl::SetFieldRange(int nField, BYTE nLower, BYTE nUpper)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, IPM_SETRANGE, (WPARAM) nField, MAKEIPRANGE(nLower, nUpper)); }

/////////////////////////////////////////////////////////////////////////////

_AFXCMN_INLINE BOOL CImageList::SetImageCount(UINT uNewCount)
	{ ASSERT(m_hImageList != NULL); return AfxImageList_SetImageCount(m_hImageList, uNewCount); }
_AFXCMN_INLINE BOOL CImageList::Copy(int iDst, int iSrc, UINT uFlags /* = ILCF_MOVE */)
	{ ASSERT(m_hImageList != NULL); return AfxImageList_Copy(m_hImageList, iDst, m_hImageList, iSrc, uFlags); }
_AFXCMN_INLINE BOOL CImageList::Copy(int iDst, CImageList* pSrc, int iSrc, UINT uFlags /* = ILCF_MOVE */)
	{ ASSERT(m_hImageList != NULL); ASSERT(pSrc != NULL && (HIMAGELIST)*pSrc != NULL); return AfxImageList_Copy(m_hImageList, iDst, *pSrc, iSrc, uFlags); }

/////////////////////////////////////////////////////////////////////////////

#endif //_AFXCMN_INLINE

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxcmn3.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXCMN.H
// Contains wrappers for API's messages not in all supported
// platforms

#if (_WIN32_WINNT >= 0x0501)

#include <atlchecked.h>

AFX_INLINE HRESULT CToolTipCtrl::SetWindowTheme(LPCWSTR pszSubAppName)
	{ ASSERT(::IsWindow(m_hWnd)); return (HRESULT)::SendMessage(m_hWnd, TTM_SETWINDOWTHEME, 0, (LPARAM)pszSubAppName); }

AFX_INLINE HRESULT CComboBoxEx::SetWindowTheme(LPCWSTR pszSubAppName)
	{ ASSERT(::IsWindow(m_hWnd)); return (HRESULT)::SendMessage(m_hWnd, CBEM_SETWINDOWTHEME, 0, (LPARAM)pszSubAppName); }

AFX_INLINE void CReBarCtrl::GetBandMargins(PMARGINS pMargins) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, RB_GETBANDMARGINS, 0, (LPARAM)pMargins); }

AFX_INLINE HRESULT CReBarCtrl::SetWindowTheme(LPCWSTR pszSubAppName)
	{ ASSERT(::IsWindow(m_hWnd)); return (HRESULT)::SendMessage(m_hWnd, RB_SETWINDOWTHEME, 0, (LPARAM)pszSubAppName); }

AFX_INLINE void CToolBarCtrl::GetMetrics(LPTBMETRICS ptbm) const
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(ptbm != NULL);
	::SendMessage(m_hWnd, TB_GETMETRICS, 0, (LPARAM)ptbm);
}

AFX_INLINE void CToolBarCtrl::SetMetrics(LPTBMETRICS ptbm)
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(ptbm != NULL);
	::SendMessage(m_hWnd, TB_SETMETRICS, 0, (LPARAM)ptbm);
}

AFX_INLINE HRESULT CToolBarCtrl::SetWindowTheme(LPCWSTR pszSubAppName)
	{ ASSERT(::IsWindow(m_hWnd)); return (HRESULT)::SendMessage(m_hWnd, TB_SETWINDOWTHEME, 0, (LPARAM)pszSubAppName); }

#endif	// _WIN32_WINNT >= 0x0501

#if (_WIN32_WINNT >= 0x600) && defined(UNICODE)

AFX_INLINE CImageList* CToolBarCtrl::SetPressedImageList(int iImageID, CImageList* pImageList)
	{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, TB_SETPRESSEDIMAGELIST, (WPARAM)iImageID, (LPARAM)pImageList->GetSafeHandle())); }

AFX_INLINE CImageList* CToolBarCtrl::GetPressedImageList() const
{ ASSERT(::IsWindow(m_hWnd)); return CImageList::FromHandle((HIMAGELIST) ::SendMessage(m_hWnd, TB_GETPRESSEDIMAGELIST, 0, 0L)); }

#endif // _WIN32_WINNT >= 0x600 && defined(UNICODE)

#if (_WIN32_WINNT >= 0x0501)

AFX_INLINE void CListCtrl::SetSelectedColumn(int iCol)
{
	ASSERT(::IsWindow(m_hWnd));
	ListView_SetSelectedColumn(m_hWnd, iCol); // LVM_SETSELECTEDCOLUMN
}
AFX_INLINE DWORD CListCtrl::SetView(int iView)
{
	ASSERT(::IsWindow(m_hWnd));
	return ListView_SetView(m_hWnd, iView); // LVM_SETVIEW
}
AFX_INLINE DWORD CListCtrl::GetView() const
{
	ASSERT(::IsWindow(m_hWnd));
	return ListView_GetView(m_hWnd); // LVM_GETVIEW
}
AFX_INLINE int CListCtrl::InsertGroup(int index, PLVGROUP pgrp)
{
	ASSERT(::IsWindow(m_hWnd));
	return (int)ListView_InsertGroup(m_hWnd, index, pgrp); // LVM_INSERTGROUP
}
AFX_INLINE int CListCtrl::SetGroupInfo(int iGroupId, PLVGROUP pGroup)
{
	ASSERT(::IsWindow(m_hWnd));
	return (int)ListView_SetGroupInfo(m_hWnd, iGroupId, pGroup); // LVM_SETGROUPINFO
}
AFX_INLINE int CListCtrl::GetGroupInfo(int iGroupId, PLVGROUP pgrp) const
{
	ASSERT(::IsWindow(m_hWnd));
	return (int)ListView_GetGroupInfo(m_hWnd, iGroupId, pgrp); // LVM_GETGROUPINFO
}
AFX_INLINE int CListCtrl::RemoveGroup(int iGroupId)
{
	ASSERT(::IsWindow(m_hWnd));
	return (int)ListView_RemoveGroup(m_hWnd, iGroupId); // LVM_REMOVEGROUP
}
AFX_INLINE void CListCtrl::MoveGroup(int iGroupId, int toIndex)
{
	ASSERT(::IsWindow(m_hWnd));
	ListView_MoveGroup(m_hWnd, iGroupId, toIndex); // LVM_MOVEGROUP
}
AFX_INLINE void CListCtrl::MoveItemToGroup(int idItemFrom, int idGroupTo)
{
	ASSERT(::IsWindow(m_hWnd));
	ListView_MoveItemToGroup(m_hWnd, idItemFrom, idGroupTo); // LVM_MOVEITEMTOGROUP
}
AFX_INLINE void CListCtrl::SetGroupMetrics(PLVGROUPMETRICS pGroupMetrics)
{
	ASSERT(::IsWindow(m_hWnd));
	ListView_SetGroupMetrics(m_hWnd, pGroupMetrics); // LVM_SETGROUPMETRICS
}
AFX_INLINE void CListCtrl::GetGroupMetrics(PLVGROUPMETRICS pGroupMetrics) const
{
	ASSERT(::IsWindow(m_hWnd));
	ListView_GetGroupMetrics(m_hWnd, pGroupMetrics); // LVM_GETGROUPMETRICS
}
AFX_INLINE int CListCtrl::EnableGroupView(BOOL fEnable)
{
	ASSERT(::IsWindow(m_hWnd));
	return (int)ListView_EnableGroupView(m_hWnd, fEnable); // LVM_ENABLEGROUPVIEW
}
AFX_INLINE BOOL CListCtrl::SortGroups(PFNLVGROUPCOMPARE _pfnGroupCompare, LPVOID _plv)
{
	ASSERT(::IsWindow(m_hWnd));
	return (BOOL)ListView_SortGroups(m_hWnd, _pfnGroupCompare, _plv); // LVM_SORTGROUPS
}
AFX_INLINE void CListCtrl::InsertGroupSorted(PLVINSERTGROUPSORTED pStructInsert)
{
	ASSERT(::IsWindow(m_hWnd));
	ListView_InsertGroupSorted(m_hWnd, pStructInsert); // LVM_INSERTGROUPSORTED
}
AFX_INLINE void CListCtrl::RemoveAllGroups()
{
	ASSERT(::IsWindow(m_hWnd));
	ListView_RemoveAllGroups(m_hWnd); // LVM_REMOVEALLGROUPS
}
AFX_INLINE BOOL CListCtrl::HasGroup(int iGroupId) const
{
	ASSERT(::IsWindow(m_hWnd));
	return (BOOL)ListView_HasGroup(m_hWnd, iGroupId); // LVM_HASGROUP
}
AFX_INLINE BOOL CListCtrl::SetTileViewInfo(PLVTILEVIEWINFO ptvi)
{
	ASSERT(::IsWindow(m_hWnd));
	return (BOOL)ListView_SetTileViewInfo(m_hWnd, ptvi); // LVM_SETTILEVIEWINFO
}
AFX_INLINE BOOL CListCtrl::GetTileViewInfo(PLVTILEVIEWINFO ptvi) const
{
	ASSERT(::IsWindow(m_hWnd));
	return (BOOL)ListView_GetTileViewInfo(m_hWnd, ptvi); // LVM_GETTILEVIEWINFO
}
AFX_INLINE BOOL CListCtrl::SetTileInfo(PLVTILEINFO pti)
{
	ASSERT(::IsWindow(m_hWnd));
	return (BOOL)ListView_SetTileInfo(m_hWnd, pti); // LVM_SETTILEINFO
}
AFX_INLINE BOOL CListCtrl::GetTileInfo(PLVTILEINFO pti) const
{
	ASSERT(::IsWindow(m_hWnd));
	return (BOOL)ListView_GetTileInfo(m_hWnd, pti); // LVM_GETTILEINFO
}
AFX_INLINE BOOL CListCtrl::SetInsertMark(LPLVINSERTMARK lvim)
{
	ASSERT(::IsWindow(m_hWnd));
	return (BOOL)ListView_SetInsertMark(m_hWnd, lvim); // LVM_SETINSERTMARK
}
AFX_INLINE BOOL CListCtrl::GetInsertMark(LPLVINSERTMARK lvim) const
{
	ASSERT(::IsWindow(m_hWnd));
	return (BOOL)ListView_GetInsertMark(m_hWnd, lvim); // LVM_GETINSERTMARK
}
AFX_INLINE int CListCtrl::InsertMarkHitTest(LPPOINT pPoint, LPLVINSERTMARK lvim) const
{
	ASSERT(::IsWindow(m_hWnd));
	return (int)ListView_InsertMarkHitTest(m_hWnd, pPoint, lvim); // LVM_INSERTMARKHITTEST
}
AFX_INLINE int CListCtrl::GetInsertMarkRect(LPRECT pRect) const
{
	ASSERT(::IsWindow(m_hWnd));
	return (int)ListView_GetInsertMarkRect(m_hWnd, pRect); // LVM_GETINSERTMARKRECT
}
AFX_INLINE COLORREF CListCtrl::SetInsertMarkColor(COLORREF color)
{
	ASSERT(::IsWindow(m_hWnd));
	return (COLORREF)ListView_SetInsertMarkColor(m_hWnd, color); // LVM_SETINSERTMARKCOLOR
}
AFX_INLINE COLORREF CListCtrl::GetInsertMarkColor() const
{
	ASSERT(::IsWindow(m_hWnd));
	return ListView_GetInsertMarkColor(m_hWnd); // LVM_GETINSERTMARKCOLOR
}
AFX_INLINE BOOL CListCtrl::SetInfoTip(PLVSETINFOTIP plvInfoTip)
{
	ASSERT(::IsWindow(m_hWnd));
	return ListView_SetInfoTip(m_hWnd, plvInfoTip); // LVM_SETINFOTIP
}
AFX_INLINE UINT CListCtrl::GetSelectedColumn() const
{
	ASSERT(::IsWindow(m_hWnd));
	return ListView_GetSelectedColumn(m_hWnd); // LVM_GETSELECTEDCOLUMN
}
AFX_INLINE BOOL CListCtrl::IsGroupViewEnabled() const
{
	ASSERT(::IsWindow(m_hWnd));
	return ListView_IsGroupViewEnabled(m_hWnd); // LVM_ISGROUPVIEWENABLED
}
AFX_INLINE COLORREF CListCtrl::GetOutlineColor() const
{
	ASSERT(::IsWindow(m_hWnd));
	return ListView_GetOutlineColor(m_hWnd); // LVM_GETOUTLINECOLOR
}
AFX_INLINE COLORREF CListCtrl::SetOutlineColor(COLORREF color)
{
	ASSERT(::IsWindow(m_hWnd));
	return ListView_SetOutlineColor(m_hWnd, color); // LVM_SETOUTLINECOLOR
}
AFX_INLINE void CListCtrl::CancelEditLabel()
{
	ASSERT(::IsWindow(m_hWnd));
	ListView_CancelEditLabel(m_hWnd); // LVM_CANCELEDITLABEL
}

#endif	// _WIN32_WINNT >= 0x0501

#if (_WIN32_WINNT >= 0x0600) && defined(UNICODE)

AFX_INLINE CString CListCtrl::GetEmptyText() const
{
	ASSERT(::IsWindow(m_hWnd));
	LPTSTR lpszText=NULL;
	int cchText = 0;
	CString strOut;
	BOOL fRet = CWnd::EnlargeBufferGetText<BOOL>(FALSE, lpszText, cchText, LVM_GETEMPTYTEXT, (WPARAM &)cchText, (LPARAM &)lpszText, strOut);
	if (fRet)
		return strOut;
	else
		return CString();
}
AFX_INLINE BOOL CListCtrl::GetItemIndexRect(PLVITEMINDEX pItemIndex, int iColumn, int rectType, LPRECT pRect) const
{
	ASSERT(::IsWindow(m_hWnd));
	return ListView_GetItemIndexRect(m_hWnd, pItemIndex, iColumn, rectType, pRect); // LVM_GETITEMINDEXRECT
}
AFX_INLINE HRESULT CListCtrl::SetItemIndexState(PLVITEMINDEX pItemIndex, DWORD dwState, DWORD dwMask)
{
	ASSERT(::IsWindow(m_hWnd));
	LV_ITEM lvi = {0};
	lvi.stateMask = dwMask;
	lvi.state = dwState;
	return (HRESULT)SNDMSG(m_hWnd, LVM_SETITEMINDEXSTATE, (WPARAM)pItemIndex, (LPARAM)&lvi);
}
AFX_INLINE BOOL CListCtrl::GetNextItemIndex(PLVITEMINDEX pItemIndex, int nFlags) const
{
	ASSERT(::IsWindow(m_hWnd));
	return ListView_GetNextItemIndex(m_hWnd, pItemIndex, nFlags); // LVM_GETNEXTITEMINDEX
}
AFX_INLINE int CListCtrl::GetGroupCount() const
{
	ASSERT(::IsWindow(m_hWnd));
	return (int)ListView_GetGroupCount(m_hWnd); // LVM_GETGROUPCOUNT
}
AFX_INLINE BOOL CListCtrl::GetGroupInfoByIndex(int iIndex, PLVGROUP pGroup) const
{
	ASSERT(::IsWindow(m_hWnd));
	return (BOOL)ListView_GetGroupInfoByIndex(m_hWnd, iIndex, pGroup); // LVM_GETGROUPINFOBYINDEX
}
AFX_INLINE void CListCtrl::SetGroupState(int iGroupId, DWORD dwMask, DWORD dwState)
{
	ASSERT(::IsWindow(m_hWnd));
	ListView_SetGroupState(m_hWnd, iGroupId, dwMask, dwState); // LVM_SETGROUPINFO
}
AFX_INLINE UINT CListCtrl::GetGroupState(int iGroupId, DWORD dwMask) const
{
	ASSERT(::IsWindow(m_hWnd));
	return ListView_GetGroupState(m_hWnd, iGroupId, dwMask); // LVM_GETGROUPSTATE
}
AFX_INLINE int CListCtrl::GetFocusedGroup() const
{
	ASSERT(::IsWindow(m_hWnd));
	return (int)ListView_GetFocusedGroup(m_hWnd); // LVM_GETFOCUSEDGROUP
}
AFX_INLINE BOOL CListCtrl::GetGroupRect(_In_ int iGroupId, _Out_ LPRECT lpRect, _In_ int iType /* = LVGGR_GROUP */) const
{
	ASSERT(::IsWindow(m_hWnd));
	return (BOOL)ListView_GetGroupRect(m_hWnd, iGroupId, iType, lpRect); // LVM_GETGROUPRECT
}
AFX_INLINE UINT CListCtrl::MapIndexToID(UINT index) const
{
	ASSERT(::IsWindow(m_hWnd));
	return ListView_MapIndexToID(m_hWnd, index); // LVM_MAPINDEXTOID
}
AFX_INLINE UINT CListCtrl::MapIDToIndex(UINT id) const
{
	ASSERT(::IsWindow(m_hWnd));
	return ListView_MapIDToIndex(m_hWnd, id); // LVM_MAPIDTOINDEX
}
AFX_INLINE BOOL CListCtrl::IsItemVisible(int index) const
{
	ASSERT(::IsWindow(m_hWnd));
	return (BOOL)ListView_IsItemVisible(m_hWnd, index); // LVM_ISITEMVISIBLE
}
#endif	// _WIN32_WINNT >= 0x0600 && defined(UNICODE)

/////////////////////////////////////////////////////////////////////////////
// CPagerCtrl

AFX_INLINE CPagerCtrl::CPagerCtrl()
{ }

AFX_INLINE CPagerCtrl::~CPagerCtrl()
{
	DestroyWindow();
}

// Attributes
AFX_INLINE void CPagerCtrl::SetChild(HWND hwndChild)
{
	ASSERT(::IsWindow(m_hWnd));
	return Pager_SetChild(m_hWnd, hwndChild); // PGM_SETCHILD
}

AFX_INLINE COLORREF CPagerCtrl::SetBkColor(COLORREF clrBk)
{
	ASSERT(::IsWindow(m_hWnd));
	return Pager_SetBkColor(m_hWnd, clrBk); // PGM_SETBKCOLOR
}

AFX_INLINE COLORREF CPagerCtrl::GetBkColor() const
{
	ASSERT(::IsWindow(m_hWnd));
	return Pager_GetBkColor(m_hWnd); // PGM_GETBKCOLOR
}

AFX_INLINE int CPagerCtrl::SetBorder(int iBorder)
{
	ASSERT(::IsWindow(m_hWnd));
	return Pager_SetBorder(m_hWnd, iBorder); // PGM_SETBORDER
}

AFX_INLINE int CPagerCtrl::GetBorder() const
{
	ASSERT(::IsWindow(m_hWnd));
	return Pager_GetBorder(m_hWnd); // PGM_GETBORDER
}

AFX_INLINE void CPagerCtrl::SetScrollPos(int iPos)
{
	ASSERT(::IsWindow(m_hWnd));
	Pager_SetPos(m_hWnd, iPos); // PGM_SETPOS
}

AFX_INLINE int CPagerCtrl::GetScrollPos() const
{
	ASSERT(::IsWindow(m_hWnd));
	return Pager_GetPos(m_hWnd); // PGM_GETPOS
}

AFX_INLINE int CPagerCtrl::SetButtonSize(int iButtonSize)
{
	ASSERT(::IsWindow(m_hWnd));
	return Pager_SetButtonSize(m_hWnd, iButtonSize); // PGM_SETBUTTONSIZE
}

AFX_INLINE int CPagerCtrl::GetButtonSize() const
{
	ASSERT(::IsWindow(m_hWnd));
	return Pager_GetButtonSize(m_hWnd); // PGM_GETBUTTONSIZE
}

AFX_INLINE BOOL CPagerCtrl::IsButtonInvisible(int iButton) const
{
	ASSERT(::IsWindow(m_hWnd));
	return(GetButtonState(iButton) == PGF_INVISIBLE);
}

AFX_INLINE BOOL CPagerCtrl::IsButtonNormal(int iButton) const
{
	ASSERT(::IsWindow(m_hWnd));
	return((GetButtonState(iButton) & PGF_NORMAL) == PGF_NORMAL);
}

AFX_INLINE BOOL CPagerCtrl::IsButtonGrayed(int iButton) const
{
	ASSERT(::IsWindow(m_hWnd));
	return((GetButtonState(iButton) & PGF_GRAYED) == PGF_GRAYED);
}

AFX_INLINE BOOL CPagerCtrl::IsButtonDepressed(int iButton) const
{
	ASSERT(::IsWindow(m_hWnd));
	return((GetButtonState(iButton) & PGF_DEPRESSED) == PGF_DEPRESSED);
}

AFX_INLINE BOOL CPagerCtrl::IsButtonHot(int iButton) const
{
	ASSERT(::IsWindow(m_hWnd));
	return((GetButtonState(iButton) & PGF_HOT) == PGF_HOT);
}

AFX_INLINE DWORD CPagerCtrl::GetButtonState(int iButton) const
{
	ASSERT(::IsWindow(m_hWnd));
	return Pager_GetButtonState(m_hWnd, iButton); // PGM_GETBUTTONSTATE
}

AFX_INLINE IDropTarget* CPagerCtrl::GetDropTarget() const
{
	ASSERT(::IsWindow(m_hWnd));
	IDropTarget* pdt = NULL;
	Pager_GetDropTarget(m_hWnd, &pdt); // PGM_GETDROPTARGET
	return pdt;
}

// Operations
AFX_INLINE void CPagerCtrl::RecalcSize()
{
	ASSERT(::IsWindow(m_hWnd));
	return Pager_RecalcSize(m_hWnd); // PGM_RECALCSIZE
}

AFX_INLINE void CPagerCtrl::ForwardMouse(BOOL bForward)
{
	ASSERT(::IsWindow(m_hWnd));
	return Pager_ForwardMouse(m_hWnd, bForward); // PGM_FORWARDMOUSE
}

#if (_WIN32_WINNT >= 0x0501)

/////////////////////////////////////////////////////////////////////////////
// CLinkCtrl

AFX_INLINE CLinkCtrl::CLinkCtrl()
{ }

AFX_INLINE CLinkCtrl::~CLinkCtrl()
{
	DestroyWindow();
}

// Attributes
AFX_INLINE int CLinkCtrl::GetIdealHeight() const
{
	ASSERT(::IsWindow(m_hWnd));
	return (int) ::SendMessage(m_hWnd, LM_GETIDEALHEIGHT, 0, 0);
}

#if (_WIN32_WINNT >= 0x0600) && defined(UNICODE)
AFX_INLINE int CLinkCtrl::GetIdealSize(int cxMaxWidth, SIZE* pSize) const
{
	ASSERT(::IsWindow(m_hWnd));
	return (int) ::SendMessage(m_hWnd, LM_GETIDEALSIZE, (WPARAM)cxMaxWidth, (LPARAM)pSize);
}
#endif // (_WIN32_WINNT >= 0x0600) && defined(UNICODE)

// operations
AFX_INLINE BOOL CLinkCtrl::SetItem(PLITEM pItem)
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(pItem != NULL);
	return (BOOL) ::SendMessage(m_hWnd, LM_SETITEM, 0, (LPARAM)pItem);
}

AFX_INLINE BOOL CLinkCtrl::SetItemID(int iLink, LPCWSTR szID)
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(lstrlenW(szID) <= MAX_LINKID_TEXT);
	if (lstrlenW(szID) > MAX_LINKID_TEXT)
		return FALSE;

	LITEM item;
	item.mask = LIF_ITEMINDEX | LIF_ITEMID;
	item.iLink = iLink;
	::ATL::Checked::wcscpy_s(item.szID, _countof(item.szID), szID);

	return SetItem(&item);
}

AFX_INLINE BOOL CLinkCtrl::SetItemUrl(int iLink, LPCWSTR szUrl)
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(lstrlenW(szUrl) <= L_MAX_URL_LENGTH);
	if (lstrlenW(szUrl) >= L_MAX_URL_LENGTH)
		return FALSE;

	LITEM item;
	item.mask = LIF_ITEMINDEX | LIF_URL;
	item.iLink = iLink;
	::ATL::Checked::wcscpy_s(item.szUrl, _countof(item.szUrl), szUrl);

	return SetItem(&item);
}

AFX_INLINE BOOL CLinkCtrl::SetItemState(int iLink, UINT state, UINT stateMask /*= 0xFFFFFFFF*/)
{
	ASSERT(::IsWindow(m_hWnd));
	LITEM item;
	item.mask = LIF_ITEMINDEX | LIF_STATE;
	item.iLink = iLink;
	item.state = state;
	item.stateMask = stateMask;

	return SetItem(&item);
}

AFX_INLINE BOOL CLinkCtrl::GetItem(PLITEM pItem) const
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(pItem != NULL);
	return (BOOL) ::SendMessage(m_hWnd, LM_GETITEM, 0, (LPARAM)pItem);
}

AFX_INLINE BOOL CLinkCtrl::GetItemID(int iLink, CString& strID) const
{
	ASSERT(::IsWindow(m_hWnd));
	LITEM item;
	item.mask = LIF_ITEMINDEX | LIF_ITEMID;
	item.iLink = iLink;

	if (!GetItem(&item))
		return FALSE;

	strID = item.szID;
	return TRUE;
}

AFX_INLINE BOOL CLinkCtrl::GetItemID(_In_ int iLink, _Out_z_cap_(cchID) LPWSTR szID, _In_ UINT cchID) const
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(szID != NULL);
	ASSERT(cchID >= MAX_LINKID_TEXT);
	if (szID!=NULL)
	{
		szID[0]=L'\0';
	}
	if (szID == NULL || cchID < MAX_LINKID_TEXT)
		return FALSE;

	LITEM item;
	item.mask = LIF_ITEMINDEX | LIF_ITEMID;
	item.iLink = iLink;

	if (!GetItem(&item))
		return FALSE;

	::ATL::Checked::wcscpy_s(szID, cchID, item.szID);
	return TRUE;
}

AFX_INLINE BOOL CLinkCtrl::GetItemUrl(int iLink, CString& strUrl) const
{
	ASSERT(::IsWindow(m_hWnd));
	LITEM item;
	item.mask = LIF_ITEMINDEX | LIF_URL;
	item.iLink = iLink;

	if (!GetItem(&item))
		return FALSE;

	strUrl = item.szUrl;
	return TRUE;
}

AFX_INLINE BOOL CLinkCtrl::GetItemUrl(_In_ int iLink, _Out_z_cap_(cchUrl) LPWSTR szUrl, _In_ UINT cchUrl) const
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(szUrl != NULL);
	ASSERT(cchUrl >= L_MAX_URL_LENGTH);
	if(szUrl!=NULL)
	{
		szUrl[0]=L'\0';
	}
	if (szUrl == NULL || cchUrl < L_MAX_URL_LENGTH)
		return FALSE;

	LITEM item;
	item.mask = LIF_ITEMINDEX | LIF_URL;
	item.iLink = iLink;

	if (!GetItem(&item))
		return FALSE;

	::ATL::Checked::wcscpy_s(szUrl, cchUrl, item.szUrl);
	return TRUE;
}

AFX_INLINE BOOL CLinkCtrl::GetItemState(int iLink, UINT *pnState, UINT stateMask /*= 0xFFFFFFFF*/) const
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(pnState != NULL);
	if (pnState == NULL)
		return FALSE;

	LITEM item;
	item.mask = LIF_ITEMINDEX | LIF_URL;
	item.iLink = iLink;
	item.stateMask = stateMask;

	if (!GetItem(&item))
		return FALSE;

	*pnState = item.state;
	return TRUE;
}


AFX_INLINE BOOL CLinkCtrl::HitTest(PLHITTESTINFO phti)  const
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(phti != NULL);
	return (BOOL) ::SendMessage(m_hWnd, LM_HITTEST, 0, (LPARAM)phti);
}

#endif	// _WIN32_WINNT >= 0x0501

#if (NTDDI_VERSION >= NTDDI_LONGHORN) && defined(UNICODE)

/////////////////////////////////////////////////////////////////////////////
// CNetAddressCtrl

AFX_INLINE CNetAddressCtrl::CNetAddressCtrl()
{ }

AFX_INLINE CNetAddressCtrl::~CNetAddressCtrl()
{
	DestroyWindow();
}

// Attributes
AFX_INLINE HRESULT CNetAddressCtrl::GetAddress(PNC_ADDRESS pAddress) const
{
	ASSERT(::IsWindow(m_hWnd));
	return NetAddr_GetAddress(m_hWnd, pAddress); // NCM_GETADDRESS
}

AFX_INLINE HRESULT CNetAddressCtrl::SetAllowType(DWORD dwAddrMask)
{
	ASSERT(::IsWindow(m_hWnd));
	return (HRESULT)NetAddr_SetAllowType(m_hWnd, dwAddrMask); // NCM_SETALLOWTYPE
}

AFX_INLINE DWORD CNetAddressCtrl::GetAllowType() const
{
	ASSERT(::IsWindow(m_hWnd));
	return NetAddr_GetAllowType(m_hWnd); // NCM_GETALLOWTYPE
}

// Operations
AFX_INLINE HRESULT CNetAddressCtrl::DisplayErrorTip()
{
	ASSERT(::IsWindow(m_hWnd));
	return NetAddr_DisplayErrorTip(m_hWnd); // NCM_DISPLAYERRORTIP
}

#endif // (NTDDI_VERSION >= NTDDI_LONGHORN) && defined(UNICDOE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxcoll.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXCOLL_H__
#define __AFXCOLL_H__

#ifndef __AFX_H__
	#include <afx.h>
#endif

#pragma once

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// Classes declared in this file

//CObject
	// Arrays
	class CByteArray;           // array of BYTE
	class CWordArray;           // array of WORD
	class CDWordArray;          // array of DWORD
	class CUIntArray;           // array of UINT
	class CPtrArray;            // array of void*
	class CObArray;             // array of CObject*

	// Lists
	class CPtrList;             // list of void*
	class CObList;              // list of CObject*

	// Maps (aka Dictionaries)
	class CMapWordToOb;         // map from WORD to CObject*
	class CMapWordToPtr;        // map from WORD to void*
	class CMapPtrToWord;        // map from void* to WORD
	class CMapPtrToPtr;         // map from void* to void*

	// Special String variants
	class CStringArray;         // array of CStrings
	class CStringList;          // list of CStrings
	class CMapStringToPtr;      // map from CString to void*
	class CMapStringToOb;       // map from CString to CObject*
	class CMapStringToString;   // map from CString to CString

/////////////////////////////////////////////////////////////////////////////

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

////////////////////////////////////////////////////////////////////////////

class CByteArray : public CObject
{

	DECLARE_SERIAL(CByteArray)
public:

// Construction
	CByteArray();

// Attributes
	INT_PTR GetSize() const;
	INT_PTR GetCount() const;
	BOOL IsEmpty() const;
	INT_PTR GetUpperBound() const;
	void SetSize(INT_PTR nNewSize, INT_PTR nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	BYTE GetAt(INT_PTR nIndex) const;
	void SetAt(INT_PTR nIndex, BYTE newElement);

	BYTE& ElementAt(INT_PTR nIndex);

	// Direct Access to the element data (may return NULL)
	const BYTE* GetData() const;
	BYTE* GetData();

	// Potentially growing the array
	void SetAtGrow(INT_PTR nIndex, BYTE newElement);

	INT_PTR Add(BYTE newElement);

	INT_PTR Append(const CByteArray& src);
	void Copy(const CByteArray& src);

	// overloaded operator helpers
	BYTE operator[](INT_PTR nIndex) const;
	BYTE& operator[](INT_PTR nIndex);

	// Operations that move elements around
	void InsertAt(INT_PTR nIndex, BYTE newElement, INT_PTR nCount = 1);

	void RemoveAt(INT_PTR nIndex, INT_PTR nCount = 1);
	void InsertAt(INT_PTR nStartIndex, CByteArray* pNewArray);

// Implementation
protected:
	BYTE* m_pData;   // the actual array of data
	INT_PTR m_nSize;     // # of elements (upperBound - 1)
	INT_PTR m_nMaxSize;  // max allocated
	INT_PTR m_nGrowBy;   // grow amount


public:
	~CByteArray();

	void Serialize(CArchive&);
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif

protected:
	// local typedefs for class templates
	typedef BYTE BASE_TYPE;
	typedef BYTE BASE_ARG_TYPE;
};


////////////////////////////////////////////////////////////////////////////

class CWordArray : public CObject
{

	DECLARE_SERIAL(CWordArray)
public:

// Construction
	CWordArray();

// Attributes
	INT_PTR GetSize() const;
	INT_PTR GetCount() const;
	BOOL IsEmpty() const;
	INT_PTR GetUpperBound() const;
	void SetSize(INT_PTR nNewSize, INT_PTR nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	WORD GetAt(INT_PTR nIndex) const;
	void SetAt(INT_PTR nIndex, WORD newElement);

	WORD& ElementAt(INT_PTR nIndex);

	// Direct Access to the element data (may return NULL)
	const WORD* GetData() const;
	WORD* GetData();

	// Potentially growing the array
	void SetAtGrow(INT_PTR nIndex, WORD newElement);

	INT_PTR Add(WORD newElement);

	INT_PTR Append(const CWordArray& src);
	void Copy(const CWordArray& src);

	// overloaded operator helpers
	WORD operator[](INT_PTR nIndex) const;
	WORD& operator[](INT_PTR nIndex);

	// Operations that move elements around
	void InsertAt(INT_PTR nIndex, WORD newElement, INT_PTR nCount = 1);

	void RemoveAt(INT_PTR nIndex, INT_PTR nCount = 1);
	void InsertAt(INT_PTR nStartIndex, CWordArray* pNewArray);

// Implementation
protected:
	WORD* m_pData;   // the actual array of data
	INT_PTR m_nSize;     // # of elements (upperBound - 1)
	INT_PTR m_nMaxSize;  // max allocated
	INT_PTR m_nGrowBy;   // grow amount


public:
	~CWordArray();

	void Serialize(CArchive&);
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif

protected:
	// local typedefs for class templates
	typedef WORD BASE_TYPE;
	typedef WORD BASE_ARG_TYPE;
};


////////////////////////////////////////////////////////////////////////////

class CDWordArray : public CObject
{

	DECLARE_SERIAL(CDWordArray)
public:

// Construction
	CDWordArray();

// Attributes
	INT_PTR GetSize() const;
	INT_PTR GetCount() const;
	BOOL IsEmpty() const;
	INT_PTR GetUpperBound() const;
	void SetSize(INT_PTR nNewSize, INT_PTR nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	DWORD GetAt(INT_PTR nIndex) const;
	void SetAt(INT_PTR nIndex, DWORD newElement);

	DWORD& ElementAt(INT_PTR nIndex);

	// Direct Access to the element data (may return NULL)
	const DWORD* GetData() const;
	DWORD* GetData();

	// Potentially growing the array
	void SetAtGrow(INT_PTR nIndex, DWORD newElement);

	INT_PTR Add(DWORD newElement);

	INT_PTR Append(const CDWordArray& src);
	void Copy(const CDWordArray& src);

	// overloaded operator helpers
	DWORD operator[](INT_PTR nIndex) const;
	DWORD& operator[](INT_PTR nIndex);

	// Operations that move elements around
	void InsertAt(INT_PTR nIndex, DWORD newElement, INT_PTR nCount = 1);

	void RemoveAt(INT_PTR nIndex, INT_PTR nCount = 1);
	void InsertAt(INT_PTR nStartIndex, CDWordArray* pNewArray);

// Implementation
protected:
	DWORD* m_pData;   // the actual array of data
	INT_PTR m_nSize;     // # of elements (upperBound - 1)
	INT_PTR m_nMaxSize;  // max allocated
	INT_PTR m_nGrowBy;   // grow amount


public:
	~CDWordArray();

	void Serialize(CArchive&);
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif

protected:
	// local typedefs for class templates
	typedef DWORD BASE_TYPE;
	typedef DWORD BASE_ARG_TYPE;
};


////////////////////////////////////////////////////////////////////////////

class CUIntArray : public CObject
{

	DECLARE_DYNAMIC(CUIntArray)
public:

// Construction
	CUIntArray();

// Attributes
	INT_PTR GetSize() const;
	INT_PTR GetCount() const;
	BOOL IsEmpty() const;
	INT_PTR GetUpperBound() const;
	void SetSize(INT_PTR nNewSize, INT_PTR nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	UINT GetAt(INT_PTR nIndex) const;
	void SetAt(INT_PTR nIndex, UINT newElement);

	UINT& ElementAt(INT_PTR nIndex);

	// Direct Access to the element data (may return NULL)
	const UINT* GetData() const;
	UINT* GetData();

	// Potentially growing the array
	void SetAtGrow(INT_PTR nIndex, UINT newElement);

	INT_PTR Add(UINT newElement);

	INT_PTR Append(const CUIntArray& src);
	void Copy(const CUIntArray& src);

	// overloaded operator helpers
	UINT operator[](INT_PTR nIndex) const;
	UINT& operator[](INT_PTR nIndex);

	// Operations that move elements around
	void InsertAt(INT_PTR nIndex, UINT newElement, INT_PTR nCount = 1);

	void RemoveAt(INT_PTR nIndex, INT_PTR nCount = 1);
	void InsertAt(INT_PTR nStartIndex, CUIntArray* pNewArray);

// Implementation
protected:
	UINT* m_pData;   // the actual array of data
	INT_PTR m_nSize;     // # of elements (upperBound - 1)
	INT_PTR m_nMaxSize;  // max allocated
	INT_PTR m_nGrowBy;   // grow amount


public:
	~CUIntArray();
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif

protected:
	// local typedefs for class templates
	typedef UINT BASE_TYPE;
	typedef UINT BASE_ARG_TYPE;
};


////////////////////////////////////////////////////////////////////////////

class CPtrArray : public CObject
{

	DECLARE_DYNAMIC(CPtrArray)
public:

// Construction
	CPtrArray();

// Attributes
	INT_PTR GetSize() const;
	INT_PTR GetCount() const;
	BOOL IsEmpty() const;
	INT_PTR GetUpperBound() const;
	void SetSize(INT_PTR nNewSize, INT_PTR nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	void* GetAt(INT_PTR nIndex) const;
	void SetAt(INT_PTR nIndex, void* newElement);

	void*& ElementAt(INT_PTR nIndex);

	// Direct Access to the element data (may return NULL)
	const void** GetData() const;
	void** GetData();

	// Potentially growing the array
	void SetAtGrow(INT_PTR nIndex, void* newElement);

	INT_PTR Add(void* newElement);

	INT_PTR Append(const CPtrArray& src);
	void Copy(const CPtrArray& src);

	// overloaded operator helpers
	void* operator[](INT_PTR nIndex) const;
	void*& operator[](INT_PTR nIndex);

	// Operations that move elements around
	void InsertAt(INT_PTR nIndex, void* newElement, INT_PTR nCount = 1);

	void RemoveAt(INT_PTR nIndex, INT_PTR nCount = 1);
	void InsertAt(INT_PTR nStartIndex, CPtrArray* pNewArray);

// Implementation
protected:
	void** m_pData;   // the actual array of data
	INT_PTR m_nSize;     // # of elements (upperBound - 1)
	INT_PTR m_nMaxSize;  // max allocated
	INT_PTR m_nGrowBy;   // grow amount


public:
	~CPtrArray();
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif

protected:
	// local typedefs for class templates
	typedef void* BASE_TYPE;
	typedef void* BASE_ARG_TYPE;
};


////////////////////////////////////////////////////////////////////////////

class CObArray : public CObject
{

	DECLARE_SERIAL(CObArray)
public:

// Construction
	CObArray();

// Attributes
	INT_PTR GetSize() const;
	INT_PTR GetCount() const;
	BOOL IsEmpty() const;
	INT_PTR GetUpperBound() const;
	void SetSize(INT_PTR nNewSize, INT_PTR nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	CObject* GetAt(INT_PTR nIndex) const;
	void SetAt(INT_PTR nIndex, CObject* newElement);

	CObject*& ElementAt(INT_PTR nIndex);

	// Direct Access to the element data (may return NULL)
	const CObject** GetData() const;
	CObject** GetData();

	// Potentially growing the array
	void SetAtGrow(INT_PTR nIndex, CObject* newElement);

	INT_PTR Add(CObject* newElement);

	INT_PTR Append(const CObArray& src);
	void Copy(const CObArray& src);

	// overloaded operator helpers
	CObject* operator[](INT_PTR nIndex) const;
	CObject*& operator[](INT_PTR nIndex);

	// Operations that move elements around
	void InsertAt(INT_PTR nIndex, CObject* newElement, INT_PTR nCount = 1);

	void RemoveAt(INT_PTR nIndex, INT_PTR nCount = 1);
	void InsertAt(INT_PTR nStartIndex, CObArray* pNewArray);

// Implementation
protected:
	CObject** m_pData;   // the actual array of data
	INT_PTR m_nSize;     // # of elements (upperBound - 1)
	INT_PTR m_nMaxSize;  // max allocated
	INT_PTR m_nGrowBy;   // grow amount


public:
	~CObArray();

	void Serialize(CArchive&);
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif

protected:
	// local typedefs for class templates
	typedef CObject* BASE_TYPE;
	typedef CObject* BASE_ARG_TYPE;
};


////////////////////////////////////////////////////////////////////////////

class CStringArray : public CObject
{

	DECLARE_SERIAL(CStringArray)
public:

// Construction
	CStringArray();

// Attributes
	INT_PTR GetSize() const;
	INT_PTR GetCount() const;
	BOOL IsEmpty() const;
	INT_PTR GetUpperBound() const;
	void SetSize(INT_PTR nNewSize, INT_PTR nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	const CString& GetAt(INT_PTR nIndex) const;
	void SetAt(INT_PTR nIndex, LPCTSTR newElement);

	void SetAt(INT_PTR nIndex, const CString& newElement);

	CString& ElementAt(INT_PTR nIndex);

	// Direct Access to the element data (may return NULL)
	const CString* GetData() const;
	CString* GetData();

	// Potentially growing the array
	void SetAtGrow(INT_PTR nIndex, LPCTSTR newElement);

	void SetAtGrow(INT_PTR nIndex, const CString& newElement);

	INT_PTR Add(LPCTSTR newElement);

	INT_PTR Add(const CString& newElement);

	INT_PTR Append(const CStringArray& src);
	void Copy(const CStringArray& src);

	// overloaded operator helpers
	const CString& operator[](INT_PTR nIndex) const;
	CString& operator[](INT_PTR nIndex);

	// Operations that move elements around
	void InsertAt(INT_PTR nIndex, LPCTSTR newElement, INT_PTR nCount = 1);

	void InsertAt(INT_PTR nIndex, const CString& newElement, INT_PTR nCount = 1);

	void RemoveAt(INT_PTR nIndex, INT_PTR nCount = 1);
	void InsertAt(INT_PTR nStartIndex, const CStringArray* pNewArray);

// Implementation
protected:
	CString* m_pData;   // the actual array of data
	INT_PTR m_nSize;     // # of elements (upperBound - 1)
	INT_PTR m_nMaxSize;  // max allocated
	INT_PTR m_nGrowBy;   // grow amount

	void InsertEmpty(INT_PTR nIndex, INT_PTR nCount);


public:
	~CStringArray();

	void Serialize(CArchive&);
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif

protected:
	// local typedefs for class templates
	typedef CString BASE_TYPE;
	typedef LPCTSTR BASE_ARG_TYPE;
};


/////////////////////////////////////////////////////////////////////////////

class CPtrList : public CObject
{

	DECLARE_DYNAMIC(CPtrList)

protected:
	struct CNode
	{
		CNode* pNext;
		CNode* pPrev;
		void* data;
	};
public:

// Construction
	/* explicit */ CPtrList(INT_PTR nBlockSize = 10);

// Attributes (head and tail)
	// count of elements
	INT_PTR GetCount() const;
	INT_PTR GetSize() const;
	BOOL IsEmpty() const;

	// peek at head or tail
	void*& GetHead();
	const void* GetHead() const;
	void*& GetTail();
	const void* GetTail() const;

// Operations
	// get head or tail (and remove it) - don't call on empty list!
	void* RemoveHead();
	void* RemoveTail();

	// add before head or after tail
	POSITION AddHead(void* newElement);
	POSITION AddTail(void* newElement);


	// add another list of elements before head or after tail
	void AddHead(CPtrList* pNewList);
	void AddTail(CPtrList* pNewList);

	// remove all elements
	void RemoveAll();

	// iteration
	POSITION GetHeadPosition() const;
	POSITION GetTailPosition() const;
	void*& GetNext(POSITION& rPosition); // return *Position++
	const void* GetNext(POSITION& rPosition) const; // return *Position++
	void*& GetPrev(POSITION& rPosition); // return *Position--
	const void* GetPrev(POSITION& rPosition) const; // return *Position--

	// getting/modifying an element at a given position
	void*& GetAt(POSITION position);
	const void* GetAt(POSITION position) const;
	void SetAt(POSITION pos, void* newElement);

	void RemoveAt(POSITION position);

	// inserting before or after a given position
	POSITION InsertBefore(POSITION position, void* newElement);
	POSITION InsertAfter(POSITION position, void* newElement);


	// helper functions (note: O(n) speed)
	POSITION Find(void* searchValue, POSITION startAfter = NULL) const;
						// defaults to starting at the HEAD
						// return NULL if not found
	POSITION FindIndex(INT_PTR nIndex) const;
						// get the 'nIndex'th element (may return NULL)

// Implementation
protected:
	CNode* m_pNodeHead;
	CNode* m_pNodeTail;
	INT_PTR m_nCount;
	CNode* m_pNodeFree;
	struct CPlex* m_pBlocks;
	INT_PTR m_nBlockSize;

	CNode* NewNode(CNode*, CNode*);
	void FreeNode(CNode*);

public:
	~CPtrList();
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif
	// local typedefs for class templates
	typedef void* BASE_TYPE;
	typedef void* BASE_ARG_TYPE;
};


/////////////////////////////////////////////////////////////////////////////

class CObList : public CObject
{

	DECLARE_SERIAL(CObList)

protected:
	struct CNode
	{
		CNode* pNext;
		CNode* pPrev;
		CObject* data;
	};
public:

// Construction
	/* explicit */ CObList(INT_PTR nBlockSize = 10);

// Attributes (head and tail)
	// count of elements
	INT_PTR GetCount() const;
	INT_PTR GetSize() const;
	BOOL IsEmpty() const;

	// peek at head or tail
	CObject*& GetHead();
	const CObject* GetHead() const;
	CObject*& GetTail();
	const CObject* GetTail() const;

// Operations
	// get head or tail (and remove it) - don't call on empty list!
	CObject* RemoveHead();
	CObject* RemoveTail();

	// add before head or after tail
	POSITION AddHead(CObject* newElement);
	POSITION AddTail(CObject* newElement);


	// add another list of elements before head or after tail
	void AddHead(CObList* pNewList);
	void AddTail(CObList* pNewList);

	// remove all elements
	void RemoveAll();

	// iteration
	POSITION GetHeadPosition() const;
	POSITION GetTailPosition() const;
	CObject*& GetNext(POSITION& rPosition); // return *Position++
	const CObject* GetNext(POSITION& rPosition) const; // return *Position++
	CObject*& GetPrev(POSITION& rPosition); // return *Position--
	const CObject* GetPrev(POSITION& rPosition) const; // return *Position--

	// getting/modifying an element at a given position
	CObject*& GetAt(POSITION position);
	const CObject* GetAt(POSITION position) const;
	void SetAt(POSITION pos, CObject* newElement);

	void RemoveAt(POSITION position);

	// inserting before or after a given position
	POSITION InsertBefore(POSITION position, CObject* newElement);
	POSITION InsertAfter(POSITION position, CObject* newElement);


	// helper functions (note: O(n) speed)
	POSITION Find(CObject* searchValue, POSITION startAfter = NULL) const;
						// defaults to starting at the HEAD
						// return NULL if not found
	POSITION FindIndex(INT_PTR nIndex) const;
						// get the 'nIndex'th element (may return NULL)

// Implementation
protected:
	CNode* m_pNodeHead;
	CNode* m_pNodeTail;
	INT_PTR m_nCount;
	CNode* m_pNodeFree;
	struct CPlex* m_pBlocks;
	INT_PTR m_nBlockSize;

	CNode* NewNode(CNode*, CNode*);
	void FreeNode(CNode*);

public:
	~CObList();

	void Serialize(CArchive&);
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif
	// local typedefs for class templates
	typedef CObject* BASE_TYPE;
	typedef CObject* BASE_ARG_TYPE;
};


/////////////////////////////////////////////////////////////////////////////

class CStringList : public CObject
{

	DECLARE_SERIAL(CStringList)

protected:
	struct CNode
	{
		CNode* pNext;
		CNode* pPrev;
		CString data;
	};
public:

// Construction
	/* explicit */ CStringList(INT_PTR nBlockSize = 10);

// Attributes (head and tail)
	// count of elements
	INT_PTR GetCount() const;
	INT_PTR GetSize() const;
	BOOL IsEmpty() const;

	// peek at head or tail
	CString& GetHead();
	const CString& GetHead() const;
	CString& GetTail();
	const CString& GetTail() const;

// Operations
	// get head or tail (and remove it) - don't call on empty list!
	CString RemoveHead();
	CString RemoveTail();

	// add before head or after tail
	POSITION AddHead(LPCTSTR newElement);
	POSITION AddTail(LPCTSTR newElement);

	POSITION AddHead(const CString& newElement);
	POSITION AddTail(const CString& newElement);


	// add another list of elements before head or after tail
	void AddHead(CStringList* pNewList);
	void AddTail(CStringList* pNewList);

	// remove all elements
	void RemoveAll();

	// iteration
	POSITION GetHeadPosition() const;
	POSITION GetTailPosition() const;
	CString& GetNext(POSITION& rPosition); // return *Position++
	const CString& GetNext(POSITION& rPosition) const; // return *Position++
	CString& GetPrev(POSITION& rPosition); // return *Position--
	const CString& GetPrev(POSITION& rPosition) const; // return *Position--

	// getting/modifying an element at a given position
	CString& GetAt(POSITION position);
	const CString& GetAt(POSITION position) const;
	void SetAt(POSITION pos, LPCTSTR newElement);

	void SetAt(POSITION pos, const CString& newElement);

	void RemoveAt(POSITION position);

	// inserting before or after a given position
	POSITION InsertBefore(POSITION position, LPCTSTR newElement);
	POSITION InsertAfter(POSITION position, LPCTSTR newElement);

	POSITION InsertBefore(POSITION position, const CString& newElement);
	POSITION InsertAfter(POSITION position, const CString& newElement);


	// helper functions (note: O(n) speed)
	POSITION Find(LPCTSTR searchValue, POSITION startAfter = NULL) const;
						// defaults to starting at the HEAD
						// return NULL if not found
	POSITION FindIndex(INT_PTR nIndex) const;
						// get the 'nIndex'th element (may return NULL)

// Implementation
protected:
	CNode* m_pNodeHead;
	CNode* m_pNodeTail;
	INT_PTR m_nCount;
	CNode* m_pNodeFree;
	struct CPlex* m_pBlocks;
	INT_PTR m_nBlockSize;

	CNode* NewNode(CNode*, CNode*);
	void FreeNode(CNode*);

public:
	~CStringList();

	void Serialize(CArchive&);
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif
	// local typedefs for class templates
	typedef CString BASE_TYPE;
	typedef LPCTSTR BASE_ARG_TYPE;
};


/////////////////////////////////////////////////////////////////////////////

class CMapWordToPtr : public CObject
{

	DECLARE_DYNAMIC(CMapWordToPtr)
protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;
		void* value;
		WORD key;
	};

public:

// Construction
	/* explicit */ CMapWordToPtr(INT_PTR nBlockSize = 10);

// Attributes
	// number of elements
	INT_PTR GetCount() const;
	INT_PTR GetSize() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(WORD key, void*& rValue) const;

// Operations
	// Lookup and add if not there
	void*& operator[](WORD key);

	// add a new (key, value) pair
	void SetAt(WORD key, void* newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(WORD key);
	void RemoveAll();

	// iterating all (key, value) pairs
	POSITION GetStartPosition() const;
	void GetNextAssoc(POSITION& rNextPosition, WORD& rKey, void*& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Overridables: special non-virtual (see map implementation for details)
	// Routine used to user-provided hash keys
	UINT HashKey(WORD key) const;

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	INT_PTR m_nCount;
	CAssoc* m_pFreeList;
	struct CPlex* m_pBlocks;
	INT_PTR m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(WORD, UINT&, UINT&) const;

public:
	~CMapWordToPtr();
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif


protected:
	// local typedefs for CTypedPtrMap class template
	typedef WORD BASE_KEY;
	typedef WORD BASE_ARG_KEY;
	typedef void* BASE_VALUE;
	typedef void* BASE_ARG_VALUE;
};


/////////////////////////////////////////////////////////////////////////////

class CMapPtrToWord : public CObject
{

	DECLARE_DYNAMIC(CMapPtrToWord)
protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;

		void* key;
		WORD value;
	};

public:

// Construction
	/* explicit */ CMapPtrToWord(INT_PTR nBlockSize = 10);

// Attributes
	// number of elements
	INT_PTR GetCount() const;
	INT_PTR GetSize() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(void* key, WORD& rValue) const;

// Operations
	// Lookup and add if not there
	WORD& operator[](void* key);

	// add a new (key, value) pair
	void SetAt(void* key, WORD newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(void* key);
	void RemoveAll();

	// iterating all (key, value) pairs
	POSITION GetStartPosition() const;
	void GetNextAssoc(POSITION& rNextPosition, void*& rKey, WORD& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Overridables: special non-virtual (see map implementation for details)
	// Routine used to user-provided hash keys
	UINT HashKey(void* key) const;

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	INT_PTR m_nCount;
	CAssoc* m_pFreeList;
	struct CPlex* m_pBlocks;
	INT_PTR m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(void*, UINT&, UINT&) const;

public:
	~CMapPtrToWord();
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif


protected:
	// local typedefs for CTypedPtrMap class template
	typedef void* BASE_KEY;
	typedef void* BASE_ARG_KEY;
	typedef WORD BASE_VALUE;
	typedef WORD BASE_ARG_VALUE;
};


/////////////////////////////////////////////////////////////////////////////

class CMapPtrToPtr : public CObject
{

	DECLARE_DYNAMIC(CMapPtrToPtr)
protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;

		void* key;
		void* value;
	};

public:

// Construction
	/* explicit */ CMapPtrToPtr(INT_PTR nBlockSize = 10);

// Attributes
	// number of elements
	INT_PTR GetCount() const;
	INT_PTR GetSize() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(void* key, void*& rValue) const;

// Operations
	// Lookup and add if not there
	void*& operator[](void* key);

	// add a new (key, value) pair
	void SetAt(void* key, void* newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(void* key);
	void RemoveAll();

	// iterating all (key, value) pairs
	POSITION GetStartPosition() const;
	void GetNextAssoc(POSITION& rNextPosition, void*& rKey, void*& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Overridables: special non-virtual (see map implementation for details)
	// Routine used to user-provided hash keys
	UINT HashKey(void* key) const;

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	INT_PTR m_nCount;
	CAssoc* m_pFreeList;
	struct CPlex* m_pBlocks;
	INT_PTR m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(void*, UINT&, UINT&) const;

public:
	~CMapPtrToPtr();
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif

	void* GetValueAt(void* key) const;


protected:
	// local typedefs for CTypedPtrMap class template
	typedef void* BASE_KEY;
	typedef void* BASE_ARG_KEY;
	typedef void* BASE_VALUE;
	typedef void* BASE_ARG_VALUE;
};


/////////////////////////////////////////////////////////////////////////////

class CMapWordToOb : public CObject
{

	DECLARE_SERIAL(CMapWordToOb)
protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;
		CObject* value;
		WORD key;
	};

public:

// Construction
	/* explicit */ CMapWordToOb(INT_PTR nBlockSize = 10);

// Attributes
	// number of elements
	INT_PTR GetCount() const;
	INT_PTR GetSize() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(WORD key, CObject*& rValue) const;

// Operations
	// Lookup and add if not there
	CObject*& operator[](WORD key);

	// add a new (key, value) pair
	void SetAt(WORD key, CObject* newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(WORD key);
	void RemoveAll();

	// iterating all (key, value) pairs
	POSITION GetStartPosition() const;
	void GetNextAssoc(POSITION& rNextPosition, WORD& rKey, CObject*& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Overridables: special non-virtual (see map implementation for details)
	// Routine used to user-provided hash keys
	UINT HashKey(WORD key) const;

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	INT_PTR m_nCount;
	CAssoc* m_pFreeList;
	struct CPlex* m_pBlocks;
	INT_PTR m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(WORD, UINT&, UINT&) const;

public:
	~CMapWordToOb();

	void Serialize(CArchive&);
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif


protected:
	// local typedefs for CTypedPtrMap class template
	typedef WORD BASE_KEY;
	typedef WORD BASE_ARG_KEY;
	typedef CObject* BASE_VALUE;
	typedef CObject* BASE_ARG_VALUE;
};


/////////////////////////////////////////////////////////////////////////////

class CMapStringToPtr : public CObject
{

	DECLARE_DYNAMIC(CMapStringToPtr)
protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;
		UINT nHashValue;  // needed for efficient iteration
		CString key;
		void* value;
	};

public:

// Construction
	/* explicit */ CMapStringToPtr(INT_PTR nBlockSize = 10);

// Attributes
	// number of elements
	INT_PTR GetCount() const;
	INT_PTR GetSize() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(LPCTSTR key, void*& rValue) const;
	BOOL LookupKey(LPCTSTR key, LPCTSTR& rKey) const;

// Operations
	// Lookup and add if not there
	void*& operator[](LPCTSTR key);

	// add a new (key, value) pair
	void SetAt(LPCTSTR key, void* newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(LPCTSTR key);
	void RemoveAll();

	// iterating all (key, value) pairs
	POSITION GetStartPosition() const;
	void GetNextAssoc(POSITION& rNextPosition, CString& rKey, void*& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Overridables: special non-virtual (see map implementation for details)
	// Routine used to user-provided hash keys
	UINT HashKey(LPCTSTR key) const;

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	INT_PTR m_nCount;
	CAssoc* m_pFreeList;
	struct CPlex* m_pBlocks;
	INT_PTR m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(LPCTSTR, UINT&, UINT&) const;

public:
	~CMapStringToPtr();
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif

protected:
	// local typedefs for CTypedPtrMap class template
	typedef CString BASE_KEY;
	typedef LPCTSTR BASE_ARG_KEY;
	typedef void* BASE_VALUE;
	typedef void* BASE_ARG_VALUE;
};


/////////////////////////////////////////////////////////////////////////////

class CMapStringToOb : public CObject
{

	DECLARE_SERIAL(CMapStringToOb)
protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;
		UINT nHashValue;  // needed for efficient iteration
		CString key;
		CObject* value;
	};

public:

// Construction
	/* explicit */ CMapStringToOb(INT_PTR nBlockSize = 10);

// Attributes
	// number of elements
	INT_PTR GetCount() const;
	INT_PTR GetSize() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(LPCTSTR key, CObject*& rValue) const;
	BOOL LookupKey(LPCTSTR key, LPCTSTR& rKey) const;

// Operations
	// Lookup and add if not there
	CObject*& operator[](LPCTSTR key);

	// add a new (key, value) pair
	void SetAt(LPCTSTR key, CObject* newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(LPCTSTR key);
	void RemoveAll();

	// iterating all (key, value) pairs
	POSITION GetStartPosition() const;
	void GetNextAssoc(POSITION& rNextPosition, CString& rKey, CObject*& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Overridables: special non-virtual (see map implementation for details)
	// Routine used to user-provided hash keys
	UINT HashKey(LPCTSTR key) const;

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	INT_PTR m_nCount;
	CAssoc* m_pFreeList;
	struct CPlex* m_pBlocks;
	INT_PTR m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(LPCTSTR, UINT&, UINT&) const;

public:
	~CMapStringToOb();

	void Serialize(CArchive&);
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif

protected:
	// local typedefs for CTypedPtrMap class template
	typedef CString BASE_KEY;
	typedef LPCTSTR BASE_ARG_KEY;
	typedef CObject* BASE_VALUE;
	typedef CObject* BASE_ARG_VALUE;
};


/////////////////////////////////////////////////////////////////////////////
class CMapStringToString : public CObject
{

	DECLARE_SERIAL(CMapStringToString)
public:
	// Association
	struct CPair
	{
		const CString key;
		CString value;
	protected:
		CPair(LPCTSTR keyval) : key(keyval) {}
	};
protected:
	class CAssoc : public CPair
	{
		friend class CMapStringToString;
		CAssoc* pNext;
		UINT nHashValue;  // needed for efficient iteration
	public:
		CAssoc( LPCTSTR keyval ) : CPair( keyval ) {}
	};

public:

// Construction
	/* explicit */ CMapStringToString(INT_PTR nBlockSize = 10);

// Attributes
	// number of elements
	INT_PTR GetCount() const;
	INT_PTR GetSize() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(LPCTSTR key, CString& rValue) const;
	const CPair *PLookup(LPCTSTR key) const;
	CPair *PLookup(LPCTSTR key);
	BOOL LookupKey(LPCTSTR key, LPCTSTR& rKey) const;

// Operations
	// Lookup and add if not there
	CString& operator[](LPCTSTR key);

	// add a new (key, value) pair
	void SetAt(LPCTSTR key, LPCTSTR newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(LPCTSTR key);
	void RemoveAll();

	// iterating all (key, value) pairs
	POSITION GetStartPosition() const;

	const CPair *PGetFirstAssoc() const;
	CPair *PGetFirstAssoc();

	void GetNextAssoc(POSITION& rNextPosition, CString& rKey, CString& rValue) const;

	const CPair *PGetNextAssoc(const CPair* pAssoc) const;
	CPair *PGetNextAssoc(const CPair* pAssoc);

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Overridables: special non-virtual (see map implementation for details)
	// Routine used to user-provided hash keys
	UINT HashKey(LPCTSTR key) const;

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	INT_PTR m_nCount;
	CAssoc* m_pFreeList;
	struct CPlex* m_pBlocks;
	INT_PTR m_nBlockSize;

	CAssoc* NewAssoc(LPCTSTR key);
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(LPCTSTR, UINT&, UINT&) const;

public:
	~CMapStringToString();

	void Serialize(CArchive&);
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif

protected:
	// local typedefs for CTypedPtrMap class template
	typedef CString BASE_KEY;
	typedef LPCTSTR BASE_ARG_KEY;
	typedef CString BASE_VALUE;
	typedef LPCTSTR BASE_ARG_VALUE;
};


#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifndef __AFXSTATE_H__
	#include <afxstat_.h>   // for MFC private state structures
#endif

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_ENABLE_INLINES
#define _AFXCOLL_INLINE AFX_INLINE
#include <afxcoll.inl>
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //!__AFXCOLL_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxcolorbutton.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#include "afxcontrolbarutil.h"
#include "afxbutton.h"
#include "afxcolorbar.h"

class CMFCColorPopupMenu;

/////////////////////////////////////////////////////////////////////////////
// CMFCColorButton window

class CMFCColorButton : public CMFCButton
{
	friend class CMFCColorBar;

	DECLARE_DYNAMIC(CMFCColorButton)

// Construction
public:
	CMFCColorButton();

// Attributes
public:
	COLORREF GetColor() const { return m_Color; }
	void SetColor(COLORREF color /* -1 - automatic*/);

	void SetColumnsNumber(int nColumns) { m_nColumns = nColumns; }

	void EnableAutomaticButton(LPCTSTR lpszLabel, COLORREF colorAutomatic, BOOL bEnable = TRUE);
	void EnableOtherButton(LPCTSTR lpszLabel, BOOL bAltColorDlg = TRUE, BOOL bEnable = TRUE);
	
	void SetDocumentColors(LPCTSTR lpszLabel, CList<COLORREF,COLORREF>& lstColors);

	static void __stdcall SetColorName(COLORREF color, const CString& strName) { CMFCColorBar::SetColorName(color, strName); }

	COLORREF GetAutomaticColor() const { return m_ColorAutomatic; }

	BOOL m_bEnabledInCustomizeMode;
	BOOL m_bAutoSetFocus;

protected:
	virtual void UpdateColor(COLORREF color);
	void RebuildPalette(CPalette* pPal);

protected:
	COLORREF m_Color;
	COLORREF m_ColorAutomatic;

	CArray<COLORREF, COLORREF> m_Colors;
	CList<COLORREF,COLORREF>   m_lstDocColors;

	int m_nColumns;
	CMFCColorPopupMenu* m_pPopup;

	CString m_strOtherText;
	CString m_strDocColorsText;
	CString m_strAutoColorText;

	BOOL m_bAltColorDlg;

	CPalette* m_pPalette;

// Operations
public:
	void SetPalette(CPalette* pPalette);

// Implementation
public:
	virtual ~CMFCColorButton();
	virtual CSize SizeToContent(BOOL bCalcOnly = FALSE);

protected:
	virtual void OnFillBackground(CDC* pDC, const CRect& rectClient);
	virtual void OnDraw(CDC* pDC, const CRect& rect, UINT uiState);
	virtual void OnDrawBorder(CDC* pDC, CRect& rectClient, UINT uiState);
	virtual void OnDrawFocusRect(CDC* pDC, const CRect& rectClient);
	
	virtual void OnShowColorPopup();

	BOOL IsDrawXPTheme() const;

protected:
	//{{AFX_MSG(CMFCColorButton)
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg UINT OnGetDlgCode();
	afx_msg void OnSysColorChange();
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg LRESULT OnInitControl(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxcolorbar.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#include "afxcontrolbarutil.h"
#include "afxpopupmenubar.h"

class CMFCColorButton;
class CMFCPropertyGridCtrl;
class CMFCRibbonColorButton;

/////////////////////////////////////////////////////////////////////////////
// CMFCColorBar window

class CMFCColorBar : public CMFCPopupMenuBar
{
	friend class CMFCColorPopupMenu;
	friend class CMFCColorMenuButton;
	friend class CMFCColorButton;
	friend class CMFCToolBarColorButton;
	friend class CMFCImageEditorDialog;
	friend class CMFCPropertyGridColorProperty;
	friend class CMFCRibbonColorButton;

	DECLARE_SERIAL(CMFCColorBar)

// Construction
public:
	CMFCColorBar();

	virtual BOOL Create(CWnd* pParentWnd, DWORD dwStyle, UINT nID,
		CPalette* pPalette = NULL, // Palette color, NULL - standard 20 colors
		int nColumns = 0,          // Number of columns, -1 - default
		int nRowsDockHorz = 0,     // Number of rows for horz. docking
		int nColDockVert = 0);     // Number of columns for vert. docking

	virtual BOOL CreateControl(CWnd* pParentWnd, const CRect& rect, UINT nID, int nColumns = -1, CPalette* pPalette = NULL);

protected:
	CMFCColorBar(const CArray<COLORREF, COLORREF>& colors, COLORREF color, LPCTSTR lpszAutoColor, LPCTSTR lpszOtherColor, LPCTSTR lpszDocColors,
		CList<COLORREF,COLORREF>& lstDocColors, int nColumns, int nRowsDockHorz, int nColDockVert, COLORREF colorAutomatic, UINT nCommandID, CMFCColorButton* pParentBtn);
	CMFCColorBar(const CArray<COLORREF, COLORREF>& colors, COLORREF color, LPCTSTR lpszAutoColor, LPCTSTR lpszOtherColor, LPCTSTR lpszDocColors,
		CList<COLORREF,COLORREF>& lstDocColors, int nColumns, COLORREF colorAutomatic, UINT nCommandID, CMFCRibbonColorButton*	pParentRibbonBtn);
	CMFCColorBar(CMFCColorBar& src, UINT uiCommandID);

// Operations:
public:
	void SetDocumentColors(LPCTSTR lpszCaption, CList<COLORREF,COLORREF>& lstDocColors, BOOL bShowWhenDocked = FALSE);
	void ContextToSize(BOOL bSquareButtons = TRUE, BOOL bCenterButtons = TRUE);

// Attributes
public:
	void SetColor(COLORREF color);
	COLORREF GetColor() const { return m_ColorSelected; }
	static void __stdcall SetColorName(COLORREF color, const CString& strName) { m_ColorNames.SetAt(color, strName); }

	void EnableAutomaticButton(LPCTSTR lpszLabel, COLORREF colorAutomatic, BOOL bEnable = TRUE);
	void EnableOtherButton(LPCTSTR lpszLabel, BOOL bAltColorDlg = TRUE, BOOL bEnable = TRUE);

	UINT GetCommandID() const { return m_nCommandID; }
	void SetCommandID(UINT nCommandID) { m_nCommandID = nCommandID; }
	BOOL IsTearOff() const { return m_bIsTearOff; }

	void SetVertMargin(int nVertMargin);
	void SetHorzMargin(int nHorzMargin);

	int GetVertMargin() const { return m_nVertMargin; }
	int GetHorzMargin() { return m_nHorzMargin; }

	COLORREF GetHighlightedColor() const;

protected:
	int m_nNumColumns;
	int m_nNumRowsHorz;
	int m_nNumColumnsVert;
	int m_nHorzOffset;
	int m_nVertOffset;
	int m_nRowHeight;
	int m_nVertMargin;
	int m_nHorzMargin;

	BOOL m_bStdColorDlg;
	BOOL m_bIsEnabled;
	BOOL m_bIsTearOff;
	BOOL m_bShowDocColorsWhenDocked;
	BOOL m_bInternal;  // Used in customization

	UINT m_nCommandID;

	CArray<COLORREF, COLORREF> m_colors;
	CList<COLORREF,COLORREF>   m_lstDocColors;

	CSize               m_BoxSize;
	CPalette            m_Palette;
	COLORREF            m_ColorSelected; // (-1) - auto
	COLORREF            m_ColorAutomatic;
	CString             m_strAutoColor;
	CString             m_strOtherColor;
	CString             m_strDocColors;
	CMFCColorButton*    m_pParentBtn;
	CMFCPropertyGridCtrl*      m_pWndPropList;
	CMFCRibbonColorButton* m_pParentRibbonBtn;

	AFX_IMPORT_DATA static CMap<COLORREF,COLORREF,CString, LPCTSTR> m_ColorNames;

// Overrides
	virtual BOOL OnSendCommand(const CMFCToolBarButton* pButton);
	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);
	virtual void AdjustLocations();
	virtual CSize CalcSize(BOOL bVertDock);
	virtual void DoPaint(CDC* pDC);
	virtual BOOL OnKey(UINT nChar);
	virtual void OnChangeHot(int iHot);

	virtual void Serialize(CArchive& ar);
	virtual void ShowCommandMessageString(UINT uiCmdId);

	virtual BOOL AllowChangeTextLabels() const { return FALSE; }
	virtual BOOL AllowShowOnList() const { return TRUE; }

	virtual BOOL OpenColorDialog(const COLORREF colorDefault, COLORREF& colorRes);

	virtual void Rebuild();

	virtual BOOL PreTranslateMessage(MSG* pMsg);

// Implementation
public:
	virtual ~CMFCColorBar();

protected:
	//{{AFX_MSG(CMFCColorBar)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg BOOL OnQueryNewPalette();
	afx_msg void OnPaletteChanged(CWnd* pFocusWnd);
	afx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp);
	afx_msg void OnNcPaint();
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnDestroy();
	afx_msg LRESULT OnMouseLeave(WPARAM,LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	static int __stdcall InitColors(CPalette* pPalette, CArray<COLORREF, COLORREF>& arColors);
	static BOOL __stdcall CreatePalette(const CArray<COLORREF, COLORREF>& arColors, CPalette& palette);

	CSize GetColorGridSize(BOOL bVertDock) const;
	int GetExtraHeight(int nNumColumns) const;
	CPalette* SelectPalette(CDC* pDC);

	void SetPropList(CMFCPropertyGridCtrl* pWndList) { m_pWndPropList = pWndList; }
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxcolordialog.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCColorPropertySheet;

#include "afxcontrolbarutil.h"
#include "afxdialogex.h"
#include "afxribbonres.h"
#include "afxcolorpickerctrl.h"
#include "afxbutton.h"
#include "afxstandardcolorspropertypage.h"
#include "afxcustomcolorspropertypage.h"

/////////////////////////////////////////////////////////////////////////////
// CMFCColorDialog dialog

class CMFCColorDialog : public CDialogEx
{
// Construction

public:
	CMFCColorDialog(COLORREF clrInit = 0, DWORD dwFlags = 0 /* reserved */, CWnd* pParentWnd = NULL, HPALETTE hPal = NULL);
	virtual ~CMFCColorDialog();

	void SetCurrentColor(COLORREF rgb);
	void SetNewColor(COLORREF rgb);

	COLORREF GetColor() const { return m_NewColor; }

	void SetPageTwo(BYTE R, BYTE G, BYTE B);
	void SetPageOne(BYTE R, BYTE G, BYTE B);

	CPalette* GetPalette() const { return m_pPalette; }

// Dialog Data
	enum { IDD = IDD_AFXBARRES_COLOR_DLG };

public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);

protected:
	virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV support

// Implementation
protected:
	CMFCColorPropertySheet* m_pPropSheet;

	CMFCStandardColorsPropertyPage* m_pColourSheetOne;
	CMFCCustomColorsPropertyPage* m_pColourSheetTwo;
	CPalette*    m_pPalette;

	COLORREF m_CurrentColor;
	COLORREF m_NewColor;
	HCURSOR  m_hcurPicker;

	BOOL m_bIsMyPalette;
	BOOL m_bPickerMode;

	CMFCButton          m_btnColorSelect;
	CStatic             m_wndStaticPlaceHolder;
	CMFCColorPickerCtrl m_wndColors;

	//{{AFX_MSG(CMFCColorDialog)
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	afx_msg void OnSysColorChange();
	afx_msg void OnColorSelect();
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void RebuildPalette();
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxcoll.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXCOLL.H

#pragma once

#ifdef _AFXCOLL_INLINE

////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE INT_PTR CByteArray::GetSize() const
	{ return m_nSize; }
_AFXCOLL_INLINE INT_PTR CByteArray::GetCount() const
	{ return m_nSize; }
_AFXCOLL_INLINE BOOL CByteArray::IsEmpty() const
	{ return m_nSize == 0; }
_AFXCOLL_INLINE INT_PTR CByteArray::GetUpperBound() const
	{ return m_nSize-1; }
_AFXCOLL_INLINE void CByteArray::RemoveAll()
	{ SetSize(0); }
_AFXCOLL_INLINE BYTE CByteArray::GetAt(INT_PTR nIndex) const
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		return m_pData[nIndex]; }
_AFXCOLL_INLINE void CByteArray::SetAt(INT_PTR nIndex, BYTE newElement)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		m_pData[nIndex] = newElement; }

_AFXCOLL_INLINE BYTE& CByteArray::ElementAt(INT_PTR nIndex)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		return m_pData[nIndex]; }
_AFXCOLL_INLINE const BYTE* CByteArray::GetData() const
	{ return (const BYTE*)m_pData; }
_AFXCOLL_INLINE BYTE* CByteArray::GetData()
	{ return (BYTE*)m_pData; }
_AFXCOLL_INLINE INT_PTR CByteArray::Add(BYTE newElement)
	{ INT_PTR nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }

_AFXCOLL_INLINE BYTE CByteArray::operator[](INT_PTR nIndex) const
	{ return GetAt(nIndex); }
_AFXCOLL_INLINE BYTE& CByteArray::operator[](INT_PTR nIndex)
	{ return ElementAt(nIndex); }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE INT_PTR CWordArray::GetSize() const
	{ return m_nSize; }
_AFXCOLL_INLINE INT_PTR CWordArray::GetCount() const
	{ return m_nSize; }
_AFXCOLL_INLINE BOOL CWordArray::IsEmpty() const
	{ return m_nSize == 0; }
_AFXCOLL_INLINE INT_PTR CWordArray::GetUpperBound() const
	{ return m_nSize-1; }
_AFXCOLL_INLINE void CWordArray::RemoveAll()
	{ SetSize(0); }
_AFXCOLL_INLINE WORD CWordArray::GetAt(INT_PTR nIndex) const
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		return m_pData[nIndex]; }
_AFXCOLL_INLINE void CWordArray::SetAt(INT_PTR nIndex, WORD newElement)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		m_pData[nIndex] = newElement; }

_AFXCOLL_INLINE WORD& CWordArray::ElementAt(INT_PTR nIndex)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		return m_pData[nIndex]; }
_AFXCOLL_INLINE const WORD* CWordArray::GetData() const
	{ return (const WORD*)m_pData; }
_AFXCOLL_INLINE WORD* CWordArray::GetData()
	{ return (WORD*)m_pData; }
_AFXCOLL_INLINE INT_PTR CWordArray::Add(WORD newElement)
	{ INT_PTR nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }

_AFXCOLL_INLINE WORD CWordArray::operator[](INT_PTR nIndex) const
	{ return GetAt(nIndex); }
_AFXCOLL_INLINE WORD& CWordArray::operator[](INT_PTR nIndex)
	{ return ElementAt(nIndex); }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE INT_PTR CDWordArray::GetSize() const
	{ return m_nSize; }
_AFXCOLL_INLINE INT_PTR CDWordArray::GetCount() const
	{ return m_nSize; }
_AFXCOLL_INLINE BOOL CDWordArray::IsEmpty() const
	{ return m_nSize == 0; }
_AFXCOLL_INLINE INT_PTR CDWordArray::GetUpperBound() const
	{ return m_nSize-1; }
_AFXCOLL_INLINE void CDWordArray::RemoveAll()
	{ SetSize(0); }
_AFXCOLL_INLINE DWORD CDWordArray::GetAt(INT_PTR nIndex) const
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		return m_pData[nIndex]; }
_AFXCOLL_INLINE void CDWordArray::SetAt(INT_PTR nIndex, DWORD newElement)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		m_pData[nIndex] = newElement; }

_AFXCOLL_INLINE DWORD& CDWordArray::ElementAt(INT_PTR nIndex)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		return m_pData[nIndex]; }
_AFXCOLL_INLINE const DWORD* CDWordArray::GetData() const
	{ return (const DWORD*)m_pData; }
_AFXCOLL_INLINE DWORD* CDWordArray::GetData()
	{ return (DWORD*)m_pData; }
_AFXCOLL_INLINE INT_PTR CDWordArray::Add(DWORD newElement)
	{ INT_PTR nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }

_AFXCOLL_INLINE DWORD CDWordArray::operator[](INT_PTR nIndex) const
	{ return GetAt(nIndex); }
_AFXCOLL_INLINE DWORD& CDWordArray::operator[](INT_PTR nIndex)
	{ return ElementAt(nIndex); }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE INT_PTR CUIntArray::GetSize() const
	{ return m_nSize; }
_AFXCOLL_INLINE INT_PTR CUIntArray::GetCount() const
	{ return m_nSize; }
_AFXCOLL_INLINE BOOL CUIntArray::IsEmpty() const
	{ return m_nSize == 0; }
_AFXCOLL_INLINE INT_PTR CUIntArray::GetUpperBound() const
	{ return m_nSize-1; }
_AFXCOLL_INLINE void CUIntArray::RemoveAll()
	{ SetSize(0); }
_AFXCOLL_INLINE UINT CUIntArray::GetAt(INT_PTR nIndex) const
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		return m_pData[nIndex]; }
_AFXCOLL_INLINE void CUIntArray::SetAt(INT_PTR nIndex, UINT newElement)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		m_pData[nIndex] = newElement; }

_AFXCOLL_INLINE UINT& CUIntArray::ElementAt(INT_PTR nIndex)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		return m_pData[nIndex]; }
_AFXCOLL_INLINE const UINT* CUIntArray::GetData() const
	{ return (const UINT*)m_pData; }
_AFXCOLL_INLINE UINT* CUIntArray::GetData()
	{ return (UINT*)m_pData; }
_AFXCOLL_INLINE INT_PTR CUIntArray::Add(UINT newElement)
	{ INT_PTR nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }

_AFXCOLL_INLINE UINT CUIntArray::operator[](INT_PTR nIndex) const
	{ return GetAt(nIndex); }
_AFXCOLL_INLINE UINT& CUIntArray::operator[](INT_PTR nIndex)
	{ return ElementAt(nIndex); }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE INT_PTR CPtrArray::GetSize() const
	{ return m_nSize; }
_AFXCOLL_INLINE INT_PTR CPtrArray::GetCount() const
	{ return m_nSize; }
_AFXCOLL_INLINE BOOL CPtrArray::IsEmpty() const
	{ return m_nSize == 0; }
_AFXCOLL_INLINE INT_PTR CPtrArray::GetUpperBound() const
	{ return m_nSize-1; }
_AFXCOLL_INLINE void CPtrArray::RemoveAll()
	{ SetSize(0); }
_AFXCOLL_INLINE void* CPtrArray::GetAt(INT_PTR nIndex) const
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		return m_pData[nIndex]; }
_AFXCOLL_INLINE void CPtrArray::SetAt(INT_PTR nIndex, void* newElement)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		m_pData[nIndex] = newElement; }

_AFXCOLL_INLINE void*& CPtrArray::ElementAt(INT_PTR nIndex)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		return m_pData[nIndex]; }
_AFXCOLL_INLINE const void** CPtrArray::GetData() const
	{ return (const void**)m_pData; }
_AFXCOLL_INLINE void** CPtrArray::GetData()
	{ return (void**)m_pData; }
_AFXCOLL_INLINE INT_PTR CPtrArray::Add(void* newElement)
	{ INT_PTR nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }

_AFXCOLL_INLINE void* CPtrArray::operator[](INT_PTR nIndex) const
	{ return GetAt(nIndex); }
_AFXCOLL_INLINE void*& CPtrArray::operator[](INT_PTR nIndex)
	{ return ElementAt(nIndex); }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE INT_PTR CObArray::GetSize() const
	{ return m_nSize; }
_AFXCOLL_INLINE INT_PTR CObArray::GetCount() const
	{ return m_nSize; }
_AFXCOLL_INLINE BOOL CObArray::IsEmpty() const
	{ return m_nSize == 0; }
_AFXCOLL_INLINE INT_PTR CObArray::GetUpperBound() const
	{ return m_nSize-1; }
_AFXCOLL_INLINE void CObArray::RemoveAll()
	{ SetSize(0); }
_AFXCOLL_INLINE CObject* CObArray::GetAt(INT_PTR nIndex) const
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		return m_pData[nIndex]; }
_AFXCOLL_INLINE void CObArray::SetAt(INT_PTR nIndex, CObject* newElement)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		m_pData[nIndex] = newElement; }

_AFXCOLL_INLINE CObject*& CObArray::ElementAt(INT_PTR nIndex)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		return m_pData[nIndex]; }
_AFXCOLL_INLINE const CObject** CObArray::GetData() const
	{ return (const CObject**)m_pData; }
_AFXCOLL_INLINE CObject** CObArray::GetData()
	{ return (CObject**)m_pData; }
_AFXCOLL_INLINE INT_PTR CObArray::Add(CObject* newElement)
	{ INT_PTR nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }

_AFXCOLL_INLINE CObject* CObArray::operator[](INT_PTR nIndex) const
	{ return GetAt(nIndex); }
_AFXCOLL_INLINE CObject*& CObArray::operator[](INT_PTR nIndex)
	{ return ElementAt(nIndex); }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE INT_PTR CStringArray::GetSize() const
	{ return m_nSize; }
_AFXCOLL_INLINE INT_PTR CStringArray::GetCount() const
	{ return m_nSize; }
_AFXCOLL_INLINE BOOL CStringArray::IsEmpty() const
	{ return m_nSize == 0; }
_AFXCOLL_INLINE INT_PTR CStringArray::GetUpperBound() const
	{ return m_nSize-1; }
_AFXCOLL_INLINE void CStringArray::RemoveAll()
	{ SetSize(0); }
_AFXCOLL_INLINE const CString& CStringArray::GetAt(INT_PTR nIndex) const
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		return m_pData[nIndex]; }
_AFXCOLL_INLINE void CStringArray::SetAt(INT_PTR nIndex, LPCTSTR newElement)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		m_pData[nIndex] = newElement; }

_AFXCOLL_INLINE void CStringArray::SetAt(INT_PTR nIndex, const CString& newElement)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		m_pData[nIndex] = newElement; }

_AFXCOLL_INLINE CString& CStringArray::ElementAt(INT_PTR nIndex)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		return m_pData[nIndex]; }

_AFXCOLL_INLINE const CString* CStringArray::GetData() const
	{ return (const CString*)m_pData; }
_AFXCOLL_INLINE CString* CStringArray::GetData()
	{ return (CString*)m_pData; }
_AFXCOLL_INLINE INT_PTR CStringArray::Add(LPCTSTR newElement)
	{ INT_PTR nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }

_AFXCOLL_INLINE INT_PTR CStringArray::Add(const CString& newElement)
	{ INT_PTR nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }

_AFXCOLL_INLINE const CString& CStringArray::operator[](INT_PTR nIndex) const
	{ return GetAt(nIndex); }
_AFXCOLL_INLINE CString& CStringArray::operator[](INT_PTR nIndex)
	{ return ElementAt(nIndex); }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE INT_PTR CPtrList::GetCount() const
	{ return m_nCount; }
_AFXCOLL_INLINE INT_PTR CPtrList::GetSize() const
	{ return m_nCount; }
_AFXCOLL_INLINE BOOL CPtrList::IsEmpty() const
	{ return m_nCount == 0; }
_AFXCOLL_INLINE void*& CPtrList::GetHead()
	{ ASSERT(m_pNodeHead != NULL);
		return m_pNodeHead->data; }
_AFXCOLL_INLINE const void* CPtrList::GetHead() const
	{ ASSERT(m_pNodeHead != NULL);
		return m_pNodeHead->data; }
_AFXCOLL_INLINE void*& CPtrList::GetTail()
	{ ASSERT(m_pNodeTail != NULL);
		return m_pNodeTail->data; }
_AFXCOLL_INLINE const void* CPtrList::GetTail() const
	{ ASSERT(m_pNodeTail != NULL);
		return m_pNodeTail->data; }
_AFXCOLL_INLINE POSITION CPtrList::GetHeadPosition() const
	{ return (POSITION) m_pNodeHead; }
_AFXCOLL_INLINE POSITION CPtrList::GetTailPosition() const
	{ return (POSITION) m_pNodeTail; }
_AFXCOLL_INLINE void*& CPtrList::GetNext(POSITION& rPosition) // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
_AFXCOLL_INLINE const void* CPtrList::GetNext(POSITION& rPosition) const // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
_AFXCOLL_INLINE void*& CPtrList::GetPrev(POSITION& rPosition) // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
_AFXCOLL_INLINE const void* CPtrList::GetPrev(POSITION& rPosition) const // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
_AFXCOLL_INLINE void*& CPtrList::GetAt(POSITION position)
	{ CNode* pNode = (CNode*) position;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		return pNode->data; }
_AFXCOLL_INLINE const void* CPtrList::GetAt(POSITION position) const
	{ CNode* pNode = (CNode*) position;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		return pNode->data; }
_AFXCOLL_INLINE void CPtrList::SetAt(POSITION pos, void* newElement)
	{ CNode* pNode = (CNode*) pos;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		pNode->data = newElement; }



////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE INT_PTR CObList::GetCount() const
	{ return m_nCount; }
_AFXCOLL_INLINE INT_PTR CObList::GetSize() const
	{ return m_nCount; }
_AFXCOLL_INLINE BOOL CObList::IsEmpty() const
	{ return m_nCount == 0; }
_AFXCOLL_INLINE CObject*& CObList::GetHead()
	{ ASSERT(m_pNodeHead != NULL);
		return m_pNodeHead->data; }
_AFXCOLL_INLINE const CObject* CObList::GetHead() const
	{ ASSERT(m_pNodeHead != NULL);
		return m_pNodeHead->data; }
_AFXCOLL_INLINE CObject*& CObList::GetTail()
	{ ASSERT(m_pNodeTail != NULL);
		return m_pNodeTail->data; }
_AFXCOLL_INLINE const CObject* CObList::GetTail() const
	{ ASSERT(m_pNodeTail != NULL);
		return m_pNodeTail->data; }
_AFXCOLL_INLINE POSITION CObList::GetHeadPosition() const
	{ return (POSITION) m_pNodeHead; }
_AFXCOLL_INLINE POSITION CObList::GetTailPosition() const
	{ return (POSITION) m_pNodeTail; }
_AFXCOLL_INLINE CObject*& CObList::GetNext(POSITION& rPosition) // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
_AFXCOLL_INLINE const CObject* CObList::GetNext(POSITION& rPosition) const // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
_AFXCOLL_INLINE CObject*& CObList::GetPrev(POSITION& rPosition) // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
_AFXCOLL_INLINE const CObject* CObList::GetPrev(POSITION& rPosition) const // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
_AFXCOLL_INLINE CObject*& CObList::GetAt(POSITION position)
	{ CNode* pNode = (CNode*) position;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		return pNode->data; }
_AFXCOLL_INLINE const CObject* CObList::GetAt(POSITION position) const
	{ CNode* pNode = (CNode*) position;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		return pNode->data; }
_AFXCOLL_INLINE void CObList::SetAt(POSITION pos, CObject* newElement)
	{ CNode* pNode = (CNode*) pos;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		pNode->data = newElement; }



////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE INT_PTR CStringList::GetCount() const
	{ return m_nCount; }
_AFXCOLL_INLINE INT_PTR CStringList::GetSize() const
	{ return m_nCount; }
_AFXCOLL_INLINE BOOL CStringList::IsEmpty() const
	{ return m_nCount == 0; }
_AFXCOLL_INLINE CString& CStringList::GetHead()
	{ ASSERT(m_pNodeHead != NULL);
		return m_pNodeHead->data; }
_AFXCOLL_INLINE const CString& CStringList::GetHead() const
	{ ASSERT(m_pNodeHead != NULL);
		return m_pNodeHead->data; }
_AFXCOLL_INLINE CString& CStringList::GetTail()
	{ ASSERT(m_pNodeTail != NULL);
		return m_pNodeTail->data; }
_AFXCOLL_INLINE const CString& CStringList::GetTail() const
	{ ASSERT(m_pNodeTail != NULL);
		return m_pNodeTail->data; }
_AFXCOLL_INLINE POSITION CStringList::GetHeadPosition() const
	{ return (POSITION) m_pNodeHead; }
_AFXCOLL_INLINE POSITION CStringList::GetTailPosition() const
	{ return (POSITION) m_pNodeTail; }
_AFXCOLL_INLINE CString& CStringList::GetNext(POSITION& rPosition) // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
_AFXCOLL_INLINE const CString& CStringList::GetNext(POSITION& rPosition) const // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
_AFXCOLL_INLINE CString& CStringList::GetPrev(POSITION& rPosition) // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
_AFXCOLL_INLINE const CString& CStringList::GetPrev(POSITION& rPosition) const // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
_AFXCOLL_INLINE CString& CStringList::GetAt(POSITION position)
	{ CNode* pNode = (CNode*) position;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		return pNode->data; }
_AFXCOLL_INLINE const CString& CStringList::GetAt(POSITION position) const
	{ CNode* pNode = (CNode*) position;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		return pNode->data; }
_AFXCOLL_INLINE void CStringList::SetAt(POSITION pos, LPCTSTR newElement)
	{ CNode* pNode = (CNode*) pos;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		pNode->data = newElement; }

_AFXCOLL_INLINE void CStringList::SetAt(POSITION pos, const CString& newElement)
	{ CNode* pNode = (CNode*) pos;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		if( pNode == NULL )
			AfxThrowInvalidArgException();
		pNode->data = newElement; }



////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE INT_PTR CMapWordToPtr::GetCount() const
	{ return m_nCount; }
_AFXCOLL_INLINE INT_PTR CMapWordToPtr::GetSize() const
	{ return m_nCount; }
_AFXCOLL_INLINE BOOL CMapWordToPtr::IsEmpty() const
	{ return m_nCount == 0; }
_AFXCOLL_INLINE void CMapWordToPtr::SetAt(WORD key, void* newValue)
	{ (*this)[key] = newValue; }
_AFXCOLL_INLINE POSITION CMapWordToPtr::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
_AFXCOLL_INLINE UINT CMapWordToPtr::GetHashTableSize() const
	{ return m_nHashTableSize; }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE INT_PTR CMapPtrToWord::GetCount() const
	{ return m_nCount; }
_AFXCOLL_INLINE INT_PTR CMapPtrToWord::GetSize() const
	{ return m_nCount; }
_AFXCOLL_INLINE BOOL CMapPtrToWord::IsEmpty() const
	{ return m_nCount == 0; }
_AFXCOLL_INLINE void CMapPtrToWord::SetAt(void* key, WORD newValue)
	{ (*this)[key] = newValue; }
_AFXCOLL_INLINE POSITION CMapPtrToWord::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
_AFXCOLL_INLINE UINT CMapPtrToWord::GetHashTableSize() const
	{ return m_nHashTableSize; }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE INT_PTR CMapPtrToPtr::GetCount() const
	{ return m_nCount; }
_AFXCOLL_INLINE INT_PTR CMapPtrToPtr::GetSize() const
	{ return m_nCount; }
_AFXCOLL_INLINE BOOL CMapPtrToPtr::IsEmpty() const
	{ return m_nCount == 0; }
_AFXCOLL_INLINE void CMapPtrToPtr::SetAt(void* key, void* newValue)
	{ (*this)[key] = newValue; }
_AFXCOLL_INLINE POSITION CMapPtrToPtr::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
_AFXCOLL_INLINE UINT CMapPtrToPtr::GetHashTableSize() const
	{ return m_nHashTableSize; }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE INT_PTR CMapWordToOb::GetCount() const
	{ return m_nCount; }
_AFXCOLL_INLINE INT_PTR CMapWordToOb::GetSize() const
	{ return m_nCount; }
_AFXCOLL_INLINE BOOL CMapWordToOb::IsEmpty() const
	{ return m_nCount == 0; }
_AFXCOLL_INLINE void CMapWordToOb::SetAt(WORD key, CObject* newValue)
	{ (*this)[key] = newValue; }
_AFXCOLL_INLINE POSITION CMapWordToOb::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
_AFXCOLL_INLINE UINT CMapWordToOb::GetHashTableSize() const
	{ return m_nHashTableSize; }


////////////////////////////////////////////////////////////////////////////
_AFXCOLL_INLINE INT_PTR CMapStringToPtr::GetCount() const
	{ return m_nCount; }
_AFXCOLL_INLINE INT_PTR CMapStringToPtr::GetSize() const
	{ return m_nCount; }
_AFXCOLL_INLINE BOOL CMapStringToPtr::IsEmpty() const
	{ return m_nCount == 0; }
_AFXCOLL_INLINE void CMapStringToPtr::SetAt(LPCTSTR key, void* newValue)
	{ (*this)[key] = newValue; }
_AFXCOLL_INLINE POSITION CMapStringToPtr::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
_AFXCOLL_INLINE UINT CMapStringToPtr::GetHashTableSize() const
	{ return m_nHashTableSize; }


////////////////////////////////////////////////////////////////////////////
_AFXCOLL_INLINE INT_PTR CMapStringToOb::GetCount() const
	{ return m_nCount; }
_AFXCOLL_INLINE INT_PTR CMapStringToOb::GetSize() const
	{ return m_nCount; }
_AFXCOLL_INLINE BOOL CMapStringToOb::IsEmpty() const
	{ return m_nCount == 0; }
_AFXCOLL_INLINE void CMapStringToOb::SetAt(LPCTSTR key, CObject* newValue)
	{ (*this)[key] = newValue; }
_AFXCOLL_INLINE POSITION CMapStringToOb::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
_AFXCOLL_INLINE UINT CMapStringToOb::GetHashTableSize() const
	{ return m_nHashTableSize; }


////////////////////////////////////////////////////////////////////////////
_AFXCOLL_INLINE INT_PTR CMapStringToString::GetCount() const
	{ return m_nCount; }
_AFXCOLL_INLINE INT_PTR CMapStringToString::GetSize() const
	{ return m_nCount; }
_AFXCOLL_INLINE BOOL CMapStringToString::IsEmpty() const
	{ return m_nCount == 0; }
_AFXCOLL_INLINE void CMapStringToString::SetAt(LPCTSTR key, LPCTSTR newValue)
	{ (*this)[key] = newValue; }
_AFXCOLL_INLINE POSITION CMapStringToString::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
_AFXCOLL_INLINE UINT CMapStringToString::GetHashTableSize() const
	{ return m_nHashTableSize; }

/////////////////////////////////////////////////////////////////////////////

#endif //_AFXCOLL_INLINE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxcolormenubutton.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxtoolbarmenubutton.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

extern AFX_IMPORT_DATA UINT AFX_WM_GETDOCUMENTCOLORS;

class CMFCColorMenuButton : public CMFCToolBarMenuButton  
{
	DECLARE_SERIAL(CMFCColorMenuButton)

public:
	CMFCColorMenuButton();
	CMFCColorMenuButton(UINT uiCmdID, LPCTSTR lpszText, CPalette* pPalette = NULL);
	virtual ~CMFCColorMenuButton();

	virtual void SetColor(COLORREF clr, BOOL bNotify = TRUE);
	COLORREF GetColor() const { return m_Color; }

	static COLORREF __stdcall GetColorByCmdID(UINT uiCmdID);
	static void __stdcall SetColorByCmdID(UINT uiCmdID, COLORREF color) { m_ColorsByID.SetAt(uiCmdID, color); }
	void SetColumnsNumber(int nColumns) { m_nColumns = nColumns; }

	void EnableAutomaticButton(LPCTSTR lpszLabel, COLORREF colorAutomatic, BOOL bEnable = TRUE);
	void EnableOtherButton(LPCTSTR lpszLabel, BOOL bAltColorDlg = TRUE, BOOL bEnable = TRUE);
	void EnableDocumentColors(LPCTSTR lpszLabel, BOOL bEnable = TRUE);
	void EnableTearOff(UINT uiID, int nVertDockColumns = -1, int nHorzDockRows = -1);

	static void __stdcall SetColorName(COLORREF color, const CString& strName);

	COLORREF GetAutomaticColor() const { return m_colorAutomatic; }

	virtual BOOL OpenColorDialog(const COLORREF colorDefault, COLORREF& colorRes);
	virtual void OnChangeParentWnd(CWnd* pWndParent);

protected:
	virtual void OnDraw(CDC* pDC, const CRect& rect, CMFCToolBarImages* pImages, BOOL bHorz = TRUE, BOOL bCustomizeMode = FALSE,
		BOOL bHighlight = FALSE, BOOL bDrawBorder = TRUE, BOOL bGrayDisabledButtons = TRUE); 
	virtual CMFCPopupMenu* CreatePopupMenu();
	virtual BOOL IsEmptyMenuAllowed() const { return TRUE; }

	virtual void Serialize(CArchive& ar);
	virtual void CopyFrom(const CMFCToolBarButton& src);
	virtual int OnDrawOnCustomizeList(CDC* pDC, const CRect& rect, BOOL bSelected);

	void Initialize();

protected:
	COLORREF m_Color;  // Currently selected color
	COLORREF m_colorAutomatic;

	CArray<COLORREF, COLORREF> m_Colors;

	CPalette m_Palette;

	int m_nColumns;
	int m_nVertDockColumns;
	int m_nHorzDockRows;

	BOOL m_bIsAutomaticButton;
	BOOL m_bIsOtherButton;
	BOOL m_bIsDocumentColors;

	CString m_strAutomaticButtonLabel;
	CString m_strOtherButtonLabel;
	CString m_strDocumentColorsLabel;

	BOOL m_bStdColorDlg;

	AFX_IMPORT_DATA static CMap<UINT,UINT,COLORREF, COLORREF> m_ColorsByID;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxcolorpickerctrl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCColorPickerCtrl window

class CMFCColorPickerCtrl : public CButton
{
// Construction
public:
	CMFCColorPickerCtrl();
	virtual ~CMFCColorPickerCtrl();

// Attributes
public:

	enum COLORTYPE { CURRENT, LUMINANCE, PICKER, HEX, HEX_GREYSCALE };

// Operations
public:

// Overrides
protected:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual void PreSubclassWindow();
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);

// Implementation
public:
	void SetType(COLORTYPE colorType);
	void SetPalette(CPalette*	pPalette);

	void SetOriginalColor(COLORREF ref);

	void SetHLS(double hue,double luminance, double saturation, BOOL bInvalidate = TRUE);
	void GetHLS(double *hue,double *luminance, double *saturation);

	void SetLuminanceBarWidth	(int w);

	double GetHue() const        { return m_dblHue; };
	double GetLuminance() const  { return m_dblLum; };
	double GetSaturation() const { return m_dblSat; };
	COLORREF GetColor() const    { return m_colorNew; };

	void SetHue(double Hue)               { m_dblHue = Hue; };
	void SetLuminance(double Luminance)   { m_dblLum = Luminance; };
	void SetSaturation(double Saturation) { m_dblSat = Saturation; };
	void SetColor(COLORREF Color);

	void SelectCellHexagon(BYTE R, BYTE G, BYTE B);

protected:
	void CreateHexagon();
	void CreateHexGreyScaleBar();

	void DrawHex(CDC* pDC);
	void DrawPicker(CDC* pDC);
	void DrawLuminanceBar(CDC* pDC);

	int GetAngleFromPoint(int nX, int nY);
	virtual void DrawCursor(CDC* pDC, const CRect& rect);

 	BOOL SelectCellHexagon(int x, int y);

	double LumFromPoint(int nY);
	int PointFromLum(double dblLum);

	CPoint GetCursorPos();
	CRect GetCursorRect();

	void NotifyParent();

protected:
	//{{AFX_MSG(CMFCColorPickerCtrl)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg UINT OnGetDlgCode();
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg BOOL OnQueryNewPalette();
	afx_msg void OnPaletteChanged(CWnd* pFocusWnd);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnCancelMode();
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Attributes:
protected:
	COLORTYPE m_COLORTYPE;

	double    m_dblLum, m_dblSat, m_dblHue;
	COLORREF  m_colorNew;
	COLORREF  m_colorOriginal;

	int       m_nLumBarWidth;

	CPalette* m_pPalette;
	CBitmap   m_bmpPicker;
	CObArray  m_arCells;	// Array of CCellObj's
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxcolorpropertysheet.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCColorPropertySheet

class CMFCColorPropertySheet : public CPropertySheet
{
	DECLARE_DYNAMIC(CMFCColorPropertySheet)

// Construction
public:
	CMFCColorPropertySheet(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
	CMFCColorPropertySheet(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);

// Overrides
public:
	virtual BOOL OnInitDialog();

protected:
	virtual void PostNcDestroy();
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	virtual BOOL PreTranslateMessage(MSG* pMsg);

// Implementation
public:
	virtual ~CMFCColorPropertySheet();
	void LoadAcceleratorTable(UINT nAccelTableID = 0);

protected:
	HACCEL m_hAccel;

	void ResizeControl();

	//{{AFX_MSG(CMFCColorPropertySheet)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxcolorpopupmenu.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxpopupmenu.h"
#include "afxcolorbar.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CPane;
class CMFCPropertyGridCtrl;
class CMFCRibbonColorButton;

/////////////////////////////////////////////////////////////////////////////
// CMFCColorPopupMenu window

class CMFCColorPopupMenu : public CMFCPopupMenu
{
	friend class CMFCColorButton;
	friend class CMFCPropertyGridColorProperty;

	DECLARE_DYNAMIC(CMFCColorPopupMenu)

// Construction
public:
	CMFCColorPopupMenu(const CArray<COLORREF, COLORREF>& colors, COLORREF color, LPCTSTR lpszAutoColor, LPCTSTR lpszOtherColor, LPCTSTR lpszDocColors, CList<COLORREF,COLORREF>& lstDocColors,
		int nColumns, int nHorzDockRows, int nVertDockColumns, COLORREF colorAutomatic, UINT uiCommandID, BOOL bStdColorDlg = FALSE) :
	m_wndColorBar(colors, color, lpszAutoColor, lpszOtherColor, lpszDocColors, lstDocColors, nColumns, nHorzDockRows, nVertDockColumns, colorAutomatic, uiCommandID, NULL)
	{
		m_bEnabledInCustomizeMode = FALSE;
		m_wndColorBar.m_bStdColorDlg = bStdColorDlg;
	}

	CMFCColorPopupMenu(CMFCColorButton* pParentBtn, const CArray<COLORREF, COLORREF>& colors, COLORREF color, LPCTSTR lpszAutoColor, LPCTSTR lpszOtherColor,
		LPCTSTR lpszDocColors, CList<COLORREF,COLORREF>& lstDocColors, int nColumns, COLORREF colorAutomatic) :
	m_wndColorBar(colors, color, lpszAutoColor, lpszOtherColor, lpszDocColors, lstDocColors, nColumns, -1, -1, colorAutomatic, (UINT)-1, pParentBtn)
	{
		m_bEnabledInCustomizeMode = FALSE;
	}

	CMFCColorPopupMenu(CMFCRibbonColorButton* pParentBtn, const CArray<COLORREF, COLORREF>& colors, COLORREF color, LPCTSTR lpszAutoColor, LPCTSTR lpszOtherColor,
		LPCTSTR lpszDocColors, CList<COLORREF,COLORREF>& lstDocColors, int nColumns, COLORREF colorAutomatic, UINT nID) :
	m_wndColorBar(colors, color, lpszAutoColor, lpszOtherColor, lpszDocColors, lstDocColors, nColumns, colorAutomatic, nID, pParentBtn)
	{
		m_bEnabledInCustomizeMode = FALSE;
	}

	virtual ~CMFCColorPopupMenu();

// Attributes
protected:
	CMFCColorBar m_wndColorBar;
	BOOL      m_bEnabledInCustomizeMode;

public:
	void SetPropList(CMFCPropertyGridCtrl* pWndList) { m_wndColorBar.SetPropList(pWndList); }

// Overrides
	virtual CMFCPopupMenuBar* GetMenuBar() { return &m_wndColorBar; }
	virtual CPane* CreateTearOffBar(CFrameWnd* pWndMain, UINT uiID, LPCTSTR lpszName);

protected:
	//{{AFX_MSG(CMFCColorPopupMenu)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxcomctl32.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXCOMCTL32.H

#pragma once


/////////////////////////////////////////////////////////////////////////////
// Fusion: Macros to create global functions from wrapper methods (comctl32,commdlg)
// of dynamic wrappers.

#pragma push_macro("COMCTL_AFXFUNC")
#pragma push_macro("COMCTL_AFXPROC")

#define COMCTL_AFXFUNC(type, name, params, args) \
	inline type WINAPI Afx##name##params \
	{ \
		return afxComCtlWrapper->_##name##args; \
	}

#define COMCTL_AFXPROC(name, params, args) \
	inline void WINAPI Afx##name##params \
	{ \
		afxComCtlWrapper->_##name##args; \
	}

/////////////////////////////////////////////////////////////////////////////

COMCTL_AFXPROC(InitCommonControls, (), ())
COMCTL_AFXFUNC(BOOL, InitCommonControlsEx, (LPINITCOMMONCONTROLSEX unnamed1), (unnamed1))
COMCTL_AFXFUNC(HIMAGELIST, ImageList_Create, (int cx,int cy,UINT flags,int cInitial,int cGrow), (cx,cy,flags,cInitial,cGrow))
COMCTL_AFXFUNC(BOOL, ImageList_Destroy, (HIMAGELIST himl), (himl))
COMCTL_AFXFUNC(int, ImageList_GetImageCount, (HIMAGELIST himl), (himl))
COMCTL_AFXFUNC(BOOL, ImageList_SetImageCount, (HIMAGELIST himl,UINT uNewCount), (himl,uNewCount))
COMCTL_AFXFUNC(int, ImageList_Add, (HIMAGELIST himl,HBITMAP hbmImage,HBITMAP hbmMask), (himl,hbmImage,hbmMask))
COMCTL_AFXFUNC(int, ImageList_ReplaceIcon, (HIMAGELIST himl,int i,HICON hicon), (himl,i,hicon))
COMCTL_AFXFUNC(COLORREF, ImageList_SetBkColor, (HIMAGELIST himl,COLORREF clrBk), (himl,clrBk))
COMCTL_AFXFUNC(COLORREF, ImageList_GetBkColor, (HIMAGELIST himl), (himl))
COMCTL_AFXFUNC(BOOL, ImageList_SetOverlayImage, (HIMAGELIST himl,int iImage,int iOverlay), (himl,iImage,iOverlay))
COMCTL_AFXFUNC(BOOL, ImageList_Draw, (HIMAGELIST himl,int i,HDC hdcDst,int x,int y,UINT fStyle), (himl,i,hdcDst,x,y,fStyle))
COMCTL_AFXFUNC(BOOL, ImageList_Replace, (HIMAGELIST himl,int i,HBITMAP hbmImage,HBITMAP hbmMask), (himl,i,hbmImage,hbmMask))
COMCTL_AFXFUNC(int, ImageList_AddMasked, (HIMAGELIST himl,HBITMAP hbmImage,COLORREF crMask), (himl,hbmImage,crMask))
COMCTL_AFXFUNC(BOOL, ImageList_DrawEx, (HIMAGELIST himl,int i,HDC hdcDst,int x,int y,int dx,int dy,COLORREF rgbBk,COLORREF rgbFg,UINT fStyle), (himl,i,hdcDst,x,y,dx,dy,rgbBk,rgbFg,fStyle))
COMCTL_AFXFUNC(BOOL, ImageList_DrawIndirect, (IMAGELISTDRAWPARAMS*pimldp), (pimldp))
COMCTL_AFXFUNC(BOOL, ImageList_Remove, (HIMAGELIST himl,int i), (himl,i))
COMCTL_AFXFUNC(HICON, ImageList_GetIcon, (HIMAGELIST himl,int i,UINT flags), (himl,i,flags))
COMCTL_AFXFUNC(HIMAGELIST, ImageList_LoadImageA, (HINSTANCE hi,LPCSTR lpbmp,int cx,int cGrow,COLORREF crMask,UINT uType,UINT uFlags), (hi,lpbmp,cx,cGrow,crMask,uType,uFlags))
COMCTL_AFXFUNC(HIMAGELIST, ImageList_LoadImageW, (HINSTANCE hi,LPCWSTR lpbmp,int cx,int cGrow,COLORREF crMask,UINT uType,UINT uFlags), (hi,lpbmp,cx,cGrow,crMask,uType,uFlags))
COMCTL_AFXFUNC(BOOL, ImageList_Copy, (HIMAGELIST himlDst,int iDst,HIMAGELIST himlSrc,int iSrc,UINT uFlags), (himlDst,iDst,himlSrc,iSrc,uFlags))
COMCTL_AFXFUNC(BOOL, ImageList_BeginDrag, (HIMAGELIST himlTrack,int iTrack,int dxHotspot,int dyHotspot), (himlTrack,iTrack,dxHotspot,dyHotspot))
COMCTL_AFXPROC(ImageList_EndDrag, (), ())
COMCTL_AFXFUNC(BOOL, ImageList_DragEnter, (HWND hwndLock,int x,int y), (hwndLock,x,y))
COMCTL_AFXFUNC(BOOL, ImageList_DragLeave, (HWND hwndLock), (hwndLock))
COMCTL_AFXFUNC(BOOL, ImageList_DragMove, (int x,int y), (x,y))
COMCTL_AFXFUNC(BOOL, ImageList_SetDragCursorImage, (HIMAGELIST himlDrag,int iDrag,int dxHotspot,int dyHotspot), (himlDrag,iDrag,dxHotspot,dyHotspot))
COMCTL_AFXFUNC(BOOL, ImageList_DragShowNolock, (BOOL fShow), (fShow))
COMCTL_AFXFUNC(HIMAGELIST, ImageList_GetDragImage, (POINT*ppt,POINT*pptHotspot), (ppt,pptHotspot))
COMCTL_AFXFUNC(HIMAGELIST, ImageList_Read, (IStream *pstm), (pstm))
COMCTL_AFXFUNC(BOOL, ImageList_Write, (HIMAGELIST himl,IStream *pstm), (himl,pstm))

#if (_WIN32_WINNT >= 0x0501)
COMCTL_AFXFUNC(HRESULT, ImageList_ReadEx, (DWORD dwFlags,IStream *pstm,REFIID riid,PVOID*ppv), (dwFlags,pstm,riid,ppv))
COMCTL_AFXFUNC(HRESULT, ImageList_WriteEx, (HIMAGELIST himl,DWORD dwFlags,IStream *pstm), (himl,dwFlags,pstm))
#endif /* (_WIN32_WINNT >= 0x0501) */

COMCTL_AFXFUNC(BOOL, ImageList_GetIconSize, (HIMAGELIST himl,int*cx,int*cy), (himl,cx,cy))
COMCTL_AFXFUNC(BOOL, ImageList_SetIconSize, (HIMAGELIST himl,int cx,int cy), (himl,cx,cy))
COMCTL_AFXFUNC(BOOL, ImageList_GetImageInfo, (HIMAGELIST himl,int i,IMAGEINFO*pImageInfo), (himl,i,pImageInfo))
COMCTL_AFXFUNC(HIMAGELIST, ImageList_Merge, (HIMAGELIST himl1,int i1,HIMAGELIST himl2,int i2,int dx,int dy), (himl1,i1,himl2,i2,dx,dy))
COMCTL_AFXFUNC(HIMAGELIST, ImageList_Duplicate, (HIMAGELIST himl), (himl))
COMCTL_AFXFUNC(HWND, CreateToolbarEx, (HWND hwnd,DWORD ws,UINT wID,int nBitmaps,HINSTANCE hBMInst,UINT_PTR wBMID,LPCTBBUTTON lpButtons,int iNumButtons,int dxButton,int dyButton,int dxBitmap,int dyBitmap,UINT uStructSize), (hwnd,ws,wID,nBitmaps,hBMInst,wBMID,lpButtons,iNumButtons,dxButton,dyButton,dxBitmap,dyBitmap,uStructSize))
COMCTL_AFXFUNC(HBITMAP, CreateMappedBitmap, (HINSTANCE hInstance,INT_PTR idBitmap,UINT wFlags,LPCOLORMAP lpColorMap,int iNumMaps), (hInstance,idBitmap,wFlags,lpColorMap,iNumMaps))
COMCTL_AFXPROC(DrawStatusTextA, (HDC hDC,LPRECT lprc,LPCSTR pszText,UINT uFlags), (hDC,lprc,pszText,uFlags))
COMCTL_AFXPROC(DrawStatusTextW, (HDC hDC,LPRECT lprc,LPCWSTR pszText,UINT uFlags), (hDC,lprc,pszText,uFlags))
COMCTL_AFXFUNC(HWND, CreateStatusWindowA, (long style,LPCSTR lpszText,HWND hwndParent,UINT wID), (style,lpszText,hwndParent,wID))
COMCTL_AFXFUNC(HWND, CreateStatusWindowW, (long style,LPCWSTR lpszText,HWND hwndParent,UINT wID), (style,lpszText,hwndParent,wID))
COMCTL_AFXPROC(MenuHelp, (UINT uMsg,WPARAM wParam,LPARAM lParam,HMENU hMainMenu,HINSTANCE hInst,HWND hwndStatus,UINT*lpwIDs), (uMsg,wParam,lParam,hMainMenu,hInst,hwndStatus,lpwIDs))
COMCTL_AFXFUNC(BOOL, ShowHideMenuCtl, (HWND hWnd,UINT_PTR uFlags,LPINT lpInfo), (hWnd,uFlags,lpInfo))
COMCTL_AFXPROC(GetEffectiveClientRect, (HWND hWnd,LPRECT lprc,LPINT lpInfo), (hWnd,lprc,lpInfo))
COMCTL_AFXFUNC(BOOL, MakeDragList, (HWND hLB), (hLB))
COMCTL_AFXPROC(DrawInsert, (HWND handParent,HWND hLB,int nItem), (handParent,hLB,nItem))
COMCTL_AFXFUNC(int, LBItemFromPt, (HWND hLB,POINT pt,BOOL bAutoScroll), (hLB,pt,bAutoScroll))
COMCTL_AFXFUNC(HWND, CreateUpDownControl, (DWORD dwStyle,int x,int y,int cx,int cy,HWND hParent,int nID,HINSTANCE hInst,HWND hBuddy,int nUpper,int nLower,int nPos), (dwStyle,x,y,cx,cy,hParent,nID,hInst,hBuddy,nUpper,nLower,nPos))
COMCTL_AFXPROC(InitMUILanguage, (LANGID uiLang), (uiLang))
COMCTL_AFXFUNC(LANGID, GetMUILanguage, (), ())
COMCTL_AFXFUNC(HDSA, DSA_Create, (int cbItem,int cItemGrow), (cbItem,cItemGrow))
COMCTL_AFXFUNC(BOOL, DSA_Destroy, (HDSA hdsa), (hdsa))
COMCTL_AFXPROC(DSA_DestroyCallback, (HDSA hdsa,PFNDSAENUMCALLBACK pfnCB,void*pData), (hdsa,pfnCB,pData))
COMCTL_AFXFUNC(PVOID, DSA_GetItemPtr, (HDSA hdsa,int i), (hdsa,i))
COMCTL_AFXFUNC(int, DSA_InsertItem, (HDSA hdsa,int i,void*pitem), (hdsa,i,pitem))
COMCTL_AFXFUNC(HDPA, DPA_Create, (int cItemGrow), (cItemGrow))
COMCTL_AFXFUNC(BOOL, DPA_Destroy, (HDPA hdpa), (hdpa))
COMCTL_AFXFUNC(PVOID, DPA_DeletePtr, (HDPA hdpa,int i), (hdpa,i))
COMCTL_AFXFUNC(BOOL, DPA_DeleteAllPtrs, (HDPA hdpa), (hdpa))
COMCTL_AFXPROC(DPA_EnumCallback, (HDPA hdpa,PFNDPAENUMCALLBACK pfnCB,void*pData), (hdpa,pfnCB,pData))
COMCTL_AFXPROC(DPA_DestroyCallback, (HDPA hdpa,PFNDPAENUMCALLBACK pfnCB,void*pData), (hdpa,pfnCB,pData))
COMCTL_AFXFUNC(BOOL, DPA_SetPtr, (HDPA hdpa,int i,void*p), (hdpa,i,p))
COMCTL_AFXFUNC(int, DPA_InsertPtr, (HDPA hdpa,int i,void*p), (hdpa,i,p))
COMCTL_AFXFUNC(PVOID, DPA_GetPtr, (HDPA hdpa,INT_PTR i), (hdpa,i))
COMCTL_AFXFUNC(BOOL, DPA_Sort, (HDPA hdpa,PFNDPACOMPARE pfnCompare,LPARAM lParam), (hdpa,pfnCompare,lParam))
COMCTL_AFXFUNC(int, DPA_Search, (HDPA hdpa,void*pFind,int iStart,PFNDPACOMPARE pfnCompare,LPARAM lParam,UINT options), (hdpa,pFind,iStart,pfnCompare,lParam,options))
COMCTL_AFXFUNC(BOOL, Str_SetPtrW, (__deref_inout_opt LPWSTR*ppsz,LPCWSTR psz), (ppsz,psz))

#if !defined(NOTRACKMOUSEEVENT)
COMCTL_AFXFUNC(BOOL, _TrackMouseEvent, (LPTRACKMOUSEEVENT lpEventTrack), (lpEventTrack))
#endif /* !defined(NOTRACKMOUSEEVENT) */

COMCTL_AFXFUNC(BOOL, FlatSB_EnableScrollBar, (HWND unnamed1,int unnamed2,UINT unnamed3), (unnamed1,unnamed2,unnamed3))
COMCTL_AFXFUNC(BOOL, FlatSB_ShowScrollBar, (HWND unnamed1,int code,BOOL unnamed2), (unnamed1,code,unnamed2))
COMCTL_AFXFUNC(BOOL, FlatSB_GetScrollRange, (HWND unnamed1,int code,LPINT unnamed2,LPINT unnamed3), (unnamed1,code,unnamed2,unnamed3))
COMCTL_AFXFUNC(BOOL, FlatSB_GetScrollInfo, (HWND unnamed1,int code,LPSCROLLINFO unnamed2), (unnamed1,code,unnamed2))
COMCTL_AFXFUNC(int, FlatSB_GetScrollPos, (HWND unnamed1,int code), (unnamed1,code))
COMCTL_AFXFUNC(BOOL, FlatSB_GetScrollProp, (HWND unnamed1,int propIndex,LPINT unnamed2), (unnamed1,propIndex,unnamed2))

#ifdef _WIN64
COMCTL_AFXFUNC(BOOL, FlatSB_GetScrollPropPtr, (HWND unnamed1,int propIndex,PINT_PTR unnamed2), (unnamed1,propIndex,unnamed2))
#else
#define AfxFlatSB_GetScrollPropPtr  AfxFlatSB_GetScrollProp
#endif

COMCTL_AFXFUNC(int, FlatSB_SetScrollPos, (HWND unnamed1,int code,int pos,BOOL fRedraw), (unnamed1,code,pos,fRedraw))
COMCTL_AFXFUNC(int, FlatSB_SetScrollInfo, (HWND unnamed1,int code,LPSCROLLINFO unnamed2,BOOL fRedraw), (unnamed1,code,unnamed2,fRedraw))
COMCTL_AFXFUNC(int, FlatSB_SetScrollRange, (HWND unnamed1,int code,int min,int max,BOOL fRedraw), (unnamed1,code,min,max,fRedraw))
COMCTL_AFXFUNC(BOOL, FlatSB_SetScrollProp, (HWND unnamed1,UINT index,INT_PTR newValue,BOOL unnamed2), (unnamed1,index,newValue,unnamed2))
COMCTL_AFXFUNC(BOOL, InitializeFlatSB, (HWND unnamed1), (unnamed1))
COMCTL_AFXFUNC(HRESULT, UninitializeFlatSB, (HWND unnamed1), (unnamed1))

#if _WIN32_WINNT >= 0x501
COMCTL_AFXFUNC(BOOL, SetWindowSubclass, (HWND hWnd,SUBCLASSPROC pfnSubclass,UINT_PTR uIdSubclass,DWORD_PTR dwRefData), (hWnd,pfnSubclass,uIdSubclass,dwRefData))
COMCTL_AFXFUNC(BOOL, GetWindowSubclass, (HWND hWnd,SUBCLASSPROC pfnSubclass,UINT_PTR uIdSubclass,DWORD_PTR*pdwRefData), (hWnd,pfnSubclass,uIdSubclass,pdwRefData))
COMCTL_AFXFUNC(BOOL, RemoveWindowSubclass, (HWND hWnd,SUBCLASSPROC pfnSubclass,UINT_PTR uIdSubclass), (hWnd,pfnSubclass,uIdSubclass))
#endif /* _WIN32_WINNT >= 0x501 */

COMCTL_AFXFUNC(LRESULT, DefSubclassProc, (HWND hWnd,UINT uMsg,WPARAM wParam,LPARAM lParam), (hWnd,uMsg,wParam,lParam))
COMCTL_AFXFUNC(int, DrawShadowText, (HDC hdc,LPCWSTR pszText,UINT cch,RECT*prc,DWORD dwFlags,COLORREF crText,COLORREF crShadow,int ixOffset,int iyOffset), (hdc,pszText,cch,prc,dwFlags,crText,crShadow,ixOffset,iyOffset))

COMCTL_AFXFUNC(HPROPSHEETPAGE, CreatePropertySheetPageA, (LPCPROPSHEETPAGEA constPropSheetPagePointer), (constPropSheetPagePointer))
COMCTL_AFXFUNC(HPROPSHEETPAGE, CreatePropertySheetPageW, (LPCPROPSHEETPAGEW constPropSheetPagePointer), (constPropSheetPagePointer))
COMCTL_AFXFUNC(BOOL, DestroyPropertySheetPage, (HPROPSHEETPAGE unnamed1), (unnamed1))
COMCTL_AFXFUNC(INT_PTR, PropertySheetA, (LPCPROPSHEETHEADERA unnamed1), (unnamed1))
COMCTL_AFXFUNC(INT_PTR, PropertySheetW, (LPCPROPSHEETHEADERW unnamed1), (unnamed1))

/////////////////////////////////////////////////////////////////////////////

#pragma pop_macro("COMCTL_AFXFUNC")
#pragma pop_macro("COMCTL_AFXPROC")

//////////////////// Commdlg.h /////////////////////////////////////////////////////////
#pragma push_macro("COMMDLG_AFXCTXFUNC")
#define COMMDLG_AFXCTXFUNC(type, name, params, args) \
	inline type WINAPI AfxCtx##name##params \
	{ \
		return afxCommDlgWrapper->_##name##args; \
	}

COMMDLG_AFXCTXFUNC(BOOL,GetOpenFileNameA,(LPOPENFILENAMEA unnamed1),(unnamed1))
COMMDLG_AFXCTXFUNC(BOOL,GetOpenFileNameW,(LPOPENFILENAMEW unnamed1),(unnamed1))
COMMDLG_AFXCTXFUNC(BOOL,GetSaveFileNameA,(LPOPENFILENAMEA unnamed1),(unnamed1))
COMMDLG_AFXCTXFUNC(BOOL,GetSaveFileNameW,(LPOPENFILENAMEW unnamed1),(unnamed1))
COMMDLG_AFXCTXFUNC(short,GetFileTitleA,(LPCSTR unnamed1,LPSTR unnamed2,WORD unnamed3),(unnamed1,unnamed2,unnamed3))
COMMDLG_AFXCTXFUNC(short ,GetFileTitleW,(LPCWSTR unnamed1,LPWSTR unnamed2,WORD unnamed3),(unnamed1,unnamed2,unnamed3))
COMMDLG_AFXCTXFUNC(BOOL ,ChooseColorA,(LPCHOOSECOLORA unnamed1),(unnamed1))
COMMDLG_AFXCTXFUNC(BOOL ,ChooseColorW,(LPCHOOSECOLORW unnamed1),(unnamed1))
COMMDLG_AFXCTXFUNC(HWND ,FindTextA,(LPFINDREPLACEA unnamed1),(unnamed1))
COMMDLG_AFXCTXFUNC(HWND ,FindTextW,(LPFINDREPLACEW unnamed1),(unnamed1))
COMMDLG_AFXCTXFUNC(HWND ,ReplaceTextA,(LPFINDREPLACEA unnamed1),(unnamed1))
COMMDLG_AFXCTXFUNC(HWND ,ReplaceTextW,(LPFINDREPLACEW unnamed1),(unnamed1))
COMMDLG_AFXCTXFUNC(BOOL ,ChooseFontA,(LPCHOOSEFONTA unnamed1),(unnamed1))
COMMDLG_AFXCTXFUNC(BOOL ,ChooseFontW,(LPCHOOSEFONTW unnamed1),(unnamed1))
COMMDLG_AFXCTXFUNC(BOOL ,PrintDlgA,(LPPRINTDLGA unnamed1),(unnamed1))
COMMDLG_AFXCTXFUNC(BOOL ,PrintDlgW,(LPPRINTDLGW unnamed1),(unnamed1))
#if defined(STDMETHOD) && (WINVER >= 0x0500)
COMMDLG_AFXCTXFUNC(HRESULT ,PrintDlgExA,(LPPRINTDLGEXA unnamed1),(unnamed1))
COMMDLG_AFXCTXFUNC(HRESULT ,PrintDlgExW,(LPPRINTDLGEXW unnamed1),(unnamed1))
#endif /* defined(STDMETHOD) && (WINVER >= 0x0500) */
COMMDLG_AFXCTXFUNC(DWORD ,CommDlgExtendedError,(void),())
COMMDLG_AFXCTXFUNC(BOOL ,PageSetupDlgA,(LPPAGESETUPDLGA unnamed1),(unnamed1))
COMMDLG_AFXCTXFUNC(BOOL ,PageSetupDlgW,(LPPAGESETUPDLGW unnamed1),(unnamed1))

/////////////////////////////////////////////////////////////////////////////

#pragma pop_macro("COMMDLG_AFXCTXFUNC")

//////////////////////// ShellApi.h /////////////////////////////////////////
#pragma push_macro("SHELL_AFXCTXFUNC")

#define SHELL_AFXCTXFUNC(type, name, params, args) \
	inline type WINAPI AfxCtx##name##params \
	{ \
		return afxShellWrapper->_##name##args; \
	}

SHELL_AFXCTXFUNC(BOOL ,InitNetworkAddressControl,(void),())

/////////////////////////////////////////////////////////////////////////////

#pragma pop_macro("SHELL_AFXCTXFUNC")

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxcommandmanager.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxtoolbarimages.h"
#include "afxtoolbarbutton.h"
#include "afxcmdusagecount.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CCommandManager;

CCommandManager* GetCmdMgr();
#define afxCommandManager GetCmdMgr()

class CCommandManager
{
friend class _STATIC_CREATOR_;
protected:
	CCommandManager();

public:
	virtual ~CCommandManager();

	void CleanUp(); // Final cleaning

	// Image functions
	void SetCmdImage(UINT uiCmd, int iImage, BOOL bUserImage);
	int  GetCmdImage(UINT uiCmd, BOOL bUserImage = FALSE) const;
	void ClearCmdImage(UINT uiCmd);
	void ClearUserCmdImages();
	void ClearAllCmdImages();

	void EnableMenuItemImage(UINT uiCmd, BOOL bEnable = TRUE, int nUserImage = -1);
	
	BOOL IsMenuItemWithoutImage(UINT uiCmd) const { return m_lstCommandsWithoutImages.Find(uiCmd) != NULL; }
	int GetMenuUserImage(UINT uiMenuCmd) const
	{
		int iImage = -1;
		m_mapMenuUserImages.Lookup(uiMenuCmd, iImage);

		return iImage;
	}

	BOOL LoadState(LPCTSTR lpszProfileName);
	BOOL SaveState(LPCTSTR lpszProfileName);

protected:
	CMap<UINT, UINT, int, int> m_CommandIndex;
	CMap<UINT, UINT, int, int> m_CommandIndexUser;
	CMap<UINT, UINT, int, int> m_DefaultImages;

	// List of menu items where image appearance is disabled:
	CList<UINT,UINT>           m_lstCommandsWithoutImages;

	// List of menu items with user images:
	CMap<UINT,UINT,int,int>    m_mapMenuUserImages;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxcom_.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// AFXCOM_.H
//
// THIS FILE IS FOR MFC IMPLEMENTATION ONLY.

#ifndef __AFXCOM_H__
#define __AFXCOM_H__

#ifndef _OBJBASE_H_
#include <objbase.h>
#endif

#pragma once

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 

/////////////////////////////////////////////////////////////////////////////

#ifndef _AFX_NOFORCE_LIBS
#pragma comment(lib, "uuid.lib")
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#include <malloc.h>
#ifndef ASSERT
#ifndef _INC_CRTDBG
#include <crtdbg.h>
#endif // _INC_CRTDBG
#define ASSERT(x) _ASSERT(x)
#endif // ASSERT

/////////////////////////////////////////////////////////////////////////////

template<class _Interface, const IID* _IID>
class _CIP
{
public:
	// Declare interface type so that the type may be available outside
	// the scope of this template.
	typedef _Interface Interface;

	// To avoid conversion difficulties this function should be used
	// to obtain the CLSID.
	static const IID& GetIID()
		{ ASSERT(_IID != NULL); return *_IID; }

	// Construct empty in preperation for assignment.
	_CIP();

	// Copy the pointer and AddRef().
	_CIP(const _CIP& cp) : _pInterface(cp._pInterface)
		{ _AddRef(); }

	// Saves and AddRef()'s the interface
	_CIP(Interface* pInterface) : _pInterface(pInterface)
		{ _AddRef(); }

	// Copies the pointer.  If bAddRef is TRUE, the interface will
	// be AddRef()ed.
	_CIP(Interface* pInterface, BOOL bAddRef)
		: _pInterface(pInterface)
	{
		if (bAddRef)
		{
			ASSERT(pInterface != NULL);
			_AddRef();
		}
	}

	// Calls CoCreateClass with the provided CLSID.
	_CIP(const CLSID& clsidObject, DWORD dwClsContext = CLSCTX_INPROC_SERVER)
		: _pInterface(NULL)
	{
		CreateObject(clsidObject, dwClsContext);
	}

	// Calls CoCreateClass with the provided CLSID retrieved from
	// the string.
	_CIP(LPOLESTR str, DWORD dwClsContext = CLSCTX_INPROC_SERVER)
		: _pInterface(NULL)
	{
		CreateObject(str, dwClsContext);
	}

	// Saves and AddRef()s the interface.
	_CIP& operator=(Interface* pInterface)
	{
		if (_pInterface != pInterface)
		{
			Interface* pOldInterface = _pInterface;
			_pInterface = pInterface;
			_AddRef();
			if (pOldInterface != NULL)
				pOldInterface->Release();
		}
		return *this;
	}

	// Copies and AddRef()'s the interface.
	_CIP& operator=(const _CIP& cp)
		{ return operator=(cp._pInterface); }

	// Releases any current interface and loads the class with the
	// provided CLSID.
	_CIP& operator=(const CLSID& clsidOther)
	{
		CreateObject(clsidOther);
		return *this;
	}

	// Calls CoCreateClass with the provided CLSID retrieved from
	// the string.
	_CIP& operator=(LPOLESTR str)
	{
		CreateObject(str);
		return *this;
	}

	~_CIP();

	// Saves/sets the interface without AddRef()ing.  This call
	// will release any previously aquired interface.
	void Attach(Interface* pInterface)
	{
		_Release();
		_pInterface = pInterface;
	}

	// Saves/sets the interface only AddRef()ing if bAddRef is TRUE.
	// This call will release any previously aquired interface.
	void Attach(Interface* pInterface, BOOL bAddRef)
	{
		_Release();
		_pInterface = pInterface;
		if (bAddRef)
		{
			ASSERT(pInterface != NULL);
			_AddRef();
		}
	}

	// Simply NULL the interface pointer so that it isn't Released()'ed.
	void Detach()
	{
		ASSERT(_pInterface);
		_pInterface = NULL;
	}

	// Return the interface.  This value may be NULL
	operator Interface*() const
		{ return _pInterface; }

	// Queries for the unknown and return it
	operator IUnknown*()
		{ return _pInterface; }

	// Provides minimal level assertion before use.
	operator Interface&() const
		{ ASSERT(_pInterface); return *_pInterface; }

	// Allows an instance of this class to act as though it were the
	// actual interface.  Also provides minimal assertion verification.
	Interface& operator*() const
		{ ASSERT(_pInterface); return *_pInterface; }

	// Returns the address of the interface pointer contained in this
	// class.  This is useful when using the COM/OLE interfaces to create
	// this interface.
	Interface** operator&()
	{
		_Release();
		_pInterface = NULL;
		return &_pInterface;
	}

	// Allows this class to be used as the interface itself.
	// Also provides simple assertion verification.
	Interface* operator->() const
	{
		ASSERT(_pInterface != NULL);
		if (_pInterface == NULL)
		{
			AfxThrowInvalidArgException();
		}
		return _pInterface;
	}

	// This operator is provided so that simple boolean expressions will
	// work.  For example: "if (p) ...".
	// Returns TRUE if the pointer is not NULL.
	operator BOOL() const
		{ return _pInterface != NULL; }

	// Provides assertion verified, Release()ing of this interface.
	void Release()
	{
		ASSERT(_pInterface != NULL);
		_Release();
		_pInterface = NULL;
	}

	// Provides assertion verified AddRef()ing of this interface.
	void AddRef()
		{ ASSERT(_pInterface != NULL); _AddRef(); }

	// Another way to get the interface pointer without casting.
	Interface* GetInterfacePtr() const
		{ return _pInterface; }

	// Loads an interface for the provided CLSID.
	// Returns an HRESULT.  Any previous interface is released.
	HRESULT CreateObject(
		const CLSID& clsidObject, DWORD dwClsContext = CLSCTX_INPROC_SERVER)
	{
		_Release();
		HRESULT hr = CoCreateInstance(clsidObject, NULL, dwClsContext,
			GetIID(), reinterpret_cast<void**>(&_pInterface));
		ASSERT(SUCCEEDED(hr));
		return hr;
	}

	// Creates the class specified by clsidString.  clsidString may
	// contain a class id, or a prog id string.
	HRESULT CreateObject(
		LPOLESTR clsidString, DWORD dwClsContext=CLSCTX_INPROC_SERVER)
	{
		ASSERT(clsidString != NULL);
		if (clsidString == NULL)
			return E_INVALIDARG;
		CLSID clsidObject;
		HRESULT hr;
		if (clsidString[0] == '{')
			hr = CLSIDFromString(clsidString, &clsidObject);
		else
			hr = CLSIDFromProgID(clsidString, &clsidObject);
		ASSERT(SUCCEEDED(hr));
		if (FAILED(hr))
			return hr;
		return CreateObject(clsidObject, dwClsContext);
	}

	// Performs a QI on pUnknown for the interface type returned
	// for this class.  The interface is stored.  If pUnknown is
	// NULL, or the QI fails, E_NOINTERFACE is returned and
	// _pInterface is set to NULL.
	HRESULT QueryInterface(IUnknown* pUnknown)
	{
		if (pUnknown == NULL) // Can't QI NULL
		{
			operator=(static_cast<Interface*>(NULL));
			return E_NOINTERFACE;
		}

		// Query for this interface
		Interface* pInterface;
		HRESULT hr = pUnknown->QueryInterface(GetIID(),
			reinterpret_cast<void**>(&pInterface));
		if (FAILED(hr))
		{
			// If failed intialize interface to NULL and return HRESULT.
			Attach(NULL);
			return hr;
		}

		// Save the interface without AddRef()ing.
		Attach(pInterface);
		return hr;
	}

private:
	// Releases only if the interface is not null.
	// The interface is not set to NULL.
	void _Release()
	{
		if (_pInterface != NULL)
			_pInterface->Release();
	}

	// AddRefs only if the interface is not NULL
	void _AddRef()
	{
		if (_pInterface != NULL)
			_pInterface->AddRef();
	}

	// The Interface.
	Interface* _pInterface;
}; // class _CIP

template<class _Interface, const IID* _IID>
_CIP<_Interface, _IID>::_CIP()
	: _pInterface(NULL)
{
}

template<class _Interface, const IID* _IID>
_CIP<_Interface, _IID>::~_CIP()
{
	// If we still have an interface then Release() it.  The interface
	// may be NULL if Detach() has previosly been called, or if it was
	// never set.

	_Release();
}

template<class _Interface, const IID* _IID>
class CIP : public _CIP<_Interface, _IID>
{
public:
	// Simplified name for base class and provide derived classes
	// access to base type
	typedef _CIP<_Interface, _IID> BC;

	// Provideds derived classes access to the interface type.
	typedef _Interface Interface;

	// Construct empty in preperation for assignment.
	CIP() { }
	~CIP();

	// Copy the pointer and AddRef().
	CIP(const CIP& cp) : _CIP<_Interface, _IID>(cp) { }

	// Saves and AddRef()s the interface.
	CIP(Interface* pInterface) : _CIP<_Interface, _IID>(pInterface) { }

	// Saves the interface and AddRef()s only if bAddRef is TRUE.
	CIP(Interface* pInterface, BOOL bAddRef)
		: _CIP<_Interface, _IID>(pInterface, bAddRef) { }

	// Queries for this interface.
	CIP(IUnknown* pUnknown)
	{
		if (pUnknown == NULL)
			return;
		Interface* pInterface;
		HRESULT hr = pUnknown->QueryInterface(GetIID(),
			reinterpret_cast<void**>(&pInterface));
		ASSERT(SUCCEEDED(hr));
		Attach(pInterface);
	}

	// Creates the interface from the CLSID.
	CIP(const CLSID& clsid) : _CIP<_Interface, _IID>(clsid) { }

	// Creates the interface from the CLSID.
	CIP(LPOLESTR str) : _CIP<_Interface, _IID>(str) { }

	// Copies and AddRef()'s the interface.
	CIP& operator=(const CIP& cp)
		{ _CIP<_Interface, _IID>::operator=(cp); return *this; }

	// Saves and AddRef()s the interface.
	CIP& operator=(Interface* pInterface)
		{ _CIP<_Interface, _IID>::operator=(pInterface); return *this; }

	CIP& operator=(IUnknown* pUnknown)
	{
		HRESULT hr = QueryInterface(pUnknown);
		ASSERT(SUCCEEDED(hr));
		return *this;
	}

	// Releases any current interface and loads the class with the
	// provided CLSID.
	CIP& operator=(const CLSID& clsid)
		{ _CIP<_Interface, _IID>::operator=(clsid); return *this; }

	// Releases any current interface and loads the class with the
	// provided CLSID.
	CIP& operator=(LPOLESTR str)
		{ _CIP<_Interface, _IID>::operator=(str); return *this; }
}; // class CIP

template<class _Interface, const IID* _IID>
CIP<_Interface, _IID>::~CIP()
{
}

template<>
class CIP<IUnknown, &IID_IUnknown> : public _CIP<IUnknown, &IID_IUnknown>
{
public:
	// Simplified name for base class and provide derived classes
	// access to base type
	typedef _CIP<IUnknown, &IID_IUnknown> BC;

	// Provideds derived classes access to the interface type.
	typedef IUnknown Interface;

	// Construct empty in preperation for assignment.
	CIP() { }

	// Copy the pointer and AddRef().
	CIP(const CIP& cp) : _CIP<IUnknown, &IID_IUnknown>(cp) { }

	// Saves and AddRef()s the interface.
	CIP(Interface* pInterface)
		: _CIP<IUnknown, &IID_IUnknown>(pInterface) { }

	// Saves and then AddRef()s only if bAddRef is TRUE.
	CIP(Interface* pInterface, BOOL bAddRef)
		: _CIP<IUnknown, &IID_IUnknown>(pInterface, bAddRef) { }

	// Creates the interface from the CLSID.
	CIP(const CLSID& clsid) : _CIP<IUnknown, &IID_IUnknown>(clsid) { }

	// Creates the interface from the CLSID.
	CIP(LPOLESTR str) : _CIP<IUnknown, &IID_IUnknown>(str) { }

	// Copies and AddRef()'s the interface.
	CIP& operator=(const CIP& cp)
		{ _CIP<IUnknown, &IID_IUnknown>::operator=(cp); return *this; }

	// Saves and AddRef()s the interface.  The previously saved
	// interface is released.
	CIP& operator=(Interface* pInterface)
		{ _CIP<IUnknown, &IID_IUnknown>::operator=(pInterface); return *this; }

	// Releases any current interface and loads the class with the
	// provided CLSID.
	CIP& operator=(const CLSID& clsid)
		{ _CIP<IUnknown, &IID_IUnknown>::operator=(clsid); return *this; }

	// Releases any current interface and loads the class with the
	// provided CLSID.
	CIP& operator=(LPOLESTR str)
		{ _CIP<IUnknown, &IID_IUnknown>::operator=(str); return *this; }

	// Queries for the unknown and return it
	operator IUnknown*()
		{ return GetInterfacePtr(); }

	// Verifies that pUnknown is not null and performs assignment.
	HRESULT QueryInterface(IUnknown* pUnknown)
	{
		_CIP<IUnknown, &IID_IUnknown>::operator=(pUnknown);
		return pUnknown != NULL ? S_OK : E_NOINTERFACE;
	}
};  // CIP<IUnknown, &IID_IUnknown>

#define IPTR(x) CIP<x, &IID_##x>
#define DEFINE_IPTR(x) typedef IPTR(x) x##Ptr;

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif // __AFXCOM_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxcomctl32.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// Fusion: Dlls that have WinSxS assemblies and several versions can be loaded
// into the same process, and called by mfc, need special wrappers to allow the
// same mfc dll to call the correct version, stored in the module state of the
// user exe/dll.

#ifndef __AFXCOMCTL32_H__
#define __AFXCOMCTL32_H__

#pragma once

#if _WIN32_WINNT < 0x0500
#error This file requires _WIN32_WINNT to be #defined at least to 0x0500. Value 0x0501 or higher is recommended.
#endif


#pragma warning(disable: 4127)  // conditional expression constant

/////////////////////////////////////////////////////////////////////////////
// (WinSxS/Manifest) API.



enum eActCtxResult { ActCtxFailed, ActCtxSucceeded, ActCtxNoFusion };

BOOL AFXAPI AfxGetAmbientActCtx();
void AFXAPI AfxSetAmbientActCtx(BOOL bSet);
/////////////////////////////////////////////////////////////////////////////

#pragma push_macro("AFX_ISOLATIONAWARE_COMMON_ACTIVATE")
#pragma push_macro("AFX_ISOLATIONAWARE_FUNC_ACTIVATE")
#pragma push_macro("AFX_ISOLATIONAWARE_FUNC_DEACTIVATE")
#pragma push_macro("AFX_ISOLATIONAWARE_FUNC")
#pragma push_macro("AFX_ISOLATIONAWARE_STATICLINK_FUNC")
#pragma push_macro("AFX_ISOLATIONAWARE_STATICLINK_PROC")
#pragma push_macro("AFX_ISOLATIONAWARE_PROC")

#define AFX_ISOLATIONAWARE_COMMON_ACTIVATE() \
		ULONG_PTR ulActCtxCookie = 0;\
		BOOL fActCtxSucceeded = ActivateActCtx(AfxGetModuleState()->m_hActCtx, &ulActCtxCookie);\

#define AFX_ISOLATIONAWARE_FUNC_ACTIVATE(type, failure_retval) \
		AFX_ISOLATIONAWARE_COMMON_ACTIVATE() \
		type result=(failure_retval);\
		if (!fActCtxSucceeded)\
		{\
			return result;\
		}\
		__try {

#define AFX_ISOLATIONAWARE_FUNC_DEACTIVATE(failure_retval) \
}\
		__finally\
		{\
			const BOOL fPreserveLastError = (result == (failure_retval) );\
			const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;\
			DeactivateActCtx(0,ulActCtxCookie);\
			if (fPreserveLastError)\
			{\
				SetLastError(dwLastError);\
			}\
		}\
		return result;

#define AFX_ISOLATIONAWARE_STATICLINK_FUNC(type, name, params, args, failure_retval) \
	inline type AfxCtx##name##params \
	{ \
		AFX_ISOLATIONAWARE_FUNC_ACTIVATE(type, failure_retval)\
		result=name##args; \
		AFX_ISOLATIONAWARE_FUNC_DEACTIVATE(failure_retval)\
	}

#define AFX_ISOLATIONAWARE_PROC_ACTIVATE() \
		AFX_ISOLATIONAWARE_COMMON_ACTIVATE() \
		if (!fActCtxSucceeded)\
		{\
			return;\
		}\
		__try {

#define AFX_ISOLATIONAWARE_PROC_DEACTIVATE() \
}\
		__finally\
		{\
			DeactivateActCtx(0, ulActCtxCookie);\
		}		

#define AFX_ISOLATIONAWARE_STATICLINK_PROC(name, params, args) \
	inline void AfxCtx##name##params \
	{ \
		AFX_ISOLATIONAWARE_PROC_ACTIVATE() \
		name##args; \
		AFX_ISOLATIONAWARE_PROC_DEACTIVATE() \
	}
	

#define AFX_PROC_PTR_TYPE(type, name_with_postfix, params) \
	struct name_with_postfix \
	{ \
		typedef type (WINAPI *Ptr)##params; \
		Ptr p; \
		name_with_postfix() : p(NULL) {} \
		void operator=(Ptr q) { p = q; } \
		Ptr operator->() { return p; } \
		operator Ptr() { return p; } \
		bool operator!() const { return !p; } \
	}

#define AFX_ISOLATIONAWARE_FUNC(type, name, params, args, failure_retval) \
	AFX_PROC_PTR_TYPE(type, name##_Type, params) m__##name; \
	\
	name##_Type GetProcAddress_##name() \
	{ \
		if (!m__##name) \
		{ \
			m__##name = (name##_Type::Ptr) ::GetProcAddress(GetModuleHandle(), #name); \
		} \
		return m__##name; \
	} \
	\
	type _##name##params \
	{ \
			AFX_ISOLATIONAWARE_FUNC_ACTIVATE(type, failure_retval)\
			GetProcAddress_##name(); \
			ENSURE(m__##name != NULL); \
			result=m__##name##args; \
			AFX_ISOLATIONAWARE_FUNC_DEACTIVATE(failure_retval)\
	}

#define AFX_ISOLATIONAWARE_PROC(name, params, args) \
	AFX_PROC_PTR_TYPE(void, name##_Type, params) m__##name; \
	\
	name##_Type GetProcAddress_##name() \
	{ \
		if (!m__##name) \
		{ \
			m__##name = (name##_Type::Ptr) ::GetProcAddress(GetModuleHandle(), #name); \
		} \
		return m__##name; \
	} \
	\
	void _##name##params \
	{ \
			AFX_ISOLATIONAWARE_PROC_ACTIVATE() \
			GetProcAddress_##name(); \
			ENSURE(m__##name != NULL); \
			m__##name##args; \
			AFX_ISOLATIONAWARE_PROC_DEACTIVATE() \
	}


#define AFX_COMCTL32_IF_EXISTS(proc) (afxComCtlWrapper->GetProcAddress_##proc() != NULL)

#if defined(_UNICODE)
#define AFX_COMCTL32_IF_EXISTS2(proc) (afxComCtlWrapper->GetProcAddress_##proc##W() != NULL)
#else
#define AFX_COMCTL32_IF_EXISTS2(proc) (afxComCtlWrapper->GetProcAddress_##proc##A() != NULL)
#endif

/////////////////////////////////////////////////////////////////////////////
// Base class for all dll wrappers
//
class CDllIsolationWrapperBase : public CNoTrackObject
{
public:
	HMODULE m_hModule;
	bool m_bFreeLib;
protected:
	CString m_strModuleName;
public:
	HMODULE GetModuleHandle()
	{
		if (m_hModule == NULL)
		{
			m_hModule = ::GetModuleHandle(m_strModuleName.GetString());
			if (m_hModule == NULL)
			{
				m_hModule = ::LoadLibrary(m_strModuleName.GetString());
				m_bFreeLib = m_hModule != NULL;
			}
		}
		return m_hModule;
	}

public:
	CDllIsolationWrapperBase()
	{
		CommonConstruct();
	}
	CDllIsolationWrapperBase(const CString& strModuleName) 
	: m_strModuleName(strModuleName)
	{
		CommonConstruct();
	}

	void CommonConstruct()
	{
		m_hModule  = NULL;
		m_bFreeLib = false;
	}
	virtual ~CDllIsolationWrapperBase()
	{ 
		m_bFreeLib && ::FreeLibrary(m_hModule);
	}

};

class CComCtlWrapper : public CDllIsolationWrapperBase
{
public:
	CComCtlWrapper() 
	: CDllIsolationWrapperBase(_T("comctl32.dll"))
	{
	}

public:
	AFX_ISOLATIONAWARE_PROC(InitCommonControls, (), ())
	AFX_ISOLATIONAWARE_FUNC(BOOL, InitCommonControlsEx, (LPINITCOMMONCONTROLSEX unnamed1), (unnamed1), FALSE)
	AFX_ISOLATIONAWARE_FUNC(HIMAGELIST, ImageList_Create, (int cx,int cy,UINT flags,int cInitial,int cGrow), (cx,cy,flags,cInitial,cGrow), NULL)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_Destroy, (HIMAGELIST himl), (himl), FALSE)
	AFX_ISOLATIONAWARE_FUNC(int, ImageList_GetImageCount, (HIMAGELIST himl), (himl), 0)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_SetImageCount, (HIMAGELIST himl,UINT uNewCount), (himl,uNewCount), FALSE)
	AFX_ISOLATIONAWARE_FUNC(int, ImageList_Add, (HIMAGELIST himl,HBITMAP hbmImage,HBITMAP hbmMask), (himl,hbmImage,hbmMask), -1)
	AFX_ISOLATIONAWARE_FUNC(int, ImageList_ReplaceIcon, (HIMAGELIST himl,int i,HICON hicon), (himl,i,hicon),-1)
	AFX_ISOLATIONAWARE_FUNC(COLORREF, ImageList_SetBkColor, (HIMAGELIST himl,COLORREF clrBk), (himl,clrBk),RGB(0,0,0))
	AFX_ISOLATIONAWARE_FUNC(COLORREF, ImageList_GetBkColor, (HIMAGELIST himl), (himl),RGB(0,0,0))
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_SetOverlayImage, (HIMAGELIST himl,int iImage,int iOverlay), (himl,iImage,iOverlay),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_Draw, (HIMAGELIST himl,int i,HDC hdcDst,int x,int y,UINT fStyle), (himl,i,hdcDst,x,y,fStyle),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_Replace, (HIMAGELIST himl,int i,HBITMAP hbmImage,HBITMAP hbmMask), (himl,i,hbmImage,hbmMask),FALSE)
	AFX_ISOLATIONAWARE_FUNC(int, ImageList_AddMasked, (HIMAGELIST himl,HBITMAP hbmImage,COLORREF crMask), (himl,hbmImage,crMask),-1)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_DrawEx, (HIMAGELIST himl,int i,HDC hdcDst,int x,int y,int dx,int dy,COLORREF rgbBk,COLORREF rgbFg,UINT fStyle), (himl,i,hdcDst,x,y,dx,dy,rgbBk,rgbFg,fStyle),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_DrawIndirect, (IMAGELISTDRAWPARAMS*pimldp), (pimldp),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_Remove, (HIMAGELIST himl,int i), (himl,i),FALSE)
	AFX_ISOLATIONAWARE_FUNC(HICON, ImageList_GetIcon, (HIMAGELIST himl,int i,UINT flags), (himl,i,flags),NULL)
	AFX_ISOLATIONAWARE_FUNC(HIMAGELIST, ImageList_LoadImageA, (HINSTANCE hi,LPCSTR lpbmp,int cx,int cGrow,COLORREF crMask,UINT uType,UINT uFlags), (hi,lpbmp,cx,cGrow,crMask,uType,uFlags),NULL)
	AFX_ISOLATIONAWARE_FUNC(HIMAGELIST, ImageList_LoadImageW, (HINSTANCE hi,LPCWSTR lpbmp,int cx,int cGrow,COLORREF crMask,UINT uType,UINT uFlags), (hi,lpbmp,cx,cGrow,crMask,uType,uFlags),NULL)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_Copy, (HIMAGELIST himlDst,int iDst,HIMAGELIST himlSrc,int iSrc,UINT uFlags), (himlDst,iDst,himlSrc,iSrc,uFlags),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_BeginDrag, (HIMAGELIST himlTrack,int iTrack,int dxHotspot,int dyHotspot), (himlTrack,iTrack,dxHotspot,dyHotspot),FALSE)
	AFX_ISOLATIONAWARE_PROC(ImageList_EndDrag, (), ())
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_DragEnter, (HWND hwndLock,int x,int y), (hwndLock,x,y),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_DragLeave, (HWND hwndLock), (hwndLock),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_DragMove, (int x,int y), (x,y),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_SetDragCursorImage, (HIMAGELIST himlDrag,int iDrag,int dxHotspot,int dyHotspot), (himlDrag,iDrag,dxHotspot,dyHotspot),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_DragShowNolock, (BOOL fShow), (fShow),FALSE)
	AFX_ISOLATIONAWARE_FUNC(HIMAGELIST, ImageList_GetDragImage, (POINT*ppt,POINT*pptHotspot), (ppt,pptHotspot),NULL)
	AFX_ISOLATIONAWARE_FUNC(HIMAGELIST, ImageList_Read, (IStream *pstm), (pstm),NULL)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_Write, (HIMAGELIST himl,IStream *pstm), (himl,pstm),FALSE)
	
	AFX_ISOLATIONAWARE_FUNC(HRESULT, ImageList_ReadEx, (DWORD dwFlags,IStream *pstm,REFIID riid,PVOID*ppv), (dwFlags,pstm,riid,ppv),S_OK)
	AFX_ISOLATIONAWARE_FUNC(HRESULT, ImageList_WriteEx, (HIMAGELIST himl,DWORD dwFlags,IStream *pstm), (himl,dwFlags,pstm),S_OK)
	
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_GetIconSize, (HIMAGELIST himl,int*cx,int*cy), (himl,cx,cy),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_SetIconSize, (HIMAGELIST himl,int cx,int cy), (himl,cx,cy),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, ImageList_GetImageInfo, (HIMAGELIST himl,int i,IMAGEINFO*pImageInfo), (himl,i,pImageInfo),FALSE)
	AFX_ISOLATIONAWARE_FUNC(HIMAGELIST, ImageList_Merge, (HIMAGELIST himl1,int i1,HIMAGELIST himl2,int i2,int dx,int dy), (himl1,i1,himl2,i2,dx,dy),NULL)
	AFX_ISOLATIONAWARE_FUNC(HIMAGELIST, ImageList_Duplicate, (HIMAGELIST himl), (himl),NULL)
	AFX_ISOLATIONAWARE_FUNC(HWND, CreateToolbarEx, (HWND hwnd,DWORD ws,UINT wID,int nBitmaps,HINSTANCE hBMInst,UINT_PTR wBMID,LPCTBBUTTON lpButtons,int iNumButtons,int dxButton,int dyButton,int dxBitmap,int dyBitmap,UINT uStructSize), (hwnd,ws,wID,nBitmaps,hBMInst,wBMID,lpButtons,iNumButtons,dxButton,dyButton,dxBitmap,dyBitmap,uStructSize),NULL)
	AFX_ISOLATIONAWARE_FUNC(HBITMAP, CreateMappedBitmap, (HINSTANCE hInstance,INT_PTR idBitmap,UINT wFlags,LPCOLORMAP lpColorMap,int iNumMaps), (hInstance,idBitmap,wFlags,lpColorMap,iNumMaps),NULL)
	AFX_ISOLATIONAWARE_PROC(DrawStatusTextA, (HDC hDC,LPRECT lprc,LPCSTR pszText,UINT uFlags), (hDC,lprc,pszText,uFlags))
	AFX_ISOLATIONAWARE_PROC(DrawStatusTextW, (HDC hDC,LPRECT lprc,LPCWSTR pszText,UINT uFlags), (hDC,lprc,pszText,uFlags))
	AFX_ISOLATIONAWARE_FUNC(HWND, CreateStatusWindowA, (long style,LPCSTR lpszText,HWND hwndParent,UINT wID), (style,lpszText,hwndParent,wID),NULL)
	AFX_ISOLATIONAWARE_FUNC(HWND, CreateStatusWindowW, (long style,LPCWSTR lpszText,HWND hwndParent,UINT wID), (style,lpszText,hwndParent,wID),NULL)
	AFX_ISOLATIONAWARE_PROC(MenuHelp, (UINT uMsg,WPARAM wParam,LPARAM lParam,HMENU hMainMenu,HINSTANCE hInst,HWND hwndStatus,UINT*lpwIDs), (uMsg,wParam,lParam,hMainMenu,hInst,hwndStatus,lpwIDs))
	AFX_ISOLATIONAWARE_FUNC(BOOL, ShowHideMenuCtl, (HWND hWnd,UINT_PTR uFlags,LPINT lpInfo), (hWnd,uFlags,lpInfo),FALSE)
	AFX_ISOLATIONAWARE_PROC(GetEffectiveClientRect, (HWND hWnd,LPRECT lprc,LPINT lpInfo), (hWnd,lprc,lpInfo))
	AFX_ISOLATIONAWARE_FUNC(BOOL, MakeDragList, (HWND hLB), (hLB),FALSE)
	AFX_ISOLATIONAWARE_PROC(DrawInsert, (HWND handParent,HWND hLB,int nItem), (handParent,hLB,nItem))
	AFX_ISOLATIONAWARE_FUNC(int, LBItemFromPt, (HWND hLB,POINT pt,BOOL bAutoScroll), (hLB,pt,bAutoScroll),-1)
	AFX_ISOLATIONAWARE_FUNC(HWND, CreateUpDownControl, (DWORD dwStyle,int x,int y,int cx,int cy,HWND hParent,int nID,HINSTANCE hInst,HWND hBuddy,int nUpper,int nLower,int nPos), (dwStyle,x,y,cx,cy,hParent,nID,hInst,hBuddy,nUpper,nLower,nPos),NULL)
	AFX_ISOLATIONAWARE_PROC(InitMUILanguage, (LANGID uiLang), (uiLang))
	AFX_ISOLATIONAWARE_FUNC(LANGID, GetMUILanguage, (), (),MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL))
	AFX_ISOLATIONAWARE_FUNC(HDSA, DSA_Create, (int cbItem,int cItemGrow), (cbItem,cItemGrow),NULL)
	AFX_ISOLATIONAWARE_FUNC(BOOL, DSA_Destroy, (HDSA hdsa), (hdsa),FALSE)
	AFX_ISOLATIONAWARE_PROC(DSA_DestroyCallback, (HDSA hdsa,PFNDSAENUMCALLBACK pfnCB,void*pData), (hdsa,pfnCB,pData))
	AFX_ISOLATIONAWARE_FUNC(PVOID, DSA_GetItemPtr, (HDSA hdsa,int i), (hdsa,i),NULL)
	AFX_ISOLATIONAWARE_FUNC(int, DSA_InsertItem, (HDSA hdsa,int i,void*pitem), (hdsa,i,pitem),-1)
	AFX_ISOLATIONAWARE_FUNC(HDPA, DPA_Create, (int cItemGrow), (cItemGrow),NULL)
	AFX_ISOLATIONAWARE_FUNC(BOOL, DPA_Destroy, (HDPA hdpa), (hdpa),FALSE)
	AFX_ISOLATIONAWARE_FUNC(PVOID, DPA_DeletePtr, (HDPA hdpa,int i), (hdpa,i),NULL)
	AFX_ISOLATIONAWARE_FUNC(BOOL, DPA_DeleteAllPtrs, (HDPA hdpa), (hdpa),FALSE)
	AFX_ISOLATIONAWARE_PROC(DPA_EnumCallback, (HDPA hdpa,PFNDPAENUMCALLBACK pfnCB,void*pData), (hdpa,pfnCB,pData))
	AFX_ISOLATIONAWARE_PROC(DPA_DestroyCallback, (HDPA hdpa,PFNDPAENUMCALLBACK pfnCB,void*pData), (hdpa,pfnCB,pData))
	AFX_ISOLATIONAWARE_FUNC(BOOL, DPA_SetPtr, (HDPA hdpa,int i,void*p), (hdpa,i,p),FALSE)
	AFX_ISOLATIONAWARE_FUNC(int, DPA_InsertPtr, (HDPA hdpa,int i,void*p), (hdpa,i,p),-1)
	AFX_ISOLATIONAWARE_FUNC(PVOID, DPA_GetPtr, (HDPA hdpa,INT_PTR i), (hdpa,i),NULL)
	AFX_ISOLATIONAWARE_FUNC(BOOL, DPA_Sort, (HDPA hdpa,PFNDPACOMPARE pfnCompare,LPARAM lParam), (hdpa,pfnCompare,lParam),FALSE)
	AFX_ISOLATIONAWARE_FUNC(int, DPA_Search, (HDPA hdpa,void*pFind,int iStart,PFNDPACOMPARE pfnCompare,LPARAM lParam,UINT options), (hdpa,pFind,iStart,pfnCompare,lParam,options),-1)
	AFX_ISOLATIONAWARE_FUNC(BOOL, Str_SetPtrW, (LPWSTR*ppsz,LPCWSTR psz), (ppsz,psz),FALSE)
	
	AFX_ISOLATIONAWARE_FUNC(BOOL, _TrackMouseEvent, (LPTRACKMOUSEEVENT lpEventTrack), (lpEventTrack),FALSE)
	
	AFX_ISOLATIONAWARE_FUNC(BOOL, FlatSB_EnableScrollBar, (HWND unnamed1,int unnamed2,UINT unnamed3), (unnamed1,unnamed2,unnamed3),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, FlatSB_ShowScrollBar, (HWND unnamed1,int code,BOOL unnamed2), (unnamed1,code,unnamed2),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, FlatSB_GetScrollRange, (HWND unnamed1,int code,LPINT unnamed2,LPINT unnamed3), (unnamed1,code,unnamed2,unnamed3),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, FlatSB_GetScrollInfo, (HWND unnamed1,int code,LPSCROLLINFO unnamed2), (unnamed1,code,unnamed2),FALSE)
	AFX_ISOLATIONAWARE_FUNC(int, FlatSB_GetScrollPos, (HWND unnamed1,int code), (unnamed1,code),0)
	AFX_ISOLATIONAWARE_FUNC(BOOL, FlatSB_GetScrollProp, (HWND unnamed1,int propIndex,LPINT unnamed2), (unnamed1,propIndex,unnamed2),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, FlatSB_GetScrollPropPtr, (HWND unnamed1,int propIndex,PINT_PTR unnamed2), (unnamed1,propIndex,unnamed2),FALSE)
	AFX_ISOLATIONAWARE_FUNC(int, FlatSB_SetScrollPos, (HWND unnamed1,int code,int pos,BOOL fRedraw), (unnamed1,code,pos,fRedraw),0)
	AFX_ISOLATIONAWARE_FUNC(int, FlatSB_SetScrollInfo, (HWND unnamed1,int code,LPSCROLLINFO unnamed2,BOOL fRedraw), (unnamed1,code,unnamed2,fRedraw),0)
	AFX_ISOLATIONAWARE_FUNC(int, FlatSB_SetScrollRange, (HWND unnamed1,int code,int min,int max,BOOL fRedraw), (unnamed1,code,min,max,fRedraw),0)
	AFX_ISOLATIONAWARE_FUNC(BOOL, FlatSB_SetScrollProp, (HWND unnamed1,UINT index,INT_PTR newValue,BOOL unnamed2), (unnamed1,index,newValue,unnamed2),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, InitializeFlatSB, (HWND unnamed1), (unnamed1),FALSE)
	AFX_ISOLATIONAWARE_FUNC(HRESULT, UninitializeFlatSB, (HWND unnamed1), (unnamed1),S_OK)

	typedef LRESULT (CALLBACK *SUBCLASSPROC)(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);

	AFX_ISOLATIONAWARE_FUNC(BOOL, SetWindowSubclass, (HWND hWnd,SUBCLASSPROC pfnSubclass,UINT_PTR uIdSubclass,DWORD_PTR dwRefData), (hWnd,pfnSubclass,uIdSubclass,dwRefData),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, GetWindowSubclass, (HWND hWnd,SUBCLASSPROC pfnSubclass,UINT_PTR uIdSubclass,DWORD_PTR*pdwRefData), (hWnd,pfnSubclass,uIdSubclass,pdwRefData),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL, RemoveWindowSubclass, (HWND hWnd,SUBCLASSPROC pfnSubclass,UINT_PTR uIdSubclass), (hWnd,pfnSubclass,uIdSubclass),FALSE)
	
	AFX_ISOLATIONAWARE_FUNC(LRESULT, DefSubclassProc, (HWND hWnd,UINT uMsg,WPARAM wParam,LPARAM lParam), (hWnd,uMsg,wParam,lParam),0)
	AFX_ISOLATIONAWARE_FUNC(int, DrawShadowText, (HDC hdc,LPCWSTR pszText,UINT cch,RECT*prc,DWORD dwFlags,COLORREF crText,COLORREF crShadow,int ixOffset,int iyOffset), (hdc,pszText,cch,prc,dwFlags,crText,crShadow,ixOffset,iyOffset),-1)
	
	AFX_ISOLATIONAWARE_FUNC(HPROPSHEETPAGE, CreatePropertySheetPageA, (LPCPROPSHEETPAGEA constPropSheetPagePointer), (constPropSheetPagePointer),NULL)
	AFX_ISOLATIONAWARE_FUNC(HPROPSHEETPAGE, CreatePropertySheetPageW, (LPCPROPSHEETPAGEW constPropSheetPagePointer), (constPropSheetPagePointer),NULL)
	AFX_ISOLATIONAWARE_FUNC(BOOL, DestroyPropertySheetPage, (HPROPSHEETPAGE unnamed1), (unnamed1),FALSE)
	AFX_ISOLATIONAWARE_FUNC(INT_PTR, PropertySheetA, (LPCPROPSHEETHEADERA unnamed1), (unnamed1),-1)
	AFX_ISOLATIONAWARE_FUNC(INT_PTR, PropertySheetW, (LPCPROPSHEETHEADERW unnamed1), (unnamed1),-1)
};
/////////////////////////////////////////////////////////////////////////////

#ifdef _UNICODE
#define AfxCreateStatusWindow AfxCreateStatusWindowW
#define AfxDrawStatusText AfxDrawStatusTextW
#define AfxImageList_LoadImage AfxImageList_LoadImageW
#define AfxCreatePropertySheetPage AfxCreatePropertySheetPageW
#define AfxPropertySheet AfxPropertySheetW
#else
#define AfxCreateStatusWindow AfxCreateStatusWindowA
#define AfxDrawStatusText AfxDrawStatusTextA
#define AfxImageList_LoadImage AfxImageList_LoadImageA
#define AfxCreatePropertySheetPage AfxCreatePropertySheetPageA
#define AfxPropertySheet AfxPropertySheetA
#endif

#define AfxImageList_RemoveAll(himl) AfxImageList_Remove(himl, -1)
#define AfxImageList_ExtractIcon(hi, himl, i) AfxImageList_GetIcon(himl, i, 0)
#define AfxImageList_LoadBitmap(hi, lpbmp, cx, cGrow, crMask) AfxImageList_LoadImage(hi, lpbmp, cx, cGrow, crMask, IMAGE_BITMAP, 0)
#define AfxImageList_AddIcon(himl, hicon) AfxImageList_ReplaceIcon(himl, -1, hicon)

////////////////////// commdlg.h //////////////////////////////////////////
class CCommDlgWrapper : public CDllIsolationWrapperBase
{
public:
	CCommDlgWrapper() 
	: CDllIsolationWrapperBase(_T("comdlg32.dll"))
	{
	}
public:
	AFX_ISOLATIONAWARE_FUNC(BOOL,GetOpenFileNameA,(LPOPENFILENAMEA unnamed1),(unnamed1),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL,GetOpenFileNameW,(LPOPENFILENAMEW unnamed1),(unnamed1),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL,GetSaveFileNameA,(LPOPENFILENAMEA unnamed1),(unnamed1),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL,GetSaveFileNameW,(LPOPENFILENAMEW unnamed1),(unnamed1),FALSE)
	AFX_ISOLATIONAWARE_FUNC(short,GetFileTitleA,(LPCSTR unnamed1,LPSTR unnamed2,WORD unnamed3),(unnamed1,unnamed2,unnamed3),-1)
	AFX_ISOLATIONAWARE_FUNC(short ,GetFileTitleW,(LPCWSTR unnamed1,LPWSTR unnamed2,WORD unnamed3),(unnamed1,unnamed2,unnamed3),-1)
	AFX_ISOLATIONAWARE_FUNC(BOOL ,ChooseColorA,(LPCHOOSECOLORA unnamed1),(unnamed1),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL ,ChooseColorW,(LPCHOOSECOLORW unnamed1),(unnamed1),FALSE)
	AFX_ISOLATIONAWARE_FUNC(HWND ,FindTextA,(LPFINDREPLACEA unnamed1),(unnamed1),NULL)
	AFX_ISOLATIONAWARE_FUNC(HWND ,FindTextW,(LPFINDREPLACEW unnamed1),(unnamed1),NULL)
	AFX_ISOLATIONAWARE_FUNC(HWND ,ReplaceTextA,(LPFINDREPLACEA unnamed1),(unnamed1),NULL)
	AFX_ISOLATIONAWARE_FUNC(HWND ,ReplaceTextW,(LPFINDREPLACEW unnamed1),(unnamed1),NULL)
	AFX_ISOLATIONAWARE_FUNC(BOOL ,ChooseFontA,(LPCHOOSEFONTA unnamed1),(unnamed1),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL ,ChooseFontW,(LPCHOOSEFONTW unnamed1),(unnamed1),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL ,PrintDlgA,(LPPRINTDLGA unnamed1),(unnamed1),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL ,PrintDlgW,(LPPRINTDLGW unnamed1),(unnamed1),FALSE)
	AFX_ISOLATIONAWARE_FUNC(DWORD ,CommDlgExtendedError,(void),(),0)
	AFX_ISOLATIONAWARE_FUNC(BOOL ,PageSetupDlgA,(LPPAGESETUPDLGA unnamed1),(unnamed1),FALSE)
	AFX_ISOLATIONAWARE_FUNC(BOOL ,PageSetupDlgW,(LPPAGESETUPDLGW unnamed1),(unnamed1),FALSE)
//These 2 must be the last in struct, because MFC always build them and the user may not 
//define WINVER >= 0x0500, so code in user module (inline funcs) will miscalculate the offsets. 
#if defined(STDMETHOD) && (WINVER >= 0x0500)
	AFX_ISOLATIONAWARE_FUNC(HRESULT ,PrintDlgExA,(LPPRINTDLGEXA unnamed1),(unnamed1),E_FAIL)
	AFX_ISOLATIONAWARE_FUNC(HRESULT ,PrintDlgExW,(LPPRINTDLGEXW unnamed1),(unnamed1),E_FAIL)
#endif /* defined(STDMETHOD) && (WINVER >= 0x0500) */
};
#ifdef _UNICODE
#define AfxCtxGetOpenFileName AfxCtxGetOpenFileNameW
#define AfxCtxGetSaveFileName AfxCtxGetSaveFileNameW
#define AfxCtxGetFileTitle	  AfxCtxGetFileTitleW
#define AfxCtxChooseColor	  AfxCtxChooseColorW
#define AfxCtxFindText		  AfxCtxFindTextW
#define AfxCtxReplaceText	  AfxCtxReplaceTextW
#define AfxCtxChooseFont	  AfxCtxChooseFontW
#define AfxCtxPrintDlg		  AfxCtxPrintDlgW
#define AfxCtxCommDlgExtendedError AfxCtxCommDlgExtendedErrorW
#define AfxCtxPageSetupDlg	  AfxCtxPageSetupDlgW
#define AfxCtxPrintDlgEx	  AfxCtxPrintDlgExW
#else // ANSI
#define AfxCtxGetOpenFileName AfxCtxGetOpenFileNameA
#define AfxCtxGetSaveFileName AfxCtxGetSaveFileNameA
#define AfxCtxGetFileTitle	  AfxCtxGetFileTitleA
#define AfxCtxChooseColor	  AfxCtxChooseColorA
#define AfxCtxFindText		  AfxCtxFindTextA
#define AfxCtxReplaceText	  AfxCtxReplaceTextA
#define AfxCtxChooseFont	  AfxCtxChooseFontA
#define AfxCtxPrintDlg		  AfxCtxPrintDlgA
#define AfxCtxCommDlgExtendedError AfxCtxCommDlgExtendedErrorA
#define AfxCtxPageSetupDlg	  AfxCtxPageSetupDlgA
#define AfxCtxPrintDlgEx	  AfxCtxPrintDlgExA
#endif


////////////////////// WinUser.inl //////////////////////////////////////////
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(ATOM ,RegisterClassA,(const WNDCLASSA*lpWndClass),(lpWndClass),0)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(ATOM ,RegisterClassW,(const WNDCLASSW*lpWndClass),(lpWndClass),0)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(BOOL ,UnregisterClassA,(LPCSTR lpClassName,HINSTANCE hInstance),(lpClassName,hInstance),FALSE)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(BOOL ,UnregisterClassW,(LPCWSTR lpClassName,HINSTANCE hInstance),(lpClassName,hInstance),FALSE)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(BOOL ,GetClassInfoA,(HINSTANCE hInstance,LPCSTR lpClassName,LPWNDCLASSA lpWndClass),(hInstance,lpClassName,lpWndClass),FALSE)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(BOOL ,GetClassInfoW,(HINSTANCE hInstance,LPCWSTR lpClassName,LPWNDCLASSW lpWndClass),(hInstance,lpClassName,lpWndClass),FALSE)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(ATOM ,RegisterClassExA,(const WNDCLASSEXA*unnamed1),(unnamed1),0)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(ATOM ,RegisterClassExW,(const WNDCLASSEXW*unnamed1),(unnamed1),0)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(BOOL ,GetClassInfoExA,(HINSTANCE unnamed1,LPCSTR unnamed2,LPWNDCLASSEXA unnamed3),(unnamed1,unnamed2,unnamed3),FALSE)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(BOOL ,GetClassInfoExW,(HINSTANCE unnamed1,LPCWSTR unnamed2,LPWNDCLASSEXW unnamed3),(unnamed1,unnamed2,unnamed3),FALSE)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(HWND ,CreateWindowExA,(DWORD dwExStyle,LPCSTR lpClassName,LPCSTR lpWindowName,DWORD dwStyle,int X,int Y,int nWidth,int nHeight,HWND hWndParent,HMENU hMenu,HINSTANCE hInstance,LPVOID lpParam),(dwExStyle,lpClassName,lpWindowName,dwStyle,X,Y,nWidth,nHeight,hWndParent,hMenu,hInstance,lpParam),NULL)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(HWND ,CreateWindowExW,(DWORD dwExStyle,LPCWSTR lpClassName,LPCWSTR lpWindowName,DWORD dwStyle,int X,int Y,int nWidth,int nHeight,HWND hWndParent,HMENU hMenu,HINSTANCE hInstance,LPVOID lpParam),(dwExStyle,lpClassName,lpWindowName,dwStyle,X,Y,nWidth,nHeight,hWndParent,hMenu,hInstance,lpParam),NULL)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(HWND ,CreateDialogParamA,(HINSTANCE hInstance,LPCSTR lpTemplateName,HWND hWndParent,DLGPROC lpDialogFunc,LPARAM dwInitParam),(hInstance,lpTemplateName,hWndParent,lpDialogFunc,dwInitParam),NULL)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(HWND ,CreateDialogParamW,(HINSTANCE hInstance,LPCWSTR lpTemplateName,HWND hWndParent,DLGPROC lpDialogFunc,LPARAM dwInitParam),(hInstance,lpTemplateName,hWndParent,lpDialogFunc,dwInitParam),NULL)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(HWND ,CreateDialogIndirectParamA,(HINSTANCE hInstance,LPCDLGTEMPLATEA lpTemplate,HWND hWndParent,DLGPROC lpDialogFunc,LPARAM dwInitParam),(hInstance,lpTemplate,hWndParent,lpDialogFunc,dwInitParam),NULL)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(HWND ,CreateDialogIndirectParamW,(HINSTANCE hInstance,LPCDLGTEMPLATEW lpTemplate,HWND hWndParent,DLGPROC lpDialogFunc,LPARAM dwInitParam),(hInstance,lpTemplate,hWndParent,lpDialogFunc,dwInitParam),NULL)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(INT_PTR ,DialogBoxParamA,(HINSTANCE hInstance,LPCSTR lpTemplateName,HWND hWndParent,DLGPROC lpDialogFunc,LPARAM dwInitParam),(hInstance,lpTemplateName,hWndParent,lpDialogFunc,dwInitParam),-1)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(INT_PTR ,DialogBoxParamW,(HINSTANCE hInstance,LPCWSTR lpTemplateName,HWND hWndParent,DLGPROC lpDialogFunc,LPARAM dwInitParam),(hInstance,lpTemplateName,hWndParent,lpDialogFunc,dwInitParam),-1)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(INT_PTR ,DialogBoxIndirectParamA,(HINSTANCE hInstance,LPCDLGTEMPLATEA hDialogTemplate,HWND hWndParent,DLGPROC lpDialogFunc,LPARAM dwInitParam),(hInstance,hDialogTemplate,hWndParent,lpDialogFunc,dwInitParam),-1)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(INT_PTR ,DialogBoxIndirectParamW,(HINSTANCE hInstance,LPCDLGTEMPLATEW hDialogTemplate,HWND hWndParent,DLGPROC lpDialogFunc,LPARAM dwInitParam),(hInstance,hDialogTemplate,hWndParent,lpDialogFunc,dwInitParam),-1)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(int ,MessageBoxA,(HWND hWnd,LPCSTR lpText,LPCSTR lpCaption,UINT uType),(hWnd,lpText,lpCaption,uType),0)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(int ,MessageBoxW,(HWND hWnd,LPCWSTR lpText,LPCWSTR lpCaption,UINT uType),(hWnd,lpText,lpCaption,uType),0)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(int ,MessageBoxExA,(HWND hWnd,LPCSTR lpText,LPCSTR lpCaption,UINT uType,WORD wLanguageId),(hWnd,lpText,lpCaption,uType,wLanguageId),0)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(int ,MessageBoxExW,(HWND hWnd,LPCWSTR lpText,LPCWSTR lpCaption,UINT uType,WORD wLanguageId),(hWnd,lpText,lpCaption,uType,wLanguageId),0)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(int ,MessageBoxIndirectA,(const MSGBOXPARAMSA*unnamed1),(unnamed1),0)
 AFX_ISOLATIONAWARE_STATICLINK_FUNC(int ,MessageBoxIndirectW,(const MSGBOXPARAMSW*unnamed1),(unnamed1),0)

#ifdef _UNICODE
#define AfxCtxRegisterClass   AfxCtxRegisterClassW
#define AfxCtxUnregisterClass AfxCtxUnregisterClassW
#define AfxCtxGetClassInfo   AfxCtxGetClassInfoW
#define AfxCtxRegisterClassEx AfxCtxRegisterClassExW
#define AfxCtxGetClassInfoEx AfxCtxGetClassInfoExW
#define AfxCtxCreateWindowEx AfxCtxCreateWindowExW
#define AfxCtxCreateDialogParam AfxCtxCreateDialogParamW
#define AfxCtxCreateDialogIndirectParam AfxCtxCreateDialogIndirectParamW
#define AfxCtxDialogBoxParam AfxCtxDialogBoxParamW
#define AfxCtxDialogBoxIndirectParam AfxCtxDialogBoxIndirectParamW
#define AfxCtxMessageBox AfxCtxMessageBoxW
#define AfxCtxMessageBoxEx AfxCtxMessageBoxExW
#define AfxCtxMessageBoxIndirect AfxCtxMessageBoxIndirectW
#else // ANSI
#define AfxCtxRegisterClass   AfxCtxRegisterClassA
#define AfxCtxUnregisterClass AfxCtxUnregisterClassA
#define AfxCtxGetClassInfo   AfxCtxGetClassInfoA
#define AfxCtxRegisterClassEx AfxCtxRegisterClassExA
#define AfxCtxGetClassInfoEx AfxCtxGetClassInfoExA
#define AfxCtxCreateWindowEx AfxCtxCreateWindowExA
#define AfxCtxCreateDialogParam AfxCtxCreateDialogParamA
#define AfxCtxCreateDialogIndirectParam AfxCtxCreateDialogIndirectParamA
#define AfxCtxDialogBoxParam AfxCtxDialogBoxParamA
#define AfxCtxDialogBoxIndirectParam AfxCtxDialogBoxIndirectParamA
#define AfxCtxMessageBox AfxCtxMessageBoxA
#define AfxCtxMessageBoxEx AfxCtxMessageBoxExA
#define AfxCtxMessageBoxIndirect AfxCtxMessageBoxIndirectA
#endif

////////////////////// WinBase.inl //////////////////////////////////////////
//Only the funcs that actually change in winbase.inl context are in this list.
AFX_ISOLATIONAWARE_STATICLINK_FUNC(HMODULE,LoadLibraryA,(LPCSTR lpLibFileName),(lpLibFileName),NULL)
AFX_ISOLATIONAWARE_STATICLINK_FUNC(HMODULE,LoadLibraryW,(LPCWSTR lpLibFileName),(lpLibFileName),NULL)
AFX_ISOLATIONAWARE_STATICLINK_FUNC(HMODULE,LoadLibraryExA,(LPCSTR lpLibFileName,HANDLE hFile,DWORD dwFlags),(lpLibFileName,hFile,dwFlags),NULL)
AFX_ISOLATIONAWARE_STATICLINK_FUNC(HMODULE,LoadLibraryExW,(LPCWSTR lpLibFileName,HANDLE hFile,DWORD dwFlags),(lpLibFileName,hFile,dwFlags),NULL)

#ifdef _UNICODE
#define AfxCtxLoadLibrary AfxCtxLoadLibraryW
#define AfxCtxLoadLibraryEx AfxCtxLoadLibraryExW
#else // ANSI
#define AfxCtxLoadLibrary AfxCtxLoadLibraryA
#define AfxCtxLoadLibraryEx AfxCtxLoadLibraryExA
#endif
///////////////////////// ShellApi.h ////////////////////////////////////////

class CShellWrapper : public CDllIsolationWrapperBase
{
public:
	CShellWrapper() 
	: CDllIsolationWrapperBase(_T("shell32.dll"))
	{
	}
public:
	AFX_ISOLATIONAWARE_FUNC(BOOL,InitNetworkAddressControl, (void), (),FALSE)
};

/////////////////////////////////////////////////////////////////////////////

#pragma pop_macro("AFX_ISOLATIONAWARE_FUNC")
#pragma pop_macro("AFX_ISOLATIONAWARE_PROC")
#pragma pop_macro("AFX_ISOLATIONAWARE_STATICLINK_FUNC")
#pragma pop_macro("AFX_ISOLATIONAWARE_STATICLINK_PROC")
#pragma pop_macro("AFX_ISOLATIONAWARE_FUNC_DEACTIVATE")
#pragma pop_macro("AFX_ISOLATIONAWARE_FUNC_ACTIVATE")
#pragma pop_macro("AFX_ISOLATIONAWARE_COMMON_ACTIVATE")

/////////////////////////////////////////////////////////////////////////////

#endif // __AFXCOMCTL32_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxcontrolbarimpl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CPane;

class CMFCControlBarImpl
{
	friend class CMFCToolBar;
	friend class CMFCReBar;

public:
	CMFCControlBarImpl(CPane* pBar);
	virtual ~CMFCControlBarImpl();

	void GetGripperRect(CRect& rectGripper, BOOL bClientCoord = FALSE);

// Attributes:
protected:
	CPane* m_pBar;

// Operations:
protected:
	void CalcNcSize(NCCALCSIZE_PARAMS FAR* lpncsp);
	void DrawNcArea();
	BOOL GetBackgroundFromParent(CDC* pDC);
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxcontextmenumanager.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCPopupMenu;

class CContextMenuManager : public CObject
{
	friend class CMFCPopupMenuBar;

public:
	CContextMenuManager();
	virtual ~CContextMenuManager();

// Opreations:
public:
	BOOL AddMenu(UINT uiMenuNameResId, UINT uiMenuResId);
	BOOL AddMenu(LPCTSTR lpszName, UINT uiMenuResId);

	virtual BOOL ShowPopupMenu(UINT uiMenuResId, int x, int y, CWnd* pWndOwner, 
		BOOL bOwnMessage = FALSE, BOOL bRightAlign = FALSE);
	virtual CMFCPopupMenu* ShowPopupMenu(HMENU hmenuPopup, int x, int y, CWnd* pWndOwner, BOOL bOwnMessage = FALSE,
		BOOL bAutoDestroy = TRUE, BOOL bRightAlign = FALSE);
	virtual UINT TrackPopupMenu(HMENU hmenuPopup, int x, int y, CWnd* pWndOwner, BOOL bRightAlign = FALSE);

	virtual BOOL LoadState(LPCTSTR lpszProfileName = NULL);
	virtual BOOL SaveState(LPCTSTR lpszProfileName = NULL);

// Customization operations:
	void GetMenuNames(CStringList& listOfNames) const;
	HMENU GetMenuByName(LPCTSTR lpszName, UINT* puiOrigResID = NULL) const;
	HMENU GetMenuById(UINT nMenuResId) const;

	virtual BOOL ResetState();

// Attributes:
public:
	void SetDontCloseActiveMenu(BOOL bSet = TRUE)
	{
		m_bDontCloseActiveMenu = bSet;
	}

protected:
	CMap<UINT, UINT, HMENU, HMENU>       m_Menus;
	CMap<CString, LPCTSTR, HMENU, HMENU> m_MenuNames;
	CMap<UINT, UINT, CObList*, CObList*> m_MenuOriginalItems;

	UINT m_nLastCommandID;
	BOOL m_bTrackMode;
	BOOL m_bDontCloseActiveMenu;

	void CopyOriginalMenuItemsToMenu(UINT uiResId, CMFCPopupMenuBar& menuBar);
	void CopyOriginalMenuItemsFromMenu(UINT uiResId, CMFCPopupMenuBar& menuBar);
};

extern CContextMenuManager* afxContextMenuManager;

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxcontrolbars.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.
//

#pragma once

#ifndef __AFXTEMPL_H__
#include <afxtempl.h>
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#include "afxcontrolbarutil.h" // Library global definitions.

//----------------------------
// Control bars:
//----------------------------
#include "afxtoolbar.h"
#include "afxstatusbar.h"
#include "afxmenubar.h"
#include "afxpanedialog.h"
#include "afxoutlookbar.h"
#include "afxoutlookbartabctrl.h"
#include "afxcolorbar.h"
#include "afxcaptionbar.h"
#include "afxoutlookbarpane.h"
#include "afxtabbedpane.h"
#include "afxtaskspane.h"

//--------------------------
// Ribbon bar:
//--------------------------
#include "afxribbonbar.h"
#include "afxribboncustomizedialog.h"
#include "afxribbonkeyboardcustomizedialog.h"
#include "afxribbonpanel.h"
#include "afxribbonmainpanel.h"
#include "afxribbonpanelmenu.h"
#include "afxribbonminitoolbar.h"
#include "afxribboncategory.h"
#include "afxribbonbutton.h"
#include "afxribbonlabel.h"
#include "afxbaseribbonelement.h"
#include "afxribbonbuttonsgroup.h"
#include "afxribboncolorbutton.h"
#include "afxribbonedit.h"
#include "afxribboncombobox.h"
#include "afxribboncheckbox.h"
#include "afxribboncommandslistbox.h"
#include "afxribbonpalettegallery.h"
#include "afxribbonstatusbar.h"
#include "afxribbonstatusbarpane.h"
#include "afxribbonslider.h"
#include "afxribbonprogressbar.h"
#include "afxribbonlinkctrl.h"
#include "afxribbonundobutton.h"

//-----------------------------------
// Control bar buttons:
//-----------------------------------
#include "afxtoolbarbutton.h"
#include "afxtoolbarcomboboxbutton.h"
#include "afxtoolbarmenubutton.h"
#include "afxtoolbareditboxbutton.h"
#include "afxtoolbarspineditboxbutton.h"
#include "afxtoolbarsystemmenubutton.h"
#include "afxtoolbardatetimectrl.h"
#include "afxdropdowntoolbar.h"
#include "afxcolormenubutton.h"
#include "afxtoolbarfontcombobox.h"
#include "afxoutlookbarpanebutton.h"
#include "afxdropdownlistbox.h"

//-------------------------
// Autohide bars
//-------------------------
#include "afxautohidebutton.h"
#include "afxautohidebar.h"

//-------------------------------------------------------------------
// Control Bar frame and miniframe windows (replaces CFrameWnd, 
// CMDIFrameWnd, CMDIChildWnd, COleIPFrameWnd and COleDocIPFrameWnd):
//-------------------------------------------------------------------
#include "afxframewndex.h"
#include "afxmdiframewndex.h"
#include "afxmdichildwndex.h"
#include "afxoleipframewndex.h"
#include "afxoledocipframewndex.h"
#include "afxolecntrframewndex.h"

#include "afxpaneframewnd.h"
#include "afxmultipaneframewnd.h"

//-----------------------------------
// Control Bar customization stuff:
//-----------------------------------
#include "afxtoolbarscustomizedialog.h"
#include "afxcustomizemenubutton.h"

#include "afxcontextmenumanager.h"
#include "afxkeyboardmanager.h"
#include "afxmousemanager.h"

#include "afxusertool.h"
#include "afxacceleratorkey.h"

//--------------------------------
// Control Bar workspace manager
//--------------------------------
#include "afxwinappex.h"
#include "afxsettingsstore.h"
#include "afxrebarstate.h"

//-----------------------
// Control Bar helpers:
//-----------------------
#include "afxmenutearoffmanager.h"
#include "afxdrawmanager.h"
#include "afxdockingpanesrow.h"
#include "afxtooltipmanager.h"
#include "afxcontrolrenderer.h"

//---------------------------------
// Control Bar menu replacements:
//---------------------------------
#include "afxpopupmenu.h"
#include "afxpopupmenubar.h"
#include "afxtoolbarimages.h"

//----------------------------
// Control Bar docking bars:
//----------------------------
#include "afxdockablepane.h"
#include "afxtabctrl.h"
#include "afxdockablepaneadapter.h"
#include "afxdocksite.h"

//------------------------
// Control Bar controls:
//------------------------
#include "afxbutton.h"
#include "afxeditbrowsectrl.h"
#include "afxcolorbutton.h"
#include "afxmenubutton.h"
#include "afxlinkctrl.h"
#include "afxvslistbox.h"
#include "afxcolorpickerctrl.h"
#include "afxfontcombobox.h"
#include "afxrebar.h"
#include "afxshelltreectrl.h"
#include "afxshelllistctrl.h"
#include "afxpropertygridctrl.h"
#include "afxmaskededit.h"
#include "afxsplitterwndex.h"
#include "afxspinbuttonctrl.h"
#include "afxdesktopalertwnd.h"
#include "afxdesktopalertdialog.h"
#include "afxtoolbarslistcheckbox.h"
#include "afxtooltipctrl.h"

//-----------------------
// Control Bar dialogs:
//-----------------------
#include "afxdialogex.h"
#include "afxwindowsmanagerdialog.h"
#include "afxpreviewviewex.h"
#include "afximageeditordialog.h"
#include "afxcolordialog.h"
#include "afxkeymapdialog.h"
#include "afxpropertysheet.h"
#include "afxpropertypage.h"

//---------------------
// Control Bar views:
//---------------------
#include "afxtabview.h"

//--------------------
// Visualization stuff:
//--------------------
#include "afxvisualmanager.h"
#include "afxvisualmanagerofficexp.h"
#include "afxvisualmanagerwindows.h"
#include "afxvisualmanageroffice2003.h"
#include "afxvisualmanagervs2005.h"
#include "afxvisualmanagervs2008.h"
#include "afxvisualmanageroffice2007.h"
#include "afxvisualmanagerwindows7.h"

//-------------------------
// OLE Full Server Support:
//-------------------------
#include "afxoleserverdocex.h"

//-------------------------
// Global Utils:
//-------------------------
#include "afxglobalutils.h"
#include "afxaccessibility.h"

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxcontrolbarutil.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.
//

#pragma once

#ifndef __AFXCMN_H__
	#include <afxcmn.h> // MFC support for Windows Common Controls
#endif

#ifndef __AFXTEMPL_H__
	#include "afxtempl.h"
#endif

#include "afxusertoolsmanager.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#define _AFX_USING_CONTROL_BARS

inline BOOL IsStandardCommand(UINT uiCmd)
{
	return((uiCmd >= ID_FILE_MRU_FILE1 && uiCmd <= ID_FILE_MRU_FILE16) || // MRU commands,
		(uiCmd >= 0xF000 && uiCmd < 0xF1F0) ||                            // system commands,
		((int) uiCmd >= AFX_IDM_FIRST_MDICHILD) ||                        // windows commands
		(uiCmd >= ID_OLE_VERB_FIRST && uiCmd <= ID_OLE_VERB_LAST) ||      // OLE commands
		afxUserToolsManager != NULL && uiCmd == afxUserToolsManager->GetToolsEntryCmd());
}

void ControlBarCleanUp();

extern CFrameWnd* g_pTopLevelFrame;

inline void AFXSetTopLevelFrame(CFrameWnd* pFrame)
{
	g_pTopLevelFrame = pFrame;
}

inline CFrameWnd* AFXGetTopLevelFrame(const CWnd* pWnd)
{
	ASSERT_VALID(pWnd);
	return g_pTopLevelFrame == NULL ? pWnd->GetTopLevelFrame() : g_pTopLevelFrame;
}

CFrameWnd* AFXGetParentFrame(const CWnd* pWnd);

#define AFX_GET_X_LPARAM(lp) ((int)(short)LOWORD(lp))
#define AFX_GET_Y_LPARAM(lp) ((int)(short)HIWORD(lp))

class CMemDC
{
public:
	AFX_IMPORT_DATA static BOOL m_bUseMemoryDC;

	CMemDC(CDC& dc, CWnd* pWnd);
	CMemDC(CDC& dc, const CRect& rect);

	virtual ~CMemDC();

	CDC& GetDC() { return m_bMemDC ? m_dcMem : m_dc; }
	BOOL IsMemDC() const { return m_bMemDC; }
	BOOL IsVistaDC() const { return m_hBufferedPaint != NULL; }

protected:
	CDC&     m_dc;
	BOOL     m_bMemDC;
	HANDLE   m_hBufferedPaint;
	CDC      m_dcMem;
	CBitmap  m_bmp;
	CBitmap* m_pOldBmp;
	CRect    m_rect;
};

// Windows Vista Notifications:
#ifndef WM_DWMCOMPOSITIONCHANGED
#define WM_DWMCOMPOSITIONCHANGED        0x031E
#endif

#ifndef WM_DWMNCRENDERINGCHANGED
#define WM_DWMNCRENDERINGCHANGED        0x031F
#endif

#ifndef WM_DWMCOLORIZATIONCOLORCHANGED
#define WM_DWMCOLORIZATIONCOLORCHANGED  0x0320
#endif

#ifndef WM_DWMWINDOWMAXIMIZEDCHANGE
#define WM_DWMWINDOWMAXIMIZEDCHANGE     0x0321
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

// Smart docking theme:
typedef enum AFX_SMARTDOCK_THEME
{
	AFX_SDT_DEFAULT = 0,	// Visual Manager-specific theme
	AFX_SDT_VS2005 = 1,		// VS 2005-style
	AFX_SDT_VS2008 = 2		// VS 2008-style
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxcontrolrenderer.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxtoolbarimages.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCControlRendererInfo
{
public:
	CMFCControlRendererInfo();
	~CMFCControlRendererInfo();

	CMFCControlRendererInfo(UINT uiBmpResID, const CRect& rtImage, const CRect& rtCorners, const CRect& rtSides = CRect(0, 0, 0, 0), const CRect& rtInner = CRect(0, 0, 0, 0));
	CMFCControlRendererInfo(LPCTSTR lpszBmpResID, const CRect& rtImage, const CRect& rtCorners, const CRect& rtSides = CRect(0, 0, 0, 0), const CRect& rtInner = CRect(0, 0, 0, 0));
	CMFCControlRendererInfo(UINT uiBmpResID, COLORREF clrTransparent, const CRect& rtImage, const CRect& rtCorners, const CRect& rtSides = CRect(0, 0, 0, 0), const CRect& rtInner = CRect(0, 0, 0, 0), BOOL bPreMultiplyCheck = TRUE);
	CMFCControlRendererInfo(LPCTSTR lpszBmpResID, COLORREF clrTransparent, const CRect& rtImage, const CRect& rtCorners, const CRect& rtSides = CRect(0, 0, 0, 0), const CRect& rtInner = CRect(0, 0, 0, 0), BOOL bPreMultiplyCheck = TRUE);
	CMFCControlRendererInfo(const CMFCControlRendererInfo& rSrc);

public:
	void CommonInit();

	LPCTSTR GetResourceID() const;
	void SetResourceID(LPCTSTR lpszBmpResID);

	CMFCControlRendererInfo& operator = (const CMFCControlRendererInfo& rSrc);

public:
	UINT     m_uiBmpResID;
	CString  m_strBmpResID;
	CRect    m_rectImage;
	CRect    m_rectCorners;
	CRect    m_rectSides;
	CRect    m_rectInter;
	COLORREF m_clrTransparent;
	BOOL     m_bPreMultiplyCheck;
};

class CMFCControlRenderer : public CObject
{
	DECLARE_DYNCREATE(CMFCControlRenderer)

public:
	CMFCControlRenderer();
	virtual ~CMFCControlRenderer();

// Operations:
public:
	virtual BOOL Create(const CMFCControlRendererInfo& params, BOOL bFlipvert = FALSE);

	/// <summary> 
	/// Smoothly resizes images.</summary>
	/// <param name="dblScale"> Scale ratio.</param>
	/// <returns> TRUE if resize succeeds; otherwise FALSE.</returns>
	BOOL SmoothResize(double dblScale);

	virtual void Draw(CDC* pDC, CRect rect, UINT index = 0, BYTE alphaSrc = 255);
	virtual void DrawFrame(CDC* pDC, CRect rect, UINT index = 0, BYTE alphaSrc = 255);
	virtual void FillInterior(CDC* pDC, CRect rect, UINT index = 0, BYTE alphaSrc = 255);
	virtual void FillInterior(CDC* pDC, CRect rect, CMFCToolBarImages::ImageAlignHorz horz, CMFCToolBarImages::ImageAlignVert vert, UINT index = 0, BYTE alphaSrc = 255);

	virtual void OnSysColorChange();
	const CMFCControlRendererInfo& GetParams() const { return m_Params; }

	BOOL IsValid() const { return m_Bitmap.IsValid(); }
	BOOL IsMirror() const { return m_bMirror; }

	virtual void Mirror();
	virtual void CleanUp();
	
	int GetImageCount() const
	{
		CRect rectImage(m_Params.m_rectImage);

		if (m_Bitmap.GetCount() == 1)
		{
			HBITMAP hBmp = m_Bitmap.GetImageWell();
			BITMAP bmp;

			if (::GetObject(hBmp, sizeof(BITMAP), &bmp) == sizeof(BITMAP))
			{
				return bmp.bmHeight / m_Params.m_rectImage.Height();
			}

			return 0;
		}

		return m_Bitmap.GetCount();
	}

	/// <summary>
	/// Tells whether this control renderer works with scaled (resized) images.</summary>
	/// <returns>Returns TRUE if this control renderer works with resized (scaled) images.</returns>
	BOOL IsScaled() const
	{
		return m_bIsScaled;
	}

// Attributes:
protected:
	CMFCToolBarImages       m_Bitmap;
	CMFCControlRendererInfo m_Params;
	BOOL                    m_bMirror;
	BOOL                    m_bIsScaled;
};

class CMFCShadowRenderer : public CMFCControlRenderer  
{
	DECLARE_DYNCREATE(CMFCShadowRenderer)

public:
	CMFCShadowRenderer();
	virtual ~CMFCShadowRenderer();

// Operations:
public:
	virtual BOOL Create (int nDepth, COLORREF clrBase, int iMinBrightness = 0, int iMaxBrightness = 100);

	virtual void OnSysColorChange ();
	virtual void Draw (CDC* pDC, CRect rect, UINT index = 0, BYTE alphaSrc = 255);
	virtual void DrawFrame (CDC* pDC, CRect rect, UINT index = 0, BYTE alphaSrc = 255);

	
protected:
	virtual BOOL Create (const CMFCControlRendererInfo& params, BOOL bFlipvert = FALSE);
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxconv.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXCONV_H__
#define __AFXCONV_H__

#ifndef _OBJBASE_H_
#include <objbase.h>
#endif

#pragma once

/////////////////////////////////////////////////////////////////////////////
// Global UNICODE<>ANSI translation helpers

#ifdef _WINGDI_
LPDEVMODEW AFXAPI AfxDevModeA2W(LPDEVMODEW lpDevModeW, LPDEVMODEA lpDevModeA);
LPDEVMODEA AFXAPI AfxDevModeW2A(LPDEVMODEA lpDevModeA, LPDEVMODEW lpDevModeW);
LPTEXTMETRICW AFXAPI AfxTextMetricA2W(LPTEXTMETRICW lptmW, LPTEXTMETRICA lptmA);
LPTEXTMETRICA AFXAPI AfxTextMetricW2A(LPTEXTMETRICA lptmA, LPTEXTMETRICW lptmW);

#ifndef ATLDEVMODEA2W
#define ATLDEVMODEA2W AfxDevModeA2W
#define ATLDEVMODEW2A AfxDevModeW2A
#define ATLTEXTMETRICA2W AfxTextMetricA2W
#define ATLTEXTMETRICW2A AfxTextMetricW2A
#endif

#endif //_WINGDI

LPWSTR AFXAPI AfxA2WHelper(_Out_z_cap_(nChars) LPWSTR lpw, _In_z_ LPCSTR lpa, _In_ int nChars);
LPSTR AFXAPI AfxW2AHelper(_Out_z_cap_(nChars) LPSTR lpa, _In_z_ LPCWSTR lpw, _In_ int nChars);

#ifndef ATLA2WHELPER
#define ATLA2WHELPER AfxA2WHelper
#define ATLW2AHELPER AfxW2AHelper
#endif

#define OLESTDDELIMOLE OLESTR("\\")

#if defined(_UNICODE)
// in these cases the default (TCHAR) is the same as OLECHAR
	AFX_INLINE LPOLESTR TASKSTRINGT2OLE(LPOLESTR lp) { return lp; }
	AFX_INLINE LPTSTR TASKSTRINGOLE2T(LPOLESTR lp) { return lp; }
	AFX_INLINE BSTR BSTR2TBSTR(BSTR bstr) { return bstr;}
#else
	#define TASKSTRINGT2OLE(lpa)    AfxTaskStringA2W(lpa)
	#define TASKSTRINGOLE2T(lpo) AfxTaskStringW2A(lpo)
	#define BSTR2TBSTR(bstr) AfxBSTR2ABSTR(bstr)
#endif

#include <atlconv.h>

#endif //__AFXCONV_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxctl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// AFXCTL.H - MFC OLE Control support

#ifndef __AFXCTL_H__
#define __AFXCTL_H__

#pragma once

// make sure afxole.h is included first
#ifndef __AFXOLE_H__
	#include <afxole.h>
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 

/////////////////////////////////////////////////////////////////////////////
// Classes declared in this file

//CWinApp
	class COleControlModule;        // Module housekeeping for an .OCX

class CFontHolder;                  // For manipulating font objects
class CPictureHolder;               // For manipulating picture objects

//CWnd
	class COleControl;              // OLE Control

//CDialog
	class COlePropertyPage;         // OLE Property page

class CPropExchange;                // Abstract base for property exchange

//CAsyncMonikerFile
	class CDataPathProperty;        // Asynchronous properties for OLE Controls
		class CCachedDataPathProperty;  // Cached asynchronous properties for OLE Controls

/////////////////////////////////////////////////////////////////////////////
// Set structure packing

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// MFC data definition for data exported from the runtime DLL

#undef AFX_DATA
#define AFX_DATA AFX_OLE_DATA

/////////////////////////////////////////////////////////////////////////////
// COleControlModule - base class for .OCX module
//  This object is statically linked into the control.

class COleControlModule : public CWinApp
{
	DECLARE_DYNAMIC(COleControlModule)
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};

/////////////////////////////////////////////////////////////////////////////
//  Module state macro

#define AfxGetControlModuleContext  AfxGetStaticModuleState
#define _afxModuleAddrThis AfxGetStaticModuleState()

/////////////////////////////////////////////////////////////////////////////
// Connection helper functions

BOOL AFXAPI AfxConnectionAdvise(LPUNKNOWN pUnkSrc, REFIID iid,
	LPUNKNOWN pUnkSink, BOOL bRefCount, DWORD* pdwCookie);

BOOL AFXAPI AfxConnectionUnadvise(LPUNKNOWN pUnkSrc, REFIID iid,
	LPUNKNOWN pUnkSink, BOOL bRefCount, DWORD dwCookie);

/////////////////////////////////////////////////////////////////////////////
// Event maps

enum AFX_EVENTMAP_FLAGS
{
	afxEventCustom = 0,
	afxEventStock = 1,
};

struct AFX_EVENTMAP_ENTRY
{
	AFX_EVENTMAP_FLAGS flags;
	DISPID dispid;
	LPCTSTR pszName;
	LPCSTR lpszParams;
};

struct AFX_EVENTMAP
{
#ifdef _AFXDLL
	const AFX_EVENTMAP* (PASCAL* pfnGetBaseMap)();
#else
	const AFX_EVENTMAP* lpBaseEventMap;
#endif
	const AFX_EVENTMAP_ENTRY* lpEntries;
	DWORD* lpStockEventMask;
};

#ifdef _AFXDLL
#define DECLARE_EVENT_MAP() \
private: \
	static const AFX_EVENTMAP_ENTRY _eventEntries[]; \
	static DWORD _dwStockEventMask; \
protected: \
	static const AFX_EVENTMAP eventMap; \
	static const AFX_EVENTMAP* PASCAL GetThisEventMap(); \
	virtual const AFX_EVENTMAP* GetEventMap() const; \

#define BEGIN_EVENT_MAP(theClass, baseClass) \
	const AFX_EVENTMAP* PASCAL theClass::GetThisEventMap() \
		{ return &theClass::eventMap; } \
	const AFX_EVENTMAP* theClass::GetEventMap() const \
		{ return &eventMap; } \
	AFX_COMDAT const AFX_EVENTMAP theClass::eventMap = \
		{ &(baseClass::GetThisEventMap), theClass::_eventEntries, \
			&theClass::_dwStockEventMask }; \
	AFX_COMDAT DWORD theClass::_dwStockEventMask = (DWORD)-1; \
	AFX_COMDAT const AFX_EVENTMAP_ENTRY theClass::_eventEntries[] = \
	{
#else
#define DECLARE_EVENT_MAP() \
private: \
	static const AFX_EVENTMAP_ENTRY _eventEntries[]; \
	static DWORD _dwStockEventMask; \
protected: \
	static const AFX_EVENTMAP eventMap; \
	virtual const AFX_EVENTMAP* GetEventMap() const;

#define BEGIN_EVENT_MAP(theClass, baseClass) \
	const AFX_EVENTMAP* theClass::GetEventMap() const \
		{ return &eventMap; } \
	AFX_COMDAT const AFX_EVENTMAP theClass::eventMap = \
		{ &(baseClass::eventMap), theClass::_eventEntries, \
			&theClass::_dwStockEventMask }; \
	AFX_COMDAT DWORD theClass::_dwStockEventMask = (DWORD)-1; \
	AFX_COMDAT const AFX_EVENTMAP_ENTRY theClass::_eventEntries[] = \
	{
#endif

#define END_EVENT_MAP() \
		{ afxEventCustom, DISPID_UNKNOWN, NULL, NULL }, \
	};

#define EVENT_CUSTOM(pszName, pfnFire, vtsParams) \
	{ afxEventCustom, DISPID_UNKNOWN, _T(pszName), vtsParams },

#define EVENT_CUSTOM_ID(pszName, dispid, pfnFire, vtsParams) \
	{ afxEventCustom, dispid, _T(pszName), vtsParams },

#define EVENT_PARAM(vtsParams) (BYTE*)(vtsParams)

/////////////////////////////////////////////////////////////////////////////
// Stock events

#define EVENT_STOCK_CLICK() \
	{ afxEventStock, DISPID_CLICK, _T("Click"), VTS_NONE },

#define EVENT_STOCK_DBLCLICK() \
	{ afxEventStock, DISPID_DBLCLICK, _T("DblClick"), VTS_NONE },

#define EVENT_STOCK_KEYDOWN() \
	{ afxEventStock, DISPID_KEYDOWN, _T("KeyDown"), VTS_PI2 VTS_I2 },

#define EVENT_STOCK_KEYPRESS() \
	{ afxEventStock, DISPID_KEYPRESS, _T("KeyPress"), VTS_PI2 },

#define EVENT_STOCK_KEYUP() \
	{ afxEventStock, DISPID_KEYUP, _T("KeyUp"), VTS_PI2 VTS_I2 },

#define EVENT_STOCK_MOUSEDOWN() \
	{ afxEventStock, DISPID_MOUSEDOWN, _T("MouseDown"), \
	  VTS_I2 VTS_I2 VTS_XPOS_PIXELS VTS_YPOS_PIXELS },

#define EVENT_STOCK_MOUSEMOVE() \
	{ afxEventStock, DISPID_MOUSEMOVE, _T("MouseMove"), \
	  VTS_I2 VTS_I2 VTS_XPOS_PIXELS VTS_YPOS_PIXELS },

#define EVENT_STOCK_MOUSEUP() \
	{ afxEventStock, DISPID_MOUSEUP, _T("MouseUp"), \
	  VTS_I2 VTS_I2 VTS_XPOS_PIXELS VTS_YPOS_PIXELS },

#define EVENT_STOCK_ERROREVENT() \
	{ afxEventStock, DISPID_ERROREVENT, _T("Error"), \
	  VTS_I2 VTS_PBSTR VTS_SCODE VTS_BSTR VTS_BSTR VTS_I4 VTS_PBOOL },

#define EVENT_STOCK_READYSTATECHANGE() \
	{ afxEventStock, DISPID_READYSTATECHANGE, _T("ReadyStateChange"), \
	  VTS_I4 },

// Shift state values for mouse and keyboard events
#define SHIFT_MASK      0x01
#define CTRL_MASK       0x02
#define ALT_MASK        0x04

// Button values for mouse events
#define LEFT_BUTTON     0x01
#define RIGHT_BUTTON    0x02
#define MIDDLE_BUTTON   0x04

/////////////////////////////////////////////////////////////////////////////
// Stock properties

#define DISP_PROPERTY_STOCK(theClass, szExternalName, dispid, pfnGet, pfnSet, vtPropType) \
	{ _T(szExternalName), dispid, NULL, vtPropType, \
		(AFX_PMSG)(void (theClass::*)(void))&pfnGet, \
		(AFX_PMSG)(void (theClass::*)(void))&pfnSet, 0, afxDispStock }, \

#define DISP_STOCKPROP_APPEARANCE() \
	DISP_PROPERTY_STOCK(COleControl, "Appearance", DISPID_APPEARANCE, \
		COleControl::GetAppearance, COleControl::SetAppearance, VT_I2)

#define DISP_STOCKPROP_BACKCOLOR() \
	DISP_PROPERTY_STOCK(COleControl, "BackColor", DISPID_BACKCOLOR, \
		COleControl::GetBackColor, COleControl::SetBackColor, VT_COLOR)

#define DISP_STOCKPROP_BORDERSTYLE() \
	DISP_PROPERTY_STOCK(COleControl, "BorderStyle", DISPID_BORDERSTYLE, \
		COleControl::GetBorderStyle, COleControl::SetBorderStyle, VT_I2)

#define DISP_STOCKPROP_CAPTION() \
	DISP_PROPERTY_STOCK(COleControl, "Caption", DISPID_CAPTION, \
		COleControl::GetText, COleControl::SetText, VT_BSTR)

#define DISP_STOCKPROP_ENABLED() \
	DISP_PROPERTY_STOCK(COleControl, "Enabled", DISPID_ENABLED, \
		COleControl::GetEnabled, COleControl::SetEnabled, VT_BOOL)

#define DISP_STOCKPROP_FONT() \
	DISP_PROPERTY_STOCK(COleControl, "Font", DISPID_FONT, \
		COleControl::GetFont, COleControl::SetFont, VT_FONT)

#define DISP_STOCKPROP_FORECOLOR() \
	DISP_PROPERTY_STOCK(COleControl, "ForeColor", DISPID_FORECOLOR, \
		COleControl::GetForeColor, COleControl::SetForeColor, VT_COLOR)

#define DISP_STOCKPROP_HWND() \
	DISP_PROPERTY_STOCK(COleControl, "hWnd", DISPID_HWND, \
		COleControl::GetHwnd, SetNotSupported, VT_HANDLE)

#define DISP_STOCKPROP_TEXT() \
	DISP_PROPERTY_STOCK(COleControl, "Text", DISPID_TEXT, \
		COleControl::GetText, COleControl::SetText, VT_BSTR)

#define DISP_STOCKPROP_READYSTATE() \
	DISP_PROPERTY_STOCK(COleControl, "ReadyState", DISPID_READYSTATE, \
		COleControl::GetReadyState, SetNotSupported, VT_I4)

/////////////////////////////////////////////////////////////////////////////
// Stock methods

#define DISP_FUNCTION_STOCK(theClass, szExternalName, dispid, pfnMember, vtRetVal, vtsParams) \
	{ _T(szExternalName), dispid, vtsParams, vtRetVal, \
		(AFX_PMSG)(void (theClass::*)(void))&pfnMember, (AFX_PMSG)0, 0, \
		afxDispStock }, \

#define DISP_STOCKFUNC_REFRESH() \
	DISP_FUNCTION_STOCK(COleControl, "Refresh", DISPID_REFRESH, \
			COleControl::Refresh, VT_EMPTY, VTS_NONE)

#define DISP_STOCKFUNC_DOCLICK() \
	DISP_FUNCTION_STOCK(COleControl, "DoClick", DISPID_DOCLICK, \
			COleControl::DoClick, VT_EMPTY, VTS_NONE)

/////////////////////////////////////////////////////////////////////////////
// Macros for object factory and class ID

#define BEGIN_OLEFACTORY(class_name) \
protected: \
	class class_name##Factory : public COleObjectFactoryEx \
	{ \
	public: \
		class_name##Factory(REFCLSID clsid, CRuntimeClass* pRuntimeClass, \
			BOOL bMultiInstance, LPCTSTR lpszProgID) : \
				COleObjectFactoryEx(clsid, pRuntimeClass, bMultiInstance, \
				lpszProgID) {} \
		virtual BOOL UpdateRegistry(BOOL);

#define END_OLEFACTORY(class_name) \
	}; \
	friend class class_name##Factory; \
	static class_name##Factory factory; \
public: \
	static const GUID guid; \
	virtual HRESULT GetClassID(LPCLSID pclsid);

#define DECLARE_OLECREATE_EX(class_name) \
	BEGIN_OLEFACTORY(class_name) \
	END_OLEFACTORY(class_name)

#define IMPLEMENT_OLECREATE_EX(class_name, external_name, \
			l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
	const TCHAR _szProgID_##class_name[] = _T(external_name); \
	class_name::class_name##Factory class_name::factory( \
		class_name::guid, RUNTIME_CLASS(class_name), FALSE, \
		_szProgID_##class_name); \
	const GUID class_name::guid = \
		{ l, w1, w2, { b1, b2, b3, b4, b5, b6, b7, b8 } }; \
	HRESULT class_name::GetClassID(LPCLSID pclsid) \
		{ *pclsid = guid; return NOERROR; }

/////////////////////////////////////////////////////////////////////////////
// Macros for type name and misc status

#define DECLARE_OLECTLTYPE(class_name) \
	virtual UINT GetUserTypeNameID(); \
	virtual DWORD GetMiscStatus();

#define IMPLEMENT_OLECTLTYPE(class_name, idsUserTypeName, dwOleMisc) \
	UINT class_name::GetUserTypeNameID() { return idsUserTypeName; } \
	DWORD class_name::GetMiscStatus() { return dwOleMisc; }

/////////////////////////////////////////////////////////////////////////////
// Macros for property page IDs

#define DECLARE_PROPPAGEIDS(class_name) \
	protected: \
		virtual LPCLSID GetPropPageIDs(ULONG& cPropPages);

#define BEGIN_PROPPAGEIDS(class_name, count) \
	static CLSID _rgPropPageIDs_##class_name[count]; \
	AFX_COMDAT ULONG _cPropPages_##class_name = (ULONG)-1; \
	LPCLSID class_name::GetPropPageIDs(ULONG& cPropPages) { \
		if (_cPropPages_##class_name == (ULONG)-1) { \
			_cPropPages_##class_name = count; \
			LPCLSID pIDs = _rgPropPageIDs_##class_name; \
			ULONG iPageMax = count; \
			ULONG iPage = 0;

#define PROPPAGEID(clsid) \
			ASSERT(iPage < iPageMax); \
			if (iPage < iPageMax) \
				pIDs[iPage++] = clsid;

#define END_PROPPAGEIDS(class_name) \
			ASSERT(iPage == iPageMax); \
		} \
		cPropPages = _cPropPages_##class_name; \
		return _rgPropPageIDs_##class_name; }

/////////////////////////////////////////////////////////////////////////////
// CFontHolder - helper class for dealing with font objects

class CFontHolder
{
// Constructors
public:
	explicit CFontHolder(LPPROPERTYNOTIFYSINK pNotify);

// Attributes
	LPFONT m_pFont;

// Operations
	void InitializeFont(
			const FONTDESC* pFontDesc = NULL,
			LPDISPATCH pFontDispAmbient = NULL);
	void SetFont(LPFONT pNewFont);
	void ReleaseFont();
	HFONT GetFontHandle();
	HFONT GetFontHandle(long cyLogical, long cyHimetric);
	CFont* Select(CDC* pDC, long cyLogical, long cyHimetric);
	BOOL GetDisplayString(CString& strValue);
	LPFONTDISP GetFontDispatch();
	void QueryTextMetrics(LPTEXTMETRIC lptm);

// Implementation
public:
	~CFontHolder();
	void SetFontNotifySink(LPPROPERTYNOTIFYSINK pNotify);

protected:
	DWORD m_dwConnectCookie;
	LPPROPERTYNOTIFYSINK m_pNotify;
};

/////////////////////////////////////////////////////////////////////////////
// CPictureHolder - helper class for dealing with picture objects

class CPictureHolder
{
// Constructors
public:
	CPictureHolder();

// Attributes
	LPPICTURE m_pPict;

// Operations
	BOOL CreateEmpty();

	BOOL CreateFromBitmap(UINT idResource);
	BOOL CreateFromBitmap(CBitmap* pBitmap, CPalette* pPal = NULL,
		BOOL bTransferOwnership = TRUE);
	BOOL CreateFromBitmap(HBITMAP hbm, HPALETTE hpal = NULL,
		BOOL bTransferOwnership = FALSE);

	BOOL CreateFromMetafile(HMETAFILE hmf, int xExt, int yExt,
		BOOL bTransferOwnership = FALSE);

	BOOL CreateFromIcon(UINT idResource);
	BOOL CreateFromIcon(HICON hIcon, BOOL bTransferOwnership = FALSE);

	short GetType();
	BOOL GetDisplayString(CString& strValue);
	LPPICTUREDISP GetPictureDispatch();
	void SetPictureDispatch(LPPICTUREDISP pDisp);
	void Render(CDC* pDC, const CRect& rcRender, const CRect& rcWBounds);

// Implementation
public:
	~CPictureHolder();
};

/////////////////////////////////////////////////////////////////////////////
// CDataPathProperty - Asynchonous properties for OLE Controls

class CDataPathProperty: public CAsyncMonikerFile
{
	DECLARE_DYNAMIC(CDataPathProperty)

private:
   using CAsyncMonikerFile::Open;

// Constructors
public:
	CDataPathProperty(COleControl* pControl = NULL);
	CDataPathProperty(LPCTSTR lpszPath, COleControl* pControl = NULL);
	// Calls SetPath(pControl) and SetPath(lpszPath) as appropriate.

// Attributes
public:
	void SetPath(LPCTSTR lpszPath);
	// Sets the path to be opened by Open(COleControl*) and Open()
	// lpszPath may be NULL.

	CString GetPath() const;
	// Returns the current path setting.  Result may be empty.

	COleControl* GetControl();
	// Returns a Pointer to the control.  Result may be NULL.

	void SetControl(COleControl* pControl);
	// Sets the control which will be used with Open.  pControl may be NULL.

// Operations
public:
	// Overloads of Open takings some or all of: a path, a control,
	// and a CFileException
	// Overloads taking a COleControl call SetControl(pControl)
	// Overloads taking an LPCTSTR cal SetPath(lpszPath)
	virtual BOOL Open(COleControl* pControl, CFileException* pError = NULL);
	virtual BOOL Open(LPCTSTR lpszPath, COleControl* pControl,
		CFileException* pError = NULL);
	virtual BOOL Open(LPCTSTR lpszPath, CFileException* pError = NULL);
	virtual BOOL Open(CFileException* pError = NULL);
	// Attempts to obtain an IBindHost* from the control returned by
	// GetControl(). Calls CAsyncMonikerFile::Open with the path returned by
	// GetPath() and, if it was obtained, the IBindHost*.
	// Returns TRUE if successful.

// Overridables
public:
	virtual void ResetData();
	// Derived classes should overide this.

// Implementation
public:
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

private:
	COleControl* m_pControl;
	CString m_strPath;
};

/////////////////////////////////////////////////////////////////////////////
// CCachedDataPathProperty - Cached asynchonous properties for OLE Controls

class CCachedDataPathProperty : public CDataPathProperty
{
	DECLARE_DYNAMIC(CCachedDataPathProperty)
//Constructors
public:
	CCachedDataPathProperty(COleControl* pControl = NULL);
	CCachedDataPathProperty(LPCTSTR lpszPath, COleControl* pControl = NULL);

// Attributes
public:
	CMemFile m_Cache;

// Implementation
public:
	virtual void OnDataAvailable(DWORD dwSize, DWORD bscfFlag);
	virtual void Close();
	virtual void ResetData();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// COleControl - base class for a control implemented in C++ with MFC

struct _AFXCTL_ADVISE_INFO;     // implementation class
struct _AFXCTL_UIACTIVE_INFO;   // implementation class

class CControlRectTracker : public CRectTracker
{
// Implementation
public:
	CControlRectTracker(LPCRECT lpSrcRect, UINT nStyle)
		: CRectTracker(lpSrcRect, nStyle) { }
	CRect m_rectClip;   // saves the original clipping rectangle
};

class AFX_NOVTABLE COleControl : public CWnd
{
	DECLARE_DYNAMIC(COleControl)

// Constructors
public:
	COleControl();

// Operations

	// Initialization
	void SetInitialSize(int cx, int cy);
	void InitializeIIDs(const IID* piidPrimary, const IID* piidEvents);

	// Invalidating
	void InvalidateControl(LPCRECT lpRect = NULL, BOOL bErase = TRUE);

	// Modified flag
	BOOL IsModified();
	void SetModifiedFlag(BOOL bModified = TRUE);

	// Drawing operations
	void DoSuperclassPaint(CDC* pDC, const CRect& rcBounds);
	BOOL IsOptimizedDraw();

	// Property exchange
	BOOL ExchangeVersion(CPropExchange* pPX, DWORD dwVersionDefault,
		BOOL bConvert = TRUE);
	BOOL ExchangeExtent(CPropExchange* pPX);
	void ExchangeStockProps(CPropExchange* pPX);
	BOOL IsConvertingVBX();

	DWORD SerializeVersion(CArchive& ar, DWORD dwVersionDefault,
		BOOL bConvert = TRUE);
	void SerializeExtent(CArchive& ar);
	void SerializeStockProps(CArchive& ar);

	void ResetVersion(DWORD dwVersionDefault);
	void ResetStockProps();

	// Stock methods
	void Refresh();
	void DoClick();

	// Stock properties
	short GetAppearance();
	void SetAppearance(short);
	OLE_COLOR GetBackColor();
	void SetBackColor(OLE_COLOR);
	short GetBorderStyle();
	void SetBorderStyle(short);
	BOOL GetEnabled();
	void SetEnabled(BOOL);
	CFontHolder& InternalGetFont();
	LPFONTDISP GetFont();
	void SetFont(LPFONTDISP);
	OLE_COLOR GetForeColor();
	void SetForeColor(OLE_COLOR);
	OLE_HANDLE GetHwnd();
	const CString& InternalGetText();
	BSTR GetText();
	void SetText(LPCTSTR);
	long GetReadyState();
	void InternalSetReadyState(long lNewReadyState);

	// Using colors
	COLORREF TranslateColor(OLE_COLOR clrColor, HPALETTE hpal = NULL);

	// Using fonts
	CFont* SelectStockFont(CDC* pDC);
	CFont* SelectFontObject(CDC* pDC, CFontHolder& fontHolder);
	void GetStockTextMetrics(LPTEXTMETRIC lptm);
	void GetFontTextMetrics(LPTEXTMETRIC lptm, CFontHolder& fontHolder);

	// Client site access
	LPOLECLIENTSITE GetClientSite();

	// Generic ambient property access
	BOOL GetAmbientProperty(DISPID dispid, VARTYPE vtProp, void* pvProp);
	BOOL WillAmbientsBeValidDuringLoad();

	// Specific ambient properties
	short AmbientAppearance();
	OLE_COLOR AmbientBackColor();
	CString AmbientDisplayName();
	LPFONTDISP AmbientFont();
	OLE_COLOR AmbientForeColor();
	LCID AmbientLocaleID();
	CString AmbientScaleUnits();
	short AmbientTextAlign();
	BOOL AmbientUserMode();
	BOOL AmbientUIDead();
	BOOL AmbientShowGrabHandles();
	BOOL AmbientShowHatching();

	// Firing events
	void AFX_CDECL FireEvent(DISPID dispid, BYTE* pbParams, ...);

	// Firing functions for stock events
	void FireKeyDown(USHORT* pnChar, short nShiftState);
	void FireKeyUp(USHORT* pnChar, short nShiftState);
	void FireKeyPress(USHORT* pnChar);
	void FireMouseDown(short nButton, short nShiftState,
		OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	void FireMouseUp(short nButton, short nShiftState,
		OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	void FireMouseMove(short nButton, short nShiftState,
		OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	void FireClick();
	void FireDblClick();
	void FireError(SCODE scode, LPCTSTR lpszDescription, UINT nHelpID = 0);
	void FireReadyStateChange();

	// Changing size and/or rectangle
	BOOL GetRectInContainer(LPRECT lpRect);
	BOOL SetRectInContainer(LPCRECT lpRect);
	void GetControlSize(int* pcx, int* pcy);
	BOOL SetControlSize(int cx, int cy);

	// Window management
	void RecreateControlWindow();

	// Modal dialog operations
	void PreModalDialog(HWND hWndParent = NULL);
	void PostModalDialog(HWND hWndParent = NULL);

	// Data binding operations
	void BoundPropertyChanged(DISPID dispid);
	BOOL BoundPropertyRequestEdit(DISPID dispid);

	// Dispatch exceptions
	void ThrowError(SCODE sc, UINT nDescriptionID, UINT nHelpID = -1);
	void ThrowError(SCODE sc, LPCTSTR pszDescription = NULL, UINT nHelpID = 0);
	void GetNotSupported();
	void SetNotSupported();
	void SetNotPermitted();

	// Communication with the control site
	void ControlInfoChanged();
	BOOL LockInPlaceActive(BOOL bLock);
	LPDISPATCH GetExtendedControl();
	void TransformCoords(POINTL* lpptlHimetric,
		POINTF* lpptfContainer, DWORD flags);

	// Simple frame
	void EnableSimpleFrame();

	// Windowless operations
	CWnd* SetCapture();
	BOOL ReleaseCapture();
	CWnd* GetCapture();
	CWnd* SetFocus();
	CWnd* GetFocus();
	CDC* GetDC(LPCRECT lprcRect = NULL, DWORD dwFlags = OLEDC_PAINTBKGND);
	int ReleaseDC(CDC* pDC);
	void InvalidateRgn(CRgn* pRgn, BOOL bErase = TRUE);
	void ScrollWindow(int xAmount, int yAmount, LPCRECT lpRect = NULL,
		LPCRECT lpClipRect = NULL);
	BOOL ClipCaretRect(LPRECT lpRect);
	virtual void GetClientRect(LPRECT lpRect) const;

// Overridables
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	virtual void OnDraw(
				CDC* pDC, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void OnDrawMetafile(CDC* pDC, const CRect& rcBounds);

	// Class ID (implemented by IMPLEMENT_OLECREATE_EX macro)
	virtual HRESULT GetClassID(LPCLSID pclsid) = 0;

	// For customizing the default messages on the status bar
	virtual void GetMessageString(UINT nID, CString& rMessage) const;

	// Display of error events to user
	virtual void DisplayError(SCODE scode, LPCTSTR lpszDescription,
		LPCTSTR lpszSource, LPCTSTR lpszHelpFile, UINT nHelpID);

	// IOleObject notifications
	virtual void OnSetClientSite();
	virtual BOOL OnSetExtent(LPSIZEL lpSizeL);
	virtual void OnClose(DWORD dwSaveOption);

	// IOleInPlaceObject notifications
	virtual BOOL OnSetObjectRects(LPCRECT lpRectPos, LPCRECT lpRectClip);

	// Event connection point notifications
	virtual void OnEventAdvise(BOOL bAdvise);

	// Override to hook firing of Click event
	virtual void OnClick(USHORT iButton);

	// Override to get character after key events have been processed.
	virtual void OnKeyDownEvent(USHORT nChar, USHORT nShiftState);
	virtual void OnKeyUpEvent(USHORT nChar, USHORT nShiftState);
	virtual void OnKeyPressEvent(USHORT nChar);

	// Change notifications
	virtual void OnAppearanceChanged();
	virtual void OnBackColorChanged();
	virtual void OnBorderStyleChanged();
	virtual void OnEnabledChanged();
	virtual void OnTextChanged();
	virtual void OnFontChanged();
	virtual void OnForeColorChanged();

	// IOleControl notifications
	virtual void OnGetControlInfo(LPCONTROLINFO pControlInfo);
	virtual void OnMnemonic(LPMSG pMsg);
	virtual void OnAmbientPropertyChange(DISPID dispid);
	virtual void OnFreezeEvents(BOOL bFreeze);

	// In-place activation
	virtual HMENU OnGetInPlaceMenu();
	virtual void OnShowToolBars();
	virtual void OnHideToolBars();

	// IViewObject
	virtual BOOL OnGetColorSet(DVTARGETDEVICE* ptd, HDC hicTargetDev,
				LPLOGPALETTE* ppColorSet);
	virtual BOOL OnGetViewExtent(DWORD dwDrawAspect, LONG lindex,
		DVTARGETDEVICE* ptd, LPSIZEL lpsizel);
	virtual BOOL OnGetViewRect(DWORD dwAspect, LPRECTL pRect);
	virtual DWORD OnGetViewStatus();
	virtual BOOL OnQueryHitPoint(DWORD dwAspect, LPCRECT pRectBounds,
		POINT ptlLoc, LONG lCloseHint, DWORD* pHitResult);
	virtual BOOL OnQueryHitRect(DWORD dwAspect, LPCRECT pRectBounds,
		LPCRECT prcLoc, LONG lCloseHint, DWORD* pHitResult);
	virtual BOOL OnGetNaturalExtent(DWORD dwAspect, LONG lindex,
		DVTARGETDEVICE* ptd, HDC hicTargetDev, DVEXTENTINFO* pExtentInfo,
		LPSIZEL psizel);

	// IDataObject - see COleDataSource for a description of these overridables
	virtual BOOL OnRenderGlobalData(LPFORMATETC lpFormatEtc, HGLOBAL* phGlobal);
	virtual BOOL OnRenderFileData(LPFORMATETC lpFormatEtc, CFile* pFile);
	virtual BOOL OnRenderData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium);
	virtual BOOL OnSetData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium,
		BOOL bRelease);

	// Verbs
	virtual BOOL OnEnumVerbs(LPENUMOLEVERB* ppenumOleVerb);
	virtual BOOL OnDoVerb(LONG iVerb, LPMSG lpMsg, HWND hWndParent, LPCRECT lpRect);
	virtual BOOL OnEdit(LPMSG lpMsg, HWND hWndParent, LPCRECT lpRect);
	virtual BOOL OnProperties(LPMSG lpMsg, HWND hWndParent, LPCRECT lpRect);

	// IPerPropertyBrowsing overrides
	virtual BOOL OnGetDisplayString(DISPID dispid, CString& strValue);
	virtual BOOL OnMapPropertyToPage(DISPID dispid, LPCLSID lpclsid,
		BOOL* pbPageOptional);
	virtual BOOL OnGetPredefinedStrings(DISPID dispid,
		CStringArray* pStringArray, CDWordArray* pCookieArray);
	virtual BOOL OnGetPredefinedValue(DISPID dispid, DWORD dwCookie,
		VARIANT* lpvarOut);

	// Subclassing
	virtual BOOL IsSubclassedControl();

	// Window reparenting
	virtual void ReparentControlWindow(HWND hWndOuter, HWND hWndParent);

	// Window procedure
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);

	// General-purpose flags
	enum ControlFlags {
		fastBeginPaint      = 0x0001,
		clipPaintDC         = 0x0002,
		pointerInactive     = 0x0004,
		noFlickerActivate   = 0x0008,
		windowlessActivate  = 0x0010,
		canOptimizeDraw     = 0x0020,
	};
	virtual DWORD GetControlFlags();

	// Inactive pointer handling
	virtual DWORD GetActivationPolicy();
	virtual BOOL OnInactiveSetCursor(LPCRECT lprcBounds, long x, long y,
		DWORD dwMouseMsg, BOOL bSetAlways);
	virtual void OnInactiveMouseMove(LPCRECT lprcBounds, long x, long y,
		DWORD dwKeyState);

	// Windowless activation handling
	virtual BOOL OnWindowlessMessage(UINT msg, WPARAM wParam, LPARAM lParam,
		LRESULT* plResult);
	virtual IDropTarget* GetWindowlessDropTarget();

	// Inactive/windowless helper functions
	virtual void GetClientOffset(long* pdxOffset, long* pdyOffset) const;
	virtual UINT ParentToClient(LPCRECT lprcBounds, LPPOINT pPoint,
		BOOL bHitTest = FALSE) const;
	virtual void ClientToParent(LPCRECT lprcBounds, LPPOINT pPoint) const;

	// Asynchronous properties
	void Load(LPCTSTR strNewPath, CDataPathProperty& prop);

// Implementation
public:
	virtual ~COleControl() = 0;
	void RequestAsynchronousExchange(DWORD dwVersion);

#ifdef _DEBUG
	void AssertValid() const;
	void Dump(CDumpContext& dc) const;
#endif // _DEBUG

protected:
	// Friend classes
	friend class COleControlInnerUnknown;
	friend class CReflectorWnd;
	friend class CControlFrameWnd;

	// Interface hook for primary automation interface
	LPUNKNOWN GetInterfaceHook(const void* piid);

	// Shutdown
	virtual void OnFinalRelease();
	void ReleaseCaches();

	// Window management
	virtual BOOL CreateControlWindow(HWND hWndParent, const CRect& rcPos,
		LPCRECT prcClipped = NULL);
	void CreateWindowForSubclassedControl();
	BOOL IgnoreWindowMessage(UINT msg, WPARAM wParam, LPARAM lParam,
		LRESULT* plResult);
	virtual LRESULT DefWindowProc(UINT nMsg, WPARAM wParam, LPARAM lParam);

	// Serialization
	HRESULT SaveState(IStream* pStm);
	HRESULT LoadState(IStream* pStm);
	virtual void Serialize(CArchive& ar);

	// Drawing
	void DrawContent(CDC* pDC, CRect& rc);
	void DrawMetafile(CDC* pDC, CRect& rc);
	BOOL GetMetafileData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium);

	// Implementation of IDataObject
	// CControlDataSource implements OnRender reflections to COleControl
	class CControlDataSource : public COleDataSource
	{
	public:
		CControlDataSource(COleControl* pCtrl);
	protected:
		virtual BOOL OnRenderGlobalData(LPFORMATETC lpFormatEtc, HGLOBAL* phGlobal);
		virtual BOOL OnRenderFileData(LPFORMATETC lpFormatEtc, CFile* pFile);
		virtual BOOL OnRenderData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium);
		virtual BOOL OnSetData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium,
			BOOL bRelease);
		COleControl* m_pCtrl;
	};
	friend class CControlDataSource;

	// IDataObject formats
	CControlDataSource* GetDataSource();
	virtual void SetInitialDataFormats();
	BOOL GetPropsetData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium,
		REFCLSID fmtid);
	BOOL SetPropsetData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium,
		REFCLSID fmtid);

	// Type library
	BOOL GetDispatchIID(IID* pIID);

	// Connection point container
	virtual LPCONNECTIONPOINT GetConnectionHook(REFIID iid);
	virtual BOOL GetExtraConnectionPoints(CPtrArray* pConnPoints);

	// Events
	static const AFX_EVENTMAP_ENTRY _eventEntries[];
#ifdef _AFXDLL
	static const AFX_EVENTMAP* PASCAL GetThisEventMap();
#endif
	virtual const AFX_EVENTMAP* GetEventMap() const;
	static const AFX_EVENTMAP eventMap;
	const AFX_EVENTMAP_ENTRY* GetEventMapEntry(LPCTSTR pszName,
		DISPID* pDispid) const;
	void FireEventV(DISPID dispid, BYTE* pbParams, va_list argList);

	// Stock events
	void KeyDown(USHORT* pnChar);
	void KeyUp(USHORT* pnChar);
	void ButtonDown(USHORT iButton, UINT nFlags, CPoint point);
	void ButtonUp(USHORT iButton, UINT nFlags, CPoint point);
	void ButtonDblClk(USHORT iButton, UINT nFlags, CPoint point);

	// Masks to identify which stock events and properties are used
	void InitStockEventMask();
	void InitStockPropMask();
	DWORD GetStockEventMask() const;
	DWORD GetStockPropMask() const;

	// Support for subclassing a Windows control
	CWnd* GetOuterWindow() const;       // m_pReflect if any, otherwise this
	virtual void OnReflectorDestroyed();

	// Aggregation of default handler
	virtual BOOL OnCreateAggregates();
	LPVOID QueryDefHandler(REFIID iid);

	// State change notifications
	void SendAdvise(UINT uCode);

	// Non-in-place activation
	virtual HRESULT OnOpen(BOOL bTryInPlace, LPMSG pMsg);
#ifdef _AFXDLL
	void ResizeOpenControl(int cx, int cy);
	virtual CControlFrameWnd* CreateFrameWindow();
	virtual void ResizeFrameWindow(int cx, int cy);
	virtual void OnFrameClose();
#endif
	virtual HRESULT OnHide();

	// In-place activation
	virtual HRESULT OnActivateInPlace(BOOL bUIActivate, LPMSG pMsg);
	void ForwardActivationMsg(LPMSG pMsg);
	virtual void AddFrameLevelUI();
	virtual void RemoveFrameLevelUI();
	virtual BOOL BuildSharedMenu();
	virtual void DestroySharedMenu();

	// Property sheet
	virtual LPCLSID GetPropPageIDs(ULONG& cPropPages);

	// IOleObject implementation
	void GetUserType(_Pre_notnull_ _Post_z_ LPTSTR pszUserType);
	virtual UINT GetUserTypeNameID() = 0;
	virtual DWORD GetMiscStatus() = 0;

	// Rectangle tracker
	void CreateTracker(BOOL bHandles, BOOL bHatching);
	void CreateTracker(BOOL bHandles, BOOL bHatching, LPCRECT prcClip);
	void DestroyTracker();

	// Automation
	BOOL IsInvokeAllowed(DISPID dispid);

	// Ambient property interface initialization
	COleDispatchDriver* GetAmbientDispatchDriver();

	// Data members
	const IID* m_piidPrimary;           // IID for control automation
	const IID* m_piidEvents;            // IID for control events
	DWORD m_dwVersionLoaded;            // Version number of loaded state
	COleDispatchDriver m_ambientDispDriver; // Driver for ambient properties
	ULONG m_cEventsFrozen;              // Event freeze count (>0 means frozen)
	union
	{
#ifdef _AFXDLL
		CControlFrameWnd* m_pWndOpenFrame;  // Open frame window.
#endif
		CControlRectTracker* m_pRectTracker;       // Tracker for UI active control
	};
	CRect m_rcPos;                      // Control's position rectangle
	CRect m_rcBounds;                   // Bounding rectangle for drawing
	CPoint m_ptOffset;                  // Child window origin
	long m_cxExtent;                    // Control's width in HIMETRIC units
	long m_cyExtent;                    // Control's height in HIMETRIC units
	class CReflectorWnd* m_pReflect;    // Reflector window
	UINT m_nIDTracking;                 // Tracking command ID or string IDS
	UINT m_nIDLastMessage;              // Last displayed message string IDS
	unsigned m_bAutoMenuEnable : 1;     // Disable menu items without handlers?
	unsigned m_bFinalReleaseCalled : 1; // Are we handling the final Release?
	unsigned m_bModified : 1;           // "Dirty" bit.
	unsigned m_bCountOnAmbients : 1;    // Can we count on Ambients during load?
	unsigned m_iButtonState : 3;        // Which buttons are down?
	unsigned m_iDblClkState : 3;        // Which buttons involved in dbl click?
	unsigned m_bInPlaceActive : 1;      // Are we in-place active?
	unsigned m_bUIActive : 1;           // Are we UI active?
	unsigned m_bPendingUIActivation : 1; // Are we about to become UI active?
#ifdef _AFXDLL
	unsigned m_bOpen : 1;               // Are we open (non-in-place)?
#endif
	unsigned m_bChangingExtent : 1;     // Extent is currently being changed
	unsigned m_bConvertVBX : 1;         // VBX conversion in progress
	unsigned m_bSimpleFrame : 1;        // Simple frame support
	unsigned m_bUIDead : 1;             // UIDead ambient property value
	unsigned m_bInitialized : 1;        // Was IPersist*::{InitNew,Load} called?
	unsigned m_bAutoClip : 1;           // Does container automatically clip?
	unsigned m_bMsgReflect : 1;         // Does container reflect messages?
	unsigned m_bInPlaceSiteEx : 1;      // Extended in-place site?
	unsigned m_bInPlaceSiteWndless : 1; // Windowless in-place site?
	unsigned m_bNoRedraw : 1;           // Should we skip OnPaint this time?
	unsigned m_bOptimizedDraw : 1;      // Is optimized drawing possible?

	// Stock properties
	OLE_COLOR m_clrBackColor;           // BackColor
	OLE_COLOR m_clrForeColor;           // ForeColor
	CString m_strText;                  // Text/Caption
	CFontHolder m_font;                 // Font
	HFONT m_hFontPrev;                  // Previously selected font object
	short m_sAppearance;                // Appearance
	short m_sBorderStyle;               // BorderStyle
	BOOL m_bEnabled;                    // Enabled
	long m_lReadyState;                 // ReadyState

	// UI Active info (shared OLE menu data)
	_AFXCTL_UIACTIVE_INFO* m_pUIActiveInfo;

	// Default Handler aggregation
	LPUNKNOWN m_pDefIUnknown;
	_AFXCTL_ADVISE_INFO* m_pAdviseInfo;
	LPPERSISTSTORAGE m_pDefIPersistStorage;
	LPVIEWOBJECT m_pDefIViewObject;
	LPOLECACHE m_pDefIOleCache;

	// OLE client site interfaces
	LPOLECLIENTSITE m_pClientSite;          // Client site
	union
	{
		LPOLEINPLACESITE m_pInPlaceSite;    // In-place site
		LPOLEINPLACESITEEX m_pInPlaceSiteEx;
		LPOLEINPLACESITEWINDOWLESS m_pInPlaceSiteWndless;
	};
	LPOLECONTROLSITE m_pControlSite;        // Control site
	LPOLEADVISEHOLDER m_pOleAdviseHolder;   // Advise holder
	LPDATAADVISEHOLDER m_pDataAdviseHolder; // Data advise holder
	LPSIMPLEFRAMESITE m_pSimpleFrameSite;   // Simple frame site

	// OLE in-place activation info
	LPOLEINPLACEFRAME m_pInPlaceFrame;
	OLEINPLACEFRAMEINFO m_frameInfo;
	LPOLEINPLACEUIWINDOW m_pInPlaceDoc;

	// OLE data source
	CControlDataSource* m_pDataSource;

	// OLE data path load data
	BOOL m_bDataPathPropertiesLoaded;
	DWORD m_dwDataPathVersionToReport;

// Message Maps
protected:
	//{{AFX_MSG(COleControl)
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnMButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnMButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnRButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnInitMenuPopup(CMenu*, UINT, BOOL);
	afx_msg void OnMenuSelect(UINT nItemID, UINT nFlags, HMENU hSysMenu);
	afx_msg LRESULT OnSetMessageString(WPARAM wParam, LPARAM lParam);
	afx_msg void OnEnterIdle(UINT nWhy, CWnd* pWho);
	afx_msg void OnCancelMode();
	afx_msg void OnPaint(CDC* pDC);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnSysKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg int  OnMouseActivate(CWnd *pDesktopWnd, UINT nHitTest, UINT message);
	afx_msg LRESULT OnSetText(WPARAM wParam, LPARAM lParam);
	afx_msg BOOL OnNcCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg  void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnNcPaint();
	afx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS* lpncsp);
	afx_msg LRESULT OnNcHitTest(CPoint point);
	afx_msg void OnNcLButtonDown(UINT nHitTest, CPoint point);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg UINT OnGetDlgCode();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnMove(int x, int y);
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	//}}AFX_MSG

	afx_msg LRESULT OnOcmCtlColorBtn(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnOcmCtlColorDlg(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnOcmCtlColorEdit(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnOcmCtlColorListBox(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnOcmCtlColorMsgBox(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnOcmCtlColorScrollBar(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnOcmCtlColorStatic(WPARAM wParam, LPARAM lParam);

	DECLARE_MESSAGE_MAP()

	// button handler helpers
	void OnButtonUp(USHORT nButton, UINT nFlags, CPoint point);
	void OnButtonDown(USHORT nButton, UINT nFlags, CPoint point);
	void OnButtonDblClk(USHORT nButton, UINT nFlags, CPoint point);

// Interface Maps
public:
	// IPersistStorage
	BEGIN_INTERFACE_PART(PersistStorage, IPersistStorage)
		INIT_INTERFACE_PART(COleControl, PersistStorage)
		STDMETHOD(GetClassID)(LPCLSID);
		STDMETHOD(IsDirty)();
		STDMETHOD(InitNew)(LPSTORAGE);
		STDMETHOD(Load)(LPSTORAGE);
		STDMETHOD(Save)(LPSTORAGE, BOOL);
		STDMETHOD(SaveCompleted)(LPSTORAGE);
		STDMETHOD(HandsOffStorage)();
	END_INTERFACE_PART_STATIC(PersistStorage)

	// IPersistStreamInit
	BEGIN_INTERFACE_PART(PersistStreamInit, IPersistStreamInit)
		INIT_INTERFACE_PART(COleControl, PersistStreamInit)
		STDMETHOD(GetClassID)(LPCLSID);
		STDMETHOD(IsDirty)();
		STDMETHOD(Load)(LPSTREAM);
		STDMETHOD(Save)(LPSTREAM, BOOL);
		STDMETHOD(GetSizeMax)(ULARGE_INTEGER *);
		STDMETHOD(InitNew)();
	END_INTERFACE_PART_STATIC(PersistStreamInit)

	// IPersistMemory
	BEGIN_INTERFACE_PART(PersistMemory, IPersistMemory)
		INIT_INTERFACE_PART(COleControl, PersistMemory)
		STDMETHOD(GetClassID)(LPCLSID);
		STDMETHOD(IsDirty)();
		STDMETHOD(Load)(LPVOID, ULONG);
		STDMETHOD(Save)(LPVOID, BOOL, ULONG);
		STDMETHOD(GetSizeMax)(ULONG*);
		STDMETHOD(InitNew)();
	END_INTERFACE_PART_STATIC(PersistMemory)

	// IPersistPropertyBag
	BEGIN_INTERFACE_PART(PersistPropertyBag, IPersistPropertyBag)
		INIT_INTERFACE_PART(COleControl, PersistPropertyBag)
		STDMETHOD(GetClassID)(LPCLSID);
		STDMETHOD(InitNew)();
		STDMETHOD(Load)(LPPROPERTYBAG, LPERRORLOG);
		STDMETHOD(Save)(LPPROPERTYBAG, BOOL, BOOL);
	END_INTERFACE_PART_STATIC(PersistPropertyBag)

	// IOleObject
	BEGIN_INTERFACE_PART(OleObject, IOleObject)
		INIT_INTERFACE_PART(COleControl, OleObject)
		STDMETHOD(SetClientSite)(LPOLECLIENTSITE);
		STDMETHOD(GetClientSite)(LPOLECLIENTSITE*);
		STDMETHOD(SetHostNames)(LPCOLESTR, LPCOLESTR);
		STDMETHOD(Close)(DWORD);
		STDMETHOD(SetMoniker)(DWORD, LPMONIKER);
		STDMETHOD(GetMoniker)(DWORD, DWORD, LPMONIKER*);
		STDMETHOD(InitFromData)(LPDATAOBJECT, BOOL, DWORD);
		STDMETHOD(GetClipboardData)(DWORD, LPDATAOBJECT*);
		STDMETHOD(DoVerb)(LONG, LPMSG, LPOLECLIENTSITE, LONG, HWND, LPCRECT);
		STDMETHOD(EnumVerbs)(IEnumOLEVERB**);
		STDMETHOD(Update)();
		STDMETHOD(IsUpToDate)();
		STDMETHOD(GetUserClassID)(CLSID*);
		STDMETHOD(GetUserType)(DWORD, LPOLESTR*);
		STDMETHOD(SetExtent)(DWORD, LPSIZEL);
		STDMETHOD(GetExtent)(DWORD, LPSIZEL);
		STDMETHOD(Advise)(LPADVISESINK, LPDWORD);
		STDMETHOD(Unadvise)(DWORD);
		STDMETHOD(EnumAdvise)(LPENUMSTATDATA*);
		STDMETHOD(GetMiscStatus)(DWORD, LPDWORD);
		STDMETHOD(SetColorScheme)(LPLOGPALETTE);
	END_INTERFACE_PART(OleObject)

	// IViewObjectEx
	BEGIN_INTERFACE_PART(ViewObject, IViewObjectEx)
		INIT_INTERFACE_PART(COleControl, ViewObject)
		STDMETHOD(Draw)(DWORD, LONG, void*, DVTARGETDEVICE*, HDC, HDC,
			LPCRECTL, LPCRECTL, BOOL (CALLBACK*)(DWORD_PTR), DWORD_PTR);
		STDMETHOD(GetColorSet)(DWORD, LONG, void*, DVTARGETDEVICE*,
			HDC, LPLOGPALETTE*);
		STDMETHOD(Freeze)(DWORD, LONG, void*, DWORD*);
		STDMETHOD(Unfreeze)(DWORD);
		STDMETHOD(SetAdvise)(DWORD, DWORD, LPADVISESINK);
		STDMETHOD(GetAdvise)(DWORD*, DWORD*, LPADVISESINK*);
		STDMETHOD(GetExtent) (DWORD, LONG, DVTARGETDEVICE*, LPSIZEL);
		STDMETHOD(GetRect)(DWORD, LPRECTL);
		STDMETHOD(GetViewStatus)(DWORD*);
		STDMETHOD(QueryHitPoint)(DWORD, LPCRECT, POINT, LONG, DWORD*);
		STDMETHOD(QueryHitRect)(DWORD, LPCRECT, LPCRECT, LONG, DWORD*);
		STDMETHOD(GetNaturalExtent)(DWORD, LONG, DVTARGETDEVICE*, HDC,
			DVEXTENTINFO*, LPSIZEL);
	END_INTERFACE_PART(ViewObject)

	// IDataObject
	BEGIN_INTERFACE_PART(DataObject, IDataObject)
		INIT_INTERFACE_PART(COleControl, DataObject)
		STDMETHOD(GetData)(LPFORMATETC, LPSTGMEDIUM);
		STDMETHOD(GetDataHere)(LPFORMATETC, LPSTGMEDIUM);
		STDMETHOD(QueryGetData)(LPFORMATETC);
		STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC, LPFORMATETC);
		STDMETHOD(SetData)(LPFORMATETC, LPSTGMEDIUM, BOOL);
		STDMETHOD(EnumFormatEtc)(DWORD, LPENUMFORMATETC*);
		STDMETHOD(DAdvise)(LPFORMATETC, DWORD, LPADVISESINK, LPDWORD);
		STDMETHOD(DUnadvise)(DWORD);
		STDMETHOD(EnumDAdvise)(LPENUMSTATDATA*);
	END_INTERFACE_PART_STATIC(DataObject)

	// IOleInPlaceObject
	BEGIN_INTERFACE_PART(OleInPlaceObject, IOleInPlaceObjectWindowless)
		INIT_INTERFACE_PART(COleControl, OleInPlaceObject)
		STDMETHOD(GetWindow)(HWND*);
		STDMETHOD(ContextSensitiveHelp)(BOOL);
		STDMETHOD(InPlaceDeactivate)();
		STDMETHOD(UIDeactivate)();
		STDMETHOD(SetObjectRects)(LPCRECT, LPCRECT);
		STDMETHOD(ReactivateAndUndo)();
		STDMETHOD(OnWindowMessage)(UINT msg, WPARAM wParam, LPARAM lparam,
			LRESULT* plResult);
		STDMETHOD(GetDropTarget)(IDropTarget **ppDropTarget);
	END_INTERFACE_PART(OleInPlaceObject)

	// IOleInPlaceActiveObject
	BEGIN_INTERFACE_PART(OleInPlaceActiveObject, IOleInPlaceActiveObject)
		INIT_INTERFACE_PART(COleControl, OleInPlaceActiveObject)
		STDMETHOD(GetWindow)(HWND*);
		STDMETHOD(ContextSensitiveHelp)(BOOL);
		STDMETHOD(TranslateAccelerator)(LPMSG);
		STDMETHOD(OnFrameWindowActivate)(BOOL);
		STDMETHOD(OnDocWindowActivate)(BOOL);
		STDMETHOD(ResizeBorder)(LPCRECT, LPOLEINPLACEUIWINDOW, BOOL);
		STDMETHOD(EnableModeless)(BOOL);
	END_INTERFACE_PART(OleInPlaceActiveObject)

	// IOleCache
	BEGIN_INTERFACE_PART(OleCache, IOleCache)
		INIT_INTERFACE_PART(COleControl, OleCache)
		STDMETHOD(Cache)(LPFORMATETC, DWORD, LPDWORD);
		STDMETHOD(Uncache)(DWORD);
		STDMETHOD(EnumCache)(LPENUMSTATDATA*);
		STDMETHOD(InitCache)(LPDATAOBJECT);
		STDMETHOD(SetData)(LPFORMATETC, STGMEDIUM*, BOOL);
	END_INTERFACE_PART_STATIC(OleCache)

	// IOleControl
	BEGIN_INTERFACE_PART(OleControl, IOleControl)
		INIT_INTERFACE_PART(COleControl, OleControl)
		STDMETHOD(GetControlInfo)(LPCONTROLINFO pCI);
		STDMETHOD(OnMnemonic)(LPMSG pMsg);
		STDMETHOD(OnAmbientPropertyChange)(DISPID dispid);
		STDMETHOD(FreezeEvents)(BOOL bFreeze);
	END_INTERFACE_PART(OleControl)

	// IProvideClassInfo2
	BEGIN_INTERFACE_PART(ProvideClassInfo, IProvideClassInfo2)
		INIT_INTERFACE_PART(COleControl, ProvideClassInfo)
		STDMETHOD(GetClassInfo)(LPTYPEINFO* ppTypeInfo);
		STDMETHOD(GetGUID)(DWORD dwGuidKind, GUID* pGUID);
	END_INTERFACE_PART_STATIC(ProvideClassInfo)

	// ISpecifyPropertyPages
	BEGIN_INTERFACE_PART(SpecifyPropertyPages, ISpecifyPropertyPages)
		INIT_INTERFACE_PART(COleControl, SpecifyPropertyPages)
		STDMETHOD(GetPages)(CAUUID*);
	END_INTERFACE_PART_STATIC(SpecifyPropertyPages)

	// IPerPropertyBrowsing
	BEGIN_INTERFACE_PART(PerPropertyBrowsing, IPerPropertyBrowsing)
		INIT_INTERFACE_PART(COleControl, PerPropertyBrowsing)
		STDMETHOD(GetDisplayString)(DISPID dispid, BSTR* lpbstr);
		STDMETHOD(MapPropertyToPage)(DISPID dispid, LPCLSID lpclsid);
		STDMETHOD(GetPredefinedStrings)(DISPID dispid,
			CALPOLESTR* lpcaStringsOut, CADWORD* lpcaCookiesOut);
		STDMETHOD(GetPredefinedValue)(DISPID dispid, DWORD dwCookie,
			VARIANT* lpvarOut);
	END_INTERFACE_PART_STATIC(PerPropertyBrowsing)

	// IPropertyNotifySink for font updates (not exposed via QueryInterface)
	BEGIN_INTERFACE_PART(FontNotification, IPropertyNotifySink)
		INIT_INTERFACE_PART(COleControl, FontNotification)
		STDMETHOD(OnChanged)(DISPID dispid);
		STDMETHOD(OnRequestEdit)(DISPID dispid);
	END_INTERFACE_PART_STATIC(FontNotification)

	// IQuickActivate
	BEGIN_INTERFACE_PART(QuickActivate, IQuickActivate)
		STDMETHOD(QuickActivate)(QACONTAINER *pQAContainer, QACONTROL *pqacontrol);
		STDMETHOD(SetContentExtent)(LPSIZEL lpsizel);
		STDMETHOD(GetContentExtent)(LPSIZEL lpsizel);
	END_INTERFACE_PART_STATIC(QuickActivate)

	// IPointerInactive
	BEGIN_INTERFACE_PART(PointerInactive, IPointerInactive)
		STDMETHOD(GetActivationPolicy)(DWORD* pdwPolicy);
		STDMETHOD(OnInactiveSetCursor)(LPCRECT lprcBounds, long x, long y,
			DWORD dwMouseMsg, BOOL bSetAlways);
		STDMETHOD(OnInactiveMouseMove)(LPCRECT lprcBounds, long x, long y,
			DWORD dwKeyState);
	END_INTERFACE_PART_STATIC(PointerInactive)

	DECLARE_INTERFACE_MAP()

// Connection maps
protected:
	// Connection point for events
	BEGIN_CONNECTION_PART(COleControl, EventConnPt)
		virtual void OnAdvise(BOOL bAdvise);
		virtual REFIID GetIID();
		virtual HRESULT QuerySinkInterface(LPUNKNOWN pUnkSink, 
			void** ppInterface);
	END_CONNECTION_PART(EventConnPt)

	// Connection point for property notifications
	BEGIN_CONNECTION_PART(COleControl, PropConnPt)
		CONNECTION_IID(IID_IPropertyNotifySink)
	END_CONNECTION_PART(PropConnPt)

	DECLARE_CONNECTION_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// Registry functions

BOOL AFXAPI AfxOleRegisterControlClass(HINSTANCE hInstance, REFCLSID clsid,
	LPCTSTR pszProgID, UINT idTypeName, UINT idBitmap, int nRegFlags,
	DWORD dwMiscStatus, REFGUID tlid, WORD wVerMajor, WORD wVerMinor);

BOOL AFXAPI AfxOleUnregisterClass(REFCLSID clsid, LPCTSTR pszProgID);

BOOL AFXAPI AfxOleRegisterPropertyPageClass(HINSTANCE hInstance,
	REFCLSID clsid, UINT idTypeName);

BOOL AFXAPI AfxOleRegisterPropertyPageClass(HINSTANCE hInstance,
	REFCLSID clsid, UINT idTypeName, int nRegFlags);

/////////////////////////////////////////////////////////////////////////////
// Licensing functions

BOOL AFXAPI AfxVerifyLicFile(HINSTANCE hInstance, LPCTSTR pszLicFileName,
	LPCOLESTR pszLicFileContents, UINT cch=-1);

/////////////////////////////////////////////////////////////////////////////
// CPropExchange - Abstract base class for property exchange

class AFX_NOVTABLE CPropExchange
{
// Operations
public:
	BOOL IsLoading();
	DWORD GetVersion();

	BOOL IsAsynchronous();
	// FALSE -> Do Sync stuff, and start async stuff if possible
	// TRUE -> Do not do Sync stuff.  Always start Async stuff

	virtual BOOL ExchangeVersion(DWORD& dwVersionLoaded, DWORD dwVersionDefault,
		BOOL bConvert);

	virtual BOOL ExchangeProp(LPCTSTR pszPropName, VARTYPE vtProp,
				void* pvProp, const void* pvDefault = NULL) = 0;
	virtual BOOL ExchangeBlobProp(LPCTSTR pszPropName, HGLOBAL* phBlob,
				HGLOBAL hBlobDefault = NULL) = 0;
	virtual BOOL ExchangeFontProp(LPCTSTR pszPropName, CFontHolder& font,
				const FONTDESC* pFontDesc,
				LPFONTDISP pFontDispAmbient) = 0;
	virtual BOOL ExchangePersistentProp(LPCTSTR pszPropName,
				LPUNKNOWN* ppUnk, REFIID iid, LPUNKNOWN pUnkDefault) = 0;

// Implementation
public:
   virtual ~CPropExchange() = 0 { }
protected:
	CPropExchange();
	BOOL m_bLoading;
	BOOL m_bAsync;
	DWORD m_dwVersion;
};

/////////////////////////////////////////////////////////////////////////////
// Property-exchange (PX_) helper functions

BOOL AFX_CDECL PX_Short(CPropExchange* pPX, LPCTSTR pszPropName, short& sValue);

BOOL AFX_CDECL PX_Short(CPropExchange* pPX, LPCTSTR pszPropName, short& sValue,
	short sDefault);

BOOL AFX_CDECL PX_UShort(CPropExchange* pPX, LPCTSTR pszPropName, USHORT& usValue);

BOOL AFX_CDECL PX_UShort(CPropExchange* pPX, LPCTSTR pszPropName, USHORT& usValue,
	USHORT usDefault);

BOOL AFX_CDECL PX_Long(CPropExchange* pPX, LPCTSTR pszPropName, long& lValue);

BOOL AFX_CDECL PX_Long(CPropExchange* pPX, LPCTSTR pszPropName, long& lValue,
	long lDefault);

BOOL AFX_CDECL PX_ULong(CPropExchange* pPX, LPCTSTR pszPropName, ULONG& ulValue);

BOOL AFX_CDECL PX_ULong(CPropExchange* pPX, LPCTSTR pszPropName, ULONG& ulValue,
	ULONG ulDefault);

BOOL AFX_CDECL PX_Color(CPropExchange* pPX, LPCTSTR pszPropName, OLE_COLOR& clrValue);

BOOL AFX_CDECL PX_Color(CPropExchange* pPX, LPCTSTR pszPropName, OLE_COLOR& clrValue,
	OLE_COLOR clrDefault);

BOOL AFX_CDECL PX_Bool(CPropExchange* pPX, LPCTSTR pszPropName, BOOL& bValue);

BOOL AFX_CDECL PX_Bool(CPropExchange* pPX, LPCTSTR pszPropName, BOOL& bValue,
	BOOL bDefault);

BOOL AFX_CDECL PX_String(CPropExchange* pPX, LPCTSTR pszPropName, CString& strValue);

BOOL AFX_CDECL PX_String(CPropExchange* pPX, LPCTSTR pszPropName, CString& strValue,
	const CString& strDefault);
BOOL AFX_CDECL PX_String(CPropExchange* pPX, LPCTSTR pszPropName, CString& strValue,
	LPCTSTR lpszDefault);

BOOL AFX_CDECL PX_Currency(CPropExchange* pPX, LPCTSTR pszPropName, CY& cyValue);

BOOL AFX_CDECL PX_Currency(CPropExchange* pPX, LPCTSTR pszPropName, CY& cyValue,
	CY cyDefault);

BOOL AFX_CDECL PX_Float(CPropExchange* pPX, LPCTSTR pszPropName, float& floatValue);

BOOL AFX_CDECL PX_Float(CPropExchange* pPX, LPCTSTR pszPropName, float& floatValue,
	float floatDefault);

BOOL AFX_CDECL PX_Double(CPropExchange* pPX, LPCTSTR pszPropName, double& doubleValue);

BOOL AFX_CDECL PX_Double(CPropExchange* pPX, LPCTSTR pszPropName, double& doubleValue,
	double doubleDefault);

BOOL AFX_CDECL PX_Blob(CPropExchange* pPX, LPCTSTR pszPropName, HGLOBAL& hBlob,
	HGLOBAL hBlobDefault = NULL);

BOOL AFX_CDECL PX_Font(CPropExchange* pPX, LPCTSTR pszPropName, CFontHolder& font,
	const FONTDESC* pFontDesc = NULL,
	LPFONTDISP pFontDispAmbient = NULL);

BOOL AFX_CDECL PX_Picture(CPropExchange* pPX, LPCTSTR pszPropName,
	CPictureHolder& pict);

BOOL AFX_CDECL PX_Picture(CPropExchange* pPX, LPCTSTR pszPropName,
	CPictureHolder& pict, CPictureHolder& pictDefault);

BOOL AFX_CDECL PX_IUnknown(CPropExchange* pPX, LPCTSTR pszPropName, LPUNKNOWN& pUnk,
	REFIID iid, LPUNKNOWN pUnkDefault = NULL);

BOOL AFX_CDECL PX_VBXFontConvert(CPropExchange* pPX, CFontHolder& font);

BOOL AFX_CDECL PX_DataPath(CPropExchange* pPX, LPCTSTR pszPropName,
	CDataPathProperty& dataPathProp, LPCTSTR pszDefault = NULL);

BOOL AFX_CDECL PX_DataPath(CPropExchange* pPX, LPCTSTR pszPropName,
	CDataPathProperty& dataPathProp, const CString& strDefault);

/////////////////////////////////////////////////////////////////////////////
// Structures used by COlePropertyPage

typedef struct tagAFX_PPFIELDSTATUS
{
	UINT    nID;
	BOOL    bDirty;

} AFX_PPFIELDSTATUS;

/////////////////////////////////////////////////////////////////////////////
// Property Page Dialog Class

class AFX_NOVTABLE COlePropertyPage : public CDialog
{
	DECLARE_DYNAMIC(COlePropertyPage)

// Constructors
public:
	COlePropertyPage(UINT idDlg, UINT idCaption);

// Operations
	LPDISPATCH* GetObjectArray(ULONG* pnObjects);
	void SetModifiedFlag(BOOL bModified = TRUE);
	BOOL IsModified();
	LPPROPERTYPAGESITE GetPageSite();
	void SetDialogResource(HGLOBAL hDialog);
	void SetPageName(LPCTSTR lpszPageName);
	void SetHelpInfo(LPCTSTR lpszDocString, LPCTSTR lpszHelpFile = NULL,
		DWORD dwHelpContext = 0);

	BOOL GetControlStatus(UINT nID);
	BOOL SetControlStatus(UINT nID, BOOL bDirty);
	void IgnoreApply(UINT nID);

#pragma push_macro("MessageBox")
#undef MessageBox
	// note that these are non-virtual overrides of CWnd::MessageBox()
	int _AFX_FUNCNAME(MessageBox)(LPCTSTR lpszText, LPCTSTR lpszCaption = NULL,
			UINT nType = MB_OK);

	int MessageBox(LPCTSTR lpszText, LPCTSTR lpszCaption = NULL,
			UINT nType = MB_OK);
#pragma pop_macro("MessageBox")

// Overridables
	virtual void OnSetPageSite();
	virtual void OnObjectsChanged();
	virtual BOOL OnHelp(LPCTSTR lpszHelpDir);
	virtual BOOL OnInitDialog();
	virtual BOOL OnEditProperty(DISPID dispid);

// Implementation

	// DDP_ property get/set helper routines
	BOOL SetPropText(LPCTSTR pszPropName, BYTE &Value);
	BOOL GetPropText(LPCTSTR pszPropName, BYTE* pValue);
	BOOL SetPropText(LPCTSTR pszPropName, short &Value);
	BOOL GetPropText(LPCTSTR pszPropName, short* pValue);
	BOOL SetPropText(LPCTSTR pszPropName, int &Value);
	BOOL GetPropText(LPCTSTR pszPropName, int* pValue);
	BOOL SetPropText(LPCTSTR pszPropName, UINT &Value);
	BOOL GetPropText(LPCTSTR pszPropName, UINT* pValue);
	BOOL SetPropText(LPCTSTR pszPropName, long &Value);
	BOOL GetPropText(LPCTSTR pszPropName, long* pValue);
	BOOL SetPropText(LPCTSTR pszPropName, DWORD &Value);
	BOOL GetPropText(LPCTSTR pszPropName, DWORD* pValue);
	BOOL SetPropText(LPCTSTR pszPropName, CString &Value);
	BOOL GetPropText(LPCTSTR pszPropName, CString* pValue);
	BOOL SetPropText(LPCTSTR pszPropName, float &Value);
	BOOL GetPropText(LPCTSTR pszPropName, float* pValue);
	BOOL SetPropText(LPCTSTR pszPropName, double &Value);
	BOOL GetPropText(LPCTSTR pszPropName, double* pValue);
	BOOL SetPropCheck(LPCTSTR pszPropName, int Value);
	BOOL GetPropCheck(LPCTSTR pszPropName, int* pValue);
	BOOL SetPropRadio(LPCTSTR pszPropName, int Value);
	BOOL GetPropRadio(LPCTSTR pszPropName, int* pValue);
	BOOL SetPropIndex(LPCTSTR pszPropName, int Value);
	BOOL GetPropIndex(LPCTSTR pszPropName, int* pValue);
	CPtrArray m_arrayDDP;      // pending DDP data

	// Destructors
	virtual ~COlePropertyPage() = 0;

protected:
	LRESULT WindowProc(UINT msg, WPARAM wParam, LPARAM lParam);
	BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	BOOL PreTranslateMessage(LPMSG lpMsg);
	virtual void OnFinalRelease();
	void CleanupObjectArray();
	static BOOL CALLBACK EnumChildProc(HWND hWnd, LPARAM lParam);
	static BOOL CALLBACK EnumControls(HWND hWnd, LPARAM lParam);

private:
	BOOL m_bDirty;
	UINT m_idDlg;
	UINT m_idCaption;
	CString m_strPageName;
	SIZE m_sizePage;
	CString m_strDocString;
	CString m_strHelpFile;
	DWORD m_dwHelpContext;
	LPPROPERTYPAGESITE m_pPageSite;

	LPDISPATCH* m_ppDisp;   // Array of IDispatch pointers, used to
								// access the properties of each control

	LPDWORD m_pAdvisors;        // Array of connection tokens used by
								// IConnecitonPoint::Advise/UnAdvise.

	BOOL m_bPropsChanged;       // IPropertyNotifySink::OnChanged has been
								// called, but not acted upon yet.

	ULONG m_nObjects;           // Objects in m_ppDisp, m_ppDataObj, m_pAdvisors

	BOOL m_bInitializing;       // TRUE if the contents of the fields of
								// the dialog box are being initialized

	int m_nControls;            // Number of fields on this property page

	AFX_PPFIELDSTATUS* m_pStatus;   // Array containing information on
									// which fields are dirty

	CDWordArray m_IDArray;      // Array containing information on which
								// controls to ignore when deciding if
								// the apply button is to be enabled

	HGLOBAL m_hDialog;          // Handle of the dialog resource

#ifdef _DEBUG
protected:
	BOOL m_bNonStandardSize;
#endif

protected:
	// Generated message map functions
	//{{AFX_MSG(COlePropertyPage)
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Interface Maps
public:
	BEGIN_INTERFACE_PART(PropertyPage, IPropertyPage2)
		INIT_INTERFACE_PART(COlePropertyPage, PropertyPage)
		STDMETHOD(SetPageSite)(LPPROPERTYPAGESITE);
		STDMETHOD(Activate)(HWND, LPCRECT, BOOL);
		STDMETHOD(Deactivate)();
		STDMETHOD(GetPageInfo)(LPPROPPAGEINFO);
		STDMETHOD(SetObjects)(ULONG, LPUNKNOWN*);
		STDMETHOD(Show)(UINT);
		STDMETHOD(Move)(LPCRECT);
		STDMETHOD(IsPageDirty)();
		STDMETHOD(Apply)();
		STDMETHOD(Help)(LPCOLESTR);
		STDMETHOD(TranslateAccelerator)(LPMSG);
		STDMETHOD(EditProperty)(DISPID);
	END_INTERFACE_PART(PropertyPage)

	BEGIN_INTERFACE_PART(PropNotifySink, IPropertyNotifySink)
		INIT_INTERFACE_PART(COlePropertyPage, PropNotifySink)
		STDMETHOD(OnRequestEdit)(DISPID);
		STDMETHOD(OnChanged)(DISPID);
	END_INTERFACE_PART(PropNotifySink)

	DECLARE_INTERFACE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// Property Page Dialog Data Exchange routines

// simple text operations
void AFXAPI DDP_Text(CDataExchange*pDX, int id, BYTE& member, LPCTSTR pszPropName);
void AFXAPI DDP_Text(CDataExchange*pDX, int id, short& member, LPCTSTR pszPropName);
void AFXAPI DDP_Text(CDataExchange*pDX, int id, int& member, LPCTSTR pszPropName);
void AFXAPI DDP_Text(CDataExchange*pDX, int id, UINT& member, LPCTSTR pszPropName);
void AFXAPI DDP_Text(CDataExchange*pDX, int id, long& member, LPCTSTR pszPropName);
void AFXAPI DDP_Text(CDataExchange*pDX, int id, DWORD& member, LPCTSTR pszPropName);
void AFXAPI DDP_Text(CDataExchange*pDX, int id, float& member, LPCTSTR pszPropName);
void AFXAPI DDP_Text(CDataExchange*pDX, int id, double& member, LPCTSTR pszPropName);
void AFXAPI DDP_Text(CDataExchange*pDX, int id, CString& member, LPCTSTR pszPropName);
void AFXAPI DDP_Check(CDataExchange*pDX, int id, int& member, LPCTSTR pszPropName);
void AFXAPI DDP_Radio(CDataExchange*pDX, int id, int& member, LPCTSTR pszPropName);
void AFXAPI DDP_LBString(CDataExchange* pDX, int id, CString& member, LPCTSTR pszPropName);
void AFXAPI DDP_LBStringExact(CDataExchange* pDX, int id, CString& member, LPCTSTR pszPropName);
void AFXAPI DDP_LBIndex(CDataExchange* pDX, int id, int& member, LPCTSTR pszPropName);
void AFXAPI DDP_CBString(CDataExchange* pDX, int id, CString& member, LPCTSTR pszPropName);
void AFXAPI DDP_CBStringExact(CDataExchange* pDX, int id, CString& member, LPCTSTR pszPropName);
void AFXAPI DDP_CBIndex(CDataExchange* pDX, int id, int& member, LPCTSTR pszPropName);
void AFXAPI DDP_PostProcessing(CDataExchange *pDX);

////////////////////////////////////////////////////////////////////////////
// AfxOleTypeMatchGuid - Tests whether a given TYPEDESC matches a type with a
// given GUID, when all aliases have been expanded.

BOOL AFXAPI AfxOleTypeMatchGuid(LPTYPEINFO pTypeInfo,
	TYPEDESC* pTypeDesc, REFGUID guidType, ULONG cIndirectionLevels);

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXCTL_INLINE AFX_INLINE
#include <afxctl.inl>
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif // __AFXCTL_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxctl.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXCTL.H

#pragma once

#ifdef _AFXCTL_INLINE

/////////////////////////////////////////////////////////////////////////////

// COleControl inlines
_AFXCTL_INLINE BOOL COleControl::IsOptimizedDraw()
	{ return m_bOptimizedDraw; }
_AFXCTL_INLINE BOOL COleControl::IsConvertingVBX()
	{ return m_bConvertVBX; }
_AFXCTL_INLINE void COleControl::FireKeyDown(USHORT* pnChar, short nShiftState)
	{ FireEvent(DISPID_KEYDOWN, EVENT_PARAM(VTS_PI2 VTS_I2), pnChar,
		nShiftState); }
_AFXCTL_INLINE void COleControl::FireKeyUp(USHORT* pnChar, short nShiftState)
	{ FireEvent(DISPID_KEYUP, EVENT_PARAM(VTS_PI2 VTS_I2), pnChar,
		nShiftState); }
_AFXCTL_INLINE void COleControl::FireKeyPress(USHORT* pnChar)
	{ FireEvent(DISPID_KEYPRESS, EVENT_PARAM(VTS_PI2), pnChar); }
_AFXCTL_INLINE void COleControl::FireMouseDown(short nButton,
		short nShiftState, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y)
	{ FireEvent(DISPID_MOUSEDOWN,
		EVENT_PARAM(VTS_I2 VTS_I2 VTS_XPOS_PIXELS VTS_YPOS_PIXELS),
		nButton, nShiftState, x, y); }
_AFXCTL_INLINE void COleControl::FireMouseUp(short nButton,
		short nShiftState, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y)
	{ FireEvent(DISPID_MOUSEUP,
		EVENT_PARAM(VTS_I2 VTS_I2 VTS_XPOS_PIXELS VTS_YPOS_PIXELS),
		nButton, nShiftState, x, y); }
_AFXCTL_INLINE void COleControl::FireMouseMove(short nButton,
		short nShiftState, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y)
	{ FireEvent(DISPID_MOUSEMOVE,
		EVENT_PARAM(VTS_I2 VTS_I2 VTS_XPOS_PIXELS VTS_YPOS_PIXELS),
		nButton, nShiftState, x, y); }
_AFXCTL_INLINE void COleControl::FireClick()
	{ FireEvent(DISPID_CLICK, EVENT_PARAM(VTS_NONE)); }
_AFXCTL_INLINE void COleControl::FireDblClick()
	{ FireEvent(DISPID_DBLCLICK, EVENT_PARAM(VTS_NONE)); }
_AFXCTL_INLINE void COleControl::FireReadyStateChange()
	{ FireEvent(DISPID_READYSTATECHANGE, EVENT_PARAM(VTS_I4), m_lReadyState); }
_AFXCTL_INLINE void COleControl::InternalSetReadyState(long lNewReadyState)
	{ ASSERT((lNewReadyState >=0) && (lNewReadyState <= READYSTATE_COMPLETE));
	  if (m_lReadyState != lNewReadyState)
		{m_lReadyState = lNewReadyState; FireReadyStateChange(); } }
_AFXCTL_INLINE BOOL COleControl::ExchangeVersion(
	CPropExchange* pPX, DWORD dwVersionDefault, BOOL bConvert)
	{ return pPX->ExchangeVersion(m_dwVersionLoaded, dwVersionDefault, bConvert); }
_AFXCTL_INLINE DWORD COleControl::GetStockEventMask() const
	{ return *GetEventMap()->lpStockEventMask; }
_AFXCTL_INLINE DWORD COleControl::GetStockPropMask() const
	{ return *GetDispatchMap()->lpStockPropMask; }
_AFXCTL_INLINE void COleControl::RequestAsynchronousExchange(DWORD dwVersion)
	{ m_bDataPathPropertiesLoaded = FALSE; m_dwDataPathVersionToReport = dwVersion; }

// CPropExchange inlines
_AFXCTL_INLINE CPropExchange::CPropExchange() : m_dwVersion(0), m_bAsync(FALSE)
	{ }
_AFXCTL_INLINE BOOL CPropExchange::IsLoading()
	{ return m_bLoading; }
_AFXCTL_INLINE DWORD CPropExchange::GetVersion()
	{ return m_dwVersion; }
_AFXCTL_INLINE BOOL CPropExchange::IsAsynchronous()
	{ return m_bAsync; }

// COlePropertyPage inlines
#pragma push_macro("MessageBox")
#undef MessageBox
_AFXCTL_INLINE int COlePropertyPage::MessageBox(LPCTSTR lpszText, LPCTSTR lpszCaption, UINT nType)
	{
		return _AFX_FUNCNAME(MessageBox)(lpszText, lpszCaption, nType);
	}
#pragma pop_macro("MessageBox")

// CDataPathProperty inlines
_AFXCTL_INLINE CDataPathProperty::CDataPathProperty(COleControl* pControl)
	: m_pControl(pControl) {}
_AFXCTL_INLINE CDataPathProperty::CDataPathProperty(LPCTSTR lpszPath, COleControl* pControl)
	: m_pControl(pControl), m_strPath(lpszPath) {}
_AFXCTL_INLINE void CDataPathProperty::SetPath(LPCTSTR lpszPath)
	{ ASSERT_VALID(this); m_strPath = lpszPath; }
_AFXCTL_INLINE CString CDataPathProperty::GetPath() const
	{ ASSERT_VALID(this); return m_strPath; }
_AFXCTL_INLINE COleControl* CDataPathProperty::GetControl()
	{ ASSERT_VALID(this); return m_pControl; }
_AFXCTL_INLINE void CDataPathProperty::SetControl(COleControl* pControl)
	{ ASSERT_VALID(this); m_pControl=pControl; }

// CCachedDataPathProperty inlines
_AFXCTL_INLINE CCachedDataPathProperty::CCachedDataPathProperty(COleControl* pControl)
	: CDataPathProperty(pControl) {}
_AFXCTL_INLINE CCachedDataPathProperty::CCachedDataPathProperty(LPCTSTR lpszPath, COleControl* pControl)
	: CDataPathProperty(lpszPath, pControl) {}

// inline DDP_ routines
_AFXCTL_INLINE void AFXAPI DDP_LBString(CDataExchange* pDX, int id,
		CString& member, LPCTSTR pszPropName)
	{ DDP_Text(pDX, id, member, pszPropName); }
_AFXCTL_INLINE void AFXAPI DDP_LBStringExact(CDataExchange* pDX, int id,
		CString& member, LPCTSTR pszPropName)
	{ DDP_Text(pDX, id, member, pszPropName); }
_AFXCTL_INLINE void AFXAPI DDP_LBIndex(CDataExchange* pDX, int id,
		int& member, LPCTSTR pszPropName)
	{ DDP_Text(pDX, id, member, pszPropName); }
_AFXCTL_INLINE void AFXAPI DDP_CBString(CDataExchange* pDX, int id,
		CString& member, LPCTSTR pszPropName)
	{ DDP_Text(pDX, id, member, pszPropName); }
_AFXCTL_INLINE void AFXAPI DDP_CBStringExact(CDataExchange* pDX, int id,
		CString& member, LPCTSTR pszPropName)
	{ DDP_Text(pDX, id, member, pszPropName); }
_AFXCTL_INLINE void AFXAPI DDP_CBIndex(CDataExchange* pDX, int id,
		int& member, LPCTSTR pszPropName)
	{ DDP_Text(pDX, id, member, pszPropName); }

#endif //_AFXCTL_INLINE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxctrlcontainer.h ===
// CWnd support for MFC Control containment (Feature Pack controls)
//

#pragma once

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

////////////////////////////////////////////////////////////////////////////

void AfxRegisterMFCCtrlClasses();

class CTagManager;

/////////////////////////////////////////////////////////////////////////////
// CMFCControlContainer

class CMFCControlContainer : public CObject
{
public:
// Constructor
	CMFCControlContainer(CWnd* pWnd);
	virtual ~CMFCControlContainer();

// Operations
	BOOL SubclassDlgControls();
	void FreeSubclassedControls();

	BOOL IsSubclassedFeaturePackControl(HWND hWndCtrl);
	BOOL ReSubclassControl(HWND hWndCtrl, WORD nIDC, CWnd& control);

	void SetControlData(WORD nIDC, DWORD dwSize, BYTE* pbData);
	BOOL GetControlData(WORD nIDC, DWORD& dwSize, BYTE*& pbData);
	void ClearControlData();

	static int __stdcall UTF8ToString(LPCSTR lpSrc, CString& strDst, int nLength);
	static BOOL __stdcall ReadBoolProp(CTagManager& tagManager, LPCTSTR lpszTag, BOOL& bMember);

// Attributes
	CWnd* m_pWnd;
	CObArray m_arSubclassedCtrls;

protected:
	CMapWordToOb m_mapControlData;

// Implementation
protected:
	CWnd* CreateDlgControl(LPCTSTR lpszClassName);
	void PreUnsubclassControl(CWnd* pControl);
};

////////////////////////////////////////////////////////////////////////////

// wParam - DWORD dwSize
// lParam - BYTE* pbInitData

#define MFC_BTN_STYLE_3D            4
#define MFC_BTN_STYLE_FLAT          5
#define MFC_BTN_STYLE_NOBORDERS     6
#define MFC_BTN_MODE_STYLE_SEMIFLAT 7
#define MFC_BTN_IMAGETYPE_NONE      8
#define MFC_BTN_IMAGETYPE_ICON      9
#define MFC_BTN_IMAGETYPE_BITMAP    10
#define MFC_BTN_CURSORTYPE_NONE     11
#define MFC_BTN_CURSORTYPE_HAND     12
#define MFC_BTN_CURSORTYPE_CUSTOM   13

#define MFC_EB_MODE_NONE    0
#define MFC_EB_MODE_FILE    1
#define MFC_EB_MODE_FOLDER  2
#define MFC_EB_MODE_CUSTOM  3

// String constants to identify property
#define PS_True                                     _T("TRUE")
#define PS_False                                    _T("FALSE")
#define PS_MFCLink_Url                              _T("MFCLink_Url")
#define PS_MFCLink_UrlPrefix                        _T("MFCLink_UrlPrefix")
#define PS_MFCLink_Tooltip                          _T("MFCLink_Tooltip")
#define PS_MFCLink_FullTextTooltip                  _T("MFCLink_FullTextTooltip")
#define PS_MFCComboBox_DrawUsingFont                _T("MFCComboBox_DrawUsingFont")
#define PS_MFCComboBox_ShowTrueTypeFonts            _T("MFCComboBox_ShowTrueTypeFonts")
#define PS_MFCComboBox_ShowRasterTypeFonts          _T("MFCComboBox_ShowRasterTypeFonts")
#define PS_MFCComboBox_ShowDeviceTypeFonts          _T("MFCComboBox_ShowDeviceTypeFonts")
#define PS_MFCShellListCtrl_EnableShellContextMenu  _T("MFCShellListCtrl_EnableShellContextMenu")
#define PS_MFCShellTreeCtrl_EnableShellContextMenu  _T("MFCShellTreeCtrl_EnableShellContextMenu")
#define PS_MFCColorButton_EnableOtherButton         _T("MFCColorButton_EnableOtherButton")
#define PS_MFCColorButton_EnableAutomaticButton     _T("MFCColorButton_EnableAutomaticButton")
#define PS_MFCColorButton_ColumnsCount              _T("MFCColorButton_ColumnsCount")

#define PS_MFCMenuButton_OSMenu                     _T("MFCMenuButton_OSMenu")
#define PS_MFCMenuButton_RightArrow                 _T("MFCMenuButton_RightArrow")
#define PS_MFCMenuButton_StayPressed                _T("MFCMenuButton_StayPressed")
#define PS_MFCMenuButton_DefaultClick               _T("MFCMenuButton_DefaultClick")
#define PS_MFCMenuButton_Autosize                   _T("MFCMenuButton_Autosize")

#define PS_MFCPropertyGrid_DescriptionArea          _T("MFCPropertyGrid_DescriptionArea")
#define PS_MFCPropertyGrid_DescriptionRows          _T("MFCPropertyGrid_DescriptionRows")
#define PS_MFCPropertyGrid_HeaderCtrl               _T("MFCPropertyGrid_HeaderCtrl")
#define PS_MFCPropertyGrid_AlphabeticMode           _T("MFCPropertyGrid_AlphabeticMode")
#define PS_MFCPropertyGrid_ModifiedProperties       _T("MFCPropertyGrid_ModifiedProperties")
#define PS_MFCPropertyGrid_VSDotNetLook             _T("MFCPropertyGrid_VSDotNetLook")

#define PS_MFCEditBrowse_BrowseMode                 _T("MFCEditBrowse_Mode")

#define PS_MFCButton_Style                          _T("MFCButton_Style")
#define PS_MFCButton_Autosize                       _T("MFCButton_Autosize")
#define PS_MFCButton_Tooltip                        _T("MFCButton_Tooltip")
#define PS_MFCButton_FullTextTooltip                _T("MFCButton_FullTextTool")
#define PS_MFCButton_CursorType                     _T("MFCButton_CursorType")
#define PS_MFCButton_Cursor                         _T("MFCButton_Cursor")
#define PS_MFCButton_CursorID                       _T("MFCButton_CursorID")
#define PS_MFCButton_ImageType                      _T("MFCButton_ImageType")
#define PS_MFCButton_Image                          _T("MFCButton_Image")
#define PS_MFCButton_ImageID                        _T("MFCButton_ImageID")
#define PS_MFCButton_ImageOnTop                     _T("MFCButton_ImageOnTop") 
#define PS_MFCButton_ImageOnRight                   _T("MFCButton_ImageOnRight")

#define PS_MFCMaskedEdit_SelectByGroup              _T("MFCMaskedEdit_SelectByGroup")
#define PS_MFCMaskedEdit_Mask                       _T("MFCMaskedEdit_Mask")
#define PS_MFCMaskedEdit_InputTemplate              _T("MFCMaskedEdit_InputTemplate")
#define PS_MFCMaskedEdit_DefaultChar                _T("MFCMaskedEdit_DefaultChar")
#define PS_MFCMaskedEdit_ValidChars                 _T("MFCMaskedEdit_ValidChars")

#define PS_MFCVSListbox_BrowseButton                _T("MFCVSListbox_BrowseButton")
#define PS_MFCVSListbox_NewButton                   _T("MFCVSListbox_NewButton")
#define PS_MFCVSListbox_RemoveButton                _T("MFCVSListbox_RemoveButton")
#define PS_MFCVSListbox_UpButton                    _T("MFCVSListbox_UpButton")
#define PS_MFCVSListbox_DownButton                  _T("MFCVSListbox_DownButton")

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxcustomizemenubutton.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxtoolbarmenubutton.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#define AFX_CUSTOMIZE_INTERNAL_ID ((UINT)-20)

class  CMFCCustomizeMenuButton : public CMFCToolBarMenuButton
{
	friend class CMFCPopupMenuBar;

	DECLARE_DYNCREATE(CMFCCustomizeMenuButton)

public:
	CMFCCustomizeMenuButton(UINT uiID,HMENU hMenu,int iImage,LPCTSTR lpszText = NULL,BOOL bUserButton = FALSE);
	CMFCCustomizeMenuButton();
	virtual ~CMFCCustomizeMenuButton();

	static BOOL __stdcall SetParentToolbar(CMFCToolBar* pToolBar)
	{
		m_pWndToolBar = pToolBar;
		return TRUE;
	}

	static CMFCToolBar* __stdcall GetParentToolbar()
	{
		return m_pWndToolBar;
	}

	void SetItemIndex(UINT uiIndex, BOOL bExist = TRUE, BOOL bAddSp = FALSE);

//Overridables
protected:
	virtual void OnDraw(CDC* pDC, const CRect& rect, CMFCToolBarImages* pImages, BOOL bHorz = TRUE, BOOL bCustomizeMode = FALSE,
		BOOL bHighlight = FALSE, BOOL bDrawBorder = TRUE, BOOL bGrayDisabledButtons = TRUE);
	virtual void CopyFrom(const CMFCToolBarButton& src);
	virtual SIZE OnCalculateSize(CDC* pDC, const CSize& sizeDefault, BOOL bHorz);
	virtual BOOL OnClickMenuItem();
	virtual void DrawCheckBox(CDC* pDC, const CRect& rect, BOOL bHighlight);

public:

	void SetSeparator()
	{
		bSeparator = TRUE;
		SetStyle(TBBS_DISABLED);
	}

	void RestoreRecentlyUsedState() { CMFCMenuBar::SetRecentlyUsedMenus(m_bRecentlyUsedOld); }

	// Save Resently Used State
	AFX_IMPORT_DATA static BOOL m_bRecentlyUsedOld;

	void EnableCustomization(BOOL bEnable = TRUE) { m_bIsEnabled = bEnable; }
	void SetSiblingsButton() { m_bBrothersBtn = TRUE; }

	AFX_IMPORT_DATA static CMap<UINT, UINT, int, int> m_mapPresentIDs;

	static BOOL __stdcall IsCommandExist(UINT uiCmdId);

protected:
	AFX_IMPORT_DATA static CMFCToolBar* m_pWndToolBar;

	UINT m_uiIndex;
	BOOL m_bShow;
	BOOL bSeparator;
	BOOL m_bExist;
	BOOL m_bAddSpr;
	BOOL m_bIsEnabled;
	BOOL m_bBrothersBtn;

protected:
	CString SearchCommandText(CMenu* pMenu, UINT in_uiCmd);
	void UpdateCustomizeButton();
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxcustomizebutton.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxtoolbarmenubutton.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCToolBar;

class CMFCCustomizeButton : public  CMFCToolBarMenuButton
{
	friend class CMFCToolBar;

	DECLARE_SERIAL(CMFCCustomizeButton)

public:
	CMFCCustomizeButton();
	CMFCCustomizeButton(int uiCustomizeCmdId, const CString& strCustomizeText);
	virtual ~CMFCCustomizeButton();

	virtual void OnDraw(CDC* pDC, const CRect& rect, CMFCToolBarImages* pImages, BOOL bHorz = TRUE, BOOL bCustomizeMode = FALSE,
		BOOL bHighlight = FALSE, BOOL bDrawBorder = TRUE, BOOL bGrayDisabledButtons = TRUE);
	virtual CMFCPopupMenu* CreatePopupMenu();

	virtual void CopyFrom(const CMFCToolBarButton& src);
	virtual BOOL IsEmptyMenuAllowed() const { return TRUE; }

	virtual void OnCancelMode();
	virtual void OnChangeParentWnd(CWnd* pWndParent);
	virtual SIZE OnCalculateSize(CDC* pDC, const CSize& sizeDefault, BOOL bHorz);

	virtual BOOL IsEditable() const { return FALSE; }
	virtual BOOL CanBeStored() const { return FALSE; }

	int GetCustomizeCmdId() const { return m_iCustomizeCmdId; }

	CString GetCustomizeText() const { return m_strCustomizeText; }

	const CObList& GetInvisibleButtons() const { return m_lstInvisibleButtons; }

	CMFCToolBar* GetParentToolbar() { return m_pWndParentToolbar; }

	void SetDefaultDraw(BOOL bDefaultDraw = TRUE) { m_bDefaultDraw = bDefaultDraw; }
	BOOL IsDefaultDraw() const { return m_bDefaultDraw; }

	void SetExtraSize(int cx, int cy) { m_sizeExtra = CSize(cx, cy); }
	CSize GetExtraSize() const { return m_bIsPipeStyle ? m_sizeExtra : CSize(0, 0); }

	void SetPipeStyle(BOOL bOn = TRUE) { m_bIsPipeStyle = bOn; }
	BOOL IsPipeStyle() const { return m_bIsPipeStyle && !m_bOnRebar; }

	void AddInvisibleButton(CMFCToolBarButton* pButton) { m_lstInvisibleButtons.AddTail(pButton); }

	virtual BOOL InvokeCommand(CMFCPopupMenuBar* pMenuBar, const CMFCToolBarButton* pButton);

	void SetMenuRightAlign(BOOL bMenuRightAlign) { m_bMenuRightAlign = bMenuRightAlign; }
	BOOL IsMenuRightAlign() const { return m_bMenuRightAlign; }

public:
	AFX_IMPORT_DATA static BOOL m_bIgnoreLargeIconsMode;

protected:
	void CommonInit();

	int             m_iCustomizeCmdId;
	CSize           m_sizeExtra;
	CString         m_strCustomizeText;
	CMFCToolBar* m_pWndParentToolbar;
	BOOL            m_bIsEmpty;
	BOOL            m_bDefaultDraw;
	BOOL            m_bIsPipeStyle;        // Used in 2003 style only
	BOOL            m_bOnRebar;
	BOOL            m_bMenuRightAlign;
	CObList         m_lstInvisibleButtons; // List of invisible butons on the parent toolbar.
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxcustomcolorspropertypage.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcolorpickerctrl.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCColorDialog;

/////////////////////////////////////////////////////////////////////////////
// CMFCCustomColorsPropertyPage dialog

class CMFCCustomColorsPropertyPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CMFCCustomColorsPropertyPage)

// Construction
public:
	CMFCCustomColorsPropertyPage();
	CMFCColorDialog* m_pDialog;

	void Setup(BYTE R, BYTE G, BYTE B);

protected:
	//{{AFX_DATA(CMFCCustomColorsPropertyPage)
	enum { IDD = IDD_AFXBARRES_COLORPAGE_TWO };
	CMFCColorPickerCtrl m_wndLuminance;
	CMFCColorPickerCtrl m_wndColorPicker;
	int  m_r;
	int  m_b;
	int  m_g;
	UINT m_l;
	UINT m_h;
	UINT m_s;
	//}}AFX_DATA

// Overrides
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Implementation
protected:
	//{{AFX_MSG(CMFCCustomColorsPropertyPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnRGBChanged();
	afx_msg void OnHLSChanged();
	afx_msg void OnLuminance();
	afx_msg void OnColour();
	afx_msg void OnDoubleClickedColor();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	BOOL m_bIsReady;
	BOOL m_bInUpdate;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxcview.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXCVIEW.H

#ifdef _AFXCVIEW_INLINE

#pragma once

// CListView
_AFXCVIEW_INLINE CListView::CListView() : CCtrlView(WC_LISTVIEW,
	AFX_WS_DEFAULT_VIEW)
	{ }
// NOTE: The cast in GetListCtrl is ugly, but must be preserved for compatibility.
// CListCtrl is not related to CListView by inheritance so we must be careful to ensure 
// that CListCtrl remains a binary compatible subset of CListView.
_AFXCVIEW_INLINE CListCtrl& CListView::GetListCtrl() const
	{ return *(CListCtrl*)this; }
_AFXCVIEW_INLINE CTreeView::CTreeView() : CCtrlView(WC_TREEVIEW,
	AFX_WS_DEFAULT_VIEW)
	{ }
// NOTE: The cast in GetTreeCtrl is ugly, but must be preserved for compatibility.
// CTreeCtrl is not related to CTreeView by inheritance so we must be careful to ensure 
// that CTreeCtrl remains a binary compatible subset of CTreeView.
_AFXCVIEW_INLINE CTreeCtrl& CTreeView::GetTreeCtrl() const
	{ return *(CTreeCtrl*)this; }

#endif //_AFXCVIEW_INLINE

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxcview.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXCVIEW_H__
#define __AFXCVIEW_H__

#pragma once

#ifdef _AFX_NO_AFXCMN_SUPPORT
	#error Windows common control classes not supported in this library variant.
#endif

#ifndef __AFXWIN_H__
	#include <afxwin.h>
#endif

#ifndef __AFXCMN_H__
	#include <afxcmn.h>
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// AFXRICH - MFC RichEdit classes

// Classes declared in this file

//CObject
	//CCmdTarget;
		//CWnd
			//CView
				//CCtrlView
					class CListView;// list control view
					class CTreeView;// tree control view

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

/////////////////////////////////////////////////////////////////////////////
// CListView

class CListView : public CCtrlView
{
	DECLARE_DYNCREATE(CListView)

// Construction
public:
	CListView();

// Attributes
public:
	CListCtrl& GetListCtrl() const;

// Overridables
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);

protected:
	void RemoveImageList(int nImageList);
	virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);

public:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

	//{{AFX_MSG(CListView)
	afx_msg void OnNcDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CTreeView

class CTreeView : public CCtrlView
{
	DECLARE_DYNCREATE(CTreeView)

// Construction
public:
	CTreeView();

// Attributes
public:
	CTreeCtrl& GetTreeCtrl() const;

protected:
	void RemoveImageList(int nImageList);

public:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

	//{{AFX_MSG(CTreeView)
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXCVIEW_INLINE AFX_INLINE
#include <afxcview.inl>
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXCVIEW_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxdao.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXDAO_H
#define __AFXDAO_H

#ifdef _WIN64
	#error DAO Database classes are not supported for Win64 platforms
#endif

#ifdef _AFX_NO_DAO_SUPPORT
	#error DAO Database classes not supported in this library variant.
#endif

#pragma once

#ifndef __AFXDISP_H__
	#include <afxdisp.h>    // Must include this before dao headers
#endif
#ifndef _DBDAOINT_H_
	#include <dbdaoint.h>
#endif
#ifndef _DAOGETRW_H_
	#include <daogetrw.h>
#endif
#ifndef _DBDAOID_H_
	#include <dbdaoid.h>
#endif
#ifndef _DBDAOERR_H_
	#include <dbdaoerr.h>
#endif

#ifndef __AFXDB__H__
	#include <afxdb_.h> // shared header with ODBC database classes
#endif

#ifndef __AFXEXT_H__
	#include <afxext.h> // for CFormView
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 

#if defined(_MFC_DLL_BLD)

#include <initguid.h>

// Privately define DAO CLSIDs and GUIDs so we don't have to link against
// DAOUUID.LIB.  That library was not built with the current compiler and
// linker so it triggers BinScope warnings against the MFC DLLs.
DEFINE_DAOGUID(CLSID_CDAODBEngine,   0x00000100);
DEFINE_DAOGUID(IID_IDAODBEngine,     0x00000020);
DEFINE_DAOGUID(IID_IDAODBEngineW,    0x00000021);
DEFINE_OLEGUID(IID_ICDAORecordset,   0x00025e31, 0, 0);
DEFINE_DAOGUID(IID_IDAOField,        0x00000050);
DEFINE_DAOGUID(IID_IDAOFieldW,       0x00000051);
DEFINE_DAOGUID(IID_IDAOIndexFields,  0x0000005C);
DEFINE_DAOGUID(IID_IDAOIndexFieldsW, 0x0000005D);

#else // _MFC_DLL_BLD

#ifndef _AFX_NOFORCE_LIBS

/////////////////////////////////////////////////////////////////////////////
// Win32 libraries

#pragma comment(lib, "daouuid.lib")

#endif //!_AFX_NOFORCE_LIBS

#endif // _MFC_DLL_BLD

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

////////////////////////////////////////////////////////////////////////
// AFXDAO - MFC Database support using DAO

// Classes declared in this file

	// CException
		class CDaoException;    // DAO error/exception handling

	// CObject
		class CDaoRecordView;
		class CDaoWorkspace;    // DAO engine/transaction/security manager
		class CDaoDatabase;     // DAO database manager
		class CDaoRecordset;    // DAO result set manager
		class CDaoTableDef;     // DAO base table manager
		class CDaoQueryDef;     // DAO query manager

	// Non-CObject classes
		class CDaoFieldExchange;
		struct CDaoFieldCache;
		struct CDaoErrorInfo;
		struct CDaoWorkspaceInfo;
		struct CDaoDatabaseInfo;
		struct CDaoTableDefInfo;
		struct CDaoFieldInfo;
		struct CDaoIndexInfo;
		struct CDaoRelationInfo;
		struct CDaoQueryDefInfo;
		struct CDaoParameterInfo;

/////////////////////////////////////////////////////////////////////////////
// AFXDLL support

#undef AFX_DATA
#define AFX_DATA AFX_DB_DATA

////////////////////////////////////////////////////////////////////////
// Data caching structures
struct CDaoFieldCache
{
	void* m_pvData;     // Pointer to cached data of any supported type.
	BYTE m_nStatus;     // (NULL) status cache.
	BYTE m_nDataType;       // Type of data cached.
};

////////////////////////////////////////////////////////////////////////
// Info structures

struct CDaoErrorInfo
{
// Attributes
	long m_lErrorCode;
	CString m_strSource;
	CString m_strDescription;
	CString m_strHelpFile;
	long m_lHelpContext;

	virtual ~CDaoErrorInfo() {}

#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
};

struct CDaoWorkspaceInfo
{
// Attributes
	CString m_strName;              // Primary
	CString m_strUserName;          // Secondary
	BOOL m_bIsolateODBCTrans;       // All

	virtual ~CDaoWorkspaceInfo() {}

#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
};

struct CDaoDatabaseInfo
{
// Attributes
	CString m_strName;              // Primary
	BOOL m_bUpdatable;              // Primary
	BOOL m_bTransactions;           // Primary
	CString m_strVersion;           // Secondary
	long m_lCollatingOrder;         // Secondary
	short m_nQueryTimeout;          // Secondary
	CString m_strConnect;           // All

	virtual ~CDaoDatabaseInfo() {}

#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
};

struct CDaoTableDefInfo
{
// Attributes
	CString m_strName;              // Primary
	BOOL m_bUpdatable;              // Primary
	long m_lAttributes;             // Primary
	COleDateTime m_dateCreated;     // Secondary
	COleDateTime m_dateLastUpdated; // Secondary
	CString m_strSrcTableName;      // Secondary
	CString m_strConnect;           // Secondary
	CString m_strValidationRule;    // All
	CString m_strValidationText;    // All
	long m_lRecordCount;            // All

	virtual ~CDaoTableDefInfo() {}

#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
};

struct CDaoFieldInfo
{
// Attributes
	CString m_strName;              // Primary
	short m_nType;                  // Primary
	long m_lSize;                   // Primary
	long m_lAttributes;             // Primary
	short m_nOrdinalPosition;       // Secondary
	BOOL m_bRequired;               // Secondary
	BOOL m_bAllowZeroLength;        // Secondary
	long m_lCollatingOrder;         // Secondary
	CString m_strForeignName;       // Secondary
	CString m_strSourceField;       // Secondary
	CString m_strSourceTable;       // Secondary
	CString m_strValidationRule;    // All
	CString m_strValidationText;    // All
	CString m_strDefaultValue;      // All

	virtual ~CDaoFieldInfo() {}

#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
};

struct CDaoIndexFieldInfo
{
// Attributes
	CString m_strName;              // Primary
	BOOL m_bDescending;             // Primary

	virtual ~CDaoIndexFieldInfo() {}

#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
};

struct CDaoIndexInfo
{
// Constructors
	CDaoIndexInfo();

// Attributes
	CString m_strName;                      // Primary
	CDaoIndexFieldInfo* m_pFieldInfos;      // Primary
	short m_nFields;                        // Primary
	BOOL m_bPrimary;                        // Secondary
	BOOL m_bUnique;                         // Secondary
	BOOL m_bClustered;                      // Secondary
	BOOL m_bIgnoreNulls;                    // Secondary
	BOOL m_bRequired;                       // Secondary
	BOOL m_bForeign;                        // Secondary
	long m_lDistinctCount;                  // All

// Implementation
	virtual ~CDaoIndexInfo();
	BOOL m_bCleanupFieldInfo;

#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
};

struct CDaoRelationFieldInfo
{
// Attributes
	CString m_strName;              // Primary
	CString m_strForeignName;       // Primary

	virtual ~CDaoRelationFieldInfo() {}

#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
};

struct CDaoRelationInfo
{
// Constructor
	CDaoRelationInfo();

// Attributes
	CString m_strName;              // Primary
	CString m_strTable;             // Primary
	CString m_strForeignTable;      // Primary
	long m_lAttributes;             // Secondary
	CDaoRelationFieldInfo* m_pFieldInfos;   // Secondary
	short m_nFields;                // Secondary

// Implementation
	virtual ~CDaoRelationInfo();
	BOOL m_bCleanupFieldInfo;

#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
};

struct CDaoQueryDefInfo
{
// Attributes
	CString m_strName;              // Primary
	short m_nType;                  // Primary
	COleDateTime m_dateCreated;     // Secondary
	COleDateTime m_dateLastUpdated; // Secondary
	BOOL m_bUpdatable;              // Secondary
	BOOL m_bReturnsRecords;         // Secondary
	CString m_strSQL;               // All
	CString m_strConnect;           // All
	short m_nODBCTimeout;           // See readme

	virtual ~CDaoQueryDefInfo() {}

#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
};

struct CDaoParameterInfo
{
// Attributes
	CString m_strName;              // Primary
	short m_nType;                  // Primary
	COleVariant m_varValue;         // Secondary

	virtual ~CDaoParameterInfo() {}

#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
};

////////////////////////////////////////////////////////////////////////
// DAO Helpers
//

// Flags for getting and/or setting object properties
#define AFX_DAO_PRIMARY_INFO    0x00000001  // Get only primary
#define AFX_DAO_SECONDARY_INFO  0x00000002  // Get primary & secondary
#define AFX_DAO_ALL_INFO        0x00000004  // Get All info

// Jet engine TRUE/FALSE definitions
#define AFX_DAO_TRUE                    (-1L)
#define AFX_DAO_FALSE                   0

// Set CDaoRecordset::Open option to use m_nDefaultType
#define AFX_DAO_USE_DEFAULT_TYPE        (-1L)

// Flags used for Move/Find
#define AFX_DAO_NEXT                    (+1L)
#define AFX_DAO_PREV                    (-1L)
#define AFX_DAO_FIRST                   LONG_MIN
#define AFX_DAO_LAST                    LONG_MAX

// Default sizes for DFX function PreAlloc sizes
#define AFX_DAO_TEXT_DEFAULT_SIZE       255
#define AFX_DAO_BINARY_DEFAULT_SIZE     2048
#define AFX_DAO_LONGBINARY_DEFAULT_SIZE 32768

// Flag used for DFX functions dwBindOptions bitmask
#define AFX_DAO_ENABLE_FIELD_CACHE      0x01
#define AFX_DAO_DISABLE_FIELD_CACHE     0
#define AFX_DAO_CACHE_BY_VALUE          0x80    // MFC Internal

// Field Flags, used to indicate status of fields
#define AFX_DAO_FIELD_FLAG_DIRTY            0x01
#define AFX_DAO_FIELD_FLAG_NULL             0x02
#define AFX_DAO_FIELD_FLAG_NULLABLE_KNOWN   0x04
#define AFX_DAO_FIELD_FLAG_NULLABLE         0x08

// Extended error codes
#define NO_AFX_DAO_ERROR                        0
#define AFX_DAO_ERROR_MIN                       2000
#define AFX_DAO_ERROR_ENGINE_INITIALIZATION     AFX_DAO_ERROR_MIN + 0
#define AFX_DAO_ERROR_DFX_BIND                  AFX_DAO_ERROR_MIN + 1
#define AFX_DAO_ERROR_OBJECT_NOT_OPEN           AFX_DAO_ERROR_MIN + 2
#define AFX_DAO_ERROR_MAX                       AFX_DAO_ERROR_MIN + 2

// Object status flags
#define AFX_DAO_IMPLICIT_WS                     0x01
#define AFX_DAO_IMPLICIT_DB                     0x02
#define AFX_DAO_IMPLICIT_QD                     0x04
#define AFX_DAO_IMPLICIT_TD                     0x08
#define AFX_DAO_IMPLICIT_CLOSE                  0x40
#define AFX_DAO_DEFAULT_WS                      0x80

// CDaoRecordView status flags
#define AFX_DAOVIEW_SCROLL_NEXT                 0x01
#define AFX_DAOVIEW_SCROLL_LAST                 0x02
#define AFX_DAOVIEW_SCROLL_BACKWARD             0x04

// Logging helpers
void AFXAPI AfxDaoCheck(SCODE scode, LPCSTR lpszDaoCall,
	LPCSTR lpszFile, int nLine, int nError = NO_AFX_DAO_ERROR,
	BOOL bMemOnly = FALSE);

#ifdef _DEBUG
void AFXAPI AfxDaoTrace(SCODE scode, LPCSTR lpszDaoCall,
	LPCSTR lpszFile, int nLine);
#endif

#ifdef _DEBUG
#define DAO_CHECK(f)            AfxDaoCheck(f, #f, THIS_FILE, __LINE__)
#define DAO_CHECK_ERROR(f, err) AfxDaoCheck(f, #f, THIS_FILE, __LINE__, err)
#define DAO_CHECK_MEM(f)        AfxDaoCheck(f, #f, THIS_FILE, __LINE__, \
									NO_AFX_DAO_ERROR, TRUE)
#define DAO_TRACE(f)            AfxDaoTrace(f, #f, THIS_FILE, __LINE__)
#else
#define DAO_CHECK(f)            AfxDaoCheck(f, NULL, NULL, 0)
#define DAO_CHECK_ERROR(f, err) AfxDaoCheck(f, NULL, NULL, 0, err)
#define DAO_CHECK_MEM(f)        AfxDaoCheck(f, NULL, NULL, 0, \
									NO_AFX_DAO_ERROR, TRUE)
#define DAO_TRACE(f)            f
#endif

/////////////////////////////////////////////////////////////////////////////
// CDaoFieldExchange - for field exchange
class CDaoFieldExchange
{
// Attributes
public:
	enum DFX_Operation
	{
		AddToParameterList,     // builds PARAMETERS clause
		AddToSelectList,        // builds SELECT clause
		BindField,              // sets up binding structure
		BindParam,              // sets parameter values
		Fixup,                  // sets NULL status
		AllocCache,             // allocates cache used for dirty check
		StoreField,             // saves current record to cache
		LoadField,              // restores cached data to member vars
		FreeCache,              // frees cache
		SetFieldNull,           // sets field status & value to NULL
		MarkForAddNew,          // marks fields dirty if not PSEUDO NULL
		MarkForEdit,            // marks fields dirty if don't match cache
		SetDirtyField,          // sets field values marked as dirty
#ifdef _DEBUG
		DumpField,
#endif
		MaxDFXOperation,        // dummy operation type for input checking
	};

	UINT m_nOperation;          // type of exchange operation
	CDaoRecordset* m_prs;       // recordset handle

// Operations
public:
	enum FieldType
	{
		none,
		outputColumn,
		param,
	};

	void SetFieldType(UINT nFieldType);
	BOOL IsValidOperation();

// Implementation
public:
	CDaoFieldExchange(UINT nOperation, CDaoRecordset* prs,
		void* pvField = NULL);

	void Default(LPCTSTR lpszName, void* pv, DWORD dwFieldType,
		DWORD dwBindOptions = 0);

	static void PASCAL AppendParamType(CString& strParamList, DWORD dwParamType);
	static CDaoFieldCache* PASCAL GetCacheValue(CDaoRecordset* prs, void* pv);
	static void PASCAL SetNullValue(void* pv, DWORD dwDataType);
	static BOOL PASCAL IsNullValue(void* pv, DWORD dwDataType);
	static void PASCAL AllocCacheValue(CDaoFieldCache*& pCache, DWORD dwDataType);
	static void PASCAL DeleteCacheValue(CDaoFieldCache* pCache, DWORD dwDataType);
	static void PASCAL CopyValue(void* pvSrc, void* pvDest, DWORD dwDataType);
	static BOOL PASCAL CompareValue(void* pvSrc, void* pvDest, DWORD dwDataType);
	static void PASCAL FillVariant(void* pvValue, DWORD dwDataType, COleVariant** ppVar);

	// Current type of field
	UINT m_nFieldType;
	void* m_pvField;
	UINT m_nField;
	UINT m_nParam;
	UINT m_nFieldFound;

#ifdef _DEBUG
	CDumpContext* m_pdcDump;
#endif //_DEBUG
};

/////////////////////////////////////////////////////////////////////////////
// Standard RecordSet Field Exchange routines

// variable length data
void AFXAPI DFX_Text(CDaoFieldExchange* pFX, LPCTSTR lpszName,
	CString& value, int nPreAllocSize = AFX_DAO_TEXT_DEFAULT_SIZE,
	DWORD dwBindOptions = AFX_DAO_ENABLE_FIELD_CACHE);
void AFXAPI DFX_Binary(CDaoFieldExchange* pFX, LPCTSTR lpszName,
	CByteArray& value, int nPreAllocSize = AFX_DAO_BINARY_DEFAULT_SIZE,
	DWORD dwBindOptions = 0);
void AFXAPI DFX_LongBinary(CDaoFieldExchange* pFX, LPCTSTR lpszName,
	CLongBinary& value, DWORD dwPreAllocSize = AFX_DAO_LONGBINARY_DEFAULT_SIZE,
	DWORD dwBndOptions = 0);

//fixed length data
void AFXAPI DFX_Bool(CDaoFieldExchange* pFX, LPCTSTR lpszName,
	BOOL& value, DWORD dwBindOptions = AFX_DAO_ENABLE_FIELD_CACHE);
void AFXAPI DFX_Byte(CDaoFieldExchange* pFX, LPCTSTR lpszName,
	BYTE& value, DWORD dwBindOptions = AFX_DAO_ENABLE_FIELD_CACHE);
void AFXAPI DFX_Short(CDaoFieldExchange* pFX, LPCTSTR lpszName,
	short& value, DWORD dwBindOptions = AFX_DAO_ENABLE_FIELD_CACHE);
void AFXAPI DFX_Long(CDaoFieldExchange* pFX, LPCTSTR lpszName,
	long& value, DWORD dwBindOptions = AFX_DAO_ENABLE_FIELD_CACHE);
void AFXAPI DFX_Currency(CDaoFieldExchange* pFX, LPCTSTR lpszName,
	COleCurrency& value, DWORD dwBindOptions = AFX_DAO_ENABLE_FIELD_CACHE);
void AFXAPI DFX_Single(CDaoFieldExchange* pFX, LPCTSTR lpszName,
	float& value, DWORD dwBindOptions = AFX_DAO_ENABLE_FIELD_CACHE);
void AFXAPI DFX_Double(CDaoFieldExchange* pFX, LPCTSTR lpszName,
	double& value, DWORD dwBindOptions = AFX_DAO_ENABLE_FIELD_CACHE);
void AFXAPI DFX_DateTime(CDaoFieldExchange* pFX, LPCTSTR lpszName,
	COleDateTime& value, DWORD dwBindOptions = AFX_DAO_ENABLE_FIELD_CACHE);

//////////////////////////////////////////////////////////////////////////
// Database Dialog Data Exchange cover routines
// Cover routines provide database semantics on top of DDX routines

// simple text operations
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, BOOL& value,
	CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, BYTE& value,
	CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, short& value,
	CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, long& value,
	CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, COleCurrency& value,
	CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, DWORD& value,
	CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, float& value,
	CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, double& value,
	CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, COleDateTime& value,
	CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, CString& value,
	CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldText(_In_ CDataExchange* pDX, _In_ int nIDC, _Out_z_cap_(nMaxLen) LPTSTR pstrValue,
	_In_ int nMaxLen, _In_ CDaoRecordset* pRecordset);

// special control types
void AFXAPI DDX_FieldCheck(CDataExchange* pDX, int nIDC, int& value,
	CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldRadio(CDataExchange* pDX, int nIDC, int& value,
	CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldLBString(CDataExchange* pDX, int nIDC,
	CString& value, CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldCBString(CDataExchange* pDX, int nIDC,
	CString& value, CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldLBStringExact(CDataExchange* pDX, int nIDC,
	CString& value, CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldCBStringExact(CDataExchange* pDX, int nIDC,
	CString& value, CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldLBIndex(CDataExchange* pDX, int nIDC, int& index,
	CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldCBIndex(CDataExchange* pDX, int nIDC, int& index,
	CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldLBStringExact(CDataExchange* pDX, int nIDC, CString& value,
	CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldCBStringExact(CDataExchange* pDX, int nIDC, CString& value,
	CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldScroll(CDataExchange* pDX, int nIDC, int& value,
	CDaoRecordset* pRecordset);
void AFXAPI DDX_FieldSlider(CDataExchange* pDX, int nIDC, int& value,
	CDaoRecordset* pRecordset);

////////////////////////////////////////////////////////////////////////
// CDaoWorkspace - a DAO Workspace

class CDaoWorkspace : public CObject
{
	DECLARE_DYNAMIC(CDaoWorkspace)

// Constructors
public:
	CDaoWorkspace();

	virtual void Create(LPCTSTR lpszName, LPCTSTR lpszUserName,
		LPCTSTR lpszPassword);
	virtual void Append();

	virtual void Open(LPCTSTR lpszName = NULL);
	virtual void Close();

// Attributes
public:
	DAOWorkspace* m_pDAOWorkspace;

	static CString PASCAL GetVersion();
	static CString PASCAL GetIniPath();
	static void PASCAL SetIniPath(LPCTSTR lpszRegistrySubKey);
	static void PASCAL SetDefaultUser(LPCTSTR lpszDefaultUser);
	static void PASCAL SetDefaultPassword(LPCTSTR lpszPassword);
	static short PASCAL GetLoginTimeout();
	static void PASCAL SetLoginTimeout(short nSeconds);

	CString GetName();
	CString GetUserName();
	void SetIsolateODBCTrans(BOOL bIsolateODBCTrans);
	BOOL GetIsolateODBCTrans();

	BOOL IsOpen() const;

// Operations
public:
	void BeginTrans();
	void CommitTrans();
	void Rollback();

	static void PASCAL CompactDatabase(LPCTSTR lpszSrcName,
		LPCTSTR lpszDestName, LPCTSTR lpszLocale = dbLangGeneral,
		int nOptions = 0);
	// Password parameter added late in dev cycle, new interface req'd
	static void PASCAL CompactDatabase(LPCTSTR lpszSrcName,
		LPCTSTR lpszDestName, LPCTSTR lpszLocale, int nOptions,
		LPCTSTR lpszPassword);
	static void PASCAL RepairDatabase(LPCTSTR lpszName);

	static void PASCAL Idle(int nAction = dbFreeLocks);

	short GetWorkspaceCount();
	void GetWorkspaceInfo(int nIndex, CDaoWorkspaceInfo& wkspcinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);
	void GetWorkspaceInfo(LPCTSTR lpszName, CDaoWorkspaceInfo& wkspcinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);

	short GetDatabaseCount();
	void GetDatabaseInfo(int nIndex, CDaoDatabaseInfo& dbinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);
	void GetDatabaseInfo(LPCTSTR lpszName, CDaoDatabaseInfo& dbinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);

// Overridables
public:

// Implementation
public:
	virtual ~CDaoWorkspace();

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	DAOWorkspaces* m_pDAOWorkspaces;
	DAODatabases* m_pDAODatabases;
	int m_nStatus;

	CMapPtrToPtr m_mapDatabases;        // Map of all Open CDaoDatabases
	BOOL IsNew() const;

protected:
	BOOL m_bOpen;
	BOOL m_bNew;

	static void AFX_CDECL InitializeEngine();

	void InitWorkspacesCollection();
	void FillWorkspaceInfo(DAOWorkspace* pDAOWorkspace,
		CDaoWorkspaceInfo& wsinfo, DWORD dwOptions);

	void InitDatabasesCollection();
	void FillDatabaseInfo(DAODatabase* pDAODatabase,
		CDaoDatabaseInfo& dbinfo, DWORD dwOptions);

	virtual void ThrowDaoException(int nError = NO_AFX_DAO_ERROR);
};

////////////////////////////////////////////////////////////////////////
// CDaoException - DAO error trapping mechanism
class CDaoException : public CException
{
	DECLARE_DYNAMIC(CDaoException)

// Constructors
public:
	CDaoException();

// Attributes
public:
	CDaoErrorInfo* m_pErrorInfo;

	SCODE m_scode;
	int m_nAfxDaoError;     // DAO class extended error code

// Operations
public:
	short GetErrorCount();
	void GetErrorInfo(int nIndex);

// Implementation
public:
	virtual ~CDaoException();

	DAOError* m_pDAOError;
	DAOErrors* m_pDAOErrors;

	virtual BOOL GetErrorMessage(_Out_z_cap_(nMaxError) LPTSTR lpszError, _In_ UINT nMaxError,
		_Out_opt_ PUINT pnHelpContext = NULL) const;

protected:
	void InitErrorsCollection();
	void FillErrorInfo();
};

void AFXAPI AfxThrowDaoException(int nAfxDaoError = NO_AFX_DAO_ERROR,
	SCODE scode = S_OK);


////////////////////////////////////////////////////////////////////////
// CDaoDatabase - a DAO Database

class CDaoDatabase : public CObject
{
	DECLARE_DYNAMIC(CDaoDatabase)

// Constructors
public:
	/* explicit */ CDaoDatabase(CDaoWorkspace* pWorkspace = NULL);

	virtual void Create(LPCTSTR lpszName,
		LPCTSTR lpszLocale = dbLangGeneral, int dwOptions = 0);

	virtual void Open(LPCTSTR lpszName, BOOL bExclusive = FALSE,
		BOOL bReadOnly = FALSE, LPCTSTR lpszConnect = _T(""));
	virtual void Close();

// Attributes
public:
	CDaoWorkspace* m_pWorkspace;
	DAODatabase* m_pDAODatabase;

	BOOL IsOpen() const;

	BOOL CanUpdate();
	BOOL CanTransact();

	CString GetName();
	CString GetConnect();

	CString GetVersion();
	short GetQueryTimeout();
	void SetQueryTimeout(short nSeconds);
	long GetRecordsAffected();

// Operations
public:
	void Execute(LPCTSTR lpszSQL, int nOptions = dbFailOnError);

	void DeleteTableDef(LPCTSTR lpszName);
	void DeleteQueryDef(LPCTSTR lpszName);

	void CreateRelation(LPCTSTR lpszName, LPCTSTR lpszTable,
		LPCTSTR lpszForeignTable, long lAttributes,
		LPCTSTR lpszField, LPCTSTR lpszForeignField);
	void CreateRelation(CDaoRelationInfo& relinfo);
	void DeleteRelation(LPCTSTR lpszName);

	short GetTableDefCount();
	void GetTableDefInfo(int nIndex, CDaoTableDefInfo& tabledefinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);
	void GetTableDefInfo(LPCTSTR lpszName, CDaoTableDefInfo& tabledefinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);

	short GetRelationCount();
	void GetRelationInfo(int nIndex, CDaoRelationInfo& relinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);
	void GetRelationInfo(LPCTSTR lpszName, CDaoRelationInfo& relinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);

	short GetQueryDefCount();
	void GetQueryDefInfo(int nIndex, CDaoQueryDefInfo& querydefinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);
	void GetQueryDefInfo(LPCTSTR lpszName, CDaoQueryDefInfo& querydefinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);

// Overridables
public:

// Implementation
public:
	virtual ~CDaoDatabase();

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	DAOTableDefs* m_pDAOTableDefs;
	DAORelations* m_pDAORelations;
	DAOQueryDefs* m_pDAOQueryDefs;
	DAORecordsets* m_pDAORecordsets;
	int m_nStatus;

	CMapPtrToPtr m_mapTableDefs;        // Map of all Open CDaoTableDefs
	CMapPtrToPtr m_mapQueryDefs;        // Map of all Open CDaoQueryDefs
	CMapPtrToPtr m_mapRecordsets;       // Map of all Open CDaoRecordsets

protected:
	BOOL m_bOpen;

	void InitWorkspace();
	void InitTableDefsCollection();
	void FillTableDefInfo(DAOTableDef* pDAOTableDef,
		CDaoTableDefInfo& tabledefinfo, DWORD dwOptions);
	void InitRelationsCollection();
	void FillRelationInfo(DAORelation* pDAORelation,
		CDaoRelationInfo& relinfo, DWORD dwOptions);
	void InitQueryDefsCollection();
	void FillQueryDefInfo(DAOQueryDef* pDAOQueryDef,
		CDaoQueryDefInfo& querydefinfo, DWORD dwOptions);

	virtual void ThrowDaoException(int nError = NO_AFX_DAO_ERROR);
};


////////////////////////////////////////////////////////////////////////
// CDaoTableDef - a DAO TableDef

class CDaoTableDef : public CObject
{
	DECLARE_DYNAMIC(CDaoTableDef)

// Constructors
public:
	/* explicit */ CDaoTableDef(CDaoDatabase* pDatabase);

	virtual void Create(LPCTSTR lpszName, long lAttributes = 0,
		LPCTSTR lpszSrcTable = NULL, LPCTSTR lpszConnect = NULL);
	virtual void Append();

	virtual void Open(LPCTSTR lpszName);
	virtual void Close();

// Attributes
public:
	CDaoDatabase* m_pDatabase;
	DAOTableDef* m_pDAOTableDef;

	BOOL IsOpen() const;
	BOOL CanUpdate();

	void SetName(LPCTSTR lpszName);
	CString GetName();
	void SetSourceTableName(LPCTSTR lpszSrcTableName);
	CString GetSourceTableName();
	void SetConnect(LPCTSTR lpszConnect);
	CString GetConnect();
	void SetAttributes(long lAttributes);
	long GetAttributes();
	COleDateTime GetDateCreated();
	COleDateTime GetDateLastUpdated();
	void SetValidationRule(LPCTSTR lpszValidationRule);
	CString GetValidationRule();
	void SetValidationText(LPCTSTR lpszValidationText);
	CString GetValidationText();
	long GetRecordCount();

// Overridables
public:

// Operations
public:
	void CreateField(LPCTSTR lpszName, short nType, long lSize,
		long lAttributes = 0);
	void CreateField(CDaoFieldInfo& fieldinfo);
	void DeleteField(LPCTSTR lpszName);
	void DeleteField(int nIndex);

	void CreateIndex(CDaoIndexInfo& indexinfo);
	void DeleteIndex(LPCTSTR lpszName);
	void DeleteIndex(int nIndex);

	short GetFieldCount();
	void GetFieldInfo(int nIndex, CDaoFieldInfo& fieldinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);
	void GetFieldInfo(LPCTSTR lpszName, CDaoFieldInfo& fieldinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);

	short GetIndexCount();
	void GetIndexInfo(int nIndex, CDaoIndexInfo& indexinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);
	void GetIndexInfo(LPCTSTR lpszName, CDaoIndexInfo& indexinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);

	void RefreshLink();

// Implementation
public:
	~CDaoTableDef();

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	DAOFields* m_pDAOFields;
	DAOIndexes* m_pDAOIndexes;

protected:
	BOOL m_bOpen;
	BOOL m_bNew;

	void InitFieldsCollection();
	void InitIndexesCollection();

	virtual void ThrowDaoException(int nError = NO_AFX_DAO_ERROR);
};


////////////////////////////////////////////////////////////////////////
// CDaoQueryDef - a DAO QueryDef

class CDaoQueryDef : public CObject
{
	DECLARE_DYNAMIC(CDaoQueryDef)

// Constructors
public:
	/* explicit */ CDaoQueryDef(CDaoDatabase* pDatabase);

	virtual void Create(LPCTSTR lpszName = NULL,
		LPCTSTR lpszSQL = NULL);
	virtual void Append();

	virtual void Open(LPCTSTR lpszName = NULL);
	virtual void Close();

// Attributes
public:
	CDaoDatabase* m_pDatabase;
	DAOQueryDef* m_pDAOQueryDef;

	BOOL CanUpdate();

	CString GetName();
	void SetName(LPCTSTR lpszName);
	CString GetSQL();
	void SetSQL(LPCTSTR lpszSQL);
	short GetType();
	COleDateTime GetDateCreated();
	COleDateTime GetDateLastUpdated();
	CString GetConnect();
	void SetConnect(LPCTSTR lpszConnect);
	short GetODBCTimeout();
	void SetODBCTimeout(short nODBCTimeout);
	BOOL GetReturnsRecords();
	void SetReturnsRecords(BOOL bReturnsRecords);
	long GetRecordsAffected();

	BOOL IsOpen() const;

// Operations
public:
	virtual void Execute(int nOptions = dbFailOnError);

	virtual COleVariant GetParamValue(LPCTSTR lpszName);
	virtual COleVariant GetParamValue(int nIndex);
	virtual void SetParamValue(LPCTSTR lpszName,
		const COleVariant& varValue);
	virtual void SetParamValue(int nIndex,
		const COleVariant& varValue);
	void SetParamValueNull(LPCTSTR lpszName);
	void SetParamValueNull(int nIndex);

	short GetFieldCount();
	void GetFieldInfo(int nIndex, CDaoFieldInfo& fieldinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);
	void GetFieldInfo(LPCTSTR lpszName, CDaoFieldInfo& fieldinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);

	short GetParameterCount();
	void GetParameterInfo(int nIndex, CDaoParameterInfo& paraminfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);
	void GetParameterInfo(LPCTSTR lpszName,
		CDaoParameterInfo& paraminfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);

// Overridables
public:

// Implementation
public:
	~CDaoQueryDef();

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	DAOFields* m_pDAOFields;
	DAOParameters* m_pDAOParameters;

protected:
	BOOL m_bOpen;
	BOOL m_bNew;

	void InitFieldsCollection();
	void InitParametersCollection();
	void FillParameterInfo(DAOParameter* pDAOParameter,
		CDaoParameterInfo& paraminfo, DWORD dwInfoOptions);

	virtual void ThrowDaoException(int nError = NO_AFX_DAO_ERROR);
};


////////////////////////////////////////////////////////////////////////
// CDaoRecordset - the result of a query or base table browse

class CDaoRecordset : public CObject
{
	DECLARE_DYNAMIC(CDaoRecordset)

// Constructor
public:
	/* explicit */ CDaoRecordset(CDaoDatabase* pDatabase = NULL);

	virtual void Open(int nOpenType = AFX_DAO_USE_DEFAULT_TYPE,
		LPCTSTR lpszSQL = NULL, int nOptions = 0);
	virtual void Open(CDaoQueryDef* pQueryDef,
		int nOpenType = dbOpenDynaset, int nOptions = 0);
	virtual void Open(CDaoTableDef* pTableDef,
		int nOpenType = dbOpenTable, int nOptions = 0);
	virtual void Close();

// Attributes
public:
	CDaoDatabase* m_pDatabase;  // Source database for this result set
	DAORecordset* m_pDAORecordset;

	CString m_strFilter;    // Filter string used when constructing SQL
	CString m_strSort;      // Sort string used when constructing SQL

	int m_nFields;
	int m_nParams;

	BOOL m_bCheckCacheForDirtyFields;   // Switch for dirty field checking.

	BOOL CanUpdate() const;
	BOOL CanAppend() const;
	BOOL CanScroll() const;
	BOOL CanRestart();
	BOOL CanTransact();
	BOOL CanBookmark();

	BOOL IsOpen() const;
	BOOL IsBOF() const;
	BOOL IsEOF() const;
	BOOL IsDeleted() const;

	BOOL IsFieldDirty(void* pv);
	BOOL IsFieldNull(void* pv);
	BOOL IsFieldNullable(void* pv);

	CString GetName();
	short GetType();
	short GetEditMode();
	CString GetSQL() const;

	COleDateTime GetDateCreated();
	COleDateTime GetDateLastUpdated();
	COleVariant GetLastModifiedBookmark();
	CString GetValidationRule();
	CString GetValidationText();
	CString GetCurrentIndex();
	void SetCurrentIndex(LPCTSTR lpszIndex);

	long GetRecordCount();

// Operations
public:
	// Cursor operations
	void MoveNext();
	void MovePrev();
	void MoveFirst();
	void MoveLast();
	virtual void Move(long lRows);

	BOOL FindNext(LPCTSTR lpszFilter);
	BOOL FindPrev(LPCTSTR lpszFilter);
	BOOL FindFirst(LPCTSTR lpszFilter);
	BOOL FindLast(LPCTSTR lpszFilter);
	virtual BOOL Find(long lFindType, LPCTSTR lpszFilter);

	COleVariant GetBookmark();
	void SetBookmark(COleVariant varBookmark);
	long GetAbsolutePosition();
	void SetAbsolutePosition(long lPosition);
	float GetPercentPosition();
	void SetPercentPosition(float fPosition);

	// seek allowed on recordset opened as tables (max keys = 13)
	BOOL Seek(LPCTSTR lpszComparison, COleVariant* pKey1,
		COleVariant* pKey2 = NULL, COleVariant* pKey3 = NULL);
	BOOL Seek(LPCTSTR lpszComparison, COleVariant* pKeyArray, WORD nKeys);

	// edit buffer operations
	virtual void AddNew();
	virtual void Edit();
	virtual void Update();
	virtual void Delete();
	virtual void CancelUpdate();

	// field operations
	virtual void GetFieldValue(LPCTSTR lpszName, COleVariant& varValue);
	virtual void GetFieldValue(int nIndex, COleVariant& varValue);
	virtual void SetFieldValue(LPCTSTR lpszName,
		const COleVariant& varValue);
	virtual void SetFieldValue(int nIndex,
		const COleVariant& varValue);
	void SetFieldValue(int nIndex, LPCTSTR lpszValue);
	void SetFieldValue(LPCTSTR lpszName, LPCTSTR lpszValue);
	void SetFieldValueNull(LPCTSTR lpszName);
	void SetFieldValueNull(int nIndex);

	virtual COleVariant GetParamValue(LPCTSTR lpszName);
	virtual COleVariant GetParamValue(int nIndex);
	virtual void SetParamValue(LPCTSTR lpszName,
		const COleVariant& varValue);
	virtual void SetParamValue(int nIndex,
		const COleVariant& varValue);
	void SetParamValueNull(LPCTSTR lpszName);
	void SetParamValueNull(int nIndex);

	void SetFieldDirty(void* pv, BOOL bDirty = TRUE);
	void SetFieldNull(void* pv, BOOL bNull = TRUE);

	void SetLockingMode(BOOL bPessimistic);
	BOOL GetLockingMode();

	// Recordset operations
	virtual void Requery();

	// Jet's remote data caching operations
	void SetCacheStart(COleVariant varBookmark);
	COleVariant GetCacheStart();
	void SetCacheSize(long lSize);
	long GetCacheSize();
	void FillCache(long* pSize = NULL, COleVariant* pBookmark = NULL);

	short GetFieldCount();
	void GetFieldInfo(int nIndex, CDaoFieldInfo& fieldinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);
	void GetFieldInfo(LPCTSTR lpszName, CDaoFieldInfo& fieldinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);

	short GetIndexCount();
	void GetIndexInfo(int nIndex, CDaoIndexInfo& indexinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);
	void GetIndexInfo(LPCTSTR lpszName, CDaoIndexInfo& indexinfo,
		DWORD dwInfoOptions = AFX_DAO_PRIMARY_INFO);

// Overridables
public:
	virtual CString GetDefaultDBName();
	virtual CString GetDefaultSQL();

	// for recordset field exchange
	virtual void DoFieldExchange(CDaoFieldExchange* pFX);

// Implementation
public:
	virtual ~CDaoRecordset();

	// Out-of-date functions kept for backward compatability
	virtual COleVariant GetFieldValue(LPCTSTR lpszName);
	virtual COleVariant GetFieldValue(int nIndex);

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	CString m_strSQL;

	CDaoQueryDef* m_pQueryDef;  // Source query for this result set
	CDaoTableDef* m_pTableDef;
	ICDAORecordset* m_pICDAORecordsetGetRows;
	DAOFields* m_pDAOFields;
	DAOIndexes* m_pDAOIndexes;

	void SetCursorAttributes();
	void GetDataAndFixupNulls();
	DWORD GetFieldLength(int nFieldIndex);

	BOOL IsFieldStatusDirty(UINT nField);
	void SetDirtyFieldStatus(UINT nField);
	void ClearDirtyFieldStatus(UINT nField);

	BOOL IsFieldStatusNull(UINT nField);
	void SetNullFieldStatus(UINT nField);
	void ClearNullFieldStatus(UINT nField);

	BOOL IsFieldStatusNullable(UINT nField);
	void SetNullableFieldStatus(UINT nField);

	BOOL IsFieldStatusNullableKnown(UINT nField);
	void SetNullableKnownFieldStatus(UINT nField);

	void ClearFieldStatusFlags();
	BOOL IsMatch();

	DWORD m_cbFixedLengthFields;
	DAOCOLUMNBINDING* m_prgDaoColBindInfo;
	DWORD* m_pulColumnLengths;
	DAOFETCHROWS m_DaoFetchRows;
	BYTE* m_pbFieldFlags;
	BYTE* m_pbParamFlags;

	CMapPtrToPtr* m_pMapFieldCache;
	CMapPtrToPtr* m_pMapFieldIndex;

	static void AFX_CDECL StripBrackets(_In_z_ LPCTSTR lpszSrc, _Pre_notnull_ _Post_z_ LPTSTR lpszDest);

protected:
	BOOL m_bOpen;
	int m_nStatus;

	BOOL m_bAppendable;
	BOOL m_bScrollable;
	BOOL m_bDeleted;

	int m_nOpenType;
	int m_nDefaultType;
	int m_nOptions;

	CString m_strRequerySQL;
	CString m_strRequeryFilter;
	CString m_strRequerySort;

	void BuildSQL();
	void AllocDatabase();

	// RFX Operation Cover Functions
	void BuildSelectList();
	void BuildParameterList();
	void BindFields();
	void BindParameters();
	void Fixup();
	void AllocCache();
	void StoreFields();
	void LoadFields();
	void FreeCache();
	void MarkForEdit();
	void MarkForAddNew();
	int GetFieldIndex(void* pv);
	virtual void SetDirtyFields();

	void InitFieldsCollection();
	void InitIndexesCollection();

	virtual void ThrowDaoException(int nError = NO_AFX_DAO_ERROR);

	friend class CDaoFieldExchange;
	friend class CDaoRecordView;
};

/////////////////////////////////////////////////////////////////////////////
// CDaoRecordView - form for viewing data records

class AFX_NOVTABLE CDaoRecordView : public CFormView
{
	DECLARE_DYNAMIC(CDaoRecordView)

// Construction
protected:  // must derive your own class
	explicit CDaoRecordView(LPCTSTR lpszTemplateName);
	explicit CDaoRecordView(UINT nIDTemplate);

// Attributes
public:
	virtual CDaoRecordset* OnGetRecordset() = 0;

	BOOL IsOnLastRecord();
	BOOL IsOnFirstRecord();

// Operations
public:
	virtual BOOL OnMove(UINT nIDMoveCommand);

// Implementation
public:
	virtual ~CDaoRecordView() = 0;
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual void OnInitialUpdate();

protected:
	int m_nStatus;
	COleVariant m_varBookmarkCurrent;
	COleVariant m_varBookmarkFirst;
	COleVariant m_varBookmarkLast;

	//{{AFX_MSG(CDaoRecordView)
	afx_msg void OnUpdateRecordFirst(CCmdUI* pCmdUI);
	afx_msg void OnUpdateRecordPrev(CCmdUI* pCmdUI);
	afx_msg void OnUpdateRecordNext(CCmdUI* pCmdUI);
	afx_msg void OnUpdateRecordLast(CCmdUI* pCmdUI);
	//}}AFX_MSG
	afx_msg void OnMove(int cx, int cy);

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// DAODBEngine helpers - implementation specific and undocumented
void AFXAPI AfxDaoInit();
DAODBEngine* AFXAPI AfxDaoGetEngine();
void AFXAPI AfxDaoTerm();

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXDAOCORE_INLINE AFX_INLINE
#define _AFXDAODFX_INLINE AFX_INLINE
#define _AFXDAOVIEW_INLINE AFX_INLINE
#include <afxdao.inl>
#undef _AFXDAOCORE_INLINE
#undef _AFXDAODFX_INLINE
#undef _AFXDAOVIEW_INLINE
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifndef _AFX_DISABLE_DEPRECATED
#pragma deprecated( CDaoException )
#pragma deprecated( CDaoRecordView )
#pragma deprecated( CDaoWorkspace )
#pragma deprecated( CDaoDatabase )
#pragma deprecated( CDaoRecordset )
#pragma deprecated( CDaoTableDef )
#pragma deprecated( CDaoQueryDef )
#pragma deprecated( CDaoFieldExchange )
#pragma deprecated( CDaoFieldCache )
#pragma deprecated( CDaoErrorInfo )
#pragma deprecated( CDaoWorkspaceInfo )
#pragma deprecated( CDaoDatabaseInfo )
#pragma deprecated( CDaoTableDefInfo )
#pragma deprecated( CDaoFieldInfo )
#pragma deprecated( CDaoIndexInfo )
#pragma deprecated( CDaoRelationInfo )
#pragma deprecated( CDaoQueryDefInfo )
#pragma deprecated( CDaoParameterInfo )
#endif

#endif //__AFXDAO_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxdb_.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Do not include this file directly (included by AFXDB.H & AFXDAO.H)

#ifndef __AFXDB__H__
#define __AFXDB__H__

#pragma once

#include <sqltypes.h>

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

//////////////////////////////////////////////////////////////////////////////
// Recordset Field exchange for ODBC & DAO classes (RFX_ and DFX_)

#define AFX_RFX_SHORT_PSEUDO_NULL (0x7EE4)
#define AFX_RFX_INT_PSEUDO_NULL (0x7EE4)
#define AFX_RFX_LONG_PSEUDO_NULL (0x4a4d4120L)
#define AFX_RFX_BIGINT_PSEUDO_NULL (0x4a4d4120L)
#define AFX_RFX_BYTE_PSEUDO_NULL 255
#define AFX_RFX_SINGLE_PSEUDO_NULL (-9.123e19f)
#define AFX_RFX_DOUBLE_PSEUDO_NULL (-9.123e19)
#define AFX_RFX_BOOL_PSEUDO_NULL 2
#define AFX_RFX_DATE_PSEUDO_NULL CTime(0)
#define AFX_RFX_TIMESTAMP_PSEUDO_NULL 99

#define AFX_RFX_NO_TYPE     0
#define AFX_RFX_BOOL        1
#define AFX_RFX_BYTE        2
#define AFX_RFX_INT         3
#define AFX_RFX_LONG        4
#define AFX_RFX_SINGLE      6
#define AFX_RFX_DOUBLE      7
#define AFX_RFX_DATE        8
#define AFX_RFX_BINARY      9
#define AFX_RFX_TEXT        10
#define AFX_RFX_LONGBINARY  11
#define AFX_RFX_SHORT       12
#define AFX_RFX_CURRENCY    13
#define AFX_RFX_OLEDATETIME 14
#define AFX_RFX_TIMESTAMP   15
#define AFX_RFX_OLEDATE     16
#define AFX_RFX_LPTSTR      17
#define AFX_RFX_LPWSTR      18
#define AFX_RFX_LPASTR      19
#define AFX_RFX_WTEXT       20
#define AFX_RFX_ATEXT       21
#define AFX_RFX_BIGINT      22

//////////////////////////////////////////////////////////////////////////////
// CLongBinary - a Long (generally > 32k in length) Binary object

class CLongBinary : public CObject
{
	DECLARE_DYNAMIC(CLongBinary)

// Constructors
public:
	CLongBinary();

// Attributes
	HGLOBAL m_hData;
	SQLULEN m_dwDataLength;

// Implementation
public:
	virtual ~CLongBinary();

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif //_DEBUG
};

//////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif // __AFXDB__H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxdb.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXDB_H__
#define __AFXDB_H__

#ifdef _AFX_NO_DB_SUPPORT
	#error Database classes not supported in this library variant.
#endif

#pragma once

#ifndef __AFXEXT_H__
	#include <afxext.h>
#endif

#ifndef __AFXDB__H__
	#include <afxdb_.h> // shared header DAO database classes
#endif

// include standard SQL/ODBC "C" APIs
#ifndef __SQL
	#include <sql.h>        // core
#endif
#ifndef __SQLEXT
	#include <sqlext.h>     // extensions
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 

#ifndef _AFX_NOFORCE_LIBS

/////////////////////////////////////////////////////////////////////////////
// Win32 libraries

#pragma comment(lib, "odbc32.lib")
#pragma comment(lib, "odbccp32.lib")

#endif //!_AFX_NOFORCE_LIBS

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// AFXDB - MFC SQL/ODBC/Database support

// Classes declared in this file

	//CException
		class CDBException;    // abnormal return value

	//CFieldExchange
		class CFieldExchange;       // Recordset Field Exchange

	//CObject
		class CDatabase;    // Connecting to databases
		class CRecordset;   // Data result sets

//CObject
	//CCmdTarget;
		//CWnd
			//CView
				//CScrollView
					//CFormView
						class CRecordView;     // view records with a form

// Non CObject classes
class CDBVariant;
struct CRecordsetStatus;
struct CFieldInfo;
struct CODBCFieldInfo;
struct CODBCParamInfo;

/////////////////////////////////////////////////////////////////////////////

// ODBC helpers
// return code left in 'nRetCode'

// This MACRO is now out-of-date (kept for backward compatibility)
#define AFX_ODBC_CALL(SQLFunc) \
	do \
	{ \
	} while ((nRetCode = (SQLFunc)) == SQL_STILL_EXECUTING)

// Not really required, but kept for compatibilty
#define AFX_SQL_SYNC(SQLFunc) \
	do \
	{ \
		nRetCode = SQLFunc; \
	} while (0)

// Now out-of-date (prs not used) but kept for compatibility
#define AFX_SQL_ASYNC(prs, SQLFunc) AFX_ODBC_CALL(SQLFunc)

// Max display length in chars of timestamp (date & time) value
#define TIMESTAMP_PRECISION 23

// AFXDLL support
#undef AFX_DATA
#define AFX_DATA AFX_DB_DATA

//  Miscellaneous sizing info
#define MAX_CURRENCY     30     // Max size of Currency($) string
#define MAX_TNAME_LEN    64     // Max size of table names
#define MAX_FNAME_LEN    256    // Max size of field names
#define MAX_DBNAME_LEN   32     // Max size of a database name
#define MAX_DNAME_LEN    256    // Max size of Recordset names
#define MAX_CONNECT_LEN  1024   // Max size of Connect string
#define MAX_CURSOR_NAME  18     // Max size of a cursor name
#define DEFAULT_FIELD_TYPE SQL_TYPE_NULL // pick "C" data type to match SQL data type

// Timeout and net wait defaults
#define DEFAULT_LOGIN_TIMEOUT 15    // seconds to before fail on connect
#define DEFAULT_QUERY_TIMEOUT 15    // seconds to before fail waiting for results

// Field Flags, used to indicate status of fields
#define AFX_SQL_FIELD_FLAG_DIRTY    0x1
#define AFX_SQL_FIELD_FLAG_NULL     0x2

// Update options flags
#define AFX_SQL_SETPOSUPDATES       0x0001
#define AFX_SQL_POSITIONEDSQL       0x0002
#define AFX_SQL_GDBOUND             0x0004

/////////////////////////////////////////////////////////////////////////////
// CDBException - something gone wrong

// Dbkit extended error codes
#define AFX_SQL_ERROR                           1000
#define AFX_SQL_ERROR_CONNECT_FAIL              AFX_SQL_ERROR+1
#define AFX_SQL_ERROR_RECORDSET_FORWARD_ONLY    AFX_SQL_ERROR+2
#define AFX_SQL_ERROR_EMPTY_COLUMN_LIST         AFX_SQL_ERROR+3
#define AFX_SQL_ERROR_FIELD_SCHEMA_MISMATCH     AFX_SQL_ERROR+4
#define AFX_SQL_ERROR_ILLEGAL_MODE              AFX_SQL_ERROR+5
#define AFX_SQL_ERROR_MULTIPLE_ROWS_AFFECTED    AFX_SQL_ERROR+6
#define AFX_SQL_ERROR_NO_CURRENT_RECORD         AFX_SQL_ERROR+7
#define AFX_SQL_ERROR_NO_ROWS_AFFECTED          AFX_SQL_ERROR+8
#define AFX_SQL_ERROR_RECORDSET_READONLY        AFX_SQL_ERROR+9
#define AFX_SQL_ERROR_SQL_NO_TOTAL              AFX_SQL_ERROR+10
#define AFX_SQL_ERROR_ODBC_LOAD_FAILED          AFX_SQL_ERROR+11
#define AFX_SQL_ERROR_DYNASET_NOT_SUPPORTED     AFX_SQL_ERROR+12
#define AFX_SQL_ERROR_SNAPSHOT_NOT_SUPPORTED    AFX_SQL_ERROR+13
#define AFX_SQL_ERROR_API_CONFORMANCE           AFX_SQL_ERROR+14
#define AFX_SQL_ERROR_SQL_CONFORMANCE           AFX_SQL_ERROR+15
#define AFX_SQL_ERROR_NO_DATA_FOUND             AFX_SQL_ERROR+16
#define AFX_SQL_ERROR_ROW_UPDATE_NOT_SUPPORTED  AFX_SQL_ERROR+17
#define AFX_SQL_ERROR_ODBC_V2_REQUIRED          AFX_SQL_ERROR+18
#define AFX_SQL_ERROR_NO_POSITIONED_UPDATES     AFX_SQL_ERROR+19
#define AFX_SQL_ERROR_LOCK_MODE_NOT_SUPPORTED   AFX_SQL_ERROR+20
#define AFX_SQL_ERROR_DATA_TRUNCATED            AFX_SQL_ERROR+21
#define AFX_SQL_ERROR_ROW_FETCH                 AFX_SQL_ERROR+22
#define AFX_SQL_ERROR_INCORRECT_ODBC            AFX_SQL_ERROR+23
#define AFX_SQL_ERROR_UPDATE_DELETE_FAILED      AFX_SQL_ERROR+24
#define AFX_SQL_ERROR_DYNAMIC_CURSOR_NOT_SUPPORTED  AFX_SQL_ERROR+25
#define AFX_SQL_ERROR_FIELD_NOT_FOUND           AFX_SQL_ERROR+26
#define AFX_SQL_ERROR_BOOKMARKS_NOT_SUPPORTED   AFX_SQL_ERROR+27
#define AFX_SQL_ERROR_BOOKMARKS_NOT_ENABLED     AFX_SQL_ERROR+28
#define AFX_SQL_ERROR_MAX                       AFX_SQL_ERROR+29

class CDBException : public CException
{
	DECLARE_DYNAMIC(CDBException)

// Attributes
public:
	RETCODE m_nRetCode;
	CString m_strError;
	CString m_strStateNativeOrigin;

// Implementation (use AfxThrowDBException to create)
public:
	/* explicit */ CDBException(RETCODE nRetCode = SQL_SUCCESS);

	virtual void BuildErrorString(CDatabase* pdb, HSTMT hstmt,
		BOOL bTrace = TRUE);
	void Empty();
	virtual ~CDBException();

	virtual BOOL GetErrorMessage(_Out_z_cap_(nMaxError) LPTSTR lpszError, _In_ UINT nMaxError,
		_Out_opt_ PUINT pnHelpContext = NULL) const;

#ifdef _DEBUG
	void TraceErrorMessage(LPCTSTR szTrace) const;
#endif // DEBUG

};

void AFXAPI AfxThrowDBException(RETCODE nRetCode, CDatabase* pdb, HSTMT hstmt);

//////////////////////////////////////////////////////////////////////////////
// CDatabase - a SQL Database

class CDatabase : public CObject
{
	DECLARE_DYNAMIC(CDatabase)

// Constructors
public:
	CDatabase();

	enum DbOpenOptions
	{
		openExclusive =         0x0001, // Not implemented
		openReadOnly =          0x0002, // Open database read only
		useCursorLib =          0x0004, // Use ODBC cursor lib
		noOdbcDialog =          0x0008, // Don't display ODBC Connect dialog
		forceOdbcDialog =       0x0010, // Always display ODBC connect dialog
	};

	virtual BOOL Open(LPCTSTR lpszDSN, BOOL bExclusive = FALSE,
		BOOL bReadonly = FALSE, LPCTSTR lpszConnect = _T("ODBC;"),
		BOOL bUseCursorLib = TRUE);
	virtual BOOL OpenEx(LPCTSTR lpszConnectString, DWORD dwOptions = 0);
	virtual void Close();

// Attributes
public:
	HDBC m_hdbc;

	BOOL IsOpen() const;        // Database successfully opened?
	BOOL CanUpdate() const;
	BOOL CanTransact() const;   // Are Transactions supported?

	CString GetDatabaseName() const;
	const CString& GetConnect() const;

	DWORD GetBookmarkPersistence() const;
	int GetCursorCommitBehavior() const;
	int GetCursorRollbackBehavior() const;

// Operations
public:
	void SetLoginTimeout(DWORD dwSeconds);
	void SetQueryTimeout(DWORD dwSeconds);

	// transaction control
	BOOL BeginTrans();
	BOOL CommitTrans();
	BOOL Rollback();

	void ExecuteSQL(LPCTSTR lpszSQL);

	// Cancel asynchronous operation
	void Cancel();

// Overridables
public:
	// set special options
	virtual void OnSetOptions(HSTMT hstmt);
	virtual void BindParameters(HSTMT hstmt);

// Implementation
public:
	virtual ~CDatabase();

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;

	BOOL m_bTransactionPending;
#endif //_DEBUG

	// general error check
	virtual BOOL Check(RETCODE nRetCode) const;
	BOOL PASCAL CheckHstmt(RETCODE, HSTMT hstmt) const;

	void  ReplaceBrackets(_Inout_z_ LPTSTR lpchSQL);
	BOOL  m_bStripTrailingSpaces;
	BOOL  m_bIncRecordCountOnAdd;
	BOOL  m_bAddForUpdate;
	TCHAR m_chIDQuoteChar;

	void SetSynchronousMode(BOOL bSynchronous); // Obsolete, does nothing

protected:
	CString m_strConnect;

	CPtrList m_listRecordsets;  // maintain list to ensure CRecordsets all closed

	int nRefCount;
	BOOL m_bUpdatable;

	BOOL m_bTransactions;
	SWORD m_nTransactionCapable;
	SWORD m_nCursorCommitBehavior;
	SWORD m_nCursorRollbackBehavior;
	DWORD m_dwUpdateOptions;
	DWORD m_dwBookmarkAttributes;   // cache driver bookmark persistence

	DWORD m_dwLoginTimeout;
	HSTMT m_hstmt;

	DWORD m_dwQueryTimeout;

	virtual void ThrowDBException(RETCODE nRetCode);
	void AllocConnect(DWORD dwOptions);
	BOOL Connect(DWORD dwOptions);
	void VerifyConnect();
	void GetConnectInfo();
	void Free();

	// friend classes that call protected CDatabase overridables
	friend class CRecordset;
	friend class CFieldExchange;
	friend class CDBException;
};

//////////////////////////////////////////////////////////////////////////////
// CFieldExchange - for field exchange
class CFieldExchange
{
// Attributes
public:
	enum RFX_Operation
	{
		BindParam,          // register users parameters with ODBC SQLBindParameter
		RebindParam,        //  migrate param values to proxy array before Requery
		BindFieldToColumn,  // register users fields with ODBC SQLBindCol
		BindFieldForUpdate, // temporarily bind columns before update (via SQLSetPos)
		UnbindFieldForUpdate,   // unbind columns after update (via SQLSetPos)
		Fixup,              // Set string lengths, clear status bits
		MarkForAddNew,      // Prepare fields and flags for addnew operation
		MarkForUpdate,      // Prepare fields and flags for update operation
		Name,               // append dirty field name
		NameValue,          // append dirty name=value
		Value,              // append dirty value or parameter marker
		SetFieldNull,       // Set status bit for null value
		StoreField,         // archive values of current record
		LoadField,          // reload archived values into current record
		AllocCache,         // allocate cache used for dirty field check
		AllocMultiRowBuffer,    // allocate buffer holding multi rows of data
		DeleteMultiRowBuffer,   // delete buffer holding multi rows of data
#ifdef _DEBUG
		DumpField,          // dump bound field name and value
#endif
	};
	UINT m_nOperation;  // Type of exchange operation
	CRecordset* m_prs;  // recordset handle

// Operations
	enum FieldType
	{
		noFieldType     = -1,
		outputColumn    = 0,
		param           = SQL_PARAM_INPUT,
		inputParam      = param,
		outputParam     = SQL_PARAM_OUTPUT,
		inoutParam      = SQL_PARAM_INPUT_OUTPUT,
	};

// Operations (for implementors of RFX procs)
	BOOL IsFieldType(UINT* pnField);

	// Indicate purpose of subsequent RFX calls
	void SetFieldType(UINT nFieldType);

// Implementation
	CFieldExchange(UINT nOperation, CRecordset* prs, void* pvField = NULL);

	void Default(LPCTSTR szName,
		void* pv, LONG_PTR* plLength, int nCType, SQLULEN cbValue, SQLULEN cbPrecision);

	// long binary helpers
	SQLLEN GetLongBinarySize(int nField);
	void GetLongBinaryData(int nField, CLongBinary& lb, SQLLEN* plSize);
	BYTE* ReallocLongBinary(CLongBinary& lb, SQLLEN lSizeRequired,
		SQLLEN lReallocSize);

	// Current type of field
	UINT m_nFieldType;

	UINT m_nFieldFound;

	CString* m_pstr;    // Field name or destination for building various SQL clauses
	BOOL m_bField;      // Value to set for SetField operation
	void* m_pvField;    // For indicating an operation on a specific field
	LPCTSTR m_lpszSeparator; // append after field names
	UINT m_nFields;     // count of fields for various operations
	UINT m_nParams;     // count of fields for various operations
	UINT m_nParamFields;    // count of fields for various operations
	HSTMT m_hstmt;      // For SQLBindParameter on update statement
	SQLLEN m_lDefaultLBFetchSize;     // For fetching CLongBinary data of unknown len
	SQLLEN m_lDefaultLBReallocSize;   // For fetching CLongBinary data of unknown len

#ifdef _DEBUG
	CDumpContext* m_pdcDump;
#endif //_DEBUG

};

/////////////////////////////////////////////////////////////////////////////
// Global helper

HENV AFXAPI AfxGetHENV();

/////////////////////////////////////////////////////////////////////////////
// Recordset Field Exchange helpers

void AFXAPI AfxStoreField(CRecordset& rs, UINT nField, void* pvField);
void AFXAPI AfxLoadField(CRecordset& rs, UINT nField,
	void* pvField, LONG_PTR* plLength);
BOOL AFXAPI AfxCompareValueByRef(void* pvData, void* pvCache, int nDataType);
void AFXAPI AfxCopyValueByRef(void* pvCache, void* pvData,
	LONG_PTR* plLength, int nDataType);

/////////////////////////////////////////////////////////////////////////////
// Standard Recordset Field Exchange routines

// text data
void AFXAPI RFX_Text(CFieldExchange* pFX, LPCTSTR szName, CStringW &value,
	// Default max length for char and varchar, default datasource type
	int nMaxLength = 255, int nColumnType = SQL_VARCHAR, short nScale = 0);
void AFXAPI RFX_Text(CFieldExchange* pFX, LPCTSTR szName, CStringA &value,
	// Default max length for char and varchar, default datasource type
	int nMaxLength = 255, int nColumnType = SQL_VARCHAR, short nScale = 0);

void AFXAPI RFX_Text(_In_ CFieldExchange* pFX, _In_z_ LPCTSTR szName, _Out_cap_(nMaxLength) _Pre_notnull_ _Post_z_ LPWSTR value,
	_In_ int nMaxLength, _In_ int nColumnType = SQL_VARCHAR, _In_ short nScale = 0);
void AFXAPI RFX_Text(_In_ CFieldExchange* pFX, _In_ LPCTSTR szName, _Out_cap_(nMaxLength) _Pre_notnull_ _Post_z_ LPSTR value,
	_In_ int nMaxLength, _In_ int nColumnType = SQL_VARCHAR, _In_ short nScale = 0);

// boolean data
void AFXAPI RFX_Bool(CFieldExchange* pFX, LPCTSTR szName, BOOL& value);

// integer data
void AFXAPI RFX_Long(CFieldExchange* pFX, LPCTSTR szName, long& value);
void AFXAPI RFX_Int(CFieldExchange* pFX, LPCTSTR szName, int& value);
void AFXAPI RFX_Single(CFieldExchange* pFX, LPCTSTR szName, float& value);
void AFXAPI RFX_Double(CFieldExchange* pFX, LPCTSTR szName, double& value);
void AFXAPI RFX_BigInt(CFieldExchange* pFX, LPCTSTR szName, LONGLONG& value);

// date and time
void AFXAPI RFX_Date(CFieldExchange* pFX, LPCTSTR szName, CTime& value);
void AFXAPI RFX_Date(CFieldExchange* pFX, LPCTSTR szName, TIMESTAMP_STRUCT& value);
void AFXAPI RFX_Date(CFieldExchange* pFX, LPCTSTR szName, COleDateTime& value);

// Binary data
void AFXAPI RFX_Binary(CFieldExchange* pFX, LPCTSTR szName, CByteArray& value,
	// Default max length is for binary and varbinary
	INT_PTR nMaxLength = 255);
void AFXAPI RFX_Byte(CFieldExchange* pFX, LPCTSTR szName, BYTE& value);
void AFXAPI RFX_LongBinary(CFieldExchange* pFX, LPCTSTR szName, CLongBinary& value);

/////////////////////////////////////////////////////////////////////////////
// Bulk Recordset Field Exchange helpers
void AFXAPI AfxRFXBulkDefault(CFieldExchange* pFX, LPCTSTR szName,
	void* pv, LONG_PTR* rgLengths, int nCType, SQLULEN cbValue);

/////////////////////////////////////////////////////////////////////////////
// Bulk Recordset Field Exchange routines

void AFXAPI RFX_Text_Bulk(CFieldExchange* pFX, LPCTSTR szName,
	_Out_ _Deref_post_cap_(nMaxLength) LPWSTR* prgStrVals, LONG_PTR** prgLengths, int nMaxLength);
void AFXAPI RFX_Text_Bulk(CFieldExchange* pFX, LPCTSTR szName,
	_Out_ _Deref_post_cap_(nMaxLength) LPSTR* prgStrVals, LONG_PTR** prgLengths, int nMaxLength);

void AFXAPI RFX_Bool_Bulk(CFieldExchange* pFX, LPCTSTR szName,
	BOOL** prgBoolVals, LONG_PTR** prgLengths);
void AFXAPI RFX_Int_Bulk(CFieldExchange* pFX, LPCTSTR szName,
	int** prgIntVals, LONG_PTR** prgLengths);
void AFXAPI RFX_Long_Bulk(CFieldExchange* pFX, LPCTSTR szName,
	long** prgLongVals, LONG_PTR** prgLengths);

void AFXAPI RFX_Single_Bulk(CFieldExchange* pFX, LPCTSTR szName,
	float** prgFltVals, LONG_PTR** prgLengths);
void AFXAPI RFX_Double_Bulk(CFieldExchange* pFX, LPCTSTR szName,
	double** prgDblVals, LONG_PTR** prgLengths);

void AFXAPI RFX_Date_Bulk(CFieldExchange* pFX, LPCTSTR szName,
	TIMESTAMP_STRUCT** prgTSVals, LONG_PTR** prgLengths);

void AFXAPI RFX_Byte_Bulk(CFieldExchange* pFX, LPCTSTR szName,
	BYTE** prgByteVals, LONG_PTR** prgLengths);
void AFXAPI RFX_Binary_Bulk(CFieldExchange* pFX, LPCTSTR szName,
	BYTE** prgByteVals, LONG_PTR** prgLengths, int nMaxLength);

/////////////////////////////////////////////////////////////////////////////
// Database Dialog Data Exchange cover routines
// Cover routines provide database semantics on top of DDX routines

// simple text operations
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, BYTE& value,
	CRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, int& value,
	CRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, UINT& value,
	CRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, long& value,
	CRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, DWORD& value,
	CRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, CString& value,
	CRecordset* pRecordset);
void AFXAPI DDX_FieldText(_In_ CDataExchange* pDX, _In_ int nIDC, _Out_z_cap_(nMaxLen) LPTSTR pstrValue,
	_In_ int nMaxLen, _In_ CRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, double& value,
	CRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, float& value,
	CRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, CTime& value,
	CRecordset* pRecordset);

// special control types
void AFXAPI DDX_FieldCheck(CDataExchange* pDX, int nIDC, int& value,
	CRecordset* pRecordset);
void AFXAPI DDX_FieldRadio(CDataExchange* pDX, int nIDC, int& value,
	CRecordset* pRecordset);
void AFXAPI DDX_FieldLBString(CDataExchange* pDX, int nIDC,
	CString& value,
	CRecordset* pRecordset);
void AFXAPI DDX_FieldCBString(CDataExchange* pDX, int nIDC,
	CString& value,
	CRecordset* pRecordset);
void AFXAPI DDX_FieldLBIndex(CDataExchange* pDX, int nIDC, int& index,
	CRecordset* pRecordset);
void AFXAPI DDX_FieldCBIndex(CDataExchange* pDX, int nIDC, int& index,
	CRecordset* pRecordset);
void AFXAPI DDX_FieldLBStringExact(CDataExchange* pDX, int nIDC,
	CString& value,
	CRecordset* pRecordset);
void AFXAPI DDX_FieldCBStringExact(CDataExchange* pDX, int nIDC,
	CString& value,
	CRecordset* pRecordset);
void AFXAPI DDX_FieldScroll(CDataExchange* pDX, int nIDC, int& value,
	CRecordset* pRecordset);

//////////////////////////////////////////////////////////////////////////////
// CRecordset - the result of a SQL Statement

#define AFX_DB_USE_DEFAULT_TYPE     (0xFFFFFFFF)

// Most Move constants out of date
// #define AFX_MOVE_FIRST      0x80000000L
// #define AFX_MOVE_PREVIOUS   (-1L)
// #define AFX_MOVE_NEXT       (+1L)
// #define AFX_MOVE_LAST       0x7fffffffL

#define AFX_MOVE_REFRESH       0L

#define AFX_RECORDSET_STATUS_OPEN    (+1L)
#define AFX_RECORDSET_STATUS_CLOSED  0L
#define AFX_RECORDSET_STATUS_UNKNOWN (-1L)

class CRecordset : public CObject
{
	DECLARE_DYNAMIC(CRecordset)

// Constructor
public:
	/* explicit */ CRecordset(CDatabase* pDatabase = NULL);

public:
	virtual ~CRecordset();

	enum OpenType
	{
		dynaset,        // uses SQLExtendedFetch, keyset driven cursor
		snapshot,       // uses SQLExtendedFetch, static cursor
		forwardOnly,    // uses SQLFetch
		dynamic         // uses SQLExtendedFetch, dynamic cursor
	};

	enum OpenOptions
	{
		none =                      0x0,
		readOnly =                  0x0004,
		appendOnly =                0x0008,
		skipDeletedRecords =        0x0010, // turn on skipping of deleted records, Will slow Move(n).
		noDirtyFieldCheck =         0x0020, // disable automatic dirty field checking
		useBookmarks =              0x0100, // turn on bookmark support
		useMultiRowFetch =          0x0200, // turn on multi-row fetch model
		userAllocMultiRowBuffers =  0x0400, // if multi-row fetch on, user will alloc memory for buffers
		useExtendedFetch =          0x0800, // use SQLExtendedFetch with forwardOnly type recordsets
		executeDirect =             0x2000, // Directly execute SQL rather than prepared execute
		optimizeBulkAdd =           0x4000, // Use prepared HSTMT for multiple AddNews, dirty fields must not change.
		firstBulkAdd =              0x8000, // INTERNAL to MFC, don't specify on Open.
	};
	virtual BOOL Open(UINT nOpenType = AFX_DB_USE_DEFAULT_TYPE,
		LPCTSTR lpszSQL = NULL, DWORD dwOptions = none);
	virtual void Close();

// Attributes
public:
	HSTMT m_hstmt;          // Source statement for this resultset
	CDatabase* m_pDatabase;       // Source database for this resultset

	CString m_strFilter;        // Where clause
	CString m_strSort;      // Order By Clause

	BOOL CanAppend() const;     // Can AddNew be called?
	BOOL CanRestart() const;    // Can Requery be called to restart a query?
	BOOL CanScroll() const;     // Can MovePrev and MoveFirst be called?
	BOOL CanTransact() const;   // Are Transactions supported?
	BOOL CanUpdate() const;     // Can Edit/AddNew/Delete be called?
	BOOL CanBookmark() const;       // Can Get/SetBookmark be called?

	const CString& GetSQL() const;      // SQL executed for this recordset
	const CString& GetTableName() const;        // Table name

	BOOL IsOpen() const;        // Recordset successfully opened?
	BOOL IsBOF() const;     // Beginning Of File
	BOOL IsEOF() const;     // End Of File
	BOOL IsDeleted() const;     // On a deleted record

	BOOL IsFieldDirty(void *pv);    // has field been updated?
	BOOL IsFieldNull(void *pv); // is field NULL valued?
	BOOL IsFieldNullable(void *pv); // can field be set to a NULL value

	long GetRecordCount() const;        // Records seen so far or -1 if unknown
	void GetStatus(CRecordsetStatus& rStatus) const;

// Operations
public:
	// cursor operations
	void MoveNext();
	void MovePrev();
	void MoveFirst();
	void MoveLast();
	virtual void Move(long nRows, WORD wFetchType = SQL_FETCH_RELATIVE);

	void SetAbsolutePosition(long nRows);

	void GetBookmark(CDBVariant& varBookmark);
	void SetBookmark(const CDBVariant& varBookmark);

	virtual void SetRowsetSize(DWORD dwNewRowsetSize);
	DWORD GetRowsetSize() const;
	SQLULEN GetRowsFetched() const;
	virtual void CheckRowsetError(RETCODE nRetCode);
	void RefreshRowset(WORD wRow, WORD wLockType = SQL_LOCK_NO_CHANGE);
	void SetRowsetCursorPosition(WORD wRow, WORD wLockType = SQL_LOCK_NO_CHANGE);
	WORD GetRowStatus(WORD wRow) const;

	// edit buffer operations
	virtual void AddNew();      // add new record at the end
	virtual void Edit();        // start editing
	virtual BOOL Update();      // update it
	virtual void Delete();      // delete the current record
	void CancelUpdate();        // cancel pending Edit/AddNew

	BOOL FlushResultSet();

	// field operations
	short GetODBCFieldCount() const;
	void GetODBCFieldInfo(short nIndex, CODBCFieldInfo& fieldinfo);
	void GetODBCFieldInfo(LPCTSTR lpszName, CODBCFieldInfo& fieldinfo);

	void GetFieldValue(LPCTSTR lpszName, CDBVariant& varValue,
		short nFieldType = DEFAULT_FIELD_TYPE);
	void GetFieldValue(short nIndex, CDBVariant& varValue,
		short nFieldType = DEFAULT_FIELD_TYPE);

	void GetFieldValue(LPCTSTR lpszName, CStringW &strValue);
	void GetFieldValue(LPCTSTR lpszName, CStringA &strValue);
	void GetFieldValue(short nIndex, CStringW &strValue);
	void GetFieldValue(short nIndex, CStringA &strValue);

private:
	template<typename StringType>
	inline void GetFieldValueEx(short nIndex, StringType &strValue, short nFieldType)
	{
		ASSERT_VALID(this);
		ASSERT(IsOpen());

		// No data or no column info fetched yet
		if (GetODBCFieldCount() <= 0)
		{
			ASSERT(FALSE);
			return;
		}

		// Convert index to 1-based and check range
		nIndex++;
		if (nIndex < 1 || nIndex > GetODBCFieldCount())
		{
			ThrowDBException(AFX_SQL_ERROR_FIELD_NOT_FOUND);
		}

		SQLLEN nLen = GetTextLen(m_rgODBCFieldInfos[nIndex - 1].m_nSQLType,
				m_rgODBCFieldInfos[nIndex - 1].m_nPrecision);
		if (nLen > INT_MAX)
			AfxThrowMemoryException();
		void* pvData = strValue.GetBufferSetLength(int(nLen));

		// Now can actually get the data
		SQLLEN nActualSize = GetData(m_pDatabase, m_hstmt, nIndex,
			nFieldType, pvData, nLen * sizeof(StringType::XCHAR),
 			m_rgODBCFieldInfos[nIndex - 1].m_nSQLType);

		// Handle NULL data separately
		if (nActualSize == SQL_NULL_DATA)
		{
			// Clear value
			strValue.Empty();
		}
		else
		{
			// May need to cleanup and call SQLGetData again if necessary
			GetLongCharDataAndCleanup(m_pDatabase, m_hstmt, nIndex,
				nActualSize / (sizeof(StringType::XCHAR)), &pvData, nLen, strValue,
				m_rgODBCFieldInfos[nIndex - 1].m_nSQLType, nFieldType);
		}
	}

	template<typename StringType>
	void GetFieldValueEx(LPCTSTR lpszName, StringType &strValue)
	{
		ASSERT_VALID(this);
		ASSERT(IsOpen());
		ASSERT(lpszName != NULL);

		// No data or no column info fetched yet
		if (GetODBCFieldCount() <= 0)
		{
			ASSERT(FALSE);
			return;
		}

		// Get the index of the field corresponding to name
		short nField = GetFieldIndexByName(lpszName);

		GetFieldValue(nField, strValue);
	}

public:
	void SetFieldDirty(void *pv, BOOL bDirty = TRUE);
	void SetFieldNull(void *pv, BOOL bNull = TRUE);
	void SetParamNull(int nIndex, BOOL bNull = TRUE);

	// locking control during Edit
	enum LockMode
	{
		optimistic,
		pessimistic,
	};
	void SetLockingMode(UINT nMode);

	// Recordset operations
	virtual BOOL Requery();         // Re-execute query based on new params

	// Cancel asynchronous operation
	void Cancel();

// Overridables
public:
	// Get default connect string
	virtual CString GetDefaultConnect();

	// Get SQL to execute
	virtual CString GetDefaultSQL();

	// set special options
	virtual void OnSetOptions(HSTMT hstmt);
	virtual void OnSetUpdateOptions(HSTMT hstmt);

	// for recordset field exchange
	virtual void DoFieldExchange(CFieldExchange* pFX);
	virtual void DoBulkFieldExchange(CFieldExchange* pFX);

// Implementation
public:
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif //_DEBUG

	virtual BOOL Check(RETCODE nRetCode) const; // general error check

	void InitRecord();
	void ResetCursor();
	void CheckRowsetCurrencyStatus(UWORD wFetchType, long nRows);
	RETCODE FetchData(UWORD wFetchType, SDWORD nRow,
		SQLULEN* pdwRowsFetched);
	void SkipDeletedRecords(UWORD wFetchType, long nRows,
		SQLULEN* pdwRowsFetched, RETCODE* pnRetCode);
	virtual void SetRowsetCurrencyStatus(RETCODE nRetCode,
		UWORD wFetchType, long nRows, SQLULEN dwRowsFetched);

	virtual void PreBindFields();   // called before data fields are bound
	UINT m_nFields;         // number of RFX fields
	UINT m_nParams;         // number of RFX params
	BOOL m_bCheckCacheForDirtyFields;   // switch for dirty field checking
	BOOL m_bRebindParams;     // date or UNICODE text parameter existence flag
	BOOL m_bLongBinaryColumns;  // long binary column existence flag
	BOOL m_bUseUpdateSQL;   // uses SQL-based updates
	DWORD m_dwOptions;          // archive dwOptions on Open
	SWORD m_nResultCols;    // number of columns in result set
	BOOL m_bUseODBCCursorLib;   // uses ODBC cursor lib if m_pDatabase not Open
	CODBCFieldInfo* m_rgODBCFieldInfos; // Array of field info structs with ODBC meta-data
	CFieldInfo* m_rgFieldInfos;         // Array of field info structs with MFC specific field data
	CMapPtrToPtr m_mapFieldIndex;       // Map of member address to field index
	CMapPtrToPtr m_mapParamIndex;       // Map of member address to field index

	BOOL IsSQLUpdatable(LPCTSTR lpszSQL);
	BOOL IsSelectQueryUpdatable(LPCTSTR lpszSQL);
	static BOOL PASCAL IsJoin(LPCTSTR lpszJoinClause);
	static LPCTSTR PASCAL FindSQLToken(LPCTSTR lpszSQL, LPCTSTR lpszSQLToken);

	// RFX Operations on fields of CRecordset
	UINT BindParams(HSTMT hstmt);
	void RebindParams(HSTMT hstmt);
	UINT BindFieldsToColumns();
	void BindFieldsForUpdate();
	void UnbindFieldsForUpdate();
	void Fixups();
	UINT AppendNames(CString* pstr, LPCTSTR szSeparator);
	UINT AppendValues(HSTMT hstmt, CString* pstr, LPCTSTR szSeparator);
	UINT AppendNamesValues(HSTMT hstmt, CString* pstr, LPCTSTR szSeparator);
	void StoreFields();
	void LoadFields();
	void MarkForAddNew();
	void MarkForUpdate();
	void AllocDataCache();
	void FreeDataCache();
#ifdef _DEBUG
	void DumpFields(CDumpContext& dc) const;
#endif //_DEBUG

	// RFX operation helper functions
	virtual void ThrowDBException(RETCODE nRetCode, HSTMT hstmt = SQL_NULL_HSTMT);

	int GetBoundFieldIndex(void* pv);
	int GetBoundParamIndex(void* pv);
	short GetFieldIndexByName(LPCTSTR lpszFieldName);

	void AllocStatusArrays();
	LONG_PTR* GetFieldLengthBuffer(DWORD nField, int nFieldType);   // for fields & params

	BYTE GetFieldStatus(DWORD nField);
	void SetFieldStatus(DWORD nField, BYTE bFlags);
	void ClearFieldStatus();

	BOOL IsFieldStatusDirty(DWORD nField) const;
	void SetDirtyFieldStatus(DWORD nField);
	void ClearDirtyFieldStatus(DWORD nField);

	BOOL IsFieldStatusNull(DWORD nField) const;
	void SetNullFieldStatus(DWORD nField);
	void ClearNullFieldStatus(DWORD nField);

	BOOL IsParamStatusNull(DWORD nField) const;
	void SetNullParamStatus(DWORD nField);
	void ClearNullParamStatus(DWORD nField);

	BOOL IsFieldNullable(DWORD nField) const;

	void** m_pvFieldProxy;
	void** m_pvParamProxy;
	UINT m_nProxyFields;
	UINT m_nProxyParams;

	// GetFieldValue helpers
	static short PASCAL GetDefaultFieldType(short nSQLType);
	static void* PASCAL GetDataBuffer(CDBVariant& varValue, short nFieldType,
		SQLLEN* pnLen, short nSQLType, SQLULEN nPrecision);
	static SQLLEN PASCAL GetTextLen(short nSQLType, SQLULEN nPrecision);
	static SQLLEN PASCAL GetData(CDatabase* pdb, HSTMT hstmt, short nFieldIndex,
		short nFieldType, LPVOID pvData, SQLLEN nLen, short nSQLType);
	static void PASCAL GetLongBinaryDataAndCleanup(CDatabase* pdb, HSTMT hstmt,
		short nFieldIndex, SQLLEN nActualSize, LPVOID* ppvData, SQLLEN nLen,
		CDBVariant& varValue, short nSQLType);

	static void PASCAL GetLongCharDataAndCleanup(CDatabase* pdb, HSTMT hstmt,
		short nFieldIndex, SQLLEN nActualSize, LPVOID* ppvData, SQLLEN nLen,
		CStringW& strValue, short nSQLType, short nSQLCType = SQL_C_WCHAR);

	static void PASCAL GetLongCharDataAndCleanup(CDatabase* pdb, HSTMT hstmt,
		short nFieldIndex, SQLLEN nActualSize, LPVOID* ppvData, SQLLEN nLen,
		CStringA& strValue, short nSQLType, short nSQLCType = SQL_C_CHAR);

protected:
	UINT m_nOpenType;
	UINT m_nDefaultType;
	enum EditMode
	{
		noMode,
		edit,
		addnew
	};
	long m_lOpen;
	UINT m_nEditMode;
	BOOL m_bEOFSeen;
	long m_lRecordCount;
	long m_lCurrentRecord;
	CString m_strCursorName;
	// Perform operation based on m_nEditMode
	BOOL UpdateInsertDelete();
	BOOL m_nLockMode;       // Control concurrency for Edit()
	UDWORD m_dwDriverConcurrency;   // driver supported concurrency types
	UDWORD m_dwConcurrency; // requested concurrency type
	UWORD* m_rgRowStatus;     // row status used by SQLExtendedFetch and SQLSetPos
	SQLULEN m_dwRowsFetched;  // number of rows fetched by SQLExtendedFetch
	HSTMT m_hstmtUpdate;
	BOOL m_bRecordsetDb;
	BOOL m_bBOF;
	BOOL m_bEOF;
	BOOL m_bUpdatable;      // Is recordset updatable?
	BOOL m_bAppendable;
	CString m_strSQL;       // SQL statement for recordset
	CString m_strUpdateSQL; // SQL statement for updates
	CString m_strTableName;     // source table of recordset
	BOOL m_bScrollable; // supports MovePrev
	BOOL m_bDeleted;
	int m_nFieldsBound;
	BYTE* m_pbFieldFlags;
	BYTE* m_pbParamFlags;
	LONG_PTR* m_plParamLength;
	DWORD m_dwInitialGetDataLen;    // Initial GetFieldValue alloc size for long data
	DWORD m_dwRowsetSize;
	DWORD m_dwAllocatedRowsetSize;

protected:
	CString m_strRequerySQL;    // archive SQL string for use in Requery()
	CString m_strRequeryFilter; // archive filter string for use in Requery()
	CString m_strRequerySort;   // archive sort string for use in Requery()

	void SetState(int nOpenType, LPCTSTR lpszSQL, DWORD dwOptions);
	BOOL AllocHstmt();
	void BuildSQL(LPCTSTR lpszSQL);
	void PrepareAndExecute();

	void BuildSelectSQL();
	void AppendFilterAndSortSQL();
	BOOL IsRecordsetUpdatable();

	void VerifyDriverBehavior();
	DWORD VerifyCursorSupport();
	void EnableBookmarks();
	void SetUpdateMethod();
	void SetConcurrencyAndCursorType(HSTMT hstmt, DWORD dwScrollOptions);
	void AllocAndCacheFieldInfo();
	void AllocRowset();
	void FreeRowset();

	void ExecuteSetPosUpdate();
	void PrepareUpdateHstmt();
	void BuildUpdateSQL();
	void ExecuteUpdateSQL();
	void SendLongBinaryData(HSTMT hstmt);
	virtual SQLLEN GetLBFetchSize(SQLLEN lOldSize);     // CLongBinary fetch chunking
	virtual SQLLEN GetLBReallocSize(SQLLEN lOldSize);   // CLongBinary realloc chunking

	friend class CFieldExchange;
	friend class CRecordView;
};

/////////////////////////////////////////////////////////////////////////////
// Info helper definitions
#define AFX_CURRENT_RECORD_UNDEFINED (-2)
#define AFX_CURRENT_RECORD_BOF (-1)

// For returning status for a recordset
struct CRecordsetStatus
{
	long m_lCurrentRecord;  // -2=Unknown,-1=BOF,0=1st record. . .
	BOOL m_bRecordCountFinal;// Have we counted all records?
};

#pragma warning( push )
#pragma warning( disable: 4121 )

// Must maintian data binding info
struct CFieldInfo
{
	// MFC specific info
	void* m_pvDataCache;
	LONG_PTR m_nLength;
	int m_nDataType;
	BYTE m_bStatus;
#ifdef _DEBUG
	void* m_pvBindAddress;
#endif
};

#pragma warning( pop )

struct CODBCFieldInfo
{
	// meta data from ODBC
	CString m_strName;
	SWORD m_nSQLType;
	SQLULEN m_nPrecision;
	SWORD m_nScale;
	SWORD m_nNullability;
};

struct CODBCParamInfo
{
	// meta data from ODBC
	SWORD m_nSQLType;
	UDWORD m_nPrecision;
	SWORD m_nScale;
	SWORD m_nNullability;
};


/////////////////////////////////////////////////////////////////////////////
// CDBVariant

#define DBVT_NULL       0
#define DBVT_BOOL       1
#define DBVT_UCHAR      2
#define DBVT_SHORT      3
#define DBVT_LONG       4
#define DBVT_SINGLE     5
#define DBVT_DOUBLE     6
#define DBVT_DATE       7
#define DBVT_STRING     8
#define DBVT_BINARY     9
#define DBVT_ASTRING    10
#define DBVT_WSTRING    11

class CDBVariant
{
// Constructor
public:
	CDBVariant();

// Attributes
public:
	DWORD m_dwType;

	union
	{
	  BOOL              m_boolVal;
	  unsigned char     m_chVal;
	  short             m_iVal;
	  long              m_lVal;
	  float             m_fltVal;
	  double            m_dblVal;
	  TIMESTAMP_STRUCT* m_pdate;
	  CString*          m_pstring;
	  CLongBinary*      m_pbinary;
	  CStringA*			m_pstringA;
	  CStringW*			m_pstringW;
	};

// Operations
	void Clear();

// Implementation
public:
	virtual ~CDBVariant();
};

/////////////////////////////////////////////////////////////////////////////
// CRecordView - form for viewing data records

class AFX_NOVTABLE CRecordView : public CFormView
{
	DECLARE_DYNAMIC(CRecordView)

// Construction
protected:  // must derive your own class
	explicit CRecordView(LPCTSTR lpszTemplateName);
	explicit CRecordView(UINT nIDTemplate);

// Attributes
public:
	virtual CRecordset* OnGetRecordset() = 0;

	BOOL IsOnLastRecord();
	BOOL IsOnFirstRecord();

// Operations
public:
	virtual BOOL OnMove(UINT nIDMoveCommand);

// Implementation
public:
	virtual ~CRecordView() = 0;
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual void OnInitialUpdate();

protected:
	BOOL m_bOnFirstRecord;
	BOOL m_bOnLastRecord;

	//{{AFX_MSG(CRecordView)
	afx_msg void OnUpdateRecordFirst(CCmdUI* pCmdUI);
	afx_msg void OnUpdateRecordPrev(CCmdUI* pCmdUI);
	afx_msg void OnUpdateRecordNext(CCmdUI* pCmdUI);
	afx_msg void OnUpdateRecordLast(CCmdUI* pCmdUI);
	//}}AFX_MSG
	afx_msg void OnMove(int cx, int cy);

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXDBCORE_INLINE AFX_INLINE
#define _AFXDBRFX_INLINE AFX_INLINE
#define _AFXDBVIEW_INLINE AFX_INLINE
#include <afxdb.inl>
#undef _AFXDBVIEW_INLINE
#undef _AFXDBCORE_INLINE
#undef _AFXDBRFX_INLINE
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXDB_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxdb.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXDB.H

#pragma once

/////////////////////////////////////////////////////////////////////////////
// General database inlines

#ifdef _AFXDBCORE_INLINE

// CDatabase inlines
_AFXDBCORE_INLINE BOOL CDatabase::IsOpen() const
	{ ASSERT_VALID(this); return m_hdbc != SQL_NULL_HDBC; }
_AFXDBCORE_INLINE BOOL CDatabase::CanUpdate() const
	{ ASSERT(IsOpen()); return m_bUpdatable; }
_AFXDBCORE_INLINE BOOL CDatabase::CanTransact() const
	{ ASSERT(IsOpen()); return m_bTransactions; }
_AFXDBCORE_INLINE void CDatabase::SetLoginTimeout(DWORD dwSeconds)
	{ ASSERT_VALID(this); m_dwLoginTimeout = dwSeconds; }
_AFXDBCORE_INLINE void CDatabase::SetQueryTimeout(DWORD dwSeconds)
	{ ASSERT_VALID(this); m_dwQueryTimeout = dwSeconds; }
_AFXDBCORE_INLINE const CString& CDatabase::GetConnect() const
	{ ASSERT_VALID(this); return m_strConnect; }
_AFXDBCORE_INLINE DWORD CDatabase::GetBookmarkPersistence() const
	{ ASSERT_VALID(this); return m_dwBookmarkAttributes; }
_AFXDBCORE_INLINE int CDatabase::GetCursorCommitBehavior() const
	{ ASSERT_VALID(this); return m_nCursorCommitBehavior; }
_AFXDBCORE_INLINE int CDatabase::GetCursorRollbackBehavior() const
	{ ASSERT_VALID(this); return m_nCursorRollbackBehavior; }
_AFXDBCORE_INLINE void CDatabase::ThrowDBException(RETCODE nRetCode)
	{ ASSERT_VALID(this); AfxThrowDBException(nRetCode, this, m_hstmt); }
_AFXDBCORE_INLINE void CDatabase::SetSynchronousMode(BOOL /* bSynchronous */ )
	{ ASSERT_VALID(this); TRACE(_T("Error: SetSynchronousMode is obsolete and has no effect.\n")); }

// CRecordset inlines
_AFXDBCORE_INLINE const CString& CRecordset::GetSQL() const
	{ ASSERT(IsOpen()); return m_strSQL; }
_AFXDBCORE_INLINE const CString& CRecordset::GetTableName() const
	{ ASSERT(IsOpen()); return m_strTableName; }
_AFXDBCORE_INLINE BOOL CRecordset::IsBOF() const
	{ ASSERT(IsOpen()); return m_bBOF; }
_AFXDBCORE_INLINE BOOL CRecordset::IsEOF() const
	{ ASSERT(IsOpen()); return m_bEOF; }
_AFXDBCORE_INLINE BOOL CRecordset::IsDeleted() const
	{ ASSERT(IsOpen()); return m_bDeleted; }
_AFXDBCORE_INLINE BOOL CRecordset::CanUpdate() const
	{ ASSERT(IsOpen()); return m_bUpdatable; }
_AFXDBCORE_INLINE BOOL CRecordset::CanScroll() const
	{ ASSERT(IsOpen()); return m_bScrollable; }
_AFXDBCORE_INLINE BOOL CRecordset::CanAppend() const
	{ ASSERT(IsOpen()); return m_bAppendable; }
_AFXDBCORE_INLINE BOOL CRecordset::CanRestart() const
	{ ASSERT(IsOpen()); return !(m_dwOptions & executeDirect); }
_AFXDBCORE_INLINE BOOL CRecordset::CanTransact() const
	{ ASSERT(m_pDatabase != NULL );
		if( m_pDatabase == NULL )
			AfxThrowUserException();
		ASSERT(m_pDatabase->IsOpen());
		return m_pDatabase->m_bTransactions; }
_AFXDBCORE_INLINE short CRecordset::GetODBCFieldCount() const
	{ ASSERT(IsOpen()); return m_nResultCols; }
_AFXDBCORE_INLINE DWORD CRecordset::GetRowsetSize() const
	{ ASSERT(IsOpen()); return m_dwRowsetSize; }
_AFXDBCORE_INLINE SQLULEN CRecordset::GetRowsFetched() const
	{ ASSERT(IsOpen()); return m_dwRowsFetched; }
_AFXDBCORE_INLINE WORD CRecordset::GetRowStatus(WORD wRow) const
	{ ASSERT(IsOpen()); ASSERT(wRow > 0); return m_rgRowStatus[wRow-1]; }
_AFXDBCORE_INLINE long CRecordset::GetRecordCount() const
	{ ASSERT(IsOpen()); return m_lRecordCount; }
_AFXDBCORE_INLINE void CRecordset::GetStatus(CRecordsetStatus& rStatus) const
	{ ASSERT(IsOpen());
		rStatus.m_lCurrentRecord = m_lCurrentRecord;
		rStatus.m_bRecordCountFinal = m_bEOFSeen; }
_AFXDBCORE_INLINE void CRecordset::ThrowDBException(RETCODE nRetCode, HSTMT hstmt)
	{ ASSERT_VALID(this); AfxThrowDBException(nRetCode, m_pDatabase,
		(hstmt == SQL_NULL_HSTMT)? m_hstmt : hstmt); }
_AFXDBCORE_INLINE void CRecordset::MoveNext()
	{ ASSERT(IsOpen()); Move(1, SQL_FETCH_NEXT); }
_AFXDBCORE_INLINE void CRecordset::MovePrev()
	{ ASSERT(IsOpen()); Move(-1, SQL_FETCH_PRIOR); }
_AFXDBCORE_INLINE void CRecordset::MoveFirst()
	{ ASSERT(IsOpen()); Move(1, SQL_FETCH_FIRST); }
_AFXDBCORE_INLINE void CRecordset::MoveLast()
	{ ASSERT(IsOpen()); Move(-1, SQL_FETCH_LAST); }
_AFXDBCORE_INLINE void CRecordset::SetAbsolutePosition(long nRows)
	{ ASSERT(IsOpen()); Move(nRows, SQL_FETCH_ABSOLUTE); }

#endif //_AFXDBCORE_INLINE

#ifdef _AFXDBRFX_INLINE

_AFXDBRFX_INLINE void CFieldExchange::SetFieldType(UINT nFieldType)
	{ ASSERT(nFieldType == outputColumn ||
		nFieldType == inputParam ||
		nFieldType == outputParam ||
		nFieldType == inoutParam);
		m_nFieldType = nFieldType; }

#endif //_AFXDBRFX_INLINE

#ifdef _AFXDBVIEW_INLINE

// CRecordView inlines
_AFXDBVIEW_INLINE void CRecordView::OnMove(int cx, int cy)
	{ CFormView::OnMove(cx, cy); }

#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxdatarecovery.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

/////////////////////////////////////////////////////////////////////////////
// The CDataRecoveryHandler does the bulk of the work in all restart scenarios,
// whether the restart is due to the Restart Manager (like in a component upgrade
// scenario) or due to application recovery (like in a hang or crash scenario.
//
// The component upgrade scenario goes like this:
// The application is sent the WM_QUERYENDSESSION, WM_ENDSESSION and WM_CLOSE
// messages.  In the WM_CLOSE, the application calls the CDataRecoveryHandler
// to auto-save any dirty documents (via AutosaveAllDocumentInfo, which in turn
// calls AutosaveDocumentInfo for each open document).  This ensures both that
// the document is in the list of open documents and that the document is saved
// to a temporary auto-save location.  The list of open documents is then saved
// to the registry (via SaveOpenDocumentList), and if there is an auto-save 
// available this is associated with the registry entry for the document.  When
// the application is restarted, the list of documents is read from the registry
// (via ReadOpenDocumentList) and the documents are subsequently re-opened
// (via ReopenPreviousDocuments).  The user is then queried about restoring any
// available auto-saved documents (via QueryRestoreAutosavedDocuments) and if he
// indicates he wants this, the selected auto-saved documents are then opened and
// the original documents are closed (via RestoreAutosavedDocuments).
//
// The crash recovery scenario goes like this:
// A timer is set for the specified auto-save interval.  When the timer ticks, a
// flag is set which indicates that documents should be auto-saved on the next idle
// loop.  The application hangs or crashes and the application recovery callback is
// invoked.  The recovery callback calls the CDataRecoveryHandler to save the list
// of open documents to the registry (via SaveOpenDocumentList).  The behavior on
// restart is the same as in the above scenario.
//
/////////////////////////////////////////////////////////////////////////////
// CDataRecoveryHandler class

class CDataRecoveryHandler : public CObject
{
// Construction
public:
	CDataRecoveryHandler(_In_ DWORD dwRestartManagerSupportFlags, _In_ int nAutosaveInterval);
	virtual ~CDataRecoveryHandler();

	virtual BOOL Initialize();

// Attributes
public:
	// These functions get and set the auto-save interval (in milliseconds).
	virtual int GetAutosaveInterval() const { return m_nAutosaveInterval; }
	virtual void SetAutosaveInterval(_In_ int nAutosaveInterval);

	// These functions get and set the auto-save directory where files will be auto-saved.
	virtual CString GetAutosavePath() const { return m_strAutosavePath; }
	virtual void SetAutosavePath(_In_ const CString &strAutosavePath) { m_strAutosavePath = strAutosavePath; }

	// These functions get and set the unique restart identifier which is used on the command line and in the registry.
	virtual CString GetRestartIdentifier() const { return m_strRestartIdentifier; }
	virtual void SetRestartIdentifier(_In_ const CString &strRestartIdentifier) { m_strRestartIdentifier = strRestartIdentifier; }

	// These functions get and set the flag that indicates that auto-save should be done in the current idle loop.
	virtual BOOL GetSaveDocumentInfoOnIdle() const { return m_bSaveDocumentInfoOnIdle; }
	virtual void SetSaveDocumentInfoOnIdle(_In_ BOOL bSaveOnIdle) { m_bSaveDocumentInfoOnIdle = bSaveOnIdle; }

	// These functions get and set the flag that indicates that the shut-down was invoked by the Restart Manager (WM_QUERYENDSESSION, etc).
	virtual BOOL GetShutdownByRestartManager() const { return m_bShutdownByRestartManager; }
	virtual void SetShutdownByRestartManager(_In_ BOOL bShutdownByRestartManager) { m_bShutdownByRestartManager = bShutdownByRestartManager; }

// Operations
public:
	// These functions save the open document list to the registry and read it back in from the registry.
	virtual BOOL SaveOpenDocumentList();  // save to registry
	virtual BOOL ReadOpenDocumentList();  // load from registry

	// This function ensures that the document is in the open document list and auto-saves the document if it is dirty.
	virtual BOOL AutosaveDocumentInfo(_In_ CDocument *pDocument, _In_ BOOL bResetModifiedFlag = TRUE);

	// This function iterates through all open documents and calls AutosaveDocumentInfo (above) on each.
	virtual BOOL AutosaveAllDocumentInfo();

	// This function creates information about the document in the open document list (usually after a document is opened or a new document is created).
	virtual BOOL CreateDocumentInfo(_In_ CDocument *pDocument);

	// This function updates information about the document in the open document list after the document is saved (may be a new filename).
	virtual BOOL UpdateDocumentInfo(_In_ CDocument *pDocument);

	// This function removes information about the document from the open document list (usually after the document is closed).
	virtual BOOL RemoveDocumentInfo(_In_ CDocument *pDocument);

	// This function attempts to delete the auto-saved file, and if unsuccessful, keeps the filename in a list for later deletion.
	virtual BOOL DeleteAutosavedFile(_In_ const CString &strAutosavedFile);

	// This function deletes all auto-saved files (usually on normal application close, when all documents have been properly saved).
	virtual BOOL DeleteAllAutosavedFiles();

	// These functions reopen the previously open documents, prompt for restoration and restore any associated auto-saved documents.
	virtual BOOL ReopenPreviousDocuments();
	virtual void QueryRestoreAutosavedDocuments();
	virtual BOOL RestoreAutosavedDocuments();

	// This function creates the document list name for the document.  This name is used in the m_map*DocName* maps.
	virtual CString GetDocumentListName(_In_ CDocument *pDocument) const;

	// This function creates the auto-save filename based on the document name.  This name is used in the m_mapDocNameToAutosaveName map.
	virtual CString GenerateAutosaveFileName(_In_ const CString &strDocumentName) const;

	// This function creates the title for the recovered document.  This title is used as the title in the UI until the document is saved.
	virtual CString GetRecoveredDocumentTitle(_In_ const CString &strDocumentTitle) const;

	// This function obtains the normal title for the recovered document.  This title is used in the UI (prompt for save, etc.).
	virtual CString GetNormalDocumentTitle(_In_ CDocument *pDocument) const;

protected:
	CMap<CString, LPCTSTR, CString, LPCTSTR>        m_mapDocNameToAutosaveName;   // maps document name to auto-save filename: list of currently open documents and associated auto-save file (if any)
	CMap<CString, LPCTSTR, CDocument *, CDocument*> m_mapDocNameToDocumentPtr;    // maps document name to CDocument *: list of documents to close after auto-saved versions are opened)
	CMap<CString, LPCTSTR, bool, bool>              m_mapDocNameToRestoreBool;    // maps document name to true/false: list of documents and whether to restore auto-save or not
	CMap<CDocument *, CDocument*, CString, LPCTSTR> m_mapDocumentPtrToDocName;    // maps CDocument * to document name: associates document with name used in other maps
	CMap<CDocument *, CDocument*, CString, LPCTSTR> m_mapDocumentPtrToDocTitle;   // maps CDocument * to document title (without "recovered"): for use in save prompt, etc.

	CStringList        m_lstAutosavesToDelete;  // list of auto-saved files which could not be deleted; retry delete on this list at shutdown time.

	CString m_strAutosavePath;       // path on disk where auto-saved documents will be stored
	CString m_strRestartIdentifier;  // string representation of GUID (used for storing data in registry)

	DWORD   m_dwRestartManagerSupportFlags; // what aspects of Restart Manager support does the application want?  (See AFX_RESTART_MANAGER_ flags in afxwin.h.)
	int     m_nAutosaveInterval;            // timer interval between auto-saves (in milliseconds)
	BOOL    m_bSaveDocumentInfoOnIdle;      // should auto-save be performed in the next idle loop?
	BOOL    m_bShutdownByRestartManager;    // is the application being shut down by the Restart Manager?
	BOOL    m_bRestoringPreviousOpenDocs;   // is the data recovery handler currently reopening previously opened documents?

	UINT_PTR m_nTimerID;                    // periodic auto-save timer identifier
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxdao.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXDAO.H

#pragma once

/////////////////////////////////////////////////////////////////////////////
// General database inlines

#ifdef _AFXDAOCORE_INLINE

// CDaoWorkspace inlines
_AFXDAOCORE_INLINE BOOL CDaoWorkspace::IsOpen() const
	{ ASSERT_VALID(this); return m_bOpen; }
_AFXDAOCORE_INLINE BOOL CDaoWorkspace::IsNew() const
	{ ASSERT_VALID(this); return m_bNew; }

// CDaoDatabase inlines
_AFXDAOCORE_INLINE BOOL CDaoDatabase::IsOpen() const
	{ ASSERT_VALID(this); return m_bOpen; }

// CDaoTableDef inlines
_AFXDAOCORE_INLINE BOOL CDaoTableDef::IsOpen() const
	{ ASSERT_VALID(this); return m_bOpen; }

// CDaoQueryDef inlines
_AFXDAOCORE_INLINE BOOL CDaoQueryDef::IsOpen() const
	{ ASSERT_VALID(this); return m_bOpen; }

// CDaoRecordset inlines
_AFXDAOCORE_INLINE BOOL CDaoRecordset::IsOpen() const
	{ ASSERT_VALID(this); return m_bOpen; }

#endif // _AFXDAOCORE_INLINE


#ifdef _AFXDAODFX_INLINE

// CDaoFieldExchange
_AFXDAODFX_INLINE void CDaoFieldExchange::SetFieldType(UINT nFieldType)
{ ASSERT(nFieldType == outputColumn || nFieldType == param);
		m_nFieldType = nFieldType; }

#endif // _AFXDAODFX_INLINE


#ifdef _AFXDAOVIEW_INLINE

// CDaoRecordView inlines
_AFXDAOVIEW_INLINE void CDaoRecordView::OnUpdateRecordFirst(CCmdUI* pCmdUI)
	{ ASSERT_VALID(this);
		pCmdUI->Enable(m_nStatus & AFX_DAOVIEW_SCROLL_BACKWARD); }

_AFXDAOVIEW_INLINE void CDaoRecordView::OnUpdateRecordNext(CCmdUI* pCmdUI)
	{ ASSERT_VALID(this);
		pCmdUI->Enable(m_nStatus & AFX_DAOVIEW_SCROLL_NEXT); }

_AFXDAOVIEW_INLINE void CDaoRecordView::OnUpdateRecordPrev(CCmdUI* pCmdUI)
	{ ASSERT_VALID(this);
		pCmdUI->Enable(m_nStatus & AFX_DAOVIEW_SCROLL_BACKWARD); }

_AFXDAOVIEW_INLINE void CDaoRecordView::OnUpdateRecordLast(CCmdUI* pCmdUI)
	{ ASSERT_VALID(this);
		pCmdUI->Enable(m_nStatus & AFX_DAOVIEW_SCROLL_LAST); }

_AFXDAOVIEW_INLINE void CDaoRecordView::OnMove(int cx, int cy)
	{ CFormView::OnMove(cx, cy); }

#endif // _AFXDAOVIEW_INLINE

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxdesktopalertdialog.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#include "afxdialogex.h"
#include "afxlinkctrl.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCDesktopAlertWndInfo

class CMFCDesktopAlertWndInfo
{
public:
	CMFCDesktopAlertWndInfo()
	{
		m_hIcon = NULL;
		m_nURLCmdID = 0;
	}

	HICON   m_hIcon;
	CString m_strText;
	CString m_strURL;
	UINT    m_nURLCmdID;

	CMFCDesktopAlertWndInfo& operator= (CMFCDesktopAlertWndInfo& src)
	{
		m_hIcon     = src.m_hIcon;
		m_strText   = src.m_strText;
		m_strURL    = src.m_strURL;
		m_nURLCmdID = src.m_nURLCmdID;
		return *this;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CMFCDesktopAlertDialog window

class CMFCDesktopAlertWnd;

class CMFCDesktopAlertDialog : public CDialogEx
{
	DECLARE_DYNCREATE(CMFCDesktopAlertDialog)

	friend class CMFCDesktopAlertWnd;

// Construction
public:
	CMFCDesktopAlertDialog();
	BOOL CreateFromParams(CMFCDesktopAlertWndInfo& params, CMFCDesktopAlertWnd* pParent);

// Attributes
protected:
	CMFCDesktopAlertWnd*   m_pParentPopup;
	CMFCDesktopAlertWndInfo m_Params;

	CStatic         m_wndIcon;
	CStatic         m_wndText;
	CMFCLinkCtrl  m_btnURL;
	CSize           m_sizeDlg;

	BOOL            m_bDefault;
	BOOL            m_bDontSetFocus;
	BOOL            m_bMenuIsActive;

// Operations
public:
	BOOL HasFocus() const;
	CSize GetDlgSize();

// Overrides
public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);

protected:
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);

// Implementation
public:
	virtual ~CMFCDesktopAlertDialog();

protected:
	//{{AFX_MSG(CMFCDesktopAlertDialog)
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnPaint();
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	virtual BOOL OnInitDialog();
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg LRESULT OnPrintClient(WPARAM wp, LPARAM lp);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	virtual void OnDraw(CDC* pDC);
	CSize GetOptimalTextSize(CString str);
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxdd_.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Do not include this file directly (included by AFXWIN.H)

#pragma once

/////////////////////////////////////////////////////////////////////////////
// Standard Dialog Data Exchange routines

class COleCurrency;    // forward reference (see afxdisp.h)

namespace ATL
{
	class COleDateTime;	// forward reference (see atlcomtime.h)
}
using ATL::COleDateTime;

struct tagDEC;
typedef tagDEC DECIMAL;

// simple text operations
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, BYTE& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, short& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, int& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, UINT& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, long& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, DWORD& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, LONGLONG& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, ULONGLONG& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, CString& value);
void AFXAPI DDX_Text(_Inout_ CDataExchange* pDX, _In_ int nIDC, _Out_z_cap_(nMaxLen) LPTSTR value, _In_ int nMaxLen);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, float& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, double& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, COleCurrency& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, COleDateTime& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, GUID& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, DECIMAL& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, FILETIME& value);

// special control types
void AFXAPI DDX_Check(CDataExchange* pDX, int nIDC, int& value);
void AFXAPI DDX_Radio(CDataExchange* pDX, int nIDC, int& value);
void AFXAPI DDX_LBString(CDataExchange* pDX, int nIDC, CString& value);
void AFXAPI DDX_CBString(CDataExchange* pDX, int nIDC, CString& value);
void AFXAPI DDX_LBIndex(CDataExchange* pDX, int nIDC, int& index);
void AFXAPI DDX_CBIndex(CDataExchange* pDX, int nIDC, int& index);
void AFXAPI DDX_LBStringExact(CDataExchange* pDX, int nIDC, CString& value);
void AFXAPI DDX_CBStringExact(CDataExchange* pDX, int nIDC, CString& value);
void AFXAPI DDX_Scroll(CDataExchange* pDX, int nIDC, int& value);
void AFXAPI DDX_Slider(CDataExchange* pDX, int nIDC, int& value);

void AFXAPI DDX_IPAddress(CDataExchange* pDX, int nIDC, DWORD& value);

void AFXAPI DDX_MonthCalCtrl(CDataExchange* pDX, int nIDC, CTime& value);
void AFXAPI DDX_MonthCalCtrl(CDataExchange* pDX, int nIDC, COleDateTime& value);
void AFXAPI DDX_MonthCalCtrl(CDataExchange* pDX, int nIDC, FILETIME& value);
void AFXAPI DDX_DateTimeCtrl(CDataExchange* pDX, int nIDC, CString& value);
void AFXAPI DDX_DateTimeCtrl(CDataExchange* pDX, int nIDC, CTime& value);
void AFXAPI DDX_DateTimeCtrl(CDataExchange* pDX, int nIDC, COleDateTime& value);
void AFXAPI DDX_DateTimeCtrl(CDataExchange* pDX, int nIDC, FILETIME& value);

// for getting access to the actual controls
void AFXAPI DDX_Control(CDataExchange* pDX, int nIDC, CWnd& rControl);

/////////////////////////////////////////////////////////////////////////////
// Standard Dialog Data Validation routines

// range - value must be >= minVal and <= maxVal
// NOTE: you will require casts for 'minVal' and 'maxVal' to use the
//   UINT, DWORD or float types
void AFXAPI DDV_MinMaxByte(CDataExchange* pDX, BYTE value, BYTE minVal, BYTE maxVal);
void AFXAPI DDV_MinMaxShort(CDataExchange* pDX, short value, short minVal, short maxVal);
void AFXAPI DDV_MinMaxInt(CDataExchange* pDX, int value, int minVal, int maxVal);
void AFXAPI DDV_MinMaxLong(CDataExchange* pDX, long value, long minVal, long maxVal);
void AFXAPI DDV_MinMaxUInt(CDataExchange* pDX, UINT value, UINT minVal, UINT maxVal);
void AFXAPI DDV_MinMaxDWord(CDataExchange* pDX, DWORD value, DWORD minVal, DWORD maxVal);
void AFXAPI DDV_MinMaxLongLong(CDataExchange* pDX, LONGLONG value, LONGLONG minVal, LONGLONG maxVal);
void AFXAPI DDV_MinMaxULongLong(CDataExchange* pDX, ULONGLONG value, ULONGLONG minVal, ULONGLONG maxVal);
void AFXAPI DDV_MinMaxFloat(CDataExchange* pDX, float const& value, float minVal, float maxVal);
void AFXAPI DDV_MinMaxDouble(CDataExchange* pDX, double const& value, double minVal, double maxVal);

// special control types
void AFXAPI DDV_MinMaxSlider(CDataExchange* pDX, DWORD value, DWORD minVal, DWORD maxVal);
void AFXAPI DDV_MinMaxDateTime(CDataExchange* pDX, CTime& refValue, const CTime* refMinRange, const CTime* refMaxRange);
void AFXAPI DDV_MinMaxDateTime(CDataExchange* pDX, COleDateTime& refValue, const COleDateTime* refMinRange, const COleDateTime* refMaxRange);
void AFXAPI DDV_MinMaxMonth(CDataExchange* pDX,	CTime& refValue, const CTime* pMinRange, const CTime* pMaxRange);
void AFXAPI DDV_MinMaxMonth(CDataExchange* pDX, COleDateTime& refValue, const COleDateTime* refMinRange, const COleDateTime* refMaxRange);


// number of characters
void AFXAPI DDV_MaxChars(CDataExchange* pDX, CString const& value, int nChars);

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxdesktopalertwnd.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#include "afxbutton.h"
#include "afxdesktopalertdialog.h"
#include "afxpopupmenu.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCDesktopAlertWndButton window

extern AFX_IMPORT_DATA UINT AFX_WM_ON_CLOSEPOPUPWINDOW;

class CMFCDesktopAlertWndButton : public CMFCButton
{
	friend class CMFCDesktopAlertWnd;

public:
	CMFCDesktopAlertWndButton()
	{
		m_bIsCaptionButton = FALSE;
		m_bIsCloseButton = FALSE;
	}

	BOOL IsCaptionButton() const { return m_bIsCaptionButton; }
	BOOL IsCloseButton() const { return m_bIsCloseButton; }

protected:
	virtual void OnFillBackground(CDC* pDC, const CRect& rectClient);
	virtual void OnDrawBorder(CDC* pDC, CRect& rectClient, UINT uiState);
	virtual void OnDraw(CDC* pDC, const CRect& rect, UINT uiState);

	BOOL m_bIsCaptionButton;
	BOOL m_bIsCloseButton;
};

/////////////////////////////////////////////////////////////////////////////
// CMFCDesktopAlertWnd window

class CMFCDesktopAlertWnd : public CWnd
{
	friend CMFCDesktopAlertDialog;

	DECLARE_DYNAMIC(CMFCDesktopAlertWnd)

// Construction
public:
	CMFCDesktopAlertWnd();

// Attributes
public:

	CMFCPopupMenu::ANIMATION_TYPE GetAnimationType() { return m_AnimationType; }
	void SetAnimationType(CMFCPopupMenu::ANIMATION_TYPE type) { m_AnimationType = type; }

	void SetAnimationSpeed(UINT nSpeed)
	{
		if(nSpeed == 0 || nSpeed > 200)
		{
			ASSERT(FALSE);
			return;
		}
		m_AnimationSpeed = max (2, nSpeed);
	}
	UINT GetAnimationSpeed() const { return m_AnimationSpeed; }

	void SetTransparency(BYTE nTransparency)
	{
		if (nTransparency < 0 || nTransparency > 255)
		{
			ASSERT(FALSE);
			return;
		}
		m_nTransparency = nTransparency;
	}
	BYTE GetTransparency() const { return m_nTransparency; }

	void SetSmallCaption(BOOL bSmallCaption = TRUE) { m_bSmallCaption = bSmallCaption; }
	BOOL HasSmallCaption() const { return m_bSmallCaption; }

	// times in milliseconds
	void SetAutoCloseTime(int nTime) { m_nAutoCloseTime = nTime; }
	int GetAutoCloseTime() const { return m_nAutoCloseTime; }

	CPoint GetLastPos() const { return 	m_ptLastPos; }

protected:
	CWnd*  m_pWndOwner;
	CPoint m_ptLastPos;
	CPoint m_ptStartMove;

	BOOL m_bMoving;
	BOOL m_bIsActive;
	BOOL m_bHasCloseButton;
	BOOL m_bSmallCaption;

	UINT m_uiDlgResID;
	int  m_nAutoCloseTime; // milliseconds
	int  m_nBtnMarginVert;
	int  m_nBtnMarginHorz;
	BYTE m_nTransparency; // (0..255)

	HMENU m_hMenu;

	CMFCDesktopAlertDialog*      m_pWndDlg;
	CMFCDesktopAlertWndButton m_btnClose;
	CMFCDesktopAlertWndButton m_btnMenu;

	//----------------------
	// Animation attributes:
	//----------------------
	CMFCPopupMenu::ANIMATION_TYPE m_AnimationType;

	UINT m_AnimationSpeed;
	UINT m_nAnimationAlpha;
	BOOL m_bAnimationIsDone;
	BOOL m_bIsAnimRight;
	BOOL m_bIsAnimDown;
	BOOL m_bFadeOutAnimation;
	int  m_iFadePercent;
	int  m_iFadeStep;
	int  m_nAnimStepX;
	int  m_nAnimStepY;

	CSize   m_AnimSize;
	CSize   m_FinalSize;
	CBitmap m_bmpScreenSrc;
	CBitmap m_bmpScreenDst;
	CBitmap m_bmpScreenTmp;

	COLORREF* m_cFadeSrcBits;
	COLORREF* m_cFadeDstBits;
	COLORREF* m_cFadeTmpBits;

// Operations
public:
	BOOL ProcessCommand(HWND hwnd);

protected:
	CRect GetCaptionRect();
	void StartAnimation(BOOL bShow = TRUE);
	void DrawAnimation(CDC* pPaintDC);

	BOOL CommonCreate(CPoint ptPos, CMFCDesktopAlertWndInfo* pParams = NULL);

	void StartWindowMove();

// Overrides
public:
	virtual BOOL Create(CWnd* pWndOwner, UINT uiDlgResID, HMENU hMenu = NULL, CPoint ptPos = CPoint (-1, -1), CRuntimeClass* pRTIDlgBar = RUNTIME_CLASS(CMFCDesktopAlertDialog));
	virtual BOOL Create(CWnd* pWndOwner, CMFCDesktopAlertWndInfo& params, HMENU hMenu = NULL, CPoint ptPos = CPoint (-1, -1));
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);

	virtual CSize GetDialogSize();
	virtual BOOL OnBeforeShow(CPoint& /*ptPos*/) { return TRUE; }
	virtual void OnDraw(CDC* pDC);
	virtual int GetCaptionHeight();

	virtual BOOL OnClickLinkButton(UINT /*uiCmdID*/) { return FALSE; }

// Implementation
public:
	virtual ~CMFCDesktopAlertWnd();

protected:
	//{{AFX_MSG(CMFCDesktopAlertWnd)
	afx_msg void OnTimer(UINT_PTR nIDEvent);
	afx_msg void OnNcDestroy();
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnPaint();
	afx_msg void OnDestroy();
	afx_msg void OnClose();
	afx_msg void OnWindowPosChanged(WINDOWPOS FAR* lpwndpos);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnCancelMode();
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg LRESULT OnPrintClient(WPARAM wp, LPARAM lp);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxdialogex.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxdialogimpl.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CDialogEx dialog

class CDialogEx : public CDialog
{
	friend class CMFCPopupMenu;
	friend class CMFCDropDownListBox;
	friend class CContextMenuManager;

	DECLARE_DYNAMIC(CDialogEx)

// Construction
public:
	CDialogEx();
	CDialogEx(UINT nIDTemplate, CWnd *pParent = NULL);
	CDialogEx(LPCTSTR lpszTemplateName, CWnd *pParentWnd = NULL);

protected:
	void CommonConstruct();

// Attributes:
public:
	enum BackgroundLocation
	{
		BACKGR_TILE,
		BACKGR_TOPLEFT,
		BACKGR_TOPRIGHT,
		BACKGR_BOTTOMLEFT,
		BACKGR_BOTTOMRIGHT,
	};

protected:
	HBITMAP            m_hBkgrBitmap;
	CSize              m_sizeBkgrBitmap;
	CBrush             m_brBkgr;
	BackgroundLocation m_BkgrLocation;
	CDialogImpl     m_Impl;
	BOOL               m_bAutoDestroyBmp;

// Operations:
public:
	void SetBackgroundColor(COLORREF color, BOOL bRepaint = TRUE);
	void SetBackgroundImage(HBITMAP hBitmap, BackgroundLocation location = BACKGR_TILE, BOOL bAutoDestroy = TRUE, BOOL bRepaint = TRUE);
	BOOL SetBackgroundImage(UINT uiBmpResId, BackgroundLocation location = BACKGR_TILE, BOOL bRepaint = TRUE);

// Overrides
public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);

protected:
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);

// Implementation
protected:
	//{{AFX_MSG(CDialogEx)
	afx_msg void OnActivate(UINT nState, CWnd *pWndOther, BOOL bMinimized);
	afx_msg BOOL OnNcActivate(BOOL bActive);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnDestroy();
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg void OnSysColorChange();
	afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void SetActiveMenu(CMFCPopupMenu* pMenu);
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxdhtml.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXDHTML_H__
#define __AFXDHTML_H__

#ifndef __mshtml_h__
#include <mshtml.h>
#endif

#ifndef __MSHTMDID_H__
#include <mshtmdid.h>
#endif

#ifndef __mshtmhst_h__
#include <mshtmhst.h>
#endif

#ifndef __ATLBASE_H__
#include <atlbase.h>
#endif

#ifndef __exdisp_h__
#include <exdisp.h>
#endif

#include <atlbase.h>
#include <atlcom.h>

#include <afxpriv2.h>
#include <afxocc.h>
#include <afxtempl.h>
#include <float.h>

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

// Classes declared in this file
class CDHtmlSinkHandler;
	class CDHtmlEventSink;

// IDispatch
	class CDHtmlControlSink;

// IDispatch
	class CDHtmlElementEventSink;

// CObject
	// CCmdTarget
		// COleControlSite
			class CBrowserControlSite;

// CObject
	// CCmdTarget
		// CWnd
			// CDialog
				class CDHtmlDialog;
					class CMultiPageDHtmlDialog;

enum DHtmlEventMapEntryType { DHTMLEVENTMAPENTRY_NAME, DHTMLEVENTMAPENTRY_CLASS, DHTMLEVENTMAPENTRY_TAG,
	DHTMLEVENTMAPENTRY_ELEMENT, DHTMLEVENTMAPENTRY_CONTROL, DHTMLEVENTMAPENTRY_END };

struct DHtmlEventMapEntry;

// Dummy base classes just to force pointers-to-member that work with multiple inheritance
class CDHtmlSinkHandlerBase1
{
};
class CDHtmlSinkHandlerBase2
{
};

class CDHtmlSinkHandler :
	public CDHtmlSinkHandlerBase1,
	public CDHtmlSinkHandlerBase2
{
public:
	STDMETHOD(CDHtmlSinkHandlerQueryInterface)(REFIID riid, void ** ppvObject) = 0;
	virtual ULONG STDMETHODCALLTYPE AddRef(void) = 0;
	virtual ULONG STDMETHODCALLTYPE Release(void) = 0;
	STDMETHOD(GetTypeInfoCount)(UINT *pctinfo) = 0;
	STDMETHOD(GetTypeInfo)(UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo) = 0;
	STDMETHOD(GetIDsOfNames)(REFIID riid, _In_count_(cNames) OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId) = 0;
	STDMETHOD(Invoke)(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,
		DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr) = 0;
	virtual const DHtmlEventMapEntry* GetDHtmlEventMap() = 0;
};

struct DHtmlEventMapEntry
{
	DHtmlEventMapEntryType nType;
	DISPID dispId;
	LPCTSTR szName;	// name or class based on nType
	void (__stdcall CDHtmlSinkHandler::*pfnEventFunc)();
};

typedef HRESULT (CDHtmlSinkHandler::*DHEVTFUNC)(IHTMLElement *pElement);
typedef void (__stdcall CDHtmlSinkHandler::*DHEVTFUNCCONTROL)();

#define DECLARE_DHTML_EVENT_MAP()\
private:\
protected:\
	virtual const DHtmlEventMapEntry* GetDHtmlEventMap();\

#define BEGIN_DHTML_EVENT_MAP(className)\
const DHtmlEventMapEntry* className::GetDHtmlEventMap()\
{\
	typedef className theClass;\
	PTM_WARNING_DISABLE \
	static const DHtmlEventMapEntry _dhtmlEventEntries[] = {

#define END_DHTML_EVENT_MAP()\
{ DHTMLEVENTMAPENTRY_END, 0, NULL, (DHEVTFUNCCONTROL) NULL },\
};\
	PTM_WARNING_RESTORE \
	return _dhtmlEventEntries;\
}

#define BEGIN_DHTML_EVENT_MAP_INLINE(className)\
const DHtmlEventMapEntry* GetDHtmlEventMap()\
{\
	typedef className theClass;\
	PTM_WARNING_DISABLE \
	static const DHtmlEventMapEntry _dhtmlEventEntries[] = \
	{\

#define END_DHTML_EVENT_MAP_INLINE()\
	{ DHTMLEVENTMAPENTRY_END, 0, NULL, (DHEVTFUNCCONTROL) NULL },\
	};\
	PTM_WARNING_RESTORE \
	return _dhtmlEventEntries;\
}\


#define DHTML_EVENT(dispid, elemName, memberFxn)\
{ DHTMLEVENTMAPENTRY_NAME, dispid, elemName, (DHEVTFUNCCONTROL) (DHEVTFUNC) &theClass::memberFxn },\

#define DHTML_EVENT_CLASS(dispid, elemName, memberFxn)\
{ DHTMLEVENTMAPENTRY_CLASS, dispid, elemName, (DHEVTFUNCCONTROL) (DHEVTFUNC) &theClass::memberFxn },\

#define DHTML_EVENT_TAG(dispid, elemName, memberFxn)\
{ DHTMLEVENTMAPENTRY_TAG, dispid, elemName, (DHEVTFUNCCONTROL) (DHEVTFUNC) &theClass::memberFxn },\

#define DHTML_EVENT_ELEMENT(dispid, elemName, memberFxn)\
{ DHTMLEVENTMAPENTRY_ELEMENT, dispid, elemName, (DHEVTFUNCCONTROL) (DHEVTFUNC) &theClass::memberFxn },\

#define DHTML_EVENT_AXCONTROL(dispid, controlName, memberFxn)\
{ DHTMLEVENTMAPENTRY_CONTROL, dispid, controlName, (DHEVTFUNCCONTROL) (static_cast<void (__stdcall theClass::*)()>(&theClass::memberFxn)) },\

// specific commonly used events
#define DHTML_EVENT_ONHELP(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONHELP, elemName, memberFxn)\

#define DHTML_EVENT_ONCLICK(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONCLICK, elemName, memberFxn)\

#define DHTML_EVENT_ONDBLCLICK(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONDBLCLICK, elemName, memberFxn)\

#define DHTML_EVENT_ONKEYPRESS(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONKEYPRESS, elemName, memberFxn)\

#define DHTML_EVENT_ONKEYDOWN(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONKEYDOWN, elemName, memberFxn)\

#define DHTML_EVENT_ONKEYUP(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONKEYUP, elemName, memberFxn)\

#define DHTML_EVENT_ONMOUSEOUT(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONMOUSEOUT, elemName, memberFxn)\

#define DHTML_EVENT_ONMOUSEOVER(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONMOUSEOVER, elemName, memberFxn)\

#define DHTML_EVENT_ONMOUSEMOVE(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONMOUSEMOVE, elemName, memberFxn)\

#define DHTML_EVENT_ONMOUSEDOWN(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONMOUSEDOWN, elemName, memberFxn)\

#define DHTML_EVENT_ONMOUSEUP(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONMOUSEUP, elemName, memberFxn)\

#define DHTML_EVENT_ONSELECTSTART(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONSELECTSTART, elemName, memberFxn)\

#define DHTML_EVENT_ONFILTERCHANGE(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONFILTERCHANGE, elemName, memberFxn)\

#define DHTML_EVENT_ONDRAGSTART(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONDRAGSTART, elemName, memberFxn)\

#define DHTML_EVENT_ONBEFOREUPDATE(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONBEFOREUPDATE, elemName, memberFxn)\

#define DHTML_EVENT_ONAFTERUPDATE(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONAFTERUPDATE, elemName, memberFxn)\

#define DHTML_EVENT_ONERRORUPDATE(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONERRORUPDATE, elemName, memberFxn)\

#define DHTML_EVENT_ONROWEXIT(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONROWEXIT, elemName, memberFxn)\

#define DHTML_EVENT_ONROWENTER(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONROWENTER, elemName, memberFxn)\

#define DHTML_EVENT_ONDATASETCHANGED(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONDATASETCHANGED, elemName, memberFxn)\

#define DHTML_EVENT_ONDATAAVAILABLE(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONDATAAVAILABLE, elemName, memberFxn)\

#define DHTML_EVENT_ONDATASETCOMPLETE(elemName, memberFxn)\
DHTML_EVENT(DISPID_HTMLELEMENTEVENTS_ONDATASETCOMPLETE, elemName, memberFxn)\

// non-bubbled element events
#define DHTML_EVENT_ONBLUR(elemName, memberFxn)\
DHTML_EVENT_ELEMENT(DISPID_EVMETH_ONBLUR, elemName, memberFxn)\

#define DHTML_EVENT_ONCHANGE(elemName, memberFxn)\
DHTML_EVENT_ELEMENT(DISPID_EVMETH_ONCHANGE, elemName, memberFxn)\

#define DHTML_EVENT_ONFOCUS(elemName, memberFxn)\
DHTML_EVENT_ELEMENT(DISPID_EVMETH_ONFOCUS, elemName, memberFxn)\

#define DHTML_EVENT_ONRESIZE(elemName, memberFxn)\
DHTML_EVENT_ELEMENT(DISPID_EVMETH_ONRESIZE, elemName, memberFxn)\

class CDHtmlEventSink : public CDHtmlSinkHandler
{
public:
	HRESULT ConnectToConnectionPoint(IUnknown *punkObj, REFIID riid, DWORD *pdwCookie);
	void DisconnectFromConnectionPoint(IUnknown *punkObj, REFIID riid, DWORD& dwCookie);
	STDMETHOD(CDHtmlSinkHandlerQueryInterface)(REFIID iid, LPVOID* ppvObj);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();
	STDMETHOD(GetTypeInfoCount)(UINT *pctinfo);
	STDMETHOD(GetTypeInfo)(UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo);
	STDMETHOD(GetIDsOfNames)(REFIID riid, _In_count_(cNames) OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId);
	STDMETHOD(Invoke)(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,
		DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr);
	virtual BOOL DHtmlEventHook(HRESULT *phr, DISPID dispIdMember, DISPPARAMS *pDispParams,
		VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr);
	virtual const DHtmlEventMapEntry* GetDHtmlEventMap() = 0;
	virtual HRESULT GetDHtmlDocument(IHTMLDocument2 **pphtmlDoc) = 0;
	int FindDHtmlEventEntry(const DHtmlEventMapEntry *pEventMap, DISPID dispIdMember,
							   IHTMLElement **ppsrcElement);
};

class CDHtmlControlSink : public IDispatch
{
public:
	LPCTSTR m_szControlId;
	DWORD m_dwCookie;
	::ATL::CComPtr<IUnknown> m_spunkObj;
	IID m_iid;
	GUID m_libid;
	WORD m_wMajor;
	WORD m_wMinor;
	::ATL::CComPtr<ITypeInfo> m_spTypeInfo;
	CDHtmlSinkHandler *m_pHandler;
	DWORD_PTR m_dwThunkOffset;

	CDHtmlControlSink();
	CDHtmlControlSink(IUnknown *punkObj, CDHtmlSinkHandler *pHandler, LPCTSTR szControlId, 
			DWORD_PTR dwThunkOffset = 0);
	virtual ~CDHtmlControlSink();
	HRESULT ConnectToControl(IUnknown *punkObj);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();
	STDMETHOD(QueryInterface)(REFIID iid, LPVOID* ppvObj);
	STDMETHOD(GetTypeInfoCount)(UINT *pctinfo);
	STDMETHOD(GetTypeInfo)(UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo);
	STDMETHOD(GetIDsOfNames)(REFIID riid, _In_count_(cNames) OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId);
	STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
		DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr);
	HRESULT InvokeFromFuncInfo(DHEVTFUNCCONTROL pEvent, ATL::_ATL_FUNC_INFO& info, DISPPARAMS* pdispparams, VARIANT* pvarResult);
	HRESULT GetFuncInfoFromId(const IID& iid, DISPID dispidMember, LCID lcid, ATL::_ATL_FUNC_INFO& info);
	VARTYPE GetUserDefinedType(ITypeInfo *pTI, HREFTYPE hrt);
};

class CDHtmlElementEventSink : public IDispatch
{
public:
	CDHtmlEventSink *m_pHandler;
	::ATL::CComPtr<IUnknown> m_spunkElem;
	DWORD m_dwCookie;

	CDHtmlElementEventSink(CDHtmlEventSink *pHandler, IDispatch *pdisp);
	virtual ~CDHtmlElementEventSink() {}
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();
	STDMETHOD(QueryInterface)(REFIID iid, LPVOID* ppvObj);
	STDMETHOD(GetTypeInfoCount)(UINT *pctinfo);
	STDMETHOD(GetTypeInfo)(UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo);
	STDMETHOD(GetIDsOfNames)(REFIID riid, _In_count_(cNames) OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId);
	STDMETHOD(Invoke)(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,
		DISPPARAMS *pdispparams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr);
	HRESULT Advise(LPUNKNOWN pUnkObj, REFIID iid);
	HRESULT UnAdvise(LPUNKNOWN pUnkObj, REFIID iid);
};

/////////////////////////////////////////////////////////////////////////////
// CBrowserControlSite class - Implements the control site for hosting
// the browser.  Used by CDHtmlDialog
class CBrowserControlSite : public COleControlSite,
	public IDocHostUIHandler
{
public:
	CBrowserControlSite(COleControlContainer* pCtrlCont, CDHtmlDialog *pHandler);

protected:
// Implementation
	LPUNKNOWN GetInterfaceHook(const void *iid);
// IUnknown methods
	STDMETHOD(QueryInterface)(REFIID riid, void **ppvObject);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();
// IDocHostUIHandler methods
	STDMETHOD(ShowContextMenu)(DWORD dwID, POINT *ppt, IUnknown *pcmdtReserved, IDispatch *pdispReserved);
	STDMETHOD(GetHostInfo)(DOCHOSTUIINFO *pInfo);
	STDMETHOD(ShowUI)(DWORD dwID, IOleInPlaceActiveObject *pActiveObject, IOleCommandTarget *pCommandTarget, IOleInPlaceFrame *pFrame, IOleInPlaceUIWindow *pDoc);
	STDMETHOD(HideUI)(void);
	STDMETHOD(UpdateUI)(void);
	STDMETHOD(EnableModeless)(BOOL fEnable);
	STDMETHOD(OnDocWindowActivate)(BOOL fActivate);
	STDMETHOD(OnFrameWindowActivate)(BOOL fActivate);
	STDMETHOD(ResizeBorder)(LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow);
	STDMETHOD(TranslateAccelerator)(LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID);
	STDMETHOD(GetOptionKeyPath)(LPOLESTR *pchKey, DWORD dw);
	STDMETHOD(GetDropTarget)(IDropTarget *pDropTarget, IDropTarget **ppDropTarget);
	STDMETHOD(GetExternal)(IDispatch **ppDispatch);
	STDMETHOD(TranslateUrl)(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut);
	STDMETHOD(FilterDataObject)(IDataObject *pDO, IDataObject **ppDORet);

protected:
	CDHtmlDialog *m_pHandler;
};

// DDX_DHtml helper macros
#define DDX_DHtml_ElementValue(dx, name, var) DDX_DHtml_ElementText(dx, name, DISPID_A_VALUE, var)
#define DDX_DHtml_ElementInnerText(dx, name, var) DDX_DHtml_ElementText(dx, name, DISPID_IHTMLELEMENT_INNERTEXT, var)
#define DDX_DHtml_ElementInnerHtml(dx, name, var) DDX_DHtml_ElementText(dx, name, DISPID_IHTMLELEMENT_INNERHTML, var)
#define DDX_DHtml_Anchor_Href(dx, name, var) DDX_DHtml_ElementText(dx, name, DISPID_IHTMLANCHORELEMENT_HREF, var)
#define DDX_DHtml_Anchor_Target(dx, name, var) DDX_DHtml_ElementText(dx, name, DISPID_IHTMLANCHORELEMENT_TARGET, var)
#define DDX_DHtml_Img_Src(dx, name, var) DDX_DHtml_ElementText(dx, name, DISPID_IHTMLIMGELEMENT_SRC, var)
#define DDX_DHtml_Frame_Src(dx, name, var) DDX_DHtml_ElementText(dx, name, DISPID_IHTMLFRAMEBASE_SRC, var)
#define DDX_DHtml_IFrame_Src(dx, name, var) DDX_DHtml_ElementText(dx, name, DISPID_IHTMLFRAMEBASE_SRC, var)

/////////////////////////////////////////////////////////////////////////////
// CDHtmlDialog class - Implements a CDialog that hosts the WebBrowser 
// control and allows for handling events generated by HTML elements
class CDHtmlDialog : public CDialog,
	public CDHtmlEventSink
{
public:
	CString m_strCurrentUrl;
	LPTSTR m_szHtmlResID;
	UINT m_nHtmlResID;
	::ATL::CComPtr<IWebBrowser2> m_pBrowserApp;
	::ATL::CComPtr<IHTMLDocument2> m_spHtmlDoc;
	BOOL m_bUseHtmlTitle;

	CDHtmlDialog();
	CDHtmlDialog(UINT nIDTemplate, UINT nHtmlResID = 0, CWnd *pParentWnd = NULL);
	CDHtmlDialog(LPCTSTR lpszTemplateName, LPCTSTR szHtmlResID, CWnd *pParentWnd = NULL);
	virtual ~CDHtmlDialog();
	virtual BOOL CreateControlSite(COleControlContainer* pContainer, 
			COleControlSite** ppSite, UINT /* nID */, REFCLSID /* clsid */);
	HRESULT GetDHtmlDocument(IHTMLDocument2 **pphtmlDoc);
	void GetCurrentUrl(CString& szUrl);
	virtual BOOL CanAccessExternal();
	virtual void OnBeforeNavigate(LPDISPATCH pDisp, LPCTSTR szUrl);
	virtual void OnNavigateComplete(LPDISPATCH pDisp, LPCTSTR szUrl);
	virtual void OnDocumentComplete(LPDISPATCH pDisp, LPCTSTR szUrl);
	virtual BOOL OnInitDialog();
	BOOL LoadFromResource(LPCTSTR lpszResource);
	BOOL LoadFromResource(UINT nRes);
	void Navigate(LPCTSTR lpszURL, DWORD dwFlags= 0, LPCTSTR lpszTargetFrameName = NULL,
		LPCTSTR lpszHeaders = NULL, LPVOID lpvPostData = NULL,
		DWORD dwPostDataLen = 0);
	void DestroyModeless();

// DDX functions
	void DDX_DHtml_ElementText(CDataExchange* pDX, LPCTSTR szId, DISPID dispid, CString& value);
	void DDX_DHtml_ElementText(CDataExchange* pDX, LPCTSTR szId, DISPID dispid, short& value);
	void DDX_DHtml_ElementText(CDataExchange* pDX, LPCTSTR szId, DISPID dispid, int& value);
	void DDX_DHtml_ElementText(CDataExchange* pDX, LPCTSTR szId, DISPID dispid, long& value);
	void DDX_DHtml_ElementText(CDataExchange* pDX, LPCTSTR szId, DISPID dispid, DWORD& value);
	void DDX_DHtml_ElementText(CDataExchange* pDX, LPCTSTR szId, DISPID dispid, float& value);
	void DDX_DHtml_ElementText(CDataExchange* pDX, LPCTSTR szId, DISPID dispid, double& value);
	void DDX_DHtml_CheckBox(CDataExchange* pDX, LPCTSTR szId, int& value);
	void DDX_DHtml_Radio(CDataExchange* pDX, LPCTSTR szId, long& value);
	void DDX_DHtml_SelectValue(CDataExchange* pDX, LPCTSTR szId, CString& value);
	void DDX_DHtml_SelectString(CDataExchange* pDX, LPCTSTR szId, CString& value);
	void DDX_DHtml_SelectIndex(CDataExchange* pDX, LPCTSTR szId, long& value);
	void DDX_DHtml_AxControl(CDataExchange *pDX, LPCTSTR szId, DISPID dispid, VARIANT& var);
	void DDX_DHtml_AxControl(CDataExchange *pDX, LPCTSTR szId, LPCTSTR szPropName, VARIANT& var);

// host handler
	void SetHostFlags(DWORD dwFlags);
	void SetExternalDispatch(IDispatch *pdispExternal);
	virtual BOOL IsExternalDispatchSafe();
	STDMETHOD(ShowContextMenu)(DWORD dwID, POINT *ppt, IUnknown *pcmdtReserved, IDispatch *pdispReserved);
	STDMETHOD(GetHostInfo)(DOCHOSTUIINFO *pInfo);
	STDMETHOD(ShowUI)(DWORD dwID, IOleInPlaceActiveObject *pActiveObject, IOleCommandTarget *pCommandTarget, IOleInPlaceFrame *pFrame, IOleInPlaceUIWindow *pDoc);
	STDMETHOD(HideUI)(void);
	STDMETHOD(UpdateUI)(void);
	STDMETHOD(EnableModeless)(BOOL fEnable);
	STDMETHOD(OnDocWindowActivate)(BOOL fActivate);
	STDMETHOD(OnFrameWindowActivate)(BOOL fActivate);
	STDMETHOD(ResizeBorder)(LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow);
	STDMETHOD(TranslateAccelerator)(LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID);
	STDMETHOD(GetOptionKeyPath)(LPOLESTR *pchKey, DWORD dw);
	STDMETHOD(GetDropTarget)(IDropTarget *pDropTarget, IDropTarget **ppDropTarget);
	STDMETHOD(GetExternal)(IDispatch **ppDispatch);
	STDMETHOD(TranslateUrl)(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut);
	STDMETHOD(FilterDataObject)(IDataObject *pDO, IDataObject **ppDORet);

	HRESULT GetElement(LPCTSTR szElementId, IDispatch **ppdisp, BOOL *pbCollection = NULL);
	HRESULT GetElement(LPCTSTR szElementId, IHTMLElement **pphtmlElement);
	template <class Q>
	HRESULT GetElementInterface(LPCTSTR szElementId, Q** ppvObj)
	{
		return GetElementInterface(szElementId, __uuidof(Q), (void **) ppvObj);
	}
	HRESULT GetElementInterface(LPCTSTR szElementId, REFIID riid, void **ppvObj);
	BSTR GetElementText(LPCTSTR szElementId);
	void SetElementText(LPCTSTR szElementId, BSTR bstrText);
	void SetElementText(IUnknown *punkElem, BSTR bstrText);
	BSTR GetElementHtml(LPCTSTR szElementId);
	void SetElementHtml(LPCTSTR szElementId, BSTR bstrText);
	void SetElementHtml(IUnknown *punkElem, BSTR bstrText);
	VARIANT GetElementProperty(LPCTSTR szElementId, DISPID dispid);
	void SetElementProperty(LPCTSTR szElementId, DISPID dispid, VARIANT *pVar);
	HRESULT GetControlDispatch(LPCTSTR szId, IDispatch **ppdisp);
	VARIANT GetControlProperty(IDispatch *pdispControl, DISPID dispid);
	VARIANT GetControlProperty(LPCTSTR szId, DISPID dispid);
	VARIANT GetControlProperty(LPCTSTR szId, LPCTSTR szPropName);
	void SetControlProperty(IDispatch *pdispControl, DISPID dispid, VARIANT *pVar);
	void SetControlProperty(LPCTSTR szElementId, DISPID dispid, VARIANT *pVar);
	void SetControlProperty(LPCTSTR szElementId, LPCTSTR szPropName, VARIANT *pVar);
	HRESULT GetEvent(IHTMLEventObj **ppEventObj);

//Implementation
public:
	HRESULT OnDocumentReadyStateChange(IHTMLElement *phtmlElem);

protected:
	BOOL m_bAttachedControl;
	CString m_strDlgCaption;
	CWnd m_wndBrowser;

	static UINT WM_DESTROYMODELESS;

	DECLARE_DYNAMIC(CDHtmlDialog)
	DECLARE_MESSAGE_MAP()
	DECLARE_EVENTSINK_MAP()

	afx_msg void OnDestroy();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	void Initialize();
	void _OnBeforeNavigate2(LPDISPATCH pDisp, VARIANT FAR* URL, VARIANT FAR* Flags, VARIANT FAR* TargetFrameName, VARIANT FAR* PostData, VARIANT FAR* Headers, BOOL FAR* Cancel);
	void _OnNavigateComplete2(LPDISPATCH pDisp, VARIANT FAR* URL);
	void _OnDocumentComplete(LPDISPATCH pDisp, VARIANT* URL);
	LRESULT OnDestroyModeless(WPARAM, LPARAM);

	// DDX Functions
	void DDX_DHtml_ElementText(LPCTSTR szId, DISPID dispid, CString& value, BOOL bSave);
	void DDX_DHtml_ElementText(LPCTSTR szId, DISPID dispid, short& value, BOOL bSave);
	void DDX_DHtml_ElementText(LPCTSTR szId, DISPID dispid, int& value, BOOL bSave);
	void DDX_DHtml_ElementText(LPCTSTR szId, DISPID dispid, long& value, BOOL bSave);
	void DDX_DHtml_ElementText(LPCTSTR szId, DISPID dispid, DWORD& value, BOOL bSave);
	void DDX_DHtml_ElementText(LPCTSTR szId, DISPID dispid, float& value, BOOL bSave);
	void DDX_DHtml_ElementText(LPCTSTR szId, DISPID dispid, double& value, BOOL bSave);

	/////////////////////////////////////////////////////////////////////////////
	// Data exchange for special controls
	void DDX_DHtml_CheckBox(LPCTSTR szId, int& value, BOOL bSave);
	void DDX_DHtml_Radio(LPCTSTR szId, long& value, BOOL bSave);
	void DDX_DHtml_SelectValue(LPCTSTR szId, CString& value, BOOL bSave);
	void DDX_DHtml_SelectString(LPCTSTR szId, CString& value, BOOL bSave);
	void DDX_DHtml_SelectIndex(LPCTSTR szId, long& value, BOOL bSave);
	void DDX_DHtml_AxControl(LPCTSTR szId, DISPID dispid, VARIANT& var, BOOL bSave);
	void DDX_DHtml_AxControl(LPCTSTR szId, LPCTSTR szPropName, VARIANT& var, BOOL bSave);
	void OnDDXError(LPCTSTR szId, UINT nIDPrompt, BOOL bSave);

	void __cdecl DDX_DHtml_ElementTextWithFormat(LPCTSTR szId,
		DISPID dispid, LPCTSTR lpszFormat, UINT nIDPrompt, BOOL bSave, ...);
	void DDX_DHtml_ElementTextFloatFormat(LPCTSTR szId,
		DISPID dispid, void* pData, double value, int nSizeGcvt, BOOL bSave);
	BOOL _AfxSimpleScanf(LPCTSTR lpszText,
		LPCTSTR lpszFormat, va_list pData);
	BOOL _AfxSimpleFloatParse(LPCTSTR lpszText, double& d);
	long Select_FindString(IHTMLSelectElement *pSelect, BSTR bstr, BOOL fExact);
	void SetFocusToElement(LPCTSTR szId);

// event sink
	DWORD m_dwDHtmlEventSinkCookie;
	::ATL::CSimpleArray<CDHtmlControlSink *> m_ControlSinks;
	::ATL::CSimpleArray<CDHtmlElementEventSink *> m_SinkedElements;

	virtual const DHtmlEventMapEntry* GetDHtmlEventMap();

	HRESULT ConnectDHtmlEvents(IUnknown *punkDoc);
	void DisconnectDHtmlEvents();
	HRESULT ConnectDHtmlElementEvents(DWORD_PTR dwThunkOffset = 0);
	BOOL FindSinkForObject(LPCTSTR szName);
	BOOL IsSinkedElement(IDispatch *pdispElem);
	void DisconnectDHtmlElementEvents();

// host handler
	DWORD m_dwHostFlags;
	::ATL::CComPtr<IDispatch> m_spExternalDisp;
};

UINT __declspec(selectany) CDHtmlDialog::WM_DESTROYMODELESS = 0;

/////////////////////////////////////////////////////////////////////////////
// Multi Url event map support
struct DHtmlUrlEventMapEntry
{
	LPCTSTR szUrl;	// the url
	const DHtmlEventMapEntry *pEventMap; // the map associated with the Url
};

#define DECLARE_DHTML_URL_EVENT_MAP()\
	virtual const DHtmlEventMapEntry *GetEventMapForUrl(LPCTSTR szUrl);

#define BEGIN_DHTML_URL_EVENT_MAP(className)\

#define BEGIN_EMBED_DHTML_EVENT_MAP(className, mapName)\
	typedef className theClass;\
	static const DHtmlEventMapEntry className##mapName##[] = \
	{\

#define END_EMBED_DHTML_EVENT_MAP()\
{ DHTMLEVENTMAPENTRY_END, 0, NULL, NULL },\
	};\

#define BEGIN_URL_ENTRIES(className)\
	static const DHtmlUrlEventMapEntry className##UrlEntries[] = \
	{\

#define URL_EVENT_ENTRY(className, url, mapName)\
{ url, className##mapName },\

#define END_URL_ENTRIES()\
	{ NULL, NULL },\
	};\

#define END_DHTML_URL_EVENT_MAP(className)\
	const DHtmlEventMapEntry *className::GetEventMapForUrl(LPCTSTR szUrl)\
	{\
		for (int i=0; className##UrlEntries[i].szUrl; i++)\
		{\
			if (!_tcsicmp(className##UrlEntries[i].szUrl, szUrl))\
				return className##UrlEntries[i].pEventMap;\
		}\
	return NULL;\
}\

class CMultiPageDHtmlDialog : public CDHtmlDialog
{
public:
	CMultiPageDHtmlDialog();
	CMultiPageDHtmlDialog(UINT nIDTemplate, UINT nHtmlResID = 0, CWnd *pParentWnd = NULL);
	CMultiPageDHtmlDialog(LPCTSTR lpszTemplateName, LPCTSTR szHtmlResID = NULL, CWnd *pParentWnd = NULL);
	virtual ~CMultiPageDHtmlDialog();

//implementation
protected:
	virtual const DHtmlEventMapEntry *GetEventMapForUrl(LPCTSTR szUrl);
	virtual const DHtmlEventMapEntry* GetDHtmlEventMap();
	virtual void OnNavigateComplete(LPDISPATCH pDisp, LPCTSTR szUrl);
	DECLARE_DYNAMIC(CMultiPageDHtmlDialog)

	const DHtmlEventMapEntry *m_pCurrentMap;
};

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif // __AFXDHTML_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxdialogimpl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCPopupMenu;

class CDialogImpl
{
	friend class CDialogEx;
	friend class CMFCPropertyPage;
	friend class CMFCPropertySheet;

protected:
	CDialogImpl(CWnd& dlg);
	virtual ~CDialogImpl();

	static LRESULT CALLBACK DialogMouseHookProc(int nCode, WPARAM wParam, LPARAM lParam);

	void SetActiveMenu(CMFCPopupMenu* pMenu);

	BOOL ProcessMouseClick(POINT pt);
	BOOL ProcessMouseMove(POINT pt);

	BOOL PreTranslateMessage(MSG* pMsg);
	BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	void OnNcActivate(BOOL& bActive);
	void OnActivate(UINT nState, CWnd* pWndOther);

	void OnDestroy();

	CWnd& m_Dlg;

	AFX_IMPORT_DATA static HHOOK           m_hookMouse;
	AFX_IMPORT_DATA static CDialogImpl* m_pMenuDlgImpl;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxdlgs.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXDLGS_H__
#define __AFXDLGS_H__

#pragma once

#ifndef __AFXWIN_H__
	#include <afxwin.h>
#endif

#include <objbase.h>

#ifndef _INC_COMMDLG
	#include <commdlg.h>    // common dialog APIs
#endif

#if WINVER >= 0x0600
#ifndef _WIN32_IE
#define _WIN32_IE 0x0700
#else
#undef _WIN32_IE
#define _WIN32_IE 0x0700
#endif
#ifndef __shobjidl_h__
	#include <shobjidl.h>    // for IFileDialog/IFileOpenDialog/IFileSaveDialog
#endif
#endif

// Avoid mapping GetFileTitle to GetFileTitle[A/W]
#ifdef GetFileTitle
#undef GetFileTitle
AFX_INLINE short APIENTRY GetFileTitle(LPCTSTR lpszFile, LPTSTR lpszTitle, WORD cbBuf)
#ifdef UNICODE
	{ return ::GetFileTitleW(lpszFile, lpszTitle, cbBuf); }
#else
	{ return ::GetFileTitleA(lpszFile, lpszTitle, cbBuf); }
#endif
#endif

#ifndef _AFX_NO_RICHEDIT_SUPPORT
	#ifndef _RICHEDIT_
		#include <richedit.h>
	#endif
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 

#ifndef _AFX_NOFORCE_LIBS

/////////////////////////////////////////////////////////////////////////////
// Win32 libraries

#endif //!_AFX_NOFORCE_LIBS

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// AFXDLGS - MFC Standard dialogs

// Classes declared in this file

	// CDialog
		class CCommonDialog;  // implementation base class

			// modeless dialogs
			class CFindReplaceDialog; // Find/FindReplace dialog

			// modal dialogs
			class CFileDialog;    // FileOpen/FileSaveAs dialogs
			class CColorDialog;   // Color picker dialog
			class CFontDialog;    // Font chooser dialog
			class CPrintDialog;   // Print/PrintSetup dialogs
#if WINVER >= 0x0500
			class CPrintDialogEx;   // Windows 2000 Print dialog
#endif //(WINVER >= 0x0500)
			class CPageSetupDialog; // Page Setup dialog

	// CWnd
	class CPropertySheet;     // implements tabbed dialogs

	// CDialog
		class CPropertyPage;  // Used with CPropertySheet for tabbed dialogs

/////////////////////////////////////////////////////////////////////////////

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

/////////////////////////////////////////////////////////////////////////////
// CCommonDialog - base class for all common dialogs

class CCommonDialog : public CDialog
{
	DECLARE_DYNAMIC(CCommonDialog)
	
public:
	explicit CCommonDialog(CWnd* pParentWnd);

// Implementation
public:
    virtual ~CCommonDialog() {};

protected:
	virtual void OnOK();
	virtual void OnCancel();

	//{{AFX_MSG(CCommonDialog)
	afx_msg BOOL OnHelpInfo(HELPINFO*);
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CFileDialog - used for FileOpen... or FileSaveAs...

class CFileDialog : public CCommonDialog
{
	DECLARE_DYNAMIC(CFileDialog)

public:
// Attributes
	__declspec(property(get=GetOFN)) OPENFILENAME m_ofn;
	const OPENFILENAME& GetOFN() const;
	OPENFILENAME& GetOFN();
	LPOPENFILENAME m_pOFN;

// Constructors
	explicit CFileDialog(BOOL bOpenFileDialog, // TRUE for FileOpen, FALSE for FileSaveAs
		LPCTSTR lpszDefExt = NULL,
		LPCTSTR lpszFileName = NULL,
		DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
		LPCTSTR lpszFilter = NULL,
		CWnd* pParentWnd = NULL,
		DWORD dwSize = 0,
		BOOL bVistaStyle = TRUE);
	virtual ~CFileDialog();

// Operations
	virtual INT_PTR DoModal();

#if WINVER >= 0x0600
	/// <summary>
	/// Determines if the current dialog in folder picker mode.</summary>
	/// <returns> 
	/// If the dialog in the folder pikcer mode, the return value is TRUE. Otherwise - FALSE</returns>
	BOOL IsPickFoldersMode() const { return m_bPickFoldersMode; }
#endif

	// Helpers for parsing file name after successful return
	// or during Overridable callbacks if OFN_EXPLORER is set
	CString GetPathName() const;  // return full path and filename
	CString GetFileName() const;  // return only filename
	CString GetFileExt() const;   // return only ext
	CString GetFileTitle() const; // return file title
	BOOL GetReadOnlyPref() const; // return TRUE if readonly checked

	// Enumerating multiple file selections
	POSITION GetStartPosition() const;
	CString GetNextPathName(POSITION& pos) const;

	// Helpers for custom templates
	void SetTemplate(UINT nWin3ID, UINT nWin4ID);
	void SetTemplate(LPCTSTR lpWin3ID, LPCTSTR lpWin4ID);

	// Other operations available while the dialog is visible
	CString GetFolderPath() const; // return full path
	void SetControlText(int nID, LPCSTR lpsz);
	#ifdef UNICODE
	void SetControlText(int nID, const wchar_t  *lpsz);
	#endif 
	void HideControl(int nID);
	void SetDefExt(LPCSTR lpsz);

	virtual void UpdateOFNFromShellDialog();
	void ApplyOFNToShellDialog();
	IFileOpenDialog* GetIFileOpenDialog() throw();
	IFileSaveDialog* GetIFileSaveDialog() throw();
	IFileDialogCustomize* GetIFileDialogCustomize() throw();

#if WINVER >= 0x0600
	/// <summary>
	/// Adds a folder to the list of places available for the user to open or save items.</summary>
	/// <param name="lpszFolder">A path to the folder to be made available to the user. This can only be a folder.</param>
	/// <param name="fdap">Specifies where the folder is placed within the list.</param>
	void AddPlace(LPCWSTR lpszFolder, FDAP fdap = FDAP_TOP) throw();

	/// <summary>
	/// Adds a folder to the list of places available for the user to open or save items.</summary>
	/// <param name="psi">A pointer to an IShellItem that represents the folder to be made available to the user. This can only be a folder.</param>
	/// <param name="fdap">Specifies where the folder is placed within the list.</param>
	void AddPlace(IShellItem* psi, FDAP fdap = FDAP_TOP) throw();

	/// <summary>
	/// Gets the choice that the user made in the dialog.</summary>
	/// <returns> 
	/// A pointer to an IShellItem that represents the user's choice</returns>
	IShellItem* GetResult() throw();

	/// <summary>
	/// Gets the user's choices in a dialog that allows multiple selection.</summary>
	/// <returns> 
	/// A pointer to an IShellItemArray through which the items selected in the dialog can be accessed</returns>
	IShellItemArray* GetResults() throw();

	/// <summary>
	/// Provides a property store that defines the default values to be used for the item being saved.</summary>
	/// <returns> 
	/// TRUE if successful, FALSE - otherwise</returns>
	/// <param name="lpszPropList">A list of predefined properties divided by ";"</param>
	BOOL SetProperties(LPCWSTR lpszPropList);

	// IFileDialogCustomize wrappers:

	/// <summary>
	/// Enables a drop-down list on the Open or Save button in the dialog.</summary>
	/// <returns> 
	/// Returns S_OK if successful, or an error value otherwise.</returns>
	/// <param name="dwIDCtl">The ID of the drop-down list</param>
	HRESULT EnableOpenDropDown(DWORD dwIDCtl);

	/// <summary>
	/// Adds a menu to the dialog.</summary>
	/// <returns> 
	/// Returns S_OK if successful, or an error value otherwise.</returns>
	/// <param name="dwIDCtl">The ID of the menu to add</param>
	/// <param name="strLabel">The menu name</param>
	HRESULT AddMenu(DWORD dwIDCtl, const CString& strLabel);

	/// <summary>
	/// Adds a button to the dialog.</summary>
	/// <returns> 
	/// Returns S_OK if successful, or an error value otherwise.</returns>
	/// <param name="dwIDCtl">The ID of the button to add</param>
	/// <param name="strLabel">The button name</param>
	HRESULT AddPushButton(DWORD dwIDCtl, const CString& strLabel);

	/// <summary>
	/// Adds a combo box to the dialog.</summary>
	/// <returns> 
	/// Returns S_OK if successful, or an error value otherwise.</returns>
	/// <param name="dwIDCtl">The ID of the combo box to add</param>
	HRESULT AddComboBox(DWORD dwIDCtl);

	/// <summary>
	/// Adds an option button (also known as radio button) group to the dialog.</summary>
	/// <returns> 
	/// Returns S_OK if successful, or an error value otherwise.</returns>
	/// <param name="dwIDCtl">The ID of the option button group to add</param>
	HRESULT AddRadioButtonList(DWORD dwIDCtl);

	/// <summary>
	/// Adds a check button to the dialog.</summary>
	/// <returns> 
	/// Returns S_OK if successful, or an error value otherwise.</returns>
	/// <param name="dwIDCtl">The ID of the check button to add</param>
	/// <param name="strLabel">The check button name</param>
	/// <param name="bChecked">A BOOL indicating the current state of the check button. TRUE if checked; FALSE otherwise</param>
	HRESULT AddCheckButton(DWORD dwIDCtl, const CString& strLabel, BOOL bChecked);

	/// <summary>
	/// Adds an edit box to the dialog.</summary>
	/// <returns> 
	/// Returns S_OK if successful, or an error value otherwise.</returns>
	/// <param name="dwIDCtl">The ID of the edit box to add</param>
	/// <param name="strText">The edit box name</param>
	HRESULT AddEditBox(DWORD dwIDCtl, const CString& strText);

	/// <summary>
	/// Adds a separator to the dialog.</summary>
	/// <returns> 
	/// Returns S_OK if successful, or an error value otherwise.</returns>
	/// <param name="dwIDCtl">The ID of the separator add</param>
	HRESULT AddSeparator(DWORD dwIDCtl);

	/// <summary>
	/// Adds text content to the dialog.</summary>
	/// <returns> 
	/// Returns S_OK if successful, or an error value otherwise.</returns>
	/// <param name="dwIDCtl">The ID of the text to add</param>
	/// <param name="strText">The text name</param>
	HRESULT AddText(DWORD dwIDCtl, const CString& strText);

	/// <summary>
	/// Sets the text associated with a control, such as button text or an edit box label.</summary>
	/// <returns> 
	/// Returns S_OK if successful, or an error value otherwise.</returns>
	/// <param name="dwIDCtl">The ID of the control</param>
	/// <param name="strLabel">The control name</param>
	HRESULT SetControlLabel(DWORD dwIDCtl, const CString& strLabel);

	/// <summary>
	/// Gets the current visibility and enabled states of a given control.</summary>
	/// <returns> 
	/// Returns S_OK if successful, or an error value otherwise.</returns>
	/// <param name="dwIDCtl">The ID of the control</param>
	/// <param name="dwState">A reference to a variable that receives one or more values from the CDCONTROLSTATE enumeration that indicate the current state of the control.</param>
	HRESULT GetControlState(DWORD dwIDCtl, CDCONTROLSTATEF& dwState);

	/// <summary>
	/// Sets the current visibility and enabled states of a given control.</summary>
	/// <returns> 
	/// Returns S_OK if successful, or an error value otherwise.</returns>
	/// <param name="dwIDCtl">The ID of the control</param>
	/// <param name="dwState"> One or more values from the CDCONTROLSTATE enumeration that indicate the current state of the control.</param>
	HRESULT SetControlState(DWORD dwIDCtl, CDCONTROLSTATEF dwState);

	/// <summary>
	/// Gets the current text in an edit box control.</summary>
	/// <returns> 
	/// Returns S_OK if successful, or an error value otherwise.</returns>
	/// <param name="dwIDCtl">The ID of the edit box</param>
	/// <param name="strText">The text value</param>
	HRESULT GetEditBoxText(DWORD dwIDCtl, CString& strText);

	/// <summary>
	/// Sets the current text in an edit box control.</summary>
	/// <returns> 
	/// Returns S_OK if successful, or an error value otherwise.</returns>
	/// <param name="dwIDCtl">The ID of the edit box</param>
	/// <param name="strText">The text value</param>
	HRESULT SetEditBoxText(DWORD dwIDCtl, const CString& strText);

	/// <summary>
	/// Gets the current state of a check button (check box) in the dialog.</summary>
	/// <returns> 
	/// Returns S_OK if successful, or an error value otherwise.</returns>
	/// <param name="dwIDCtl">The ID of the check box</param>
	/// <param name="bChecked">check box state: TRUE means checked; FALSE, unchecked</param>
	HRESULT GetCheckButtonState(DWORD dwIDCtl, BOOL& bChecked);

	/// <summary>
	/// Sets the current state of a check button (check box) in the dialog.</summary>
	/// <returns> 
	/// Returns S_OK if successful, or an error value otherwise.</returns>
	/// <param name="dwIDCtl">The ID of the check box</param>
	/// <param name="bChecked">check box state: TRUE means checked; FALSE, unchecked</param>
	HRESULT SetCheckButtonState(DWORD dwIDCtl, BOOL bChecked);

	/// <summary>
	/// Adds an item to a container control in the dialog.</summary>
	/// <returns> 
	/// Returns S_OK if successful, or an error value otherwise.</returns>
	/// <param name="dwIDCtl">The ID of the container control to which the item is to be added</param>
	/// <param name="dwIDItem">The ID of the item</param>
	/// <param name="strLabel">Item's text</param>
	HRESULT AddControlItem(DWORD dwIDCtl, DWORD dwIDItem, const CString& strLabel);

	/// <summary>
	/// Removes an item from a container control in the dialog.</summary>
	/// <returns> 
	/// Returns S_OK if successful, or an error value otherwise.</returns>
	/// <param name="dwIDCtl">The ID of the container control from which the item is to be removed</param>
	/// <param name="dwIDItem">The ID of the item</param>
	HRESULT RemoveControlItem(DWORD dwIDCtl, DWORD dwIDItem);

	/// <summary>
	/// Gets the current state of an item in a container control found in the dialog.</summary>
	/// <returns> 
	/// Returns S_OK if successful, or an error value otherwise.</returns>
	/// <param name="dwIDCtl">The ID of the container control</param>
	/// <param name="dwIDItem">The ID of the item</param>
	/// <param name="dwState">A reference to a variable that receives one of more values from the CDCONTROLSTATE enumeration that indicate the current state of the control</param>
	HRESULT GetControlItemState(DWORD dwIDCtl, DWORD dwIDItem, CDCONTROLSTATEF& dwState);

	/// <summary>
	/// Sets the current state of an item in a container control found in the dialog.</summary>
	/// <returns> 
	/// Returns S_OK if successful, or an error value otherwise.</returns>
	/// <param name="dwIDCtl">The ID of the container control</param>
	/// <param name="dwIDItem">The ID of the item</param>
	/// <param name="dwState">One or more values from the CDCONTROLSTATE enumeration that indicate the new state of the control</param>
	HRESULT SetControlItemState(DWORD dwIDCtl, DWORD dwIDItem, CDCONTROLSTATEF dwState);

	/// <summary>
	/// Gets a particular item from specified container controls in the dialog.</summary>
	/// <returns> 
	/// Returns S_OK if successful, or an error value otherwise.</returns>
	/// <param name="dwIDCtl">The ID of the container control</param>
	/// <param name="dwIDItem">The ID of the item that the user selected in the control</param>
	HRESULT GetSelectedControlItem(DWORD dwIDCtl, DWORD& dwIDItem);

	/// <summary>
	/// Sets the selected state of a particular item in an option button group or a combo box found in the dialog.</summary>
	/// <returns> 
	/// Returns S_OK if successful, or an error value otherwise.</returns>
	/// <param name="dwIDCtl">The ID of the container control</param>
	/// <param name="dwIDItem">The ID of the item that the user selected in the control</param>
	HRESULT SetSelectedControlItem(DWORD dwIDCtl, DWORD dwIDItem);

	/// <summary>
	/// Declares a visual group in the dialog. Subsequent calls to any "add" method add those elements to this group.</summary>
	/// <returns> 
	/// Returns S_OK if successful, or an error value otherwise.</returns>
	/// <param name="dwIDCtl">The ID of the visual group</param>
	/// <param name="strLabel">The group name</param>
	HRESULT StartVisualGroup(DWORD dwIDCtl, const CString& strLabel);

	/// <summary>
	/// Stops the addition of elements to a visual group in the dialog.</summary>
	/// <returns> 
	/// Returns S_OK if successful, or an error value otherwise.</returns>
	HRESULT EndVisualGroup();

	/// <summary>
	/// Places a control in the dialog so that it stands out compared to other added controls.</summary>
	/// <returns> 
	/// Returns S_OK if successful, or an error value otherwise.</returns>
	/// <param name="dwIDCtl">The ID of the control</param>
	HRESULT MakeProminent(DWORD dwIDCtl);

	/// <summary>
	/// Sets the text of a control item. For example, the text that accompanies a radio button or an item in a menu.</summary>
	/// <returns> 
	/// Returns S_OK if successful, or an error value otherwise.</returns>
	/// <param name="dwIDCtl">The ID of the container control</param>
	/// <param name="dwIDItem">The ID of the item</param>
	/// <param name="strLabel">Item's text</param>
	HRESULT SetControlItemText(DWORD dwIDCtl, DWORD dwIDItem, const CString& strLabel);
#endif

// Overridable callbacks
protected:

#if WINVER >= 0x0600
	HRESULT CDialogEventHandler_CreateInstance(REFIID riid, void **ppv);
#endif

	friend UINT_PTR CALLBACK _AfxCommDlgProc(HWND, UINT, WPARAM, LPARAM);
	virtual UINT OnShareViolation(LPCTSTR lpszPathName);
	virtual BOOL OnFileNameOK();
	virtual void OnLBSelChangedNotify(UINT nIDBox, UINT iCurSel, UINT nCode);

	// only called back if OFN_EXPLORER is set
	virtual void OnInitDone();
	virtual void OnFileNameChange();
	virtual void OnFolderChange();
	virtual void OnTypeChange();

	/// <summary>
	/// Called when the container item is being selected.</summary>
	/// <param name="dwIDCtl">The ID of the container control</param>
	/// <param name="dwIDItem">The ID of the item</param>
	virtual void OnItemSelected(DWORD dwIDCtl, DWORD dwIDItem);

	/// <summary>
	/// Called when the button is clicked.</summary>
	/// <param name="dwIDCtl">The ID of the button</param>
	virtual void OnButtonClicked(DWORD dwIDCtl);

	/// <summary>
	/// Called when the check box is checked/unchecked.</summary>
	/// <param name="dwIDCtl">The ID of the check box</param>
	/// <param name="bChecked">checked/unchecked</param>
	virtual void OnCheckButtonToggled(DWORD dwIDCtl, BOOL bChecked);

	/// <summary>
	/// Called when the control is being active.</summary>
	/// <param name="dwIDCtl">The ID of the control</param>
	virtual void OnControlActivating(DWORD dwIDCtl);

// Implementation
#ifdef _DEBUG
public:
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

	BOOL m_bVistaStyle;
	BOOL m_bPickFoldersMode;
	DWORD m_dwCookie;
	void* m_pIFileDialog;
	void* m_pIFileDialogCustomize;

	BOOL m_bOpenFileDialog;       // TRUE for file open, FALSE for file save
	CString m_strFilter;          // filter string
						// separate fields with '|', terminate with '||\0'
	TCHAR m_szFileTitle[64];       // contains file title after return
	TCHAR m_szFileName[_MAX_PATH]; // contains full path name after return

	OPENFILENAME*  m_pofnTemp;

	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);

protected:
	DECLARE_INTERFACE_MAP()

#if WINVER >= 0x0600

	BEGIN_INTERFACE_PART(FileDialogEvents, IFileDialogEvents)
		STDMETHOD(OnFileOk)(IFileDialog *);
		STDMETHOD(OnFolderChange)(IFileDialog *);
		STDMETHOD(OnFolderChanging)(IFileDialog *, IShellItem *);
		STDMETHOD(OnHelp)(IFileDialog *);
		STDMETHOD(OnSelectionChange)(IFileDialog *);
		STDMETHOD(OnShareViolation)(IFileDialog *pfd, IShellItem *psi, FDE_SHAREVIOLATION_RESPONSE *pResponse);
		STDMETHOD(OnTypeChange)(IFileDialog *);
		STDMETHOD(OnOverwrite)(IFileDialog *, IShellItem *, FDE_OVERWRITE_RESPONSE *);
	END_INTERFACE_PART_OPTIONAL(FileDialogEvents)

	BEGIN_INTERFACE_PART(FileDialogControlEvents, IFileDialogControlEvents)
		STDMETHOD(OnItemSelected)(IFileDialogCustomize *, DWORD, DWORD);
		STDMETHOD(OnButtonClicked)(IFileDialogCustomize *, DWORD);
		STDMETHOD(OnCheckButtonToggled)(IFileDialogCustomize *, DWORD, BOOL);
		STDMETHOD(OnControlActivating)(IFileDialogCustomize *, DWORD);
	END_INTERFACE_PART_OPTIONAL(FileDialogControlEvents)

#else
	
	BEGIN_INTERFACE_PART(FileDialogEvents, IUnknown)
	END_INTERFACE_PART_OPTIONAL(FileDialogEvents)
	
	BEGIN_INTERFACE_PART(FileDialogControlEvents, IUnknown)
	END_INTERFACE_PART_OPTIONAL(FileDialogControlEvents)

#endif

private:
#if WINVER >= 0x0600
	HRESULT _PSGetPropertyDescriptionListFromString(LPCWSTR pszPropList, REFIID riid, void **ppv);
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CFolderPickerDialog - used to select a folder

/// <summary>
/// CFolderPickerDialog class implements CFileDialog in the folder picker mode.</summary>
class CFolderPickerDialog : public CFileDialog
{
	DECLARE_DYNAMIC(CFolderPickerDialog)

// Constructors

	/// <summary>
	/// CFolderPickerDialog constructor</summary>
	/// <param name="lpszFolder">Initial folder</param>
	/// <param name="dwFlags">A combination of one or more flags that allow you to customize the dialog box</param>
	/// <param name="pParentWnd">A pointer to the file dialog-box object's parent or owner window</param>
	/// <param name="dwSize">The size of the OPENFILENAME structure</param>
	explicit CFolderPickerDialog(LPCTSTR lpszFolder = NULL, DWORD dwFlags = 0, CWnd* pParentWnd = NULL, DWORD dwSize = 0);

	/// <summary>
	/// CFolderPickerDialog destructor.</summary>
	virtual ~CFolderPickerDialog();
};

/////////////////////////////////////////////////////////////////////////////
// CFontDialog - used to select a font

class CFontDialog : public CCommonDialog
{
	DECLARE_DYNAMIC(CFontDialog)

public:
// Attributes
	// font choosing parameter block
	CHOOSEFONT m_cf;

// Constructors
	CFontDialog(LPLOGFONT lplfInitial = NULL,
		DWORD dwFlags = CF_EFFECTS | CF_SCREENFONTS,
		CDC* pdcPrinter = NULL,
		CWnd* pParentWnd = NULL);
#ifndef _AFX_NO_RICHEDIT_SUPPORT
	CFontDialog(const CHARFORMAT& charformat,
		DWORD dwFlags = CF_SCREENFONTS,
		CDC* pdcPrinter = NULL,
		CWnd* pParentWnd = NULL);
#endif
// Operations
	virtual INT_PTR DoModal();

	// Get the selected font (works during DoModal displayed or after)
	void GetCurrentFont(LPLOGFONT lplf);

	// Helpers for parsing information after successful return
	CString GetFaceName() const;  // return the face name of the font
	CString GetStyleName() const; // return the style name of the font
	int GetSize() const;          // return the pt size of the font
	COLORREF GetColor() const;    // return the color of the font
	int GetWeight() const;        // return the chosen font weight
	BOOL IsStrikeOut() const;     // return TRUE if strikeout
	BOOL IsUnderline() const;     // return TRUE if underline
	BOOL IsBold() const;          // return TRUE if bold font
	BOOL IsItalic() const;        // return TRUE if italic font
#ifndef _AFX_NO_RICHEDIT_SUPPORT
	void GetCharFormat(CHARFORMAT& cf) const;
#endif

// Implementation
	LOGFONT m_lf; // default LOGFONT to store the info
#ifndef _AFX_NO_RICHEDIT_SUPPORT
	DWORD FillInLogFont(const CHARFORMAT& cf);
#endif

#ifdef _DEBUG
public:
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	TCHAR m_szStyleName[64]; // contains style name after return
};

/////////////////////////////////////////////////////////////////////////////
// CColorDialog - used to select a color

class CColorDialog : public CCommonDialog
{
	DECLARE_DYNAMIC(CColorDialog)

public:
// Attributes
	// color chooser parameter block
	CHOOSECOLOR m_cc;

// Constructors
	CColorDialog(COLORREF clrInit = 0, DWORD dwFlags = 0,
			CWnd* pParentWnd = NULL);

// Operations
	virtual INT_PTR DoModal();

	// Set the current color while dialog is displayed
	void SetCurrentColor(COLORREF clr);

	// Helpers for parsing information after successful return
	COLORREF GetColor() const;
	static COLORREF* PASCAL GetSavedCustomColors();

// Overridable callbacks
protected:
	friend UINT_PTR CALLBACK _AfxCommDlgProc(HWND, UINT, WPARAM, LPARAM);
	virtual BOOL OnColorOK();       // validate color

// Implementation

#ifdef _DEBUG
public:
	virtual void Dump(CDumpContext& dc) const;
#endif
};

// for backward compatibility clrSavedCustom is defined as GetSavedCustomColors
#define clrSavedCustom GetSavedCustomColors()

/////////////////////////////////////////////////////////////////////////////
// Page Setup dialog

class CPageSetupDialog : public CCommonDialog
{
	DECLARE_DYNAMIC(CPageSetupDialog)

public:
// Attributes
	PAGESETUPDLG m_psd;

// Constructors
	CPageSetupDialog(DWORD dwFlags = PSD_MARGINS | PSD_INWININIINTLMEASURE,
		CWnd* pParentWnd = NULL);

// Attributes
	LPDEVMODE GetDevMode() const;   // return DEVMODE
	CString GetDriverName() const;  // return driver name
	CString GetDeviceName() const;  // return device name
	CString GetPortName() const;    // return output port name
	HDC CreatePrinterDC();
	CSize GetPaperSize() const;
	void GetMargins(LPRECT lpRectMargins, LPRECT lpRectMinMargins) const;

// Operations
	virtual INT_PTR DoModal();

// Overridables
	virtual UINT PreDrawPage(WORD wPaper, WORD wFlags, LPPAGESETUPDLG pPSD);
	virtual UINT OnDrawPage(CDC* pDC, UINT nMessage, LPRECT lpRect);

// Implementation
protected:
	static UINT CALLBACK PaintHookProc(HWND hWnd, UINT message, WPARAM wParam,
		LPARAM lParam);

#ifdef _DEBUG
public:
	virtual void Dump(CDumpContext& dc) const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CPrintDialog - used for Print... and PrintSetup...

class CPrintDialog : public CCommonDialog
{
	DECLARE_DYNAMIC(CPrintDialog)

public:
// Attributes
	// print dialog parameter block (note this is a reference)
	PRINTDLG& m_pd;

// Constructors
	CPrintDialog(BOOL bPrintSetupOnly,
		// TRUE for Print Setup, FALSE for Print Dialog
		DWORD dwFlags = PD_ALLPAGES | PD_USEDEVMODECOPIES | PD_NOPAGENUMS
			| PD_HIDEPRINTTOFILE | PD_NOSELECTION,
		CWnd* pParentWnd = NULL);

// Operations
	virtual INT_PTR DoModal();

	// GetDefaults will not display a dialog but will get
	// device defaults
	BOOL GetDefaults();

	// Helpers for parsing information after successful return
	int GetCopies() const;          // num. copies requested
	BOOL PrintCollate() const;      // TRUE if collate checked
	BOOL PrintSelection() const;    // TRUE if printing selection
	BOOL PrintAll() const;          // TRUE if printing all pages
	BOOL PrintRange() const;        // TRUE if printing page range
	int GetFromPage() const;        // starting page if valid
	int GetToPage() const;          // starting page if valid
	LPDEVMODE GetDevMode() const;   // return DEVMODE
	CString GetDriverName() const;  // return driver name
	CString GetDeviceName() const;  // return device name
	CString GetPortName() const;    // return output port name
	HDC GetPrinterDC() const;       // return HDC (caller must delete)

	// This helper creates a DC based on the DEVNAMES and DEVMODE structures.
	// This DC is returned, but also stored in m_pd.hDC as though it had been
	// returned by CommDlg.  It is assumed that any previously obtained DC
	// has been/will be deleted by the user.  This may be
	// used without ever invoking the print/print setup dialogs.

	HDC CreatePrinterDC();

// Implementation

#ifdef _DEBUG
public:
	virtual void Dump(CDumpContext& dc) const;
#endif

private:
	PRINTDLG m_pdActual; // the Print/Print Setup need to share this
protected:
	// The following handle the case of print setup... from the print dialog
	CPrintDialog(PRINTDLG& pdInit);
	virtual CPrintDialog* AttachOnSetup();

	//{{AFX_MSG(CPrintDialog)
	afx_msg void OnPrintSetup();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CPrintDialogEx - Windows 2000 Print Dialog

#if WINVER >= 0x0500

#ifndef __ocidl_h__
	#include <ocidl.h>
#endif

class CPrintDialogEx :
			public CCommonDialog,
			public IPrintDialogCallback,
			public IObjectWithSite
{

	DECLARE_DYNAMIC(CPrintDialogEx)

public:
// Attributes
	// print dialog parameter block
	PRINTDLGEX m_pdex;

// Constructors
	CPrintDialogEx(DWORD dwFlags = PD_ALLPAGES | PD_USEDEVMODECOPIES | PD_NOPAGENUMS
			| PD_HIDEPRINTTOFILE | PD_NOSELECTION | PD_NOCURRENTPAGE,
		CWnd* pParentWnd = NULL);

// Operations
	virtual INT_PTR DoModal();

	// GetDefaults will not display a dialog but will get
	// device defaults
	BOOL GetDefaults();

	// Helpers for parsing information after successful return
	int GetCopies() const;          // num. copies requested
	BOOL PrintCollate() const;      // TRUE if collate checked
	BOOL PrintSelection() const;    // TRUE if printing selection
	BOOL PrintCurrentPage() const;	// TRUE if printing current page
	BOOL PrintAll() const;          // TRUE if printing all pages
	BOOL PrintRange() const;        // TRUE if printing page range
	LPDEVMODE GetDevMode() const;   // return DEVMODE
	CString GetDriverName() const;  // return driver name
	CString GetDeviceName() const;  // return device name
	CString GetPortName() const;    // return output port name
	HDC GetPrinterDC() const;       // return HDC (caller must delete)

	// This helper creates a DC based on the DEVNAMES and DEVMODE structures.
	// This DC is returned, but also stored in m_pdex.hDC as though it had been
	// returned by CommDlg.  It is assumed that any previously obtained DC
	// has been/will be deleted by the user.  This may be
	// used without ever invoking the print dialog.

	HDC CreatePrinterDC();

// Implementation

#ifdef _DEBUG
public:
	virtual void Dump(CDumpContext& dc) const;
#endif

// IUnknown
	STDMETHOD(QueryInterface)(REFIID riid, void** ppvObject);
	virtual ULONG STDMETHODCALLTYPE AddRef();
	virtual ULONG STDMETHODCALLTYPE Release();

// IPrintDialogCallback
	STDMETHOD(InitDone)();
	STDMETHOD(SelectionChange)();
	STDMETHOD(HandleMessage)(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam, LRESULT* plResult);

// IObjectWithSite
	STDMETHOD(SetSite)(IUnknown *pUnkSite);
	STDMETHOD(GetSite)(REFIID riid, void **ppvSite);

	IUnknown* m_pUnkSite;

	// implementation helpers
	HWND PreModal();
	void PostModal();
	virtual LRESULT DefWindowProc(UINT message, WPARAM wParam, LPARAM lParam);

	//{{AFX_MSG(CPrintDialogEx)
	afx_msg LRESULT HandleInitDialog(WPARAM, LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif //(WINVER >= 0x0500)

/////////////////////////////////////////////////////////////////////////////
// Find/FindReplace modeless dialogs

class CFindReplaceDialog : public CCommonDialog
{
	DECLARE_DYNAMIC(CFindReplaceDialog)

public:
// Attributes
	FINDREPLACE m_fr;

// Constructors
	CFindReplaceDialog();
	// Note: you must allocate these on the heap.
	//  If you do not, you must derive and override PostNcDestroy()

	virtual BOOL Create(BOOL bFindDialogOnly, // TRUE for Find, FALSE for FindReplace
			LPCTSTR lpszFindWhat,
			LPCTSTR lpszReplaceWith = NULL,
			DWORD dwFlags = FR_DOWN,
			CWnd* pParentWnd = NULL);

	// find/replace parameter block
	static CFindReplaceDialog* PASCAL GetNotifier(LPARAM lParam);

// Operations
	// Helpers for parsing information after successful return
	CString GetReplaceString() const;// get replacement string
	CString GetFindString() const;   // get find string
	BOOL SearchDown() const;         // TRUE if search down, FALSE is up
	BOOL FindNext() const;           // TRUE if command is find next
	BOOL MatchCase() const;          // TRUE if matching case
	BOOL MatchWholeWord() const;     // TRUE if matching whole words only
	BOOL ReplaceCurrent() const;     // TRUE if replacing current string
	BOOL ReplaceAll() const;         // TRUE if replacing all occurrences
	BOOL IsTerminating() const;      // TRUE if terminating dialog

// Implementation
protected:
	virtual void PostNcDestroy();

#ifdef _DEBUG
public:
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	TCHAR m_szFindWhat[128];
	TCHAR m_szReplaceWith[128];
};

////////////////////////////////////////////////////////////////////////////
// CPropertyPage -- one page of a tabbed dialog

class CPropertyPage : public CDialog
{
	DECLARE_DYNAMIC(CPropertyPage)

// Construction
public:
	// simple construction
	CPropertyPage();
	explicit CPropertyPage(UINT nIDTemplate, UINT nIDCaption = 0, DWORD dwSize = sizeof(PROPSHEETPAGE));
	explicit CPropertyPage(LPCTSTR lpszTemplateName, UINT nIDCaption = 0, DWORD dwSize = sizeof(PROPSHEETPAGE));
	void Construct(UINT nIDTemplate, UINT nIDCaption = 0);
	void Construct(LPCTSTR lpszTemplateName, UINT nIDCaption = 0);

	// extended construction
	CPropertyPage(UINT nIDTemplate, UINT nIDCaption, 
		UINT nIDHeaderTitle, UINT nIDHeaderSubTitle = 0, DWORD dwSize = sizeof(PROPSHEETPAGE));
	CPropertyPage(LPCTSTR lpszTemplateName, UINT nIDCaption, 
		UINT nIDHeaderTitle, UINT nIDHeaderSubTitle = 0, DWORD dwSize = sizeof(PROPSHEETPAGE));
	void Construct(UINT nIDTemplate, UINT nIDCaption, 
		UINT nIDHeaderTitle, UINT nIDHeaderSubTitle = 0);
	void Construct(LPCTSTR lpszTemplateName, UINT nIDCaption, 
		UINT nIDHeaderTitle, UINT nIDHeaderSubTitle = 0);

// Attributes
	__declspec(property(get=GetPSP)) PROPSHEETPAGE m_psp;
	const PROPSHEETPAGE & GetPSP() const;
	PROPSHEETPAGE & GetPSP();
	LPPROPSHEETPAGE m_pPSP;

// Operations
	void CancelToClose();
	void SetModified(BOOL bChanged = TRUE);
	LRESULT QuerySiblings(WPARAM wParam, LPARAM lParam);

// Overridables
public:
	virtual BOOL OnApply();
	virtual void OnReset();
	virtual void OnOK();
	virtual void OnCancel();
	virtual BOOL OnSetActive();
	virtual BOOL OnKillActive();
	virtual BOOL OnQueryCancel();

	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	virtual BOOL OnWizardFinish();	
	virtual HWND OnWizardFinishEx();

// Implementation
public:
	virtual ~CPropertyPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	void EndDialog(int nEndID); // called for error scenarios

protected:
	// private implementation data
	CString m_strCaption;
	BOOL m_bFirstSetActive;
	CString m_strHeaderTitle;    // this is displayed in the header
	CString m_strHeaderSubTitle; //

	// implementation helpers
	void AllocPSP(DWORD dwSize);
	void CommonConstruct(LPCTSTR lpszTemplateName, UINT nIDCaption);
	void CommonConstruct(LPCTSTR lpszTemplateName, UINT nIDCaption, 
		UINT nIDHeaderTitle, UINT nIDHeaderSubTitle);
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	virtual BOOL PreTranslateMessage(MSG*);
	LRESULT MapWizardResult(LRESULT lToMap);
	BOOL IsButtonEnabled(int iButton);

	void PreProcessPageTemplate(PROPSHEETPAGE& psp, BOOL bWizard);
#ifndef _AFX_NO_OCC_SUPPORT
	void Cleanup();
	const DLGTEMPLATE* InitDialogInfo(const DLGTEMPLATE* pTemplate);
#endif

	// Generated message map functions
	//{{AFX_MSG(CPropertyPage)
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	friend class CPropertySheet;
};

#define CPropertyPageEx CPropertyPage

////////////////////////////////////////////////////////////////////////////
// CPropertySheet -- a tabbed "dialog" (really a popup-window)

class CTabCtrl; // forward reference (see afxcmn.h)

class CPropertySheet : public CWnd
{
	DECLARE_DYNAMIC(CPropertySheet)

// Construction
public:
	// simple construction
	CPropertySheet();
	explicit CPropertySheet(UINT nIDCaption, CWnd* pParentWnd = NULL,
		UINT iSelectPage = 0);
	explicit CPropertySheet(LPCTSTR pszCaption, CWnd* pParentWnd = NULL,
		UINT iSelectPage = 0);
	void Construct(UINT nIDCaption, CWnd* pParentWnd = NULL,
		UINT iSelectPage = 0);
	void Construct(LPCTSTR pszCaption, CWnd* pParentWnd = NULL,
		UINT iSelectPage = 0);

	// extended construction
	CPropertySheet(UINT nIDCaption, CWnd* pParentWnd,
		UINT iSelectPage, HBITMAP hbmWatermark,
		HPALETTE hpalWatermark = NULL, HBITMAP hbmHeader = NULL);
	CPropertySheet(LPCTSTR pszCaption, CWnd* pParentWnd,
		UINT iSelectPage, HBITMAP hbmWatermark,
		HPALETTE hpalWatermark = NULL, HBITMAP hbmHeader = NULL);
	void Construct(UINT nIDCaption, CWnd* pParentWnd,
		UINT iSelectPage, HBITMAP hbmWatermark,
		HPALETTE hpalWatermark = NULL, HBITMAP hbmHeader = NULL);
	void Construct(LPCTSTR pszCaption, CWnd* pParentWnd,
		UINT iSelectPage, HBITMAP hbmWatermark,
		HPALETTE hpalWatermark = NULL, HBITMAP hbmHeader = NULL);

	// for modeless creation
	virtual BOOL Create(CWnd* pParentWnd = NULL, DWORD dwStyle = (DWORD)-1,
		DWORD dwExStyle = 0);
	// the default style, expressed by passing -1 as dwStyle, is actually:
	// WS_SYSMENU | WS_POPUP | WS_CAPTION | DS_MODALFRAME | DS_CONTEXT_HELP | WS_VISIBLE

// Attributes
public:
	PROPSHEETHEADER m_psh;

	int GetPageCount() const;
	CPropertyPage* GetActivePage() const;
	int GetActiveIndex() const;
	CPropertyPage* GetPage(int nPage) const;
	int GetPageIndex(CPropertyPage* pPage);
	BOOL SetActivePage(int nPage);
	BOOL SetActivePage(CPropertyPage* pPage);
	void SetTitle(LPCTSTR lpszText, UINT nStyle = 0);
	CTabCtrl* GetTabControl() const;

	void SetWizardMode();
	void SetFinishText(LPCTSTR lpszText);
	void SetWizardButtons(DWORD dwFlags);

	void EnableStackedTabs(BOOL bStacked);

// Operations
public:
	virtual INT_PTR DoModal();
	void AddPage(CPropertyPage* pPage);
	void RemovePage(CPropertyPage* pPage);
	void RemovePage(int nPage);
	void EndDialog(int nEndID); // used to terminate a modal dialog
	void PressButton(int nButton);
	void MapDialogRect(LPRECT lpRect) const;

// Overridables (special message map entries)
	virtual BOOL OnInitDialog();

// Implementation
public:
	virtual ~CPropertySheet();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	void CommonConstruct(CWnd* pParentWnd, UINT iSelectPage);
	void CommonConstruct(CWnd* pParentWnd, UINT iSelectPage,
		HBITMAP hbmWatermark, HPALETTE hpalWatermark, HBITMAP hbmHeader);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual void BuildPropPageArray();
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual BOOL ContinueModal();
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo);
	BOOL IsWizard() const;
	BOOL IsModeless() const;

protected:
	CPtrArray m_pages;      // array of CPropertyPage pointers
	CString m_strCaption;   // caption of the pseudo-dialog
	CWnd* m_pParentWnd;     // parent window of property sheet
	BOOL m_bStacked;        // EnableStackedTabs sets this
	BOOL m_bModeless;       // TRUE when Create called instead of DoModal

	// Generated message map functions
	//{{AFX_MSG(CPropertySheet)
	afx_msg BOOL OnNcCreate(LPCREATESTRUCT);
	afx_msg LRESULT HandleInitDialog(WPARAM, LPARAM);
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg LRESULT OnCommandHelp(WPARAM, LPARAM);
	afx_msg void OnClose();
	afx_msg void OnSysCommand(UINT nID, LPARAM);
	afx_msg LRESULT OnSetDefID(WPARAM, LPARAM);
	afx_msg LRESULT OnKickIdle(WPARAM, LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	friend class CPropertyPage;
};

#define CPropertySheetEx CPropertySheet

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXDLGS_INLINE AFX_INLINE
#include <afxdlgs.inl>
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXDLGS_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxdllx.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// AFXDLLX.H: Extra header for building an MFC Extension DLL
//
// This file is really a source file that you should include in the
// main source file of your DLL.  It must only be included once, and
// not multiple times (you will get linker errors if it is included
// multiple times).  If you do not use _AFXEXT, it is not required
// but you may want the feature it provides.
//
// Previous versions of 32-bit MFC did not require this file.  This version
// requires this file to support dynamic loading of extension DLLs.  In
// other words, if your application does LoadLibrary on any extension
// DLL (instead of binding to the DLL at link time), this file is
// required.

#pragma once

// Startup code must be unmanaged to avoid loader lock issues.
#pragma managed(push, off)

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 

// The following symbol used to force inclusion of this module for _AFXEXT
#if defined(_X86_)
extern "C" { int _afxForceEXTDLL; }
#else
extern "C" { int __afxForceEXTDLL; }
#endif

/////////////////////////////////////////////////////////////////////////////
// RawDllMain that saves current app class list and factory list

extern "C" BOOL WINAPI ExtRawDllMain(HINSTANCE, DWORD dwReason, LPVOID);
extern "C" BOOL (WINAPI* const _pRawDllMain)(HINSTANCE, DWORD, LPVOID) = &ExtRawDllMain;

extern "C"
BOOL WINAPI ExtRawDllMain(HINSTANCE, DWORD dwReason, LPVOID)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		// save critical data pointers before running the constructors
		AFX_MODULE_STATE* pModuleState = AfxGetModuleState();
		pModuleState->m_pClassInit = pModuleState->m_classList;
		pModuleState->m_pFactoryInit = pModuleState->m_factoryList;
		pModuleState->m_classList.m_pHead = NULL;
		pModuleState->m_factoryList.m_pHead = NULL;
	}
	return TRUE;    // ok
}

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

/////////////////////////////////////////////////////////////////////////////

#pragma managed(pop)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxdisp.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXDISP_H__
#define __AFXDISP_H__

#ifdef _AFX_NO_OLE_SUPPORT
	#error OLE classes not supported in this library variant.
#endif

#pragma once

#ifndef __AFXWIN_H__
	#include <afxwin.h>
#endif

// include necessary OLE headers
#ifndef _OBJBASE_H_
	#include <objbase.h>
#endif
#ifndef _OLEAUTO_H_
	#include <oleauto.h>
#endif
#ifndef _OLECTL_H_
	#include <olectl.h>
#endif
#ifndef __ocidl_h__
	#include <ocidl.h>
#endif
 
// Shell interface support
#ifndef _SHLOBJ_H_
	#include <shlobj.h>
#endif

// Include ATL COM headers
#include <atlcomcli.h>
#include <atlcomtime.h>
#include <atlcommem.h>
#include <cstringt.inl>

using ATL::CComBSTR;
using ATL::COleDateTime;
using ATL::COleDateTimeSpan;

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 

#ifndef _AFX_NOFORCE_LIBS

/////////////////////////////////////////////////////////////////////////////
// Win32 libraries

#pragma comment(lib, "oledlg.lib")
#pragma comment(lib, "ole32.lib")
#pragma comment(lib, "oleaut32.lib")
#pragma comment(lib, "uuid.lib")
#pragma comment(lib, "urlmon.lib")

#endif //!_AFX_NOFORCE_LIBS

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// AFXDISP - MFC IDispatch & ClassFactory support

// Classes declared in this file

//CException
	class COleException;            // caught by client or server
	class COleDispatchException;    // special exception for IDispatch calls

//CCmdTarget
	class COleObjectFactory;        // glue for IClassFactory -> runtime class
		class COleTemplateServer;   // server documents using CDocTemplate

class COleDispatchDriver;           // helper class to call IDispatch

class COleVariant;          // OLE VARIANT wrapper
class COleCurrency;         // Based on OLE CY
class COleSafeArray;        // Based on OLE VARIANT
/////////////////////////////////////////////////////////////////////////////

// AFXDLL support
#undef AFX_DATA
#define AFX_DATA AFX_OLE_DATA

/////////////////////////////////////////////////////////////////////////////
// COleException - unexpected or rare OLE error returned

class COleException : public CException
{
	DECLARE_DYNAMIC(COleException)

public:
	SCODE m_sc;
	static SCODE PASCAL Process(const CException* pAnyException);

// Implementation (use AfxThrowOleException to create)
public:
	COleException();
	virtual ~COleException();

	virtual BOOL GetErrorMessage(_Out_z_cap_(nMaxError) LPTSTR lpszError, _In_ UINT nMaxError,
		_Out_opt_ PUINT pnHelpContext = NULL) const;
};

void AFXAPI AfxThrowOleException(SCODE sc);
void AFXAPI AfxCheckError(SCODE sc);

/////////////////////////////////////////////////////////////////////////////
// IDispatch specific exception

class COleDispatchException : public CException
{
	DECLARE_DYNAMIC(COleDispatchException)

public:
// Attributes
	WORD m_wCode;   // error code (specific to IDispatch implementation)
	CString m_strDescription;   // human readable description of the error
	DWORD m_dwHelpContext;      // help context for error

	// usually empty in application which creates it (eg. servers)
	CString m_strHelpFile;      // help file to use with m_dwHelpContext
	CString m_strSource;        // source of the error (name of server)

// Implementation
public:
	COleDispatchException(LPCTSTR lpszDescription, UINT nHelpID, WORD wCode);
	virtual ~COleDispatchException();
	static void PASCAL Process(
		EXCEPINFO* pInfo, const CException* pAnyException);

	virtual BOOL GetErrorMessage(_Out_z_cap_(nMaxError) LPTSTR lpszError, _In_ UINT nMaxError,
		_Out_opt_ PUINT pnHelpContext = NULL) const;

	SCODE m_scError;            // SCODE describing the error
};

void AFXAPI AfxThrowOleDispatchException(WORD wCode, LPCTSTR lpszDescription,
	UINT nHelpID = 0);
void AFXAPI AfxThrowOleDispatchException(WORD wCode, UINT nDescriptionID,
	UINT nHelpID = (UINT)-1);

/////////////////////////////////////////////////////////////////////////////
// Macros for CCmdTarget IDispatchable classes

#ifdef _AFXDLL
#define BEGIN_DISPATCH_MAP(theClass, baseClass) \
	const AFX_DISPMAP* PASCAL theClass::GetThisDispatchMap() \
		{ return &theClass::dispatchMap; } \
	const AFX_DISPMAP* theClass::GetDispatchMap() const \
		{ return &theClass::dispatchMap; } \
	AFX_COMDAT const AFX_DISPMAP theClass::dispatchMap = \
		{ &baseClass::GetThisDispatchMap, &theClass::_dispatchEntries[0], \
			&theClass::_dispatchEntryCount, &theClass::_dwStockPropMask }; \
	AFX_COMDAT UINT theClass::_dispatchEntryCount = (UINT)-1; \
	AFX_COMDAT DWORD theClass::_dwStockPropMask = (DWORD)-1; \
	AFX_COMDAT const AFX_DISPMAP_ENTRY theClass::_dispatchEntries[] = \
	{ \

#else
#define BEGIN_DISPATCH_MAP(theClass, baseClass) \
	const AFX_DISPMAP* theClass::GetDispatchMap() const \
		{ return &theClass::dispatchMap; } \
	AFX_COMDAT const AFX_DISPMAP theClass::dispatchMap = \
		{ &baseClass::dispatchMap, &theClass::_dispatchEntries[0], \
			&theClass::_dispatchEntryCount, &theClass::_dwStockPropMask }; \
	AFX_COMDAT UINT theClass::_dispatchEntryCount = (UINT)-1; \
	AFX_COMDAT DWORD theClass::_dwStockPropMask = (DWORD)-1; \
	AFX_COMDAT const AFX_DISPMAP_ENTRY theClass::_dispatchEntries[] = \
	{ \

#endif

#define END_DISPATCH_MAP() \
	{ VTS_NONE, DISPID_UNKNOWN, VTS_NONE, VT_VOID, \
		(AFX_PMSG)NULL, (AFX_PMSG)NULL, (size_t)-1, afxDispCustom } }; \

// parameter types: by value VTs
#define VTS_I2              "\x02"      // a 'short'
#define VTS_I4              "\x03"      // a 'long'
#define VTS_R4              "\x04"      // a 'float'
#define VTS_R8              "\x05"      // a 'double'
#define VTS_CY              "\x06"      // a 'CY' or 'CY*'
#define VTS_DATE            "\x07"      // a 'DATE'
#define VTS_WBSTR           "\x08"      // an 'LPCOLESTR'
#define VTS_DISPATCH        "\x09"      // an 'IDispatch*'
#define VTS_SCODE           "\x0A"      // an 'SCODE'
#define VTS_BOOL            "\x0B"      // a 'VARIANT_BOOL'
#define VTS_VARIANT         "\x0C"      // a 'const VARIANT&' or 'VARIANT*'
#define VTS_UNKNOWN         "\x0D"      // an 'IUnknown*'
#if defined(_UNICODE)
	#define VTS_BSTR            VTS_WBSTR// an 'LPCOLESTR'
	#define VT_BSTRT            VT_BSTR
#else
	#define VTS_BSTR            "\x0E"  // an 'LPCSTR'
	#define VT_BSTRA            14
	#define VT_BSTRT            VT_BSTRA
#endif
#define VTS_I1              "\x10"      // a 'signed char'
#define VTS_UI1             "\x11"      // a 'BYTE'
#define VTS_UI2             "\x12"      // a 'WORD'
#define VTS_UI4             "\x13"      // a 'DWORD'
#define VTS_I8              "\x14"      // a 'LONGLONG'
#define VTS_UI8             "\x15"      // a 'ULONGLONG'

// parameter types: by reference VTs
#define VTS_PI2             "\x42"      // a 'short*'
#define VTS_PI4             "\x43"      // a 'long*'
#define VTS_PR4             "\x44"      // a 'float*'
#define VTS_PR8             "\x45"      // a 'double*'
#define VTS_PCY             "\x46"      // a 'CY*'
#define VTS_PDATE           "\x47"      // a 'DATE*'
#define VTS_PBSTR           "\x48"      // a 'BSTR*'
#define VTS_PDISPATCH       "\x49"      // an 'IDispatch**'
#define VTS_PSCODE          "\x4A"      // an 'SCODE*'
#define VTS_PBOOL           "\x4B"      // a 'VARIANT_BOOL*'
#define VTS_PVARIANT        "\x4C"      // a 'VARIANT*'
#define VTS_PUNKNOWN        "\x4D"      // an 'IUnknown**'
#define VTS_PI1             "\x50"      // a 'signed char*'
#define VTS_PUI1            "\x51"      // a 'BYTE*'
#define VTS_PUI2            "\x52"      // a 'WORD*'
#define VTS_PUI4            "\x53"      // a 'DWORD*'
#define VTS_PI8             "\x54"      // a 'LONGLONG*'
#define VTS_PUI8            "\x55"      // a 'ULONGLONG*'

// special VT_ and VTS_ values
#define VTS_NONE            NULL        // used for members with 0 params
#define VT_MFCVALUE         0xFFF       // special value for DISPID_VALUE
#define VT_MFCBYREF         0x40        // indicates VT_BYREF type
#define VT_MFCMARKER        0xFF        // delimits named parameters (INTERNAL USE)

// variant handling (use V_BSTRT when you have ANSI BSTRs, as in DAO)
#ifndef _UNICODE
	#define V_BSTRT(b)  (LPSTR)V_BSTR(b)
#else
	#define V_BSTRT(b)  V_BSTR(b)
#endif

/////////////////////////////////////////////////////////////////////////////
// OLE control parameter types

#define VTS_COLOR           VTS_I4      // OLE_COLOR
#define VTS_XPOS_PIXELS     VTS_I4      // OLE_XPOS_PIXELS
#define VTS_YPOS_PIXELS     VTS_I4      // OLE_YPOS_PIXELS
#define VTS_XSIZE_PIXELS    VTS_I4      // OLE_XSIZE_PIXELS
#define VTS_YSIZE_PIXELS    VTS_I4      // OLE_YSIZE_PIXELS
#define VTS_XPOS_HIMETRIC   VTS_I4      // OLE_XPOS_HIMETRIC
#define VTS_YPOS_HIMETRIC   VTS_I4      // OLE_YPOS_HIMETRIC
#define VTS_XSIZE_HIMETRIC  VTS_I4      // OLE_XSIZE_HIMETRIC
#define VTS_YSIZE_HIMETRIC  VTS_I4      // OLE_YSIZE_HIMETRIC
#define VTS_TRISTATE        VTS_I2      // OLE_TRISTATE
#define VTS_OPTEXCLUSIVE    VTS_BOOL    // OLE_OPTEXCLUSIVE

#define VTS_PCOLOR          VTS_PI4     // OLE_COLOR*
#define VTS_PXPOS_PIXELS    VTS_PI4     // OLE_XPOS_PIXELS*
#define VTS_PYPOS_PIXELS    VTS_PI4     // OLE_YPOS_PIXELS*
#define VTS_PXSIZE_PIXELS   VTS_PI4     // OLE_XSIZE_PIXELS*
#define VTS_PYSIZE_PIXELS   VTS_PI4     // OLE_YSIZE_PIXELS*
#define VTS_PXPOS_HIMETRIC  VTS_PI4     // OLE_XPOS_HIMETRIC*
#define VTS_PYPOS_HIMETRIC  VTS_PI4     // OLE_YPOS_HIMETRIC*
#define VTS_PXSIZE_HIMETRIC VTS_PI4     // OLE_XSIZE_HIMETRIC*
#define VTS_PYSIZE_HIMETRIC VTS_PI4     // OLE_YSIZE_HIMETRIC*
#define VTS_PTRISTATE       VTS_PI2     // OLE_TRISTATE*
#define VTS_POPTEXCLUSIVE   VTS_PBOOL   // OLE_OPTEXCLUSIVE*

#define VTS_FONT            VTS_DISPATCH    // IFontDispatch*
#define VTS_PICTURE         VTS_DISPATCH    // IPictureDispatch*

#define VTS_HANDLE          VTS_I4      // OLE_HANDLE
#define VTS_PHANDLE         VTS_PI4     // OLE_HANDLE*

// these DISP_ macros cause the framework to generate the DISPID
#define DISP_FUNCTION(theClass, szExternalName, pfnMember, vtRetVal, vtsParams) \
	{ _T(szExternalName), DISPID_UNKNOWN, vtsParams, vtRetVal, \
		(AFX_PMSG)(void (theClass::*)(void))&pfnMember, (AFX_PMSG)0, 0, \
		afxDispCustom }, \

#define DISP_PROPERTY(theClass, szExternalName, memberName, vtPropType) \
	{ _T(szExternalName), DISPID_UNKNOWN, NULL, vtPropType, (AFX_PMSG)0, (AFX_PMSG)0, \
		offsetof(theClass, memberName), afxDispCustom }, \

#define DISP_PROPERTY_NOTIFY(theClass, szExternalName, memberName, pfnAfterSet, vtPropType) \
	{ _T(szExternalName), DISPID_UNKNOWN, NULL, vtPropType, (AFX_PMSG)0, \
		(AFX_PMSG)(void (theClass::*)(void))&pfnAfterSet, \
		offsetof(theClass, memberName), afxDispCustom }, \

#define DISP_PROPERTY_EX(theClass, szExternalName, pfnGet, pfnSet, vtPropType) \
	{ _T(szExternalName), DISPID_UNKNOWN, NULL, vtPropType, \
		(AFX_PMSG)(void (theClass::*)(void))&pfnGet, \
		(AFX_PMSG)(void (theClass::*)(void))&pfnSet, 0, afxDispCustom }, \

#define DISP_PROPERTY_PARAM(theClass, szExternalName, pfnGet, pfnSet, vtPropType, vtsParams) \
	{ _T(szExternalName), DISPID_UNKNOWN, vtsParams, vtPropType, \
		(AFX_PMSG)(void (theClass::*)(void))&pfnGet, \
		(AFX_PMSG)(void (theClass::*)(void))&pfnSet, 0, afxDispCustom }, \

// these DISP_ macros allow the app to determine the DISPID
#define DISP_FUNCTION_ID(theClass, szExternalName, dispid, pfnMember, vtRetVal, vtsParams) \
	{ _T(szExternalName), dispid, vtsParams, vtRetVal, \
		(AFX_PMSG)(void (theClass::*)(void))&pfnMember, (AFX_PMSG)0, 0, \
		afxDispCustom }, \

#define DISP_PROPERTY_ID(theClass, szExternalName, dispid, memberName, vtPropType) \
	{ _T(szExternalName), dispid, NULL, vtPropType, (AFX_PMSG)0, (AFX_PMSG)0, \
		offsetof(theClass, memberName), afxDispCustom }, \

#define DISP_PROPERTY_NOTIFY_ID(theClass, szExternalName, dispid, memberName, pfnAfterSet, vtPropType) \
	{ _T(szExternalName), dispid, NULL, vtPropType, (AFX_PMSG)0, \
		(AFX_PMSG)(void (theClass::*)(void))&pfnAfterSet, \
		offsetof(theClass, memberName), afxDispCustom }, \

#define DISP_PROPERTY_EX_ID(theClass, szExternalName, dispid, pfnGet, pfnSet, vtPropType) \
	{ _T(szExternalName), dispid, NULL, vtPropType, \
		(AFX_PMSG)(void (theClass::*)(void))&pfnGet, \
		(AFX_PMSG)(void (theClass::*)(void))&pfnSet, 0, afxDispCustom }, \

#define DISP_PROPERTY_PARAM_ID(theClass, szExternalName, dispid, pfnGet, pfnSet, vtPropType, vtsParams) \
	{ _T(szExternalName), dispid, vtsParams, vtPropType, \
		(AFX_PMSG)(void (theClass::*)(void))&pfnGet, \
		(AFX_PMSG)(void (theClass::*)(void))&pfnSet, 0, afxDispCustom }, \

// the DISP_DEFVALUE is a special case macro that creates an alias for DISPID_VALUE
#define DISP_DEFVALUE(theClass, szExternalName) \
	{ _T(szExternalName), DISPID_UNKNOWN, NULL, VT_MFCVALUE, \
		(AFX_PMSG)0, (AFX_PMSG)0, 0, afxDispCustom }, \

#define DISP_DEFVALUE_ID(theClass, dispid) \
	{ NULL, dispid, NULL, VT_MFCVALUE, (AFX_PMSG)0, (AFX_PMSG)0, 0, \
		afxDispCustom }, \

/////////////////////////////////////////////////////////////////////////////
// Macros for creating "creatable" automation classes.

enum AFX_REG_FLAGS
{
	afxRegDefault               = 0x0000,
	afxRegInsertable            = 0x0001,
	afxRegApartmentThreading    = 0x0002,
	afxRegFreeThreading			 = 0x0004,
};

#define DECLARE_OLECREATE(class_name) \
public: \
	static COleObjectFactory factory; \
	static const GUID guid; \

#define IMPLEMENT_OLECREATE(class_name, external_name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
	COleObjectFactory class_name::factory(class_name::guid, \
		RUNTIME_CLASS(class_name), FALSE, _T(external_name)); \
	AFX_COMDAT const GUID class_name::guid = \
		{ l, w1, w2, { b1, b2, b3, b4, b5, b6, b7, b8 } }; \

#define IMPLEMENT_OLECREATE_FLAGS(class_name, external_name, nFlags, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
	COleObjectFactory class_name::factory(class_name::guid, \
		RUNTIME_CLASS(class_name), FALSE, nFlags, _T(external_name)); \
	AFX_COMDAT const GUID class_name::guid = \
		{ l, w1, w2, { b1, b2, b3, b4, b5, b6, b7, b8 } }; \

/////////////////////////////////////////////////////////////////////////////
// Helper class for driving IDispatch

class COleDispatchDriver
{
// Constructors
public:
	COleDispatchDriver();
	COleDispatchDriver(LPDISPATCH lpDispatch, BOOL bAutoRelease = TRUE);
	COleDispatchDriver(const COleDispatchDriver& dispatchSrc);

// Attributes
	LPDISPATCH m_lpDispatch;
	BOOL m_bAutoRelease;

// Operations
	BOOL CreateDispatch(REFCLSID clsid, COleException* pError = NULL);
	BOOL CreateDispatch(LPCTSTR lpszProgID, COleException* pError = NULL);

	void AttachDispatch(LPDISPATCH lpDispatch, BOOL bAutoRelease = TRUE);
	LPDISPATCH DetachDispatch();
		// detach and get ownership of m_lpDispatch
	void ReleaseDispatch();

	// helpers for IDispatch::Invoke
	void AFX_CDECL InvokeHelper(DISPID dwDispID, WORD wFlags,
		VARTYPE vtRet, void* pvRet, const BYTE* pbParamInfo, ...);
	void AFX_CDECL SetProperty(DISPID dwDispID, VARTYPE vtProp, ...);
	void GetProperty(DISPID dwDispID, VARTYPE vtProp, void* pvProp) const;

	// special operators
	operator LPDISPATCH();
	const COleDispatchDriver& operator=(const COleDispatchDriver& dispatchSrc);

// Implementation
public:
	~COleDispatchDriver();
	void InvokeHelperV(DISPID dwDispID, WORD wFlags, VARTYPE vtRet,
		void* pvRet, const BYTE* pbParamInfo, va_list argList);
};

/////////////////////////////////////////////////////////////////////////////
// Class Factory implementation (binds OLE class factory -> runtime class)
//  (all specific class factories derive from this class factory)

class COleObjectFactory : public CCmdTarget
{
	DECLARE_DYNAMIC(COleObjectFactory)

// Construction
public:
	COleObjectFactory(REFCLSID clsid, CRuntimeClass* pRuntimeClass,
		BOOL bMultiInstance, LPCTSTR lpszProgID);
	COleObjectFactory(REFCLSID clsid, CRuntimeClass* pRuntimeClass,
		BOOL bMultiInstance, int nFlags, LPCTSTR lpszProgID);

// Attributes
	virtual BOOL IsRegistered() const;
	REFCLSID GetClassID() const;

// Operations
	virtual BOOL Register();
	BOOL Unregister();
	void Revoke();
	void UpdateRegistry(LPCTSTR lpszProgID = NULL);
		// default uses m_lpszProgID if not NULL
	BOOL IsLicenseValid();

	static BOOL PASCAL UnregisterAll();
	static BOOL PASCAL RegisterAll();
	static void PASCAL RevokeAll();
	static BOOL PASCAL UpdateRegistryAll(BOOL bRegister = TRUE);

// Overridables
protected:
	virtual CCmdTarget* OnCreateObject();
	virtual BOOL UpdateRegistry(BOOL bRegister);
	virtual BOOL VerifyUserLicense();
	virtual BOOL GetLicenseKey(DWORD dwReserved, BSTR* pbstrKey);
	virtual BOOL VerifyLicenseKey(BSTR bstrKey);

// Implementation
public:
	virtual ~COleObjectFactory();
#ifdef _DEBUG
	void AssertValid() const;
	void Dump(CDumpContext& dc) const;
#endif

public:
	COleObjectFactory* m_pNextFactory;  // list of factories maintained

protected:
	void CommonConstruct(REFCLSID clsid, CRuntimeClass* pRuntimeClass,
		BOOL bMultiInstance, int nFlags, LPCTSTR lpszProgID);

	DWORD m_dwRegister;             // registry identifier
	CLSID m_clsid;                  // registered class ID
	CRuntimeClass* m_pRuntimeClass; // runtime class of CCmdTarget derivative
	BOOL m_bMultiInstance;          // multiple instance?
	int m_nFlags;						  // threading flags
	LPCTSTR m_lpszProgID;           // human readable class ID
	BYTE m_bLicenseChecked;
	BYTE m_bLicenseValid;
	BYTE m_bRegistered;             // is currently registered w/ system
	BYTE m_bOAT;                    // used by COleTemplateServer to
											  // remember application type for unregistry

// Interface Maps
public:
	BEGIN_INTERFACE_PART(ClassFactory, IClassFactory2)
		INIT_INTERFACE_PART(COleObjectFactory, ClassFactory)
		STDMETHOD(CreateInstance)(LPUNKNOWN, REFIID, LPVOID*);
		STDMETHOD(LockServer)(BOOL);
		STDMETHOD(GetLicInfo)(LPLICINFO);
		STDMETHOD(RequestLicKey)(DWORD, BSTR*);
		STDMETHOD(CreateInstanceLic)(LPUNKNOWN, LPUNKNOWN, REFIID, BSTR,
			LPVOID*);
	END_INTERFACE_PART(ClassFactory)

	DECLARE_INTERFACE_MAP()

	friend SCODE AFXAPI AfxDllGetClassObject(REFCLSID, REFIID, LPVOID*);
	friend SCODE STDAPICALLTYPE DllGetClassObject(REFCLSID, REFIID, LPVOID*);
};

// Define COleObjectFactoryEx for compatibility with old CDK
#define COleObjectFactoryEx COleObjectFactory

extern int __mixedModuleStartup;

#ifdef _USRDLL
#ifdef _M_CEE
__declspec(selectany) int __mixedModuleStartup = 1;
#endif // _M_CEE
#endif // _USRDLL

//////////////////////////////////////////////////////////////////////////////
// COleTemplateServer - COleObjectFactory using CDocTemplates

// This enumeration is used in AfxOleRegisterServerClass to pick the
//  correct registration entries given the application type.
enum OLE_APPTYPE
{
	OAT_UNKNOWN = -1,                // no type decided yet
	OAT_INPLACE_SERVER = 0,     // server has full server user-interface
	OAT_SERVER = 1,             // server supports only embedding
	OAT_CONTAINER = 2,          // container supports links to embeddings
	OAT_DISPATCH_OBJECT = 3,    // IDispatch capable object
	OAT_DOC_OBJECT_SERVER = 4,  // sever supports DocObject embedding
	OAT_DOC_OBJECT_CONTAINER =5,// container supports DocObject clients
};

class COleTemplateServer : public COleObjectFactory
{
// Constructors
public:
	COleTemplateServer();

// Operations
	// set doc template after creating it in InitInstance
	void ConnectTemplate(REFCLSID clsid, CDocTemplate* pDocTemplate, BOOL bMultiInstance, BOOL bRegisterRichPreviewHandler = FALSE);

	// may want to UpdateRegistry if not run with /Embedded
	void UpdateRegistry(OLE_APPTYPE nAppType = OAT_INPLACE_SERVER, LPCTSTR* rglpszRegister = NULL, LPCTSTR* rglpszOverwrite = NULL, BOOL bRegister = TRUE);

	BOOL Register();
	BOOL Unregister();

// Implementation
protected:
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	virtual CCmdTarget* OnCreateObject();
	CDocTemplate* m_pDocTemplate;

private:
	using COleObjectFactory::UpdateRegistry;

	// hide base class version of UpdateRegistry
	void UpdateRegistry(LPCTSTR lpszProgID);
};

/////////////////////////////////////////////////////////////////////////////
// System registry helpers

// Helper to register server in case of no .REG file loaded
BOOL AFXAPI AfxOleRegisterServerClass(
	REFCLSID clsid, LPCTSTR lpszClassName,
	LPCTSTR lpszShortTypeName, LPCTSTR lpszLongTypeName,
	OLE_APPTYPE nAppType = OAT_SERVER,
	LPCTSTR* rglpszRegister = NULL, LPCTSTR* rglpszOverwrite = NULL,
	int nIconIndex = 0, LPCTSTR lpszLocalFilterName = NULL);
BOOL AFXAPI AfxOleRegisterServerClass(
	REFCLSID clsid, LPCTSTR lpszClassName,
	LPCTSTR lpszShortTypeName, LPCTSTR lpszLongTypeName,
	OLE_APPTYPE nAppType,
	LPCTSTR* rglpszRegister, LPCTSTR* rglpszOverwrite,
	int nIconIndex, LPCTSTR lpszLocalFilterName, LPCTSTR lpszLocalFilterExt);

BOOL AFXAPI AfxOleUnregisterServerClass(
	REFCLSID clsid, LPCTSTR lpszClassName, LPCTSTR lpszShortTypeName,
	LPCTSTR lpszLongTypeName, OLE_APPTYPE nAppType = OAT_SERVER,
	LPCTSTR* rglpszRegister = NULL, LPCTSTR* rglpszOverwrite = NULL);

// Special helpers used for search/organize/preview/thumbnail handlers
/// <summary>
/// A helper to register a preview handler.</summary>
/// <param name="lpszCLSID">Specifies CLSID of handler.</param>
/// <param name="lpszShortTypeName">Specifies ProgID of handler.</param>
/// <param name="lpszFilterExt">Specifies file extension registered with this handler.</param>
/// <returns>Returns TRUE if this function succeeds, otherwise FALSE..</returns>
BOOL AFXAPI AfxRegisterPreviewHandler(LPCTSTR lpszCLSID, LPCTSTR lpszShortTypeName, LPCTSTR lpszFilterExt);

/// <summary>
/// A helper to unregister a preview handler.</summary>
/// <param name="lpszCLSID">Specifies CLSID of handler to be unregistered.</param>
/// <returns>Returns TRUE if this function succeeds; otherwise FALSE.</returns>
BOOL AFXAPI AfxUnRegisterPreviewHandler(LPCTSTR lpszCLSID);
BOOL AFXAPI AfxRegisterThumbnailHandler(LPCTSTR lpszCLSID, LPCTSTR lpszFilterExt, DWORD nTreatment = 1);

// AfxOleRegisterHelper is a worker function used by
//  AfxOleRegisterServerClass (available for advanced registry work)
BOOL AFXAPI AfxOleRegisterHelper(LPCTSTR const* rglpszRegister,
	LPCTSTR const* rglpszSymbols, int nSymbols, BOOL bReplace,
	HKEY hKeyRoot = HKEY_CLASSES_ROOT); // HKEY_CLASSES_ROOT

BOOL AFXAPI AfxOleUnregisterHelper(LPCTSTR const* rglpszRegister,
	LPCTSTR const* rglpszSymbols, int nSymbols,
	HKEY hKeyRoot = HKEY_CLASSES_ROOT); // HKEY_CLASSES_ROOT

BOOL AFXAPI AfxOleInprocRegisterHelper(HKEY hkeyProgID,
	HKEY hkeyClassID, int nRegFlags);

BOOL AFXAPI AfxOleRegisterTypeLib(HINSTANCE hInstance, REFGUID tlid,
	LPCTSTR pszFileName = NULL, LPCTSTR pszHelpDir = NULL);

BOOL AFXAPI AfxOleUnregisterTypeLib(REFGUID tlid, WORD wVerMajor = 0,
	WORD wVerMinor = 0, LCID lcid = 0);

/////////////////////////////////////////////////////////////////////////////
// Connection maps

#define BEGIN_CONNECTION_PART(theClass, localClass) \
	class X##localClass : public CConnectionPoint \
	{ \
	public: \
		X##localClass() \
			{ m_nOffset = offsetof(theClass, m_x##localClass); }

#define CONNECTION_IID(iid) \
		REFIID GetIID() { return iid; }

#define END_CONNECTION_PART(localClass) \
	} m_x##localClass; \
	friend class X##localClass;

#ifdef _AFXDLL
#define BEGIN_CONNECTION_MAP(theClass, theBase) \
	const AFX_CONNECTIONMAP* PASCAL theClass::GetThisConnectionMap() \
		{ return &theClass::connectionMap; } \
	const AFX_CONNECTIONMAP* theClass::GetConnectionMap() const \
		{ return &theClass::connectionMap; } \
	AFX_COMDAT const AFX_CONNECTIONMAP theClass::connectionMap = \
		{ &theBase::GetThisConnectionMap, &theClass::_connectionEntries[0], }; \
	AFX_COMDAT const AFX_CONNECTIONMAP_ENTRY theClass::_connectionEntries[] = \
	{ \

#else
#define BEGIN_CONNECTION_MAP(theClass, theBase) \
	const AFX_CONNECTIONMAP* theClass::GetConnectionMap() const \
		{ return &theClass::connectionMap; } \
	AFX_COMDAT const AFX_CONNECTIONMAP theClass::connectionMap = \
		{ &(theBase::connectionMap), &theClass::_connectionEntries[0], }; \
	AFX_COMDAT const AFX_CONNECTIONMAP_ENTRY theClass::_connectionEntries[] = \
	{ \

#endif

#define CONNECTION_PART(theClass, iid, localClass) \
		{ &iid, offsetof(theClass, m_x##localClass) }, \

#define END_CONNECTION_MAP() \
		{ NULL, (size_t)-1 } \
	}; \

/////////////////////////////////////////////////////////////////////////////
// CConnectionPoint

class AFX_NOVTABLE CConnectionPoint : public CCmdTarget
{
// Constructors
public:
	CConnectionPoint();

// Operations
	POSITION GetStartPosition() const;
	LPUNKNOWN GetNextConnection(POSITION& pos) const;
	const CPtrArray* GetConnections();  // obsolete

// Overridables
	virtual LPCONNECTIONPOINTCONTAINER GetContainer();
	virtual REFIID GetIID() = 0;
	virtual void OnAdvise(BOOL bAdvise);
	virtual int GetMaxConnections();
	virtual HRESULT QuerySinkInterface(LPUNKNOWN pUnkSink, 
		void** ppInterface);

// Implementation
	virtual ~CConnectionPoint() = 0;
	void CreateConnectionArray();
	int GetConnectionCount();

protected:
	size_t m_nOffset;
	LPUNKNOWN m_pUnkFirstConnection;
	CPtrArray* m_pConnections;

// Interface Maps
public:
	BEGIN_INTERFACE_PART(ConnPt, IConnectionPoint)
		INIT_INTERFACE_PART(CConnectionPoint, ConnPt)
		STDMETHOD(GetConnectionInterface)(IID* pIID);
		STDMETHOD(GetConnectionPointContainer)(
			IConnectionPointContainer** ppCPC);
		STDMETHOD(Advise)(LPUNKNOWN pUnkSink, DWORD* pdwCookie);
		STDMETHOD(Unadvise)(DWORD dwCookie);
		STDMETHOD(EnumConnections)(LPENUMCONNECTIONS* ppEnum);
	END_INTERFACE_PART(ConnPt)
};

/////////////////////////////////////////////////////////////////////////////
// EventSink Maps

#ifndef _AFX_NO_OCC_SUPPORT

#ifdef _AFXDLL
#define BEGIN_EVENTSINK_MAP(theClass, baseClass) \
	PTM_WARNING_DISABLE \
	const AFX_EVENTSINKMAP* PASCAL theClass::GetThisEventSinkMap() \
		{ return &theClass::eventsinkMap; } \
	const AFX_EVENTSINKMAP* theClass::GetEventSinkMap() const \
		{ return &theClass::eventsinkMap; } \
	AFX_COMDAT const AFX_EVENTSINKMAP theClass::eventsinkMap = \
		{ &baseClass::GetThisEventSinkMap, &theClass::_eventsinkEntries[0], \
			&theClass::_eventsinkEntryCount }; \
	AFX_COMDAT UINT theClass::_eventsinkEntryCount = (UINT)-1; \
	AFX_COMDAT const AFX_EVENTSINKMAP_ENTRY theClass::_eventsinkEntries[] = \
	{ \

#else
#define BEGIN_EVENTSINK_MAP(theClass, baseClass) \
	PTM_WARNING_DISABLE \
	const AFX_EVENTSINKMAP* theClass::GetEventSinkMap() const \
		{ return &theClass::eventsinkMap; } \
	AFX_COMDAT const AFX_EVENTSINKMAP theClass::eventsinkMap = \
		{ &baseClass::eventsinkMap, &theClass::_eventsinkEntries[0], \
			&theClass::_eventsinkEntryCount }; \
	AFX_COMDAT UINT theClass::_eventsinkEntryCount = (UINT)-1; \
	AFX_COMDAT const AFX_EVENTSINKMAP_ENTRY theClass::_eventsinkEntries[] = \
	{ \

#endif

#define END_EVENTSINK_MAP() \
	PTM_WARNING_RESTORE \
	{ VTS_NONE, DISPID_UNKNOWN, VTS_NONE, VT_VOID, \
		(AFX_PMSG)NULL, (AFX_PMSG)NULL, (size_t)-1, afxDispCustom, \
		(UINT)-1, 0 } }; \

#define ON_EVENT(theClass, id, dispid, pfnHandler, vtsParams) \
	{ _T(""), dispid, vtsParams, VT_BOOL, \
		(AFX_PMSG)(void (theClass::*)(void))&pfnHandler, (AFX_PMSG)0, 0, \
		afxDispCustom, id, (UINT)-1 }, \

#define ON_EVENT_RANGE(theClass, idFirst, idLast, dispid, pfnHandler, vtsParams) \
	{ _T(""), dispid, vtsParams, VT_BOOL, \
		(AFX_PMSG)(void (theClass::*)(void))&pfnHandler, (AFX_PMSG)0, 0, \
		afxDispCustom, idFirst, idLast }, \

#define ON_PROPNOTIFY(theClass, id, dispid, pfnRequest, pfnChanged) \
	{ _T(""), dispid, VTS_NONE, VT_VOID, \
		(AFX_PMSG)(BOOL (CCmdTarget::*)(BOOL*))&pfnRequest, \
		(AFX_PMSG)(BOOL (CCmdTarget::*)(void))&pfnChanged, \
		1, afxDispCustom, id, (UINT)-1 }, \

#define ON_PROPNOTIFY_RANGE(theClass, idFirst, idLast, dispid, pfnRequest, pfnChanged) \
	{ _T(""), dispid, VTS_NONE, VT_VOID, \
		(AFX_PMSG)(BOOL (CCmdTarget::*)(UINT, BOOL*))&pfnRequest, \
		(AFX_PMSG)(BOOL (CCmdTarget::*)(UINT))&pfnChanged, \
		1, afxDispCustom, idFirst, idLast }, \

#define ON_DSCNOTIFY(theClass, id, pfnNotify) \
	{ _T(""), DISPID_UNKNOWN, VTS_NONE, VT_VOID, \
		(AFX_PMSG)(BOOL (CCmdTarget::*)(DSCSTATE, DSCREASON, BOOL*))&pfnNotify, (AFX_PMSG)0, \
		1, afxDispCustom, id, (UINT)-1 }, \

#define ON_DSCNOTIFY_RANGE(theClass, idFirst, idLast, pfnNotify) \
	{ _T(""), DISPID_UNKNOWN, VTS_NONE, VT_VOID, \
		(AFX_PMSG)(BOOL (CCmdTarget::*)(UINT, DSCSTATE, DSCREASON, BOOL*))&pfnNotify, (AFX_PMSG)0, \
		1, afxDispCustom, idFirst, idLast }, \

#define ON_EVENT_REFLECT(theClass, dispid, pfnHandler, vtsParams) \
	{ _T(""), dispid, vtsParams, VT_BOOL, \
		(AFX_PMSG)(void (theClass::*)(void))&pfnHandler, (AFX_PMSG)0, 0, \
		afxDispCustom, (UINT)-1, (UINT)-1 }, \

#define ON_PROPNOTIFY_REFLECT(theClass, dispid, pfnRequest, pfnChanged) \
	{ _T(""), dispid, VTS_NONE, VT_VOID, \
		(AFX_PMSG)(BOOL (CCmdTarget::*)(BOOL*))&pfnRequest, \
		(AFX_PMSG)(BOOL (CCmdTarget::*)(void))&pfnChanged, \
		1, afxDispCustom, (UINT)-1, (UINT)-1 }, \


/////////////////////////////////////////////////////////////////////////////
// Inline variants of event sink macros
#ifdef _AFXDLL
#define BEGIN_EVENTSINK_MAP_INLINE(theClass, baseClass) \
	PTM_WARNING_DISABLE \
	__declspec(selectany) const AFX_EVENTSINKMAP theClass::eventsinkMap = \
		{ &baseClass::GetThisEventSinkMap, &theClass::_eventsinkEntries[0], \
			&theClass::_eventsinkEntryCount }; \
	__declspec(selectany) UINT theClass::_eventsinkEntryCount = (UINT)-1; \
	__declspec(selectany) const AFX_EVENTSINKMAP_ENTRY theClass::_eventsinkEntries[] = \
	{ \

#else
#define BEGIN_EVENTSINK_MAP_INLINE(theClass, baseClass) \
	PTM_WARNING_DISABLE \
	__declspec(selectany) const AFX_EVENTSINKMAP theClass::eventsinkMap = \
		{ &baseClass::eventsinkMap, &theClass::_eventsinkEntries[0], \
			&theClass::_eventsinkEntryCount }; \
	__declspec(selectany) UINT theClass::_eventsinkEntryCount = (UINT)-1; \
	__declspec(selectany) const AFX_EVENTSINKMAP_ENTRY theClass::_eventsinkEntries[] = \
	{ \

#endif

#endif // !_AFX_NO_OCC_SUPPORT

/////////////////////////////////////////////////////////////////////////////
// Macros for type library information

CTypeLibCache* AFXAPI AfxGetTypeLibCache(const GUID* pTypeLibID);

#define DECLARE_OLETYPELIB(class_name) \
	protected: \
		virtual UINT GetTypeInfoCount(); \
		virtual HRESULT GetTypeLib(LCID, LPTYPELIB*); \
		virtual CTypeLibCache* GetTypeLibCache(); \

#define IMPLEMENT_OLETYPELIB(class_name, tlid, wVerMajor, wVerMinor) \
	UINT class_name::GetTypeInfoCount() \
		{ return 1; } \
	HRESULT class_name::GetTypeLib(LCID lcid, LPTYPELIB* ppTypeLib) \
		{ return ::LoadRegTypeLib(tlid, wVerMajor, wVerMinor, lcid, ppTypeLib); } \
	CTypeLibCache* class_name::GetTypeLibCache() \
		{ AFX_MANAGE_STATE(m_pModuleState); return AfxGetTypeLibCache(&tlid); } \

/////////////////////////////////////////////////////////////////////////////
// Init & Term helpers

BOOL AFXAPI AfxOleInit();
void AFXAPI AfxOleTerm(BOOL bJustRevoke = FALSE);
void AFXAPI AfxOleTermOrFreeLib(BOOL bTerm = TRUE, BOOL bJustRevoke = FALSE);

/////////////////////////////////////////////////////////////////////////////
// Memory management helpers (for OLE task allocator memory)

#define AfxAllocTaskMem(nSize) CoTaskMemAlloc(nSize)
#define AfxFreeTaskMem(p) CoTaskMemFree(p)

LPWSTR AFXAPI AfxAllocTaskWideString(LPCWSTR lpszString);
LPWSTR AFXAPI AfxAllocTaskWideString(LPCSTR lpszString);
LPSTR AFXAPI AfxAllocTaskAnsiString(LPCWSTR lpszString);
LPSTR AFXAPI AfxAllocTaskAnsiString(LPCSTR lpszString);

#define AfxAllocTaskWideString AtlAllocTaskWideString
#define AfxAllocTaskAnsiString AtlAllocTaskAnsiString
#define AfxAllocTaskString AtlAllocTaskString
#define AfxAllocTaskOleString AtlAllocTaskOleString

HRESULT AFXAPI AfxGetClassIDFromString(LPCTSTR lpsz, LPCLSID lpClsID);

/////////////////////////////////////////////////////////////////////////////
// Special in-proc server APIs

SCODE AFXAPI AfxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
SCODE AFXAPI AfxDllCanUnloadNow(void);

/////////////////////////////////////////////////////////////////////////////
// COleVariant class helpers

#define AFX_OLE_TRUE (-1)
#define AFX_OLE_FALSE 0

class CLongBinary;  // forward reference (see afxdb_.h)

/////////////////////////////////////////////////////////////////////////////
// COleVariant class - wraps VARIANT types

typedef const VARIANT* LPCVARIANT;

class COleVariant : public tagVARIANT
{
// Constructors
public:
	COleVariant();

	COleVariant(const VARIANT& varSrc);
	COleVariant(LPCVARIANT pSrc);
	COleVariant(const COleVariant& varSrc);

	COleVariant(LPCTSTR lpszSrc);
	COleVariant(LPCTSTR lpszSrc, VARTYPE vtSrc); // used to set to ANSI string
	COleVariant(CString& strSrc);

	COleVariant(BYTE nSrc);
	COleVariant(short nSrc, VARTYPE vtSrc = VT_I2);
	COleVariant(long lSrc, VARTYPE vtSrc = VT_I4);
	COleVariant(const COleCurrency& curSrc);

#if (_WIN32_WINNT >= 0x0501) || defined(_ATL_SUPPORT_VT_I8)
	COleVariant(LONGLONG nSrc);
	COleVariant(ULONGLONG nSrc);
#endif

	COleVariant(float fltSrc);
	COleVariant(double dblSrc);
	COleVariant(const COleDateTime& timeSrc);

	COleVariant(const CByteArray& arrSrc);
	COleVariant(const CLongBinary& lbSrc);

	COleVariant(LPCITEMIDLIST pidl);

// Operations
public:
	void Clear();
	void ChangeType(VARTYPE vartype, LPVARIANT pSrc = NULL);
	void Attach(VARIANT& varSrc);
	VARIANT Detach();
   void GetByteArrayFromVariantArray(CByteArray& bytes);

	BOOL operator==(const VARIANT& varSrc) const;
	BOOL operator==(LPCVARIANT pSrc) const;

	const COleVariant& operator=(const VARIANT& varSrc);
	const COleVariant& operator=(LPCVARIANT pSrc);
	const COleVariant& operator=(const COleVariant& varSrc);

	const COleVariant& operator=(const LPCTSTR lpszSrc);
	const COleVariant& operator=(const CString& strSrc);

	const COleVariant& operator=(BYTE nSrc);
	const COleVariant& operator=(short nSrc);
	const COleVariant& operator=(long lSrc);
	const COleVariant& operator=(const COleCurrency& curSrc);

#if (_WIN32_WINNT >= 0x0501) || defined(_ATL_SUPPORT_VT_I8)
	const COleVariant& operator=(LONGLONG nSrc);
	const COleVariant& operator=(ULONGLONG nSrc);
#endif

	const COleVariant& operator=(float fltSrc);
	const COleVariant& operator=(double dblSrc);
	const COleVariant& operator=(const COleDateTime& dateSrc);

	const COleVariant& operator=(const CByteArray& arrSrc);
	const COleVariant& operator=(const CLongBinary& lbSrc);

	void SetString(LPCTSTR lpszSrc, VARTYPE vtSrc); // used to set ANSI string

	operator LPVARIANT();
	operator LPCVARIANT() const;

// Implementation
public:
	~COleVariant();
};

// COleVariant diagnostics and serialization
#ifdef _DEBUG
CDumpContext& AFXAPI operator<<(CDumpContext& dc, COleVariant varSrc);
#endif
CArchive& AFXAPI operator<<(CArchive& ar, COleVariant varSrc);
CArchive& AFXAPI operator>>(CArchive& ar, COleVariant& varSrc);

// CComBSTR serialization
CArchive& AFXAPI operator<<(CArchive& ar, CComBSTR string);
CArchive& AFXAPI operator>>(CArchive& ar, CComBSTR& string);

// Helper for initializing VARIANT structures
void AFXAPI AfxVariantInit(LPVARIANT pVar);

/////////////////////////////////////////////////////////////////////////////
// COleCurrency class

class COleCurrency
{
// Constructors
public:
	COleCurrency();

	COleCurrency(CURRENCY cySrc);
	COleCurrency(const COleCurrency& curSrc);
	COleCurrency(const VARIANT& varSrc);
	COleCurrency(long nUnits, long nFractionalUnits);

// Attributes
public:
	enum CurrencyStatus
	{
		valid = 0,
		invalid = 1,    // Invalid currency (overflow, div 0, etc.)
		null = 2,       // Literally has no value
	};

	CURRENCY m_cur;
	CurrencyStatus m_status;

	void SetStatus(CurrencyStatus status);
	CurrencyStatus GetStatus() const;

// Operations
public:
	const COleCurrency& operator=(CURRENCY cySrc);
	const COleCurrency& operator=(const COleCurrency& curSrc);
	const COleCurrency& operator=(const VARIANT& varSrc);

	BOOL operator==(const COleCurrency& cur) const;
	BOOL operator!=(const COleCurrency& cur) const;
	BOOL operator<(const COleCurrency& cur) const;
	BOOL operator>(const COleCurrency& cur) const;
	BOOL operator<=(const COleCurrency& cur) const;
	BOOL operator>=(const COleCurrency& cur) const;

	// Currency math
	COleCurrency operator+(const COleCurrency& cur) const;
	COleCurrency operator-(const COleCurrency& cur) const;
	const COleCurrency& operator+=(const COleCurrency& cur);
	const COleCurrency& operator-=(const COleCurrency& cur);
	COleCurrency operator-() const;

	COleCurrency operator*(long nOperand) const;
	COleCurrency operator/(long nOperand) const;
	const COleCurrency& operator*=(long nOperand);
	const COleCurrency& operator/=(long nOperand);

	operator CURRENCY() const;

	// Currency definition
	void SetCurrency(long nUnits, long nFractionalUnits);
	BOOL ParseCurrency(LPCTSTR lpszCurrency, DWORD dwFlags = 0,
		LCID = LANG_USER_DEFAULT);

	// formatting
	CString Format(DWORD dwFlags = 0, LCID lcid = LANG_USER_DEFAULT) const;
};

// COleCurrency diagnostics and serialization
#ifdef _DEBUG
CDumpContext& AFXAPI operator<<(CDumpContext& dc, COleCurrency curSrc);
#endif
CArchive& AFXAPI operator<<(CArchive& ar, COleCurrency curSrc);
CArchive& AFXAPI operator>>(CArchive& ar, COleCurrency& curSrc);

// COleDateTime diagnostics and serialization
#ifdef _DEBUG
CDumpContext& AFXAPI operator<<(CDumpContext& dc, COleDateTime dateSrc);
#endif
CArchive& AFXAPI operator<<(CArchive& ar, COleDateTime dateSrc);
CArchive& AFXAPI operator>>(CArchive& ar, COleDateTime& dateSrc);

// COleDateTimeSpan diagnostics and serialization
#ifdef _DEBUG
CDumpContext& AFXAPI operator<<(CDumpContext& dc,COleDateTimeSpan dateSpanSrc);
#endif
CArchive& AFXAPI operator<<(CArchive& ar, COleDateTimeSpan dateSpanSrc);
CArchive& AFXAPI operator>>(CArchive& ar, COleDateTimeSpan& dateSpanSrc);

/////////////////////////////////////////////////////////////////////////////
// Helper for initializing COleSafeArray
void AFXAPI AfxSafeArrayInit(COleSafeArray* psa);

/////////////////////////////////////////////////////////////////////////////
// CSafeArray class

typedef const SAFEARRAY* LPCSAFEARRAY;

class COleSafeArray : public tagVARIANT
{
//Constructors
public:
	COleSafeArray();
	COleSafeArray(const SAFEARRAY& saSrc, VARTYPE vtSrc);
	COleSafeArray(LPCSAFEARRAY pSrc, VARTYPE vtSrc);
	COleSafeArray(const COleSafeArray& saSrc);
	COleSafeArray(const VARIANT& varSrc);
	COleSafeArray(LPCVARIANT pSrc);
	COleSafeArray(const COleVariant& varSrc);

// Operations
public:
	void Clear();
	void Attach(VARIANT& varSrc);
	VARIANT Detach();

	COleSafeArray& operator=(const COleSafeArray& saSrc);
	COleSafeArray& operator=(const VARIANT& varSrc);
	COleSafeArray& operator=(LPCVARIANT pSrc);
	COleSafeArray& operator=(const COleVariant& varSrc);

	BOOL operator==(const SAFEARRAY& saSrc) const;
	BOOL operator==(LPCSAFEARRAY pSrc) const;
	BOOL operator==(const COleSafeArray& saSrc) const;
	BOOL operator==(const VARIANT& varSrc) const;
	BOOL operator==(LPCVARIANT pSrc) const;
	BOOL operator==(const COleVariant& varSrc) const;

	operator LPVARIANT();
	operator LPCVARIANT() const;

	// One dim array helpers
	void CreateOneDim(VARTYPE vtSrc, DWORD dwElements,
		const void* pvSrcData = NULL, long nLBound = 0);
	DWORD GetOneDimSize();
	void ResizeOneDim(DWORD dwElements);

	// Multi dim array helpers
	void Create(VARTYPE vtSrc, DWORD dwDims, DWORD* rgElements);

	// SafeArray wrapper classes
	void Create(VARTYPE vtSrc, DWORD dwDims, SAFEARRAYBOUND* rgsabounds);
	void AccessData(void** ppvData);
	void UnaccessData();
	void AllocData();
	void AllocDescriptor(DWORD dwDims);
	void Copy(LPSAFEARRAY* ppsa);
	void GetLBound(DWORD dwDim, long* pLBound);
	void GetUBound(DWORD dwDim, long* pUBound);
	void GetElement(long* rgIndices, void* pvData);
	void PtrOfIndex(long* rgIndices, void** ppvData);
	void PutElement(long* rgIndices, void* pvData);
	void Redim(SAFEARRAYBOUND* psaboundNew);
	void Lock();
	void Unlock();
	DWORD GetDim();
	DWORD GetElemSize();
	void Destroy();
	void DestroyData();
	void DestroyDescriptor();

   void GetByteArray(CByteArray& bytes);

// Implementation
public:
	~COleSafeArray();

	// Cache info to make element access (operator []) faster
	DWORD m_dwElementSize;
	DWORD m_dwDims;
};

// COleSafeArray diagnostics and serialization
#ifdef _DEBUG
CDumpContext& AFXAPI operator<<(CDumpContext& dc, COleSafeArray& saSrc);
#endif

/////////////////////////////////////////////////////////////////////////////
// DDX_ functions for OLE controls on dialogs

#ifndef _AFX_NO_OCC_SUPPORT

void AFXAPI DDX_OCText(CDataExchange* pDX, int nIDC, DISPID dispid,
	CString& value);
void AFXAPI DDX_OCTextRO(CDataExchange* pDX, int nIDC, DISPID dispid,
	CString& value);
void AFXAPI DDX_OCBool(CDataExchange* pDX, int nIDC, DISPID dispid,
	BOOL& value);
void AFXAPI DDX_OCBoolRO(CDataExchange* pDX, int nIDC, DISPID dispid,
	BOOL& value);
void AFXAPI DDX_OCInt(CDataExchange* pDX, int nIDC, DISPID dispid,
	int &value);
void AFXAPI DDX_OCIntRO(CDataExchange* pDX, int nIDC, DISPID dispid,
	int &value);
void AFXAPI DDX_OCInt(CDataExchange* pDX, int nIDC, DISPID dispid,
	long &value);
void AFXAPI DDX_OCIntRO(CDataExchange* pDX, int nIDC, DISPID dispid,
	long &value);
void AFXAPI DDX_OCShort(CDataExchange* pDX, int nIDC, DISPID dispid,
	short& value);
void AFXAPI DDX_OCShortRO(CDataExchange* pDX, int nIDC, DISPID dispid,
	short& value);
void AFXAPI DDX_OCColor(CDataExchange* pDX, int nIDC, DISPID dispid,
	OLE_COLOR& value);
void AFXAPI DDX_OCColorRO(CDataExchange* pDX, int nIDC, DISPID dispid,
	OLE_COLOR& value);
void AFXAPI DDX_OCFloat(CDataExchange* pDX, int nIDC, DISPID dispid,
	float& value);
void AFXAPI DDX_OCFloatRO(CDataExchange* pDX, int nIDC, DISPID dispid,
	float& value);
void AFXAPI DDX_OCFloat(CDataExchange* pDX, int nIDC, DISPID dispid,
	double& value);
void AFXAPI DDX_OCFloatRO(CDataExchange* pDX, int nIDC, DISPID dispid,
	double& value);

#endif // !_AFX_NO_OCC_SUPPORT

/////////////////////////////////////////////////////////////////////////////
// Function to enable containment of OLE controls

#ifndef _AFX_NO_OCC_SUPPORT

#ifndef __AFXOCC_H__
	#include <afxocc.h>
#endif

void AFX_CDECL AfxEnableControlContainer(COccManager* pOccManager=NULL);
#else
#define AfxEnableControlContainer()
#endif

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXDISP_INLINE AFX_INLINE
#include <afxole.inl>
#undef _AFXDISP_INLINE
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#if defined(_USRDLL) && defined(_M_CEE)
	/* Include PostDllMain to correctly initialize CWinApp in _M_CEE applications */

	#ifndef _UNICODE
		#ifdef _DEBUG
			#pragma comment(lib, "mfcm" _MFC_FILENAME_VER "d.lib")
		#else
			#pragma comment(lib, "mfcm" _MFC_FILENAME_VER ".lib")
		#endif
	#else
		#ifdef _DEBUG
			#pragma comment(lib, "mfcm" _MFC_FILENAME_VER "ud.lib")
		#else
			#pragma comment(lib, "mfcm" _MFC_FILENAME_VER "u.lib")
		#endif
	#endif

#if defined(_M_IX86)
	#pragma comment(linker, "/include:??0PostDllMain@@$$FQAE@XZ")
	#pragma comment(linker, "/include:??0PostRawDllMain@@$$FQAE@XZ")
#elif defined (_M_AMD64)
	#pragma comment(linker, "/include:??0PostDllMain@@$$FQEAA@XZ")
	#pragma comment(linker, "/include:??0PostRawDllMain@@$$FQEAA@XZ")
#else
	#error Compiling for unsupported platform
#endif

#endif

#endif //__AFXDISP_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxdlgs.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXDLGS.H

#pragma once

#ifdef _AFXDLGS_INLINE

// CCommonDialog
_AFXDLGS_INLINE CCommonDialog::CCommonDialog(CWnd* pParentWnd)
	: CDialog((UINT)0, pParentWnd) { }

// CFileDialog
_AFXDLGS_INLINE BOOL CFileDialog::GetReadOnlyPref() const
	{ return m_ofn.Flags & OFN_READONLY ? TRUE : FALSE; }
_AFXDLGS_INLINE void CFileDialog::SetTemplate(UINT nWin3ID, UINT nWin4ID)
	{ SetTemplate(MAKEINTRESOURCE(nWin3ID), MAKEINTRESOURCE(nWin4ID)); }
_AFXDLGS_INLINE POSITION CFileDialog::GetStartPosition() const
	{ return (POSITION)m_ofn.lpstrFile; }

// CFontDialog
_AFXDLGS_INLINE CString CFontDialog::GetFaceName() const
	{ return (LPCTSTR)m_cf.lpLogFont->lfFaceName; }
_AFXDLGS_INLINE CString CFontDialog::GetStyleName() const
	{ return m_cf.lpszStyle; }
_AFXDLGS_INLINE int CFontDialog::GetSize() const
	{ return m_cf.iPointSize; }
_AFXDLGS_INLINE int CFontDialog::GetWeight() const
	{ return (int)m_cf.lpLogFont->lfWeight; }
_AFXDLGS_INLINE BOOL CFontDialog::IsItalic() const
	{ return m_cf.lpLogFont->lfItalic ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CFontDialog::IsStrikeOut() const
	{ return m_cf.lpLogFont->lfStrikeOut ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CFontDialog::IsBold() const
	{ return m_cf.lpLogFont->lfWeight == FW_BOLD ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CFontDialog::IsUnderline() const
	{ return m_cf.lpLogFont->lfUnderline ? TRUE : FALSE; }
_AFXDLGS_INLINE COLORREF CFontDialog::GetColor() const
	{ return m_cf.rgbColors; }

// CColorDialog
_AFXDLGS_INLINE COLORREF CColorDialog::GetColor() const
	{ return m_cc.rgbResult; }

// CPrintDialog
_AFXDLGS_INLINE BOOL CPrintDialog::PrintSelection() const
	{ return m_pd.Flags & PD_SELECTION ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CPrintDialog::PrintRange() const
	{ return m_pd.Flags & PD_PAGENUMS ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CPrintDialog::PrintAll() const
	{ return !PrintRange() && !PrintSelection() ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CPrintDialog::PrintCollate() const
	{ return m_pd.Flags & PD_COLLATE ? TRUE : FALSE; }
_AFXDLGS_INLINE int CPrintDialog::GetFromPage() const
	{ return (PrintRange() ? m_pd.nFromPage :-1); }
_AFXDLGS_INLINE int CPrintDialog::GetToPage() const
	{ return (PrintRange() ? m_pd.nToPage :-1); }
_AFXDLGS_INLINE HDC CPrintDialog::GetPrinterDC() const
	{ ASSERT_VALID(this);
		ASSERT(m_pd.Flags & PD_RETURNDC);
		return m_pd.hDC; }

// CPrintDialogEx
#if WINVER >= 0x0500
_AFXDLGS_INLINE BOOL CPrintDialogEx::PrintSelection() const
	{ return m_pdex.Flags & PD_SELECTION ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CPrintDialogEx::PrintRange() const
	{ return m_pdex.Flags & PD_PAGENUMS ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CPrintDialogEx::PrintCurrentPage() const
	{ return m_pdex.Flags & PD_CURRENTPAGE ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CPrintDialogEx::PrintAll() const
	{ return !PrintRange() && !PrintSelection() && !PrintCurrentPage() ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CPrintDialogEx::PrintCollate() const
	{ return m_pdex.Flags & PD_COLLATE ? TRUE : FALSE; }
_AFXDLGS_INLINE HDC CPrintDialogEx::GetPrinterDC() const
	{ ASSERT_VALID(this);
		ASSERT(m_pdex.Flags & PD_RETURNDC);
		return m_pdex.hDC; }
#endif //(WINVER >= 0x0500)

// CFindReplaceDialog
_AFXDLGS_INLINE BOOL CFindReplaceDialog::IsTerminating() const
	{ return m_fr.Flags & FR_DIALOGTERM ? TRUE : FALSE ; }
_AFXDLGS_INLINE CString CFindReplaceDialog::GetReplaceString() const
	{ return m_fr.lpstrReplaceWith; }
_AFXDLGS_INLINE CString CFindReplaceDialog::GetFindString() const
	{ return m_fr.lpstrFindWhat; }
_AFXDLGS_INLINE BOOL CFindReplaceDialog::SearchDown() const
	{ return m_fr.Flags & FR_DOWN ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CFindReplaceDialog::FindNext() const
	{ return m_fr.Flags & FR_FINDNEXT ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CFindReplaceDialog::MatchCase() const
	{ return m_fr.Flags & FR_MATCHCASE ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CFindReplaceDialog::MatchWholeWord() const
	{ return m_fr.Flags & FR_WHOLEWORD ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CFindReplaceDialog::ReplaceCurrent() const
	{ return m_fr. Flags & FR_REPLACE ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CFindReplaceDialog::ReplaceAll() const
	{ return m_fr.Flags & FR_REPLACEALL ? TRUE : FALSE; }

// CPropertySheet
_AFXDLGS_INLINE void CPropertySheet::MapDialogRect(LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); ::MapDialogRect(m_hWnd, lpRect); }
_AFXDLGS_INLINE CPropertyPage* CPropertySheet::GetPage(int nPage) const
{ 
	CPropertyPage *pPage=STATIC_DOWNCAST(CPropertyPage, (CObject*)m_pages[nPage]); 
	ENSURE(pPage);
	return pPage;
}

_AFXDLGS_INLINE void CPropertySheet::SetWizardMode()
	{ m_psh.dwFlags |= PSH_WIZARD; }
_AFXDLGS_INLINE void CPropertySheet::SetFinishText(LPCTSTR lpszText)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, PSM_SETFINISHTEXT, 0, (LPARAM)lpszText); }
_AFXDLGS_INLINE void CPropertySheet::SetWizardButtons(DWORD dwFlags)
	{ ASSERT(::IsWindow(m_hWnd)); ::PostMessage(m_hWnd, PSM_SETWIZBUTTONS, 0, dwFlags); }
_AFXDLGS_INLINE CTabCtrl* CPropertySheet::GetTabControl() const
	{ ASSERT(::IsWindow(m_hWnd)); return (CTabCtrl*)CWnd::FromHandle(
		(HWND)::SendMessage(m_hWnd, PSM_GETTABCONTROL, 0, 0)); }
_AFXDLGS_INLINE void CPropertySheet::PressButton(int nButton)
{
	ASSERT(::IsWindow(m_hWnd));
	if (nButton == PSBTN_FINISH)
		m_nModalResult = ID_WIZFINISH;
	::SendMessage(m_hWnd, PSM_PRESSBUTTON, nButton, 0);
}
_AFXDLGS_INLINE BOOL CPropertySheet::IsWizard() const
		{ return (m_psh.dwFlags & (PSH_WIZARD | PSH_WIZARD97)) != 0; }
_AFXDLGS_INLINE BOOL CPropertySheet::IsModeless() const
		{ return m_bModeless; }
// CPageSetupDialog
_AFXDLGS_INLINE CSize CPageSetupDialog::GetPaperSize() const
	{ return CSize(m_psd.ptPaperSize.x, m_psd.ptPaperSize.y); }

/////////////////////////////////////////////////////////////////////////////

#endif //_AFXDLGS_INLINE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxdockablepaneadapter.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxdockablepane.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CDockablePaneAdapter window

class CDockablePaneAdapter : public CDockablePane
{
	DECLARE_SERIAL(CDockablePaneAdapter);

// Construction
public:
	CDockablePaneAdapter();

// Attributes
public:
	CRect m_rectInitial;
	DWORD m_dwEnabledAlignmentInitial;

// Operations
public:
	virtual BOOL SetWrappedWnd(CWnd* pWnd);
	virtual CWnd* GetWrappedWnd() const { return m_pWnd; }

	virtual BOOL LoadState(LPCTSTR lpszProfileName = NULL, int nIndex = -1, UINT uiID = (UINT) -1);
	virtual BOOL SaveState(LPCTSTR lpszProfileName = NULL, int nIndex = -1, UINT uiID = (UINT) -1);

// Implementation
public:
	virtual ~CDockablePaneAdapter();

protected:
	//{{AFX_MSG(CDockablePaneAdapter)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	CWnd* m_pWnd;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxdll_.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// afxdll_.h - extensions to AFXWIN.H used for the 'AFXDLL' version
// This file contains MFC library implementation details as well
//   as APIs for writing MFC Extension DLLs.
// Please refer to Technical Note 033 (TN033) for more details.

/////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef _AFXDLL
	#error file must be compiled with _AFXDLL
#endif

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

/////////////////////////////////////////////////////////////////////////////

// AFX_EXTENSION_MODULE - special struct used during DLL initialization

struct AFX_EXTENSION_MODULE
{
	BOOL bInitialized;
	HMODULE hModule;
	HMODULE hResource;
	CRuntimeClass* pFirstSharedClass;
	COleObjectFactory* pFirstSharedFactory;
};

/////////////////////////////////////////////////////////////////////////////
// CDynLinkLibrary - for implementation of MFC Extension DLLs

class COleObjectFactory;

class CDynLinkLibrary : public CCmdTarget
{
	DECLARE_DYNAMIC(CDynLinkLibrary)
public:

// Constructor
	explicit CDynLinkLibrary(AFX_EXTENSION_MODULE& state, BOOL bSystem = FALSE);
	CDynLinkLibrary(HINSTANCE hModule, HINSTANCE hResource);

// Attributes
	HMODULE m_hModule;
	HMODULE m_hResource;                // for shared resources
	CTypedSimpleList<CRuntimeClass*> m_classList;
#ifndef _AFX_NO_OLE_SUPPORT
	CTypedSimpleList<COleObjectFactory*> m_factoryList;
#endif
	BOOL m_bSystem;                     // TRUE only for MFC DLLs

// Implementation
public:
	CDynLinkLibrary* m_pNextDLL;        // simple singly linked list
	virtual ~CDynLinkLibrary();

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif //_DEBUG
};

// call in every DLL_PROCESS_ATTACH
BOOL AFXAPI AfxInitExtensionModule(AFX_EXTENSION_MODULE&, HMODULE hMod);
// call on every DLL_PROCESS_DETACH
void AFXAPI AfxTermExtensionModule(AFX_EXTENSION_MODULE&, BOOL bAll = FALSE);

// special function(s) for stand-alone DLLs (and controls)
void AFXAPI AfxCoreInitModule();
#define AfxOleInitModule()
#define AfxNetInitModule()
#define AfxDbInitModule()


// special functions for loading and freeing MFC extension DLLs
// (necessary if your app is multithreaded and loads extension
//  DLLs dynamically)
HINSTANCE AFXAPI AfxLoadLibrary(LPCTSTR lpszModuleName);
HINSTANCE AFXAPI AfxLoadLibraryEx( LPCTSTR lpFileName,  HANDLE hFile,  DWORD dwFlags);
BOOL AFXAPI AfxFreeLibrary(HINSTANCE hInstLib);
 

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxdockablepane.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxpane.h"
#include "afxmenuimages.h"
#include "afxpanecontainer.h"
#include "afxcaptionbutton.h"
#include "afxmultipaneframewnd.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#define AFX_CONTROLBAR_BUTTONS_NUM 3  // Hide + Expand + Menu

// auto hide timer events
static const UINT AFX_AUTO_HIDE_SLIDE_IN_EVENT     = 1;
static const UINT AFX_AUTO_HIDE_SLIDE_OUT_EVENT    = 2;
static const UINT AFX_ID_CHECK_AUTO_HIDE_CONDITION = 3;

class CDockablePane;
class CTabbedPane;
class CPaneContainerManager;

/////////////////////////////////////////////////////////////////////////
// CDockablePane control bar styles

#define AFX_SCBS_EDGELEFT       0x00000001
#define AFX_SCBS_EDGERIGHT      0x00000002
#define AFX_SCBS_EDGETOP        0x00000004
#define AFX_SCBS_EDGEBOTTOM     0x00000008
#define AFX_SCBS_EDGEALL        0x0000000F
#define AFX_SCBS_SHOWEDGES      0x00000010
#define AFX_SCBS_GRIPPER        0x00000020

static const DWORD AFX_DEFAULT_DOCKING_PANE_STYLE = AFX_CBRS_FLOAT | AFX_CBRS_CLOSE | AFX_CBRS_RESIZE | AFX_CBRS_AUTOHIDE;

class CTabbedPane;
class CPaneDivider;
class CMFCAutoHideBar;
class CMFCAutoHideButton;

extern AFX_IMPORT_DATA UINT AFX_WM_ON_PRESS_CLOSE_BUTTON;

class CDockablePane : public CPane
{
	friend class CDockingManager;
	friend class CPaneFrameWnd;
	friend class CMultiPaneFrameWnd;
	friend class CBaseTabbedPane;
	friend class CMDIClientAreaWnd;

	DECLARE_SERIAL(CDockablePane);

public:
	CDockablePane();
	virtual ~CDockablePane();

// Overrides
	public:
	virtual BOOL Create(LPCTSTR lpszCaption, CWnd* pParentWnd, const RECT& rect, BOOL bHasGripper, UINT nID, DWORD dwStyle, DWORD dwTabbedStyle = AFX_CBRS_REGULAR_TABS, DWORD dwControlBarStyle = AFX_DEFAULT_DOCKING_PANE_STYLE, CCreateContext* pContext = NULL);
	virtual BOOL CreateEx(DWORD dwStyleEx, LPCTSTR lpszCaption, CWnd* pParentWnd, const RECT& rect, BOOL bHasGripper, UINT nID, DWORD dwStyle, DWORD dwTabbedStyle = AFX_CBRS_REGULAR_TABS, DWORD dwControlBarStyle = AFX_DEFAULT_DOCKING_PANE_STYLE, CCreateContext* pContext = NULL);
	virtual BOOL PreTranslateMessage(MSG* pMsg);

public:
	virtual BOOL Create(LPCTSTR lpszWindowName, CWnd* pParentWnd, CSize sizeDefault, BOOL bHasGripper, UINT nID, 
		DWORD dwStyle = WS_CHILD | WS_VISIBLE | CBRS_TOP | CBRS_HIDE_INPLACE, DWORD dwTabbedStyle = AFX_CBRS_REGULAR_TABS, DWORD dwControlBarStyle = AFX_DEFAULT_DOCKING_PANE_STYLE);

	virtual void OnUpdateCmdUI(class CFrameWnd *pTarget, int bDisableIfNoHndler);
	virtual BOOL IsDocked() const;
	virtual int GetCaptionHeight() const;

	virtual void GetTabArea(CRect& rectTabAreaTop, CRect& rectTabAreaBottom) const
	{
		rectTabAreaTop.SetRectEmpty();
		rectTabAreaBottom.SetRectEmpty();
	}

	virtual BOOL IsTabLocationBottom() const { return TRUE; }

	virtual void OnBeforeChangeParent(CWnd* pWndNewParent, BOOL bDelay = FALSE);
	virtual void OnAfterChangeParent(CWnd* pWndOldParent);

	virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);

	virtual int HitTest(CPoint point, BOOL bDetectCaption = FALSE);

	virtual BOOL LoadState(LPCTSTR lpszProfileName = NULL, int nIndex = -1, UINT uiID = (UINT) -1);
	virtual BOOL SaveState(LPCTSTR lpszProfileName = NULL, int nIndex = -1, UINT uiID = (UINT) -1);

	virtual BOOL IsResizable() const { return TRUE; }
	virtual BOOL IsInFloatingMultiPaneFrameWnd() const;

	virtual BOOL CanAcceptPane(const CBasePane* pBar) const
	{
		if (pBar == NULL)
		{
			return FALSE;
		}

		return (pBar->IsKindOf(RUNTIME_CLASS(CDockablePane)) && (IsDocked() || IsInFloatingMultiPaneFrameWnd()));
	}

	virtual BOOL CanAcceptMiniFrame(CPaneFrameWnd* pMiniFrame) const;

	virtual BOOL CanBeAttached() const { return TRUE; }
	virtual BOOL IsAutoHideMode() const { return m_bPinState; }
	virtual BOOL HasAutoHideMode() const { return TRUE; }
	virtual BOOL IsAutohideAllEnabled() const { return m_bEnableAutoHideAll; }
	void EnableAutohideAll(BOOL bEnable = TRUE) { m_bEnableAutoHideAll = bEnable; }

	virtual BOOL IsAccessibilityCompatible() { return FALSE; }

	virtual BOOL IsVisible() const;
	virtual void Slide(BOOL bSlideOut, BOOL bUseTimer = TRUE);

	void SetAutoHideParents(CMFCAutoHideBar* pToolBar, CMFCAutoHideButton* pBtn);
	void SetResizeMode(BOOL bResize);

	virtual void ToggleAutoHide();

	static const CSize& __stdcall GetDragSensitivity() { return m_sizeDragSensitivity; }

	virtual CPane* DockPaneStandard(BOOL& bWasDocked);

	virtual AFX_CS_STATUS IsChangeState(int nOffset, CBasePane** ppTargetBar) const;
	virtual AFX_CS_STATUS GetDockingStatus(CPoint pt, int nSensitivity);

	virtual CDockablePane* AttachToTabWnd(CDockablePane* pTabControlBarAttachTo, AFX_DOCK_METHOD dockMethod, BOOL bSetActive = TRUE, CDockablePane** ppTabbedControlBar = NULL);
	virtual CTabbedPane* CreateTabbedPane();

	void SetDefaultPaneDivider(HWND hSliderWnd);
	CPaneDivider* GetDefaultPaneDivider() const;

	virtual BOOL DockToFrameWindow(DWORD dwAlignment, LPCRECT lpRect = NULL, DWORD dwDockFlags = DT_DOCK_LAST, CBasePane* pRelativeBar = NULL, int nRelativeIndex = -1, BOOL bOuterEdge = FALSE);
	virtual BOOL DockToWindow(CDockablePane* pTargetWindow, DWORD dwAlignment, LPCRECT lpRect = NULL);
	virtual BOOL DockPaneContainer(CPaneContainerManager& barContainerManager, DWORD dwAlignment, AFX_DOCK_METHOD dockMethod);

	virtual void UndockPane(BOOL bDelay = FALSE);

	virtual void OnAfterDockFromMiniFrame() { OnAfterDock(this, NULL, DM_UNKNOWN); }

	virtual void UnSetAutoHideMode (CDockablePane* pFirstBarInGroup);
	BOOL ReplacePane(CDockablePane* pBarToReplaceWith, AFX_DOCK_METHOD dockMethod, BOOL bRegisterWithFrame = FALSE);

	void RemoveFromDefaultPaneDividier();

	virtual void ShowPane(BOOL bShow, BOOL bDelay, BOOL bActivate/* = TRUE*/);
	virtual BOOL DockToRecentPos() { return Dock(NULL, NULL, DM_SHOW); }

	virtual void EnableGripper(BOOL bEnable);

	virtual CMFCAutoHideBar* SetAutoHideMode(BOOL bMode, DWORD dwAlignment, CMFCAutoHideBar* pCurrAutoHideBar = NULL, BOOL bUseTimer = TRUE);
	static void __stdcall SetCaptionStyle(BOOL bDrawText, BOOL bForceGradient = FALSE, BOOL bHideDisabledButtons = FALSE);
	
	static BOOL __stdcall IsDrawCaption() { return m_bCaptionText; }
	static BOOL __stdcall IsHideDisabledButtons() { return m_bHideDisabledButtons; }

	static CPaneDivider* __stdcall CreateDefaultPaneDivider(DWORD dwAlignment, CWnd* pParent, CRuntimeClass* pSliderRTC = NULL);

	AFX_IMPORT_DATA static BOOL m_bHideInAutoHideMode;
	AFX_IMPORT_DATA static BOOL m_bDisableAnimation;

	virtual BOOL IsHideInAutoHideMode() const { return m_bHideInAutoHideMode; }
	virtual BOOL CanAutoHide() const;

	BOOL IsTracked() const { return m_bPrepareToFloat; }

	void SetLastPercentInPaneContainer(int n) { m_nLastPercent = n; }
	int  GetLastPercentInPaneContainer() const { return m_nLastPercent; }
	void GetRecentSiblingPaneInfo(CList<UINT, UINT&>& lstBarIDs);

	CRect GetAHRestoredRect() const {return m_rectRestored;}
	virtual BOOL CanAdjustLayout() const { return !m_bIsSliding || !m_bIsHiding; }
	virtual UINT GetAHSlideMode() const { return m_ahSlideMode; }

	CMFCAutoHideBar* GetAutoHideToolBar() const { return m_pAutoHideBar; }
	CMFCAutoHideButton* GetAutoHideButton() { return m_pAutoHideButton; }

	virtual void Serialize(CArchive& ar);
	virtual void CopyState(CDockablePane* pOrgBar);

	virtual BOOL OnBeforeFloat(CRect& rectFloat, AFX_DOCK_METHOD dockMethod);

	void SetTabbedPaneRTC(CRuntimeClass* pRTC)
	{
		ASSERT(pRTC != NULL);
		m_pTabbedControlBarRTC = pRTC;
	}

	void SetRestoredDefaultPaneDivider(HWND hRestoredSlider) { m_hRestoredDefaultSlider = hRestoredSlider; }
	void RestoreDefaultPaneDivider() { SetDefaultPaneDivider(m_hRestoredDefaultSlider); }

	CRuntimeClass* GetTabbedPaneRTC() const { return m_pTabbedControlBarRTC; }

	virtual void ConvertToTabbedDocument(BOOL bActiveTabOnly = TRUE);

	AFX_IMPORT_DATA static int m_nTimeOutBeforeAutoHide;
	AFX_IMPORT_DATA static int m_nSlideSteps;

protected:
	//{{AFX_MSG(CDockablePane)
	afx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp);
	afx_msg void OnNcPaint();
	afx_msg void OnPaint();
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnNcLButtonDown(UINT nHitTest, CPoint point);
	afx_msg void OnClose();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnDestroy();
	afx_msg void OnNcMouseMove(UINT nHitTest, CPoint point);
	afx_msg void OnCancelMode();
	afx_msg void OnTimer(UINT_PTR nIDEvent);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg LRESULT OnSetText(WPARAM wParam, LPARAM lParam);
	afx_msg BOOL OnNeedTipText(UINT id, NMHDR* pNMH, LRESULT* pResult);
	afx_msg LRESULT OnNcHitTest(CPoint point);
	afx_msg LRESULT OnUpdateToolTips(WPARAM, LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	virtual BOOL Dock(CBasePane* pTargetBar, LPCRECT lpRect, AFX_DOCK_METHOD dockMethod);
	virtual void OnContinueMoving() {} // do nothing - resizable control bar doesn't move after docking
	virtual void OnDrawDragRect(LPCRECT lprectNew, LPCRECT lprectOld);
	virtual void OnAfterDock(CBasePane* /*pBar*/, LPCRECT /*lpRect*/, AFX_DOCK_METHOD /*dockMethod*/); 
	
	virtual void EnterDragMode(BOOL bChangeHotPoint);
	virtual void StoreRecentDockSiteInfo();
	virtual void StoreRecentTabRelatedInfo();

	virtual void OnPressCloseButton();
	virtual void OnPressButtons(UINT /*nHit*/) {}

	virtual void DrawCaption(CDC* pDC, CRect rectCaption);
	virtual void AdjustPaneToPaneContainer(CPaneDivider* pSlider);

	void RedrawButton(const CMFCCaptionButton* pBtn);
	CMFCCaptionButton* FindButton(CPoint point) const;
	CMFCCaptionButton* FindButtonByHit(UINT nHit) const;
	void EnableButton(UINT nHit, BOOL bEnable = TRUE);
	BOOL IsButtonEnabled(UINT nHit) const;

	virtual void OnTrackCaptionButtons(CPoint point);
	virtual void StopCaptionButtonsTracking();

	virtual void SetCaptionButtons();
	void RemoveCaptionButtons();
	
	void UpdateTooltips();

	CRect m_rectCloseButton;

	/// how far the mouse is moved after NcLBtnDown before the bar becomes floating
	AFX_IMPORT_DATA static CSize m_sizeDragSensitivity;

	bool m_bPrepareToFloat;
	bool m_bReadyToFloat;
	int  m_cyGripper;
	int  m_nLastPercent;
	int  m_nBorderSize;
	BOOL m_bHasGripper; // indicates that the bar has caption (it may not be shown when floating)
	BOOL m_bActive;
	BOOL m_bEnableAutoHideAll;
	DWORD m_dwSCBStyle;
	CRect m_rectRedraw;

	// auto hide support
	BOOL     m_bPinState;
	UINT_PTR m_nAutoHideConditionTimerID;
	UINT_PTR m_nSlideTimer;
	int      m_nSlideStep;
	int      m_nSlideDelta;

	AFX_IMPORT_DATA static int m_nSlideDefaultTimeOut;

	CRect m_rectRestored;
	BOOL  m_bIsSliding;
	BOOL  m_bIsResizing;
	BOOL  m_bIsHiding;
	UINT  m_ahSlideMode;

	CMFCAutoHideButton*  m_pAutoHideButton;
	CMFCAutoHideBar* m_pAutoHideBar;

	virtual BOOL CheckAutoHideCondition();
	virtual BOOL CheckStopSlideCondition(BOOL bDirection);
	virtual void OnSlide(BOOL bSlideOut);

	void CalcRectForSliding(CRect& rect, CRect& rectSlider, BOOL bSlideDirection);
	void OffsetRectForSliding(CRect& rect, BOOL bSlideDirection, BOOL bIsRTL);
	CPoint CalcCorrectOffset(CRect rect, BOOL bIsRTL);

	CTypedPtrArray<CObArray, CMFCCaptionButton*> m_arrButtons;

	AFX_IMPORT_DATA static BOOL m_bCaptionText;
	AFX_IMPORT_DATA static BOOL m_bHideDisabledButtons;

	CRuntimeClass* m_pTabbedControlBarRTC;
	CToolTipCtrl*  m_pToolTip;

	HWND m_hDefaultSlider;
	HWND m_hRestoredDefaultSlider;
	UINT m_nHot;
	UINT m_nHit;
	BOOL m_bCaptionButtonsCaptured;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxdockingmanager.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxpane.h"
#include "afxsmartdockingmanager.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CDockSite;
class CAutoHideDockSite;
class CMFCAutoHideBar;
class CPaneFrameWnd;
class CMultiPaneFrameWnd;
class CTabbedPane;
class CPaneDivider;
class CDockablePane;
class COleCntrFrameWndEx;

struct AFX_DOCKSITE_INFO
{
	DWORD          m_dwBarAlignment;
	CRuntimeClass* pDockBarRTC;
};

struct AFX_AUTOHIDE_DOCKSITE_SAVE_INFO
{
	AFX_AUTOHIDE_DOCKSITE_SAVE_INFO()
	{
		m_pSavedBar = NULL;
		m_rectBar.SetRectEmpty();
		m_nBarID = (UINT)-1;
		m_bIsVisible = FALSE;
		m_dwBarAlignment = 0;
		m_bFirstInGroup = TRUE;
		m_bLastInGroup = TRUE;
		m_bActiveInGroup = TRUE;
	}

	AFX_AUTOHIDE_DOCKSITE_SAVE_INFO(AFX_AUTOHIDE_DOCKSITE_SAVE_INFO& src)
	{
		Copy(src);
	}

	UINT  m_nBarID;
	DWORD m_dwBarAlignment;
	BOOL  m_bIsVisible;
	CRect m_rectBar;
	CList<UINT, UINT&> m_lstSiblingBars;

	BOOL m_bFirstInGroup;
	BOOL m_bLastInGroup;
	BOOL m_bActiveInGroup;

	void Serialize(CArchive& ar);
	AFX_AUTOHIDE_DOCKSITE_SAVE_INFO& operator= (AFX_AUTOHIDE_DOCKSITE_SAVE_INFO& src) { return Copy(src); }

	AFX_AUTOHIDE_DOCKSITE_SAVE_INFO& Copy(AFX_AUTOHIDE_DOCKSITE_SAVE_INFO& src)
	{
		m_lstSiblingBars.RemoveAll();
		m_nBarID = src.m_nBarID;
		m_dwBarAlignment = src.m_dwBarAlignment;
		m_bIsVisible = src.m_bIsVisible;
		m_rectBar = src.m_rectBar;
		m_lstSiblingBars.AddTail(&src.m_lstSiblingBars);
		m_bFirstInGroup = src.m_bFirstInGroup;
		m_bLastInGroup = src.m_bLastInGroup;
		m_bActiveInGroup = src.m_bActiveInGroup;
		return *this;
	}

	CDockablePane* m_pSavedBar; // must be set before serialize;
};

#define AFX_SD_MARKERS_NUM 5

class CSmartDockingInfo : public CObject
{
public:
	CSmartDockingInfo();

	void CopyTo(CSmartDockingInfo& params);

	CSize       m_sizeTotal;    // Smart docking group bounds dimension
	int         m_nCentralGroupOffset;
	COLORREF    m_clrTransparent;
	COLORREF    m_clrToneSrc;
	COLORREF    m_clrToneDest;
	COLORREF    m_clrBaseBackground;
	COLORREF    m_clrBaseBorder;
	UINT        m_uiMarkerBmpResID [AFX_SD_MARKERS_NUM];
	UINT        m_uiMarkerLightBmpResID [AFX_SD_MARKERS_NUM];
	UINT		m_uiBaseBmpResID;
	BOOL        m_bUseThemeColorInShading;
	BOOL		m_bIsAlphaMarkers;
};

class CDockingManager : public CObject
{
	friend class CMDIChildWndEx;
	friend class COleCntrFrameWndEx;
	friend struct AFX_GLOBAL_DATA;
	friend class CMFCVisualManager;
	friend class CFrameImpl;

public:
	CDockingManager();
	virtual ~CDockingManager();

	DWORD GetEnabledAutoHideAlignment() const { return m_dwEnabledSlideBars; }

	void DockPane(CBasePane* pBar, UINT nDockBarID = 0, LPCRECT lpRect = NULL);
	BOOL DockPaneLeftOf(CPane* pBarToDock, CPane* pTargetBar);

	BOOL IsPointNearDockSite(CPoint point, DWORD& dwBarAlignment, BOOL& bOuterEdge) const;

	BOOL Create(CFrameWnd* pParentWnd);
	BOOL EnableDocking(DWORD dwStyle);
	BOOL EnableAutoHidePanes(DWORD dwStyle);

	BOOL AddDockSite(const AFX_DOCKSITE_INFO& info, CDockSite** ppDockBar = NULL); 
	BOOL InsertDockSite(const AFX_DOCKSITE_INFO& info, DWORD dwAlignToInsertAfter, CDockSite** ppDockBar = NULL);

	BOOL AddPane(CBasePane* pWnd, BOOL bTail = TRUE, BOOL bAutoHide = FALSE, BOOL bInsertForOuterEdge = FALSE);
	BOOL InsertPane(CBasePane* pControlBar, CBasePane* pTarget, BOOL bAfter = TRUE);

	void CalcExpectedDockedRect(CWnd* pWnd, CPoint ptMouse, CRect& rectResult, BOOL& bDrawTab, CDockablePane** ppTargetBar);

	void RemovePaneFromDockManager(CBasePane* pWnd, BOOL bDestroy, BOOL bAdjustLayout, BOOL bAutoHide = FALSE, CBasePane* pBarReplacement = NULL);

	virtual CBasePane* PaneFromPoint(CPoint point, int nSensitivity, bool bExactBar = false,
		CRuntimeClass* pRTCBarType = NULL, BOOL bCheckVisibility = FALSE, const CBasePane* pBarToIgnore = NULL) const;
	virtual CBasePane* PaneFromPoint(CPoint point, int nSensitivity, DWORD& dwAlignment,
		CRuntimeClass* pRTCBarType = NULL, const CBasePane* pBarToIgnore = NULL) const;
	virtual CPaneFrameWnd* FrameFromPoint(CPoint pt, CPaneFrameWnd* pFrameToExclude, BOOL bFloatMultiOnly) const;

	virtual AFX_CS_STATUS DeterminePaneAndStatus(CPoint pt, int nSensitivity, DWORD dwEnabledAlignment,
		CBasePane** ppTargetBar, const CBasePane* pBarToIgnore, const CBasePane* pBarToDock);

	virtual BOOL AddMiniFrame(CPaneFrameWnd* pWnd);
	virtual BOOL RemoveMiniFrame(CPaneFrameWnd* pWnd);

	virtual CBasePane* FindPaneByID(UINT uBarID, BOOL bSearchMiniFrames = FALSE);
	virtual CDockSite* FindDockSite(DWORD dwAlignment, BOOL bOuter);

	virtual CDockSite* FindDockSiteByPane(CPane* pTargetBar);

	virtual void FixupVirtualRects();
	virtual void RecalcLayout(BOOL bNotify = TRUE);
	virtual void AdjustDockingLayout(HDWP hdwp = NULL);
	virtual BOOL OnMoveMiniFrame(CWnd* pFrame);

	virtual void AdjustPaneFrames();

	virtual BOOL SaveState(LPCTSTR lpszProfileName = NULL, UINT uiID = (UINT) -1);
	virtual BOOL LoadState(LPCTSTR lpszProfileName = NULL, UINT uiID = (UINT) -1);
	virtual void SetDockState();

	virtual BOOL ShowPanes(BOOL bShow);
	virtual void ShowDelayShowMiniFrames(BOOL bShow);
	virtual void OnActivateFrame(BOOL bActivate);

	CRect GetClientAreaBounds() const { return m_rectClientAreaBounds; }
	CRect GetOuterEdgeBounds() const { return m_rectOuterEdgeBounds; }
	CFrameWnd* GetDockSiteFrameWnd() const { return m_pParentWnd; }

	CMFCAutoHideBar*  AutoHidePane(CDockablePane* pBar, CMFCAutoHideBar* pCurrAutoHideToolBar = NULL);
	void AlignAutoHidePane(CPaneDivider* pDefaultSlider, BOOL bIsVisible = TRUE);
	void BringBarsToTop(DWORD dwAlignment = 0, BOOL bExcludeDockedBars = TRUE);
	void SetAutohideZOrder(CDockablePane* pAHDockingBar);
	void HideAutoHidePanes(CDockablePane* pBarToExclude = NULL, BOOL bImmediately = FALSE);

	virtual BOOL AdjustRectToClientArea(CRect& rectResult, DWORD dwAlignment);

	void Serialize(CArchive& ar);

	static UINT m_nTimeOutBeforeToolBarDock;
	static UINT m_nTimeOutBeforeDockingBarDock;

	void SetPrintPreviewMode(BOOL bPreview, CPrintPreviewState* pState);
	BOOL IsPrintPreviewValid() const { return m_bIsPrintPreviewMode; }

	BOOL IsOLEContainerMode() const 
	{
		if (m_pParentWnd == NULL || m_pParentWnd->GetSafeHwnd() == NULL)
		{
			return FALSE;
		}
		return m_pParentWnd->m_pNotifyHook != NULL;
	}

	BOOL SendMessageToMiniFrames(UINT uMessage, WPARAM wParam = 0, LPARAM lParam = 0);
	BOOL ReplacePane(CDockablePane* pOriginalBar, CDockablePane* pNewBar);
	void ReleaseEmptyPaneContainers();

	void LockUpdate(BOOL bLock);

	void DisableRestoreDockState(BOOL bDisable = TRUE) { m_bDisableRestoreDockState = bDisable; }
	BOOL IsInAdjustLayout() const { return m_bAdjustingBarLayout; }

	void GetPaneList(CObList& lstBars, BOOL bIncludeAutohide = FALSE, CRuntimeClass* pRTCFilter = NULL, BOOL bIncludeTabs = FALSE);

	CSmartDockingManager* GetSmartDockingManagerPermanent() const { return m_pSDManager; }

	CSmartDockingManager* GetSmartDockingManager()  // consider returning NULL
	{
		if (m_bSDParamsModified)
		{
			// Smart docking manager should be re-created
			if (m_pSDManager != NULL)
			{
				delete m_pSDManager;
				m_pSDManager = NULL;
			}

			m_bSDParamsModified = FALSE;
		}

		// m_pParentWnd must already exist
		if (m_pSDManager == NULL)
		{
			m_pSDManager = new CSmartDockingManager;
			m_pSDManager->Create(m_pParentWnd);
		}

		return m_pSDManager;
	}

	void StartSDocking(CWnd* pDockingWnd)
	{
		CSmartDockingManager* pSDManager = GetSmartDockingManager();
		if (pSDManager != NULL)
		{
			pSDManager->SetOuterRect(m_rectOuterEdgeBounds);
			pSDManager->Start(pDockingWnd);
		}
	}

	void StopSDocking()
	{
		if (m_pSDManager != NULL)
		{
			m_pSDManager->Stop();
		}
	}

	void GetClientAreaBounds(CRect & rcClient)
	{
		rcClient = m_rectClientAreaBounds;
	}

	void ResortMiniFramesForZOrder();

	const CObList& GetMiniFrames() const
	{
		return m_lstMiniFrames;
	}

	void OnPaneContextMenu(CPoint point);
	BOOL ProcessPaneContextMenuCommand(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	void OnClosePopupMenu();

	void AddHiddenMDITabbedBar(CDockablePane* pBar);
	void RemoveHiddenMDITabbedBar(CDockablePane* pBar);

public:
	BOOL m_bEnableAdjustLayout;
	BOOL m_bLockUpdate;
	BOOL m_bSizeFrame;
	CRect m_rectInPlace;

	static AFX_DOCK_TYPE __stdcall GetDockingMode() { return m_dockModeGlobal; }

	/// <summary>
	/// Sets docking mode.</summary>
	/// <param name="dockMode">Specifies a docking mode to set. It should be one of the following 
	/// enumerated values: DT_IMMEDIATE, DT_STANDARD or combination of DT_IMMEDIATE and DT_SMART.</param>
	/// <param name="theme">Specifies the theme to be used for smart docking markers. It can be 
	/// one of the following enumerated values: AFX_SDT_DEFAULT, AFX_SDT_VS2005, AFX_SDT_VS2008.</param>
	static void __stdcall SetDockingMode(AFX_DOCK_TYPE dockMode, AFX_SMARTDOCK_THEME theme = AFX_SDT_DEFAULT);

	static void __stdcall SetSmartDockingParams(CSmartDockingInfo& params);
	static CSmartDockingInfo& __stdcall GetSmartDockingParams() { return m_SDParams; }

	/// <summary>
	/// A static method that returns a theme used to display smart docking markers.</summary>
	/// <returns> 
	/// Returns one of the following enumerated values: AFX_SDT_DEFAULT, AFX_SDT_VS2005, AFX_SDT_VS2008.</returns>
	static AFX_SMARTDOCK_THEME __stdcall GetSmartDockingTheme()
	{
		return m_SDTheme;
	}

	static void __stdcall EnableDockSiteMenu(BOOL bEnable = TRUE) { m_bDockBarMenu = bEnable; }
	static BOOL __stdcall IsDockSiteMenu() { return m_bDockBarMenu; }

	void EnablePaneContextMenu(BOOL bEnable, UINT uiCustomizeCmd, const CString& strCustomizeText, BOOL bToolbarsOnly = FALSE);
	void BuildPanesMenu(CMenu& menu, BOOL bToolbarsOnly);

	AFX_IMPORT_DATA static UINT m_ahSlideModeGlobal;
	AFX_IMPORT_DATA static int  m_nDockSensitivity;

	AFX_IMPORT_DATA static BOOL m_bRestoringDockState;
	AFX_IMPORT_DATA static BOOL m_bSavingState;
	AFX_IMPORT_DATA static BOOL m_bHideDockingBarsInContainerMode;
	AFX_IMPORT_DATA static BOOL m_bDisableRecalcLayout;
	AFX_IMPORT_DATA static BOOL m_bFullScreenMode;
	AFX_IMPORT_DATA static BOOL m_bIgnoreEnabledAlignment;

	AFX_IMPORT_DATA static CRuntimeClass* m_pAutoHideToolbarRTC;

protected:
	AFX_IMPORT_DATA static AFX_DOCK_TYPE m_dockModeGlobal;

	CObList m_lstControlBars;
	CObList m_lstAutoHideBars;

	CObList m_lstLoadedBars; // list of control bars restored from the archive
	CObList m_lstNonFloatingBars; // list of non-floating control bars restored from the archive
	CObList m_lstLoadedMiniFrames;

	// list of ahoto hide bar ids loaded from the archive
	CList<AFX_AUTOHIDE_DOCKSITE_SAVE_INFO, AFX_AUTOHIDE_DOCKSITE_SAVE_INFO&> m_lstLoadedAutoHideBarIDs;

	CObList m_lstMiniFrames; // list miniframes; these miniframes contain control bars that belong to this dock manager (and parent frame as well)

	CFrameWnd* m_pParentWnd;
	CRect m_rectDockBarBounds;
	CRect m_rectClientAreaBounds; // contains bounds of the client area and calculated as m_rectDockBarBounds minus rectangles of all dock bars
	CRect m_rectOuterEdgeBounds;  // contains rectangle of "outer edges" and calculated as m_rectDockBarBounds minus  rectangles of first nonresizable dock bars

	DWORD m_dwEnabledDockBars;
	DWORD m_dwEnabledSlideBars;

	CBasePane*    m_pLastTargetBar;
	CMultiPaneFrameWnd* m_pLastMultiMiniFrame;

	clock_t       m_clkLastTime;
	AFX_CS_STATUS m_statusLast;

	// Print preview memebers:
	BOOL    m_bIsPrintPreviewMode;
	CObList m_lstBarsHiddenInPreview;

	CPaneFrameWnd* m_pActiveSlidingWnd;

	BOOL m_bAdjustingBarLayout;
	BOOL m_bRecalcLayout;
	BOOL m_bDisableSetDockState; // should be disabled if load from registry failed
	BOOL m_bDisableRestoreDockState; // can be set by user to disable load dock state

	// Bars hidden on deactivation
	CList<HWND, HWND&> m_lstBarsHiddenOnDeactivate;
	// maintains a list of control bars hidden during in-place activation
	CList<HWND, HWND&> m_lstBarsHiddenForOLE;
	// maintains a list of control bars hidden during in-place activation
	CList<HWND, HWND&> m_lstHiddenMDITabbedBars;

	CSmartDockingManager* m_pSDManager;

	AFX_IMPORT_DATA static CSmartDockingInfo m_SDParams;
	AFX_IMPORT_DATA static BOOL m_bSDParamsModified;
	AFX_IMPORT_DATA static BOOL m_bDockBarMenu;
	AFX_IMPORT_DATA static AFX_SMARTDOCK_THEME m_SDTheme;

	// Map of control bars that appear in context menu:
	CMap<UINT,UINT,CPane*,CPane*> m_mapControlBarsInMenu;
	BOOL m_bControlBarsMenuIsShown;

	// Controlbar context menu attributes:
	BOOL m_bControlBarsContextMenu;
	BOOL m_bControlBarsContextMenuToolbarsOnly;
	BOOL m_bHiddenForOLE;
	UINT m_uiCustomizeCmd;
	CString m_strCustomizeText;

protected:
	void AlignByRect(const CRect& rectToAlignBy, CRect& rectResult, DWORD dwAlignment, BOOL bHorizontal, BOOL bResizable);
	void AlignPaneContainer(CRect& rectCurrBounds, POSITION& posNextBar, DWORD dwAlignment, BOOL bHorizontal);
	void CalcPaneOffset(CAutoHideDockSite* pBar);

	void HideForPrintPreview(const CObList& lstBars);
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxdocksite.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxpane.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CDockingPanesRow;
class CDockingManager;

#pragma warning( disable : 4100 34 )

class CDockSite : public CBasePane
{
	DECLARE_DYNCREATE(CDockSite)

// Construction
public:
	CDockSite();

// Attributes
public:

	bool IsLastRow(CDockingPanesRow* pRow) const;
	BOOL IsRectWithinDockSite(CRect rect, CPoint& ptDelta);
	virtual BOOL IsResizable() const {return FALSE;}
	virtual BOOL CanAcceptPane(const CBasePane* pBar) const;
	virtual BOOL IsDragMode() const;
	virtual BOOL IsAccessibilityCompatible() { return FALSE; }


	virtual BOOL DoesAllowDynInsertBefore() const { return FALSE; }
	const CObList& GetPaneList() const { return m_lstControlBars; }
	const CObList& GetDockSiteRowsList() const { return m_lstDockBarRows; }
	
// Operations
public:
	virtual CDockingPanesRow* CreateRow(CDockSite* pParentDockBar, int nOffset, int nRowHeight);

	virtual void DockPane(CPane* pWnd, AFX_DOCK_METHOD dockMethod, LPCRECT lpRect = NULL);
	virtual BOOL DockPaneLeftOf(CPane* pBarToDock, CPane* pTargetBar);

	virtual void RemovePane(CPane* pWnd, AFX_DOCK_METHOD dockMethod);

	virtual BOOL MovePane(CPane* pWnd, UINT nFlags, CPoint ptOffset);

	virtual void OnInsertRow(POSITION pos);
	virtual void OnRemoveRow(POSITION pos, BOOL bByShow = FALSE);
	virtual int  OnResizeRow(CDockingPanesRow* pRowToResize, int nOffset);
	virtual void OnShowRow(POSITION pos, BOOL bShow);

	virtual void OnSizeParent(CRect& rectAvailable, UINT nSide, BOOL bExpand, int nOffset) {}
	virtual void RepositionPanes(CRect& rectNewClientArea);
	virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);

	CDockingPanesRow* AddRow(POSITION pos, int nHeight);
	void RemoveRow(CDockingPanesRow* pRow);
	void ShowRow(CDockingPanesRow* pRow, BOOL bShow, BOOL bAdjustLayout);

	void ResizeDockSite(int nNewWidth, int nNewHeight);
	int ResizeRow(CDockingPanesRow* pRow, int nNewSize, BOOL bAdjustLayout = TRUE);

	void SwapRows(CDockingPanesRow* pFirstRow, CDockingPanesRow* pSecondRow);

	virtual void FixupVirtualRects();

	virtual BOOL ShowPane(CBasePane* pBar, BOOL bShow, BOOL bDelay, BOOL bActivate);

	virtual CPane* PaneFromPoint(CPoint pt);

	BOOL ReplacePane(CPane* pOldBar, CPane* pNewBar);
	void AlignDockSite(const CRect& rectToAlignBy, CRect& rectResult, BOOL bMoveImmediately);

	int FindRowIndex(CDockingPanesRow* pRow);

	virtual void AdjustLayout();
	virtual void AdjustDockingLayout();
	virtual UINT GetDockSiteID() const {return m_nDockBarID;}

	CPane* FindPaneByID(UINT nID);

public:
	static int __stdcall RectSideFromPoint(const CRect& rect, const CPoint& point);
	virtual BOOL OnSetWindowPos(const CWnd* pWndInsertAfter, const CRect& rectWnd, UINT nFlags);

// Overrides
public:
	virtual BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, DWORD dwControlBarStyle, CCreateContext* pContext = NULL);
	virtual BOOL CreateEx(DWORD dwStyleEx, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, DWORD dwControlBarStyle, CCreateContext* pContext = NULL);

protected:
	virtual void CalcWindowRect(LPRECT lpClientRect, UINT nAdjustType = adjustBorder);

// Implementation
public:
	virtual ~CDockSite();

protected:
	//{{AFX_MSG(CDockSite)
	afx_msg void OnPaint();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnNcDestroy();
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	CDockingPanesRow* RowFromPoint(CPoint pt, bool& bOuterRow) const;
	CDockingPanesRow* RowFromPane(CBasePane* pBar) const;
	CDockingPanesRow* FindNextVisibleRow(POSITION& pos, BOOL bForward = TRUE);
	void ResizeDockSiteByOffset(int nOffset, BOOL bAdjustLayout = TRUE);
	CDockingPanesRow* FindRowByRect(CRect rectRow);

protected:
	CObList m_lstControlBars;
	CObList m_lstDockBarRows;
	UINT    m_nDockBarID; // for compatibility with MFC
};

#pragma warning( default : 4100 34 )

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxdockingpanesrow.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CDockSite;
class CPane;

/////////////////////////////////////////////////////////////////////////////
// CDockSite window

enum AFX_ROW_ALIGNMENT
{
	AFX_ROW_ALIGN_TOP = 0,
	AFX_ROW_ALIGN_BOTTOM = 1
};

class CDockingPanesRow : public CObject
{
	DECLARE_DYNAMIC(CDockingPanesRow);

public:
	CDockingPanesRow(CDockSite* pParentDockBar, int nOffset, int nHeight);
	virtual ~CDockingPanesRow();

	virtual BOOL Create() { return TRUE; }

	virtual void GetAvailableSpace(CRect& rect);
	virtual int  GetVisibleCount();

	virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);

	virtual void AddPane(CPane* pControlBar, AFX_DOCK_METHOD dockMethod, LPCRECT lpRect = NULL, BOOL bAddLast = FALSE);
	virtual void AddPaneFromRow(CPane* pControlBar, AFX_DOCK_METHOD dockMethod);
	virtual void RemovePane(CPane* pControlBar);

	virtual void ArrangePanes(int nMargin, int nSpacing);

	virtual int  ResizeByPaneDivider(int /*nOffset*/) { return 0; } // can'te be resized by slider
	virtual int  Resize(int nOffset);
	virtual void Move(int nOffset);

	virtual void ArrangePanes(CPane* pInitialBar);
	virtual void RepositionPanes(CRect& rectNewParentBarArea, UINT nSide = (UINT)-1, BOOL bExpand = FALSE, int nOffset = 0);
	virtual BOOL IsEmpty() const { return m_lstControlBars.IsEmpty(); }

	virtual void UpdateVisibleState(BOOL bDelay);
	virtual void ShowDockSiteRow(BOOL bShow, BOOL bDelay);
	
	void MovePane(CPane* pControlBar, CPoint ptOffset, BOOL bSwapControlBars, HDWP& hdwp);
	void MovePane(CPane* pControlBar, CRect rectTarget, HDWP& hdwp);
	void MovePane(CPane* pControlBar, int nOffset, bool bForward, HDWP& hdwp);
	void MovePane(CPane* pControlBar, int nAbsolutOffset, HDWP& hdwp);
	void RedrawAll();

	BOOL HasPane(CBasePane* pControlBar) { return m_lstControlBars.Find(pControlBar) != NULL; }

	virtual BOOL ReplacePane(CPane* pBarOld, CPane* pBarNew);
	virtual BOOL ShowPane(CPane* pControlBar, BOOL bShow, BOOL bDelay = FALSE);

	virtual void OnResizePane(CBasePane* pControlBar);

	void FixupVirtualRects(bool bMoveBackToVirtualRect, CPane* pBarToExclude = NULL);
	void ExpandStretchedPanes();
	void ExpandStretchedPanesRect();

	virtual BOOL IsVisible() const { return m_bVisible ;}

	int GetRowHeight() const { return m_nRowHeight; }
	int GetRowOffset() const { return m_nRowOffset; }

	int GetPaneCount() const { return (int) m_lstControlBars.GetCount(); }
	void GetWindowRect(CRect& rect) const;
	void GetClientRect(CRect& rect) const;
	void ScreenToClient(CRect& rect) const;

	bool IsHorizontal() const { return (m_dwRowAlignment & CBRS_ALIGN_TOP || m_dwRowAlignment & CBRS_ALIGN_BOTTOM); }

	DWORD GetRowAlignment() const { return m_dwRowAlignment; }
	int GetID() const { return 0; }
	CDockSite* GetDockSite() const { return m_pParentDockBar; }
	const CObList& GetPaneList() const { return m_lstControlBars; }

	virtual int GetAvailableLength(BOOL bUseVirtualRect = FALSE) const;

	void SetExtra(int nExtraSpace, AFX_ROW_ALIGNMENT rowExtraAlign)
	{
		m_nExtraSpace = nExtraSpace;
		m_nExtraAlignment = rowExtraAlign;
	}
	int GetExtraSpace() const { return m_nExtraSpace; }

	// exclusive row does not allows more than one bar that does allow sibling bars
	virtual BOOL IsExclusiveRow() const;

	void GetGroupFromPane(CPane* pBar, CObList& lst);
	int  GetMaxPaneSize(BOOL bSkipHiddenBars = TRUE) const;

	BOOL m_bIgnoreBarVisibility;

protected:
	BOOL m_bVisible;
	int  m_nRowHeight;
	int  m_nRowSavedHeight;
	int  m_nMinHeight;
	int  m_nRowOffset;
	int  m_nExtraSpace; // specifies how the row is bigger than its bars
	int  m_nExtraAlignment; // how the bars are aligned if extra space
	CObList         m_lstControlBars;
	DWORD           m_dwRowAlignment;
	CDockSite* m_pParentDockBar;

	BOOL CheckPanes(CRect& rectCurrentBar, CPane* pCurrentBar, bool bForward, CPoint ptOffset, BOOL bSwapControlBars, HDWP& hdwp);
	CPane* FindFirstVisiblePane(BOOL bForward);

protected:
	virtual void OnInsertPane(CPane* pControlBar);
	void AdjustPaneToRowArea(CPane* pBar, const CRect& rectRow, HDWP& hdwp);
	int CalcLastPaneOffset();

	void BeginTrans();
	void CommitTrans();
	int GetAvailableLengthRect();
	int StretchPaneRect(CPane* pBar, int nStretchSize);
	void ArrangePanesRect(CPane* pInitialBar);
	void ResolveIntersectionRect(CPane* pBar, bool bForward);
	int GetOutOfBoundsOffsetRect(CPane* pBar, BOOL bLeftTopBound);
	void ShiftPanesRect(CPane* pControlBar, int nOffset, BOOL bForward);
	void MovePaneRect(CPane* pControlBar, int nOffset, bool bForward);
	
private:
	void OffsetFromRect(const CRect& rect, CPoint& pt, bool bForward);
	BOOL IsEnoughSpaceToMove(CPane* pControlBar, bool bForward, int& nAllowedOffset);
	void MoveTrailingPanes(POSITION posStart, CPoint ptOffset, bool bForward, CPane* pBarToSkip, HDWP& hdwp);
	void ResolveIntersection(CPane* pBar, bool bForward, HDWP& hdwp);
	int  GetOutOfBoundsOffset(CPane* pBar, BOOL bLeftTopBound);
	void ShiftPanes(CPane* pControlBar, int nOffset, BOOL bForward);
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxdragframeimpl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CDockingManager;
class CPane;
class CDockablePane;
class CBaseTabbedPane;

class CMFCDragFrameImpl
{
public:
	CMFCDragFrameImpl();
	virtual ~CMFCDragFrameImpl();

	void Init(CWnd* pDraggedWnd);
	void MoveDragFrame(BOOL bForceMove = FALSE); 
	void EndDrawDragFrame(BOOL bClearInternalRects = TRUE);

	void PlaceTabPreDocking(CBaseTabbedPane* pTabbedBar, BOOL bFirstTime);
	void PlaceTabPreDocking(CWnd* pCBarToPlaceOn);
	void RemoveTabPreDocking(CDockablePane* pOldTargetBar = NULL);

	CPoint  m_ptHot;
	CRect   m_rectDrag;
	CRect   m_rectExpectedDocked;
	BOOL    m_bDockToTab;
	BOOL    m_bDragStarted;
	int     m_nInsertedTabID;

	CDockablePane* m_pFinalTargetBar;
	CDockablePane* m_pOldTargetBar;

	void ResetState();

protected:
	void DrawDragFrame(LPCRECT lpRectOld, LPCRECT lpRectNew, BOOL bFirstTime = FALSE, int nNewThickness = 4, int nOldThickness = 4);
	void DrawFrameTab(CDockablePane* pTargetBar, BOOL bErase);

	int                 m_nOldThickness;
	CWnd*               m_pDraggedWnd;
	CDockingManager*       m_pDockManager;
	CDockablePane* m_pTargetBar;
	CDockablePane* m_pWndDummy;
	BOOL                m_bFrameTabDrawn;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxdocob.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXDOCOB_H__
#define __AFXDOCOB_H__

#pragma once

// these error codes are needed by MFC's IPrint implementation
// but aren't available in the SDK headers.  Someday, these #define's
// can be removed.

#ifndef PRINT_E_CANCELLED
#define PRINT_E_CANCELLED 0x80040160L
#endif
#ifndef PRINT_E_NOSUCHPAGE
#define PRINT_E_NOSUCHPAGE 0x80040161L
#endif

#ifdef _AFX_NO_OLE_SUPPORT
	#error OLE classes not supported in this library variant.
#endif

#ifndef __AFXOLE_H__
	#include <afxole.h>
#endif

#ifndef __docobj_h__
	#include <docobj.h>     // defines Document Object interfaces
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

// AFXDLL support
#undef AFX_DATA
#define AFX_DATA AFX_OLE_DATA


/////////////////////////////////////////////////////////////////////////////
// AFXDOCOB.H - MFC OLE Document Object support

//CCmdUI
class COleCmdUI;

//CCmdTarg
class CDocObjectServer;

//COleIPFrameWnd
class COleDocIPFrameWnd;


/////////////////////////////////////////////////////////////////////////////
// COleCmdUI

class COleCmdUI : public CCmdUI
{
public:
	COleCmdUI(OLECMD* rgCmds, ULONG cCmds, const GUID* m_pGroup);
	virtual ~COleCmdUI() {}
	virtual void Enable(BOOL bOn);
	virtual void SetCheck(int nCheck);
	virtual void SetText(LPCTSTR lpszText);
	virtual BOOL DoUpdate(CCmdTarget* pTarget, BOOL bDisableIfNoHandler);
	DWORD m_nCmdTextFlag;

protected:
	OLECMD* m_rgCmds;
	const GUID* m_pguidCmdGroup;
public:
	CString m_strText;

	friend class CCmdTarget;
};


#define ON_OLECMD(pguid, olecmdid, id) \
	{ pguid, (ULONG)olecmdid, (UINT)id },

#define ON_OLECMD_OPEN() \
	ON_OLECMD(NULL, OLECMDID_OPEN, ID_FILE_OPEN)

#define ON_OLECMD_NEW() \
	ON_OLECMD(NULL, OLECMDID_NEW, ID_FILE_NEW)

#define ON_OLECMD_SAVE() \
	ON_OLECMD(NULL, OLECMDID_SAVE, ID_FILE_SAVE)

#define ON_OLECMD_SAVE_AS() \
	ON_OLECMD(NULL, OLECMDID_SAVEAS, ID_FILE_SAVE_AS)

#define ON_OLECMD_SAVE_COPY_AS() \
	ON_OLECMD(NULL, OLECMDID_SAVECOPYAS, ID_FILE_SAVE_COPY_AS)

#define ON_OLECMD_PRINT() \
	ON_OLECMD(NULL, OLECMDID_PRINT, ID_FILE_PRINT)

#define ON_OLECMD_PRINTPREVIEW() \
	ON_OLECMD(NULL, OLECMDID_PRINTPREVIEW, ID_FILE_PRINT_PREVIEW)

#define ON_OLECMD_PAGESETUP() \
	ON_OLECMD(NULL, OLECMDID_PAGESETUP, ID_FILE_PAGE_SETUP)

#define ON_OLECMD_CUT() \
	ON_OLECMD(NULL, OLECMDID_CUT, ID_EDIT_CUT)

#define ON_OLECMD_COPY() \
	ON_OLECMD(NULL, OLECMDID_COPY, ID_EDIT_COPY)

#define ON_OLECMD_PASTE() \
	ON_OLECMD(NULL, OLECMDID_PASTE, ID_EDIT_PASTE)

#define ON_OLECMD_PASTESPECIAL() \
	ON_OLECMD(NULL, OLECMDID_PASTESPECIAL, ID_EDIT_PASTE_SPECIAL)

#define ON_OLECMD_UNDO() \
	ON_OLECMD(NULL, OLECMDID_UNDO, ID_EDIT_UNDO)

#define ON_OLECMD_REDO() \
	ON_OLECMD(NULL, OLECMDID_REDO, ID_EDIT_REDO)

#define ON_OLECMD_SELECTALL() \
	ON_OLECMD(NULL, OLECMDID_SELECTALL, ID_EDIT_SELECT_ALL)

#define ON_OLECMD_CLEARSELECTION() \
	ON_OLECMD(NULL, OLECMDID_CLEARSELECTION, ID_EDIT_CLEAR)


/////////////////////////////////////////////////////////////////////////////
// CDocObjectServer class

class CDocObjectServer : public CCmdTarget
{
	DECLARE_DYNAMIC(CDocObjectServer)

// Constructors
public:
	explicit CDocObjectServer(COleServerDoc* pOwner,
			LPOLEDOCUMENTSITE pDocSite = NULL);

// Attributes
public:

// Operations
public:
   void ActivateDocObject();

// Overridables
protected:
   // Document Overridables

   // View Overridables
   virtual void OnApplyViewState(CArchive& ar);
   virtual void OnSaveViewState(CArchive& ar);
   virtual HRESULT OnActivateView();

// Implementation
public:
	virtual ~CDocObjectServer();
	void ReleaseDocSite();
	void SetDocSite(LPOLEDOCUMENTSITE pNewSite);
	COleDocIPFrameWnd* GetControllingFrame() const;
protected:
	STDMETHODIMP OnExecOleCmd(const GUID* pguidCmdGroup,
		DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG* pvarargIn,
		VARIANTARG* pvarargOut);
	BOOL DoPreparePrinting(CView* pView, CPrintInfo* printInfo);
	void DoPrepareDC(CView* pView, CDC* pdcPrint, CPrintInfo* pprintInfo);
	void DoPrint(CView* pView, CDC* pdcPrint, CPrintInfo* pprintInfo);
	void DoBeginPrinting(CView* pView, CDC* pDC, CPrintInfo* pprintInfo);
	void DoEndPrinting(CView* pView, CDC* pDC, CPrintInfo* pprintInfo);

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

   // Overrides
protected:
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDocObjectServer)
	public:
	virtual void OnCloseDocument();
	//}}AFX_VIRTUAL

	// Implementation Data
protected:
	// Document Data
	LPOLEDOCUMENTSITE m_pDocSite;
	COleServerDoc* m_pOwner;

	// Print Data
	LONG m_nFirstPage;
	LPCONTINUECALLBACK m_pContinueCallback;

	// View Data
	LPOLEINPLACESITE  m_pViewSite;

   // Implementation Helpers
protected:
	void OnSetItemRects(LPRECT lprcPosRect, LPRECT lprcClipRect);
//  LPUNKNOWN GetInterfaceHook(const void* iid);

	// Generated message map functions
protected:
	//{{AFX_MSG(CDocObjectServer)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Interface Maps
public:
	BEGIN_INTERFACE_PART(OleObject, IOleObject)
		INIT_INTERFACE_PART(CDocObjServerDoc, DocOleObject)
		STDMETHOD(SetClientSite)(LPOLECLIENTSITE);
		STDMETHOD(GetClientSite)(LPOLECLIENTSITE*);
		STDMETHOD(SetHostNames)(LPCOLESTR, LPCOLESTR);
		STDMETHOD(Close)(DWORD);
		STDMETHOD(SetMoniker)(DWORD, LPMONIKER);
		STDMETHOD(GetMoniker)(DWORD, DWORD, LPMONIKER*);
		STDMETHOD(InitFromData)(LPDATAOBJECT, BOOL, DWORD);
		STDMETHOD(GetClipboardData)(DWORD, LPDATAOBJECT*);
		STDMETHOD(DoVerb)(LONG, LPMSG, LPOLECLIENTSITE, LONG, HWND, LPCRECT);
		STDMETHOD(EnumVerbs)(IEnumOLEVERB**);
		STDMETHOD(Update)();
		STDMETHOD(IsUpToDate)();
		STDMETHOD(GetUserClassID)(CLSID*);
		STDMETHOD(GetUserType)(DWORD, LPOLESTR*);
		STDMETHOD(SetExtent)(DWORD, LPSIZEL);
		STDMETHOD(GetExtent)(DWORD, LPSIZEL);
		STDMETHOD(Advise)(LPADVISESINK, LPDWORD);
		STDMETHOD(Unadvise)(DWORD);
		STDMETHOD(EnumAdvise)(LPENUMSTATDATA*);
		STDMETHOD(GetMiscStatus)(DWORD, LPDWORD);
		STDMETHOD(SetColorScheme)(LPLOGPALETTE);
	END_INTERFACE_PART(OleObject)

	BEGIN_INTERFACE_PART(OleDocument, IOleDocument)
		INIT_INTERFACE_PART(CDocObjectServer, OleDocument)
		STDMETHOD(CreateView)(LPOLEINPLACESITE, LPSTREAM, DWORD, LPOLEDOCUMENTVIEW*);
		STDMETHOD(GetDocMiscStatus)(LPDWORD);
		STDMETHOD(EnumViews)(LPENUMOLEDOCUMENTVIEWS*, LPOLEDOCUMENTVIEW*);
	END_INTERFACE_PART(OleDocument)

	BEGIN_INTERFACE_PART(OleDocumentView, IOleDocumentView)
		INIT_INTERFACE_PART(CDocObjectServer, OleDocumentView)
		STDMETHOD(SetInPlaceSite)(LPOLEINPLACESITE);
		STDMETHOD(GetInPlaceSite)(LPOLEINPLACESITE*);
		STDMETHOD(GetDocument)(LPUNKNOWN*);
		STDMETHOD(SetRect)(LPRECT);
		STDMETHOD(GetRect)(LPRECT);
		STDMETHOD(SetRectComplex)(LPRECT, LPRECT, LPRECT, LPRECT);
		STDMETHOD(Show)(BOOL);
		STDMETHOD(UIActivate)(BOOL);
		STDMETHOD(Open)();
		STDMETHOD(CloseView)(DWORD);
		STDMETHOD(SaveViewState)(LPSTREAM);
		STDMETHOD(ApplyViewState)(LPSTREAM);
		STDMETHOD(Clone)(LPOLEINPLACESITE, LPOLEDOCUMENTVIEW*);
	END_INTERFACE_PART(OleDocumentView)

	BEGIN_INTERFACE_PART(OleCommandTarget, IOleCommandTarget)
		INIT_INTERFACE_PART(CDocObjectServer, OleCommandTarget)
		STDMETHOD(QueryStatus)(const GUID*, ULONG, OLECMD[], OLECMDTEXT*);
		STDMETHOD(Exec)(const GUID*, DWORD, DWORD, VARIANTARG*, VARIANTARG*);
	END_INTERFACE_PART(OleCommandTarget)

	BEGIN_INTERFACE_PART(Print, IPrint)
		INIT_INTERFACE_PART(CDocObjectServer, Print)
		STDMETHOD(SetInitialPageNum)(LONG);
		STDMETHOD(GetPageInfo)(LPLONG, LPLONG);
		STDMETHOD(Print)(DWORD, DVTARGETDEVICE**, PAGESET**, LPSTGMEDIUM,
				 LPCONTINUECALLBACK, LONG, LPLONG, LPLONG);
	END_INTERFACE_PART(Print)

	DECLARE_INTERFACE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// COleDocIPFrameWnd class

class COleDocIPFrameWnd : public COleIPFrameWnd
{
	DECLARE_DYNCREATE(COleDocIPFrameWnd)

// Constructors
public:
	COleDocIPFrameWnd();

// Attributes
public:

// Operations
public:

// Overridables
protected:

// Implementation
public:
	virtual ~COleDocIPFrameWnd();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(COleDocIPFrameWnd)
	//}}AFX_VIRTUAL
protected:
	virtual void OnRequestPositionChange(LPCRECT lpRect);
	virtual void RecalcLayout(BOOL bNotify = TRUE);

	// Menu Merging support
	virtual BOOL BuildSharedMenu();
	virtual void DestroySharedMenu();

	// Generated message map functions
	//{{AFX_MSG(COleDocIPFrameWnd)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


class CDocObjectServerItem : public COleServerItem
{
	DECLARE_DYNAMIC(CDocObjectServerItem)

// Constructors
protected:
	CDocObjectServerItem(COleServerDoc* pServerDoc, BOOL bAutoDelete);

// Attributes
public:
	COleServerDoc* GetDocument() const
		{ return (COleServerDoc*) COleServerItem::GetDocument(); }

// Overridables
public:

// Implementation
public:
	virtual ~CDocObjectServerItem();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

   // Overrides
protected:
   virtual void OnDoVerb(LONG iVerb);
   virtual void OnHide();
   virtual void OnShow();
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDocObjectServerItem)
	//}}AFX_VIRTUAL

};

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXDOCOB_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxdrawmanager.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CDrawingManager : public CObject
{
public:
	CDrawingManager(CDC& dc);
	virtual ~CDrawingManager();

// Operations:
	BOOL DrawShadow(CRect rect,					// Shadow will be draw around this rect
					int nDepth,						// Shadow depth (pixels)
					int iMinBrightness = 100,		// Min. brighttness
					int iMaxBrightness = 50,		// Max. beightness
					CBitmap* pBmpSaveBottom = NULL,	// Bitmap may be saved in 
					CBitmap* pBmpSaveRight = NULL,	// two bitmaps
					COLORREF clrBase =(COLORREF)-1,	// Base color
					BOOL bRightShadow = TRUE);		// Shadow on right side

	BOOL HighlightRect(CRect rect,					// Rectangle to be highlighted
						int nPercentage = -1,		// < 100 - darker, > 100 - lighter, -1 - default light
						COLORREF clrTransparent = (COLORREF)-1,	// Don't change this color
						int nTolerance = 0, COLORREF clrBlend = (COLORREF)-1);

	void FillGradient(CRect rect, COLORREF colorStart, COLORREF colorFinish,
		BOOL bHorz = TRUE, int nStartFlatPercentage = 0, int nEndFlatPercentage = 0);

	void FillGradient2(CRect rect, COLORREF colorStart, COLORREF colorFinish, 
						int nAngle = 0 /* 0 - 360 */);

	void Fill4ColorsGradient(CRect rect, 
						COLORREF colorStart1, COLORREF colorFinish1, 
						COLORREF colorStart2, COLORREF colorFinish2,
						BOOL bHorz = TRUE,
						int nPercentage = 50);	/* 0 - 100 */

	void FillAlpha(const CRect& rect, BYTE bValue = 255);

	BOOL GrayRect(CRect rect,					// Rectangle to be grayed
				int nPercentage = -1,		// < 100 - darker, > 100 - lighter, -1 - default light
				COLORREF clrTransparent = (COLORREF)-1,	// Don't change this color
				COLORREF clrDisabled = (COLORREF)-1);		// Use this color for desaturation

	void MirrorRect(CRect rect, BOOL bHorz = TRUE);

	BOOL DrawGradientRing(CRect rect, COLORREF colorStart, COLORREF colorFinish, COLORREF colorBorder, int nAngle /* 0 - 360 */,
				int nWidth, COLORREF clrFace = (COLORREF) -1);

	void DrawLine(int x1, int y1, int x2, int y2, COLORREF clrLine);
	void DrawLineA(double x1, double y1, double x2, double y2, COLORREF clrLine);
	void DrawEllipse(const CRect& rect, COLORREF clrFill, COLORREF clrLine);
	void DrawRect(const CRect& rect, COLORREF clrFill, COLORREF clrLine);
	void DrawAlpha(CDC* pDstDC, const CRect& rectDst, CDC* pSrcDC, const CRect& rectSrc);

	/// <summary>
	/// Rotates a source DC content inside the given rectangle by +/- 90 degrees</summary>
	/// <param name="rectDest">Destination rectangle</param>
	/// <param name="dcSrc">The source device content.</param>
	/// <param name="bClockWise">TRUE - rotate +90 degrees, FALSE - 90.</param>
	void DrawRotated(CRect rectDest, CDC& dcSrc, BOOL bClockWise);

// Helpers:
	static COLORREF __stdcall PixelAlpha(COLORREF srcPixel, int percent);
	static COLORREF __stdcall PixelAlpha(COLORREF srcPixel, double percentR, double percentG, double percentB);
	static COLORREF __stdcall PixelAlpha(COLORREF srcPixel, COLORREF dstPixel, int percent);
	static void __stdcall SetAlphaPixel(COLORREF* pBits, CRect rect, int x, int y, int percent, int iShadowSize, COLORREF clrBase = (COLORREF)-1, BOOL bIsRight = TRUE);
	static void __stdcall SetPixel(COLORREF* pBits, int cx, int cy, int x, int y, COLORREF color);

// Conversion between the HSL (Hue, Saturation, and Luminosity) and RGB:
	static double __stdcall HuetoRGB(double m1, double m2, double h);
	static BYTE __stdcall HueToRGB(float rm1, float rm2, float rh);
	static COLORREF __stdcall HLStoRGB_ONE(double H, double L, double S);
	static COLORREF __stdcall HLStoRGB_TWO(double H, double L, double S);
	static void __stdcall RGBtoHSL(COLORREF rgb, double *H, double *S, double *L);

// Conversion between the HSV (Hue/Saturation/Value) and RGB:
	static void __stdcall RGBtoHSV(COLORREF rgb, double *H, double *S, double *V);
	static COLORREF __stdcall HSVtoRGB(double H, double S, double V);

	static COLORREF __stdcall SmartMixColors(COLORREF color1, COLORREF color2, double dblLumRatio = 1., int k1 = 1, int k2 = 1);

	/// <summary> Creates an empty 32 bit bitmap.</summary>
	/// <returns> A handle to created bitmap, or NULL, if creation fails.</returns>
	/// <param name="size">Specifies bitmap size.</param>
	/// <param name="pBits">When the function returns contains a pointer to bitmap bits.</param>
	static HBITMAP __stdcall CreateBitmap_32(const CSize& size, void** pBits);

	/// <summary> Creates a 32 bit bitmap from the specified bitmap.</summary>
	/// <returns> A handle to created bitmap, or NULL, if creation fails.</returns>
	/// <param name="bitmap"> A handle to the original bitmap.</param>
	/// <param name="clrTransparent"> An RGB value specifying transparent color of the original bitmap.</param>
	static HBITMAP __stdcall CreateBitmap_32(HBITMAP bitmap, COLORREF clrTransparent = -1);

	static HBITMAP __stdcall PrepareShadowMask(int nDepth, COLORREF clrBase, int iMinBrightness = 0, int iMaxBrightness = 100);


protected:
	void _FillGradient(CRect rect, COLORREF colorStart, COLORREF colorFinish, BOOL bHorz = TRUE, int nStartFlatPercentage = 0, int nEndFlatPercentage = 0);

// Attributes:
protected:
	CDC& m_dc;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxdropdownlistbox.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxpopupmenu.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCRibbonComboBox;

/////////////////////////////////////////////////////////////////////////////
// CMFCDropDownListBox window

class CMFCDropDownListBox : public CMFCPopupMenu
{
	DECLARE_DYNAMIC(CMFCDropDownListBox)

// Construction
public:
	CMFCDropDownListBox();
	CMFCDropDownListBox(CWnd* pEditCtrl);
	CMFCDropDownListBox(CMFCRibbonComboBox* pRibbonCombo);

protected:
	void CommonInit();

// Attributes
public:
	void SetMaxHeight(int nMaxHeight) { m_nMaxHeight = nMaxHeight; }
	void SetMinWidth(int nMinWidth) { m_nMinWidth = nMinWidth; }

	int GetCount() const;

	int GetCurSel();
	int SetCurSel(int nSelect);

	// for listbox items
	void GetText(int nIndex, CString& rString) const;

	BOOL IsEditFocused() const { return m_pEditCtrl->GetSafeHwnd() == ::GetFocus(); }

// Operations
public:
	// manipulating listbox items
	void AddString(LPCTSTR lpszItem);
	void ResetContent();

	void Track(CPoint point, CWnd *pWndOwner = NULL);

// Overrides
	virtual void OnDrawItem(CDC* pDC, CMFCToolBarMenuButton* pItem, BOOL bHighlight);
	virtual CSize OnGetItemSize(CDC* pDC, CMFCToolBarMenuButton* pItem, CSize sizeDefault);
	virtual void OnChooseItem(UINT uidCmdID);
	virtual void OnChangeHot(int nHot);
	virtual BOOL DefaultMouseClickOnClose() const { return m_pRibbonCombo == NULL; }

// Implementation
public:
	virtual ~CMFCDropDownListBox();

protected:
	//{{AFX_MSG(CMFCDropDownListBox)
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void HighlightItem(int nIndex);
	CMFCToolBarButton* GetItem(int nIndex) const;

	CMenu m_Menu;
	int   m_nCurSel;
	int   m_nMinWidth;
	CWnd* m_pEditCtrl;
	CMFCRibbonComboBox* m_pRibbonCombo;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxdropdowntoolbar.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxpopupmenubar.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCDropDownToolbarButton;
class CMFCMenuBar;
class CMFCToolBarMenuButton;

class CMFCDropDownToolBar : public CMFCToolBar
{
	friend class CMFCDropDownToolbarButton;
	friend class CMFCDropDownFrame;

	DECLARE_SERIAL(CMFCDropDownToolBar)

public:
	CMFCDropDownToolBar() { m_bLocked = TRUE; }
	virtual ~CMFCDropDownToolBar() {}

	virtual BOOL OnSendCommand(const CMFCToolBarButton* pButton);

	virtual BOOL LoadBitmap(UINT uiResID, UINT uiColdResID = 0, UINT uiMenuResID = 0, BOOL /*bLocked*/ = FALSE, UINT uiDisabledResID = 0, UINT uiMenuDisabledResID = 0)
	{
		return CMFCToolBar::LoadBitmap(uiResID, uiColdResID, uiMenuResID, TRUE /* Locked */, uiDisabledResID, uiMenuDisabledResID);
	}

	virtual BOOL LoadToolBar(UINT uiResID, UINT uiColdResID = 0, UINT uiMenuResID = 0, BOOL /*bLocked*/ = FALSE, UINT uiDisabledResID = 0, UINT uiMenuDisabledResID = 0, UINT uiHotResID = 0)
	{
		return CMFCToolBar::LoadToolBar(uiResID, uiColdResID, uiMenuResID, /*bLocked*/ TRUE, uiDisabledResID, uiMenuDisabledResID, uiHotResID);
	}

	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);
	virtual BOOL AllowShowOnPaneMenu() const { return FALSE; }

	//{{AFX_MSG(CMFCDropDownToolBar)
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CMFCDropDownFrame frame

class CMFCDropDownFrame : public CMiniFrameWnd
{
	friend CMFCDropDownToolbarButton;
	friend CMFCDropDownToolBar;

	DECLARE_SERIAL(CMFCDropDownFrame)

public:
	CMFCDropDownFrame();
	virtual ~CMFCDropDownFrame();

// Attributes
public:
	BOOL m_bAutoDestroyParent;

	void SetAutoDestroy(BOOL bAutoDestroy = TRUE) { m_bAutoDestroy = bAutoDestroy; }

protected:
	CMFCDropDownToolbarButton* m_pParentBtn;
	CMFCDropDownToolBar        m_wndToolBar;
	CMFCDropDownToolBar*       m_pWndOriginToolbar;

	int  m_x;
	int  m_y;
	BOOL m_bAutoDestroy;
	CString m_strCaption;

protected:
	AFX_IMPORT_DATA static CString m_strClassName;

// Operations
public:
	CMFCDropDownFrame* GetParentPopupMenu() const;
	CMFCMenuBar* GetParentMenuBar() const;

// Overrides
public:
	virtual BOOL Create(CWnd* pWndParent, int x, int y, CMFCDropDownToolBar* pWndOriginToolbar);
	virtual void RecalcLayout(BOOL bNotify = TRUE);

protected:
	virtual void PostNcDestroy();

// Implementation
protected:
	//{{AFX_MSG(CMFCDropDownFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnPaint();
	afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
	afx_msg void OnDestroy();
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnActivateApp(BOOL bActive, DWORD dwThreadID);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class CMFCDropDownToolbarButton : public CMFCToolBarButton
{
	friend class CMFCDropDownFrame;

	DECLARE_SERIAL(CMFCDropDownToolbarButton)

public:
	CMFCDropDownToolbarButton();
	CMFCDropDownToolbarButton(LPCTSTR lpszName, CMFCDropDownToolBar* pToolBar);
	virtual ~CMFCDropDownToolbarButton();

// Overrides:
public:
	virtual void CopyFrom(const CMFCToolBarButton& src);
	virtual void Serialize(CArchive& ar);
	virtual void OnDraw(CDC* pDC, const CRect& rect, CMFCToolBarImages* pImages, BOOL bHorz = TRUE, BOOL bCustomizeMode = FALSE,
		BOOL bHighlight = FALSE, BOOL bDrawBorder = TRUE, BOOL bGrayDisabledButtons = TRUE);
	virtual BOOL OnClick(CWnd* pWnd, BOOL bDelay = TRUE);
	virtual BOOL OnClickUp();
	virtual void OnChangeParentWnd(CWnd* pWndParent);
	virtual void OnCancelMode();
	virtual BOOL OnContextHelp(CWnd* pWnd) { return OnClick(pWnd, FALSE); }

	virtual int OnDrawOnCustomizeList(CDC* pDC, const CRect& rect, BOOL bSelected);
	virtual SIZE OnCalculateSize(CDC* pDC, const CSize& sizeDefault, BOOL bHorz);
	virtual BOOL ExportToMenuButton(CMFCToolBarMenuButton& menuButton) const;

	void SetDefaultCommand(UINT uiCmd);
	BOOL DropDownToolbar(CWnd* pWnd);

	virtual BOOL IsExtraSize() const { return m_bExtraSize && !m_bInternalDraw; }
	virtual BOOL OnCustomizeMenu(CMenu* pMenu);

// Attributes:
public:
	BOOL IsDropDown() const { return m_pPopupMenu != NULL; }
	CMFCToolBar* GetDropDownToolBar() const { return m_pToolBar; }

	AFX_IMPORT_DATA static UINT m_uiShowBarDelay;

protected:
	CMFCDropDownToolBar* m_pToolBar;
	CString           m_strName;
	CMFCDropDownFrame*   m_pPopupMenu;

	UINT m_uiTimer;
	int  m_iSelectedImage;
	BOOL m_bInternalDraw;
	BOOL m_bLocalUserButton;

#ifdef _DEBUG

// diagnostics:
public:
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;

#endif
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxeditbrowsectrl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCEditBrowseCtrl window

class CMFCEditBrowseCtrl : public CEdit
{
// Construction
public:
	CMFCEditBrowseCtrl();

// Attributes
public:
	enum BrowseMode
	{
		BrowseMode_None,
		BrowseMode_Default,
		BrowseMode_File,
		BrowseMode_Folder,
	};

	CMFCEditBrowseCtrl::BrowseMode GetMode() const { return m_Mode; }

protected:
	int  m_nBrowseButtonWidth;
	BOOL m_bIsButtonPressed;
	BOOL m_bIsButtonHighlighted;
	BOOL m_bIsButtonCaptured;
	BOOL m_bDefaultImage;

	CRect   m_rectBtn;
	CSize   m_sizeImage;
	CString m_strLabel;
	CString m_strDefFileExt;
	CString m_strFileFilter;

	BrowseMode m_Mode;
	CImageList m_ImageBrowse;

// Operations
public:
	void EnableBrowseButton(BOOL bEnable = TRUE, LPCTSTR szLabel = _T("..."));
	void EnableFileBrowseButton(LPCTSTR lpszDefExt = NULL, LPCTSTR lpszFilter = NULL);
	void EnableFolderBrowseButton();

	void SetBrowseButtonImage(HICON hIcon, BOOL bAutoDestroy = TRUE);
	void SetBrowseButtonImage(HBITMAP hBitmap, BOOL bAutoDestroy = TRUE);
	void SetBrowseButtonImage(UINT uiBmpResId);

// Overrides
public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual void OnBrowse();
	virtual void OnDrawBrowseButton(CDC* pDC, CRect rect, BOOL bIsButtonPressed, BOOL bIsButtonHot);
	virtual void OnChangeLayout();
	virtual void OnAfterUpdate();
	/// <summary>
	/// Called by the framework when an illegal file name was entered in the edit control.</summary>
	/// <param name="strFileName">Specifies the illegal file name.</param>
	/// <returns> Should return FALSE if this file name can't be passed further to the file dialog. In this case a focus set back to the edit control
	/// and the user should continue editing. The default implementation displays a message box telling the user about illegal file name and returns FALSE.
	/// You can override this method, correct the file name and return TRUE for further processing.</returns>
	virtual BOOL OnIllegalFileName(CString& strFileName);

// Implementation
public:
	virtual ~CMFCEditBrowseCtrl();

protected:
	//{{AFX_MSG(CMFCEditBrowseCtrl)
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp);
	afx_msg void OnNcPaint();
	afx_msg void OnNcLButtonDblClk(UINT nHitTest, CPoint point);
	afx_msg void OnNcMouseMove(UINT nHitTest, CPoint point);
	afx_msg void OnCancelMode();
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	afx_msg LRESULT OnNcHitTest(CPoint point);
	afx_msg LRESULT OnInitControl(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

	void SetInternalImage();
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxdtctl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXDTCTL_H__
#define __AFXDTCTL_H__

#pragma once

#ifndef __AFXWIN_H__
	#include <afxwin.h>
#endif

#ifndef __AFXDISP_H__
	#include <afxdisp.h>
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

//CObject
	//CCmdTarget;
		//CWnd
			class CMonthCalCtrl;
			class CDateTimeCtrl;

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

/////////////////////////////////////////////////////////////////////////////
// CDateTimeCtrl

class CDateTimeCtrl : public CWnd
{
	DECLARE_DYNAMIC(CDateTimeCtrl)

public:
// Constructors
	CDateTimeCtrl();
	virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);

// Attributes
	// Retrieves the color for the specified portion of the calendar within the datetime picker control.
	COLORREF GetMonthCalColor(_In_ int iColor) const;

	// Sets the color for the specified portion of the calendar within the datetime picker control.
	COLORREF SetMonthCalColor(_In_ int iColor, _In_ COLORREF ref);

	// Sets the display of the datetime picker control based on the specified format string.
	BOOL SetFormat(_In_z_ LPCTSTR pstrFormat);

	// Retrieves the datetime picker's child calendar control.
	CMonthCalCtrl* GetMonthCalCtrl() const;

	// Retrieves the font of the datetime picker control's child calendar control.
	CFont* GetMonthCalFont() const;

	// Sets the font of the datetime picker control's child calendar control.
	void SetMonthCalFont(_In_ HFONT hFont, _In_ BOOL bRedraw = TRUE);

	// Sets the minimum and maximum allowable times for the datetime picker control.
	BOOL SetRange(_In_ const COleDateTime* pMinRange, _In_ const COleDateTime* pMaxRange);

	// Retrieves the current minimum and maximum allowable times for the datetime picker control.
	DWORD GetRange(_Out_ COleDateTime* pMinRange, _Out_ COleDateTime* pMaxRange) const;

	// Sets the minimum and maximum allowable times for the datetime picker control.
	BOOL SetRange(_In_ const CTime* pMinRange, _In_ const CTime* pMaxRange);

	// Retrieves the current minimum and maximum allowable times for the datetime picker control.
	DWORD GetRange(_Out_ CTime* pMinRange, _Out_ CTime* pMaxRange) const;

#if (NTDDI_VERSION >= NTDDI_LONGHORN) && defined(UNICODE)
	// REVIEW: Sets the style of the datetime picker control's child calendar control.
	DWORD SetMonthCalStyle(_In_ DWORD dwStyle);

	// REVIEW: Retrieves the style of the datetime picker control's child calendar control.
	DWORD GetMonthCalStyle() const;

	// Retrieves information from the datetime picker control.
	BOOL GetDateTimePickerInfo(_Out_ LPDATETIMEPICKERINFO pDateTimePickerInfo) const;

	// Retrieves the ideal size for the control (so that all the text fits).
	BOOL GetIdealSize(_Out_ LPSIZE pSize) const;
#endif // (NTDDI_VERSION >= NTDDI_LONGHORN) && defined(UNICODE)

// Operations
	// Sets the time in the datetime picker control.
	BOOL SetTime(_In_ const CTime* pTimeNew);

	// Retrieves the currently selected time from the datetime picker control.
	DWORD GetTime(_Out_ CTime& timeDest) const;

	// Sets the time in the datetime picker control.
	BOOL SetTime(_In_ const COleDateTime& timeNew);

	// Retrieves the currently selected time from the datetime picker control.
	BOOL GetTime(_Out_ COleDateTime& timeDest) const;

	// Sets the time in the datetime picker control.
	BOOL SetTime(_In_ LPSYSTEMTIME pTimeNew = NULL);

	// Retrieves the currently selected time from the datetime picker control.
	DWORD GetTime(_Out_ LPSYSTEMTIME pTimeDest) const;

#if (NTDDI_VERSION >= NTDDI_LONGHORN) && defined(UNICODE)
	// REVIEW: Closes the datetime picker control.
	void CloseMonthCal();
#endif // (NTDDI_VERSION >= NTDDI_LONGHORN) && defined(UNICODE)

// Overridables
	virtual ~CDateTimeCtrl();
};

/////////////////////////////////////////////////////////////////////////////
// CMonthCalCtrl

class CMonthCalCtrl : public CWnd
{
	DECLARE_DYNAMIC(CMonthCalCtrl)

public:
// Constructors
	CMonthCalCtrl();
	virtual BOOL Create(_In_ DWORD dwStyle, _In_ const RECT& rect, _In_ CWnd* pParentWnd, _In_ UINT nID);
	virtual BOOL Create(_In_ DWORD dwStyle, _In_ const POINT& pt, _In_ CWnd* pParentWnd, _In_ UINT nID);

//Attributes
	// Retrieves the minimum size required to display a full month in the calendar control.
	BOOL GetMinReqRect(_Out_ RECT* pRect) const;

	// Retrieves the scroll rate for the calendar control.
	int SetMonthDelta(_In_ int iDelta);

	// Sets the scroll rate for the calendar control.
	int GetMonthDelta() const;

	// Sets the first day of the week for the calendar control.
	BOOL SetFirstDayOfWeek(_In_ int iDay, _Out_ int* lpnOld = NULL);

	// Retrieves the first day of the week for the calendar control.
	int GetFirstDayOfWeek(_Out_ BOOL* pbLocal = NULL) const;

	// Retrieves the color for the specified portion of the calendar control.
	COLORREF GetColor(_In_ int nRegion) const;

	// Sets the color for the specified portion of the calendar control.
	COLORREF SetColor(_In_ int nRegion, _In_ COLORREF ref);

	// Determines which portion of the calendar control is at a given point on the screen.
	DWORD HitTest(_In_ PMCHITTESTINFO pMCHitTest);

	// Retrieves the maximum width of the "today" string in the calendar control, in pixels.
	DWORD GetMaxTodayWidth() const;

#if (NTDDI_VERSION >= NTDDI_LONGHORN) && defined(UNICODE)
	// Determines whether the calendar control is in month view.
	BOOL IsMonthView() const; // REVIEW: do we need this method?

	// Determines whether the calendar control is in year view.
	BOOL IsYearView() const; // REVIEW: do we need this method?

	// Determines whether the calendar control is in decade view.
	BOOL IsDecadeView() const; // REVIEW: do we need this method?

	// Determines whether the calendar control is in century view.
	BOOL IsCenturyView() const; // REVIEW: do we need this method?

	// REVIEW: Retrieves the current view of the calendar control.
	DWORD GetCurrentView() const;

	// REVIEW: Retrieves the number of calendars currently displayed in the calendar control.
	int GetCalendarCount() const;

	// REVIEW: Retrieves information about the calendar grid.
	BOOL GetCalendarGridInfo(_Out_ PMCGRIDINFO pmcGridInfo) const;

	// REVIEW: Retrieves the calendar ID for the calendar control.
	CALID GetCalID() const;

	// REVIEW: Sets the calendar ID for the calendar control.
	BOOL SetCalID(_In_ CALID calid);

	// Calculates how many calendars will fit in the given rectangle, and
	// returns the minimum rectangle that fits that number of calendars.
	void SizeRectToMin(_Inout_ LPRECT lpRect);

	// REVIEW: Sets the size of the calendar control border, in pixels.
	void SetCalendarBorder(_In_ int cxyBorder);

	// REVIEW: Resets the size of the calendar control border to the default.
	void SetCalendarBorderDefault();

	// REVIEW: Retrieves the size of the calendar control border, in pixels.
	int GetCalendarBorder() const;

	// Puts the calendar control in month view.
	BOOL SetMonthView(); // REVIEW: do we need this method?

	// Puts the calendar control in year view.
	BOOL SetYearView(); // REVIEW: do we need this method?

	// Puts the calendar control in decade view.
	BOOL SetDecadeView(); // REVIEW: do we need this method?

	// Puts the calendar control in century view.
	BOOL SetCenturyView(); // REVIEW: do we need this method?

	// REVIEW: Sets the current view of the calendar control.
	BOOL SetCurrentView(_In_ DWORD dwNewView);

#endif // (NTDDI_VERSION >= NTDDI_LONGHORN) && defined(UNICODE)

// Operations
	// Sizes the calendar control to the minimum size that fits a full month.
	BOOL SizeMinReq(_In_ BOOL bRepaint = TRUE);

	// Sets the "today" selection for the calendar control.
	void SetToday(_In_ const COleDateTime& refDateTime);

	// Sets the "today" selection for the calendar control.
	void SetToday(_In_ const CTime* pDateTime);

	// Sets the "today" selection for the calendar control.
	void SetToday(_In_ const LPSYSTEMTIME pDateTime);

	// Retrieves the date information for the date specified as "today" for the calendar control.
	BOOL GetToday(_Out_ CTime& refTime) const;

	// Retrieves the date information for the date specified as "today" for the calendar control.
	BOOL GetToday(_Out_ COleDateTime& refDateTime) const;

	// Retrieves the date information for the date specified as "today" for the calendar control.
	BOOL GetToday(_Out_ LPSYSTEMTIME pDateTime) const;

	// Retrieves the currently selected date in the calendar control.
	BOOL GetCurSel(_Out_ LPSYSTEMTIME pDateTime) const;

	// Sets the currently selected date in the calendar control.
	BOOL SetCurSel(_In_ const LPSYSTEMTIME pDateTime);

	// Sets the currently selected date in the calendar control.
	BOOL SetCurSel(_In_ const CTime& refDateTime);

	// Retrieves the currently selected date in the calendar control.
	BOOL GetCurSel(_Out_ CTime& refDateTime) const;

	// Sets the currently selected date in the calendar control.
	BOOL SetCurSel(_In_ const COleDateTime& refDateTime);

	// Retrieves the currently selected date in the calendar control.
	BOOL GetCurSel(_Out_ COleDateTime& refDateTime) const;

	// Sets the day states for all months that are currently visible in the calendar control.
	BOOL SetDayState(_In_ int nMonths, _In_ LPMONTHDAYSTATE pStates);

	// Sets the maximum date range that can be selected in the calendar control.
	BOOL SetMaxSelCount(_In_ int nMax);

	// Retrieves the maximum date range that can be selected in the calendar control.
	int GetMaxSelCount() const;

	// Sets the minimum and maximum allowable dates for the calendar control.
	BOOL SetRange(_In_ const COleDateTime* pMinTime, _In_ const COleDateTime* pMaxTime);

	// Retrieves the minimum and maximum allowable dates set for the calendar control.
	DWORD GetRange(_Out_ COleDateTime* pMinTime, _Out_ COleDateTime* pMaxTime) const;

	// Sets the minimum and maximum allowable dates for the calendar control.
	BOOL SetRange(_In_ const CTime* pMinTime, _In_ const CTime* pMaxTime);

	// Retrieves the minimum and maximum allowable dates set for the calendar control.
	DWORD GetRange(_Out_ CTime* pMinTime, _Out_ CTime* pMaxTime) const;

	// Sets the minimum and maximum allowable dates for the calendar control.
	BOOL SetRange(_In_ const LPSYSTEMTIME pMinRange, _In_ const LPSYSTEMTIME pMaxRange);

	// Retrieves the minimum and maximum allowable dates set for the calendar control.
	DWORD GetRange(_Out_ LPSYSTEMTIME pMinRange, _Out_ LPSYSTEMTIME pMaxRange) const;

	// Retrieves date information that represents the limits of the calendar control's display.
	int GetMonthRange(_Out_ COleDateTime& refMinRange, _Out_ COleDateTime& refMaxRange, _In_ DWORD dwFlags) const;

	// Retrieves date information that represents the limits of the calendar control's display.
	int GetMonthRange(_Out_ CTime& refMinRange, _Out_ CTime& refMaxRange, _In_ DWORD dwFlags) const;

	// Retrieves date information that represents the limits of the calendar control's display.
	int GetMonthRange(_Out_ LPSYSTEMTIME pMinRange, _Out_ LPSYSTEMTIME pMaxRange, _In_ DWORD dwFlags) const;

	// Sets the selection for the calendar control to the specified date range.
	BOOL SetSelRange(_In_ const COleDateTime& pMinRange, _In_ const COleDateTime& pMaxRange);

	// Retrieves date information that represents the date range currently selected in the calendar control.
	BOOL GetSelRange(_Out_ COleDateTime& refMinRange, _Out_ COleDateTime& refMaxRange) const;

	// Sets the selection for the calendar control to the specified date range.
	BOOL SetSelRange(_In_ const CTime& pMinRange, _In_ const CTime& pMaxRange);

	// Retrieves date information that represents the date range currently selected in the calendar control.
	BOOL GetSelRange(_Out_ CTime& refMinRange, _Out_ CTime& refMaxRange) const;

	// Retrieves date information that represents the date range currently selected in the calendar control.
	BOOL GetSelRange(_Out_ LPSYSTEMTIME pMinRange, _Out_ LPSYSTEMTIME pMaxRange) const;

	// Sets the selection for the calendar control to the specified date range.
	BOOL SetSelRange(_In_ const LPSYSTEMTIME pMinRange, _In_ const LPSYSTEMTIME pMaxRange);

// Overridables
	virtual ~CMonthCalCtrl();
};

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXDTCTL_INLINE AFX_INLINE
#include <afxdtctl.inl>
#undef _AFXDTCTL_INLINE
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXDTCTL_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxext.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXEXT.H

#pragma once

#ifdef _AFXEXT_INLINE

// CCreateContext
_AFXEXT_INLINE CCreateContext::CCreateContext()
	{ memset(this, 0, sizeof(*this)); }

// CMetaFileDC
_AFXEXT_INLINE BOOL CMetaFileDC::Create(LPCTSTR lpszFilename)
	{ return Attach(::CreateMetaFile(lpszFilename)); }
_AFXEXT_INLINE HMETAFILE CMetaFileDC::Close()
	{ return ::CloseMetaFile(Detach()); }
_AFXEXT_INLINE BOOL CMetaFileDC::CreateEnhanced(CDC* pDCRef,
		LPCTSTR lpszFileName, LPCRECT lpBounds, LPCTSTR lpszDescription)
	{ return Attach(::CreateEnhMetaFile(pDCRef->GetSafeHdc(),
		lpszFileName, lpBounds, lpszDescription)); }
_AFXEXT_INLINE HENHMETAFILE CMetaFileDC::CloseEnhanced()
	{ return ::CloseEnhMetaFile(Detach()); }
_AFXEXT_INLINE CPoint CMetaFileDC::SetViewportOrg(POINT point)
	{ ASSERT(m_hDC != NULL); return SetViewportOrg(point.x, point.y); }
_AFXEXT_INLINE CSize CMetaFileDC::SetViewportExt(SIZE size)
	{ ASSERT(m_hDC != NULL); return SetViewportExt(size.cx, size.cy); }
_AFXEXT_INLINE BOOL CMetaFileDC::TextOut(int x, int y, const CString& str)
	{ ASSERT(m_hDC != NULL); return TextOut(x, y, (LPCTSTR)str, (int)str.GetLength()); }
_AFXEXT_INLINE BOOL CMetaFileDC::ExtTextOut(int x, int y, UINT nOptions, LPCRECT lpRect,
	const CString& str, LPINT lpDxWidths)
	{ ASSERT(m_hDC != NULL); return ::ExtTextOut(m_hDC, x, y, nOptions, lpRect,
		str, (UINT)str.GetLength(), lpDxWidths); }
_AFXEXT_INLINE CSize CMetaFileDC::TabbedTextOut(int x, int y, const CString& str,
	int nTabPositions, LPINT lpnTabStopPositions, int nTabOrigin)
	{ ASSERT(m_hDC != NULL); return ::TabbedTextOut(m_hDC, x, y, str, (int)str.GetLength(),
		nTabPositions, lpnTabStopPositions, nTabOrigin); }
#pragma push_macro("DrawText")
#pragma push_macro("DrawTextEx")
#undef DrawText
#undef DrawTextEx
_AFXEXT_INLINE int CMetaFileDC::_AFX_FUNCNAME(DrawText)(const CString& str, LPRECT lpRect, UINT nFormat)
	{ ASSERT(m_hDC != NULL);
		return _AFX_FUNCNAME(DrawText)((LPCTSTR)str, (int)str.GetLength(), lpRect, nFormat); }
_AFXEXT_INLINE int CMetaFileDC::_AFX_FUNCNAME(DrawTextEx)(const CString& str, LPRECT lpRect, UINT nFormat, LPDRAWTEXTPARAMS lpDTParams)
	{ ASSERT(m_hDC != NULL);
		return _AFX_FUNCNAME(DrawTextEx)(const_cast<LPTSTR>((LPCTSTR)str), (int)str.GetLength(), lpRect, nFormat, lpDTParams); }
_AFXEXT_INLINE int CMetaFileDC::DrawText(LPCTSTR lpszString, int nCount, LPRECT lpRect, UINT nFormat)
	{ return _AFX_FUNCNAME(DrawText)(lpszString, nCount, lpRect, nFormat); }
_AFXEXT_INLINE int CMetaFileDC::DrawText(const CString& str, LPRECT lpRect, UINT nFormat)
	{ return _AFX_FUNCNAME(DrawText)(str, lpRect, nFormat); }
_AFXEXT_INLINE int CMetaFileDC::DrawTextEx(LPTSTR lpszString, int nCount, LPRECT lpRect, UINT nFormat, LPDRAWTEXTPARAMS lpDTParams)
	{ return _AFX_FUNCNAME(DrawTextEx)(lpszString, nCount, lpRect, nFormat, lpDTParams); }
_AFXEXT_INLINE int CMetaFileDC::DrawTextEx(const CString& str, LPRECT lpRect, UINT nFormat, LPDRAWTEXTPARAMS lpDTParams)
	{ return _AFX_FUNCNAME(DrawTextEx)(str, lpRect, nFormat, lpDTParams); }
#pragma pop_macro("DrawText")
#pragma pop_macro("DrawTextEx")

_AFXEXT_INLINE BOOL CMetaFileDC::PtVisible(POINT point) const
	{ ASSERT(m_hDC != NULL); return PtVisible(point.x, point.y); }

// CSplitterWnd
_AFXEXT_INLINE int CSplitterWnd::GetRowCount() const
	{ return m_nRows; }
_AFXEXT_INLINE int CSplitterWnd::GetColumnCount() const
	{ return m_nCols; }
// obsolete functions
#pragma warning(push)
#pragma warning(disable: 4996)
_AFXEXT_INLINE BOOL CSplitterWnd::IsChildPane(CWnd* /*pWnd*/, int& /*row*/, int& /*col*/)
	{ ASSERT(FALSE); return FALSE; }
_AFXEXT_INLINE CWnd* CSplitterWnd::GetActivePane(int& /*row*/, int& /*col*/)
	{ ASSERT(FALSE); return NULL; }
#pragma warning(pop)
_AFXEXT_INLINE BOOL CSplitterWnd::IsTracking()
	{ return m_bTracking; }

// CControlBar
_AFXEXT_INLINE int CControlBar::GetCount() const
	{ return m_nCount; }
_AFXEXT_INLINE DWORD CControlBar::GetBarStyle()
	{ return m_dwStyle; }
_AFXEXT_INLINE void CControlBar::SetBorders(LPCRECT lpRect)
	{ SetBorders(lpRect->left, lpRect->top, lpRect->right, lpRect->bottom); }
_AFXEXT_INLINE CRect CControlBar::GetBorders() const
	{ return CRect(m_cxLeftBorder, m_cyTopBorder, m_cxRightBorder, m_cyBottomBorder); }

// CToolBar
_AFXEXT_INLINE BOOL CToolBar::LoadToolBar(UINT nIDResource)
	{ return LoadToolBar(MAKEINTRESOURCE(nIDResource)); }
_AFXEXT_INLINE BOOL CToolBar::LoadBitmap(UINT nIDResource)
	{ return LoadBitmap(MAKEINTRESOURCE(nIDResource)); }

// NOTE: The cast in GetToolBarCtrl is ugly, but must be preserved for compatibility.
// CToolBarCtrl is not related to CToolBar by inheritance so we must be careful to ensure 
// that CToolBarCtrl remains a binary compatible subset of CToolBar.
_AFXEXT_INLINE CToolBarCtrl& CToolBar::GetToolBarCtrl() const
	{ return *(CToolBarCtrl*)this; }

// CDialogBar
_AFXEXT_INLINE BOOL CDialogBar::Create(CWnd* pParentWnd, UINT nIDTemplate,
		UINT nStyle, UINT nID)
	{ return Create(pParentWnd, MAKEINTRESOURCE(nIDTemplate), nStyle, nID); }

// CStatusBar
// NOTE: The cast in GetStatusBarCtrl is ugly, but must be preserved for compatibility.
// CStatusBarCtrl is not related to CStatusBar by inheritance so we must be careful to ensure 
// that CStatusBarCtrl remains a binary compatible subset of CStatusBar.
_AFXEXT_INLINE CStatusBarCtrl& CStatusBar::GetStatusBarCtrl() const
	{ return *(CStatusBarCtrl*)this; }
_AFXEXT_INLINE void CStatusBar::SetBorders(LPCRECT lpRect)
	{ SetBorders(lpRect->left, lpRect->top, lpRect->right, lpRect->bottom); }
_AFXEXT_INLINE void CStatusBar::SetBorders(int cxLeft, int cyTop, int cxRight, int cyBottom)
	{ ASSERT(cyTop >= 2); CControlBar::SetBorders(cxLeft, cyTop, cxRight, cyBottom); }
#ifdef _DEBUG
// status bars do not support docking
_AFXEXT_INLINE void CStatusBar::EnableDocking(DWORD)
	{ ASSERT(FALSE); }
#endif

// CReBar
// NOTE: The cast in GetReBarCtrl is ugly, but must be preserved for compatibility.
// CReBarCtrl is not related to CReBar by inheritance so we must be careful to ensure 
// that CReBarCtrl remains a binary compatible subset of CReBar.
_AFXEXT_INLINE CReBarCtrl& CReBar::GetReBarCtrl() const
	{ return *(CReBarCtrl*)this; }
_AFXEXT_INLINE UINT CReBar::GetReBarBandInfoSize() const
	{ return m_nReBarBandInfoSize; }
#ifdef _DEBUG
// rebars do not support docking
_AFXEXT_INLINE void CReBar::EnableDocking(DWORD)
	{ ASSERT(FALSE); }
#endif

// CRectTracker
_AFXEXT_INLINE CRectTracker::CRectTracker()
	{ Construct(); }

// CBitmapButton
_AFXEXT_INLINE CBitmapButton::CBitmapButton()
	{ }
_AFXEXT_INLINE BOOL CBitmapButton::LoadBitmaps(UINT nIDBitmapResource,
	UINT nIDBitmapResourceSel, UINT nIDBitmapResourceFocus,
	UINT nIDBitmapResourceDisabled)
	{ return LoadBitmaps(MAKEINTRESOURCE(nIDBitmapResource),
		MAKEINTRESOURCE(nIDBitmapResourceSel),
		MAKEINTRESOURCE(nIDBitmapResourceFocus),
		MAKEINTRESOURCE(nIDBitmapResourceDisabled)); }

// CPrintInfo
_AFXEXT_INLINE void CPrintInfo::SetMinPage(UINT nMinPage)
	{ m_pPD->m_pd.nMinPage = (WORD)nMinPage; }
_AFXEXT_INLINE void CPrintInfo::SetMaxPage(UINT nMaxPage)
	{ m_pPD->m_pd.nMaxPage = (WORD)nMaxPage; }
_AFXEXT_INLINE UINT CPrintInfo::GetMinPage() const
	{ return m_pPD->m_pd.nMinPage; }
_AFXEXT_INLINE UINT CPrintInfo::GetMaxPage() const
	{ return m_pPD->m_pd.nMaxPage; }
_AFXEXT_INLINE UINT CPrintInfo::GetFromPage() const
	{ return m_pPD->m_pd.nFromPage; }
_AFXEXT_INLINE UINT CPrintInfo::GetToPage() const
	{ return m_pPD->m_pd.nToPage; }
// CEditView
// NOTE: The cast in GetEditCtrl is ugly, but must be preserved for compatibility.
// CEdit is not related to CEditView by inheritance so we must be careful to ensure 
// that CEdit remains a binary compatible subset of CEditView.
_AFXEXT_INLINE CEdit& CEditView::GetEditCtrl() const
	{ return *(CEdit*)this; }

#endif //_AFXEXT_INLINE

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxfontcombobox.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCFontInfo;

/////////////////////////////////////////////////////////////////////////////
// CMFCFontComboBox window

class CMFCFontComboBox : public CComboBox
{
// Construction
public:
	CMFCFontComboBox();

// Attributes
public:
	AFX_IMPORT_DATA static BOOL m_bDrawUsingFont;

protected:
	CImageList m_Images;
	BOOL       m_bToolBarMode;

// Operations
public:
	BOOL Setup(int nFontType = DEVICE_FONTTYPE | RASTER_FONTTYPE | TRUETYPE_FONTTYPE, BYTE nCharSet = DEFAULT_CHARSET, BYTE nPitchAndFamily = DEFAULT_PITCH);
	BOOL SelectFont(CMFCFontInfo* pDesc);
	BOOL SelectFont(LPCTSTR lpszName, BYTE nCharSet = DEFAULT_CHARSET);
	
	CMFCFontInfo* GetSelFont() const;

protected:
	void Init();
	void CleanUp();

// Overrides
public:
	virtual int CompareItem(LPCOMPAREITEMSTRUCT lpCompareItemStruct);
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	virtual BOOL PreTranslateMessage(MSG* pMsg);

protected:
	virtual void PreSubclassWindow();

// Implementation
public:
	virtual ~CMFCFontComboBox();

protected:
	//{{AFX_MSG(CMFCFontComboBox)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg LRESULT OnInitControl(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxdtctl.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXDTCTL.H

#pragma once

/////////////////////////////////////////////////////////////////////////////
// Date/Time common control inlines

#ifdef _AFXDTCTL_INLINE

//CDateTimeCtrl
_AFXDTCTL_INLINE CDateTimeCtrl::CDateTimeCtrl()
	{ }
_AFXDTCTL_INLINE CFont* CDateTimeCtrl::GetMonthCalFont() const
	{ ASSERT(::IsWindow(m_hWnd)); return CFont::FromHandle((HFONT) ::SendMessage(m_hWnd, DTM_GETMCFONT, 0, 0)); }
_AFXDTCTL_INLINE CMonthCalCtrl* CDateTimeCtrl::GetMonthCalCtrl() const
	{ ASSERT(::IsWindow(m_hWnd)); return (CMonthCalCtrl*) CWnd::FromHandle((HWND) ::SendMessage(m_hWnd, DTM_GETMONTHCAL, 0, 0)); }
_AFXDTCTL_INLINE void CDateTimeCtrl::SetMonthCalFont(_In_ HFONT hFont, _In_ BOOL bRedraw /* = TRUE */)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, DTM_SETMCFONT, (WPARAM) hFont, MAKELONG(bRedraw, 0)); }
_AFXDTCTL_INLINE COLORREF CDateTimeCtrl::SetMonthCalColor(_In_ int iColor, _In_ COLORREF ref)
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, DTM_SETMCCOLOR, (WPARAM) iColor, (LPARAM) ref); }
_AFXDTCTL_INLINE DWORD CDateTimeCtrl::GetTime(_Out_ LPSYSTEMTIME pTimeDest) const
	{ ASSERT(::IsWindow(m_hWnd)); ASSERT(pTimeDest != NULL); return (DWORD) ::SendMessage(m_hWnd, DTM_GETSYSTEMTIME, 0, (LPARAM) pTimeDest); }
_AFXDTCTL_INLINE COLORREF CDateTimeCtrl::GetMonthCalColor(_In_ int iColor) const
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF) ::SendMessage(m_hWnd, DTM_GETMCCOLOR, (WPARAM) iColor, 0); }
_AFXDTCTL_INLINE BOOL CDateTimeCtrl::SetFormat(_In_z_ LPCTSTR pstrFormat)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL) ::SendMessage(m_hWnd, DTM_SETFORMAT, 0, (LPARAM) pstrFormat); }
#if (NTDDI_VERSION >= NTDDI_LONGHORN) && defined(UNICODE)
_AFXDTCTL_INLINE DWORD CDateTimeCtrl::SetMonthCalStyle(_In_ DWORD dwStyle)
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) DateTime_SetMonthCalStyle(m_hWnd, dwStyle); } // DTM_SETMCSTYLE
_AFXDTCTL_INLINE DWORD CDateTimeCtrl::GetMonthCalStyle() const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) DateTime_GetMonthCalStyle(m_hWnd); } // DTM_GETMCSTYLE
_AFXDTCTL_INLINE BOOL CDateTimeCtrl::GetDateTimePickerInfo(_Out_ LPDATETIMEPICKERINFO pDateTimePickerInfo) const
{ 
	ASSERT(::IsWindow(m_hWnd)); 
	ASSERT(pDateTimePickerInfo != NULL);
	if (pDateTimePickerInfo == NULL)
		return FALSE;
	pDateTimePickerInfo->cbSize = sizeof(DATETIMEPICKERINFO); 
	return (BOOL) DateTime_GetDateTimePickerInfo(m_hWnd, pDateTimePickerInfo); // DTM_GETDATETIMEPICKERINFO
} 
_AFXDTCTL_INLINE BOOL CDateTimeCtrl::GetIdealSize(_Out_ LPSIZE pSize) const
	{ ASSERT(::IsWindow(m_hWnd)); return DateTime_GetIdealSize(m_hWnd, pSize); } // DTM_GETIDEALSIZE
_AFXDTCTL_INLINE void CDateTimeCtrl::CloseMonthCal()
	{ ASSERT(::IsWindow(m_hWnd)); DateTime_CloseMonthCal(m_hWnd); } // DTM_CLOSEMONTHCAL
#endif // (NTDDI_VERSION >= NTDDI_LONGHORN) && defined(UNICODE)

//CMonthCalCtrl
_AFXDTCTL_INLINE CMonthCalCtrl::CMonthCalCtrl()
	{ }
_AFXDTCTL_INLINE DWORD CMonthCalCtrl::HitTest(_In_ PMCHITTESTINFO pMCHitTest)
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD) ::SendMessage(m_hWnd, MCM_HITTEST, 0, (LPARAM) pMCHitTest); }
_AFXDTCTL_INLINE BOOL CMonthCalCtrl::GetMinReqRect(_Out_ RECT* pRect) const
	{ ASSERT(m_hWnd != NULL); return (BOOL) ::SendMessage(m_hWnd, MCM_GETMINREQRECT, 0, (LPARAM) pRect); }
_AFXDTCTL_INLINE int CMonthCalCtrl::SetMonthDelta(_In_ int iDelta)
	{ ASSERT(m_hWnd != NULL); return (int) ::SendMessage(m_hWnd, MCM_SETMONTHDELTA, (WPARAM) iDelta, 0); }
_AFXDTCTL_INLINE int CMonthCalCtrl::GetMonthDelta() const
	{ ASSERT(m_hWnd != NULL); return (int) ::SendMessage(m_hWnd, MCM_GETMONTHDELTA, 0, 0); }
_AFXDTCTL_INLINE COLORREF CMonthCalCtrl::GetColor(_In_ int nRegion) const
	{ ASSERT(m_hWnd != NULL); return (COLORREF) ::SendMessage(m_hWnd, MCM_GETCOLOR, (WPARAM) nRegion, 0); }
_AFXDTCTL_INLINE COLORREF CMonthCalCtrl::SetColor(_In_ int nRegion, _In_ COLORREF ref)
	{ ASSERT(m_hWnd != NULL); return (COLORREF) ::SendMessage(m_hWnd, MCM_SETCOLOR, (WPARAM) nRegion, (LPARAM) ref); }
_AFXDTCTL_INLINE BOOL CMonthCalCtrl::SetMaxSelCount(_In_ int nMax)
	{ ASSERT(m_hWnd != NULL); return (BOOL) ::SendMessage(m_hWnd, MCM_SETMAXSELCOUNT, nMax, 0); }
_AFXDTCTL_INLINE int CMonthCalCtrl::GetMaxSelCount() const
	{ ASSERT(m_hWnd != NULL); return (int) ::SendMessage(m_hWnd, MCM_GETMAXSELCOUNT, 0, 0); }
_AFXDTCTL_INLINE void CMonthCalCtrl::SetToday(_In_ const LPSYSTEMTIME pDateTime)
	{ ASSERT(m_hWnd != NULL); ::SendMessage(m_hWnd, MCM_SETTODAY, 0, (LPARAM) pDateTime); }
_AFXDTCTL_INLINE BOOL CMonthCalCtrl::GetToday(_Out_ LPSYSTEMTIME pDateTime) const
	{ ASSERT(m_hWnd != NULL); return (BOOL) ::SendMessage(m_hWnd, MCM_GETTODAY, 0, (LPARAM) pDateTime); }
_AFXDTCTL_INLINE BOOL CMonthCalCtrl::SetCurSel(_In_ const LPSYSTEMTIME pDateTime)
	{ ASSERT(m_hWnd != NULL); return (BOOL) ::SendMessage(m_hWnd, MCM_SETCURSEL, 0, (LPARAM) pDateTime); }
_AFXDTCTL_INLINE BOOL CMonthCalCtrl::GetCurSel(_Out_ LPSYSTEMTIME pDateTime) const
	{ ASSERT(m_hWnd != NULL); BOOL bRetVal = (BOOL)::SendMessage(m_hWnd, MCM_GETCURSEL, 0, (LPARAM) pDateTime);
	pDateTime->wHour = pDateTime->wMinute = pDateTime->wSecond = pDateTime->wMilliseconds = 0; return bRetVal;}
_AFXDTCTL_INLINE DWORD CMonthCalCtrl::GetMaxTodayWidth() const
	{ ASSERT(m_hWnd != NULL); return MonthCal_GetMaxTodayWidth(m_hWnd); } // MCM_GETMAXTODAYWIDTH
#if (NTDDI_VERSION >= NTDDI_LONGHORN) && defined(UNICODE)
_AFXDTCTL_INLINE BOOL CMonthCalCtrl::IsMonthView() const // REVIEW: do we need this method?
	{ ASSERT(m_hWnd != NULL); return (GetCurrentView() == MCMV_MONTH); }
_AFXDTCTL_INLINE BOOL CMonthCalCtrl::IsYearView() const // REVIEW: do we need this method?
	{ ASSERT(m_hWnd != NULL); return (GetCurrentView() == MCMV_YEAR); }
_AFXDTCTL_INLINE BOOL CMonthCalCtrl::IsDecadeView() const // REVIEW: do we need this method?
	{ ASSERT(m_hWnd != NULL); return (GetCurrentView() == MCMV_DECADE); }
_AFXDTCTL_INLINE BOOL CMonthCalCtrl::IsCenturyView() const // REVIEW: do we need this method?
	{ ASSERT(m_hWnd != NULL); return (GetCurrentView() == MCMV_CENTURY); }
_AFXDTCTL_INLINE DWORD CMonthCalCtrl::GetCurrentView() const
	{ ASSERT(m_hWnd != NULL); return MonthCal_GetCurrentView(m_hWnd); } // MCM_GETCURRENTVIEW
_AFXDTCTL_INLINE int CMonthCalCtrl::GetCalendarCount() const
	{ ASSERT(m_hWnd != NULL); return (int) MonthCal_GetCalendarCount(m_hWnd); } // MCM_GETCALENDARCOUNT
_AFXDTCTL_INLINE BOOL CMonthCalCtrl::GetCalendarGridInfo(_Out_ PMCGRIDINFO pmcGridInfo) const
	{ ASSERT(m_hWnd != NULL); return MonthCal_GetCalendarGridInfo(m_hWnd, pmcGridInfo); } // MCM_GETCALENDARGRIDINFO
_AFXDTCTL_INLINE CALID CMonthCalCtrl::GetCalID() const
	{ ASSERT(m_hWnd != NULL); return MonthCal_GetCALID(m_hWnd); } // MCM_GETCALID
_AFXDTCTL_INLINE BOOL CMonthCalCtrl::SetCalID(_In_ CALID calid)
	{ ASSERT(m_hWnd != NULL); return (BOOL) MonthCal_SetCALID(m_hWnd, calid); } // MCM_SETCALID
_AFXDTCTL_INLINE void CMonthCalCtrl::SizeRectToMin(_Inout_ LPRECT lpRect)
	{ ASSERT(m_hWnd != NULL); MonthCal_SizeRectToMin(m_hWnd, lpRect); } // MCM_SIZERECTTOMIN
_AFXDTCTL_INLINE void CMonthCalCtrl::SetCalendarBorder(_In_ int cxyBorder)
	{ ASSERT(m_hWnd != NULL); MonthCal_SetCalendarBorder(m_hWnd, TRUE, cxyBorder); } // MCM_SETCALENDARBORDER
_AFXDTCTL_INLINE void CMonthCalCtrl::SetCalendarBorderDefault()
	{ ASSERT(m_hWnd != NULL); MonthCal_SetCalendarBorder(m_hWnd, FALSE, 0); } // MCM_SETCALENDARBORDER
_AFXDTCTL_INLINE int CMonthCalCtrl::GetCalendarBorder() const
	{ ASSERT(m_hWnd != NULL); return MonthCal_GetCalendarBorder(m_hWnd); } // MCM_GETCALENDARBORDER
_AFXDTCTL_INLINE BOOL CMonthCalCtrl::SetMonthView() // REVIEW: do we need this method?
	{ ASSERT(m_hWnd != NULL); return (SetCurrentView(MCMV_MONTH)); }
_AFXDTCTL_INLINE BOOL CMonthCalCtrl::SetYearView() // REVIEW: do we need this method?
	{ ASSERT(m_hWnd != NULL); return (SetCurrentView(MCMV_YEAR)); }
_AFXDTCTL_INLINE BOOL CMonthCalCtrl::SetDecadeView() // REVIEW: do we need this method?
	{ ASSERT(m_hWnd != NULL); return (SetCurrentView(MCMV_DECADE)); }
_AFXDTCTL_INLINE BOOL CMonthCalCtrl::SetCenturyView() // REVIEW: do we need this method?
	{ ASSERT(m_hWnd != NULL); return (SetCurrentView(MCMV_CENTURY)); }
_AFXDTCTL_INLINE BOOL CMonthCalCtrl::SetCurrentView(_In_ DWORD dwNewView)
	{ ASSERT(m_hWnd != NULL); return MonthCal_SetCurrentView(m_hWnd, dwNewView); } // MCM_SETCURRENTVIEW
#endif // (NTDDI_VERSION >= NTDDI_LONGHORN) && defined(UNICODE)

#endif //_AFXDTCTL_INLINE
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxext.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXEXT_H__
#define __AFXEXT_H__

#pragma once

#ifndef __AFXWIN_H__
	#include <afxwin.h>
#endif
#ifndef __AFXDLGS_H__
	#include <afxdlgs.h>
#endif

#include <uxtheme.h>

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// AFXEXT - MFC Advanced Extensions and Advanced Customizable classes

// Classes declared in this file

//CObject
	//CCmdTarget;
		//CWnd
			//CButton
				class CBitmapButton;    // Bitmap button (self-draw)

			class CControlBar;          // control bar
				class CStatusBar;       // status bar
				class CToolBar;         // toolbar
				class CDialogBar;       // dialog as control bar
				class CReBar;			// ie40 dock bar

			class CSplitterWnd;         // splitter manager

			//CView
				//CScrollView
				class CFormView;        // view with a dialog template
				class CEditView;        // simple text editor view

	//CDC
		class CMetaFileDC;              // a metafile with proxy

class CRectTracker;                     // tracker for rectangle objects

// information structures
struct CPrintInfo;          // Printing context
struct CPrintPreviewState;  // Print Preview context/state
struct CCreateContext;      // Creation context

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

/////////////////////////////////////////////////////////////////////////////
// Simple bitmap button

// CBitmapButton - push-button with 1->4 bitmap images
class CBitmapButton : public CButton
{
	DECLARE_DYNAMIC(CBitmapButton)
public:
// Construction
	CBitmapButton();

	BOOL LoadBitmaps(LPCTSTR lpszBitmapResource,
			LPCTSTR lpszBitmapResourceSel = NULL,
			LPCTSTR lpszBitmapResourceFocus = NULL,
			LPCTSTR lpszBitmapResourceDisabled = NULL);
	BOOL LoadBitmaps(UINT nIDBitmapResource,
			UINT nIDBitmapResourceSel = 0,
			UINT nIDBitmapResourceFocus = 0,
			UINT nIDBitmapResourceDisabled = 0);
	BOOL AutoLoad(UINT nID, CWnd* pParent);

// Operations
	void SizeToContent();

// Implementation:
public:
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
protected:
	// all bitmaps must be the same size
	CBitmap m_bitmap;           // normal image (REQUIRED)
	CBitmap m_bitmapSel;        // selected image (OPTIONAL)
	CBitmap m_bitmapFocus;      // focused but not selected (OPTIONAL)
	CBitmap m_bitmapDisabled;   // disabled bitmap (OPTIONAL)

	virtual void DrawItem(LPDRAWITEMSTRUCT lpDIS);
};

/////////////////////////////////////////////////////////////////////////////
// Control Bars

// forward declarations (private to implementation)
class CDockBar;
class CDockContext;
class CControlBarInfo;
struct AFX_SIZEPARENTPARAMS;

// Layout Modes for CalcDynamicLayout
#define LM_STRETCH  0x01    // same meaning as bStretch in CalcFixedLayout.  If set, ignores nLength
							// and returns dimensions based on LM_HORZ state, otherwise LM_HORZ is used
							// to determine if nLength is the desired horizontal or vertical length
							// and dimensions are returned based on nLength
#define LM_HORZ     0x02    // same as bHorz in CalcFixedLayout
#define LM_MRUWIDTH 0x04    // Most Recently Used Dynamic Width
#define LM_HORZDOCK 0x08    // Horizontal Docked Dimensions
#define LM_VERTDOCK 0x10    // Vertical Docked Dimensions
#define LM_LENGTHY  0x20    // Set if nLength is a Height instead of a Width
#define LM_COMMIT   0x40    // Remember MRUWidth

class AFX_NOVTABLE CControlBar : public CWnd
{
	DECLARE_DYNAMIC(CControlBar)
// Construction
protected:
	CControlBar();


// Attributes
public:
	int GetCount() const;
	CWnd *m_pInPlaceOwner;
	void SetInPlaceOwner(CWnd *pWnd);

	// for styles specific to CControlBar
	DWORD GetBarStyle();
	void SetBarStyle(DWORD dwStyle);

	BOOL m_bAutoDelete;

	// getting and setting border space
	void SetBorders(LPCRECT lpRect);
	void SetBorders(int cxLeft = 0, int cyTop = 0, int cxRight = 0, int cyBottom = 0);
	CRect GetBorders() const;

	CFrameWnd* GetDockingFrame() const;
	BOOL IsFloating() const;
	virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);
	virtual CSize CalcDynamicLayout(int nLength, DWORD nMode);

// Operations
	void EnableDocking(DWORD dwDockStyle);

// Overridables
	// updating
	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler) = 0;

	// painting
	virtual void CalcInsideRect(CRect& rect, BOOL bHorz) const;
	virtual void DoPaint(CDC* pDC);
	virtual void DrawBorders(CDC* pDC, CRect& rect);
	virtual void DrawGripper(CDC* pDC, const CRect& rect);
	virtual void DrawNCGripper(CDC* pDC, const CRect& rect);
	virtual BOOL DrawThemedGripper(CDC* pDC, const CRect& rect, BOOL fCentered);
	virtual BOOL DrawNonThemedGripper(CDC* pDC, const CRect& rect);

// Implementation
public:
	virtual ~CControlBar() = 0;
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual void DelayShow(BOOL bShow);
	virtual BOOL IsVisible() const;
	virtual DWORD RecalcDelayShow(AFX_SIZEPARENTPARAMS* lpLayout);

	virtual BOOL IsDockBar() const;
	virtual BOOL DestroyWindow();
	virtual void OnBarStyleChange(DWORD dwOldStyle, DWORD dwNewStyle);

	// info about bar (for status bar and toolbar)
	int m_cxLeftBorder, m_cxRightBorder;
	int m_cyTopBorder, m_cyBottomBorder;
	int m_cxDefaultGap;         // default gap value
	UINT m_nMRUWidth;   // For dynamic resizing.

	// array of elements
	int m_nCount;
	void* m_pData;        // m_nCount elements - type depends on derived class

	// support for theming
	HTHEME m_hReBarTheme;

	// support for delayed hide/show
	enum StateFlags
		{ delayHide = 1, delayShow = 2, tempHide = 4, statusSet = 8 };
	UINT m_nStateFlags;

	// support for docking
	DWORD m_dwStyle;    // creation style (used for layout)
	DWORD m_dwDockStyle;// indicates how bar can be docked
	CFrameWnd* m_pDockSite; // current dock site, if dockable
	CDockBar* m_pDockBar;   // current dock bar, if dockable
	CDockContext* m_pDockContext;   // used during dragging

	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual void PostNcDestroy();

	// implementation helpers
	virtual LRESULT WindowProc(UINT nMsg, WPARAM wParam, LPARAM lParam);
	BOOL AllocElements(int nElements, int cbElement);
	virtual BOOL SetStatusText(INT_PTR nHit);
#ifdef _WIN64
        /* 
        Initial releases of 64 bit MFC had SetStatusText(int), same size as
        32 bit MFC. Since this function is virtual, it could be overridden.

        Future overriders of SetStatusText should do so by overriding the
        INT_PTR version. But this extra function will allow 64 bit code ported
        from MFC70 to continue to work correctly.
        */
	virtual BOOL SetStatusText(int nHit);
#endif
	void ResetTimer(UINT_PTR nEvent, UINT nTime);
	void EraseNonClient();

	void GetBarInfo(CControlBarInfo* pInfo);
	void SetBarInfo(CControlBarInfo* pInfo, CFrameWnd* pFrameWnd);

	//{{AFX_MSG(CControlBar)
	afx_msg void OnTimer(UINT_PTR nIDEvent);
	afx_msg int OnCreate(LPCREATESTRUCT lpcs);
	afx_msg void OnDestroy();
	afx_msg void OnPaint();
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg void OnWindowPosChanging(LPWINDOWPOS lpWndPos);
	afx_msg LRESULT OnSizeParent(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnHelpHitTest(WPARAM wParam, LPARAM lParam);
	afx_msg void OnInitialUpdate();
	afx_msg LRESULT OnIdleUpdateCmdUI(WPARAM wParam, LPARAM lParam);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint pt );
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint pt);
	afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT nMsg);
	afx_msg LRESULT OnThemeChanged();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	friend class CFrameWnd;
	friend class CDockBar;
};

/////////////////////////////////////////////////////////////////////////////
// CStatusBar control

class CStatusBarCtrl;   // forward reference (see afxcmn.h for definition)
struct AFX_STATUSPANE;  // private to implementation

class CStatusBar : public CControlBar
{
	DECLARE_DYNAMIC(CStatusBar)

// Construction
public:
	CStatusBar();
	virtual BOOL Create(CWnd* pParentWnd,
		DWORD dwStyle = WS_CHILD | WS_VISIBLE | CBRS_BOTTOM,
		UINT nID = AFX_IDW_STATUS_BAR);
	virtual BOOL CreateEx(CWnd* pParentWnd, DWORD dwCtrlStyle = 0,
		DWORD dwStyle = WS_CHILD | WS_VISIBLE | CBRS_BOTTOM,
		UINT nID = AFX_IDW_STATUS_BAR);
	BOOL SetIndicators(const UINT* lpIDArray, int nIDCount);

// Attributes
public:
	void SetBorders(LPCRECT lpRect);
	void SetBorders(int cxLeft = 0, int cyTop = 0, int cxRight = 0, int cyBottom = 0);

	// standard control bar things
	int CommandToIndex(UINT nIDFind) const;
	UINT GetItemID(int nIndex) const;
	void GetItemRect(int nIndex, LPRECT lpRect) const;

	// specific to CStatusBar
	void GetPaneText(int nIndex, CString& rString) const;
	CString GetPaneText(int nIndex) const;
	BOOL SetPaneText(int nIndex, LPCTSTR lpszNewText, BOOL bUpdate = TRUE);
	void GetPaneInfo(int nIndex, UINT& nID, UINT& nStyle, int& cxWidth) const;
	void SetPaneInfo(int nIndex, UINT nID, UINT nStyle, int cxWidth);
	UINT GetPaneStyle(int nIndex) const;
	void SetPaneStyle(int nIndex, UINT nStyle);

	// for direct access to the underlying common control
	CStatusBarCtrl& GetStatusBarCtrl() const;

// Overridables
	virtual void DrawItem(LPDRAWITEMSTRUCT);

// Implementation
public:
	virtual ~CStatusBar();
	virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);
	BOOL PreCreateWindow(CREATESTRUCT& cs);
	BOOL AllocElements(int nElements, int cbElement);
	void CalcInsideRect(CRect& rect, BOOL bHorz) const;
	virtual void OnBarStyleChange(DWORD dwOldStyle, DWORD dwNewStyle);

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
	void EnableDocking(DWORD dwDockStyle);
#endif
	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);

protected:
	int m_nMinHeight;

	AFX_STATUSPANE* _GetPanePtr(int nIndex) const;
	void UpdateAllPanes(BOOL bUpdateRects, BOOL bUpdateText);
	virtual BOOL OnChildNotify(UINT message, WPARAM, LPARAM, LRESULT*);

	//{{AFX_MSG(CStatusBar)
	afx_msg LRESULT OnNcHitTest(CPoint);
	afx_msg void OnNcCalcSize(BOOL, NCCALCSIZE_PARAMS*);
	afx_msg void OnNcPaint();
	afx_msg void OnPaint();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnWindowPosChanging(LPWINDOWPOS);
	afx_msg LRESULT OnSetText(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnGetText(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnGetTextLength(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnSetMinHeight(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

// Styles for status bar panes
#define SBPS_NORMAL     0x0000
#define SBPS_NOBORDERS  SBT_NOBORDERS
#define SBPS_POPOUT     SBT_POPOUT
#define SBPS_OWNERDRAW  SBT_OWNERDRAW
#define SBPS_DISABLED   0x04000000
#define SBPS_STRETCH    0x08000000  // stretch to fill status bar

/////////////////////////////////////////////////////////////////////////////
// CToolBar control

HBITMAP AFXAPI AfxLoadSysColorBitmap(HINSTANCE hInst, HRSRC hRsrc, BOOL bMono = FALSE);

class CToolBarCtrl; // forward reference (see afxcmn.h for definition)

class CToolBar : public CControlBar
{
	DECLARE_DYNAMIC(CToolBar)

// Construction
public:
	CToolBar();
	virtual BOOL Create(CWnd* pParentWnd,
		DWORD dwStyle = WS_CHILD | WS_VISIBLE | CBRS_TOP,
		UINT nID = AFX_IDW_TOOLBAR);
	virtual BOOL CreateEx(CWnd* pParentWnd, DWORD dwCtrlStyle = TBSTYLE_FLAT,
		DWORD dwStyle = WS_CHILD | WS_VISIBLE | CBRS_ALIGN_TOP,
		CRect rcBorders = CRect(0, 0, 0, 0),
		UINT nID = AFX_IDW_TOOLBAR);

	void SetSizes(SIZE sizeButton, SIZE sizeImage);
		// button size should be bigger than image
	void SetHeight(int cyHeight);
		// call after SetSizes, height overrides bitmap size
	BOOL LoadToolBar(LPCTSTR lpszResourceName);
	BOOL LoadToolBar(UINT nIDResource);
	BOOL LoadBitmap(LPCTSTR lpszResourceName);
	BOOL LoadBitmap(UINT nIDResource);
	BOOL SetBitmap(HBITMAP hbmImageWell);
	BOOL SetButtons(const UINT* lpIDArray, int nIDCount);
		// lpIDArray can be NULL to allocate empty buttons

// Attributes
public:
	// standard control bar things
	int CommandToIndex(UINT nIDFind) const;
	UINT GetItemID(int nIndex) const;
	virtual void GetItemRect(int nIndex, LPRECT lpRect) const;
	UINT GetButtonStyle(int nIndex) const;
	void SetButtonStyle(int nIndex, UINT nStyle);

	// for changing button info
	void GetButtonInfo(int nIndex, UINT& nID, UINT& nStyle, int& iImage) const;
	void SetButtonInfo(int nIndex, UINT nID, UINT nStyle, int iImage);
	BOOL SetButtonText(int nIndex, LPCTSTR lpszText);
	CString GetButtonText(int nIndex) const;
	void GetButtonText(int nIndex, CString& rString) const;

	// for direct access to the underlying common control
	CToolBarCtrl& GetToolBarCtrl() const;

// Implementation
public:
	virtual ~CToolBar();
	virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);
	virtual CSize CalcDynamicLayout(int nLength, DWORD nMode);
	virtual INT_PTR OnToolHitTest(CPoint point, TOOLINFO* pTI) const;
	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);
	void SetOwner(CWnd* pOwnerWnd);
	BOOL AddReplaceBitmap(HBITMAP hbmImageWell);
	virtual void OnBarStyleChange(DWORD dwOldStyle, DWORD dwNewStyle);
	virtual HRESULT get_accName(VARIANT varChild, BSTR *pszName);

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	HRSRC m_hRsrcImageWell; // handle to loaded resource for image well
	HINSTANCE m_hInstImageWell; // instance handle to load image well from
	HBITMAP m_hbmImageWell; // contains color mapped button images
	BOOL m_bDelayedButtonLayout; // used to manage when button layout should be done

	CSize m_sizeImage;  // current image size
	CSize m_sizeButton; // current button size

	CMapStringToPtr* m_pStringMap;  // used as CMapStringToUInt

	// implementation helpers
	void _GetButton(int nIndex, TBBUTTON* pButton) const;
	void _SetButton(int nIndex, TBBUTTON* pButton);
	CSize CalcLayout(DWORD nMode, int nLength = -1);
	CSize CalcSize(TBBUTTON* pData, int nCount);
	int WrapToolBar(TBBUTTON* pData, int nCount, int nWidth);
	void SizeToolBar(TBBUTTON* pData, int nCount, int nLength, BOOL bVert = FALSE);
	void Layout(); // called for delayed button layout

	//{{AFX_MSG(CToolBar)
	afx_msg LRESULT OnNcHitTest(CPoint);
	afx_msg void OnNcPaint();
	afx_msg void OnPaint();
	afx_msg void OnNcCalcSize(BOOL, NCCALCSIZE_PARAMS*);
	afx_msg void OnWindowPosChanging(LPWINDOWPOS);
	afx_msg void OnSysColorChange();
	afx_msg LRESULT OnSetButtonSize(WPARAM, LPARAM);
	afx_msg LRESULT OnSetBitmapSize(WPARAM, LPARAM);
	afx_msg LRESULT OnPreserveZeroBorderHelper(WPARAM, LPARAM);
	afx_msg LRESULT OnPreserveSizingPolicyHelper(WPARAM, LPARAM);
	afx_msg BOOL OnNcCreate(LPCREATESTRUCT);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	LRESULT OnSetSizeHelper(CSize& size, LPARAM lParam);
};

// Styles for toolbar buttons
#define TBBS_BUTTON     MAKELONG(TBSTYLE_BUTTON, 0) // this entry is button
#define TBBS_SEPARATOR  MAKELONG(TBSTYLE_SEP, 0)    // this entry is a separator
#define TBBS_CHECKBOX   MAKELONG(TBSTYLE_CHECK, 0)  // this is an auto check button
#define TBBS_GROUP      MAKELONG(TBSTYLE_GROUP, 0)  // marks the start of a group
#define TBBS_CHECKGROUP (TBBS_GROUP|TBBS_CHECKBOX)  // normal use of TBBS_GROUP
#define TBBS_DROPDOWN	MAKELONG(TBSTYLE_DROPDOWN, 0) // drop down style
#define TBBS_AUTOSIZE	MAKELONG(TBSTYLE_AUTOSIZE, 0) // autocalc button width
#define TBBS_NOPREFIX	MAKELONG(TBSTYLE_NOPREFIX, 0) // no accel prefix for this button

// styles for display states
#define TBBS_CHECKED    MAKELONG(0, TBSTATE_CHECKED)    // button is checked/down
#define TBBS_PRESSED    MAKELONG(0, TBSTATE_PRESSED)    // button is being depressed
#define TBBS_DISABLED   MAKELONG(0, TBSTATE_ENABLED)    // button is disabled
#define TBBS_INDETERMINATE  MAKELONG(0, TBSTATE_INDETERMINATE)  // third state
#define TBBS_HIDDEN     MAKELONG(0, TBSTATE_HIDDEN) // button is hidden
#define TBBS_WRAPPED    MAKELONG(0, TBSTATE_WRAP)   // button is wrapped at this point
#define TBBS_ELLIPSES	MAKELONG(0, TBSTATE_ELIPSES) 
#define TBBS_MARKED		MAKELONG(0, TBSTATE_MARKED)

////////////////////////////////////////////
// CDialogBar control
// This is a control bar built from a dialog template. It is a modeless
// dialog that delegates all control notifications to the parent window
// of the control bar [the grandparent of the control]

class CDialogBar : public CControlBar
{
	DECLARE_DYNAMIC(CDialogBar)

// Construction
public:
	CDialogBar();
	virtual BOOL Create(CWnd* pParentWnd, LPCTSTR lpszTemplateName,
			UINT nStyle, UINT nID);
	virtual BOOL Create(CWnd* pParentWnd, UINT nIDTemplate,
			UINT nStyle, UINT nID);

// Implementation
public:
	virtual ~CDialogBar();
	virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);
	CSize m_sizeDefault;
	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);

protected:
#ifndef _AFX_NO_OCC_SUPPORT
	// data and functions necessary for OLE control containment
	_AFX_OCC_DIALOG_INFO* m_pOccDialogInfo;
	LPCTSTR m_lpszTemplateName;
	virtual BOOL SetOccDialogInfo(_AFX_OCC_DIALOG_INFO* pOccDialogInfo);

	//{{AFX_MSG(CDialogBar)
	DECLARE_MESSAGE_MAP()
	//}}AFX_MSG
	afx_msg LRESULT HandleInitDialog(WPARAM, LPARAM);
#endif
};

////////////////////////////////////////////
// CReBar control

class CReBarCtrl;

class CReBar : public CControlBar
{
	DECLARE_DYNAMIC(CReBar)

protected:
	UINT m_nReBarBandInfoSize;

	// Construction
public:
	CReBar();
	virtual BOOL Create(CWnd* pParentWnd, DWORD dwCtrlStyle = RBS_BANDBORDERS,
		DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | WS_CLIPCHILDREN | CBRS_TOP,
		UINT nID = AFX_IDW_REBAR);

// Attributes
public:
	// for direct access to the underlying common control
	CReBarCtrl& GetReBarCtrl() const;

	UINT GetReBarBandInfoSize() const;

// Operations
public:
	BOOL AddBar(CWnd* pBar, LPCTSTR pszText = NULL, CBitmap* pbmp = NULL, 
		DWORD dwStyle = RBBS_GRIPPERALWAYS | RBBS_FIXEDBMP);
	BOOL AddBar(CWnd* pBar, COLORREF clrFore, COLORREF clrBack,
		LPCTSTR pszText = NULL, DWORD dwStyle = RBBS_GRIPPERALWAYS);

// Implementation
	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);
	virtual INT_PTR OnToolHitTest(CPoint point, TOOLINFO* pTI) const;
	virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);
	virtual CSize CalcDynamicLayout(int nLength, DWORD nMode);
#ifdef _DEBUG
	void EnableDocking(DWORD dwDockStyle);
#endif

protected:
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	BOOL _AddBar(CWnd* pBar, REBARBANDINFO* pRBBI);

	//{{AFX_MSG(CReBar)
	afx_msg BOOL OnNcCreate(LPCREATESTRUCT);
	afx_msg void OnPaint();
	afx_msg void OnHeightChange(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnNcPaint();
	afx_msg void OnNcCalcSize(BOOL, NCCALCSIZE_PARAMS*);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg LRESULT OnShowBand(WPARAM wParam, LPARAM lParam);
	afx_msg void OnRecalcParent();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// Splitter Window

#define SPLS_DYNAMIC_SPLIT  0x0001
#define SPLS_INVERT_TRACKER 0x0002  // obsolete (now ignored)

class CSplitterWnd : public CWnd
{
	DECLARE_DYNAMIC(CSplitterWnd)

// Construction
public:
	CSplitterWnd();
	// Create a single view type splitter with multiple splits
	virtual BOOL Create(CWnd* pParentWnd,
				int nMaxRows, int nMaxCols, SIZE sizeMin,
				CCreateContext* pContext,
				DWORD dwStyle = WS_CHILD | WS_VISIBLE |
					WS_HSCROLL | WS_VSCROLL | SPLS_DYNAMIC_SPLIT,
				UINT nID = AFX_IDW_PANE_FIRST);

	// Create a multiple view type splitter with static layout
	virtual BOOL CreateStatic(CWnd* pParentWnd,
				int nRows, int nCols,
				DWORD dwStyle = WS_CHILD | WS_VISIBLE,
				UINT nID = AFX_IDW_PANE_FIRST);

	virtual BOOL CreateView(int row, int col, CRuntimeClass* pViewClass,
			SIZE sizeInit, CCreateContext* pContext);

// Attributes
public:
	int GetRowCount() const;
	int GetColumnCount() const;

	// information about a specific row or column
	void GetRowInfo(int row, int& cyCur, int& cyMin) const;
	void SetRowInfo(int row, int cyIdeal, int cyMin);
	void GetColumnInfo(int col, int& cxCur, int& cxMin) const;
	void SetColumnInfo(int col, int cxIdeal, int cxMin);

	// for setting and getting shared scroll bar style
	DWORD GetScrollStyle() const;
	void SetScrollStyle(DWORD dwStyle);

	// views inside the splitter
	CWnd* GetPane(int row, int col) const;
	BOOL IsChildPane(CWnd* pWnd, int* pRow, int* pCol);
	AFX_DEPRECATED("IsChildPane(CWnd *, int&, int&) has been superseded by IsChildPane(CWnd*, int*, int*)") 
			BOOL IsChildPane(CWnd* pWnd, int& row, int& col); // obsolete
	int IdFromRowCol(int row, int col) const;

	BOOL IsTracking();  // TRUE during split operation

// Operations
public:
	virtual void RecalcLayout();    // call after changing sizes

// Overridables
protected:
	// to customize the drawing
	enum ESplitType { splitBox, splitBar, splitIntersection, splitBorder };
	virtual void OnDrawSplitter(CDC* pDC, ESplitType nType, const CRect& rect);
	virtual void OnInvertTracker(const CRect& rect);

	/// <summary>
	/// Called by the framework to draw the splitter window.</summary>
	/// <param name="pDC"> A pointer to a device context.</param>
	virtual void OnDraw(CDC* pDC);

public:
	// for customizing scrollbar regions
	virtual BOOL CreateScrollBarCtrl(DWORD dwStyle, UINT nID);

	// for customizing DYNAMIC_SPLIT behavior
	virtual void DeleteView(int row, int col);
	virtual BOOL SplitRow(int cyBefore);
	virtual BOOL SplitColumn(int cxBefore);
	virtual void DeleteRow(int rowDelete);
	virtual void DeleteColumn(int colDelete);

	// determining active pane from focus or active view in frame
	virtual CWnd* GetActivePane(int* pRow = NULL, int* pCol = NULL);
	virtual void SetActivePane(int row, int col, CWnd* pWnd = NULL);
protected:
	AFX_DEPRECATED("GetActivePane(int&, int&) has been superseded by GetActivePane(int*, int*)") 
			CWnd* GetActivePane(int& row, int& col); // obsolete

public:
	// high level command operations - called by default view implementation
	virtual BOOL CanActivateNext(BOOL bPrev = FALSE);
	virtual void ActivateNext(BOOL bPrev = FALSE);
	virtual BOOL DoKeyboardSplit();

	// synchronized scrolling
	virtual BOOL DoScroll(CView* pViewFrom, UINT nScrollCode,
		BOOL bDoScroll = TRUE);
	virtual BOOL DoScrollBy(CView* pViewFrom, CSize sizeScroll,
		BOOL bDoScroll = TRUE);

// Implementation
public:
	virtual ~CSplitterWnd();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// implementation structure
	struct CRowColInfo
	{
		int nMinSize;       // below that try not to show
		int nIdealSize;     // user set size
		// variable depending on the available size layout
		int nCurSize;       // 0 => invisible, -1 => nonexistant
	};

protected:
	// customizable implementation attributes (set by constructor or Create)
	CRuntimeClass* m_pDynamicViewClass;
	int m_nMaxRows, m_nMaxCols;

	// implementation attributes which control layout of the splitter
	int m_cxSplitter, m_cySplitter;         // size of splitter bar
	int m_cxBorderShare, m_cyBorderShare;   // space on either side of splitter
	int m_cxSplitterGap, m_cySplitterGap;   // amount of space between panes
	int m_cxBorder, m_cyBorder;             // borders in client area

	// current state information
	int m_nRows, m_nCols;
	BOOL m_bHasHScroll, m_bHasVScroll;
	CRowColInfo* m_pColInfo;
	CRowColInfo* m_pRowInfo;

	// Tracking info - only valid when 'm_bTracking' is set
	BOOL m_bTracking, m_bTracking2;
	CPoint m_ptTrackOffset;
	CRect m_rectLimit;
	CRect m_rectTracker, m_rectTracker2;
	int m_htTrack;

	// implementation routines
	BOOL CreateCommon(CWnd* pParentWnd, SIZE sizeMin, DWORD dwStyle, UINT nID);
	virtual int HitTest(CPoint pt) const;
	virtual void GetInsideRect(CRect& rect) const;
	virtual void GetHitRect(int ht, CRect& rect);
	virtual void TrackRowSize(int y, int row);
	virtual void TrackColumnSize(int x, int col);
	virtual void DrawAllSplitBars(CDC* pDC, int cxInside, int cyInside);
	virtual void SetSplitCursor(int ht);
	CWnd* GetSizingParent();

	// starting and stopping tracking
	virtual void StartTracking(int ht);
	virtual void StopTracking(BOOL bAccept);

	// special command routing to frame
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);

	//{{AFX_MSG(CSplitterWnd)
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnMouseMove(UINT nFlags, CPoint pt);
	afx_msg void OnPaint();
	afx_msg void OnLButtonDown(UINT nFlags, CPoint pt);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint pt);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint pt);
	afx_msg void OnCancelMode();
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg BOOL OnMouseWheel(UINT nFlags, short zDelta, CPoint pt);
	afx_msg BOOL OnNcCreate(LPCREATESTRUCT lpcs);
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnDisplayChange();
	afx_msg LRESULT OnPrintClient(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CFormView - generic view constructed from a dialog template

class CFormView : public CScrollView
{
	DECLARE_DYNAMIC(CFormView)

// Construction
protected:      // must derive your own class
	CFormView(LPCTSTR lpszTemplateName);
	CFormView(UINT nIDTemplate);

// Implementation
public:
    virtual ~CFormView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual void OnInitialUpdate();

public:
	virtual HRESULT get_accChild(VARIANT varChild, IDispatch **ppdispChild)
	{
		return GetAccessibleChild(varChild, ppdispChild);
	}

	virtual HRESULT get_accChildCount(long *pcountChildren)
	{
		(*pcountChildren) = GetAccessibleChildCount();
		return S_OK;
	}

	HRESULT get_accName(VARIANT varChild, BSTR *pszName)
	{
		return GetAccessibleName(varChild, pszName);
	}

	virtual HRESULT accLocation(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild)
	{
		return GetAccessibilityLocation(varChild, pxLeft, pyTop, pcxWidth, pcyHeight);
	}

	virtual HRESULT accHitTest(long xLeft, long yTop, VARIANT *pvarChild)
	{
		return GetAccessibilityHitTest(xLeft, yTop, pvarChild);
	}

protected:
	LPCTSTR m_lpszTemplateName;
	CCreateContext* m_pCreateContext;
	HWND m_hWndFocus;   // last window to have focus

	virtual void OnDraw(CDC* pDC);      // default does nothing
	// special case override of child window creation
	virtual BOOL Create(LPCTSTR, LPCTSTR, DWORD,
		const RECT&, CWnd*, UINT, CCreateContext*);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual void OnActivateView(BOOL, CView*, CView*);
	virtual void OnActivateFrame(UINT, CFrameWnd*);
	BOOL SaveFocusControl();    // updates m_hWndFocus

#ifndef _AFX_NO_OCC_SUPPORT
	// data and functions necessary for OLE control containment
	_AFX_OCC_DIALOG_INFO* m_pOccDialogInfo;
	_AFX_OCC_DIALOG_INFO* m_pCreatedOccDialogInfo;
	virtual BOOL SetOccDialogInfo(_AFX_OCC_DIALOG_INFO* pOccDialogInfo);
	virtual _AFX_OCC_DIALOG_INFO* GetOccDialogInfo();
	afx_msg LRESULT HandleInitDialog(WPARAM, LPARAM);
#endif

	//{{AFX_MSG(CFormView)
	afx_msg int OnCreate(LPCREATESTRUCT lpcs);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CEditView - simple text editor view

class CEditView : public CCtrlView
{
	DECLARE_DYNCREATE(CEditView)

// Construction
public:
	CEditView();

// Attributes
public:
	static AFX_DATA const DWORD dwStyleDefault;
	// CEdit control access
	CEdit& GetEditCtrl() const;

	// presentation attributes
	CFont* GetPrinterFont() const;
	void SetPrinterFont(CFont* pFont);
	void SetTabStops(int nTabStops);

	// other attributes
	void GetSelectedText(CString& strResult) const;

	// buffer access
	LPCTSTR LockBuffer() const;
	void UnlockBuffer() const;
	UINT GetBufferLength() const;

// Operations
public:
	BOOL FindText(LPCTSTR lpszFind, BOOL bNext = TRUE, BOOL bCase = TRUE);
	void SerializeRaw(CArchive& ar);
	UINT PrintInsideRect(CDC* pDC, RECT& rectLayout, UINT nIndexStart,
		UINT nIndexStop);

// Overrideables
protected:
	virtual void OnFindNext(LPCTSTR lpszFind, BOOL bNext, BOOL bCase);
	virtual void OnReplaceSel(LPCTSTR lpszFind, BOOL bNext, BOOL bCase,
		LPCTSTR lpszReplace);
	virtual void OnReplaceAll(LPCTSTR lpszFind, LPCTSTR lpszReplace,
		BOOL bCase);
	virtual void OnTextNotFound(LPCTSTR lpszFind);

// Implementation
public:
	virtual ~CEditView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual void Serialize(CArchive& ar);
	virtual void DeleteContents();
	void ReadFromArchive(CArchive& ar, UINT nLen);
	void WriteToArchive(CArchive& ar);
	virtual void OnPrepareDC(CDC* pDC, CPrintInfo* pInfo);

	static AFX_DATA const UINT nMaxSize;
		// maximum number of characters supported

protected:
	int m_nTabStops;            // tab stops in dialog units
	LPTSTR m_pShadowBuffer;     // special shadow buffer only used in Win95
	UINT m_nShadowSize;

	CUIntArray m_aPageStart;    // array of starting pages
	HFONT m_hPrinterFont;       // if NULL, mirror display font
	HFONT m_hMirrorFont;        // font object used when mirroring

	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	// printing support
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnPrint(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo = NULL);
	BOOL PaginateTo(CDC* pDC, CPrintInfo* pInfo);

	// find & replace support
	void OnEditFindReplace(BOOL bFindOnly);
	BOOL InitializeReplace();
	BOOL SameAsSelected(LPCTSTR lpszCompare, BOOL bCase);

	// special overrides for implementation
	virtual void CalcWindowRect(LPRECT lpClientRect,
		UINT nAdjustType = adjustBorder);

	//{{AFX_MSG(CEditView)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg LRESULT OnSetFont(WPARAM wParam, LPARAM lParam);
	afx_msg void OnUpdateNeedSel(CCmdUI* pCmdUI);
	afx_msg void OnUpdateNeedClip(CCmdUI* pCmdUI);
	afx_msg void OnUpdateNeedText(CCmdUI* pCmdUI);
	afx_msg void OnUpdateNeedFind(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditUndo(CCmdUI* pCmdUI);
	afx_msg BOOL OnEditChange();
	afx_msg void OnEditCut();
	afx_msg void OnEditCopy();
	afx_msg void OnEditPaste();
	afx_msg void OnEditClear();
	afx_msg void OnEditUndo();
	afx_msg void OnEditSelectAll();
	afx_msg void OnEditFind();
	afx_msg void OnEditReplace();
	afx_msg void OnEditRepeat();
	afx_msg LRESULT OnFindReplaceCmd(WPARAM wParam, LPARAM lParam);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CMetaFileDC

class CMetaFileDC : public CDC
{
	DECLARE_DYNAMIC(CMetaFileDC)

// Constructors
public:
	CMetaFileDC();
	BOOL Create(LPCTSTR lpszFilename = NULL);
	BOOL CreateEnhanced(CDC* pDCRef, LPCTSTR lpszFileName,
		LPCRECT lpBounds, LPCTSTR lpszDescription);

// Operations
	HMETAFILE Close();
	HENHMETAFILE CloseEnhanced();

// Implementation
public:
	virtual void SetAttribDC(HDC hDC);  // Set the Attribute DC

protected:
	virtual void SetOutputDC(HDC hDC);  // Set the Output DC -- Not allowed
	virtual void ReleaseOutputDC();     // Release the Output DC -- Not allowed

public:
	virtual ~CMetaFileDC();

// Clipping Functions (use the Attribute DC's clip region)
	virtual int GetClipBox(LPRECT lpRect) const;
	virtual BOOL PtVisible(int x, int y) const;
			BOOL PtVisible(POINT point) const;
	virtual BOOL RectVisible(LPCRECT lpRect) const;

// Text Functions
	virtual BOOL TextOut(int x, int y, LPCTSTR lpszString, int nCount);
			BOOL TextOut(int x, int y, const CString& str);
	virtual BOOL ExtTextOut(int x, int y, UINT nOptions, LPCRECT lpRect,
				LPCTSTR lpszString, UINT nCount, LPINT lpDxWidths);
			BOOL ExtTextOut(int x, int y, UINT nOptions, LPCRECT lpRect,
				const CString& str, LPINT lpDxWidths);
	virtual CSize TabbedTextOut(int x, int y, LPCTSTR lpszString, int nCount,
				int nTabPositions, LPINT lpnTabStopPositions, int nTabOrigin);
			CSize TabbedTextOut(int x, int y, const CString& str,
				int nTabPositions, LPINT lpnTabStopPositions, int nTabOrigin);
#pragma push_macro("DrawText")
#pragma push_macro("DrawTextEx")
#undef DrawText
#undef DrawTextEx
	virtual int _AFX_FUNCNAME(DrawText)(LPCTSTR lpszString, int nCount, LPRECT lpRect,
				UINT nFormat);
			int _AFX_FUNCNAME(DrawText)(const CString& str, LPRECT lpRect, UINT nFormat);

	virtual int _AFX_FUNCNAME(DrawTextEx)(_In_count_(nCount) LPTSTR lpszString, int nCount, LPRECT lpRect,
				UINT nFormat, LPDRAWTEXTPARAMS lpDTParams);
			int _AFX_FUNCNAME(DrawTextEx)(const CString& str, LPRECT lpRect, UINT nFormat, LPDRAWTEXTPARAMS lpDTParams);


			int DrawText(LPCTSTR lpszString, int nCount, LPRECT lpRect,
				UINT nFormat);
			int DrawText(const CString& str, LPRECT lpRect, UINT nFormat);

			int DrawTextEx(_In_count_(nCount) LPTSTR lpszString, int nCount, LPRECT lpRect,
				UINT nFormat, LPDRAWTEXTPARAMS lpDTParams);
			int DrawTextEx(const CString& str, LPRECT lpRect, UINT nFormat, LPDRAWTEXTPARAMS lpDTParams);
#pragma pop_macro("DrawText")
#pragma pop_macro("DrawTextEx")

// Printer Escape Functions
	virtual int Escape(int nEscape, int nCount, LPCSTR lpszInData, LPVOID lpOutData);

// Viewport Functions
	virtual CPoint SetViewportOrg(int x, int y);
			CPoint SetViewportOrg(POINT point);
	virtual CPoint OffsetViewportOrg(int nWidth, int nHeight);
	virtual CSize SetViewportExt(int x, int y);
			CSize SetViewportExt(SIZE size);
	virtual CSize ScaleViewportExt(int xNum, int xDenom, int yNum, int yDenom);

protected:
	void AdjustCP(int cx);
};

/////////////////////////////////////////////////////////////////////////////
// CRectTracker - simple rectangular tracking rectangle w/resize handles

class CRectTracker
{
public:
// Constructors
	CRectTracker();
	CRectTracker(LPCRECT lpSrcRect, UINT nStyle);

// Style Flags
	enum StyleFlags
	{
		solidLine = 1, dottedLine = 2, hatchedBorder = 4,
		resizeInside = 8, resizeOutside = 16, hatchInside = 32,
	};

// Hit-Test codes
	enum TrackerHit
	{
		hitNothing = -1,
		hitTopLeft = 0, hitTopRight = 1, hitBottomRight = 2, hitBottomLeft = 3,
		hitTop = 4, hitRight = 5, hitBottom = 6, hitLeft = 7, hitMiddle = 8
	};

// Attributes
	UINT m_nStyle;      // current state
	CRect m_rect;       // current position (always in pixels)
	CSize m_sizeMin;    // minimum X and Y size during track operation
	int m_nHandleSize;  // size of resize handles (default from WIN.INI)

// Operations
	void Draw(CDC* pDC) const;
	void GetTrueRect(LPRECT lpTrueRect) const;
	BOOL SetCursor(CWnd* pWnd, UINT nHitTest) const;
	BOOL Track(CWnd* pWnd, CPoint point, BOOL bAllowInvert = FALSE,
		CWnd* pWndClipTo = NULL);
	BOOL TrackRubberBand(CWnd* pWnd, CPoint point, BOOL bAllowInvert = TRUE);
	int HitTest(CPoint point) const;
	int NormalizeHit(int nHandle) const;

// Overridables
	virtual void DrawTrackerRect(LPCRECT lpRect, CWnd* pWndClipTo,
		CDC* pDC, CWnd* pWnd);
	virtual void AdjustRect(int nHandle, LPRECT lpRect);
	virtual void OnChangedRect(const CRect& rectOld);
	virtual UINT GetHandleMask() const;

// Implementation
public:
	virtual ~CRectTracker();

protected:
	BOOL m_bAllowInvert;    // flag passed to Track or TrackRubberBand
	CRect m_rectLast;
	CSize m_sizeLast;
	BOOL m_bErase;          // TRUE if DrawTrackerRect is called for erasing
	BOOL m_bFinalErase;     // TRUE if DragTrackerRect called for final erase

	// implementation helpers
	int HitTestHandles(CPoint point) const;
	void GetHandleRect(int nHandle, CRect* pHandleRect) const;
	void GetModifyPointers(int nHandle, int**ppx, int**ppy, int* px, int*py);
	virtual int GetHandleSize(LPCRECT lpRect = NULL) const;
	BOOL TrackHandle(int nHandle, CWnd* pWnd, CPoint point, CWnd* pWndClipTo);
	void Construct();
};

/////////////////////////////////////////////////////////////////////////////
// Informational data structures

struct CPrintInfo // Printing information structure
{
	CPrintInfo();
	~CPrintInfo();

	CPrintDialog* m_pPD;     // pointer to print dialog

	BOOL m_bDocObject;       // TRUE if printing by IPrint interface
	BOOL m_bPreview;         // TRUE if in preview mode
	BOOL m_bDirect;          // TRUE if bypassing Print Dialog
	BOOL m_bContinuePrinting;// set to FALSE to prematurely end printing
	UINT m_nCurPage;         // Current page
	UINT m_nNumPreviewPages; // Desired number of preview pages
	CString m_strPageDesc;   // Format string for page number display
	LPVOID m_lpUserData;     // pointer to user created struct
	CRect m_rectDraw;        // rectangle defining current usable page area
	int m_nJobNumber;			 // job number (after StartDoc)

	// these only valid if m_bDocObject
	UINT m_nOffsetPage;      // offset of first page in combined IPrint job
	DWORD m_dwFlags;         // flags passed to IPrint::Print

	void SetMinPage(UINT nMinPage);
	void SetMaxPage(UINT nMaxPage);
	UINT GetMinPage() const;
	UINT GetMaxPage() const;
	UINT GetFromPage() const;
	UINT GetToPage() const;
	UINT GetOffsetPage() const;
};

struct CPrintPreviewState   // Print Preview context/state
{
	UINT nIDMainPane;          // main pane ID to hide
	HMENU hMenu;               // saved hMenu
	DWORD dwStates;            // Control Bar Visible states (bit map)
	CView* pViewActiveOld;     // save old active view during preview
	BOOL (CALLBACK* lpfnCloseProc)(CFrameWnd* pFrameWnd);
	HACCEL hAccelTable;       // saved accelerator table

// Implementation
	CPrintPreviewState();
};

struct CCreateContext   // Creation information structure
	// All fields are optional and may be NULL
{
	// for creating new views
	CRuntimeClass* m_pNewViewClass; // runtime class of view to create or NULL
	CDocument* m_pCurrentDoc;

	// for creating MDI children (CMDIChildWnd::LoadFrame)
	CDocTemplate* m_pNewDocTemplate;

	// for sharing view/frame state from the original view/frame
	CView* m_pLastView;
	CFrameWnd* m_pCurrentFrame;

// Implementation
	CCreateContext();
};

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXEXT_INLINE AFX_INLINE
#include <afxext.inl>
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXEXT_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxframewndex.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxframeimpl.h"
#include "afxcontrolbarutil.h"
#include "afxpopupmenu.h"

#include "afxdockingmanager.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCMenuBar;
class CMFCToolBarMenuButton;
class CMFCToolBarButton;

/////////////////////////////////////////////////////////////////////////////
// CFrameWndEx frame

class CFrameWndEx : public CFrameWnd
{
	friend class CMFCToolBar;
	friend class CMFCMenuBar;
	friend class CWinAppEx;
	friend class CMFCPopupMenu;
	friend class CPaneFrameWnd;

	DECLARE_DYNCREATE(CFrameWndEx)

protected:
	CFrameWndEx();           // protected constructor used by dynamic creation

// Attributes
public:
	BOOL IsMenuBarAvailable() const { return m_Impl.GetMenuBar() != NULL; }
	const CMFCMenuBar* GetMenuBar() const { return m_Impl.GetMenuBar(); }

	UINT GetDefaultResId() const { return m_Impl.m_nIDDefaultResource; }

	CMFCPopupMenu* GetActivePopup() const { return CMFCPopupMenu::m_pActivePopupMenu; }
	const CObList& GetTearOffBars() const { return m_Impl.m_listTearOffToolbars; }

	CMFCRibbonBar* GetRibbonBar() { return m_Impl.GetRibbonBar(); }

protected:
	BOOL  m_bIsTlbCustMode;
	BOOL m_bContextHelp;
	BOOL m_bWasMaximized;
	BOOL m_bIsMinimized;
	HMENU m_hmenuWindow;
	CFrameImpl m_Impl;
	CDockingManager  m_dockManager; // THE DockManager

	// workaround for Print Preview bug in VS 7.1
	CFrameWnd* m_pPrintPreviewFrame;

// Operations
public:
	//------------------ dockmanager layer ------------
	void AddDockSite();
	BOOL AddPane(CBasePane* pControlBar, BOOL bTail = TRUE);
	BOOL InsertPane(CBasePane* pControlBar, CBasePane* pTarget, BOOL bAfter = TRUE);
	void RemovePaneFromDockManager(CBasePane* pControlBar, BOOL bDestroy, BOOL bAdjustLayout, BOOL bAutoHide, CBasePane* pBarReplacement);
	void DockPane(CBasePane* pBar, UINT nDockBarID = 0, LPCRECT lpRect = NULL);

	CBasePane* PaneFromPoint(CPoint point, int nSensitivity, bool bExactBar, CRuntimeClass* pRTCBarType) const;
	CBasePane* PaneFromPoint(CPoint point, int nSensitivity, DWORD& dwAlignment, CRuntimeClass* pRTCBarType) const;
	BOOL IsPointNearDockSite(CPoint point, DWORD& dwBarAlignment, BOOL& bOuterEdge) const;
	virtual void AdjustDockingLayout(HDWP hdwp = NULL);
	BOOL EnableDocking(DWORD dwDockStyle);
	BOOL EnableAutoHidePanes(DWORD dwDockStyle);

	CBasePane* GetPane(UINT nID);
	void ShowPane(CBasePane* pBar, BOOL bShow, BOOL bDelay, BOOL bActivate);
	
	virtual BOOL OnMoveMiniFrame(CWnd* pFrame);
	virtual void RecalcLayout(BOOL bNotify = TRUE);

	BOOL DockPaneLeftOf(CPane* pBar, CPane* pLeftOf);

	void SetupToolbarMenu(CMenu& menu, const UINT uiViewUserToolbarCmdFirst, const UINT uiViewUserToolbarCmdLast)
	{
		m_Impl.SetupToolbarMenu(menu, uiViewUserToolbarCmdFirst, uiViewUserToolbarCmdLast);
	}

	void SetDockState(const CDockState& state) { m_Impl.SetDockState(state); }

	BOOL IsFullScreen() const { return m_Impl.m_FullScreenMgr.IsFullScreen(); }
	void ShowFullScreen() { m_Impl.m_FullScreenMgr.ShowFullScreen(); }
	void EnableFullScreenMainMenu(BOOL bEnableMenu) { m_Impl.m_FullScreenMgr.EnableMainMenu(bEnableMenu); }
	void EnableFullScreenMode(UINT uiFullScreenCmd) { m_Impl.m_FullScreenMgr.SetFullScreenID(uiFullScreenCmd); }

	void EnableLoadDockState(BOOL bEnable = TRUE) { m_Impl.m_bLoadDockState = bEnable; }

	CDockingManager* GetDockingManager() { return &m_dockManager; }

	void SetPrintPreviewFrame(CFrameWnd* pWnd)
	{
		if (pWnd != NULL)
		{
			ASSERT_VALID(pWnd);
		}

		m_pPrintPreviewFrame = pWnd;
	}

	void EnablePaneMenu(BOOL bEnable, UINT uiCustomizeCmd, const CString& strCustomizeLabel, UINT uiViewToolbarsMenuEntryID,
		BOOL bContextMenuShowsToolbarsOnly = FALSE, BOOL bViewMenuShowsToolbarsOnly = FALSE)
	{
		m_dockManager.EnablePaneContextMenu(bEnable, uiCustomizeCmd, strCustomizeLabel, bContextMenuShowsToolbarsOnly);
		m_Impl.SetControlbarsMenuId(uiViewToolbarsMenuEntryID, bViewMenuShowsToolbarsOnly);
	}

	void UpdateCaption() { m_Impl.UpdateCaption(); }
	BOOL IsPrintPreview() { return m_Impl.IsPrintPreview(); }

protected:

// Implementation:
	void InitUserToolbars(LPCTSTR lpszRegEntry, UINT uiUserToolbarFirst, UINT uiUserToolbarLast)
	{
		m_Impl.InitUserToolbars(lpszRegEntry, uiUserToolbarFirst, uiUserToolbarLast);
	}

	void LoadUserToolbars() { m_Impl.LoadUserToolbars(); }
	void SaveUserToolbars() { m_Impl.SaveUserToolbars(); }
	void LoadTearOffMenus() { m_Impl.LoadTearOffMenus(); }
	void SaveTearOffMenus() { m_Impl.SaveTearOffMenus(); }

	BOOL IsDockStateValid(const CDockState& state) { return m_Impl.IsDockStateValid(state); }
	CMFCToolBar* GetUserToolBarByIndex(int iIndex) const { return m_Impl.GetUserToolBarByIndex(iIndex); }

// Overrides
public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual BOOL LoadFrame(UINT nIDResource, DWORD dwDefaultStyle = WS_OVERLAPPEDWINDOW | FWS_ADDTOTITLE, CWnd* pParentWnd = NULL, CCreateContext* pContext = NULL);
	virtual void WinHelp(DWORD dwData, UINT nCmd = HELP_CONTEXT);
	virtual void OnSetPreviewMode(BOOL bPreview, CPrintPreviewState* pState);
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);

protected:
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

	virtual void HtmlHelp(DWORD_PTR dwData, UINT nCmd = 0x000F);

// Implementation
protected:
	virtual ~CFrameWndEx();

	BOOL OnSetMenu(HMENU hmenu);
	BOOL ShowPopupMenu(CMFCPopupMenu* pMenuPopup);

	virtual void AdjustClientArea();
	virtual COleClientItem*	GetInPlaceActiveItem();

public:
	virtual BOOL OnShowPopupMenu(CMFCPopupMenu* /*pMenuPopup*/);

	virtual BOOL OnShowCustomizePane(CMFCPopupMenu* pMenuPane, UINT uiToolbarID)
	{
		m_Impl.AddDefaultButtonsToCustomizePane(pMenuPane, uiToolbarID);
		return TRUE;
	}

	virtual void OnClosePopupMenu(CMFCPopupMenu* pMenuPopup);
	virtual BOOL OnDrawMenuImage(CDC* pDC, const CMFCToolBarMenuButton* pMenuButton, const CRect& rectImage);

	virtual BOOL OnMenuButtonToolHitTest(CMFCToolBarButton* /*pButton*/, TOOLINFO* /*pTI*/) { return FALSE; }
	virtual BOOL GetToolbarButtonToolTipText(CMFCToolBarButton* /*pButton*/, CString& /*strTTText*/) { return FALSE; }
	virtual void OnDrawMenuLogo(CDC* /*pDC*/, CMFCPopupMenu* /*pMenu*/, const CRect& /*rectLogo*/) {}
	virtual BOOL OnTearOffMenu(CMFCPopupMenu* /*pMenuPopup*/, CPane* /*pBar*/) { return TRUE; }

	virtual void OnUpdateFrameMenu(HMENU hMenuAlt);

	virtual BOOL OnShowPanes(BOOL bShow);
	virtual BOOL NegotiateBorderSpace( UINT nBorderCmd, LPRECT lpRectBorder);

	virtual void DelayUpdateFrameMenu(HMENU hMenuAlt);
	virtual BOOL OnCloseMiniFrame(CPaneFrameWnd* /*pWnd*/) { return TRUE; }
	virtual BOOL OnCloseDockingPane(CDockablePane* /*pWnd*/) { return TRUE; }

	void ActiveItemRecalcLayout();
	virtual void OnUpdateFrameTitle(BOOL bAddToTitle);

	//{{AFX_MSG(CFrameWndEx)
	afx_msg LRESULT OnMenuChar(UINT nChar, UINT nFlags, CMenu* pMenu);
	afx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);
	afx_msg void OnClose();
	afx_msg void OnDestroy();
	afx_msg void OnSizing(UINT fwSide, LPRECT pRect);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI);
	afx_msg void OnWindowPosChanged(WINDOWPOS FAR* lpwndpos);
	afx_msg void OnNcPaint();
	afx_msg BOOL OnNcActivate(BOOL bActive);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnNcMouseMove(UINT nHitTest, CPoint point);
	afx_msg LRESULT OnNcHitTest(CPoint point);
	afx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnActivateApp(BOOL bActive, DWORD dwThreadID);
	afx_msg LRESULT OnSetMenu(WPARAM wp, LPARAM);
	afx_msg LRESULT OnToolbarCreateNew(WPARAM,LPARAM);
	afx_msg LRESULT OnToolbarDelete(WPARAM,LPARAM);
	afx_msg void OnContextHelp();
	afx_msg void OnUpdatePaneMenu(CCmdUI* pCmdUI);
	afx_msg BOOL OnPaneCheck(UINT nID);
	afx_msg LRESULT OnIdleUpdateCmdUI(WPARAM wParam = 0, LPARAM lParam = 0);
	LRESULT OnExitSizeMove(WPARAM, LPARAM);
	afx_msg LRESULT OnToolbarContextMenu(WPARAM,LPARAM);
	afx_msg LRESULT OnSetText(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnChangeVisualManager(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnPostPreviewFrame(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnDWMCompositionChanged(WPARAM,LPARAM);
	afx_msg LRESULT OnPowerBroadcast(WPARAM wp, LPARAM lp);
	afx_msg void OnSysColorChange();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxframeimpl.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

class CBasePane;
class CMFCToolBar;
class CMFCMenuBar;
class CMFCPopupMenu;
class CMFCRibbonBar;
class CMFCRibbonStatusBar;
class CMFCCaptionButtonEx;

#include "afxcontrolbarutil.h"
#include "afxdockingmanager.h"
#include "afxfullscreenimpl.h"
#include "afxvisualmanager.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CFrameImpl
{
	friend class CMFCToolBar;
	friend class CMDIFrameWndEx;
	friend class CFrameWndEx;
	friend class COleIPFrameWndEx;
	friend class COleDocIPFrameWndEx;
	friend class CMFCMenuBar;
	friend class CWinAppEx;
	friend class CMFCPopupMenu;
	friend class CPaneFrameWnd;
	friend class CFullScreenImpl;
	friend class CMDIChildWndEx;
	friend class CMDIClientAreaWnd;

public:
	CFrameImpl(CFrameWnd* pFrame);
	virtual ~CFrameImpl();

	void SetDockingManager(CDockingManager* pManager) 
	{
		ASSERT_VALID(pManager); 
		m_pDockManager = pManager;
	}

	void GetFullScreenMinMaxInfo(MINMAXINFO FAR* lpMMI) { m_FullScreenMgr.OnGetMinMaxInfo(lpMMI); }
	static const CList<CFrameWnd*, CFrameWnd*>& __stdcall GetFrameList() { return m_lstFrames; }

	static void __stdcall AddFrame(CFrameWnd* pFrame);
	static void __stdcall RemoveFrame(CFrameWnd* pFrame);

	void OnChangeVisualManager();

// Attributes:
public:
	const CMFCMenuBar* GetMenuBar() const { return m_pMenuBar; }
	CMFCMenuBar* GetMenuBar() { return m_pMenuBar; }
	CMFCRibbonBar* GetRibbonBar() { return m_pRibbonBar; }

	void SetNewUserToolBarRTC(CRuntimeClass* pCustomUserToolBarRTC);

	void SetControlbarsMenuId(UINT uiViewMenuEntryID, BOOL bViewMenuShowsToolbarsOnly)
	{
		m_uiControlbarsMenuEntryID = uiViewMenuEntryID;
		m_bViewMenuShowsToolbarsOnly = bViewMenuShowsToolbarsOnly;
	}

	BOOL HasRegion () const
	{
		return m_bIsWindowRgn;
	}

	AFX_IMPORT_DATA static BOOL m_bControlBarExtraPixel;

protected:
	UINT m_uiUserToolbarFirst;
	UINT m_uiUserToolbarLast;
	UINT m_nIDDefaultResource;
	UINT m_nHotSysButton;
	UINT m_nHitSysButton;
	UINT m_uiControlbarsMenuEntryID;

	BOOL m_bCaptured;
	BOOL m_bIsWindowRgn;
	BOOL m_bHasBorder;
	BOOL m_bIsMDIChildFrame;
	BOOL m_bIsOleInPlaceActive;
	BOOL m_bHadCaption;
	BOOL m_bLoadDockState;
	BOOL m_bViewMenuShowsToolbarsOnly;
	BOOL m_bWindowPosChanging;

	HMENU              m_hDefaultMenu;
	CRect              m_rectRedraw;
	CObList            m_listUserDefinedToolbars;
	CObList            m_listTearOffToolbars;
	CObList            m_lstCaptionSysButtons;
	CString            m_strControlBarRegEntry;
	CMFCMenuBar*          m_pMenuBar;
	CFrameWnd*         m_pFrame;
	CDockingManager*      m_pDockManager;
	CFullScreenImpl m_FullScreenMgr;
	CRuntimeClass*     m_pCustomUserToolBarRTC;
	CMFCRibbonBar*        m_pRibbonBar;
	CMFCRibbonStatusBar*  m_pRibbonStatusBar;


// Operations
protected:
	static UINT __stdcall GetFreeCtrlBarID(UINT uiFirstID, UINT uiLastID, const CObList& lstCtrlBars);

	// User-defined toolbars:
	void InitUserToolbars(LPCTSTR lpszRegEntry, UINT uiUserToolbarFirst, UINT uiUserToolbarLast);
	void LoadUserToolbars();
	void SaveUserToolbars(BOOL bFrameBarsOnly = FALSE);

	const CMFCToolBar* CreateNewToolBar(LPCTSTR lpszName);
	BOOL DeleteToolBar(CMFCToolBar* pToolBar);

	// Tear-off toolbars:
	void AddTearOffToolbar(CBasePane* pToolBar);
	void RemoveTearOffToolbar(CBasePane* pToolBar);

	void LoadTearOffMenus();
	void SaveTearOffMenus(BOOL bFrameBarsOnly = FALSE);

	void OnCloseFrame();
	void OnLoadFrame();
	void RestorePosition(CREATESTRUCT& cs);

	void StoreWindowPlacement();

	BOOL IsDockStateValid(const CDockState& state);
	BOOL IsUserDefinedToolbar(const CMFCToolBar* pToolBar) const;

	void SetMenuBar(CMFCMenuBar* pMenuBar);
	CMFCToolBar* GetUserToolBarByIndex(int iIndex) const;

	void SetupToolbarMenu(	CMenu& menu, const UINT uiViewUserToolbarCmdFirst, const UINT uiViewUserToolbarCmdLast);

	BOOL ProcessKeyboard(int nKey, BOOL* pbProcessAccel = NULL);
	BOOL ProcessMouseClick(UINT uiMsg, POINT pt, HWND hwnd);
	BOOL ProcessMouseMove(POINT pt);
	BOOL ProcessMouseWheel(WPARAM wParam, LPARAM lParam);

	void FrameEnableDocking(CFrameWnd * pFrame, DWORD dwDockStyle);

	BOOL OnShowPopupMenu(CMFCPopupMenu* pMenuPopup, CFrameWnd* pWndFrame);
	BOOL OnShowCustomizePane(CMFCPopupMenu* /*pMenuPane*/, UINT uiToolbarID);

	BOOL OnMenuChar(UINT nChar);

	void DeactivateMenu();

	void SetDockState(const CDockState& state);
	void SaveDockState(LPCTSTR lpszSectionName = NULL);
	void LoadDockState(LPCTSTR lpszSectionName = NULL);

	BOOL LoadLargeIconsState();

	static BOOL __stdcall IsHelpKey(LPMSG lpMsg);

	void ShowQuickCustomizePane(CMFCPopupMenu* pMenuPopup);
	void AddDefaultButtonsToCustomizePane(CMFCPopupMenu* pMenuPane, UINT uiToolbarID);
	BOOL IsCustomizePane(const CMFCPopupMenu* pMenuPopup) const;

	CRect GetFullScreeen() { return m_FullScreenMgr.GetFullScreenRect(); }
	BOOL IsFullScreeen() const { return m_FullScreenMgr.IsFullScreen(); }
	void EnableFullScreenMainMenu(BOOL bShow = TRUE) { m_FullScreenMgr.EnableMainMenu(bShow); }
	BOOL IsPrintPreview();
	BOOL IsOwnerDrawCaption() { return CMFCVisualManager::GetInstance()->IsOwnerDrawCaption() && !m_bIsOleInPlaceActive; }

	void OnSetText(LPCTSTR lpszText);
	void OnActivateApp(BOOL bActive);
	void OnWindowPosChanging(WINDOWPOS FAR* lpwndpos);
	BOOL OnNcPaint();
	void OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI);
	BOOL OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp);
	BOOL OnNcActivate(BOOL bActive);
	void UpdateCaption();
	CRect GetCaptionRect();
	UINT OnNcHitTest(CPoint point);
	void OnNcMouseMove(UINT nHitTest, CPoint point);
	void OnLButtonDown(CPoint point);
	void OnLButtonUp(CPoint point);
	void OnMouseMove(CPoint point);

	CMFCCaptionButtonEx* GetSysButton(UINT nHit);

	void SetHighlightedSysButton(UINT nHitTest);
	void OnTrackCaptionButtons(CPoint point);
	void StopCaptionButtonsTracking();
	void RedrawCaptionButton(CMFCCaptionButtonEx* pBtn);
	void OnDWMCompositionChanged();

	AFX_IMPORT_DATA static CList<CFrameWnd*, CFrameWnd*> m_lstFrames;
};

extern AFX_IMPORT_DATA UINT AFX_WM_POSTSETPREVIEWFRAME;

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxglobalutils.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CDockingManager;
class CBasePane;
class CDockablePane;
class CPaneContainerManager;

class CGlobalUtils
{
public:
	CGlobalUtils();
	virtual ~CGlobalUtils();

	BOOL CheckAlignment(CPoint point, CBasePane* pBar, int nSensitivity, const CDockingManager* pDockManager,
		BOOL bOuterEdge, DWORD& dwAlignment, DWORD dwEnabledDockBars = CBRS_ALIGN_ANY, LPCRECT lpRectBounds = NULL) const;

	CDockingManager* GetDockingManager(CWnd* pWnd);
	
	void FlipRect(CRect& rect, int nDegrees);
	DWORD GetOppositeAlignment(DWORD dwAlign);
	void SetNewParent(CObList& lstControlBars, CWnd* pNewParent, BOOL bCheckVisibility = TRUE);
	void CalcExpectedDockedRect(CPaneContainerManager& barContainerManager, CWnd* pWndToDock,
		CPoint ptMouse, CRect& rectResult, BOOL& bDrawTab, CDockablePane** ppTargetBar);
	BOOL GetPaneAndAlignFromPoint(CPaneContainerManager& barContainerManager, CPoint pt,
		CDockablePane** ppTargetControlBar, DWORD& dwAlignment, BOOL& bTabArea, BOOL& bCaption);
	void ForceAdjustLayout(CDockingManager* pDockManager, BOOL bForce = FALSE, BOOL bForceInvisible = FALSE);
	BOOL CanPaneBeInFloatingMultiPaneFrameWnd(CWnd* pWnd) const;
	void AdjustRectToWorkArea(CRect& rect, CRect* pRectDelta = NULL);
	BOOL CanBeAttached(CWnd* pWnd) const;

	BOOL StringFromCy(CString& str, CY& cy);
	BOOL CyFromString(CY& cy, LPCTSTR psz);
	BOOL StringFromDecimal(CString& str, DECIMAL& decimal);
	BOOL DecimalFromString(DECIMAL& decimal, LPCTSTR psz);

	HICON GetWndIcon(CWnd* pWnd);

	BOOL m_bDialogApp;
	BOOL m_bIsDragging;
};

extern CGlobalUtils afxGlobalUtils;

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxhh.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFX_HH_H__
#define __AFX_HH_H__

#pragma once

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

// Non-Client HitTest help IDs
#define HID_HT_NOWHERE                          0x40000
#define HID_HT_CAPTION                          0x40002
#define HID_HT_HSCROLL                          0x40006
#define HID_HT_VSCROLL                          0x40007
#define HID_HT_MINBUTTON                        0x40008
#define HID_HT_MAXBUTTON                        0x40009
#define HID_HT_SIZE                             0x40012 // alias: ID_HT_BORDER
#define HID_HT_OBJECT							0x40013
#define HID_HT_CLOSE							0x40014
#define HID_HT_HELP								0x40015

// WM_SYSCOMMAND help IDs
#define HID_SC_SIZE                             0x1EF00
#define HID_SC_MOVE                             0x1EF01
#define HID_SC_MINIMIZE                         0x1EF02
#define HID_SC_MAXIMIZE                         0x1EF03
#define HID_SC_NEXTWINDOW                       0x1EF04
#define HID_SC_PREVWINDOW                       0x1EF05
#define HID_SC_CLOSE                            0x1EF06
#define HID_SC_RESTORE                          0x1EF12
#define HID_SC_TASKLIST                         0x1EF13

// File MRU and aliases
#define HID_FILE_MRU_FILE1                      0x1E11F

// Window menu list
#define HID_WINDOW_ALL                          0x1EF1F

// OLE menu and aliases
#define HID_OLE_VERB_1                          0x1E21F

// Commands (HID_*) 
#define HID_FILE_NEW                            0x1E100
#define HID_FILE_OPEN                           0x1E101
#define HID_FILE_CLOSE                          0x1E102
#define HID_FILE_SAVE                           0x1E103
#define HID_FILE_SAVE_AS                        0x1E104
#define HID_FILE_PAGE_SETUP                     0x1E105
#define HID_FILE_PRINT_SETUP                    0x1E106
#define HID_FILE_PRINT                          0x1E107
#define HID_FILE_PRINT_DIRECT                   0x1E108
#define HID_FILE_PRINT_PREVIEW                  0x1E109
#define HID_FILE_UPDATE                         0x1E10A
#define HID_FILE_SAVE_COPY_AS                   0x1E10B
#define HID_FILE_SEND_MAIL                      0x1E10C
#define HID_EDIT_CLEAR                          0x1E120
#define HID_EDIT_CLEAR_ALL                      0x1E121
#define HID_EDIT_COPY                           0x1E122
#define HID_EDIT_CUT                            0x1E123
#define HID_EDIT_FIND                           0x1E124
#define HID_EDIT_PASTE                          0x1E125
#define HID_EDIT_PASTE_LINK                     0x1E126
#define HID_EDIT_PASTE_SPECIAL                  0x1E127
#define HID_EDIT_REPEAT                         0x1E128
#define HID_EDIT_REPLACE                        0x1E129
#define HID_EDIT_SELECT_ALL                     0x1E12A
#define HID_EDIT_UNDO                           0x1E12B
#define HID_EDIT_REDO                           0x1E12C
#define HID_WINDOW_NEW                          0x1E130
#define HID_WINDOW_ARRANGE                      0x1E131
#define HID_WINDOW_CASCADE                      0x1E132
#define HID_WINDOW_TILE_HORZ                    0x1E133
#define HID_WINDOW_TILE_VERT                    0x1E134
#define HID_WINDOW_SPLIT                        0x1E135
#define HID_APP_ABOUT                           0x1E140
#define HID_APP_EXIT                            0x1E141
#define HID_HELP_INDEX                          0x1E142
#define HID_HELP_FINDER                         0x1E143
#define HID_HELP_USING                          0x1E144
#define HID_CONTEXT_HELP                        0x1E145
#define HID_NEXT_PANE                           0x1E150
#define HID_PREV_PANE                           0x1E151
#define HID_FORMAT_FONT                         0x1E160
#define HID_OLE_INSERT_NEW                      0x1E200
#define HID_OLE_EDIT_LINKS                      0x1E201
#define HID_OLE_EDIT_CONVERT                    0x1E202
#define HID_OLE_EDIT_CHANGE_ICON                0x1E203
#define HID_OLE_EDIT_PROPERTIES                 0x1E204
#define HID_VIEW_TOOLBAR                        0x1E800
#define HID_VIEW_STATUS_BAR                     0x1E801
#define HID_RECORD_FIRST                        0x1E900
#define HID_RECORD_LAST                         0x1E901
#define HID_RECORD_NEXT                         0x1E902
#define HID_RECORD_PREV                         0x1E903
#define HID_WIZBACK                             0x13023
#define HID_WIZNEXT                             0x13024
#define HID_WIZFINISH                           0x13025

// Dialogs (AFX_HIDD_*)
#define AFX_HIDD_FILEOPEN                       0x27004
#define AFX_HIDD_FILESAVE                       0x27005
#define AFX_HIDD_FONT                           0x27006
#define AFX_HIDD_COLOR                          0x27007
#define AFX_HIDD_PRINT                          0x27008
#define AFX_HIDD_PRINTSETUP                     0x27009
#define AFX_HIDD_FIND                           0x2700A
#define AFX_HIDD_REPLACE                        0x2700B
#define AFX_HIDD_NEWTYPEDLG                     0x27801
#define AFX_HIDD_PRINTDLG                       0x27802
#define AFX_HIDD_PREVIEW_TOOLBAR                0x27803
#define AFX_HIDD_PREVIEW_SHORTTOOLBAR           0x2780B
#define AFX_HIDD_INSERTOBJECT                   0x27804
#define AFX_HIDD_CHANGEICON                     0x27805
#define AFX_HIDD_CONVERT                        0x27806
#define AFX_HIDD_PASTESPECIAL                   0x27807
#define AFX_HIDD_EDITLINKS                      0x27808
#define AFX_HIDD_FILEBROWSE                     0x27809
#define AFX_HIDD_BUSY                           0x2780A
#define AFX_HIDD_OBJECTPROPERTIES               0x2780C
#define AFX_HIDD_CHANGESOURCE                   0x2780D

// Prompts/Errors (AFX_HIDP_*)
#define AFX_HIDP_NO_ERROR_AVAILABLE             0x3F020
#define AFX_HIDP_INVALID_FILENAME               0x3F100
#define AFX_HIDP_FAILED_TO_OPEN_DOC             0x3F101
#define AFX_HIDP_FAILED_TO_SAVE_DOC             0x3F102
#define AFX_HIDP_ASK_TO_SAVE                    0x3F103
#define AFX_HIDP_FAILED_TO_CREATE_DOC           0x3F104
#define AFX_HIDP_FILE_TOO_LARGE                 0x3F105
#define AFX_HIDP_FAILED_TO_START_PRINT          0x3F106
#define AFX_HIDP_FAILED_TO_LAUNCH_HELP          0x3F107
#define AFX_HIDP_INTERNAL_FAILURE               0x3F108
#define AFX_HIDP_COMMAND_FAILURE                0x3F109
#define AFX_HIDP_FAILED_MEMORY_ALLOC            0x3F10A
#define AFX_HIDP_UNREG_DONE                     0x3F10B
#define AFX_HIDP_UNREG_FAILURE                  0x3F10C
#define AFX_HIDP_DLL_LOAD_FAILED                0x3F10D
#define AFX_HIDP_DLL_BAD_VERSION                0x3F10E
#define AFX_HIDP_PARSE_INT                      0x3F110
#define AFX_HIDP_PARSE_REAL                     0x3F111
#define AFX_HIDP_PARSE_INT_RANGE                0x3F112
#define AFX_HIDP_PARSE_REAL_RANGE               0x3F113
#define AFX_HIDP_PARSE_STRING_SIZE              0x3F114
#define AFX_HIDP_PARSE_RADIO_BUTTON             0x3F115
#define AFX_HIDP_PARSE_BYTE                     0x3F116
#define AFX_HIDP_PARSE_UINT                     0x3F117
#define AFX_HIDP_PARSE_DATETIME                 0x3F118
#define AFX_HIDP_PARSE_CURRENCY                 0x3F119
#define AFX_HIDP_FAILED_INVALID_FORMAT          0x3F120
#define AFX_HIDP_FAILED_INVALID_PATH            0x3F121
#define AFX_HIDP_FAILED_DISK_FULL               0x3F122
#define AFX_HIDP_FAILED_ACCESS_READ             0x3F123
#define AFX_HIDP_FAILED_ACCESS_WRITE            0x3F124
#define AFX_HIDP_FAILED_IO_ERROR_READ           0x3F125
#define AFX_HIDP_FAILED_IO_ERROR_WRITE          0x3F126
#define AFX_HIDP_STATIC_OBJECT                  0x3F180
#define AFX_HIDP_FAILED_TO_CONNECT              0x3F181
#define AFX_HIDP_SERVER_BUSY                    0x3F182
#define AFX_HIDP_BAD_VERB                       0x3F183
#define AFX_HIDP_FAILED_TO_NOTIFY               0x3F185
#define AFX_HIDP_FAILED_TO_LAUNCH               0x3F186
#define AFX_HIDP_ASK_TO_UPDATE                  0x3F187
#define AFX_HIDP_FAILED_TO_UPDATE               0x3F188
#define AFX_HIDP_FAILED_TO_REGISTER             0x3F189
#define AFX_HIDP_FAILED_TO_AUTO_REGISTER        0x3F18A
#define AFX_HIDP_FAILED_TO_CONVERT              0x3F18B
#define AFX_HIDP_GET_NOT_SUPPORTED              0x3F18C
#define AFX_HIDP_SET_NOT_SUPPORTED              0x3F18D
#define AFX_HIDP_ASK_TO_DISCARD                 0x3F18E
#define AFX_HIDP_FAILED_TO_CREATE               0x3F18F
#define AFX_HIDP_FAILED_MAPI_LOAD               0x3F190
#define AFX_HIDP_INVALID_MAPI_DLL               0x3F191
#define AFX_HIDP_FAILED_MAPI_SEND               0x3F192
#define AFX_HIDP_FILE_NONE                      0x3F1A0
#define AFX_HIDP_FILE_GENERIC                   0x3F1A1
#define AFX_HIDP_FILE_NOT_FOUND                 0x3F1A2
#define AFX_HIDP_FILE_BAD_PATH                  0x3F1A3
#define AFX_HIDP_FILE_TOO_MANY_OPEN             0x3F1A4
#define AFX_HIDP_FILE_ACCESS_DENIED             0x3F1A5
#define AFX_HIDP_FILE_INVALID_FILE              0x3F1A6
#define AFX_HIDP_FILE_REMOVE_CURRENT            0x3F1A7
#define AFX_HIDP_FILE_DIR_FULL                  0x3F1A8
#define AFX_HIDP_FILE_BAD_SEEK                  0x3F1A9
#define AFX_HIDP_FILE_HARD_IO                   0x3F1AA
#define AFX_HIDP_FILE_SHARING                   0x3F1AB
#define AFX_HIDP_FILE_LOCKING                   0x3F1AC
#define AFX_HIDP_FILE_DISKFULL                  0x3F1AD
#define AFX_HIDP_FILE_EOF                       0x3F1AE
#define AFX_HIDP_ARCH_NONE                      0x3F1B0
#define AFX_HIDP_ARCH_GENERIC                   0x3F1B1
#define AFX_HIDP_ARCH_READONLY                  0x3F1B2
#define AFX_HIDP_ARCH_ENDOFFILE                 0x3F1B3
#define AFX_HIDP_ARCH_WRITEONLY                 0x3F1B4
#define AFX_HIDP_ARCH_BADINDEX                  0x3F1B5
#define AFX_HIDP_ARCH_BADCLASS                  0x3F1B6
#define AFX_HIDP_ARCH_BADSCHEMA                 0x3F1B7
#define AFX_HIDP_SQL_CONNECT_FAIL               0x3F281
#define AFX_HIDP_SQL_RECORDSET_FORWARD_ONLY     0x3F282
#define AFX_HIDP_SQL_EMPTY_COLUMN_LIST          0x3F283
#define AFX_HIDP_SQL_FIELD_SCHEMA_MISMATCH      0x3F284
#define AFX_HIDP_SQL_ILLEGAL_MODE               0x3F285
#define AFX_HIDP_SQL_MULTIPLE_ROWS_AFFECTED     0x3F286
#define AFX_HIDP_SQL_NO_CURRENT_RECORD          0x3F287
#define AFX_HIDP_SQL_NO_ROWS_AFFECTED           0x3F288
#define AFX_HIDP_SQL_RECORDSET_READONLY         0x3F289
#define AFX_HIDP_SQL_SQL_NO_TOTAL               0x3F28A
#define AFX_HIDP_SQL_ODBC_LOAD_FAILED           0x3F28B
#define AFX_HIDP_SQL_DYNASET_NOT_SUPPORTED      0x3F28C
#define AFX_HIDP_SQL_SNAPSHOT_NOT_SUPPORTED     0x3F28D
#define AFX_HIDP_SQL_API_CONFORMANCE            0x3F28E
#define AFX_HIDP_SQL_SQL_CONFORMANCE            0x3F28F
#define AFX_HIDP_SQL_NO_DATA_FOUND              0x3F290
#define AFX_HIDP_SQL_ROW_UPDATE_NOT_SUPPORTED   0x3F291
#define AFX_HIDP_SQL_ODBC_V2_REQUIRED           0x3F292
#define AFX_HIDP_SQL_NO_POSITIONED_UPDATES      0x3F293
#define AFX_HIDP_SQL_LOCK_MODE_NOT_SUPPORTED    0x3F294
#define AFX_HIDP_SQL_DATA_TRUNCATED             0x3F295
#define AFX_HIDP_SQL_ROW_FETCH                  0x3F296
#define AFX_HIDP_SQL_INCORRECT_ODBC             0x3F297
#define AFX_HIDP_SQL_UPDATE_DELETE_FAILED       0x3F298
#define AFX_HIDP_SQL_DYNAMIC_CURSOR_NOT_SUPPORTED	0x3F299
#define AFX_HIDP_SQL_FIELD_NOT_FOUND            0x3F29A
#define AFX_HIDP_SQL_BOOKMARKS_NOT_SUPPORTED    0x3F29B
#define AFX_HIDP_SQL_BOOKMARKS_NOT_ENABLED      0x3F29C
#define AFX_HIDP_DAO_ENGINE_INITIALIZATION      0x3F2B0
#define AFX_HIDP_DAO_DFX_BIND                   0x3F2B1
#define AFX_HIDP_DAO_OBJECT_NOT_OPEN            0x3F2B2
#define AFX_HIDP_DAO_ROWTOOSHORT                0x3F2B3
#define AFX_HIDP_DAO_BADBINDINFO                0x3F2B4
#define AFX_HIDP_DAO_COLUMNUNAVAILABLE          0x3F2B5

// Frame Controls (AFX_HIDW_*)
#define AFX_HIDW_TOOLBAR                        0x5E800
#define AFX_HIDW_STATUS_BAR                     0x5E801
#define AFX_HIDW_PREVIEW_BAR                    0x5E802
#define AFX_HIDW_RESIZE_BAR                     0x5E803
#define AFX_HIDW_DOCKBAR_TOP                    0x5E81B
#define AFX_HIDW_DOCKBAR_LEFT                   0x5E81C
#define AFX_HIDW_DOCKBAR_RIGHT                  0x5E81D
#define AFX_HIDW_DOCKBAR_BOTTOM                 0x5E81E
#define AFX_HIDW_DOCKBAR_FLOAT                  0x5E81F

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif // __AFX_HH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxheaderctrl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCHeaderCtrl window

class CMFCHeaderCtrl : public CHeaderCtrl
{
	DECLARE_DYNAMIC(CMFCHeaderCtrl)

// Construction
public:
	CMFCHeaderCtrl();

// Attributes
public:
	int GetSortColumn() const;
	BOOL IsAscending() const;
	int GetColumnState(int iColumn) const; // Returns: 0 - not not sorted, -1 - descending, 1 - ascending

	BOOL IsMultipleSort() const { return m_bMultipleSort; }
	BOOL IsDialogControl() const { return m_bIsDlgControl; }

protected:
	CMap<int,int,int,int> m_mapColumnsStatus; // -1, 1, 0
	BOOL  m_bIsMousePressed;
	BOOL  m_bMultipleSort;
	BOOL  m_bAscending;
	BOOL  m_bTracked;
	BOOL  m_bIsDlgControl;
	int   m_nHighlightedItem;
	HFONT m_hFont;

// Operations
public:
	void SetSortColumn(int iColumn, BOOL bAscending = TRUE, BOOL bAdd = FALSE);
	void RemoveSortColumn(int iColumn);
	void EnableMultipleSort(BOOL bEnable = TRUE);

// Overrides
protected:
	virtual void PreSubclassWindow();
	virtual void OnDrawItem(CDC* pDC, int iItem, CRect rect, BOOL bIsPressed, BOOL bIsHighlighted);
	virtual void OnFillBackground(CDC* pDC);
	virtual void OnDrawSortArrow(CDC* pDC, CRect rectArrow);

// Implementation
public:
	virtual ~CMFCHeaderCtrl();

protected:
	//{{AFX_MSG(CMFCHeaderCtrl)
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnPaint();
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnCancelMode();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg LRESULT OnMouseLeave(WPARAM,LPARAM);
	afx_msg LRESULT OnSetFont(WPARAM, LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void CommonInit();
	CFont* SelectFont(CDC *pDC);
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxglobals.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.
//
#pragma once

#include "afxcontrolbarutil.h"

#include "afxaccessibility.h"
#include <oleacc.h>

#if (NTDDI_VERSION >= NTDDI_WIN7)
#include <shobjidl.h>
#endif

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// Auxiliary System/Screen metrics

typedef enum AFX_DOCK_TYPE
{
	DT_UNDEFINED = 0,    // inherit from application
	DT_IMMEDIATE = 1,    // control bar torn off immediately and follows the mouse
	DT_STANDARD  = 2,    // user drags a frame
	DT_SMART     = 0x80  // smart docking style
};

// autohide sliding modes
static const UINT AFX_AHSM_MOVE    = 1;
static const UINT AFX_AHSM_STRETCH = 2;

#define AFX_AUTOHIDE_LEFT   0x0001
#define AFX_AUTOHIDE_RIGHT  0x0002
#define AFX_AUTOHIDE_TOP    0x0004
#define AFX_AUTOHIDE_BOTTOM 0x0008

typedef HANDLE AFX_HPAINTBUFFER;  // handle to a buffered paint context

typedef HRESULT (__stdcall * DRAWTHEMEPARENTBACKGROUND)(HWND hWnd, HDC hdc,const RECT *pRec);

typedef enum _AFX_BP_BUFFERFORMAT
{
	AFX_BPBF_COMPATIBLEBITMAP,    // Compatible bitmap
	AFX_BPBF_DIB,                 // Device-independent bitmap
	AFX_BPBF_TOPDOWNDIB,          // Top-down device-independent bitmap
	AFX_BPBF_TOPDOWNMONODIB       // Top-down monochrome device-independent bitmap
} AFX_BP_BUFFERFORMAT;

typedef struct _AFX_BP_PAINTPARAMS
{
	DWORD                       cbSize;
	DWORD                       dwFlags; // BPPF_ flags
	const RECT *                prcExclude;
	const BLENDFUNCTION *       pBlendFunction;
} AFX_BP_PAINTPARAMS;

typedef HRESULT (__stdcall * BUFFEREDPAINTINIT)(VOID);
typedef HRESULT (__stdcall * BUFFEREDPAINTUNINIT)(VOID);
typedef AFX_HPAINTBUFFER (__stdcall * BEGINBUFFEREDPAINT)(HDC hdcTarget, const RECT* rcTarget, AFX_BP_BUFFERFORMAT dwFormat, AFX_BP_PAINTPARAMS *pPaintParams, HDC *phdc);
typedef HRESULT (__stdcall * ENDBUFFEREDPAINT)(AFX_HPAINTBUFFER hBufferedPaint, BOOL fUpdateTarget);

typedef struct _AFX_MARGINS {
	int cxLeftWidth;
	int cxRightWidth;
	int cyTopHeight;
	int cyBottomHeight;
} AFX_MARGINS;

typedef HRESULT (__stdcall * DWMEXTENDFRAMEINTOCLIENTAREA)(HWND hWnd, const AFX_MARGINS* pMargins);
typedef HRESULT (__stdcall * DWMDEFWINDOWPROC)(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult);
typedef HRESULT (__stdcall * DWMISCOMPOSITIONENABLED)(BOOL* pfEnabled);

typedef int (WINAPI *AFX_DTT_CALLBACK_PROC)(HDC hdc, LPWSTR pszText, int cchText, LPRECT prc, UINT dwFlags, LPARAM lParam);

typedef struct _AFX_DTTOPTS {
	DWORD dwSize;
	DWORD dwFlags;
	COLORREF crText;
	COLORREF crBorder;
	COLORREF crShadow;
	int iTextShadowType;
	POINT ptShadowOffset;
	int nBorderSize;
	int iFontPropId;
	int iColorPropId;
	int iStateId;
	BOOL fApplyOverlay;
	int iGlowSize;
	AFX_DTT_CALLBACK_PROC pfnDrawTextCallback;
	LPARAM lParam;
} AFX_DTTOPTS;

typedef HRESULT (__stdcall * DRAWTHEMETEXTEX)(HTHEME hTheme, HDC hdc, int iPartId, int iStateId, LPCWSTR pszText, int iCharCount, DWORD dwFlags, LPRECT pRect, const AFX_DTTOPTS *pOptions);

class CMFCToolBarImages;

struct AFX_GLOBAL_DATA
{
	friend class CMemDC;

	BOOL m_bUseSystemFont;	// Use system font for menu/toolbar/ribbons
	BOOL m_bInSettingChange;

	// solid brushes with convenient gray colors and system colors
	HBRUSH hbrBtnHilite, hbrBtnShadow;
	HBRUSH hbrWindow;

	// color values of system colors used for CToolBar
	COLORREF clrBtnFace, clrBtnShadow, clrBtnHilite;
	COLORREF clrBtnText, clrWindowFrame;
	COLORREF clrBtnDkShadow, clrBtnLight;
	COLORREF clrGrayedText;
	COLORREF clrHilite;
	COLORREF clrTextHilite;
	COLORREF clrHotLinkNormalText;
	COLORREF clrHotLinkHoveredText;
	COLORREF clrHotLinkVisitedText;

	COLORREF clrBarWindow;
	COLORREF clrBarFace;
	COLORREF clrBarShadow, clrBarHilite;
	COLORREF clrBarDkShadow, clrBarLight;
	COLORREF clrBarText;

	COLORREF clrWindow;
	COLORREF clrWindowText;

	COLORREF clrCaptionText;
	COLORREF clrMenuText;
	COLORREF clrActiveCaption;
	COLORREF clrInactiveCaption;
	COLORREF clrInactiveCaptionText;
	///<summary>
	/// Specifies gradient color of active caption. Generally used for docking panes. </summary>
	COLORREF clrActiveCaptionGradient;
	///<summary>
	/// Specifies gradient color of inactive active caption. Generally used for docking panes. </summary>
	COLORREF clrInactiveCaptionGradient;

	COLORREF clrActiveBorder;
	COLORREF clrInactiveBorder;

	CBrush brBtnFace;
	CBrush brHilite;
	CBrush brLight;
	CBrush brBlack;
	CBrush brActiveCaption;
	CBrush brInactiveCaption;
	CBrush brWindow;

	CBrush brBarFace;

	CPen penHilite;
	CPen penBarFace;
	CPen penBarShadow;

	// Library cursors:
	HCURSOR m_hcurStretch;
	HCURSOR m_hcurStretchVert;
	HCURSOR m_hcurHand;
	HCURSOR m_hcurSizeAll;
	HCURSOR m_hcurMoveTab;
	HCURSOR m_hcurNoMoveTab;

	HCURSOR GetHandCursor();

	HICON m_hiconTool;
	HICON m_hiconLink;
	HICON m_hiconColors;

	// Shell icon sizes:
	CSize m_sizeSmallIcon;

	// Toolbar and menu fonts:
	CFont fontRegular;
	CFont fontTooltip;
	CFont fontBold;
	CFont fontDefaultGUIBold;
	CFont fontUnderline;
	CFont fontDefaultGUIUnderline;
	CFont fontVert;
	CFont fontVertCaption;
	CFont fontSmall;
	CFont fontMarlett;	// Standard Windows menu symbols
	CRect m_rectVirtual;

	BOOL  bIsWindowsVista;
	///<summary>
	/// Indicates whether the application is being executed under Windows 7 OS or higher</summary>
	BOOL  bIsWindows7;
	BOOL  bDisableAero;
	BOOL  bIsRemoteSession;

	BOOL  m_bIsBlackHighContrast;
	BOOL  m_bIsWhiteHighContrast;
	BOOL  m_bUseBuiltIn32BitIcons;
	BOOL  m_bMenuAnimation;
	BOOL  m_bMenuFadeEffect;
	BOOL  m_bIsRTL;
	BOOL  m_bEnableAccessibility;

	BOOL m_bUnderlineKeyboardShortcuts;
	BOOL m_bSysUnderlineKeyboardShortcuts;

	BOOL m_bRefreshAutohideBars;

	int   m_nBitsPerPixel;
	int   m_nDragFrameThicknessFloat;
	int   m_nDragFrameThicknessDock;
	int   m_nAutoHideToolBarSpacing;
	int   m_nAutoHideToolBarMargin;
	int   m_nCoveredMainWndClientAreaPercent;
	int   m_nMaxToolTipWidth;
	int   m_nShellAutohideBars;

// Implementation
	AFX_GLOBAL_DATA();
	~AFX_GLOBAL_DATA();

	void UpdateSysColors();
	void UpdateFonts();
	void OnSettingChange();

	BOOL SetMenuFont(LPLOGFONT lpLogFont, BOOL bHorz);

	int GetTextHeight(BOOL bHorz = TRUE)
	{
		return bHorz ? m_nTextHeightHorz : m_nTextHeightVert;
	}

	int GetTextWidth(BOOL bHorz = TRUE)
	{
		return bHorz ? m_nTextWidthHorz : m_nTextWidthVert;
	}

	double GetRibbonImageScale()
	{
		return m_bIsRibbonImageScale ? m_dblRibbonImageScale : 1.;
	}

	void EnableRibbonImageScale(BOOL bEnable = TRUE)
	{
		m_bIsRibbonImageScale = bEnable;
	}

	BOOL IsRibbonImageScaleEnabled()
	{
		return m_bIsRibbonImageScale;
	}

	BOOL IsWindowsThemingDrawParentBackground() const
	{
		return m_pfDrawThemeBackground != NULL;
	}

	BOOL DrawParentBackground(CWnd* pWnd, CDC* pDC, LPRECT lpRect = NULL);
	void CleanUp();

	COLORREF GetColor(int nColor);

	BOOL SetLayeredAttrib(HWND hwnd, COLORREF crKey, BYTE bAlpha, DWORD dwFlags);
	BOOL IsWindowsLayerSupportAvailable() const
	{
		return TRUE;
	}

	BOOL Is32BitIcons() const
	{
		return m_bUseBuiltIn32BitIcons && m_nBitsPerPixel >= 16 && !m_bIsBlackHighContrast && !m_bIsWhiteHighContrast;
	}

	BOOL IsHighContrastMode() const
	{
		return m_bIsWhiteHighContrast || m_bIsBlackHighContrast;
	}

	BOOL IsAccessibilitySupport() const
	{
		return m_bEnableAccessibility;
	}

	/// <summary>
	/// Determines positions of Shell auto hide bars.</summary>
	/// <returns> An integer value with encoded flags that specify positions of auto hide bars.
	/// It may combine the following values: AFX_AUTOHIDE_BOTTOM, AFX_AUTOHIDE_TOP, AFX_AUTOHIDE_LEFT, 
	/// AFX_AUTOHIDE_RIGHT.</returns>
	int GetShellAutohideBars()
	{
		if (m_bRefreshAutohideBars)
		{
			m_bRefreshAutohideBars = FALSE;

			APPBARDATA abd;
			ZeroMemory(&abd, sizeof(APPBARDATA));
			abd.cbSize = sizeof(APPBARDATA);

			abd.uEdge = ABE_BOTTOM;
			if (SHAppBarMessage(ABM_GETAUTOHIDEBAR, &abd))
			{
				m_nShellAutohideBars |= AFX_AUTOHIDE_BOTTOM;
			}

			abd.uEdge = ABE_TOP;
			if (SHAppBarMessage(ABM_GETAUTOHIDEBAR, &abd))
			{
				m_nShellAutohideBars |= AFX_AUTOHIDE_TOP;
			}

			abd.uEdge = ABE_LEFT;
			if (SHAppBarMessage(ABM_GETAUTOHIDEBAR, &abd))
			{
				m_nShellAutohideBars |= AFX_AUTOHIDE_LEFT;
			}

			abd.uEdge = ABE_RIGHT;
			if (SHAppBarMessage(ABM_GETAUTOHIDEBAR, &abd))
			{
				m_nShellAutohideBars |= AFX_AUTOHIDE_RIGHT;
			}
		}

		return m_nShellAutohideBars;
	}

	void EnableAccessibilitySupport(BOOL bEnable = TRUE);

	CString RegisterWindowClass(LPCTSTR lpszClassNamePrefix);
	BOOL ExcludeTag(CString& strBuffer, LPCTSTR lpszTag, CString& strTag, BOOL bIsCharsList = FALSE);

	BOOL DwmExtendFrameIntoClientArea(HWND hWnd, AFX_MARGINS* pMargins);
	LRESULT DwmDefWindowProc(HWND hWnd, UINT message, WPARAM wp, LPARAM lp);
	BOOL DwmIsCompositionEnabled();

	BOOL DrawTextOnGlass(HTHEME hTheme, CDC* pDC, int iPartId, int iStateId, CString strText,
		CRect rect, DWORD dwFlags, int nGlowSize = 0, COLORREF clrText = (COLORREF)-1);

	BOOL Resume();
	BOOL GetNonClientMetrics (NONCLIENTMETRICS& info);

#if (WINVER >= 0x0600)
	/// <summary>
	/// Creates and initializes a Shell item object from a parsing name.</summary>
	/// <param name="pszPath">[in] A pointer to a display name.</param> 
	/// <param name="pbc">A pointer to a bind context that controls the parsing operation.</param> 
	/// <param name="riid">A reference to an interface ID.</param> 
	/// <param name="ppv">[out] When this function returns, contains the interface pointer requested in riid. This will typically be IShellItem or IShellItem2.</param> 
	/// <returns>Returns S_OK if successful, or an error value otherwise. </returns>
	HRESULT ShellCreateItemFromParsingName(PCWSTR pszPath, IBindCtx *pbc, REFIID riid, void **ppv);
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
	/// <summary>
	/// Creates and stores in the global data a pointer to ITaskBarList interface.</summary>
	/// <returns>A pointer to ITaskbarList interface if creation of a task bar list object succeeds, or NULL if creation fails or current
	/// Operation System is less than Windows 7.</returns>
	ITaskbarList  *GetITaskbarList();

	/// <summary>
	/// Creates and stores in the global data a pointer to ITaskBarList3 interface.</summary>
	/// <returns>A pointer to ITaskbarList3 interface if creation creation of a task bar list object succeeds, or NULL if creation fails or current
	/// Operation System is less than Windows 7.</returns>
	ITaskbarList3 *GetITaskbarList3();

	/// <summary>
	/// Releases interfaces obtained through GetITaskbarList and GetITaskbarList3 methods.</summary>
	void ReleaseTaskBarRefs();
#endif

protected:

	void UpdateTextMetrics();
	HBITMAP CreateDitherBitmap(HDC hDC);
	
	int m_nTextHeightHorz;
	int m_nTextHeightVert;
	int m_nTextWidthHorz;
	int m_nTextWidthVert;

	double m_dblRibbonImageScale;
	BOOL   m_bIsRibbonImageScale;
	BOOL   m_bBufferedPaintInited;

	HINSTANCE m_hinstUXThemeDLL;
	HINSTANCE m_hinstDwmapiDLL;

	DRAWTHEMEPARENTBACKGROUND    m_pfDrawThemeBackground;
	DRAWTHEMETEXTEX              m_pfDrawThemeTextEx;
	BUFFEREDPAINTINIT            m_pfBufferedPaintInit;
	BUFFEREDPAINTUNINIT          m_pfBufferedPaintUnInit;
	BEGINBUFFEREDPAINT           m_pfBeginBufferedPaint;
	ENDBUFFEREDPAINT             m_pfEndBufferedPaint;
	DWMEXTENDFRAMEINTOCLIENTAREA m_pfDwmExtendFrameIntoClientArea;
	DWMDEFWINDOWPROC             m_pfDwmDefWindowProc;
	DWMISCOMPOSITIONENABLED      m_pfDwmIsCompositionEnabled;

#if (NTDDI_VERSION >= NTDDI_WIN7)
	BOOL m_bComInitialized;
	BOOL m_bTaskBarInterfacesAvailable;
	ITaskbarList*  m_pTaskbarList;
	ITaskbarList3* m_pTaskbarList3;
#endif
};

AFX_IMPORT_DATA extern AFX_GLOBAL_DATA afxGlobalData;

#define AFX_IMAGE_MARGIN 4

// MFC Control bar compatibility
#define AFX_CX_BORDER   1
#define AFX_CY_BORDER   1

#define AFX_CX_GRIPPER  3
#define AFX_CY_GRIPPER  3
#define AFX_CX_BORDER_GRIPPER 2
#define AFX_CY_BORDER_GRIPPER 2

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxfullscreenimpl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

class CMFCToolBar;
class CFrameImpl;

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CFullScreenImpl
{
public:
	CFullScreenImpl(CFrameImpl* pFrameImpl);
	virtual ~CFullScreenImpl();

	void ShowFullScreen();

	void ShowFullScreen(CFrameWnd* pFrame);
	void RestoreState(CFrameWnd* pFrame);

	CRect GetFullScreenRect() const { return m_rectFullScreenWindow; }

	BOOL IsFullScreen() const { return m_bFullScreen; }

	void EnableMainMenu(BOOL bShow = TRUE)
	{
		m_bShowMenu = bShow;
	}
	void SetFullScreenID(UINT uiFullScreenID)
	{
		m_uiFullScreenID = uiFullScreenID;
	}

	void EnableTabsArea(BOOL bShowTabs)
	{
		m_bTabsArea = bShowTabs;
	}

	void OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI);

protected:
	CRect           m_rectFullScreenWindow;
	CMFCToolBar* m_pwndFullScreenBar;
	BOOL            m_bFullScreen;
	BOOL            m_bShowMenu;
	CRect           m_rectFramePrev;
	CFrameImpl*  m_pImpl;
	UINT            m_uiFullScreenID;
	BOOL            m_bTabsArea;
	CString         m_strRegSection;

protected:
	void UndockAndHidePanes(CFrameWnd* pFrame);
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxhtml.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXHTML_H__
#define __AFXHTML_H__

#pragma once

#ifndef __AFXDISP_H__
	#include <afxdisp.h>
#endif

#ifndef __exdisp_h__
	#include <exdisp.h>
#endif

#ifndef __mshtmhst_h__
#include <mshtmhst.h>
#endif

#ifndef __mshtml_h__
#include <mshtml.h>
#endif

#ifndef __mshtmcid_h__
#include <mshtmcid.h>
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#pragma warning(push)
#pragma warning(disable:4571)//catch(...) blocks compiled with /EHs do NOT catch or re-throw Structured Exceptions

/////////////////////////////////////////////////////////////////////////////
// AFXHTML - MFC Visual HTML classes

// Classes declared in this file

//CObject
	//CCmdTarget;
		//CWnd,CHtmlEditCtrlBase<CHtmlEditCtrl>
			class CHtmlEditCtrl;

//CObject
	//CCmdTarget;
		//CWnd
			//CView
				//CScrollView
					//CFormView
						class CHtmlView;

//CObject
	//CCmdTarget;
		//CWnd
			//CView
				//CScrollView
					//CFormView,CHtmlEditCtrlBase<CHtmlEditView>
						class CHtmlEditView;

//CObject
	//CCmdTarget;
		//CDocument
			class CHtmlEditDoc;


#undef AFX_DATA
#define AFX_DATA AFX_OLE_DATA

/////////////////////////////////////////////////////////////////////////////
// CHtmlView

class CHtmlView : public CFormView
{
protected: // create from serialization only
	CHtmlView();
	DECLARE_DYNCREATE(CHtmlView)
	DECLARE_EVENTSINK_MAP()

// Attributes
public:
	CString GetType() const;
	long GetLeft() const;
	void SetLeft(long nNewValue);
	long GetTop() const;
	void SetTop(long nNewValue);
	long GetHeight() const;
	void SetHeight(long nNewValue);
	long GetWidth() const;
	void SetWidth(long nNewValue);
	void SetVisible(BOOL bNewValue);
	BOOL GetVisible() const;
	CString GetLocationName() const;
	READYSTATE GetReadyState() const;
	BOOL GetOffline() const;
	void SetOffline(BOOL bNewValue);
	BOOL GetSilent() const;
	void SetSilent(BOOL bNewValue);
	BOOL GetTopLevelContainer() const;
	CString GetLocationURL() const;
	BOOL GetBusy() const;
	LPDISPATCH GetApplication() const;
	LPDISPATCH GetParentBrowser() const;
	LPDISPATCH GetContainer() const;
	LPDISPATCH GetHtmlDocument() const;
	CString GetFullName() const;
	int GetToolBar() const;
	void SetToolBar(int nNewValue);
	BOOL GetMenuBar() const;
	void SetMenuBar(BOOL bNewValue);
	BOOL GetFullScreen() const;
	void SetFullScreen(BOOL bNewValue);
	OLECMDF QueryStatusWB(OLECMDID cmdID) const;
	BOOL GetRegisterAsBrowser() const;
	void SetRegisterAsBrowser(BOOL bNewValue);
	BOOL GetRegisterAsDropTarget() const;
	void SetRegisterAsDropTarget(BOOL bNewValue);
	BOOL GetTheaterMode() const;
	void SetTheaterMode(BOOL bNewValue);
	BOOL GetAddressBar() const;
	void SetAddressBar(BOOL bNewValue);
	BOOL GetStatusBar() const;
	void SetStatusBar(BOOL bNewValue);

// Operations
public:
	void GoBack();
	void GoForward();
	void GoHome();
	void GoSearch();
	void Navigate(LPCTSTR URL, DWORD dwFlags = 0,
		LPCTSTR lpszTargetFrameName = NULL,
		LPCTSTR lpszHeaders = NULL, LPVOID lpvPostData = NULL,
		DWORD dwPostDataLen = 0);
	void Navigate2(LPITEMIDLIST pIDL, DWORD dwFlags = 0,
		LPCTSTR lpszTargetFrameName = NULL);
	void Navigate2(LPCTSTR lpszURL, DWORD dwFlags = 0,
		LPCTSTR lpszTargetFrameName = NULL,	LPCTSTR lpszHeaders = NULL,
		LPVOID lpvPostData = NULL, DWORD dwPostDataLen = 0);
	void Navigate2(LPCTSTR lpszURL, DWORD dwFlags,
		CByteArray& baPostedData,
		LPCTSTR lpszTargetFrameName = NULL, LPCTSTR lpszHeader = NULL);
	void Refresh();
	void Refresh2(int nLevel);
	void Stop();
	void PutProperty(LPCTSTR lpszProperty, const VARIANT& vtValue);
	void PutProperty(LPCTSTR lpszPropertyName, double dValue);
	void PutProperty(LPCTSTR lpszPropertyName, LPCTSTR lpszValue);
	void PutProperty(LPCTSTR lpszPropertyName, long lValue);
	void PutProperty(LPCTSTR lpszPropertyName, short nValue);
	BOOL GetProperty(LPCTSTR lpszProperty, CString& strValue);
	COleVariant GetProperty(LPCTSTR lpszProperty);
	void ExecWB(OLECMDID cmdID, OLECMDEXECOPT cmdexecopt, VARIANT* pvaIn,
		VARIANT* pvaOut);
	virtual BOOL GetSource(CString& strRef);
	BOOL LoadFromResource(LPCTSTR lpszResource);
	BOOL LoadFromResource(UINT nRes);

	HRESULT QueryFormsCommand(DWORD dwCommandID, BOOL* pbSupported,
								BOOL* pbEnabled, BOOL* pbChecked);
	HRESULT ExecFormsCommand(DWORD dwCommandID, VARIANT* pVarIn,
								VARIANT* pVarOut);

// Overrides
public:
	virtual BOOL CreateControlSite(COleControlContainer* pContainer, 
	   COleControlSite** ppSite, UINT nID, REFCLSID clsid);
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName,
		DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

	//{{AFX_MSG(CHtmlView)
	afx_msg void OnFilePrint();
	//}}AFX_MSG

	// DocHostUIHandler overrideables
	virtual HRESULT OnShowContextMenu(DWORD dwID, LPPOINT ppt,
		LPUNKNOWN pcmdtReserved, LPDISPATCH pdispReserved);
	virtual HRESULT OnGetExternal(LPDISPATCH *lppDispatch);
	virtual HRESULT OnGetHostInfo(DOCHOSTUIINFO *pInfo);
	virtual HRESULT OnShowUI(DWORD dwID,
		LPOLEINPLACEACTIVEOBJECT pActiveObject,
		LPOLECOMMANDTARGET pCommandTarget, LPOLEINPLACEFRAME pFrame,
		LPOLEINPLACEUIWINDOW pDoc);
	virtual HRESULT OnHideUI();
	virtual HRESULT OnUpdateUI();
	virtual HRESULT OnEnableModeless(BOOL fEnable);
	virtual HRESULT OnDocWindowActivate(BOOL fActivate);
	virtual HRESULT OnFrameWindowActivate(BOOL fActivate);
	virtual HRESULT OnResizeBorder(LPCRECT prcBorder,
		LPOLEINPLACEUIWINDOW pUIWindow, BOOL fFrameWindow);
	virtual HRESULT OnTranslateAccelerator(LPMSG lpMsg,
		const GUID* pguidCmdGroup, DWORD nCmdID);
	virtual HRESULT OnGetOptionKeyPath(LPOLESTR* pchKey, DWORD dwReserved);
	virtual HRESULT OnFilterDataObject(LPDATAOBJECT pDataObject,
		LPDATAOBJECT* ppDataObject);
	virtual HRESULT OnTranslateUrl(DWORD dwTranslate,
		OLECHAR* pchURLIn, OLECHAR** ppchURLOut);
	virtual HRESULT OnGetDropTarget(LPDROPTARGET pDropTarget,
		LPDROPTARGET* ppDropTarget);

	// Events
	virtual void OnNavigateComplete2(LPCTSTR strURL);
	virtual void OnBeforeNavigate2(LPCTSTR lpszURL, DWORD nFlags,
		LPCTSTR lpszTargetFrameName, CByteArray& baPostedData,
		LPCTSTR lpszHeaders, BOOL* pbCancel);
	virtual void OnStatusTextChange(LPCTSTR lpszText);
	virtual void OnProgressChange(long nProgress, long nProgressMax);
	virtual void OnCommandStateChange(long nCommand, BOOL bEnable);
	virtual void OnDownloadBegin();
	virtual void OnDownloadComplete();
	virtual void OnTitleChange(LPCTSTR lpszText);
	virtual void OnPropertyChange(LPCTSTR lpszProperty);
	virtual void OnNewWindow2(LPDISPATCH* ppDisp, BOOL* Cancel);
	virtual void OnDocumentComplete(LPCTSTR lpszURL);
	virtual void OnQuit();
	virtual void OnVisible(BOOL bVisible);
	virtual void OnToolBar(BOOL bToolBar);
	virtual void OnMenuBar(BOOL bMenuBar);
	virtual void OnStatusBar(BOOL bStatusBar);
	virtual void OnFullScreen(BOOL bFullScreen);
	virtual void OnTheaterMode(BOOL bTheaterMode);
	virtual void OnNavigateError(LPCTSTR lpszURL, LPCTSTR lpszFrame, DWORD dwError, BOOL *pbCancel);

	/// <summary>
	/// Called by the framework when it needs to obtain a bitmap to be displayed on Windows 7 tab thumbnail, 
	/// or on the client for application peek. </summary>
	/// <description>
	/// Calls OleDraw to display HTML elements.</description>
	/// <param name="dc"> Specifies the device context.</param>
	/// <param name="rect"> Specifies the bounding rectangle of area to render.</param>
	/// <param name="szRequiredThumbnailSize"> Specifies the size of target thumbnail. Should be ignored if bIsThumbnail is FALSE.</param>
	/// <param name="bIsThumbnail"> Specifies whether this method is called for iconic thumbnail or live preview (peek).</param>
	/// <param name="bAlphaChannelSet"> Output parameter. Set it to TRUE if your implementation initializes alpha channel of a bitmap
	/// selected in dc.</param> 
	virtual void OnDrawIconicThumbnailOrLivePreview(CDC& dc, CRect rect, CSize szRequiredThumbnailSize, BOOL bIsThumbnail, BOOL& bAlphaChannelSet);

// Implementation
public:
	virtual ~CHtmlView();
	virtual void OnDraw(CDC* pDC);
	CWnd m_wndBrowser;
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
protected:
	::ATL::CComPtr<IWebBrowser2> m_pBrowserApp;

// Event reflectors (not normally overridden)
protected:
	virtual void NavigateComplete2(LPDISPATCH pDisp, VARIANT* URL);
	virtual void BeforeNavigate2(LPDISPATCH pDisp, VARIANT* URL,
		VARIANT* Flags, VARIANT* TargetFrameName, VARIANT* PostData,
		VARIANT* Headers, VARIANT_BOOL* Cancel);
	virtual void DocumentComplete(LPDISPATCH pDisp, VARIANT* URL);
	virtual void NavigateError(LPDISPATCH pDisp, VARIANT* pvURL,
		VARIANT* pvFrame, VARIANT* pvStatusCode, VARIANT_BOOL* pvbCancel);

// Generated message map functions
protected:
	//{{AFX_MSG(CHtmlView)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnPaint();
	afx_msg void OnDestroy();
	afx_msg void OnEditCopy();
	afx_msg void OnUpdateEditCopy(CCmdUI* pCmdUI);
	afx_msg void OnEditCut();
	afx_msg void OnUpdateEditCut(CCmdUI* pCmdUI);
	afx_msg void OnEditPaste();
	afx_msg void OnUpdateEditPaste(CCmdUI* pCmdUI);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

// CStreamOnCString
// This is a helper class used by the CHtmlEditCtrlBase class to stream
// HTML into and out of the web browser control.
class CStreamOnCString : public IStream
{
public:
// Construction
	CStreamOnCString()
	{
		m_current_index = 0;
	}

	CStreamOnCString(LPCTSTR szData):
		m_strStream(szData)
	{
		m_current_index = 0;
	}

	virtual ~CStreamOnCString() {}

	// Copies the data currently held in this
	// object into a CString
	BOOL CopyData(CString& target)
	{
		target = m_strStream;
		return TRUE;
	}

	// Sets the value of 
	BOOL SetData(LPCTSTR szData)
	{
		_ATLTRY
		{
			m_strStream = szData;
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
		return TRUE;
	}

// Implementation
	STDMETHOD(QueryInterface)(REFIID iid, void **ppUnk)
	{
		if (ppUnk == NULL) 
		{ 
			return E_POINTER; 
		}
		if (::InlineIsEqualGUID(iid, IID_IUnknown) ||
			::InlineIsEqualGUID(iid, IID_IStream) ||
			::InlineIsEqualGUID(iid, IID_ISequentialStream))
		{
			*ppUnk = (void*)this;
			AddRef();
			return S_OK;
		}
		return E_NOINTERFACE;
	}

	ULONG STDMETHODCALLTYPE AddRef( void) 
	{
		return (ULONG)1;
	}

	ULONG STDMETHODCALLTYPE Release( void) 
	{
		return (ULONG)1;
	}

	STDMETHOD(Read)(void *pv, ULONG cb, ULONG *pcbRead)
	{
		if (pcbRead)
			*pcbRead = 0;
		if (m_strAnsi.GetLength() == 0)
			m_strAnsi = m_strStream;

		if (!pv)
			return E_POINTER;

		unsigned int length = m_strAnsi.GetLength();
		char *pStream = m_strAnsi.GetBuffer();
		if (!pStream)
			return E_UNEXPECTED;

		UINT_PTR uSum = (UINT_PTR)pStream + length;
		if (uSum < static_cast<UINT_PTR>(length))
			return E_UNEXPECTED;
		char *pEnd = reinterpret_cast<char*>(uSum);

		uSum = (UINT_PTR)pStream + m_current_index;
		if (uSum < m_current_index)
			return E_UNEXPECTED;
		char *pStart = reinterpret_cast<char*>(uSum);

		if (pStart >= pEnd)
			return S_FALSE; // no more data to read
		
		int bytes_left = (int)(pEnd-pStart);
		int bytes_to_copy = (int)__min(bytes_left, (int)cb);
		if (bytes_to_copy <= 0)
		{
			// reset members so this stream can be used again
			m_current_index = 0;
			m_strAnsi.Empty();
			return S_FALSE;
		}

		::ATL::Checked::memcpy_s(pv, cb, (void*)uSum, bytes_to_copy);
		if (pcbRead)
			*pcbRead = (ULONG)bytes_to_copy;
		m_current_index += bytes_to_copy;
		m_strAnsi.ReleaseBuffer(0);
		return S_OK;
	}

	STDMETHOD(Write)(const void *pv, ULONG cb, ULONG *pcbWritten)
	{
		if (pcbWritten)
			*pcbWritten = 0;
		try
		{
#ifdef _UNICODE
			int flags = IS_TEXT_UNICODE_UNICODE_MASK;
			if (0 != IsTextUnicode((LPVOID)pv, cb, &flags))
			{
				// compiling UNICODE and got a UNICODE buffer
				UINT nCharsToSkip = flags & IS_TEXT_UNICODE_SIGNATURE ? 1 : 0;
				m_strStream.Append((wchar_t*)( ((wchar_t*)pv)+nCharsToSkip), (cb/sizeof(wchar_t))-nCharsToSkip);
				if (pcbWritten)
					*pcbWritten = cb-nCharsToSkip*sizeof(wchar_t);
			}
			else
			{
				// compiling UNICODE and got an ansi buffer
				// convert ansi buffer to UNICODE buffer
				CStringW strTemp((LPCSTR)pv, cb);
				m_strStream.Append(strTemp);
				if (pcbWritten)
					*pcbWritten = cb;
				
			}
#else
			int flags = IS_TEXT_UNICODE_UNICODE_MASK;
			if (0 != IsTextUnicode((LPVOID)pv, cb, &flags))
			{
				// compiling ANSI and got a UNICODE buffer
				UINT nCharsToSkip = flags & IS_TEXT_UNICODE_SIGNATURE ? 1 : 0;
				CStringA strTemp((const wchar_t*)pv + nCharsToSkip, (cb/sizeof(wchar_t))- nCharsToSkip);
				m_strStream.Append(strTemp);
				if (pcbWritten)
					*pcbWritten = cb-nCharsToSkip*sizeof(wchar_t);
			}
			else
			{
				// compiling ANSI and got an ANSI buffer
				m_strStream.Append((char*)pv, cb);
				if (pcbWritten)
					*pcbWritten = cb;
			}
#endif
		}
		catch (CMemoryException* e)
		{
			e->Delete();
			return E_OUTOFMEMORY;
		}
		return S_OK;
	}

	STDMETHOD(Seek)(LARGE_INTEGER , DWORD , ULARGE_INTEGER *)
	{
		return E_NOTIMPL;
	}

	STDMETHOD(SetSize)(ULARGE_INTEGER )
	{
		return E_NOTIMPL;
	}

	STDMETHOD(CopyTo)(IStream *, ULARGE_INTEGER , ULARGE_INTEGER *,
		ULARGE_INTEGER *)
	{
		return E_NOTIMPL;
	}

	STDMETHOD(Commit)(DWORD )
	{
		return E_NOTIMPL;
	}

	STDMETHOD(Revert)( void)
	{
		return E_NOTIMPL;
	}

	STDMETHOD(LockRegion)(ULARGE_INTEGER , ULARGE_INTEGER , DWORD )
	{
		return E_NOTIMPL;
	}

	STDMETHOD(UnlockRegion)(ULARGE_INTEGER , ULARGE_INTEGER ,
		DWORD )
	{
		return E_NOTIMPL;
	}

	STDMETHOD(Stat)(STATSTG *, DWORD )
	{
		return E_NOTIMPL;
	}

	STDMETHOD(Clone)(IStream **)
	{
		return E_NOTIMPL;
	}

protected:
	CString m_strStream;
	CStringA m_strAnsi;
	UINT m_current_index;

};

/////////////////////////////////////////////////////////////////////////////
// CHtmlEditCtrlBase

template <class T>
class CHtmlEditCtrlBase 
{
public:
	BOOL SetDesignMode(BOOL bMode) const
	{
		const T* pT = static_cast<const T*>(this);
		::ATL::CComPtr<IHTMLDocument2> spDoc;
		pT->GetDHtmlDocument(&spDoc);
		if (spDoc)
		{
			if (bMode)
				return S_OK == spDoc->put_designMode(CComBSTR(L"On")) ? TRUE : FALSE;
			else
				return S_OK == spDoc->put_designMode(CComBSTR(L"Off")) ? TRUE : FALSE;
		}
		return FALSE;
	}

	HRESULT ExecCommand(const GUID *pGuid, long cmdID, long cmdExecOpt, VARIANT* pInVar=NULL, VARIANT* pOutVar=NULL) const
	{
		const T* pT = static_cast<const T*>(this);
		::ATL::CComPtr<IHTMLDocument2> spDoc;
		HRESULT hr = E_FAIL;
		pT->GetDHtmlDocument(&spDoc);
		if (spDoc)
		{
			CComQIPtr<IOleCommandTarget> spCmdTarg = spDoc;
			if (spCmdTarg)
			{
				hr = spCmdTarg->Exec(pGuid, cmdID, cmdExecOpt, pInVar , pOutVar);
			}
			else
				hr = E_NOINTERFACE;
		}
		return hr;
	}
	HRESULT ExecCommand(long cmdID, long cmdExecOpt, VARIANT* pInVar=NULL, VARIANT* pOutVar=NULL) const
	{
		return ExecCommand(&CGID_MSHTML, cmdID, cmdExecOpt, 
					pInVar , pOutVar );
	}

	long QueryStatus(long cmdID) const
	{
		const T* pT = static_cast<const T*>(this);
		::ATL::CComPtr<IHTMLDocument2> spDoc;
		pT->GetDHtmlDocument(&spDoc);
		if (spDoc)
		{
			CComQIPtr<IOleCommandTarget> spCmdTarg = spDoc;
			if (spCmdTarg)
			{
				OLECMD ocmd = {cmdID, 0};
				if (S_OK == spCmdTarg->QueryStatus(&CGID_MSHTML, 1, &ocmd, NULL))
					return ocmd.cmdf;
			}
		}
		// if an error occurred, returning 0 means the command is disabled
		return 0;
	}

	HRESULT GetEvent(IHTMLEventObj **ppEventObj) const
	{
		::ATL::CComPtr<IHTMLWindow2> sphtmlWnd;
		::ATL::CComPtr<IHTMLDocument2> sphtmlDoc;

		if (!ppEventObj)
			return E_POINTER;

		*ppEventObj = NULL;
		HRESULT hr = E_FAIL;

		if (GetDocument(&sphtmlDoc))
		{
			hr = sphtmlDoc->get_parentWindow(&sphtmlWnd);
			if(hr == S_OK)
			{
				hr = sphtmlWnd->get_event(ppEventObj);
			}
		}
		return hr;
	}

	HRESULT GetEventSrcElement(IHTMLElement **ppSrcElement) const
	{
		::ATL::CComPtr<IHTMLEventObj> spEventObj;
		if (!ppSrcElement)
			return E_POINTER;

		*ppSrcElement = NULL;
		HRESULT hr = GetEvent(&spEventObj);
		if (hr == S_OK)
		{
			hr = spEventObj->get_srcElement(ppSrcElement);
		}
		return hr;
	}

	HRESULT GetDocument(IHTMLDocument2** ppDoc) const
	{	
		const T* pT = static_cast<const T*>(this);
		return pT->GetDHtmlDocument(ppDoc) ? S_OK : E_NOINTERFACE;
	}

	HRESULT NewDocument() const
	{
		HRESULT hr = E_FAIL;
		const T* pT = static_cast<const T*>(this);
		::ATL::CComPtr<IHTMLDocument2> spHTMLDocument;
		CComQIPtr<IPersistStreamInit> spPSI;
		CStreamOnCString stream;

		pT->GetDHtmlDocument(&spHTMLDocument);
		if (spHTMLDocument)
		{
			spPSI = spHTMLDocument;
			if (spPSI)
			{
				hr = spPSI->InitNew();
			}
		}
		return hr;
	}

	HRESULT GetDocumentHTML(CString& szHTML) const
	{
		HRESULT hr = E_NOINTERFACE;
		const T* pT = static_cast<const T*>(this);
		::ATL::CComPtr<IHTMLDocument2> spHTMLDocument;
		CComQIPtr<IPersistStreamInit> spPSI;
		CStreamOnCString stream;

		pT->GetDHtmlDocument(&spHTMLDocument);
		if (spHTMLDocument)
		{
			spPSI = spHTMLDocument;
			if (spPSI)
			{
				hr = spPSI->Save(static_cast<IStream*>(&stream), FALSE);
				if (hr == S_OK)
				{
					if (!stream.CopyData(szHTML))
						hr = E_OUTOFMEMORY;
				}
			}
		}
		return hr;
	}

	HRESULT SetDocumentHTML(LPCTSTR szHTML) const
	{
		HRESULT hr = E_NOINTERFACE;
		const T* pT = static_cast<const T*>(this);
		CStreamOnCString stream(szHTML);
		::ATL::CComPtr<IHTMLDocument2> spHTMLDocument;
		CComQIPtr<IPersistStreamInit> spPSI;

		pT->GetDHtmlDocument(&spHTMLDocument);
		if (spHTMLDocument)
		{
			spPSI = spHTMLDocument;
			if (spPSI)
				hr = spPSI->Load(static_cast<IStream*>(&stream));
		}
		return hr;
	}

	HRESULT GetIsDirty() const
	{
		HRESULT hr = E_NOINTERFACE;
		const T* pT = static_cast<const T*>(this);
		::ATL::CComPtr<IHTMLDocument2> spHTMLDocument;
		CComQIPtr<IPersistStreamInit> spPSI;

		pT->GetDHtmlDocument(&spHTMLDocument);
		if (spHTMLDocument)
		{
			spPSI = spHTMLDocument;
			if (spPSI)
				hr = spPSI->IsDirty();
		}
		return hr;
	}

	HRESULT GetDocumentTitle(CString& szTitle) const
	{
		HRESULT hr = E_FAIL;
		const T* pT = static_cast<const T*>(this);
		::ATL::CComPtr<IHTMLDocument2> spHTMLDocument;
		CComBSTR bstrTitle;
		pT->GetDHtmlDocument(&spHTMLDocument);
		if (!spHTMLDocument)
			hr = E_NOINTERFACE;
		else
		{
			hr = spHTMLDocument->get_title(&bstrTitle);
			if (hr == S_OK)
				szTitle = COLE2CT(bstrTitle);
		}
		return hr;
	}

	HRESULT GetBlockFormatNames(CStringArray &sa) const
	{
		CComVariant vaRet;
		HRESULT hr = E_FAIL;
		long lStatus = QueryStatus(IDM_GETBLOCKFMTS);
		if (lStatus & OLECMDF_ENABLED || lStatus & OLECMDF_LATCHED)
		{
			if (S_OK == ExecCommand(IDM_GETBLOCKFMTS, OLECMDEXECOPT_DODEFAULT, NULL, &vaRet))
			{						 
				if(vaRet.vt & VT_ARRAY)
				{
					SAFEARRAY *psa = vaRet.parray;
					
					long lBound = 0,uBound = 0;
					if(S_OK == SafeArrayGetLBound(psa,1,&lBound) &&
					   S_OK == SafeArrayGetUBound(psa,1,&uBound) )
					{
						for(long i=lBound; i<=uBound; i++)
						{	
							CComBSTR bstrElem;
							if( (S_OK == SafeArrayGetElement(psa, &i, &bstrElem) ))
							{
								sa.Add(CString(bstrElem));
							}
						}		
						hr = S_OK;
					}
				}
			}
		}

		if (vaRet.vt == VT_ERROR)
			hr = V_ERROR(&vaRet);

		return hr;
	}

	HRESULT SetForeColor(LPCTSTR szColor) const
	{
		return ExecHelperSetVal(IDM_FORECOLOR, szColor);
	}

	HRESULT SetForeColor(int nColor) const
	{
		return ExecHelperSetVal(IDM_FORECOLOR, nColor, OLECMDF_SUPPORTED|OLECMDF_ENABLED);
	}

	HRESULT GetForeColor(int &nColor)
	{
		return ExecHelperGetVal(IDM_FORECOLOR, nColor, OLECMDF_ENABLED|OLECMDF_SUPPORTED);
	}

	HRESULT GetBackColor(int& nColor) const
	{
		return ExecHelperGetVal(IDM_BACKCOLOR, nColor, OLECMDF_ENABLED|OLECMDF_SUPPORTED);
	}

	HRESULT SetBackColor(LPCTSTR szColor) const
	{
		return ExecHelperSetVal(IDM_BACKCOLOR, szColor, OLECMDF_ENABLED|OLECMDF_SUPPORTED);
	}

	HRESULT SetBackColor(int nColor) const
	{
		return ExecHelperSetVal(IDM_BACKCOLOR, nColor, OLECMDF_ENABLED|OLECMDF_SUPPORTED);
	}

	HRESULT SetDefaultComposeSettings(LPCSTR szFontName=NULL,
									  unsigned short nFontSize=3,
									  COLORREF crFontColor=0xFF000000,
									  COLORREF crFontBgColor=0xFF000000,
									  bool bBold = false,
									  bool bItalic = false,
									  bool bUnderline = false) const
	{

		HRESULT hr = ExecHelperSetVal(IDM_HTMLEDITMODE, true);
		if (FAILED(hr))
			return hr;

		CString strBuffer;
		TCHAR szFontColor[12];
		TCHAR szBgColor[12];
		if(crFontColor == 0xFF000000)
			szFontColor[0] = 0;
		else
			if (0 > _sntprintf(szFontColor, 12, _T("%d.%d.%d"), GetRValue(crFontColor),
					GetGValue(crFontColor), GetBValue(crFontColor)))
					return E_UNEXPECTED;

		if (crFontBgColor == 0xFF000000)
			szBgColor[0] = 0;
		else
			if (0 > _sntprintf(szBgColor, 12, _T("%d.%d.%d"), GetRValue(crFontBgColor),
					GetGValue(crFontBgColor), GetBValue(crFontBgColor)))
					return E_UNEXPECTED;

		_ATLTRY
		{
		strBuffer.Format(_T("%d,%d,%d,%d,%s,%s,%s"),
						bBold ? 1 : 0,
						bItalic ? 1 : 0,
						bUnderline ? 1 : 0,
						nFontSize,
						szFontColor,
						szBgColor,
						szFontName);
		}
		_ATLCATCHALL()
		{
			return E_UNEXPECTED;
		}
		return ExecHelperSetVal(IDM_COMPOSESETTINGS, (LPCTSTR)strBuffer);
	}

	HRESULT GetBlockFormat(CString& strFormat) const
	{
		return ExecHelperGetVal(IDM_BLOCKFMT, strFormat, OLECMDF_SUPPORTED|OLECMDF_ENABLED);
	}

	HRESULT SetBlockFormat(LPCTSTR szFormat) const
	{
		return ExecHelperSetVal(IDM_BLOCKFMT, szFormat);
	}

	HRESULT GetFontFace(CString& strFace) const
	{
		return ExecHelperGetVal(IDM_FONTNAME, strFace, OLECMDF_ENABLED|OLECMDF_SUPPORTED);
	}

	HRESULT SetFontFace(LPCTSTR szFace) const
	{
		return ExecHelperSetVal(IDM_FONTNAME, szFace);
	}

	HRESULT IE50Paste(LPCTSTR szData) const
	{
		return ExecHelperSetVal(IDM_IE50_PASTE, szData);
	}

	HRESULT GetBookMark(CString& strAnchor) const
	{
		return ExecHelperGetVal(IDM_BOOKMARK, strAnchor);
	}

	HRESULT SetBookMark(LPCTSTR szAnchorName) const
	{
		return ExecHelperSetVal(IDM_BOOKMARK, szAnchorName,OLECMDF_SUPPORTED);
	}

	HRESULT SetOverwriteMode(bool bMode) const
	{
		return ExecHelperSetVal(IDM_OVERWRITE, bMode);
	}

	HRESULT Is1DElement(bool& bValue) const
	{
		return ExecHelperGetVal(IDM_1D_ELEMENT, bValue);
	}

	HRESULT Is2DElement(bool& bValue) const
	{
		return ExecHelperGetVal(IDM_2D_ELEMENT, bValue);
	}

	HRESULT GetFontSize(short& nSize) const
	{
		return ExecHelperGetVal(IDM_FONTSIZE, nSize);
	}

	HRESULT SetFontSize(unsigned short size) const
	{
		return ExecHelperSetVal(IDM_FONTSIZE, (short)size);
	}

	HRESULT GetFrameZone(short& nZone) const
	{
		return ExecHelperGetVal(IDM_GETFRAMEZONE, nZone);
	}

	HRESULT SetCSSEditingLevel(short nLevel) const
	{
		return ExecHelperSetVal(IDM_CSSEDITING_LEVEL, nLevel, 0);
	}

	HRESULT HyperLink(LPCTSTR szUrl = NULL) const
	{
		if (szUrl)
			return ExecHelperSetVal(IDM_HYPERLINK, szUrl, OLECMDF_SUPPORTED,
									OLECMDEXECOPT_DONTPROMPTUSER);
		return ExecHelperNN(IDM_HYPERLINK, OLECMDF_SUPPORTED, OLECMDEXECOPT_DODEFAULT);
	}

	HRESULT Image(LPCTSTR szUrl = NULL) const
	{
		if (szUrl)
			return ExecHelperSetVal(IDM_IMAGE, szUrl, OLECMDF_SUPPORTED,
									OLECMDEXECOPT_DONTPROMPTUSER);
		return ExecHelperNN(IDM_IMAGE, OLECMDF_SUPPORTED, OLECMDEXECOPT_DODEFAULT);
	}

	HRESULT OrderList(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_ORDERLIST, szId);
	}

	HRESULT UnorderList(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_UNORDERLIST, szId);
	}

	HRESULT AddToGlyphTable(LPCTSTR szTag,
							LPCTSTR szImgUrl,
							unsigned short nTagType,
							unsigned short nAlignment,
							unsigned short nPosInfo,
							unsigned short nDirection,
							unsigned int nImgWidth,
							unsigned int nImgHeight) const
	{
		// Check Paramters
		if (!szTag ||
			!szImgUrl ||
			nTagType > 2 ||
			nAlignment > 3 ||
			nPosInfo > 3 ||
			nDirection > 4)
			return E_INVALIDARG;

		CString strGlyphEntry;
		_ATLTRY
		{
			strGlyphEntry.Format(_T("%%%%%s^^%%%%%s^^%%%%%d^^%%%%%d^^%%%%%d^^")
								 _T("%%%%%d^^%%%%%d^^%%%%%d^^%%%%%d^^%%%%%d^^**"),
								 szTag, szImgUrl, nTagType, nAlignment, nPosInfo,
								 nDirection, nImgWidth, nImgHeight, nImgWidth, nImgHeight);
		}
		_ATLCATCHALL()
		{
			return E_UNEXPECTED;
		}
		CComVariant vIn((LPCTSTR)strGlyphEntry);
		return ExecCommand(IDM_ADDTOGLYPHTABLE, OLECMDEXECOPT_DODEFAULT, &vIn);
	}

	HRESULT EmptyGlyphTable() const
	{
		return ExecHelperNN(IDM_EMPTYGLYPHTABLE);
	}

	HRESULT Button(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_BUTTON, szId);
	}

	HRESULT CheckBox(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_CHECKBOX, szId);
	}

	HRESULT DropDownBox(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_DROPDOWNBOX, szId);
	}

	HRESULT HorizontalLine(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_HORIZONTALLINE, szId);
	}

	HRESULT Iframe(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_IFRAME, szId);
	}

	HRESULT InsFieldSet(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_INSFIELDSET, szId);
	}

	HRESULT InsInputButton(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_INSINPUTBUTTON, szId);
	}

	HRESULT InsInputHidden(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_INSINPUTHIDDEN, szId);
	}

	HRESULT InsInputImage(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_INSINPUTIMAGE, szId);
	}

	HRESULT InsInputPassword(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_INSINPUTPASSWORD, szId);
	}

	HRESULT InsInputReset(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_INSINPUTRESET, szId);
	}

	HRESULT InsInputSubmit(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_INSINPUTSUBMIT, szId);
	}

	HRESULT InsInputUpload(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_INSINPUTUPLOAD, szId);
	}

	HRESULT ListBox(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_LISTBOX, szId);
	}

	HRESULT Marquee(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_MARQUEE, szId);
	}

	HRESULT Paragraph(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_PARAGRAPH, szId);
	}

	HRESULT RadioButton(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_RADIOBUTTON, szId);
	}

	HRESULT SaveAs(LPCTSTR szPath = NULL) const
	{
		if (szPath)
		{
			return ExecHelperSetVal(IDM_SAVEAS, szPath, OLECMDF_SUPPORTED,
									OLECMDEXECOPT_DONTPROMPTUSER);
		}
		else
		{
			return ExecHelperNN(IDM_SAVEAS, OLECMDF_SUPPORTED, OLECMDEXECOPT_DODEFAULT);
		}
	}

	HRESULT TextArea(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_TEXTAREA, szId);
	}

	HRESULT TextBox(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_TEXTBOX, szId);
	}

	HRESULT GetAbsolutePosition(bool &bCurValue) const
	{
		bCurValue = (QueryStatus(IDM_ABSOLUTE_POSITION) & OLECMDF_LATCHED) != 0;
		return S_OK;
	}

	HRESULT SetAbsolutePosition(bool bNewValue) const
	{
		return ExecHelperSetVal(IDM_ABSOLUTE_POSITION, bNewValue );
	}


	HRESULT Set2DPosition(bool bNewValue) const
	{
		return ExecHelperSetVal(IDM_2D_POSITION, bNewValue, 0);
	}

	HRESULT SetAtomicSelection(bool bNewValue) const
	{
		return ExecHelperSetVal(IDM_ATOMICSELECTION, bNewValue, 0);
	}

	HRESULT SetAutoURLDetectMode(bool bNewValue) const
	{
		return ExecHelperSetVal(IDM_AUTOURLDETECT_MODE, bNewValue, 0);
	}

	HRESULT SetDisableEditFocusUI(bool bNewValue) const
	{
		return ExecHelperSetVal(IDM_DISABLE_EDITFOCUS_UI, bNewValue, 0);
	}

	HRESULT SetIE5PasteMode(bool bNewValue) const
	{
		return ExecHelperSetVal(IDM_IE50_PASTE_MODE, bNewValue, 0);
	}

	HRESULT SetLiveResize(bool bNewValue) const
	{
		return ExecHelperSetVal(IDM_LIVERESIZE, bNewValue, 0);
	}

	HRESULT SetMultiSelect(bool bNewValue) const
	{
		return ExecHelperSetVal(IDM_MULTIPLESELECTION, bNewValue, 0);
	}

	HRESULT SetOverrideCursor(bool bNewValue) const
	{
		return ExecHelperSetVal(IDM_OVERRIDE_CURSOR, bNewValue, 0);
	}

	HRESULT SetRespectVisInDesign(bool bNewValue) const
	{
		return ExecHelperSetVal(IDM_RESPECTVISIBILITY_INDESIGN, bNewValue, 0);
	}

	HRESULT GetShowAlignedSiteTags(bool &bCurValue) const
	{
		bCurValue = (QueryStatus(IDM_SHOWALIGNEDSITETAGS) & OLECMDF_LATCHED) != 0;
		return S_OK;
	}

	HRESULT SetShowAlignedSiteTags(bool bNewValue) const
	{
		return ExecHelperSetVal(IDM_SHOWALIGNEDSITETAGS, bNewValue);
	}

	HRESULT GetShowAllTags(bool &bCurValue) const
	{
		bCurValue = (QueryStatus(IDM_SHOWALLTAGS) & OLECMDF_LATCHED) != 0;
		return S_OK;
	}

	HRESULT SetShowAllTags(bool bNewValue) const
	{
		return ExecHelperSetVal(IDM_SHOWALLTAGS, bNewValue);
	}

	HRESULT GetShowAreaTags(bool &bCurValue) const
	{
		bCurValue = (QueryStatus(IDM_SHOWAREATAGS) & OLECMDF_LATCHED) != 0;
		return S_OK;
	}

	HRESULT SetShowAreaTags(bool bNewValue) const
	{
		return ExecHelperSetVal(IDM_SHOWAREATAGS, bNewValue);
	}

	HRESULT GetShowCommentTags(bool &bCurValue) const
	{
		bCurValue = (QueryStatus(IDM_SHOWCOMMENTTAGS) & OLECMDF_LATCHED) != 0;
		return S_OK;
	}

	HRESULT SetShowCommentTags(bool bNewValue) const
	{
		return ExecHelperSetVal(IDM_SHOWCOMMENTTAGS, bNewValue);
	}

	HRESULT GetShowMiscTags(bool &bCurValue) const
	{
		bCurValue = (QueryStatus(IDM_SHOWMISCTAGS) & OLECMDF_LATCHED) != 0;
		return S_OK;
	}

	HRESULT SetShowMiscTags(bool bNewValue) const
	{
		return ExecHelperSetVal(IDM_SHOWMISCTAGS, bNewValue);
	}

	HRESULT GetShowScriptTags(bool &bCurValue) const
	{
		bCurValue = (QueryStatus(IDM_SHOWSCRIPTTAGS) & OLECMDF_LATCHED) != 0;
		return S_OK;
	}

	HRESULT SetShowScriptTags(bool bNewValue) const
	{
		return ExecHelperSetVal(IDM_SHOWSCRIPTTAGS, bNewValue);
	}

	HRESULT GetShowStyleTags(bool &bCurValue) const
	{
		bCurValue = (QueryStatus(IDM_SHOWSTYLETAGS) & OLECMDF_LATCHED) != 0;
		return S_OK;
	}

	HRESULT SetShowStyleTags(bool bNewValue) const
	{
		return ExecHelperSetVal(IDM_SHOWSTYLETAGS, bNewValue);
	}

	HRESULT GetShowUnknownTags(bool &bCurValue) const
	{
		bCurValue = (QueryStatus(IDM_SHOWUNKNOWNTAGS) & OLECMDF_LATCHED) != 0;
		return S_OK;
	}

	HRESULT SetShowUnknownTags(bool bNewValue) const
	{
		return ExecHelperSetVal(IDM_SHOWUNKNOWNTAGS, bNewValue);
	}

	HRESULT GetShowBRTags(bool &bCurValue) const
	{
		bCurValue = (QueryStatus(IDM_SHOWWBRTAGS) & OLECMDF_LATCHED) != 0;
		return S_OK;
	}

	HRESULT SetShowBRTags(bool bNewValue) const
	{
		return ExecHelperSetVal(IDM_SHOWWBRTAGS, bNewValue);
	}

	HRESULT PrintDocument() const
	{
		return ExecHelperNN(IDM_PRINT);
	}

	HRESULT PrintDocument(LPCTSTR szPrintTemplate) const
	{
		return ExecHelperSetVal(IDM_PRINT, szPrintTemplate);
	}

	HRESULT PrintDocument(bool bShowPrintDialog) const
	{
		return ExecHelperSetVal(IDM_PRINT, (short)(bShowPrintDialog ? 1 : 0));
	}

	HRESULT PrintPreview() const
	{
		return ExecHelperNN(IDM_PRINTPREVIEW);
	}

	HRESULT PrintPreview(LPCTSTR szPrintTemplate) const
	{
		return ExecHelperSetVal(IDM_PRINTPREVIEW, szPrintTemplate);
	}

	HRESULT Bold() const
	{
		return ExecHelperNN(IDM_BOLD);
	}

	HRESULT Copy() const
	{
		return ExecHelperNN(IDM_COPY);
	}

	HRESULT Cut() const
	{
		return ExecHelperNN(IDM_CUT);
	}

	HRESULT Delete() const
	{
		return ExecHelperNN(IDM_DELETE);
	}

	HRESULT Indent() const
	{
		return ExecHelperNN(IDM_INDENT);
	}

	HRESULT Italic() const
	{
		return ExecHelperNN(IDM_ITALIC);
	}

	HRESULT JustifyCenter() const
	{
		return ExecHelperNN(IDM_JUSTIFYCENTER);
	}

	HRESULT JustifyLeft() const
	{
		return ExecHelperNN(IDM_JUSTIFYLEFT);
	}

	HRESULT JustifyRight() const
	{
		return ExecHelperNN(IDM_JUSTIFYRIGHT);
	}

	HRESULT Outdent() const
	{
		return ExecHelperNN(IDM_OUTDENT);
	}

	HRESULT Paste() const
	{
		return ExecHelperNN(IDM_PASTE);
	}

	HRESULT RemoveFormat() const
	{
		return ExecHelperNN(IDM_REMOVEFORMAT);
	}

	HRESULT SelectAll() const
	{
		return ExecHelperNN(IDM_SELECTALL);
	}

	HRESULT Underline() const
	{
		return ExecHelperNN(IDM_UNDERLINE);
	}

	HRESULT Unlink() const
	{
		return ExecHelperNN(IDM_UNLINK);
	}

	HRESULT ClearSelection() const
	{
		return ExecHelperNN(IDM_CLEARSELECTION);
	}

	HRESULT Font() const
	{
		return ExecHelperNN(IDM_FONT);
	}

	HRESULT RefreshDocument() const
	{
		return ExecHelperNN(IDM_REFRESH, OLECMDF_SUPPORTED);
	}

	HRESULT UnBookmark() const
	{
		return ExecHelperNN(IDM_UNBOOKMARK);
	}

// Implementation
	HRESULT ExecHelperNN(UINT nID,
						 long nMinSupportLevel = OLECMDF_SUPPORTED|OLECMDF_ENABLED,
						 long nExecOpt = OLECMDEXECOPT_DODEFAULT) const
	{
		HRESULT hr = E_FAIL;
		long lStatus = QueryStatus(nID);
		if ((lStatus & nMinSupportLevel) == nMinSupportLevel)
			hr = ExecCommand(nID, nExecOpt);
		return hr;
	}

	HRESULT ExecHelperSetVal(UINT nCmdID, 
							 LPCTSTR szID=NULL,
							 long nMinSupportLevel = OLECMDF_SUPPORTED|OLECMDF_ENABLED,
							 long nExecOpt = OLECMDEXECOPT_DODEFAULT) const
	{
		long lStatus = QueryStatus(nCmdID);
		if ((lStatus & nMinSupportLevel) == nMinSupportLevel)
		{
			if (szID)
			{
				CComVariant vName(szID);
				return ExecCommand(nCmdID, nExecOpt, &vName);
			}
			else
				return ExecCommand(nCmdID, nExecOpt);
		}
		return E_FAIL;
	}

	HRESULT ExecHelperSetVal(UINT nCmdID,
							 bool bValue,
							 long nMinSupportLevel = OLECMDF_SUPPORTED|OLECMDF_ENABLED,
							 long nExecOpt = OLECMDEXECOPT_DODEFAULT) const
	{
		HRESULT hr = E_FAIL;
		long lStatus = QueryStatus(nCmdID);
		if ((lStatus & nMinSupportLevel) == nMinSupportLevel)
		{
			CComVariant vIn(bValue);
			hr = ExecCommand(nCmdID, nExecOpt, &vIn);
		}
		return hr;
	}

	HRESULT ExecHelperSetVal(UINT nCmdID,
							 short nNewVal,
							 long nMinSupportLevel = OLECMDF_SUPPORTED|OLECMDF_ENABLED,
							 long nExecOpt = OLECMDEXECOPT_DODEFAULT) const
	{
		HRESULT hr = E_FAIL;
		long lStatus = QueryStatus(nCmdID);
		if ((lStatus & nMinSupportLevel) == nMinSupportLevel)
		{
			CComVariant vIn((short)nNewVal);
			hr = ExecCommand(nCmdID, nExecOpt, &vIn);
		}
		return hr;
	}

	HRESULT ExecHelperSetVal(UINT nCmdID,
							 int nNewVal,
							 long nMinSupportLevel = OLECMDF_SUPPORTED|OLECMDF_ENABLED,
							 long nExecOpt = OLECMDEXECOPT_DODEFAULT) const
	{
		HRESULT hr = E_FAIL;
		long lStatus = QueryStatus(nCmdID);
		if ((lStatus & nMinSupportLevel) == nMinSupportLevel)
		{
			CComVariant vIn((int)nNewVal);
			hr = ExecCommand(nCmdID, nExecOpt, &vIn);
		}
		return hr;
	}

	HRESULT ExecHelperGetVal(UINT nCmdID,
							 bool &bValue,
							 long nMinSupportLevel = OLECMDF_SUPPORTED,
							 long nExecOpt = OLECMDEXECOPT_DODEFAULT) const
	{
		HRESULT hr = E_FAIL;
		bValue = false;
		long lStatus = QueryStatus(nCmdID);
		if ((lStatus & nMinSupportLevel) == nMinSupportLevel)
		{
			CComVariant vOut;
			hr = ExecCommand(nCmdID, nExecOpt, NULL, &vOut);
			if (hr == S_OK)
			{
				switch(vOut.vt)
				{
				case VT_BOOL:
					bValue = vOut.boolVal == VARIANT_TRUE ? true : false;
					break;
				case VT_NULL:
				case VT_EMPTY:
					break;
				case VT_ERROR:
					hr = V_ERROR(&vOut);
					break;
				default:
					hr = E_UNEXPECTED;
					break;
				}
			}
		}
		return hr;
	}

	HRESULT ExecHelperGetVal(UINT nCmdID,
							 short &nValue,
							 long nMinSupportLevel = OLECMDF_SUPPORTED,
							 long nExecOpt = OLECMDEXECOPT_DODEFAULT) const
	{
		int nTempVal;
		HRESULT hr = ExecHelperGetVal(nCmdID, nTempVal, nMinSupportLevel, nExecOpt);
		if (hr == S_OK)
			nValue = (short)nTempVal;
		return hr;
	}


	HRESULT ExecHelperGetVal(UINT nCmdID,
							 int &nValue,
							 long nMinSupportLevel = OLECMDF_SUPPORTED,
							 long nExecOpt = OLECMDEXECOPT_DODEFAULT) const
	{
		HRESULT hr = E_FAIL;
		long lStatus = QueryStatus(nCmdID);
		nValue = 0;
		if ((lStatus & nMinSupportLevel) == nMinSupportLevel)
		{
			CComVariant vOut;
			hr = ExecCommand(nCmdID, nExecOpt, NULL, &vOut);
			if (hr == S_OK)
			{
				switch (vOut.vt)
				{
				case VT_I4:
					nValue = vOut.lVal;
					break;
				case VT_I2:
					nValue = vOut.iVal;
					break;
				case VT_EMPTY:
				case VT_NULL:
					break;
				case VT_ERROR:
					hr = V_ERROR(&vOut);
					break;
				default:
					hr = E_UNEXPECTED;
					break;
				}
			}
		}
		return hr;
	}

	HRESULT ExecHelperGetVal(UINT nCmdID,
							 CString& strValue,
							 long nMinSupportLevel = OLECMDF_SUPPORTED,
							 long nExecOpt = OLECMDEXECOPT_DODEFAULT) const
	{
		HRESULT hr = E_FAIL;
		CComVariant vaRet;
		strValue.Empty();
		long lStatus = QueryStatus(nCmdID);
		if ((lStatus & nMinSupportLevel) == nMinSupportLevel)
		{
			hr = ExecCommand(nCmdID, nExecOpt, NULL, &vaRet);
			if (hr == S_OK)
			{
				switch(vaRet.vt)
				{
				case VT_BSTR:
					{
					CW2T szVal(vaRet.bstrVal);
					strValue = szVal;
					}
					break;
				case VT_NULL:
				case VT_EMPTY:
					break;
				case VT_ERROR:
					hr = V_ERROR(&vaRet);
					break;
				default:
					hr = E_UNEXPECTED;
					break;
				}
			}
		}
		return hr;
	}
}; //CHtmlEditCtrlBase

/////////////////////////////////////////////////////////////////////////////
// CHtmlEditCtrl
class CHtmlEditCtrl:
	public CWnd,
	public CHtmlEditCtrlBase<CHtmlEditCtrl>
{
public:
	// Construct
	CHtmlEditCtrl();

	// Create a new instance of the control. This will also call the 
	// contained WebBrowser control's Navigate method to load a default
	// document into the WebBrowser control.
	virtual BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, int nID, CCreateContext *pContext=NULL);

	// Retrieves the URL to a default document to load.
	virtual LPCTSTR GetStartDocument();

	// Retrieves the IHTMLDocument2 interface on the contained WebBrowser control's
	// currently loaded document.
	BOOL GetDHtmlDocument(IHTMLDocument2 **ppDocument) const;

// Implementation
public:
	// Destruct
	virtual ~CHtmlEditCtrl();

protected:
	DECLARE_EVENTSINK_MAP()
	void _OnNavigateComplete2(LPDISPATCH pDisp, VARIANT FAR* URL);

};


/////////////////////////////////////////////////////////////////////////////
// CHtmlEditView
#define AFX_INVALID_DHTML_CMD_ID 0xFFFFFFFF
#define AFX_UI_ELEMTYPE_NORMAL	0
#define AFX_UI_ELEMTYPE_CHECBOX	1
#define AFX_UI_ELEMTYPE_RADIO	2


#define DECLARE_DHTMLEDITING_CMDMAP(className) \
public: \
	UINT GetDHtmlCommandMapping(UINT nIDWindowsCommand, BOOL&, UINT&); \
	BOOL ExecHandler(UINT nCmdID); \
	typedef void  (className##::*PFN_##className##_CMDHDLR)(UINT); \
	struct className##dhtml_cmd_mapping \
	{ \
		UINT windowsCommand; \
		UINT dhtmlCommand; \
		UINT nElementType; \
		PFN_##className##_CMDHDLR pfn; \
	}; \
	static className##dhtml_cmd_mapping m_commands[];\

#define DHTMLEDITING_CMD_ENTRY(cmdID, dhtmlcmdID)\
{cmdID, dhtmlcmdID, AFX_UI_ELEMTYPE_NORMAL, NULL}, 

#define DHTMLEDITING_CMD_ENTRY_FUNC(cmdID, dhtmlcmdID, member_func_name)\
{cmdID, dhtmlcmdID, AFX_UI_ELEMTYPE_NORMAL, member_func_name},

#define DHTMLEDITING_CMD_ENTRY_TYPE(cmdID, dhtmlcmdID, elemType)\
{cmdID, dhtmlcmdID, elemType, NULL}, 

#define DHTMLEDITING_CMD_ENTRY_FUNC_TYPE(cmdID, dhtmlcmdID, member_func_name, elemType)\
{cmdID, dhtmlcmdID, elemType, member_func_name},

#define BEGIN_DHTMLEDITING_CMDMAP(className) \
PTM_WARNING_DISABLE \
BOOL className##::ExecHandler(UINT nWindowsCommand)\
{\
	const className##dhtml_cmd_mapping *pMapping = className##::m_commands;\
	while (pMapping->dhtmlCommand != 0)\
	 {\
	 if (nWindowsCommand == pMapping->windowsCommand)\
	 {\
		(this->*pMapping->pfn)(pMapping->dhtmlCommand);\
		return TRUE;\
	 }\
	 pMapping++;\
	 }\
	return FALSE;\
}\
UINT className##::GetDHtmlCommandMapping(UINT nIDWindowsCommand, BOOL& bHasExecFunc, UINT& uiElemType)\
{ \
	const className##dhtml_cmd_mapping *pMapping = className##::m_commands;\
	 while (pMapping->dhtmlCommand != 0)\
	 {\
	 if (pMapping->windowsCommand == nIDWindowsCommand)\
	 {\
		 bHasExecFunc = pMapping->pfn != NULL ? TRUE : FALSE;\
		 uiElemType = pMapping->nElementType;\
		 return pMapping->dhtmlCommand;\
	 }\
	 pMapping++;\
	 }\
	return AFX_INVALID_DHTML_CMD_ID;\
}\
className##::className##dhtml_cmd_mapping className##::m_commands[] = {

#define END_DHTMLEDITING_CMDMAP()\
		{0, 0, 0, NULL} \
	}; \
	PTM_WARNING_RESTORE

class CHtmlEditView :
	public CHtmlView,
	public CHtmlEditCtrlBase<CHtmlEditView>
{
public:
	CHtmlEditView();

	// Retrieve the IHTMLDocument2 interface associated with the
	// document loaded in the contained WebBrowser control.
	BOOL GetDHtmlDocument(IHTMLDocument2 **ppDocument) const;

	// Create a new window object. This function will also call the
	// contained WebBrowser's Navigate method to load a default document.
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName,
		DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL);

	// Retrieve the name of the default document for this view.
	virtual LPCTSTR GetStartDocument();

// Implementation
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	virtual UINT GetDHtmlCommandMapping(UINT nIDWindowsCommand, BOOL& bHasExecFunc, UINT& uiElemType);
	virtual BOOL ExecHandler(UINT nCmdID);
	virtual void OnNavigateComplete2(LPCTSTR strURL);
	void OnPaint();
protected:
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	DECLARE_MESSAGE_MAP()
	DECLARE_DYNCREATE(CHtmlEditView)
	virtual ~CHtmlEditView();
};

class AFX_NOVTABLE CHtmlEditDoc : public CDocument
{
public:
	// Construction
	CHtmlEditDoc();

	// Get the CHtmlEditView associated with this document
	virtual CHtmlEditView* GetView() const;

	// Open a URL into the view associated with this document
	virtual BOOL OpenURL(LPCTSTR lpszURL);

	// See if the associated view's WebBrowser control contains a 
	// document that has been modified by the user.
	virtual BOOL IsModified();

// Implementation
public:
	virtual ~CHtmlEditDoc();
	virtual void DeleteContents();
	virtual BOOL OnOpenDocument(LPCTSTR lpszFileName);
	virtual BOOL OnSaveDocument(LPCTSTR lpszFileName);
	virtual BOOL OnNewDocument();

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	DECLARE_DYNCREATE(CHtmlEditDoc)
};

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#pragma warning(pop)

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXHTML_INLINE AFX_INLINE
#include <afxhtml.inl>
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif // __AFXHTML_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxhtml.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXHTML.H

#pragma once

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFXHTML_INLINE

_AFXHTML_INLINE void CHtmlView::SetRegisterAsBrowser(BOOL bNewValue)
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->put_RegisterAsBrowser((short) (bNewValue ? AFX_OLE_TRUE : AFX_OLE_FALSE)); }

_AFXHTML_INLINE void CHtmlView::SetRegisterAsDropTarget(BOOL bNewValue)
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->put_RegisterAsDropTarget((short) (bNewValue ? AFX_OLE_TRUE : AFX_OLE_FALSE)); }

_AFXHTML_INLINE void CHtmlView::SetTheaterMode(BOOL bNewValue)
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->put_TheaterMode((short) (bNewValue ? AFX_OLE_TRUE : AFX_OLE_FALSE)); }

_AFXHTML_INLINE void CHtmlView::SetVisible(BOOL bNewValue)
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->put_Visible((short) (bNewValue ? AFX_OLE_TRUE : AFX_OLE_FALSE)); }

_AFXHTML_INLINE void CHtmlView::SetMenuBar(BOOL bNewValue)
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->put_MenuBar((short) (bNewValue ? AFX_OLE_TRUE : AFX_OLE_FALSE)); }

_AFXHTML_INLINE void CHtmlView::SetToolBar(int nNewValue)
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->put_ToolBar(nNewValue); }

_AFXHTML_INLINE void CHtmlView::SetOffline(BOOL bNewValue)
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->put_Offline((short) (bNewValue ? AFX_OLE_TRUE : AFX_OLE_FALSE)); }

_AFXHTML_INLINE void CHtmlView::SetSilent(BOOL bNewValue)
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->put_Silent((short) (bNewValue ? AFX_OLE_TRUE : AFX_OLE_FALSE)); }

_AFXHTML_INLINE void CHtmlView::GoBack()
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->GoBack(); }

_AFXHTML_INLINE void CHtmlView::GoForward()
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->GoForward(); }

_AFXHTML_INLINE void CHtmlView::GoHome()
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->GoHome(); }

_AFXHTML_INLINE void CHtmlView::GoSearch()
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->GoSearch(); }

_AFXHTML_INLINE void CHtmlView::Refresh()
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->Refresh(); }

_AFXHTML_INLINE void CHtmlView::Refresh2(int nLevel)
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->Refresh2(COleVariant((long) nLevel, VT_I4)); }

_AFXHTML_INLINE void CHtmlView::Stop()
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->Stop(); }

_AFXHTML_INLINE void CHtmlView::SetFullScreen(BOOL bNewValue)
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->put_FullScreen((short) (bNewValue ? AFX_OLE_TRUE : AFX_OLE_FALSE)); }

_AFXHTML_INLINE void CHtmlView::SetAddressBar(BOOL bNewValue)
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->put_AddressBar((short) (bNewValue ? AFX_OLE_TRUE : AFX_OLE_FALSE)); }

_AFXHTML_INLINE void CHtmlView::SetHeight(long nNewValue)
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->put_Height(nNewValue); }

_AFXHTML_INLINE void CHtmlView::SetWidth(long nNewValue)
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->put_Width(nNewValue); }

_AFXHTML_INLINE void CHtmlView::PutProperty(LPCTSTR lpszPropertyName, long lValue)
	{ ASSERT(m_pBrowserApp != NULL); ASSERT(m_pBrowserApp != NULL); PutProperty(lpszPropertyName, COleVariant(lValue, VT_UI4)); }

_AFXHTML_INLINE void CHtmlView::PutProperty(LPCTSTR lpszPropertyName, short nValue)
	{ ASSERT(m_pBrowserApp != NULL); ASSERT(m_pBrowserApp != NULL); PutProperty(lpszPropertyName, COleVariant(nValue, VT_UI2)); }

_AFXHTML_INLINE void CHtmlView::PutProperty(LPCTSTR lpszPropertyName, LPCTSTR lpszValue)
	{ ASSERT(m_pBrowserApp != NULL); ASSERT(m_pBrowserApp != NULL); PutProperty(lpszPropertyName, COleVariant(lpszValue, VT_BSTR)); }

_AFXHTML_INLINE void CHtmlView::PutProperty(LPCTSTR lpszPropertyName, double dValue)
	{ ASSERT(m_pBrowserApp != NULL); ASSERT(m_pBrowserApp != NULL); PutProperty(lpszPropertyName, COleVariant(dValue)); }

_AFXHTML_INLINE void CHtmlView::SetTop(long nNewValue)
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->put_Top(nNewValue); }

_AFXHTML_INLINE void CHtmlView::SetLeft(long nNewValue)
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->put_Left(nNewValue); }

_AFXHTML_INLINE void CHtmlView::SetStatusBar(BOOL bNewValue)
	{ ASSERT(m_pBrowserApp != NULL); m_pBrowserApp->put_StatusBar((short) (bNewValue ? AFX_OLE_TRUE : AFX_OLE_FALSE)); }


#endif //_AFXHTML_INLINE

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afximagepaintarea.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCImageEditorDialog;

/////////////////////////////////////////////////////////////////////////////
// CMFCImagePaintArea window

class CMFCImagePaintArea : public CButton
{
// Construction
public:
	CMFCImagePaintArea(CMFCImageEditorDialog* pParentDlg);

// Attributes
public:
	enum IMAGE_EDIT_MODE
	{
		IMAGE_EDIT_MODE_PEN = 0,
		IMAGE_EDIT_MODE_FILL,
		IMAGE_EDIT_MODE_LINE,
		IMAGE_EDIT_MODE_RECT,
		IMAGE_EDIT_MODE_ELLIPSE,
		IMAGE_EDIT_MODE_COLOR
	};

	CRect     m_rectParentPreviewArea;

protected:
	COLORREF  m_rgbColor;
	CDC       m_memDC;
	CSize     m_sizeImage;
	CBitmap*  m_pBitmap;
	HCURSOR   m_hcurPen;
	HCURSOR   m_hcurFill;
	HCURSOR   m_hcurLine;
	HCURSOR   m_hcurRect;
	HCURSOR   m_hcurEllipse;
	HCURSOR   m_hcurColor;
	CSize     m_sizeCell;
	CPen      m_penDraw;
	CPen      m_penStretch;
	CRect     m_rectDraw;

	CMFCImageEditorDialog*  m_pParentDlg;
	IMAGE_EDIT_MODE m_Mode;

// Operations
public:
	void SetBitmap(CBitmap* pBitmap);
	void SetColor(COLORREF color);
	void SetMode(IMAGE_EDIT_MODE mode)
	{
		m_Mode = mode;
	}

	IMAGE_EDIT_MODE GetMode() const
	{
		return m_Mode;
	}

protected:
	void ScreenToBitmap(CPoint& point);
	void BitmapToClient(CRect& rect);

	void FloodFill(const CPoint& point);

// Overrides
protected:
	virtual void PreSubclassWindow();

// Implementation
public:
	virtual ~CMFCImagePaintArea();

protected:
	//{{AFX_MSG(CMFCImagePaintArea)
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnCancelMode();
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	//}}AFX_MSG

	virtual void DrawItem(LPDRAWITEMSTRUCT lpDIS);
	void DrawPixel(POINT point);

	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afximageeditordialog.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxdialogex.h"
#include "afxcolorbar.h"
#include "afximagepaintarea.h"
#include "afxtoolbar.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCImageEditorPaletteBar : public CMFCToolBar
{
	virtual BOOL IsButtonExtraSizeAvailable() const
	{
		return FALSE;
	}

	virtual int GetRowHeight() const
	{
		return GetButtonSize().cy;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CMFCImageEditorDialog dialog

class CMFCImageEditorDialog : public CDialogEx
{
	friend CMFCImagePaintArea;

// Construction
public:
	CMFCImageEditorDialog(CBitmap* pBitmap, CWnd* pParent = NULL, int nBitsPixel = -1);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CMFCImageEditorDialog)
	enum { IDD = IDD_AFXBARRES_IMAGE_EDITOR };
	CStatic m_wndColorPickerLocation;
	CStatic m_wndPaletteBarLocation;
	CStatic m_wndPreview;
	CMFCImagePaintArea m_wndLargeDrawArea;
	//}}AFX_DATA

// Operations:
protected:
	BOOL OnPickColor(COLORREF color);

	void SetMode(CMFCImagePaintArea::IMAGE_EDIT_MODE mode) { m_wndLargeDrawArea.SetMode(mode); }
	CMFCImagePaintArea::IMAGE_EDIT_MODE GetMode() const { return m_wndLargeDrawArea.GetMode(); }

// Overrides
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Implementation
protected:
	//{{AFX_MSG(CMFCImageEditorDialog)
	virtual BOOL OnInitDialog();
	afx_msg void OnPaint();
	afx_msg void OnToolClear();
	afx_msg void OnToolCopy();
	afx_msg void OnToolPaste();
	afx_msg void OnUpdateToolPaste(CCmdUI* pCmdUI);
	afx_msg void OnToolEllipse();
	afx_msg void OnToolFill();
	afx_msg void OnToolLine();
	afx_msg void OnToolPen();
	afx_msg void OnToolPick();
	afx_msg void OnToolRect();
	afx_msg void OnUpdateToolEllipse(CCmdUI* pCmdUI);
	afx_msg void OnUpdateToolFill(CCmdUI* pCmdUI);
	afx_msg void OnUpdateToolLine(CCmdUI* pCmdUI);
	afx_msg void OnUpdateToolPen(CCmdUI* pCmdUI);
	afx_msg void OnUpdateToolPick(CCmdUI* pCmdUI);
	afx_msg void OnUpdateToolRect(CCmdUI* pCmdUI);
	afx_msg LRESULT OnKickIdle(WPARAM, LPARAM);
	afx_msg void OnColors();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Attributes:
	CBitmap* m_pBitmap;
	CSize    m_sizeImage;
	int      m_nBitsPixel;

	CRect m_rectPreviewFrame;
	CRect m_rectPreviewImage;

	CMFCColorBar m_wndColorBar;
	CMFCImageEditorPaletteBar m_wndPaletteBar;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxkeyboardmanager.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

static CString _afxDefaultAcceleratorDelimiter = _T("; ");

class CKeyboardManager : public CObject
{
// Constructor/Destructor:
public:
	CKeyboardManager();
	virtual ~CKeyboardManager();

// Operattion:
public:
	BOOL LoadState(LPCTSTR lpszProfileName = NULL, CFrameWnd* pDefaultFrame = NULL);
	BOOL SaveState(LPCTSTR lpszProfileName = NULL, CFrameWnd* pDefaultFrame = NULL);

	BOOL UpdateAccelTable(CMultiDocTemplate* pTemplate, LPACCEL lpAccel, int nSize, CFrameWnd* pDefaultFrame = NULL);
	BOOL UpdateAccelTable(CMultiDocTemplate* pTemplate, HACCEL hAccelNew, CFrameWnd* pDefaultFrame = NULL);

	void ResetAll();

	static BOOL __stdcall FindDefaultAccelerator(UINT uiCmd, CString& str, CFrameWnd* pWndFrame, BOOL bIsDefaultFrame);
	static BOOL __stdcall IsKeyPrintable(const UINT nChar);
	static UINT __stdcall TranslateCharToUpper(const UINT nChar);
	static BOOL __stdcall IsKeyHandled(WORD nKey, BYTE fVirt, CFrameWnd* pWndFrame, BOOL bIsDefaultFrame);

	static void __stdcall ShowAllAccelerators(BOOL bShowAll = TRUE, LPCTSTR lpszDelimiter = _afxDefaultAcceleratorDelimiter);
	static BOOL __stdcall IsShowAllAccelerators() { return m_bAllAccelerators; }

	static void __stdcall CleanUp();

protected:
	BOOL SaveAcceleratorState(LPCTSTR lpszProfileName, UINT uiResId, HACCEL hAccelTable);
	BOOL LoadAcceleratorState(LPCTSTR lpszProfileName, UINT uiResId, HACCEL& hAccelTable);
	
	static void __stdcall SetAccelTable(LPACCEL& lpAccel, HACCEL& hAccelLast, int& nSize, const HACCEL hAccelCur);

	AFX_IMPORT_DATA static LPACCEL m_lpAccelDefault;    // Main frame acceleration table 
	AFX_IMPORT_DATA static LPACCEL m_lpAccel;           // Child frame acceleration table
	AFX_IMPORT_DATA static int     m_nAccelDefaultSize;
	AFX_IMPORT_DATA static int     m_nAccelSize;
	AFX_IMPORT_DATA static HACCEL  m_hAccelDefaultLast;
	AFX_IMPORT_DATA static HACCEL  m_hAccelLast;
	AFX_IMPORT_DATA static BOOL    m_bAllAccelerators;
	AFX_IMPORT_DATA static CString m_strDelimiter;
};

extern CKeyboardManager* afxKeyboardManager;

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxlinkctrl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxbutton.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCLinkCtrl window

class CMFCLinkCtrl : public CMFCButton
{
	DECLARE_DYNAMIC(CMFCLinkCtrl)

// Construction
public:
	CMFCLinkCtrl();

// Attributes
public:
	BOOL m_bMultilineText;
	BOOL m_bAlwaysUnderlineText;
	BOOL m_bDefaultClickProcess;
	BOOL m_bVisited;

protected:
	CString m_strURL;
	CString m_strPrefix;

// Operations
public:
	void SetURL(LPCTSTR lpszURL);          // By default, window text will be used
	void SetURLPrefix(LPCTSTR lpszPrefix); // For example "mailto:"

	virtual CSize SizeToContent(BOOL bVCenter = FALSE, BOOL bHCenter = FALSE);

protected:
	virtual void OnDraw(CDC* pDC, const CRect& rect, UINT uiState);
	virtual void OnDrawFocusRect(CDC* pDC, const CRect& rectClient);

// Overrides
	virtual BOOL PreTranslateMessage(MSG* pMsg);

// Implementation
public:
	virtual ~CMFCLinkCtrl();

protected:
	//{{AFX_MSG(CMFCLinkCtrl)
	afx_msg BOOL OnClicked();
	afx_msg LRESULT OnInitControl(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxkeymapdialog.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxdialogex.h"
#include "afxribbonres.h"
#include "afxbutton.h"
#include "afxlistctrl.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCToolBarsCustomizeDialog;
class CMFCToolBarButton;

/////////////////////////////////////////////////////////////////////////////
// CMFCKeyMapDialog dialog

class CMFCKeyMapDialog : public CDialogEx
{
// Construction
public:
	CMFCKeyMapDialog(CFrameWnd* pWndParentFrame, BOOL bEnablePrint = FALSE);   // standard constructor
	~CMFCKeyMapDialog();

// Dialog Data
	//{{AFX_DATA(CMFCKeyMapDialog)
	enum { IDD = IDD_AFXBARRES_KEYMAP };
	CStatic         m_wndAccelLabel;
	CMFCListCtrl m_KeymapList;
	CComboBox       m_wndCategoryList;
	CStatic         m_wndViewIcon;
	CComboBox       m_wndViewTypeList;
	CMFCButton   m_ButtonPrint;
	CMFCButton   m_ButtonCopy;
	//}}AFX_DATA

	CFrameWnd*      m_pWndParentFrame;
	HACCEL          m_hAccelTable;
	LPACCEL         m_lpAccel;
	int             m_nAccelSize;
	CMFCToolBarsCustomizeDialog* m_pDlgCust;
	int             m_nSortedCol;
	BOOL            m_bSortAscending;
	const BOOL      m_bEnablePrint;

// Overrides
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);

protected:
	virtual void CopyKeyMap();
	virtual void PrintKeyMap();

	virtual int OnPrintHeader(CDC& dc, int nPage, int cx) const;
	virtual int OnPrintItem(CDC& dc, int nItem, int y, int cx, BOOL bCalcHeight) const;

	virtual CString FormatItem(int nItem) const;

	virtual void OnSetColumns();
	virtual void OnInsertItem(CMFCToolBarButton* pButton, int nItem);
	virtual void SetColumnsWidth();

	virtual CString GetCommandKeys(UINT uiCmdID) const;

// Implementation
protected:
	//{{AFX_MSG(CMFCKeyMapDialog)
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeViewType();
	afx_msg void OnSelchangeCategory();
	afx_msg void OnCopy();
	afx_msg void OnPrint();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxinet.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXINET.H

#pragma once

/////////////////////////////////////////////////////////////////////////////
//

#ifdef _AFXINET_INLINE

_AFXINET_INLINE DWORD_PTR CInternetSession::GetContext() const
	{ return m_dwContext; }

_AFXINET_INLINE CString CInternetConnection::GetServerName() const
	{ return m_strServerName; }

_AFXINET_INLINE CInternetSession* CInternetConnection::GetSession() const
	{ return m_pSession; }

_AFXINET_INLINE CInternetSession::operator HINTERNET() const
	{ return m_hSession; }

_AFXINET_INLINE BOOL CInternetSession::SetOption(DWORD dwOption, DWORD dwValue,
	DWORD dwFlags /* = 0 */)
	{ ASSERT((dwFlags & INTERNET_FLAG_ASYNC) == 0); return SetOption(dwOption, &dwValue, sizeof(dwValue), dwFlags); }


_AFXINET_INLINE CGopherLocator::operator LPCTSTR() const
	{ return (LPCTSTR) m_Locator; }

_AFXINET_INLINE BOOL CGopherLocator::GetLocatorType(DWORD& dwRef) const
	{ return GopherGetLocatorType((LPCTSTR) m_Locator, &dwRef); }

_AFXINET_INLINE CGopherLocator::CGopherLocator(const CGopherLocator& ref)
	{ m_Locator = ref.m_Locator; m_dwBufferLength = ref.m_dwBufferLength; }


#pragma push_macro("GetObject")
#undef GetObject
_AFXINET_INLINE CString CHttpFile::GetObject() const
	{ return _AFX_FUNCNAME(GetObject)(); }
#pragma pop_macro("GetObject")


_AFXINET_INLINE CInternetConnection::operator HINTERNET() const
	{ return m_hConnection; }

_AFXINET_INLINE DWORD_PTR CInternetConnection::GetContext() const
	{ return m_dwContext; }

_AFXINET_INLINE BOOL CInternetConnection::SetOption(DWORD dwOption,
	DWORD dwValue, DWORD dwFlags /* = 0 */)
	{ return SetOption(dwOption, &dwValue, sizeof(dwValue), dwFlags); }


_AFXINET_INLINE DWORD_PTR CInternetFile::GetContext() const
	{ return m_dwContext; }

_AFXINET_INLINE CInternetFile::operator HINTERNET() const
	{ return m_hFile; }

_AFXINET_INLINE BOOL CInternetFile::SetOption(DWORD dwOption, DWORD dwValue,
	DWORD dwFlags /* = 0 */)
	{ ASSERT((dwFlags & INTERNET_FLAG_ASYNC) == 0); return SetOption(dwOption, &dwValue, sizeof(dwValue), dwFlags); }


#pragma push_macro("SetCurrentDirectory")
#undef SetCurrentDirectory
_AFXINET_INLINE BOOL CFtpConnection::SetCurrentDirectory(LPCTSTR pstrDirName)
	{ return _AFX_FUNCNAME(SetCurrentDirectory)(pstrDirName); }
#pragma pop_macro("SetCurrentDirectory")

#pragma push_macro("CreateDirectory")
#undef CreateDirectory
_AFXINET_INLINE BOOL CFtpConnection::CreateDirectory(LPCTSTR pstrDirName)
	{ return _AFX_FUNCNAME(CreateDirectory)(pstrDirName); }
#pragma pop_macro("CreateDirectory")


#endif //_AFXINET_INLINE

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxlistctrl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxheaderctrl.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCListCtrl window

class CMFCListCtrl : public CListCtrl
{
	DECLARE_DYNAMIC(CMFCListCtrl)

// Construction
public:
	CMFCListCtrl();

// Attributes
public:
	virtual CMFCHeaderCtrl& GetHeaderCtrl() { return m_wndHeader; }

	// Mark sorted column by background color
	void EnableMarkSortedColumn(BOOL bMark = TRUE, BOOL bRedraw = TRUE);

protected:
	CMFCHeaderCtrl m_wndHeader;
	COLORREF m_clrSortedColumn;
	int      m_iSortedColumn;
	BOOL     m_bAscending;
	BOOL     m_bMarkSortedColumn;
	HFONT    m_hOldFont;

// Operations
public:
	// Sorting operations:
	virtual void Sort(int iColumn, BOOL bAscending = TRUE, BOOL bAdd = FALSE);
	void SetSortColumn(int iColumn, BOOL bAscending = TRUE, BOOL bAdd = FALSE);
	void RemoveSortColumn(int iColumn);
	void EnableMultipleSort(BOOL bEnable = TRUE);
	BOOL IsMultipleSort() const;

// Overrides
	virtual int OnCompareItems(LPARAM lParam1, LPARAM lParam2, int iColumn);

	// Support for individual cells text/background colors:
	virtual COLORREF OnGetCellTextColor(int /*nRow*/, int /*nColum*/) { return GetTextColor(); }
	virtual COLORREF OnGetCellBkColor(int /*nRow*/, int /*nColum*/) { return GetBkColor(); }
	virtual HFONT OnGetCellFont(int /*nRow*/, int /*nColum*/, DWORD /*dwData*/ = 0) { return NULL; }

protected:
	virtual void PreSubclassWindow();

// Implementation
public:
	virtual ~CMFCListCtrl();

protected:
	//{{AFX_MSG(CMFCListCtrl)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnSysColorChange();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnCustomDraw(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg LRESULT OnStyleChanged(WPARAM wp, LPARAM lp);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	static int CALLBACK CompareProc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
	BOOL InitList();
	void InitColors();

	virtual void InitHeader();
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxinet.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXINET_H_
#define __AFXINET_H_

#pragma once

#ifndef __AFX_H__
	#include <afx.h>
#endif

#ifndef _WININET_
#include <wininet.h>
#endif

#ifdef _AFXDLL
#pragma comment(lib, "wininet.lib")
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// classes that are declared in this file

class CInternetSession; // from CObject

class CGopherLocator;   // from CObject

class CInternetFile;    // from CStdioFile (FILETXT.CPP)
	class CHttpFile;
	class CGopherFile;

class CInternetConnection;
	class CFtpConnection;
	class CGopherConnection;
	class CHttpConnection;

class CFtpFileFind;     // from CFileFind (FILEFIND.CPP)
class CGopherFileFind;

class CInternetException;

/////////////////////////////////////////////////////////////////////////////

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

/////////////////////////////////////////////////////////////////////////////
// Global Functions

BOOL AFXAPI AfxParseURL(LPCTSTR pstrURL, DWORD& dwServiceType,
	CString& strServer, CString& strObject, INTERNET_PORT& nPort);
BOOL AFXAPI AfxParseURLEx(LPCTSTR pstrURL, DWORD& dwServiceType,
	CString& strServer, CString& strObject, INTERNET_PORT& nPort,
	CString& strUsername, CString& strPassword, DWORD dwFlags = 0);

DWORD AFXAPI AfxGetInternetHandleType(HINTERNET hQuery);

// see CInternetException at the bottom of this file

void AFXAPI AfxThrowInternetException(DWORD_PTR dwContext, DWORD dwError = 0);

// these are defined by WININET.H

#define AFX_INET_SERVICE_FTP        INTERNET_SERVICE_FTP
#define AFX_INET_SERVICE_HTTP       INTERNET_SERVICE_HTTP
#define AFX_INET_SERVICE_GOPHER     INTERNET_SERVICE_GOPHER

// these are types that MFC parsing functions understand

#define AFX_INET_SERVICE_UNK        0x1000
#define AFX_INET_SERVICE_FILE       (AFX_INET_SERVICE_UNK+1)
#define AFX_INET_SERVICE_MAILTO     (AFX_INET_SERVICE_UNK+2)
#define AFX_INET_SERVICE_MID        (AFX_INET_SERVICE_UNK+3)
#define AFX_INET_SERVICE_CID        (AFX_INET_SERVICE_UNK+4)
#define AFX_INET_SERVICE_NEWS       (AFX_INET_SERVICE_UNK+5)
#define AFX_INET_SERVICE_NNTP       (AFX_INET_SERVICE_UNK+6)
#define AFX_INET_SERVICE_PROSPERO   (AFX_INET_SERVICE_UNK+7)
#define AFX_INET_SERVICE_TELNET     (AFX_INET_SERVICE_UNK+8)
#define AFX_INET_SERVICE_WAIS       (AFX_INET_SERVICE_UNK+9)
#define AFX_INET_SERVICE_AFS        (AFX_INET_SERVICE_UNK+10)
#define AFX_INET_SERVICE_HTTPS      (AFX_INET_SERVICE_UNK+11)

/////////////////////////////////////////////////////////////////////////////
// classes that are declared in this file

class CInternetSession : public CObject
{
public:
	/* explicit */ CInternetSession(LPCTSTR pstrAgent = NULL,
		DWORD_PTR dwContext = 1,
		DWORD dwAccessType = PRE_CONFIG_INTERNET_ACCESS,
		LPCTSTR pstrProxyName = NULL,
		LPCTSTR pstrProxyBypass = NULL,
		DWORD dwFlags = 0);

	BOOL QueryOption(DWORD dwOption, LPVOID lpBuffer, LPDWORD lpdwBufLen) const;
	BOOL QueryOption(DWORD dwOption, DWORD& dwValue) const;

	BOOL SetOption(DWORD dwOption, LPVOID lpBuffer, DWORD dwBufferLength,
			DWORD dwFlags = 0);
	BOOL SetOption(DWORD dwOption, DWORD dwValue, DWORD dwFlags = 0);

	CStdioFile* OpenURL(LPCTSTR pstrURL,
		DWORD_PTR dwContext = 1, DWORD dwFlags = INTERNET_FLAG_TRANSFER_ASCII,
		LPCTSTR pstrHeaders = NULL, DWORD dwHeadersLength = 0);

	CFtpConnection* GetFtpConnection(LPCTSTR pstrServer,
		LPCTSTR pstrUserName = NULL, LPCTSTR pstrPassword = NULL,
		INTERNET_PORT nPort = INTERNET_INVALID_PORT_NUMBER,
		BOOL bPassive = FALSE);

	CHttpConnection* GetHttpConnection(LPCTSTR pstrServer,
		INTERNET_PORT nPort = INTERNET_INVALID_PORT_NUMBER,
		LPCTSTR pstrUserName = NULL, LPCTSTR pstrPassword = NULL);
	CHttpConnection* GetHttpConnection(LPCTSTR pstrServer, DWORD dwFlags,
		INTERNET_PORT nPort = INTERNET_INVALID_PORT_NUMBER,
		LPCTSTR pstrUserName = NULL, LPCTSTR pstrPassword = NULL);

	CGopherConnection* GetGopherConnection(LPCTSTR pstrServer,
		LPCTSTR pstrUserName = NULL, LPCTSTR pstrPassword = NULL,
		INTERNET_PORT nPort = INTERNET_INVALID_PORT_NUMBER);

	BOOL EnableStatusCallback(BOOL bEnable = TRUE);

// Operations

	DWORD_PTR GetContext() const;
	operator HINTERNET() const;
	virtual void Close();

	// cookies
	static BOOL SetCookie(LPCTSTR pstrUrl, LPCTSTR pstrCookieName, LPCTSTR pstrCookieData);
	static BOOL GetCookie(_In_z_ LPCTSTR pstrUrl, _In_z_ LPCTSTR pstrCookieName, _Out_z_cap_(dwBufLen) LPTSTR pstrCookieData, _In_ DWORD dwBufLen);
	static DWORD GetCookieLength(LPCTSTR pstrUrl, LPCTSTR pstrCookieName);
	static BOOL GetCookie(LPCTSTR pstrUrl, LPCTSTR pstrCookieName, CString& strCookieData);

// Overridables
	virtual void OnStatusCallback(DWORD_PTR dwContext, DWORD dwInternetStatus,
		LPVOID lpvStatusInformation, DWORD dwStatusInformationLength);

// Implementation
	DECLARE_DYNAMIC(CInternetSession)
	~CInternetSession();

protected:
	DWORD_PTR m_dwContext;
	HINTERNET m_hSession;
	INTERNET_STATUS_CALLBACK m_pOldCallback;
	BOOL m_bCallbackEnabled;

public:
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
};


////////////////////////////////////////////////////////////////////////////
// Internet File Access Wrapper

class CInternetFile : public CStdioFile
{
// Constructors
protected:
	CInternetFile(HINTERNET hFile, LPCTSTR pstrFileName,
		CInternetConnection* pConnection, BOOL bReadMode);
	CInternetFile(HINTERNET hFile, HINTERNET hSession,
		LPCTSTR pstrFileName, LPCTSTR pstrServer, DWORD_PTR dwContext,
		BOOL bReadMode);

// Attributes
protected:
	HINTERNET m_hFile;
public:
	operator HINTERNET() const;
	DWORD_PTR GetContext() const;

// Operations
	BOOL SetWriteBufferSize(UINT nWriteSize);
	BOOL SetReadBufferSize(UINT nReadSize);

	BOOL QueryOption(DWORD dwOption, LPVOID lpBuffer, LPDWORD lpdwBufLen) const;
	BOOL QueryOption(DWORD dwOption, DWORD& dwValue) const;

	BOOL SetOption(DWORD dwOption, LPVOID lpBuffer, DWORD dwBufferLength,
			DWORD dwFlags = 0);
	BOOL SetOption(DWORD dwOption, DWORD dwValue, DWORD dwFlags = 0);

// Overridables
	virtual ULONGLONG Seek(LONGLONG lOffset, UINT nFrom);

	virtual UINT Read(void* lpBuf, UINT nCount);
	virtual void Write(const void* lpBuf, UINT nCount);

	virtual void Abort();
	virtual void Flush();

	virtual void Close();
	virtual ULONGLONG GetLength() const;

	virtual BOOL ReadString(CString& rString);
	virtual LPTSTR ReadString(_Out_z_cap_(nMax) LPTSTR pstr, _In_ UINT nMax);
	virtual void WriteString(LPCTSTR pstr);

	// Not supported by CInternetFile
	void LockRange(ULONGLONG dwPos, ULONGLONG dwCount);
	void UnlockRange(ULONGLONG dwPos, ULONGLONG dwCount);
	CFile* Duplicate() const;
	virtual void SetLength(ULONGLONG dwNewLen);

// Implementation
public:
	virtual ~CInternetFile();

protected:
	BOOL m_bReadMode;
	DWORD_PTR m_dwContext;
	HINTERNET m_hConnection;

	CString m_strServerName;

	UINT m_nWriteBufferSize;
	UINT m_nWriteBufferPos;
	LPBYTE m_pbWriteBuffer;

	UINT m_nReadBufferSize;
	UINT m_nReadBufferPos;
	LPBYTE m_pbReadBuffer;
	UINT m_nReadBufferBytes;

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	friend class CInternetSession;
	friend class CFtpConnection;
	friend class CHttpConnection;
	friend class CGopherConnection;
	DECLARE_DYNAMIC(CInternetFile)
};


class CHttpFile : public CInternetFile
{
// Constructors
protected:
	CHttpFile(HINTERNET hFile, HINTERNET hSession, LPCTSTR pstrObject,
		LPCTSTR pstrServer, LPCTSTR pstrVerb, DWORD_PTR dwContext);
	CHttpFile(HINTERNET hFile, LPCTSTR pstrVerb, LPCTSTR pstrObject,
		CHttpConnection* pConnection);

// Operations
public:
	BOOL AddRequestHeaders(LPCTSTR pstrHeaders,
		DWORD dwFlags = HTTP_ADDREQ_FLAG_ADD_IF_NEW, int dwHeadersLen = -1);
	BOOL AddRequestHeaders(CString& str,
		DWORD dwFlags = HTTP_ADDREQ_FLAG_ADD_IF_NEW);

	BOOL SendRequest(LPCTSTR pstrHeaders = NULL, DWORD dwHeadersLen = 0,
		LPVOID lpOptional = NULL, DWORD dwOptionalLen = 0);
	BOOL SendRequest(CString& strHeaders,
		LPVOID lpOptional = NULL, DWORD dwOptionalLen = 0);
	BOOL SendRequestEx(DWORD dwTotalLen,
		DWORD dwFlags = HSR_INITIATE,	DWORD_PTR dwContext = 1);
	BOOL SendRequestEx(LPINTERNET_BUFFERS lpBuffIn,
		LPINTERNET_BUFFERS lpBuffOut, DWORD dwFlags = HSR_INITIATE,
		DWORD_PTR dwContext = 1);
	BOOL EndRequest(DWORD dwFlags = 0,
		LPINTERNET_BUFFERS lpBuffIn = NULL, DWORD_PTR dwContext = 1);
	BOOL QueryInfo(DWORD dwInfoLevel, LPVOID lpvBuffer,
		LPDWORD lpdwBufferLength, LPDWORD lpdwIndex = NULL) const;
	BOOL QueryInfo(DWORD dwInfoLevel, CString& str,
		LPDWORD dwIndex = NULL) const;
	BOOL QueryInfo(DWORD dwInfoLevel, SYSTEMTIME* pSysTime,
		LPDWORD dwIndex = NULL) const;
	BOOL QueryInfo(DWORD dwInfoLevel, DWORD& dwResult,
		LPDWORD dwIndex = NULL) const;
	BOOL QueryInfoStatusCode(DWORD& dwStatusCode) const;

	DWORD ErrorDlg(CWnd* pParent = NULL,
		DWORD dwError = ERROR_INTERNET_INCORRECT_PASSWORD,
		DWORD dwFlags = FLAGS_ERROR_UI_FLAGS_GENERATE_DATA | FLAGS_ERROR_UI_FLAGS_CHANGE_OPTIONS,
		LPVOID* lppvData = NULL);

// Attributes
public:
	CString GetVerb() const;

#pragma push_macro("GetObject")
#undef GetObject
	CString _AFX_FUNCNAME(GetObject)() const;
	CString GetObject() const;
#pragma pop_macro("GetObject")

	virtual CString GetFileURL() const;

// Implementation
public:
	virtual ~CHttpFile();
protected:
	CString m_strObject;
	CString m_strVerb;

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	friend class CHttpConnection;
	friend class CInternetSession;
	DECLARE_DYNAMIC(CHttpFile)
};

// class CGopherFile is declared after CGopherLocator, below


////////////////////////////////////////////////////////////////////////////
// Connection types

class CInternetConnection : public CObject
{
public:
	CInternetConnection(CInternetSession* pSession, LPCTSTR pstrServer,
		INTERNET_PORT nPort = INTERNET_INVALID_PORT_NUMBER,
		DWORD_PTR dwContext = 1);

// Operations
	operator HINTERNET() const;
	DWORD_PTR GetContext() const;
	CInternetSession* GetSession() const;

	CString GetServerName() const;

	BOOL QueryOption(DWORD dwOption, LPVOID lpBuffer, LPDWORD lpdwBufLen) const;
	BOOL QueryOption(DWORD dwOption, DWORD& dwValue) const;

	BOOL SetOption(DWORD dwOption, LPVOID lpBuffer, DWORD dwBufferLength,
			DWORD dwFlags = 0);
	BOOL SetOption(DWORD dwOption, DWORD dwValue, DWORD dwFlags = 0);

	virtual void Close();

// Implementation
protected:
	HINTERNET m_hConnection;
	DWORD_PTR m_dwContext;
	CInternetSession* m_pSession;

	CString m_strServerName;
	INTERNET_PORT m_nPort;

public:
	~CInternetConnection();
	DECLARE_DYNAMIC(CInternetConnection)

#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
	void AssertValid() const;
#endif
};

class CFtpConnection : public CInternetConnection
{
public:
	enum CmdResponseType
	{
		CmdRespNone = 0,
		CmdRespRead,
		CmdRespWrite
	};

public:
	CFtpConnection(CInternetSession* pSession, HINTERNET hConnected,
		LPCTSTR pstrServer, DWORD_PTR dwContext);
	CFtpConnection(CInternetSession* pSession, LPCTSTR pstrServer,
		LPCTSTR pstrUserName = NULL, LPCTSTR pstrPassword = NULL,
		DWORD_PTR dwContext = 0,
		INTERNET_PORT nPort = INTERNET_INVALID_PORT_NUMBER,
		BOOL bPassive = FALSE);

#pragma push_macro("SetCurrentDirectory")
#undef SetCurrentDirectory
	BOOL _AFX_FUNCNAME(SetCurrentDirectory)(LPCTSTR pstrDirName);
	BOOL SetCurrentDirectory(LPCTSTR pstrDirName);
#pragma pop_macro("SetCurrentDirectory")

	BOOL GetCurrentDirectory(CString& strDirName) const;
	BOOL GetCurrentDirectory(_Out_z_cap_post_count_(*lpdwLen, *lpdwLen) LPTSTR pstrDirName, _Inout_ LPDWORD lpdwLen) const;
	BOOL GetCurrentDirectoryAsURL(_Out_z_cap_post_count_(*lpdwLen, *lpdwLen) LPTSTR pstrName, _Inout_ LPDWORD lpdwLen) const;
	BOOL GetCurrentDirectoryAsURL(CString& strDirName) const;

	BOOL RemoveDirectory(LPCTSTR pstrDirName);
#pragma push_macro("CreateDirectory")
#undef CreateDirectory
	BOOL _AFX_FUNCNAME(CreateDirectory)(LPCTSTR pstrDirName);
	BOOL CreateDirectory(LPCTSTR pstrDirName);
#pragma pop_macro("CreateDirectory")
	BOOL Rename(LPCTSTR pstrExisting, LPCTSTR pstrNew);
	BOOL Remove(LPCTSTR pstrFileName);

	BOOL PutFile(LPCTSTR pstrLocalFile, LPCTSTR pstrRemoteFile,
		DWORD dwFlags = FTP_TRANSFER_TYPE_BINARY, DWORD_PTR dwContext = 1);

	BOOL GetFile(LPCTSTR pstrRemoteFile, LPCTSTR pstrLocalFile,
		BOOL bFailIfExists = TRUE,
		DWORD dwAttributes = FILE_ATTRIBUTE_NORMAL,
		DWORD dwFlags = FTP_TRANSFER_TYPE_BINARY, DWORD_PTR dwContext = 1);

	CInternetFile* OpenFile(LPCTSTR pstrFileName,
		DWORD dwAccess = GENERIC_READ,
		DWORD dwFlags = FTP_TRANSFER_TYPE_BINARY, DWORD_PTR dwContext = 1);

#if _WIN32_IE >= 0x0500
	CInternetFile* Command(LPCTSTR pszCommand, CmdResponseType eResponse = CmdRespNone,
		DWORD dwFlags = FTP_TRANSFER_TYPE_BINARY,
		DWORD_PTR dwContext = 1);
#endif

// Implementation
	~CFtpConnection();

protected:
	CString m_strServerName;

public:
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
	virtual void AssertValid() const;
#endif

	DECLARE_DYNAMIC(CFtpConnection)
};

class CHttpConnection : public CInternetConnection
{
public:
	enum {
		_HTTP_VERB_MIN      = 0,
		HTTP_VERB_POST      = 0,
		HTTP_VERB_GET       = 1,
		HTTP_VERB_HEAD      = 2,
		HTTP_VERB_PUT       = 3,
		HTTP_VERB_LINK      = 4,
		HTTP_VERB_DELETE    = 5,
		HTTP_VERB_UNLINK    = 6,
		_HTTP_VERB_MAX      = 6,
	};

public:
	CHttpConnection(CInternetSession* pSession, HINTERNET hConnected,
		LPCTSTR pstrServer, DWORD_PTR dwContext);
	CHttpConnection(CInternetSession* pSession, LPCTSTR pstrServer,
		INTERNET_PORT nPort = INTERNET_INVALID_PORT_NUMBER,
		LPCTSTR pstrUserName = NULL, LPCTSTR pstrPassword = NULL,
		DWORD_PTR dwContext = 1);
	CHttpConnection(CInternetSession* pSession, LPCTSTR pstrServer,
		DWORD dwFlags, INTERNET_PORT nPort = INTERNET_INVALID_PORT_NUMBER,
		LPCTSTR pstrUserName = NULL, LPCTSTR pstrPassword = NULL,
		DWORD_PTR dwContext = 1);

	CHttpFile* OpenRequest(LPCTSTR pstrVerb,    LPCTSTR pstrObjectName,
		LPCTSTR pstrReferer = NULL,DWORD_PTR dwContext = 1,
		LPCTSTR* ppstrAcceptTypes = NULL, LPCTSTR pstrVersion = NULL,
		DWORD dwFlags = INTERNET_FLAG_EXISTING_CONNECT);

	CHttpFile* OpenRequest(int nVerb, LPCTSTR pstrObjectName,
		LPCTSTR pstrReferer = NULL, DWORD_PTR dwContext = 1,
		LPCTSTR* ppstrAcceptTypes = NULL, LPCTSTR pstrVersion = NULL,
		DWORD dwFlags = INTERNET_FLAG_EXISTING_CONNECT);

// Implementation
	~CHttpConnection();

protected:
	CString m_strServerName;
	static const LPCTSTR szHtmlVerbs[];

public:
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
	virtual void AssertValid() const;
#endif

	friend class CInternetSession;  // just to access szHtmlVerbs
	DECLARE_DYNAMIC(CHttpConnection)
};

class CGopherConnection : public CInternetConnection
{
public:
	CGopherConnection(CInternetSession* pSession,
		HINTERNET hConnected, LPCTSTR pstrServer, DWORD_PTR dwContext);

	CGopherConnection(CInternetSession* pSession, LPCTSTR pstrServer,
		LPCTSTR pstrUserName = NULL, LPCTSTR pstrPassword = NULL,
		DWORD_PTR dwContext = 0,
		INTERNET_PORT nPort = INTERNET_INVALID_PORT_NUMBER);

	CGopherFile* OpenFile(CGopherLocator& refLocator, DWORD dwFlags = 0,
		LPCTSTR pstrView = NULL, DWORD_PTR dwContext = 1);

	CGopherLocator CreateLocator(LPCTSTR pstrDisplayString,
		LPCTSTR pstrSelectorString, DWORD dwGopherType);

	BOOL CGopherConnection::GetAttribute(CGopherLocator& refLocator,
		CString strRequestedAttributes, CString& strResult);

	static CGopherLocator CreateLocator(LPCTSTR pstrLocator);
	static CGopherLocator CreateLocator(LPCTSTR pstrServerName,
		LPCTSTR pstrDisplayString,
		LPCTSTR pstrSelectorString, DWORD dwGopherType,
		INTERNET_PORT nPort = INTERNET_INVALID_PORT_NUMBER);

// Implementation
	~CGopherConnection();

public:
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
	virtual void AssertValid() const;
#endif
	DECLARE_DYNAMIC(CGopherConnection)
};


/////////////////////////////////////////////////////////////////////////////
// CFtpFileFind

class CFtpFileFind : public CFileFind
{
public:
	explicit CFtpFileFind(CFtpConnection* pConnection, DWORD_PTR dwContext = 1);
	virtual ~CFtpFileFind();

	virtual BOOL FindFile(LPCTSTR pstrName = NULL,
		DWORD dwFlags = INTERNET_FLAG_RELOAD);
	virtual BOOL FindNextFile();
	CString GetFileURL() const;

// Implementation
protected:
	virtual void CloseContext();
	CFtpConnection* m_pConnection;
	DWORD_PTR m_dwContext;

public:
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
	virtual void AssertValid() const;
#endif

	DECLARE_DYNAMIC(CFtpFileFind)
};


/////////////////////////////////////////////////////////////////////////////
// CGopherLocator

class CGopherLocator : public CObject
{
public:
	~CGopherLocator();
	operator LPCTSTR() const;
	CGopherLocator(const CGopherLocator& ref);
	BOOL GetLocatorType(DWORD& dwRef) const;

private:
	// this only created by CGopherConnection::CreateLocator or by serialization
	CGopherLocator(LPCTSTR pstrLocator, DWORD dwLocLen);

	CString m_Locator;  // _not_ a zero-terminated string!
	DWORD m_dwBufferLength;

	friend class CGopherConnection;
	friend class CGopherFile;
};


/////////////////////////////////////////////////////////////////////////////
// CGopherFile

class CGopherFile : public CInternetFile
{
// Constructors
protected:
	CGopherFile(HINTERNET hFile, CGopherLocator& refLocator,
		CGopherConnection* pConnection);
	CGopherFile(HINTERNET hFile, HINTERNET hSession,
		LPCTSTR pstrLocator, DWORD dwLocLen, DWORD_PTR dwContext);

// Operations
public:
	virtual void Write(const void* lpBuf, UINT nCount);
	void WriteString(LPCTSTR pstr);

// Implementation
protected:
	CGopherLocator m_Locator;
public:
	virtual ~CGopherFile();

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	friend class CInternetSession;
	friend class CGopherConnection;
	DECLARE_DYNAMIC(CGopherFile)
};


/////////////////////////////////////////////////////////////////////////////
// CGopherFileFind

class CGopherFileFind : public CFileFind
{
public:
	explicit CGopherFileFind(CGopherConnection* pConnection, DWORD_PTR dwContext = 1);
	virtual ~CGopherFileFind();

	virtual BOOL FindFile(CGopherLocator& refLocator, LPCTSTR pstrString,
		DWORD dwFlags = INTERNET_FLAG_RELOAD);
	virtual BOOL FindFile(LPCTSTR pstrString,
		DWORD dwFlags = INTERNET_FLAG_RELOAD);
	virtual BOOL FindNextFile();

	virtual BOOL IsDots() const;

	virtual BOOL GetLastWriteTime(FILETIME* pTimeStamp) const;
	virtual BOOL GetLastAccessTime(FILETIME* pTimeStamp) const;
	virtual BOOL GetCreationTime(FILETIME* pTimeStamp) const;
	virtual BOOL GetLastWriteTime(CTime& refTime) const;
	virtual BOOL GetLastAccessTime(CTime& refTime) const;
	virtual BOOL GetCreationTime(CTime& refTime) const;

	CGopherLocator GetLocator() const;
	CString GetScreenName() const;

	virtual ULONGLONG GetLength() const;

protected:
	virtual void CloseContext();
	CGopherConnection* m_pConnection;
	DWORD_PTR m_dwContext;

// Implementation
public:
	// Unsupported APIs
	CString GetFileName() const;
	CString GetFilePath() const;
	CString GetFileTitle() const;
	CString GetFileURL() const;
	CString GetRoot() const;

#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
	virtual void AssertValid() const;
#endif
	DECLARE_DYNAMIC(CGopherFileFind)
};


///////////////////////////////////////////////////////////////////////
// CInternetException

class CInternetException : public CException
{
public:
// Constructor
	CInternetException(DWORD dwError);

// Attributes
	DWORD m_dwError;
	DWORD_PTR m_dwContext;

// Implementation
public:
	~CInternetException();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual BOOL GetErrorMessage(_Out_z_cap_(nMaxError) LPTSTR lpstrError, _In_ UINT nMaxError,
		_Out_opt_ PUINT pnHelpContext = NULL) const;
	DECLARE_DYNAMIC(CInternetException)
};

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_ENABLE_INLINES
#define _AFXINET_INLINE AFX_INLINE
#include <afxinet.inl>
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifndef _AFX_DISABLE_DEPRECATED
#pragma deprecated( CGopherLocator )
#pragma deprecated( CGopherFile )
#pragma deprecated( CGopherConnection )
#pragma deprecated( CGopherFileFind )
#endif

#endif // __AFXINET_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxmdichildwndex.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxframeimpl.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMDIFrameWndEx;
class CMDIChildWndEx;

class CMDITabProxyWnd : public CWnd
{
	DECLARE_DYNCREATE(CMDITabProxyWnd)
public:
	CMDITabProxyWnd();
	virtual ~CMDITabProxyWnd();

	void SetRelatedMDIChildFrame(CMDIChildWndEx* pRelatedMDIFrame);
	HBITMAP GetClientBitmap(int nWidth, int nHeight, BOOL bIsThumbnail);

protected:
	afx_msg LRESULT OnSendIconicThumbnail(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnSendIconicLivePreviewBitmap(WPARAM wParam, LPARAM lParam);
	afx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);
	afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnClose();
	DECLARE_MESSAGE_MAP()

	BOOL IsMDIChildActive();

	CMDIChildWndEx* m_pRelatedMDIChildFrame;
};
/////////////////////////////////////////////////////////////////////////////
// CMDIChildWndEx frame

class CMDIChildWndEx : public CMDIChildWnd
{
	friend class CMDIClientAreaWnd;
	friend class CMDIFrameWndEx;
	friend class CMDITabProxyWnd;

	DECLARE_DYNCREATE(CMDIChildWndEx)
protected:
	CMDIChildWndEx(); // protected constructor used by dynamic creation

// Attributes
public:
	AFX_IMPORT_DATA static BOOL  m_bEnableFloatingBars;
	AFX_IMPORT_DATA static DWORD m_dwExcludeStyle;
	/// <summary>
	/// A combination of flags, which is passed by the framework to the SetTaskbarTabProperties method,
	/// when a tab (MDI child) is being registered with Windows 7 taskbar tabs.
	/// The default combination is STPF_USEAPPTHUMBNAILWHENACTIVE | STPF_USEAPPPEEKWHENACTIVE.</summary>
	AFX_IMPORT_DATA static DWORD m_dwDefaultTaskbarTabPropertyFlags;

	BOOL IsTabbedPane() const { return m_pTabbedControlBar != NULL; }
	CDockablePane* GetTabbedPane() const { return m_pTabbedControlBar; }

	CMDIFrameWndEx* GetMDIFrameWndEx() const { return m_pMDIFrame; }

protected:
	// ---- MDITabGroup+
	CMFCTabCtrl* m_pRelatedTabGroup;
	// ---- MDITabGroup-

	BOOL  m_bToBeDestroyed;
	BOOL  m_bWasMaximized;
	BOOL  m_bIsMinimized;
	CRect m_rectOriginal;
	// set during OnMDIActivate to prevent unnecessary 
	// RecalcLayout in CMDIFrameWnd in OLE InPlace mode
	BOOL  m_bActivating;
	BOOL  m_bInOnCreate;

	CFrameImpl      m_Impl;
	CDockingManager m_dockManager;
	CDockablePane*  m_pTabbedControlBar;
	CMDIFrameWndEx* m_pMDIFrame;

	CMDITabProxyWnd m_tabProxyWnd;
	BOOL            m_bTabRegistered;
	BOOL            m_bEnableTaskbarThumbnailClip;

// Operations
public:
	// ---- MDITabGroup+
	CMFCTabCtrl* GetRelatedTabGroup() { return m_pRelatedTabGroup; }
	void SetRelatedTabGroup(CMFCTabCtrl* p) { m_pRelatedTabGroup = p; }
	// ---- MDITabGroup-

	void AddDockSite();
	BOOL AddPane(CBasePane* pControlBar, BOOL bTail = TRUE);
	BOOL InsertPane(CBasePane* pControlBar, CBasePane* pTarget, BOOL bAfter = TRUE);
	void RemovePaneFromDockManager(CBasePane* pControlBar, BOOL bDestroy, BOOL bAdjustLayout, BOOL bAutoHide, CBasePane* pBarReplacement);
	void DockPane(CBasePane* pBar, UINT nDockBarID = 0, LPCRECT lpRect = NULL);

	void AddTabbedPane(CDockablePane* pControlBar);

	CBasePane* PaneFromPoint(CPoint point, int nSensitivity, bool bExactBar, CRuntimeClass* pRTCBarType) const;
	CBasePane* PaneFromPoint(CPoint point, int nSensitivity, DWORD& dwAlignment, CRuntimeClass* pRTCBarType) const;
	BOOL IsPointNearDockSite(CPoint point, DWORD& dwBarAlignment, BOOL& bOuterEdge) const;
	virtual void AdjustDockingLayout(HDWP hdwp = NULL);
	BOOL EnableDocking(DWORD dwDockStyle);
	BOOL EnableAutoHidePanes(DWORD dwDockStyle);

	CBasePane* GetPane(UINT nID);
	void ShowPane(CBasePane* pBar, BOOL bShow, BOOL bDelay, BOOL bActivate);

	virtual BOOL OnMoveMiniFrame(CWnd* pFrame);
	virtual void RecalcLayout(BOOL bNotify = TRUE);

	virtual BOOL GetToolbarButtonToolTipText(CMFCToolBarButton* /*pButton*/, CString& /*strTTText*/) { return FALSE; }

	BOOL DockPaneLeftOf(CPane* pBar, CPane* pLeftOf);

	/// <summary>
	/// Registers MDI child with Windows 7 taskbar tabs.</summary>
	/// <param name="pWndBefore">A pointer to MDI child window whose thumbnail is inserted to the left of. 
	/// This window must already be registered through RegisterTaskbarTab. If this value is NULL, the new thumbnail is added to the end of the list.</param>
	virtual void RegisterTaskbarTab(CMDIChildWndEx* pWndBefore = NULL);

	/// <summary>
	/// Returns TRUE if MDI child was successfully registered with Windows 7 taskbar tabs.</summary>
	/// <returns>
	/// TRUE if MDI child is registered with Windows 7 taskbar tabs; otherwise FALSE.</returns>
	BOOL IsRegisteredWithTaskbarTabs();

	/// <summary>
	/// Invalidates iconic bitmap representation of MDI child.</summary>
	/// <remarks> Should be called when the live content or size of MDI child has changed</remarks>
	/// <returns> Returns FALSE is Windows 7 taskbar support is disabled or the MDI child
	/// is not registered with Windows 7 taskbar tabs; otherwise returns TRUE.</returns>
	BOOL InvalidateIconicBitmaps();

	/// <summary>
	/// Tells whether the MDI child can appear on Windows 7 taskbar tabs.</summary>
	/// <remarks> Returns TRUE if MDI child can show on Windows 7 taskbar tabs.</remarks>
	/// <returns> Returns TRUE if MDI child can show on Windows 7 taskbar tabs, 
	/// or FALSE if MDI child can't be shown on Windows 7 taskbar tabs.</returns>
	BOOL IsTaskbarTabsSupportEnabled();

	/// <summary>
	/// Inserts MDI child before specified window on Windows 7 taskbar tabs.</summary>
	/// <param name="pWndBefore">A pointer to MDI child window whose thumbnail is inserted to the left of. 
	/// This window must already be registered through RegisterTaskbarTab. If this value is NULL, the new thumbnail is added to the end of the list.</param>
	void SetTaskbarTabOrder(CMDIChildWndEx* pWndBefore = NULL);

	/// <summary>
	/// Activates corresponding Windows 7 taskbar tab.</summary>
	void SetTaskbarTabActive();

	/// <summary>
	/// Sets properties for a Windows 7 taskbar tab.</summary>
	/// <param name="dwFlags">A combination of STPFLAG values. See ITaskbarList4::SetTabProperties for details.</param>
	void SetTaskbarTabProperties(DWORD dwFlags);

	/// <summary> 
	/// Removes MDI child from Windows 7 taskbar tabs.</summary>
	/// <param name="bCheckRegisteredMDIChildCount">Specifies whether this function needs to check the number of MDI children registered with MDI tabs.
	/// If this number is 0, then this function removes clipping rectangle from application's taskbar thumbnail.</param>
	void UnregisterTaskbarTab(BOOL bCheckRegisteredMDIChildCount = TRUE);

	/// <summary> 
	/// Returns tab proxy window actually registered with Windows 7 taskbar tabs.</summary>
	/// <returns> A pointer to CMDITabProxyWnd object, which is registered with Windows 7 taskbar tabs.</returns>
	CMDITabProxyWnd* GetTabProxyWnd() { return &m_tabProxyWnd;}

	/// <summary> 
	/// Enables or disables automatic selection of a portion of a window's client area to display 
	/// as that window's thumbnail in the taskbar. </summary>
	/// <param name="bEnable"> Specifies whether to enable (TRUE), or disable (FALSE) automatic selection of a portion of a window's client area to display.</param>
	void EnableTaskbarThumbnailClipRect(BOOL bEnable = TRUE);

	/// <summary> 
	/// Tells whether automatic selection of a portion of a window's client area to display 
	/// as that window's thumbnail in the taskbar is enabled or disabled. </summary>
	/// <returns>
	/// Returns TRUE if automatic selection of a portion of a window's client area to display is enabled; otherwise FALSE.</returns>
	BOOL IsTaskbarThumbnailClipRectEnabled() const { return m_bEnableTaskbarThumbnailClip; }

// Overrides

	// Next methods used by MDI tabs:
	virtual CString GetFrameText() const;
	virtual HICON GetFrameIcon() const;

	virtual void OnUpdateFrameTitle(BOOL bAddToTitle);

	virtual BOOL CanShowOnMDITabs() { return (GetStyle() & WS_VISIBLE) != 0; }
	virtual BOOL CanShowOnWindowsList() { return TRUE; }
	virtual BOOL IsReadOnly() { return FALSE; }

	/// <summary>
	/// Updates Windows 7 taskbar tab icon.</summary>
	/// <param name="hIcon"> A handle to an icon to display on Windows 7 taskbar tab.</param>
	virtual void UpdateTaskbarTabIcon(HICON hIcon);
	/// <summary> 
	/// Tells the framework whether this MDI child can be displayed on Windows 7 taskbar tabs.</summary>
	/// <remarks>
	/// Override this method in a derived class and return FALSE to disable appearance of this MDI child
	/// on Windows 7 taskbar tabs.</remarks>
	/// <returns>
	/// Should return TRUE if the content of MDI child can be displayed on Windows 7 taskbar thumbnails.</returns>
	virtual BOOL CanShowOnTaskBarTabs() { return TRUE; }

	/// <summary> 
	/// Called by the framework when it needs to obtain a bitmap for iconic thumbnail of MDI child.</summary>
	/// <returns> 
	/// If processed, should return a handle to a valid 32bpp bitmap, otherwise NULL.</returns>
	/// <remarks>
	/// Override this method in a derived class an return a valid 32bpp bitmap for iconic thumbnail of MDI child.
	/// This method is called only when MDI child is displayed on Windows 7 taskbar tabs.
	/// If you return NULL, MFC calls default handlers and obtains bitmaps using PrintClient.</remarks>
	/// <param name="nWidth"> Specifies the width of required bitmap.</param>
	/// <param name="nHeight"> Specifies the height of required bitmap.</param>
	virtual HBITMAP OnGetIconicThumbnail(int nWidth, int nHeight) 
	{ 
		UNREFERENCED_PARAMETER(nWidth);
		UNREFERENCED_PARAMETER(nHeight);
		return NULL; 
	}

	/// <summary> 
	/// Called by the framework when it needs to obtain a bitmap for live preview of MDI child.</summary>
	/// <returns> 
	/// If processed, should return a handle to a valid 32bpp bitmap, otherwise NULL.</returns>
	/// <remarks>
	/// Override this method in a derived class an return a valid 32bpp bitmap for live preview of MDI child.
	/// This method is called only when MDI child is displayed on Windows 7 taskbar tabs.
	/// If you return NULL, MFC calls default handlers and obtains bitmaps using PrintClient or PrintWindow.</remarks>
	/// <param name="bIsMDIChildActive"> This parameter is TRUE if the bitmap is requested for MDI child, which is currently active and the main window is not minimized. 
	/// The default processing in this case takes a snapshot of the main window.</param>
	/// <param name="ptLocation"> Specifies the location of bitmap in the main (top level) window client coordinated. This point should be provided by callee.</param>
	virtual HBITMAP OnGetIconicLivePreviewBitmap(BOOL bIsMDIChildActive, CPoint& ptLocation) 
	{
		UNREFERENCED_PARAMETER(bIsMDIChildActive);
		UNREFERENCED_PARAMETER(ptLocation);
		return NULL; 
	}

	/// <summary> 
	/// Called by the framework when it needs to stretch a bitmap for Windows 7 taskbar tab thumbnail preview of MDI child.</summary>
	/// <returns>Should return TRUE if overridden and processed in a derived class.</returns> 
	/// <param name="hBmpDst">A handle to a destination bitmap.</param>
	/// <param name="rectDst">Specifies the destination rectangle.</param>
	/// <param name="hBmpSrc">A handle to a source bitmap.</param>
	/// <param name="rectSrc">Specifies the source rectangle.</param>
	virtual BOOL OnTaskbarTabThumbnailStretch(HBITMAP hBmpDst, const CRect& rectDst, HBITMAP hBmpSrc, const CRect& rectSrc);

	/// <summary> 
	/// Called by the framework when it needs to obtain a child window (usually a view or splitter window) to be displayed on Windows 7 taskbar tab thumbnail.</summary>
	/// <returns>
	/// Should return a valid pointer to a CWnd object, whose preview should be displayed on 
	/// Windows 7 taskbar tab related to this MDI child. The default implementation returns
	/// a child window of this MDI child with AFX_IDW_PANE_FIRST control ID (which is usually a CView-derived class).</returns>
	virtual CWnd* GetTaskbarPreviewWnd();

	/// <summary> 
	/// Called by the framework when the user presses close button on Taskbar tab thumbnail..</summary>
	virtual void OnPressTaskbarThmbnailCloseButton();

	/// <summary> 
	/// Called by the framework when the Taskbar tab thumbnail should process WM_ACTIVATE message.</summary>
	/// <description>
	/// The default implementation activates related MDI child frame. </description>
	/// <param name="nState">Specifies whether the CWnd is being activated or deactivated.</param>
	/// <param name="pWndOther">Pointer to the CWnd being activated or deactivated. The pointer can be NULL, and it may be temporary.</param>
	/// <param name="bMinimized">Specifies the minimized state of the CWnd being activated or deactivated. A value of TRUE indicates the window is minimized.</param>
	virtual void OnTaskbarTabThumbnailActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);

	/// <summary> 
	/// Called by the framework when the Taskbar tab thumbnail should process WM_MOUSEACTIVATE message.</summary>
	/// <description>
	/// The default implementation activates related MDI child frame. </description>
	/// <param name="pDesktopWnd">Specifies a pointer to the top-level parent window of the window being activated. The pointer may be temporary and should not be stored.</param>
	/// <param name="nHitTest">Specifies the hit-test area code. A hit test is a test that determines the location of the cursor.</param>
	/// <param name="message">Specifies the mouse message number.</param>
	virtual int OnTaskbarTabThumbnailMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);

	/// <summary> 
	/// Called by the framework when it needs to select a portion of a window's client area to display 
	/// as that window's thumbnail in the taskbar.</summary>
	/// <returns> A rectangle in windows coordinates. This rectangle will be mapped to the client area of top level frame. 
	/// The rectangle should be empty to clear the clipping rectangle</returns>
	virtual CRect GetTaskbarThumbnailClipRect() const;

	CDockingManager* GetDockingManager() { return &m_dockManager; }

	virtual LPCTSTR GetDocumentName(CObject** pObj);

public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual void ActivateFrame(int nCmdShow = -1);
	virtual void OnSetPreviewMode(BOOL bPreview, CPrintPreviewState* pState);

protected:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

	/// <summary>
	/// Called internally by the framework to set clipping rectangle to select a portion of a window's client area to display 
	/// as that window's thumbnail in the taskbar.</summary>
	/// <param name="rect">Specifies the new clipping rectangle. If rectangle is empty or null, the clipping is removed.</param>
	/// <returns>Returns TRUE if the functions succeeds; otherwise FALSE.</returns>
	virtual BOOL SetTaskbarThumbnailClipRect(CRect rect);

// Implementation
protected:
	virtual ~CMDIChildWndEx();

	//{{AFX_MSG(CMDIChildWndEx)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnMDIActivate(BOOL bActivate, CWnd* pActivateWnd, CWnd* pDeactivateWnd);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnSizing(UINT fwSide, LPRECT pRect);
	afx_msg void OnDestroy();
	afx_msg void OnWindowPosChanged(WINDOWPOS FAR* lpwndpos);
	afx_msg void OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI);
	afx_msg void OnNcPaint();
	afx_msg BOOL OnNcActivate(BOOL bActive);
	afx_msg void OnNcMouseMove(UINT nHitTest, CPoint point);
	afx_msg LRESULT OnNcHitTest(CPoint point);
	afx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg LRESULT OnSetText(WPARAM,LPARAM);
	afx_msg LRESULT OnSetIcon(WPARAM,LPARAM);
	afx_msg LRESULT OnIdleUpdateCmdUI(WPARAM wParam = 0, LPARAM lParam = 0);
	afx_msg void OnStyleChanged(int nStyleType, LPSTYLESTRUCT lpStyleStruct);
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg LRESULT OnChangeVisualManager(WPARAM wParam, LPARAM lParam);
	afx_msg void OnNcRButtonUp(UINT nHitTest, CPoint point);
#if (NTDDI_VERSION >= NTDDI_WIN7)
	afx_msg void OnSendIconicThumbnail(WPARAM wParam, LPARAM lParam);
	afx_msg void OnSendIconicLivePreviewBitmap(WPARAM wParam, LPARAM lParam);
#endif
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void AdjustClientArea();
	/// <summary>
	/// Called internally by the framework to activate top level frame when the application should be activated 
	/// from a taskbar tab.</summary>
	virtual void ActivateTopLevelFrame();

	/// <summary>
	/// Called internally by the framework to set text of taskbar tab.</summary>
	/// <param name="lpcszDefaultText"> Specifies a text to set. Current implementation adds this text to application name if the MDI child has FWS_ADDTOTITLE style. </param>
	virtual void SetTaskbarTabText(LPCTSTR lpcszDefaultText);
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxmaskededit.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCMaskedEdit window

class CMFCMaskedEdit : public CEdit
{
	DECLARE_DYNAMIC(CMFCMaskedEdit)

// Construction
public:
	CMFCMaskedEdit();
	~CMFCMaskedEdit();

// Implementation
public:
	void EnableMask(LPCTSTR lpszMask, LPCTSTR lpszInputTemplate, TCHAR chMaskInputTemplate = _T('_'), LPCTSTR lpszValid = NULL);
	void DisableMask();

	void SetValidChars(LPCTSTR lpszValid = NULL);
	void EnableGetMaskedCharsOnly(BOOL bEnable = TRUE) { m_bGetMaskedCharsOnly = bEnable; }
	void EnableSetMaskedCharsOnly(BOOL bEnable = TRUE) { m_bSetMaskedCharsOnly = bEnable; }
	void EnableSelectByGroup(BOOL bEnable = TRUE) { m_bSelectByGroup = bEnable; }

	void SetWindowText(LPCTSTR lpszString);
	int GetWindowText(_Out_z_cap_post_count_(nMaxCount, return + 1) LPTSTR lpszStringBuf, _In_ int nMaxCount) const;
	void GetWindowText(CString& rstrString) const;

protected:
	virtual BOOL IsMaskedChar(TCHAR chChar, TCHAR chMaskChar) const;

	const CString GetValue() const { return m_str;}
	const CString GetMaskedValue(BOOL bWithSpaces = TRUE) const;
	BOOL SetValue(LPCTSTR lpszString, BOOL bWithDelimiters = TRUE);

private:
	BOOL CheckChar(TCHAR chChar, int nPos);
	void OnCharPrintchar(UINT nChar, UINT nRepCnt, UINT nFlags);
	void OnCharBackspace(UINT nChar, UINT nRepCnt, UINT nFlags);
	void OnCharDelete(UINT nChar, UINT nRepCnt, UINT nFlags);
	void GetGroupBounds(int &nBegin, int &nEnd, int nStartPos=0, BOOL bForward=TRUE);
	BOOL DoUpdate(BOOL bRestoreLastGood = TRUE, int nBeginOld = -1, int nEndOld = -1);

// Attributes
private:
	CString m_str;                  // Initial value
	CString m_strMask;              // The mask string
	CString m_strInputTemplate;     // "_" char = character entry
	TCHAR   m_chMaskInputTemplate;  // Default char
	CString m_strValid;             // Valid string characters
	BOOL    m_bGetMaskedCharsOnly;
	BOOL    m_bSetMaskedCharsOnly;
	BOOL    m_bSelectByGroup;
	BOOL    m_bMaskKeyInProgress;
	BOOL    m_bPasteProcessing;
	BOOL    m_bSetTextProcessing;

protected:
	//{{AFX_MSG(CMFCMaskedEdit)
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg BOOL OnUpdateR();
	afx_msg void OnSetFocusR();
	afx_msg LRESULT OnCut(WPARAM, LPARAM);
	afx_msg LRESULT OnClear(WPARAM, LPARAM);
	afx_msg LRESULT OnPaste(WPARAM, LPARAM);
	afx_msg LRESULT OnSetText(WPARAM, LPARAM);
	afx_msg LRESULT OnGetText(WPARAM, LPARAM);
	afx_msg LRESULT OnGetTextLength(WPARAM, LPARAM);
	afx_msg LRESULT OnInitControl(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxmdiclientareawnd.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxtabctrl.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMDIFrameWndEx;

extern AFX_IMPORT_DATA UINT AFX_WM_ON_MOVETOTABGROUP;

/////////////////////////////////////////////////////////////////////////////
// CMDITabInfo

class CMDITabInfo
{
public:
	CMDITabInfo();
	void Serialize(CArchive& ar);

	CMFCTabCtrl::Location m_tabLocation;
	CMFCTabCtrl::Style    m_style;

	BOOL m_bTabIcons;
	BOOL m_bTabCloseButton;
	BOOL m_bTabCustomTooltips;
	BOOL m_bAutoColor;
	BOOL m_bDocumentMenu;
	BOOL m_bEnableTabSwap;
	BOOL m_bFlatFrame;
	BOOL m_bActiveTabCloseButton;
	int  m_nTabBorderSize;
};

/////////////////////////////////////////////////////////////////////////////
// CMDIClientAreaWnd window

class CMDIClientAreaWnd : public CWnd
{
	DECLARE_DYNAMIC(CMDIClientAreaWnd)
	friend class CMDIFrameWndEx;

// Construction
public:
	CMDIClientAreaWnd();

// Attributes
public:
	CMFCTabCtrl& GetMDITabs()
	{
		return m_wndTab;
	}

protected:
	CMFCTabCtrl m_wndTab;
	BOOL    m_bTabIsVisible;
	BOOL    m_bTabIsEnabled;

	CImageList m_TabIcons;
	CMap<HICON,HICON,int,int> m_mapIcons; // Icons already loaded into the image list

	// ---- MDITabGroup+
	enum GROUP_ALIGNMENT
	{
		GROUP_NO_ALIGN,
		GROUP_VERT_ALIGN,
		GROUP_HORZ_ALIGN
	};

	CMDITabInfo m_mdiTabParams;
	CObList       m_lstTabbedGroups;

	CMap<CWnd*, CWnd*, CImageList*, CImageList*>m_mapTabIcons;

	BOOL m_bIsMDITabbedGroup;
	BOOL m_bNewVericalGroup;
	BOOL m_bDisableUpdateTabs;
	CObList m_lstRemovedTabbedGroups;

	int m_nResizeMargin;
	int m_nNewGroupMargin;
	int m_nTotalResizeRest;
	CRect m_rectNewTabGroup;
	CStringList m_lstLoadedTabDocuments;
	GROUP_ALIGNMENT m_groupAlignment;
	// ---- MDITabGroup-

// Operations
public:
	void EnableMDITabs(BOOL bEnable, const CMDITabInfo& params);
	BOOL DoesMDITabExist() const { return m_bTabIsEnabled; }

	void SetActiveTab(HWND hwnd);
	void UpdateTabs(BOOL bSetActiveTabVisible = FALSE);

	// ---- MDITabGroup+
	void EnableMDITabbedGroups(BOOL bEnable, const CMDITabInfo& mdiTabParams);
	BOOL IsMDITabbedGroup() const { return m_bIsMDITabbedGroup; }

	virtual CMFCTabCtrl* CreateTabGroup(CMFCTabCtrl* pWndTab);
	void UpdateMDITabbedGroups(BOOL bSetActiveTabVisible);
	void CalcWindowRectForMDITabbedGroups(LPRECT lpClientRect, UINT nAdjustType);

	DWORD GetMDITabsContextMenuAllowedItems();

	BOOL IsMemberOfMDITabGroup(CWnd* pWnd);
	CMFCTabCtrl* FindActiveTabWndByActiveChild();
	CMFCTabCtrl* FindActiveTabWnd();
	CMFCTabCtrl* GetFirstTabWnd();
	/// <summary>
	/// Finds tab control containing the specified window.</summary>
	/// <return> 
	/// A valid pointer to tab control containing the specified window. 
	/// It's NULL if the specified window is not found.</return>
	/// <param name="hWndChild">A handle to window, which is contained in the resulting tab control.</param>
	/// <param name="iIndex">When the function returns it contains an index of hWndChild in tab control.</param>
	/// <remarks>
	/// If window specified by hWndChild is found, iIndex contains index of this window in the tabbed group.</remarks>
	CMFCTabCtrl* FindTabWndByChild(HWND hWndChild, int& iIndex);
	const CObList& GetMDITabGroups() const { return m_lstTabbedGroups; }

	void MDITabMoveToNextGroup(BOOL bNext = TRUE);
	void MDITabNewGroup(BOOL bVert = TRUE);
	BOOL MoveWindowToTabGroup(CMFCTabCtrl* pTabWndFrom, CMFCTabCtrl* pTabWndTo, int nIdxFrom = -1);

	void RemoveTabGroup(CMFCTabCtrl* pTabWnd, BOOL bRecalcLayout = TRUE);
	void CloseAllWindows(CMFCTabCtrl* pTabWnd);

	BOOL SaveState(LPCTSTR lpszProfileName, UINT nFrameID);
	BOOL LoadState(LPCTSTR lpszProfileName, UINT nFrameID);
	void Serialize(CArchive& ar);

	// Win7 taskbar interaction
	/// <summary>
	/// Goes over all tabs and windows and sets proper tab order</summary>
	void SetTaskbarTabOrder();

	/// <summary>
	/// Goes over all MDI children starting from the specified tab and returns first encountered MDI child registered with Windows 7 taskbar tabs.</summary>
	/// <return>
	/// Returns a valid pointer to CMDIChildWndEx if registered child is found, or NULL.</return>
	/// <param name="pTabCtrl">A pointer to a tabbed window (tab control) where to look for registered MDI child. </param>
	/// <param name="iStartFrom">Specifies the starting position for search within tab control.</param>
	CMDIChildWndEx* FindNextRegisteredWithTaskbarMDIChild(CMFCTabCtrl* pTabCtrl, int iStartFrom = 0);

	/// <summary>
	/// Finds a tabbed group containing the specified MDI child, then 
	/// goes over all MDI children starting from the found tab and returns first encountered MDI child registered with Windows 7 taskbar tabs.</summary>
	/// <return>
	/// Returns a valid pointer to CMDIChildWndEx if registered child is found, or NULL.</return>
	/// <param name="pOrgWnd">A valid pointer to an MDI child window, which specifies the starting window for search.</param>
	CMDIChildWndEx* FindNextRegisteredWithTaskbarMDIChild(CMDIChildWndEx* pOrgWnd);

	// ---- MDITabGroup-

// Overrides
protected:
	virtual void CalcWindowRect(LPRECT lpClientRect, UINT nAdjustType = adjustBorder);
	virtual void PreSubclassWindow();

// Implementation
public:
	virtual ~CMDIClientAreaWnd();

protected:
	//{{AFX_MSG(CMDIClientAreaWnd)
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnStyleChanging(int nStyleType, LPSTYLESTRUCT lpStyleStruct);
	afx_msg LRESULT OnSetMenu(WPARAM wp, LPARAM);
	afx_msg LRESULT OnUpdateTabs(WPARAM, LPARAM);
	afx_msg LRESULT OnMDIRefreshMenu(WPARAM wp, LPARAM);
	afx_msg LRESULT OnMDIDestroy(WPARAM wp, LPARAM);
	afx_msg LRESULT OnMDINext(WPARAM wp, LPARAM);
	afx_msg LRESULT OnGetDragBounds(WPARAM wp, LPARAM lp);
	afx_msg LRESULT OnDragComplete(WPARAM wp, LPARAM lp);
	afx_msg LRESULT OnTabGroupMouseMove(WPARAM wp, LPARAM lp);
	afx_msg LRESULT OnCancelTabMove(WPARAM wp, LPARAM lp);
	afx_msg LRESULT OnMoveTabComplete(WPARAM wp, LPARAM lp);
	afx_msg LRESULT OnActiveTabChanged(WPARAM wp, LPARAM lp);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	CMFCTabCtrl* GetNextTabWnd(CMFCTabCtrl* pOrgTabWnd, BOOL bWithoutAsserts = FALSE);
	void AdjustMDIChildren(CMFCTabCtrl* pTabWnd);
	void DrawNewGroupRect(LPCRECT rectNew, LPCRECT rectOld);
	CMFCTabCtrl* TabWndFromPoint(CPoint ptScreen);
	CMFCTabCtrl* CreateNewTabGroup(CMFCTabCtrl* pTabWndAfter, CRect rectGroup, BOOL bVertical);
	void ApplyParams(CMFCTabCtrl* pTabWnd);
	void SerializeTabGroup(CArchive& ar, CMFCTabCtrl* pTabWnd, BOOL bSetRelation = FALSE);
	void SerializeOpenChildren(CArchive& ar);

	BOOL IsKeepClientEdge();
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxmenubutton.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxbutton.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCMenuButton window

class CMFCMenuButton : public CMFCButton
{
	DECLARE_DYNAMIC(CMFCMenuButton)

// Construction
public:
	CMFCMenuButton();

// Attributes
public:
	BOOL  m_bRightArrow;
	HMENU m_hMenu;
	int   m_nMenuResult;
	BOOL  m_bStayPressed;
	BOOL  m_bOSMenu;       // User standard Windows menu either than library
	BOOL  m_bDefaultClick; // Allow default (on button text/image) processing

protected:
	BOOL  m_bMenuIsActive;
	BOOL  m_bClickOnMenu;

// Overrides
public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);

// Implementation
public:
	virtual ~CMFCMenuButton();
	virtual CSize SizeToContent(BOOL bCalcOnly = FALSE);

protected:
	virtual void OnDraw(CDC* pDC, const CRect& rect, UINT uiState);
	virtual void OnShowMenu();

protected:
	//{{AFX_MSG(CMFCMenuButton)
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg UINT OnGetDlgCode();
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg LRESULT OnInitControl(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxmenutearoffmanager.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMenuTearOffManager : public CObject
{

public:
	CMenuTearOffManager();
	virtual ~CMenuTearOffManager();

// Operations:
	BOOL Initialize(LPCTSTR lpszRegEntry, UINT uiTearOffMenuFirst, UINT uiTearOffMenuLast);
	void Reset(HMENU hmenu);

	void SetupTearOffMenus(HMENU hMenu);
	void SetInUse(UINT uiCmdId, BOOL bUse = TRUE);

	void Build(UINT uiTearOffBarID, CString& strText);
	UINT Parse(CString& str);

protected:
	UINT GetFreeTearOffID();

// Attributes:
public:
	LPCTSTR GetRegPath() const
	{
		return m_strTearOffBarRegEntry;
	}

	BOOL IsDynamicID(UINT uiID) const
	{
		return (uiID >= m_uiTearOffMenuFirst && uiID <= m_uiTearOffMenuLast);
	}

protected:
	UINT    m_uiTearOffMenuFirst;
	UINT    m_uiTearOffMenuLast;
	CString m_strTearOffBarRegEntry;

	CArray<int,int> m_arTearOffIDsUsage;
};

extern CMenuTearOffManager* g_pTearOffMenuManager;

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxmenuimages.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxtoolbarimages.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMenuImages  
{
public:
	enum IMAGES_IDS
	{
		IdArrowDown,
		IdArrowRight,
		IdCheck,
		IdMinimize,
		IdRestore,
		IdClose,
		IdMaximize,
		IdArrowUp,
		IdArrowShowAll,
		IdArrowLeft,
		IdCloseSmall,
		IdMoreButtons,
		IdRadio,
		IdArrowDownLarge,
		IdArrowRightLarge,
		IdPinHorz,
		IdPinVert,
		IdArrowLeftLarge,
		IdArrowFirst,
		IdArrowLast,
		IdArrowRightTab3d,
		IdArrowLeftTab3d,
		IdArrowRightDsbldTab3d,
		IdArrowLeftDsbldTab3d,
		IdArrowUpLarge,
		IdArrowPageLeft,
		IdArrowPageRight,
		IdArrowBack,
		IdArrowForward,
		IdCustomizeArrowDown,
		IdCustomizeArrowLeft,
		IdCustomizeMoreButtonsHorz,
		IdCustomizeMoreButtonsVert,
		IdCustomizeArrowDownBold,
		IdCloseBold,
		IdLaunchArrow,
	};

	enum IMAGE_STATE
	{
		ImageBlack,
		ImageGray,
		ImageLtGray,
		ImageWhite,
		ImageDkGray,
		ImageBlack2,
	};

	static void __stdcall Draw(CDC* pDC, CMenuImages::IMAGES_IDS id, const CPoint& ptImage, CMenuImages::IMAGE_STATE state = CMenuImages::ImageBlack, const CSize& sizeImage = CSize(0, 0));
	static void __stdcall Draw(CDC* pDC, CMenuImages::IMAGES_IDS id, const CRect& rectImage, CMenuImages::IMAGE_STATE state = CMenuImages::ImageBlack, const CSize& sizeImage = CSize(0, 0));
	static CSize __stdcall Size();
	static void __stdcall SetColor(CMenuImages::IMAGE_STATE state, COLORREF color);	// color == -1: default
	static void __stdcall CleanUp();

protected:
	static BOOL __stdcall Initialize();
	static void __stdcall CreateCopy(CMFCToolBarImages& images, COLORREF clr);

	AFX_IMPORT_DATA static CMFCToolBarImages m_ImagesBlack;
	AFX_IMPORT_DATA static CMFCToolBarImages m_ImagesDkGray;
	AFX_IMPORT_DATA static CMFCToolBarImages m_ImagesGray;
	AFX_IMPORT_DATA static CMFCToolBarImages m_ImagesLtGray;
	AFX_IMPORT_DATA static CMFCToolBarImages m_ImagesWhite;
	AFX_IMPORT_DATA static CMFCToolBarImages m_ImagesBlack2;

	static BOOL m_bInitializing;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxmousemanager.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMouseManager : public CObject
{
	DECLARE_SERIAL(CMouseManager)

public:
	CMouseManager();
	virtual ~CMouseManager();

// Operations:
public:
	BOOL AddView(int iViewId, UINT uiViewNameResId, UINT uiIconId = 0);
	BOOL AddView(int iId, LPCTSTR lpszViewName, UINT uiIconId = 0);
	UINT GetViewDblClickCommand(int iId) const;

	BOOL LoadState(LPCTSTR lpszProfileName = NULL);
	BOOL SaveState(LPCTSTR lpszProfileName = NULL);

// Customization operations:
	void GetViewNames(CStringList& listOfNames) const;
	int GetViewIdByName(LPCTSTR lpszName) const;
	UINT GetViewIconId(int iViewId) const;

	void SetCommandForDblClk(int iViewId, UINT uiCmd);

// Overrides:
protected:
	virtual void Serialize(CArchive& ar);

// Attributes:
protected:
	CMap<CString, LPCTSTR, int, int> m_ViewsNames;
	CMap<int, int, UINT, UINT>       m_ViewsToCommands;
	CMap<int, int, UINT, UINT>       m_ViewsToIcons;
};

extern CMouseManager* afxMouseManager;

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxmousepropertypage.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxribbonres.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCMousePropertyPage dialog

class CMFCMousePropertyPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CMFCMousePropertyPage)

// Construction
public:
	CMFCMousePropertyPage();
	~CMFCMousePropertyPage();

// Operations:
protected:
	void EnableDblClkControls(BOOL bEnable = TRUE);
	BOOL SelectCommand(UINT uiCmd);

// Attributes:
protected:
	int        m_iCurrViewId;
	CImageList m_ViewsImages;

// Dialog Data
	//{{AFX_DATA(CMFCMousePropertyPage)
	enum { IDD = IDD_AFXBARRES_PROPPAGE4 };
	CListCtrl m_wndListOfViews;
	CListBox  m_wndListOfCommands;
	CStatic   m_wndCommandDescription;
	CString   m_strCommandDescription;
	//}}AFX_DATA

// Overrides
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Implementation
protected:
	//{{AFX_MSG(CMFCMousePropertyPage)
	afx_msg void OnNoDblcliick();
	afx_msg void OnUseDblcliick();
	afx_msg void OnSelchangeListOfCommands();
	afx_msg void OnItemchangedListViews(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	virtual BOOL OnInitDialog();
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxmdiframewndex.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxframeimpl.h"
#include "afxmdiclientareawnd.h"
#include "afxpopupmenu.h"
#include "afxdockingmanager.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class COleClientItem;
class CMFCPopupMenu;
class CMFCToolBar;
class CMFCToolBarMenuButton;
class CMFCToolBarButton;

static const DWORD AFX_MDI_CREATE_VERT_GROUP = 0x001;
static const DWORD AFX_MDI_CREATE_HORZ_GROUP = 0x002;
static const DWORD AFX_MDI_CAN_MOVE_PREV     = 0x004;
static const DWORD AFX_MDI_CAN_MOVE_NEXT     = 0x008;
static const DWORD AFX_MDI_CAN_BE_DOCKED     = 0x010;

/////////////////////////////////////////////////////////////////////////////
// CMDIFrameWndEx frame

class CMDIFrameWndEx : public CMDIFrameWnd
{
	friend class CMDIClientAreaWnd;
	friend class CMFCToolBar;
	friend class CMFCMenuBar;
	friend class CWinAppEx;
	friend class CMFCPopupMenu;
	friend class CMFCToolBarsCustomizeDialog;
	friend class CPaneFrameWnd;
	friend class CMDIChildWndEx;
	friend class CGlobalUtils;
	friend class CMFCTabCtrl;
	friend class CMFCRibbonButton;

	DECLARE_DYNCREATE(CMDIFrameWndEx)

protected:
	CMDIFrameWndEx(); // protected constructor used by dynamic creation

// Attributes
public:
	BOOL IsMenuBarAvailable() const { return m_Impl.GetMenuBar() != NULL; }
	const CMFCMenuBar* GetMenuBar() const { return m_Impl.GetMenuBar(); }

	UINT GetDefaultResId() const { return m_Impl.m_nIDDefaultResource; }
	CMFCPopupMenu*	GetActivePopup() const { return CMFCPopupMenu::m_pActivePopupMenu; }
	const CObList& GetTearOffBars() const { return m_Impl.m_listTearOffToolbars; }

	void SetPrintPreviewFrame(CFrameWnd* pWnd)
	{
		if (pWnd != NULL)
		{
			ASSERT_VALID(pWnd);
		}
		m_pPrintPreviewFrame = pWnd;
	}

	BOOL IsPrintPreview() { return m_Impl.IsPrintPreview(); }
	CMFCRibbonBar* GetRibbonBar() { return m_Impl.GetRibbonBar(); }
	void ActiveItemRecalcLayout();

	AFX_IMPORT_DATA static BOOL m_bDisableSetRedraw;

protected:
	CString m_strWindowsDlgMenuText;
	HMENU   m_hmenuWindow;

	UINT m_uiWindowsDlgMenuId;
	BOOL m_bIsTlbCustMode;
	BOOL m_bContextHelp;
	BOOL m_bDoSubclass;
	BOOL m_bShowWindowsDlgAlways;
	BOOL m_bShowWindowsDlgHelpButton;
	BOOL m_bCanConvertControlBarToMDIChild;
	BOOL m_bWasMaximized;
	BOOL m_bIsMinimized;
	BOOL m_bClosing;
	int  m_nFrameID; // need for uniqueness when saving state in MTI 

	// workaround for Pront Preview bug in VS 7.1
	CFrameWnd*         m_pPrintPreviewFrame;
	CDockingManager       m_dockManager; // THE DockManager
	CFrameImpl      m_Impl;
	CMDIClientAreaWnd m_wndClientArea;

// Operations
public:
	//------------------ dockmanager layer ------------
	void AddDockSite();
	BOOL AddPane(CBasePane* pControlBar, BOOL bTail = TRUE);
	BOOL InsertPane(CBasePane* pControlBar, CBasePane* pTarget, BOOL bAfter = TRUE);
	void RemovePaneFromDockManager(CBasePane* pControlBar, BOOL bDestroy, BOOL bAdjustLayout, BOOL bAutoHide, CBasePane* pBarReplacement);
	void DockPane(CBasePane* pBar, UINT nDockBarID = 0, LPCRECT lpRect = NULL);
	CBasePane* PaneFromPoint(CPoint point, int nSensitivity, bool bExactBar, CRuntimeClass* pRTCBarType) const;
	CBasePane* PaneFromPoint(CPoint point, int nSensitivity, DWORD& dwAlignment, CRuntimeClass* pRTCBarType) const;
	BOOL IsPointNearDockSite(CPoint point, DWORD& dwBarAlignment, BOOL& bOuterEdge) const;
	virtual void AdjustDockingLayout(HDWP hdwp = NULL);
	BOOL EnableDocking(DWORD dwDockStyle);
	BOOL EnableAutoHidePanes(DWORD dwDockStyle);

	CBasePane* GetPane(UINT nID);
	void ShowPane(CBasePane* pBar, BOOL bShow, BOOL bDelay, BOOL bActivate);

	virtual BOOL OnMoveMiniFrame(CWnd* pFrame);
	virtual void RecalcLayout(BOOL bNotify = TRUE);
	
	//-------------------- MDI Tab Groups interface ---
	DWORD GetMDITabsContextMenuAllowedItems() { return m_wndClientArea.GetMDITabsContextMenuAllowedItems(); }
	BOOL IsMemberOfMDITabGroup(CWnd* pWnd) { return m_wndClientArea.IsMemberOfMDITabGroup(pWnd); }

	void MDITabMoveToNextGroup(BOOL bNext = TRUE) { m_wndClientArea.MDITabMoveToNextGroup(bNext); }
	void MDITabNewGroup(BOOL bVert = TRUE) { m_wndClientArea.MDITabNewGroup(bVert); }
	const CObList& GetMDITabGroups() const { return m_wndClientArea.GetMDITabGroups(); }
	
	virtual BOOL OnShowMDITabContextMenu(CPoint point, DWORD dwAllowedItems, BOOL bTabDrop);
	//-------------------------------------------------

	BOOL DockPaneLeftOf(CPane* pBar, CPane* pLeftOf);

	void SetupToolbarMenu(CMenu& menu, const UINT uiViewUserToolbarCmdFirst, const UINT uiViewUserToolbarCmdLast)
	{
		m_Impl.SetupToolbarMenu(menu, uiViewUserToolbarCmdFirst, uiViewUserToolbarCmdLast);
	}

	// Enable built-in CMFCWindowsManagerDialog dialog. When bShowAlways is TRUE, show windows dialog everytime;
	// otherwise only instead of the standard "Windows..." dialog (appears if more than 9 windows are open).
	void EnableWindowsDialog(UINT uiMenuId, LPCTSTR lpszMenuText, BOOL bShowAlways = FALSE, BOOL bShowHelpButton = FALSE);
	void EnableWindowsDialog(UINT uiMenuId, UINT uiMenuTextResId, BOOL bShowAlways = FALSE, BOOL bShowHelpButton = FALSE);
	void ShowWindowsDialog();
	
	// Enable/Disable MDI child tabs:
	void EnableMDITabs(BOOL bEnable = TRUE, BOOL bIcons = TRUE, CMFCTabCtrl::Location tabLocation = CMFCTabCtrl::LOCATION_BOTTOM, BOOL bTabCloseButton = FALSE,
		CMFCTabCtrl::Style style = CMFCTabCtrl::STYLE_3D_SCROLLED, BOOL bTabCustomTooltips = FALSE, BOOL bActiveTabCloseButton = FALSE);
	void EnableMDITabbedGroups(BOOL bEnable, const CMDITabInfo& params);

	BOOL AreMDITabs(int* pnMDITabsType = NULL) const
	{
		if (pnMDITabsType != NULL)
		{
			*pnMDITabsType = 0;
			if (m_wndClientArea.m_bTabIsEnabled)
			{
				*pnMDITabsType = 1;
			}
			else if (m_wndClientArea.IsMDITabbedGroup())
			{
				*pnMDITabsType = 2;
			}
		}
		return m_wndClientArea.m_bTabIsEnabled || m_wndClientArea.IsMDITabbedGroup();
	}

	BOOL IsMDITabbedGroup() const { return m_wndClientArea.IsMDITabbedGroup(); }
	CMFCTabCtrl& GetMDITabs() { return m_wndClientArea.GetMDITabs(); }

	BOOL IsFullScreen() const { return m_Impl.m_FullScreenMgr.IsFullScreen(); }
	void ShowFullScreen() { m_Impl.m_FullScreenMgr.ShowFullScreen(); }
	void EnableFullScreenMainMenu(BOOL bEnableMenu) { m_Impl.m_FullScreenMgr.EnableMainMenu(bEnableMenu); }
	void EnableFullScreenMode(UINT uiFullScreenCmd) { m_Impl.m_FullScreenMgr.SetFullScreenID(uiFullScreenCmd); }

	void EnableLoadDockState(BOOL bEnable = TRUE) { m_Impl.m_bLoadDockState = bEnable; }

	void EnableMDITabsLastActiveActivation(BOOL bLastActiveTab = TRUE)
	{
		if (AreMDITabs() || IsMDITabbedGroup())
		{
			m_wndClientArea.m_wndTab.EnableActivateLastActive(bLastActiveTab);
		}
	}

	void EnablePaneMenu(BOOL bEnable, UINT uiCustomizeCmd, const CString& strCustomizeLabel, UINT uiViewToolbarsMenuEntryID,
		BOOL bContextMenuShowsToolbarsOnly = FALSE, BOOL bViewMenuShowsToolbarsOnly = FALSE)
	{
		m_dockManager.EnablePaneContextMenu(bEnable, uiCustomizeCmd, strCustomizeLabel, bContextMenuShowsToolbarsOnly);
		m_Impl.SetControlbarsMenuId(uiViewToolbarsMenuEntryID, bViewMenuShowsToolbarsOnly);
	}

	void UpdateCaption() { m_Impl.UpdateCaption(); }

	virtual CMDIChildWndEx* ControlBarToTabbedDocument(CDockablePane* pBar);
	virtual BOOL TabbedDocumentToControlBar(CMDIChildWndEx* pMDIChildWnd);

	void RegisterAllMDIChildrenWithTaskbar(BOOL bRegister = TRUE);
	void UpdateMDITabbedBarsIcons();
	int GetRegisteredWithTaskBarMDIChildCount();

	virtual BOOL CanConvertControlBarToMDIChild() { return m_bCanConvertControlBarToMDIChild; }

protected:
	virtual BOOL OnSetMenu(HMENU hmenu);

// Implementation:
	void InitUserToolbars(LPCTSTR lpszRegEntry, UINT uiUserToolbarFirst, UINT uiUserToolbarLast)
	{
		m_Impl.InitUserToolbars(lpszRegEntry, uiUserToolbarFirst, uiUserToolbarLast);
	}

	void LoadUserToolbars() { m_Impl.LoadUserToolbars(); }
	void SaveUserToolbars() { m_Impl.SaveUserToolbars(); }
	void LoadTearOffMenus() { m_Impl.LoadTearOffMenus(); }
	void SaveTearOffMenus() { m_Impl.SaveTearOffMenus(); }

	BOOL IsDockStateValid(const CDockState& state) { return m_Impl.IsDockStateValid(state); }
	CMFCToolBar* GetUserToolBarByIndex(int iIndex) const { return m_Impl.GetUserToolBarByIndex(iIndex); }
	void SetDockState(const CDockState& state) { m_Impl.SetDockState(state); }
	CDockingManager* GetDockingManager() { return &m_dockManager; }

// Overrides
public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual BOOL LoadFrame(UINT nIDResource, DWORD dwDefaultStyle = WS_OVERLAPPEDWINDOW | FWS_ADDTOTITLE, CWnd* pParentWnd = NULL, CCreateContext* pContext = NULL);
	virtual void WinHelp(DWORD dwData, UINT nCmd = HELP_CONTEXT);
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);

protected:
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

	virtual HMENU GetWindowMenuPopup(HMENU hMenuBar);
	virtual void HtmlHelp(DWORD_PTR dwData, UINT nCmd = 0x000F);

	BOOL ShowPopupMenu(CMFCPopupMenu* pMenuPopup);

public:
	virtual BOOL OnShowPopupMenu(CMFCPopupMenu* /*pMenuPopup*/);

	virtual BOOL OnShowCustomizePane(CMFCPopupMenu* pMenuPane, UINT uiToolbarID)
	{
		m_Impl.AddDefaultButtonsToCustomizePane(pMenuPane, uiToolbarID);
		return TRUE;
	}

	virtual void OnClosePopupMenu(CMFCPopupMenu* pMenuPopup);
	virtual BOOL OnDrawMenuImage(CDC* pDC, const CMFCToolBarMenuButton* pMenuButton, const CRect& rectImage);

	virtual BOOL OnMenuButtonToolHitTest(CMFCToolBarButton* /*pButton*/, TOOLINFO* /*pTI*/) { return FALSE; }
	virtual BOOL GetToolbarButtonToolTipText(CMFCToolBarButton* /*pButton*/, CString& /*strTTText*/) { return FALSE; }
	virtual BOOL OnEraseMDIClientBackground(CDC* /*pDC*/) { return FALSE; }

	virtual void OnSizeMDIClient(const CRect& /*rectOld*/, const CRect& /*rectNew*/) {}
	virtual void OnDrawMenuLogo(CDC* /*pDC*/, CMFCPopupMenu* /*pMenu*/, const CRect& /*rectLogo*/) {}
	virtual void OnUpdateFrameMenu(HMENU hMenuAlt);

	virtual BOOL OnTearOffMenu(CMFCPopupMenu* /*pMenuPopup*/, CPane* /*pBar*/) { return TRUE; }

	virtual void OnSetPreviewMode(BOOL bPreview, CPrintPreviewState* pState);
	virtual BOOL OnShowPanes(BOOL bShow);
	virtual BOOL NegotiateBorderSpace( UINT nBorderCmd, LPRECT lpRectBorder );

	virtual void AdjustClientArea();
	virtual BOOL OnCloseMiniFrame(CPaneFrameWnd* /*pWnd*/) { return TRUE; }
	virtual BOOL OnCloseDockingPane(CDockablePane* /*pWnd*/) { return TRUE; }

	virtual BOOL LoadMDIState(LPCTSTR lpszProfileName);
	virtual BOOL SaveMDIState(LPCTSTR lpszProfileName);

	virtual CMDIChildWndEx* CreateDocumentWindow(LPCTSTR lpcszDocName, CObject* pObj);
	virtual CMDIChildWndEx* CreateNewWindow(LPCTSTR lpcszDocName, CObject* pObj);

// Implementation
protected:
	virtual ~CMDIFrameWndEx();
	virtual COleClientItem* GetInPlaceActiveItem();

	//{{AFX_MSG(CMDIFrameWndEx)
	afx_msg LRESULT OnMenuChar(UINT nChar, UINT nFlags, CMenu* pMenu);
	afx_msg void OnWindowPosChanged(WINDOWPOS FAR* lpwndpos);
	afx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);
	afx_msg void OnClose();
	afx_msg void OnDestroy();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnNcPaint();
	afx_msg BOOL OnNcActivate(BOOL bActive);
	afx_msg void OnNcMouseMove(UINT nHitTest, CPoint point);
	afx_msg LRESULT OnNcHitTest(CPoint point);
	afx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnActivateApp(BOOL bActive, DWORD dwThreadID);
	afx_msg LRESULT OnToolbarCreateNew(WPARAM,LPARAM);
	afx_msg LRESULT OnToolbarDelete(WPARAM,LPARAM);
	afx_msg void OnContextHelp();
	afx_msg void OnUpdatePaneMenu(CCmdUI* pCmdUI);
	afx_msg BOOL OnPaneCheck(UINT nID);
	afx_msg LRESULT OnIdleUpdateCmdUI(WPARAM wParam, LPARAM);
	afx_msg LRESULT OnExitSizeMove(WPARAM, LPARAM);
	afx_msg void OnWindowNew();
	afx_msg LRESULT OnToolbarContextMenu(WPARAM,LPARAM);
	afx_msg LRESULT OnSetText(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnChangeVisualManager(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnPostPreviewFrame(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnDWMCompositionChanged(WPARAM,LPARAM);
	afx_msg LRESULT OnPowerBroadcast(WPARAM wp, LPARAM lp);
	afx_msg void OnSysColorChange();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxmenuhash.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCToolBar;

class CMenuHash
{
public:
	CMenuHash();
	virtual ~CMenuHash();

	BOOL SaveMenuBar(HMENU hMenu, CMFCToolBar* pBar);
	BOOL LoadMenuBar(HMENU hMenu, CMFCToolBar* pBar);

	BOOL RemoveMenu(HMENU hMenu);
	void CleanUp();

	BOOL IsActive() const
	{
		return m_bIsActive;
	}

protected:
	CMap<HMENU, HMENU&, HANDLE, HANDLE&> m_StoredMenues;

	BOOL m_bIsActive;
};

extern CMenuHash afxMenuHash;

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxmenubar.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxtoolbar.h"
#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCToolBarMenuButton;
class CMFCToolBarSystemMenuButton;
class CMFCToolBarMenuButtonsButton;
class CMFCToolBarComboBoxButton;
class CMFCToolBarsMenuPropertyPage;

#define AFX_IDW_MENUBAR               0xE806  // CMFCMenuBar

/////////////////////////////////////////////////////////////////////////////
// CMFCMenuBar window

class CMFCMenuBar : public CMFCToolBar
{
	friend class CMFCToolBarsOptionsPropertyPage;
	friend class CMFCToolBar;
	friend class CMFCPopupMenuBar;
	friend class CMFCToolBarsMenuPropertyPage;

	DECLARE_SERIAL(CMFCMenuBar)

// Construction
public:
	CMFCMenuBar();

// Attributes
public:
	static BOOL __stdcall IsShowAllCommands() { return m_bShowAllCommands || !m_bRecentlyUsedMenus || !m_UsageCount.HasEnoughInformation(); }
	static BOOL __stdcall IsRecentlyUsedMenus() { return m_bRecentlyUsedMenus; }
	static BOOL __stdcall IsShowAllCommandsDelay() { return m_bShowAllMenusDelay; }

	static void __stdcall SetShowAllCommands(BOOL bShowAllCommands = TRUE);
	static void __stdcall SetRecentlyUsedMenus(BOOL bOn = TRUE);

	static BOOL __stdcall SetMenuFont(LPLOGFONT lpLogFont, BOOL bHorz = TRUE);
	static const CFont& __stdcall GetMenuFont(BOOL bHorz = TRUE);

	static void __stdcall EnableMenuShadows(BOOL bEnable = TRUE) { m_bMenuShadows = bEnable; }
	static BOOL __stdcall IsMenuShadows() { return m_bMenuShadows; }
	static void __stdcall HighlightDisabledItems(BOOL bHighlight = TRUE) { m_bHighlightDisabledItems = bHighlight; }
	static BOOL __stdcall IsHighlightDisabledItems() { return m_bHighlightDisabledItems ; }

	BOOL m_bAutoDocMenus;     // Automatically load/save  document menus
	BOOL m_bClearHashOnClose; // Clear temporary files on close

	BOOL GetForceDownArrows() { return m_bForceDownArrows; }
	void SetForceDownArrows(BOOL bValue) { m_bForceDownArrows = bValue; }

	// Support for MS Office-like help combobox:
	void EnableHelpCombobox(UINT uiID /* 0 - disable */, LPCTSTR lpszPrompt = NULL, int nComboBoxWidth = 150);
	CMFCToolBarComboBoxButton* GetHelpCombobox();

	void SetMenuButtonRTC(CRuntimeClass* pMenuButtonRTC);

protected:
	CWnd* m_pParentWnd;
	HMENU m_hMenu;
	HMENU m_hDefaultMenu;
	HMENU m_hSysMenu;
	HICON m_hSysIcon;
	UINT  m_uiDefMenuResId;
	UINT  m_nHelpComboID;
	int   m_nSystemButtonsNum;
	int   m_nSystemButtonsNumSaved;
	int   m_nHelpComboWidth;
	BOOL  m_bMaximizeMode;
	BOOL  m_bHaveButtons;
	BOOL  m_bForceDownArrows;

	CSize   m_szSystemButton;	// System button size
	CString m_strHelpComboPrompt;

	CMFCToolBarsMenuPropertyPage*     m_pMenuPage;
	CRuntimeClass* m_pMenuButtonRTC;

	AFX_IMPORT_DATA static BOOL m_bShowAllCommands;
	AFX_IMPORT_DATA static BOOL m_bRecentlyUsedMenus;
	AFX_IMPORT_DATA static BOOL m_bShowAllMenusDelay;
	AFX_IMPORT_DATA static BOOL m_bMenuShadows;
	AFX_IMPORT_DATA static BOOL m_bHighlightDisabledItems;

// Operations
public:
	virtual void CreateFromMenu(HMENU hMenu, BOOL bDefaultMenu = FALSE, BOOL bForceUpdate = FALSE);
	void SetMaximizeMode(BOOL bMax, CWnd* pWnd = NULL, BOOL bRecalcLayout = TRUE);

	void SetDefaultMenuResId(UINT uiResId);
	UINT GetDefaultMenuResId() const { return m_uiDefMenuResId; }
	HMENU GetHMenu() const { return m_hMenu; }
	HMENU GetDefaultMenu() const { return m_hDefaultMenu; }

	CMFCToolBarButton* GetMenuItem(int iItem) const;
	CMFCToolBarSystemMenuButton* GetSystemMenu() const;
	CMFCToolBarMenuButtonsButton* GetSystemButton(UINT uiBtn, BOOL bByCommand = TRUE) const;
	int GetSystemButtonsCount() const { return m_nSystemButtonsNum; }

	int GetFloatPopupDirection(CMFCToolBarMenuButton* pButton);

protected:
	void RestoreMaximizeMode(BOOL bRecalcLayout = TRUE);

	static BOOL __stdcall FindMenuItemText(HMENU hMenu, const UINT nID, CString& strText);

	void CalcSysButtonSize();
	virtual BOOL BuildOrigItems(UINT uiMenuResID); // Required for the SmartResourceUpdate

// Overrides
public:
	virtual BOOL Create(CWnd* pParentWnd, DWORD dwStyle = AFX_DEFAULT_TOOLBAR_STYLE, UINT nID = AFX_IDW_MENUBAR);
	virtual BOOL CreateEx(CWnd* pParentWnd, DWORD dwCtrlStyle = TBSTYLE_FLAT, DWORD dwStyle = AFX_DEFAULT_TOOLBAR_STYLE,
		CRect rcBorders = CRect(1, 1, 1, 1), UINT nID = AFX_IDW_MENUBAR);

	virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);
	virtual CSize CalcLayout(DWORD dwMode, int nLength = -1);

	virtual int CalcMaxButtonHeight();

	virtual void AdjustLocations();
	virtual BOOL OnSendCommand(const CMFCToolBarButton* pButton);

	virtual INT_PTR OnToolHitTest(CPoint point, TOOLINFO* pTI) const;

	virtual BOOL LoadState(LPCTSTR lpszProfileName = NULL, int nIndex = -1, UINT uiID = (UINT) -1);
	virtual BOOL SaveState(LPCTSTR lpszProfileName = NULL, int nIndex = -1, UINT uiID = (UINT) -1);

	virtual BOOL CanBeRestored() const { return TRUE; }
	virtual BOOL CanBeClosed() const { return FALSE; }
	virtual BOOL AllowChangeTextLabels() const { return FALSE; }
	virtual BOOL IsButtonExtraSizeAvailable() const { return FALSE; }
	virtual BOOL AllowShowOnPaneMenu() const { return FALSE; }

	virtual void OnDefaultMenuLoaded(HMENU) {};
	virtual BOOL RestoreOriginalstate();
	virtual BOOL PreTranslateMessage(MSG* pMsg);

	virtual int GetRowHeight() const
	{
		return max(afxGlobalData.GetTextHeight(GetCurrentAlignment() & CBRS_ORIENT_HORZ),
			m_bHaveButtons ? GetButtonSize().cy : m_sizeMenuButton.cy <= 0 ? m_sizeButton.cy - 2 : m_sizeMenuButton.cy - 2);
	}

	virtual int GetColumnWidth() const
	{
		return m_bHaveButtons ? GetButtonSize().cx : m_sizeMenuButton.cx <= 0 ? m_sizeButton.cx - 2 : m_sizeMenuButton.cx - 2;
	}

	virtual BOOL OnSetDefaultButtonText(CMFCToolBarButton* pButton);
	virtual void OnChangeHot(int iHot);
	
	virtual int GetAvailableExpandSize() const { return m_bExclusiveRow ? 0xFFFF /*unlimited size*/ : CMFCToolBar::GetAvailableExpandSize(); }

protected:
	virtual int FindDropIndex(const CPoint point, CRect& rectDrag) const;
	virtual void ResetImages();

	virtual BOOL IsPureMenuButton(CMFCToolBarButton* pButton) const;
	static void __stdcall UpdateMDIChildrenMenus(CMultiDocTemplate* pTemplate);

	// Implementation
public:
	virtual ~CMFCMenuBar();

	// Generated message map functions
protected:
	//{{AFX_MSG(CMFCMenuBar)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnTimer(UINT_PTR nIDEvent);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxmsg_.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Do not include this file directly (included by AFXWIN.H)

#pragma once

/////////////////////////////////////////////////////////////////////////////

// Entries in a message map (a 'AFX_MSGMAP_ENTRY') table can be of 9 formats
//
// 1) control notification message (i.e. in response to WM_COMMAND)
//      WM_COMMAND, nNotifyCode, nControlID, nControlID, signature type, parameterless member function
//      (eg: WM_COMMAND, LBN_SELCHANGE, IDC_LISTBOX, AfxSig_vv, ... )
// 2) control notification message range (i.e. in response to WM_COMMAND)
//      WM_COMMAND, nNotifyCode, nControlIDFirst, nControlIDLast, signature type, parameterless member function
//      (eg: WM_COMMAND, LBN_SELCHANGE, IDC_LISTBOX1, IDC_LISTBOX5, AfxSig_vw, ... )
// 3) WM_NOTIFY notification
//      WM_NOTIFY, nNotifyCode, nControlID, nControlID, signature type, ...)
// 3) Update Command UI
//      -1, 0, nControlID, 0, signature Unknown, parameterless member function
// 4) Update Command UI Range
//      -1, 0, nControlIDFirst, nControlIDLast, signature Unknown, parameterless member function
// 5) menu/accelerator notification message (i.e. special case of first format)
//      WM_COMMAND, 0, nID, 0, signature type, parameterless member function
//      (eg: WM_COMMAND, 0, IDM_FILESAVE, 0, AfxSig_vv, ... )
// 6) menu/accelerator notification message range
//      WM_COMMAND, 0, nIDFirst, nIDLast, signature type, parameterless member function
//      (eg: WM_COMMAND, 0, IDM_FILE_MRU1, IDM_FILE_MRU4, AfxSig_vw, ... )
// 7) constant windows message
//      nMessage, 0, 0, 0, signature type, member function
//      (eg: WM_PAINT, 0, ...)
// 8) variable windows message (using RegisterWindowMessage)
//      0xC000, 0, 0, 0, &nMessage, special member function
//
// The end of the message map is marked with a special value
//      0, 0, AfxSig_end, 0
/////////////////////////////////////////////////////////////////////////////

// Naming scheme:
// <signature> -> AfxSig_<ReturnType>_<WPARAMType>_<LPARAMType>
// <ReturnType> -> b (BOOL)
//                 h (HANDLE)
//                 v (void)
//                 i (int)
//                 l (LRESULT)
// <WPARAMType> ->                  
// Naming scheme:
// b - BOOL
// D - CDC*
// W - CWnd*
// w - UINT
// h - handle
// i - int
// s - LPTSTR
// v - void
// l - LPARAM
// M - CMenu*
// p - CPoint
// POS - WINDOWPOS*
// CALC - NCCALCSIZE_PARAMS*
// NMHDR - NMHDR*
// HELPINFO - HELPINFO*
// SIZING - LPRECT
// cmdui - CCmdUI*
// CDS - COPYDATASTRUCT*
// s - short
// by - byte

enum AfxSig
{
	AfxSig_end = 0,     // [marks end of message map]

	AfxSig_b_D_v,				// BOOL (CDC*)
	AfxSig_b_b_v,				// BOOL (BOOL)
	AfxSig_b_u_v,				// BOOL (UINT)
	AfxSig_b_h_v,				// BOOL (HANDLE)
	AfxSig_b_W_uu,				// BOOL (CWnd*, UINT, UINT)
	AfxSig_b_W_COPYDATASTRUCT,				// BOOL (CWnd*, COPYDATASTRUCT*)
	AfxSig_b_v_HELPINFO,		// BOOL (LPHELPINFO);
	AfxSig_CTLCOLOR,			// HBRUSH (CDC*, CWnd*, UINT)
	AfxSig_CTLCOLOR_REFLECT,	// HBRUSH (CDC*, UINT)
	AfxSig_i_u_W_u,				// int (UINT, CWnd*, UINT)  // ?TOITEM
	AfxSig_i_uu_v,				// int (UINT, UINT)
	AfxSig_i_W_uu,				// int (CWnd*, UINT, UINT)
	AfxSig_i_v_s,				// int (LPTSTR)
	AfxSig_l_w_l,				// LRESULT (WPARAM, LPARAM)
	AfxSig_l_uu_M,				// LRESULT (UINT, UINT, CMenu*)
	AfxSig_v_b_h,				// void (BOOL, HANDLE)
	AfxSig_v_h_v,				// void (HANDLE)
	AfxSig_v_h_h,				// void (HANDLE, HANDLE)
	AfxSig_v_v_v,				// void ()
	AfxSig_v_u_v,				// void (UINT)
	AfxSig_v_u_u,				// void (UINT, UINT)
	AfxSig_v_uu_v,				// void (UINT, UINT)
	AfxSig_v_v_ii,				// void (int, int)
	AfxSig_v_u_uu,				// void (UINT, UINT, UINT)
	AfxSig_v_u_ii,				// void (UINT, int, int)
	AfxSig_v_u_W,				// void (UINT, CWnd*)
	AfxSig_i_u_v,				// int (UINT)
	AfxSig_u_u_v,				// UINT (UINT)
	AfxSig_b_v_v,				// BOOL ()
	AfxSig_v_w_l,				// void (WPARAM, LPARAM)
	AfxSig_MDIACTIVATE,			// void (BOOL, CWnd*, CWnd*)
	AfxSig_v_D_v,				// void (CDC*)
	AfxSig_v_M_v,				// void (CMenu*)
	AfxSig_v_M_ub,				// void (CMenu*, UINT, BOOL)
	AfxSig_v_W_v,				// void (CWnd*)
	AfxSig_v_v_W,				// void (CWnd*)
	AfxSig_v_W_uu,				// void (CWnd*, UINT, UINT)
	AfxSig_v_W_p,				// void (CWnd*, CPoint)
	AfxSig_v_W_h,				// void (CWnd*, HANDLE)
	AfxSig_C_v_v,				// HCURSOR ()
	AfxSig_ACTIVATE,			// void (UINT, CWnd*, BOOL)
	AfxSig_SCROLL,				// void (UINT, UINT, CWnd*)
	AfxSig_SCROLL_REFLECT,		// void (UINT, UINT)
	AfxSig_v_v_s,				// void (LPTSTR)
	AfxSig_v_u_cs,				// void (UINT, LPCTSTR)
	AfxSig_OWNERDRAW,			// void (int, LPTSTR) force return TRUE
	AfxSig_i_i_s,				// int (int, LPTSTR)
	AfxSig_u_v_p,				// UINT (CPoint)
	AfxSig_u_v_v,				// UINT ()
	AfxSig_v_b_NCCALCSIZEPARAMS,		// void (BOOL, NCCALCSIZE_PARAMS*)
	AfxSig_v_v_WINDOWPOS,			// void (WINDOWPOS*)
	AfxSig_v_uu_M,				// void (UINT, UINT, HMENU)
	AfxSig_v_u_p,				// void (UINT, CPoint)
	AfxSig_SIZING,				// void (UINT, LPRECT)
	AfxSig_MOUSEWHEEL,			// BOOL (UINT, short, CPoint)
	AfxSig_MOUSEHWHEEL,			// void (UINT, short, CPoint)
	AfxSigCmd_v,				// void ()
	AfxSigCmd_b,				// BOOL ()
	AfxSigCmd_RANGE,			// void (UINT)
	AfxSigCmd_EX,				// BOOL (UINT)
	AfxSigNotify_v,				// void (NMHDR*, LRESULT*)
	AfxSigNotify_b,				// BOOL (NMHDR*, LRESULT*)
	AfxSigNotify_RANGE,			// void (UINT, NMHDR*, LRESULT*)
	AfxSigNotify_EX,			// BOOL (UINT, NMHDR*, LRESULT*)
	AfxSigCmdUI,				// void (CCmdUI*)
	AfxSigCmdUI_RANGE,			// void (CCmdUI*, UINT)
	AfxSigCmd_v_pv,				// void (void*)
	AfxSigCmd_b_pv,				// BOOL (void*)
	AfxSig_l,				// LRESULT ()
	AfxSig_l_p,				// LRESULT (CPOINT)	
	AfxSig_u_W_u,				// UINT (CWnd*, UINT)
	AfxSig_v_u_M,				// void (UINT, CMenu* )
	AfxSig_u_u_M,				// UINT (UINT, CMenu* )
	AfxSig_u_v_MENUGETOBJECTINFO,		// UINT (MENUGETOBJECTINFO*)
	AfxSig_v_M_u,				// void (CMenu*, UINT)
	AfxSig_v_u_LPMDINEXTMENU,		// void (UINT, LPMDINEXTMENU)
	AfxSig_APPCOMMAND,			// void (CWnd*, UINT, UINT, UINT)
	AfxSig_RAWINPUT,			// void (UINT, HRAWINPUT)
	AfxSig_u_u_u,				// UINT (UINT, UINT)
	AfxSig_MOUSE_XBUTTON,			// void (UINT, UINT, CPoint)
	AfxSig_MOUSE_NCXBUTTON,			// void (short, UINT, CPoint)
	AfxSig_INPUTLANGCHANGE,			// void (UINT, UINT)
	AfxSig_v_u_hkl,					// void (UINT, HKL)
	AfxSig_INPUTDEVICECHANGE,		// void (unsigned short, HANDLE)
// Old
	AfxSig_bD = AfxSig_b_D_v,      // BOOL (CDC*)
	AfxSig_bb = AfxSig_b_b_v,      // BOOL (BOOL)
	AfxSig_bWww = AfxSig_b_W_uu,    // BOOL (CWnd*, UINT, UINT)
	AfxSig_hDWw = AfxSig_CTLCOLOR,    // HBRUSH (CDC*, CWnd*, UINT)
	AfxSig_hDw = AfxSig_CTLCOLOR_REFLECT,     // HBRUSH (CDC*, UINT)
	AfxSig_iwWw = AfxSig_i_u_W_u,    // int (UINT, CWnd*, UINT)
	AfxSig_iww = AfxSig_i_uu_v,     // int (UINT, UINT)
	AfxSig_iWww = AfxSig_i_W_uu,    // int (CWnd*, UINT, UINT)
	AfxSig_is = AfxSig_i_v_s,      // int (LPTSTR)
	AfxSig_lwl = AfxSig_l_w_l,     // LRESULT (WPARAM, LPARAM)
	AfxSig_lwwM = AfxSig_l_uu_M,    // LRESULT (UINT, UINT, CMenu*)
	AfxSig_vv = AfxSig_v_v_v,      // void (void)

	AfxSig_vw = AfxSig_v_u_v,      // void (UINT)
	AfxSig_vww = AfxSig_v_u_u,     // void (UINT, UINT)
	AfxSig_vww2 = AfxSig_v_uu_v,    // void (UINT, UINT) // both come from wParam
	AfxSig_vvii = AfxSig_v_v_ii,    // void (int, int) // wParam is ignored
	AfxSig_vwww = AfxSig_v_u_uu,    // void (UINT, UINT, UINT)
	AfxSig_vwii = AfxSig_v_u_ii,    // void (UINT, int, int)
	AfxSig_vwl = AfxSig_v_w_l,     // void (UINT, LPARAM)
	AfxSig_vbWW = AfxSig_MDIACTIVATE,    // void (BOOL, CWnd*, CWnd*)
	AfxSig_vD = AfxSig_v_D_v,      // void (CDC*)
	AfxSig_vM = AfxSig_v_M_v,      // void (CMenu*)
	AfxSig_vMwb = AfxSig_v_M_ub,    // void (CMenu*, UINT, BOOL)

	AfxSig_vW = AfxSig_v_W_v,      // void (CWnd*)
	AfxSig_vWww = AfxSig_v_W_uu,    // void (CWnd*, UINT, UINT)
	AfxSig_vWp = AfxSig_v_W_p,     // void (CWnd*, CPoint)
	AfxSig_vWh = AfxSig_v_W_h,     // void (CWnd*, HANDLE)
	AfxSig_vwW = AfxSig_v_u_W,     // void (UINT, CWnd*)
	AfxSig_vwWb = AfxSig_ACTIVATE,    // void (UINT, CWnd*, BOOL)
	AfxSig_vwwW = AfxSig_SCROLL,    // void (UINT, UINT, CWnd*)
	AfxSig_vwwx = AfxSig_SCROLL_REFLECT,    // void (UINT, UINT)
	AfxSig_vs = AfxSig_v_v_s,      // void (LPTSTR)
	AfxSig_vOWNER = AfxSig_OWNERDRAW,  // void (int, LPTSTR), force return TRUE
	AfxSig_iis = AfxSig_i_i_s,     // int (int, LPTSTR)
	AfxSig_wp = AfxSig_u_v_p,      // UINT (CPoint)
	AfxSig_wv = AfxSig_u_v_v,      // UINT (void)
	AfxSig_vPOS = AfxSig_v_v_WINDOWPOS,    // void (WINDOWPOS*)
	AfxSig_vCALC = AfxSig_v_b_NCCALCSIZEPARAMS,   // void (BOOL, NCCALCSIZE_PARAMS*)
	AfxSig_vNMHDRpl = AfxSigNotify_v,    // void (NMHDR*, LRESULT*)
	AfxSig_bNMHDRpl = AfxSigNotify_b,    // BOOL (NMHDR*, LRESULT*)
	AfxSig_vwNMHDRpl = AfxSigNotify_RANGE,   // void (UINT, NMHDR*, LRESULT*)
	AfxSig_bwNMHDRpl = AfxSigNotify_EX,   // BOOL (UINT, NMHDR*, LRESULT*)
	AfxSig_bHELPINFO = AfxSig_b_v_HELPINFO,   // BOOL (HELPINFO*)
	AfxSig_vwSIZING = AfxSig_SIZING,    // void (UINT, LPRECT) -- return TRUE

	// signatures specific to CCmdTarget
	AfxSig_cmdui = AfxSigCmdUI,   // void (CCmdUI*)
	AfxSig_cmduiw = AfxSigCmdUI_RANGE,  // void (CCmdUI*, UINT)
	AfxSig_vpv = AfxSigCmd_v_pv,     // void (void*)
	AfxSig_bpv = AfxSigCmd_b_pv,     // BOOL (void*)

	// Other aliases (based on implementation)
	AfxSig_vwwh = AfxSig_v_uu_M,                // void (UINT, UINT, HMENU)
	AfxSig_vwp = AfxSig_v_u_p,                 // void (UINT, CPoint)
	AfxSig_bw = AfxSig_b_u_v,      // BOOL (UINT)
	AfxSig_bh = AfxSig_b_h_v,      // BOOL (HANDLE)
	AfxSig_iw = AfxSig_i_u_v,      // int (UINT)
	AfxSig_ww = AfxSig_u_u_v,      // UINT (UINT)
	AfxSig_bv = AfxSig_b_v_v,      // BOOL (void)
	AfxSig_hv = AfxSig_C_v_v,      // HANDLE (void)
	AfxSig_vb = AfxSig_vw,      // void (BOOL)
	AfxSig_vbh = AfxSig_v_b_h,    // void (BOOL, HANDLE)
	AfxSig_vbw = AfxSig_vww,    // void (BOOL, UINT)
	AfxSig_vhh = AfxSig_v_h_h,    // void (HANDLE, HANDLE)
	AfxSig_vh = AfxSig_v_h_v,      // void (HANDLE)
	AfxSig_viSS = AfxSig_vwl,   // void (int, STYLESTRUCT*)
	AfxSig_bwl = AfxSig_lwl,
	AfxSig_vwMOVING = AfxSig_vwSIZING,  // void (UINT, LPRECT) -- return TRUE

	AfxSig_vW2 = AfxSig_v_v_W,                 // void (CWnd*) (CWnd* comes from lParam)
	AfxSig_bWCDS = AfxSig_b_W_COPYDATASTRUCT,               // BOOL (CWnd*, COPYDATASTRUCT*)
	AfxSig_bwsp = AfxSig_MOUSEWHEEL,                // BOOL (UINT, short, CPoint)
	AfxSig_vws = AfxSig_v_u_cs,
};

/////////////////////////////////////////////////////////////////////////////
// Command notifications for CCmdTarget notifications

#define CN_COMMAND              0               // void ()
#define CN_UPDATE_COMMAND_UI    ((UINT)(-1))    // void (CCmdUI*)
#define CN_EVENT                ((UINT)(-2))    // OLE event
#define CN_OLECOMMAND           ((UINT)(-3))    // OLE document command
#define CN_OLE_UNREGISTER       ((UINT)(-4))    // OLE unregister
// > 0 are control notifications
// < 0 are for MFC's use

#define ON_COMMAND(id, memberFxn) \
	{ WM_COMMAND, CN_COMMAND, (WORD)id, (WORD)id, AfxSigCmd_v, \
		static_cast<AFX_PMSG> (memberFxn) },
		// ON_COMMAND(id, OnBar) is the same as
		//   ON_CONTROL(0, id, OnBar) or ON_BN_CLICKED(0, id, OnBar)

#define ON_COMMAND_RANGE(id, idLast, memberFxn) \
	{ WM_COMMAND, CN_COMMAND, (WORD)id, (WORD)idLast, AfxSigCmd_RANGE, \
		(AFX_PMSG) \
		(static_cast< void (AFX_MSG_CALL CCmdTarget::*)(UINT) > \
		(memberFxn)) },
		// ON_COMMAND_RANGE(id, idLast, OnBar) is the same as
		//   ON_CONTROL_RANGE(0, id, idLast, OnBar)

#define ON_COMMAND_EX(id, memberFxn) \
	{ WM_COMMAND, CN_COMMAND, (WORD)id, (WORD)id, AfxSigCmd_EX, \
		(AFX_PMSG) \
		(static_cast< BOOL (AFX_MSG_CALL CCmdTarget::*)(UINT) > \
		(memberFxn)) },

#define ON_COMMAND_EX_RANGE(id, idLast, memberFxn) \
	{ WM_COMMAND, CN_COMMAND, (WORD)id, (WORD)idLast, AfxSigCmd_EX, \
		(AFX_PMSG) \
		(static_cast< BOOL (AFX_MSG_CALL CCmdTarget::*)(UINT) > \
		(memberFxn)) },

// update ui's are listed as WM_COMMAND's so they get routed like commands
#define ON_UPDATE_COMMAND_UI(id, memberFxn) \
	{ WM_COMMAND, CN_UPDATE_COMMAND_UI, (WORD)id, (WORD)id, AfxSigCmdUI, \
		(AFX_PMSG) \
		(static_cast< void (AFX_MSG_CALL CCmdTarget::*)(CCmdUI*) > \
		(memberFxn)) },

#define ON_UPDATE_COMMAND_UI_RANGE(id, idLast, memberFxn) \
	{ WM_COMMAND, CN_UPDATE_COMMAND_UI, (WORD)id, (WORD)idLast, AfxSigCmdUI, \
		(AFX_PMSG) \
		(static_cast< void (AFX_MSG_CALL CCmdTarget::*)(CCmdUI*) > \
		(memberFxn)) },

#define ON_NOTIFY(wNotifyCode, id, memberFxn) \
	{ WM_NOTIFY, (WORD)(int)wNotifyCode, (WORD)id, (WORD)id, AfxSigNotify_v, \
		(AFX_PMSG) \
		(static_cast< void (AFX_MSG_CALL CCmdTarget::*)(NMHDR*, LRESULT*) > \
		(memberFxn)) },

#define ON_NOTIFY_RANGE(wNotifyCode, id, idLast, memberFxn) \
	{ WM_NOTIFY, (WORD)(int)wNotifyCode, (WORD)id, (WORD)idLast, AfxSigNotify_RANGE, \
		(AFX_PMSG) \
		(static_cast< void (AFX_MSG_CALL CCmdTarget::*)(UINT, NMHDR*, LRESULT*) > \
		(memberFxn)) },

#define ON_NOTIFY_EX(wNotifyCode, id, memberFxn) \
	{ WM_NOTIFY, (WORD)(int)wNotifyCode, (WORD)id, (WORD)id, AfxSigNotify_EX, \
		(AFX_PMSG) \
		(static_cast< BOOL (AFX_MSG_CALL CCmdTarget::*)(UINT, NMHDR*, LRESULT*) > \
		(memberFxn)) },

#define ON_NOTIFY_EX_RANGE(wNotifyCode, id, idLast, memberFxn) \
	{ WM_NOTIFY, (WORD)(int)wNotifyCode, (WORD)id, (WORD)idLast, AfxSigNotify_EX, \
		(AFX_PMSG) \
		(static_cast< BOOL (AFX_MSG_CALL CCmdTarget::*)(UINT, NMHDR*, LRESULT*) > \
		(memberFxn)) },

// for general controls
#define ON_CONTROL(wNotifyCode, id, memberFxn) \
	{ WM_COMMAND, (WORD)wNotifyCode, (WORD)id, (WORD)id, AfxSigCmd_v, \
		(static_cast< AFX_PMSG > (memberFxn)) },

#define ON_CONTROL_RANGE(wNotifyCode, id, idLast, memberFxn) \
	{ WM_COMMAND, (WORD)wNotifyCode, (WORD)id, (WORD)idLast, AfxSigCmd_RANGE, \
		(AFX_PMSG) \
		(static_cast< void (AFX_MSG_CALL CCmdTarget::*)(UINT) > (memberFxn)) },

#define WM_REFLECT_BASE 0xBC00

// for control notification reflection
#define ON_CONTROL_REFLECT(wNotifyCode, memberFxn) \
	{ WM_COMMAND+WM_REFLECT_BASE, (WORD)wNotifyCode, 0, 0, AfxSigCmd_v, \
		(static_cast<AFX_PMSG> (memberFxn)) },

#define ON_CONTROL_REFLECT_EX(wNotifyCode, memberFxn) \
	{ WM_COMMAND+WM_REFLECT_BASE, (WORD)wNotifyCode, 0, 0, AfxSigCmd_b, \
		(AFX_PMSG) \
		(static_cast<BOOL (AFX_MSG_CALL CCmdTarget::*)(void)> (memberFxn)) },

#define ON_NOTIFY_REFLECT(wNotifyCode, memberFxn) \
	{ WM_NOTIFY+WM_REFLECT_BASE, (WORD)(int)wNotifyCode, 0, 0, AfxSigNotify_v, \
		(AFX_PMSG) \
		(static_cast<void (AFX_MSG_CALL CCmdTarget::*)(NMHDR*, LRESULT*) > \
		(memberFxn)) },

#define ON_NOTIFY_REFLECT_EX(wNotifyCode, memberFxn) \
	{ WM_NOTIFY+WM_REFLECT_BASE, (WORD)(int)wNotifyCode, 0, 0, AfxSigNotify_b, \
		(AFX_PMSG) \
		(static_cast<BOOL (AFX_MSG_CALL CCmdTarget::*)(NMHDR*, LRESULT*) > \
		(memberFxn)) },

#define ON_UPDATE_COMMAND_UI_REFLECT(memberFxn) \
	{ WM_COMMAND+WM_REFLECT_BASE, (WORD)CN_UPDATE_COMMAND_UI, 0, 0, AfxSigCmdUI, \
		(AFX_PMSG) \
		(static_cast<void (AFX_MSG_CALL CCmdTarget::*)(CCmdUI*) > \
		(memberFxn)) },

/////////////////////////////////////////////////////////////////////////////
// Message map tables for Windows messages

#define ON_WM_CREATE() \
	{ WM_CREATE, 0, 0, 0, AfxSig_is, \
		(AFX_PMSG) (AFX_PMSGW) \
		(static_cast< int (AFX_MSG_CALL CWnd::*)(LPCREATESTRUCT) > ( &ThisClass :: OnCreate)) },

#define ON_WM_COPYDATA() \
	{ WM_COPYDATA, 0, 0, 0, AfxSig_bWCDS, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< BOOL (AFX_MSG_CALL CWnd::*)(CWnd*, COPYDATASTRUCT*) > ( &ThisClass :: OnCopyData)) },

#define ON_WM_DESTROY() \
	{ WM_DESTROY, 0, 0, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnDestroy)) },

#define ON_WM_MOVE() \
	{ WM_MOVE, 0, 0, 0, AfxSig_vvii, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(int, int) > ( &ThisClass :: OnMove)) },

#define ON_WM_SIZE() \
	{ WM_SIZE, 0, 0, 0, AfxSig_vwii, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, int, int) > ( &ThisClass :: OnSize)) },

#define ON_WM_ACTIVATE() \
	{ WM_ACTIVATE, 0, 0, 0, AfxSig_vwWb, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CWnd*, BOOL) > ( &ThisClass :: OnActivate)) },

#define ON_WM_SETFOCUS() \
	{ WM_SETFOCUS, 0, 0, 0, AfxSig_vW, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(CWnd*) > ( &ThisClass :: OnSetFocus)) },

#define ON_WM_KILLFOCUS() \
	{ WM_KILLFOCUS, 0, 0, 0, AfxSig_vW, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(CWnd*) > ( &ThisClass :: OnKillFocus)) },

#define ON_WM_ENABLE() \
	{ WM_ENABLE, 0, 0, 0, AfxSig_vb, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(BOOL) > ( &ThisClass :: OnEnable)) },

#define ON_WM_HELPINFO() \
	{ WM_HELP, 0, 0, 0, AfxSig_bHELPINFO, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< BOOL (AFX_MSG_CALL CWnd::*)(HELPINFO*) > ( &ThisClass :: OnHelpInfo)) },

#define ON_WM_PAINT() \
	{ WM_PAINT, 0, 0, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnPaint)) },

#define ON_WM_SYNCPAINT() \
	{ WM_SYNCPAINT, 0, 0, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnSyncPaint)) },

#define ON_WM_CLOSE() \
	{ WM_CLOSE, 0, 0, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnClose)) },

#define ON_WM_QUERYENDSESSION() \
	{ WM_QUERYENDSESSION, 0, 0, 0, AfxSig_bv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< BOOL (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnQueryEndSession)) },

#define ON_WM_QUERYOPEN() \
	{ WM_QUERYOPEN, 0, 0, 0, AfxSig_bv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< BOOL (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnQueryOpen)) },

#define ON_WM_ERASEBKGND() \
	{ WM_ERASEBKGND, 0, 0, 0, AfxSig_bD, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< BOOL (AFX_MSG_CALL CWnd::*)(CDC*) > ( &ThisClass :: OnEraseBkgnd)) },

#define ON_WM_SYSCOLORCHANGE() \
	{ WM_SYSCOLORCHANGE, 0, 0, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnSysColorChange)) },

#define ON_WM_ENDSESSION() \
	{ WM_ENDSESSION, 0, 0, 0, AfxSig_vb, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(BOOL) > ( &ThisClass :: OnEndSession)) },

#if(_WIN32_WINNT >= 0x0501)

#define ON_WM_WTSSESSION_CHANGE() \
	{ WM_WTSSESSION_CHANGE, 0, 0, 0, AfxSig_vww, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT) > ( &ThisClass :: OnSessionChange)) },

#else

#define ON_WM_WTSSESSION_CHANGE() \
	__pragma(message("WM_WTSSESSION_CHANGE requires _WIN32_WINNT to be >= 0x501")) \
	{ WM_WTSSESSION_CHANGE, 0, 0, 0, AfxSig_vww, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT) > ( &ThisClass :: OnSessionChange)) },

#endif

#define ON_WM_SHOWWINDOW() \
	{ WM_SHOWWINDOW, 0, 0, 0, AfxSig_vbw, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(BOOL, UINT) > ( &ThisClass :: OnShowWindow)) },

#define ON_WM_CTLCOLOR() \
	{ WM_CTLCOLOR, 0, 0, 0, AfxSig_hDWw, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< HBRUSH (AFX_MSG_CALL CWnd::*)(CDC*, CWnd*, UINT)>  ( &ThisClass :: OnCtlColor)) },

#define ON_WM_CTLCOLOR_REFLECT() \
	{ WM_CTLCOLOR+WM_REFLECT_BASE, 0, 0, 0, AfxSig_hDw, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< HBRUSH (AFX_MSG_CALL CWnd::*)(CDC*, UINT) > ( &ThisClass :: CtlColor)) },

#define ON_WM_SETTINGCHANGE() \
	{ WM_SETTINGCHANGE, 0, 0, 0, AfxSig_vws, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, LPCTSTR) > ( &ThisClass :: OnSettingChange)) },

#define ON_WM_WININICHANGE() \
	{ WM_WININICHANGE, 0, 0, 0, AfxSig_vs, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(LPCTSTR) > ( &ThisClass :: OnWinIniChange)) },

#define ON_WM_DEVMODECHANGE() \
	{ WM_DEVMODECHANGE, 0, 0, 0, AfxSig_vs, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(LPTSTR) > ( &ThisClass :: OnDevModeChange)) },

#define ON_WM_ACTIVATEAPP() \
	{ WM_ACTIVATEAPP, 0, 0, 0, AfxSig_vww, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(BOOL, DWORD) > ( &ThisClass :: OnActivateApp)) },

#define ON_WM_FONTCHANGE() \
	{ WM_FONTCHANGE, 0, 0, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnFontChange)) },

#define ON_WM_TIMECHANGE() \
	{ WM_TIMECHANGE, 0, 0, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnTimeChange)) },

#define ON_WM_CANCELMODE() \
	{ WM_CANCELMODE, 0, 0, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnCancelMode)) },

#define ON_WM_SETCURSOR() \
	{ WM_SETCURSOR, 0, 0, 0, AfxSig_bWww, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< BOOL (AFX_MSG_CALL CWnd::*)(CWnd*, UINT, UINT) > ( &ThisClass :: OnSetCursor)) },

#define ON_WM_MOUSEACTIVATE() \
	{ WM_MOUSEACTIVATE, 0, 0, 0, AfxSig_iWww, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< int (AFX_MSG_CALL CWnd::*)(CWnd*, UINT, UINT) > ( &ThisClass :: OnMouseActivate)) },

#define ON_WM_CHILDACTIVATE() \
	{ WM_CHILDACTIVATE, 0, 0, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnChildActivate)) },

#define ON_WM_GETMINMAXINFO() \
	{ WM_GETMINMAXINFO, 0, 0, 0, AfxSig_vs, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(MINMAXINFO*) > ( &ThisClass :: OnGetMinMaxInfo)) },

#define ON_WM_ICONERASEBKGND() \
	{ WM_ICONERASEBKGND, 0, 0, 0, AfxSig_vD, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(CDC*) > ( &ThisClass :: OnIconEraseBkgnd)) },

#define ON_WM_SPOOLERSTATUS() \
	{ WM_SPOOLERSTATUS, 0, 0, 0, AfxSig_vww, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT) > ( &ThisClass :: OnSpoolerStatus)) },

#define ON_WM_DRAWITEM() \
	{ WM_DRAWITEM, 0, 0, 0, AfxSig_vOWNER, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(int, LPDRAWITEMSTRUCT) > ( &ThisClass :: OnDrawItem)) },

#define ON_WM_DRAWITEM_REFLECT() \
	{ WM_DRAWITEM+WM_REFLECT_BASE, 0, 0, 0, AfxSig_vs, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(LPDRAWITEMSTRUCT) > ( &ThisClass :: DrawItem)) },

#define ON_WM_MEASUREITEM() \
	{ WM_MEASUREITEM, 0, 0, 0, AfxSig_vOWNER, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(int, LPMEASUREITEMSTRUCT) > ( &ThisClass :: OnMeasureItem)) },

#define ON_WM_MEASUREITEM_REFLECT() \
	{ WM_MEASUREITEM+WM_REFLECT_BASE, 0, 0, 0, AfxSig_vs, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(LPMEASUREITEMSTRUCT) > ( &ThisClass :: MeasureItem)) },

#define ON_WM_DELETEITEM() \
	{ WM_DELETEITEM, 0, 0, 0, AfxSig_vOWNER, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(int, LPDELETEITEMSTRUCT) > ( &ThisClass :: OnDeleteItem)) },

#define ON_WM_DELETEITEM_REFLECT() \
	{ WM_DELETEITEM+WM_REFLECT_BASE, 0, 0, 0, AfxSig_vs, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(LPDELETEITEMSTRUCT) > ( &ThisClass :: DeleteItem)) },

#define ON_WM_CHARTOITEM() \
	{ WM_CHARTOITEM, 0, 0, 0, AfxSig_iwWw, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< int (AFX_MSG_CALL CWnd::*)(UINT, CListBox*, UINT) > ( &ThisClass :: OnCharToItem)) },

#define ON_WM_CHARTOITEM_REFLECT() \
	{ WM_CHARTOITEM+WM_REFLECT_BASE, 0, 0, 0, AfxSig_iww, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< int (AFX_MSG_CALL CWnd::*)(UINT, UINT) > ( &ThisClass :: CharToItem)) },

#define ON_WM_VKEYTOITEM() \
	{ WM_VKEYTOITEM, 0, 0, 0, AfxSig_iwWw, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< int (AFX_MSG_CALL CWnd::*)(UINT, CListBox*, UINT) > ( &ThisClass :: OnVKeyToItem)) },

#define ON_WM_VKEYTOITEM_REFLECT() \
	{ WM_VKEYTOITEM+WM_REFLECT_BASE, 0, 0, 0, AfxSig_iww, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< int (AFX_MSG_CALL CWnd::*)(UINT, UINT) > ( &ThisClass :: VKeyToItem)) },

#define ON_WM_QUERYDRAGICON() \
	{ WM_QUERYDRAGICON, 0, 0, 0, AfxSig_hv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< HCURSOR (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnQueryDragIcon)) },

#define ON_WM_COMPAREITEM() \
	{ WM_COMPAREITEM, 0, 0, 0, AfxSig_iis, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< int (AFX_MSG_CALL CWnd::*)(int, LPCOMPAREITEMSTRUCT) > ( &ThisClass :: OnCompareItem)) },

#define ON_WM_COMPAREITEM_REFLECT() \
	{ WM_COMPAREITEM+WM_REFLECT_BASE, 0, 0, 0, AfxSig_is, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< int (AFX_MSG_CALL CWnd::*)(LPCOMPAREITEMSTRUCT) > ( &ThisClass :: CompareItem)) },

#define ON_WM_COMPACTING() \
	{ WM_COMPACTING, 0, 0, 0, AfxSig_vw, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT) > ( &ThisClass :: OnCompacting)) },

#define ON_WM_NCCREATE() \
	{ WM_NCCREATE, 0, 0, 0, AfxSig_is, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< BOOL (AFX_MSG_CALL CWnd::*)(LPCREATESTRUCT) > ( &ThisClass :: OnNcCreate)) },

#define ON_WM_NCDESTROY() \
	{ WM_NCDESTROY, 0, 0, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnNcDestroy)) },

#define ON_WM_NCCALCSIZE() \
	{ WM_NCCALCSIZE, 0, 0, 0, AfxSig_vCALC, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(BOOL, NCCALCSIZE_PARAMS*) > ( &ThisClass :: OnNcCalcSize)) },

#define ON_WM_NCHITTEST() \
	{ WM_NCHITTEST, 0, 0, 0, AfxSig_l_p, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< LRESULT (AFX_MSG_CALL CWnd::*)(CPoint) > (&ThisClass :: OnNcHitTest)) },

#define ON_WM_NCPAINT() \
	{ WM_NCPAINT, 0, 0, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnNcPaint)) },

#define ON_WM_NCACTIVATE() \
	{ WM_NCACTIVATE, 0, 0, 0, AfxSig_bb, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< BOOL (AFX_MSG_CALL CWnd::*)(BOOL) > ( &ThisClass :: OnNcActivate)) },

#define ON_WM_GETDLGCODE() \
	{ WM_GETDLGCODE, 0, 0, 0, AfxSig_wv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< UINT (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnGetDlgCode)) },

#define ON_WM_NCMOUSEMOVE() \
	{ WM_NCMOUSEMOVE, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnNcMouseMove)) },

#define ON_WM_NCMOUSEHOVER() \
	{ WM_NCMOUSEHOVER, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnNcMouseHover)) },

#define ON_WM_NCMOUSELEAVE() \
	{ WM_NCMOUSELEAVE, 0, 0, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnNcMouseLeave)) },

#define ON_WM_NCLBUTTONDOWN() \
	{ WM_NCLBUTTONDOWN, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnNcLButtonDown)) },

#define ON_WM_NCLBUTTONUP() \
	{ WM_NCLBUTTONUP, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnNcLButtonUp)) },

#define ON_WM_NCLBUTTONDBLCLK() \
	{ WM_NCLBUTTONDBLCLK, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnNcLButtonDblClk)) },

#define ON_WM_NCRBUTTONDOWN() \
	{ WM_NCRBUTTONDOWN, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnNcRButtonDown)) },

#define ON_WM_NCRBUTTONUP() \
	{ WM_NCRBUTTONUP, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnNcRButtonUp)) },

#define ON_WM_NCRBUTTONDBLCLK() \
	{ WM_NCRBUTTONDBLCLK, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnNcRButtonDblClk)) },

#define ON_WM_NCMBUTTONDOWN() \
	{ WM_NCMBUTTONDOWN, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnNcMButtonDown)) },

#define ON_WM_NCMBUTTONUP() \
	{ WM_NCMBUTTONUP, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnNcMButtonUp)) },

#define ON_WM_NCMBUTTONDBLCLK() \
	{ WM_NCMBUTTONDBLCLK, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnNcMButtonDblClk)) },

#if(_WIN32_WINNT >= 0x0500)

#define ON_WM_NCXBUTTONDOWN() \
	{ WM_NCXBUTTONDOWN, 0, 0, 0, AfxSig_MOUSE_NCXBUTTON, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(short, UINT, CPoint) > ( &ThisClass :: OnNcXButtonDown)) },

#define ON_WM_NCXBUTTONUP() \
	{ WM_NCXBUTTONUP, 0, 0, 0, AfxSig_MOUSE_NCXBUTTON, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(short, UINT, CPoint) > ( &ThisClass :: OnNcXButtonUp)) },

#define ON_WM_NCXBUTTONDBLCLK() \
	{ WM_NCXBUTTONDBLCLK, 0, 0, 0, AfxSig_MOUSE_NCXBUTTON, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(short, UINT, CPoint) > ( &ThisClass :: OnNcXButtonDblClk)) },

#else

#define ON_WM_NCXBUTTONDOWN() \
	__pragma(message("WM_NCXBUTTONDOWN requires _WIN32_WINNT to be >= 0x500")) \
	{ WM_NCXBUTTONDOWN, 0, 0, 0, AfxSig_MOUSE_NCXBUTTON, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(short, UINT, CPoint) > ( &ThisClass :: OnNcXButtonDown)) },

#define ON_WM_NCXBUTTONUP() \
	__pragma(message("WM_NCXBUTTONUP requires _WIN32_WINNT to be >= 0x500")) \
	{ WM_NCXBUTTONUP, 0, 0, 0, AfxSig_MOUSE_NCXBUTTON, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(short, UINT, CPoint) > ( &ThisClass :: OnNcXButtonUp)) },

#define ON_WM_NCXBUTTONDBLCLK() \
	__pragma(message("WM_NCXBUTTONDBLCLK requires _WIN32_WINNT to be >= 0x500")) \
	{ WM_NCXBUTTONDBLCLK, 0, 0, 0, AfxSig_MOUSE_NCXBUTTON, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(short, UINT, CPoint) > ( &ThisClass :: OnNcXButtonDblClk)) },

#endif

#define ON_WM_KEYDOWN() \
	{ WM_KEYDOWN, 0, 0, 0, AfxSig_vwww, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT, UINT) > ( &ThisClass :: OnKeyDown)) },

#define ON_WM_KEYUP() \
	{ WM_KEYUP, 0, 0, 0, AfxSig_vwww, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT, UINT) > ( &ThisClass :: OnKeyUp)) },

#define ON_WM_HOTKEY() \
	{ WM_HOTKEY, 0, 0, 0, AfxSig_v_u_uu, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT, UINT) > ( &ThisClass :: OnHotKey)) },

#define ON_WM_CHAR() \
	{ WM_CHAR, 0, 0, 0, AfxSig_vwww, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT, UINT) > ( &ThisClass :: OnChar)) },

#if(_WIN32_WINNT >= 0x0501)

#define ON_WM_UNICHAR() \
	{ WM_UNICHAR, 0, 0, 0, AfxSig_vwww, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT, UINT) > ( &ThisClass :: OnUniChar)) },

#else

#define ON_WM_UNICHAR() \
	__pragma(message("WM_UNICHAR requires _WIN32_WINNT to be >= 0x501")) \
	{ WM_UNICHAR, 0, 0, 0, AfxSig_vwww, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT, UINT) > ( &ThisClass :: OnUniChar)) },

#endif

#define ON_WM_DEADCHAR() \
	{ WM_DEADCHAR, 0, 0, 0, AfxSig_vwww, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT, UINT) > ( &ThisClass :: OnDeadChar)) },

#define ON_WM_SYSKEYDOWN() \
	{ WM_SYSKEYDOWN, 0, 0, 0, AfxSig_vwww, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT, UINT) > ( &ThisClass :: OnSysKeyDown)) },

#define ON_WM_SYSKEYUP() \
	{ WM_SYSKEYUP, 0, 0, 0, AfxSig_vwww, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT, UINT) > ( &ThisClass :: OnSysKeyUp)) },

#define ON_WM_SYSCHAR() \
	{ WM_SYSCHAR, 0, 0, 0, AfxSig_vwww, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast<void (AFX_MSG_CALL CWnd::*)(UINT, UINT, UINT) > ( &ThisClass :: OnSysChar)) },

#define ON_WM_SYSDEADCHAR() \
	{ WM_SYSDEADCHAR, 0, 0, 0, AfxSig_vwww, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT, UINT) > ( &ThisClass :: OnSysDeadChar)) },

#define ON_WM_SYSCOMMAND() \
	{ WM_SYSCOMMAND, 0, 0, 0, AfxSig_vwl, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, LPARAM) > ( &ThisClass :: OnSysCommand)) },

#define ON_WM_INPUTLANGCHANGE() \
	{ WM_INPUTLANGCHANGE, 0, 0, 0, AfxSig_INPUTLANGCHANGE, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT) > ( &ThisClass :: OnInputLangChange)) },

#define ON_WM_INPUTLANGCHANGEREQUEST() \
	{ WM_INPUTLANGCHANGEREQUEST, 0, 0, 0, AfxSig_vww, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT) > ( &ThisClass :: OnInputLangChangeRequest)) },

#if(_WIN32_WINNT >= 0x0500)

#define ON_WM_APPCOMMAND() \
	{ WM_APPCOMMAND, 0, 0, 0, AfxSig_APPCOMMAND, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(CWnd*, UINT, UINT, UINT) > ( &ThisClass :: OnAppCommand)) },

#else

#define ON_WM_APPCOMMAND() \
	__pragma(message("WM_APPCOMMAND requires _WIN32_WINNT to be >= 0x500")) \
	{ WM_APPCOMMAND, 0, 0, 0, AfxSig_APPCOMMAND, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(CWnd*, UINT, UINT, UINT) > ( &ThisClass :: OnAppCommand)) },

#endif

#if(_WIN32_WINNT >= 0x0501)

#define ON_WM_INPUT() \
	{ WM_INPUT, 0, 0, 0, AfxSig_RAWINPUT, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, HRAWINPUT) > ( &ThisClass :: OnRawInput)) },

#else

#define ON_WM_INPUT() \
	__pragma(message("WM_INPUT requires _WIN32_WINNT to be >= 0x501")) \
	{ WM_INPUT, 0, 0, 0, AfxSig_RAWINPUT, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, HRAWINPUT) > ( &ThisClass :: OnRawInput)) },

#endif /* _WIN32_WINNT >= 0x0501 */

#if(_WIN32_WINNT >= 0x0600)

#define ON_WM_INPUT_DEVICE_CHANGE() \
	{ WM_INPUT_DEVICE_CHANGE, 0, 0, 0, AfxSig_INPUTDEVICECHANGE, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(unsigned short, HANDLE) > ( &ThisClass :: OnInputDeviceChange)) },

#else

#define ON_WM_INPUT_DEVICE_CHANGE() \
	__pragma(message("WM_INPUT_DEVICE_CHANGE requires _WIN32_WINNT to be >= 0x600")) \
	{ WM_INPUT_DEVICE_CHANGE, 0, 0, 0, AfxSig_INPUTDEVICECHANGE, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(unsigned short, HANDLE) > ( &ThisClass :: OnInputDeviceChange)) },

#endif /* _WIN32_WINNT >= 0x0600 */

#define ON_WM_TCARD() \
	{ WM_TCARD, 0, 0, 0, AfxSig_vwl, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, DWORD) > ( &ThisClass :: OnTCard)) },

#define ON_WM_TIMER() \
	{ WM_TIMER, 0, 0, 0, AfxSig_vw, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT_PTR) > ( &ThisClass :: OnTimer)) },

#define ON_WM_HSCROLL() \
	{ WM_HSCROLL, 0, 0, 0, AfxSig_vwwW, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT, CScrollBar*) > ( &ThisClass :: OnHScroll)) },

#define ON_WM_HSCROLL_REFLECT() \
	{ WM_HSCROLL+WM_REFLECT_BASE, 0, 0, 0, AfxSig_vwwx, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT) > ( &ThisClass :: HScroll)) },

#define ON_WM_VSCROLL() \
	{ WM_VSCROLL, 0, 0, 0, AfxSig_vwwW, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT, CScrollBar*) > ( &ThisClass :: OnVScroll)) },

#define ON_WM_VSCROLL_REFLECT() \
	{ WM_VSCROLL+WM_REFLECT_BASE, 0, 0, 0, AfxSig_vwwx, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT) > ( &ThisClass :: VScroll)) },

#define ON_WM_INITMENU() \
	{ WM_INITMENU, 0, 0, 0, AfxSig_vM, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(CMenu*) > ( &ThisClass :: OnInitMenu)) },

#define ON_WM_INITMENUPOPUP() \
	{ WM_INITMENUPOPUP, 0, 0, 0, AfxSig_vMwb, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(CMenu*, UINT, BOOL) > ( &ThisClass :: OnInitMenuPopup)) },

#define ON_WM_MENUSELECT() \
	{ WM_MENUSELECT, 0, 0, 0, AfxSig_vwwh, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT, HMENU) > ( &ThisClass :: OnMenuSelect)) },

#define ON_WM_MENUCHAR() \
	{ WM_MENUCHAR, 0, 0, 0, AfxSig_lwwM, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< LRESULT (AFX_MSG_CALL CWnd::*)(UINT, UINT, CMenu*) > ( &ThisClass :: OnMenuChar)) },

#if(WINVER >= 0x0500)

#define ON_WM_MENURBUTTONUP() \
	{ WM_MENURBUTTONUP, 0, 0, 0, AfxSig_v_u_M, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CMenu*) > ( &ThisClass :: OnMenuRButtonUp)) },

#else

#define ON_WM_MENURBUTTONUP() \
	__pragma(message("WM_MENURBUTTONUP requires _WIN32_WINNT to be >= 0x500")) \
	{ WM_MENURBUTTONUP, 0, 0, 0, AfxSig_v_u_M, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CMenu*) > ( &ThisClass :: OnMenuRButtonUp)) },

#endif

#define ON_WM_MENUDRAG() \
	{ WM_MENUDRAG, 0, 0, 0, AfxSig_u_u_M, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< UINT (AFX_MSG_CALL CWnd::*)(UINT, CMenu*) > ( &ThisClass :: OnMenuDrag)) },

#define ON_WM_MENUGETOBJECT() \
	{ WM_MENUGETOBJECT, 0, 0, 0, AfxSig_u_v_MENUGETOBJECTINFO, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< UINT (AFX_MSG_CALL CWnd::*)(MENUGETOBJECTINFO*) > ( &ThisClass :: OnMenuGetObject)) },

#define ON_WM_UNINITMENUPOPUP() \
	{ WM_UNINITMENUPOPUP, 0, 0, 0, AfxSig_v_M_u, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(CMenu*, UINT) > ( &ThisClass :: OnUnInitMenuPopup)) },

#define ON_WM_NEXTMENU() \
	{ WM_NEXTMENU, 0, 0, 0, AfxSig_v_u_LPMDINEXTMENU, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, LPMDINEXTMENU) > ( &ThisClass :: OnNextMenu)) },

#define ON_WM_ENTERIDLE() \
	{ WM_ENTERIDLE, 0, 0, 0, AfxSig_vwW, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CWnd*) > ( &ThisClass :: OnEnterIdle)) },

#define ON_WM_MOUSEMOVE() \
	{ WM_MOUSEMOVE, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnMouseMove)) },

#define ON_WM_MOUSEHOVER() \
	{ WM_MOUSEHOVER, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnMouseHover)) },

#define ON_WM_MOUSELEAVE() \
	{ WM_MOUSELEAVE, 0, 0, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnMouseLeave)) },

#define ON_WM_MOUSEWHEEL() \
	{ WM_MOUSEWHEEL, 0, 0, 0, AfxSig_bwsp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< BOOL (AFX_MSG_CALL CWnd::*)(UINT, short, CPoint) > ( &ThisClass :: OnMouseWheel)) },

#if (_WIN32_WINNT >= 0x0600)

#define ON_WM_MOUSEHWHEEL() \
	{ WM_MOUSEHWHEEL, 0, 0, 0, AfxSig_MOUSEHWHEEL, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, short, CPoint) > ( &ThisClass :: OnMouseHWheel)) },

#else

#define ON_WM_MOUSEHWHEEL() \
	__pragma(message("WM_MOUSEHWHEEL requires _WIN32_WINNT to be >= 0x600")) \
	{ WM_MOUSEHWHEEL, 0, 0, 0, AfxSig_MOUSEHWHEEL, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, short, CPoint) > ( &ThisClass :: OnMouseHWheel)) },

#endif

#define ON_WM_LBUTTONDOWN() \
	{ WM_LBUTTONDOWN, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnLButtonDown)) },

#define ON_WM_LBUTTONUP() \
	{ WM_LBUTTONUP, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnLButtonUp)) },

#define ON_WM_LBUTTONDBLCLK() \
	{ WM_LBUTTONDBLCLK, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnLButtonDblClk)) },

#define ON_WM_RBUTTONDOWN() \
	{ WM_RBUTTONDOWN, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnRButtonDown)) },

#define ON_WM_RBUTTONUP() \
	{ WM_RBUTTONUP, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnRButtonUp)) },

#define ON_WM_RBUTTONDBLCLK() \
	{ WM_RBUTTONDBLCLK, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnRButtonDblClk)) },

#define ON_WM_MBUTTONDOWN() \
	{ WM_MBUTTONDOWN, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnMButtonDown)) },

#define ON_WM_MBUTTONUP() \
	{ WM_MBUTTONUP, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnMButtonUp)) },

#define ON_WM_MBUTTONDBLCLK() \
	{ WM_MBUTTONDBLCLK, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnMButtonDblClk)) },

#if (_WIN32_WINNT >= 0x0500)

#define ON_WM_XBUTTONDOWN() \
	{ WM_XBUTTONDOWN, 0, 0, 0, AfxSig_MOUSE_XBUTTON, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT, CPoint) > ( &ThisClass :: OnXButtonDown)) },

#define ON_WM_XBUTTONUP() \
	{ WM_XBUTTONUP, 0, 0, 0, AfxSig_MOUSE_XBUTTON, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT, CPoint) > ( &ThisClass :: OnXButtonUp)) },

#define ON_WM_XBUTTONDBLCLK() \
	{ WM_XBUTTONDBLCLK, 0, 0, 0, AfxSig_MOUSE_XBUTTON, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT, CPoint) > ( &ThisClass :: OnXButtonDblClk)) },

#else

#define ON_WM_XBUTTONDOWN() \
	__pragma(message("WM_XBUTTONDOWN requires _WIN32_WINNT to be >= 0x500")) \
	{ WM_XBUTTONDOWN, 0, 0, 0, AfxSig_MOUSE_XBUTTON, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT, CPoint) > ( &ThisClass :: OnXButtonDown)) },

#define ON_WM_XBUTTONUP() \
	__pragma(message("WM_XBUTTONUP requires _WIN32_WINNT to be >= 0x500")) \
	{ WM_XBUTTONUP, 0, 0, 0, AfxSig_MOUSE_XBUTTON, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT, CPoint) > ( &ThisClass :: OnXButtonUp)) },

#define ON_WM_XBUTTONDBLCLK() \
	__pragma(message("WM_XBUTTONDBLCLK requires _WIN32_WINNT to be >= 0x500")) \
	{ WM_XBUTTONDBLCLK, 0, 0, 0, AfxSig_MOUSE_XBUTTON, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT, CPoint) > ( &ThisClass :: OnXButtonDblClk)) },

#endif

#define ON_WM_PARENTNOTIFY() \
	{ WM_PARENTNOTIFY, 0, 0, 0, AfxSig_vwl, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast<void (AFX_MSG_CALL CWnd::*)(UINT, LPARAM) > ( &ThisClass :: OnParentNotify)) },

#define ON_WM_PARENTNOTIFY_REFLECT() \
	{ WM_PARENTNOTIFY+WM_REFLECT_BASE, 0, 0, 0, AfxSig_vwl, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, LPARAM) > ( &ThisClass :: ParentNotify)) },

#define ON_WM_NOTIFYFORMAT() \
	{ WM_NOTIFYFORMAT, 0, 0, 0, AfxSig_u_W_u, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< UINT (AFX_MSG_CALL CWnd::*)(CWnd*, UINT) > ( &ThisClass :: OnNotifyFormat)) },

#define ON_WM_MDIACTIVATE() \
	{ WM_MDIACTIVATE, 0, 0, 0, AfxSig_vbWW, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(BOOL, CWnd*, CWnd*) > ( &ThisClass :: OnMDIActivate)) },
#define ON_WM_RENDERFORMAT() \
	{ WM_RENDERFORMAT, 0, 0, 0, AfxSig_vw, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT) > ( &ThisClass :: OnRenderFormat)) },

#define ON_WM_RENDERALLFORMATS() \
	{ WM_RENDERALLFORMATS, 0, 0, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnRenderAllFormats)) },

#define ON_WM_DESTROYCLIPBOARD() \
	{ WM_DESTROYCLIPBOARD, 0, 0, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnDestroyClipboard)) },

#define ON_WM_DRAWCLIPBOARD() \
	{ WM_DRAWCLIPBOARD, 0, 0, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnDrawClipboard)) },

#define ON_WM_PAINTCLIPBOARD() \
	{ WM_PAINTCLIPBOARD, 0, 0, 0, AfxSig_vWh, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(CWnd*, HGLOBAL) > ( &ThisClass :: OnPaintClipboard)) },

#define ON_WM_VSCROLLCLIPBOARD() \
	{ WM_VSCROLLCLIPBOARD, 0, 0, 0, AfxSig_vWww, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(CWnd*, UINT, UINT) > ( &ThisClass :: OnVScrollClipboard)) },

#define ON_WM_CONTEXTMENU() \
	{ WM_CONTEXTMENU, 0, 0, 0, AfxSig_vWp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(CWnd*, CPoint) > ( &ThisClass :: OnContextMenu)) },

#define ON_WM_SIZECLIPBOARD() \
	{ WM_SIZECLIPBOARD, 0, 0, 0, AfxSig_vWh, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(CWnd*, HGLOBAL)> ( &ThisClass :: OnSizeClipboard)) },

#define ON_WM_ASKCBFORMATNAME() \
	{ WM_ASKCBFORMATNAME, 0, 0, 0, AfxSig_vwl, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, LPTSTR) > ( &ThisClass :: OnAskCbFormatName)) },

#define ON_WM_CHANGECBCHAIN() \
	{ WM_CHANGECBCHAIN, 0, 0, 0, AfxSig_vhh, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(HWND, HWND) > ( &ThisClass :: OnChangeCbChain)) },

#define ON_WM_HSCROLLCLIPBOARD() \
	{ WM_HSCROLLCLIPBOARD, 0, 0, 0, AfxSig_vWww, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(CWnd*, UINT, UINT) > ( &ThisClass :: OnHScrollClipboard)) },

#if(_WIN32_WINNT >= 0x0600)

#define ON_WM_CLIPBOARDUPDATE() \
	{ WM_CLIPBOARDUPDATE, 0, 0, 0, AfxSig_v_v_v, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnClipboardUpdate)) },

#else

#define ON_WM_CLIPBOARDUPDATE() \
	__pragma(message("WM_CLIPBOARDUPDATE requires _WIN32_WINNT to be >= 0x0600")) \
	{ WM_CLIPBOARDUPDATE, 0, 0, 0, AfxSig_v_v_v, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnClipboardUpdate)) },

#endif /* _WIN32_WINNT >= 0x0600 */

#define ON_WM_QUERYNEWPALETTE() \
	{ WM_QUERYNEWPALETTE, 0, 0, 0, AfxSig_bv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< BOOL (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnQueryNewPalette)) },

#define ON_WM_PALETTECHANGED() \
	{ WM_PALETTECHANGED, 0, 0, 0, AfxSig_vW, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(CWnd*) > ( &ThisClass :: OnPaletteChanged)) },

#define ON_WM_PALETTEISCHANGING() \
	{ WM_PALETTEISCHANGING, 0, 0, 0, AfxSig_vW, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(CWnd*) > ( &ThisClass :: OnPaletteIsChanging)) },

#define ON_WM_DROPFILES() \
	{ WM_DROPFILES, 0, 0, 0, AfxSig_vh, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(HDROP) > ( &ThisClass :: OnDropFiles)) },

#define ON_WM_WINDOWPOSCHANGING() \
	{ WM_WINDOWPOSCHANGING, 0, 0, 0, AfxSig_vPOS, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(WINDOWPOS*) > ( &ThisClass :: OnWindowPosChanging)) },

#define ON_WM_WINDOWPOSCHANGED() \
	{ WM_WINDOWPOSCHANGED, 0, 0, 0, AfxSig_vPOS, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(WINDOWPOS*) > ( &ThisClass :: OnWindowPosChanged)) },

#define ON_WM_EXITMENULOOP() \
	{ WM_EXITMENULOOP, 0, 0, 0, AfxSig_vb, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(BOOL) > ( &ThisClass :: OnExitMenuLoop)) },

#define ON_WM_ENTERMENULOOP() \
	{ WM_ENTERMENULOOP, 0, 0, 0, AfxSig_vb, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(BOOL) > ( &ThisClass :: OnEnterMenuLoop)) },

#define ON_WM_STYLECHANGED() \
	{ WM_STYLECHANGED, 0, 0, 0, AfxSig_viSS, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(int, LPSTYLESTRUCT) > ( &ThisClass :: OnStyleChanged)) },

#define ON_WM_STYLECHANGING() \
	{ WM_STYLECHANGING, 0, 0, 0, AfxSig_viSS, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(int, LPSTYLESTRUCT) > ( &ThisClass :: OnStyleChanging)) },

#define ON_WM_SIZING() \
	{ WM_SIZING, 0, 0, 0, AfxSig_vwSIZING, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, LPRECT) > ( &ThisClass :: OnSizing)) },

#define ON_WM_MOVING() \
	{ WM_MOVING, 0, 0, 0, AfxSig_vwMOVING, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, LPRECT) > ( &ThisClass :: OnMoving)) },

#define ON_WM_ENTERSIZEMOVE() \
	{ WM_ENTERSIZEMOVE, 0, 0, 0, AfxSig_v_v_v, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnEnterSizeMove)) },

#define ON_WM_EXITSIZEMOVE() \
	{ WM_EXITSIZEMOVE, 0, 0, 0, AfxSig_v_v_v, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnExitSizeMove)) },

#define ON_WM_CAPTURECHANGED() \
	{ WM_CAPTURECHANGED, 0, 0, 0, AfxSig_vW2, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(CWnd*) > ( &ThisClass :: OnCaptureChanged)) },

#define ON_WM_DEVICECHANGE() \
	{ WM_DEVICECHANGE, 0, 0, 0, AfxSig_bwl, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< BOOL (AFX_MSG_CALL CWnd::*)(UINT, DWORD_PTR) > ( &ThisClass :: OnDeviceChange)) },

#define ON_WM_POWERBROADCAST() \
	{ WM_POWERBROADCAST, 0, 0, 0, AfxSig_u_u_u, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< UINT (AFX_MSG_CALL CWnd::*)(UINT, UINT) > ( &ThisClass :: OnPowerBroadcast)) },

#define ON_WM_USERCHANGED() \
	{ WM_USERCHANGED, 0, 0, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnUserChanged)) },

#if(_WIN32_WINNT >= 0x0500 && WINVER >= 0x0500)

#define ON_WM_CHANGEUISTATE() \
	{ WM_CHANGEUISTATE, 0, 0, 0, AfxSig_vww2, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT) > ( &ThisClass :: OnChangeUIState)) },

#define ON_WM_UPDATEUISTATE() \
	{ WM_UPDATEUISTATE, 0, 0, 0, AfxSig_vww2, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT) > ( &ThisClass :: OnUpdateUIState)) },

#define ON_WM_QUERYUISTATE() \
	{ WM_QUERYUISTATE, 0, 0, 0, AfxSig_wv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< UINT (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnQueryUIState)) },
#else

#define ON_WM_CHANGEUISTATE() \
	__pragma(message("WM_CHANGEUISTATE requires _WIN32_WINNT and WINVER to be >= 0x500")) \
	{ WM_CHANGEUISTATE, 0, 0, 0, AfxSig_vww2, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT) > ( &ThisClass :: OnChangeUIState)) },

#define ON_WM_UPDATEUISTATE() \
	__pragma(message("WM_UPDATEUISTATE requires _WIN32_WINNT and WINVER to be >= 0x500")) \
	{ WM_UPDATEUISTATE, 0, 0, 0, AfxSig_vww2, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT) > ( &ThisClass :: OnUpdateUIState)) },

#define ON_WM_QUERYUISTATE() \
	__pragma(message("WM_QUERYUISTATE requires _WIN32_WINNT and WINVER to be >= 0x500")) \
	{ WM_QUERYUISTATE, 0, 0, 0, AfxSig_wv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< UINT (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnQueryUIState)) },

#endif // _WIN32_WINNT >= 0x0500 && WINVER >= 0x0500

#if(_WIN32_WINNT >= 0x0501)
#define ON_WM_THEMECHANGED() \
	{ WM_THEMECHANGED, 0, 0, 0, AfxSig_l, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< LRESULT (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnThemeChanged)) },
#else
#define ON_WM_THEMECHANGED \
	__pragma(message("ON_WM_THEMECHANGED requires _WIN32_WINNT >= 0x0501")) \
	{ WM_THEMECHANGED, 0, 0, 0, AfxSig_l, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< LRESULT (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnThemeChanged)) },
#endif	 // _WIN32_WINNT >= 0x0501

#if(_WIN32_WINNT >= 0x0600)

#define ON_WM_DWMCOMPOSITIONCHANGED() \
	{ WM_DWMCOMPOSITIONCHANGED, 0, 0, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnCompositionChanged)) },

#define ON_WM_DWMNCRENDERINGCHANGED() \
	{ WM_DWMNCRENDERINGCHANGED, 0, 0, 0, AfxSig_vb, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(BOOL) > ( &ThisClass :: OnNcRenderingChanged)) },

#define ON_WM_DWMCOLORIZATIONCOLORCHANGED() \
	{ WM_DWMCOLORIZATIONCOLORCHANGED, 0, 0, 0, AfxSig_vww, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(DWORD, BOOL) > ( &ThisClass :: OnColorizationColorChanged)) },

#define ON_WM_DWMWINDOWMAXIMIZEDCHANGE() \
	{ WM_DWMWINDOWMAXIMIZEDCHANGE, 0, 0, 0, AfxSig_vb, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(BOOL) > ( &ThisClass :: OnWindowMaximizedChange)) },

#else

#define ON_WM_DWMCOMPOSITIONCHANGED \
	__pragma(message("WM_DWMCOMPOSITIONCHANGED requires _WIN32_WINNT >= 0x0600")) \
	{ WM_DWMCOMPOSITIONCHANGED, 0, 0, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnCompositionChanged)) },

#define ON_WM_DWMNCRENDERINGCHANGED() \
	__pragma(message("WM_DWMNCRENDERINGCHANGED requires _WIN32_WINNT >= 0x0600")) \
	{ WM_DWMNCRENDERINGCHANGED, 0, 0, 0, AfxSig_vb, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(BOOL) > ( &ThisClass :: OnRenderingChanged)) },

#define ON_WM_DWMCOLORIZATIONCOLORCHANGED() \
	__pragma(message("WM_DWMCOLORIZATIONCOLORCHANGED requires _WIN32_WINNT >= 0x0600")) \
	{ WM_DWMCOLORIZATIONCOLORCHANGED, 0, 0, 0, AfxSig_vww, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(DWORD, BOOL) > ( &ThisClass :: OnColorizationColorChanged)) },

#define ON_WM_DWMWINDOWMAXIMIZEDCHANGE() \
	__pragma(message("WM_DWMWINDOWMAXIMIZEDCHANGE requires _WIN32_WINNT >= 0x0600")) \
	{ WM_DWMWINDOWMAXIMIZEDCHANGE, 0, 0, 0, AfxSig_vb, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(BOOL) > ( &ThisClass :: OnWindowMaximizedChange)) },

#endif

/////////////////////////////////////////////////////////////////////////////
// Message map tables for Control Notification messages

// Static control notification codes
#define ON_STN_CLICKED(id, memberFxn) \
	ON_CONTROL(STN_CLICKED, id, memberFxn)
#define ON_STN_DBLCLK(id, memberFxn) \
	ON_CONTROL(STN_DBLCLK, id, memberFxn)
#define ON_STN_ENABLE(id, memberFxn) \
	ON_CONTROL(STN_ENABLE, id, memberFxn)
#define ON_STN_DISABLE(id, memberFxn) \
	ON_CONTROL(STN_DISABLE, id, memberFxn)


// Edit Control Notification Codes
#define ON_EN_SETFOCUS(id, memberFxn) \
	ON_CONTROL(EN_SETFOCUS, id, memberFxn)
#define ON_EN_KILLFOCUS(id, memberFxn) \
	ON_CONTROL(EN_KILLFOCUS, id, memberFxn)
#define ON_EN_CHANGE(id, memberFxn) \
	ON_CONTROL(EN_CHANGE, id, memberFxn)
#define ON_EN_UPDATE(id, memberFxn) \
	ON_CONTROL(EN_UPDATE, id, memberFxn)
#define ON_EN_ERRSPACE(id, memberFxn) \
	ON_CONTROL(EN_ERRSPACE, id, memberFxn)
#define ON_EN_MAXTEXT(id, memberFxn) \
	ON_CONTROL(EN_MAXTEXT, id, memberFxn)
#define ON_EN_HSCROLL(id, memberFxn) \
	ON_CONTROL(EN_HSCROLL, id, memberFxn)
#define ON_EN_VSCROLL(id, memberFxn) \
	ON_CONTROL(EN_VSCROLL, id, memberFxn)

#if(_WIN32_WINNT >= 0x0500)
#define ON_EN_ALIGN_LTR_EC(id, memberFxn) \
	ON_CONTROL(EN_ALIGN_LTR_EC, id, memberFxn)
#define ON_EN_ALIGN_RTL_EC(id, memberFxn) \
	ON_CONTROL(EN_ALIGN_RTL_EC, id, memberFxn)
#else
#define ON_EN_ALIGN_LTR_EC(id, memberFxn) \
	__pragma(message("EN_ALIGN_LTR_EC requires _WIN32_WINNT to be >= 0x0500")) \
	ON_CONTROL(EN_ALIGN_LTR_EC, id, memberFxn)
#define ON_EN_ALIGN_RTL_EC(id, memberFxn) \
	__pragma(message("EN_ALIGN_RTL_EC requires _WIN32_WINNT to be >= 0x0500")) \
	ON_CONTROL(EN_ALIGN_RTL_EC, id, memberFxn)
#endif // _WIN32_WINNT >= 0x0500

// Richedit Control Notification Codes
#define ON_EN_IMECHANGE(id, memberFxn) \
	ON_CONTROL(EN_IMECHANGE, id, memberFxn)
#define ON_EN_ALIGNLTR(id, memberFxn) \
	ON_CONTROL(EN_ALIGNLTR, id, memberFxn)
#define ON_EN_ALIGNRTL(id, memberFxn) \
	ON_CONTROL(EN_ALIGNRTL, id, memberFxn)

// Animation Control Notification Codes
#define ON_ACN_START(id, memberFxn) \
	ON_CONTROL(ACN_START, id, memberFxn)
#define ON_ACN_STOP(id, memberFxn) \
	ON_CONTROL(ACN_STOP, id, memberFxn)

// User Button Notification Codes
#define ON_BN_CLICKED(id, memberFxn) \
	ON_CONTROL(BN_CLICKED, id, memberFxn)
#define ON_BN_DOUBLECLICKED(id, memberFxn) \
	ON_CONTROL(BN_DOUBLECLICKED, id, memberFxn)
#define ON_BN_SETFOCUS(id, memberFxn) \
	ON_CONTROL(BN_SETFOCUS, id, memberFxn)
#define ON_BN_KILLFOCUS(id, memberFxn) \
	ON_CONTROL(BN_KILLFOCUS, id, memberFxn)

// old BS_USERBUTTON button notifications - obsolete in Win31
#define ON_BN_PAINT(id, memberFxn) \
	ON_CONTROL(BN_PAINT, id, memberFxn)
#define ON_BN_HILITE(id, memberFxn) \
	ON_CONTROL(BN_HILITE, id, memberFxn)
#define ON_BN_UNHILITE(id, memberFxn) \
	ON_CONTROL(BN_UNHILITE, id, memberFxn)
#define ON_BN_DISABLE(id, memberFxn) \
	ON_CONTROL(BN_DISABLE, id, memberFxn)

// Listbox Notification Codes
#define ON_LBN_ERRSPACE(id, memberFxn) \
	ON_CONTROL(LBN_ERRSPACE, id, memberFxn)
#define ON_LBN_SELCHANGE(id, memberFxn) \
	ON_CONTROL(LBN_SELCHANGE, id, memberFxn)
#define ON_LBN_DBLCLK(id, memberFxn) \
	ON_CONTROL(LBN_DBLCLK, id, memberFxn)
#define ON_LBN_SELCANCEL(id, memberFxn) \
	ON_CONTROL(LBN_SELCANCEL, id, memberFxn)
#define ON_LBN_SETFOCUS(id, memberFxn) \
	ON_CONTROL(LBN_SETFOCUS, id, memberFxn)
#define ON_LBN_KILLFOCUS(id, memberFxn) \
	ON_CONTROL(LBN_KILLFOCUS, id, memberFxn)

// Check Listbox Notification codes
#define CLBN_CHKCHANGE (40)
#define ON_CLBN_CHKCHANGE(id, memberFxn) \
	ON_CONTROL(CLBN_CHKCHANGE, id, memberFxn)

// Combo Box Notification Codes
#define ON_CBN_ERRSPACE(id, memberFxn) \
	ON_CONTROL(CBN_ERRSPACE, id, memberFxn)
#define ON_CBN_SELCHANGE(id, memberFxn) \
	ON_CONTROL(CBN_SELCHANGE, id, memberFxn)
#define ON_CBN_DBLCLK(id, memberFxn) \
	ON_CONTROL(CBN_DBLCLK, id, memberFxn)
#define ON_CBN_SETFOCUS(id, memberFxn) \
	ON_CONTROL(CBN_SETFOCUS, id, memberFxn)
#define ON_CBN_KILLFOCUS(id, memberFxn) \
	ON_CONTROL(CBN_KILLFOCUS, id, memberFxn)
#define ON_CBN_EDITCHANGE(id, memberFxn) \
	ON_CONTROL(CBN_EDITCHANGE, id, memberFxn)
#define ON_CBN_EDITUPDATE(id, memberFxn) \
	ON_CONTROL(CBN_EDITUPDATE, id, memberFxn)
#define ON_CBN_DROPDOWN(id, memberFxn) \
	ON_CONTROL(CBN_DROPDOWN, id, memberFxn)
#define ON_CBN_CLOSEUP(id, memberFxn)  \
	ON_CONTROL(CBN_CLOSEUP, id, memberFxn)
#define ON_CBN_SELENDOK(id, memberFxn)  \
	ON_CONTROL(CBN_SELENDOK, id, memberFxn)
#define ON_CBN_SELENDCANCEL(id, memberFxn)  \
	ON_CONTROL(CBN_SELENDCANCEL, id, memberFxn)

/////////////////////////////////////////////////////////////////////////////
// User extensions for message map entries

// for Windows messages
#define ON_MESSAGE(message, memberFxn) \
	{ message, 0, 0, 0, AfxSig_lwl, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< LRESULT (AFX_MSG_CALL CWnd::*)(WPARAM, LPARAM) > \
		(memberFxn)) },

// for Registered Windows messages
#define ON_REGISTERED_MESSAGE(nMessageVariable, memberFxn) \
	{ 0xC000, 0, 0, 0, (UINT_PTR)(UINT*)(&nMessageVariable), \
		/*implied 'AfxSig_lwl'*/ \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< LRESULT (AFX_MSG_CALL CWnd::*)(WPARAM, LPARAM) > \
		(memberFxn)) },

// for Thread messages
#define ON_THREAD_MESSAGE(message, memberFxn) \
	{ message, 0, 0, 0, AfxSig_vwl, \
		(AFX_PMSG)(AFX_PMSGT) \
		(static_cast< void (AFX_MSG_CALL CWinThread::*)(WPARAM, LPARAM) > \
		(memberFxn)) },

// for Registered Windows messages
#define ON_REGISTERED_THREAD_MESSAGE(nMessageVariable, memberFxn) \
	{ 0xC000, 0, 0, 0, (UINT_PTR)(UINT*)(&nMessageVariable), \
		/*implied 'AfxSig_vwl'*/ \
		(AFX_PMSG)(AFX_PMSGT) \
		(static_cast< void (AFX_MSG_CALL CWinThread::*)(WPARAM, LPARAM) > \
		(memberFxn)) },

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxmultidoctemplateex.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

//--------------------------------------------------------
// The class CMultiDocTemplateEx is created for access
// to protected member 'uiMenuResId' of CMultiDocTemplate!
//--------------------------------------------------------

#pragma warning (disable : 4510 4610)

class CMultiDocTemplateEx : public CMultiDocTemplate
{
public:
	UINT GetResId () const { return m_nIDResource; }
};

#pragma warning (default : 4510 4610)

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxmultipaneframewnd.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxpaneframewnd.h"
#include "afxpanecontainermanager.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMultiPaneFrameWnd window

class CMultiPaneFrameWnd : public CPaneFrameWnd
{
	DECLARE_SERIAL(CMultiPaneFrameWnd)
// Construction
public:
	CMultiPaneFrameWnd();

// Attributes
public:
	CPaneContainerManager& GetPaneContainerManager() { return m_barContainerManager; }
	virtual BOOL CanBeDockedToPane(const CDockablePane* pDockingBar) const;

// Operations
public:
	virtual void AddPane(CBasePane* pWnd);
	virtual void RemovePane(CBasePane* pBar, BOOL bDestroy = FALSE, BOOL bNoDelayedDestroy = TRUE);
	virtual void ReplacePane(CBasePane* pBarOrg, CBasePane* pBarReplaceWith);
	virtual BOOL DockFrame(CPaneFrameWnd* pDockedFrame, AFX_DOCK_METHOD dockMethod);
	virtual BOOL DockPane(CDockablePane* pDockedBar);

	virtual int GetPaneCount() const { return m_barContainerManager.GetPaneCount(); }
	virtual int GetVisiblePaneCount() const { return m_barContainerManager.GetVisiblePaneCount(); }
	virtual CWnd* GetFirstVisiblePane() const { return m_barContainerManager.GetFirstVisiblePane(); }
	virtual CWnd* GetPane() const;

	virtual BOOL CanBeAttached() const { return m_barContainerManager.CanBeAttached(); }

	virtual void CloseMiniFrame();

	virtual BOOL SetPreDockState(AFX_PREDOCK_STATE preDockState, CBasePane* pBarToDock = NULL, AFX_DOCK_METHOD dockMethod = DM_MOUSE);

	virtual BOOL SaveState(LPCTSTR lpszProfileName = NULL, UINT uiID = (UINT) -1);
	virtual BOOL LoadState(LPCTSTR lpszProfileName = NULL, UINT uiID = (UINT) -1);

	virtual void Serialize(CArchive& ar);
	virtual void SetDockState(CDockingManager* pDockManager);
	virtual void StoreRecentDockSiteInfo(CPane* pBar);
	virtual void StoreRecentTabRelatedInfo(CDockablePane* pDockingBar, CDockablePane* pTabbedBar);

	virtual BOOL AddRecentPane(CDockablePane* pBar);
	virtual void DockRecentPaneToMainFrame(CDockablePane* pBar);

	virtual void OnShowPane(CDockablePane* pBar, BOOL bShow);

	virtual BOOL InsertPane(CBasePane* pControlBar, CBasePane* pTarget, BOOL bAfter);

	virtual void CalcExpectedDockedRect(CWnd* pWndToDock, CPoint ptMouse, CRect& rectResult, BOOL& bDrawTab, CDockablePane** ppTargetBar);
	virtual CBasePane* PaneFromPoint(CPoint point, int nSensitivity, BOOL bCheckVisibility);

	virtual void RemoveNonValidPanes();

	virtual void OnSetRollUpTimer();
	virtual void OnKillRollUpTimer();

	virtual void AdjustPaneFrames();

	virtual void OnDockToRecentPos();
	virtual void ConvertToTabbedDocument();

	void SetLastFocusedPane(HWND hwnd) {m_hWndLastFocused = hwnd;}

// Implementation
public:
	virtual ~CMultiPaneFrameWnd();

	virtual void CheckGripperVisibility();
	virtual void OnPaneRecalcLayout();
	virtual void AdjustLayout() {}
	virtual CString GetCaptionText();

protected:
	//{{AFX_MSG(CMultiPaneFrameWnd)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnSizing(UINT fwSide, LPRECT pRect);
	afx_msg void OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg LRESULT OnIdleUpdateCmdUI(WPARAM wParam, LPARAM);
	afx_msg LRESULT OnCheckEmptyState(WPARAM, LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	virtual void SaveRecentFloatingState();
	virtual CDockablePane* DockPaneStandard(BOOL& bWasDocked);

protected:
	CPaneContainerManager m_barContainerManager;
	HWND                 m_hWndLastFocused;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxodlgs.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXODLGS_H__
#define __AFXODLGS_H__

#ifdef _AFX_NO_OLE_SUPPORT
	#error OLE classes not supported in this library variant.
#endif

#pragma once

#ifndef __AFXOLE_H__
	#include <afxole.h>
#endif

#ifndef __AFXDLGS_H__
	#include <afxdlgs.h>
#endif

// include OLE dialog/helper APIs
#ifndef _OLEDLG_H_
	#include <oledlg.h>
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// AFXODLGS.H - MFC OLE dialogs

// Classes declared in this file

//CCommonDialog
	class COleDialog;                   // base class for OLE dialog wrappers
		class COleInsertDialog;         // insert object dialog
		class COleConvertDialog;        // convert dialog
		class COleChangeIconDialog;     // change icon dialog
		class COlePasteSpecialDialog;   // paste special dialog
		class COleLinksDialog;          // edit links dialog
			class COleUpdateDialog;     // update links/embeddings dialog
		class COleBusyDialog;           // used for
		class COlePropertiesDialog;
		class COleChangeSourceDialog;

/////////////////////////////////////////////////////////////////////////////

// AFXDLL support
#undef AFX_DATA
#define AFX_DATA AFX_OLE_DATA

/////////////////////////////////////////////////////////////////////////////
// COleUILinkInfo -- used internally to implement
// IOleUILinkInfo and IOleUILinkContainer
// used by COleLinksDialog and COleChangeSourceDialog

class COleUILinkInfo : public IOleUILinkInfo
{
public:
	COleUILinkInfo(COleDocument* pDocument);
	COleUILinkInfo(COleClientItem *pItem);

// Implementation
	COleDocument* m_pDocument;          // document being manipulated
	COleClientItem* m_pSelectedItem;    // primary selected item in m_pDocument
	POSITION m_pos;						// used during link enumeration
	COleClientItem *m_pItem;

	BOOL m_bUpdateLinks;                // update links?
	BOOL m_bUpdateEmbeddings;           // update embeddings?

	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();
	STDMETHOD(QueryInterface)(REFIID, LPVOID*);

	// IOleUILinkContainer
	STDMETHOD_(DWORD,GetNextLink)(DWORD);
	STDMETHOD(SetLinkUpdateOptions)(DWORD, DWORD);
	STDMETHOD(GetLinkUpdateOptions)(DWORD, LPDWORD);
	STDMETHOD(SetLinkSource)(DWORD, _In_count_(_LenFileName) LPTSTR, ULONG _LenFileName, ULONG*, BOOL);
	STDMETHOD(GetLinkSource)(DWORD, _Deref_out_ LPTSTR*, ULONG*, _Deref_out_ LPTSTR*, _Deref_out_ LPTSTR*, BOOL*,
		BOOL*);
	STDMETHOD(OpenLinkSource)(DWORD);
	STDMETHOD(UpdateLink)(DWORD, BOOL, BOOL);
	STDMETHOD(CancelLink)(DWORD);
	// IOleUILinkInfo
	STDMETHOD(GetLastUpdate)(DWORD dwLink, FILETIME* lpLastUpdate);

private:
	COleClientItem* GetLinkItem(DWORD dwLink);
};

/////////////////////////////////////////////////////////////////////////////
// Wrappers for OLE UI dialogs

class AFX_NOVTABLE COleDialog : public CCommonDialog
{
	DECLARE_DYNAMIC(COleDialog)

// Attributes
public:
	UINT GetLastError() const;

// Implementation
public:
	int MapResult(UINT nResult);
	explicit COleDialog(CWnd* pParentWnd);
	virtual ~COleDialog() = 0 { }
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	UINT m_nLastError;
};

/////////////////////////////////////////////////////////////////////////////
// COleInsertDialog

class COleInsertDialog : public COleDialog
{
	DECLARE_DYNAMIC(COleInsertDialog)

// Attributes
public:
	OLEUIINSERTOBJECT m_io; // structure for OleUIInsertObject

// Constructors
	/* explicit */ COleInsertDialog(DWORD dwFlags = IOF_SELECTCREATENEW,
		CWnd* pParentWnd = NULL);

// Operations
	virtual INT_PTR DoModal();
	INT_PTR DoModal(DWORD dwFlags);
	BOOL CreateItem(COleClientItem* pItem);
		// call after DoModal to create item based on dialog data

// Attributes (after DoModal returns IDOK)
	enum Selection { createNewItem, insertFromFile, linkToFile };
	UINT GetSelectionType() const;
		// return type of selection made

	CString GetPathName() const;  // return full path name
	REFCLSID GetClassID() const;    // get class ID of new item

	DVASPECT GetDrawAspect() const;
		// DVASPECT_CONTENT or DVASPECT_ICON
	HGLOBAL GetIconicMetafile() const;
		// returns HGLOBAL to METAFILEPICT struct with iconic data

// Implementation
public:
	virtual ~COleInsertDialog();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif

	enum FilterFlags {
		DocObjectsOnly = 1,
		ControlsOnly = 2,
	};

protected:
	TCHAR m_szFileName[_MAX_PATH];
		// contains full path name after return

	void AddClassIDToList(LPCLSID& lpList, int& nListCount,
		int& nBufferLen, LPCLSID pNewID);
};

/////////////////////////////////////////////////////////////////////////////
// COleConvertDialog

class COleConvertDialog : public COleDialog
{
	DECLARE_DYNAMIC(COleConvertDialog)

// Attributes
public:
	OLEUICONVERT m_cv;  // structure for OleUIConvert

// Constructors
	explicit COleConvertDialog(COleClientItem* pItem,
		DWORD dwFlags = CF_SELECTCONVERTTO, CLSID* pClassID = NULL,
		CWnd* pParentWnd = NULL);

// Operations
	virtual INT_PTR DoModal();
		// just display the dialog and collect convert info
	BOOL DoConvert(COleClientItem* pItem);
		// do the conversion on pItem (after DoModal == IDOK)

// Attributes (after DoModal returns IDOK)
	enum Selection { noConversion, convertItem, activateAs };
	UINT GetSelectionType() const;

	HGLOBAL GetIconicMetafile() const;  // will return NULL if same as before
	REFCLSID GetClassID() const;    // get class ID to convert or activate as
	DVASPECT GetDrawAspect() const; // get new draw aspect

// Implementation
public:
	virtual ~COleConvertDialog();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// COleChangeIconDialog

class COleChangeIconDialog : public COleDialog
{
	DECLARE_DYNAMIC(COleChangeIconDialog)

// Attributes
public:
	OLEUICHANGEICON m_ci;   // structure for OleUIChangeIcon

// Constructors
	explicit COleChangeIconDialog(COleClientItem* pItem,
		DWORD dwFlags = CIF_SELECTCURRENT,
		CWnd* pParentWnd = NULL);

// Operations
	virtual INT_PTR DoModal();
	BOOL DoChangeIcon(COleClientItem* pItem);

// Attributes
	HGLOBAL GetIconicMetafile() const;

// Implementation
public:
	virtual ~COleChangeIconDialog();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// COlePasteSpecialDialog

class COlePasteSpecialDialog : public COleDialog
{
	DECLARE_DYNAMIC(COlePasteSpecialDialog)

// Attributes
public:
	OLEUIPASTESPECIAL m_ps; // structure for OleUIPasteSpecial

// Constructors
	/* explicit */ COlePasteSpecialDialog(DWORD dwFlags = PSF_SELECTPASTE,
		COleDataObject* pDataObject = NULL, CWnd *pParentWnd = NULL);

// Operations
	OLEUIPASTEFLAG AddLinkEntry(UINT cf);
	void AddFormat(const FORMATETC& formatEtc, _In_z_ LPTSTR lpszFormat,
		_In_z_ LPTSTR lpszResult, DWORD flags);
	void AddFormat(UINT cf, DWORD tymed, UINT nFormatID, BOOL bEnableIcon,
		BOOL bLink);
	void AddStandardFormats(BOOL bEnableLink = TRUE);

	virtual INT_PTR DoModal();
	BOOL CreateItem(COleClientItem *pNewItem);
		// creates a standard OLE item from selection data

// Attributes (after DoModal returns IDOK)
	int GetPasteIndex() const;      // resulting index to use for paste

	enum Selection { pasteLink = 1, pasteNormal = 2, pasteStatic = 3, pasteOther = 4};
	UINT GetSelectionType() const;
		// get selection type (pasteLink, pasteNormal, pasteStatic)

	DVASPECT GetDrawAspect() const;
		// DVASPECT_CONTENT or DVASPECT_ICON
	HGLOBAL GetIconicMetafile() const;
		// returns HGLOBAL to METAFILEPICT struct with iconic data

// Implementation
public:
	virtual ~COlePasteSpecialDialog();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
	virtual void AssertValid() const;
#endif
	unsigned int m_arrLinkTypes[8];
		// size limit imposed by MFCUIx32.DLL library
};

/////////////////////////////////////////////////////////////////////////////
// COleLinksDialog

class COleLinksDialog : public COleDialog
{
	DECLARE_DYNAMIC(COleLinksDialog)

// Attributes
public:
	OLEUIEDITLINKS m_el;    // structure for OleUIEditLinks

// Constructors
	COleLinksDialog(COleDocument* pDoc, CView* pView, DWORD dwFlags = 0,
		CWnd* pParentWnd = NULL);

// Operations
	virtual INT_PTR DoModal();  // display the dialog and edit links

// Implementation
public:
	virtual ~COleLinksDialog();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
	virtual void AssertValid() const;
#endif

public:
	COleUILinkInfo m_xLinkInfo; // implements IOleUILinkContainer
};

/////////////////////////////////////////////////////////////////////////////
// COleUpdateDialog

class COleUpdateDialog : public COleLinksDialog
{
	DECLARE_DYNAMIC(COleUpdateDialog)

// Constructors
public:
	explicit COleUpdateDialog(COleDocument* pDoc,
		BOOL bUpdateLinks = TRUE, BOOL bUpdateEmbeddings = FALSE,
		CWnd* pParentWnd = NULL);

// Operations
	virtual INT_PTR DoModal();

// Implementation
public:
	virtual ~COleUpdateDialog();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	CString m_strCaption;   // caption for the dialog
};

/////////////////////////////////////////////////////////////////////////////
// COleBusyDialog - useful in managing concurrency

class COleBusyDialog : public COleDialog
{
	DECLARE_DYNAMIC(COleBusyDialog)

// Attributes
public:
	OLEUIBUSY m_bz;

// Constructors
	explicit COleBusyDialog(HTASK htaskBusy, BOOL bNotResponding = FALSE,
		DWORD dwFlags = 0, CWnd* pParentWnd = NULL);

// Operations
	virtual INT_PTR DoModal();

	enum Selection { switchTo = 1, retry = 2, callUnblocked = 3 };
	UINT GetSelectionType() const;

// Implementation
public:
	~COleBusyDialog();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	Selection m_selection;  // selection after DoModal returns IDOK
};

/////////////////////////////////////////////////////////////////////////////
// COleEditProperties

class COlePropertiesDialog : public COleDialog
{
	DECLARE_DYNAMIC(COlePropertiesDialog)

// Attributes
public:
	OLEUIOBJECTPROPS m_op;      // structure for OleUIObjectProperties
	OLEUIGNRLPROPS m_gp;        // specific to "General" page
	OLEUIVIEWPROPS m_vp;        // specific to "View" page
	OLEUILINKPROPS m_lp;        // specific to "Link" page
	PROPSHEETHEADER m_psh;      // PROPSHEETHEADER for customization

// Constructors
public:
	COlePropertiesDialog(COleClientItem* pItem,
		UINT nScaleMin = 10, UINT nScaleMax = 500, CWnd* pParentWnd = NULL);

// Operations
	virtual INT_PTR DoModal();

// Overridables
	virtual BOOL OnApplyScale(
		COleClientItem* pItem, int nCurrentScale, BOOL bRelativeToOrig);

// Implementation
public:
	COleDocument* m_pDoc;

#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
	virtual void AssertValid() const;
#endif
	virtual BOOL OnInitDialog();

	BEGIN_INTERFACE_PART(OleUIObjInfo, IOleUIObjInfo)
		INIT_INTERFACE_PART(COlePropertiesDialog, OleUIObjInfo)
		STDMETHOD(GetObjectInfo) (THIS_ DWORD dwObject,
			DWORD* lpdwObjSize, LPTSTR* lplpszLabel,
			LPTSTR* lplpszType, LPTSTR* lplpszShortType,
			LPTSTR* lplpszLocation);
		STDMETHOD(GetConvertInfo) (THIS_ DWORD dwObject,
			CLSID* lpClassID, WORD* lpwFormat,
			CLSID* lpConvertDefaultClassID,
			LPCLSID* lplpClsidExclude, UINT* lpcClsidExclude);
		STDMETHOD(ConvertObject) (THIS_ DWORD dwObject, REFCLSID clsidNew);
		STDMETHOD(GetViewInfo) (THIS_ DWORD dwObject,
			HGLOBAL* phMetaPict, DWORD* pdvAspect, int* pnCurrentScale);
		STDMETHOD(SetViewInfo) (THIS_ DWORD dwObject,
			HGLOBAL hMetaPict, DWORD dvAspect,
			int nCurrentScale, BOOL bRelativeToOrig);
	END_INTERFACE_PART(OleUIObjInfo)
	COleUILinkInfo m_xLinkInfo; // implements IOleUILinkContainer
};

/////////////////////////////////////////////////////////////////////////////
// COleChangeSourceDialog

class COleChangeSourceDialog : public COleDialog
{
	DECLARE_DYNAMIC(COleChangeSourceDialog)

// Attributes
public:
	OLEUICHANGESOURCE m_cs; // structure for OleUIChangeSource

// Constructors
public:
	explicit COleChangeSourceDialog(COleClientItem* pItem, CWnd* pParentWnd = NULL);

// Operations
	virtual INT_PTR DoModal();

// Attributes (after DoModal returns IDOK)
	BOOL IsValidSource();
	CString GetDisplayName();
	CString GetFileName();
	CString GetItemName();
	CString GetFromPrefix();
	CString GetToPrefix();

// Implementation
public:
	COleUILinkInfo m_xLinkInfo;

	virtual ~COleChangeSourceDialog();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
	virtual void AssertValid() const;
#endif
	virtual void PreInitDialog();
};

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXODLGS_INLINE AFX_INLINE
#include <afxole.inl>
#undef _AFXODLGS_INLINE
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXODLGS_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxmt.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXMT.H

#pragma once

#ifndef __AFXMT_H__
#error afxmt.inl requires afxmt.h to be included first
#endif

#ifdef _AFXMT_INLINE

/* Special considerations for this file
Classes CSyncObject, CSemaphore, CEvent, CSingleLock, CMultiLock and CCriticalSection 
have the same names as classes in the ::ATL namespace. 
Typically, the ATL headers perform using namespace ATL, meaning that references 
to these classes would be ambiguous.
We want it to be possible to include ATL headers before including this file.
Thus, all references to the classes listed above from anywhere within this file 
should be preceded by :: to ensure that they unambiguously refer to the MFC classes 
in the global namespace */

_AFXMT_INLINE ::CSyncObject::operator HANDLE() const
{ 
	return m_hObject;
}

_AFXMT_INLINE BOOL (::CSemaphore::Unlock())
{ 
	return Unlock(1, NULL); 
}

_AFXMT_INLINE BOOL (::CEvent::SetEvent())
{ 
	ASSERT(m_hObject != NULL); 
	
	return ::SetEvent(m_hObject); 	
}

_AFXMT_INLINE BOOL (::CEvent::PulseEvent())
{ 
	ASSERT(m_hObject != NULL); 
	
	return ::PulseEvent(m_hObject); 
}

_AFXMT_INLINE BOOL (::CEvent::ResetEvent())
{ 
	ASSERT(m_hObject != NULL); 
	
	return ::ResetEvent(m_hObject); 
}

_AFXMT_INLINE ::CSingleLock::~CSingleLock()
{ 
	Unlock(); 
}

_AFXMT_INLINE BOOL (::CSingleLock::IsLocked())
{ 
	return m_bAcquired; 
}

_AFXMT_INLINE BOOL (::CMultiLock::IsLocked(DWORD dwObject))
{ 
	ASSERT(dwObject < m_dwCount);
	
	return m_bLockedArray[dwObject]; 
}

_AFXMT_INLINE HRESULT (::CCriticalSection::Init())
{
	if (!InitializeCriticalSectionAndSpinCount(&m_sect, 0))
	{
		return HRESULT_FROM_WIN32(GetLastError());
	}
	
	return S_OK;
}

_AFXMT_INLINE ::CCriticalSection::CCriticalSection() : CSyncObject(NULL)
{ 		
	HRESULT hr = Init();
	
	if (FAILED(hr))
	{
		AtlThrow(hr);
	}		
}

_AFXMT_INLINE ::CCriticalSection::operator CRITICAL_SECTION*()
{
	return (CRITICAL_SECTION*) &m_sect; 
}

_AFXMT_INLINE ::CCriticalSection::~CCriticalSection()
{ 
	::DeleteCriticalSection(&m_sect); 
}

_AFXMT_INLINE BOOL (::CCriticalSection::Lock())
{	
	::EnterCriticalSection(&m_sect); 

	return TRUE; 
}

_AFXMT_INLINE BOOL (::CCriticalSection::Lock(DWORD dwTimeout))
{ 
	ASSERT(dwTimeout == INFINITE); 
	(void)dwTimeout; 
	
	return Lock(); 
}

_AFXMT_INLINE BOOL (::CCriticalSection::Unlock())
{ 
	::LeaveCriticalSection(&m_sect); 
	
	return TRUE; 
}

#endif //_AFXMT_INLINE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxmt.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXMT_H__
#define __AFXMT_H__

#pragma once

#ifndef __AFX_H__
	#include <afx.h>
#endif

#if _WIN32_WINNT < 0x0403
#error This file requires _WIN32_WINNT to be #defined at least to 0x0403. Value 0x0501 or higher is recommended.
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// AFXMT - MFC Multithreaded Extensions (Syncronization Objects)

// Classes declared in this file

//CObject
	class CSyncObject;
		class CSemaphore;
		class CMutex;
		class CEvent;
		class CCriticalSection;

class CSingleLock;
class CMultiLock;

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

/////////////////////////////////////////////////////////////////////////////
// Basic synchronization object

class CSyncObject : public CObject
{
	DECLARE_DYNAMIC(CSyncObject)

// Constructor
public:
	explicit CSyncObject(LPCTSTR pstrName);

// Attributes
public:
	operator HANDLE() const;
	HANDLE  m_hObject;

// Operations
	virtual BOOL Lock(DWORD dwTimeout = INFINITE);
	virtual BOOL Unlock() = 0;
	virtual BOOL Unlock(LONG /* lCount */, LPLONG /* lpPrevCount=NULL */)
		{ return TRUE; }

// Implementation
public:
	virtual ~CSyncObject();
#ifdef _DEBUG
	CString m_strName;
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	friend class CSingleLock;
	friend class CMultiLock;
};

/////////////////////////////////////////////////////////////////////////////
// CSemaphore

class CSemaphore : public CSyncObject
{
	DECLARE_DYNAMIC(CSemaphore)

// Constructor
public:
	/* explicit */ CSemaphore(LONG lInitialCount = 1, LONG lMaxCount = 1,
		LPCTSTR pstrName=NULL, LPSECURITY_ATTRIBUTES lpsaAttributes = NULL);

// Implementation
public:
	virtual ~CSemaphore();
	virtual BOOL Unlock();
	virtual BOOL Unlock(LONG lCount, LPLONG lprevCount = NULL);
};

/////////////////////////////////////////////////////////////////////////////
// CMutex

class CMutex : public CSyncObject
{
	DECLARE_DYNAMIC(CMutex)

// Constructor
public:
	/* explicit */ CMutex(BOOL bInitiallyOwn = FALSE, LPCTSTR lpszName = NULL,
		LPSECURITY_ATTRIBUTES lpsaAttribute = NULL);

// Implementation
public:
	virtual ~CMutex();
	BOOL Unlock();
};

/////////////////////////////////////////////////////////////////////////////
// CEvent

class CEvent : public CSyncObject
{
	DECLARE_DYNAMIC(CEvent)

private:
   using CSyncObject::Unlock;

// Constructor
public:
	/* explicit */ CEvent(BOOL bInitiallyOwn = FALSE, BOOL bManualReset = FALSE,
		LPCTSTR lpszNAme = NULL, LPSECURITY_ATTRIBUTES lpsaAttribute = NULL);

// Operations
public:
	BOOL SetEvent();
	BOOL PulseEvent();
	BOOL ResetEvent();
	BOOL Unlock();

// Implementation
public:
	virtual ~CEvent();
};

/////////////////////////////////////////////////////////////////////////////
// CCriticalSection

class CCriticalSection : public CSyncObject
{
	DECLARE_DYNAMIC(CCriticalSection)

private:
   using CSyncObject::Unlock;

// Constructor
public:
	CCriticalSection();

// Attributes
public:
	operator CRITICAL_SECTION*();
	CRITICAL_SECTION m_sect;

// Operations
public:
	BOOL Unlock();
	BOOL Lock();
	BOOL Lock(DWORD dwTimeout);

// Implementation
public:
	virtual ~CCriticalSection();

private:
	HRESULT Init();
};

/////////////////////////////////////////////////////////////////////////////
// CSingleLock

class CSingleLock
{
// Constructors
public:
	explicit CSingleLock(CSyncObject* pObject, BOOL bInitialLock = FALSE);

// Operations
public:
	BOOL Lock(DWORD dwTimeOut = INFINITE);
	BOOL Unlock();
	BOOL Unlock(LONG lCount, LPLONG lPrevCount = NULL);
	BOOL IsLocked();

// Implementation
public:
	~CSingleLock();

protected:
	CSyncObject* m_pObject;
	HANDLE  m_hObject;
	BOOL    m_bAcquired;
};

/////////////////////////////////////////////////////////////////////////////
// CMultiLock

class CMultiLock
{
// Constructor
public:
	CMultiLock(CSyncObject* ppObjects[], DWORD dwCount, BOOL bInitialLock = FALSE);

// Operations
public:
	DWORD Lock(DWORD dwTimeOut = INFINITE, BOOL bWaitForAll = TRUE,
		DWORD dwWakeMask = 0);
	BOOL Unlock();
	BOOL Unlock(LONG lCount, LPLONG lPrevCount = NULL);
	BOOL IsLocked(DWORD dwItem);

// Implementation
public:
	~CMultiLock();

protected:
	HANDLE  m_hPreallocated[8];
	BOOL    m_bPreallocated[8];

	CSyncObject* const * m_ppObjectArray;
	HANDLE* m_pHandleArray;
	BOOL*   m_bLockedArray;
	DWORD   m_dwCount;
};

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXMT_INLINE AFX_INLINE
#include <afxmt.inl>
#undef _AFXMT_INLINE
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif  // __AFXMT_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxocc.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXOCC_H__
#define __AFXOCC_H__

#pragma once

#ifndef _AFX_NO_OCC_SUPPORT

#include <afxtempl.h>
#include <oledb.h>
#include "olebind.h"
#include "ocdbid.h"
#include "ocdb.h"

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CDataSourceControl;
class CDataBoundProperty;

// CCmdTarget
	class COleControlContainer;
	class COleControlSite;

class COccManager;
struct _AFX_OCC_DIALOG_INFO;

#define DISPID_DATASOURCE   0x80010001
#define DISPID_DATAFIELD    0x80010002


class COleControlSiteFactory;
__declspec(selectany) extern const CLSID CLSID_WinFormsControl = 
{0xb7e7a666,0xd623,0x457f,{0xa3,0x0a,0x6a,0x49,0xa3,0xe5,0xb4,0x70}};
/////////////////////////////////////////////////////////////////////////////
// Control site factory interface - allow instantiation of different control sites

class IControlSiteFactory 
{
public:
		virtual ~IControlSiteFactory() {}
		virtual COleControlSite* CreateSite(COleControlContainer* pCtrlCont,const CControlCreationInfo& creationInfo) = 0;
};

/////////////////////////////////////////////////////////////////////////////
// Control site factory collection manager class

class CControlSiteFactoryMgr : public CNoTrackObject {
public:
	CControlSiteFactoryMgr();
	virtual ~CControlSiteFactoryMgr();
	BOOL RegisterSiteFactory(IControlSiteFactory* pFactory);
	BOOL UnregisterSiteFactory(IControlSiteFactory* pFactory);
	COleControlSite* CreateSite(COleControlContainer* pCtrlCont,const CControlCreationInfo& creationInfo);
protected:
	CList <IControlSiteFactory*,IControlSiteFactory*> m_lstFactory;
	COleControlSiteFactory* m_pOleControlSiteDefaultFactory;
};

BOOL AFXAPI AfxRegisterSiteFactory(IControlSiteFactory* pFactory);
BOOL AFXAPI AfxUnregisterSiteFactory(IControlSiteFactory* pFactory);



class CControlCreationInfo {
public:
	CControlCreationInfo();
	enum HandleKind { ReflectionType,ControlInstance,NullHandle };
	BOOL IsManaged() const;
	HandleKind m_hk;
	intptr_t   m_nHandle;
	
	CLSID m_clsid;
};


/////////////////////////////////////////////////////////////////////////////
// Control containment helper functions

DLGTEMPLATE* _AfxSplitDialogTemplate(const DLGTEMPLATE* pTemplate,
	CMapWordToPtr* pOleItemMap);

void _AfxZOrderOleControls(CWnd* pWnd, CMapWordToPtr* pOleItemMap);

/////////////////////////////////////////////////////////////////////////////
// COleControlContainer

class COleControlContainer : public CCmdTarget
{
public:
// Constructor
	explicit COleControlContainer(CWnd*  pWnd);

// Operations
	virtual void BroadcastAmbientPropertyChange(DISPID dispid);
	BOOL CreateControl(CWnd* pWndCtrl, REFCLSID clsid,
		LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, UINT nID,
		CFile* pPersist=NULL, BOOL bStorage=FALSE, BSTR bstrLicKey=NULL,
		COleControlSite** ppNewSite=NULL);
   // Overload to allow creation of default-sized controls
	BOOL CreateControl(CWnd* pWndCtrl, REFCLSID clsid,
		LPCTSTR lpszWindowName, DWORD dwStyle, const POINT* ppt,
	  const SIZE* psize, UINT nID, CFile* pPersist=NULL, BOOL bStorage=FALSE,
	  BSTR bstrLicKey=NULL, COleControlSite** ppNewSite=NULL);
	//Overload to create managed controls
	BOOL CreateControl(CWnd* pWndCtrl,const CControlCreationInfo& creationInfo,
			DWORD dwStyle, const POINT* ppt, const SIZE* psize,UINT nID);

	BOOL CreateControlCommon(CWnd* pWndCtrl, REFCLSID clsid,const CControlCreationInfo& creationInfo,
			LPCTSTR lpszWindowName, DWORD dwStyle, const POINT* ppt, const SIZE* psize,
		   UINT nID, CFile* pPersist=NULL, BOOL bStorage=FALSE, BSTR bstrLicKey=NULL, COleControlSite** ppNewSite=NULL);


	virtual COleControlSite* FindItem(UINT nID) const;
	virtual BOOL GetAmbientProp(COleControlSite* pSite, DISPID dispid,
		VARIANT* pvarResult);
	void CreateOleFont(CFont* pFont);
	void FreezeAllEvents(BOOL bFreeze);
	virtual void ScrollChildren(int dx, int dy);
	virtual void OnUIActivate(COleControlSite* pSite);
	virtual void OnUIDeactivate(COleControlSite* pSite);

	virtual void CheckDlgButton(int nIDButton, UINT nCheck);
	virtual void CheckRadioButton(int nIDFirstButton, int nIDLastButton,
		int nIDCheckButton);
	virtual CWnd* GetDlgItem(int nID) const;
	virtual void GetDlgItem(int nID, HWND* phWnd) const;
	virtual UINT GetDlgItemInt(int nID, BOOL* lpTrans, BOOL bSigned) const;
	virtual int GetDlgItemText(_In_ int nID, _Out_cap_post_count_(nMaxCount, return + 1) _Pre_notnull_ _Post_z_ LPTSTR lpStr, _In_ int nMaxCount) const;
	virtual LRESULT SendDlgItemMessage(int nID, UINT message, WPARAM wParam,
		LPARAM lParam);
	virtual void SetDlgItemInt(int nID, UINT nValue, BOOL bSigned);
	virtual void SetDlgItemText(int nID, LPCTSTR lpszString);
	virtual UINT IsDlgButtonChecked(int nIDButton) const;

   virtual BOOL HandleSetFocus();
   virtual BOOL HandleWindowlessMessage(UINT message, WPARAM wParam, 
	  LPARAM lParam, LRESULT* plResult );
   virtual BOOL OnPaint(CDC* pDC);
#ifndef _AFXDLL
	virtual void AttachControlSite(CWnd* pWnd, UINT nIDC = 0);
#else
	void AttachControlSite(CWnd* pWnd, UINT nIDC = 0);
#endif
	virtual BOOL FillListSitesOrWnds(_AFX_OCC_DIALOG_INFO* pOccDlgInfo);
// Attributes
	CWnd* m_pWnd;
	CMapPtrToPtr m_siteMap;
	CTypedPtrList< CPtrList, COleControlSiteOrWnd* > m_listSitesOrWnds;
	COLORREF m_crBack;
	COLORREF m_crFore;
	LPFONTDISP m_pOleFont;
	COleControlSite* m_pSiteUIActive;
	COleControlSite* m_pSiteCapture;
	COleControlSite* m_pSiteFocus;
	int m_nWindowlessControls;

// Implementation
public:
	virtual ~COleControlContainer();

public:
	// Interface maps
	BEGIN_INTERFACE_PART(OleIPFrame, IOleInPlaceFrame)
		INIT_INTERFACE_PART(COleControlContainer, OleIPFrame)
		STDMETHOD(GetWindow)(HWND*);
		STDMETHOD(ContextSensitiveHelp)(BOOL);
		STDMETHOD(GetBorder)(LPRECT);
		STDMETHOD(RequestBorderSpace)(LPCBORDERWIDTHS);
		STDMETHOD(SetBorderSpace)(LPCBORDERWIDTHS);
		STDMETHOD(SetActiveObject)(LPOLEINPLACEACTIVEOBJECT, LPCOLESTR);
		STDMETHOD(InsertMenus)(HMENU, LPOLEMENUGROUPWIDTHS);
		STDMETHOD(SetMenu)(HMENU, HOLEMENU, HWND);
		STDMETHOD(RemoveMenus)(HMENU);
		STDMETHOD(SetStatusText)(LPCOLESTR);
		STDMETHOD(EnableModeless)(BOOL);
		STDMETHOD(TranslateAccelerator)(LPMSG, WORD);
	END_INTERFACE_PART(OleIPFrame)

	BEGIN_INTERFACE_PART(OleContainer, IOleContainer)
		INIT_INTERFACE_PART(COleControlContainer, OleContainer)
		STDMETHOD(ParseDisplayName)(LPBINDCTX, _In_z_ LPOLESTR, ULONG*, LPMONIKER*);
		STDMETHOD(EnumObjects)(DWORD, LPENUMUNKNOWN*);
		STDMETHOD(LockContainer)(BOOL);
	END_INTERFACE_PART(OleContainer)

	DECLARE_INTERFACE_MAP()
	DECLARE_DISPATCH_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// COleControlSite

#define VT_MFCFORCEPUTREF   0x8000  // force DISPATCH_PROPERTYPUTREF

class COleControlSite : public CCmdTarget
{
public:
// Constructor
	explicit COleControlSite(COleControlContainer* pCtrlCont);

// Operations
	virtual HRESULT CreateControl(CWnd* pWndCtrl, REFCLSID clsid,
		LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, UINT nID,
		CFile* pPersist=NULL, BOOL bStorage=FALSE, BSTR bstrLicKey=NULL);
   // Overload to allow creation of default-sized controls
	virtual HRESULT CreateControl(CWnd* pWndCtrl, REFCLSID clsid,
		LPCTSTR lpszWindowName, DWORD dwStyle, const POINT* ppt,
	  const SIZE* psize, UINT nID, CFile* pPersist=NULL, BOOL bStorage=FALSE,
	  BSTR bstrLicKey=NULL);

	HRESULT CreateControl(CWnd* pWndCtrl, const CControlCreationInfo& creationInfo,
			 DWORD dwStyle, const POINT* ppt, const SIZE* psize,UINT nID);

	virtual BOOL DestroyControl();
	BOOL GetEventIID(IID* piid);
	virtual HRESULT DoVerb(LONG nVerb, LPMSG lpMsg = NULL);
	BOOL IsDefaultButton();
	DWORD GetDefBtnCode();
	void SetDefaultButton(BOOL bDefault);
	void FreezeEvents(BOOL bFreeze);

	virtual void InvokeHelperV(DISPID dwDispID, WORD wFlags, VARTYPE vtRet,
		void* pvRet, const BYTE* pbParamInfo, va_list argList);
	virtual void SetPropertyV(DISPID dwDispID, VARTYPE vtProp, va_list argList);
	virtual void AFX_CDECL InvokeHelper(DISPID dwDispID, WORD wFlags, VARTYPE vtRet,
		void* pvRet, const BYTE* pbParamInfo, ...);
	virtual void GetProperty(DISPID dwDispID, VARTYPE vtProp, void* pvProp) const;
	virtual void AFX_CDECL SetProperty(DISPID dwDispID, VARTYPE vtProp, ...);
	virtual BOOL AFX_CDECL SafeSetProperty(DISPID dwDispID, VARTYPE vtProp, ...);

	virtual DWORD GetStyle() const;
	virtual DWORD GetExStyle() const;
	virtual BOOL ModifyStyle(DWORD dwRemove, DWORD dwAdd, UINT nFlags);
	virtual BOOL ModifyStyleEx(DWORD dwRemove, DWORD dwAdd, UINT nFlags);
	virtual void SetWindowText(LPCTSTR lpszString);
	virtual void GetWindowText(CString& str) const;
	virtual int GetDlgCtrlID() const;
	virtual int SetDlgCtrlID(int nID);
	virtual void MoveWindow(int x, int y, int nWidth, int nHeight);
	virtual BOOL SetWindowPos(const CWnd* pWndInsertAfter, int x, int y,
		int cx, int cy, UINT nFlags);
	virtual BOOL ShowWindow(int nCmdShow);
	virtual BOOL IsWindowEnabled() const;
	virtual BOOL EnableWindow(BOOL bEnable);
	virtual CWnd* SetFocus();
	virtual CWnd* SetFocus(LPMSG lpmsg);
	virtual void EnableDSC();
	virtual void BindDefaultProperty(DISPID dwDispID, VARTYPE vtProp, LPCTSTR szFieldName, CWnd* pDSCWnd);
	virtual void BindProperty(DISPID dwDispId, CWnd* pWndDSC);

// Overridables
	virtual BOOL QuickActivate();

// Attributes
	COleControlContainer* m_pCtrlCont;
	HWND m_hWnd;
	CWnd* m_pWndCtrl;
	UINT m_nID;
	CRect m_rect;
	IID m_iidEvents;
	LPOLEOBJECT m_pObject;
	LPOLEINPLACEOBJECT m_pInPlaceObject;
	LPOLEINPLACEACTIVEOBJECT m_pActiveObject;
	IOleInPlaceObjectWindowless* m_pWindowlessObject;
	DWORD m_dwEventSink;
	DWORD m_dwPropNotifySink;
	DWORD m_dwStyleMask;
	DWORD m_dwStyle;
	DWORD m_dwMiscStatus;
	BOOL m_bIsWindowless;
	CONTROLINFO m_ctlInfo;

protected:
	void GetControlInfo();

	virtual HRESULT CreateControlCommon(CWnd* pWndCtrl, REFCLSID clsid,const CControlCreationInfo& creationInfo,
		LPCTSTR lpszWindowName, DWORD dwStyle, const POINT* ppt, const SIZE* psize, UINT nID,
		CFile* pPersist, BOOL bStorage, BSTR bstrLicKey);

// Implementation
public:
	~COleControlSite();

	BOOL IsMatchingMnemonic(LPMSG lpMsg);
	void SendMnemonic(LPMSG lpMsg);
	
	void AttachWindow();
	void DetachWindow();
protected:
	BOOL SetExtent();

	virtual HRESULT CreateOrLoad(const CControlCreationInfo& creationInfo);
	virtual	HRESULT CreateOrLoad(REFCLSID clsid, CFile* pPersist, BOOL bStorage,
		BSTR bstrLicKey);

	DWORD ConnectSink(REFIID iid, LPUNKNOWN punkSink);
	void DisconnectSink(REFIID iid, DWORD dwCookie);
	
	BOOL OnEvent(AFX_EVENT* pEvent);
	HRESULT GetCursor(DISPID dispid, LPUNKNOWN* ppcursorOut, LPVOID *ppcidOut);

public:
	// Databound control stuff
	BOOL m_bIgnoreNotify;
	DWORD m_dwNotifyDBEvents; // INotifyDBEvents sink cookie
	CDataSourceControl* m_pDataSourceControl;
	CDataBoundProperty* m_pBindings;
	union {
		COleControlSite *m_pDSCSite;
		WORD m_ctlidRowSource;
	};
	DISPID m_defdispid;
	UINT m_dwType;
	CString m_strDataField;
	BOOL m_bIsDirty;
	VARIANT m_varResult;

protected:
	COleDispatchDriver m_dispDriver;
   CDC* m_pDC;

public:
// Interface maps
	BEGIN_INTERFACE_PART(OleClientSite, IOleClientSite)
		INIT_INTERFACE_PART(COleControlSite, OleClientSite)
		STDMETHOD(SaveObject)();
		STDMETHOD(GetMoniker)(DWORD, DWORD, LPMONIKER*);
		STDMETHOD(GetContainer)(LPOLECONTAINER*);
		STDMETHOD(ShowObject)();
		STDMETHOD(OnShowWindow)(BOOL);
		STDMETHOD(RequestNewObjectLayout)();
	END_INTERFACE_PART(OleClientSite)

	BEGIN_INTERFACE_PART(OleIPSite, IOleInPlaceSiteWindowless)
		INIT_INTERFACE_PART(COleControlSite, OleIPSite)
		STDMETHOD(GetWindow)(HWND*);
		STDMETHOD(ContextSensitiveHelp)(BOOL);

		STDMETHOD(CanInPlaceActivate)();
		STDMETHOD(OnInPlaceActivate)();
		STDMETHOD(OnUIActivate)();
		STDMETHOD(GetWindowContext)(LPOLEINPLACEFRAME*,
			LPOLEINPLACEUIWINDOW*, LPRECT, LPRECT, LPOLEINPLACEFRAMEINFO);
		STDMETHOD(Scroll)(SIZE);
		STDMETHOD(OnUIDeactivate)(BOOL);
		STDMETHOD(OnInPlaceDeactivate)();
		STDMETHOD(DiscardUndoState)();
		STDMETHOD(DeactivateAndUndo)();
		STDMETHOD(OnPosRectChange)(LPCRECT);

	  STDMETHOD(OnInPlaceActivateEx)( BOOL* ptNoRedraw, DWORD dwFlags );
	  STDMETHOD(OnInPlaceDeactivateEx)( BOOL tNoRedraw );
	  STDMETHOD(RequestUIActivate)();

	  STDMETHOD(AdjustRect)( LPRECT prect );
	  STDMETHOD(CanWindowlessActivate)();
	  STDMETHOD(GetCapture)();
	  STDMETHOD(GetDC)( LPCRECT prect, DWORD dwFlags, HDC* phDC );
	  STDMETHOD(GetFocus)();
	  STDMETHOD(InvalidateRect)( LPCRECT prect, BOOL tErase );
	  STDMETHOD(InvalidateRgn)( HRGN hRgn, BOOL tErase );
	  STDMETHOD(OnDefWindowMessage)( UINT nMessage, WPARAM wParam,
		 LPARAM lParam, LRESULT* plResult );
	  STDMETHOD(ReleaseDC)( HDC hDC );
	  STDMETHOD(ScrollRect)( int dx, int dy, LPCRECT prectScroll,
		 LPCRECT prectClip );
	  STDMETHOD(SetCapture)( BOOL tCapture );
	  STDMETHOD(SetFocus)( BOOL tFocus );
   END_INTERFACE_PART(OleIPSite)

	BEGIN_INTERFACE_PART(OleControlSite, IOleControlSite)
		INIT_INTERFACE_PART(COleControlSite, OleControlSite)
		STDMETHOD(OnControlInfoChanged)();
		STDMETHOD(LockInPlaceActive)(BOOL fLock);
		STDMETHOD(GetExtendedControl)(LPDISPATCH* ppDisp);
		STDMETHOD(TransformCoords)(POINTL* lpptlHimetric,
			POINTF* lpptfContainer, DWORD flags);
		STDMETHOD(TranslateAccelerator)(LPMSG lpMsg, DWORD grfModifiers);
		STDMETHOD(OnFocus)(BOOL fGotFocus);
		STDMETHOD(ShowPropertyFrame)();
	END_INTERFACE_PART(OleControlSite)

	BEGIN_INTERFACE_PART(AmbientProps, IDispatch)
		INIT_INTERFACE_PART(COleControlSite, AmbientProps)
		STDMETHOD(GetTypeInfoCount)(unsigned int*);
		STDMETHOD(GetTypeInfo)(unsigned int, LCID, ITypeInfo**);
		STDMETHOD(GetIDsOfNames)(REFIID, _In_count_(cNames) LPOLESTR*, unsigned int cNames, LCID, DISPID*);
		STDMETHOD(Invoke)(DISPID, REFIID, LCID, unsigned short, DISPPARAMS*,
						  VARIANT*, EXCEPINFO*, unsigned int*);
	END_INTERFACE_PART(AmbientProps)

	BEGIN_INTERFACE_PART(PropertyNotifySink, IPropertyNotifySink)
		INIT_INTERFACE_PART(COleControlSite, PropertyNotifySink)
		STDMETHOD(OnChanged)(DISPID dispid);
		STDMETHOD(OnRequestEdit)(DISPID dispid);
	END_INTERFACE_PART(PropertyNotifySink)

	BEGIN_INTERFACE_PART(EventSink, IDispatch)
		INIT_INTERFACE_PART(COleControlSite, EventSink)
		STDMETHOD(GetTypeInfoCount)(unsigned int*);
		STDMETHOD(GetTypeInfo)(unsigned int, LCID, ITypeInfo**);
		STDMETHOD(GetIDsOfNames)(REFIID, _In_count_(cNames) LPOLESTR*, unsigned int cNames, LCID, DISPID*);
		STDMETHOD(Invoke)(DISPID, REFIID, LCID, unsigned short, DISPPARAMS*,
						  VARIANT*, EXCEPINFO*, unsigned int*);
	END_INTERFACE_PART(EventSink)

	BEGIN_INTERFACE_PART(BoundObjectSite, IBoundObjectSite)
		STDMETHOD(GetCursor)(DISPID dispid, LPLPCURSOR ppcursorOut, LPVOID *ppcidOut);
	END_INTERFACE_PART(BoundObjectSite)

	BEGIN_INTERFACE_PART(NotifyDBEvents, INotifyDBEvents)
		STDMETHOD(OKToDo)(DWORD dwEventWhat, ULONG cReasons, DBNOTIFYREASON rgReasons[]);
		STDMETHOD(Cancelled)(DWORD dwEventWhat, ULONG cReasons, DBNOTIFYREASON rgReasons[]);
		STDMETHOD(SyncBefore)(DWORD dwEventWhat, ULONG cReasons, DBNOTIFYREASON rgReasons[]);
		STDMETHOD(AboutToDo)(DWORD dwEventWhat, ULONG cReasons, DBNOTIFYREASON rgReasons[]);
		STDMETHOD(FailedToDo)(DWORD dwEventWhat, ULONG cReasons, DBNOTIFYREASON rgReasons[]);
		STDMETHOD(SyncAfter)(DWORD dwEventWhat, ULONG cReasons, DBNOTIFYREASON rgReasons[]);
		STDMETHOD(DidEvent)(DWORD dwEventWhat, ULONG cReasons, DBNOTIFYREASON rgReasons[]);

		// Not part of i/f - just a helper
		HRESULT FireEvent(DWORD dwEventWhat, ULONG cReasons,
			DBNOTIFYREASON rgReasons[], DSCSTATE nState);
	END_INTERFACE_PART(NotifyDBEvents)

	BEGIN_INTERFACE_PART(RowsetNotify, IRowsetNotify)
		STDMETHOD(OnFieldChange)(IRowset* pRowset, HROW hRow, DBORDINAL cColumns, DBORDINAL rgColumns[], DBREASON eReason, DBEVENTPHASE ePhase, BOOL fCantDeny);
		STDMETHOD(OnRowChange)(IRowset* pRowset, DBCOUNTITEM cRows, const HROW rghRows[], DBREASON eReason, DBEVENTPHASE ePhase, BOOL fCantDeny);
		STDMETHOD(OnRowsetChange)(IRowset* pRowset, DBREASON eReason, DBEVENTPHASE ePhase, BOOL fCantDeny);
	END_INTERFACE_PART(RowsetNotify)

	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// COleControlSiteOrWnd (helper)
struct COleControlSiteOrWnd
{
	COleControlSiteOrWnd();
	COleControlSiteOrWnd(COleControlSite *pSite);
	COleControlSiteOrWnd(HWND hWnd, BOOL bAutoRadioButton);
	~COleControlSiteOrWnd();

	DWORD GetStyle() const;

	HWND m_hWnd;
	COleControlSite *m_pSite;
	BOOL m_bAutoRadioButton;
};

COleControlSiteOrWnd* AFXAPI _AfxFindSiteOrWnd(CWnd *pWndDlg, CWnd *pWnd);

/////////////////////////////////////////////////////////////////////////////
// OLE control container manager

class COccManager : public CNoTrackObject
{
// Operations
public:
	// Event handling
	virtual BOOL OnEvent(CCmdTarget* pCmdTarget, UINT idCtrl, AFX_EVENT* pEvent,
		AFX_CMDHANDLERINFO* pHandlerInfo);

	// Internal object creation
	virtual COleControlContainer* CreateContainer(CWnd* pWnd);
	virtual COleControlSite* CreateSite(COleControlContainer* pCtrlCont);
	virtual COleControlSite* CreateSite(COleControlContainer* pCtrlCont,const CControlCreationInfo& creationInfo);

	// Dialog creation
	virtual const DLGTEMPLATE* PreCreateDialog(_AFX_OCC_DIALOG_INFO* pOccDialogInfo,
		const DLGTEMPLATE* pOrigTemplate);
	virtual void PostCreateDialog(_AFX_OCC_DIALOG_INFO* pOccDialogInfo);
	virtual DLGTEMPLATE* SplitDialogTemplate(const DLGTEMPLATE* pTemplate,
		DLGITEMTEMPLATE** ppOleDlgItems);
	virtual BOOL CreateDlgControls(CWnd* pWndParent, LPCTSTR lpszResourceName,
		_AFX_OCC_DIALOG_INFO* pOccDialogInfo);
	virtual BOOL CreateDlgControls(CWnd* pWndParent, void* lpResource,
		_AFX_OCC_DIALOG_INFO* pOccDialogInfo);

	// Dialog manager
	virtual BOOL IsDialogMessage(CWnd* pWndDlg, LPMSG lpMsg);
	static BOOL AFX_CDECL IsLabelControl(CWnd* pWnd);
	static BOOL AFX_CDECL IsLabelControl(COleControlSiteOrWnd* pWnd);
	static BOOL AFX_CDECL IsMatchingMnemonic(CWnd* pWnd, LPMSG lpMsg);
	static BOOL AFX_CDECL IsMatchingMnemonic(COleControlSiteOrWnd* pWnd, LPMSG lpMsg);
	static void AFX_CDECL SetDefaultButton(CWnd* pWnd, BOOL bDefault);
	static DWORD AFX_CDECL GetDefBtnCode(CWnd* pWnd);

// Implementation
protected:
	// Dialog creation
	BOOL CreateDlgControl(CWnd* pWndParent, HWND hwAfter, BOOL bDialogEx,
		LPDLGITEMTEMPLATE pDlgItem, WORD nMsg, BYTE* lpData, DWORD cb, HWND* phWnd);

	// Databinding
	void BindControls(CWnd* pWndParent);

	// Dialog manager
	static void AFX_CDECL UIActivateControl(CWnd* pWndNewFocus);
	static void AFX_CDECL UIDeactivateIfNecessary(CWnd* pWndOldFocus, CWnd* pWndNewFocus);
};

struct _AFX_OCC_DIALOG_INFO
{
	DLGTEMPLATE* m_pNewTemplate;
	DLGITEMTEMPLATE** m_ppOleDlgItems;

	unsigned m_cItems;
	struct ItemInfo
	{
		unsigned nId;
		BOOL bAutoRadioButton;
	};
	ItemInfo *m_pItemInfo;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif // !_AFX_NO_OCC_SUPPORT
#endif // __AFXOCC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxole.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXOLE_H__
#define __AFXOLE_H__

#ifdef _AFX_NO_OLE_SUPPORT
	#error OLE classes not supported in this library variant.
#endif

#ifndef __AFXEXT_H__
	#include <afxext.h>
#endif

#ifndef __AFXDISP_H__
	#include <afxdisp.h>
#endif

// include OLE Compound Document headers
#ifndef _OLE2_H_
	#include <ole2.h>
#endif

// ActiveX Document support
#ifndef __docobj_h__
	#include <docobj.h>
#endif

// URL Monikers support
#ifndef __urlmon_h__
	#include <urlmon.h>
#endif

#ifndef __AFXCOM_H__
#include <afxcom_.h>
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif


#ifndef _AFX_NOFORCE_LIBS

#pragma comment(lib, "urlmon.lib")

#endif // !_AFX_NOFORCE_LIBS

/////////////////////////////////////////////////////////////////////////////
// AFXOLE.H - MFC OLE support

// Classes declared in this file

//CDocument
	class COleDocument;             // OLE container document
		class COleLinkingDoc;       // supports links to embeddings
			class COleServerDoc;    // OLE server document
	class CDocObjectServer;         // might be owned by a COleServerDoc

//CCmdTarget
	class CDocItem;                 // part of a document
		class COleClientItem;       // embedded ole object from outside
			class COleDocObjectItem;// ActiveX Document item
		class COleServerItem;       // ole object to export
	class COleDataSource;           // clipboard data source mechanism
	class COleDropSource;           // drag/drop source
	class COleDropTarget;           // drag/drop target
	class COleMessageFilter;        // concurrency management

//CFrameWnd
	class COleIPFrameWnd;           // frame window for in-place servers

//CControlBar
	class COleResizeBar;            // implements in-place resizing

//CFile
	class COleStreamFile;           // CFile wrapper for IStream interface
		class CMonikerFile;         // bound to via IMoniker
			class CAsyncMonikerFile;// asynchronous IMoniker

class COleDataObject;               // wrapper for IDataObject interface

/////////////////////////////////////////////////////////////////////////////

// AFXDLL support
#undef AFX_DATA
#define AFX_DATA AFX_OLE_DATA

/////////////////////////////////////////////////////////////////////////////
// backward compatibility

// COleClientDoc is now obsolete -- use COleDocument instead
#define COleClientDoc COleDocument

// COleServer has been replaced by the more general COleObjectFactory
#define COleServer  COleObjectFactory

/////////////////////////////////////////////////////////////////////////////
// Useful OLE specific types (some from OLE 1.0 headers)

// Codes for CallBack events
enum OLE_NOTIFICATION
{
	OLE_CHANGED,        // representation of a draw aspect has changed
	OLE_SAVED,          // the item has committed its storage
	OLE_CLOSED,         // the item has closed
	OLE_RENAMED,        // the item has changed its moniker
	OLE_CHANGED_STATE,  // the item state (open, active, etc.) has changed
	OLE_CHANGED_ASPECT, // the item draw aspect has changed
};

// Object types
enum OLE_OBJTYPE
{
	OT_UNKNOWN = 0,

	// These are OLE 1.0 types and OLE 2.0 types as returned from GetType().
	OT_LINK = 1,
	OT_EMBEDDED = 2,
	OT_STATIC = 3,

	// All OLE2 objects are written with this tag when serialized.  This
	//  differentiates them from OLE 1.0 objects written with MFC 2.0.
	//  This value will never be returned from GetType().
	OT_OLE2 = 256,
};

/////////////////////////////////////////////////////////////////////////////
// COleDataObject -- simple wrapper for IDataObject

class COleDataObject
{
// Constructors
public:
	COleDataObject();

// Operations
	void Attach(LPDATAOBJECT lpDataObject, BOOL bAutoRelease = TRUE);
	LPDATAOBJECT Detach();  // detach and get ownership of m_lpDataObject
	void Release(); // detach and Release ownership of m_lpDataObject
	BOOL AttachClipboard(); // attach to current clipboard object

// Attributes
	void BeginEnumFormats();
	BOOL GetNextFormat(LPFORMATETC lpFormatEtc);
	CFile* GetFileData(CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc = NULL);
	HGLOBAL GetGlobalData(CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc = NULL);
	BOOL GetData(CLIPFORMAT cfFormat, LPSTGMEDIUM lpStgMedium,
		LPFORMATETC lpFormatEtc = NULL);
	BOOL IsDataAvailable(CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc = NULL);

// Implementation
public:
	LPDATAOBJECT m_lpDataObject;
	LPENUMFORMATETC m_lpEnumerator;
	~COleDataObject();

	// advanced use and implementation
	LPDATAOBJECT GetIDataObject(BOOL bAddRef);
	void EnsureClipboardObject();
	BOOL m_bClipboard;      // TRUE if represents the Win32 clipboard

protected:
	BOOL m_bAutoRelease;    // TRUE if destructor should call Release

private:
	// Disable the copy constructor and assignment by default so you will get
	//   compiler errors instead of unexpected behaviour if you pass objects
	//   by value or assign objects.
	COleDataObject(const COleDataObject&);  // no implementation
	void operator=(const COleDataObject&);  // no implementation
};

/////////////////////////////////////////////////////////////////////////////
// COleDataSource -- wrapper for implementing IDataObject
//  (works similar to how data is provided on the clipboard)

struct AFX_DATACACHE_ENTRY;
class COleDropSource;

class COleDataSource : public CCmdTarget
{
// Constructors
public:
	COleDataSource();

// Operations
	void Empty();   // empty cache (similar to ::EmptyClipboard)

	// CacheData & DelayRenderData operations similar to ::SetClipboardData
	void CacheGlobalData(CLIPFORMAT cfFormat, HGLOBAL hGlobal,
		LPFORMATETC lpFormatEtc = NULL);    // for HGLOBAL based data
	void DelayRenderFileData(CLIPFORMAT cfFormat,
		LPFORMATETC lpFormatEtc = NULL);    // for CFile* based delayed render

	// Clipboard and Drag/Drop access
	DROPEFFECT DoDragDrop(
		DWORD dwEffects = DROPEFFECT_COPY|DROPEFFECT_MOVE|DROPEFFECT_LINK,
		LPCRECT lpRectStartDrag = NULL,
		COleDropSource* pDropSource = NULL);
	void SetClipboard();
	static void PASCAL FlushClipboard();
	static COleDataSource* PASCAL GetClipboardOwner();

	// Advanced: STGMEDIUM based cached data
	void CacheData(CLIPFORMAT cfFormat, LPSTGMEDIUM lpStgMedium,
		LPFORMATETC lpFormatEtc = NULL);    // for LPSTGMEDIUM based data
	// Advanced: STGMEDIUM or HGLOBAL based delayed render
	void DelayRenderData(CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc = NULL);

	// Advanced: support for SetData in COleServerItem
	//  (not generally useful for clipboard or drag/drop operations)
	void DelaySetData(CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc = NULL);

// Overidables
	virtual BOOL OnRenderGlobalData(LPFORMATETC lpFormatEtc, HGLOBAL* phGlobal);
	virtual BOOL OnRenderFileData(LPFORMATETC lpFormatEtc, CFile* pFile);
	virtual BOOL OnRenderData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium);
		// OnRenderFileData and OnRenderGlobalData are called by
		//  the default implementation of OnRenderData.

	virtual BOOL OnSetData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium,
		BOOL bRelease);
		// used only in COleServerItem implementation

// Implementation
public:
	virtual ~COleDataSource();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	AFX_DATACACHE_ENTRY* m_pDataCache;  // data cache itself
	UINT m_nMaxSize;    // current allocated size
	UINT m_nSize;       // current size of the cache
	UINT m_nGrowBy;     // number of cache elements to grow by for new allocs

	AFX_DATACACHE_ENTRY* Lookup(
		LPFORMATETC lpFormatEtc, DATADIR nDataDir) const;
	AFX_DATACACHE_ENTRY* GetCacheEntry(
		LPFORMATETC lpFormatEtc, DATADIR nDataDir);

// Interface Maps
public:
	BEGIN_INTERFACE_PART(DataObject, IDataObject)
		INIT_INTERFACE_PART(COleDataSource, DataObject)
		STDMETHOD(GetData)(LPFORMATETC, LPSTGMEDIUM);
		STDMETHOD(GetDataHere)(LPFORMATETC, LPSTGMEDIUM);
		STDMETHOD(QueryGetData)(LPFORMATETC);
		STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC, LPFORMATETC);
		STDMETHOD(SetData)(LPFORMATETC, LPSTGMEDIUM, BOOL);
		STDMETHOD(EnumFormatEtc)(DWORD, LPENUMFORMATETC*);
		STDMETHOD(DAdvise)(LPFORMATETC, DWORD, LPADVISESINK, LPDWORD);
		STDMETHOD(DUnadvise)(DWORD);
		STDMETHOD(EnumDAdvise)(LPENUMSTATDATA*);
	END_INTERFACE_PART(DataObject)

	DECLARE_INTERFACE_MAP()

	friend class COleServerItem;
};

//////////////////////////////////////////////////////////////////////////////
// DocItem support

class CDocItem : public CCmdTarget
{
	DECLARE_SERIAL(CDocItem)

// Constructors
protected:      // abstract class
	CDocItem();

// Attributes
public:
	CDocument* GetDocument() const; // return container document

// Overridables
public:
	// Raw data access (native format)
	virtual BOOL IsBlank() const;

// Implementation
protected:
	COleDocument* m_pDocument;

public:
	virtual void Serialize(CArchive& ar);   // for Native data
	virtual ~CDocItem();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	friend class COleDocument;              // for access to back pointer
};

//////////////////////////////////////////////////////////////////////////////
// COleDocument - common OLE container behavior (enables server functionality)

class COleDocument : public CDocument
{
	DECLARE_DYNAMIC(COleDocument)

// Constructors
public:
	COleDocument();

// Attributes
	BOOL HasBlankItems() const; // check for BLANK items
	virtual COleClientItem* GetInPlaceActiveItem(CWnd* pWnd);
		// return in-place active item for this view or NULL if none

// Operations
	// iterating over existing items
	virtual POSITION GetStartPosition() const;
	virtual CDocItem* GetNextItem(POSITION& pos) const;

	// iterator helpers (helpers use virtual GetNextItem above)
	COleClientItem* GetNextClientItem(POSITION& pos) const;
	COleServerItem* GetNextServerItem(POSITION& pos) const;

	// adding new items - called from item constructors
	virtual void AddItem(CDocItem* pItem);
	virtual void RemoveItem(CDocItem* pItem);

	void EnableCompoundFile(BOOL bEnable = TRUE);
		// enable compound file support (only call during constructor)
	virtual void UpdateModifiedFlag();
		// scan for modified items -- mark document modified

	// printer-device caching/control
	BOOL ApplyPrintDevice(const DVTARGETDEVICE* ptd);
	BOOL ApplyPrintDevice(const PRINTDLG* ppd);
		// these apply the target device to all COleClientItem objects

	// Overridables
	virtual COleClientItem* GetPrimarySelectedItem(CView* pView);
		// return primary selected item or NULL if none
	virtual void OnShowViews(BOOL bVisible);
		// called during app-idle when visibility of a document has changed

// Implementation
public:
	CObList m_docItemList;  // not owned items

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	CFrameWnd* GetFirstFrame();

	// document handling overrides
	virtual void SetPathName(LPCTSTR lpszPathName, BOOL bAddToMRU = TRUE);
	virtual ~COleDocument();
	virtual void DeleteContents(); // delete client items in list
	virtual void Serialize(CArchive& ar);   // serialize items to file
	virtual void PreCloseFrame(CFrameWnd* pFrame);
	virtual BOOL DoSave(LPCTSTR lpszPathName, BOOL bReplace);
	virtual BOOL SaveModified();
	virtual void OnIdle();

	// compound file implementation
	virtual BOOL OnNewDocument();
	virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
	virtual BOOL OnSaveDocument(LPCTSTR lpszPathName);
	virtual void OnCloseDocument();
	void CommitItems(BOOL bSuccess, LPSTORAGE pNewStorage = NULL);    // called during File.Save & File.Save As

	// minimal linking protocol
	virtual LPMONIKER GetMoniker(OLEGETMONIKER nAssign);
	virtual LPOLEITEMCONTAINER GetContainer();

protected:
	// document state implementation
	UINT m_dwNextItemNumber;// serial number for next item in this document
	BOOL m_bLastVisible;    // TRUE if one or more views was last visible

	// 'docfile' support
	BOOL m_bCompoundFile;   // TRUE if use compound files
	LPSTORAGE m_lpRootStg;  // root storage for the document
	BOOL m_bSameAsLoad;     // TRUE = file-save, FALSE = Save [Copy] As
	BOOL m_bRemember;       // if FALSE, indicates Save Copy As

	CString m_strStorageName; // last storage where the document was loaded/saved (may be different from m_strPathName)

	DVTARGETDEVICE* m_ptd;  // current document target device

	// implementation helpers
	virtual void LoadFromStorage();
	virtual void SaveToStorage(CObject* pObject = NULL);
	CDocItem* GetNextItemOfKind(POSITION& pos, CRuntimeClass* pClass) const;

	// overridables. Currently called by search/organize/preview/live-icon handlers to load data from stream
	virtual HRESULT OnLoadDocumentFromStream(IStream* pStream, DWORD grfMode);

	// command handling
public:
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo);

protected:
	afx_msg void OnUpdatePasteMenu(CCmdUI* pCmdUI);
	afx_msg void OnUpdatePasteLinkMenu(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditLinksMenu(CCmdUI* pCmdUI);
	afx_msg void OnEditLinks();
	afx_msg void OnEditConvert();
	afx_msg void OnUpdateEditChangeIcon(CCmdUI* pCmdUI);
	afx_msg void OnEditChangeIcon();
	afx_msg void OnUpdateObjectVerbMenu(CCmdUI* pCmdUI);
	afx_msg void OnFileSendMail();

	friend class COleClientItem;
	friend class COleServerItem;
};

/////////////////////////////////////////////////////////////////////////////
// COleClientItem - Supports OLE2 non-inplace editing.
//      implements IOleClientSite, IAdviseSink, and IOleInPlaceSite

class COleFrameHook;    // forward reference (see ..\src\oleimpl2.h)

class COleClientItem : public CDocItem
{
	DECLARE_DYNAMIC(COleClientItem)

// Constructors
public:
	/* explicit */ COleClientItem(COleDocument* pContainerDoc = NULL);

	// create from the clipboard
	BOOL CreateFromClipboard(OLERENDER render = OLERENDER_DRAW,
		CLIPFORMAT cfFormat = 0, LPFORMATETC lpFormatEtc = NULL);
	BOOL CreateLinkFromClipboard(OLERENDER render = OLERENDER_DRAW,
		CLIPFORMAT cfFormat = 0, LPFORMATETC lpFormatEtc = NULL);
	BOOL CreateStaticFromClipboard(OLERENDER render = OLERENDER_DRAW,
		CLIPFORMAT cfFormat = 0, LPFORMATETC lpFormatEtc = NULL);

	// create from a class ID (Insert New Object dialog)
	BOOL CreateNewItem(REFCLSID clsid, OLERENDER render = OLERENDER_DRAW,
		CLIPFORMAT cfFormat = 0, LPFORMATETC lpFormatEtc = NULL);

	// create from COleDataObject
	BOOL CreateFromData(COleDataObject* pDataObject,
		OLERENDER render = OLERENDER_DRAW,
		CLIPFORMAT cfFormat = 0, LPFORMATETC lpFormatEtc = NULL);
	BOOL CreateLinkFromData(COleDataObject* pDataObject,
		OLERENDER render = OLERENDER_DRAW,
		CLIPFORMAT cfFormat = 0, LPFORMATETC lpFormatEtc = NULL);
	BOOL CreateStaticFromData(COleDataObject* pDataObject,
		OLERENDER render = OLERENDER_DRAW,
		CLIPFORMAT cfFormat = 0, LPFORMATETC lpFormatEtc = NULL);

	// create from file (package support)
	BOOL CreateFromFile(LPCTSTR lpszFileName, REFCLSID clsid = CLSID_NULL,
		OLERENDER render = OLERENDER_DRAW,
		CLIPFORMAT cfFormat = 0, LPFORMATETC lpFormatEtc = NULL);
	BOOL CreateLinkFromFile(LPCTSTR lpszFileName,
		OLERENDER render = OLERENDER_DRAW,
		CLIPFORMAT cfFormat = 0, LPFORMATETC lpFormatEtc = NULL);

	// create a copy
	BOOL CreateCloneFrom(const COleClientItem* pSrcItem);

// General Attributes
public:
	HICON GetIconFromRegistry() const;
	static HICON GetIconFromRegistry(CLSID& clsid);
	SCODE GetLastStatus() const;
	OLE_OBJTYPE GetType() const; // OT_LINK, OT_EMBEDDED, OT_STATIC
	void GetClassID(CLSID* pClassID) const;
	void GetUserType(USERCLASSTYPE nUserClassType, CString& rString);
	BOOL GetExtent(LPSIZE lpSize, DVASPECT nDrawAspect = (DVASPECT)-1);
		// will return FALSE if item is BLANK
	BOOL GetCachedExtent(LPSIZE lpSize, DVASPECT nDrawAspect = (DVASPECT)-1);

	// getting/setting iconic cache
	HGLOBAL GetIconicMetafile();
	BOOL SetIconicMetafile(HGLOBAL hMetaPict);

	// setting/getting default display aspect
	DVASPECT GetDrawAspect() const;
	virtual void SetDrawAspect(DVASPECT nDrawAspect);

	// for printer presentation cache
	BOOL SetPrintDevice(const DVTARGETDEVICE* ptd);
	BOOL SetPrintDevice(const PRINTDLG* ppd);

	// Item state
	enum ItemState
		{ emptyState, loadedState, openState, activeState, activeUIState };
	UINT GetItemState() const;

	BOOL IsModified() const;
	BOOL IsRunning() const;
	BOOL IsInPlaceActive() const;
	BOOL IsOpen() const;
	CView* GetActiveView() const;

	// Data access
	void AttachDataObject(COleDataObject& rDataObject) const;

	// other rare access information
	COleDocument* GetDocument() const; // return container

	// helpers for checking clipboard data availability
	static BOOL PASCAL CanPaste();
	static BOOL PASCAL CanPasteLink();

	// helpers for checking COleDataObject, useful in drag drop
	static BOOL PASCAL CanCreateFromData(const COleDataObject* pDataObject);
	static BOOL PASCAL CanCreateLinkFromData(const COleDataObject* pDataObject);

// General Operations
	virtual void Release(OLECLOSE dwCloseOption = OLECLOSE_NOSAVE);
		// cleanup, detach (close if needed)
	void Close(OLECLOSE dwCloseOption = OLECLOSE_SAVEIFDIRTY);
		// close without releasing the item
	void Delete(BOOL bAutoDelete = TRUE);
		// logically delete from file -- not part of the document anymore
	void Run(); // insure item is in running state

	// Drawing
	BOOL Draw(CDC* pDC, LPCRECT lpBounds,
		DVASPECT nDrawAspect = (DVASPECT)-1);   // defaults to m_nDrawAspect

	// Activation
	virtual BOOL DoVerb(LONG nVerb, CView* pView, LPMSG lpMsg = NULL);
	void Activate(LONG nVerb, CView* pView, LPMSG lpMsg = NULL);

	// In-place Activation
	void Deactivate();          // completely deactivate
	void DeactivateUI();        // deactivate the user interface
	BOOL ReactivateAndUndo();   // reactivate then perform undo command
	BOOL SetItemRects(LPCRECT lpPosRect = NULL, LPCRECT lpClipRect = NULL);
	CWnd* GetInPlaceWindow();

	// Clipboard operations
	void CopyToClipboard(BOOL bIncludeLink = FALSE);
	DROPEFFECT DoDragDrop(LPCRECT lpItemRect, CPoint ptOffset,
		BOOL bIncludeLink = FALSE,
		DWORD dwEffects = DROPEFFECT_COPY|DROPEFFECT_MOVE,
		LPCRECT lpRectStartDrag = NULL);
	void GetClipboardData(COleDataSource* pDataSource,
		BOOL bIncludeLink = FALSE, LPPOINT lpOffset = NULL,
		LPSIZE lpSize = NULL);

	// called for creating a COleDataSource by CopyToClipboard and DoDragDrop
	virtual COleDataSource* OnGetClipboardData(BOOL bIncludeLink,
		LPPOINT lpOffset, LPSIZE lpSize);

	// Operations that apply to embedded items only
	void SetHostNames(LPCTSTR lpszHost, LPCTSTR lpszHostObj);
	void SetExtent(const CSize& size, DVASPECT nDrawAspect = DVASPECT_CONTENT);

	// Operations that apply to linked items only
	//  (link options are rarely changed, except through Links dialog)
	OLEUPDATE GetLinkUpdateOptions();
	void SetLinkUpdateOptions(OLEUPDATE dwUpdateOpt);

	// Link-source update status (also useful for embeddings that contain links)
	BOOL UpdateLink();  // make up-to-date
	BOOL IsLinkUpToDate() const;    // is link up-to-date

	// object conversion
	virtual BOOL ConvertTo(REFCLSID clsidNew);
	virtual BOOL ActivateAs(LPCTSTR lpszUserType, REFCLSID clsidOld, REFCLSID clsidNew);
	BOOL Reload();  // for lazy reload after ActivateAs

// Overridables (notifications of IAdviseSink, IOleClientSite and IOleInPlaceSite)
	// Callbacks/notifications from the server you must/should implement
	virtual void OnChange(OLE_NOTIFICATION nCode, DWORD dwParam);
		// implement OnChange to invalidate when item changes

protected:
	virtual void OnGetItemPosition(CRect& rPosition);
		// implement OnGetItemPosition if you support in-place activation

	// Common overrides for in-place activation
	virtual BOOL OnScrollBy(CSize sizeExtent);

	// Common overrides for applications supporting undo
	virtual void OnDiscardUndoState();
	virtual void OnDeactivateAndUndo();

public:
	virtual void OnDeactivateUI(BOOL bUndoable);

protected:
	// Common overrides for applications supporting links to embeddings
	virtual void OnShowItem();

	// Advanced overrides for in-place activation
	virtual void OnGetClipRect(CRect& rClipRect);
	virtual BOOL CanActivate();

public:
	virtual void OnActivate();
	virtual void OnActivateUI();
	virtual void OnDeactivate();

protected:
	virtual BOOL OnGetWindowContext(CFrameWnd** ppMainFrame,
		CFrameWnd** ppDocFrame, LPOLEINPLACEFRAMEINFO lpFrameInfo);
	virtual BOOL OnChangeItemPosition(const CRect& rectPos);
		// default calls SetItemRects and caches the pos rect

public:
	// Advanced overrides for menu/title handling (rarely overridden)
	virtual void OnInsertMenus(CMenu* pMenuShared,
		LPOLEMENUGROUPWIDTHS lpMenuWidths);
	virtual void OnSetMenu(CMenu* pMenuShared, HOLEMENU holemenu,
		HWND hwndActiveObject);
	virtual void OnRemoveMenus(CMenu* pMenuShared);
	virtual BOOL OnUpdateFrameTitle();

	// Advanced override for control bar handling
	virtual BOOL OnShowControlBars(CFrameWnd* pFrameWnd, BOOL bShow);

// Implementation
public:
	// data to support non-inplace activated items
	LPOLEOBJECT m_lpObject; // in case you want direct access to the OLE object
	LPVIEWOBJECT2 m_lpViewObject;// IViewObject for IOleObject above
	DWORD m_dwItemNumber;   // serial number for this item in this document
	DVASPECT m_nDrawAspect; // current default display aspect
	SCODE m_scLast;         // last error code encountered
	LPSTORAGE m_lpStorage;  // provides storage for m_lpObject
	LPLOCKBYTES m_lpLockBytes;  // part of implementation of m_lpStorage
	DWORD m_dwConnection;   // advise connection to the m_lpObject
	BYTE m_bLinkUnavail;    // TRUE if link is currently unavailable
	BYTE m_bMoniker;        // TRUE if moniker is assigned
	BYTE m_bLocked;         // TRUE if object has external lock
	BYTE m_bNeedCommit;     // TRUE if need CommitItem
	BYTE m_bClosing;        // TRUE if currently doing COleClientItem::Close
	BYTE m_bReserved[3];    // (reserved for future use)

	// for compound file support
	LPSTORAGE m_lpNewStorage;   // used during Save As situations

	// item state & item type
	ItemState m_nItemState; // item state (see ItemState enumeration)
	OLE_OBJTYPE m_nItemType;    // item type (depends on how created)

	// data valid when in-place activated
	CView* m_pView; // view when object is in-place activated
	DWORD m_dwContainerStyle;   // style of the container wnd before activation
	COleFrameHook* m_pInPlaceFrame;// frame window when in-place active
	COleFrameHook* m_pInPlaceDoc;   // doc window when in-place (may be NULL)
	HWND m_hWndServer;  // HWND of in-place server window

	DWORD m_dwFrameMenuBarVisibility; // visibility of the frame window menu bar

public:
	virtual ~COleClientItem();
	virtual void Serialize(CArchive& ar);
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Implementation
public:
	virtual BOOL ReportError(SCODE sc) const;
	virtual BOOL FreezeLink();  // converts to static: for edit links dialog

	DWORD GetNewItemNumber();   // generates new item number
	_AFX_INSECURE_DEPRECATE("COleClientItem::GetItemName(TCHAR *) is insecure. Instead use COleClientItem::GetItemName(TCHAR *, UINT *size)")
	void GetItemName(_Out_ _Pre_notnull_ _Post_z_ LPTSTR lpszItemName) const; // gets readable item name
	void GetItemName(_Out_z_cap_(cchItemName)  _Pre_notnull_ _Post_z_ LPTSTR lpszItemName, UINT cchItemName) const;

	void UpdateItemType();  // update m_nItemType

protected:
	// clipboard helpers
	void GetEmbeddedItemData(LPSTGMEDIUM lpStgMedium);
	void AddCachedData(COleDataSource* pDataSource);
	BOOL GetLinkSourceData(LPSTGMEDIUM lpStgMedium);
	void GetObjectDescriptorData(LPPOINT lpOffset, LPSIZE lpSize,
		LPSTGMEDIUM lpStgMedium);

	// interface helpers
	virtual LPOLECLIENTSITE GetClientSite();

	// helpers for printer-cached representation
	BOOL GetPrintDeviceInfo(LPOLECACHE* plpOleCache,
		DVTARGETDEVICE** pptd, DWORD* pdwConnection);

// Advanced Overridables for implementation
protected:
	virtual BOOL FinishCreate(SCODE sc);
	virtual void CheckGeneral(SCODE sc);

	virtual void OnDataChange(LPFORMATETC lpFormatEtc,
		LPSTGMEDIUM lpStgMedium);

public:
	// for storage hookability (override to use 'docfiles')
	virtual void GetItemStorage();  // allocate storage for new item
	virtual void ReadItem(CArchive& ar);    // read item from archive
	virtual void WriteItem(CArchive& ar);   // write item to archive
	virtual void CommitItem(BOOL bSuccess); // commit item's storage

	// compound & flat file implementations of above
	void GetItemStorageFlat();
	void ReadItemFlat(CArchive& ar);
	void WriteItemFlat(CArchive& ar);
	void GetItemStorageCompound();
	void ReadItemCompound(CArchive& ar);
	void WriteItemCompound(CArchive& ar);

// Interface Maps
public:
	BEGIN_INTERFACE_PART(OleClientSite, IOleClientSite)
		INIT_INTERFACE_PART(COleClientItem, OleClientSite)
		STDMETHOD(SaveObject)();
		STDMETHOD(GetMoniker)(DWORD, DWORD, LPMONIKER*);
		STDMETHOD(GetContainer)(LPOLECONTAINER*);
		STDMETHOD(ShowObject)();
		STDMETHOD(OnShowWindow)(BOOL);
		STDMETHOD(RequestNewObjectLayout)();
	END_INTERFACE_PART(OleClientSite)

	BEGIN_INTERFACE_PART(AdviseSink, IAdviseSink)
		INIT_INTERFACE_PART(COleClientItem, AdviseSink)
		STDMETHOD_(void,OnDataChange)(LPFORMATETC, LPSTGMEDIUM);
		STDMETHOD_(void,OnViewChange)(DWORD, LONG);
		STDMETHOD_(void,OnRename)(LPMONIKER);
		STDMETHOD_(void,OnSave)();
		STDMETHOD_(void,OnClose)();
	END_INTERFACE_PART(AdviseSink)

	BEGIN_INTERFACE_PART(OleIPSite, IOleInPlaceSite)
		INIT_INTERFACE_PART(COleClientItem, OleIPSite)
		STDMETHOD(GetWindow)(HWND*);
		STDMETHOD(ContextSensitiveHelp)(BOOL);
		STDMETHOD(CanInPlaceActivate)();
		STDMETHOD(OnInPlaceActivate)();
		STDMETHOD(OnUIActivate)();
		STDMETHOD(GetWindowContext)(LPOLEINPLACEFRAME*,
			LPOLEINPLACEUIWINDOW*, LPRECT, LPRECT, LPOLEINPLACEFRAMEINFO);
		STDMETHOD(Scroll)(SIZE);
		STDMETHOD(OnUIDeactivate)(BOOL);
		STDMETHOD(OnInPlaceDeactivate)();
		STDMETHOD(DiscardUndoState)();
		STDMETHOD(DeactivateAndUndo)();
		STDMETHOD(OnPosRectChange)(LPCRECT);
	END_INTERFACE_PART(OleIPSite)

	DECLARE_INTERFACE_MAP()

// Friendship declarations (to avoid many public members)
	friend class COleUIWindow;
	friend class COleFrameWindow;
	friend class COleLinkingDoc;
};

class COleDocObjectItem : public COleClientItem
{
	friend class COleFrameHook;
	DECLARE_DYNAMIC(COleDocObjectItem)

// Constructors
public:
	/* explicit */ COleDocObjectItem(COleDocument* pContainerDoc = NULL);

//Overridables
public:
	LPOLEDOCUMENTVIEW GetActiveView() const;
	virtual void Release(OLECLOSE dwCloseOption = OLECLOSE_NOSAVE);
	virtual void OnInsertMenus(CMenu* pMenuShared,
		LPOLEMENUGROUPWIDTHS lpMenuWidths);
	virtual void OnRemoveMenus(CMenu *pMenuShared);

// Operations
public:
	static HRESULT DoDefaultPrinting(CView *pCaller, CPrintInfo *pInfo);
	static BOOL OnPreparePrinting(CView* pCaller, CPrintInfo* pInfo,
		BOOL bPrintAll = TRUE);
	static void OnPrint(CView* pCaller, CPrintInfo* pInfo,
		BOOL bPrintAll = TRUE);
	BOOL GetPageCount(LPLONG pnFirstPage, LPLONG pcPages);
	HRESULT ExecCommand(DWORD nCmdID,
		DWORD nCmdExecOpt = OLECMDEXECOPT_DONTPROMPTUSER,
		const GUID* pguidCmdGroup = NULL);
	HRESULT QueryCommand(ULONG nCmdID,
			DWORD* pdwStatus,
			OLECMDTEXT* pCmdText=NULL,
			const GUID* pguidCmdGroup=NULL);

	//command routing of OLE commands
	DECLARE_OLECMD_MAP()
	BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
// Implementation
public:
	virtual ~COleDocObjectItem();
	CMenu* m_pHelpPopupMenu;

protected:
	virtual void OnGetItemPosition(CRect& rPosition);
	virtual CMenu* GetHelpMenu(UINT& nPosition);
	void ActivateAndShow();
	LPOLEDOCUMENTVIEW m_pActiveView;
	LPPRINT m_pIPrint;
	BOOL SupportsIPrint();
	BOOL m_bInHelpMenu;

	BEGIN_INTERFACE_PART(OleDocumentSite, IOleDocumentSite)
		INIT_INTERFACE_PART(COleDocObjectItem, OleDocumentSite)
		STDMETHOD(ActivateMe)(LPOLEDOCUMENTVIEW pViewToActivate);
	END_INTERFACE_PART(OleDocumentSite)

	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// COleServerItem - IOleObject & IDataObject OLE component

class AFX_NOVTABLE COleServerItem : public CDocItem
{
	DECLARE_DYNAMIC(COleServerItem)
protected:
	// NOTE: many members in this class are protected - since everything
	//   in this class is designed for implementing an OLE server.
	// Requests will come from OLE containers through non-C++ mechanisms,
	//   which will result in virtual functions in this class being called.

// Constructors
	COleServerItem(COleServerDoc* pServerDoc, BOOL bAutoDelete);
		// If your COleServerItem is an integral part of your data,
		//  bAutoDelete should be FALSE.  If your COleServerItem can be
		//  deleted when a link is released, it can be TRUE.

	COleDataSource* GetDataSource();
		// Use this data source to add conversion formats that your
		//  server should support.  Usually such formats are
		//  added in the item's constructor.

// Public Attributes
public:
	COleServerDoc* GetDocument() const; // return server document

	// naming (for links only)
	const CString& GetItemName() const; // get name of linked item
	void SetItemName(LPCTSTR lpszItemName);  // set name of linked item

	// link state
	BOOL IsConnected() const;   // returns TRUE if item has a client
	BOOL IsLinkedItem() const;  // returns TRUE if item is not embedded item

	// extents
	CSize m_sizeExtent;
		// HIMETRIC size -- the default implementation of OnSetExtent
		//  updates this member variable.  This member tells the server how
		//  much of the object is visible in the container document.

// Operations
public:
	void NotifyChanged(DVASPECT nDrawAspect = DVASPECT_CONTENT);
		// call this after you change item
	void CopyToClipboard(BOOL bIncludeLink = FALSE);
		// helper for implementing server 'copy to clipboard'
	DROPEFFECT DoDragDrop(LPCRECT lpRectItem, CPoint ptOffset,
		BOOL bIncludeLink = FALSE,
		DWORD dwEffects = DROPEFFECT_COPY|DROPEFFECT_MOVE,
		LPCRECT lpRectStartDrag = NULL);
	void GetClipboardData(COleDataSource* pDataSource,
		BOOL bIncludeLink = FALSE, LPPOINT lpOffset = NULL,
		LPSIZE lpSize = NULL);

// Overridables
	// overridables you must implement for yourself
	virtual BOOL OnDraw(CDC* pDC, CSize& rSize) = 0;
		// drawing for metafile format (return FALSE if not supported or error)
		//  (called for DVASPECT_CONTENT only)

	// overridables you may want to implement yourself
	virtual void OnUpdate(COleServerItem* pSender,
		LPARAM lHint, CObject* pHint, DVASPECT nDrawAspect);
		// the default implementation always calls NotifyChanged

	virtual BOOL OnDrawEx(CDC* pDC, DVASPECT nDrawAspect, CSize& rSize);
		// advanced drawing -- called for DVASPECT other than DVASPECT_CONTENT
	virtual BOOL OnSetExtent(DVASPECT nDrawAspect, const CSize& size);
	virtual BOOL OnGetExtent(DVASPECT nDrawAspect, CSize& rSize);
		// default implementation uses m_sizeExtent

	// overridables you do not have to implement
	virtual void OnDoVerb(LONG iVerb);
		// default routes to OnShow &/or OnOpen
	virtual BOOL OnSetColorScheme(const LOGPALETTE* lpLogPalette);
		// default does nothing
	virtual COleDataSource* OnGetClipboardData(BOOL bIncludeLink,
		LPPOINT lpOffset, LPSIZE lpSize);
		// called for access to clipboard data
	virtual BOOL OnQueryUpdateItems();
		// called to determine if there are any contained out-of-date links
	virtual void OnUpdateItems();
		// called to update any out-of-date links

protected:
	virtual void OnShow();
		// show item in the user interface (may edit in-place)
	virtual void OnOpen();
		// show item in the user interface (must open fully)
	virtual void OnHide();
		// hide document (and sometimes application)

	// very advanced overridables
public:
	virtual BOOL OnInitFromData(COleDataObject* pDataObject, BOOL bCreation);
		// initialize object from IDataObject

	// see COleDataSource for a description of these overridables
	virtual BOOL OnRenderGlobalData(LPFORMATETC lpFormatEtc, HGLOBAL* phGlobal);
	virtual BOOL OnRenderFileData(LPFORMATETC lpFormatEtc, CFile* pFile);
	virtual BOOL OnRenderData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium);
		// HGLOBAL version will be called first, then CFile* version

	virtual BOOL OnSetData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium,
		BOOL bRelease);
		// Rare -- only if you support SetData (programmatic paste)

	// advanced helpers for CopyToClipboard
	void GetEmbedSourceData(LPSTGMEDIUM lpStgMedium);
	void AddOtherClipboardData(COleDataSource* pDataSource);
	BOOL GetLinkSourceData(LPSTGMEDIUM lpStgMedium);
	void GetObjectDescriptorData(LPPOINT lpOffset, LPSIZE lpSize,
		LPSTGMEDIUM lpStgMedium);

// Implementation
public:
	BOOL m_bNeedUnlock;             // if TRUE need to pDoc->LockExternal(FALSE)
	BOOL m_bAutoDelete;             // if TRUE will OnRelease will 'delete this'

	// special version of OnFinalRelease to implement document locking
	virtual void OnFinalRelease();

protected:
	CString m_strItemName;          // simple item name

public:
	LPOLEADVISEHOLDER m_lpOleAdviseHolder;  // may be NULL
	LPDATAADVISEHOLDER m_lpDataAdviseHolder;    // may be NULL

	virtual ~COleServerItem() = 0;
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// implementation helpers
	void NotifyClient(OLE_NOTIFICATION wNotification, DWORD_PTR dwParam);
	LPDATAOBJECT GetDataObject();
	LPOLEOBJECT GetOleObject();
	LPMONIKER GetMoniker(OLEGETMONIKER nAssign);

protected:
	virtual BOOL GetMetafileData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM pmedium);
		// calls OnDraw or OnDrawEx
	virtual void OnSaveEmbedding(LPSTORAGE lpStorage);
	virtual BOOL IsBlank() const;

	// CItemDataSource implements OnRender reflections to COleServerItem
	class CItemDataSource : public COleDataSource
	{
	protected:
		// the GetData and SetData interfaces forward to m_pItem
		virtual BOOL OnRenderGlobalData(LPFORMATETC lpFormatEtc, HGLOBAL* phGlobal);
		virtual BOOL OnRenderFileData(LPFORMATETC lpFormatEtc, CFile* pFile);
		virtual BOOL OnRenderData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium);
			// HGLOBAL version will be called first, then CFile* version

		virtual BOOL OnSetData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium,
			BOOL bRelease);
	};
	CItemDataSource m_dataSource;
		// data source used to implement IDataObject

// Interface Maps
//  (Note: these interface maps are used just for link implementation)
public:
	BEGIN_INTERFACE_PART(OleObject, IOleObject)
		INIT_INTERFACE_PART(COleServerItem, OleObject)
		STDMETHOD(SetClientSite)(LPOLECLIENTSITE);
		STDMETHOD(GetClientSite)(LPOLECLIENTSITE*);
		STDMETHOD(SetHostNames)(LPCOLESTR, LPCOLESTR);
		STDMETHOD(Close)(DWORD);
		STDMETHOD(SetMoniker)(DWORD, LPMONIKER);
		STDMETHOD(GetMoniker)(DWORD, DWORD, LPMONIKER*);
		STDMETHOD(InitFromData)(LPDATAOBJECT, BOOL, DWORD);
		STDMETHOD(GetClipboardData)(DWORD, LPDATAOBJECT*);
		STDMETHOD(DoVerb)(LONG, LPMSG, LPOLECLIENTSITE, LONG, HWND, LPCRECT);
		STDMETHOD(EnumVerbs)(LPENUMOLEVERB*);
		STDMETHOD(Update)();
		STDMETHOD(IsUpToDate)();
		STDMETHOD(GetUserClassID)(LPCLSID);
		STDMETHOD(GetUserType)(DWORD, _Deref_out_z_ LPOLESTR*);
		STDMETHOD(SetExtent)(DWORD, LPSIZEL);
		STDMETHOD(GetExtent)(DWORD, LPSIZEL);
		STDMETHOD(Advise)(LPADVISESINK, LPDWORD);
		STDMETHOD(Unadvise)(DWORD);
		STDMETHOD(EnumAdvise)(LPENUMSTATDATA*);
		STDMETHOD(GetMiscStatus)(DWORD, LPDWORD);
		STDMETHOD(SetColorScheme)(LPLOGPALETTE);
	END_INTERFACE_PART(OleObject)

	BEGIN_INTERFACE_PART(DataObject, IDataObject)
		INIT_INTERFACE_PART(COleServerItem, DataObject)
		STDMETHOD(GetData)(LPFORMATETC, LPSTGMEDIUM);
		STDMETHOD(GetDataHere)(LPFORMATETC, LPSTGMEDIUM);
		STDMETHOD(QueryGetData)(LPFORMATETC);
		STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC, LPFORMATETC);
		STDMETHOD(SetData)(LPFORMATETC, LPSTGMEDIUM, BOOL);
		STDMETHOD(EnumFormatEtc)(DWORD, LPENUMFORMATETC*);
		STDMETHOD(DAdvise)(LPFORMATETC, DWORD, LPADVISESINK, LPDWORD);
		STDMETHOD(DUnadvise)(DWORD);
		STDMETHOD(EnumDAdvise)(LPENUMSTATDATA*);
	END_INTERFACE_PART(DataObject)

	DECLARE_INTERFACE_MAP()

	friend class CItemDataSource;
	friend class COleServerDoc;
	friend class COleLinkingDoc;
};

/////////////////////////////////////////////////////////////////////////////
// COleLinkingDoc -
//  (enables linking to embeddings - beginnings of server fuctionality)

class COleLinkingDoc : public COleDocument
{
	DECLARE_DYNAMIC(COleLinkingDoc)

// Constructors
public:
	COleLinkingDoc();

// Operations
	BOOL Register(COleObjectFactory* pFactory, LPCTSTR lpszPathName);
		// notify the running object table and connect to pServer
	void Revoke();
		// revoke from running object table

// Overridables
protected:
	virtual COleServerItem* OnGetLinkedItem(LPCTSTR lpszItemName);
		// return item for the named linked item (for supporting links)
	virtual COleClientItem* OnFindEmbeddedItem(LPCTSTR lpszItemName);
		// return item for the named embedded item (for links to embeddings)

// Implementation
public:
	COleObjectFactory* m_pFactory;  // back-pointer to server

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual ~COleLinkingDoc();

	// overrides for updating of monikers & running object table registration
	virtual BOOL OnNewDocument();
	virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
	virtual BOOL OnSaveDocument(LPCTSTR lpszPathName);
	virtual void OnCloseDocument();
	virtual LPOLEITEMCONTAINER GetContainer();
	virtual LPMONIKER GetMoniker(OLEGETMONIKER nAssign);

	// special handling of error messages during save/load
	virtual void ReportSaveLoadException(LPCTSTR lpszPathName,
		CException* e, BOOL bSaving, UINT nIDPDefault);
	void BeginDeferErrors();
	SCODE EndDeferErrors(SCODE sc);

protected:
	BOOL m_bDeferErrors;    // TRUE if in non-interactive OLE mode
	CException* m_pLastException;

	DWORD m_dwRegister;     // file moniker's registration in the ROT
	LPMONIKER m_lpMonikerROT; // file moniker that is registered
	CString m_strMoniker;   // filename used to create moniker
	BOOL m_bVisibleLock;    // TRUE if user is holding lock on document

	// implementation helpers
	virtual BOOL RegisterIfServerAttached(LPCTSTR lpszPathName, BOOL bMessage);
	void LockExternal(BOOL bLock, BOOL bRemoveRefs);
	void UpdateVisibleLock(BOOL bVisible, BOOL bRemoveRefs);
	virtual void OnShowViews(BOOL bVisible);

	virtual void SaveToStorage(CObject* pObject = NULL);

// Interface Maps
public:
	BEGIN_INTERFACE_PART(PersistFile, IPersistFile)
		INIT_INTERFACE_PART(COleLinkingDoc, PersistFile)
		STDMETHOD(GetClassID)(LPCLSID);
		STDMETHOD(IsDirty)();
		STDMETHOD(Load)(LPCOLESTR, DWORD);
		STDMETHOD(Save)(LPCOLESTR, BOOL);
		STDMETHOD(SaveCompleted)(LPCOLESTR);
		STDMETHOD(GetCurFile)(LPOLESTR*);
	END_INTERFACE_PART(PersistFile)

	BEGIN_INTERFACE_PART(OleItemContainer, IOleItemContainer)
		INIT_INTERFACE_PART(COleLinkingDoc, OleItemContainer)
		STDMETHOD(ParseDisplayName)(LPBC, LPOLESTR, ULONG*, LPMONIKER*);
		STDMETHOD(EnumObjects)(DWORD, LPENUMUNKNOWN*);
		STDMETHOD(LockContainer)(BOOL);
		STDMETHOD(GetObject)(LPOLESTR, DWORD, LPBINDCTX, REFIID, LPVOID*);
		STDMETHOD(GetObjectStorage)(LPOLESTR, LPBINDCTX, REFIID, LPVOID*);
		STDMETHOD(IsRunning)(LPOLESTR);
	END_INTERFACE_PART(OleItemContainer)

	DECLARE_INTERFACE_MAP()

	friend class COleClientItem;
	friend class COleClientItem::XOleClientSite;
	friend class COleServerItem::XOleObject;
};

//////////////////////////////////////////////////////////////////////////////
// COleServerDoc - registered server document containing COleServerItems

class AFX_NOVTABLE COleServerDoc : public COleLinkingDoc
{
	DECLARE_DYNAMIC(COleServerDoc)

// Constructors and Destructors
public:
	COleServerDoc();

// Attributes
	BOOL IsEmbedded() const;    // TRUE if document is an embedding
	BOOL IsDocObject() const;   // TRUE if document is a DocObject
	COleServerItem* GetEmbeddedItem();
		// return embedded item for document (will allocate if necessary)

	// attributes specific to in-place activation
	BOOL IsInPlaceActive() const;
	void GetItemPosition(LPRECT lpPosRect) const;
		// get current position rectangle of in-place edit
	void GetItemClipRect(LPRECT lpClipRect) const;
		// get current clipping rectangle of in-place edit
	BOOL GetZoomFactor(LPSIZE lpSizeNum = NULL, LPSIZE lpSizeDenom = NULL,
		LPCRECT lpPosRect = NULL) const;
		// returns the zoom factor in pixels

// Operations
	void NotifyChanged();
		// call this after you change some global attribute like
		//  document dimensions
	void UpdateAllItems(COleServerItem* pSender,
		LPARAM lHint = 0L, CObject* pHint = NULL,
		DVASPECT nDrawAspect = DVASPECT_CONTENT);

	// changes to the entire document (automatically notifies clients)
	void NotifyRename(LPCTSTR lpszNewName);
	void NotifySaved();
	void NotifyClosed();        // call this after you close document

	// specific operations for embedded documents
	void SaveEmbedding();       // call this to save embedded (before closing)

	// specific to in-place activation
	BOOL ActivateInPlace();
	void ActivateDocObject();
	void RequestPositionChange(LPCRECT lpPosRect);
	BOOL ScrollContainerBy(CSize sizeScroll);
	BOOL DeactivateAndUndo();
	BOOL DiscardUndoState();

public:
// Overridables for standard user interface (full server)
	virtual BOOL OnUpdateDocument(); // implementation of embedded update

protected:
// Overridables you must implement for yourself
	virtual COleServerItem* OnGetEmbeddedItem() = 0;
		// return item representing entire (embedded) document

// Overridables you do not have to implement
	virtual void OnClose(OLECLOSE dwCloseOption);
	virtual void OnSetHostNames(LPCTSTR lpszHost, LPCTSTR lpszHostObj);
	virtual HRESULT OnExecOleCmd(const GUID* pguidCmdGroup, DWORD nCmdID,
		DWORD nCmdExecOpt, VARIANTARG* pvarargIn, VARIANTARG* pvarargOut);
	virtual CDocObjectServer* GetDocObjectServer(LPOLEDOCUMENTSITE pDocSite);

// Advanced overridables
	LPUNKNOWN GetInterfaceHook(const void* piid);
	virtual void OnShowDocument(BOOL bShow);
		// show first frame for document or hide all frames for document

// Advanced overridables for in-place activation
public:
	virtual void OnDeactivate();
	virtual void OnDeactivateUI(BOOL bUndoable);
	virtual void OnDocWindowActivate(BOOL bActivate);
	virtual void OnShowControlBars(CFrameWnd* pFrameWnd, BOOL bShow);

protected:
	virtual void OnSetItemRects(LPCRECT lpPosRect, LPCRECT lpClipRect);
	virtual BOOL OnReactivateAndUndo();

	virtual void OnFrameWindowActivate(BOOL bActivate);

	virtual COleIPFrameWnd* CreateInPlaceFrame(CWnd* pParentWnd);
	virtual void DestroyInPlaceFrame(COleIPFrameWnd* pFrameWnd);
public:
	virtual void OnResizeBorder(LPCRECT lpRectBorder,
		LPOLEINPLACEUIWINDOW lpUIWindow, BOOL bFrame);

	LPOLECLIENTSITE GetClientSite() const;
// Implementation
protected:
	LPOLECLIENTSITE m_lpClientSite;     // for embedded item
	CString m_strHostObj;               // name of document in container
	BOOL m_bCntrVisible;                // TRUE if OnShowWindow(TRUE) called
	BOOL m_bClosing;                    // TRUE if shutting down
	COleServerItem* m_pEmbeddedItem;    // pointer to embedded item for document

	COleIPFrameWnd* m_pInPlaceFrame;    // not NULL if in-place activated
	CWnd* m_pOrigParent;                // not NULL if existing view used
	DWORD m_dwOrigStyle;                // original style of in-place view
	DWORD m_dwOrigStyleEx;              // original extended style

	CDocObjectServer* m_pDocObjectServer;  // if DocObject, ptr to doc site

public:
	virtual ~COleServerDoc() = 0;
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// overridables for implementation
	virtual BOOL OnSaveDocument(LPCTSTR lpszPathName);
	virtual void OnCloseDocument();
	virtual void DeleteContents(); // delete auto-delete server items
	virtual LPMONIKER GetMoniker(OLEGETMONIKER nAssign);
	virtual COleServerItem* OnGetLinkedItem(LPCTSTR lpszItemName);
		// return item for the named linked item (only if supporting links)
	virtual BOOL CanCloseFrame(CFrameWnd* pFrame);

protected:
	// overrides to handle server user-interface
	virtual BOOL SaveModified();        // return TRUE if ok to continue
	virtual HMENU GetDefaultMenu();     // return menu based on doc type
	virtual HACCEL GetDefaultAccelerator(); // return accel table based on doc type
	virtual BOOL GetFileTypeString(CString& rString);

	// IPersistStorage implementation
	virtual void OnNewEmbedding(LPSTORAGE lpStorage);
	virtual void OnOpenEmbedding(LPSTORAGE lpStorage);
	virtual void OnSaveEmbedding(LPSTORAGE lpStorage);

	// Implementation helpers
	void NotifyAllItems(OLE_NOTIFICATION wNotification, DWORD_PTR dwParam);
	BOOL SaveModifiedPrompt();
	void ConnectView(CWnd* pParentWnd, CView* pView);
	void UpdateUsingHostObj(UINT nIDS, CCmdUI* pCmdUI);

// Message Maps
	//{{AFX_MSG(COleServerDoc)
	afx_msg void OnFileUpdate();
	afx_msg void OnFileSaveCopyAs();
	afx_msg void OnUpdateFileUpdate(CCmdUI* pCmdUI);
	afx_msg void OnUpdateFileExit(CCmdUI* pCmdUI);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Interface Maps
public:
	BEGIN_INTERFACE_PART(PersistStorage, IPersistStorage)
		INIT_INTERFACE_PART(COleServerDoc, PersistStorage)
		STDMETHOD(GetClassID)(LPCLSID);
		STDMETHOD(IsDirty)();
		STDMETHOD(InitNew)(LPSTORAGE);
		STDMETHOD(Load)(LPSTORAGE);
		STDMETHOD(Save)(LPSTORAGE, BOOL);
		STDMETHOD(SaveCompleted)(LPSTORAGE);
		STDMETHOD(HandsOffStorage)();
	END_INTERFACE_PART(PersistStorage)

	BEGIN_INTERFACE_PART(OleObject, IOleObject)
		INIT_INTERFACE_PART(COleServerDoc, OleObject)
		STDMETHOD(SetClientSite)(LPOLECLIENTSITE);
		STDMETHOD(GetClientSite)(LPOLECLIENTSITE*);
		STDMETHOD(SetHostNames)(LPCOLESTR, LPCOLESTR);
		STDMETHOD(Close)(DWORD);
		STDMETHOD(SetMoniker)(DWORD, LPMONIKER);
		STDMETHOD(GetMoniker)(DWORD, DWORD, LPMONIKER*);
		STDMETHOD(InitFromData)(LPDATAOBJECT, BOOL, DWORD);
		STDMETHOD(GetClipboardData)(DWORD, LPDATAOBJECT*);
		STDMETHOD(DoVerb)(LONG, LPMSG, LPOLECLIENTSITE, LONG, HWND, LPCRECT);
		STDMETHOD(EnumVerbs)(IEnumOLEVERB**);
		STDMETHOD(Update)();
		STDMETHOD(IsUpToDate)();
		STDMETHOD(GetUserClassID)(CLSID*);
		STDMETHOD(GetUserType)(DWORD, LPOLESTR*);
		STDMETHOD(SetExtent)(DWORD, LPSIZEL);
		STDMETHOD(GetExtent)(DWORD, LPSIZEL);
		STDMETHOD(Advise)(LPADVISESINK, LPDWORD);
		STDMETHOD(Unadvise)(DWORD);
		STDMETHOD(EnumAdvise)(LPENUMSTATDATA*);
		STDMETHOD(GetMiscStatus)(DWORD, LPDWORD);
		STDMETHOD(SetColorScheme)(LPLOGPALETTE);
	END_INTERFACE_PART(OleObject)

	BEGIN_INTERFACE_PART(DataObject, IDataObject)
		INIT_INTERFACE_PART(COleServerDoc, DataObject)
		STDMETHOD(GetData)(LPFORMATETC, LPSTGMEDIUM);
		STDMETHOD(GetDataHere)(LPFORMATETC, LPSTGMEDIUM);
		STDMETHOD(QueryGetData)(LPFORMATETC);
		STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC, LPFORMATETC);
		STDMETHOD(SetData)(LPFORMATETC, LPSTGMEDIUM, BOOL);
		STDMETHOD(EnumFormatEtc)(DWORD, LPENUMFORMATETC*);
		STDMETHOD(DAdvise)(LPFORMATETC, DWORD, LPADVISESINK, LPDWORD);
		STDMETHOD(DUnadvise)(DWORD);
		STDMETHOD(EnumDAdvise)(LPENUMSTATDATA*);
	END_INTERFACE_PART(DataObject)

	BEGIN_INTERFACE_PART(OleInPlaceObject, IOleInPlaceObject)
		INIT_INTERFACE_PART(COleServerDoc, OleInPlaceObject)
		STDMETHOD(GetWindow)(HWND*);
		STDMETHOD(ContextSensitiveHelp)(BOOL);
		STDMETHOD(InPlaceDeactivate)();
		STDMETHOD(UIDeactivate)();
		STDMETHOD(SetObjectRects)(LPCRECT, LPCRECT);
		STDMETHOD(ReactivateAndUndo)();
	END_INTERFACE_PART(OleInPlaceObject)

	BEGIN_INTERFACE_PART(OleInPlaceActiveObject, IOleInPlaceActiveObject)
		INIT_INTERFACE_PART(COleServerDoc, OleInPlaceActiveObject)
		STDMETHOD(GetWindow)(HWND*);
		STDMETHOD(ContextSensitiveHelp)(BOOL);
		STDMETHOD(TranslateAccelerator)(LPMSG);
		STDMETHOD(OnFrameWindowActivate)(BOOL);
		STDMETHOD(OnDocWindowActivate)(BOOL);
		STDMETHOD(ResizeBorder)(LPCRECT, LPOLEINPLACEUIWINDOW, BOOL);
		STDMETHOD(EnableModeless)(BOOL);
	END_INTERFACE_PART(OleInPlaceActiveObject)

	DECLARE_INTERFACE_MAP()

	friend class COleServer;
	friend class COleServerItem;
	friend class CDocObjectServer;
};

//////////////////////////////////////////////////////////////////////////////
// COleIPFrameWnd

class COleCntrFrameWnd;

class COleIPFrameWnd : public CFrameWnd
{
	DECLARE_DYNCREATE(COleIPFrameWnd)

// Constructors
public:
	COleIPFrameWnd();

// Overridables
public:
	virtual BOOL OnCreateControlBars(CWnd* pWndFrame, CWnd* pWndDoc);
		// create control bars on container windows (pWndDoc can be NULL)
	virtual BOOL OnCreateControlBars(CFrameWnd* pWndFrame, CFrameWnd* pWndDoc);
		// create control bars on container windows (pWndDoc can be NULL)

	virtual void RepositionFrame(LPCRECT lpPosRect, LPCRECT lpClipRect);
		// Advanced: reposition frame to wrap around new lpPosRect

// Implementation
public:
	BOOL m_bUIActive;   // TRUE if currently in uiacitve state

	virtual BOOL LoadFrame(UINT nIDResource,
		DWORD dwDefaultStyle = WS_CHILD|WS_BORDER|WS_CLIPSIBLINGS,
		CWnd* pParentWnd = NULL,
		CCreateContext* pContext = NULL);
	virtual void RecalcLayout(BOOL bNotify = TRUE);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual LRESULT OnSetMessageString(WPARAM wParam, LPARAM lParam);
	virtual ~COleIPFrameWnd();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	CFrameWnd* GetDocFrame();
	CFrameWnd* GetMainFrame();
	HRESULT GetInPlaceFrame(LPOLEINPLACEUIWINDOW *ppUIWindow);
	HRESULT GetInPlaceDocFrame(LPOLEINPLACEUIWINDOW *ppUIWindow);
	void SetPreviewMode(BOOL bNewMode);

protected:
	// in-place state
	OLEINPLACEFRAMEINFO m_frameInfo;
	LPOLEINPLACEFRAME m_lpFrame;
	LPOLEINPLACEUIWINDOW m_lpDocFrame;
	COleCntrFrameWnd* m_pMainFrame;
	COleCntrFrameWnd* m_pDocFrame;

	HMENU m_hSharedMenu;
	OLEMENUGROUPWIDTHS m_menuWidths;
	HOLEMENU m_hOleMenu;
	CRect m_rectPos;            // client area rect of the item
	CRect m_rectClip;           // area to which frame should be clipped
	BOOL m_bInsideRecalc;
	BOOL m_bPreviewMode;
	HMENU m_hMenuHelpPopup;

	HMENU _m_Reserved;

	// Advanced: in-place activation virtual implementation
	virtual BOOL BuildSharedMenu();
	virtual void DestroySharedMenu();
	virtual HMENU GetInPlaceMenu();

	// Advanced: possible override to change in-place sizing behavior
	virtual void OnRequestPositionChange(LPCRECT lpRect);

protected:
	//{{AFX_MSG(COleIPFrameWnd)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg LRESULT OnRecalcParent(WPARAM wParam, LPARAM lParam);
	afx_msg void OnIdleUpdateCmdUI();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg LRESULT OnResizeChild(WPARAM wParam, LPARAM lParam);
	afx_msg void OnContextHelp();
	afx_msg void OnUpdateControlBarMenu(CCmdUI* pCmdUI);
	afx_msg BOOL OnBarCheck(UINT nID);
	afx_msg void OnWindowPosChanging(LPWINDOWPOS lpWndPos);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	friend class COleServerDoc;
	friend class COleCntrFrameWnd;
	friend class CDocObjectServer;
};

/////////////////////////////////////////////////////////////////////////////
// COleResizeBar - supports in-place resizing in server applications

class COleResizeBar : public CControlBar
{
	DECLARE_DYNAMIC(COleResizeBar)

// Constructors
public:
	COleResizeBar();
	virtual BOOL Create(CWnd* pParentWnd, DWORD dwStyle = WS_CHILD | WS_VISIBLE,
		UINT nID = AFX_IDW_RESIZE_BAR);

// Implementation
public:
	virtual ~COleResizeBar();
	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);

protected:
	CRectTracker m_tracker;     // implemented with a tracker

protected:
	//{{AFX_MSG(COleResizeBar)
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnPaint();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnLButtonDown(UINT, CPoint point);
	afx_msg LRESULT OnSizeParent(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// COleStreamFile - implementation of CFile which uses an IStream

class COleStreamFile : public CFile
{
	DECLARE_DYNAMIC(COleStreamFile)

private:
   using CFile::Open;

// Constructors and Destructors
public:
	/* explicit */ COleStreamFile(LPSTREAM lpStream = NULL);

// Operations
	// Note: OpenStream and CreateStream can accept eith STGM_ flags or
	//  CFile::OpenFlags bits since common values are guaranteed to have
	//  the same semantics.
	BOOL OpenStream(LPSTORAGE lpStorage, LPCTSTR lpszStreamName,
		DWORD nOpenFlags = modeReadWrite|shareExclusive,
		CFileException* pError = NULL);
	BOOL CreateStream(LPSTORAGE lpStorage, LPCTSTR lpszStreamName,
		DWORD nOpenFlags = modeReadWrite|shareExclusive|modeCreate,
		CFileException* pError = NULL);

	BOOL CreateMemoryStream(CFileException* pError = NULL);

	// attach & detach can be used when Open/Create functions aren't adequate
	void Attach(LPSTREAM lpStream);
	LPSTREAM Detach();

	IStream* GetStream() const;
	// Returns the current stream

// Implementation
public:
	LPSTREAM m_lpStream;
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual ~COleStreamFile();

	// attributes for implementation
	BOOL GetStatus(CFileStatus& rStatus) const;
	virtual ULONGLONG GetPosition() const;

	virtual const CString GetStorageName() const;

	// overrides for implementation
	virtual CFile* Duplicate() const;
	virtual ULONGLONG Seek(LONGLONG lOff, UINT nFrom);
	virtual void SetLength(ULONGLONG dwNewLen);
	virtual ULONGLONG GetLength() const;
	virtual UINT Read(void* lpBuf, UINT nCount);
	virtual void Write(const void* lpBuf, UINT nCount);
	virtual void LockRange(ULONGLONG dwPos, ULONGLONG dwCount);
	virtual void UnlockRange(ULONGLONG dwPos, ULONGLONG dwCount);
	virtual void Abort();
	virtual void Flush();
	virtual void Close();

protected:
	CString m_strStorageName;
};

/////////////////////////////////////////////////////////////////////////////
// CMonikerFile - implementation of COleStreamFile that uses an IMoniker to
//                get the IStream

class CMonikerFile: public COleStreamFile
{
	DECLARE_DYNAMIC(CMonikerFile)

private:
   using COleStreamFile::Open;

public:
	CMonikerFile();

	virtual BOOL Open(LPCTSTR lpszURL, CFileException* pError=NULL);
	// Uses synchronous URLMonikers to create a moniker.
	// Opens the URL specified.
	// If provided, pError will be set in case of error.
	// Return value: TRUE if successful, FALSE otherwise.

	virtual BOOL Open(IMoniker* pMoniker, CFileException* pError=NULL);
	// Binds to the provided moniker to obtain a stream.
	// If provided, pError will be set in case of error.
	// Return value: TRUE if successful, FALSE otherwise.

	virtual void Close();
	// Detaches the stream, Release()s it, and the moniker.  Close may be
	// called on unopened, or already closed streams.

	BOOL Detach(CFileException* pError = NULL);
	// Closes the stream.  If there is an error when closing, then the
	// error code will be placed in pError and the function will return FALSE.

	IMoniker* GetMoniker() const;
	// Returns the current moniker.  The moniker returned is not AddRef()'ed.

protected:
// Overidables
	IBindCtx* CreateBindContext(CFileException* pError);
	// A hook so users can provide a particular IBindCtx, potentially one
	// on which the user has registered one or more objects.

// Implementation
protected:
	virtual BOOL Open(LPCTSTR lpszUrl, IBindHost* pBindHost,
		IBindStatusCallback* pBSC, IBindCtx* pBindCtx, CFileException* pError);
	BOOL Attach(LPCTSTR lpszUrl, IBindHost* pBindHost,
		IBindStatusCallback* pBSC, IBindCtx* pBindCtx, CFileException* pError);
	virtual BOOL Open(IMoniker* pMoniker, IBindHost* pBindHost,
		IBindStatusCallback* pBSC, IBindCtx* pBindCtx, CFileException* pError);

	BOOL Attach(IMoniker* pMoniker, IBindHost* pBindHost,
		IBindStatusCallback* pBSC, IBindCtx* pBindCtx, CFileException* pError);

	virtual BOOL PostBindToStream(CFileException* pError);

	static IBindHost* CreateBindHost();
public:
	virtual ~CMonikerFile();
	// Closes the stream, and releases the moniker if needed.

	virtual void Flush();

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
	// Calls COleStreamFile::Dump(), and prints out moniker value.
#endif

protected:
	IPTR(IMoniker) m_Moniker;
	// The moniker provided or created to which this class is bound.

	CMonikerFile(const CMonikerFile&);
	// Prevents copying.
};

/////////////////////////////////////////////////////////////////////////////
// CAsyncMonikerFile - implementation of COleStreamFile that uses an
//                     asynchronous IMoniker to get the IStream

class _AfxBindStatusCallback; // Forward declaration

class CAsyncMonikerFile: public CMonikerFile
{
	DECLARE_DYNAMIC(CAsyncMonikerFile)

private:
   using CMonikerFile::Open;

public:
	CAsyncMonikerFile();
	// Creates the IBindStatusCallback used internally to provide asynchronous
	// operation.

	//All Open overloads call one of these two.
	virtual BOOL Open(LPCTSTR lpszURL, IBindHost* pBindHost,
		CFileException* pError=NULL);
	virtual BOOL Open(IMoniker* pMoniker, IBindHost* pBindHost,
		CFileException* pError=NULL);

	//Open overloads that take monikers
	virtual BOOL Open(IMoniker* pMoniker, CFileException* pError=NULL);
	virtual BOOL Open(IMoniker* pMoniker, IServiceProvider* pServiceProvider,
		CFileException* pError=NULL);
	virtual BOOL Open(IMoniker* pMoniker, IUnknown* pUnknown,
		CFileException* pError=NULL);

	//Open overloads that take strings
	virtual BOOL Open(LPCTSTR lpszURL, CFileException* pError=NULL);
	virtual BOOL Open(LPCTSTR lpszURL, IServiceProvider* pServiceProvider,
		CFileException* pError=NULL);
	virtual BOOL Open(LPCTSTR lpszURL, IUnknown* pUnknown,
		CFileException* pError=NULL);

	virtual void Close();

	IBinding* GetBinding() const;
	// Returns the binding provided when the asychronous transfer begins.
	// With the IBinding*, the user may abort, or pause the transfer.
	// NULL may be returned if for any reason the transfer could not be
	// made asynchronous, or if the IBinding* has not yet been provided by
	// the system.

	FORMATETC* GetFormatEtc() const;
	// Returns the FORMATETC for the currently opened stream.  NULL will be
	// returned if this is called from outside the context of OnDataAvailable.
	// If you want to keep the FORMATETC beyond this call, make a copy of it.
	// The FORMATETC indicates the format of the data in the stream.

protected:
// Overidables
	virtual IUnknown* CreateBindStatusCallback(IUnknown* pUnkControlling);

	virtual DWORD GetBindInfo() const;
	// Returns the settings returned by IBindStatusCallback::GetBindInfo.
	// The default values returned should work for most cases and should not
	// be changed lightly.

	virtual LONG GetPriority() const;
	// Returns the priority at which the asynchronous transfer will take
	// place.  The value is one of the standard thread priority flags.
	// By default THREAD_PRIORITY_NORMAL is returned.

	virtual void OnDataAvailable(DWORD dwSize, DWORD bscfFlag);
	// Called when there is data available to be read.  dwSize indicates
	// the cumulative number of bytes which can be read.  The bscfFlag may be used
	// to identify first, last, and intermediate blocks of data.

	virtual void OnLowResource();
	// This is called when resources are low.

	virtual void OnStartBinding();
	// Called when the binding is starting up.

	virtual void OnProgress(ULONG ulProgress, ULONG ulProgressMax,
		ULONG ulStatusCode, LPCTSTR szStatusText);

	virtual void OnStopBinding(HRESULT hresult, LPCTSTR szError);
	// Called when the transfer is stopped.  This function releases the
	// IBinding and should nearly always be call when overidden.

// Implementation
public:
	virtual ~CAsyncMonikerFile();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
	// Calls CMonikerFile::Dump(), and prints out IBinding,
	// IBindStatusCallback, and m_pFormatEtc values.
#endif
	virtual UINT Read(void* lpBuf, UINT nCount);

protected:
	friend class _AfxBindStatusCallback;
	_AfxBindStatusCallback* m_pAfxBSCCurrent;
	BOOL m_bStopBindingReceived;
	void EndCallbacks();

	IPTR(IBinding) m_Binding;
	FORMATETC* m_pFormatEtc;

	void SetBinding(IBinding* pBinding);
	// Sets and AddRefs m_Binding

	void SetFormatEtc(FORMATETC* pFormatEtc);
	// Sets the FORMATETC for the current stream.

	virtual BOOL PostBindToStream(CFileException* pError);
};

/////////////////////////////////////////////////////////////////////////////
// COleDropSource (advanced drop source support)

class COleDropSource : public CCmdTarget
{
// Constructors
public:
	COleDropSource();

// Overridables
	virtual SCODE QueryContinueDrag(BOOL bEscapePressed, DWORD dwKeyState);
	virtual SCODE GiveFeedback(DROPEFFECT dropEffect);
	virtual BOOL OnBeginDrag(CWnd* pWnd);

// Implementation
public:
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif

public:
	BEGIN_INTERFACE_PART(DropSource, IDropSource)
		INIT_INTERFACE_PART(COleDropSource, DropSource)
		STDMETHOD(QueryContinueDrag)(BOOL, DWORD);
		STDMETHOD(GiveFeedback)(DWORD);
	END_INTERFACE_PART(DropSource)

	DECLARE_INTERFACE_MAP()

	CRect m_rectStartDrag;  // when mouse leaves this rect, drag drop starts
	BOOL m_bDragStarted;    // has drag really started yet?
	DWORD m_dwButtonCancel; // which button will cancel (going down)
	DWORD m_dwButtonDrop;   // which button will confirm (going up)

	// metrics for drag start determination
	static AFX_DATA UINT nDragMinDist;  // min. amount mouse must move for drag
	static AFX_DATA UINT nDragDelay;    // delay before drag starts

	friend class COleDataSource;
};

/////////////////////////////////////////////////////////////////////////////
// COleDropTarget (advanced drop target support)

class COleDropTarget : public CCmdTarget
{
// Constructors
public:
	COleDropTarget();

// Operations
	BOOL Register(CWnd* pWnd);
	virtual void Revoke();  // virtual for implementation

// Overridables
	virtual DROPEFFECT OnDragEnter(CWnd* pWnd, COleDataObject* pDataObject,
		DWORD dwKeyState, CPoint point);
	virtual DROPEFFECT OnDragOver(CWnd* pWnd, COleDataObject* pDataObject,
		DWORD dwKeyState, CPoint point);
	virtual BOOL OnDrop(CWnd* pWnd, COleDataObject* pDataObject,
		DROPEFFECT dropEffect, CPoint point);
	virtual DROPEFFECT OnDropEx(CWnd* pWnd, COleDataObject* pDataObject,
		DROPEFFECT dropDefault, DROPEFFECT dropList, CPoint point);
	virtual void OnDragLeave(CWnd* pWnd);
	virtual DROPEFFECT OnDragScroll(CWnd* pWnd, DWORD dwKeyState,
		CPoint point);

// Implementation
public:
	virtual ~COleDropTarget();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	HWND m_hWnd;            // HWND this IDropTarget is attached to
	LPDATAOBJECT m_lpDataObject;    // != NULL between OnDragEnter, OnDragLeave
	UINT m_nTimerID;        // != MAKEWORD(-1, -1) when in scroll area
	DWORD m_dwLastTick;     // only valid when m_nTimerID valid
	UINT m_nScrollDelay;    // time to next scroll

	// metrics for drag-scrolling
	static AFX_DATA int nScrollInset;
	static AFX_DATA UINT nScrollDelay;
	static AFX_DATA UINT nScrollInterval;

	// implementation helpers
	void SetupTimer(CView* pView, UINT nTimerID);
	void CancelTimer(CWnd* pWnd);

// Interface Maps
public:
	BEGIN_INTERFACE_PART(DropTarget, IDropTarget)
		INIT_INTERFACE_PART(COleDropTarget, DropTarget)
		STDMETHOD(DragEnter)(LPDATAOBJECT, DWORD, POINTL, LPDWORD);
		STDMETHOD(DragOver)(DWORD, POINTL, LPDWORD);
		STDMETHOD(DragLeave)();
		STDMETHOD(Drop)(LPDATAOBJECT, DWORD, POINTL pt, LPDWORD);
	END_INTERFACE_PART(DropTarget)

	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// COleMessageFilter (implements IMessageFilter)

class COleMessageFilter : public CCmdTarget
{
// Constructors
public:
	COleMessageFilter();

// Operations
	BOOL Register();
	void Revoke();

	// for controlling the busy state of the server application (called app)
	virtual void BeginBusyState();
	virtual void EndBusyState();
	void SetBusyReply(SERVERCALL nBusyReply);

	// for controlling actions taken against rejected/retried calls
	void SetRetryReply(DWORD nRetryReply = 0);
		// only used when the "not responding" dialog is disabled
	void SetMessagePendingDelay(DWORD nTimeout = 5000);
		// used to determine amount of time before significant message
	void EnableBusyDialog(BOOL bEnableBusy = TRUE);
	void EnableNotRespondingDialog(BOOL bEnableNotResponding = TRUE);
		// used to enable/disable the two types of busy dialogs

// Overridables
	virtual BOOL OnMessagePending(const MSG* pMsg);
		// return TRUE to eat the message (usually only if processed)

// Implementation
public:
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual ~COleMessageFilter();
	virtual BOOL IsSignificantMessage(MSG* pMsg);
		// determine if any significant messages are present in the queue
	virtual int OnBusyDialog(HTASK htaskBusy);
	virtual int OnNotRespondingDialog(HTASK htaskBusy);
		// these functions display the busy dialog

protected:
	BOOL m_bRegistered;
	LONG m_nBusyCount;  // for BeginBusyState & EndBusyState
	BOOL m_bEnableBusy;
	BOOL m_bEnableNotResponding;
	BOOL m_bUnblocking;
	DWORD m_nRetryReply;    // only used if m_bEnableNotResponding == FALSE
	DWORD m_nBusyReply;
	DWORD m_nTimeout;

// Interface Maps
public:
	BEGIN_INTERFACE_PART(MessageFilter, IMessageFilter)
		INIT_INTERFACE_PART(COleMessageFilter, MessageFilter)
		STDMETHOD_(DWORD, HandleInComingCall)(DWORD, HTASK, DWORD,
			LPINTERFACEINFO);
		STDMETHOD_(DWORD, RetryRejectedCall)(HTASK, DWORD, DWORD);
		STDMETHOD_(DWORD, MessagePending)(HTASK, DWORD, DWORD);
	END_INTERFACE_PART(MessageFilter)

	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// message map entries for OLE verbs

#define ON_STDOLEVERB(iVerb, memberFxn) \
	{ 0xC002, 0, (UINT)iVerb, (UINT)iVerb, (UINT)-1, \
		(AFX_PMSG)(BOOL (AFX_MSG_CALL CCmdTarget::*)(LPMSG, HWND, LPCRECT))&memberFxn },

#define ON_OLEVERB(idsVerbName, memberFxn) \
	{ 0xC002, 0, 1, 1, idsVerbName, \
		(AFX_PMSG)(BOOL (AFX_MSG_CALL CCmdTarget::*)(LPMSG, HWND, LPCRECT))&memberFxn },

/////////////////////////////////////////////////////////////////////////////
// global helpers and debugging

void AFXAPI AfxOleSetEditMenu(COleClientItem* pClient, CMenu* pMenu,
	UINT iMenuItem, UINT nIDVerbMin, UINT nIDVerbMax = 0, UINT nIDConvert = 0);

#ifdef _DEBUG
// Mapping SCODEs to readable text
LPCTSTR AFXAPI AfxGetFullScodeString(SCODE sc);
LPCTSTR AFXAPI AfxGetScodeString(SCODE sc);
LPCTSTR AFXAPI AfxGetScodeRangeString(SCODE sc);
LPCTSTR AFXAPI AfxGetSeverityString(SCODE sc);
LPCTSTR AFXAPI AfxGetFacilityString(SCODE sc);

// Mapping IIDs to readable text
CString AFXAPI AfxGetIIDString(REFIID iid);
#endif

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXOLE_INLINE AFX_INLINE
#define _AFXOLECLI_INLINE AFX_INLINE
#define _AFXOLESVR_INLINE AFX_INLINE
#define _AFXOLEDOBJ_INLINE AFX_INLINE
#define _AFXOLEMONIKER_INLINE AFX_INLINE
#include <afxole.inl>
#undef _AFXOLE_INLINE
#undef _AFXOLECLI_INLINE
#undef _AFXOLESVR_INLINE
#undef _AFXOLEDOBJ_INLINE
#undef _AFXOLEMONIKER_INLINE
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _M_CEE
    #include <afxpriv.h>
#endif

#endif //__AFXOLE_H__

/////////////////////////////////////////////////////////////////////////////x
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxoledb.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXOLEDB_H__
#define __AFXOLEDB_H__

//#ifdef _AFX_NO_DAO_SUPPORT
//	#error OLE DB classes not supported in this library variant.
//#endif

#ifndef __AFXEXT_H__
	#include <afxext.h>
#endif

#include <atldbcli.h>

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 

/////////////////////////////////////////////////////////////////////////////
// Win32 libraries

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////

//CObject
	//CCmdTarget;
		//CWnd
			//CView
				//CScrollView
					//CFormView
						class COleDBRecordView; // view records with a form

/////////////////////////////////////////////////////////////////////////////

#undef AFX_DATA
#define AFX_DATA AFX_DB_DATA

void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, DB_NUMERIC& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, DBDATE& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, DBTIME& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, DBTIMESTAMP& value);

void AFXAPI DDX_DateTimeCtrl(CDataExchange* pDX, int nIDC, DBDATE& value);
void AFXAPI DDX_DateTimeCtrl(CDataExchange* pDX, int nIDC, DBTIME& value);
void AFXAPI DDX_DateTimeCtrl(CDataExchange* pDX, int nIDC, DBTIMESTAMP& value);
void AFXAPI DDX_MonthCalCtrl(CDataExchange* pDX, int nIDC, DBDATE& value);

/////////////////////////////////////////////////////////////////////////////
// CRecordView - form for viewing data records

class COleDBRecordView : public CFormView
{
	DECLARE_DYNAMIC(COleDBRecordView)

// Construction
protected:  // must derive your own class
	COleDBRecordView(LPCTSTR lpszTemplateName)
		: CFormView(lpszTemplateName)
	{
		m_bOnFirstRecord = TRUE;
		m_bOnLastRecord = FALSE;
	}
	COleDBRecordView(UINT nIDTemplate)
		: CFormView(nIDTemplate)
	{
		m_bOnFirstRecord = TRUE;
		m_bOnLastRecord = FALSE;
	}

// Attributes
public:
	virtual CRowset<>* OnGetRowset() = 0;

// Operations
public:
	virtual BOOL OnMove(UINT nIDMoveCommand);

// Implementation
public:
	virtual void OnInitialUpdate();

protected:
	BOOL m_bOnFirstRecord;
	BOOL m_bOnLastRecord;

	//{{AFX_MSG(CRecordView)
	afx_msg void OnUpdateRecordFirst(CCmdUI* pCmdUI);
	afx_msg void OnUpdateRecordPrev(CCmdUI* pCmdUI);
	afx_msg void OnUpdateRecordNext(CCmdUI* pCmdUI);
	afx_msg void OnUpdateRecordLast(CCmdUI* pCmdUI);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif __AFXOLEDB_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxolecntrframewndex.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxpriv.h"
#include "afxcontrolbarutil.h"
#include "afxdockingmanager.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// COleCntrFrameWndEx frame

class COleCntrFrameWndEx : public COleCntrFrameWnd
{
	friend class COleIPFrameWndEx;
	friend class COleDocIPFrameWndEx;

	DECLARE_DYNAMIC(COleCntrFrameWndEx)

public:
	COleCntrFrameWndEx(COleIPFrameWnd* pInPlaceFrame);

// Attributes
protected:
	CDockingManager m_dockManager;

// Operations
public:
	virtual BOOL OnShowPanes(BOOL bShow);

	void AddDockSite();
	BOOL AddPane(CBasePane* pControlBar, BOOL bTail = TRUE);
	BOOL InsertPane(CBasePane* pControlBar, CBasePane* pTarget, BOOL bAfter = TRUE);
	void RemovePaneFromDockManager(CBasePane* pControlBar, BOOL bDestroy, BOOL bAdjustLayout, BOOL bAutoHide, CBasePane* pBarReplacement);
	void DockPane(CBasePane* pBar, UINT nDockBarID = 0, LPCRECT lpRect = NULL);

	CBasePane* PaneFromPoint(CPoint point, int nSensitivity, bool bExactBar, CRuntimeClass* pRTCBarType) const;
	CBasePane* PaneFromPoint(CPoint point, int nSensitivity, DWORD& dwAlignment, CRuntimeClass* pRTCBarType) const;
	BOOL IsPointNearDockSite(CPoint point, DWORD& dwBarAlignment, BOOL& bOuterEdge) const;

	virtual void AdjustDockingLayout(HDWP hdwp = NULL);

	BOOL EnableDocking(DWORD dwDockStyle);
	BOOL EnableAutoHidePanes(DWORD dwDockStyle);

	CBasePane* GetPane(UINT nID);
	void ShowPane(CBasePane* pBar, BOOL bShow, BOOL bDelay, BOOL bActivate);

	virtual BOOL OnMoveMiniFrame(CWnd* pFrame);
	virtual void RecalcLayout(BOOL bNotify = TRUE);

	BOOL DockPaneLeftOf(CPane* pBar, CPane* pLeftOf);

	void CreateDockingManager() { m_dockManager.Create(this); }
	void AdjustClientArea();

// Overrides
	CDockingManager* GetDockingManager() {return &m_dockManager;}

protected:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

// Implementation
protected:
	virtual ~COleCntrFrameWndEx();

	//{{AFX_MSG(COleCntrFrameWndEx)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnSizing(UINT fwSide, LPRECT pRect);
	afx_msg void OnDestroy();
	afx_msg void OnIdleUpdateCmdUI();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxole.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXOLE.H

// more than one _INLINE type; can't use #pragma once

/////////////////////////////////////////////////////////////////////////////
// General OLE inlines (CDocItem, COleDocument)

#ifdef _AFXOLE_INLINE

// CDocItem
_AFXOLE_INLINE CDocument* CDocItem::GetDocument() const
	{ return m_pDocument; }

// COleDocument
_AFXOLE_INLINE void COleDocument::EnableCompoundFile(BOOL bEnable)
	{ m_bCompoundFile = bEnable; }

// COleMessageFilter
_AFXOLE_INLINE void COleMessageFilter::SetBusyReply(SERVERCALL nBusyReply)
	{ ASSERT_VALID(this); m_nBusyReply = nBusyReply; }
_AFXOLE_INLINE void COleMessageFilter::SetRetryReply(DWORD nRetryReply)
	{ ASSERT_VALID(this); m_nRetryReply = nRetryReply; }
_AFXOLE_INLINE void COleMessageFilter::SetMessagePendingDelay(DWORD nTimeout)
	{ ASSERT_VALID(this); m_nTimeout = nTimeout; }
_AFXOLE_INLINE void COleMessageFilter::EnableBusyDialog(BOOL bEnable)
	{ ASSERT_VALID(this); m_bEnableBusy = bEnable; }
_AFXOLE_INLINE void COleMessageFilter::EnableNotRespondingDialog(BOOL bEnable)
	{ ASSERT_VALID(this); m_bEnableNotResponding = bEnable; }

#endif //_AFXOLE_INLINE

/////////////////////////////////////////////////////////////////////////////
// OLE Moniker inlines

#ifdef _AFXOLEMONIKER_INLINE

// CMonikerFile
_AFXOLEMONIKER_INLINE CMonikerFile::CMonikerFile() { }
_AFXOLEMONIKER_INLINE IMoniker* CMonikerFile::GetMoniker() const
	{ ASSERT_VALID(this); return m_Moniker; }

// CAsyncMonikerFile
_AFXOLEMONIKER_INLINE IBinding* CAsyncMonikerFile::GetBinding() const
	{ ASSERT_VALID(this); return m_Binding; }
_AFXOLEMONIKER_INLINE void CAsyncMonikerFile::SetBinding(IBinding* pBinding)
	{ ASSERT_VALID(this); m_Binding=pBinding; }
_AFXOLEMONIKER_INLINE void CAsyncMonikerFile::SetFormatEtc(FORMATETC* pFormatEtc)
	{ ASSERT_VALID(this); m_pFormatEtc=pFormatEtc; }
_AFXOLEMONIKER_INLINE FORMATETC* CAsyncMonikerFile::GetFormatEtc() const
	{ ASSERT_VALID(this); return m_pFormatEtc; }

#endif //_AFXOLEMONIKER_INLINE

/////////////////////////////////////////////////////////////////////////////
// OLE automation inlines

#ifdef _AFXDISP_INLINE

// COleException
_AFXDISP_INLINE COleException::COleException()
	{ m_sc = S_OK; }
_AFXDISP_INLINE COleException::~COleException()
	{ }

// CCmdTarget
_AFXDISP_INLINE DWORD CCmdTarget::InternalAddRef()
	{ ASSERT(GetInterfaceMap() != NULL); return InterlockedIncrement(&m_dwRef); }

// CObjectFactory
_AFXDISP_INLINE BOOL COleObjectFactory::IsRegistered() const
	{ ASSERT_VALID(this); return m_dwRegister != 0; }
_AFXDISP_INLINE REFCLSID COleObjectFactory::GetClassID() const
	{ ASSERT_VALID(this); return m_clsid; }

// COleDispatchDriver
_AFXDISP_INLINE COleDispatchDriver::~COleDispatchDriver()
	{ ReleaseDispatch(); }
_AFXDISP_INLINE COleDispatchDriver::operator LPDISPATCH()
	{ return m_lpDispatch; }

// COleVariant
_AFXDISP_INLINE COleVariant::COleVariant()
	{ AfxVariantInit(this); }
_AFXDISP_INLINE COleVariant::~COleVariant()
	{ VERIFY(::VariantClear(this) == NOERROR); }
_AFXDISP_INLINE void COleVariant::Clear()
	{ VERIFY(::VariantClear(this) == NOERROR); }
_AFXDISP_INLINE COleVariant::COleVariant(LPCTSTR lpszSrc)
	{ vt = VT_EMPTY; *this = lpszSrc; }
_AFXDISP_INLINE COleVariant::COleVariant(CString& strSrc)
	{ vt = VT_EMPTY; *this = strSrc; }
_AFXDISP_INLINE COleVariant::COleVariant(BYTE nSrc)
	{ vt = VT_UI1; bVal = nSrc; }
_AFXDISP_INLINE COleVariant::COleVariant(const COleCurrency& curSrc)
	{ vt = VT_CY; cyVal = curSrc.m_cur; }
#if (_WIN32_WINNT >= 0x0501) || defined(_ATL_SUPPORT_VT_I8)
_AFXDISP_INLINE COleVariant::COleVariant(LONGLONG nSrc)
	{ vt = VT_I8; llVal = nSrc; }
_AFXDISP_INLINE COleVariant::COleVariant(ULONGLONG nSrc)
	{ vt = VT_UI8; ullVal = nSrc; }
#endif
_AFXDISP_INLINE COleVariant::COleVariant(float fltSrc)
	{ vt = VT_R4; fltVal = fltSrc; }
_AFXDISP_INLINE COleVariant::COleVariant(double dblSrc)
	{ vt = VT_R8; dblVal = dblSrc; }
_AFXDISP_INLINE COleVariant::COleVariant(const COleDateTime& dateSrc)
	{ vt = VT_DATE; date = dateSrc; }
_AFXDISP_INLINE COleVariant::COleVariant(const CByteArray& arrSrc)
	{ vt = VT_EMPTY; *this = arrSrc; }
_AFXDISP_INLINE COleVariant::COleVariant(const CLongBinary& lbSrc)
	{ vt = VT_EMPTY; *this = lbSrc; }
_AFXDISP_INLINE BOOL COleVariant::operator==(LPCVARIANT pSrc) const
	{ return *this == *pSrc; }
_AFXDISP_INLINE COleVariant::operator LPVARIANT()
	{ return this; }
_AFXDISP_INLINE COleVariant::operator LPCVARIANT() const
	{ return this; }

// COleCurrency
_AFXDISP_INLINE COleCurrency::COleCurrency()
	{ m_cur.Hi = 0; m_cur.Lo = 0; SetStatus(valid); }
_AFXDISP_INLINE COleCurrency::COleCurrency(CURRENCY cySrc)
	{ m_cur = cySrc; SetStatus(valid); }
_AFXDISP_INLINE COleCurrency::COleCurrency(const COleCurrency& curSrc)
	{ m_cur = curSrc.m_cur; m_status = curSrc.m_status; }
_AFXDISP_INLINE COleCurrency::COleCurrency(const VARIANT& varSrc)
	{ *this = varSrc; }
_AFXDISP_INLINE COleCurrency::CurrencyStatus COleCurrency::GetStatus() const
	{ return m_status; }
_AFXDISP_INLINE void COleCurrency::SetStatus(CurrencyStatus status)
	{ m_status = status; }
_AFXDISP_INLINE const COleCurrency& COleCurrency::operator+=(const COleCurrency& cur)
	{ *this = *this + cur; return *this; }
_AFXDISP_INLINE const COleCurrency& COleCurrency::operator-=(const COleCurrency& cur)
	{ *this = *this - cur; return *this; }
_AFXDISP_INLINE const COleCurrency& COleCurrency::operator*=(long nOperand)
	{ *this = *this * nOperand; return *this; }
_AFXDISP_INLINE const COleCurrency& COleCurrency::operator/=(long nOperand)
	{ *this = *this / nOperand; return *this; }
_AFXDISP_INLINE BOOL COleCurrency::operator==(const COleCurrency& cur) const
	{ return(m_status == cur.m_status && m_cur.Hi == cur.m_cur.Hi &&
		m_cur.Lo == cur.m_cur.Lo); }
_AFXDISP_INLINE BOOL COleCurrency::operator!=(const COleCurrency& cur) const
	{ return(m_status != cur.m_status || m_cur.Hi != cur.m_cur.Hi ||
		m_cur.Lo != cur.m_cur.Lo); }
_AFXDISP_INLINE COleCurrency::operator CURRENCY() const
	{ return m_cur; }

// COleSafeArray
_AFXDISP_INLINE COleSafeArray::COleSafeArray()
	{ AfxSafeArrayInit(this);
		vt = VT_EMPTY; }
_AFXDISP_INLINE COleSafeArray::~COleSafeArray()
	{ Clear(); }
_AFXDISP_INLINE void COleSafeArray::Clear()
	{ VERIFY(::VariantClear(this) == NOERROR); }
_AFXDISP_INLINE COleSafeArray::operator LPVARIANT()
	{ return this; }
_AFXDISP_INLINE COleSafeArray::operator LPCVARIANT() const
	{ return this; }
_AFXDISP_INLINE DWORD COleSafeArray::GetDim()
	{ return ::SafeArrayGetDim(parray); }
_AFXDISP_INLINE DWORD COleSafeArray::GetElemSize()
	{ return ::SafeArrayGetElemsize(parray); }

#endif //_AFXDISP_INLINE

/////////////////////////////////////////////////////////////////////////////
// OLE Container inlines

#ifdef _AFXOLECLI_INLINE

// COleClientItem
_AFXOLECLI_INLINE SCODE COleClientItem::GetLastStatus() const
	{ ASSERT_VALID(this); return m_scLast; }
_AFXOLECLI_INLINE COleDocument* COleClientItem::GetDocument() const
	{ ASSERT_VALID(this); return (COleDocument*)m_pDocument; }
_AFXOLECLI_INLINE OLE_OBJTYPE COleClientItem::GetType() const
	{ ASSERT_VALID(this); return m_nItemType; }
_AFXOLECLI_INLINE DVASPECT COleClientItem::GetDrawAspect() const
	{ ASSERT_VALID(this); return m_nDrawAspect; }
_AFXOLECLI_INLINE BOOL COleClientItem::IsRunning() const
	{ ASSERT_VALID(this);
		ASSERT(m_lpObject != NULL);
		return ::OleIsRunning(m_lpObject); }
_AFXOLECLI_INLINE UINT COleClientItem::GetItemState() const
	{ ASSERT_VALID(this); return m_nItemState; }
_AFXOLECLI_INLINE BOOL COleClientItem::IsInPlaceActive() const
	{ ASSERT_VALID(this);
		return m_nItemState == activeState || m_nItemState == activeUIState; }
_AFXOLECLI_INLINE BOOL COleClientItem::IsOpen() const
	{ ASSERT_VALID(this); return m_nItemState == openState; }
_AFXOLECLI_INLINE BOOL COleClientItem::IsLinkUpToDate() const
	{ ASSERT_VALID(this);
		ASSERT(m_lpObject != NULL);
		// TRUE if result is S_OK (aka S_TRUE)
		return m_lpObject->IsUpToDate() == NOERROR; }
_AFXOLECLI_INLINE CView* COleClientItem::GetActiveView() const
	{ return m_pView; }

// COleLinkingDoc
_AFXOLECLI_INLINE void COleLinkingDoc::BeginDeferErrors()
	{ ASSERT(m_pLastException == NULL); ++m_bDeferErrors; }

#endif //_AFXOLECLI_INLINE

#ifdef _AFXOLEDOBJ_INLINE

// COleDataObject
_AFXOLEDOBJ_INLINE COleDataObject::~COleDataObject()
	{ Release(); }

#endif //_AFXOLECTL_INLINE

/////////////////////////////////////////////////////////////////////////////
// OLE dialog inlines

#ifdef _AFXODLGS_INLINE

_AFXODLGS_INLINE UINT COleDialog::GetLastError() const
	{ return m_nLastError; }
_AFXODLGS_INLINE CString COleInsertDialog::GetPathName() const
	{ ASSERT_VALID(this);
		ASSERT(GetSelectionType() != createNewItem); return m_szFileName; }
_AFXODLGS_INLINE REFCLSID COleInsertDialog::GetClassID() const
	{ ASSERT_VALID(this); return m_io.clsid; }
_AFXODLGS_INLINE HGLOBAL COleInsertDialog::GetIconicMetafile() const
	{ ASSERT_VALID(this); return m_io.hMetaPict; }
_AFXODLGS_INLINE DVASPECT COleInsertDialog::GetDrawAspect() const
	{ ASSERT_VALID(this); return m_io.dwFlags & IOF_CHECKDISPLAYASICON ?
		DVASPECT_ICON : DVASPECT_CONTENT; }
_AFXODLGS_INLINE HGLOBAL COleConvertDialog::GetIconicMetafile() const
	{ ASSERT_VALID(this); return m_cv.hMetaPict; }
_AFXODLGS_INLINE DVASPECT COleConvertDialog::GetDrawAspect() const
	{ ASSERT_VALID(this); return (DVASPECT)m_cv.dvAspect; }
_AFXODLGS_INLINE REFCLSID COleConvertDialog::GetClassID() const
	{ ASSERT_VALID(this); return m_cv.clsidNew; }
_AFXODLGS_INLINE HGLOBAL COleChangeIconDialog::GetIconicMetafile() const
	{ ASSERT_VALID(this); return m_ci.hMetaPict; }
_AFXODLGS_INLINE int COlePasteSpecialDialog::GetPasteIndex() const
	{ ASSERT_VALID(this); return m_ps.nSelectedIndex; }
_AFXODLGS_INLINE DVASPECT COlePasteSpecialDialog::GetDrawAspect() const
	{ ASSERT_VALID(this); return m_ps.dwFlags & PSF_CHECKDISPLAYASICON ?
		DVASPECT_ICON : DVASPECT_CONTENT; }
_AFXODLGS_INLINE HGLOBAL COlePasteSpecialDialog::GetIconicMetafile() const
	{ ASSERT_VALID(this); return m_ps.hMetaPict; }
_AFXODLGS_INLINE UINT COleBusyDialog::GetSelectionType() const
	{ ASSERT_VALID(this); return m_selection; }

_AFXODLGS_INLINE BOOL COleChangeSourceDialog::IsValidSource()
	{ return m_cs.dwFlags & CSF_VALIDSOURCE; }
_AFXODLGS_INLINE CString COleChangeSourceDialog::GetDisplayName()
	{ return m_cs.lpszDisplayName; }
_AFXODLGS_INLINE CString COleChangeSourceDialog::GetFileName()
	{ return CString(m_cs.lpszDisplayName, m_cs.nFileLength); }
_AFXODLGS_INLINE CString COleChangeSourceDialog::GetItemName()
	{ return m_cs.lpszDisplayName+m_cs.nFileLength; }
_AFXODLGS_INLINE CString COleChangeSourceDialog::GetFromPrefix()
	{ return m_cs.lpszFrom; }
_AFXODLGS_INLINE CString COleChangeSourceDialog::GetToPrefix()
	{ return m_cs.lpszTo; }

#endif //_AFXODLGS_INLINE

/////////////////////////////////////////////////////////////////////////////
// OLE Server inlines

#ifdef _AFXOLESVR_INLINE

// COleServerItem
_AFXOLESVR_INLINE COleServerDoc* COleServerItem::GetDocument() const
	{ ASSERT_VALID(this); return (COleServerDoc*)m_pDocument; }
_AFXOLESVR_INLINE void COleServerItem::NotifyChanged(DVASPECT nDrawAspect)
	{ ASSERT_VALID(this); NotifyClient(OLE_CHANGED, nDrawAspect); }
_AFXOLESVR_INLINE const CString& COleServerItem::GetItemName() const
	{ ASSERT_VALID(this); return m_strItemName; }
_AFXOLESVR_INLINE void COleServerItem::SetItemName(LPCTSTR lpszItemName)
{
	ASSERT_VALID(this);
	ASSERT(lpszItemName != NULL);
	ASSERT(AfxIsValidString(lpszItemName));
	m_strItemName = lpszItemName;
}
_AFXOLESVR_INLINE BOOL COleServerItem::IsLinkedItem() const
	{ ASSERT_VALID(this); return GetDocument()->m_pEmbeddedItem != this; }
_AFXOLESVR_INLINE COleDataSource* COleServerItem::GetDataSource()
	{ ASSERT_VALID(this); return &m_dataSource; }

// COleServerDoc
_AFXOLESVR_INLINE void COleServerDoc::NotifyChanged()
	{ ASSERT_VALID(this); NotifyAllItems(OLE_CHANGED, DVASPECT_CONTENT); }
_AFXOLESVR_INLINE void COleServerDoc::NotifyClosed()
	{ ASSERT_VALID(this); NotifyAllItems(OLE_CLOSED, 0); }
_AFXOLESVR_INLINE void COleServerDoc::NotifySaved()
	{ ASSERT_VALID(this); NotifyAllItems(OLE_SAVED, 0); }
_AFXOLESVR_INLINE BOOL COleServerDoc::IsEmbedded() const
	{ ASSERT_VALID(this); return m_bEmbedded; }
_AFXOLESVR_INLINE BOOL COleServerDoc::IsDocObject() const
	{ ASSERT_VALID(this); return m_pDocObjectServer != NULL; }
_AFXOLESVR_INLINE BOOL COleServerDoc::IsInPlaceActive() const
	{ ASSERT_VALID(this); return m_pInPlaceFrame != NULL; }
_AFXOLESVR_INLINE LPOLECLIENTSITE COleServerDoc::GetClientSite() const
	{ ASSERT_VALID(this); return m_lpClientSite; }

// COleIPFrameWnd
_AFXOLESVR_INLINE CFrameWnd* COleIPFrameWnd::GetDocFrame() { return (CFrameWnd*)m_pDocFrame; }
_AFXOLESVR_INLINE CFrameWnd* COleIPFrameWnd::GetMainFrame() { return (CFrameWnd*)m_pMainFrame; }
_AFXOLESVR_INLINE HRESULT COleIPFrameWnd::GetInPlaceFrame(LPOLEINPLACEUIWINDOW *ppUIWindow)
{
	HRESULT hr = E_UNEXPECTED;
	if (m_pMainFrame && m_lpFrame)
	{
		hr = m_lpFrame->QueryInterface(IID_IOleInPlaceUIWindow, (void**)ppUIWindow);
	}
	return hr;
}
_AFXOLESVR_INLINE HRESULT COleIPFrameWnd::GetInPlaceDocFrame(LPOLEINPLACEUIWINDOW *ppUIWindow)
{
	HRESULT hr = E_UNEXPECTED;
	if (m_pDocFrame && m_lpDocFrame)
	{
		hr = m_lpDocFrame->QueryInterface(IID_IOleInPlaceUIWindow, (void**)ppUIWindow);
	}
	return hr;
}
_AFXOLESVR_INLINE void COleIPFrameWnd::SetPreviewMode(BOOL bNewMode) { m_bPreviewMode = bNewMode; }

#endif //_AFXOLESVR_INLINE

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxoleserverdocex.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// COleServerDocEx document

class COleServerDocEx : public COleServerDoc
{
protected:
	COleServerDocEx();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(COleServerDocEx)

// Overrides
public:
	virtual void Serialize(CArchive& ar);   // overridden for document i/o

protected:
	virtual BOOL OnNewDocument();
	virtual COleServerItem* OnGetEmbeddedItem();
	virtual void OnResizeBorder( LPCRECT lpRectBorder, LPOLEINPLACEUIWINDOW lpUIWindow, BOOL bFrame );
	virtual void OnShowControlBars(CFrameWnd* pFrameWnd, BOOL bShow);
	virtual void OnDocWindowActivate( BOOL bActivate );

// Implementation
public:
	virtual ~COleServerDocEx();

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	//{{AFX_MSG(COleServerDocEx)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxoleipframewndex.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxframeimpl.h"
#include "afxcontrolbarutil.h"
#include "afxpopupmenu.h"
#include "afxdockingmanager.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCMenuBar;
class CMFCToolBarMenuButton;
class CMFCToolBarButton;
class COleCntrFrameWndEx;

/////////////////////////////////////////////////////////////////////////////
// COleIPFrameWndEx window

class COleIPFrameWndEx : public COleIPFrameWnd
{
	friend class CMFCMenuBar;
	friend class CMFCToolBar;
	friend class CWinAppEx;
	friend class CMFCPopupMenu;
	friend class CPaneFrameWnd;

	DECLARE_DYNCREATE(COleIPFrameWndEx)

// Construction
protected:
	COleIPFrameWndEx();           // protected constructor used by dynamic creation

// Attributes
public:
	BOOL IsMenuBarAvailable() const { return m_Impl.GetMenuBar() != NULL; }
	const CMFCMenuBar* GetMenuBar() const { return m_Impl.GetMenuBar(); }
	UINT GetDefaultResId() const { return m_Impl.m_nIDDefaultResource; }
	CMFCPopupMenu* GetActivePopup() const { return CMFCPopupMenu::m_pActivePopupMenu; }
	const CObList& GetTearOffBars() const { return m_Impl.m_listTearOffToolbars; }

	CFrameWnd* GetMainFrame() { return (CFrameWnd*) m_pMainFrame; }
	CFrameWnd* GetDockFrame() { return (CFrameWnd*) m_pDocFrame; }
	CDockingManager* GetDockingManager() { return &m_dockManager; }

	COleCntrFrameWndEx* GetContainerFrameWindow();

protected:
	BOOL  m_bIsTlbCustMode;
	BOOL  m_bContextHelp;
	HMENU m_hmenuWindow;
	HWND  m_hwndLastTopLevelFrame;
	CFrameImpl m_Impl;
	CDockingManager  m_dockManager;

// Operations
public:
	virtual BOOL OnShowPanes(BOOL bShow);

	//------------------ dockmanager layer ------------
	void AddDockSite();
	BOOL AddPane(CBasePane* pControlBar, BOOL bTail = TRUE);
	BOOL InsertPane(CBasePane* pControlBar, CBasePane* pTarget, BOOL bAfter = TRUE);
	void RemovePaneFromDockManager(CBasePane* pControlBar, BOOL bDestroy, BOOL bAdjustLayout, BOOL bAutoHide, CBasePane* pBarReplacement);
	void DockPane(CBasePane* pBar, UINT nDockBarID = 0, LPCRECT lpRect = NULL);

	CBasePane* PaneFromPoint(CPoint point, int nSensitivity, bool bExactBar, CRuntimeClass* pRTCBarType) const;
	CBasePane* PaneFromPoint(CPoint point, int nSensitivity, DWORD& dwAlignment, CRuntimeClass* pRTCBarType) const;
	BOOL IsPointNearDockSite(CPoint point, DWORD& dwBarAlignment, BOOL& bOuterEdge) const;
	virtual void AdjustDockingLayout(HDWP hdwp = NULL);
	BOOL EnableDocking(DWORD dwDockStyle);
	BOOL EnableAutoHidePanes(DWORD dwDockStyle);

	CBasePane* GetPane(UINT nID);
	void ShowPane(CBasePane* pBar, BOOL bShow, BOOL bDelay, BOOL bActivate);

	virtual BOOL OnMoveMiniFrame(CWnd* pFrame);
	virtual void RecalcLayout(BOOL bNotify = TRUE);
	//-------------------------------------------------
	
	BOOL DockPaneLeftOf(CPane* pBar, CPane* pLeftOf);
	void SetupToolbarMenu(CMenu& menu, const UINT uiViewUserToolbarCmdFirst, const UINT uiViewUserToolbarCmdLast)
	{
		m_Impl.SetupToolbarMenu(menu, uiViewUserToolbarCmdFirst, uiViewUserToolbarCmdLast);
	}

	void SetDockState(const CDockState& state) { m_Impl.SetDockState(state); }

	void EnablePaneMenu(BOOL bEnable, UINT uiCustomizeCmd, const CString& strCustomizeLabel, UINT uiViewToolbarsMenuEntryID,
		BOOL bContextMenuShowsToolbarsOnly = FALSE, BOOL bViewMenuShowsToolbarsOnly = FALSE)
	{
		m_dockManager.EnablePaneContextMenu(bEnable, uiCustomizeCmd, strCustomizeLabel, bContextMenuShowsToolbarsOnly);
		m_Impl.SetControlbarsMenuId(uiViewToolbarsMenuEntryID, bViewMenuShowsToolbarsOnly);
	}

protected:

// Implementation:
	void InitUserToolbars(LPCTSTR lpszRegEntry, UINT uiUserToolbarFirst, UINT uiUserToolbarLast)
	{
		m_Impl.InitUserToolbars(lpszRegEntry, uiUserToolbarFirst, uiUserToolbarLast);
	}

	void LoadUserToolbars() { m_Impl.LoadUserToolbars(); }
	void SaveUserToolbars() { m_Impl.SaveUserToolbars(); }
	void LoadTearOffMenus() { m_Impl.LoadTearOffMenus(); }
	void SaveTearOffMenus() { m_Impl.SaveTearOffMenus(); }

	BOOL IsDockStateValid(const CDockState& state) { return m_Impl.IsDockStateValid(state); }
	CMFCToolBar* GetUserToolBarByIndex(int iIndex) const { return m_Impl.GetUserToolBarByIndex(iIndex); }

// Overrides
public:
	virtual BOOL LoadFrame(UINT nIDResource, DWORD dwDefaultStyle = WS_OVERLAPPEDWINDOW | FWS_ADDTOTITLE, CWnd* pParentWnd = NULL, CCreateContext* pContext = NULL);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual void WinHelp(DWORD dwData, UINT nCmd = HELP_CONTEXT);
	virtual void OnSetPreviewMode(BOOL bPreview, CPrintPreviewState* pState);
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);

protected:
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

	virtual void HtmlHelp(DWORD_PTR dwData, UINT nCmd = 0x000F);
	virtual BOOL OnCreateControlBars(CFrameWnd* pWndFrame, CFrameWnd* pWndDoc);

// Implementation
protected:
	virtual ~COleIPFrameWndEx();

	BOOL OnSetMenu(HMENU hmenu);
	BOOL ShowPopupMenu(CMFCPopupMenu* pMenuPopup);

public:
	virtual BOOL OnShowPopupMenu(CMFCPopupMenu* /*pMenuPopup*/) { return TRUE; }

	virtual BOOL OnShowCustomizePane(CMFCPopupMenu* pMenuPane, UINT uiToolbarID)
	{
		m_Impl.AddDefaultButtonsToCustomizePane(pMenuPane, uiToolbarID);
		return TRUE;
	}

	virtual void OnClosePopupMenu(CMFCPopupMenu* pMenuPopup);
	virtual BOOL OnDrawMenuImage(	CDC* /*pDC*/, const CMFCToolBarMenuButton* /*pMenuButton*/, const CRect& /*rectImage*/) { return FALSE; }
	virtual BOOL OnMenuButtonToolHitTest(CMFCToolBarButton* /*pButton*/, TOOLINFO* /*pTI*/) { return FALSE; }
	virtual BOOL GetToolbarButtonToolTipText(CMFCToolBarButton* /*pButton*/, CString& /*strTTText*/) { return FALSE; }

	virtual void OnDrawMenuLogo(CDC* /*pDC*/, CMFCPopupMenu* /*pMenu*/, const CRect& /*rectLogo*/){}

	virtual BOOL OnTearOffMenu(CMFCPopupMenu* /*pMenuPopup*/, CPane* /*pBar*/) { return TRUE; }
	virtual BOOL OnCloseMiniFrame(CPaneFrameWnd* /*pWnd*/) { return TRUE; }
	virtual BOOL OnCloseDockingPane(CDockablePane* /*pWnd*/) { return TRUE; }

protected:
	//{{AFX_MSG(COleIPFrameWndEx)
	afx_msg LRESULT OnMenuChar(UINT nChar, UINT nFlags, CMenu* pMenu);
	afx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);
	afx_msg void OnClose();
	afx_msg void OnDestroy();
	afx_msg LRESULT OnSetMenu(WPARAM wp, LPARAM);
	afx_msg LRESULT OnToolbarCreateNew(WPARAM,LPARAM);
	afx_msg LRESULT OnToolbarDelete(WPARAM,LPARAM);
	afx_msg void OnContextHelp();
	afx_msg void OnUpdatePaneMenu(CCmdUI* pCmdUI);
	afx_msg BOOL OnPaneCheck(UINT nID);
	afx_msg LRESULT OnIdleUpdateCmdUI(WPARAM wParam, LPARAM);
	afx_msg LRESULT OnToolbarContextMenu(WPARAM,LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxoutlookbar.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxbasetabbedpane.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCOutlookBarPane;

/////////////////////////////////////////////////////////////////////////////
// CMFCOutlookBar window

class CMFCOutlookBar : public CBaseTabbedPane
{
	DECLARE_SERIAL(CMFCOutlookBar)

// Construction
public:
	CMFCOutlookBar();
	virtual ~CMFCOutlookBar();

// Attributes
	virtual BOOL CanAcceptPane(const CBasePane* pBar) const;
	virtual BOOL AllowDestroyEmptyTabbedPane() const 
	{
		// allow to destroy only when the outlook can be floating (dynamic)
		return CanFloat();
	}

	virtual void OnScroll(BOOL /*bDown*/) {}

	void SetMode2003(BOOL bMode2003 = TRUE);
	BOOL IsMode2003() const { return m_bMode2003; }
	
	virtual BOOL CanSetCaptionTextToTabName() const { return m_bMode2003 ? TRUE : CBaseTabbedPane::CanSetCaptionTextToTabName(); }

	CFont* GetButtonsFont() const { return m_pFontButtons; }

	void SetButtonsFont(CFont* pFont, BOOL bRedraw = TRUE);

// Overrides
	virtual BOOL Create(LPCTSTR lpszCaption, CWnd* pParentWnd, const RECT& rect, UINT nID, DWORD dwStyle, DWORD dwControlBarStyle = AFX_CBRS_RESIZE, CCreateContext* pContext = NULL);
	virtual void GetTabArea(CRect& rectTabAreaTop, CRect& rectTabAreaBottom) const;
	virtual AFX_CS_STATUS GetDockingStatus(CPoint pt, int nSensitivity);

// Implementation
	CMFCOutlookBarPane* CreateCustomPage(LPCTSTR lpszPageName, BOOL bActivatePage = TRUE, DWORD dwEnabledDocking = CBRS_ALIGN_ANY, BOOL bEnableTextLabels = TRUE);

	BOOL RemoveCustomPage(UINT uiPage, CMFCOutlookBarTabCtrl* pTargetWnd);

	virtual BOOL LoadState(LPCTSTR lpszProfileName, int nIndex, UINT uiID);
	virtual BOOL SaveState(LPCTSTR lpszProfileName, int nIndex, UINT uiID);

	virtual BOOL OnBeforeAnimation(int /*nPage*/) { return TRUE; }
	virtual void OnAfterAnimation(int /*nPage*/) {}

	virtual BOOL FloatTab(CWnd* pBar, int nTabID, AFX_DOCK_METHOD dockMethod, BOOL bHide);
	virtual void GetPaneName(CString& strName) const { strName = m_strBarName; }

protected:
	//{{AFX_MSG(CMFCOutlookBar)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Attributes
public:
	virtual BOOL DoesAllowDynInsertBefore() const {return FALSE;}

protected:
	UINT FindAvailablePageID();

protected:
	CObList m_lstCustomPages;
	BOOL    m_bMode2003;
	CFont*  m_pFontButtons;
	CString m_strBarName;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxoledocipframewndex.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#ifndef __AFXDOCOB_H__
#include <afxdocob.h>
#endif

#include "afxcontrolbarutil.h"
#include "afxframeimpl.h"
#include "afxpopupmenu.h"
#include "afxdockingmanager.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCMenuBar;
class CMFCToolBarMenuButton;
class CMFCToolBarButton;

/////////////////////////////////////////////////////////////////////////////
// COleDocIPFrameWndEx frame

class COleDocIPFrameWndEx : public COleDocIPFrameWnd
{
	friend class CMFCPopupMenu;
	friend class CPaneFrameWnd;
	friend class COleCntrFrameWndEx;

	DECLARE_DYNCREATE(COleDocIPFrameWndEx)

// Construction
protected:
	COleDocIPFrameWndEx();           // protected constructor used by dynamic creation

// Attributes
public:
	BOOL IsMenuBarAvailable() const { return m_Impl.GetMenuBar() != NULL; }
	const CMFCMenuBar* GetMenuBar() const { return m_Impl.GetMenuBar(); }

	UINT GetDefaultResId() const { return m_Impl.m_nIDDefaultResource; }
	CMFCPopupMenu*	GetActivePopup() const { return CMFCPopupMenu::m_pActivePopupMenu; }
	const CObList& GetTearOffBars() const { return m_Impl.m_listTearOffToolbars; }

protected:
	HMENU m_hmenuWindow;
	BOOL  m_bContextHelp;
	HWND  m_hwndLastTopLevelFrame;

	CFrameImpl m_Impl;
	CDockingManager  m_dockManager;

// Operations
public:
	virtual BOOL OnShowPanes(BOOL bShow);

	//------------------ dockmanager layer ------------
	void AddDockSite();
	BOOL AddPane(CBasePane* pControlBar, BOOL bTail = TRUE);
	BOOL InsertPane(CBasePane* pControlBar, CBasePane* pTarget, BOOL bAfter = TRUE);
	void RemovePaneFromDockManager(CBasePane* pControlBar, BOOL bDestroy, BOOL bAdjustLayout, BOOL bAutoHide, CBasePane* pBarReplacement);
	void DockPane(CBasePane* pBar, UINT nDockBarID = 0, LPCRECT lpRect = NULL);

	CBasePane* PaneFromPoint(CPoint point, int nSensitivity, bool bExactBar, CRuntimeClass* pRTCBarType) const;
	CBasePane* PaneFromPoint(CPoint point, int nSensitivity, DWORD& dwAlignment, CRuntimeClass* pRTCBarType) const;
	BOOL IsPointNearDockSite(CPoint point, DWORD& dwBarAlignment, BOOL& bOuterEdge) const;
	virtual void AdjustDockingLayout(HDWP hdwp = NULL);
	BOOL EnableDocking(DWORD dwDockStyle);
	BOOL EnableAutoHidePanes(DWORD dwDockStyle);

	CBasePane* GetPane(UINT nID);
	void ShowPane(CBasePane* pBar, BOOL bShow, BOOL bDelay, BOOL bActivate);

	virtual BOOL OnMoveMiniFrame(CWnd* pFrame);
	virtual void RecalcLayout(BOOL bNotify = TRUE);
	BOOL DockPaneLeftOf(CPane* pBar, CPane* pLeftOf);
	//-------------------------------------------------

	void SetupToolbarMenu(CMenu& menu, const UINT uiViewUserToolbarCmdFirst, const UINT uiViewUserToolbarCmdLast)
	{
		m_Impl.SetupToolbarMenu(menu, uiViewUserToolbarCmdFirst, uiViewUserToolbarCmdLast);
	}

	void SetDockState(const CDockState& state) { m_Impl.SetDockState(state); }
	CDockingManager* GetDockingManager() { return &m_dockManager; }

	COleCntrFrameWndEx* GetContainerFrameWindow();

	void EnablePaneMenu(BOOL bEnable, UINT uiCustomizeCmd, const CString& strCustomizeLabel,UINT uiViewToolbarsMenuEntryID, 
		BOOL bContextMenuShowsToolbarsOnly = FALSE, BOOL bViewMenuShowsToolbarsOnly = FALSE)
	{
		m_dockManager.EnablePaneContextMenu(bEnable, uiCustomizeCmd, strCustomizeLabel, bContextMenuShowsToolbarsOnly);
		m_Impl.SetControlbarsMenuId(uiViewToolbarsMenuEntryID, bViewMenuShowsToolbarsOnly);
	}

protected:

// Implementation:
	void InitUserToolbars(LPCTSTR lpszRegEntry, UINT uiUserToolbarFirst, UINT uiUserToolbarLast)
	{
		m_Impl.InitUserToolbars(lpszRegEntry, uiUserToolbarFirst, uiUserToolbarLast);
	}

	void LoadUserToolbars() { m_Impl.LoadUserToolbars(); }
	void SaveUserToolbars() { m_Impl.SaveUserToolbars(); }
	void LoadTearOffMenus() { m_Impl.LoadTearOffMenus(); }
	void SaveTearOffMenus() { m_Impl.SaveTearOffMenus(); }

	BOOL IsDockStateValid(const CDockState& state) { return m_Impl.IsDockStateValid(state); }
	CMFCToolBar* GetUserToolBarByIndex(int iIndex) const { return m_Impl.GetUserToolBarByIndex(iIndex); }

// Overrides
public:
	virtual BOOL LoadFrame(UINT nIDResource, DWORD dwDefaultStyle = WS_OVERLAPPEDWINDOW | FWS_ADDTOTITLE, CWnd* pParentWnd = NULL, CCreateContext* pContext = NULL);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual void WinHelp(DWORD dwData, UINT nCmd = HELP_CONTEXT);
	virtual void OnSetPreviewMode(BOOL bPreview, CPrintPreviewState* pState);
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);

protected:
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

	virtual void HtmlHelp(DWORD_PTR dwData, UINT nCmd = 0x000F);
	virtual BOOL OnCreateControlBars(CFrameWnd* pWndFrame, CFrameWnd* pWndDoc);

// Implementation
protected:
	virtual ~COleDocIPFrameWndEx();

	BOOL OnSetMenu(HMENU hmenu);
	BOOL ShowPopupMenu(CMFCPopupMenu* pMenuPopup);

public:
	virtual BOOL OnShowPopupMenu(CMFCPopupMenu* /*pMenuPopup*/) { return TRUE; }

	virtual BOOL OnShowCustomizePane(CMFCPopupMenu* pMenuPane, UINT uiToolbarID)
	{
		m_Impl.AddDefaultButtonsToCustomizePane(pMenuPane, uiToolbarID);
		return TRUE;
	}

	virtual void OnClosePopupMenu(CMFCPopupMenu* pMenuPopup);
	virtual BOOL OnDrawMenuImage(	CDC* /*pDC*/, const CMFCToolBarMenuButton* /*pMenuButton*/, const CRect& /*rectImage*/) { return FALSE; }
	virtual BOOL OnMenuButtonToolHitTest(CMFCToolBarButton* /*pButton*/, TOOLINFO* /*pTI*/) { return FALSE; }
	virtual BOOL GetToolbarButtonToolTipText(CMFCToolBarButton* /*pButton*/, CString& /*strTTText*/) { return FALSE; }

	virtual void OnDrawMenuLogo(CDC* /*pDC*/, CMFCPopupMenu* /*pMenu*/, const CRect& /*rectLogo*/){}

	virtual BOOL OnTearOffMenu(CMFCPopupMenu* /*pMenuPopup*/, CPane* /*pBar*/) { return TRUE; }
	virtual BOOL OnCloseMiniFrame(CPaneFrameWnd* /*pWnd*/) { return TRUE; }
	virtual BOOL OnCloseDockingPane(CDockablePane* /*pWnd*/) { return TRUE; }

protected:
	//{{AFX_MSG(COleDocIPFrameWndEx)
	afx_msg LRESULT OnMenuChar(UINT nChar, UINT nFlags, CMenu* pMenu);
	afx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);
	afx_msg void OnClose();
	afx_msg void OnDestroy();
	afx_msg LRESULT OnSetMenu(WPARAM wp, LPARAM);
	afx_msg LRESULT OnToolbarCreateNew(WPARAM,LPARAM);
	afx_msg LRESULT OnToolbarDelete(WPARAM,LPARAM);
	afx_msg void OnContextHelp();
	afx_msg void OnUpdatePaneMenu(CCmdUI* pCmdUI);
	afx_msg BOOL OnPaneCheck(UINT nID);
	afx_msg LRESULT OnIdleUpdateCmdUI(WPARAM wParam, LPARAM);
	afx_msg LRESULT OnToolbarContextMenu(WPARAM,LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxoutlookbarpaneadapter.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxdockablepaneadapter.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCOutlookBarPaneAdapter window

class CMFCOutlookBarPaneAdapter : public CDockablePaneAdapter
{
	DECLARE_SERIAL(CMFCOutlookBarPaneAdapter)
// Construction
public:
	CMFCOutlookBarPaneAdapter();

// Implementation
public:
	virtual ~CMFCOutlookBarPaneAdapter();

protected:
	//{{AFX_MSG(CMFCOutlookBarPaneAdapter)
	afx_msg void OnNcDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxoutlookbarpane.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxtoolbar.h"
#include "afxbutton.h"
#include "afxtoolbarimages.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCOutlookBarPane window

class CMFCOutlookBarPane : public CMFCToolBar
{
	friend class CMFCVisualManager;
	friend class CMFCOutlookBarTabCtrl;

	DECLARE_SERIAL(CMFCOutlookBarPane)

// Construction
public:
	CMFCOutlookBarPane();

// Attributes
public:

// Operations
public:
	//--------------------
	// Add/remove buttons:
	//--------------------

	BOOL AddButton(UINT uiImage, LPCTSTR lpszLabel, UINT iIdCommand, int iInsertAt = -1);
	BOOL AddButton(UINT uiImage, UINT uiLabel, UINT iIdCommand, int iInsertAt = -1);
	BOOL AddButton(LPCTSTR szBmpFileName, LPCTSTR szLabel, UINT iIdCommand, int iInsertAt = -1);

	BOOL AddButton(HBITMAP hBmp, LPCTSTR lpszLabel, UINT iIdCommand, int iInsertAt = -1);
	BOOL AddButton(HICON hIcon, LPCTSTR lpszLabel, UINT iIdCommand, int iInsertAt = -1, BOOL bAlphaBlend = FALSE);

	BOOL RemoveButton(UINT iIdCommand);

	void ClearAll();
	void SetDefaultState();

	//--------------
	// General look:
	//--------------
	void SetTextColor(COLORREF clrRegText, COLORREF clrSelText = 0/* Obsolete*/);
	void SetTransparentColor(COLORREF color);
	void SetBackImage(UINT uiImageID);
	void SetBackColor(COLORREF color);

	// Set extra space between buttons
	void SetExtraSpace(int nSpace) { m_nExtraSpace = nSpace; }
	virtual BOOL CanBeAttached() const { return TRUE; }

	virtual AFX_CS_STATUS IsChangeState(int nOffset, CBasePane** ppTargetBar) const;
	virtual BOOL Dock(CBasePane* pDockBar, LPCRECT lpRect, AFX_DOCK_METHOD dockMethod);
	virtual BOOL OnBeforeFloat(CRect& rectFloat, AFX_DOCK_METHOD dockMethod);

	virtual BOOL RestoreOriginalstate();
	virtual BOOL SmartUpdate(const CObList& lstPrevButtons);

	virtual BOOL CanBeRestored() const { return !m_OrigButtons.IsEmpty(); }

	virtual void RemoveAllButtons();

protected:
	BOOL InternalAddButton(int iImageIndex, LPCTSTR szLabel, UINT iIdCommand, int iInsertAt = -1);
	int	 AddBitmapImage(HBITMAP hBitmap);

	void ScrollUp();
	void ScrollDown();
	void ScrollPageUp();
	void ScrollPageDown();

	void CopyButtonsList(const CObList& lstSrc, CObList& lstDst);

// Overrides
	virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);

	virtual void AdjustLocations();
	virtual void DoPaint(CDC* pDC);
	virtual DROPEFFECT OnDragOver(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point);
	virtual CMFCToolBarButton* CreateDroppedButton(COleDataObject* pDataObject);

	virtual BOOL EnableContextMenuItems(CMFCToolBarButton* pButton, CMenu* pPopup);

	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual void OnEraseWorkArea(CDC* pDC, CRect rectWorkArea);

	virtual DWORD GetCurrentAlignment() const { return (m_dwStyle & CBRS_ALIGN_ANY) & ~CBRS_ORIENT_HORZ; }

	virtual BOOL AllowShowOnList() const { return FALSE; }
	virtual BOOL CanFloat() const { return FALSE; }

	virtual void AddRemoveSeparator(const CMFCToolBarButton* /*pButton*/, const CPoint& /*ptStart*/, const CPoint& /*ptDrop*/) {}
	virtual BOOL AllowShowOnPaneMenu() const { return FALSE; }

public:
	virtual BOOL Create(CWnd* pParentWnd, DWORD dwStyle = AFX_DEFAULT_TOOLBAR_STYLE, UINT uiID = (UINT)-1, DWORD dwControlBarStyle = 0);

// Implementation
public:
	virtual ~CMFCOutlookBarPane();

protected:
	//{{AFX_MSG(CMFCOutlookBarPane)
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp);
	afx_msg void OnSysColorChange();
	afx_msg void OnTimer(UINT_PTR nIDEvent);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnNcDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	COLORREF GetRegularColor() const { return m_clrRegText; }
	BOOL IsDrawShadedHighlight() const { return m_bDrawShadedHighlight; }
	BOOL IsBackgroundTexture() const { return m_bmpBack.GetCount() != 0; }
	void EnablePageScrollMode(BOOL bPageScroll = TRUE) { m_bPageScrollMode = bPageScroll; }

// Attributes:
protected:
	COLORREF m_clrRegText;
	COLORREF m_clrTransparentColor;
	COLORREF m_clrBackColor;

	CMFCToolBarImages m_bmpBack;
	CMFCButton  m_btnUp;
	CMFCButton  m_btnDown;

	UINT m_uiBackImageId;
	int  m_nSize;           // Width or Height, orientation dependable
	int  m_iScrollOffset;
	int  m_iFirstVisibleButton;
	int  m_nExtraSpace;

	HWND m_hRecentOutlookWnd;
	BOOL m_bScrollDown;
	BOOL m_bDrawShadedHighlight;
	BOOL m_bDontAdjustLayout;
	BOOL m_bPageScrollMode;

	AFX_IMPORT_DATA static CSize          m_csImage;
	AFX_IMPORT_DATA static CMFCToolBarImages m_Images;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxoutlookbarpanebutton.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxtoolbarbutton.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCOutlookBarPane;

class CMFCOutlookBarPaneButton : public CMFCToolBarButton
{
	friend class CMFCOutlookBarPane;

	DECLARE_SERIAL(CMFCOutlookBarPaneButton)

public:
	CMFCOutlookBarPaneButton();
	virtual ~CMFCOutlookBarPaneButton();

	virtual void OnDraw(CDC* pDC, const CRect& rect, CMFCToolBarImages* pImages, BOOL bHorz = TRUE, BOOL bCustomizeMode = FALSE,
		BOOL bHighlight = FALSE, BOOL bDrawBorder = TRUE, BOOL bGrayDisabledButtons = TRUE);
	virtual SIZE OnCalculateSize(CDC* pDC, const CSize& sizeDefault, BOOL bHorz);
	virtual void OnChangeParentWnd(CWnd* pWndParent);

	virtual BOOL CanBeDropped(CMFCToolBar* pToolbar);
	virtual void SetImage(int iImage);

protected:
	CMFCOutlookBarPane* m_pWndParentBar;
	CSize            m_sizeImage;
	BOOL             m_bIsWholeText;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxpane.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxbasepane.h"
#include "afxrecentdocksiteinfo.h"
#include "afxdragframeimpl.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#pragma warning( disable : 4100 34 )

/////////////////////////////////////////////////////////////////////////////
// CPane window

class CDockSite;
class CFrameWndEx;
class CDockingPanesRow;
class CPaneFrameWnd;
class CDockingManager;


// CS - change state status
typedef enum AFX_CS_STATUS
{
	CS_NOTHING,
	CS_DOCK_IMMEDIATELY,
	CS_DELAY_DOCK,
	CS_DELAY_DOCK_TO_TAB
};


static const DWORD AFX_DEFAULT_PANE_STYLE = AFX_CBRS_FLOAT | AFX_CBRS_CLOSE;
static const int AFX_DEFAULT_TOOLBAR_STYLE = (WS_CHILD | WS_VISIBLE | CBRS_TOP | CBRS_GRIPPER | CBRS_HIDE_INPLACE);


/////////////////////////////////////////////////////////////////////////////
// CPane window

class CPane : public CBasePane
{
	friend class CPaneFrameWnd;
	friend class CMultiPaneFrameWnd;

	DECLARE_DYNCREATE(CPane)

// Construction
protected:
	CPane();

// Attributes
public:

	virtual BOOL CanBeDocked(CBasePane* pDockBar) const;
	virtual BOOL IsResizable() const { return FALSE; }
	virtual BOOL IsDragMode() const { return m_bDragMode; }
	virtual void GetMinSize(CSize& size) const { size = m_sizeMin; }

	AFX_IMPORT_DATA static BOOL m_bHandleMinSize;

	void SetMinSize(const CSize& size) { m_sizeMin = size; }
	virtual int GetMinLength() const { return IsHorizontal() ? 10 : 10; }
	virtual int GetResizeStep() const { return -1; }

	CPoint GetHotSpot() const { return m_dragFrameImpl.m_ptHot; }
	CPoint GetClientHotSpot() const { return m_ptClientHotSpot; }
	void SetClientHotSpot(const CPoint& ptNew) { m_ptClientHotSpot = ptNew; }

	virtual BOOL IsInFloatingMultiPaneFrameWnd() const { return FALSE; }

	virtual int GetAvailableExpandSize() const;
	virtual int GetAvailableStretchSize() const;
	
	virtual BOOL DoesAllowSiblingBars() const { return !m_bExclusiveRow; }

	bool IsLeftOf(CRect rect, bool bWindowRect = true) const;
	bool IsLastPaneOnLastRow() const;

	virtual BOOL IsTabbed() const;
	virtual void CopyState(CPane* pOrgBar);

	virtual BOOL AllowShowOnPaneMenu() const { return TRUE; }
	virtual void GetPaneName(CString& strName) const;

	CDockingPanesRow* GetDockSiteRow() const { return m_pDockBarRow; }
	void GetDockSiteRow(CDockingPanesRow* pRow) { m_pDockBarRow = pRow; }

	void GetVirtualRect(CRect& rectVirtual) const;
	void SetVirtualRect(const CRect& rect, BOOL bMapToParent = TRUE);
	void UpdateVirtualRect();
	void UpdateVirtualRect(CPoint ptOffset);
	void UpdateVirtualRect(CSize sizeNew);
	
	bool m_bDisableMove;
	BOOL m_bFirstInGroup;
	BOOL m_bLastInGroup;
	BOOL m_bActiveInGroup;

	virtual void SetActiveInGroup(BOOL bActive);

	virtual void SetExclusiveRowMode(BOOL bExclusive = TRUE) { m_bExclusiveRow = bExclusive; }
	virtual BOOL GetExclusiveRowMode() const { return m_bExclusiveRow; }

// Operations
public:
	virtual void PrepareToDock(CDockSite* pDockBar, AFX_DOCK_METHOD dockMethod);
	virtual BOOL DockPane(CBasePane* pDockBar, LPCRECT lpRect, AFX_DOCK_METHOD dockMethod);
	virtual BOOL DockByMouse(CBasePane* pDockBar);
	virtual BOOL DockToFrameWindow(DWORD dwAlignment, LPCRECT lpRect = NULL, DWORD dwDockFlags = DT_DOCK_LAST, 
		CBasePane* pRelativeBar = NULL, int nRelativeIndex = -1, BOOL bOuterEdge = FALSE)
	{
		return FALSE;
	}

	virtual BOOL FloatPane(CRect rectFloat, AFX_DOCK_METHOD dockMethod = DM_UNKNOWN, bool bShow = true);
	virtual CSize CalcSize(BOOL bVertDock) {return CSize(0, 0);}
	
	BOOL MoveByAlignment(DWORD dwAlignment, int nOffset);
	virtual CSize MovePane(CRect rectNew, BOOL bForceMove, HDWP& hdwp);
	virtual int  StretchPaneDeferWndPos(int nStretchSize, HDWP& hdwp);

	virtual CPane* DockPaneStandard(BOOL& bWasDocked)
	{
		bWasDocked = FALSE;
		return this;
	}
	virtual AFX_CS_STATUS IsChangeState(int nOffset, CBasePane** ppTargetBar) const;

	virtual CPaneFrameWnd* CreateDefaultMiniframe(CRect rectInitial);

	virtual BOOL LoadState(LPCTSTR lpszProfileName = NULL, int nIndex = -1, UINT uiID = (UINT) -1);
	virtual BOOL SaveState(LPCTSTR lpszProfileName = NULL, int nIndex = -1, UINT uiID = (UINT) -1);

	virtual void SetDockState(CDockingManager* pDockManager);
	virtual void OnProcessDblClk();

	virtual BOOL OnBeforeFloat(CRect& rectFloat, AFX_DOCK_METHOD dockMethod);
	virtual void OnAfterFloat();

	virtual void UndockPane(BOOL bDelay = FALSE);

// Overrides
public:
	virtual BOOL Create(LPCTSTR lpszClassName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, DWORD dwControlBarStyle = AFX_DEFAULT_PANE_STYLE, CCreateContext* pContext = NULL);
	virtual BOOL CreateEx(DWORD dwStyleEx, LPCTSTR lpszClassName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, DWORD dwControlBarStyle = AFX_DEFAULT_PANE_STYLE, CCreateContext* pContext = NULL);

	virtual void OnBeforeChangeParent(CWnd* pWndNewParent, BOOL bDelay = FALSE);
	virtual void OnAfterChangeParent(CWnd* pWndOldParent);

	virtual void RecalcLayout();
	virtual CSize CalcAvailableSize(CRect rectRequired);

	void SetMiniFrameRTC(CRuntimeClass* pClass)	{m_pMiniFrameRTC = pClass;}

	virtual void AdjustSizeImmediate(BOOL bRecalcLayout = TRUE);

	virtual void ToggleAutoHide()	{}
	virtual void OnPressCloseButton();

	virtual BOOL CanBeTabbedDocument() const;
	virtual void ConvertToTabbedDocument(BOOL bActiveTabOnly = TRUE);

public:
	virtual BOOL OnShowControlBarMenu(CPoint point);
	
protected:
	virtual BOOL OnBeforeShowPaneMenu(CMenu& /*menu*/) { return TRUE; }
	virtual BOOL OnAfterShowPaneMenu(int nMenuResult) { return TRUE; }

	virtual void OnContinueMoving();
	virtual void OnDrawDragRect(LPCRECT /*lprectNew*/, LPCRECT /*lprectOld*/) {}
	
	virtual BOOL OnBeforeDock(CBasePane** ppDockBar, LPCRECT lpRect, AFX_DOCK_METHOD dockMethod);
	virtual void OnAfterDock(CBasePane* /*pBar*/, LPCRECT /*lpRect*/, AFX_DOCK_METHOD /*dockMethod*/) {}

	virtual void OnBeforeStretch(int& /*nStretchSize*/) {}
	virtual void OnAfterStretch(int /*nStretchSize*/) {}
	
	virtual void RemoveFromMiniframe(CWnd* pNewParent, AFX_DOCK_METHOD dockMethod);
	virtual void SetDragMode(BOOL bOnOff);

	virtual BOOL Dock(CBasePane* pDockBar, LPCRECT lpRect, AFX_DOCK_METHOD dockMethod);

	virtual void EnterDragMode(BOOL bChangeHotPoint);
	virtual void OnRTLChanged(BOOL bIsRTL);

	// Implementation
public:
	virtual ~CPane();
	
	//---------------------------------------------------------------------------------------------
	// FOR COMPATIBILITY with MFC's CControlBar:
	//----------------------------------------------------------------------------------------------
	void SetBorders(int cxLeft = 0, int cyTop = 0, int cxRight = 0, int cyBottom = 0);
	void SetBorders(LPCRECT lpRect);
	CRect GetBorders() const;

	// array of elements
	int m_nCount;
	void* m_pData;        // m_nCount elements - type depends on derived class

	// info about bar (for status bar and toolbar)
	int m_cxLeftBorder, m_cxRightBorder;
	int m_cyTopBorder, m_cyBottomBorder;
	int m_cxDefaultGap;         // default gap value
	int m_nMRUWidth;

	void CalcInsideRect(CRect& rect, BOOL bHorz) const; // adjusts borders etc
	BOOL AllocElements(int nElements, int cbElement);

	//----------------------------------------------------------------------------------------------
	// Generated message map functions
protected:
	//{{AFX_MSG(CPane)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnNcDestroy();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnCancelMode();
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnDestroy();
	afx_msg void OnStyleChanged(int nStyleType, LPSTYLESTRUCT lpStyleStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	CRect  m_rectVirtual;
	CRect  m_rectDragImmediate;
	CSize  m_sizeMin;
	CPoint m_ptClientHotSpot;
	bool   m_bCaptured;
	bool   m_bDisableChangeHot;
	bool   m_bDblClick;
	BOOL   m_bDragMode;
	BOOL   m_bExclusiveRow;
	BOOL   m_bPinState;
	UINT   m_nID;
	HWND   m_hwndMiniFrameToBeClosed;

	CRuntimeClass* m_pMiniFrameRTC;
	CMFCDragFrameImpl m_dragFrameImpl;

//-----------------------------------------------
//  Recent dock/float state
//-----------------------------------------------
public:
	CRecentDockSiteInfo m_recentDockInfo;
	CRect m_rectSavedDockedRect; // in client coordinates

	BOOL m_bRecentFloatingState;
	BOOL m_bWasFloatingBeforeMove;
	BOOL m_bWasFloatingBeforeTabbed;

	void SetRecentTabWindowInfo(DWORD dwFrameAlignment, const CList<UINT, UINT&>& lstSiblingBars);
	void CalcRecentDockedRect();

protected:
	virtual void StoreRecentDockSiteInfo();
//-----------------------------------------------
};

_inline BOOL CPane::CanBeDocked(CBasePane* pDockBar) const
{
	ASSERT_VALID(this);
	return ((GetEnabledAlignment() & pDockBar->GetCurrentAlignment()) != 0);
}

#pragma warning( default : 4100 34 )

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxpanecontainermanager.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxpanedivider.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CPane;
class CPaneContainer;

class CPaneContainerManager : public CObject
{
	friend class CPaneContainer;
	friend class CMultiPaneFrameWnd;
	friend class CRecentPaneContainerInfo;

	DECLARE_DYNCREATE(CPaneContainerManager)
public:
	CPaneContainerManager();
	virtual ~CPaneContainerManager();

	virtual BOOL Create(CWnd* pParentWnd, CPaneDivider* pDefaultSlider, CRuntimeClass* pContainerRTC = NULL);
	void SetPaneContainerRTC(CRuntimeClass* pContainerRTC) { m_pContainerRTC = pContainerRTC; }

	CRuntimeClass* GetPaneContainerRTC() const { return m_pContainerRTC; }

	virtual BOOL AddPaneContainerManager(CPaneContainerManager& srcManager, BOOL bOuterEdge);
	virtual BOOL AddPaneContainerManager(CDockablePane* pTargetControlBar, DWORD dwAlignment, CPaneContainerManager& srcManager, BOOL bCopy);
	virtual BOOL AddPaneContainerManagerToDockablePane(CDockablePane* pTargetControlBar, CPaneContainerManager& srcManager);
	virtual void AddPane(CDockablePane* pControlBarToAdd);
	virtual CDockablePane* AddPaneToRecentPaneContainer(CDockablePane* pBarToAdd, CPaneContainer* pRecentContainer);
	virtual BOOL InsertPane(CDockablePane* pControlBarToInsert, CDockablePane* pTargetControlBar,
		DWORD dwAlignment, LPCRECT lpRect = NULL, AFX_DOCK_METHOD dockMethod = DM_UNKNOWN);

	virtual int  OnPaneDividerMove(CPaneDivider* pSlider, UINT uFlags, int nOffset, HDWP& hdwp);
	virtual void GetWindowRect(CRect& rect) const;
	virtual void GetAvailableSpace(CRect& rect) const;
	virtual BOOL RemovePaneFromPaneContainer(CDockablePane* pControlBar);
	virtual void ResizePaneContainers(UINT nSide, BOOL bExpand, int nOffset, HDWP& hdwp);
	virtual void ResizePaneContainers(CRect rect, HDWP& hdwp);
	virtual BOOL ReplacePane(CDockablePane* pBarOld, CDockablePane* pBarNew);
	virtual void GetMinMaxOffset(CPaneDivider* pSlider, int& nMinOffset, int& nMaxOffset, int& nStep);

	virtual BOOL OnShowPane(CDockablePane* pBar, BOOL bShow);
	virtual BOOL IsRootPaneContainerVisible() const;

	virtual void GetMinSize(CSize& size);
	virtual int  GetVisiblePaneCount() const;
	virtual void EnableGrippers(BOOL bEnable);
	virtual void HideAll();

	virtual BOOL DoesContainFloatingPane();
	virtual BOOL DoesAllowDynInsertBefore() const;

	virtual CDockablePane* PaneFromPoint(CPoint point, int nSensitivity, BOOL bExactBar, BOOL& bIsTabArea, BOOL& bCaption);
	virtual BOOL CheckForMiniFrameAndCaption(CPoint point, CDockablePane** ppTargetControlBar);

	virtual CBasePane* GetFirstPane() const;
	virtual CWnd* GetDockSiteFrameWnd() { return m_pDockSite; }
	virtual CWnd* GetFirstVisiblePane() const;

	virtual BOOL CanBeAttached() const;

	CPaneDivider* GetDefaultPaneDivider() const {return m_pDefaultSlider;}

	void ReleaseEmptyPaneContainers();
	void AddPaneToList(CDockablePane* pControlBarToAdd); 
	BOOL IsEmpty() const;

	int GetTotalRefCount() const;
	int GetPaneCount() const { return(int)m_lstControlBars.GetCount(); }
	int GetNodeCount() const;

	virtual void SetResizeMode(BOOL bResize);
	virtual void RemovePaneDivider(CPaneDivider* pSlider);
	virtual void StoreRecentDockSiteInfo(CDockablePane* pBar);

	BOOL IsAutoHideMode() const { return (m_pDefaultSlider != NULL && m_pDefaultSlider->IsAutoHideMode()); }

	void SetDefaultPaneDividerForPanes(CPaneDivider* pSlider);
	void Serialize(CArchive& ar);
	CDockablePane* FindTabbedPane(UINT nID);
	virtual CPaneContainer* FindPaneContainer(CDockablePane* pBar, BOOL& bLeftBar);

	void AddPanesToList(CObList* plstControlBars, CObList* plstSliders);
	void RemoveAllPanesAndPaneDividers();

	void CalcRects(CRect& rectOriginal, CRect& rectInserted, CRect& rectSlider, DWORD& dwSliderStyle, DWORD dwAlignment, CSize sizeMinOriginal, CSize sizeMinInserted);
	void NotifyPaneDivider();

	void RemoveNonValidPanes();
	BOOL CheckAndRemoveNonValidPane(CWnd* pWnd);

protected:
	CPaneDivider* CreatePaneDivider(CRect rectSlider, DWORD dwSliderStyle, int nSliderID = -1);
	UINT FindPane(CPoint pt, CPane** ppBar, POSITION& posRet);
	UINT FindPane(CRect rect, CPane** ppBar, POSITION& posRet);
	BOOL AddPaneAndPaneDivider(CDockablePane* pBarOriginal, CDockablePane* pBarToInsert, POSITION posNearestBar, DWORD dwAlignment);
	BOOL AddPaneAndPaneContainer(CDockablePane* pBarOriginal, CPaneContainer* pContainerToInsert, DWORD dwAlignment);

	CObList  m_lstControlBars;
	CObList  m_lstSliders;

	CPaneContainer* m_pRootContainer;
	CRuntimeClass* m_pContainerRTC;
	CPaneDivider* m_pDefaultSlider;

	BOOL  m_bDestroyRootContainer;
	CWnd* m_pDockSite;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxpanedialog.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxdockablepane.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CPaneDialog window

class CPaneDialog : public CDockablePane
{
	DECLARE_SERIAL(CPaneDialog)

// Construction
public:
	CPaneDialog();

	BOOL Create(LPCTSTR lpszWindowName, CWnd* pParentWnd, BOOL bHasGripper, LPCTSTR lpszTemplateName, UINT nStyle, UINT nID,
		DWORD dwTabbedStyle = AFX_CBRS_REGULAR_TABS, DWORD dwControlBarStyle = AFX_DEFAULT_DOCKING_PANE_STYLE);
	BOOL Create(LPCTSTR lpszWindowName, CWnd* pParentWnd, BOOL bHasGripper, UINT nIDTemplate, UINT nStyle, UINT nID);

	BOOL Create(CWnd* pParentWnd, LPCTSTR lpszTemplateName, UINT nStyle, UINT nID)
	{
		return Create(_T(""), pParentWnd, TRUE /* bHasGripper */, lpszTemplateName, nStyle, nID);
	}

	BOOL Create(CWnd* pParentWnd, UINT nIDTemplate, UINT nStyle, UINT nID)
	{
		return Create(_T(""), pParentWnd, TRUE /* bHasGripper */, nIDTemplate, nStyle, nID);
	}

// Attributes
protected:
	CSize m_sizeDefault;

public:

// Overrides
	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);

// Implementation
#ifndef _AFX_NO_OCC_SUPPORT
	// data and functions necessary for OLE control containment
	_AFX_OCC_DIALOG_INFO* m_pOccDialogInfo;
	virtual BOOL SetOccDialogInfo(_AFX_OCC_DIALOG_INFO* pOccDialogInfo);
#endif

	//{{AFX_MSG(CPaneDialog)
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnWindowPosChanging(WINDOWPOS FAR* lpwndpos);
	afx_msg LRESULT HandleInitDialog(WPARAM, LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	virtual ~CPaneDialog();
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxpanecontainer.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CBasePane;
class CPane;
class CDockablePane;
class CPaneDivider;

class CPaneContainer : public CObject  
{
	friend class CPaneContainerManager;
	friend class CRecentPaneContainerInfo;

	DECLARE_DYNAMIC(CPaneContainer);
public:
	CPaneContainer(CPaneContainerManager* pManager = NULL, CDockablePane* pLeftBar = NULL, CDockablePane* pRightBar = NULL, CPaneDivider* pSlider = NULL);
	virtual ~CPaneContainer();

	CDockablePane* AddPane(CDockablePane* pBar);
	BOOL AddSubPaneContainer(CPaneContainer* pContainer, BOOL bRightNodeNew);

	enum BC_FIND_CRITERIA
	{
		BC_FIND_BY_LEFT_BAR,
		BC_FIND_BY_RIGHT_BAR,
		BC_FIND_BY_SLIDER,
		BC_FIND_BY_CONTAINER
	};

	CPaneContainer* FindSubPaneContainer(const CObject* pObject, BC_FIND_CRITERIA findCriteria);

	BOOL IsEmpty() const;
	BOOL IsLeftPartEmpty(BOOL bCheckVisibility = FALSE) const;
	BOOL IsRightPartEmpty(BOOL bCheckVisibility = FALSE) const;

	BOOL IsVisible() const;

	int  GetNodeCount() const;
	int  GetTotalReferenceCount() const;

	const CDockablePane* GetLeftPane() const { return m_pBarLeftTop; }
	const CDockablePane* GetRightPane() const { return m_pBarRightBottom; }
	const CPaneDivider* GetPaneDivider() const { return m_pSlider; }
	const CPaneContainer* GetLeftPaneContainer() const { return m_pLeftContainer; }
	const CPaneContainer* GetRightPaneContainer() const { return m_pRightContainer; }

	DWORD GetRecentPaneDividerStyle() const { return m_dwRecentSliderStyle; }
	CRect GetRecentPaneDividerRect() const { return m_rectRecentSlider; }

	CPaneContainer* GetParentPaneContainer() const { return m_pParentContainer; }

	void SetPane(CDockablePane* pBar, BOOL bLeft);
	void SetPaneContainer(CPaneContainer* pContainer, BOOL bLeft);
	void SetPaneDivider(CPaneDivider* pSlider) { m_pSlider = pSlider; }

	BOOL IsLeftPaneContainer() const;
	BOOL IsLeftPane(CDockablePane* pBar) const;

	void SetParentPaneContainer(CPaneContainer* p) { m_pParentContainer = p; }

	BOOL SetUpByID(UINT nID, CDockablePane* pBar);
	CDockablePane* FindTabbedPane(UINT nID);

// Overrides
	virtual void GetWindowRect(CRect& rect, BOOL bIgnoreVisibility = FALSE) const;
	virtual void GetMinSize(CSize& size) const;
	virtual void GetMinSizeLeft(CSize& size) const;
	virtual void GetMinSizeRight(CSize& size) const;
	virtual int  GetResizeStep() const;

	virtual void OnShowPane(CDockablePane* pBar, BOOL bShow);

	virtual void RemovePane(CDockablePane* pBar);
	virtual void DeletePane(CDockablePane* pBar, BC_FIND_CRITERIA barType);
	virtual void StoreRecentDockSiteInfo(CDockablePane* pBar);

	void OnDeleteHidePane(CDockablePane* pBar, BOOL bHide);

	virtual void Move(CPoint ptNewLeftTop);

	virtual int StretchPaneContainer(int nOffset, BOOL bStretchHorz, BOOL bLeftBar, BOOL bMoveSlider, HDWP& hdwp);
	virtual int OnMoveInternalPaneDivider(int nOffset, HDWP& hdwp);
	virtual void ResizePane(int nOffset, CPane* pBar, CPaneContainer* pContainer, BOOL bHorz, BOOL bLeftBar, HDWP& hdwp);
	virtual int CalcAvailablePaneSpace(int nRequiredOffset, CPane* pBar, CPaneContainer* pContainer, BOOL bLeftBar);
	virtual CSize CalcAvailableSpace(CSize sizeStretch, BOOL bLeftBar);

	virtual void Resize(CRect rect, HDWP& hdwp, BOOL bRedraw = FALSE);
	virtual void ResizePartOfPaneContainer(int nOffset, BOOL bLeftPart, HDWP& hdwp);

	void SetRecentPercent(int nRecentPercent) { m_nRecentPercent = nRecentPercent; };
	int GetRecentPercent() { return m_nRecentPercent; }
	void CalculateRecentSize();

	void CheckPaneDividerVisibility();
	void RemoveNonValidPanes();

	BOOL IsDisposed() const { return m_bDisposed; }

	void AddRef();
	DWORD Release();
	LONG GetRefCount() { return m_dwRefCount; }

	void Serialize(CArchive& ar);
	void ReleaseEmptyPaneContainer();

	virtual CPaneContainer* Copy(CPaneContainer* pParentContainer);

	CList<UINT, UINT>* GetAssociatedSiblingPaneIDs(CDockablePane* pBar);

	AFX_IMPORT_DATA static BOOL m_bMaintainPercentage;
	AFX_IMPORT_DATA static BOOL m_bRetainInternalSliderPosition;

protected:
	CDockablePane* m_pBarLeftTop;
	CDockablePane* m_pBarRightBottom;
	CPaneDivider*      m_pSlider;

	CPaneContainer* m_pLeftContainer;
	CPaneContainer* m_pRightContainer;
	CPaneContainer* m_pParentContainer;

	CPaneContainerManager* m_pContainerManager;

	int  m_nRecentPercent;
	UINT m_nSavedLeftBarID;
	UINT m_nSavedRightBarID;
	UINT m_nSavedSliderID;
	LONG m_dwRefCount;

	BOOL m_bIsRecentSliderHorz;
	BOOL m_bSavedSliderVisibility;
	BOOL m_bDisposed;

	DWORD m_dwRecentSliderStyle;
	CRect m_rectRecentSlider;
	CRect m_rectSavedSliderRect;

	CList<UINT, UINT> m_lstSavedSiblingBarIDsLeft;
	CList<UINT, UINT> m_lstSavedSiblingBarIDsRight;

protected:
	void AddNode(CPaneContainer* pContainer);
	void CleanUp();
	
	void SetPaneContainerManager(CPaneContainerManager* p, BOOL bDeep = FALSE);

	void MoveWnd(CWnd* pWnd, int nOffset, BOOL bHorz);

	void SaveTabbedPane(CArchive& ar, CDockablePane* pBar);
	CDockablePane* LoadTabbedPane(CArchive& ar, CList<UINT, UINT>& lstBarIDs);
	void FreeReleasedPaneContainer();

	BOOL IsPaneDividerHorz() const;
};

class CPaneContainerGC
{
	CObList m_lstDisposedContainers;

public:
	void AddPaneContainer(CPaneContainer* p)
	{
		m_lstDisposedContainers.AddTail(p);
	}

	void CleanUp()
	{
		while (!CPaneContainerGC::m_lstDisposedContainers.IsEmpty())
		{
			delete m_lstDisposedContainers.RemoveHead();
		}
	}

	~CPaneContainerGC()
	{
		CPaneContainerGC::CleanUp();
	}
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxoutlookbartabctrl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxribbonres.h"
#include "afxbasetabctrl.h"
#include "afxbutton.h"
#include "afxtoolbar.h"
#include "afxtoolbarslistcheckbox.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCOutlookBarTabCtrl;

class CMFCOutlookBarScrollButton : public CMFCButton
{
	virtual void OnFillBackground(CDC* pDC, const CRect& rectClient);
	virtual void OnDrawBorder(CDC* pDC, CRect& rectClient, UINT uiState);
};

class CMFCOutlookBarToolBar : public CMFCToolBar
{
	friend class CMFCOutlookBarTabCtrl;

	DECLARE_DYNAMIC(CMFCOutlookBarToolBar)

	CMFCOutlookBarToolBar(CMFCOutlookBarTabCtrl* pParentBar);

	virtual BOOL LoadState(LPCTSTR /*lpszProfileName*/ = NULL, int /*nIndex*/ = -1, UINT /*uiID*/ = (UINT) -1)	{	return TRUE;	}
	virtual BOOL SaveState(LPCTSTR /*lpszProfileName*/ = NULL, int /*nIndex*/ = -1, UINT /*uiID*/ = (UINT) -1)	{	return TRUE;	}

	virtual BOOL OnSendCommand(const CMFCToolBarButton* pButton);
	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);

	virtual BOOL OnUserToolTip(CMFCToolBarButton* pButton, CString& strTTText) const;

	virtual BOOL IsTabbed() const { return FALSE; }

	virtual BOOL AllowShowOnPaneMenu() const { return FALSE; }
	virtual BOOL AllowShowOnList() const { return FALSE; }
	virtual void AdjustLocations();
	virtual void OnCustomizeMode(BOOL bSet);

	CMap<int, int, int, int> m_TabButtons;
	CMFCOutlookBarTabCtrl*             m_pParentBar;

	//{{AFX_MSG(CMFCOutlookBarToolBar)
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp);
	afx_msg void OnNcPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CMFCOutlookBarTabCtrl window

class CMFCOutlookBarTabCtrl : public CMFCBaseTabCtrl
{
	friend class COutlookOptionsDlg;

	DECLARE_DYNCREATE(CMFCOutlookBarTabCtrl)

// Construction
public:
	CMFCOutlookBarTabCtrl();

// Attributes
public:
	virtual BOOL IsPtInTabArea(CPoint point) const;
	virtual void GetTabArea(CRect& rectTabAreaTop, CRect& rectTabAreaBottom) const;

	int GetBorderSize() const { return m_nBorderSize; }
	void SetBorderSize(int nBorderSize);

	static void __stdcall EnableAnimation(BOOL bEnable = TRUE);
	static BOOL __stdcall IsAnimation() { return m_bEnableAnimation; }

	void SetPageButtonTextAlign(UINT uiAlign, BOOL bRedraw = TRUE); // TA_LEFT, TA_CENTER or TA_RIGHT

	BOOL IsMode2003() const;

	int GetVisiblePageButtons() const { return m_nVisiblePageButtons; }
	void SetVisiblePageButtons(int nVisiblePageButtons) { m_nVisiblePageButtons = nVisiblePageButtons; }

	virtual void OnShowMorePageButtons();
	virtual void OnShowFewerPageButtons();
	virtual BOOL CanShowMorePageButtons() const;
	virtual BOOL CanShowFewerPageButtons() const;
	virtual void OnShowOptions();

	virtual void OnChangeTabs();

	BOOL SetToolbarImageList(UINT uiID, int cx, COLORREF clrTransp = RGB(255, 0, 255));

// Operations
public:
	void AddControl(CWnd* pWndCtrl, LPCTSTR lpszName, int nImageID = -1, BOOL bDetachable = TRUE,
		DWORD dwControlBarStyle = AFX_CBRS_FLOAT | AFX_CBRS_CLOSE | AFX_CBRS_RESIZE | AFX_CBRS_AUTOHIDE);

	virtual void RecalcLayout();
	virtual void EnableInPlaceEdit(BOOL bEnable)
	{
		ASSERT_VALID(this);
		m_bIsInPlaceEdit = bEnable;
	}

	virtual void CalcRectEdit(CRect& rectEdit)
	{
		ASSERT_VALID(this);
		rectEdit.DeflateRect(1, 1);
	}

	void EnableScrollButtons(BOOL bEnable = TRUE, BOOL bIsUp = TRUE, BOOL bIsDown = TRUE);

// Overrides
	virtual BOOL IsTabDetachable(int iTab) const;

public:
	virtual BOOL Create(const CRect& rect, CWnd* pParentWnd, UINT nID);

protected:
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);

	virtual DROPEFFECT OnDragEnter(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point);
	virtual DROPEFFECT OnDragOver(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point);

// Implementation
public:
	virtual ~CMFCOutlookBarTabCtrl();

	virtual BOOL SetActiveTab(int iTab);
	virtual CWnd* FindTargetWnd(const CPoint& pt);

protected:
	virtual int GetTabNumberToDetach(int nTabNum = -1) const;

	void DrawTabButton(CDC& dc, int iButtonIdx, BOOL bDrawPressedButton = TRUE);
	void RebuildToolBar();

	virtual void OnScrollUp() {}
	virtual void OnScrollDown() {}

	// Generated message map functions
protected:
	//{{AFX_MSG(CMFCOutlookBarTabCtrl)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnPaint();
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnCancelMode();
	afx_msg void OnToolbarCommand(UINT id);
	afx_msg void OnUpdateToolbarCommand(CCmdUI* pCmdUI);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	int   m_nBorderSize;
	int   m_nVisiblePageButtons;
	int   m_nMaxVisiblePageButtons;
	BOOL  m_bIsTracking;
	BOOL  m_bDontAdjustLayout;
	BOOL  m_bScrollButtons;
	UINT  m_nPageButtonTextAlign;
	CRect m_rectWndArea;
	CRect m_rectCaption;
	CRect m_rectSplitter;
	CSize m_sizeToolbarImage;

	CImageList           m_imagesToolbar;
	CMFCOutlookBarToolBar   m_wndToolBar;
	CMFCOutlookBarScrollButton m_btnUp;
	CMFCOutlookBarScrollButton m_btnDown;

	AFX_IMPORT_DATA static BOOL m_bEnableAnimation;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxplex_.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXPLEX_H__
#define __AFXPLEX_H__

#pragma once

#ifndef __AFX_H__
	#include <afx.h>
#endif

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

struct CPlex     // warning variable length structure
{
	CPlex* pNext;
#ifndef _WIN64
#if (_AFX_PACKING >= 8)
	DWORD dwReserved[1];    // align on 8 byte boundary
#endif
#endif
	// BYTE data[maxNum*elementSize];

	void* data() { return this+1; }

	static CPlex* PASCAL Create(CPlex*& head, UINT_PTR nMax, UINT_PTR cbElement);
			// like 'calloc' but no zero fill
			// may throw memory exceptions

	void FreeDataChain();       // free this one and links
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#endif //__AFXPLEX_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxpanedivider.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxbasepane.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CPaneContainerManager;
class CPane;
class CDockablePane;
class CPaneContainer;

/////////////////////////////////////////////////////////////////////////////
// CPaneDivider window

class CPaneDivider : public CBasePane
{
	friend class CDockablePane;

	DECLARE_DYNCREATE(CPaneDivider)

// Construction
public:
	CPaneDivider();
	CPaneDivider(BOOL bDefaultSlider, CWnd* pParent = NULL);

	void Init(BOOL bDefaultSlider = FALSE, CWnd* pParent = NULL);

	enum SS_STYLE
	{
		SS_HORZ = 0x1,
		SS_VERT = 0x2
	};

// Attributes
public:
	BOOL IsHorizontal() const { return m_dwDividerStyle & SS_HORZ; }
	int GetWidth() const  { return m_nWidth; }
	static int __stdcall GetDefaultWidth() { return m_nDefaultWidth; }
	BOOL IsDefault() const { return m_bDefaultDivider; }
	BOOL IsAutoHideMode() const { return m_bAutoHideMode; }

	DWORD GetPaneDividerStyle() const { return m_dwDividerStyle; }

	virtual BOOL DoesAllowDynInsertBefore() const;

	AFX_IMPORT_DATA static int m_nDefaultWidth;
	AFX_IMPORT_DATA static CRuntimeClass* m_pContainerManagerRTC;
	AFX_IMPORT_DATA static CRuntimeClass* m_pSliderRTC;

// Operations
public:

	void ShowWindow(int nCmdShow);

	virtual void Move(CPoint& ptOffset, BOOL bAdjustLayout = TRUE);
	virtual void AddPane(CDockablePane* pBar);

	virtual CDockablePane* AddRecentPane(CDockablePane* pBar);

	virtual BOOL InsertPane(CDockablePane* pBarToInsert, CDockablePane* pTargetBar, DWORD dwAlignment, LPCRECT lpRect = NULL);
	virtual BOOL ReplacePane(CDockablePane* pBarToReplace, CDockablePane* pBarToReplaceWith);
	virtual void RemovePane(CDockablePane* pBar);
	virtual void RepositionPanes(CRect& rectNew, HDWP& hdwp);
	virtual BOOL AddPaneContainer(CPaneContainerManager& barContainerManager, BOOL bOuterEdge);
	virtual BOOL AddPaneContainer(CDockablePane* pTargetBar, CPaneContainerManager& barContainerManager, DWORD dwAlignment);

	virtual BOOL CheckVisibility();

	virtual void OnShowPane(CDockablePane* pBar, BOOL bShow);

	virtual BOOL DoesContainFloatingPane();
	virtual void CalcExpectedDockedRect(CWnd* pWndToDock, CPoint ptMouse, CRect& rectResult, BOOL& bDrawTab, CDockablePane** ppTargetBar);

	void StoreRecentDockSiteInfo(CDockablePane* pBar);
	void StoreRecentTabRelatedInfo(CDockablePane* pDockingBar, CDockablePane* pTabbedBar);

	void SetPaneContainerManager(CPaneContainerManager* p) {m_pContainerManager = p;}
	void ReleaseEmptyPaneContainers();

	void SetAutoHideMode(BOOL bMode) { m_bAutoHideMode = bMode; }

	const CBasePane* GetFirstPane() const;

	void Serialize(CArchive& ar);
	CDockablePane* FindTabbedPane(UINT nID);
	CPaneContainer* FindPaneContainer(CDockablePane* pBar, BOOL& bLeftBar);
	CRect GetRootContainerRect();

	virtual void NotifyAboutRelease();

	void GetPanes(CObList& lstBars);
	void GetPaneDividers(CObList& lstSliders);

// Overrides
public:
	virtual BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
	virtual BOOL CreateEx(DWORD dwStyleEx, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext);

// Implementation
public:
	virtual ~CPaneDivider();
	virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);

protected:
	//{{AFX_MSG(CPaneDivider)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnPaint();
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnDestroy();
	afx_msg void OnNcDestroy();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnCancelMode();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	void SetDefaultMode(BOOL bMode) {m_bDefaultDivider = bMode;}
	virtual void StopTracking(BOOL bMoveSlider);

protected:
	UINT   m_nID;
	DWORD m_dwDividerStyle;
	int   m_nWidth;
	int   m_nMinOffset;
	int   m_nMaxOffset;
	int   m_nStep;
	bool  m_bCaptured;
	BOOL  m_bDefaultDivider; // true if this slider is created on the "edge" of one or several containers
	BOOL  m_bAutoHideMode;

	CRect  m_rectLastDragRect;
	CRect  m_rectDragBounds;
	CPoint m_ptHotTotal;
	CPoint m_ptHotDrag;
	CWnd*  m_pParentWndForSerialize;
	CPaneContainerManager* m_pContainerManager;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxpaneframewnd.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxtoolbar.h"
#include "afxcaptionbutton.h"
#include "afxdragframeimpl.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#pragma warning( disable : 4100 34 )

/////////////////////////////////////////////////////////////////////////////
// CPaneFrameWnd window

class CPane;
class CBasePane;
class CDockablePane;
class CMFCPopupMenu;

#define AFX_CAPTION_BTN_PIN       0x1
#define AFX_CAPTION_BTN_CLOSE     0x2
#define AFX_CAPTION_BTN_MENU      0x4
#define AFX_CAPTION_BTN_MAXIMIZE  0x8
#define AFX_CAPTION_BTN_CUSTOMIZE 0x10

typedef enum AFX_PREDOCK_STATE
{
	PDS_NOTHING,
	PDS_DOCK_REGULAR,
	PDS_DOCK_TO_TAB
};

static const UINT AFX_DOCK_EVENT = 4;
static const UINT AFX_CHECK_ROLL_STATE = 5;

extern AFX_IMPORT_DATA UINT AFX_WM_CHECKEMPTYMINIFRAME;

class CPaneFrameWnd : public CWnd
{
	DECLARE_SERIAL(CPaneFrameWnd)
	friend class CPane;
	friend class CDockingManager;
	friend class CMFCBaseTabCtrl;
	friend class CMFCPopupMenu;

// Construction
public:
	CPaneFrameWnd();

// Attributes
public:
	CPoint GetHotPoint() const { return m_dragFrameImpl.m_ptHot; }
	void SetHotPoint(CPoint& ptNew) { m_dragFrameImpl.m_ptHot = ptNew; }
	BOOL IsCaptured() const { return m_bCaptured; }

	BOOL IsDelayShow() const { return m_bDelayShow; }
	void SetDelayShow(BOOL bDelayShow) { m_bDelayShow = bDelayShow; }

	virtual BOOL CanBeDockedToPane(const CDockablePane* pDockingBar) const;
	virtual BOOL IsRollDown() const;
	virtual BOOL IsRollUp() const;

	virtual int GetCaptionHeight() const { return m_nCaptionHeight; }

	virtual BOOL CanBeAttached() const
	{
		CPane* pBar = DYNAMIC_DOWNCAST(CPane, GetPane());
		if (pBar != NULL)
		{
			return pBar->CanBeAttached();
		}
		return FALSE;
	}

	bool m_bBlockMove;

	AFX_IMPORT_DATA static int m_nCaptionButtonMargin;
	AFX_IMPORT_DATA static int m_nCaptionButtonSpacing;
	AFX_IMPORT_DATA static const int m_nToolbarBorderSize;
	AFX_IMPORT_DATA static UINT m_nRollTimeOut;
	AFX_IMPORT_DATA static BOOL m_bUseSaveBits;

	void SetDockingManager(CDockingManager* pManager) { m_pDockManager = pManager; }
	CDockingManager* GetDockingManager() const { return m_pDockManager; }


	CWnd* GetParent() { return CWnd::FromHandlePermanent(m_hParentWnd); }

// Operations
public:
	virtual void AddPane(CBasePane* pWnd);
	virtual void RemovePane(CBasePane* pWnd, BOOL bDestroy = FALSE, BOOL bNoDelayedDestroy = FALSE);
	virtual void ReplacePane(CBasePane* pBarOrg, CBasePane* pBarReplaceWith);
	static BOOL __stdcall AddRemovePaneFromGlobalList(CBasePane* pWnd, BOOL bAdd);
	static void __stdcall RedrawAll();

	virtual CDockablePane* DockPane(BOOL& bWasDocked);
	virtual void CheckGripperVisibility() {}

	virtual void SetCaptionButtons(DWORD dwButtons);

	virtual BOOL SetPreDockState(AFX_PREDOCK_STATE preDockState, CBasePane* pBarToDock = NULL, AFX_DOCK_METHOD dockMethod = DM_MOUSE);

	AFX_PREDOCK_STATE GetPreDockState() { return m_preDockStateCurr; }

	virtual void OnMovePane(CPane* pBar, CPoint ptOffset);
	virtual void OnDockToRecentPos();
	virtual BOOL OnBeforeDock();

	virtual int GetPaneCount() const {return (CWnd::FromHandlePermanent(m_hEmbeddedBar) != NULL) ? 1 : 0;}
	virtual int GetVisiblePaneCount() const 
	{
		if (IsWindow(m_hEmbeddedBar) && (::GetWindowLong(m_hEmbeddedBar, GWL_STYLE) & WS_VISIBLE))
		{
			return 1;
		}
		return 0;
	}

	virtual CWnd* GetPane() const;
	virtual CWnd* GetFirstVisiblePane() const;

	virtual AFX_DOCK_TYPE GetDockingMode() const;
	virtual void SizeToContent();

	virtual CString GetCaptionText();
	virtual void CalcBorderSize(CRect& rectBorderSize) const;
	virtual void CalcExpectedDockedRect(CWnd* pWndToDock, CPoint ptMouse, CRect& rectResult, BOOL& bDrawTab, CDockablePane** ppTargetBar)
	{
		bDrawTab = FALSE;
		rectResult.SetRectEmpty();
	}

	virtual CBasePane* PaneFromPoint(CPoint point, int nSensitivity, BOOL bCheckVisibility);

	virtual void GetCaptionRect(CRect& rectCaption) const;

	virtual void OnPaneRecalcLayout();
	virtual void AdjustLayout();

	void SetDockingTimer(UINT nTimeOut);
	void KillDockingTimer();

	static CBasePane* __stdcall FindFloatingPaneByID(UINT nID);
	static CPaneFrameWnd* __stdcall FrameFromPoint(CPoint pt, int nSensitivity, CPaneFrameWnd* pFrameToExclude = NULL, BOOL bFloatMultiOnly = FALSE);

	virtual BOOL SaveState(LPCTSTR lpszProfileName = NULL, UINT uiID = (UINT) -1);
	virtual BOOL LoadState(LPCTSTR lpszProfileName = NULL, UINT uiID = (UINT) -1);

	virtual void Serialize(CArchive& ar);

	virtual void SetDockState(CDockingManager* pDockManager);
	virtual void StoreRecentDockSiteInfo(CPane* pBar);
	virtual void StoreRecentTabRelatedInfo(CDockablePane* pDockingBar, CDockablePane* pTabbedBar);

	CRect GetRecentFloatingRect() const {return m_rectRecentFloatingRect;}

	// does nothing - derived class should adjust container (if any)
	virtual void OnShowPane(CDockablePane* pBar, BOOL bShow) {}

	virtual LRESULT HitTest(CPoint point, BOOL bDetectCaption);

	virtual void RemoveNonValidPanes();

	void Pin(BOOL bPin = TRUE) { m_bPinned = bPin; }

	BOOL GetPinState() const { return m_bPinned; }

	BOOL StartTearOff(CMFCPopupMenu* pMenu);

	virtual void OnSetRollUpTimer();
	virtual void OnKillRollUpTimer();

	virtual void AdjustPaneFrames() {}
	virtual void ConvertToTabbedDocument();

// Overrides
public:
	virtual BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, CCreateContext* pContext = NULL);
	virtual BOOL CreateEx(DWORD dwStyleEx, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, CCreateContext* pContext = NULL);
	virtual BOOL PreTranslateMessage(MSG* pMsg);

protected:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

	virtual void OnCapture(BOOL bOnOff);
	virtual void EnterDragMode(HWND hWndToDestroyOnRelease = NULL); 

	static void __stdcall GetPaneList(CObList& lstBars, CRuntimeClass* pRTCFilter = NULL, BOOL bIncludeTabs = FALSE);

// Implementation
public:
	virtual ~CPaneFrameWnd();

protected:
	//{{AFX_MSG(CPaneFrameWnd)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnMoving(UINT fwSide, LPRECT pRect);
	afx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp);
	afx_msg void OnNcPaint();
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnSizing(UINT fwSide, LPRECT pRect);
	afx_msg void OnWindowPosChanging(WINDOWPOS FAR* lpwndpos);
	afx_msg void OnTimer(UINT_PTR nIDEvent);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg BOOL OnNcActivate(BOOL bActive);
	afx_msg void OnNcLButtonDblClk(UINT nHitTest, CPoint point);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg BOOL OnNcCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnNcDestroy();
	afx_msg void OnCancelMode();
	afx_msg void OnNcMouseMove(UINT nHitTest, CPoint point);
	afx_msg void OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnDestroy();
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnClose();
	afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
	afx_msg LRESULT OnCheckEmptyState(WPARAM, LPARAM);
	afx_msg LRESULT OnFloatStatus(WPARAM wParam, LPARAM);
	afx_msg LRESULT OnIdleUpdateCmdUI(WPARAM wParam, LPARAM);
	afx_msg LRESULT OnExitSizeMove(WPARAM, LPARAM);
	afx_msg BOOL OnNeedTipText(UINT id, NMHDR* pNMH, LRESULT* pResult);
	afx_msg LRESULT OnNcHitTest(CPoint point);
	afx_msg LRESULT OnUpdateToolTips(WPARAM, LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	void MoveDragFrame();
	BOOL MoveMiniFrame();
	virtual void OnDrawBorder(CDC* pDC);
	virtual void OnDrawCaptionButtons(CDC* pDC);

	virtual void SaveRecentFloatingState();

	virtual BOOL OnCloseMiniFrame();
	virtual void CloseMiniFrame();
	virtual void OnPressButtons(UINT nHit);

	virtual CDockablePane* DockPaneStandard(BOOL& bWasDocked);

	virtual void AddButton(UINT nHit);
	void RemoveButton(UINT nHit);
	void ShowButton(UINT nHit, BOOL bShow = TRUE);
	CMFCCaptionButton* FindButton(CPoint point) const;
	CMFCCaptionButton* FindButton(UINT uiHit) const;

	void ReplaceButton(UINT nHit, UINT nHitNew);
	void RemoveAllCaptionButtons();
	void ArrangeCaptionButtons();
	void SetCaptionButtonsToolTips();

	void RedrawCaptionButton(CMFCCaptionButton* pBtn);
	virtual void OnTrackCaptionButtons(CPoint point);
	virtual void StopCaptionButtonsTracking();

	CSize CalcAlignedRect(CRect& rectWnd, CDockSite* pDockBar = NULL);

	BOOL IsCustModeAndNotFloatingToolbar() const;
	int  GetCaptionButtonTotalWidth() const;

	virtual void CalcMinSize(CSize& sizeBase, MINMAXINFO FAR* lpMMI);
	virtual void OnCheckRollState();

	void SetRollUpTimer();
	void KillRollupTimer();

	virtual void RecalcCaptionHeight();
	void UpdateTooltips();

	void ForceAdjustLayout(CDockingManager* pDockManager);

protected:
	BOOL m_bActive;
	BOOL m_bIsMoving;
	BOOL m_bEnablePreDockState;
	BOOL m_bRolledUp;
	BOOL m_bPinned;
	BOOL m_bNoDelayedDestroy;
	BOOL m_bHostsToolbar;
	BOOL m_bDelayShow;
	bool m_bTabDragRectDisplayed;
	bool m_bCaptured;

	int  m_nHeightBeforeRollUp;
	UINT m_nCaptionHeight;
	UINT m_nHit; // Clicked button
	UINT m_nHot; // "Hot" button
	UINT m_nDockTimerID;
	UINT m_nRollTimerID;
	UINT m_nRestoredEmbeddedBarID;

	DWORD m_dwCaptionButtons;

	HWND m_hParentWnd;
	HWND m_hWndToDestroyOnRelease;
	HWND m_hLastFocusWnd;
	HWND m_hEmbeddedBar;

	CRect               m_rectRecentFloatingRect;  // loaded from archive for setting dock state
	CSize               m_sizeMinSize;
	CRect               m_rectRedraw;
	CPoint              m_ptHot;
	CObList             m_lstCaptionButtons;
	CToolTipCtrl*       m_pToolTip;
	CDockablePane* m_pPreDockBar;
	CMFCDragFrameImpl      m_dragFrameImpl;
	CDockingManager*       m_pDockManager; // docking manager related to embedded control bar's frame. Should be set on creation of miniframe

	AFX_PREDOCK_STATE m_preDockStateCurr;

	AFX_IMPORT_DATA static CMap<UINT,UINT,HWND,HWND> m_mapFloatingBars;
	AFX_IMPORT_DATA static CList<HWND, HWND> CPaneFrameWnd::m_lstFrames;
	AFX_IMPORT_DATA static CFrameWnd* m_pParentWndForSerialize; // should be set by caller before starting serialization
};

#pragma warning( default : 4100 34 )

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxpriv2.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Note: This header file contains useful classes that are documented only
//  in the MFC Technical Notes.  These classes may change from version to
//  version, so be prepared to change your code accordingly if you utilize
//  this header.  In the future, commonly used portions of this header
//  may be moved and officially documented.

#ifndef __AFXPRIV2_H__
// Do not define __AFXPRIV2_H__ here.  It is defined at the bottom,
// and so this header can't use #pragma once.

#ifndef __AFXPRIV_H__
	#include <afxpriv.h>
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// AFXPRIV2 - MFC Private Classes

// General OLE features

#if (!defined _AFX_NO_OLE_SUPPORT) && (defined _OBJBASE_H_)

// Implementation structures
struct AFX_EVENT;               // Event sink implementation

// Classes declared in this file
class COleControlLock;

#endif

// OLE Automation features

#ifdef __AFXDISP_H__
// Classes declared in this file

//IStream
	class CArchiveStream;

// Functions declared in this file

// AfxBSTR2ABTSR
// AfxTaskStringA2W
// AfxTaskStringW2A

#endif

/////////////////////////////////////////////////////////////////////////////

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

/////////////////////////////////////////////////////////////////////////////
// General OLE features

#if (!defined _AFX_NO_OLE_SUPPORT) && (defined _OBJBASE_H_)
#ifndef __AFXPRIV2_H__OLE__
#define __AFXPRIV2_H__OLE__

/////////////////////////////////////////////////////////////////////////////
// Implementation of event sink handling

struct AFX_EVENT
{
	enum
	{
		event,
		propRequest, propChanged,
		propDSCNotify
	};

	AFX_EVENT(int eventKind);

	AFX_EVENT(int eventKind, DISPID dispid, DISPPARAMS* pDispParams = NULL,
		EXCEPINFO* pExcepInfo = NULL, UINT* puArgError = NULL);

	int m_eventKind;
	DISPID m_dispid;
	DISPPARAMS* m_pDispParams;
	EXCEPINFO* m_pExcepInfo;
	UINT* m_puArgError;
	BOOL m_bPropChanged;
	HRESULT m_hResult;
	DSCSTATE m_nDSCState;
	DSCREASON m_nDSCReason;
};

AFX_INLINE AFX_EVENT::AFX_EVENT(int eventKind)
{
	m_eventKind = eventKind;
	m_dispid = DISPID_UNKNOWN;
	m_pDispParams = NULL;
	m_pExcepInfo = NULL;
	m_puArgError = NULL;
	m_hResult = NOERROR;
	m_nDSCState = dscNoState;
	m_nDSCReason = dscNoReason;
}

AFX_INLINE AFX_EVENT::AFX_EVENT(int eventKind, DISPID dispid,
	DISPPARAMS* pDispParams, EXCEPINFO* pExcepInfo, UINT* puArgError)
{
	m_eventKind = eventKind;
	m_dispid = dispid;
	m_pDispParams = pDispParams;
	m_pExcepInfo = pExcepInfo;
	m_puArgError = puArgError;
	m_hResult = NOERROR;
	m_nDSCState = dscNoState;
	m_nDSCReason = dscNoReason;
}

/////////////////////////////////////////////////////////////////////////////
// COleControlLock

class COleControlLock
{
// Constructors
public:
	explicit COleControlLock(REFCLSID clsid);

// Attributes
	CLSID m_clsid;
	LPCLASSFACTORY m_pClassFactory;
	COleControlLock* m_pNextLock;

// Implementation
public:
	virtual ~COleControlLock();
};

#endif // __AFXPRIV2_H__OLE__
#endif //(!defined _AFX_NO_OLE_SUPPORT) && (defined _OBJBASE_H_)

/////////////////////////////////////////////////////////////////////////////
// OLE Automation features

#ifdef __AFXDISP_H__
#ifndef __AFXPRIV2_H__DISP__
#define __AFXPRIV2_H__DISP__

/////////////////////////////////////////////////////////////////////////////
// CArchiveStream

class CArchiveStream : public IStream
{
public:
	CArchiveStream(CArchive* pArchive);

// Implementation
	CArchive* m_pArchive;

	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();
	STDMETHOD(QueryInterface)(REFIID, LPVOID*);

	STDMETHOD(Read)(void*, ULONG, ULONG*);
	STDMETHOD(Write)(const void*, ULONG cb, ULONG*);
	STDMETHOD(Seek)(LARGE_INTEGER, DWORD, ULARGE_INTEGER*);
	STDMETHOD(SetSize)(ULARGE_INTEGER);
	STDMETHOD(CopyTo)(LPSTREAM, ULARGE_INTEGER, ULARGE_INTEGER*,
		ULARGE_INTEGER*);
	STDMETHOD(Commit)(DWORD);
	STDMETHOD(Revert)();
	STDMETHOD(LockRegion)(ULARGE_INTEGER, ULARGE_INTEGER,DWORD);
	STDMETHOD(UnlockRegion)(ULARGE_INTEGER, ULARGE_INTEGER, DWORD);
	STDMETHOD(Stat)(STATSTG*, DWORD);
	STDMETHOD(Clone)(LPSTREAM*);
};

/////////////////////////////////////////////////////////////////////////////
// Global UNICODE<>ANSI translation helpers

void AFXAPI AfxBSTR2CString(CString* pStr, BSTR bstr);

#if !defined(_UNICODE)
BSTR AFXAPI AfxBSTR2ABSTR(BSTR bstrW);
LPWSTR AFXAPI AfxTaskStringA2W(LPCSTR lpa);
LPSTR AFXAPI AfxTaskStringW2A(LPCWSTR lpw);
#endif

#endif // __AFXPRIV2_H__DISP__
#endif // __AFXDISP_H__

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#if (defined __AFXPRIV2_H__OLE__) && (defined __AFXPRIV2_H__DISP__)
#define __AFXPRIV2_H__
#endif

#endif // __AFXPRIV2_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxpopupmenubar.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxtoolbar.h"
#include "afxmenubar.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCToolBarMenuButton;

/////////////////////////////////////////////////////////////////////////////
// CMFCPopupMenuBar command target

class CMFCPopupMenuBar : public CMFCToolBar
{
	friend class CMFCPopupMenu;
	friend class CMFCDropDownListBox;

	DECLARE_SERIAL(CMFCPopupMenuBar)

public:
	CMFCPopupMenuBar();
	virtual ~CMFCPopupMenuBar();

// Attributes
public:
	UINT GetDefaultMenuId() const { return m_uiDefaultMenuCmdId; }

	int GetOffset() const { return m_iOffset; }
	void SetOffset(int iOffset)
	{
		if (m_iOffset != iOffset)
		{
			m_iOffset = iOffset;
			AdjustLocations();
		}
	}

	virtual CSize GetCurrentMenuImageSize() const
	{
		if (m_pRelatedToolbar == NULL || !m_pRelatedToolbar->IsLocked())
		{
			return CMFCToolBar::GetMenuImageSize();
		}
		return m_pRelatedToolbar->GetLockedImageSize();
	}

	BOOL            m_bDisableSideBarInXPMode;
	CMFCToolBar* m_pRelatedToolbar;

	BOOL IsDropDownListMode() const { return m_bDropDownListMode; }

protected:
	UINT m_uiDefaultMenuCmdId;
	int  m_iOffset;	// rows
	int  m_xSeparatorOffsetLeft;
	int  m_xSeparatorOffsetRight;
	int  m_iMaxWidth;
	int  m_iMinWidth;
	BOOL m_bFirstClick;
	BOOL m_bFirstMove;
	BOOL m_bAreAllCommandsShown;
	BOOL m_bInCommand;
	BOOL m_bTrackMode;
	BOOL m_bIsClickOutsideItem;
	BOOL m_bPaletteMode;
	BOOL m_bPaletteRows;
	BOOL m_bDropDownListMode;
	BOOL m_nDropDownPageSize;
	BOOL m_bInScrollMode;
	BOOL m_bResizeTracking;

	CPoint                     m_ptCursor;
	CUIntArray                 m_arColumns;
	CMFCToolBarMenuButton*        m_pDelayedPopupMenuButton;
	CMFCToolBarMenuButton*        m_pDelayedClosePopupMenuButton;
	CMap<UINT, UINT,UINT,UINT> m_HiddenItemsAccel; // Accell. <==> Command

	AFX_IMPORT_DATA static UINT m_uiPopupTimerDelay;
	AFX_IMPORT_DATA static int  m_nLastCommandIndex;

// Operations
public:
	virtual BOOL ImportFromMenu(HMENU hMenu, BOOL bShowAllCommands = FALSE);
	virtual HMENU ExportToMenu() const;

	void StartPopupMenuTimer(CMFCToolBarMenuButton* pMenuButton, int nDelayFactor = 1);
	CMFCToolBar* FindDestintationToolBar(CPoint point);

	virtual void CloseDelayedSubMenu();
	virtual void RestoreDelayedSubMenu();

	BOOL LoadFromHash(HMENU hMenu);

	static int __stdcall GetLastCommandIndex() { return m_nLastCommandIndex; }
	BOOL IsPaletteMode() const { return m_bPaletteMode; }
	virtual BOOL IsRibbonPanel() const { return FALSE; }
	virtual BOOL IsRibbonPanelInRegularMode() const { return FALSE; }

	virtual void AdjustSizeImmediate(BOOL /*bRecalcLayout = TRUE*/) {}
	
	BOOL BuildOrigItems(UINT uiMenuResID);
	int GetGutterWidth();

public:
// Overrides
	virtual void SetButtonStyle(int nIndex, UINT nStyle);

protected:
	virtual BOOL OnSendCommand(const CMFCToolBarButton* pButton);
	virtual void AdjustLocations();
	virtual void DrawSeparator(CDC* pDC, const CRect& rect, BOOL bHorz);
	virtual CSize CalcSize(BOOL bVertDock);
	virtual BOOL AllowSelectDisabled() const { return CMFCMenuBar::IsHighlightDisabledItems(); }
	virtual BOOL AllowShowOnList() const { return FALSE; }
	virtual int FindDropIndex(const CPoint p, CRect& rectDrag) const;
	virtual void DrawDragCursor(CDC* pDC);
	virtual CMFCToolBarButton* CreateDroppedButton(COleDataObject* pDataObject);
	virtual void OnChangeHot(int iHot);
	virtual BOOL OnKey(UINT nChar);
	virtual BOOL OnSetDefaultButtonText(CMFCToolBarButton* pButton);
	virtual BOOL EnableContextMenuItems(CMFCToolBarButton* pButton, CMenu* pPopup);
	virtual void OnFillBackground(CDC* pDC);
	virtual void ShowCommandMessageString(UINT uiCmdId);

	virtual DROPEFFECT OnDragOver(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point);
	virtual INT_PTR OnToolHitTest(CPoint point, TOOLINFO* pTI) const;

	virtual BOOL OnUserToolTip(CMFCToolBarButton* /*pButton*/, CString& /*strTTText*/) const { return FALSE; }

	virtual CWnd* GetCommandTarget() const;
	void InvokeMenuCommand(UINT uiCmdId, const CMFCToolBarButton* pMenuItem);

	void SetInCommand(BOOL bInCommand = TRUE);

	virtual BOOL TranslateChar(UINT /*nChar*/) { return FALSE; }
	virtual BOOL IsButtonExtraSizeAvailable() const { return FALSE; }

	virtual void AdjustLayout();

	virtual void OnCalcSeparatorRect(CMFCToolBarButton* pButton, CRect& rectSeparator, BOOL bHorz);
	virtual BOOL AllowAltCustomization() const { return FALSE; }
	virtual void OnAfterButtonDelete();

	virtual BOOL AllowShowOnPaneMenu() const { return FALSE; }
	virtual BOOL AlwaysSaveSelection() const { return FALSE; }

// Implementation
protected:
	//{{AFX_MSG(CMFCPopupMenuBar)
	afx_msg void OnNcPaint();
	afx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp);
	afx_msg void OnDestroy();
	afx_msg void OnTimer(UINT_PTR nIDEvent);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg LRESULT OnIdleUpdateCmdUI(WPARAM wParam, LPARAM lParam);
	afx_msg void OnToolbarImageAndText();
	afx_msg void OnToolbarText();
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxpopupmenu.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxpopupmenubar.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCToolBarMenuButton;
class CMFCMenuBar;
class CMFCToolBarsMenuPropertyPage;
class CMFCRibbonBaseElement;
class CMFCShadowWnd;

/////////////////////////////////////////////////////////////////////////////
// CMFCPopupMenu frame

class CMFCPopupMenu : public CMiniFrameWnd
{
	friend class CMFCCustomizeButton;
	friend class CMFCToolBarMenuButton;
	friend class CMFCToolBarsMenuPropertyPage;
	friend class CFrameWndEx;
	friend class CMDIFrameWndEx;
	friend class COleIPFrameWndEx;
	friend class COleDocIPFrameWndEx;
	friend class CFrameImpl;
	friend class CDialogImpl;
	friend class CContextMenuManager;
	friend class CMFCRibbonBaseElement;
	friend class CMFCPopupMenuBar;
	friend class CMFCRibbonBar;
	friend class CMFCRibbonMiniToolBar;
	friend class CMFCRibbonPanelMenuBar;

	DECLARE_SERIAL(CMFCPopupMenu)

public:
	CMFCPopupMenu();
	virtual ~CMFCPopupMenu();

protected:
	CMFCPopupMenu(CMFCToolBarsMenuPropertyPage* pCustPage, LPCTSTR lpszTitle); // For customization only

// Attributes
public:
	enum ANIMATION_TYPE
	{
		NO_ANIMATION,
		UNFOLD,
		SLIDE,
		FADE,
		SYSTEM_DEFAULT_ANIMATION = 999,
	};

	enum MENUAREA_TYPE
	{
		MENU,
		SHADOW_RIGHT,
		SHADOW_BOTTOM,
		LOGO,
		OUTSIDE,
		TEAROFF_CAPTION
	};

	enum DROP_DIRECTION
	{
		DROP_DIRECTION_NONE,
		DROP_DIRECTION_BOTTOM,
		DROP_DIRECTION_TOP,
		DROP_DIRECTION_RIGHT,
		DROP_DIRECTION_LEFT,
	};

	enum LOGO_LOCATION
	{
		MENU_LOGO_LEFT,
		MENU_LOGO_RIGHT,
		MENU_LOGO_TOP,
		MENU_LOGO_BOTTOM,
	};

	enum QUICK_CUSTOMIZE_TYPE
	{
		QUICK_CUSTOMIZE_PANE,
		QUICK_CUSTOMIZE_ADDREMOVE,
		QUICK_CUSTOMIZE_NONE,
	};

	enum MENU_RESIZE_TYPE
	{
		MENU_RESIZE_BOTTOM,
		MENU_RESIZE_BOTTOM_RIGHT,
		MENU_RESIZE_TOP,
		MENU_RESIZE_TOP_RIGHT,
	};

	BOOL m_bAutoDestroyParent;

	HMENU GetHMenu() const { return m_hMenu; }
	virtual CMFCPopupMenuBar* GetMenuBar() { return &m_wndMenuBar; }

	void SetAutoDestroy(BOOL bAutoDestroy = TRUE) { m_bAutoDestroy = bAutoDestroy; }

	CMFCToolBarMenuButton* GetParentButton() const { return m_pParentBtn; }
	CMFCRibbonBaseElement* GetParentRibbonElement() const { return m_pParentRibbonElement; }

	static void __stdcall SetForceShadow(BOOL bValue) { m_bForceShadow = bValue; }
	static BOOL __stdcall GetForceShadow() { return m_bForceShadow; }

	static void __stdcall SetForceMenuFocus(BOOL bValue) { m_bForceMenuFocus = bValue; }
	static BOOL __stdcall GetForceMenuFocus() { return m_bForceMenuFocus; }

	static CMFCPopupMenu::ANIMATION_TYPE __stdcall GetAnimationType(BOOL bNoSystem = FALSE)
	{
		if (m_AnimationType == SYSTEM_DEFAULT_ANIMATION && !bNoSystem)
		{
			if (afxGlobalData.m_bMenuAnimation)
			{
				return afxGlobalData.m_bMenuFadeEffect ? FADE : SLIDE; 
			}
			else
			{
				return NO_ANIMATION;
			}
		}

		return m_AnimationType;
	}

	static void __stdcall SetAnimationType(CMFCPopupMenu::ANIMATION_TYPE type) { m_AnimationType = type; }
	static void __stdcall SetAnimationSpeed(UINT nElapse);
	static UINT __stdcall GetAnimationSpeed() { return m_AnimationSpeed; }
	static void __stdcall EnableMenuSound(BOOL bEnable = TRUE) { m_bMenuSound = bEnable; }
	static UINT __stdcall IsMenuSound() { return m_bMenuSound; }

	static void __stdcall AlwaysShowEmptyToolsEntry(BOOL bShow = TRUE) { m_bAlwaysShowEmptyToolsEntry = bShow; }
	static BOOL __stdcall IsAlwaysShowEmptyToolsEntry() { return m_bAlwaysShowEmptyToolsEntry; }

	static void __stdcall SetSendMenuSelectMsg(BOOL bSet = TRUE) { m_bSendMenuSelectMsg = bSet; }
	static BOOL __stdcall IsSendMenuSelectMsg() { return m_bSendMenuSelectMsg; }

	void EnableResize(CSize sizeMinResize);
	void EnableVertResize(int nMinResize);

	BOOL IsResizeble() const { return m_bIsResizable; }
	BOOL IsScrollable() const { return m_bScrollable; }
	void EnableScrolling(BOOL /*bEnable*/ = TRUE) { /* This method is obsolete. */ }

	void EnableMenuLogo(int iLogoSize, LOGO_LOCATION nLogoLocation = MENU_LOGO_LEFT);
	void SetMaxWidth(int iMaxWidth);

	CWnd* GetMessageWnd() const { return m_pMessageWnd; }
	void SetMessageWnd(CWnd* pMsgWnd) { m_pMessageWnd = pMsgWnd; }

	BOOL PostCommand(UINT uiCommandID);

	void MoveTo(const CPoint& pt)
	{
		m_ptLocation = pt;
		RecalcLayout();
	}

	virtual BOOL InCommand()
	{
		CMFCPopupMenuBar* pBar = GetMenuBar();
		return pBar == NULL ? FALSE : pBar->m_bInCommand;
	}

	static CMFCPopupMenu* __stdcall GetActiveMenu() { return m_pActivePopupMenu; }
	DROP_DIRECTION GetDropDirection() const { return m_DropDirection; }

	void SetRightAlign(BOOL bRightAlign = TRUE) { m_bRightAlign = bRightAlign; }
	BOOL IsRightAlign() const { return m_bRightAlign; }

	BOOL IsQuickCustomize() { return m_bQuickCusomize; }
	void SetQuickCustomizeType(QUICK_CUSTOMIZE_TYPE Type) { m_QuickType = Type; }
	QUICK_CUSTOMIZE_TYPE GetQuickCustomizeType() const { return m_QuickType; }
	BOOL IsCustomizePane() { return m_QuickType == QUICK_CUSTOMIZE_PANE; }

	BOOL IsShown() const { return m_bShown; }
	virtual BOOL IsIdle() const { return m_bAnimationIsDone && m_iScrollMode == 0; }

	virtual CWnd* GetParentArea(CRect& rectParentBtn);
	void SetParentRibbonElement(CMFCRibbonBaseElement* pElem);

	virtual BOOL IsAlwaysClose() const { return FALSE; }

	BOOL HasBeenResized() const { return m_bHasBeenResized; }
	virtual BOOL DefaultMouseClickOnClose() const { return TRUE; }

protected:
	AFX_IMPORT_DATA static CMFCPopupMenu* m_pActivePopupMenu;
	AFX_IMPORT_DATA static BOOL        m_bForceMenuFocus;  // Menu takes a focus when activated

	CWnd*   m_pMessageWnd;
	CPoint  m_ptLocation;
	CPoint  m_ptLocationInitial;
	CSize   m_FinalSize;
	CString m_strCaption;

	CMFCToolBarsMenuPropertyPage* const    m_pMenuCustomizationPage;
	CMFCToolBarMenuButton* m_pParentBtn;
	CMFCPopupMenuBar       m_wndMenuBar;
	DROP_DIRECTION      m_DropDirection;
	HMENU               m_hMenu;

	BOOL m_bAutoDestroy;
	BOOL m_bTrackMode;
	BOOL m_bHasBeenResized;
	BOOL m_bRightAlign;
	BOOL m_bShown;
	BOOL m_bTobeDstroyed;

	int m_nMenuBarHeight;
	int m_iMaxWidth;
	int m_iLogoWidth;
	int m_nLastCommandID;

	LOGO_LOCATION m_nLogoLocation;

	AFX_IMPORT_DATA static int m_nMinWidth;
	AFX_IMPORT_DATA static BOOL m_bMenuSound;
	AFX_IMPORT_DATA static BOOL m_bAlwaysShowEmptyToolsEntry;
	AFX_IMPORT_DATA static BOOL m_bSendMenuSelectMsg;

	//----------------------
	// Animation attributes:
	//----------------------
	AFX_IMPORT_DATA static ANIMATION_TYPE m_AnimationType;
	AFX_IMPORT_DATA static UINT           m_AnimationSpeed;

	CSize m_AnimSize;
	BOOL  m_bIsAnimRight;
	BOOL  m_bIsAnimDown;
	BOOL  m_bAnimationIsDone;
	BOOL  m_bDisableAnimation;

	//----------------------
	// Scrolling attributes:
	//----------------------
	BOOL m_bScrollable;
	BOOL m_bShowScrollBar;

	CRect m_rectScrollUp;
	CRect m_rectScrollDn;

	int m_iScrollMode;  // -1 - Up, 0 - None, 1 - Down
	int m_iScrollBtnHeight;
	int m_nMaxHeight;
	int m_iFadePercent;

	CScrollBar m_wndScrollBarVert;
	CBitmap    m_bmpScreenSrc;
	CBitmap    m_bmpScreenDst;
	CBitmap    m_bmpScreenTmp;

	COLORREF* m_cFadeSrcBits;
	COLORREF* m_cFadeDstBits;
	COLORREF* m_cFadeTmpBits;

	//-------------------
	// Shadow attributes:
	//-------------------
	int				m_iShadowSize;
	CBitmap			m_bmpShadowRight;				// Saved shadow butmaps
	CBitmap			m_bmpShadowBottom;
	CMFCShadowWnd*	m_pWndShadow;					// layered shadow


	AFX_IMPORT_DATA static BOOL m_bForceShadow;     // when TRUE paints shadows even outside main-frame

	//---------------------
	// Tear-off attributes:
	//---------------------
	BOOL         m_bTearOffTracking;
	BOOL         m_bIsTearOffCaptionActive;
	CRect        m_rectTearOffCaption;
	CToolTipCtrl m_wndToolTip;

	//-------------------
	// Resize attributes:
	//-------------------
	BOOL  m_bResizeTracking;
	BOOL  m_bWasResized;
	BOOL  m_bIsResizeBarOnTop;
	BOOL  m_bIsResizable;
	CSize m_sizeMinResize;
	CSize m_sizeCurrent;
	CRect m_rectResize;

	//------------------------
	// Quick Cusomization flags
	//------------------------
	BOOL  m_bQuickCusomize;
	BOOL  m_bEscClose;
	QUICK_CUSTOMIZE_TYPE m_QuickType;

	//-------------------
	// Ribbon attributes:
	//-------------------
	CMFCRibbonBaseElement* m_pParentRibbonElement;
	HWND                m_hwndConnectedFloaty;

// Operations
public:
	virtual void SaveState();

	CMFCPopupMenu* GetParentPopupMenu() const;
	CMFCToolBar* GetParentToolBar() const;

	CMFCToolBarMenuButton* GetSelItem();

	int InsertItem(const CMFCToolBarMenuButton& button, int iInsertAt = -1);
	int InsertSeparator(int iInsertAt = -1);

	int GetMenuItemCount() const;
	CMFCToolBarMenuButton* GetMenuItem(int iIndex) const;
	CMFCToolBarMenuButton* FindSubItemByCommand(UINT uiCmd) const;
	
	BOOL RemoveItem(int iIndex);
	void RemoveAllItems();

	void SetDefaultItem(UINT uiCmd) { GetMenuBar()->m_uiDefaultMenuCmdId = uiCmd; }

	static BOOL __stdcall ActivatePopupMenu(CFrameWnd* pTopFrame, CMFCPopupMenu* pPopupMenu);
	void CloseMenu(BOOL bSetFocusToBar = FALSE);
	void ShowAllCommands();

	BOOL HideRarelyUsedCommands() const;
	BOOL AreAllCommandsShown() const { return ((CMFCPopupMenu*) this)->GetMenuBar()->m_bAreAllCommandsShown; }

	MENUAREA_TYPE CheckArea(const CPoint& ptScreen) const;

	void UpdateShadow(LPRECT lprectScreen = NULL);
	static void __stdcall UpdateAllShadows(LPRECT lprectScreen = NULL); // Repaint all opened menu shadows

	void SetQuickMode();

	BOOL IsEscClose() { return m_bEscClose; }

	void TriggerResize();

protected:
	void Initialize();

	virtual BOOL IsScrollUpAvailable();
	virtual BOOL IsScrollDnAvailable();

	void CollapseSubmenus();
	void UpdateBottomWindows(BOOL bCheckOnly = FALSE);

	virtual void DoPaint(CDC* pPaintDC);
	virtual void DrawFade(CDC* pPaintDC);

	BOOL AdjustScroll(BOOL bForceMenuBarResize = FALSE);
	void SetScrollBar();

	virtual BOOL InitMenuBar();
	virtual BOOL TearOff(CPoint point);
	virtual CPane* CreateTearOffBar(CFrameWnd* pWndMain, UINT uiID, LPCTSTR lpszName);
	virtual void OnChooseItem(UINT /*uidCmdID*/) {}
	virtual void OnChangeHot(int /*nHot*/) {}

	BOOL NotifyParentDlg(BOOL bActivate);

	virtual BOOL IsRibbonMiniToolBar() const { return FALSE; }

	BOOL StartResize();

	virtual int GetBorderSize() const;

	static CMFCPopupMenu* __stdcall FindMenuWithConnectedFloaty();

// Overrides
public:
	virtual BOOL Create(CWnd* pWndParent, int x, int y, HMENU hMenu, BOOL bLocked = FALSE, BOOL bOwnMessage=FALSE); // Add: Alex Corazzin (2)
	virtual void RecalcLayout(BOOL bNotify = TRUE);
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	virtual BOOL PreTranslateMessage(MSG* pMsg);

protected:
	virtual void PostNcDestroy();
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);

// Implementation
protected:
	//{{AFX_MSG(CMFCPopupMenu)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnPaint();
	afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
	afx_msg void OnDestroy();
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnTimer(UINT_PTR nIDEvent);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg BOOL OnMouseWheel(UINT nFlags, short zDelta, CPoint pt);
	afx_msg LRESULT OnNcHitTest(CPoint point);
	afx_msg void OnNcLButtonDown(UINT nHitTest, CPoint point);
	afx_msg void OnActivateApp(BOOL bActive, DWORD dwThreadID);
	afx_msg void OnWindowPosChanged(WINDOWPOS FAR* lpwndpos);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class CMFCDisableMenuAnimation
{
public:
	CMFCDisableMenuAnimation ()
	{
		m_animType = CMFCPopupMenu::GetAnimationType ();
		CMFCPopupMenu::SetAnimationType (CMFCPopupMenu::NO_ANIMATION);
	}

	virtual ~CMFCDisableMenuAnimation ()
	{
		Restore ();
	}

	void Restore ()
	{
		CMFCPopupMenu::SetAnimationType (m_animType);
	}

protected:
	CMFCPopupMenu::ANIMATION_TYPE m_animType;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxpriv.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Note: This header file contains useful classes that are documented only
//  in the MFC Technical Notes.  These classes may change from version to
//  version, so be prepared to change your code accordingly if you utilize
//  this header.  In the future, commonly used portions of this header
//  may be moved and officially documented.

#ifndef __AFXPRIV_H__
#define __AFXPRIV_H__

#pragma once

#ifdef _DEBUG
// Special _CLIENT_BLOCK type to identifiy CObjects.
#define _AFX_CLIENT_BLOCK (_CLIENT_BLOCK|(0xc0<<16))
#endif

#ifndef __AFXADV_H__
	#include <afxadv.h>
#endif

#ifndef _INC_MALLOC
	#include <malloc.h>
#endif

#ifndef __AFXEXT_H__
	#include <afxext.h>
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// AFXPRIV - MFC Private Classes

// Implementation structures
struct AFX_SIZEPARENTPARAMS;    // Control bar implementation
struct AFX_CMDHANDLERINFO;      // Command routing implementation

// Classes declared in this file

	//CDC
		class CPreviewDC;               // Virtual DC for print preview

	//CCmdTarget
		//CWnd
			//CView
				class CPreviewView;     // Print preview view
		//CFrameWnd
			class COleCntrFrameWnd;
			//CMiniFrameWnd
				class CMiniDockFrameWnd;

class CDockContext;                     // for dragging control bars

/////////////////////////////////////////////////////////////////////////////

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

/////////////////////////////////////////////////////////////////////////////
// Global ID ranges (see Technical note TN020 for more details)

// 8000 -> FFFF command IDs (used for menu items, accelerators and controls)
#define IS_COMMAND_ID(nID)  ((nID) & 0x8000)

// 8000 -> DFFF : user commands
// E000 -> EFFF : AFX commands and other things
// F000 -> FFFF : standard windows commands and other things etc
	// E000 -> E7FF standard commands
	// E800 -> E8FF control bars (first 32 are special)
	// E900 -> EEFF standard window controls/components
	// EF00 -> EFFF SC_ menu help
	// F000 -> FFFF standard strings
#define ID_COMMAND_FROM_SC(sc)  (((sc - 0xF000) >> 4) + AFX_IDS_SCFIRST)

// 0000 -> 7FFF IDR range
// 0000 -> 6FFF : user resources
// 7000 -> 7FFF : AFX (and standard windows) resources
// IDR ranges (NOTE: IDR_ values must be <32768)
#define ASSERT_VALID_IDR(nIDR) ASSERT((nIDR) != 0 && (nIDR) < 0x8000)

/////////////////////////////////////////////////////////////////////////////
// Context sensitive help support (see Technical note TN028 for more details)

// Help ID bases
#define HID_BASE_COMMAND    0x00010000UL        // ID and IDM
#define HID_BASE_RESOURCE   0x00020000UL        // IDR and IDD
#define HID_BASE_PROMPT     0x00030000UL        // IDP
#define HID_BASE_NCAREAS    0x00040000UL
#define HID_BASE_CONTROL    0x00050000UL        // IDC
#define HID_BASE_DISPATCH   0x00060000UL        // IDispatch help codes

/////////////////////////////////////////////////////////////////////////////
// Internal AFX Windows messages (see Technical note TN024 for more details)
// (0x0360 - 0x037F are reserved for MFC)

#define WM_QUERYAFXWNDPROC  0x0360  // lResult = 1 if processed by AfxWndProc
#define WM_SIZEPARENT       0x0361  // lParam = &AFX_SIZEPARENTPARAMS
#define WM_SETMESSAGESTRING 0x0362  // wParam = nIDS (or 0),
									// lParam = lpszOther (or NULL)
#define WM_IDLEUPDATECMDUI  0x0363  // wParam == bDisableIfNoHandler
#define WM_INITIALUPDATE    0x0364  // (params unused) - sent to children
#define WM_COMMANDHELP      0x0365  // lResult = TRUE/FALSE,
									// lParam = dwContext
#define WM_HELPHITTEST      0x0366  // lResult = dwContext,
									// lParam = MAKELONG(x,y)
#define WM_EXITHELPMODE     0x0367  // (params unused)
#define WM_RECALCPARENT     0x0368  // force RecalcLayout on frame window
									//  (only for inplace frame windows)
#define WM_SIZECHILD        0x0369  // special notify from COleResizeBar
									// wParam = ID of child window
									// lParam = lpRectNew (new position/size)
#define WM_KICKIDLE         0x036A  // (params unused) causes idles to kick in
#define WM_QUERYCENTERWND   0x036B  // lParam = HWND to use as centering parent
#define WM_DISABLEMODAL     0x036C  // lResult = 0, disable during modal state
									// lResult = 1, don't disable
#define WM_FLOATSTATUS      0x036D  // wParam combination of FS_* flags below

// WM_ACTIVATETOPLEVEL is like WM_ACTIVATEAPP but works with hierarchies
//   of mixed processes (as is the case with OLE in-place activation)
#define WM_ACTIVATETOPLEVEL 0x036E  // wParam = nState (like WM_ACTIVATE)
									// lParam = pointer to HWND[2]
									//  lParam[0] = hWnd getting WM_ACTIVATE
									//  lParam[1] = hWndOther

#define WM_RESERVED_036F	0x036F  // was WM_QUERY3DCONTROLS (now not used)

// Note: Messages 0x0370, 0x0371, and 0x372 were incorrectly used by
//  some versions of Windows.  To remain compatible, MFC does not
//  use messages in that range.
#define WM_RESERVED_0370    0x0370
#define WM_RESERVED_0371    0x0371
#define WM_RESERVED_0372    0x0372

// WM_SOCKET_NOTIFY and WM_SOCKET_DEAD are used internally by MFC's
// Windows sockets implementation.  For more information, see sockcore.cpp
#define WM_SOCKET_NOTIFY    0x0373
#define WM_SOCKET_DEAD      0x0374

// same as WM_SETMESSAGESTRING except not popped if IsTracking()
#define WM_POPMESSAGESTRING 0x0375

// WM_HELPPROMPTADDR is used internally to get the address of 
//	m_dwPromptContext from the associated frame window. This is used
//	during message boxes to setup for F1 help while that msg box is
//	displayed. lResult is the address of m_dwPromptContext.
#define WM_HELPPROMPTADDR	0x0376

// Constants used in DLGINIT resources for OLE control containers
// NOTE: These are NOT real Windows messages they are simply tags
// used in the control resource and are never used as 'messages'
#define WM_OCC_LOADFROMSTREAM           0x0376
#define WM_OCC_LOADFROMSTORAGE          0x0377
#define WM_OCC_INITNEW                  0x0378
#define WM_OCC_LOADFROMSTREAM_EX        0x037A
#define WM_OCC_LOADFROMSTORAGE_EX       0x037B

// Constant used in DLGINIT resources for MFC controls
#define WM_MFC_INITCTRL                 0x037C

// Marker used while rearranging the message queue
#define WM_QUEUE_SENTINEL   0x0379

// Note: Messages 0x037D - 0x37E reserved for future MFC use.
#define WM_RESERVED_037D    0x037D
#define WM_RESERVED_037E    0x037E

// WM_FORWARDMSG - used by ATL to forward a message to another window for processing
//	WPARAM - DWORD dwUserData - defined by user
//	LPARAM - LPMSG pMsg - a pointer to the MSG structure
//	return value - 0 if the message was not processed, nonzero if it was
#define WM_FORWARDMSG		0x037F

// like ON_MESSAGE but no return value
#define ON_MESSAGE_VOID(message, memberFxn) \
	{ message, 0, 0, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(void))&memberFxn },

// special struct for WM_SIZEPARENT
struct AFX_SIZEPARENTPARAMS
{
	HDWP hDWP;       // handle for DeferWindowPos
	RECT rect;       // parent client rectangle (trim as appropriate)
	SIZE sizeTotal;  // total size on each side as layout proceeds
	BOOL bStretch;   // should stretch to fill all space
};

// flags for wParam in the WM_FLOATSTATUS message
enum {  FS_SHOW = 0x01, FS_HIDE = 0x02,
		FS_ACTIVATE = 0x04, FS_DEACTIVATE = 0x08,
		FS_ENABLE = 0x10, FS_DISABLE = 0x20,
		FS_SYNCACTIVE = 0x40 };

void AFXAPI AfxRepositionWindow(AFX_SIZEPARENTPARAMS* lpLayout,
	HWND hWnd, LPCRECT lpRect);

/////////////////////////////////////////////////////////////////////////////
// Implementation of command routing

struct AFX_CMDHANDLERINFO
{
	CCmdTarget* pTarget;
	void (AFX_MSG_CALL CCmdTarget::*pmf)(void);
};

/////////////////////////////////////////////////////////////////////////////
// Robust file save support
// opens a temp file if modeCreate specified and enough free space
// renaming, etc occurs automatically if everything succeeds

class CMirrorFile : public CFile
{
// Implementation
public:
	virtual void Abort();
	virtual void Close();
	virtual BOOL Open(LPCTSTR lpszFileName, UINT nOpenFlags,
		CFileException* pError = NULL);

protected:
	CString m_strMirrorName;
};

/////////////////////////////////////////////////////////////////////////////
// Implementation of PrintPreview

class CPreviewDC : public CDC
{
	DECLARE_DYNAMIC(CPreviewDC)

public:
	virtual void SetAttribDC(HDC hDC);  // Set the Attribute DC
	virtual void SetOutputDC(HDC hDC);

	virtual void ReleaseOutputDC();

// Constructors
	CPreviewDC();

// Implementation
public:
	virtual ~CPreviewDC();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	void SetScaleRatio(int nNumerator, int nDenominator);
	void SetTopLeftOffset(CSize TopLeft);
	void ClipToPage();

	// These conversion functions can be used without an output DC

	void PrinterDPtoScreenDP(LPPOINT lpPoint) const;

// Device-Context Functions
	virtual int SaveDC();
	virtual BOOL RestoreDC(int nSavedDC);

public:
	virtual CGdiObject* SelectStockObject(int nIndex);
	virtual CFont* SelectObject(CFont* pFont);

// Drawing-Attribute Functions
	virtual COLORREF SetBkColor(COLORREF crColor);
	virtual COLORREF SetTextColor(COLORREF crColor);

// Mapping Functions
	virtual int SetMapMode(int nMapMode);
	virtual CPoint SetViewportOrg(int x, int y);
	virtual CPoint OffsetViewportOrg(int nWidth, int nHeight);
	virtual CSize SetViewportExt(int x, int y);
	virtual CSize ScaleViewportExt(int xNum, int xDenom, int yNum, int yDenom);
	virtual CSize SetWindowExt(int x, int y);
	virtual CSize ScaleWindowExt(int xNum, int xDenom, int yNum, int yDenom);

// Text Functions
	virtual BOOL TextOut(int x, int y, LPCTSTR lpszString, int nCount);
	virtual BOOL ExtTextOut(int x, int y, UINT nOptions, LPCRECT lpRect,
				LPCTSTR lpszString, UINT nCount, LPINT lpDxWidths);
	virtual CSize TabbedTextOut(int x, int y, LPCTSTR lpszString, int nCount,
				int nTabPositions, LPINT lpnTabStopPositions, int nTabOrigin);
	virtual int _AFX_FUNCNAME(DrawText)(LPCTSTR lpszString, int nCount, LPRECT lpRect,
				UINT nFormat);
	virtual int _AFX_FUNCNAME(DrawTextEx)(_In_count_(nCount) LPTSTR lpszString, int nCount, LPRECT lpRect,
				UINT nFormat, LPDRAWTEXTPARAMS lpDTParams);
#pragma push_macro("DrawText")
#pragma push_macro("DrawTextEx")
#undef DrawText
#undef DrawTextEx
	int DrawText(LPCTSTR lpszString, int nCount, LPRECT lpRect,
				UINT nFormat)
	{
		return _AFX_FUNCNAME(DrawText)(lpszString, nCount, lpRect, nFormat);
	}
	int DrawTextEx(_In_count_(nCount) LPTSTR lpszString, int nCount, LPRECT lpRect,
				UINT nFormat, LPDRAWTEXTPARAMS lpDTParams)
	{
		return _AFX_FUNCNAME(DrawTextEx)(lpszString, nCount, lpRect, nFormat, lpDTParams);
	}
#pragma pop_macro("DrawText")
#pragma pop_macro("DrawTextEx")
	virtual BOOL GrayString(CBrush* pBrush,
				BOOL (CALLBACK* lpfnOutput)(HDC, LPARAM, int),
					LPARAM lpData, int nCount,
					int x, int y, int nWidth, int nHeight);

// Printer Escape Functions
	virtual int Escape(int nEscape, int nCount, LPCSTR lpszInData, LPVOID lpOutData);

// Implementation
protected:
	void MirrorMappingMode(BOOL bCompute);
	void MirrorViewportOrg();
	void MirrorFont();
	void MirrorAttributes();

	CSize ComputeDeltas(int& x, _In_z_ LPCTSTR lpszString, UINT& nCount, _In_ BOOL bTabbed,
					_In_ UINT nTabStops, _In_count_(nTabStops) LPINT lpnTabStops, _In_ int nTabOrigin,
					_Pre_notnull_ _Post_z_ LPTSTR lpszOutputString, int* pnDxWidths, int& nRightFixup);

protected:
	int m_nScaleNum;    // Scale ratio Numerator
	int m_nScaleDen;    // Scale ratio Denominator
	int m_nSaveDCIndex; // DC Save index when Screen DC Attached
	int m_nSaveDCDelta; // delta between Attrib and output restore indices
	CSize m_sizeTopLeft;// Offset for top left corner of page
	HFONT m_hFont;      // Font selected into the screen DC (NULL if none)
	HFONT m_hPrinterFont; // Font selected into the print DC

	CSize m_sizeWinExt; // cached window extents computed for screen
	CSize m_sizeVpExt;  // cached viewport extents computed for screen
};

/////////////////////////////////////////////////////////////////////////////
// CPreviewView

class CDialogBar;

class CPreviewView : public CScrollView
{
	DECLARE_DYNCREATE(CPreviewView)

// Constructors
public:
	CPreviewView();
	BOOL SetPrintView(CView* pPrintView);

// Attributes
protected:
	CView* m_pOrigView;
	CView* m_pPrintView;
	CPreviewDC* m_pPreviewDC;  // Output and attrib DCs Set, not created
	CDC m_dcPrint;             // Actual printer DC

// Operations
	void SetZoomState(UINT nNewState, UINT nPage, CPoint point);
	void SetCurrentPage(UINT nPage, BOOL bClearRatios);

	// Returns TRUE if in a page rect. Returns the page index
	// in nPage and the point converted to 1:1 screen device coordinates
	BOOL FindPageRect(CPoint& point, UINT& nPage);


// Overridables
	virtual void OnActivateView(BOOL bActivate,
			CView* pActivateView, CView* pDeactiveView);

	// Returns .cx/.cy as the numerator/denominator pair for the ratio
	// using CSize for convenience
	virtual CSize CalcScaleRatio(CSize windowSize, CSize actualSize);

	virtual void PositionPage(UINT nPage);
	virtual void OnDisplayPageNumber(UINT nPage, UINT nPagesDisplayed);

// Implementation
public:
	virtual ~CPreviewView();
	virtual void OnPrepareDC(CDC* pDC, CPrintInfo* pInfo = NULL);
	IOleInPlaceUIWindow *m_pIPUIWindow;
#ifdef _DEBUG
	void AssertValid() const;
	void Dump(CDumpContext& dc) const;
#endif

protected:
	//{{AFX_MSG(CPreviewView)
	afx_msg void OnPreviewClose();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnDraw(CDC* pDC);
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnNumPageChange();
	afx_msg void OnNextPage();
	afx_msg void OnPrevPage();
	afx_msg void OnPreviewPrint();
	afx_msg void OnZoomIn();
	afx_msg void OnZoomOut();
	afx_msg void OnUpdateNumPageChange(CCmdUI* pCmdUI);
	afx_msg void OnUpdateNextPage(CCmdUI* pCmdUI);
	afx_msg void OnUpdatePrevPage(CCmdUI* pCmdUI);
	afx_msg void OnUpdateZoomIn(CCmdUI* pCmdUI);
	afx_msg void OnUpdateZoomOut(CCmdUI* pCmdUI);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	//}}AFX_MSG

	void DoZoom(UINT nPage, CPoint point);
	void SetScaledSize(UINT nPage);
	CSize CalcPageDisplaySize();

	CPrintPreviewState* m_pPreviewState; // State to restore
	CDialogBar* m_pToolBar; // Toolbar for preview

	struct PAGE_INFO
	{
		PAGE_INFO();
		CRect rectScreen; // screen rect (screen device units)
		CSize sizeUnscaled; // unscaled screen rect (screen device units)
		CSize sizeScaleRatio; // scale ratio (cx/cy)
		CSize sizeZoomOutRatio; // scale ratio when zoomed out (cx/cy)
	};

	PAGE_INFO* m_pPageInfo; // Array of page info structures
	PAGE_INFO m_pageInfoArray[2]; // Embedded array for the default implementation

	BOOL m_bPageNumDisplayed;// Flags whether or not page number has yet
								// been displayed on status line
	UINT m_nZoomOutPages; // number of pages when zoomed out
	UINT m_nZoomState;
	UINT m_nMaxPages; // for sanity checks
	UINT m_nCurrentPage;
	UINT m_nPages;
	int m_nSecondPageOffset; // used to shift second page position

	HCURSOR m_hMagnifyCursor;

	CSize m_sizePrinterPPI; // printer pixels per inch
	CPoint m_ptCenterPoint;
	CPrintInfo* m_pPreviewInfo;

	DECLARE_MESSAGE_MAP()

	friend class CView;
	friend BOOL CALLBACK _AfxPreviewCloseProc(CFrameWnd* pFrameWnd);
};

// Zoom States
#define _AFX_ZOOM_OUT    0
#define _AFX_ZOOM_MIDDLE 1
#define _AFX_ZOOM_IN     2

#ifndef _AFX_USE_OLD_ZOOM
#define _AFX_USE_OLD_ZOOM 1
#endif

#if _AFX_USE_OLD_ZOOM
#define ZOOM_OUT    _AFX_ZOOM_OUT
#define ZOOM_MIDDLE _AFX_ZOOM_MIDDLE
#define ZOOM_IN     _AFX_ZOOM_IN
#endif

/////////////////////////////////////////////////////////////////////////////
// mirroring support

// some mirroring stuff will be in wingdi.h someday
#ifndef LAYOUT_LTR
#define LAYOUT_LTR								 0x00000000	
#endif

/////////////////////////////////////////////////////////////////////////////
// toolbar docking support

class CDockContext
{
public:
// Construction
	explicit CDockContext(CControlBar* pBar);

// Attributes
	CPoint m_ptLast;            // last mouse position during drag
	CRect m_rectLast;
	CSize m_sizeLast;
	BOOL m_bDitherLast;

	// Rectangles used during dragging or resizing
	CRect m_rectDragHorz;
	CRect m_rectDragVert;
	CRect m_rectFrameDragHorz;
	CRect m_rectFrameDragVert;

	CControlBar* m_pBar;        // the toolbar that created this context
	CFrameWnd* m_pDockSite;     // the controlling frame of the CControlBar
	DWORD m_dwDockStyle;        // allowable dock styles for bar
	DWORD m_dwOverDockStyle;    // style of dock that rect is over
	DWORD m_dwStyle;            // style of control bar
	BOOL m_bFlip;               // if shift key is down
	BOOL m_bForceFrame;         // if ctrl key is down

	CDC* m_pDC;                 // where to draw during drag
	BOOL m_bDragging;
	int m_nHitTest;

	UINT m_uMRUDockID;
	CRect m_rectMRUDockPos;

	DWORD m_dwMRUFloatStyle;
	CPoint m_ptMRUFloatPos;

// Drag Operations
	virtual void StartDrag(CPoint pt);
	void Move(CPoint pt);       // called when mouse has moved
	void EndDrag();             // drop
	void OnKey(int nChar, BOOL bDown);

// Resize Operations
	virtual void StartResize(int nHitTest, CPoint pt);
	void Stretch(CPoint pt);
	void EndResize();

// Double Click Operations
	virtual void ToggleDocking();

// Operations
	void InitLoop();
	void CancelLoop();

// Implementation
public:
	virtual ~CDockContext();
	BOOL Track();
	void DrawFocusRect(BOOL bRemoveRect = FALSE);
		// draws the correct outline
	void UpdateState(BOOL* pFlag, BOOL bNewValue);
	DWORD CanDock();
	CDockBar* GetDockBar(DWORD dwOverDockStyle);
};

/////////////////////////////////////////////////////////////////////////////
// CControlBarInfo - used for docking serialization

class CControlBarInfo
{
public:
// Implementation
	CControlBarInfo();

// Attributes
	UINT m_nBarID;      // ID of this bar
	BOOL m_bVisible;    // visibility of this bar
	BOOL m_bFloating;   // whether floating or not
	BOOL m_bHorz;       // orientation of floating dockbar
	BOOL m_bDockBar;    // TRUE if a dockbar
	CPoint m_pointPos;  // topleft point of window

	UINT m_nMRUWidth;   // MRUWidth for Dynamic Toolbars
	BOOL m_bDocking;    // TRUE if this bar has a DockContext
	UINT m_uMRUDockID;  // most recent docked dockbar
	CRect m_rectMRUDockPos; // most recent docked position
	DWORD m_dwMRUFloatStyle; // most recent floating orientation
	CPoint m_ptMRUFloatPos; // most recent floating position

	CUIntArray m_arrBarID;   // bar IDs for bars contained within this one
	CControlBar* m_pBar;    // bar which this refers to (transient)

	void Serialize(CArchive& ar, CDockState* pDockState);
	BOOL LoadState(LPCTSTR lpszProfileName, int nIndex, CDockState* pDockState);
	BOOL SaveState(LPCTSTR lpszProfileName, int nIndex);
};

/////////////////////////////////////////////////////////////////////////////
// CDockBar - used for docking

class CDockBar : public CControlBar
{
	DECLARE_DYNAMIC(CDockBar)

// Construction
public:
	/* explicit */ CDockBar(BOOL bFloating = FALSE);   // TRUE if attached to CMiniDockFrameWnd
	virtual BOOL Create(CWnd* pParentWnd, DWORD dwStyle, UINT nID);

// Attributes
	BOOL m_bFloating;

	virtual BOOL IsDockBar() const;
	int GetDockedCount() const;
	virtual int GetDockedVisibleCount() const;

// Operations
	void DockControlBar(CControlBar* pBar, LPCRECT lpRect = NULL);
	void ReDockControlBar(CControlBar* pBar, LPCRECT lpRect = NULL);
	BOOL RemoveControlBar(CControlBar*, int nPosExclude = -1, int nAddPlaceHolder = 0);
	void RemovePlaceHolder(CControlBar* pBar);

// Implementation
public:
	virtual ~CDockBar();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);
	virtual void DoPaint(CDC* pDC);

	// public implementation helpers
	void GetBarInfo(CControlBarInfo* pInfo);
	void SetBarInfo(CControlBarInfo* pInfo, CFrameWnd* pFrameWnd);
	int FindBar(CControlBar* pBar, int nPosExclude = -1);
	void ShowAll(BOOL bShow);

	CPtrArray m_arrBars;    // each element is a CControlBar
protected:
	BOOL m_bLayoutQuery;
	CRect m_rectLayout;

	CControlBar* GetDockedControlBar(int nPos) const;

	// implementation helpers
	int Insert(CControlBar* pBar, CRect rect, CPoint ptMid);
	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);

	//{{AFX_MSG(CDockBar)
	afx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS* lpncsp);
	afx_msg void OnNcPaint();
	afx_msg void OnWindowPosChanging(LPWINDOWPOS lpWndPos);
	afx_msg void OnPaint();
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg LRESULT OnSizeParent(WPARAM, LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	friend class CMiniDockFrameWnd;
};

class CMiniDockFrameWnd : public CMiniFrameWnd
{
	DECLARE_DYNCREATE(CMiniDockFrameWnd)

public:
// Construction
	CMiniDockFrameWnd();
	virtual BOOL Create(CWnd* pParent, DWORD dwBarStyle);

// Operations
	virtual void RecalcLayout(BOOL bNotify = TRUE);

// Implementation
public:
	CDockBar m_wndDockBar;

	//{{AFX_MSG(CMiniFrameWnd)
	afx_msg void OnClose();
	afx_msg void OnNcLButtonDown(UINT nHitTest, CPoint point);
	afx_msg void OnNcLButtonDblClk(UINT nHitTest, CPoint point);
	//}}AFX_MSG
	afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// COleCntrFrameWnd

class COleIPFrameWnd;

class COleCntrFrameWnd : public CFrameWnd
{
// Constructor
public:
	explicit COleCntrFrameWnd(COleIPFrameWnd* pInPlaceFrame);

// Implementation
protected:
	COleIPFrameWnd* m_pInPlaceFrame;
	virtual void PostNcDestroy();

public:
	virtual ~COleCntrFrameWnd();
	virtual void RecalcLayout(BOOL bNotify = TRUE);
	void OnIdleUpdateCmdUI();
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo);
#ifdef _DEBUG
	void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CDialogTemplate

class CDialogTemplate
{
// Constructors
public:
	/* explicit */ CDialogTemplate(const DLGTEMPLATE* pTemplate = NULL);
	explicit CDialogTemplate(HGLOBAL hGlobal);

// Attributes
	BOOL HasFont() const;
	BOOL SetFont(LPCTSTR lpFaceName, WORD nFontSize);
	BOOL SetSystemFont(WORD nFontSize = 0);
	BOOL GetFont(CString& strFaceName, WORD& nFontSize) const;
	void GetSizeInDialogUnits(SIZE* pSize) const;
	void GetSizeInPixels(SIZE* pSize) const;

	static BOOL AFX_CDECL GetFont(const DLGTEMPLATE* pTemplate,
		CString& strFaceName, WORD& nFontSize);

// Operations
	BOOL Load(LPCTSTR lpDialogTemplateID);
	HGLOBAL Detach();

// Implementation
public:
	~CDialogTemplate();

	HGLOBAL m_hTemplate;
	DWORD m_dwTemplateSize;
	BOOL m_bSystemFont;

protected:
	static BYTE* AFX_CDECL GetFontSizeField(const DLGTEMPLATE* pTemplate);
	static UINT AFX_CDECL GetTemplateSize(const DLGTEMPLATE* pTemplate);
	BOOL SetTemplate(const DLGTEMPLATE* pTemplate, UINT cb);
};

/////////////////////////////////////////////////////////////////////////////
// WM_NOTIFY support

struct AFX_NOTIFY
{
	LRESULT* pResult;
	NMHDR* pNMHDR;
};


////////////////////////////////////////////////////////////////////////////
// other global state
class CPushRoutingFrame
{
protected:
	CFrameWnd* pOldRoutingFrame;
	_AFX_THREAD_STATE* pThreadState;
   CPushRoutingFrame* pOldPushRoutingFrame;

public:
	explicit CPushRoutingFrame(CFrameWnd* pNewRoutingFrame)
	{ 
		pThreadState = AfxGetThreadState();
	  pOldPushRoutingFrame = pThreadState->m_pPushRoutingFrame;
		pOldRoutingFrame = pThreadState->m_pRoutingFrame;
		pThreadState->m_pRoutingFrame = pNewRoutingFrame;
	  pThreadState->m_pPushRoutingFrame = this;
	}
	~CPushRoutingFrame()
	{ 
	  if (pThreadState != NULL)
	  {
		 ASSERT( pThreadState->m_pPushRoutingFrame == this );
		 pThreadState->m_pRoutingFrame = pOldRoutingFrame;
		 pThreadState->m_pPushRoutingFrame = pOldPushRoutingFrame;
	  }
   }
   void Pop()
   {
	  ENSURE( pThreadState != NULL );
	  ASSERT( pThreadState->m_pPushRoutingFrame == this );
	  pThreadState->m_pRoutingFrame = pOldRoutingFrame;
	  pThreadState->m_pPushRoutingFrame = pOldPushRoutingFrame;
	  pThreadState = NULL;
   }
};

class CChevronOwnerDrawMenu : public CMenu
{
public:
	CChevronOwnerDrawMenu();

	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);

private:
	CFont m_MenuFont;
};

/////////////////////////////////////////////////////////////////////////////
// Global implementation helpers

// window creation hooking
void AFXAPI AfxHookWindowCreate(CWnd* pWnd);
BOOL AFXAPI AfxUnhookWindowCreate();
void AFXAPI AfxResetMsgCache();

// for backward compatibility to previous versions
#define _AfxHookWindowCreate    AfxHookWindowCreate
#define _AfxUnhookWindowCreate  AfxUnhookWindowCreate

// string helpers
void AFXAPI AfxSetWindowText(HWND hWndCtrl, LPCTSTR lpszNew);
int AFXAPI AfxLoadString(_In_ UINT nIDS, _Out_z_cap_post_count_(nMaxBuf, return + 1) LPSTR lpszBuf, _In_ UINT nMaxBuf = 256);
int AFXAPI AfxLoadString(_In_ UINT nIDS, _Out_z_cap_post_count_(nMaxBuf, return + 1) LPWSTR lpszBuf, _In_ UINT nMaxBuf = 256);

// registry helpers

/// <summary>
/// Creates the specified registry key.</summary>
/// <returns> 
/// If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h</returns>
/// <param name="hKey">A handle to an open registry key.</param>
/// <param name="lpSubKey">The name of a key that this function opens or creates.</param>
/// <param name="phkResult">A pointer to a variable that receives a handle to the opened or created key.</param>
/// <param name="pTM">Pointer to CAtlTransactionManager object</param>
LONG AFXAPI AfxRegCreateKey(HKEY hKey, LPCTSTR lpSubKey, PHKEY phkResult, CAtlTransactionManager* pTM = NULL);

/// <summary>
/// Opens the specified registry key.</summary>
/// <returns> 
/// If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h</returns>
/// <param name="hKey">A handle to an open registry key.</param>
/// <param name="lpSubKey">The name of a key that this function opens or creates.</param>
/// <param name="phkResult">A pointer to a variable that receives a handle to the created key.</param>
/// <param name="pTM">Pointer to CAtlTransactionManager object</param>
LONG AFXAPI AfxRegOpenKey(HKEY hKey, LPCTSTR lpSubKey, PHKEY phkResult, CAtlTransactionManager* pTM = NULL);

/// <summary>
/// Opens the specified registry key.</summary>
/// <returns> 
/// If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h</returns>
/// <param name="hKey">A handle to an open registry key.</param>
/// <param name="lpSubKey">The name of a key that this function opens or creates.</param>
/// <param name="ulOptions">This parameter is reserved and must be zero.</param>
/// <param name="samDesired">A mask that specifies the desired access rights to the key.</param>
/// <param name="phkResult">A pointer to a variable that receives a handle to the openedkey.</param>
/// <param name="pTM">Pointer to CAtlTransactionManager object</param>
LONG AFXAPI AfxRegOpenKeyEx(HKEY hKey, LPCTSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult, CAtlTransactionManager* pTM = NULL);

LONG AFXAPI AfxRegQueryValue(HKEY hKey, LPCTSTR lpSubKey, LPTSTR lpValue, PLONG lpcbValue);
LONG AFXAPI AfxRegSetValue(HKEY hKey, LPCTSTR lpSubKey, DWORD dwType,  LPCTSTR lpData, DWORD cbData);

/// <summary>
/// Deletes the specified registry key.</summary>
/// <returns> 
/// If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h</returns>
/// <param name="hKey">A handle to an open registry key.</param>
/// <param name="lpSubKey">The name of the key to be deleted.</param>
/// <param name="pTM">Pointer to CAtlTransactionManager object</param>
LONG AFXAPI AfxRegDeleteKey(HKEY hKey, LPCTSTR lpSubKey, CAtlTransactionManager* pTM = NULL);

HDC AFXAPI AfxCreateDC(HGLOBAL hDevNames, HGLOBAL hDevMode);

void AFXAPI AfxGetModuleFileName(HINSTANCE hInst, CString& strFileName);
void AFXAPI AfxGetModuleShortFileName(HINSTANCE hInst, CString& strShortName);

// Failure dialog helpers
void AFXAPI AfxFailMaxChars(CDataExchange* pDX, int nChars);
void AFXAPI AfxFailRadio(CDataExchange* pDX);

// 2008 Feature Pack Support
BOOL AFXAPI AfxIsExtendedFrameClass(CWnd* pWnd);
BOOL AFXAPI AfxIsMFCToolBar(CWnd* pWnd);

#ifndef __AFXCONV_H__
#include <afxconv.h>
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif // __AFXPRIV_H__

/////////////////////////////////////////////////////////////////////////////

#ifndef __AFXPRIV2_H__
#include <afxpriv2.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxpreviewviewex.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxcontrolbarutil.h"
#include <afxpriv.h> //for CPreviewView
#include "afxtoolbar.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCStatusBar;
class CMFCRibbonBar;
class CMFCRibbonButton;

void AFXPrintPreview(CView* pView);

/////////////////////////////////////////////////////////////////////////////
// CMFCPrintPreviewToolBar toolbar

class CMFCPrintPreviewToolBar : public CMFCToolBar
{
	friend class CPreviewViewEx;

	DECLARE_DYNAMIC(CMFCPrintPreviewToolBar)

protected:
	//{{AFX_MSG(CMFCPrintPreviewToolBar)
	afx_msg void OnContextMenu(CWnd *pWnd, CPoint pos);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	virtual INT_PTR OnToolHitTest(CPoint point, TOOLINFO* pTI) const;
	virtual BOOL AllowShowOnPaneMenu() const { return FALSE; }
};

/////////////////////////////////////////////////////////////////////////////
// CPreviewViewEx window

class CPreviewViewEx : public CPreviewView
{
protected:
	CPreviewViewEx();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CPreviewViewEx)

// Attributes
public:
	static void __stdcall EnableScaleLargeImages(BOOL bScaleLargeImages = TRUE) { m_bScaleLargeImages = bScaleLargeImages; }

// Operations
protected:
	void SetToolbarSize();

// Overrides
	void OnDisplayPageNumber(UINT nPage, UINT nPagesDisplayed);

// Implementation
protected:
	virtual ~CPreviewViewEx();

	CMFCPrintPreviewToolBar m_wndToolBar;
	CMFCStatusBar*    m_pWndStatusBar;
	CMFCRibbonBar*          m_pWndRibbonBar;
	CMFCRibbonButton*       m_pNumPageButton;

	int m_iOnePageImageIndex;
	int m_iTwoPageImageIndex;
	int m_iPagesBtnIndex;
	int m_nSimpleType;

	BOOL  m_bIsStatusBarSimple;
	CSize m_recentToolbarSize;

	AFX_IMPORT_DATA static BOOL m_bScaleLargeImages;

protected:
	//{{AFX_MSG(CPreviewViewEx)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnUpdatePreviewNumPage(CCmdUI* pCmdUI);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxpropertypage.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxdialogimpl.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCPropertySheetCategoryInfo;

/////////////////////////////////////////////////////////////////////////////
// CMFCPropertyPage window

class CMFCPropertyPage : public CPropertyPage
{
	friend class CMFCPopupMenu;
	friend class CContextMenuManager;
	friend class CMFCDropDownListBox;
	friend class CMFCPropertySheet;

	DECLARE_DYNCREATE(CMFCPropertyPage)

// Construction
public:
	CMFCPropertyPage();
	CMFCPropertyPage(UINT nIDTemplate, UINT nIDCaption = 0);
	CMFCPropertyPage(LPCTSTR lpszTemplateName, UINT nIDCaption = 0);
	~CMFCPropertyPage();

// Overrides
public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual BOOL OnSetActive();

protected:
	virtual BOOL OnInitDialog();
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);

// Implementation
protected:
	//{{AFX_MSG(CMFCPropertyPage)
	afx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);
	afx_msg BOOL OnNcActivate(BOOL bActive);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void SetActiveMenu(CMFCPopupMenu* pMenu);
	void CommonInit();

	CDialogImpl      m_Impl;
	CMFCPropertySheetCategoryInfo* m_pCategory;

	int       m_nIcon;
	int       m_nSelIconNum;
	HTREEITEM m_hTreeNode;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxpropertygridtooltipctrl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCPropertyGridToolTipCtrl window

class CMFCPropertyGridToolTipCtrl : public CWnd
{
	DECLARE_DYNAMIC(CMFCPropertyGridToolTipCtrl)

// Construction
public:
	CMFCPropertyGridToolTipCtrl();

// Attributes
public:
	void SetTextMargin(int nTextMargin) { m_nTextMargin = nTextMargin; }
	void GetLastRect(CRect& rect) const { rect = m_rectLast; }

protected:
	AFX_IMPORT_DATA static CString m_strClassName;

	CString m_strText;
	CRect   m_rectLast;
	int     m_nTextMargin;
	HFONT   m_hFont;
	CWnd*   m_pWndParent;

// Operations
public:
	void Track(CRect rect, const CString& strText);
	void Hide();
	void Deactivate();

// Overrides
public:
	virtual BOOL Create(CWnd* pWndParent = NULL);
	virtual BOOL PreTranslateMessage(MSG* pMsg);

// Implementation
public:
	virtual ~CMFCPropertyGridToolTipCtrl();

protected:
	//{{AFX_MSG(CMFCPropertyGridToolTipCtrl)
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnPaint();
	afx_msg LRESULT OnSetFont(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxpropertygridctrl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "comdef.h"
#include "afxcontrolbarutil.h"

#include "afxglobals.h"

#include "afxcolorpopupmenu.h"
#include "afxheaderctrl.h"
#include "afxpropertygridtooltipctrl.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCPropertyGridProperty object

class CMFCPropertyGridProperty : public CObject
{
	DECLARE_DYNAMIC(CMFCPropertyGridProperty)

	friend class CMFCPropertyGridCtrl;

// Construction
public:
	// Group constructor
	CMFCPropertyGridProperty(const CString& strGroupName, DWORD_PTR dwData = 0, BOOL bIsValueList = FALSE);

	// Simple property
	CMFCPropertyGridProperty(const CString& strName, const COleVariant& varValue, LPCTSTR lpszDescr = NULL, DWORD_PTR dwData = 0,
		LPCTSTR lpszEditMask = NULL, LPCTSTR lpszEditTemplate = NULL, LPCTSTR lpszValidChars = NULL);

	virtual ~CMFCPropertyGridProperty();

	enum ClickArea
	{
		ClickExpandBox,
		ClickName,
		ClickValue,
		ClickDescription
	};

// Operations:
public:
	int GetExpandedSubItems(BOOL bIncludeHidden = TRUE) const;
	BOOL AddSubItem(CMFCPropertyGridProperty* pProp);
	BOOL RemoveSubItem(CMFCPropertyGridProperty*& pProp, BOOL bDelete = TRUE);

	BOOL AddOption(LPCTSTR lpszOption, BOOL bInsertUnique = TRUE);
	void RemoveAllOptions();

	int GetOptionCount() const;
	LPCTSTR GetOption(int nIndex) const;

	CMFCPropertyGridProperty* HitTest(CPoint point, CMFCPropertyGridProperty::ClickArea* pnArea = NULL);

	void Expand(BOOL bExpand = TRUE);
	void Redraw();

	void EnableSpinControl(BOOL bEnable = TRUE, int nMin = 0, int nMax = 0);

	virtual void ResetOriginalValue();

	void Show(BOOL bShow = TRUE, BOOL bAdjustLayout = TRUE);

protected:
	void Init();
	void SetFlags();
	void SetOwnerList(CMFCPropertyGridCtrl* pWndList);
	void Reposition(int& y);
	void AddTerminalProp(CList<CMFCPropertyGridProperty*, CMFCPropertyGridProperty*>& lstProps);

	BOOL IsSubItem(CMFCPropertyGridProperty* pProp) const;
	CMFCPropertyGridProperty* FindSubItemByData(DWORD_PTR dwData) const;

	void ExpandDeep(BOOL bExpand = TRUE);
	void SetModifiedFlag();

// Overrides
public:
	virtual void OnDrawName(CDC* pDC, CRect rect);
	virtual void OnDrawValue(CDC* pDC, CRect rect);
	virtual void OnDrawExpandBox(CDC* pDC, CRect rectExpand);
	virtual void OnDrawButton(CDC* pDC, CRect rectButton);
	virtual void OnDrawDescription(CDC* pDC, CRect rect);

	virtual CString FormatProperty();

	virtual BOOL OnUpdateValue();
	virtual BOOL OnEdit(LPPOINT lptClick);
	virtual CWnd* CreateInPlaceEdit(CRect rectEdit, BOOL& bDefaultFormat);
	virtual CSpinButtonCtrl* CreateSpinControl(CRect rectSpin);

	virtual BOOL OnEndEdit();

	virtual void OnClickButton(CPoint point);
	virtual BOOL OnClickValue(UINT uiMsg, CPoint point);
	virtual BOOL OnDblClk(CPoint point);

	virtual void OnSelectCombo();
	virtual void OnCloseCombo();

	virtual BOOL OnSetCursor() const;
	virtual BOOL PushChar(UINT nChar);

	virtual CString GetNameTooltip();
	virtual CString GetValueTooltip();

	virtual void OnClickName(CPoint /*point*/) {}
	virtual void OnRClickName(CPoint /*point*/) {}
	virtual void OnRClickValue(CPoint /*point*/, BOOL /*bSelChanged*/) {}

	virtual void OnPosSizeChanged(CRect /*rectOld*/) {}

	virtual void OnSetSelection(CMFCPropertyGridProperty* /*pOldSel*/) {}
	virtual void OnKillSelection(CMFCPropertyGridProperty* /*pNewSel*/) {}

	virtual void AdjustButtonRect();
	virtual void AdjustInPlaceEditRect(CRect& rectEdit, CRect& rectSpin);

protected:
	virtual HBRUSH OnCtlColor(CDC* pDC, UINT nCtlColor);
	virtual CComboBox* CreateCombo(CWnd* pWndParent, CRect rect);
	virtual void OnDestroyWindow();

	virtual BOOL OnKillFocus(CWnd* /*pNewWnd*/) { return TRUE; }
	virtual BOOL OnEditKillFocus() { return TRUE; }

	virtual BOOL HasButton() const;

	virtual BOOL IsProcessFirstClick() const { return TRUE; }
	virtual BOOL HasValueField() const { return TRUE; }

	virtual BOOL TextToVar(const CString& strText);
	virtual BOOL IsValueChanged() const;

	virtual BOOL OnActivateByTab();
	virtual BOOL OnRotateListValue(BOOL bForward);

// Attributes
public:
	LPCTSTR GetName() const { return m_strName; }
	void SetName(LPCTSTR lpszName, BOOL bRedraw = TRUE);

	virtual const COleVariant& GetValue() const { return m_varValue; }
	virtual void SetValue(const COleVariant& varValue);

	const COleVariant& GetOriginalValue() const { return m_varValueOrig; }
	void SetOriginalValue(const COleVariant& varValue);

	const CString& GetDescription() const { return m_strDescr; }
	void SetDescription(const CString& strDescr) { m_strDescr = strDescr; }

	DWORD_PTR GetData() const { return m_dwData; }
	void SetData(DWORD_PTR dwData) { m_dwData = dwData; }

	BOOL IsGroup() const { return m_bGroup; }
	BOOL IsExpanded() const { return m_bExpanded; }

	BOOL IsParentExpanded() const;

	virtual BOOL IsSelected() const;
	int GetHierarchyLevel() const;

	void Enable(BOOL bEnable = TRUE);
	BOOL IsEnabled() const { return m_bEnabled; }

	void AllowEdit(BOOL bAllow = TRUE)
	{
		ASSERT(m_varValue.vt != VT_BOOL);
		m_bAllowEdit = bAllow;
	}
	BOOL IsAllowEdit() const { return m_bAllowEdit; }

	CRect GetRect() const { return m_Rect; }

	int GetSubItemsCount() const { return (int) m_lstSubItems.GetCount(); }

	CMFCPropertyGridProperty* GetSubItem(int nIndex) const;

	CMFCPropertyGridProperty* GetParent() const { return m_pParent; }
	BOOL IsInPlaceEditing() const { return m_bInPlaceEdit; }
	BOOL IsModified() const { return m_bIsModified; }
	BOOL IsVisible() const { return m_bIsVisible; }

public:
	// Data formats
	AFX_IMPORT_DATA static CString m_strFormatChar;
	AFX_IMPORT_DATA static CString m_strFormatShort;
	AFX_IMPORT_DATA static CString m_strFormatLong;
	AFX_IMPORT_DATA static CString m_strFormatUShort;
	AFX_IMPORT_DATA static CString m_strFormatULong;
	AFX_IMPORT_DATA static CString m_strFormatFloat;
	AFX_IMPORT_DATA static CString m_strFormatDouble;

protected:
	COleVariant m_varValue;     // Property value
	COleVariant m_varValueOrig; // Property original value

	DWORD_PTR m_dwData;   // User-defined data
	DWORD     m_dwFlags;  // Property flags

	CRect m_Rect;       // Property rectangle (in the prop.list coordinates)
	CRect m_rectButton; // Drop down/open button rectangle

	BOOL m_bButtonIsDown;    // Is button pressed?
	BOOL m_bButtonIsFocused; // Is button focused?
	BOOL m_bInPlaceEdit;     // Is in InPalce editing mode
	BOOL m_bGroup;           // Is property group?
	BOOL m_bExpanded;        // Is property expanded (for groups only)
	BOOL m_bEnabled;         // Is propperty enabled?
	BOOL m_bAllowEdit;       // Is property editable?
	BOOL m_bIsValueList;     // This is a value list group?
	BOOL m_bNameIsTruncated;
	BOOL m_bValueIsTruncated;
	BOOL m_bIsModified;      // Is property modified
	BOOL m_bIsVisible;       // Is property visible

	int m_nMinValue;
	int m_nMaxValue;

	CString m_strName;        // Property name
	CString m_strDescr;       // Property description
	CString m_strEditMask;    // Property edit mask (see CMFCMaskedEdit for description)
	CString m_strEditTempl;   // Property edit template (see CMFCMaskedEdit for description)
	CString m_strValidChars;  // Property edit valid chars (see CMFCMaskedEdit for description)
	CStringList m_lstOptions; // List of combobox items

	CWnd*              m_pWndInPlace; // Pointer to InPlace editing window
	CComboBox*         m_pWndCombo;   // Pointer to combbox
	CSpinButtonCtrl*   m_pWndSpin;    // Pointer to spin button
	CMFCPropertyGridCtrl*     m_pWndList;    // Pointer to the PropertyList window
	CMFCPropertyGridProperty* m_pParent;     // Parent property (NULL for top-level properties)

	CList<CMFCPropertyGridProperty*, CMFCPropertyGridProperty*> m_lstSubItems; // Sub-properies list
};

/////////////////////////////////////////////////////////////////////////////
// CMFCPropertyGridColorProperty object

class CMFCPropertyGridColorProperty : public CMFCPropertyGridProperty
{
	friend class CMFCPropertyGridCtrl;

	DECLARE_DYNAMIC(CMFCPropertyGridColorProperty)

// Construction
public:
	CMFCPropertyGridColorProperty(const CString& strName, const COLORREF& color, CPalette* pPalette = NULL, LPCTSTR lpszDescr = NULL, DWORD_PTR dwData = 0);
	virtual ~CMFCPropertyGridColorProperty();

// Overrides
public:
	virtual void OnDrawValue(CDC* pDC, CRect rect);
	virtual void OnClickButton(CPoint point);
	virtual BOOL OnEdit(LPPOINT lptClick);
	virtual BOOL OnUpdateValue();
	virtual CString FormatProperty();

protected:
	virtual BOOL OnKillFocus(CWnd* pNewWnd) { return pNewWnd->GetSafeHwnd() != m_pPopup->GetSafeHwnd(); }
	virtual BOOL OnEditKillFocus() { return m_pPopup == NULL; }
	virtual BOOL IsValueChanged() const { return m_Color != m_ColorOrig; }

	virtual void AdjustInPlaceEditRect(CRect& rectEdit, CRect& rectSpin);
	virtual void ResetOriginalValue();

// Attributes
public:
	COLORREF GetColor() const { return m_Color; }
	void SetColor(COLORREF color);

	// Color popup attributes:
	void EnableAutomaticButton(LPCTSTR lpszLabel, COLORREF colorAutomatic, BOOL bEnable = TRUE);
	void EnableOtherButton(LPCTSTR lpszLabel, BOOL bAltColorDlg = TRUE, BOOL bEnable = TRUE);
	void SetColumnsNumber(int nColumnsNumber);

// Attributes
protected:
	COLORREF     m_Color;          // Color value
	COLORREF     m_ColorOrig;      // Original color value
	COLORREF     m_ColorAutomatic; // Automatic (default) color value
	CString      m_strAutoColor;   // Atomatic color label
	CString      m_strOtherColor;  // Alternative color label
	CMFCColorPopupMenu* m_pPopup;

	CArray<COLORREF, COLORREF> m_Colors;

	int  m_nColumnsNumber; // Number of columns in dropped-down colors list
	BOOL m_bStdColorDlg;   // Use standard Windows color dialog
};

/////////////////////////////////////////////////////////////////////////////
// CMFCPropertyGridFileProperty object

class CMFCPropertyGridFileProperty : public CMFCPropertyGridProperty
{
	DECLARE_DYNAMIC(CMFCPropertyGridFileProperty)

// Construction
public:

	CMFCPropertyGridFileProperty(const CString& strName, const CString& strFolderName, DWORD_PTR dwData = 0, LPCTSTR lpszDescr = NULL);
	CMFCPropertyGridFileProperty(const CString& strName, BOOL bOpenFileDialog, const CString& strFileName, LPCTSTR lpszDefExt = NULL,
		DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT, LPCTSTR lpszFilter = NULL, LPCTSTR lpszDescr = NULL, DWORD_PTR dwData = 0);
	virtual ~CMFCPropertyGridFileProperty();

// Overrides
public:
	virtual void OnClickButton(CPoint point);

// Attributes
protected:
	BOOL    m_bIsFolder;

	// File open dialog atributes:
	BOOL    m_bOpenFileDialog; // TRUE - use "File Open/Save" diaog; otherwise - folder selection dialog
	DWORD   m_dwFileOpenFlags;
	CString m_strDefExt;
	CString m_strFilter;
};

/////////////////////////////////////////////////////////////////////////////
// CMFCPropertyGridFontProperty object

class CMFCPropertyGridFontProperty : public CMFCPropertyGridProperty
{
	DECLARE_DYNAMIC(CMFCPropertyGridFontProperty)

// Construction
public:
	CMFCPropertyGridFontProperty(	const CString& strName, LOGFONT& lf, DWORD dwFontDialogFlags = CF_EFFECTS | CF_SCREENFONTS, 
		LPCTSTR lpszDescr = NULL, DWORD_PTR dwData = 0, COLORREF color = (COLORREF)-1);
	virtual ~CMFCPropertyGridFontProperty();

// Overrides
public:
	virtual void OnClickButton(CPoint point);
	virtual CString FormatProperty();

// Attributes
public:
	LPLOGFONT GetLogFont() { return &m_lf; }
	COLORREF GetColor() const { return m_Color; }

protected:
	LOGFONT   m_lf;
	LOGFONT   m_lfOrig;
	DWORD_PTR m_dwFontDialogFlags;
	COLORREF  m_Color;

	virtual BOOL IsValueChanged() const
	{
		return((memcmp(&m_lf, &m_lfOrig, sizeof(LOGFONT)) != 0) || (lstrcmp(m_lf.lfFaceName, m_lfOrig.lfFaceName) != 0));
	}

	virtual void ResetOriginalValue();
};

/////////////////////////////////////////////////////////////////////////////
// CMFCPropertyGridCtrl window

#define AFX_PROPLIST_ID_INPLACE 3

extern AFX_IMPORT_DATA UINT AFX_WM_PROPERTY_CHANGED;

class CMFCPropertyGridCtrl : public CWnd
{
	DECLARE_DYNAMIC(CMFCPropertyGridCtrl)

	friend class CMFCPropertyGridProperty;
	friend class CMFCPropertyGridColorProperty;

// Construction
public:
	CMFCPropertyGridCtrl();

// Attributes
public:
	void EnableHeaderCtrl(BOOL bEnable = TRUE, LPCTSTR lpszLeftColumn = _T("Property"), LPCTSTR lpszRightColumn = _T("Value"));
	BOOL IsHeaderCtrl() const { return m_bHeaderCtrl; }

	void EnableDescriptionArea(BOOL bEnable = TRUE);
	BOOL IsDescriptionArea() const { return m_bDescriptionArea; }

	int GetDescriptionHeight() const { return m_nDescrHeight; }
	int GetDescriptionRows() const { return m_nDescrRows; }
	void SetDescriptionRows(int nDescRows);

	void SetAlphabeticMode(BOOL bSet = TRUE);
	BOOL IsAlphabeticMode() const { return m_bAlphabeticMode; }

	void SetVSDotNetLook(BOOL bSet = TRUE);
	BOOL IsVSDotNetLook() const { return m_bVSDotNetLook; }

	void MarkModifiedProperties(BOOL bMark = TRUE, BOOL bRedraw = TRUE);
	BOOL IsMarkModifiedProperties() const { return m_bMarkModifiedProperties; }

	void ResetOriginalValues(BOOL bRedraw = TRUE);

	void SetBoolLabels(LPCTSTR lpszTrue, LPCTSTR lpszFalse);
	void SetListDelimiter(TCHAR c);

	CRect GetListRect() const { return m_rectList; }

	int GetPropertyColumnWidth() const { return m_nLeftColumnWidth; }
	int GetHeaderHeight() const { return m_nHeaderHeight; }
	int GetRowHeight() const { return m_nRowHeight; }

	virtual CMFCHeaderCtrl& GetHeaderCtrl() { return m_wndHeader; }

	int GetLeftColumnWidth() const { return m_nLeftColumnWidth; }
	BOOL IsGroupNameFullWidth() const { return m_bGroupNameFullWidth; }

	void SetGroupNameFullWidth(BOOL bGroupNameFullWidth = TRUE, BOOL bRedraw = TRUE);

	BOOL IsShowDragContext() const { return m_bShowDragContext; }
	void SetShowDragContext(BOOL bShowDragContext = TRUE) { m_bShowDragContext = bShowDragContext; }

	// Use (COLORREF)-1 for the default color
	void SetCustomColors(COLORREF clrBackground, COLORREF clrText, COLORREF clrGroupBackground, COLORREF clrGroupText,
		COLORREF clrDescriptionBackground, COLORREF clrDescriptionText, COLORREF clrLine);
	void GetCustomColors(COLORREF& clrBackground, COLORREF& clrText, COLORREF& clrGroupBackground, COLORREF& clrGroupText,
		COLORREF& clrDescriptionBackground, COLORREF& clrDescriptionText, COLORREF& clrLine);

	COLORREF GetTextColor() const { return m_clrText == (COLORREF)-1 ? afxGlobalData.clrWindowText : m_clrText; }
	COLORREF GetBkColor() const { return m_clrBackground == (COLORREF)-1 ? afxGlobalData.clrWindow : m_clrBackground; }

	CFont& GetBoldFont() { return m_fontBold; }

	BOOL IsAlwaysShowUserToolTip() const { return m_bAlwaysShowUserTT; }
	void AlwaysShowUserToolTip(BOOL bShow = TRUE) { m_bAlwaysShowUserTT = bShow; }

	BOOL DrawControlBarColors() const { return m_bControlBarColors; }

protected:
	CToolTipCtrl        m_ToolTip;       // Tooltip control
	CMFCHeaderCtrl   m_wndHeader;     // Property list header control
	CMFCPropertyGridToolTipCtrl m_IPToolTip;     // Inplace tooltip control
	CScrollBar          m_wndScrollVert; // Vertical scroll bar

	BOOL m_bHeaderCtrl;             // Is header control visible?
	BOOL m_bDescriptionArea;        // Does description area enabled?
	BOOL m_bAlwaysShowUserTT;       // Always show user tooltips, even if in-place TT should be activated
	BOOL m_bAlphabeticMode;         // Use property list in alphabetic (non-"tree") mode
	BOOL m_bVSDotNetLook;           // Provide MS Visual Studio.NET look (gray groups, flat look)
	BOOL m_bMarkModifiedProperties; // Draw modified properties with bold

	CString m_strTrue;  // Customized boolean value (e.g. "Yes")
	CString m_strFalse; // Customized boolean value (e.g. "No")

	TCHAR m_cListDelimeter; // Customized list delimeter character

	HFONT m_hFont;    // Property list regular font
	CFont m_fontBold; // Property list bold font
	CRect m_rectList; // Properies area

	int m_nDescrHeight;        // Description area height
	int m_nDescrRows;          // Number of rows in description area
	int m_nTooltipsCount;      // Number of tooltip items
	int m_nEditLeftMargin;     // Edit control left margin
	int m_nBoldEditLeftMargin; // Edit control left margin (bold font)
	int m_nBorderSize;         // Control border size
	int m_nHeaderHeight;       // Header control height
	int m_nRowHeight;          // Height of the single row
	int m_nLeftColumnWidth;    // Width of the left ("Name") column
	int m_nVertScrollOffset;   // In rows
	int m_nVertScrollTotal;
	int m_nVertScrollPage;

	//-----------------------------------------------------------
	// Tracking attributes: used for the vertical and description 
	// area splitters tracking:
	//-----------------------------------------------------------
	CRect m_rectTrackHeader;
	CRect m_rectTrackDescr;

	BOOL m_bTracking;
	BOOL m_bTrackingDescr;
	BOOL m_bFocused;            // Control has focus
	BOOL m_bControlBarColors;   // Use colors of tye parent control bar
	BOOL m_bGroupNameFullWidth; // Display group name in the whole row
	BOOL m_bShowDragContext;    // Show context while dragging spliters

	CList<CMFCPropertyGridProperty*, CMFCPropertyGridProperty*> m_lstProps;         // List of top-level properties
	CList<CMFCPropertyGridProperty*, CMFCPropertyGridProperty*> m_lstTerminalProps; // List of terminal properties
	CMFCPropertyGridProperty*                            m_pSel;             // Current selection

	COLORREF m_clrGray; // Special gray color

	//---------------
	// Custom colors:
	//---------------
	COLORREF m_clrBackground;            // Control background color
	COLORREF m_clrText;                  // Control foreground color
	COLORREF m_clrGroupBackground;       // Group background text
	COLORREF m_clrGroupText;             // Group foreground text
	COLORREF m_clrDescriptionBackground; // Description background text
	COLORREF m_clrDescriptionText;       // Description foreground text
	COLORREF m_clrLine;                  // Color of the grid lines

	CBrush m_brBackground;

// Operations
public:
	int AddProperty(CMFCPropertyGridProperty* pProp, BOOL bRedraw = TRUE, BOOL bAdjustLayout = TRUE);
	BOOL DeleteProperty(CMFCPropertyGridProperty*& pProp, BOOL bRedraw = TRUE, BOOL bAdjustLayout = TRUE);
	void RemoveAll();

	CMFCPropertyGridProperty* GetProperty(int nIndex) const;
	int GetPropertyCount() const { return (int) m_lstProps.GetCount(); }

	CMFCPropertyGridProperty* FindItemByData(DWORD_PTR dwData, BOOL bSearchSubItems = TRUE) const;

	CMFCPropertyGridProperty* HitTest(CPoint pt, CMFCPropertyGridProperty::ClickArea* pnArea = NULL, BOOL bPropsOnly = FALSE) const;

	void SetCurSel(CMFCPropertyGridProperty* pProp, BOOL bRedraw = TRUE);
	CMFCPropertyGridProperty* GetCurSel() const { return m_pSel; }

	void EnsureVisible(CMFCPropertyGridProperty* pProp, BOOL bExpandParents = FALSE);
	void ExpandAll(BOOL bExpand = TRUE);

	virtual void CloseColorPopup();
	virtual void UpdateColor(COLORREF color);
	virtual void AdjustLayout();

// Overrides
	virtual void OnPropertyChanged(CMFCPropertyGridProperty* pProp) const;

public:
	virtual BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual CScrollBar* GetScrollBarCtrl(int nBar) const;

protected:
	virtual void PreSubclassWindow();
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);

public:
	virtual void OnChangeSelection(CMFCPropertyGridProperty* /*pNewSel*/, CMFCPropertyGridProperty* /*pOldSel*/) {}

	virtual BOOL EditItem(CMFCPropertyGridProperty* pProp, LPPOINT lptClick = NULL);
	virtual void OnClickButton(CPoint point);
	virtual BOOL EndEditItem(BOOL bUpdateData = TRUE);
	virtual BOOL ValidateItemData(CMFCPropertyGridProperty* /*pProp*/) { return TRUE; }

	virtual int OnDrawProperty(CDC* pDC, CMFCPropertyGridProperty* pProp) const;
	virtual void InitHeader();

protected:
	virtual void Init();

	virtual void OnFillBackground(CDC* pDC, CRect rectClient);

	virtual void OnDraw(CDC* pDC);
	virtual void OnDrawBorder(CDC* pDC);
	virtual void OnDrawList(CDC* pDC);
	virtual void OnDrawDescription(CDC* pDC, CRect rect);

	virtual BOOL ProcessClipboardAccelerators(UINT nChar);
	virtual int CompareProps(const CMFCPropertyGridProperty* pProp1, const CMFCPropertyGridProperty* pProp2) const;
	virtual void NotifyAccessibility(CMFCPropertyGridProperty* pProp);

// Implementation
public:
	virtual ~CMFCPropertyGridCtrl();

	//----------------------
	// Accessibility support:
	//----------------------
	CMFCPropertyGridProperty* m_pAccProp;

// IAccessible
public:
	virtual HRESULT get_accChildCount(long *pcountChildren);
	virtual HRESULT get_accChild(VARIANT varChild, IDispatch **ppdispChild);
	virtual HRESULT get_accName(VARIANT varChild, BSTR *pszName);
	virtual HRESULT get_accValue(VARIANT varChild, BSTR *pszValue);
	virtual HRESULT get_accDescription(VARIANT varChild, BSTR *pszDescription);
	virtual HRESULT get_accRole(VARIANT varChild, VARIANT *pvarRole);
	virtual HRESULT get_accState(VARIANT varChild, VARIANT *pvarState);
	virtual HRESULT get_accHelp(VARIANT varChild, BSTR *pszHelp);
	virtual HRESULT get_accHelpTopic(BSTR *pszHelpFile, VARIANT varChild, long *pidTopic);
	virtual HRESULT get_accKeyboardShortcut(VARIANT varChild, BSTR *pszKeyboardShortcut);
	virtual HRESULT get_accFocus(VARIANT *pvarChild);
	virtual HRESULT get_accSelection(VARIANT *pvarChildren);
	virtual HRESULT get_accDefaultAction(VARIANT varChild, BSTR *pszDefaultAction);

	virtual HRESULT accSelect(long flagsSelect, VARIANT varChild);
	virtual HRESULT accLocation(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild);
	virtual HRESULT accHitTest(long xLeft, long yTop, VARIANT *pvarChild);

protected:
	//{{AFX_MSG(CMFCPropertyGridCtrl)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
	afx_msg void OnPaint();
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnCancelMode();
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg UINT OnGetDlgCode();
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg BOOL OnMouseWheel(UINT nFlags, short zDelta, CPoint pt);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg void OnDestroy();
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp);
	afx_msg void OnNcPaint();
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg LRESULT OnSetFont(WPARAM, LPARAM);
	afx_msg LRESULT OnGetFont(WPARAM, LPARAM);
	afx_msg void OnHeaderItemChanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnHeaderTrack(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnHeaderEndTrack(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinDeltaPos(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg LRESULT OnUpdateSpin(WPARAM, LPARAM);
	afx_msg void OnStyleChanged(int nStyleType, LPSTYLESTRUCT lpStyleStruct);
	afx_msg void OnSelectCombo();
	afx_msg void OnCloseCombo();
	afx_msg void OnEditKillFocus();
	afx_msg void OnComboKillFocus();
	afx_msg BOOL OnNeedTipText(UINT id, NMHDR* pNMH, LRESULT* pResult);
	afx_msg LRESULT OnGetObject(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnInitControl(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnPrintClient(WPARAM wp, LPARAM lp);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	//------------------
	// Internal helpres:
	//------------------
	HFONT SetCurrFont(CDC* pDC);
	void TrackHeader(int nOffset);
	void TrackDescr(int nOffset);
	void TrackToolTip(CPoint pt);

	void SetScrollSizes();

	int GetTotalItems(BOOL bIncludeHidden = TRUE) const;
	void ReposProperties();

	void CreateBoldFont();
	void CalcEditMargin();
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxrecentdocksiteinfo.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CPaneContainer;
class CDockSite;
class CDockingPanesRow;
class CPaneDivider;
class CPaneFrameWnd;
class CPane;
class CDockablePane;

class CRecentPaneContainerInfo : public CObject
{
public:
	CRecentPaneContainerInfo();
	virtual ~CRecentPaneContainerInfo();

	CRecentPaneContainerInfo& operator= (CRecentPaneContainerInfo& src);

	void Init();

	virtual void StoreDockInfo(CPaneContainer* pRecentContainer, CDockablePane* pBar, CDockablePane* pTabbedBar = NULL);
	virtual void SetInfo(CRecentPaneContainerInfo& srcInfo);

public:
	
	CRect m_rectDockedRect;   // in client coordinates
	int   m_nRecentPercent;   // what percent CB took in container
	BOOL  m_bIsRecentLeftBar; // is CB was left in its container

	CList<HWND,HWND> m_lstRecentListOfBars; // need to remember a list of siblings bar in container manager to place the CB back when docked again
	CPaneContainer*   m_pRecentBarContainer; // recent container of CB
	CPaneContainer*   m_pRecentContainerOfTabWnd;
};


class CRecentDockSiteInfo : public CObject
{
public:
	CRecentDockSiteInfo(CPane* pBar);
	virtual ~CRecentDockSiteInfo();

	CRecentDockSiteInfo& operator= (CRecentDockSiteInfo& src);

	void Init();
	void CleanUp();

	virtual void StoreDockInfo(CPaneContainer* pRecentContainer, CDockablePane* pTabbedBar = NULL);
	virtual void SetInfo(BOOL bForSlider, CRecentDockSiteInfo& srcInfo);

	CPaneContainer* GetRecentPaneContainer(BOOL bForSlider);
	CPaneContainer* GetRecentTabContainer(BOOL bForSlider);
	CRect& GetRecentDockedRect(BOOL bForSlider);
	int GetRecentDockedPercent(BOOL bForSlider);
	BOOL IsRecentLeftPane(BOOL bForSlider);
	void SaveListOfRecentPanes(CList<HWND,HWND>& lstOrg, BOOL bForSlider);
	CList<HWND, HWND>& GetRecentListOfPanes(BOOL bForSlider);
	CPaneDivider* GetRecentDefaultPaneDivider();

public:
	CRect m_rectRecentFloatingRect; // in screen coordinates
	DWORD m_dwRecentAlignmentToFrame; // to what frame side control bar was docked

	int   m_nRecentTabNumber; // recent position on tab window
	int   m_nRecentRowIndex;  // if CB was resided on a dock bar what row it occupied (zero-based)
	                          // it will be used instead of m_pRecentDockBarRow if this pointer is invalid (the row was deleted)

	CDockSite*    m_pRecentDockBar;    // what dock bar CB was docked on
	CDockingPanesRow* m_pRecentDockBarRow; // a pointer to dock bar row

	HWND m_hRecentDefaultSlider; // recent default slider of CB
	HWND m_hRecentMiniFrame;

	CRecentPaneContainerInfo m_recentSliderInfo;
	CRecentPaneContainerInfo m_recentMiniFrameInfo;

protected:
	CPane* m_pBar;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxrebarstate.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCReBarState
{
private:
	static BOOL CALLBACK LoadRebarStateProc(HWND hwnd, LPARAM lParam);
	static BOOL CALLBACK SaveRebarStateProc(HWND hwnd, LPARAM lParam);

public:
	static void __stdcall LoadState(CString& strKey, CFrameWnd* pFrrame);
	static void __stdcall SaveState(CString& strKey, CFrameWnd* pFrrame);
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxpropertysheet.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxoutlookbar.h"
#include "afxoutlookbarpane.h"
#include "afxtabctrl.h"
#include "afxdialogimpl.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCPropertySheet;
class CMFCPropertyPage;

/////////////////////////////////////////////////////////////////////////////
// CMFCOutlookBarPaneList

class CMFCOutlookBarPaneList : public CMFCOutlookBarPane
{
	friend class CMFCPropertySheet;

	virtual BOOL OnSendCommand(const CMFCToolBarButton* pButton);
	void EnsureVisible(int iButton);

	CMFCPropertySheet* m_pParent;
};

class CMFCPropertySheetTabCtrl : public CMFCTabCtrl
{
	friend class CMFCPropertySheet;

	CMFCPropertySheetTabCtrl();

	virtual BOOL SetActiveTab(int iTab);

	CMFCPropertySheet* m_pParent;
};

class CMFCProperySheetListBox : public CListBox
{
	friend class CMFCPropertySheet;

	CMFCProperySheetListBox();

	afx_msg void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg LRESULT OnMouseLeave(WPARAM,LPARAM);
	DECLARE_MESSAGE_MAP()

	int  m_nHighlightedItem;
	BOOL m_bTracked;
	CMFCPropertySheet* m_pParent;
};

/////////////////////////////////////////////////////////////////////////////
// CMFCPropertySheetCategoryInfo

class CMFCPropertySheetCategoryInfo : public CObject
{
	DECLARE_DYNAMIC(CMFCPropertySheetCategoryInfo)

	CMFCPropertySheetCategoryInfo(LPCTSTR lpszName, int nIcon, int nSelectedItem, const CMFCPropertySheetCategoryInfo* pParentCategory, CMFCPropertySheet& propSheet);
	virtual ~CMFCPropertySheetCategoryInfo();

	const CString m_strName;
	const int     m_nIcon;
	const int     m_nSelectedIcon;
	HTREEITEM     m_hTreeItem;
	HTREEITEM     m_hLastSelectedItem;

	CMFCPropertySheetCategoryInfo*   m_pParentCategory;
	CMFCPropertySheet& m_propSheet;

	CList<CMFCPropertySheetCategoryInfo*,CMFCPropertySheetCategoryInfo*>    m_lstSubCategories;
	CList<CMFCPropertyPage*, CMFCPropertyPage*> m_lstPages;
};

/////////////////////////////////////////////////////////////////////////////
// CMFCPropertySheet

class CMFCPropertySheet : public CPropertySheet
{
	friend class CMFCPropertySheetCategoryInfo;

	DECLARE_DYNAMIC(CMFCPropertySheet)

// Construction
public:
	CMFCPropertySheet();
	CMFCPropertySheet(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
	CMFCPropertySheet(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);

	enum PropSheetLook
	{
		PropSheetLook_Tabs,
		PropSheetLook_OutlookBar,
		PropSheetLook_Tree,
		PropSheetLook_OneNoteTabs,
		PropSheetLook_List,
	};

	// Should be called BEFORE DoModal or Create!
	void SetLook(PropSheetLook look, int nNavControlWidth = 100);
	PropSheetLook GetLook() const { return m_look; }

// Attributes
public:
	CMFCTabCtrl& GetTab() const; // for PropSheetLook_OneNoteTabs only
	int GetHeaderHeight() const { return m_nHeaderHeight; }

protected:
	PropSheetLook  m_look;
	CMFCOutlookBarPaneList m_wndPane1;
	CMFCPropertySheetTabCtrl  m_wndTab;
	CMFCProperySheetListBox m_wndList;
	CMFCOutlookBar    m_wndOutlookBar;
	CTreeCtrl      m_wndTree;
	CImageList     m_Icons;

	int  m_nBarWidth;
	int  m_nActivePage;
	int  m_nHeaderHeight;
	BOOL m_bAlphaBlendIcons;
	BOOL m_bIsInSelectTree;

	CList<CMFCPropertySheetCategoryInfo*,CMFCPropertySheetCategoryInfo*> m_lstTreeCategories;

	CDialogImpl m_Impl;

// Operations
public:
	BOOL SetIconsList(UINT uiImageListResID, int cx, COLORREF clrTransparent = RGB(255, 0, 255));
	void SetIconsList(HIMAGELIST hIcons);

	void AddPage(CPropertyPage* pPage);

	void RemovePage(CPropertyPage* pPage);
	void RemovePage(int nPage);
	void RemoveCategory(CMFCPropertySheetCategoryInfo* pCategory);

	// PropSheetLook_Tree methods:
	CMFCPropertySheetCategoryInfo* AddTreeCategory(LPCTSTR lpszLabel, int nIconNum = -1, int nSelectedIconNum = -1, const CMFCPropertySheetCategoryInfo* pParentCategory = NULL);
	void AddPageToTree(CMFCPropertySheetCategoryInfo* pCategory, CMFCPropertyPage* pPage, int nIconNum = -1, int nSelIconNum = -1);

	void EnablePageHeader(int nHeaderHeight);

// Overrides
	virtual void OnActivatePage(CPropertyPage* pPage);
	virtual CWnd* InitNavigationControl();
	virtual BOOL OnRemoveTreePage(CPropertyPage* pPage);
	
	virtual void OnDrawPageHeader(CDC* pDC, int nPage, CRect rectHeader);

public:
	virtual BOOL OnInitDialog();
	virtual BOOL PreTranslateMessage(MSG* pMsg);

// Implementation
public:
	virtual ~CMFCPropertySheet();

protected:
	//{{AFX_MSG(CMFCPropertySheet)
	afx_msg void OnSysColorChange();
	afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
	afx_msg LRESULT OnAfterActivatePage(WPARAM,LPARAM);
	afx_msg void OnSelectTree(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnGetDispInfo(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSelectList();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void InternalAddPage(int nTab);
	void AddCategoryToTree(CMFCPropertySheetCategoryInfo* pCategory);
	void CommonInit();
	int FindPageIndexInList(CPropertyPage* pPage);
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxrebar.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxpane.h"
#include "afxcontrolbarimpl.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CReBarCtrl;

class CMFCReBar : public CPane
{
	DECLARE_DYNAMIC(CMFCReBar)

// Construction
public:
	CMFCReBar();
	BOOL Create(CWnd* pParentWnd, DWORD dwCtrlStyle = RBS_BANDBORDERS,
		DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | WS_CLIPCHILDREN | CBRS_TOP, UINT nID = AFX_IDW_REBAR);

// Attributes
public:
	// for direct access to the underlying common control
	CReBarCtrl& GetReBarCtrl() const;
	virtual BOOL CanFloat() const { return FALSE; }

	UINT GetReBarBandInfoSize () const
	{
		return m_nReBarBandInfoSize;
	}

// Operations
public:
	BOOL AddBar(CWnd* pBar, LPCTSTR pszText = NULL, CBitmap* pbmp = NULL, DWORD dwStyle = RBBS_GRIPPERALWAYS | RBBS_FIXEDBMP);
	BOOL AddBar(CWnd* pBar, COLORREF clrFore, COLORREF clrBack, LPCTSTR pszText = NULL, DWORD dwStyle = RBBS_GRIPPERALWAYS);

	virtual void SetPaneAlignment(DWORD dwAlignment);

// Implementation
	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);
	virtual INT_PTR OnToolHitTest(CPoint point, TOOLINFO* pTI) const;
	virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);
	virtual BOOL OnShowControlBarMenu(CPoint /*point*/) { return FALSE; }
	virtual BOOL IsAccessibilityCompatible() { return FALSE; }

#ifdef _DEBUG
	void EnableDocking(DWORD dwDockStyle);
#endif

protected:
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	BOOL _AddMFCToolBar(CWnd* pBar, REBARBANDINFO* pRBBI);

	//{{AFX_MSG(CMFCReBar)
	afx_msg BOOL OnNcCreate(LPCREATESTRUCT);
	afx_msg void OnPaint();
	afx_msg void OnHeightChange(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnNcPaint();
	afx_msg void OnNcCalcSize(BOOL, NCCALCSIZE_PARAMS*);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg LRESULT OnShowBand(WPARAM wParam, LPARAM lParam);
	afx_msg void OnRecalcParent();
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	CMFCControlBarImpl m_Impl;
	UINT m_nReBarBandInfoSize;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxregpath.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.
//
#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

CString AFXGetRegPath(LPCTSTR lpszPostFix, LPCTSTR lpszProfileName = NULL);

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxribbonbar.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#define AFX_IDW_RIBBON_BAR     0xE806  // CMFCRibbonBar
#define AFX_RIBBON_CAPTION_BUTTONS 3

#include "afxcontrolbarutil.h"

#include "afxpane.h"
#include "afxribbonbutton.h"
#include "afxribbonquickaccesstoolbar.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifndef RT_RIBBON
#define RT_RIBBON MAKEINTRESOURCE(28)
#endif

class CMFCRibbonCategory;
class CMFCRibbonBar;
class CMFCRibbonApplicationButton;
class CMFCToolBarMenuButton;
class CMFCRibbonMainPanel;
class CMFCRibbonRichEditCtrl;
class CMFCRibbonKeyTip;
class CMFCRibbonPanel;

/////////////////////////////////////////////////////////////////////////////
// AFX_RibbonCategoryColor

enum AFX_RibbonCategoryColor
{
	AFX_CategoryColor_None,
	AFX_CategoryColor_Red,
	AFX_CategoryColor_Orange,
	AFX_CategoryColor_Yellow,
	AFX_CategoryColor_Green,
	AFX_CategoryColor_Blue,
	AFX_CategoryColor_Indigo,
	AFX_CategoryColor_Violet
};

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonCaptionButton

class CMFCRibbonCaptionButton : public CMFCRibbonButton
{
	DECLARE_DYNCREATE(CMFCRibbonCaptionButton)

	friend class CMFCRibbonBar;

public:
	BOOL IsMDIChildButton() const { return m_hwndMDIChild != NULL; }

protected:
	CMFCRibbonCaptionButton(UINT uiCmd = 0, HWND hwndMDIChild = NULL);

	virtual void OnDraw(CDC* pDC);
	virtual void OnLButtonUp(CPoint point);

	virtual CSize GetRegularSize(CDC* pDC);
	virtual CSize GetCompactSize(CDC* pDC) { return GetRegularSize(pDC); }
	virtual BOOL IsShowTooltipOnBottom() const { return FALSE; }
	virtual int AddToListBox(CMFCRibbonCommandsListBox* /*pWndListBox*/, BOOL /*bDeep*/) { return -1; }

	HWND m_hwndMDIChild;
};

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonContextCaption

class CMFCRibbonContextCaption : public CMFCRibbonButton
{
	DECLARE_DYNCREATE(CMFCRibbonContextCaption)

	friend class CMFCRibbonBar;

public:
	AFX_RibbonCategoryColor	GetColor() const { return m_Color; }
	int GetRightTabX() const { return m_nRightTabX; }
	UINT GetContextID() const { return m_uiID; }

protected:
	CMFCRibbonContextCaption(LPCTSTR lpszName, UINT uiID, AFX_RibbonCategoryColor clrContext);
	CMFCRibbonContextCaption();

	virtual void OnDraw(CDC* pDC);
	virtual void OnLButtonUp(CPoint point);

	AFX_RibbonCategoryColor m_Color;
	UINT m_uiID;
	int  m_nRightTabX;
};

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonBar window

#define AFX_RIBBONBAR_HIDE_ELEMENTS  0x0001
#define AFX_RIBBONBAR_HIDE_ALL       0x0002

class CMFCRibbonBar : public CPane
{
	friend class CMFCRibbonCategory;
	friend class CMFCRibbonCustomizePropertyPage;
	friend class CPreviewViewEx;
	friend class CMFCRibbonApplicationButton;
	friend class CMFCRibbonPanelMenuBar;
	friend class CFrameImpl;
	friend class CMFCRibbonEdit;
	friend class CMFCRibbonPanel;
	friend class CMFCRibbonConstructor;
	friend class CMFCRibbonCollector;

	DECLARE_DYNAMIC(CMFCRibbonBar)

// Construction
public:
	CMFCRibbonBar(BOOL bReplaceFrameCaption = TRUE);

	BOOL Create(CWnd* pParentWnd, DWORD dwStyle = WS_CHILD | WS_VISIBLE | CBRS_TOP, UINT nID = AFX_IDW_RIBBON_BAR);
	BOOL CreateEx(CWnd* pParentWnd, DWORD dwCtrlStyle = 0, DWORD dwStyle = WS_CHILD | WS_VISIBLE | CBRS_TOP, UINT nID = AFX_IDW_RIBBON_BAR);

	/// <summary>
	/// Loads a Ribbon Bar from application resources.</summary>
	/// <returns> TRUE if load succeeds; otherwise FALSE. </summary>
	/// <param name="uiXMLResID">Specifies resource ID of XML string with Ribbon Bar information.</param>
	/// <param name="lpszResType">Specifies type of the resource located at uiXMLResID.</param>
	/// <param name="hInstance">Handle to the module whose executable file contains the resource. If hModule is NULL, the system loads the resource from the module that was used to create the current process.</param>
	virtual BOOL LoadFromResource(UINT uiXMLResID, LPCTSTR lpszResType = RT_RIBBON, HINSTANCE hInstance = NULL);
	/// <summary>
	/// Loads a Ribbon Bar from application resources.</summary>
	/// <returns> TRUE if load succeeds; otherwise FALSE. </summary>
	/// <param name="lpszXMLResID">Specifies resource ID (in string form) with Ribbon Bar information.</param>
	/// <param name="lpszResType">Specifies type of the resource located at uiXMLResID.</param>
	/// <param name="hInstance">Handle to the module whose executable file contains the resource. If hModule is NULL, the system loads the resource from the module that was used to create the current process.</param>
	virtual BOOL LoadFromResource(LPCTSTR lpszXMLResID, LPCTSTR lpszResType = RT_RIBBON, HINSTANCE hInstance = NULL);
	/// <summary>
	/// Loads a Ribbon Bar from application resources.</summary>
	/// <returns> TRUE if load succeeds; otherwise FALSE. </summary>
	/// <param name="lpszXMLBuffer">A buffer with XML string to load the Ribbon Bar from.</param>
	virtual BOOL LoadFromBuffer(LPCTSTR lpszXMLBuffer);

// Operations
public:
	/// <summary>
	/// Enable/disable ribbon Windows 7-style look (small rectangular application button)</summary>
	/// <param name="bWindows7Look">TRUE - set Windows 7-style look; FALSE - otherwise.</param>
	/// <param name="bRecalc">TRUE - recalculate the ribbon layout; FALSE - otherwise.</param>
	void SetWindows7Look(BOOL bWindows7Look, BOOL bRecalc = TRUE);

	/// <summary>
	/// Indicates whether the ribbon has Windows 7-style look (small rectangular application button)</summary>
	/// <returns> 
	/// TRUE if the ribbon has Windows 7-style look; otherwise FALSE.</returns>
	BOOL IsWindows7Look() const
	{
		return m_bWindows7Look;
	}

	virtual void RecalcLayout();

	//----------------------------------------------------------------------
	// Enable/disable ribbon main button (large rounded button on top left):
	//----------------------------------------------------------------------
	void SetApplicationButton(CMFCRibbonApplicationButton* pButton, CSize sizeButton);

	//--------------------------
	// Ribbon categories (tabs):
	//--------------------------
	CMFCRibbonMainPanel* AddMainCategory(LPCTSTR lpszName, UINT uiSmallImagesResID, UINT uiLargeImagesResID,
		CSize sizeSmallImage = CSize(16, 16), CSize sizeLargeImage = CSize(32, 32), CRuntimeClass* pRTI = NULL);
	CMFCRibbonCategory* AddCategory(LPCTSTR lpszName, UINT uiSmallImagesResID, UINT uiLargeImagesResID,
		CSize sizeSmallImage = CSize(16, 16), CSize sizeLargeImage = CSize(32, 32), int nInsertAt = -1, CRuntimeClass* pRTI = NULL);
	CMFCRibbonCategory* AddContextCategory(LPCTSTR lpszName, LPCTSTR lpszContextName, UINT uiContextID, AFX_RibbonCategoryColor clrContext,
		UINT uiSmallImagesResID, UINT uiLargeImagesResID, CSize sizeSmallImage = CSize(16, 16), CSize sizeLargeImage = CSize(32, 32), CRuntimeClass* pRTI = NULL);
	CMFCRibbonCategory* AddQATOnlyCategory(LPCTSTR lpszName, UINT uiSmallImagesResID, CSize sizeSmallImage = CSize(16, 16));
	CMFCRibbonCategory* AddPrintPreviewCategory();

	void EnablePrintPreview(BOOL bEnable = TRUE);
	BOOL IsPrintPreviewEnabled() const { return m_bIsPrintPreview; }

	int GetCategoryCount() const;
	int GetVisibleCategoryCount() const;
	CMFCRibbonCategory* GetCategory(int nIndex) const;
	int GetCategoryIndex(CMFCRibbonCategory* pCategory) const;

	void ShowCategory(int nIndex, BOOL bShow = TRUE);
	void ShowContextCategories(UINT uiContextID, BOOL bShow = TRUE);
	BOOL HideAllContextCategories();
	BOOL ActivateContextCategory(UINT uiContextID);

	BOOL RemoveCategory(int nIndex);
	void RemoveAllCategories();

	virtual BOOL SetActiveCategory(CMFCRibbonCategory* pCategory, BOOL bForceRestore = FALSE);
	CMFCRibbonCategory* GetActiveCategory() const { return m_pActiveCategory; }

	int FindCategoryIndexByData(DWORD dwData) const;
	BOOL GetContextName(UINT uiContextID, CString& strName) const;

	//-------------------------------
	// Ribbon elements direct access:
	//-------------------------------
	CMFCRibbonBaseElement* FindByID(UINT uiCmdID, BOOL bVisibleOnly = TRUE, BOOL bExcludeQAT = FALSE) const;
	CMFCRibbonBaseElement* FindByData(DWORD_PTR dwData, BOOL bVisibleOnly = TRUE) const;

	BOOL SetElementKeys(UINT uiCmdID, LPCTSTR lpszKeys, LPCTSTR lpszMenuKeys = NULL);

	void GetElementsByID(UINT uiCmdID, CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arButtons);
	void GetVisibleElements(CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arButtons);

	void SetQuickAccessDefaultState(const CMFCRibbonQuickAccessToolBarDefaultState& state);
	void SetQuickAccessCommands(const CList<UINT,UINT>& lstCommands, BOOL bRecalcLayout = TRUE);
	void GetQuickAccessCommands(CList<UINT,UINT>& lstCommands);

	//--------------------------------------------------
	// Additional elements located on the right of tabs:
	//--------------------------------------------------
	void AddToTabs(CMFCRibbonBaseElement* pElement);
	void RemoveAllFromTabs();

	//------------------
	// Tooltips support:
	//------------------
	void EnableToolTips(BOOL bEnable = TRUE, BOOL bEnableDescr = TRUE);
	
	BOOL IsToolTipEnabled() const { return m_bToolTip; }
	BOOL IsToolTipDescrEnabled() const { return m_bToolTipDescr; }

	int GetTooltipFixedWidthRegular() const { return m_nTooltipWidthRegular; }
	int GetTooltipFixedWidthLargeImage() const { return m_nTooltipWidthLargeImage; }

	void SetTooltipFixedWidth(int nWidthRegular, int nWidthLargeImage);	// 0 - set variable size

	//-----------------
	// Key tip support:
	//-----------------
	void EnableKeyTips(BOOL bEnable = TRUE);

	BOOL IsKeyTipEnabled() const { return m_bKeyTips; }

	void GetItemIDsList(CList<UINT,UINT>& lstItems, BOOL bHiddenOnly = FALSE) const;

	void ToggleMimimizeState();

	BOOL OnSysKeyDown(CFrameWnd* pFrameWnd, WPARAM wParam, LPARAM lParam);
	BOOL OnSysKeyUp(CFrameWnd* pFrameWnd, WPARAM wParam, LPARAM lParam);

	//--------------------
	// Save ribbon to XML:
	//--------------------
	/// <summary> Saves the Ribbon Bar to XML file.
	/// </summary>
	/// <param name="lpszFilePath">Specifies the output file.</param>
	/// <returns>TRUE if succeeds; othewise FALSE.</returns>
	BOOL SaveToXMLFile(LPCTSTR lpszFilePath) const;
	/// <summary> Saves the Ribbon Bar to a buffer.
	/// </summary>
	/// <param name="ppBuffer">When this function returns, ppBuffer points to a buffer allocated by this method and 
	/// containing Ribbon Bar information in XML format.</param>
	/// <returns>TRUE if succeeds; othewise FALSE.</returns>
	UINT SaveToXMLBuffer(LPBYTE* ppBuffer) const;

// Attributes
public:
	int GetCaptionHeight() const { return m_nCaptionHeight; }
	int GetCategoryHeight() const { return m_nCategoryHeight; }
	BOOL IsReplaceFrameCaption() const { return m_bReplaceFrameCaption; }
	CMFCRibbonApplicationButton* GetApplicationButton() const { return m_pMainButton; }
	CMFCRibbonCategory* GetMainCategory() const { return m_pMainCategory; }

	virtual CMFCRibbonBaseElement* HitTest(CPoint point, BOOL bCheckActiveCategory = FALSE, BOOL bCheckPanelCaption = FALSE);

	//---------------------------------
	// Quick access toolbar attributes:
	//---------------------------------
	void SetQuickAccessToolbarOnTop(BOOL bOnTop);

	BOOL IsQuickAccessToolbarOnTop() const { return m_bQuickAccessToolbarOnTop && m_bReplaceFrameCaption; }
	CRect GetQuickAccessToolbarLocation() const { return m_QAToolbar.GetRect(); }
	CRect GetQATCommandsLocation() const { return m_QAToolbar.GetCommandsRect(); }

	BOOL IsQATEmpty() const { return (int) m_QAToolbar.m_arButtons.GetSize() <= 1; }
	CMFCRibbonBaseElement* GetQATDroppedDown() { return m_QAToolbar.GetDroppedDown(); }

	DWORD GetHideFlags() const { return m_dwHideFlags; }
	int GetTabTruncateRatio() const { return m_nTabTruncateRatio; }

	void SetMaximizeMode(BOOL bMax, CWnd* pWnd = NULL);
	void SetActiveMDIChild(CWnd* pWnd);

	virtual CMFCRibbonBaseElement* GetDroppedDown();
	/// <summary>
	/// Returns a focused element. </summary>
	/// <returns> A pointer to a focused element or NULL.</returns>
	virtual CMFCRibbonBaseElement* GetFocused();

	BOOL IsTransparentCaption() const { return m_bIsTransparentCaption; }
	int GetKeyboardNavigationLevel() const { return m_nKeyboardNavLevel; }

	void SetKeyboardNavigationLevel(CObject* pLevel, BOOL bSetFocus = TRUE);

	CObject* GetKeyboardNavLevelParent() const { return m_pKeyboardNavLevelParent; }
	CObject* GetKeyboardNavLevelCurrent() const { return m_pKeyboardNavLevelCurrent; }

	virtual BOOL OnSetAccData(long lVal);

protected:
	int m_nTabsHeight;
	int m_nCategoryHeight;
	int m_nCategoryMinWidth;
	int m_nHighlightedTab;
	int m_nCaptionHeight;
	int m_nTabTruncateRatio;
	int m_nSystemButtonsNum;
	int m_nKeyboardNavLevel;
	int m_nCurrKeyChar;
	int m_nTooltipWidthRegular;
	int m_nTooltipWidthLargeImage;

	BOOL m_bRecalcCategoryHeight;
	BOOL m_bRecalcCategoryWidth;
	BOOL m_bTracked;
	BOOL m_bIsPrintPreview;
	BOOL m_bQuickAccessToolbarOnTop;
	BOOL m_bForceRedraw;
	BOOL m_bMaximizeMode;
	BOOL m_bAutoCommandTimer;
	BOOL m_bPrintPreviewMode;
	BOOL m_bIsTransparentCaption;
	BOOL m_bIsMaximized;
	BOOL m_bToolTip;
	BOOL m_bToolTipDescr;
	BOOL m_bKeyTips;
	BOOL m_bIsCustomizeMenu;
	BOOL m_bDontSetKeyTips;
	BOOL m_bAutoDestroyMainButton;

	const BOOL m_bReplaceFrameCaption;

	HFONT m_hFont;
	DWORD m_dwHideFlags;

	CMFCRibbonApplicationButton*  m_pMainButton;
	CMFCRibbonBaseElement* m_pHighlighted;
	CMFCRibbonBaseElement* m_pPressed;
	CMFCRibbonButtonsGroup m_TabElements;
	CMFCRibbonCategory*    m_pActiveCategory;
	CMFCRibbonCategory*    m_pActiveCategorySaved;
	CMFCRibbonCategory*    m_pMainCategory;
	CMFCRibbonCategory*    m_pPrintPreviewCategory;

	CArray<CMFCRibbonContextCaption*, CMFCRibbonContextCaption*> m_arContextCaptions;
	CArray<CMFCRibbonCategory*,CMFCRibbonCategory*> m_arCategories;
	CArray<CMFCRibbonKeyTip*,CMFCRibbonKeyTip*> m_arKeyElements;
	CArray<int,int> m_arVisibleCategoriesSaved;

	CRect m_rectCaption;
	CRect m_rectCaptionText;
	CRect m_rectSysButtons;
	CSize m_sizeMainButton;

	CToolTipCtrl* m_pToolTip;
	CObject*      m_pKeyboardNavLevelParent;
	CObject*      m_pKeyboardNavLevelCurrent;

	CMFCRibbonCaptionButton      m_CaptionButtons[AFX_RIBBON_CAPTION_BUTTONS];
	CMFCRibbonQuickAccessToolBar m_QAToolbar;

	BOOL m_bWindows7Look;

// Overrides
public:
	virtual void OnClickButton(CMFCRibbonButton* pButton, CPoint point);
	virtual BOOL IsMainRibbonBar() const { return TRUE; }
	virtual BOOL IsShowGroupBorder(CMFCRibbonButtonsGroup* /*pGroup*/) const { return FALSE; }
	virtual void OnEditContextMenu(CMFCRibbonRichEditCtrl* pEdit, CPoint point);

	virtual void DWMCompositionChanged();

	virtual BOOL OnShowRibbonQATMenu(CWnd* pWnd, int x, int y, CMFCRibbonBaseElement* pHit);

	virtual BOOL TranslateChar(UINT nChar);

	virtual void OnRTLChanged(BOOL bIsRTL);

public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);

protected:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);

	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);
	virtual void OnPaneContextMenu(CWnd* pParentFrame, CPoint point);

protected:
	virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);
	virtual BOOL AllowShowOnPaneMenu() const { return FALSE; }

	virtual void OnFillBackground(CDC* pDC, CRect rectClient);

	virtual BOOL LoadState(LPCTSTR lpszProfileName = NULL, int nIndex = -1, UINT uiID = (UINT) -1);
	virtual BOOL SaveState(LPCTSTR lpszProfileName = NULL, int nIndex = -1, UINT uiID = (UINT) -1);

	virtual void OnSetPrintPreviewKeys(CMFCRibbonPanel* pPrintPanel, CMFCRibbonPanel* pZoomPanel, CMFCRibbonPanel* pPreviewPanel);
	virtual BOOL HideInPrintPreviewMode() const { return FALSE; }
	virtual void OnBeforeProcessKey(int& nChar);

	BOOL NavigateRibbon(int nChar);

	static CMFCRibbonBaseElement* FindNextFocusedElement(int nChar, const CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arElems, CRect rectElems, CMFCRibbonBaseElement* pFocused, BOOL bIsScrollLeftAvailable, BOOL bIsScrollRightAvailable, int& nScroll);
	static CMFCRibbonBaseElement* FindNearest(CPoint pt, const CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arButtons);

// Implementation
public:
	virtual ~CMFCRibbonBar();

	void PopTooltip();
	BOOL DrawMenuImage(CDC* pDC, const CMFCToolBarMenuButton* pMenuItem, const CRect& rectImage);

	virtual BOOL OnShowRibbonContextMenu(CWnd* pWnd, int x, int y, CMFCRibbonBaseElement* pHit);

	void ForceRecalcLayout();
	void DeactivateKeyboardFocus(BOOL bSetFocus = TRUE);

	void ShowKeyTips(BOOL bRepos = FALSE);
	void HideKeyTips();

protected:
	void ShowSysMenu(const CPoint& point);
	void SetPrintPreviewMode(BOOL bSet = TRUE);

	CMFCRibbonContextCaption* FindContextCaption(UINT uiID) const;

	void UpdateToolTipsRect();
	BOOL ProcessKey(int nChar);

	void RemoveAllKeys();

protected:
	//{{AFX_MSG(CMFCRibbonBar)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnPaint();
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnCancelMode();
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnDestroy();
	afx_msg void OnSizing(UINT fwSide, LPRECT pRect);
	afx_msg BOOL OnMouseWheel(UINT nFlags, short zDelta, CPoint pt);
	afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
	afx_msg void OnTimer(UINT_PTR nIDEvent);
	afx_msg void OnSysColorChange();
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	afx_msg LRESULT OnSetFont(WPARAM, LPARAM);
	afx_msg LRESULT OnGetFont(WPARAM, LPARAM);
	afx_msg LRESULT OnMouseLeave(WPARAM, LPARAM);
	afx_msg LRESULT OnUpdateToolTips(WPARAM, LPARAM);
	afx_msg BOOL OnNeedTipText(UINT id, NMHDR* pNMH, LRESULT* pResult);
	afx_msg LRESULT OnPostRecalcLayout(WPARAM,LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonBar idle update through CMFCRibbonCmdUI class

class CMFCRibbonCmdUI : public CCmdUI
{
public:
	CMFCRibbonCmdUI();

	virtual void Enable(BOOL bOn);
	virtual void SetCheck(int nCheck);
	virtual void SetText(LPCTSTR lpszText);
	virtual void SetRadio(BOOL bOn = TRUE);

	CMFCRibbonBaseElement* m_pUpdated;
};

//////////////////////////////////////////////////////////////////////
// CMFCRibbonApplicationButton

class CMFCRibbonApplicationButton : public CMFCRibbonButton
{
	friend class CMFCRibbonCollector;
	friend class CMFCRibbonConstructor;

	DECLARE_DYNCREATE(CMFCRibbonApplicationButton);

public:
	CMFCRibbonApplicationButton() { }

	CMFCRibbonApplicationButton(UINT uiBmpResID) { SetImage(uiBmpResID); }
	CMFCRibbonApplicationButton(HBITMAP hBmp) { SetImage(hBmp); }

	void SetImage(UINT uiBmpResID);
	void SetImage(HBITMAP hBmp);
	void SetWindows7Image(UINT uiBmpResID);
	void SetWindows7Image(HBITMAP hBmp);

protected:
	virtual BOOL IsShowTooltipOnBottom() const { return FALSE; }
	virtual BOOL IsApplicationButton() const { return TRUE; }
	virtual BOOL CanBeAddedToQuickAccessToolBar() const { return FALSE; }
	virtual int AddToListBox(CMFCRibbonCommandsListBox* /*pWndListBox*/, BOOL /*bDeep*/) { return -1; }

	virtual CSize GetImageSize(RibbonImageType /*type*/) const 
	{
		ASSERT_VALID(this);
		return m_Image.GetImageSize();
	}

	virtual void DrawImage(CDC* pDC, RibbonImageType /*type*/, CRect rectImage);

	virtual BOOL SetACCData(CWnd* pParent, CAccessibilityData& data)
	{
		CMFCRibbonButton::SetACCData(pParent, data);
		data.m_nAccRole = ROLE_SYSTEM_BUTTONDROPDOWNGRID;
		data.m_bAccState |= STATE_SYSTEM_HASPOPUP;
		return TRUE;
	}

	virtual void OnLButtonDown(CPoint point);
	virtual void OnLButtonDblClk(CPoint point);
	virtual BOOL OnKey(BOOL bIsMenuKey);

	virtual BOOL IsDrawTooltipImage() const { return FALSE; }

	BOOL ShowMainMenu();

	CMFCToolBarImages m_Image;
	CMFCToolBarImages m_ImageWindows7;
};

extern AFX_IMPORT_DATA UINT AFX_WM_ON_CHANGE_RIBBON_CATEGORY;
extern AFX_IMPORT_DATA UINT AFX_WM_ON_RIBBON_CUSTOMIZE;
extern AFX_IMPORT_DATA UINT AFX_WM_ON_HIGHLIGHT_RIBBON_LIST_ITEM;
extern AFX_IMPORT_DATA UINT AFX_WM_ON_BEFORE_SHOW_RIBBON_ITEM_MENU;

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXRES_H__
#define __AFXRES_H__

#ifdef RC_INVOKED
#ifndef _INC_WINDOWS
#define _INC_WINDOWS
   #include "winres.h"           // extract from windows header
#endif
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifndef _MFC_FILENAME_VER
#define _MFC_FILENAME_VER "100"
#endif

#ifdef RC_INVOKED
	#if defined(_VC80_UPGRADE) && (_VC80_UPGRADE >= 0x0700) && (_VC80_UPGRADE < 0x0800) && defined(IDR_MANIFEST)
		// Handle project upgrade from VC7/VC7.1 for projects with manifest
		#define IDR_MANIFEST	1024
	#endif
#endif	// RC_INVOKED

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// MFC resource types (see Technical note TN024 for implementation details)

#ifndef RC_INVOKED
#define RT_DLGINIT  MAKEINTRESOURCE(240)
#define RT_TOOLBAR  MAKEINTRESOURCE(241)
#endif

#define RT_RIBBON_XML   28

/////////////////////////////////////////////////////////////////////////////

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// General style bits etc

// ControlBar styles
#define CBRS_ALIGN_LEFT     0x1000L
#define CBRS_ALIGN_TOP      0x2000L
#define CBRS_ALIGN_RIGHT    0x4000L
#define CBRS_ALIGN_BOTTOM   0x8000L
#define CBRS_ALIGN_ANY      0xF000L

#define CBRS_BORDER_LEFT    0x0100L
#define CBRS_BORDER_TOP     0x0200L
#define CBRS_BORDER_RIGHT   0x0400L
#define CBRS_BORDER_BOTTOM  0x0800L
#define CBRS_BORDER_ANY     0x0F00L

#define CBRS_TOOLTIPS       0x0010L
#define CBRS_FLYBY          0x0020L
#define CBRS_FLOAT_MULTI    0x0040L
#define CBRS_BORDER_3D      0x0080L
#define CBRS_HIDE_INPLACE   0x0008L
#define CBRS_SIZE_DYNAMIC   0x0004L
#define CBRS_SIZE_FIXED     0x0002L
#define CBRS_FLOATING       0x0001L

#define CBRS_GRIPPER        0x00400000L

#define CBRS_ORIENT_HORZ    (CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM)
#define CBRS_ORIENT_VERT    (CBRS_ALIGN_LEFT|CBRS_ALIGN_RIGHT)
#define CBRS_ORIENT_ANY     (CBRS_ORIENT_HORZ|CBRS_ORIENT_VERT)

#define CBRS_ALL            0x0040FFFFL

// the CBRS_ style is made up of an alignment style and a draw border style
//  the alignment styles are mutually exclusive
//  the draw border styles may be combined
#define CBRS_NOALIGN        0x00000000L
#define CBRS_LEFT           (CBRS_ALIGN_LEFT|CBRS_BORDER_RIGHT)
#define CBRS_TOP            (CBRS_ALIGN_TOP|CBRS_BORDER_BOTTOM)
#define CBRS_RIGHT          (CBRS_ALIGN_RIGHT|CBRS_BORDER_LEFT)
#define CBRS_BOTTOM         (CBRS_ALIGN_BOTTOM|CBRS_BORDER_TOP)

/////////////////////////////////////////////////////////////////////////////
// Standard window components

// Mode indicators in status bar - these are routed like commands
#define ID_INDICATOR_EXT                0xE700  // extended selection indicator
#define ID_INDICATOR_CAPS               0xE701  // cap lock indicator
#define ID_INDICATOR_NUM                0xE702  // num lock indicator
#define ID_INDICATOR_SCRL               0xE703  // scroll lock indicator
#define ID_INDICATOR_OVR                0xE704  // overtype mode indicator
#define ID_INDICATOR_REC                0xE705  // record mode indicator
#define ID_INDICATOR_KANA               0xE706  // kana lock indicator

#define ID_SEPARATOR                    0   // special separator value

#ifndef RC_INVOKED  // code only
// Standard control bars (IDW = window ID)
#define AFX_IDW_CONTROLBAR_FIRST        0xE800
#define AFX_IDW_CONTROLBAR_LAST         0xE8FF

#define AFX_IDW_TOOLBAR                 0xE800  // main Toolbar for window
#define AFX_IDW_STATUS_BAR              0xE801  // Status bar window
#define AFX_IDW_PREVIEW_BAR             0xE802  // PrintPreview Dialog Bar
#define AFX_IDW_RESIZE_BAR              0xE803  // OLE in-place resize bar
#define AFX_IDW_REBAR                   0xE804  // COMCTL32 "rebar" Bar
#define AFX_IDW_DIALOGBAR               0xE805  // CDialogBar

// Note: If your application supports docking toolbars, you should
//  not use the following IDs for your own toolbars.  The IDs chosen
//  are at the top of the first 32 such that the bars will be hidden
//  while in print preview mode, and are not likely to conflict with
//  IDs your application may have used succesfully in the past.

#define AFX_IDW_DOCKBAR_TOP             0xE81B
#define AFX_IDW_DOCKBAR_LEFT            0xE81C
#define AFX_IDW_DOCKBAR_RIGHT           0xE81D
#define AFX_IDW_DOCKBAR_BOTTOM          0xE81E
#define AFX_IDW_DOCKBAR_FLOAT           0xE81F

// Macro for mapping standard control bars to bitmask (limit of 32)
#define AFX_CONTROLBAR_MASK(nIDC)   (1L << (nIDC - AFX_IDW_CONTROLBAR_FIRST))

// parts of Main Frame
#define AFX_IDW_PANE_FIRST              0xE900  // first pane (256 max)
#define AFX_IDW_PANE_LAST               0xE9ff
#define AFX_IDW_HSCROLL_FIRST           0xEA00  // first Horz scrollbar (16 max)
#define AFX_IDW_VSCROLL_FIRST           0xEA10  // first Vert scrollbar (16 max)

#define AFX_IDW_SIZE_BOX                0xEA20  // size box for splitters
#define AFX_IDW_PANE_SAVE               0xEA21  // to shift AFX_IDW_PANE_FIRST
#endif //!RC_INVOKED

#ifndef APSTUDIO_INVOKED

// common style for form views
#define AFX_WS_DEFAULT_VIEW             (WS_CHILD | WS_VISIBLE | WS_BORDER)

#endif //!APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
// Standard app configurable strings

// for application title (defaults to EXE name or name in constructor)
#define AFX_IDS_APP_TITLE               0xE000
// idle message bar line
#define AFX_IDS_IDLEMESSAGE             0xE001
// message bar line when in shift-F1 help mode
#define AFX_IDS_HELPMODEMESSAGE         0xE002
// document title when editing OLE embedding
#define AFX_IDS_APP_TITLE_EMBEDDING     0xE003
// company name
#define AFX_IDS_COMPANY_NAME            0xE004
// object name when server is inplace
#define AFX_IDS_OBJ_TITLE_INPLACE       0xE005
// Application User Model ID
#define AFX_IDS_APP_ID                  0xE006

/////////////////////////////////////////////////////////////////////////////
// Standard Commands

// File commands
#define ID_FILE_NEW                     0xE100
#define ID_FILE_OPEN                    0xE101
#define ID_FILE_CLOSE                   0xE102
#define ID_FILE_SAVE                    0xE103
#define ID_FILE_SAVE_AS                 0xE104
#define ID_FILE_PAGE_SETUP              0xE105
#define ID_FILE_PRINT_SETUP             0xE106
#define ID_FILE_PRINT                   0xE107
#define ID_FILE_PRINT_DIRECT            0xE108
#define ID_FILE_PRINT_PREVIEW           0xE109
#define ID_FILE_UPDATE                  0xE10A
#define ID_FILE_SAVE_COPY_AS            0xE10B
#define ID_FILE_SEND_MAIL               0xE10C
#define ID_FILE_NEW_FRAME               0xE10D

#define ID_FILE_MRU_FIRST               0xE110
#define ID_FILE_MRU_FILE1               0xE110          // range - 16 max
#define ID_FILE_MRU_FILE2               0xE111
#define ID_FILE_MRU_FILE3               0xE112
#define ID_FILE_MRU_FILE4               0xE113
#define ID_FILE_MRU_FILE5               0xE114
#define ID_FILE_MRU_FILE6               0xE115
#define ID_FILE_MRU_FILE7               0xE116
#define ID_FILE_MRU_FILE8               0xE117
#define ID_FILE_MRU_FILE9               0xE118
#define ID_FILE_MRU_FILE10              0xE119
#define ID_FILE_MRU_FILE11              0xE11A
#define ID_FILE_MRU_FILE12              0xE11B
#define ID_FILE_MRU_FILE13              0xE11C
#define ID_FILE_MRU_FILE14              0xE11D
#define ID_FILE_MRU_FILE15              0xE11E
#define ID_FILE_MRU_FILE16              0xE11F
#define ID_FILE_MRU_LAST                0xE11F

// Edit commands
#define ID_EDIT_CLEAR                   0xE120
#define ID_EDIT_CLEAR_ALL               0xE121
#define ID_EDIT_COPY                    0xE122
#define ID_EDIT_CUT                     0xE123
#define ID_EDIT_FIND                    0xE124
#define ID_EDIT_PASTE                   0xE125
#define ID_EDIT_PASTE_LINK              0xE126
#define ID_EDIT_PASTE_SPECIAL           0xE127
#define ID_EDIT_REPEAT                  0xE128
#define ID_EDIT_REPLACE                 0xE129
#define ID_EDIT_SELECT_ALL              0xE12A
#define ID_EDIT_UNDO                    0xE12B
#define ID_EDIT_REDO                    0xE12C

// Window commands
#define ID_WINDOW_NEW                   0xE130
#define ID_WINDOW_ARRANGE               0xE131
#define ID_WINDOW_CASCADE               0xE132
#define ID_WINDOW_TILE_HORZ             0xE133
#define ID_WINDOW_TILE_VERT             0xE134
#define ID_WINDOW_SPLIT                 0xE135
#ifndef RC_INVOKED      // code only
#define AFX_IDM_WINDOW_FIRST            0xE130
#define AFX_IDM_WINDOW_LAST             0xE13F
#define AFX_IDM_FIRST_MDICHILD          0xFF00  // window list starts here
#endif //!RC_INVOKED

// Help and App commands
#define ID_APP_ABOUT                    0xE140
#define ID_APP_EXIT                     0xE141
#define ID_HELP_INDEX                   0xE142
#define ID_HELP_FINDER                  0xE143
#define ID_HELP_USING                   0xE144
#define ID_CONTEXT_HELP                 0xE145      // shift-F1
// special commands for processing help
#define ID_HELP                         0xE146      // first attempt for F1
#define ID_DEFAULT_HELP                 0xE147      // last attempt

// Misc
#define ID_NEXT_PANE                    0xE150
#define ID_PREV_PANE                    0xE151

// Format
#define ID_FORMAT_FONT                  0xE160

// OLE commands
#define ID_OLE_INSERT_NEW               0xE200
#define ID_OLE_EDIT_LINKS               0xE201
#define ID_OLE_EDIT_CONVERT             0xE202
#define ID_OLE_EDIT_CHANGE_ICON         0xE203
#define ID_OLE_EDIT_PROPERTIES          0xE204
#define ID_OLE_VERB_FIRST               0xE210     // range - 16 max
#ifndef RC_INVOKED      // code only
#define ID_OLE_VERB_LAST                0xE21F
#endif //!RC_INVOKED

// for print preview dialog bar
#define AFX_ID_PREVIEW_CLOSE            0xE300
#define AFX_ID_PREVIEW_NUMPAGE          0xE301      // One/Two Page button
#define AFX_ID_PREVIEW_NEXT             0xE302
#define AFX_ID_PREVIEW_PREV             0xE303
#define AFX_ID_PREVIEW_PRINT            0xE304
#define AFX_ID_PREVIEW_ZOOMIN           0xE305
#define AFX_ID_PREVIEW_ZOOMOUT          0xE306

// View commands (same number used as IDW used for control bar)
#define ID_VIEW_TOOLBAR                 0xE800
#define ID_VIEW_STATUS_BAR              0xE801
#define ID_VIEW_REBAR                   0xE804
#define ID_VIEW_AUTOARRANGE         0xE805
   // E810 -> E81F must be kept in order for RANGE macros
#define ID_VIEW_SMALLICON               0xE810
#define ID_VIEW_LARGEICON               0xE811
#define ID_VIEW_LIST                   0xE812
#define ID_VIEW_DETAILS                 0xE813
#define ID_VIEW_LINEUP                  0xE814
#define ID_VIEW_BYNAME                  0xE815
#define AFX_ID_VIEW_MINIMUM              ID_VIEW_SMALLICON
#define AFX_ID_VIEW_MAXIMUM              ID_VIEW_BYNAME
   // E800 -> E8FF reserved for other control bar commands

// RecordForm commands
#define ID_RECORD_FIRST                 0xE900
#define ID_RECORD_LAST                  0xE901
#define ID_RECORD_NEXT                  0xE902
#define ID_RECORD_PREV                  0xE903

/////////////////////////////////////////////////////////////////////////////
// Standard control IDs

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls

/////////////////////////////////////////////////////////////////////////////
// Standard string error/warnings

#ifndef RC_INVOKED      // code only
#define AFX_IDS_SCFIRST                 0xEF00
#endif //!RC_INVOKED

#define AFX_IDS_SCSIZE                  0xEF00
#define AFX_IDS_SCMOVE                  0xEF01
#define AFX_IDS_SCMINIMIZE              0xEF02
#define AFX_IDS_SCMAXIMIZE              0xEF03
#define AFX_IDS_SCNEXTWINDOW            0xEF04
#define AFX_IDS_SCPREVWINDOW            0xEF05
#define AFX_IDS_SCCLOSE                 0xEF06
#define AFX_IDS_SCRESTORE               0xEF12
#define AFX_IDS_SCTASKLIST              0xEF13

#define AFX_IDS_MDICHILD                0xEF1F

#define AFX_IDS_DESKACCESSORY           0xEFDA

// General strings
#define AFX_IDS_OPENFILE                0xF000
#define AFX_IDS_SAVEFILE                0xF001
#define AFX_IDS_ALLFILTER               0xF002
#define AFX_IDS_UNTITLED                0xF003
#define AFX_IDS_SAVEFILECOPY            0xF004
#define AFX_IDS_PREVIEW_CLOSE           0xF005
#define AFX_IDS_UNNAMED_FILE            0xF006
#define AFX_IDS_HIDE                    0xF011

// MFC Standard Exception Error messages
#define AFX_IDP_NO_ERROR_AVAILABLE      0xF020
#define AFX_IDS_NOT_SUPPORTED_EXCEPTION 0xF021
#define AFX_IDS_RESOURCE_EXCEPTION      0xF022
#define AFX_IDS_MEMORY_EXCEPTION        0xF023
#define AFX_IDS_USER_EXCEPTION          0xF024
#define AFX_IDS_INVALID_ARG_EXCEPTION   0xF025

// Printing and print preview strings
#define AFX_IDS_PRINTONPORT             0xF040
#define AFX_IDS_ONEPAGE                 0xF041
#define AFX_IDS_TWOPAGE                 0xF042
#define AFX_IDS_PRINTPAGENUM            0xF043
#define AFX_IDS_PREVIEWPAGEDESC         0xF044
#define AFX_IDS_PRINTDEFAULTEXT         0xF045
#define AFX_IDS_PRINTDEFAULT            0xF046
#define AFX_IDS_PRINTFILTER             0xF047
#define AFX_IDS_PRINTCAPTION            0xF048
#define AFX_IDS_PRINTTOFILE             0xF049


// OLE strings
#define AFX_IDS_OBJECT_MENUITEM         0xF080
#define AFX_IDS_EDIT_VERB               0xF081
#define AFX_IDS_ACTIVATE_VERB           0xF082
#define AFX_IDS_CHANGE_LINK             0xF083
#define AFX_IDS_AUTO                    0xF084
#define AFX_IDS_MANUAL                  0xF085
#define AFX_IDS_FROZEN                  0xF086
#define AFX_IDS_ALL_FILES               0xF087
// dynamically changing menu items
#define AFX_IDS_SAVE_MENU               0xF088
#define AFX_IDS_UPDATE_MENU             0xF089
#define AFX_IDS_SAVE_AS_MENU            0xF08A
#define AFX_IDS_SAVE_COPY_AS_MENU       0xF08B
#define AFX_IDS_EXIT_MENU               0xF08C
#define AFX_IDS_UPDATING_ITEMS          0xF08D
// COlePasteSpecialDialog defines
#define AFX_IDS_METAFILE_FORMAT         0xF08E
#define AFX_IDS_DIB_FORMAT              0xF08F
#define AFX_IDS_BITMAP_FORMAT           0xF090
#define AFX_IDS_LINKSOURCE_FORMAT       0xF091
#define AFX_IDS_EMBED_FORMAT            0xF092
// other OLE utility strings
#define AFX_IDS_PASTELINKEDTYPE         0xF094
#define AFX_IDS_UNKNOWNTYPE             0xF095
#define AFX_IDS_RTF_FORMAT              0xF096
#define AFX_IDS_TEXT_FORMAT             0xF097
// OLE datatype format error strings
#define AFX_IDS_INVALID_CURRENCY        0xF098
#define AFX_IDS_INVALID_DATETIME        0xF099
#define AFX_IDS_INVALID_DATETIMESPAN    0xF09A

// General error / prompt strings
#define AFX_IDP_INVALID_FILENAME        0xF100
#define AFX_IDP_FAILED_TO_OPEN_DOC      0xF101
#define AFX_IDP_FAILED_TO_SAVE_DOC      0xF102
#define AFX_IDP_ASK_TO_SAVE             0xF103
#define AFX_IDP_FAILED_TO_CREATE_DOC    0xF104
#define AFX_IDP_FILE_TOO_LARGE          0xF105
#define AFX_IDP_FAILED_TO_START_PRINT   0xF106
#define AFX_IDP_FAILED_TO_LAUNCH_HELP   0xF107
#define AFX_IDP_INTERNAL_FAILURE        0xF108      // general failure
#define AFX_IDP_COMMAND_FAILURE         0xF109      // command failure
#define AFX_IDP_FAILED_MEMORY_ALLOC     0xF10A
#define AFX_IDP_UNREG_DONE              0xF10B
#define AFX_IDP_UNREG_FAILURE           0xF10C
#define AFX_IDP_DLL_LOAD_FAILED         0xF10D
#define AFX_IDP_DLL_BAD_VERSION         0xF10E

// DDV parse errors
#define AFX_IDP_PARSE_INT               0xF110
#define AFX_IDP_PARSE_REAL              0xF111
#define AFX_IDP_PARSE_INT_RANGE         0xF112
#define AFX_IDP_PARSE_REAL_RANGE        0xF113
#define AFX_IDP_PARSE_STRING_SIZE       0xF114
#define AFX_IDP_PARSE_RADIO_BUTTON      0xF115
#define AFX_IDP_PARSE_BYTE              0xF116
#define AFX_IDP_PARSE_UINT              0xF117
#define AFX_IDP_PARSE_DATETIME          0xF118
#define AFX_IDP_PARSE_CURRENCY          0xF119
#define AFX_IDP_PARSE_GUID              0xF11A
#define AFX_IDP_PARSE_TIME              0xF11B
#define AFX_IDP_PARSE_DATE              0xF11C

// CFile/CArchive error strings for user failure
#define AFX_IDP_FAILED_INVALID_FORMAT   0xF120
#define AFX_IDP_FAILED_INVALID_PATH     0xF121
#define AFX_IDP_FAILED_DISK_FULL        0xF122
#define AFX_IDP_FAILED_ACCESS_READ      0xF123
#define AFX_IDP_FAILED_ACCESS_WRITE     0xF124
#define AFX_IDP_FAILED_IO_ERROR_READ    0xF125
#define AFX_IDP_FAILED_IO_ERROR_WRITE   0xF126

// Script errors / prompt strings
#define AFX_IDP_SCRIPT_ERROR            0xF130
#define AFX_IDP_SCRIPT_DISPATCH_EXCEPTION 0xF131

// OLE errors / prompt strings
#define AFX_IDP_STATIC_OBJECT           0xF180
#define AFX_IDP_FAILED_TO_CONNECT       0xF181
#define AFX_IDP_SERVER_BUSY             0xF182
#define AFX_IDP_BAD_VERB                0xF183
#define AFX_IDS_NOT_DOCOBJECT           0xF184
#define AFX_IDP_FAILED_TO_NOTIFY        0xF185
#define AFX_IDP_FAILED_TO_LAUNCH        0xF186
#define AFX_IDP_ASK_TO_UPDATE           0xF187
#define AFX_IDP_FAILED_TO_UPDATE        0xF188
#define AFX_IDP_FAILED_TO_REGISTER      0xF189
#define AFX_IDP_FAILED_TO_AUTO_REGISTER 0xF18A
#define AFX_IDP_FAILED_TO_CONVERT       0xF18B
#define AFX_IDP_GET_NOT_SUPPORTED       0xF18C
#define AFX_IDP_SET_NOT_SUPPORTED       0xF18D
#define AFX_IDP_ASK_TO_DISCARD          0xF18E
#define AFX_IDP_FAILED_TO_CREATE        0xF18F

// MAPI errors / prompt strings
#define AFX_IDP_FAILED_MAPI_LOAD        0xF190
#define AFX_IDP_INVALID_MAPI_DLL        0xF191
#define AFX_IDP_FAILED_MAPI_SEND        0xF192

#define AFX_IDP_FILE_NONE               0xF1A0
#define AFX_IDP_FILE_GENERIC            0xF1A1
#define AFX_IDP_FILE_NOT_FOUND          0xF1A2
#define AFX_IDP_FILE_BAD_PATH           0xF1A3
#define AFX_IDP_FILE_TOO_MANY_OPEN      0xF1A4
#define AFX_IDP_FILE_ACCESS_DENIED      0xF1A5
#define AFX_IDP_FILE_INVALID_FILE       0xF1A6
#define AFX_IDP_FILE_REMOVE_CURRENT     0xF1A7
#define AFX_IDP_FILE_DIR_FULL           0xF1A8
#define AFX_IDP_FILE_BAD_SEEK           0xF1A9
#define AFX_IDP_FILE_HARD_IO            0xF1AA
#define AFX_IDP_FILE_SHARING            0xF1AB
#define AFX_IDP_FILE_LOCKING            0xF1AC
#define AFX_IDP_FILE_DISKFULL           0xF1AD
#define AFX_IDP_FILE_EOF                0xF1AE

#define AFX_IDP_ARCH_NONE               0xF1B0
#define AFX_IDP_ARCH_GENERIC            0xF1B1
#define AFX_IDP_ARCH_READONLY           0xF1B2
#define AFX_IDP_ARCH_ENDOFFILE          0xF1B3
#define AFX_IDP_ARCH_WRITEONLY          0xF1B4
#define AFX_IDP_ARCH_BADINDEX           0xF1B5
#define AFX_IDP_ARCH_BADCLASS           0xF1B6
#define AFX_IDP_ARCH_BADSCHEMA          0xF1B7

#define AFX_IDS_OCC_SCALEUNITS_PIXELS   0xF1C0

// 0xf200-0xf20f reserved

// font names and point sizes
#define AFX_IDS_STATUS_FONT             0xF230
#define AFX_IDS_TOOLTIP_FONT            0xF231
#define AFX_IDS_UNICODE_FONT            0xF232
#define AFX_IDS_MINI_FONT               0xF233

// ODBC Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_SQL_FIRST                       0xF280
#endif //!RC_INVOKED
#define AFX_IDP_SQL_CONNECT_FAIL                0xF281
#define AFX_IDP_SQL_RECORDSET_FORWARD_ONLY      0xF282
#define AFX_IDP_SQL_EMPTY_COLUMN_LIST           0xF283
#define AFX_IDP_SQL_FIELD_SCHEMA_MISMATCH       0xF284
#define AFX_IDP_SQL_ILLEGAL_MODE                0xF285
#define AFX_IDP_SQL_MULTIPLE_ROWS_AFFECTED      0xF286
#define AFX_IDP_SQL_NO_CURRENT_RECORD           0xF287
#define AFX_IDP_SQL_NO_ROWS_AFFECTED            0xF288
#define AFX_IDP_SQL_RECORDSET_READONLY          0xF289
#define AFX_IDP_SQL_SQL_NO_TOTAL                0xF28A
#define AFX_IDP_SQL_ODBC_LOAD_FAILED            0xF28B
#define AFX_IDP_SQL_DYNASET_NOT_SUPPORTED       0xF28C
#define AFX_IDP_SQL_SNAPSHOT_NOT_SUPPORTED      0xF28D
#define AFX_IDP_SQL_API_CONFORMANCE             0xF28E
#define AFX_IDP_SQL_SQL_CONFORMANCE             0xF28F
#define AFX_IDP_SQL_NO_DATA_FOUND               0xF290
#define AFX_IDP_SQL_ROW_UPDATE_NOT_SUPPORTED    0xF291
#define AFX_IDP_SQL_ODBC_V2_REQUIRED            0xF292
#define AFX_IDP_SQL_NO_POSITIONED_UPDATES       0xF293
#define AFX_IDP_SQL_LOCK_MODE_NOT_SUPPORTED     0xF294
#define AFX_IDP_SQL_DATA_TRUNCATED              0xF295
#define AFX_IDP_SQL_ROW_FETCH                   0xF296
#define AFX_IDP_SQL_INCORRECT_ODBC              0xF297
#define AFX_IDP_SQL_UPDATE_DELETE_FAILED        0xF298
#define AFX_IDP_SQL_DYNAMIC_CURSOR_NOT_SUPPORTED    0xF299
#define AFX_IDP_SQL_FIELD_NOT_FOUND             0xF29A
#define AFX_IDP_SQL_BOOKMARKS_NOT_SUPPORTED     0xF29B
#define AFX_IDP_SQL_BOOKMARKS_NOT_ENABLED       0xF29C

// ODBC Database strings
#define AFX_IDS_DELETED                   0xF29D

// DAO Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_DAO_FIRST                       0xF2B0
#endif //!RC_INVOKED
#define AFX_IDP_DAO_ENGINE_INITIALIZATION       0xF2B0
#define AFX_IDP_DAO_DFX_BIND                    0xF2B1
#define AFX_IDP_DAO_OBJECT_NOT_OPEN             0xF2B2

// ICDAORecordset::GetRows Errors
//  These are not placed in DAO Errors collection
//  and must be handled directly by MFC.
#define AFX_IDP_DAO_ROWTOOSHORT                 0xF2B3
#define AFX_IDP_DAO_BADBINDINFO                 0xF2B4
#define AFX_IDP_DAO_COLUMNUNAVAILABLE           0xF2B5

/////////////////////////////////////////////////////////////////////////////
// Strings for ISAPI support

#define AFX_IDS_HTTP_TITLE              0xF2D1
#define AFX_IDS_HTTP_NO_TEXT            0xF2D2
#define AFX_IDS_HTTP_BAD_REQUEST        0xF2D3
#define AFX_IDS_HTTP_AUTH_REQUIRED      0xF2D4
#define AFX_IDS_HTTP_FORBIDDEN          0xF2D5
#define AFX_IDS_HTTP_NOT_FOUND          0xF2D6
#define AFX_IDS_HTTP_SERVER_ERROR       0xF2D7
#define AFX_IDS_HTTP_NOT_IMPLEMENTED    0xF2D8

/////////////////////////////////////////////////////////////////////////////
// Strings for Accessibility support for CCheckListBox
#define AFX_IDS_CHECKLISTBOX_UNCHECK	0xF2E1
#define AFX_IDS_CHECKLISTBOX_CHECK		0xF2E2
#define AFX_IDS_CHECKLISTBOX_MIXED		0xF2E3

/////////////////////////////////////////////////////////////////////////////
// Strings for auto-save recovery prompts
#define AFX_IDS_AUTOSAVE_RECOVERY_ASK_1	0xF2E4
#define AFX_IDS_AUTOSAVE_RECOVERY_ASK_2	0xF2E5
#define AFX_IDS_AUTOSAVE_RECOVERY_ASK_3	0xF2E6
#define AFX_IDS_AUTOSAVE_RECOVERY_ASK_4	0xF2E7
#define AFX_IDS_AUTOSAVE_RECOVERY_ASK_5	0xF2E8
#define AFX_IDS_AUTOSAVE_RECOVERY_ASK_6	0xF2E9
#define AFX_IDS_AUTOSAVE_RECOVERED		0xF2EA

/////////////////////////////////////////////////////////////////////////////
// AFX implementation - control IDs (AFX_IDC)

// Parts of dialogs
#define AFX_IDC_LISTBOX                 100
#define AFX_IDC_CHANGE                  101
#define AFX_IDC_BROWSER             102

// for print dialog
#define AFX_IDC_PRINT_DOCNAME           201
#define AFX_IDC_PRINT_PRINTERNAME       202
#define AFX_IDC_PRINT_PORTNAME          203
#define AFX_IDC_PRINT_PAGENUM           204

// Property Sheet control id's (determined with Spy++)
#define ID_APPLY_NOW                    0x3021
#define ID_WIZBACK                      0x3023
#define ID_WIZNEXT                      0x3024
#define ID_WIZFINISH                    0x3025
#define AFX_IDC_TAB_CONTROL             0x3020

/////////////////////////////////////////////////////////////////////////////
// IDRs for standard components

#ifndef RC_INVOKED  // code only
// These are really COMMDLG dialogs, so there usually isn't a resource
// for them, but these IDs are used as help IDs.
#define AFX_IDD_FILEOPEN                28676
#define AFX_IDD_FILESAVE                28677
#define AFX_IDD_FONT                    28678
#define AFX_IDD_COLOR                   28679
#define AFX_IDD_PRINT                   28680
#define AFX_IDD_PRINTSETUP              28681
#define AFX_IDD_FIND                    28682
#define AFX_IDD_REPLACE                 28683
#endif //!RC_INVOKED

// Standard dialogs app should leave alone (0x7801->)
#define AFX_IDD_NEWTYPEDLG              30721
#define AFX_IDD_PRINTDLG                30722
#define AFX_IDD_PREVIEW_TOOLBAR         30723

// Dialogs defined for OLE2UI library
#define AFX_IDD_INSERTOBJECT            30724
#define AFX_IDD_CHANGEICON              30725
#define AFX_IDD_CONVERT                 30726
#define AFX_IDD_PASTESPECIAL            30727
#define AFX_IDD_EDITLINKS               30728
#define AFX_IDD_FILEBROWSE              30729
#define AFX_IDD_BUSY                    30730

#define AFX_IDD_OBJECTPROPERTIES        30732
#define AFX_IDD_CHANGESOURCE            30733

//WinForms
#define AFX_IDD_EMPTYDIALOG				30734

// Standard cursors (0x7901->)
   // AFX_IDC = Cursor resources
#define AFX_IDC_CONTEXTHELP             30977       // context sensitive help
#define AFX_IDC_MAGNIFY                 30978       // print preview zoom
#define AFX_IDC_SMALLARROWS             30979       // splitter
#define AFX_IDC_HSPLITBAR               30980       // splitter
#define AFX_IDC_VSPLITBAR               30981       // splitter
#define AFX_IDC_NODROPCRSR              30982       // No Drop Cursor
#define AFX_IDC_TRACKNWSE               30983       // tracker
#define AFX_IDC_TRACKNESW               30984       // tracker
#define AFX_IDC_TRACKNS                 30985       // tracker
#define AFX_IDC_TRACKWE                 30986       // tracker
#define AFX_IDC_TRACK4WAY               30987       // tracker
#define AFX_IDC_MOVE4WAY                30988       // resize bar (server only)

// Wheel mouse cursors
// NOTE: values must be in this order!  See CScrollView::OnTimer()
#define AFX_IDC_MOUSE_PAN_NW            30998       // pan east
#define AFX_IDC_MOUSE_PAN_N             30999       // pan northeast
#define AFX_IDC_MOUSE_PAN_NE            31000       // pan north
#define AFX_IDC_MOUSE_PAN_W             31001       // pan northwest
#define AFX_IDC_MOUSE_PAN_HV            31002       // pan both axis
#define AFX_IDC_MOUSE_PAN_E             31003       // pan west
#define AFX_IDC_MOUSE_PAN_SW            31004       // pan south-west
#define AFX_IDC_MOUSE_PAN_S             31005       // pan south
#define AFX_IDC_MOUSE_PAN_SE            31006       // pan south-east
#define AFX_IDC_MOUSE_PAN_HORZ          31007       // pan X-axis
#define AFX_IDC_MOUSE_PAN_VERT          31008       // pan Y-axis

// Wheel mouse bitmaps
#define AFX_IDC_MOUSE_ORG_HORZ          31009       // anchor for horz only
#define AFX_IDC_MOUSE_ORG_VERT          31010       // anchor for vert only
#define AFX_IDC_MOUSE_ORG_HV            31011       // anchor for horz/vert
#define AFX_IDC_MOUSE_MASK              31012

// Mini frame window bitmap ID
#define AFX_IDB_MINIFRAME_MENU          30994

// CheckListBox checks bitmap ID
#define AFX_IDB_CHECKLISTBOX_95         30996

// AFX standard accelerator resources
#define AFX_IDR_PREVIEW_ACCEL           30997

// AFX standard ICON IDs (for MFC V1 apps) (0x7A01->)
#define AFX_IDI_STD_MDIFRAME            31233
#define AFX_IDI_STD_FRAME               31234

/////////////////////////////////////////////////////////////////////////////
// AFX OLE control implementation - control IDs (AFX_IDC)

// Font property page
#define AFX_IDC_FONTPROP                1000
#define AFX_IDC_FONTNAMES               1001
#define AFX_IDC_FONTSTYLES              1002
#define AFX_IDC_FONTSIZES               1003
#define AFX_IDC_STRIKEOUT               1004
#define AFX_IDC_UNDERLINE               1005
#define AFX_IDC_SAMPLEBOX               1006

// Color property page
#define AFX_IDC_COLOR_BLACK             1100
#define AFX_IDC_COLOR_WHITE             1101
#define AFX_IDC_COLOR_RED               1102
#define AFX_IDC_COLOR_GREEN             1103
#define AFX_IDC_COLOR_BLUE              1104
#define AFX_IDC_COLOR_YELLOW            1105
#define AFX_IDC_COLOR_MAGENTA           1106
#define AFX_IDC_COLOR_CYAN              1107
#define AFX_IDC_COLOR_GRAY              1108
#define AFX_IDC_COLOR_LIGHTGRAY         1109
#define AFX_IDC_COLOR_DARKRED           1110
#define AFX_IDC_COLOR_DARKGREEN         1111
#define AFX_IDC_COLOR_DARKBLUE          1112
#define AFX_IDC_COLOR_LIGHTBROWN        1113
#define AFX_IDC_COLOR_DARKMAGENTA       1114
#define AFX_IDC_COLOR_DARKCYAN          1115
#define AFX_IDC_COLORPROP               1116
#define AFX_IDC_SYSTEMCOLORS            1117

// Picture porperty page
#define AFX_IDC_PROPNAME                1201
#define AFX_IDC_PICTURE                 1202
#define AFX_IDC_BROWSE                  1203
#define AFX_IDC_CLEAR                   1204

/////////////////////////////////////////////////////////////////////////////
// IDRs for OLE control standard components

// Standard propery page dialogs app should leave alone (0x7E01->)
#define AFX_IDD_PROPPAGE_COLOR         32257
#define AFX_IDD_PROPPAGE_FONT          32258
#define AFX_IDD_PROPPAGE_PICTURE       32259

/////////////////////////////////////////////////////////////////////////////
// Standard OLE control strings

// OLE Control page strings
#define AFX_IDS_PROPPAGE_UNKNOWN        0xFE01
#define AFX_IDS_COLOR_DESKTOP           0xFE04
#define AFX_IDS_COLOR_APPWORKSPACE      0xFE05
#define AFX_IDS_COLOR_WNDBACKGND        0xFE06
#define AFX_IDS_COLOR_WNDTEXT           0xFE07
#define AFX_IDS_COLOR_MENUBAR           0xFE08
#define AFX_IDS_COLOR_MENUTEXT          0xFE09
#define AFX_IDS_COLOR_ACTIVEBAR         0xFE0A
#define AFX_IDS_COLOR_INACTIVEBAR       0xFE0B
#define AFX_IDS_COLOR_ACTIVETEXT        0xFE0C
#define AFX_IDS_COLOR_INACTIVETEXT      0xFE0D
#define AFX_IDS_COLOR_ACTIVEBORDER      0xFE0E
#define AFX_IDS_COLOR_INACTIVEBORDER    0xFE0F
#define AFX_IDS_COLOR_WNDFRAME          0xFE10
#define AFX_IDS_COLOR_SCROLLBARS        0xFE11
#define AFX_IDS_COLOR_BTNFACE           0xFE12
#define AFX_IDS_COLOR_BTNSHADOW         0xFE13
#define AFX_IDS_COLOR_BTNTEXT           0xFE14
#define AFX_IDS_COLOR_BTNHIGHLIGHT      0xFE15
#define AFX_IDS_COLOR_DISABLEDTEXT      0xFE16
#define AFX_IDS_COLOR_HIGHLIGHT         0xFE17
#define AFX_IDS_COLOR_HIGHLIGHTTEXT     0xFE18
#define AFX_IDS_REGULAR                 0xFE19
#define AFX_IDS_BOLD                    0xFE1A
#define AFX_IDS_ITALIC                  0xFE1B
#define AFX_IDS_BOLDITALIC              0xFE1C
#define AFX_IDS_SAMPLETEXT              0xFE1D
#define AFX_IDS_DISPLAYSTRING_FONT      0xFE1E
#define AFX_IDS_DISPLAYSTRING_COLOR     0xFE1F
#define AFX_IDS_DISPLAYSTRING_PICTURE   0xFE20
#define AFX_IDS_PICTUREFILTER           0xFE21
#define AFX_IDS_PICTYPE_UNKNOWN         0xFE22
#define AFX_IDS_PICTYPE_NONE            0xFE23
#define AFX_IDS_PICTYPE_BITMAP          0xFE24
#define AFX_IDS_PICTYPE_METAFILE        0xFE25
#define AFX_IDS_PICTYPE_ICON            0xFE26
#define AFX_IDS_COLOR_PPG               0xFE28
#define AFX_IDS_COLOR_PPG_CAPTION       0xFE29
#define AFX_IDS_FONT_PPG                0xFE2A
#define AFX_IDS_FONT_PPG_CAPTION        0xFE2B
#define AFX_IDS_PICTURE_PPG             0xFE2C
#define AFX_IDS_PICTURE_PPG_CAPTION     0xFE2D
#define AFX_IDS_PICTUREBROWSETITLE      0xFE30
#define AFX_IDS_BORDERSTYLE_0           0xFE31
#define AFX_IDS_BORDERSTYLE_1           0xFE32

// OLE Control verb names
#define AFX_IDS_VERB_EDIT               0xFE40
#define AFX_IDS_VERB_PROPERTIES         0xFE41

// OLE Control internal error messages
#define AFX_IDP_PICTURECANTOPEN         0xFE83
#define AFX_IDP_PICTURECANTLOAD         0xFE84
#define AFX_IDP_PICTURETOOLARGE         0xFE85
#define AFX_IDP_PICTUREREADFAILED       0xFE86

// Standard OLE Control error strings
#define AFX_IDP_E_ILLEGALFUNCTIONCALL       0xFEA0
#define AFX_IDP_E_OVERFLOW                  0xFEA1
#define AFX_IDP_E_OUTOFMEMORY               0xFEA2
#define AFX_IDP_E_DIVISIONBYZERO            0xFEA3
#define AFX_IDP_E_OUTOFSTRINGSPACE          0xFEA4
#define AFX_IDP_E_OUTOFSTACKSPACE           0xFEA5
#define AFX_IDP_E_BADFILENAMEORNUMBER       0xFEA6
#define AFX_IDP_E_FILENOTFOUND              0xFEA7
#define AFX_IDP_E_BADFILEMODE               0xFEA8
#define AFX_IDP_E_FILEALREADYOPEN           0xFEA9
#define AFX_IDP_E_DEVICEIOERROR             0xFEAA
#define AFX_IDP_E_FILEALREADYEXISTS         0xFEAB
#define AFX_IDP_E_BADRECORDLENGTH           0xFEAC
#define AFX_IDP_E_DISKFULL                  0xFEAD
#define AFX_IDP_E_BADRECORDNUMBER           0xFEAE
#define AFX_IDP_E_BADFILENAME               0xFEAF
#define AFX_IDP_E_TOOMANYFILES              0xFEB0
#define AFX_IDP_E_DEVICEUNAVAILABLE         0xFEB1
#define AFX_IDP_E_PERMISSIONDENIED          0xFEB2
#define AFX_IDP_E_DISKNOTREADY              0xFEB3
#define AFX_IDP_E_PATHFILEACCESSERROR       0xFEB4
#define AFX_IDP_E_PATHNOTFOUND              0xFEB5
#define AFX_IDP_E_INVALIDPATTERNSTRING      0xFEB6
#define AFX_IDP_E_INVALIDUSEOFNULL          0xFEB7
#define AFX_IDP_E_INVALIDFILEFORMAT         0xFEB8
#define AFX_IDP_E_INVALIDPROPERTYVALUE      0xFEB9
#define AFX_IDP_E_INVALIDPROPERTYARRAYINDEX 0xFEBA
#define AFX_IDP_E_SETNOTSUPPORTEDATRUNTIME  0xFEBB
#define AFX_IDP_E_SETNOTSUPPORTED           0xFEBC
#define AFX_IDP_E_NEEDPROPERTYARRAYINDEX    0xFEBD
#define AFX_IDP_E_SETNOTPERMITTED           0xFEBE
#define AFX_IDP_E_GETNOTSUPPORTEDATRUNTIME  0xFEBF
#define AFX_IDP_E_GETNOTSUPPORTED           0xFEC0
#define AFX_IDP_E_PROPERTYNOTFOUND          0xFEC1
#define AFX_IDP_E_INVALIDCLIPBOARDFORMAT    0xFEC2
#define AFX_IDP_E_INVALIDPICTURE            0xFEC3
#define AFX_IDP_E_PRINTERERROR              0xFEC4
#define AFX_IDP_E_CANTSAVEFILETOTEMP        0xFEC5
#define AFX_IDP_E_SEARCHTEXTNOTFOUND        0xFEC6
#define AFX_IDP_E_REPLACEMENTSTOOLONG       0xFEC7

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXRES_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxribbonbutton.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxbaseribbonelement.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#define AFX_RIBBON_IMAGE_AUTO 9999

class CMFCRibbonButton : public CMFCRibbonBaseElement
{
	friend class CMFCRibbonPanel;
	friend class CMFCRibbonPanelMenuBar;
	friend class CMFCToolTipCtrl;
	friend class CMFCRibbonCollector;
	friend class CMFCRibbonConstructor;

	DECLARE_DYNCREATE(CMFCRibbonButton)

// Construction
public:
	CMFCRibbonButton();
	CMFCRibbonButton(UINT nID, LPCTSTR lpszText, int nSmallImageIndex = -1, int nLargeImageIndex = -1, BOOL bAlwaysShowDescription = FALSE);
	CMFCRibbonButton(UINT nID, LPCTSTR lpszText, HICON hIcon, BOOL bAlwaysShowDescription = FALSE, HICON hIconSmall = NULL, BOOL bAutoDestroyIcon = FALSE, BOOL bAlphaBlendIcon = FALSE);

	virtual ~CMFCRibbonButton();

// Attributes
public:
	virtual void SetText(LPCTSTR lpszText);
	virtual void SetDescription(LPCTSTR lpszText);

	virtual BOOL IsDefaultPanelButton() const { return FALSE; }
	virtual BOOL IsApplicationButton() const { return FALSE; }

	void SetMenu(HMENU hMenu, BOOL bIsDefaultCommand = FALSE, BOOL bRightAlign = FALSE);
	void SetMenu(UINT uiMenuResID, BOOL bIsDefaultCommand = FALSE, BOOL bRightAlign = FALSE);
	HMENU GetMenu() const { return m_hMenu; }

	void SetDefaultCommand(BOOL bSet = TRUE) { m_bIsDefaultCommand = bSet; }
	BOOL IsDefaultCommand() const { return m_bIsDefaultCommand; }

	void SetRightAlignMenu(BOOL bSet = TRUE) { m_bRightAlignMenu = bSet; }
	BOOL IsRightAlignMenu() const { return m_bRightAlignMenu; }

	virtual BOOL HasMenu() const { return m_hMenu != NULL || m_arSubItems.GetSize() > 0; }

	virtual BOOL IsCommandAreaHighlighted() const { return m_bIsCommandHighlighted && IsHighlighted(); }
	virtual BOOL IsMenuAreaHighlighted() const { return m_bIsMenuHighlighted && IsHighlighted(); }

	CRect GetMenuRect() const { return m_rectMenu; }
	CRect GetCommandRect() const { return m_rectCommand; }

	BOOL IsMenuOnBottom() const { return m_bMenuOnBottom; }
	virtual BOOL IsAlwaysDrawBorder() const { return m_bForceDrawBorder; }

	virtual BOOL CanBeStretched();

	BOOL IsSingleLineText() const { return m_sizeTextBottom.cy == m_sizeTextRight.cy; }
	int GetTextRowHeight() const { return m_sizeTextRight.cy; }

	const CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& GetSubItems() const { return m_arSubItems; }

	int GetImageIndex(BOOL bLargeImage) const { return bLargeImage ? m_nLargeImageIndex : m_nSmallImageIndex; }
	void SetImageIndex(int nIndex, BOOL bLargeImage)
	{
		if (bLargeImage)
		{
			m_nLargeImageIndex = nIndex;
		}
		else
		{
			m_nSmallImageIndex = nIndex;
		}
	}

	BOOL IsLargeImage() const { return m_bIsLargeImage; }
	HICON GetIcon(BOOL bLargeIcon = TRUE) const { return bLargeIcon ? m_hIcon : m_hIconSmall; }

	virtual BOOL IsAlwaysLargeImage () const { return m_bIsAlwaysLarge || (m_nLargeImageIndex >= 0 && m_nSmallImageIndex < 0); }
	void SetAlwaysLargeImage(BOOL bSet = TRUE) { m_bIsAlwaysLarge = bSet; }

	virtual BOOL SetACCData(CWnd* pParent, CAccessibilityData& data);

	AFX_IMPORT_DATA static BOOL m_bUseMenuHandle;

// Operations
public:
	void AddSubItem(CMFCRibbonBaseElement* pSubItem, int nIndex = -1);
	int FindSubItemIndexByID(UINT uiID) const;
	BOOL RemoveSubItem(int nIndex);
	void RemoveAllSubItems();

	CSize DrawBottomText(CDC* pDC, BOOL bCalcOnly);

protected:
	void CommonInit();
	void FillWindowList();
	int GetGroupButtonExtraWidth();

// Overrides
public:
	virtual void OnDraw(CDC* pDC);

	virtual CSize GetRegularSize(CDC* pDC);
	virtual CSize GetCompactSize(CDC* pDC);
	virtual CSize GetIntermediateSize(CDC* pDC);

	virtual BOOL HasLargeMode() const { return GetImageSize(RibbonImageLarge) != CSize(0, 0); }
	virtual BOOL HasIntermediateMode() const { return !m_strText.IsEmpty(); }
	virtual BOOL HasCompactMode() const { return GetImageSize(RibbonImageSmall) != CSize(0, 0); }

	virtual void DrawImage(CDC* pDC, RibbonImageType type, CRect rectImage);
	virtual CSize GetImageSize(RibbonImageType type) const;

	virtual void OnCalcTextSize(CDC* pDC);
	virtual void CleanUpSizes() { m_sizeTextRight = m_sizeTextBottom = CSize(0, 0); }

	virtual void SetParentCategory(CMFCRibbonCategory* pParent);

	virtual void ClosePopupMenu();
	virtual CString GetToolTipText() const;

	virtual int DrawRibbonText(CDC* pDC, const CString& strText, CRect rectText, UINT uiDTFlags, COLORREF clrText = (COLORREF)-1);

	virtual void OnClick(CPoint point);

	virtual BOOL IsDrawTooltipImage() const { return TRUE; }
	virtual BOOL IsPopupDefaultMenuLook() const { return TRUE; }

	virtual COLORREF OnFillBackground(CDC* pDC);
	virtual void OnDrawBorder(CDC* pDC);

protected:
	virtual void OnDrawOnList(CDC* pDC, CString strText, int nTextOffset, CRect rect, BOOL bIsSelected, BOOL bHighlighted);
	virtual int AddToListBox(CMFCRibbonCommandsListBox* pWndListBox, BOOL bDeep);

	virtual void OnLButtonDown(CPoint point);
	virtual void OnLButtonUp(CPoint point);
	virtual void OnMouseMove(CPoint point);

	virtual void OnShowPopupMenu();

	virtual void CopyFrom(const CMFCRibbonBaseElement& src);
	virtual void SetOriginal(CMFCRibbonBaseElement* pOriginal);

	virtual CMFCRibbonBaseElement* FindByID(UINT uiCmdID);
	virtual CMFCRibbonBaseElement* FindByData(DWORD_PTR dwData);

	virtual void GetElementsByID(UINT uiCmdID, CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arElements);
	virtual void GetElements(CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arElements);

	virtual int GetTextOffset() const { return m_szMargin.cx; }

	virtual void SetParentRibbonBar(CMFCRibbonBar* pRibbonBar);
	virtual CRect GetKeyTipRect(CDC* pDC, BOOL bIsMenu);
	virtual BOOL OnKey(BOOL bIsMenuKey);

	virtual void OnAfterChangeRect(CDC* pDC);

	virtual void SetMargin(const CSize& sizeMargin) { m_szMargin = sizeMargin; }

// Attributes
protected:
	CSize m_sizeTextRight;
	CSize m_sizeTextBottom;
	CSize m_szMargin;
	CRect m_rectMenu;
	CRect m_rectCommand;

	int m_nSmallImageIndex;
	int m_nLargeImageIndex;
	int m_nMenuArrowMargin;
	int m_nWindowsMenuItems;
	int m_nWrapIndex;

	HMENU m_hMenu;
	HICON m_hIcon;
	HICON m_hIconSmall;

	BOOL m_bRightAlignMenu;
	BOOL m_bIsDefaultCommand;
	BOOL m_bAutodestroyMenu;
	BOOL m_bMenuOnBottom;
	BOOL m_bIsMenuHighlighted;
	BOOL m_bIsCommandHighlighted;
	BOOL m_bAutoDestroyIcon;
	BOOL m_bAlphaBlendIcon;
	BOOL m_bForceDrawBorder;
	BOOL m_bToBeClosed;
	BOOL m_bAlwaysShowDescription;
	BOOL m_bIsLargeImage;
	BOOL m_bCreatedFromMenu;
	BOOL m_bIsWindowsMenu;

	CArray<int,int> m_arWordIndexes;
	CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*> m_arSubItems;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxribboncheckbox.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxribbonbutton.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCRibbonCheckBox : public CMFCRibbonButton  
{
	DECLARE_DYNCREATE(CMFCRibbonCheckBox)

// Construction
public:
	CMFCRibbonCheckBox();
	CMFCRibbonCheckBox(UINT nID, LPCTSTR lpszText);

	virtual ~CMFCRibbonCheckBox();

// Overrides
public:
	virtual CSize GetIntermediateSize(CDC* pDC);

	virtual CSize GetCompactSize(CDC* pDC) { return GetIntermediateSize(pDC); }
	virtual CSize GetRegularSize(CDC* pDC) { return GetIntermediateSize(pDC); }

	virtual void OnDraw(CDC* pDC);
	virtual void OnDrawOnList(CDC* pDC, CString strText, int nTextOffset, CRect rect, BOOL bIsSelected, BOOL bHighlighted);

	virtual BOOL OnDrawMenuImage(CDC* /*pDC*/, CRect /*rect*/) { return FALSE; }
	virtual BOOL IsDrawTooltipImage() const { return FALSE; }

	virtual BOOL SetACCData(CWnd* pParent, CAccessibilityData& data)
	{
		CMFCRibbonButton::SetACCData(pParent, data);
		data.m_strAccDefAction = IsChecked() ? _T("Uncheck") : _T("Check");
		data.m_nAccRole = ROLE_SYSTEM_CHECKBUTTON;

		return TRUE;
	}
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxribboncategory.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxbaseribbonelement.h"
#include "afxtoolbarimages.h"
#include "afxribbonbar.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonTab

class CMFCRibbonCategory;

class CMFCRibbonTab : public CMFCRibbonBaseElement
{
	DECLARE_DYNAMIC(CMFCRibbonTab)

	friend class CMFCRibbonCategory;
	friend class CMFCRibbonBar;

	CMFCRibbonTab();
	virtual void OnDraw(CDC* pDC);
	virtual CSize GetRegularSize(CDC* pDC);
	virtual void OnLButtonDown(CPoint point);
	virtual void OnLButtonDblClk(CPoint point);
	virtual CString GetToolTipText() const;
	virtual void CopyFrom(const CMFCRibbonBaseElement& src);
	virtual CRect GetKeyTipRect(CDC* pDC, BOOL bIsMenu);
	virtual BOOL OnKey(BOOL bIsMenuKey);
	virtual BOOL IsShowTooltipOnBottom() const { return FALSE; }
	virtual void Redraw();

	AFX_RibbonCategoryColor m_Color;
	BOOL m_bIsTruncated;
	int  m_nFullWidth;

public:
	BOOL IsSelected() const;

	virtual BOOL SetACCData(CWnd* pParent, CAccessibilityData& data);
};

/////////////////////////////////////////////////////////////////////////////////
// CRibbonCategoryScroll

class CRibbonCategoryScroll : public CMFCRibbonButton
{
	friend class CMFCRibbonCategory;

	CRibbonCategoryScroll();

	virtual void OnMouseMove(CPoint point);
	virtual void OnDraw(CDC* pDC);
	virtual BOOL OnAutoRepeat();

	virtual BOOL IsAutoRepeatMode(int& /*nDelay*/) const { return TRUE; }
	virtual void CopyFrom(const CMFCRibbonBaseElement& src);
	virtual void OnClick(CPoint /*point*/) { OnAutoRepeat(); }

	BOOL	m_bIsLeft;

public:
	BOOL IsLeftScroll() const { return m_bIsLeft; }
};

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonCategory

class CMFCRibbonPanel;
class CMFCRibbonBar;

class CMFCRibbonCategory : public CObject
{
	friend class CMFCRibbonBar;
	friend class CMFCRibbonTab;
	friend class CMFCRibbonPanel;
	friend class CMFCRibbonPanelMenuBar;
	friend class CMFCRibbonBaseElement;
	friend class CMFCRibbonCollector;

	DECLARE_DYNCREATE(CMFCRibbonCategory)

// Construction
protected:
	CMFCRibbonCategory();

	CMFCRibbonCategory(CMFCRibbonBar* pParentRibbonBar, LPCTSTR lpszName, UINT uiSmallImagesResID,
		UINT uiLargeImagesResID, CSize sizeSmallImage = CSize(16, 16), CSize sizeLargeImage = CSize(32, 32));

	void CommonInit(CMFCRibbonBar* pParentRibbonBar = NULL, LPCTSTR lpszName = NULL,
		UINT uiSmallImagesResID = 0, UINT uiLargeImagesResID = 0, CSize sizeSmallImage = CSize(0, 0), CSize sizeLargeImage = CSize(0, 0));

// Attributes
public:
	CMFCRibbonBar* GetParentRibbonBar() const { return m_pParentRibbonBar; }
	CMFCRibbonPanelMenuBar* GetParentMenuBar() const { return m_pParentMenuBar; }

	CMFCRibbonBaseElement* HitTest(CPoint point, BOOL bCheckPanelCaption = FALSE) const;
	CMFCRibbonBaseElement* HitTestScrollButtons(CPoint point) const;
	int HitTestEx(CPoint point) const;
	CMFCRibbonPanel* GetPanelFromPoint(CPoint point) const;

	/// <summary>
	/// Obtain a first visible element that belong to the ribbon category</summary>
	/// <returns> 
	/// Pointer to the first visible element; may be NULL if category doesn't have any visible elements</returns>
	CMFCRibbonBaseElement* GetFirstVisibleElement() const;

	/// <summary>
	/// Obtain a last visible element that belong to the ribbon category</summary>
	/// <returns> 
	/// Pointer to the last visible element; may be NULL if category doesn't have any visible elements</returns>
	CMFCRibbonBaseElement* GetLastVisibleElement() const;

	CRect GetTabRect() const { return m_Tab.m_rect; }
	CRect GetRect() const { return m_rect; }

	BOOL IsActive() const { return m_bIsActive; }

	CSize GetImageSize(BOOL bIsLargeImage) const;

	int GetImageCount(BOOL bIsLargeImage) const
	{
		return bIsLargeImage ? m_LargeImages.GetCount() : m_SmallImages.GetCount();
	}

	LPCTSTR GetName() const { return m_strName; }
	void SetName(LPCTSTR lpszName);

	DWORD_PTR GetData() const { return m_dwData; }
	void SetData(DWORD_PTR dwData) { m_dwData = dwData; }

	UINT GetContextID() const { return m_uiContextID; }

	void SetTabColor(AFX_RibbonCategoryColor color) { m_Tab.m_Color = color; }
	AFX_RibbonCategoryColor GetTabColor() const { return m_Tab.m_Color; }

	BOOL IsVisible() const { return m_bIsVisible; }

	CMFCRibbonBaseElement* GetDroppedDown();

	/// <summary>
	/// Returns a focused element. </summary>
	/// <returns> A pointer to a focused element or NULL if no elements are focused.</returns>
	CMFCRibbonBaseElement* GetFocused();

	/// <summary>
	/// Returns a highlighted element. </summary>
	/// <returns> A pointer to a highlighted element or NULL if no elements are highlighted.</returns>
	CMFCRibbonBaseElement* GetHighlighted();
	CMFCRibbonBaseElement* GetParentButton() const;

	CMFCToolBarImages& GetSmallImages() { return m_SmallImages; }
	CMFCToolBarImages& GetLargeImages() { return m_LargeImages; }

	void SetKeys(LPCTSTR lpszKeys);

	/// <summary>
	/// Indicates whether the parent ribbon has Windows 7-style look (small rectangular application button)</summary>
	/// <returns> 
	/// TRUE if the parent ribbon has Windows 7-style look; otherwise FALSE.</returns>
	BOOL IsWindows7Look() const;

// Operations
public:
	CMFCRibbonPanel* AddPanel(LPCTSTR lpszPanelName, HICON hIcon = 0, CRuntimeClass* pRTI = NULL);
	BOOL RemovePanel (int nIndex, BOOL bDelete = TRUE);

	void SetCollapseOrder(const CArray<int, int>& arCollapseOrder);
	
	int GetPanelCount() const;
	CMFCRibbonPanel* GetPanel(int nIndex);

	int GetPanelIndex(const CMFCRibbonPanel* pPanel) const;

	int GetMaxHeight(CDC* pDC);

	CMFCRibbonBaseElement* FindByID(UINT uiCmdID, BOOL bVisibleOnly = TRUE) const;
	CMFCRibbonBaseElement* FindByData(DWORD_PTR dwData, BOOL bVisibleOnly = TRUE) const;

	CMFCRibbonPanel* HighlightPanel(CMFCRibbonPanel* pHLPanel, CPoint point);
	CMFCRibbonPanel* FindPanelWithElem(const CMFCRibbonBaseElement* pElement);

	void AddHidden(CMFCRibbonBaseElement* pElem);

	void GetElements(CArray <CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arElements);
	void GetElementsByID(UINT uiCmdID, CArray <CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arElements);

	/// <summary>
	/// Obtain all visible elements that belong to the ribbon category</summary>
	/// <param name="arElements">Array of all visible elements</param>
	void GetVisibleElements(CArray <CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arElements);

	void GetItemIDsList(CList<UINT,UINT>& lstItems, BOOL bHiddenOnly = FALSE) const;

	int GetTextTopLine() const;

// Overrides
	virtual void RecalcLayout(CDC* pDC);
	virtual void OnDraw(CDC* pDC);
	virtual void OnCancelMode();
	virtual CMFCRibbonBaseElement* OnLButtonDown(CPoint point);
	virtual void OnLButtonUp(CPoint point);
	virtual void OnMouseMove(CPoint point);
	virtual void OnUpdateCmdUI(CMFCRibbonCmdUI* pCmdUI, CFrameWnd* pTarget, BOOL bDisableIfNoHndler);

	virtual BOOL NotifyControlCommand(BOOL bAccelerator, int nNotifyCode, WPARAM wParam, LPARAM lParam);
	virtual BOOL OnDrawImage(CDC* pDC, CRect rect, CMFCRibbonBaseElement* pElement, BOOL bIsLargeImage, BOOL nImageIndex, BOOL bCenter);

	virtual void CopyFrom(CMFCRibbonCategory& src);
	virtual void OnDrawMenuBorder(CDC* /*pDC*/, CMFCRibbonPanelMenuBar* /*pMenuBar*/)	{}
	virtual void OnRTLChanged(BOOL bIsRTL);

	virtual BOOL OnScrollHorz(BOOL bScrollLeft, int nScrollOffset = 0);
	virtual void ReposPanels(CDC* pDC);

	/// <summary>
	// Called by the framework when a user presses a keyboard button.</summary>
	/// <param name="nChar">The virtual-key code for the key that a user pressed.</param>
	virtual BOOL OnKey(UINT nChar);

// Implementation
public:
	virtual ~CMFCRibbonCategory();

protected:
	void SetActive(BOOL bIsActive = TRUE);
	void ShowElements(BOOL bShow = TRUE);

	void ShowFloating(CRect rectFloating);

	void RecalcPanelWidths(CDC* pDC);
	void CleanUpSizes();
	int GetMinWidth(CDC* pDC);

	BOOL SetPanelsLayout(int nWidth);
	void ResetPanelsLayout();

	void UpdateScrollButtons();
	void EnsureVisible(CMFCRibbonButton* pButton);

	BOOL m_bMouseIsPressed;
	BOOL m_bIsActive;
	BOOL m_bIsVisible;
	UINT m_uiContextID;
	int  m_nLastCategoryWidth;
	int  m_nLastCategoryOffsetY;

	DWORD_PTR             m_dwData;
	CRect                 m_rect;
	CString               m_strName;
	CMFCRibbonTab         m_Tab;
	CRibbonCategoryScroll m_ScrollLeft;
	CRibbonCategoryScroll m_ScrollRight;
	int                   m_nScrollOffset;
	CMFCRibbonBar*        m_pParentRibbonBar;

	CMFCRibbonPanelMenuBar* m_pParentMenuBar;

	int    m_nMinWidth;
	CArray<int, int>   m_arCollapseOrder;
	CArray<CMFCRibbonPanel*,CMFCRibbonPanel*> m_arPanels;

	clock_t  m_ActiveTime;

	//----------------------
	// Category image lists:
	//----------------------
	CMFCToolBarImages m_SmallImages;
	CMFCToolBarImages m_LargeImages;

	//---------------------------------
	// Category elements (non-visible):
	//---------------------------------
	CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*> m_arElements;

	UINT m_uiSmallImagesResID;
	UINT m_uiLargeImagesResID;

private:
	void NormalizeFloatingRect(CMFCRibbonBar* pRibbonBar, CRect& rectCategory);
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxribboncolorbutton.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxcolorbar.h"
#include "afxribbonpalettegallery.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCRibbonColorButton : public CMFCRibbonGallery  
{
	friend class CMFCColorBar;
	friend class CMFCRibbonColorMenuButton;
	friend class CMFCRibbonCollector;
	friend class CMFCRibbonConstructor;

	DECLARE_DYNCREATE(CMFCRibbonColorButton)

// Construction:
public:
	CMFCRibbonColorButton();
	CMFCRibbonColorButton(UINT nID, LPCTSTR lpszText, int nSmallImageIndex, COLORREF color = RGB(0, 0, 0));
	CMFCRibbonColorButton(UINT nID, LPCTSTR lpszText, BOOL bSimpleButtonLook, int nSmallImageIndex, int nLargeImageIndex, COLORREF color = RGB(0, 0, 0));

	virtual ~CMFCRibbonColorButton();

protected:
	void CommonInit();

// Attributes:
public:
	void EnableAutomaticButton(LPCTSTR lpszLabel, COLORREF colorAutomatic, BOOL bEnable = TRUE, LPCTSTR lpszToolTip = NULL, BOOL bOnTop = TRUE, BOOL bDrawBorder = FALSE);
	void EnableOtherButton(LPCTSTR lpszLabel, LPCTSTR lpszToolTip = NULL);
	
	void SetDocumentColors(LPCTSTR lpszLabel, CList<COLORREF,COLORREF>& lstColors);

	static void __stdcall SetColorName(COLORREF color, const CString& strName) { CMFCColorBar::SetColorName(color, strName); }
	COLORREF GetAutomaticColor() const { return m_ColorAutomatic; }
	void SetColor(COLORREF color) { m_Color = color; }
	COLORREF GetColor() const { return m_Color; }

	void SetPalette(CPalette* pPalette);

	int GetColumns() const { return m_nIconsInRow; }
	void SetColumns(int nColumns) { m_nPanelColumns = m_nIconsInRow = nColumns; }

	COLORREF GetHighlightedColor() const;

	void SetColorBoxSize(CSize sizeBox);
	CSize GetColorBoxSize() const { return m_sizeBox; }

	virtual BOOL IsSimpleButtonLook() const { return m_bSimpleButtonLook; }

protected:
	virtual BOOL HasMenu() const { return TRUE; }

// Opeartions:
public:
	void AddColorsGroup(LPCTSTR lpszName, const CList<COLORREF,COLORREF>& lstColors, BOOL bContiguousColumns = FALSE);
	void RemoveAllColorGroups();

	void UpdateColor(COLORREF color);

	virtual BOOL SetACCData(CWnd* pParent, CAccessibilityData& data);

protected:
	COLORREF GetColorByIndex(int nIconIndex) const;

// Overrides
protected:
	virtual void OnDrawPaletteIcon(CDC* pDC, CRect rectIcon, int nIconIndex, CMFCRibbonGalleryIcon* pIcon, COLORREF clrText);
	virtual void DrawImage(CDC* pDC, RibbonImageType type, CRect rectImage);
	virtual void CopyFrom(const CMFCRibbonBaseElement& src);
	virtual void OnShowPopupMenu();
	virtual BOOL OnClickPaletteSubItem(CMFCRibbonButton* pButton, CMFCRibbonPanelMenuBar* pMenuBar);
	virtual void OnClickPaletteIcon(CMFCRibbonGalleryIcon* pIcon);
	virtual void NotifyHighlightListItem(int nIndex);
	virtual CString GetIconToolTip(const CMFCRibbonGalleryIcon* pIcon) const;

	virtual int GetGroupOffset() const { return 2; }

	COLORREF m_Color; // Currently selected color
	COLORREF m_ColorHighlighted;
	COLORREF m_ColorAutomatic;

	CArray<COLORREF, COLORREF> m_Colors;
	CArray<COLORREF, COLORREF> m_DocumentColors;
	CArray<LPARAM, LPARAM>     m_arContColumnsRanges;

	BOOL m_bIsAutomaticButton;
	BOOL m_bIsAutomaticButtonOnTop;
	BOOL m_bIsAutomaticButtonBorder;
	BOOL m_bIsOtherButton;
	BOOL m_bHasGroups;
	BOOL m_bSimpleButtonLook;

	CString m_strAutomaticButtonLabel;
	CString m_strAutomaticButtonToolTip;
	CString m_strOtherButtonLabel;
	CString m_strOtherButtonToolTip;
	CString m_strDocumentColorsLabel;

	CMFCRibbonButton* m_pOtherButton;
	CMFCRibbonButton* m_pAutoButton;

	CSize m_sizeBox;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxribboncombobox.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.


#pragma once

#include "afxribbonedit.h"
#include "afxtoolbarfontcombobox.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCRibbonRichEditCtrl;

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonComboBox

class CMFCRibbonComboBox : public CMFCRibbonEdit
{
	friend class CMFCDropDownListBox;
	friend class CMFCRibbonConstructor;

	DECLARE_DYNCREATE(CMFCRibbonComboBox)

// Construction:
public:
	CMFCRibbonComboBox(UINT nID, BOOL bHasEditBox = TRUE, int nWidth = -1, LPCTSTR lpszLabel = NULL, int nImage = -1);
	virtual ~CMFCRibbonComboBox();

protected:
	CMFCRibbonComboBox();

// Attributes:
public:
	void EnableDropDownListResize(BOOL bEnable = FALSE) { m_bResizeDropDownList = bEnable; }
	BOOL IsResizeDropDownList() const { return m_bResizeDropDownList; }

// Operations:
public:
	virtual INT_PTR AddItem(LPCTSTR lpszItem, DWORD_PTR dwData = 0);
	INT_PTR GetCount() const { return m_lstItems.GetCount(); }

	LPCTSTR GetItem(int iIndex) const;
	DWORD_PTR GetItemData(int iIndex) const;

	int GetCurSel() const { return m_iSelIndex; }

	void RemoveAllItems();

	BOOL SelectItem(int iIndex);
	BOOL SelectItem(DWORD_PTR dwData);
	BOOL SelectItem(LPCTSTR lpszText);

	BOOL DeleteItem(int iIndex);
	BOOL DeleteItem(DWORD_PTR dwData);
	BOOL DeleteItem(LPCTSTR lpszText);

	int FindItem(LPCTSTR lpszText) const;

	int GetDropDownHeight() const { return m_nDropDownHeight; }
	void SetDropDownHeight(int nHeight);

	BOOL HasEditBox() const { return m_bHasEditBox; }

// Overrides
public:
	virtual CSize GetIntermediateSize(CDC* pDC);
	virtual void OnSelectItem(int nItem);

protected:
	virtual void OnDraw(CDC* pDC);

	virtual void OnLButtonDown(CPoint point);
	virtual void OnLButtonUp(CPoint point);

	virtual void CopyFrom(const CMFCRibbonBaseElement& src);
	virtual BOOL HasMenu() const { return TRUE; }
	virtual BOOL CanBeStretched() { return FALSE; }

	virtual void OnAfterChangeRect(CDC* pDC);

	virtual void DropDownList();
	void CommonInit();

	virtual void ClearData();

	virtual BOOL OnDrawDropListItem(CDC* pDC, int nIndex, CMFCToolBarMenuButton* pItem, BOOL bHighlight);
	virtual CSize OnGetDropListItemSize(CDC* pDC, int nIndex, CMFCToolBarMenuButton* pItem, CSize sizeDefault);

// Attributes:
protected:
	CStringList                 m_lstItems;
	CList<DWORD_PTR, DWORD_PTR> m_lstItemData;

	int m_iSelIndex;
	int m_nDropDownHeight;

	BOOL m_bHasEditBox;
	BOOL m_bResizeDropDownList;
};

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonFontComboBox

class CMFCRibbonFontComboBox : public CMFCRibbonComboBox  
{
	DECLARE_DYNCREATE(CMFCRibbonFontComboBox)

// Construction:
public:
	CMFCRibbonFontComboBox(UINT nID, int nFontType = DEVICE_FONTTYPE | RASTER_FONTTYPE | TRUETYPE_FONTTYPE,
		BYTE nCharSet = DEFAULT_CHARSET, BYTE nPitchAndFamily = DEFAULT_PITCH, int nWidth = -1);

	virtual ~CMFCRibbonFontComboBox();

protected:
	CMFCRibbonFontComboBox();

// Operations:
public:
	BOOL SetFont(LPCTSTR lpszName, BYTE nCharSet = DEFAULT_CHARSET, BOOL bExact = FALSE);
	const CMFCFontInfo* GetFontDesc(int iIndex = -1) const
	{
		return (CMFCFontInfo*) GetItemData(iIndex);
	}

	void BuildFonts(int nFontType = DEVICE_FONTTYPE | RASTER_FONTTYPE | TRUETYPE_FONTTYPE, BYTE nCharSet = DEFAULT_CHARSET, BYTE nPitchAndFamily = DEFAULT_PITCH);
	void RebuildFonts();

	/// <summary>
	/// Returns which font types to display in the combo box. Valid options are DEVICE_FONTTYPE, RASTER_FONTTYPE, and TRUETYPE_FONTTYPE, or any bitwise combination thereof.</summary>
	/// <returns> 
	/// Font types ( see EnumFontFamProc in the Windows SDK documentation).</returns>
	int GetFontType() const { return m_nFontType; }

	/// <summary>
	/// Returns the specified character set.</summary>
	/// <returns> 
	/// Characters set (see LOGFONT in the Windows SDK documentation).</returns>
	BYTE GetCharSet() const { return m_nCharSet; }

	/// <summary>
	/// Returns the pitch and the family of the fonts that are displayed in the combo box.</summary>
	/// <returns> 
	/// Pitch and the family (see LOGFONT in the Windows SDK documentation).</returns>
	BYTE GetPitchAndFamily() const { return m_nPitchAndFamily; }

protected:
	int GetFontsCount(LPCTSTR lpszName, const CObList& lstFonts);

// Overrides
protected:
	virtual void CopyFrom(const CMFCRibbonBaseElement& src);
	virtual void ClearData();
	virtual void DropDownList();

	virtual BOOL OnDrawDropListItem(CDC* pDC, int nIndex, CMFCToolBarMenuButton* pItem, BOOL bHighlight);
	virtual CSize OnGetDropListItemSize(CDC* pDC, int nIndex, CMFCToolBarMenuButton* pItem, CSize sizeDefault);

// Attributes:
public:
	AFX_IMPORT_DATA static BOOL m_bDrawUsingFont;

protected:
	int  m_nFontType;
	BYTE m_nCharSet;
	BYTE m_nPitchAndFamily;

	CImageList m_Images;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxribboncommandslistbox.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCRibbonBar;
class CMFCRibbonBaseElement;
class CMFCRibbonCategory;
class CMFCRibbonSeparator;

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonCommandsListBox window

class CMFCRibbonCommandsListBox : public CListBox
{
// Construction
public:
	CMFCRibbonCommandsListBox(	CMFCRibbonBar* pRibbonBar, BOOL bIncludeSeparator = TRUE, BOOL bDrawDefaultIcon = FALSE);

// Attributes
public:
	CMFCRibbonBaseElement* GetSelected() const;
	CMFCRibbonBaseElement* GetCommand(int nIndex) const;
	int GetCommandIndex(UINT uiID) const;

protected:
	int               m_nTextOffset;
	BOOL              m_bDrawDefaultIcon;
	CMFCRibbonBar*       m_pRibbonBar;
	CMFCRibbonSeparator* m_pSeparator;

// Operations
public:
	void FillFromCategory(CMFCRibbonCategory* pCategory);
	void FillFromIDs(const CList<UINT,UINT>& lstCommands, BOOL bDeep);
	void FillFromArray(const CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arElements, BOOL bDeep, BOOL bIgnoreSeparators);
	void FillAll();

	BOOL AddCommand(CMFCRibbonBaseElement* pCmd, BOOL bSelect = TRUE, BOOL bDeep = TRUE);

// Implementation
public:
	virtual ~CMFCRibbonCommandsListBox();

protected:
	//{{AFX_MSG(CMFCRibbonCommandsListBox)
	afx_msg void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxribbonbuttonsgroup.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxbaseribbonelement.h"
#include "afxtoolbarimages.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCRibbonButtonsGroup : public CMFCRibbonBaseElement
{
	friend class CMFCRibbonBar;
	friend class CMFCRibbonCollector;
	friend class CMFCRibbonConstructor;

	DECLARE_DYNCREATE(CMFCRibbonButtonsGroup)

// Construction
public:
	CMFCRibbonButtonsGroup();
	CMFCRibbonButtonsGroup(CMFCRibbonBaseElement* pButton);

	virtual ~CMFCRibbonButtonsGroup();

// Attributes
public:
	void SetImages(CMFCToolBarImages* pImages, CMFCToolBarImages* pHotImages, CMFCToolBarImages* pDisabledImages);

	BOOL HasImages() const { return m_Images.GetCount() > 0; }
	const CSize GetImageSize() const;
	int GetCount() const { return (int) m_arButtons.GetSize(); }

	CMFCRibbonBaseElement* GetButton(int i) const
	{
		ASSERT_VALID(m_arButtons [i]);
		return m_arButtons [i];
	}

// Operations
public:
	void AddButton(CMFCRibbonBaseElement* pButton);
	void AddButtons(const CList<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& lstButtons);

	void RemoveAll();

// Overrides
public:
	virtual CSize GetRegularSize(CDC* pDC);

	virtual void OnDrawImage(CDC* pDC, CRect rectImage, CMFCRibbonBaseElement* pButton, int nImageIndex);
	virtual void SetParentCategory(CMFCRibbonCategory* pCategory);

protected:
	virtual void OnDraw(CDC* pDC);
	virtual void OnUpdateCmdUI(CMFCRibbonCmdUI* pCmdUI, CFrameWnd* pTarget, BOOL bDisableIfNoHndler);
	virtual void OnAfterChangeRect(CDC* pDC);
	virtual void OnShow(BOOL bShow);

	virtual CMFCRibbonBaseElement* HitTest(CPoint point);

	virtual BOOL CanBeStretched() { return FALSE; }
	virtual BOOL IsAlignByColumn() const { return FALSE; }
	virtual BOOL IsQuickAccessToolBar() const { return FALSE; }

	virtual CMFCRibbonBaseElement* Find(const CMFCRibbonBaseElement* pElement);
	virtual CMFCRibbonBaseElement* FindByID(UINT uiCmdID);
	virtual CMFCRibbonBaseElement* FindByData(DWORD_PTR dwData);
	virtual CMFCRibbonBaseElement* FindByOriginal(CMFCRibbonBaseElement* pOriginal);
	virtual CMFCRibbonBaseElement* GetPressed();
	virtual CMFCRibbonBaseElement* GetDroppedDown();
	virtual CMFCRibbonBaseElement* GetHighlighted();
	/// <summary>
	/// Returns a focused element. </summary>
	/// <returns> A pointer to a focused element or NULL.</returns>
	virtual CMFCRibbonBaseElement* GetFocused();

	virtual BOOL ReplaceByID(UINT uiCmdID, CMFCRibbonBaseElement* pElem);
	virtual void CopyFrom(const CMFCRibbonBaseElement& src);
	virtual void SetParentMenu(CMFCRibbonPanelMenuBar* pMenuBar);
	virtual void SetOriginal(CMFCRibbonBaseElement* pOriginal);

	virtual void GetElementsByID(UINT uiCmdID, CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arButtons);
	virtual void GetItemIDsList(CList<UINT,UINT>& lstItems) const;

	virtual int AddToListBox(CMFCRibbonCommandsListBox* pWndListBox, BOOL bDeep);
	virtual void AddToKeyList(CArray<CMFCRibbonKeyTip*,CMFCRibbonKeyTip*>& arElems);

	virtual void OnRTLChanged(BOOL bIsRTL);
	virtual void CleanUpSizes();

	virtual void SetParentRibbonBar(CMFCRibbonBar* pRibbonBar);

	virtual CMFCRibbonBaseElement* GetFirstTabStop();
	virtual CMFCRibbonBaseElement* GetLastTabStop();

	virtual void GetVisibleElements(CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arElements);

// Attributes
protected:
	CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*> m_arButtons;

	CMFCToolBarImages m_Images;
	CMFCToolBarImages m_HotImages;
	CMFCToolBarImages m_DisabledImages;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxribboncollector.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxribboninfo.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCRibbonCollector
{
public:
	enum XFlags
	{
		e_CollectUpdatedToolInfo = 0x01, // update tool tip info
		e_CollectRibbonBarIcons  = 0x02, // add icons of the panels or tab elements to the ribbon image
		e_CollectGroupImages     = 0x04, // add image of each group to the small image of category
		e_CollectHiddenElements  = 0x08, // collect hidden elements of the category
		e_CollectImagesID        = 0x10  // collect resource ID of the images (for category and group images)
	};

public:
	CMFCRibbonCollector(CMFCRibbonInfo& info, DWORD dwFlags = 0);
	virtual ~CMFCRibbonCollector();

public:
	virtual void CollectRibbonBar(const CMFCRibbonBar& bar);

protected:
	virtual CMFCRibbonInfo::XElement* CollectElement(const CMFCRibbonBaseElement& element);

	virtual void GetID(const CMFCRibbonBaseElement& element, CMFCRibbonInfo::XID& info);
	virtual void GetRibbonBarImages(const CMFCRibbonBar& bar, CMFCRibbonInfo::XRibbonBar& info);
	virtual void GetCategoryImages(const CMFCRibbonCategory& category, CMFCRibbonInfo::XCategory& info);
	virtual void GetCategoryImages(const CMFCRibbonCategory& category, CMFCRibbonInfo::XImage& infoSmall, CMFCRibbonInfo::XImage& infoLarge);
	virtual void GetElementImages(const CMFCRibbonBaseElement& element, CMFCRibbonInfo::XImage& info);

	virtual void CollectBaseElement(const CMFCRibbonBaseElement& element, CMFCRibbonInfo::XElement& info, BOOL bSubItems = TRUE);
	virtual void CollectElement(const CMFCRibbonBaseElement& element, CMFCRibbonInfo::XElement& info);
	virtual void CollectQATElements(const CMFCRibbonBar& bar, CMFCRibbonInfo::XRibbonBar& info);
	virtual void CollectPanel(const CMFCRibbonPanel& panel, CMFCRibbonInfo::XPanel& info);
	virtual void CollectCategory(const CMFCRibbonCategory& category, CMFCRibbonInfo::XCategory& info);
	virtual void CollectCategoryMain(const CMFCRibbonBar& bar, CMFCRibbonInfo::XCategoryMain& info);
	virtual void CollectRibbonBar(const CMFCRibbonBar& bar, CMFCRibbonInfo::XRibbonBar& info);

	virtual void CollectImageInfo(CMFCToolBarImages& ti, CMFCRibbonInfo::XImage& image, BOOL bCollectID);

	CMFCRibbonInfo& GetInfo() { return m_Info; }
	DWORD GetFlags() const { return m_dwFlags; }

private:
	CMFCRibbonInfo& m_Info;
	DWORD           m_dwFlags;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxribboncustomizedialog.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxcontrolbarutil.h"

#include "afxpropertysheet.h"
#include "afxpropertypage.h"
#include "afxbutton.h"
#include "afxribboncommandslistbox.h"
#include "afxribbonres.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCRibbonBar;
class CMFCRibbonCustomizeCategory;

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonCustomizePropertyPage dialog

class CMFCRibbonCustomizePropertyPage : public CMFCPropertyPage
{
	DECLARE_DYNCREATE(CMFCRibbonCustomizePropertyPage)

// Construction
public:
	CMFCRibbonCustomizePropertyPage(CMFCRibbonBar* pRibbonBar = NULL);
	~CMFCRibbonCustomizePropertyPage();

	void AddCustomCategory(LPCTSTR lpszName, const CList<UINT, UINT>& lstIDS);

// Dialog Data
	//{{AFX_DATA(CMFCRibbonCustomizePropertyPage)
	enum { IDD = IDD_AFXBARRES_PROPPAGE8 };
	CButton m_wndAdd;
	CButton m_wndRemove;
	CComboBox m_wndCategoryCombo;
	CMFCButton m_wndUp;
	CMFCButton m_wndDown;
	CMFCRibbonCommandsListBox m_wndCommandsList;
	CMFCRibbonCommandsListBox m_wndQATList;
	int  m_nCategory;
	BOOL m_bQAToolbarOnBottom;
	//}}AFX_DATA

// Overrides
public:
	virtual void OnOK();

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Implementation
protected:
	//{{AFX_MSG(CMFCRibbonCustomizePropertyPage)
	afx_msg void OnSelendokCategoryCombo();
	afx_msg void OnAdd();
	afx_msg void OnRemove();
	afx_msg void OnUp();
	afx_msg void OnDown();
	afx_msg void OnToolbarReset();
	afx_msg void OnSelchangeQATCommands();
	virtual BOOL OnInitDialog();
	afx_msg void OnCustomizeKeyboard();
	afx_msg void OnSelchangeCommandsList();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void MoveItem(BOOL bMoveUp);

	CMFCRibbonBar* m_pRibbonBar;
	CList<CMFCRibbonCustomizeCategory*,CMFCRibbonCustomizeCategory*> m_lstCustomCategories;
};

class CMFCRibbonCustomizeDialog : public CMFCPropertySheet
{
	DECLARE_DYNAMIC(CMFCRibbonCustomizeDialog)

public:
	CMFCRibbonCustomizeDialog(CWnd* pWndParent, CMFCRibbonBar* pRibbon);
	virtual ~CMFCRibbonCustomizeDialog();

protected:
	CMFCRibbonCustomizePropertyPage* m_pPage;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxribbonedit.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Founda