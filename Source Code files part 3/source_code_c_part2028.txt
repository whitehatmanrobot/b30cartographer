ing)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetPaymentInstrumentsCompletedEventHandler(object sender, GetPaymentInstrumentsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetPaymentInstrumentsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetPaymentInstrumentsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public GetPaymentInstrumentResults Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((GetPaymentInstrumentResults)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetSupportedCountriesCompletedEventHandler(object sender, GetSupportedCountriesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetSupportedCountriesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetSupportedCountriesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public CountryInfo[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((CountryInfo[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetUserAuthorizationCompletedEventHandler(object sender, GetUserAuthorizationCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetUserAuthorizationCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetUserAuthorizationCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public GetUserAuthorizationInfo Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((GetUserAuthorizationInfo)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void TestConnectionCompletedEventHandler(object sender, TestConnectionCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class TestConnectionCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal TestConnectionCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ConsoleApplicationsGetByMachinePuidCompletedEventHandler(object sender, ConsoleApplicationsGetByMachinePuidCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ConsoleApplicationsGetByMachinePuidCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ConsoleApplicationsGetByMachinePuidCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public ConsoleApplications Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ConsoleApplications)(this.results[0]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\WebReferences\WidgetMessaging\Reference.cs ===
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.42
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace ServerTestFramework.Web.Messaging {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="MessagingImplSoap", Namespace="http://tempuri.org/")]
    public partial class MessagingImpl : ServerTestFramework.Web.STFSoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback GetMessageStringOperationCompleted;
        
        private System.Threading.SendOrPostCallback RevokeTitleUserMessageOperationCompleted;
        
        private System.Threading.SendOrPostCallback SendTitleUserMessageOperationCompleted;
        
        private System.Threading.SendOrPostCallback SendTitleWideMessageOperationCompleted;
        
        private System.Threading.SendOrPostCallback DeleteTitleWideMessageOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetTitleWideMessageDetailsOperationCompleted;
        
        private System.Threading.SendOrPostCallback EnumTitleWideMessagesOperationCompleted;
        
        private System.Threading.SendOrPostCallback SetMessageFlagsOperationCompleted;
        
        private System.Threading.SendOrPostCallback EnumUserTitlesOperationCompleted;
        
        private System.Threading.SendOrPostCallback DeleteUserTitleOperationCompleted;
        
        private System.Threading.SendOrPostCallback RevokeMessageOperationCompleted;
        
        private System.Threading.SendOrPostCallback SendMessageOperationCompleted;
        
        private System.Threading.SendOrPostCallback DeleteMessageOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetMessageDetailsOperationCompleted;
        
        private System.Threading.SendOrPostCallback EnumMessagesOperationCompleted;
        
        /// <remarks/>
        public MessagingImpl() {
            this.ComputeUrl("wcmessaging", "/messaging/messaging.asmx");
        }
        
        /// <remarks/>
        public event GetMessageStringCompletedEventHandler GetMessageStringCompleted;
        
        /// <remarks/>
        public event RevokeTitleUserMessageCompletedEventHandler RevokeTitleUserMessageCompleted;
        
        /// <remarks/>
        public event SendTitleUserMessageCompletedEventHandler SendTitleUserMessageCompleted;
        
        /// <remarks/>
        public event SendTitleWideMessageCompletedEventHandler SendTitleWideMessageCompleted;
        
        /// <remarks/>
        public event DeleteTitleWideMessageCompletedEventHandler DeleteTitleWideMessageCompleted;
        
        /// <remarks/>
        public event GetTitleWideMessageDetailsCompletedEventHandler GetTitleWideMessageDetailsCompleted;
        
        /// <remarks/>
        public event EnumTitleWideMessagesCompletedEventHandler EnumTitleWideMessagesCompleted;
        
        /// <remarks/>
        public event SetMessageFlagsCompletedEventHandler SetMessageFlagsCompleted;
        
        /// <remarks/>
        public event EnumUserTitlesCompletedEventHandler EnumUserTitlesCompleted;
        
        /// <remarks/>
        public event DeleteUserTitleCompletedEventHandler DeleteUserTitleCompleted;
        
        /// <remarks/>
        public event RevokeMessageCompletedEventHandler RevokeMessageCompleted;
        
        /// <remarks/>
        public event SendMessageCompletedEventHandler SendMessageCompleted;
        
        /// <remarks/>
        public event DeleteMessageCompletedEventHandler DeleteMessageCompleted;
        
        /// <remarks/>
        public event GetMessageDetailsCompletedEventHandler GetMessageDetailsCompleted;
        
        /// <remarks/>
        public event EnumMessagesCompletedEventHandler EnumMessagesCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/GetMessageString", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("StringData")]
        public string GetMessageString(uint TitleID, uint StringID, string Locale) {
            object[] results = this.Invoke("GetMessageString", new object[] {
                        TitleID,
                        StringID,
                        Locale});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetMessageString(uint TitleID, uint StringID, string Locale, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetMessageString", new object[] {
                        TitleID,
                        StringID,
                        Locale}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetMessageString(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetMessageStringAsync(uint TitleID, uint StringID, string Locale) {
            this.GetMessageStringAsync(TitleID, StringID, Locale, null);
        }
        
        /// <remarks/>
        public void GetMessageStringAsync(uint TitleID, uint StringID, string Locale, object userState) {
            if ((this.GetMessageStringOperationCompleted == null)) {
                this.GetMessageStringOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetMessageStringOperationCompleted);
            }
            this.InvokeAsync("GetMessageString", new object[] {
                        TitleID,
                        StringID,
                        Locale}, this.GetMessageStringOperationCompleted, userState);
        }
        
        private void OnGetMessageStringOperationCompleted(object arg) {
            if ((this.GetMessageStringCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetMessageStringCompleted(this, new GetMessageStringCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/RevokeTitleUserMessage", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public uint RevokeTitleUserMessage([System.Xml.Serialization.XmlElementAttribute("RecipResult")] WCRecipientResult[] RecipResult) {
            object[] results = this.Invoke("RevokeTitleUserMessage", new object[] {
                        RecipResult});
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRevokeTitleUserMessage(WCRecipientResult[] RecipResult, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RevokeTitleUserMessage", new object[] {
                        RecipResult}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndRevokeTitleUserMessage(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void RevokeTitleUserMessageAsync(WCRecipientResult[] RecipResult) {
            this.RevokeTitleUserMessageAsync(RecipResult, null);
        }
        
        /// <remarks/>
        public void RevokeTitleUserMessageAsync(WCRecipientResult[] RecipResult, object userState) {
            if ((this.RevokeTitleUserMessageOperationCompleted == null)) {
                this.RevokeTitleUserMessageOperationCompleted = new System.Threading.SendOrPostCallback(this.OnRevokeTitleUserMessageOperationCompleted);
            }
            this.InvokeAsync("RevokeTitleUserMessage", new object[] {
                        RecipResult}, this.RevokeTitleUserMessageOperationCompleted, userState);
        }
        
        private void OnRevokeTitleUserMessageOperationCompleted(object arg) {
            if ((this.RevokeTitleUserMessageCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.RevokeTitleUserMessageCompleted(this, new RevokeTitleUserMessageCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/SendTitleUserMessage", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public uint SendTitleUserMessage(string Sender, ulong SenderContext, WCMessageFlags MessageFlags, uint SenderTitleID, ushort ExpireMinutes, WCMessageType MessageType, [System.Xml.Serialization.XmlElementAttribute("Recipient")] string[] Recipient, WCMessageDetails Details, [System.Xml.Serialization.XmlElementAttribute("Attachment")] WCMessageAttachment[] Attachment, [System.Xml.Serialization.XmlElementAttribute("RecipResult")] out WCRecipientResult[] RecipResult) {
            object[] results = this.Invoke("SendTitleUserMessage", new object[] {
                        Sender,
                        SenderContext,
                        MessageFlags,
                        SenderTitleID,
                        ExpireMinutes,
                        MessageType,
                        Recipient,
                        Details,
                        Attachment});
            RecipResult = ((WCRecipientResult[])(results[1]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSendTitleUserMessage(string Sender, ulong SenderContext, WCMessageFlags MessageFlags, uint SenderTitleID, ushort ExpireMinutes, WCMessageType MessageType, string[] Recipient, WCMessageDetails Details, WCMessageAttachment[] Attachment, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SendTitleUserMessage", new object[] {
                        Sender,
                        SenderContext,
                        MessageFlags,
                        SenderTitleID,
                        ExpireMinutes,
                        MessageType,
                        Recipient,
                        Details,
                        Attachment}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndSendTitleUserMessage(System.IAsyncResult asyncResult, out WCRecipientResult[] RecipResult) {
            object[] results = this.EndInvoke(asyncResult);
            RecipResult = ((WCRecipientResult[])(results[1]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void SendTitleUserMessageAsync(string Sender, ulong SenderContext, WCMessageFlags MessageFlags, uint SenderTitleID, ushort ExpireMinutes, WCMessageType MessageType, string[] Recipient, WCMessageDetails Details, WCMessageAttachment[] Attachment) {
            this.SendTitleUserMessageAsync(Sender, SenderContext, MessageFlags, SenderTitleID, ExpireMinutes, MessageType, Recipient, Details, Attachment, null);
        }
        
        /// <remarks/>
        public void SendTitleUserMessageAsync(string Sender, ulong SenderContext, WCMessageFlags MessageFlags, uint SenderTitleID, ushort ExpireMinutes, WCMessageType MessageType, string[] Recipient, WCMessageDetails Details, WCMessageAttachment[] Attachment, object userState) {
            if ((this.SendTitleUserMessageOperationCompleted == null)) {
                this.SendTitleUserMessageOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSendTitleUserMessageOperationCompleted);
            }
            this.InvokeAsync("SendTitleUserMessage", new object[] {
                        Sender,
                        SenderContext,
                        MessageFlags,
                        SenderTitleID,
                        ExpireMinutes,
                        MessageType,
                        Recipient,
                        Details,
                        Attachment}, this.SendTitleUserMessageOperationCompleted, userState);
        }
        
        private void OnSendTitleUserMessageOperationCompleted(object arg) {
            if ((this.SendTitleUserMessageCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SendTitleUserMessageCompleted(this, new SendTitleUserMessageCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/SendTitleWideMessage", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public uint SendTitleWideMessage(string Sender, ulong SenderContext, System.DateTime SentTime, uint Region, WCMessageFlags MessageFlags, uint SenderTitleID, ushort ExpireMinutes, WCMessageType MessageType, string Description, WCMessageDetails Details, [System.Xml.Serialization.XmlElementAttribute("LocalizedString")] WCLocalizedString[] LocalizedString, [System.Xml.Serialization.XmlElementAttribute("Attachment")] WCMessageAttachment[] Attachment, out ushort Delay, out uint MessageID) {
            object[] results = this.Invoke("SendTitleWideMessage", new object[] {
                        Sender,
                        SenderContext,
                        SentTime,
                        Region,
                        MessageFlags,
                        SenderTitleID,
                        ExpireMinutes,
                        MessageType,
                        Description,
                        Details,
                        LocalizedString,
                        Attachment});
            Delay = ((ushort)(results[1]));
            MessageID = ((uint)(results[2]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSendTitleWideMessage(string Sender, ulong SenderContext, System.DateTime SentTime, uint Region, WCMessageFlags MessageFlags, uint SenderTitleID, ushort ExpireMinutes, WCMessageType MessageType, string Description, WCMessageDetails Details, WCLocalizedString[] LocalizedString, WCMessageAttachment[] Attachment, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SendTitleWideMessage", new object[] {
                        Sender,
                        SenderContext,
                        SentTime,
                        Region,
                        MessageFlags,
                        SenderTitleID,
                        ExpireMinutes,
                        MessageType,
                        Description,
                        Details,
                        LocalizedString,
                        Attachment}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndSendTitleWideMessage(System.IAsyncResult asyncResult, out ushort Delay, out uint MessageID) {
            object[] results = this.EndInvoke(asyncResult);
            Delay = ((ushort)(results[1]));
            MessageID = ((uint)(results[2]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void SendTitleWideMessageAsync(string Sender, ulong SenderContext, System.DateTime SentTime, uint Region, WCMessageFlags MessageFlags, uint SenderTitleID, ushort ExpireMinutes, WCMessageType MessageType, string Description, WCMessageDetails Details, WCLocalizedString[] LocalizedString, WCMessageAttachment[] Attachment) {
            this.SendTitleWideMessageAsync(Sender, SenderContext, SentTime, Region, MessageFlags, SenderTitleID, ExpireMinutes, MessageType, Description, Details, LocalizedString, Attachment, null);
        }
        
        /// <remarks/>
        public void SendTitleWideMessageAsync(string Sender, ulong SenderContext, System.DateTime SentTime, uint Region, WCMessageFlags MessageFlags, uint SenderTitleID, ushort ExpireMinutes, WCMessageType MessageType, string Description, WCMessageDetails Details, WCLocalizedString[] LocalizedString, WCMessageAttachment[] Attachment, object userState) {
            if ((this.SendTitleWideMessageOperationCompleted == null)) {
                this.SendTitleWideMessageOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSendTitleWideMessageOperationCompleted);
            }
            this.InvokeAsync("SendTitleWideMessage", new object[] {
                        Sender,
                        SenderContext,
                        SentTime,
                        Region,
                        MessageFlags,
                        SenderTitleID,
                        ExpireMinutes,
                        MessageType,
                        Description,
                        Details,
                        LocalizedString,
                        Attachment}, this.SendTitleWideMessageOperationCompleted, userState);
        }
        
        private void OnSendTitleWideMessageOperationCompleted(object arg) {
            if ((this.SendTitleWideMessageCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SendTitleWideMessageCompleted(this, new SendTitleWideMessageCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/DeleteTitleWideMessage", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public uint DeleteTitleWideMessage(uint TitleID, uint MessageID, WCDeleteSysMsgFlags Flags) {
            object[] results = this.Invoke("DeleteTitleWideMessage", new object[] {
                        TitleID,
                        MessageID,
                        Flags});
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginDeleteTitleWideMessage(uint TitleID, uint MessageID, WCDeleteSysMsgFlags Flags, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("DeleteTitleWideMessage", new object[] {
                        TitleID,
                        MessageID,
                        Flags}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndDeleteTitleWideMessage(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void DeleteTitleWideMessageAsync(uint TitleID, uint MessageID, WCDeleteSysMsgFlags Flags) {
            this.DeleteTitleWideMessageAsync(TitleID, MessageID, Flags, null);
        }
        
        /// <remarks/>
        public void DeleteTitleWideMessageAsync(uint TitleID, uint MessageID, WCDeleteSysMsgFlags Flags, object userState) {
            if ((this.DeleteTitleWideMessageOperationCompleted == null)) {
                this.DeleteTitleWideMessageOperationCompleted = new System.Threading.SendOrPostCallback(this.OnDeleteTitleWideMessageOperationCompleted);
            }
            this.InvokeAsync("DeleteTitleWideMessage", new object[] {
                        TitleID,
                        MessageID,
                        Flags}, this.DeleteTitleWideMessageOperationCompleted, userState);
        }
        
        private void OnDeleteTitleWideMessageOperationCompleted(object arg) {
            if ((this.DeleteTitleWideMessageCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.DeleteTitleWideMessageCompleted(this, new DeleteTitleWideMessageCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/GetTitleWideMessageDetails", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public uint GetTitleWideMessageDetails(uint TitleID, uint MessageID, out WCTitleWideMessageSummary Summary, out WCMessageDetails Details) {
            object[] results = this.Invoke("GetTitleWideMessageDetails", new object[] {
                        TitleID,
                        MessageID});
            Summary = ((WCTitleWideMessageSummary)(results[1]));
            Details = ((WCMessageDetails)(results[2]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetTitleWideMessageDetails(uint TitleID, uint MessageID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetTitleWideMessageDetails", new object[] {
                        TitleID,
                        MessageID}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndGetTitleWideMessageDetails(System.IAsyncResult asyncResult, out WCTitleWideMessageSummary Summary, out WCMessageDetails Details) {
            object[] results = this.EndInvoke(asyncResult);
            Summary = ((WCTitleWideMessageSummary)(results[1]));
            Details = ((WCMessageDetails)(results[2]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void GetTitleWideMessageDetailsAsync(uint TitleID, uint MessageID) {
            this.GetTitleWideMessageDetailsAsync(TitleID, MessageID, null);
        }
        
        /// <remarks/>
        public void GetTitleWideMessageDetailsAsync(uint TitleID, uint MessageID, object userState) {
            if ((this.GetTitleWideMessageDetailsOperationCompleted == null)) {
                this.GetTitleWideMessageDetailsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetTitleWideMessageDetailsOperationCompleted);
            }
            this.InvokeAsync("GetTitleWideMessageDetails", new object[] {
                        TitleID,
                        MessageID}, this.GetTitleWideMessageDetailsOperationCompleted, userState);
        }
        
        private void OnGetTitleWideMessageDetailsOperationCompleted(object arg) {
            if ((this.GetTitleWideMessageDetailsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetTitleWideMessageDetailsCompleted(this, new GetTitleWideMessageDetailsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/EnumTitleWideMessages", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public uint EnumTitleWideMessages(uint TitleID, [System.Xml.Serialization.XmlElementAttribute("Summary")] out WCTitleWideMessageSummary[] Summary) {
            object[] results = this.Invoke("EnumTitleWideMessages", new object[] {
                        TitleID});
            Summary = ((WCTitleWideMessageSummary[])(results[1]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginEnumTitleWideMessages(uint TitleID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("EnumTitleWideMessages", new object[] {
                        TitleID}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndEnumTitleWideMessages(System.IAsyncResult asyncResult, out WCTitleWideMessageSummary[] Summary) {
            object[] results = this.EndInvoke(asyncResult);
            Summary = ((WCTitleWideMessageSummary[])(results[1]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void EnumTitleWideMessagesAsync(uint TitleID) {
            this.EnumTitleWideMessagesAsync(TitleID, null);
        }
        
        /// <remarks/>
        public void EnumTitleWideMessagesAsync(uint TitleID, object userState) {
            if ((this.EnumTitleWideMessagesOperationCompleted == null)) {
                this.EnumTitleWideMessagesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnEnumTitleWideMessagesOperationCompleted);
            }
            this.InvokeAsync("EnumTitleWideMessages", new object[] {
                        TitleID}, this.EnumTitleWideMessagesOperationCompleted, userState);
        }
        
        private void OnEnumTitleWideMessagesOperationCompleted(object arg) {
            if ((this.EnumTitleWideMessagesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.EnumTitleWideMessagesCompleted(this, new EnumTitleWideMessagesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/SetMessageFlags", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public uint SetMessageFlags([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] UserWebID, string UserGamerTag, uint MessageID, WCMessageFlags SetFlags, WCMessageFlags UnsetFlags) {
            object[] results = this.Invoke("SetMessageFlags", new object[] {
                        UserWebID,
                        UserGamerTag,
                        MessageID,
                        SetFlags,
                        UnsetFlags});
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSetMessageFlags(byte[] UserWebID, string UserGamerTag, uint MessageID, WCMessageFlags SetFlags, WCMessageFlags UnsetFlags, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SetMessageFlags", new object[] {
                        UserWebID,
                        UserGamerTag,
                        MessageID,
                        SetFlags,
                        UnsetFlags}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndSetMessageFlags(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void SetMessageFlagsAsync(byte[] UserWebID, string UserGamerTag, uint MessageID, WCMessageFlags SetFlags, WCMessageFlags UnsetFlags) {
            this.SetMessageFlagsAsync(UserWebID, UserGamerTag, MessageID, SetFlags, UnsetFlags, null);
        }
        
        /// <remarks/>
        public void SetMessageFlagsAsync(byte[] UserWebID, string UserGamerTag, uint MessageID, WCMessageFlags SetFlags, WCMessageFlags UnsetFlags, object userState) {
            if ((this.SetMessageFlagsOperationCompleted == null)) {
                this.SetMessageFlagsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetMessageFlagsOperationCompleted);
            }
            this.InvokeAsync("SetMessageFlags", new object[] {
                        UserWebID,
                        UserGamerTag,
                        MessageID,
                        SetFlags,
                        UnsetFlags}, this.SetMessageFlagsOperationCompleted, userState);
        }
        
        private void OnSetMessageFlagsOperationCompleted(object arg) {
            if ((this.SetMessageFlagsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetMessageFlagsCompleted(this, new SetMessageFlagsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/EnumUserTitles", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public uint EnumUserTitles([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] UserWebID, string UserGamerTag, [System.Xml.Serialization.XmlElementAttribute("Title")] out WCUserTitle[] Title) {
            object[] results = this.Invoke("EnumUserTitles", new object[] {
                        UserWebID,
                        UserGamerTag});
            Title = ((WCUserTitle[])(results[1]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginEnumUserTitles(byte[] UserWebID, string UserGamerTag, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("EnumUserTitles", new object[] {
                        UserWebID,
                        UserGamerTag}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndEnumUserTitles(System.IAsyncResult asyncResult, out WCUserTitle[] Title) {
            object[] results = this.EndInvoke(asyncResult);
            Title = ((WCUserTitle[])(results[1]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void EnumUserTitlesAsync(byte[] UserWebID, string UserGamerTag) {
            this.EnumUserTitlesAsync(UserWebID, UserGamerTag, null);
        }
        
        /// <remarks/>
        public void EnumUserTitlesAsync(byte[] UserWebID, string UserGamerTag, object userState) {
            if ((this.EnumUserTitlesOperationCompleted == null)) {
                this.EnumUserTitlesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnEnumUserTitlesOperationCompleted);
            }
            this.InvokeAsync("EnumUserTitles", new object[] {
                        UserWebID,
                        UserGamerTag}, this.EnumUserTitlesOperationCompleted, userState);
        }
        
        private void OnEnumUserTitlesOperationCompleted(object arg) {
            if ((this.EnumUserTitlesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.EnumUserTitlesCompleted(this, new EnumUserTitlesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/DeleteUserTitle", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public uint DeleteUserTitle([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] UserWebID, string UserGamerTag, uint TitleID) {
            object[] results = this.Invoke("DeleteUserTitle", new object[] {
                        UserWebID,
                        UserGamerTag,
                        TitleID});
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginDeleteUserTitle(byte[] UserWebID, string UserGamerTag, uint TitleID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("DeleteUserTitle", new object[] {
                        UserWebID,
                        UserGamerTag,
                        TitleID}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndDeleteUserTitle(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void DeleteUserTitleAsync(byte[] UserWebID, string UserGamerTag, uint TitleID) {
            this.DeleteUserTitleAsync(UserWebID, UserGamerTag, TitleID, null);
        }
        
        /// <remarks/>
        public void DeleteUserTitleAsync(byte[] UserWebID, string UserGamerTag, uint TitleID, object userState) {
            if ((this.DeleteUserTitleOperationCompleted == null)) {
                this.DeleteUserTitleOperationCompleted = new System.Threading.SendOrPostCallback(this.OnDeleteUserTitleOperationCompleted);
            }
            this.InvokeAsync("DeleteUserTitle", new object[] {
                        UserWebID,
                        UserGamerTag,
                        TitleID}, this.DeleteUserTitleOperationCompleted, userState);
        }
        
        private void OnDeleteUserTitleOperationCompleted(object arg) {
            if ((this.DeleteUserTitleCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.DeleteUserTitleCompleted(this, new DeleteUserTitleCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/RevokeMessage", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public uint RevokeMessage([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] SenderWebID, string SenderGamerTag, [System.Xml.Serialization.XmlElementAttribute("RecipResult")] WCRecipientResult[] RecipResult) {
            object[] results = this.Invoke("RevokeMessage", new object[] {
                        SenderWebID,
                        SenderGamerTag,
                        RecipResult});
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRevokeMessage(byte[] SenderWebID, string SenderGamerTag, WCRecipientResult[] RecipResult, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RevokeMessage", new object[] {
                        SenderWebID,
                        SenderGamerTag,
                        RecipResult}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndRevokeMessage(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void RevokeMessageAsync(byte[] SenderWebID, string SenderGamerTag, WCRecipientResult[] RecipResult) {
            this.RevokeMessageAsync(SenderWebID, SenderGamerTag, RecipResult, null);
        }
        
        /// <remarks/>
        public void RevokeMessageAsync(byte[] SenderWebID, string SenderGamerTag, WCRecipientResult[] RecipResult, object userState) {
            if ((this.RevokeMessageOperationCompleted == null)) {
                this.RevokeMessageOperationCompleted = new System.Threading.SendOrPostCallback(this.OnRevokeMessageOperationCompleted);
            }
            this.InvokeAsync("RevokeMessage", new object[] {
                        SenderWebID,
                        SenderGamerTag,
                        RecipResult}, this.RevokeMessageOperationCompleted, userState);
        }
        
        private void OnRevokeMessageOperationCompleted(object arg) {
            if ((this.RevokeMessageCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.RevokeMessageCompleted(this, new RevokeMessageCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/SendMessage", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public uint SendMessage([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] SenderWebID, string SenderGamerTag, ulong SenderContext, WCMessageFlags MessageFlags, uint SenderTitleID, ushort ExpireMinutes, WCMessageType MessageType, [System.Xml.Serialization.XmlElementAttribute("Recipient")] string[] Recipient, WCMessageDetails Details, [System.Xml.Serialization.XmlElementAttribute("Attachment")] WCMessageAttachment[] Attachment, [System.Xml.Serialization.XmlElementAttribute("RecipResult")] out WCRecipientResult[] RecipResult) {
            object[] results = this.Invoke("SendMessage", new object[] {
                        SenderWebID,
                        SenderGamerTag,
                        SenderContext,
                        MessageFlags,
                        SenderTitleID,
                        ExpireMinutes,
                        MessageType,
                        Recipient,
                        Details,
                        Attachment});
            RecipResult = ((WCRecipientResult[])(results[1]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSendMessage(byte[] SenderWebID, string SenderGamerTag, ulong SenderContext, WCMessageFlags MessageFlags, uint SenderTitleID, ushort ExpireMinutes, WCMessageType MessageType, string[] Recipient, WCMessageDetails Details, WCMessageAttachment[] Attachment, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SendMessage", new object[] {
                        SenderWebID,
                        SenderGamerTag,
                        SenderContext,
                        MessageFlags,
                        SenderTitleID,
                        ExpireMinutes,
                        MessageType,
                        Recipient,
                        Details,
                        Attachment}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndSendMessage(System.IAsyncResult asyncResult, out WCRecipientResult[] RecipResult) {
            object[] results = this.EndInvoke(asyncResult);
            RecipResult = ((WCRecipientResult[])(results[1]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void SendMessageAsync(byte[] SenderWebID, string SenderGamerTag, ulong SenderContext, WCMessageFlags MessageFlags, uint SenderTitleID, ushort ExpireMinutes, WCMessageType MessageType, string[] Recipient, WCMessageDetails Details, WCMessageAttachment[] Attachment) {
            this.SendMessageAsync(SenderWebID, SenderGamerTag, SenderContext, MessageFlags, SenderTitleID, ExpireMinutes, MessageType, Recipient, Details, Attachment, null);
        }
        
        /// <remarks/>
        public void SendMessageAsync(byte[] SenderWebID, string SenderGamerTag, ulong SenderContext, WCMessageFlags MessageFlags, uint SenderTitleID, ushort ExpireMinutes, WCMessageType MessageType, string[] Recipient, WCMessageDetails Details, WCMessageAttachment[] Attachment, object userState) {
            if ((this.SendMessageOperationCompleted == null)) {
                this.SendMessageOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSendMessageOperationCompleted);
            }
            this.InvokeAsync("SendMessage", new object[] {
                        SenderWebID,
                        SenderGamerTag,
                        SenderContext,
                        MessageFlags,
                        SenderTitleID,
                        ExpireMinutes,
                        MessageType,
                        Recipient,
                        Details,
                        Attachment}, this.SendMessageOperationCompleted, userState);
        }
        
        private void OnSendMessageOperationCompleted(object arg) {
            if ((this.SendMessageCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SendMessageCompleted(this, new SendMessageCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/DeleteMessage", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public uint DeleteMessage([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] UserWebID, string UserGamerTag, uint MessageID, WCDeleteMsgFlags Flags) {
            object[] results = this.Invoke("DeleteMessage", new object[] {
                        UserWebID,
                        UserGamerTag,
                        MessageID,
                        Flags});
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginDeleteMessage(byte[] UserWebID, string UserGamerTag, uint MessageID, WCDeleteMsgFlags Flags, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("DeleteMessage", new object[] {
                        UserWebID,
                        UserGamerTag,
                        MessageID,
                        Flags}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndDeleteMessage(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void DeleteMessageAsync(byte[] UserWebID, string UserGamerTag, uint MessageID, WCDeleteMsgFlags Flags) {
            this.DeleteMessageAsync(UserWebID, UserGamerTag, MessageID, Flags, null);
        }
        
        /// <remarks/>
        public void DeleteMessageAsync(byte[] UserWebID, string UserGamerTag, uint MessageID, WCDeleteMsgFlags Flags, object userState) {
            if ((this.DeleteMessageOperationCompleted == null)) {
                this.DeleteMessageOperationCompleted = new System.Threading.SendOrPostCallback(this.OnDeleteMessageOperationCompleted);
            }
            this.InvokeAsync("DeleteMessage", new object[] {
                        UserWebID,
                        UserGamerTag,
                        MessageID,
                        Flags}, this.DeleteMessageOperationCompleted, userState);
        }
        
        private void OnDeleteMessageOperationCompleted(object arg) {
            if ((this.DeleteMessageCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.DeleteMessageCompleted(this, new DeleteMessageCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/GetMessageDetails", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public uint GetMessageDetails([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] UserWebID, string UserGamerTag, uint MessageID, WCMessageFlags SetFlags, WCMessageFlags UnsetFlags, out WCMessageSummary Summary, out WCMessageDetails Details) {
            object[] results = this.Invoke("GetMessageDetails", new object[] {
                        UserWebID,
                        UserGamerTag,
                        MessageID,
                        SetFlags,
                        UnsetFlags});
            Summary = ((WCMessageSummary)(results[1]));
            Details = ((WCMessageDetails)(results[2]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetMessageDetails(byte[] UserWebID, string UserGamerTag, uint MessageID, WCMessageFlags SetFlags, WCMessageFlags UnsetFlags, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetMessageDetails", new object[] {
                        UserWebID,
                        UserGamerTag,
                        MessageID,
                        SetFlags,
                        UnsetFlags}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndGetMessageDetails(System.IAsyncResult asyncResult, out WCMessageSummary Summary, out WCMessageDetails Details) {
            object[] results = this.EndInvoke(asyncResult);
            Summary = ((WCMessageSummary)(results[1]));
            Details = ((WCMessageDetails)(results[2]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void GetMessageDetailsAsync(byte[] UserWebID, string UserGamerTag, uint MessageID, WCMessageFlags SetFlags, WCMessageFlags UnsetFlags) {
            this.GetMessageDetailsAsync(UserWebID, UserGamerTag, MessageID, SetFlags, UnsetFlags, null);
        }
        
        /// <remarks/>
        public void GetMessageDetailsAsync(byte[] UserWebID, string UserGamerTag, uint MessageID, WCMessageFlags SetFlags, WCMessageFlags UnsetFlags, object userState) {
            if ((this.GetMessageDetailsOperationCompleted == null)) {
                this.GetMessageDetailsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetMessageDetailsOperationCompleted);
            }
            this.InvokeAsync("GetMessageDetails", new object[] {
                        UserWebID,
                        UserGamerTag,
                        MessageID,
                        SetFlags,
                        UnsetFlags}, this.GetMessageDetailsOperationCompleted, userState);
        }
        
        private void OnGetMessageDetailsOperationCompleted(object arg) {
            if ((this.GetMessageDetailsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetMessageDetailsCompleted(this, new GetMessageDetailsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Messaging/EnumMessages", RequestNamespace="http://websvc.xboxlive.com/Messaging/", ResponseNamespace="http://websvc.xboxlive.com/Messaging/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Result")]
        public uint EnumMessages([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] UserWebID, string UserGamerTag, [System.Xml.Serialization.XmlElementAttribute("Summary")] out WCMessageSummary[] Summary) {
            object[] results = this.Invoke("EnumMessages", new object[] {
                        UserWebID,
                        UserGamerTag});
            Summary = ((WCMessageSummary[])(results[1]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginEnumMessages(byte[] UserWebID, string UserGamerTag, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("EnumMessages", new object[] {
                        UserWebID,
                        UserGamerTag}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndEnumMessages(System.IAsyncResult asyncResult, out WCMessageSummary[] Summary) {
            object[] results = this.EndInvoke(asyncResult);
            Summary = ((WCMessageSummary[])(results[1]));
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void EnumMessagesAsync(byte[] UserWebID, string UserGamerTag) {
            this.EnumMessagesAsync(UserWebID, UserGamerTag, null);
        }
        
        /// <remarks/>
        public void EnumMessagesAsync(byte[] UserWebID, string UserGamerTag, object userState) {
            if ((this.EnumMessagesOperationCompleted == null)) {
                this.EnumMessagesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnEnumMessagesOperationCompleted);
            }
            this.InvokeAsync("EnumMessages", new object[] {
                        UserWebID,
                        UserGamerTag}, this.EnumMessagesOperationCompleted, userState);
        }
        
        private void OnEnumMessagesOperationCompleted(object arg) {
            if ((this.EnumMessagesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.EnumMessagesCompleted(this, new EnumMessagesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public partial class WCRecipientResult {
        
        private string userField;
        
        private uint messageIDField;
        
        /// <remarks/>
        public string User {
            get {
                return this.userField;
            }
            set {
                this.userField = value;
            }
        }
        
        /// <remarks/>
        public uint MessageID {
            get {
                return this.messageIDField;
            }
            set {
                this.messageIDField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public partial class WCMessageSummary {
        
        private string senderField;
        
        private ulong senderContextField;
        
        private System.DateTime sentTimeField;
        
        private uint messageIDField;
        
        private WCMessageFlags messageFlagsField;
        
        private uint senderTitleIDField;
        
        private ushort expireMinutesField;
        
        private ushort detailsSizeField;
        
        private WCMessageType messageTypeField;
        
        /// <remarks/>
        public string Sender {
            get {
                return this.senderField;
            }
            set {
                this.senderField = value;
            }
        }
        
        /// <remarks/>
        public ulong SenderContext {
            get {
                return this.senderContextField;
            }
            set {
                this.senderContextField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime SentTime {
            get {
                return this.sentTimeField;
            }
            set {
                this.sentTimeField = value;
            }
        }
        
        /// <remarks/>
        public uint MessageID {
            get {
                return this.messageIDField;
            }
            set {
                this.messageIDField = value;
            }
        }
        
        /// <remarks/>
        public WCMessageFlags MessageFlags {
            get {
                return this.messageFlagsField;
            }
            set {
                this.messageFlagsField = value;
            }
        }
        
        /// <remarks/>
        public uint SenderTitleID {
            get {
                return this.senderTitleIDField;
            }
            set {
                this.senderTitleIDField = value;
            }
        }
        
        /// <remarks/>
        public ushort ExpireMinutes {
            get {
                return this.expireMinutesField;
            }
            set {
                this.expireMinutesField = value;
            }
        }
        
        /// <remarks/>
        public ushort DetailsSize {
            get {
                return this.detailsSizeField;
            }
            set {
                this.detailsSizeField = value;
            }
        }
        
        /// <remarks/>
        public WCMessageType MessageType {
            get {
                return this.messageTypeField;
            }
            set {
                this.messageTypeField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.FlagsAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public enum WCMessageFlags {
        
        /// <remarks/>
        Required = 1,
        
        /// <remarks/>
        Recommended = 2,
        
        /// <remarks/>
        HasVoice = 4,
        
        /// <remarks/>
        HasText = 8,
        
        /// <remarks/>
        Read = 16,
        
        /// <remarks/>
        NonExportable = 32,
        
        /// <remarks/>
        TeamContext = 64,
        
        /// <remarks/>
        CompContext = 128,
        
        /// <remarks/>
        AlternateTitle = 256,
        
        /// <remarks/>
        Marketing = 512,
        
        /// <remarks/>
        MSReserved0 = 1024,
        
        /// <remarks/>
        MSReserved1 = 2048,
        
        /// <remarks/>
        MSReserved2 = 4096,
        
        /// <remarks/>
        MSReserved3 = 8192,
        
        /// <remarks/>
        MSReserved4 = 16384,
        
        /// <remarks/>
        MSReserved5 = 32768,
        
        /// <remarks/>
        MSReserved6 = 65536,
        
        /// <remarks/>
        MSReserved7 = 131072,
        
        /// <remarks/>
        MSReserved8 = 262144,
        
        /// <remarks/>
        MSReserved9 = 524288,
        
        /// <remarks/>
        MSReserved10 = 1048576,
        
        /// <remarks/>
        MSReserved11 = 2097152,
        
        /// <remarks/>
        MSReserved12 = 4194304,
        
        /// <remarks/>
        MSReserved13 = 8388608,
        
        /// <remarks/>
        TitleReserved0 = 16777216,
        
        /// <remarks/>
        TitleReserved1 = 33554432,
        
        /// <remarks/>
        TitleReserved2 = 67108864,
        
        /// <remarks/>
        TitleReserved3 = 134217728,
        
        /// <remarks/>
        TitleReserved4 = 268435456,
        
        /// <remarks/>
        TitleReserved5 = 536870912,
        
        /// <remarks/>
        TitleReserved6 = 1073741824,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public enum WCMessageType {
        
        /// <remarks/>
        Invalid,
        
        /// <remarks/>
        TitleCustom,
        
        /// <remarks/>
        FriendRequest,
        
        /// <remarks/>
        GameInvite,
        
        /// <remarks/>
        TeamRecruit,
        
        /// <remarks/>
        CompReminder,
        
        /// <remarks/>
        CompRequest,
        
        /// <remarks/>
        LiveMessage,
        
        /// <remarks/>
        PersonalMessage,

        /// <remarks/>
        VideoMessage,
        
        /// <remarks/>
        QuickChatInvite,
        
        /// <remarks/>
        VideoChatInvite,
        
        /// <remarks/>
        PartyChatInvite,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public partial class WCUserTitle {
        
        private uint titleIDField;
        
        private System.DateTime lastLogonTimeField;
        
        private WCUserTitleFlags flagsField;
        
        /// <remarks/>
        public uint TitleID {
            get {
                return this.titleIDField;
            }
            set {
                this.titleIDField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime LastLogonTime {
            get {
                return this.lastLogonTimeField;
            }
            set {
                this.lastLogonTimeField = value;
            }
        }
        
        /// <remarks/>
        public WCUserTitleFlags Flags {
            get {
                return this.flagsField;
            }
            set {
                this.flagsField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.FlagsAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public enum WCUserTitleFlags {
        
        /// <remarks/>
        AcceptMarketing = 1,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public partial class WCTitleWideMessageSummary {
        
        private uint titleIDField;
        
        private ulong senderContextField;
        
        private System.DateTime sentTimeField;
        
        private uint regionField;
        
        private uint messageIDField;
        
        private WCMessageFlags messageFlagsField;
        
        private ushort expireMinutesField;
        
        private ushort detailsSizeField;
        
        private WCMessageType messageTypeField;
        
        private string senderNameField;
        
        private string descriptionField;
        
        /// <remarks/>
        public uint TitleID {
            get {
                return this.titleIDField;
            }
            set {
                this.titleIDField = value;
            }
        }
        
        /// <remarks/>
        public ulong SenderContext {
            get {
                return this.senderContextField;
            }
            set {
                this.senderContextField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime SentTime {
            get {
                return this.sentTimeField;
            }
            set {
                this.sentTimeField = value;
            }
        }
        
        /// <remarks/>
        public uint Region {
            get {
                return this.regionField;
            }
            set {
                this.regionField = value;
            }
        }
        
        /// <remarks/>
        public uint MessageID {
            get {
                return this.messageIDField;
            }
            set {
                this.messageIDField = value;
            }
        }
        
        /// <remarks/>
        public WCMessageFlags MessageFlags {
            get {
                return this.messageFlagsField;
            }
            set {
                this.messageFlagsField = value;
            }
        }
        
        /// <remarks/>
        public ushort ExpireMinutes {
            get {
                return this.expireMinutesField;
            }
            set {
                this.expireMinutesField = value;
            }
        }
        
        /// <remarks/>
        public ushort DetailsSize {
            get {
                return this.detailsSizeField;
            }
            set {
                this.detailsSizeField = value;
            }
        }
        
        /// <remarks/>
        public WCMessageType MessageType {
            get {
                return this.messageTypeField;
            }
            set {
                this.messageTypeField = value;
            }
        }
        
        /// <remarks/>
        public string SenderName {
            get {
                return this.senderNameField;
            }
            set {
                this.senderNameField = value;
            }
        }
        
        /// <remarks/>
        public string Description {
            get {
                return this.descriptionField;
            }
            set {
                this.descriptionField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public partial class WCLanguageString {
        
        private string localeField;
        
        private string stringField;
        
        /// <remarks/>
        public string Locale {
            get {
                return this.localeField;
            }
            set {
                this.localeField = value;
            }
        }
        
        /// <remarks/>
        public string String {
            get {
                return this.stringField;
            }
            set {
                this.stringField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public partial class WCLocalizedString {
        
        private byte propIDField;
        
        private string defaultLocaleField;
        
        private WCLanguageString[] langStringField;
        
        /// <remarks/>
        public byte PropID {
            get {
                return this.propIDField;
            }
            set {
                this.propIDField = value;
            }
        }
        
        /// <remarks/>
        public string DefaultLocale {
            get {
                return this.defaultLocaleField;
            }
            set {
                this.defaultLocaleField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("LangString")]
        public WCLanguageString[] LangString {
            get {
                return this.langStringField;
            }
            set {
                this.langStringField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public partial class WCMessageAttachment {
        
        private byte propIDField;
        
        private WCAttachFlags flagsField;
        
        private byte[] dataField;
        
        /// <remarks/>
        public byte PropID {
            get {
                return this.propIDField;
            }
            set {
                this.propIDField = value;
            }
        }
        
        /// <remarks/>
        public WCAttachFlags Flags {
            get {
                return this.flagsField;
            }
            set {
                this.flagsField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public byte[] Data {
            get {
                return this.dataField;
            }
            set {
                this.dataField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.FlagsAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public enum WCAttachFlags {
        
        /// <remarks/>
        NonExportable = 1,
        
        /// <remarks/>
        Directory = 2,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public partial class WCStringIdProp {
        
        private byte propIDField;
        
        private uint valueField;
        
        /// <remarks/>
        public byte PropID {
            get {
                return this.propIDField;
            }
            set {
                this.propIDField = value;
            }
        }
        
        /// <remarks/>
        public uint Value {
            get {
                return this.valueField;
            }
            set {
                this.valueField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public partial class WCBoolProp {
        
        private byte propIDField;
        
        private bool valueField;
        
        /// <remarks/>
        public byte PropID {
            get {
                return this.propIDField;
            }
            set {
                this.propIDField = value;
            }
        }
        
        /// <remarks/>
        public bool Value {
            get {
                return this.valueField;
            }
            set {
                this.valueField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public partial class WCAttachmentProp {
        
        private byte propIDField;
        
        private uint attachSizeField;
        
        private WCAttachFlags attachFlagsField;
        
        private string attachUrlField;
        
        /// <remarks/>
        public byte PropID {
            get {
                return this.propIDField;
            }
            set {
                this.propIDField = value;
            }
        }
        
        /// <remarks/>
        public uint AttachSize {
            get {
                return this.attachSizeField;
            }
            set {
                this.attachSizeField = value;
            }
        }
        
        /// <remarks/>
        public WCAttachFlags AttachFlags {
            get {
                return this.attachFlagsField;
            }
            set {
                this.attachFlagsField = value;
            }
        }
        
        /// <remarks/>
        public string AttachUrl {
            get {
                return this.attachUrlField;
            }
            set {
                this.attachUrlField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public partial class WCBinaryProp {
        
        private byte propIDField;
        
        private byte[] valueField;
        
        /// <remarks/>
        public byte PropID {
            get {
                return this.propIDField;
            }
            set {
                this.propIDField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public byte[] Value {
            get {
                return this.valueField;
            }
            set {
                this.valueField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public partial class WCTimeProp {
        
        private byte propIDField;
        
        private System.DateTime valueField;
        
        /// <remarks/>
        public byte PropID {
            get {
                return this.propIDField;
            }
            set {
                this.propIDField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime Value {
            get {
                return this.valueField;
            }
            set {
                this.valueField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public partial class WCStringProp {
        
        private byte propIDField;
        
        private string valueField;
        
        /// <remarks/>
        public byte PropID {
            get {
                return this.propIDField;
            }
            set {
                this.propIDField = value;
            }
        }
        
        /// <remarks/>
        public string Value {
            get {
                return this.valueField;
            }
            set {
                this.valueField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public partial class WCQwordProp {
        
        private byte propIDField;
        
        private ulong valueField;
        
        /// <remarks/>
        public byte PropID {
            get {
                return this.propIDField;
            }
            set {
                this.propIDField = value;
            }
        }
        
        /// <remarks/>
        public ulong Value {
            get {
                return this.valueField;
            }
            set {
                this.valueField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public partial class WCDwordProp {
        
        private byte propIDField;
        
        private uint valueField;
        
        /// <remarks/>
        public byte PropID {
            get {
                return this.propIDField;
            }
            set {
                this.propIDField = value;
            }
        }
        
        /// <remarks/>
        public uint Value {
            get {
                return this.valueField;
            }
            set {
                this.valueField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public partial class WCWordProp {
        
        private byte propIDField;
        
        private ushort valueField;
        
        /// <remarks/>
        public byte PropID {
            get {
                return this.propIDField;
            }
            set {
                this.propIDField = value;
            }
        }
        
        /// <remarks/>
        public ushort Value {
            get {
                return this.valueField;
            }
            set {
                this.valueField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public partial class WCByteProp {
        
        private byte propIDField;
        
        private byte valueField;
        
        /// <remarks/>
        public byte PropID {
            get {
                return this.propIDField;
            }
            set {
                this.propIDField = value;
            }
        }
        
        /// <remarks/>
        public byte Value {
            get {
                return this.valueField;
            }
            set {
                this.valueField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public partial class WCNullProp {
        
        private byte propIDField;
        
        /// <remarks/>
        public byte PropID {
            get {
                return this.propIDField;
            }
            set {
                this.propIDField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public partial class WCMessageDetails {
        
        private WCNullProp[] nullPropField;
        
        private WCByteProp[] bytePropField;
        
        private WCWordProp[] wordPropField;
        
        private WCDwordProp[] dwordPropField;
        
        private WCQwordProp[] qwordPropField;
        
        private WCStringProp[] stringPropField;
        
        private WCTimeProp[] timePropField;
        
        private WCBinaryProp[] binaryPropField;
        
        private WCAttachmentProp[] attachmentPropField;
        
        private WCBoolProp[] boolPropField;
        
        private WCStringIdProp[] stringIdPropField;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("NullProp")]
        public WCNullProp[] NullProp {
            get {
                return this.nullPropField;
            }
            set {
                this.nullPropField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("ByteProp")]
        public WCByteProp[] ByteProp {
            get {
                return this.bytePropField;
            }
            set {
                this.bytePropField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("WordProp")]
        public WCWordProp[] WordProp {
            get {
                return this.wordPropField;
            }
            set {
                this.wordPropField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("DwordProp")]
        public WCDwordProp[] DwordProp {
            get {
                return this.dwordPropField;
            }
            set {
                this.dwordPropField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("QwordProp")]
        public WCQwordProp[] QwordProp {
            get {
                return this.qwordPropField;
            }
            set {
                this.qwordPropField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("StringProp")]
        public WCStringProp[] StringProp {
            get {
                return this.stringPropField;
            }
            set {
                this.stringPropField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("TimeProp")]
        public WCTimeProp[] TimeProp {
            get {
                return this.timePropField;
            }
            set {
                this.timePropField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("BinaryProp")]
        public WCBinaryProp[] BinaryProp {
            get {
                return this.binaryPropField;
            }
            set {
                this.binaryPropField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("AttachmentProp")]
        public WCAttachmentProp[] AttachmentProp {
            get {
                return this.attachmentPropField;
            }
            set {
                this.attachmentPropField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("BoolProp")]
        public WCBoolProp[] BoolProp {
            get {
                return this.boolPropField;
            }
            set {
                this.boolPropField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("StringIdProp")]
        public WCStringIdProp[] StringIdProp {
            get {
                return this.stringIdPropField;
            }
            set {
                this.stringIdPropField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.FlagsAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public enum WCDeleteSysMsgFlags {
        
        /// <remarks/>
        RevokeAll = 1,
    }
    
    /// <remarks/>
    [System.FlagsAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Messaging/")]
    public enum WCDeleteMsgFlags {
        
        /// <remarks/>
        BlockSender = 1,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetMessageStringCompletedEventHandler(object sender, GetMessageStringCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetMessageStringCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetMessageStringCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void RevokeTitleUserMessageCompletedEventHandler(object sender, RevokeTitleUserMessageCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class RevokeTitleUserMessageCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal RevokeTitleUserMessageCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SendTitleUserMessageCompletedEventHandler(object sender, SendTitleUserMessageCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SendTitleUserMessageCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SendTitleUserMessageCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public WCRecipientResult[] RecipResult {
            get {
                this.RaiseExceptionIfNecessary();
                return ((WCRecipientResult[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SendTitleWideMessageCompletedEventHandler(object sender, SendTitleWideMessageCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SendTitleWideMessageCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SendTitleWideMessageCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public ushort Delay {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ushort)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public uint MessageID {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[2]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void DeleteTitleWideMessageCompletedEventHandler(object sender, DeleteTitleWideMessageCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class DeleteTitleWideMessageCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal DeleteTitleWideMessageCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetTitleWideMessageDetailsCompletedEventHandler(object sender, GetTitleWideMessageDetailsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetTitleWideMessageDetailsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetTitleWideMessageDetailsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public WCTitleWideMessageSummary Summary {
            get {
                this.RaiseExceptionIfNecessary();
                return ((WCTitleWideMessageSummary)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public WCMessageDetails Details {
            get {
                this.RaiseExceptionIfNecessary();
                return ((WCMessageDetails)(this.results[2]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void EnumTitleWideMessagesCompletedEventHandler(object sender, EnumTitleWideMessagesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class EnumTitleWideMessagesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal EnumTitleWideMessagesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public WCTitleWideMessageSummary[] Summary {
            get {
                this.RaiseExceptionIfNecessary();
                return ((WCTitleWideMessageSummary[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SetMessageFlagsCompletedEventHandler(object sender, SetMessageFlagsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SetMessageFlagsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SetMessageFlagsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void EnumUserTitlesCompletedEventHandler(object sender, EnumUserTitlesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class EnumUserTitlesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal EnumUserTitlesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public WCUserTitle[] Title {
            get {
                this.RaiseExceptionIfNecessary();
                return ((WCUserTitle[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void DeleteUserTitleCompletedEventHandler(object sender, DeleteUserTitleCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class DeleteUserTitleCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal DeleteUserTitleCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void RevokeMessageCompletedEventHandler(object sender, RevokeMessageCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class RevokeMessageCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal RevokeMessageCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SendMessageCompletedEventHandler(object sender, SendMessageCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SendMessageCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SendMessageCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public WCRecipientResult[] RecipResult {
            get {
                this.RaiseExceptionIfNecessary();
                return ((WCRecipientResult[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void DeleteMessageCompletedEventHandler(object sender, DeleteMessageCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class DeleteMessageCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal DeleteMessageCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetMessageDetailsCompletedEventHandler(object sender, GetMessageDetailsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetMessageDetailsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetMessageDetailsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public WCMessageSummary Summary {
            get {
                this.RaiseExceptionIfNecessary();
                return ((WCMessageSummary)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public WCMessageDetails Details {
            get {
                this.RaiseExceptionIfNecessary();
                return ((WCMessageDetails)(this.results[2]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void EnumMessagesCompletedEventHandler(object sender, EnumMessagesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class EnumMessagesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal EnumMessagesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public WCMessageSummary[] Summary {
            get {
                this.RaiseExceptionIfNecessary();
                return ((WCMessageSummary[])(this.results[1]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\WebReferences\WidgetAlerts\Reference.cs ===
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.42
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace ServerTestFramework.Web.Alert {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="AlertsSoap", Namespace="http://websvc.xboxlive.com/Alerts/")]
    public partial class Alerts : ServerTestFramework.Web.STFSoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback SubscriberExistsOperationCompleted;
        
        private System.Threading.SendOrPostCallback SubscribeOperationCompleted;
        
        private System.Threading.SendOrPostCallback UnsubscribeOperationCompleted;
        
        private System.Threading.SendOrPostCallback EnumerateSubscriptionsOperationCompleted;
        
        private System.Threading.SendOrPostCallback ScheduleContentAlertOperationCompleted;
        
        /// <remarks/>
        public Alerts() {
            this.ComputeUrl("wcalerts", "/alerts/alerts.asmx");
        }
        
        /// <remarks/>
        public event SubscriberExistsCompletedEventHandler SubscriberExistsCompleted;
        
        /// <remarks/>
        public event SubscribeCompletedEventHandler SubscribeCompleted;
        
        /// <remarks/>
        public event UnsubscribeCompletedEventHandler UnsubscribeCompleted;
        
        /// <remarks/>
        public event EnumerateSubscriptionsCompletedEventHandler EnumerateSubscriptionsCompleted;
        
        /// <remarks/>
        public event ScheduleContentAlertCompletedEventHandler ScheduleContentAlertCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Alerts/SubscriberExists", RequestNamespace="http://websvc.xboxlive.com/Alerts/", ResponseNamespace="http://websvc.xboxlive.com/Alerts/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public bool SubscriberExists([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webId) {
            object[] results = this.Invoke("SubscriberExists", new object[] {
                        webId});
            return ((bool)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSubscriberExists(byte[] webId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SubscriberExists", new object[] {
                        webId}, callback, asyncState);
        }
        
        /// <remarks/>
        public bool EndSubscriberExists(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((bool)(results[0]));
        }
        
        /// <remarks/>
        public void SubscriberExistsAsync(byte[] webId) {
            this.SubscriberExistsAsync(webId, null);
        }
        
        /// <remarks/>
        public void SubscriberExistsAsync(byte[] webId, object userState) {
            if ((this.SubscriberExistsOperationCompleted == null)) {
                this.SubscriberExistsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSubscriberExistsOperationCompleted);
            }
            this.InvokeAsync("SubscriberExists", new object[] {
                        webId}, this.SubscriberExistsOperationCompleted, userState);
        }
        
        private void OnSubscriberExistsOperationCompleted(object arg) {
            if ((this.SubscriberExistsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SubscriberExistsCompleted(this, new SubscriberExistsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Alerts/Subscribe", RequestNamespace="http://websvc.xboxlive.com/Alerts/", ResponseNamespace="http://websvc.xboxlive.com/Alerts/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public ExistingSubscriptions Subscribe(bool initializeSubscriber, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webId, string gamerTag, AddSubscriptions alerts) {
            object[] results = this.Invoke("Subscribe", new object[] {
                        initializeSubscriber,
                        webId,
                        gamerTag,
                        alerts});
            return ((ExistingSubscriptions)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSubscribe(bool initializeSubscriber, byte[] webId, string gamerTag, AddSubscriptions alerts, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("Subscribe", new object[] {
                        initializeSubscriber,
                        webId,
                        gamerTag,
                        alerts}, callback, asyncState);
        }
        
        /// <remarks/>
        public ExistingSubscriptions EndSubscribe(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((ExistingSubscriptions)(results[0]));
        }
        
        /// <remarks/>
        public void SubscribeAsync(bool initializeSubscriber, byte[] webId, string gamerTag, AddSubscriptions alerts) {
            this.SubscribeAsync(initializeSubscriber, webId, gamerTag, alerts, null);
        }
        
        /// <remarks/>
        public void SubscribeAsync(bool initializeSubscriber, byte[] webId, string gamerTag, AddSubscriptions alerts, object userState) {
            if ((this.SubscribeOperationCompleted == null)) {
                this.SubscribeOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSubscribeOperationCompleted);
            }
            this.InvokeAsync("Subscribe", new object[] {
                        initializeSubscriber,
                        webId,
                        gamerTag,
                        alerts}, this.SubscribeOperationCompleted, userState);
        }
        
        private void OnSubscribeOperationCompleted(object arg) {
            if ((this.SubscribeCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SubscribeCompleted(this, new SubscribeCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Alerts/Unsubscribe", RequestNamespace="http://websvc.xboxlive.com/Alerts/", ResponseNamespace="http://websvc.xboxlive.com/Alerts/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public uint Unsubscribe(bool deleteSubscriber, bool deleteAccountSubscriptions, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webId, string gamerTag, ExistingSubscriptions alerts) {
            object[] results = this.Invoke("Unsubscribe", new object[] {
                        deleteSubscriber,
                        deleteAccountSubscriptions,
                        webId,
                        gamerTag,
                        alerts});
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUnsubscribe(bool deleteSubscriber, bool deleteAccountSubscriptions, byte[] webId, string gamerTag, ExistingSubscriptions alerts, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("Unsubscribe", new object[] {
                        deleteSubscriber,
                        deleteAccountSubscriptions,
                        webId,
                        gamerTag,
                        alerts}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndUnsubscribe(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void UnsubscribeAsync(bool deleteSubscriber, bool deleteAccountSubscriptions, byte[] webId, string gamerTag, ExistingSubscriptions alerts) {
            this.UnsubscribeAsync(deleteSubscriber, deleteAccountSubscriptions, webId, gamerTag, alerts, null);
        }
        
        /// <remarks/>
        public void UnsubscribeAsync(bool deleteSubscriber, bool deleteAccountSubscriptions, byte[] webId, string gamerTag, ExistingSubscriptions alerts, object userState) {
            if ((this.UnsubscribeOperationCompleted == null)) {
                this.UnsubscribeOperationCompleted = new System.Threading.SendOrPostCallback(this.OnUnsubscribeOperationCompleted);
            }
            this.InvokeAsync("Unsubscribe", new object[] {
                        deleteSubscriber,
                        deleteAccountSubscriptions,
                        webId,
                        gamerTag,
                        alerts}, this.UnsubscribeOperationCompleted, userState);
        }
        
        private void OnUnsubscribeOperationCompleted(object arg) {
            if ((this.UnsubscribeCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.UnsubscribeCompleted(this, new UnsubscribeCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Alerts/EnumerateSubscriptions", RequestNamespace="http://websvc.xboxlive.com/Alerts/", ResponseNamespace="http://websvc.xboxlive.com/Alerts/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public ExistingSubscriptions EnumerateSubscriptions([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webId, string gamerTag) {
            object[] results = this.Invoke("EnumerateSubscriptions", new object[] {
                        webId,
                        gamerTag});
            return ((ExistingSubscriptions)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginEnumerateSubscriptions(byte[] webId, string gamerTag, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("EnumerateSubscriptions", new object[] {
                        webId,
                        gamerTag}, callback, asyncState);
        }
        
        /// <remarks/>
        public ExistingSubscriptions EndEnumerateSubscriptions(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((ExistingSubscriptions)(results[0]));
        }
        
        /// <remarks/>
        public void EnumerateSubscriptionsAsync(byte[] webId, string gamerTag) {
            this.EnumerateSubscriptionsAsync(webId, gamerTag, null);
        }
        
        /// <remarks/>
        public void EnumerateSubscriptionsAsync(byte[] webId, string gamerTag, object userState) {
            if ((this.EnumerateSubscriptionsOperationCompleted == null)) {
                this.EnumerateSubscriptionsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnEnumerateSubscriptionsOperationCompleted);
            }
            this.InvokeAsync("EnumerateSubscriptions", new object[] {
                        webId,
                        gamerTag}, this.EnumerateSubscriptionsOperationCompleted, userState);
        }
        
        private void OnEnumerateSubscriptionsOperationCompleted(object arg) {
            if ((this.EnumerateSubscriptionsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.EnumerateSubscriptionsCompleted(this, new EnumerateSubscriptionsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Alerts/ScheduleContentAlert", RequestNamespace="http://websvc.xboxlive.com/Alerts/", ResponseNamespace="http://websvc.xboxlive.com/Alerts/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public uint ScheduleContentAlert([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webId, uint type, string locale, string message, System.DateTime deliveryTime) {
            object[] results = this.Invoke("ScheduleContentAlert", new object[] {
                        webId,
                        type,
                        locale,
                        message,
                        deliveryTime});
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginScheduleContentAlert(byte[] webId, uint type, string locale, string message, System.DateTime deliveryTime, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ScheduleContentAlert", new object[] {
                        webId,
                        type,
                        locale,
                        message,
                        deliveryTime}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndScheduleContentAlert(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void ScheduleContentAlertAsync(byte[] webId, uint type, string locale, string message, System.DateTime deliveryTime) {
            this.ScheduleContentAlertAsync(webId, type, locale, message, deliveryTime, null);
        }
        
        /// <remarks/>
        public void ScheduleContentAlertAsync(byte[] webId, uint type, string locale, string message, System.DateTime deliveryTime, object userState) {
            if ((this.ScheduleContentAlertOperationCompleted == null)) {
                this.ScheduleContentAlertOperationCompleted = new System.Threading.SendOrPostCallback(this.OnScheduleContentAlertOperationCompleted);
            }
            this.InvokeAsync("ScheduleContentAlert", new object[] {
                        webId,
                        type,
                        locale,
                        message,
                        deliveryTime}, this.ScheduleContentAlertOperationCompleted, userState);
        }
        
        private void OnScheduleContentAlertOperationCompleted(object arg) {
            if ((this.ScheduleContentAlertCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ScheduleContentAlertCompleted(this, new ScheduleContentAlertCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Alerts/")]
    public partial class AddSubscriptions {
        
        private AlertSubscription[] liveSubscriptionsField;
        
        private AlertSubscription[] contentSubscriptionsField;
        
        /// <remarks/>
        public AlertSubscription[] liveSubscriptions {
            get {
                return this.liveSubscriptionsField;
            }
            set {
                this.liveSubscriptionsField = value;
            }
        }
        
        /// <remarks/>
        public AlertSubscription[] contentSubscriptions {
            get {
                return this.contentSubscriptionsField;
            }
            set {
                this.contentSubscriptionsField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Alerts/")]
    public partial class AlertSubscription {
        
        private uint typeField;
        
        private string localeField;
        
        /// <remarks/>
        public uint type {
            get {
                return this.typeField;
            }
            set {
                this.typeField = value;
            }
        }
        
        /// <remarks/>
        public string locale {
            get {
                return this.localeField;
            }
            set {
                this.localeField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Alerts/")]
    public partial class ContentSubscription {
        
        private ulong subscriptionIDField;
        
        private uint typeField;
        
        private string localeField;
        
        /// <remarks/>
        public ulong subscriptionID {
            get {
                return this.subscriptionIDField;
            }
            set {
                this.subscriptionIDField = value;
            }
        }
        
        /// <remarks/>
        public uint type {
            get {
                return this.typeField;
            }
            set {
                this.typeField = value;
            }
        }
        
        /// <remarks/>
        public string locale {
            get {
                return this.localeField;
            }
            set {
                this.localeField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Alerts/")]
    public partial class LiveSubscription {
        
        private ulong subscriptionIDField;
        
        private uint typeField;
        
        private string nameField;
        
        private string localeField;
        
        /// <remarks/>
        public ulong subscriptionID {
            get {
                return this.subscriptionIDField;
            }
            set {
                this.subscriptionIDField = value;
            }
        }
        
        /// <remarks/>
        public uint type {
            get {
                return this.typeField;
            }
            set {
                this.typeField = value;
            }
        }
        
        /// <remarks/>
        public string name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
        /// <remarks/>
        public string locale {
            get {
                return this.localeField;
            }
            set {
                this.localeField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Alerts/")]
    public partial class ExistingSubscriptions {
        
        private LiveSubscription[] liveSubscriptionsField;
        
        private ContentSubscription[] contentSubscriptionsField;
        
        /// <remarks/>
        public LiveSubscription[] liveSubscriptions {
            get {
                return this.liveSubscriptionsField;
            }
            set {
                this.liveSubscriptionsField = value;
            }
        }
        
        /// <remarks/>
        public ContentSubscription[] contentSubscriptions {
            get {
                return this.contentSubscriptionsField;
            }
            set {
                this.contentSubscriptionsField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SubscriberExistsCompletedEventHandler(object sender, SubscriberExistsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SubscriberExistsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SubscriberExistsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public bool Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SubscribeCompletedEventHandler(object sender, SubscribeCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SubscribeCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SubscribeCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public ExistingSubscriptions Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ExistingSubscriptions)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void UnsubscribeCompletedEventHandler(object sender, UnsubscribeCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class UnsubscribeCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal UnsubscribeCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void EnumerateSubscriptionsCompletedEventHandler(object sender, EnumerateSubscriptionsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class EnumerateSubscriptionsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal EnumerateSubscriptionsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public ExistingSubscriptions Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ExistingSubscriptions)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ScheduleContentAlertCompletedEventHandler(object sender, ScheduleContentAlertCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ScheduleContentAlertCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ScheduleContentAlertCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\WebReferences\WidgetProfile\Reference.cs ===
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.42
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace ServerTestFramework.Web.Profile {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="ProfileSoap", Namespace="http://websvc.xboxlive.com/Profile/")]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(UserSetting[]))]
    public partial class Profile : ServerTestFramework.Web.STFSoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback ReadAchievementsOperationCompleted;
        
        private System.Threading.SendOrPostCallback ReadSettingsOperationCompleted;
        
        /// <remarks/>
        public Profile() {
            this.ComputeUrl("wcprofile", "/profile/profile.asmx");
        }
        
        /// <remarks/>
        public event ReadAchievementsCompletedEventHandler ReadAchievementsCompleted;
        
        /// <remarks/>
        public event ReadSettingsCompletedEventHandler ReadSettingsCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Profile/ReadAchievements", RequestNamespace="http://websvc.xboxlive.com/Profile/", ResponseNamespace="http://websvc.xboxlive.com/Profile/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public wcAchievement[] ReadAchievements(ulong ul64Xuid, uint uiTitleID, ushort uslocaleId, ulong ul64ForXuid) {
            object[] results = this.Invoke("ReadAchievements", new object[] {
                        ul64Xuid,
                        uiTitleID,
                        uslocaleId,
                        ul64ForXuid});
            return ((wcAchievement[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginReadAchievements(ulong ul64Xuid, uint uiTitleID, ushort uslocaleId, ulong ul64ForXuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ReadAchievements", new object[] {
                        ul64Xuid,
                        uiTitleID,
                        uslocaleId,
                        ul64ForXuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public wcAchievement[] EndReadAchievements(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((wcAchievement[])(results[0]));
        }
        
        /// <remarks/>
        public void ReadAchievementsAsync(ulong ul64Xuid, uint uiTitleID, ushort uslocaleId, ulong ul64ForXuid) {
            this.ReadAchievementsAsync(ul64Xuid, uiTitleID, uslocaleId, ul64ForXuid, null);
        }
        
        /// <remarks/>
        public void ReadAchievementsAsync(ulong ul64Xuid, uint uiTitleID, ushort uslocaleId, ulong ul64ForXuid, object userState) {
            if ((this.ReadAchievementsOperationCompleted == null)) {
                this.ReadAchievementsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnReadAchievementsOperationCompleted);
            }
            this.InvokeAsync("ReadAchievements", new object[] {
                        ul64Xuid,
                        uiTitleID,
                        uslocaleId,
                        ul64ForXuid}, this.ReadAchievementsOperationCompleted, userState);
        }
        
        private void OnReadAchievementsOperationCompleted(object arg) {
            if ((this.ReadAchievementsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ReadAchievementsCompleted(this, new ReadAchievementsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Profile/ReadSettings", RequestNamespace="http://websvc.xboxlive.com/Profile/", ResponseNamespace="http://websvc.xboxlive.com/Profile/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public UserSetting[] ReadSettings(ulong ulXuid, uint uiTitleID, ushort usLocaleId, ulong[] arrulForXuid, uint[] arruiSettings) {
            object[] results = this.Invoke("ReadSettings", new object[] {
                        ulXuid,
                        uiTitleID,
                        usLocaleId,
                        arrulForXuid,
                        arruiSettings});
            return ((UserSetting[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginReadSettings(ulong ulXuid, uint uiTitleID, ushort usLocaleId, ulong[] arrulForXuid, uint[] arruiSettings, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ReadSettings", new object[] {
                        ulXuid,
                        uiTitleID,
                        usLocaleId,
                        arrulForXuid,
                        arruiSettings}, callback, asyncState);
        }
        
        /// <remarks/>
        public UserSetting[] EndReadSettings(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((UserSetting[])(results[0]));
        }
        
        /// <remarks/>
        public void ReadSettingsAsync(ulong ulXuid, uint uiTitleID, ushort usLocaleId, ulong[] arrulForXuid, uint[] arruiSettings) {
            this.ReadSettingsAsync(ulXuid, uiTitleID, usLocaleId, arrulForXuid, arruiSettings, null);
        }
        
        /// <remarks/>
        public void ReadSettingsAsync(ulong ulXuid, uint uiTitleID, ushort usLocaleId, ulong[] arrulForXuid, uint[] arruiSettings, object userState) {
            if ((this.ReadSettingsOperationCompleted == null)) {
                this.ReadSettingsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnReadSettingsOperationCompleted);
            }
            this.InvokeAsync("ReadSettings", new object[] {
                        ulXuid,
                        uiTitleID,
                        usLocaleId,
                        arrulForXuid,
                        arruiSettings}, this.ReadSettingsOperationCompleted, userState);
        }
        
        private void OnReadSettingsOperationCompleted(object arg) {
            if ((this.ReadSettingsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ReadSettingsCompleted(this, new ReadSettingsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Profile/")]
    public partial class wcAchievement {
        
        private uint uiAchievementIdField;
        
        private System.DateTime dtAchievedField;
        
        private int nFlagsField;
        
        private byte byTypeField;
        
        private int nCredField;
        
        private uint nImageIdField;
        
        private string szTitleField;
        
        private string szDescriptionField;
        
        private string szHowToField;
        
        /// <remarks/>
        public uint uiAchievementId {
            get {
                return this.uiAchievementIdField;
            }
            set {
                this.uiAchievementIdField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime dtAchieved {
            get {
                return this.dtAchievedField;
            }
            set {
                this.dtAchievedField = value;
            }
        }
        
        /// <remarks/>
        public int nFlags {
            get {
                return this.nFlagsField;
            }
            set {
                this.nFlagsField = value;
            }
        }
        
        /// <remarks/>
        public byte byType {
            get {
                return this.byTypeField;
            }
            set {
                this.byTypeField = value;
            }
        }
        
        /// <remarks/>
        public int nCred {
            get {
                return this.nCredField;
            }
            set {
                this.nCredField = value;
            }
        }
        
        /// <remarks/>
        public uint nImageId {
            get {
                return this.nImageIdField;
            }
            set {
                this.nImageIdField = value;
            }
        }
        
        /// <remarks/>
        public string szTitle {
            get {
                return this.szTitleField;
            }
            set {
                this.szTitleField = value;
            }
        }
        
        /// <remarks/>
        public string szDescription {
            get {
                return this.szDescriptionField;
            }
            set {
                this.szDescriptionField = value;
            }
        }
        
        /// <remarks/>
        public string szHowTo {
            get {
                return this.szHowToField;
            }
            set {
                this.szHowToField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Profile/")]
    public partial class UserSetting {
        
        private ulong ulUserIdField;
        
        private uint uiSettingIdField;
        
        private object valueField;
        
        private ReadProfileStatus statusField;
        
        /// <remarks/>
        public ulong ulUserId {
            get {
                return this.ulUserIdField;
            }
            set {
                this.ulUserIdField = value;
            }
        }
        
        /// <remarks/>
        public uint uiSettingId {
            get {
                return this.uiSettingIdField;
            }
            set {
                this.uiSettingIdField = value;
            }
        }
        
        /// <remarks/>
        public object value {
            get {
                return this.valueField;
            }
            set {
                this.valueField = value;
            }
        }
        
        /// <remarks/>
        public ReadProfileStatus status {
            get {
                return this.statusField;
            }
            set {
                this.statusField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Profile/")]
    public enum ReadProfileStatus {
        
        /// <remarks/>
        SUCCESS_TITLE,
        
        /// <remarks/>
        SUCCESS_DEFAULT,
        
        /// <remarks/>
        WARNING_NO_VALUE,
        
        /// <remarks/>
        ERROR_NO_PERMISSION,
        
        /// <remarks/>
        ERROR_PUID_INVALID,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ReadAchievementsCompletedEventHandler(object sender, ReadAchievementsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ReadAchievementsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ReadAchievementsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public wcAchievement[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((wcAchievement[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ReadSettingsCompletedEventHandler(object sender, ReadSettingsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ReadSettingsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ReadSettingsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public UserSetting[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((UserSetting[])(this.results[0]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\WebReferences\WidgetSignature\Reference.cs ===
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1378
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace ServerTestFramework.Web.SignatureWidget
{
    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Web.Services;
    using System.Web.Services.Protocols;
    using System.Xml.Serialization;

    // 
    // This source code was auto-generated by wsdl, Version=2.0.50727.42.
    // 


    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name = "SignatureSoap", Namespace = "http://websvc.xboxlive.com/Signature/")]
    public partial class Signature : ServerTestFramework.Web.STFSoapHttpClientProtocol
    {

        private System.Threading.SendOrPostCallback VerifySignatureOperationCompleted;

        private System.Threading.SendOrPostCallback CreateSignatureOperationCompleted;

        private System.Threading.SendOrPostCallback TransferUserLicensesOperationCompleted;

        private System.Threading.SendOrPostCallback BlacklistDigestOperationCompleted;

        private System.Threading.SendOrPostCallback UnBlacklistDigestOperationCompleted;

        /// <remarks/>
        public Signature()
        {
            this.ComputeUrl("wcsignature", "/signature/signature.asmx");
        }

        /// <remarks/>
        public event VerifySignatureCompletedEventHandler VerifySignatureCompleted;

        /// <remarks/>
        public event CreateSignatureCompletedEventHandler CreateSignatureCompleted;

        /// <remarks/>
        public event TransferUserLicensesCompletedEventHandler TransferUserLicensesCompleted;

        /// <remarks/>
        public event BlacklistDigestCompletedEventHandler BlacklistDigestCompleted;

        /// <remarks/>
        public event UnBlacklistDigestCompletedEventHandler UnBlacklistDigestCompleted;

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Signature/VerifySignature", RequestNamespace = "http://websvc.xboxlive.com/Signature/", ResponseNamespace = "http://websvc.xboxlive.com/Signature/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public uint[] VerifySignature(XSigVerifySignatureRequest[] sigData)
        {
            object[] results = this.Invoke("VerifySignature", new object[] {
                    sigData});
            return ((uint[])(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginVerifySignature(XSigVerifySignatureRequest[] sigData, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("VerifySignature", new object[] {
                    sigData}, callback, asyncState);
        }

        /// <remarks/>
        public uint[] EndVerifySignature(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((uint[])(results[0]));
        }

        /// <remarks/>
        public void VerifySignatureAsync(XSigVerifySignatureRequest[] sigData)
        {
            this.VerifySignatureAsync(sigData, null);
        }

        /// <remarks/>
        public void VerifySignatureAsync(XSigVerifySignatureRequest[] sigData, object userState)
        {
            if ((this.VerifySignatureOperationCompleted == null))
            {
                this.VerifySignatureOperationCompleted = new System.Threading.SendOrPostCallback(this.OnVerifySignatureOperationCompleted);
            }
            this.InvokeAsync("VerifySignature", new object[] {
                    sigData}, this.VerifySignatureOperationCompleted, userState);
        }

        private void OnVerifySignatureOperationCompleted(object arg)
        {
            if ((this.VerifySignatureCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.VerifySignatureCompleted(this, new VerifySignatureCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Signature/CreateSignature", RequestNamespace = "http://websvc.xboxlive.com/Signature/", ResponseNamespace = "http://websvc.xboxlive.com/Signature/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public XSigCreateSignatureResponse[] CreateSignature(uint titleID, string adminId, XSigCreateSignatureRequest[] sigData)
        {
            object[] results = this.Invoke("CreateSignature", new object[] {
                    titleID,
                    adminId,
                    sigData});
            return ((XSigCreateSignatureResponse[])(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginCreateSignature(uint titleID, string adminId, XSigCreateSignatureRequest[] sigData, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("CreateSignature", new object[] {
                    titleID,
                    adminId,
                    sigData}, callback, asyncState);
        }

        /// <remarks/>
        public XSigCreateSignatureResponse[] EndCreateSignature(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((XSigCreateSignatureResponse[])(results[0]));
        }

        /// <remarks/>
        public void CreateSignatureAsync(uint titleID, string adminId, XSigCreateSignatureRequest[] sigData)
        {
            this.CreateSignatureAsync(titleID, adminId, sigData, null);
        }

        /// <remarks/>
        public void CreateSignatureAsync(uint titleID, string adminId, XSigCreateSignatureRequest[] sigData, object userState)
        {
            if ((this.CreateSignatureOperationCompleted == null))
            {
                this.CreateSignatureOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCreateSignatureOperationCompleted);
            }
            this.InvokeAsync("CreateSignature", new object[] {
                    titleID,
                    adminId,
                    sigData}, this.CreateSignatureOperationCompleted, userState);
        }

        private void OnCreateSignatureOperationCompleted(object arg)
        {
            if ((this.CreateSignatureCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CreateSignatureCompleted(this, new CreateSignatureCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Signature/TransferUserLicenses", RequestNamespace = "http://websvc.xboxlive.com/Signature/", ResponseNamespace = "http://websvc.xboxlive.com/Signature/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void TransferUserLicenses(ulong xuid, string consoleId)
        {
            this.Invoke("TransferUserLicenses", new object[] {
                    xuid,
                    consoleId});
        }

        /// <remarks/>
        public System.IAsyncResult BeginTransferUserLicenses(ulong xuid, string consoleId, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("TransferUserLicenses", new object[] {
                    xuid,
                    consoleId}, callback, asyncState);
        }

        /// <remarks/>
        public void EndTransferUserLicenses(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void TransferUserLicensesAsync(ulong xuid, string consoleId)
        {
            this.TransferUserLicensesAsync(xuid, consoleId, null);
        }

        /// <remarks/>
        public void TransferUserLicensesAsync(ulong xuid, string consoleId, object userState)
        {
            if ((this.TransferUserLicensesOperationCompleted == null))
            {
                this.TransferUserLicensesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnTransferUserLicensesOperationCompleted);
            }
            this.InvokeAsync("TransferUserLicenses", new object[] {
                    xuid,
                    consoleId}, this.TransferUserLicensesOperationCompleted, userState);
        }

        private void OnTransferUserLicensesOperationCompleted(object arg)
        {
            if ((this.TransferUserLicensesCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.TransferUserLicensesCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Signature/BlacklistDigest", RequestNamespace = "http://websvc.xboxlive.com/Signature/", ResponseNamespace = "http://websvc.xboxlive.com/Signature/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void BlacklistDigest([System.Xml.Serialization.XmlElementAttribute(DataType = "base64Binary")] byte[] digest, byte deliveryType, string revocationReason)
        {
            this.Invoke("BlacklistDigest", new object[] {
                    digest,
                    deliveryType,
                    revocationReason});
        }

        /// <remarks/>
        public System.IAsyncResult BeginBlacklistDigest(byte[] digest, byte deliveryType, string revocationReason, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("BlacklistDigest", new object[] {
                    digest,
                    deliveryType,
                    revocationReason}, callback, asyncState);
        }

        /// <remarks/>
        public void EndBlacklistDigest(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void BlacklistDigestAsync(byte[] digest, byte deliveryType, string revocationReason)
        {
            this.BlacklistDigestAsync(digest, deliveryType, revocationReason, null);
        }

        /// <remarks/>
        public void BlacklistDigestAsync(byte[] digest, byte deliveryType, string revocationReason, object userState)
        {
            if ((this.BlacklistDigestOperationCompleted == null))
            {
                this.BlacklistDigestOperationCompleted = new System.Threading.SendOrPostCallback(this.OnBlacklistDigestOperationCompleted);
            }
            this.InvokeAsync("BlacklistDigest", new object[] {
                    digest,
                    deliveryType,
                    revocationReason}, this.BlacklistDigestOperationCompleted, userState);
        }

        private void OnBlacklistDigestOperationCompleted(object arg)
        {
            if ((this.BlacklistDigestCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.BlacklistDigestCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Signature/UnBlacklistDigest", RequestNamespace = "http://websvc.xboxlive.com/Signature/", ResponseNamespace = "http://websvc.xboxlive.com/Signature/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void UnBlacklistDigest([System.Xml.Serialization.XmlElementAttribute(DataType = "base64Binary")] byte[] digest)
        {
            this.Invoke("UnBlacklistDigest", new object[] {
                    digest});
        }

        /// <remarks/>
        public System.IAsyncResult BeginUnBlacklistDigest(byte[] digest, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("UnBlacklistDigest", new object[] {
                    digest}, callback, asyncState);
        }

        /// <remarks/>
        public void EndUnBlacklistDigest(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void UnBlacklistDigestAsync(byte[] digest)
        {
            this.UnBlacklistDigestAsync(digest, null);
        }

        /// <remarks/>
        public void UnBlacklistDigestAsync(byte[] digest, object userState)
        {
            if ((this.UnBlacklistDigestOperationCompleted == null))
            {
                this.UnBlacklistDigestOperationCompleted = new System.Threading.SendOrPostCallback(this.OnUnBlacklistDigestOperationCompleted);
            }
            this.InvokeAsync("UnBlacklistDigest", new object[] {
                    digest}, this.UnBlacklistDigestOperationCompleted, userState);
        }

        private void OnUnBlacklistDigestOperationCompleted(object arg)
        {
            if ((this.UnBlacklistDigestCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.UnBlacklistDigestCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        public new void CancelAsync(object userState)
        {
            base.CancelAsync(userState);
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://websvc.xboxlive.com/Signature/")]
    public partial class XSigVerifySignatureRequest
    {

        private byte[] _digestField;

        private byte[] _signatureField;

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType = "base64Binary")]
        public byte[] _digest
        {
            get
            {
                return this._digestField;
            }
            set
            {
                this._digestField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType = "base64Binary")]
        public byte[] _signature
        {
            get
            {
                return this._signatureField;
            }
            set
            {
                this._signatureField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://websvc.xboxlive.com/Signature/")]
    public partial class XSigCreateSignatureResponse
    {

        private uint _hresultField;

        private byte[] _signatureField;

        /// <remarks/>
        public uint _hresult
        {
            get
            {
                return this._hresultField;
            }
            set
            {
                this._hresultField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType = "base64Binary")]
        public byte[] _signature
        {
            get
            {
                return this._signatureField;
            }
            set
            {
                this._signatureField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://websvc.xboxlive.com/Signature/")]
    public partial class XSigCreateSignatureRequest
    {

        private byte[] _digestField;

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType = "base64Binary")]
        public byte[] _digest
        {
            get
            {
                return this._digestField;
            }
            set
            {
                this._digestField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void VerifySignatureCompletedEventHandler(object sender, VerifySignatureCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class VerifySignatureCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal VerifySignatureCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public uint[] Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((uint[])(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CreateSignatureCompletedEventHandler(object sender, CreateSignatureCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CreateSignatureCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal CreateSignatureCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public XSigCreateSignatureResponse[] Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((XSigCreateSignatureResponse[])(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void TransferUserLicensesCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void BlacklistDigestCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void UnBlacklistDigestCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\WebReferences\WidgetPresence\Reference.cs ===
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.312
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
namespace ServerTestFramework.Web.Presence
{
    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Web.Services;
    using System.Web.Services.Protocols;
    using System.Xml.Serialization;

    // 
    // This source code was auto-generated by wsdl, Version=2.0.50727.42.
    // 


    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name = "PresenceSoap", Namespace = "http://websvc.xboxlive.com/Presence/")]
    public partial class Presence : ServerTestFramework.Web.STFSoapHttpClientProtocol
    {

        private System.Threading.SendOrPostCallback GetGamertagsFromXUIDSOperationCompleted;

        private System.Threading.SendOrPostCallback GetXUIDSFromGamertagsOperationCompleted;

        private System.Threading.SendOrPostCallback GetPresenceInfoOperationCompleted;

        private System.Threading.SendOrPostCallback GetFriendsExOperationCompleted;

        private System.Threading.SendOrPostCallback GetRecentPlayersOperationCompleted;

        private System.Threading.SendOrPostCallback GetFriendsOperationCompleted;

        /// <remarks/>
        public Presence()
        {
            this.ComputeUrl("wcpresence", "/Presence/Presence.asmx");
        }

        /// <remarks/>
        public event GetGamertagsFromXUIDSCompletedEventHandler GetGamertagsFromXUIDSCompleted;

        /// <remarks/>
        public event GetXUIDSFromGamertagsCompletedEventHandler GetXUIDSFromGamertagsCompleted;

        /// <remarks/>
        public event GetPresenceInfoCompletedEventHandler GetPresenceInfoCompleted;

        /// <remarks/>
        public event GetFriendsExCompletedEventHandler GetFriendsExCompleted;

        /// <remarks/>
        public event GetRecentPlayersCompletedEventHandler GetRecentPlayersCompleted;

        /// <remarks/>
        public event GetFriendsCompletedEventHandler GetFriendsCompleted;

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Presence/GetGamertagsFromXUIDS", RequestNamespace = "http://websvc.xboxlive.com/Presence/", ResponseNamespace = "http://websvc.xboxlive.com/Presence/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string[] GetGamertagsFromXUIDS(ulong[] XUIDS)
        {
            object[] results = this.Invoke("GetGamertagsFromXUIDS", new object[] {
                    XUIDS});
            return ((string[])(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetGamertagsFromXUIDS(ulong[] XUIDS, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetGamertagsFromXUIDS", new object[] {
                    XUIDS}, callback, asyncState);
        }

        /// <remarks/>
        public string[] EndGetGamertagsFromXUIDS(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string[])(results[0]));
        }

        /// <remarks/>
        public void GetGamertagsFromXUIDSAsync(ulong[] XUIDS)
        {
            this.GetGamertagsFromXUIDSAsync(XUIDS, null);
        }

        /// <remarks/>
        public void GetGamertagsFromXUIDSAsync(ulong[] XUIDS, object userState)
        {
            if ((this.GetGamertagsFromXUIDSOperationCompleted == null))
            {
                this.GetGamertagsFromXUIDSOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetGamertagsFromXUIDSOperationCompleted);
            }
            this.InvokeAsync("GetGamertagsFromXUIDS", new object[] {
                    XUIDS}, this.GetGamertagsFromXUIDSOperationCompleted, userState);
        }

        private void OnGetGamertagsFromXUIDSOperationCompleted(object arg)
        {
            if ((this.GetGamertagsFromXUIDSCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetGamertagsFromXUIDSCompleted(this, new GetGamertagsFromXUIDSCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Presence/GetXUIDSFromGamertags", RequestNamespace = "http://websvc.xboxlive.com/Presence/", ResponseNamespace = "http://websvc.xboxlive.com/Presence/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public ulong[] GetXUIDSFromGamertags(string[] gamertags)
        {
            object[] results = this.Invoke("GetXUIDSFromGamertags", new object[] {
                    gamertags});
            return ((ulong[])(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetXUIDSFromGamertags(string[] gamertags, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetXUIDSFromGamertags", new object[] {
                    gamertags}, callback, asyncState);
        }

        /// <remarks/>
        public ulong[] EndGetXUIDSFromGamertags(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((ulong[])(results[0]));
        }

        /// <remarks/>
        public void GetXUIDSFromGamertagsAsync(string[] gamertags)
        {
            this.GetXUIDSFromGamertagsAsync(gamertags, null);
        }

        /// <remarks/>
        public void GetXUIDSFromGamertagsAsync(string[] gamertags, object userState)
        {
            if ((this.GetXUIDSFromGamertagsOperationCompleted == null))
            {
                this.GetXUIDSFromGamertagsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetXUIDSFromGamertagsOperationCompleted);
            }
            this.InvokeAsync("GetXUIDSFromGamertags", new object[] {
                    gamertags}, this.GetXUIDSFromGamertagsOperationCompleted, userState);
        }

        private void OnGetXUIDSFromGamertagsOperationCompleted(object arg)
        {
            if ((this.GetXUIDSFromGamertagsCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetXUIDSFromGamertagsCompleted(this, new GetXUIDSFromGamertagsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Presence/GetPresenceInfo", RequestNamespace = "http://websvc.xboxlive.com/Presence/", ResponseNamespace = "http://websvc.xboxlive.com/Presence/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public PresenceInfo GetPresenceInfo(ulong targetXUID, ulong senderXUID, ushort senderLocale, out uint ValidSeconds)
        {
            object[] results = this.Invoke("GetPresenceInfo", new object[] {
                    targetXUID,
                    senderXUID,
                    senderLocale});
            ValidSeconds = ((uint)(results[1]));
            return ((PresenceInfo)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetPresenceInfo(ulong targetXUID, ulong senderXUID, ushort senderLocale, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetPresenceInfo", new object[] {
                    targetXUID,
                    senderXUID,
                    senderLocale}, callback, asyncState);
        }

        /// <remarks/>
        public PresenceInfo EndGetPresenceInfo(System.IAsyncResult asyncResult, out uint ValidSeconds)
        {
            object[] results = this.EndInvoke(asyncResult);
            ValidSeconds = ((uint)(results[1]));
            return ((PresenceInfo)(results[0]));
        }

        /// <remarks/>
        public void GetPresenceInfoAsync(ulong targetXUID, ulong senderXUID, ushort senderLocale)
        {
            this.GetPresenceInfoAsync(targetXUID, senderXUID, senderLocale, null);
        }

        /// <remarks/>
        public void GetPresenceInfoAsync(ulong targetXUID, ulong senderXUID, ushort senderLocale, object userState)
        {
            if ((this.GetPresenceInfoOperationCompleted == null))
            {
                this.GetPresenceInfoOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetPresenceInfoOperationCompleted);
            }
            this.InvokeAsync("GetPresenceInfo", new object[] {
                    targetXUID,
                    senderXUID,
                    senderLocale}, this.GetPresenceInfoOperationCompleted, userState);
        }

        private void OnGetPresenceInfoOperationCompleted(object arg)
        {
            if ((this.GetPresenceInfoCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetPresenceInfoCompleted(this, new GetPresenceInfoCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Presence/GetFriendsEx", RequestNamespace = "http://websvc.xboxlive.com/Presence/", ResponseNamespace = "http://websvc.xboxlive.com/Presence/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public FriendEx[] GetFriendsEx(ulong XUID, ushort locale, out uint ValidSeconds)
        {
            object[] results = this.Invoke("GetFriendsEx", new object[] {
                    XUID,
                    locale});
            ValidSeconds = ((uint)(results[1]));
            return ((FriendEx[])(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetFriendsEx(ulong XUID, ushort locale, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetFriendsEx", new object[] {
                    XUID,
                    locale}, callback, asyncState);
        }

        /// <remarks/>
        public FriendEx[] EndGetFriendsEx(System.IAsyncResult asyncResult, out uint ValidSeconds)
        {
            object[] results = this.EndInvoke(asyncResult);
            ValidSeconds = ((uint)(results[1]));
            return ((FriendEx[])(results[0]));
        }

        /// <remarks/>
        public void GetFriendsExAsync(ulong XUID, ushort locale)
        {
            this.GetFriendsExAsync(XUID, locale, null);
        }

        /// <remarks/>
        public void GetFriendsExAsync(ulong XUID, ushort locale, object userState)
        {
            if ((this.GetFriendsExOperationCompleted == null))
            {
                this.GetFriendsExOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetFriendsExOperationCompleted);
            }
            this.InvokeAsync("GetFriendsEx", new object[] {
                    XUID,
                    locale}, this.GetFriendsExOperationCompleted, userState);
        }

        private void OnGetFriendsExOperationCompleted(object arg)
        {
            if ((this.GetFriendsExCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetFriendsExCompleted(this, new GetFriendsExCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Presence/GetRecentPlayers", RequestNamespace = "http://websvc.xboxlive.com/Presence/", ResponseNamespace = "http://websvc.xboxlive.com/Presence/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public RecentPlayer[] GetRecentPlayers(ulong xuid, ushort maxRequest, ushort locale)
        {
            object[] results = this.Invoke("GetRecentPlayers", new object[] {
                    xuid,
                    maxRequest,
                    locale});
            return ((RecentPlayer[])(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetRecentPlayers(ulong xuid, ushort maxRequest, ushort locale, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetRecentPlayers", new object[] {
                    xuid,
                    maxRequest,
                    locale}, callback, asyncState);
        }

        /// <remarks/>
        public RecentPlayer[] EndGetRecentPlayers(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((RecentPlayer[])(results[0]));
        }

        /// <remarks/>
        public void GetRecentPlayersAsync(ulong xuid, ushort maxRequest, ushort locale)
        {
            this.GetRecentPlayersAsync(xuid, maxRequest, locale, null);
        }

        /// <remarks/>
        public void GetRecentPlayersAsync(ulong xuid, ushort maxRequest, ushort locale, object userState)
        {
            if ((this.GetRecentPlayersOperationCompleted == null))
            {
                this.GetRecentPlayersOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRecentPlayersOperationCompleted);
            }
            this.InvokeAsync("GetRecentPlayers", new object[] {
                    xuid,
                    maxRequest,
                    locale}, this.GetRecentPlayersOperationCompleted, userState);
        }

        private void OnGetRecentPlayersOperationCompleted(object arg)
        {
            if ((this.GetRecentPlayersCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRecentPlayersCompleted(this, new GetRecentPlayersCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Presence/GetFriends", RequestNamespace = "http://websvc.xboxlive.com/Presence/", ResponseNamespace = "http://websvc.xboxlive.com/Presence/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public FriendsInfo GetFriends([System.Xml.Serialization.XmlElementAttribute(DataType = "base64Binary")] byte[] WebID, string GamerTag, out uint ValidSeconds)
        {
            object[] results = this.Invoke("GetFriends", new object[] {
                    WebID,
                    GamerTag});
            ValidSeconds = ((uint)(results[1]));
            return ((FriendsInfo)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetFriends(byte[] WebID, string GamerTag, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetFriends", new object[] {
                    WebID,
                    GamerTag}, callback, asyncState);
        }

        /// <remarks/>
        public FriendsInfo EndGetFriends(System.IAsyncResult asyncResult, out uint ValidSeconds)
        {
            object[] results = this.EndInvoke(asyncResult);
            ValidSeconds = ((uint)(results[1]));
            return ((FriendsInfo)(results[0]));
        }

        /// <remarks/>
        public void GetFriendsAsync(byte[] WebID, string GamerTag)
        {
            this.GetFriendsAsync(WebID, GamerTag, null);
        }

        /// <remarks/>
        public void GetFriendsAsync(byte[] WebID, string GamerTag, object userState)
        {
            if ((this.GetFriendsOperationCompleted == null))
            {
                this.GetFriendsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetFriendsOperationCompleted);
            }
            this.InvokeAsync("GetFriends", new object[] {
                    WebID,
                    GamerTag}, this.GetFriendsOperationCompleted, userState);
        }

        private void OnGetFriendsOperationCompleted(object arg)
        {
            if ((this.GetFriendsCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetFriendsCompleted(this, new GetFriendsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        public new void CancelAsync(object userState)
        {
            base.CancelAsync(userState);
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://websvc.xboxlive.com/Presence/")]
    public partial class PresenceInfo
    {

        private ulong xUIDField;

        private string gamerTagField;

        private uint onlineStateField;

        private uint lastSeenTitleField;

        private uint minutesSinceStateChangeField;

        private string richPresenceStringField;

        /// <remarks/>
        public ulong XUID
        {
            get
            {
                return this.xUIDField;
            }
            set
            {
                this.xUIDField = value;
            }
        }

        /// <remarks/>
        public string GamerTag
        {
            get
            {
                return this.gamerTagField;
            }
            set
            {
                this.gamerTagField = value;
            }
        }

        /// <remarks/>
        public uint OnlineState
        {
            get
            {
                return this.onlineStateField;
            }
            set
            {
                this.onlineStateField = value;
            }
        }

        /// <remarks/>
        public uint LastSeenTitle
        {
            get
            {
                return this.lastSeenTitleField;
            }
            set
            {
                this.lastSeenTitleField = value;
            }
        }

        /// <remarks/>
        public uint MinutesSinceStateChange
        {
            get
            {
                return this.minutesSinceStateChangeField;
            }
            set
            {
                this.minutesSinceStateChangeField = value;
            }
        }

        /// <remarks/>
        public string RichPresenceString
        {
            get
            {
                return this.richPresenceStringField;
            }
            set
            {
                this.richPresenceStringField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://websvc.xboxlive.com/Presence/")]
    public partial class OfflineFriend
    {

        private string gField;

        /// <remarks/>
        public string G
        {
            get
            {
                return this.gField;
            }
            set
            {
                this.gField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://websvc.xboxlive.com/Presence/")]
    public partial class OnlineFriend
    {

        private string gField;

        private uint tField;

        private uint sField;

        /// <remarks/>
        public string G
        {
            get
            {
                return this.gField;
            }
            set
            {
                this.gField = value;
            }
        }

        /// <remarks/>
        public uint T
        {
            get
            {
                return this.tField;
            }
            set
            {
                this.tField = value;
            }
        }

        /// <remarks/>
        public uint S
        {
            get
            {
                return this.sField;
            }
            set
            {
                this.sField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://websvc.xboxlive.com/Presence/")]
    public partial class FriendsInfo
    {

        private OnlineFriend[] onlineFriendsField;

        private OfflineFriend[] offlineFriendsField;

        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)]
        public OnlineFriend[] OnlineFriends
        {
            get
            {
                return this.onlineFriendsField;
            }
            set
            {
                this.onlineFriendsField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)]
        public OfflineFriend[] OfflineFriends
        {
            get
            {
                return this.offlineFriendsField;
            }
            set
            {
                this.offlineFriendsField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://websvc.xboxlive.com/Presence/")]
    public partial class RecentPlayer
    {

        private ulong userLivepuidField;

        private string gamertagField;

        private string gamerTileUrlField;

        private int reputationBucketField;

        private int gamerScoreField;

        private GamercardZones gamerZoneField;

        private RecentPlayerStatus statusField;

        private string gameTitleNameField;

        private System.DateTime lastMetDateField;

        private string gameTitleTileUrlField;

        /// <remarks/>
        public ulong UserLivepuid
        {
            get
            {
                return this.userLivepuidField;
            }
            set
            {
                this.userLivepuidField = value;
            }
        }

        /// <remarks/>
        public string Gamertag
        {
            get
            {
                return this.gamertagField;
            }
            set
            {
                this.gamertagField = value;
            }
        }

        /// <remarks/>
        public string GamerTileUrl
        {
            get
            {
                return this.gamerTileUrlField;
            }
            set
            {
                this.gamerTileUrlField = value;
            }
        }

        /// <remarks/>
        public int ReputationBucket
        {
            get
            {
                return this.reputationBucketField;
            }
            set
            {
                this.reputationBucketField = value;
            }
        }

        /// <remarks/>
        public int GamerScore
        {
            get
            {
                return this.gamerScoreField;
            }
            set
            {
                this.gamerScoreField = value;
            }
        }

        /// <remarks/>
        public GamercardZones GamerZone
        {
            get
            {
                return this.gamerZoneField;
            }
            set
            {
                this.gamerZoneField = value;
            }
        }

        /// <remarks/>
        public RecentPlayerStatus Status
        {
            get
            {
                return this.statusField;
            }
            set
            {
                this.statusField = value;
            }
        }

        /// <remarks/>
        public string GameTitleName
        {
            get
            {
                return this.gameTitleNameField;
            }
            set
            {
                this.gameTitleNameField = value;
            }
        }

        /// <remarks/>
        public System.DateTime LastMetDate
        {
            get
            {
                return this.lastMetDateField;
            }
            set
            {
                this.lastMetDateField = value;
            }
        }

        /// <remarks/>
        public string GameTitleTileUrl
        {
            get
            {
                return this.gameTitleTileUrlField;
            }
            set
            {
                this.gameTitleTileUrlField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://websvc.xboxlive.com/Presence/")]
    public enum GamercardZones
    {

        /// <remarks/>
        Unknown,

        /// <remarks/>
        None,

        /// <remarks/>
        Xbox_1,

        /// <remarks/>
        RR,

        /// <remarks/>
        Pro,

        /// <remarks/>
        Family,

        /// <remarks/>
        Underground,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://websvc.xboxlive.com/Presence/")]
    public enum RecentPlayerStatus
    {

        /// <remarks/>
        Neutral,

        /// <remarks/>
        Preferred,

        /// <remarks/>
        Avoided,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://websvc.xboxlive.com/Presence/")]
    public partial class FriendEx
    {

        private ulong xUIDField;

        private string gamerTagField;

        private uint friendStatusField;

        private uint onlineStateField;

        private uint lastSeenTitleField;

        private uint minutesSinceStateChangeField;

        private string richPresenceStringField;

        /// <remarks/>
        public ulong XUID
        {
            get
            {
                return this.xUIDField;
            }
            set
            {
                this.xUIDField = value;
            }
        }

        /// <remarks/>
        public string GamerTag
        {
            get
            {
                return this.gamerTagField;
            }
            set
            {
                this.gamerTagField = value;
            }
        }

        /// <remarks/>
        public uint FriendStatus
        {
            get
            {
                return this.friendStatusField;
            }
            set
            {
                this.friendStatusField = value;
            }
        }

        /// <remarks/>
        public uint OnlineState
        {
            get
            {
                return this.onlineStateField;
            }
            set
            {
                this.onlineStateField = value;
            }
        }

        /// <remarks/>
        public uint LastSeenTitle
        {
            get
            {
                return this.lastSeenTitleField;
            }
            set
            {
                this.lastSeenTitleField = value;
            }
        }

        /// <remarks/>
        public uint MinutesSinceStateChange
        {
            get
            {
                return this.minutesSinceStateChangeField;
            }
            set
            {
                this.minutesSinceStateChangeField = value;
            }
        }

        /// <remarks/>
        public string RichPresenceString
        {
            get
            {
                return this.richPresenceStringField;
            }
            set
            {
                this.richPresenceStringField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetGamertagsFromXUIDSCompletedEventHandler(object sender, GetGamertagsFromXUIDSCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetGamertagsFromXUIDSCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetGamertagsFromXUIDSCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string[] Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string[])(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetXUIDSFromGamertagsCompletedEventHandler(object sender, GetXUIDSFromGamertagsCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetXUIDSFromGamertagsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetXUIDSFromGamertagsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public ulong[] Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((ulong[])(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetPresenceInfoCompletedEventHandler(object sender, GetPresenceInfoCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetPresenceInfoCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetPresenceInfoCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public PresenceInfo Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((PresenceInfo)(this.results[0]));
            }
        }

        /// <remarks/>
        public uint ValidSeconds
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[1]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetFriendsExCompletedEventHandler(object sender, GetFriendsExCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetFriendsExCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetFriendsExCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public FriendEx[] Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((FriendEx[])(this.results[0]));
            }
        }

        /// <remarks/>
        public uint ValidSeconds
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[1]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRecentPlayersCompletedEventHandler(object sender, GetRecentPlayersCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRecentPlayersCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetRecentPlayersCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public RecentPlayer[] Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((RecentPlayer[])(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetFriendsCompletedEventHandler(object sender, GetFriendsCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetFriendsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetFriendsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public FriendsInfo Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((FriendsInfo)(this.results[0]));
            }
        }

        /// <remarks/>
        public uint ValidSeconds
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[1]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\WebReferences\WidgetQuery\Reference.cs ===
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.42
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace ServerTestFramework.Web.Query {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="QuerySoap", Namespace="http://websvc.xboxlive.com/Query/")]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(WireData))]
    public partial class Query : ServerTestFramework.Web.STFSoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback AddOperationCompleted;
        
        private System.Threading.SendOrPostCallback UpdateOperationCompleted;
        
        private System.Threading.SendOrPostCallback UpdateIdOperationCompleted;
        
        private System.Threading.SendOrPostCallback SearchOperationCompleted;
        
        private System.Threading.SendOrPostCallback FindFromIdsOperationCompleted;
        
        private System.Threading.SendOrPostCallback RemoveOperationCompleted;
        
        private System.Threading.SendOrPostCallback RemoveIdOperationCompleted;
        
        private System.Threading.SendOrPostCallback SelectOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetXQSConfigOperationCompleted;
        
        private System.Threading.SendOrPostCallback CompetitionCreateOperationCompleted;
        
        private System.Threading.SendOrPostCallback CompetitionCreateSingleEliminationOperationCompleted;
        
        private System.Threading.SendOrPostCallback CompetitionSearchOperationCompleted;
        
        private System.Threading.SendOrPostCallback CompetitionManageEntrantOperationCompleted;
        
        private System.Threading.SendOrPostCallback CompetitionCancelOperationCompleted;
        
        private System.Threading.SendOrPostCallback CompetitionTopologyOperationCompleted;
        
        private System.Threading.SendOrPostCallback CompetitionTopologySingleEliminationOperationCompleted;
        
        /// <remarks/>
        public Query() {
            this.ComputeUrl("wcquery", "/query/query.asmx");
        }
        
        /// <remarks/>
        public event AddCompletedEventHandler AddCompleted;
        
        /// <remarks/>
        public event UpdateCompletedEventHandler UpdateCompleted;
        
        /// <remarks/>
        public event UpdateIdCompletedEventHandler UpdateIdCompleted;
        
        /// <remarks/>
        public event SearchCompletedEventHandler SearchCompleted;
        
        /// <remarks/>
        public event FindFromIdsCompletedEventHandler FindFromIdsCompleted;
        
        /// <remarks/>
        public event RemoveCompletedEventHandler RemoveCompleted;
        
        /// <remarks/>
        public event RemoveIdCompletedEventHandler RemoveIdCompleted;
        
        /// <remarks/>
        public event SelectCompletedEventHandler SelectCompleted;
        
        /// <remarks/>
        public event GetXQSConfigCompletedEventHandler GetXQSConfigCompleted;
        
        /// <remarks/>
        public event CompetitionCreateCompletedEventHandler CompetitionCreateCompleted;
        
        /// <remarks/>
        public event CompetitionCreateSingleEliminationCompletedEventHandler CompetitionCreateSingleEliminationCompleted;
        
        /// <remarks/>
        public event CompetitionSearchCompletedEventHandler CompetitionSearchCompleted;
        
        /// <remarks/>
        public event CompetitionManageEntrantCompletedEventHandler CompetitionManageEntrantCompleted;
        
        /// <remarks/>
        public event CompetitionCancelCompletedEventHandler CompetitionCancelCompleted;
        
        /// <remarks/>
        public event CompetitionTopologyCompletedEventHandler CompetitionTopologyCompleted;
        
        /// <remarks/>
        public event CompetitionTopologySingleEliminationCompletedEventHandler CompetitionTopologySingleEliminationCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Query/Add", RequestNamespace="http://websvc.xboxlive.com/Query/", ResponseNamespace="http://websvc.xboxlive.com/Query/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public ulong Add(uint titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webId, string gamerTag, string teamName, uint datasetId, QueryAttribute[] attributes) {
            object[] results = this.Invoke("Add", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        datasetId,
                        attributes});
            return ((ulong)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAdd(uint titleId, byte[] webId, string gamerTag, string teamName, uint datasetId, QueryAttribute[] attributes, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("Add", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        datasetId,
                        attributes}, callback, asyncState);
        }
        
        /// <remarks/>
        public ulong EndAdd(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((ulong)(results[0]));
        }
        
        /// <remarks/>
        public void AddAsync(uint titleId, byte[] webId, string gamerTag, string teamName, uint datasetId, QueryAttribute[] attributes) {
            this.AddAsync(titleId, webId, gamerTag, teamName, datasetId, attributes, null);
        }
        
        /// <remarks/>
        public void AddAsync(uint titleId, byte[] webId, string gamerTag, string teamName, uint datasetId, QueryAttribute[] attributes, object userState) {
            if ((this.AddOperationCompleted == null)) {
                this.AddOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAddOperationCompleted);
            }
            this.InvokeAsync("Add", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        datasetId,
                        attributes}, this.AddOperationCompleted, userState);
        }
        
        private void OnAddOperationCompleted(object arg) {
            if ((this.AddCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AddCompleted(this, new AddCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Query/Update", RequestNamespace="http://websvc.xboxlive.com/Query/", ResponseNamespace="http://websvc.xboxlive.com/Query/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void Update(uint titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webId, string gamerTag, string teamName, uint datasetId, uint procIndex, QueryAttribute[] attributes) {
            this.Invoke("Update", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        datasetId,
                        procIndex,
                        attributes});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUpdate(uint titleId, byte[] webId, string gamerTag, string teamName, uint datasetId, uint procIndex, QueryAttribute[] attributes, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("Update", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        datasetId,
                        procIndex,
                        attributes}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndUpdate(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void UpdateAsync(uint titleId, byte[] webId, string gamerTag, string teamName, uint datasetId, uint procIndex, QueryAttribute[] attributes) {
            this.UpdateAsync(titleId, webId, gamerTag, teamName, datasetId, procIndex, attributes, null);
        }
        
        /// <remarks/>
        public void UpdateAsync(uint titleId, byte[] webId, string gamerTag, string teamName, uint datasetId, uint procIndex, QueryAttribute[] attributes, object userState) {
            if ((this.UpdateOperationCompleted == null)) {
                this.UpdateOperationCompleted = new System.Threading.SendOrPostCallback(this.OnUpdateOperationCompleted);
            }
            this.InvokeAsync("Update", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        datasetId,
                        procIndex,
                        attributes}, this.UpdateOperationCompleted, userState);
        }
        
        private void OnUpdateOperationCompleted(object arg) {
            if ((this.UpdateCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.UpdateCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Query/UpdateId", RequestNamespace="http://websvc.xboxlive.com/Query/", ResponseNamespace="http://websvc.xboxlive.com/Query/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void UpdateId(uint titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webId, string gamerTag, string teamName, uint datasetId, uint procIndex, ulong entityId, QueryAttribute[] attributes) {
            this.Invoke("UpdateId", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        datasetId,
                        procIndex,
                        entityId,
                        attributes});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUpdateId(uint titleId, byte[] webId, string gamerTag, string teamName, uint datasetId, uint procIndex, ulong entityId, QueryAttribute[] attributes, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("UpdateId", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        datasetId,
                        procIndex,
                        entityId,
                        attributes}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndUpdateId(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void UpdateIdAsync(uint titleId, byte[] webId, string gamerTag, string teamName, uint datasetId, uint procIndex, ulong entityId, QueryAttribute[] attributes) {
            this.UpdateIdAsync(titleId, webId, gamerTag, teamName, datasetId, procIndex, entityId, attributes, null);
        }
        
        /// <remarks/>
        public void UpdateIdAsync(uint titleId, byte[] webId, string gamerTag, string teamName, uint datasetId, uint procIndex, ulong entityId, QueryAttribute[] attributes, object userState) {
            if ((this.UpdateIdOperationCompleted == null)) {
                this.UpdateIdOperationCompleted = new System.Threading.SendOrPostCallback(this.OnUpdateIdOperationCompleted);
            }
            this.InvokeAsync("UpdateId", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        datasetId,
                        procIndex,
                        entityId,
                        attributes}, this.UpdateIdOperationCompleted, userState);
        }
        
        private void OnUpdateIdOperationCompleted(object arg) {
            if ((this.UpdateIdCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.UpdateIdCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Query/Search", RequestNamespace="http://websvc.xboxlive.com/Query/", ResponseNamespace="http://websvc.xboxlive.com/Query/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public SearchResponse Search(uint titleId, uint datasetId, uint procIndex, uint page, uint resultsPerPage, QueryAttributeSpec[] specs, QueryAttribute[] attributes) {
            object[] results = this.Invoke("Search", new object[] {
                        titleId,
                        datasetId,
                        procIndex,
                        page,
                        resultsPerPage,
                        specs,
                        attributes});
            return ((SearchResponse)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSearch(uint titleId, uint datasetId, uint procIndex, uint page, uint resultsPerPage, QueryAttributeSpec[] specs, QueryAttribute[] attributes, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("Search", new object[] {
                        titleId,
                        datasetId,
                        procIndex,
                        page,
                        resultsPerPage,
                        specs,
                        attributes}, callback, asyncState);
        }
        
        /// <remarks/>
        public SearchResponse EndSearch(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((SearchResponse)(results[0]));
        }
        
        /// <remarks/>
        public void SearchAsync(uint titleId, uint datasetId, uint procIndex, uint page, uint resultsPerPage, QueryAttributeSpec[] specs, QueryAttribute[] attributes) {
            this.SearchAsync(titleId, datasetId, procIndex, page, resultsPerPage, specs, attributes, null);
        }
        
        /// <remarks/>
        public void SearchAsync(uint titleId, uint datasetId, uint procIndex, uint page, uint resultsPerPage, QueryAttributeSpec[] specs, QueryAttribute[] attributes, object userState) {
            if ((this.SearchOperationCompleted == null)) {
                this.SearchOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSearchOperationCompleted);
            }
            this.InvokeAsync("Search", new object[] {
                        titleId,
                        datasetId,
                        procIndex,
                        page,
                        resultsPerPage,
                        specs,
                        attributes}, this.SearchOperationCompleted, userState);
        }
        
        private void OnSearchOperationCompleted(object arg) {
            if ((this.SearchCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SearchCompleted(this, new SearchCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Query/FindFromIds", RequestNamespace="http://websvc.xboxlive.com/Query/", ResponseNamespace="http://websvc.xboxlive.com/Query/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public FindFromIdsResponse FindFromIds(uint titleId, uint datasetId, uint procIndex, QueryAttributeSpec[] specs, ulong[] entityIds) {
            object[] results = this.Invoke("FindFromIds", new object[] {
                        titleId,
                        datasetId,
                        procIndex,
                        specs,
                        entityIds});
            return ((FindFromIdsResponse)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginFindFromIds(uint titleId, uint datasetId, uint procIndex, QueryAttributeSpec[] specs, ulong[] entityIds, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("FindFromIds", new object[] {
                        titleId,
                        datasetId,
                        procIndex,
                        specs,
                        entityIds}, callback, asyncState);
        }
        
        /// <remarks/>
        public FindFromIdsResponse EndFindFromIds(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((FindFromIdsResponse)(results[0]));
        }
        
        /// <remarks/>
        public void FindFromIdsAsync(uint titleId, uint datasetId, uint procIndex, QueryAttributeSpec[] specs, ulong[] entityIds) {
            this.FindFromIdsAsync(titleId, datasetId, procIndex, specs, entityIds, null);
        }
        
        /// <remarks/>
        public void FindFromIdsAsync(uint titleId, uint datasetId, uint procIndex, QueryAttributeSpec[] specs, ulong[] entityIds, object userState) {
            if ((this.FindFromIdsOperationCompleted == null)) {
                this.FindFromIdsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnFindFromIdsOperationCompleted);
            }
            this.InvokeAsync("FindFromIds", new object[] {
                        titleId,
                        datasetId,
                        procIndex,
                        specs,
                        entityIds}, this.FindFromIdsOperationCompleted, userState);
        }
        
        private void OnFindFromIdsOperationCompleted(object arg) {
            if ((this.FindFromIdsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.FindFromIdsCompleted(this, new FindFromIdsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Query/Remove", RequestNamespace="http://websvc.xboxlive.com/Query/", ResponseNamespace="http://websvc.xboxlive.com/Query/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void Remove(uint titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webId, string gamerTag, string teamName, uint datasetId, uint procIndex, QueryAttribute[] attributes) {
            this.Invoke("Remove", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        datasetId,
                        procIndex,
                        attributes});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRemove(uint titleId, byte[] webId, string gamerTag, string teamName, uint datasetId, uint procIndex, QueryAttribute[] attributes, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("Remove", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        datasetId,
                        procIndex,
                        attributes}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndRemove(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void RemoveAsync(uint titleId, byte[] webId, string gamerTag, string teamName, uint datasetId, uint procIndex, QueryAttribute[] attributes) {
            this.RemoveAsync(titleId, webId, gamerTag, teamName, datasetId, procIndex, attributes, null);
        }
        
        /// <remarks/>
        public void RemoveAsync(uint titleId, byte[] webId, string gamerTag, string teamName, uint datasetId, uint procIndex, QueryAttribute[] attributes, object userState) {
            if ((this.RemoveOperationCompleted == null)) {
                this.RemoveOperationCompleted = new System.Threading.SendOrPostCallback(this.OnRemoveOperationCompleted);
            }
            this.InvokeAsync("Remove", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        datasetId,
                        procIndex,
                        attributes}, this.RemoveOperationCompleted, userState);
        }
        
        private void OnRemoveOperationCompleted(object arg) {
            if ((this.RemoveCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.RemoveCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Query/RemoveId", RequestNamespace="http://websvc.xboxlive.com/Query/", ResponseNamespace="http://websvc.xboxlive.com/Query/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void RemoveId(uint titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webId, string gamerTag, string teamName, uint datasetId, ulong entityId) {
            this.Invoke("RemoveId", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        datasetId,
                        entityId});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRemoveId(uint titleId, byte[] webId, string gamerTag, string teamName, uint datasetId, ulong entityId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RemoveId", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        datasetId,
                        entityId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndRemoveId(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void RemoveIdAsync(uint titleId, byte[] webId, string gamerTag, string teamName, uint datasetId, ulong entityId) {
            this.RemoveIdAsync(titleId, webId, gamerTag, teamName, datasetId, entityId, null);
        }
        
        /// <remarks/>
        public void RemoveIdAsync(uint titleId, byte[] webId, string gamerTag, string teamName, uint datasetId, ulong entityId, object userState) {
            if ((this.RemoveIdOperationCompleted == null)) {
                this.RemoveIdOperationCompleted = new System.Threading.SendOrPostCallback(this.OnRemoveIdOperationCompleted);
            }
            this.InvokeAsync("RemoveId", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        datasetId,
                        entityId}, this.RemoveIdOperationCompleted, userState);
        }
        
        private void OnRemoveIdOperationCompleted(object arg) {
            if ((this.RemoveIdCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.RemoveIdCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Query/Select", RequestNamespace="http://websvc.xboxlive.com/Query/", ResponseNamespace="http://websvc.xboxlive.com/Query/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void Select(uint titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webId, string gamerTag, string teamName, uint datasetId, ulong entityId, uint action, QueryAttribute[] attributes) {
            this.Invoke("Select", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        datasetId,
                        entityId,
                        action,
                        attributes});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSelect(uint titleId, byte[] webId, string gamerTag, string teamName, uint datasetId, ulong entityId, uint action, QueryAttribute[] attributes, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("Select", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        datasetId,
                        entityId,
                        action,
                        attributes}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSelect(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void SelectAsync(uint titleId, byte[] webId, string gamerTag, string teamName, uint datasetId, ulong entityId, uint action, QueryAttribute[] attributes) {
            this.SelectAsync(titleId, webId, gamerTag, teamName, datasetId, entityId, action, attributes, null);
        }
        
        /// <remarks/>
        public void SelectAsync(uint titleId, byte[] webId, string gamerTag, string teamName, uint datasetId, ulong entityId, uint action, QueryAttribute[] attributes, object userState) {
            if ((this.SelectOperationCompleted == null)) {
                this.SelectOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSelectOperationCompleted);
            }
            this.InvokeAsync("Select", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        datasetId,
                        entityId,
                        action,
                        attributes}, this.SelectOperationCompleted, userState);
        }
        
        private void OnSelectOperationCompleted(object arg) {
            if ((this.SelectCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SelectCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Query/GetXQSConfig", RequestNamespace="http://websvc.xboxlive.com/Query/", ResponseNamespace="http://websvc.xboxlive.com/Query/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string GetXQSConfig(uint titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webId, ulong haveVersion) {
            object[] results = this.Invoke("GetXQSConfig", new object[] {
                        titleId,
                        webId,
                        haveVersion});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetXQSConfig(uint titleId, byte[] webId, ulong haveVersion, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetXQSConfig", new object[] {
                        titleId,
                        webId,
                        haveVersion}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetXQSConfig(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetXQSConfigAsync(uint titleId, byte[] webId, ulong haveVersion) {
            this.GetXQSConfigAsync(titleId, webId, haveVersion, null);
        }
        
        /// <remarks/>
        public void GetXQSConfigAsync(uint titleId, byte[] webId, ulong haveVersion, object userState) {
            if ((this.GetXQSConfigOperationCompleted == null)) {
                this.GetXQSConfigOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetXQSConfigOperationCompleted);
            }
            this.InvokeAsync("GetXQSConfig", new object[] {
                        titleId,
                        webId,
                        haveVersion}, this.GetXQSConfigOperationCompleted, userState);
        }
        
        private void OnGetXQSConfigOperationCompleted(object arg) {
            if ((this.GetXQSConfigCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetXQSConfigCompleted(this, new GetXQSConfigCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Query/CompetitionCreate", RequestNamespace="http://websvc.xboxlive.com/Query/", ResponseNamespace="http://websvc.xboxlive.com/Query/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public ulong CompetitionCreate(uint titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webId, string gamerTag, string teamName, uint datasetId, QueryAttribute[] attributes) {
            object[] results = this.Invoke("CompetitionCreate", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        datasetId,
                        attributes});
            return ((ulong)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCompetitionCreate(uint titleId, byte[] webId, string gamerTag, string teamName, uint datasetId, QueryAttribute[] attributes, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CompetitionCreate", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        datasetId,
                        attributes}, callback, asyncState);
        }
        
        /// <remarks/>
        public ulong EndCompetitionCreate(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((ulong)(results[0]));
        }
        
        /// <remarks/>
        public void CompetitionCreateAsync(uint titleId, byte[] webId, string gamerTag, string teamName, uint datasetId, QueryAttribute[] attributes) {
            this.CompetitionCreateAsync(titleId, webId, gamerTag, teamName, datasetId, attributes, null);
        }
        
        /// <remarks/>
        public void CompetitionCreateAsync(uint titleId, byte[] webId, string gamerTag, string teamName, uint datasetId, QueryAttribute[] attributes, object userState) {
            if ((this.CompetitionCreateOperationCompleted == null)) {
                this.CompetitionCreateOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCompetitionCreateOperationCompleted);
            }
            this.InvokeAsync("CompetitionCreate", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        datasetId,
                        attributes}, this.CompetitionCreateOperationCompleted, userState);
        }
        
        private void OnCompetitionCreateOperationCompleted(object arg) {
            if ((this.CompetitionCreateCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CompetitionCreateCompleted(this, new CompetitionCreateCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Query/CompetitionCreateSingleElimination", RequestNamespace="http://websvc.xboxlive.com/Query/", ResponseNamespace="http://websvc.xboxlive.com/Query/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public ulong CompetitionCreateSingleElimination(
                    uint titleId, 
                    [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webId, 
                    string gamerTag, 
                    string teamName, 
                    uint datasetId, 
                    uint cPrivateSlots, 
                    uint cPublicSlots, 
                    uint cMinimumPlayers, 
                    System.DateTime dtRegistrationOpen, 
                    System.DateTime dtRegistrationClose, 
                    System.DateTime dtCompetitionStart, 
                    System.DateTime dtRoundOneStart, 
                    System.DateTime dtRoundOneEnd, 
                    uint dwMatchReminderAdvanceMinutes, 
                    uint UnitOrMask, 
                    uint Interval, 
                    bool fTeamCompetition, 
                    uint dwTeamSize, 
                    QueryAttribute[] additionalAttributes) {
            object[] results = this.Invoke("CompetitionCreateSingleElimination", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        datasetId,
                        cPrivateSlots,
                        cPublicSlots,
                        cMinimumPlayers,
                        dtRegistrationOpen,
                        dtRegistrationClose,
                        dtCompetitionStart,
                        dtRoundOneStart,
                        dtRoundOneEnd,
                        dwMatchReminderAdvanceMinutes,
                        UnitOrMask,
                        Interval,
                        fTeamCompetition,
                        dwTeamSize,
                        additionalAttributes});
            return ((ulong)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCompetitionCreateSingleElimination(
                    uint titleId, 
                    byte[] webId, 
                    string gamerTag, 
                    string teamName, 
                    uint datasetId, 
                    uint cPrivateSlots, 
                    uint cPublicSlots, 
                    uint cMinimumPlayers, 
                    System.DateTime dtRegistrationOpen, 
                    System.DateTime dtRegistrationClose, 
                    System.DateTime dtCompetitionStart, 
                    System.DateTime dtRoundOneStart, 
                    System.DateTime dtRoundOneEnd, 
                    uint dwMatchReminderAdvanceMinutes, 
                    uint UnitOrMask, 
                    uint Interval, 
                    bool fTeamCompetition, 
                    uint dwTeamSize, 
                    QueryAttribute[] additionalAttributes, 
                    System.AsyncCallback callback, 
                    object asyncState) {
            return this.BeginInvoke("CompetitionCreateSingleElimination", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        datasetId,
                        cPrivateSlots,
                        cPublicSlots,
                        cMinimumPlayers,
                        dtRegistrationOpen,
                        dtRegistrationClose,
                        dtCompetitionStart,
                        dtRoundOneStart,
                        dtRoundOneEnd,
                        dwMatchReminderAdvanceMinutes,
                        UnitOrMask,
                        Interval,
                        fTeamCompetition,
                        dwTeamSize,
                        additionalAttributes}, callback, asyncState);
        }
        
        /// <remarks/>
        public ulong EndCompetitionCreateSingleElimination(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((ulong)(results[0]));
        }
        
        /// <remarks/>
        public void CompetitionCreateSingleEliminationAsync(
                    uint titleId, 
                    byte[] webId, 
                    string gamerTag, 
                    string teamName, 
                    uint datasetId, 
                    uint cPrivateSlots, 
                    uint cPublicSlots, 
                    uint cMinimumPlayers, 
                    System.DateTime dtRegistrationOpen, 
                    System.DateTime dtRegistrationClose, 
                    System.DateTime dtCompetitionStart, 
                    System.DateTime dtRoundOneStart, 
                    System.DateTime dtRoundOneEnd, 
                    uint dwMatchReminderAdvanceMinutes, 
                    uint UnitOrMask, 
                    uint Interval, 
                    bool fTeamCompetition, 
                    uint dwTeamSize, 
                    QueryAttribute[] additionalAttributes) {
            this.CompetitionCreateSingleEliminationAsync(titleId, webId, gamerTag, teamName, datasetId, cPrivateSlots, cPublicSlots, cMinimumPlayers, dtRegistrationOpen, dtRegistrationClose, dtCompetitionStart, dtRoundOneStart, dtRoundOneEnd, dwMatchReminderAdvanceMinutes, UnitOrMask, Interval, fTeamCompetition, dwTeamSize, additionalAttributes, null);
        }
        
        /// <remarks/>
        public void CompetitionCreateSingleEliminationAsync(
                    uint titleId, 
                    byte[] webId, 
                    string gamerTag, 
                    string teamName, 
                    uint datasetId, 
                    uint cPrivateSlots, 
                    uint cPublicSlots, 
                    uint cMinimumPlayers, 
                    System.DateTime dtRegistrationOpen, 
                    System.DateTime dtRegistrationClose, 
                    System.DateTime dtCompetitionStart, 
                    System.DateTime dtRoundOneStart, 
                    System.DateTime dtRoundOneEnd, 
                    uint dwMatchReminderAdvanceMinutes, 
                    uint UnitOrMask, 
                    uint Interval, 
                    bool fTeamCompetition, 
                    uint dwTeamSize, 
                    QueryAttribute[] additionalAttributes, 
                    object userState) {
            if ((this.CompetitionCreateSingleEliminationOperationCompleted == null)) {
                this.CompetitionCreateSingleEliminationOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCompetitionCreateSingleEliminationOperationCompleted);
            }
            this.InvokeAsync("CompetitionCreateSingleElimination", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        datasetId,
                        cPrivateSlots,
                        cPublicSlots,
                        cMinimumPlayers,
                        dtRegistrationOpen,
                        dtRegistrationClose,
                        dtCompetitionStart,
                        dtRoundOneStart,
                        dtRoundOneEnd,
                        dwMatchReminderAdvanceMinutes,
                        UnitOrMask,
                        Interval,
                        fTeamCompetition,
                        dwTeamSize,
                        additionalAttributes}, this.CompetitionCreateSingleEliminationOperationCompleted, userState);
        }
        
        private void OnCompetitionCreateSingleEliminationOperationCompleted(object arg) {
            if ((this.CompetitionCreateSingleEliminationCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CompetitionCreateSingleEliminationCompleted(this, new CompetitionCreateSingleEliminationCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Query/CompetitionSearch", RequestNamespace="http://websvc.xboxlive.com/Query/", ResponseNamespace="http://websvc.xboxlive.com/Query/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public SearchResponse CompetitionSearch(uint titleId, uint datasetId, uint queryId, uint page, uint resultsPerPage, QueryAttributeSpec[] specs, QueryAttribute[] attributes) {
            object[] results = this.Invoke("CompetitionSearch", new object[] {
                        titleId,
                        datasetId,
                        queryId,
                        page,
                        resultsPerPage,
                        specs,
                        attributes});
            return ((SearchResponse)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCompetitionSearch(uint titleId, uint datasetId, uint queryId, uint page, uint resultsPerPage, QueryAttributeSpec[] specs, QueryAttribute[] attributes, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CompetitionSearch", new object[] {
                        titleId,
                        datasetId,
                        queryId,
                        page,
                        resultsPerPage,
                        specs,
                        attributes}, callback, asyncState);
        }
        
        /// <remarks/>
        public SearchResponse EndCompetitionSearch(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((SearchResponse)(results[0]));
        }
        
        /// <remarks/>
        public void CompetitionSearchAsync(uint titleId, uint datasetId, uint queryId, uint page, uint resultsPerPage, QueryAttributeSpec[] specs, QueryAttribute[] attributes) {
            this.CompetitionSearchAsync(titleId, datasetId, queryId, page, resultsPerPage, specs, attributes, null);
        }
        
        /// <remarks/>
        public void CompetitionSearchAsync(uint titleId, uint datasetId, uint queryId, uint page, uint resultsPerPage, QueryAttributeSpec[] specs, QueryAttribute[] attributes, object userState) {
            if ((this.CompetitionSearchOperationCompleted == null)) {
                this.CompetitionSearchOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCompetitionSearchOperationCompleted);
            }
            this.InvokeAsync("CompetitionSearch", new object[] {
                        titleId,
                        datasetId,
                        queryId,
                        page,
                        resultsPerPage,
                        specs,
                        attributes}, this.CompetitionSearchOperationCompleted, userState);
        }
        
        private void OnCompetitionSearchOperationCompleted(object arg) {
            if ((this.CompetitionSearchCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CompetitionSearchCompleted(this, new CompetitionSearchCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Query/CompetitionManageEntrant", RequestNamespace="http://websvc.xboxlive.com/Query/", ResponseNamespace="http://websvc.xboxlive.com/Query/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void CompetitionManageEntrant(uint titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webId, string gamerTag, uint action, string teamName, uint datasetId, ulong competitionId, QueryAttribute[] attributes) {
            this.Invoke("CompetitionManageEntrant", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        action,
                        teamName,
                        datasetId,
                        competitionId,
                        attributes});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCompetitionManageEntrant(uint titleId, byte[] webId, string gamerTag, uint action, string teamName, uint datasetId, ulong competitionId, QueryAttribute[] attributes, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CompetitionManageEntrant", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        action,
                        teamName,
                        datasetId,
                        competitionId,
                        attributes}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCompetitionManageEntrant(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void CompetitionManageEntrantAsync(uint titleId, byte[] webId, string gamerTag, uint action, string teamName, uint datasetId, ulong competitionId, QueryAttribute[] attributes) {
            this.CompetitionManageEntrantAsync(titleId, webId, gamerTag, action, teamName, datasetId, competitionId, attributes, null);
        }
        
        /// <remarks/>
        public void CompetitionManageEntrantAsync(uint titleId, byte[] webId, string gamerTag, uint action, string teamName, uint datasetId, ulong competitionId, QueryAttribute[] attributes, object userState) {
            if ((this.CompetitionManageEntrantOperationCompleted == null)) {
                this.CompetitionManageEntrantOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCompetitionManageEntrantOperationCompleted);
            }
            this.InvokeAsync("CompetitionManageEntrant", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        action,
                        teamName,
                        datasetId,
                        competitionId,
                        attributes}, this.CompetitionManageEntrantOperationCompleted, userState);
        }
        
        private void OnCompetitionManageEntrantOperationCompleted(object arg) {
            if ((this.CompetitionManageEntrantCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CompetitionManageEntrantCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Query/CompetitionCancel", RequestNamespace="http://websvc.xboxlive.com/Query/", ResponseNamespace="http://websvc.xboxlive.com/Query/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void CompetitionCancel(uint titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webId, string gamerTag, string teamName, uint datasetId, ulong competitionId) {
            this.Invoke("CompetitionCancel", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        datasetId,
                        competitionId});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCompetitionCancel(uint titleId, byte[] webId, string gamerTag, string teamName, uint datasetId, ulong competitionId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CompetitionCancel", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        datasetId,
                        competitionId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCompetitionCancel(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void CompetitionCancelAsync(uint titleId, byte[] webId, string gamerTag, string teamName, uint datasetId, ulong competitionId) {
            this.CompetitionCancelAsync(titleId, webId, gamerTag, teamName, datasetId, competitionId, null);
        }
        
        /// <remarks/>
        public void CompetitionCancelAsync(uint titleId, byte[] webId, string gamerTag, string teamName, uint datasetId, ulong competitionId, object userState) {
            if ((this.CompetitionCancelOperationCompleted == null)) {
                this.CompetitionCancelOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCompetitionCancelOperationCompleted);
            }
            this.InvokeAsync("CompetitionCancel", new object[] {
                        titleId,
                        webId,
                        gamerTag,
                        teamName,
                        datasetId,
                        competitionId}, this.CompetitionCancelOperationCompleted, userState);
        }
        
        private void OnCompetitionCancelOperationCompleted(object arg) {
            if ((this.CompetitionCancelCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CompetitionCancelCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Query/CompetitionTopology", RequestNamespace="http://websvc.xboxlive.com/Query/", ResponseNamespace="http://websvc.xboxlive.com/Query/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public SearchResponse CompetitionTopology(uint titleId, uint datasetId, ulong competitionId, uint page, uint resultsPerPage, long startingEventId, long endingEventId, QueryAttributeSpec[] specs) {
            object[] results = this.Invoke("CompetitionTopology", new object[] {
                        titleId,
                        datasetId,
                        competitionId,
                        page,
                        resultsPerPage,
                        startingEventId,
                        endingEventId,
                        specs});
            return ((SearchResponse)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCompetitionTopology(uint titleId, uint datasetId, ulong competitionId, uint page, uint resultsPerPage, long startingEventId, long endingEventId, QueryAttributeSpec[] specs, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CompetitionTopology", new object[] {
                        titleId,
                        datasetId,
                        competitionId,
                        page,
                        resultsPerPage,
                        startingEventId,
                        endingEventId,
                        specs}, callback, asyncState);
        }
        
        /// <remarks/>
        public SearchResponse EndCompetitionTopology(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((SearchResponse)(results[0]));
        }
        
        /// <remarks/>
        public void CompetitionTopologyAsync(uint titleId, uint datasetId, ulong competitionId, uint page, uint resultsPerPage, long startingEventId, long endingEventId, QueryAttributeSpec[] specs) {
            this.CompetitionTopologyAsync(titleId, datasetId, competitionId, page, resultsPerPage, startingEventId, endingEventId, specs, null);
        }
        
        /// <remarks/>
        public void CompetitionTopologyAsync(uint titleId, uint datasetId, ulong competitionId, uint page, uint resultsPerPage, long startingEventId, long endingEventId, QueryAttributeSpec[] specs, object userState) {
            if ((this.CompetitionTopologyOperationCompleted == null)) {
                this.CompetitionTopologyOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCompetitionTopologyOperationCompleted);
            }
            this.InvokeAsync("CompetitionTopology", new object[] {
                        titleId,
                        datasetId,
                        competitionId,
                        page,
                        resultsPerPage,
                        startingEventId,
                        endingEventId,
                        specs}, this.CompetitionTopologyOperationCompleted, userState);
        }
        
        private void OnCompetitionTopologyOperationCompleted(object arg) {
            if ((this.CompetitionTopologyCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CompetitionTopologyCompleted(this, new CompetitionTopologyCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Query/CompetitionTopologySingleElimination", RequestNamespace="http://websvc.xboxlive.com/Query/", ResponseNamespace="http://websvc.xboxlive.com/Query/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public SearchResponse CompetitionTopologySingleElimination(uint titleId, uint datasetId, ulong competitionId, ulong originEventId, uint roundsForward, uint roundsBackward, uint topWidth, QueryAttributeSpec[] specs) {
            object[] results = this.Invoke("CompetitionTopologySingleElimination", new object[] {
                        titleId,
                        datasetId,
                        competitionId,
                        originEventId,
                        roundsForward,
                        roundsBackward,
                        topWidth,
                        specs});
            return ((SearchResponse)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCompetitionTopologySingleElimination(uint titleId, uint datasetId, ulong competitionId, ulong originEventId, uint roundsForward, uint roundsBackward, uint topWidth, QueryAttributeSpec[] specs, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CompetitionTopologySingleElimination", new object[] {
                        titleId,
                        datasetId,
                        competitionId,
                        originEventId,
                        roundsForward,
                        roundsBackward,
                        topWidth,
                        specs}, callback, asyncState);
        }
        
        /// <remarks/>
        public SearchResponse EndCompetitionTopologySingleElimination(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((SearchResponse)(results[0]));
        }
        
        /// <remarks/>
        public void CompetitionTopologySingleEliminationAsync(uint titleId, uint datasetId, ulong competitionId, ulong originEventId, uint roundsForward, uint roundsBackward, uint topWidth, QueryAttributeSpec[] specs) {
            this.CompetitionTopologySingleEliminationAsync(titleId, datasetId, competitionId, originEventId, roundsForward, roundsBackward, topWidth, specs, null);
        }
        
        /// <remarks/>
        public void CompetitionTopologySingleEliminationAsync(uint titleId, uint datasetId, ulong competitionId, ulong originEventId, uint roundsForward, uint roundsBackward, uint topWidth, QueryAttributeSpec[] specs, object userState) {
            if ((this.CompetitionTopologySingleEliminationOperationCompleted == null)) {
                this.CompetitionTopologySingleEliminationOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCompetitionTopologySingleEliminationOperationCompleted);
            }
            this.InvokeAsync("CompetitionTopologySingleElimination", new object[] {
                        titleId,
                        datasetId,
                        competitionId,
                        originEventId,
                        roundsForward,
                        roundsBackward,
                        topWidth,
                        specs}, this.CompetitionTopologySingleEliminationOperationCompleted, userState);
        }
        
        private void OnCompetitionTopologySingleEliminationOperationCompleted(object arg) {
            if ((this.CompetitionTopologySingleEliminationCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CompetitionTopologySingleEliminationCompleted(this, new CompetitionTopologySingleEliminationCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Query/")]
    public partial class QueryAttribute : WireData {
        
        private object valueField;
        
        private uint idField;
        
        /// <remarks/>
        public object Value {
            get {
                return this.valueField;
            }
            set {
                this.valueField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public uint Id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(XRLObject2))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(FindFromIdsResponse))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(SearchResponse))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(QueryAttributeSpec))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(QueryAttribute))]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Query/")]
    public partial class WireData {
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(FindFromIdsResponse))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(SearchResponse))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(QueryAttributeSpec))]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Query/")]
    public partial class XRLObject2 : WireData {
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Query/")]
    public partial class FindFromIdsResponse : XRLObject2 {
        
        private uint returnedResultsField;
        
        private uint attribCountField;
        
        private QueryAttribute[] attribsField;
        
        /// <remarks/>
        public uint returnedResults {
            get {
                return this.returnedResultsField;
            }
            set {
                this.returnedResultsField = value;
            }
        }
        
        /// <remarks/>
        public uint attribCount {
            get {
                return this.attribCountField;
            }
            set {
                this.attribCountField = value;
            }
        }
        
        /// <remarks/>
        public QueryAttribute[] attribs {
            get {
                return this.attribsField;
            }
            set {
                this.attribsField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Query/")]
    public partial class SearchResponse : XRLObject2 {
        
        private uint totalResultsField;
        
        private uint returnedResultsField;
        
        private uint attribCountField;
        
        private QueryAttribute[] attribsField;
        
        /// <remarks/>
        public uint totalResults {
            get {
                return this.totalResultsField;
            }
            set {
                this.totalResultsField = value;
            }
        }
        
        /// <remarks/>
        public uint returnedResults {
            get {
                return this.returnedResultsField;
            }
            set {
                this.returnedResultsField = value;
            }
        }
        
        /// <remarks/>
        public uint attribCount {
            get {
                return this.attribCountField;
            }
            set {
                this.attribCountField = value;
            }
        }
        
        /// <remarks/>
        public QueryAttribute[] attribs {
            get {
                return this.attribsField;
            }
            set {
                this.attribsField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Query/")]
    public partial class QueryAttributeSpec : XRLObject2 {
        
        private uint typeField;
        
        private uint lenField;
        
        /// <remarks/>
        public uint type {
            get {
                return this.typeField;
            }
            set {
                this.typeField = value;
            }
        }
        
        /// <remarks/>
        public uint len {
            get {
                return this.lenField;
            }
            set {
                this.lenField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AddCompletedEventHandler(object sender, AddCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AddCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal AddCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public ulong Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ulong)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void UpdateCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void UpdateIdCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SearchCompletedEventHandler(object sender, SearchCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SearchCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SearchCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public SearchResponse Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((SearchResponse)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void FindFromIdsCompletedEventHandler(object sender, FindFromIdsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class FindFromIdsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal FindFromIdsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public FindFromIdsResponse Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((FindFromIdsResponse)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void RemoveCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void RemoveIdCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SelectCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetXQSConfigCompletedEventHandler(object sender, GetXQSConfigCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetXQSConfigCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetXQSConfigCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CompetitionCreateCompletedEventHandler(object sender, CompetitionCreateCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CompetitionCreateCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal CompetitionCreateCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public ulong Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ulong)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CompetitionCreateSingleEliminationCompletedEventHandler(object sender, CompetitionCreateSingleEliminationCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CompetitionCreateSingleEliminationCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal CompetitionCreateSingleEliminationCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public ulong Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ulong)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CompetitionSearchCompletedEventHandler(object sender, CompetitionSearchCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CompetitionSearchCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal CompetitionSearchCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public SearchResponse Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((SearchResponse)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CompetitionManageEntrantCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CompetitionCancelCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CompetitionTopologyCompletedEventHandler(object sender, CompetitionTopologyCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CompetitionTopologyCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal CompetitionTopologyCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public SearchResponse Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((SearchResponse)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CompetitionTopologySingleEliminationCompletedEventHandler(object sender, CompetitionTopologySingleEliminationCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CompetitionTopologySingleEliminationCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal CompetitionTopologySingleEliminationCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public SearchResponse Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((SearchResponse)(this.results[0]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\WebReferences\xbos2\SvcProviderWrapper.cs ===
using System;
using System.Net;
using System.Net.Security;
using System.Text;
using System.Security.Cryptography.X509Certificates;
using System.Text.RegularExpressions;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.STS;
using ServerTestFramework.LiveService.FakeAAInfoNameSpace;
using xonline.common.config;
using xonline.common.protocol;

namespace ServerTestFramework.LiveService.Billing.WebService2
{
    public class SvcProviderWrapper : Billing
    {
        //UserAccount Prov=new UserAccount();

        public static int   TimeOut=25000;
        public static int   ConcurrentCalls=0;
        public string       ErrorString="";
        public ulong        ReturnCode=99;

        static protected Regex RegexXCBKReturn1=new Regex(@"<ResponseInfo><ErrorCode/><ResponseClass>(?<responseClass>(.)+)</ResponseClass><ResponseMessage/></ResponseInfo>");
        static protected Regex RegexXCBKReturn2=new Regex(@"<ResponseInfo><ErrorCode>(?<errorCode>(.)+)</ErrorCode><ResponseClass>(?<responseClass>(.)+)</ResponseClass><ResponseMessage/></ResponseInfo>");

        public string AlternateMusicNetUrl = null;
        public string AlternateBillingUrl = null;
        public string InjectedScsError = null;
        public string AlternateDmpUrl = null;

        public string ServerAddr;
        public ulong PassportPuid;
        public ulong Xuid;
        public ulong MachinePuid;
        public uint TitleId;

        static public void Initialize()
        {
            //ServicePointManager.CertificatePolicy=new MyCertPolicy();
            ServicePointManager.ServerCertificateValidationCallback += delegate(
                object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors)
            {
                if (sslPolicyErrors != SslPolicyErrors.None)
                {
                    Console.WriteLine("Security Support Provider Interface (SSPI) Status Code = " + sslPolicyErrors.ToString());
                }
                return true;
            };
        }


        new public string TestConnection(string inputMessage) {
            string results;
            results = base.TestConnection(inputMessage);

            return results;
        }
        
        new public void PurchaseMediaOffers(ulong userPuid, ulong machinePuid, string[] offerIds, int[] mediaTypes, uint[] expectedPrices, PaymentTypeEnum paymentType, string paymentInstrumentId, string billingToken, int storeId) {
            base.PurchaseMediaOffers(
                        userPuid,
                        machinePuid,
                        offerIds,
                        mediaTypes,
                        expectedPrices,
                        paymentType,
                        paymentInstrumentId,
                        billingToken,
                        storeId);
        }

        
        new public PurchaseStatus[] GetPurchaseStatus(ulong userPuid, string[] offerIds) {
            PurchaseStatus[] results;
            results = base.GetPurchaseStatus(
                        userPuid,
                        offerIds);

            return results;
        }
        
        new public MediaInstanceUrl[] FindMediaInstanceUrls(string[] mediaInstanceIds, ulong userPuid) {
            MediaInstanceUrl[] results;
            results = base.FindMediaInstanceUrls(
                        mediaInstanceIds,
                        userPuid);

            return results;
        }
        
        new public VerifyTokenResults VerifyToken(ulong userPuid, ulong machinePuid, string billingToken, int storeId) {
            VerifyTokenResults results;
            results = base.VerifyToken(
                        userPuid,
                        machinePuid,
                        billingToken,
                        storeId);

            return results;
        }
        
        
        new public void CancelSubscription(ulong userPuid, ulong machinePuid, ulong offerId, bool undoDelayedCancel) {
            base.CancelSubscription (
                        userPuid,
                        machinePuid,
                        offerId,
                        undoDelayedCancel);
        }
        
        new public GamertagEnumerateResult GamertagEnumerate(ulong userPuid, PaymentTypeEnum paymentType, uint titleId) {
            GamertagEnumerateResult results;
            results = base.GamertagEnumerate(
                        userPuid,
                        paymentType,
                        titleId);

            return results;
        }
        
        new public SubscriptionEnumerateResults SubscriptionEnumerate(ulong userPuid, ulong machinePuid, uint offerType, uint paymentType, uint titleId, bool queryForNew, bool queryForRenewals, bool queryForCurrent, bool queryForCancelled, bool queryForSuspended) {
            SubscriptionEnumerateResults results;
            results = base.SubscriptionEnumerate(
                        userPuid,
                        machinePuid,
                        offerType,
                        paymentType,
                        titleId,
                        queryForNew,
                        queryForRenewals,
                        queryForCurrent,
                        queryForCancelled,
                        queryForSuspended);

            return results;
        }
        
        new public void PurchaseBillingOffer(ulong userPuid, ulong machinePuid, ulong offerId, uint paymentType, string paymentInstrumentId, string billingToken) {
            base.PurchaseBillingOffer(
                        userPuid,
                        machinePuid,
                        offerId,
                        paymentType,
                        paymentInstrumentId,
                        billingToken);
        }
        
        new public uint PurchaseGamertag(ulong userPuid, ulong machinePuid, System.Guid offerGuId, PaymentTypeEnum paymentType, string gamertag, string token) {
            uint results;
            results = base.PurchaseGamertag(
                        userPuid,
                        machinePuid,
                        offerGuId,
                        paymentType,
                        gamertag,
                        token);
                        
            return results;
        }
        
        
        


        public SvcProviderWrapper() : this(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering))
        {
            ;
        }

        public SvcProviderWrapper(ulong passportPuid, ulong xuid, ulong machinePuid, uint titleId) : this(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering))
        {
            PassportPuid = passportPuid;
            Xuid = xuid;
            MachinePuid = machinePuid;
            TitleId = titleId;
            TimeOut = 60000;
        }

        public SvcProviderWrapper(ulong _passportPuid) : this(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering))
        {
            PassportPuid = _passportPuid;
        }

        private SvcProviderWrapper(System.Net.IPEndPoint ServerEP)
        {
            string ServerAddrPort;
            ServicePointManager.DefaultConnectionLimit=220;
            base.Timeout=TimeOut;

            ServerAddr = ServerEP.Address.ToString();
            ServerAddrPort = ServerAddr;
            if (ServerEP.Port != 80)
            {
                ServerAddrPort += ":" + ServerEP.Port;
            }

            base.Url="http://"+ServerAddrPort+"/xbos/billing.asmx";
        }

        private SvcProviderWrapper(LiveServer Server)
        {
            ServicePointManager.DefaultConnectionLimit=220;
            base.Timeout=TimeOut;

            ServerAddr = Server.EPDefault.Address.ToString();
            base.Url="http://"+Server.IPToString()+"/xbos/billing.asmx";
        }

        override protected WebRequest GetWebRequest(Uri url)
        {
            WebRequest wr = base.GetWebRequest(new Uri(Url));

            if (AlternateMusicNetUrl != null)
                wr.Headers.Add("AlternateMusicNetUrl", AlternateMusicNetUrl);
            if (AlternateBillingUrl != null)
                wr.Headers.Add("AlternateBillingUrl", AlternateBillingUrl);
            if (InjectedScsError != null)
                wr.Headers.Add("InjectedScsError", InjectedScsError);
            if (AlternateDmpUrl != null)
                wr.Headers.Add("AlternateDmpUrl", AlternateDmpUrl);

            FakeAAInfo fakeAAInfo = new FakeAAInfo(PassportPuid);

            STSUtil.GetSecurityTicketParameters gstParam = new STSUtil.GetSecurityTicketParameters();
            gstParam.Puid0 = PassportPuid.ToString();
            gstParam.Xuid0 = Xuid.ToString();
            gstParam.MachineID = MachinePuid.ToString();
            gstParam.TitleID = TitleId.ToString();
            gstParam.Certificate = new X509Certificate2("sts.test.xboxlive.com.pfx","XblRocks!");
            fakeAAInfo.SamlToken = STSUtil.GetSecurityTicket(gstParam);
            
            xonline.common.service.AAInfo.MarshallToHeaders(wr.Headers, fakeAAInfo);

            return wr;
        }



        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\WebReferences\WidgetStats\Reference.cs ===
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.312
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
namespace ServerTestFramework.Web.Stats {
    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Web.Services;
    using System.Web.Services.Protocols;
    using System.Xml.Serialization;

    // 
    // This source code was auto-generated by wsdl, Version=2.0.50727.42.
    // 


    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name = "StatsSoap", Namespace = "http://websvc.xboxlive.com/Stats/")]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(RawLBEntry[]))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(RawLBAttribute[]))]
    public partial class Stats : ServerTestFramework.Web.STFSoapHttpClientProtocol
    {

        private System.Threading.SendOrPostCallback DeleteXUIDFromLBOperationCompleted;

        private System.Threading.SendOrPostCallback DeleteXUIDFromAllLBsOperationCompleted;

        private System.Threading.SendOrPostCallback GetLBListOperationCompleted;

        private System.Threading.SendOrPostCallback GetLBListByTypeOperationCompleted;

        private System.Threading.SendOrPostCallback EnumerateLBOperationCompleted;

        private System.Threading.SendOrPostCallback GetLBNearGamerTagOperationCompleted;

        private System.Threading.SendOrPostCallback GetLBForGamerTagsOperationCompleted;

        private System.Threading.SendOrPostCallback GetLBDetailsForGamerTagsOperationCompleted;

        private System.Threading.SendOrPostCallback GetMLBByXUIDOperationCompleted;

        private System.Threading.SendOrPostCallback EnumerateTeamLBOperationCompleted;

        private System.Threading.SendOrPostCallback GetTeamLBNearTeamNameOperationCompleted;

        private System.Threading.SendOrPostCallback GetTeamLBForTeamNamesOperationCompleted;

        private System.Threading.SendOrPostCallback GetTeamLBDetailsForTeamNamesOperationCompleted;

        private System.Threading.SendOrPostCallback EnumerateLBRawOperationCompleted;

        /// <remarks/>
        public Stats()
        {
            this.ComputeUrl("wcstats", "/Stats/Stats.asmx");
        }

        /// <remarks/>
        public event DeleteXUIDFromLBCompletedEventHandler DeleteXUIDFromLBCompleted;

        /// <remarks/>
        public event DeleteXUIDFromAllLBsCompletedEventHandler DeleteXUIDFromAllLBsCompleted;

        /// <remarks/>
        public event GetLBListCompletedEventHandler GetLBListCompleted;

        /// <remarks/>
        public event GetLBListByTypeCompletedEventHandler GetLBListByTypeCompleted;

        /// <remarks/>
        public event EnumerateLBCompletedEventHandler EnumerateLBCompleted;

        /// <remarks/>
        public event GetLBNearGamerTagCompletedEventHandler GetLBNearGamerTagCompleted;

        /// <remarks/>
        public event GetLBForGamerTagsCompletedEventHandler GetLBForGamerTagsCompleted;

        /// <remarks/>
        public event GetLBDetailsForGamerTagsCompletedEventHandler GetLBDetailsForGamerTagsCompleted;

        /// <remarks/>
        public event GetMLBByXUIDCompletedEventHandler GetMLBByXUIDCompleted;

        /// <remarks/>
        public event EnumerateTeamLBCompletedEventHandler EnumerateTeamLBCompleted;

        /// <remarks/>
        public event GetTeamLBNearTeamNameCompletedEventHandler GetTeamLBNearTeamNameCompleted;

        /// <remarks/>
        public event GetTeamLBForTeamNamesCompletedEventHandler GetTeamLBForTeamNamesCompleted;

        /// <remarks/>
        public event GetTeamLBDetailsForTeamNamesCompletedEventHandler GetTeamLBDetailsForTeamNamesCompleted;

        /// <remarks/>
        public event EnumerateLBRawCompletedEventHandler EnumerateLBRawCompleted;

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/DeleteXUIDFromLB", RequestNamespace = "http://websvc.xboxlive.com/Stats/", ResponseNamespace = "http://websvc.xboxlive.com/Stats/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public DeleteXUIDStatus DeleteXUIDFromLB(uint uiTitleID, uint uiLbId, ulong xuid)
        {
            object[] results = this.Invoke("DeleteXUIDFromLB", new object[] {
                    uiTitleID,
                    uiLbId,
                    xuid});
            return ((DeleteXUIDStatus)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginDeleteXUIDFromLB(uint uiTitleID, uint uiLbId, ulong xuid, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("DeleteXUIDFromLB", new object[] {
                    uiTitleID,
                    uiLbId,
                    xuid}, callback, asyncState);
        }

        /// <remarks/>
        public DeleteXUIDStatus EndDeleteXUIDFromLB(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((DeleteXUIDStatus)(results[0]));
        }

        /// <remarks/>
        public void DeleteXUIDFromLBAsync(uint uiTitleID, uint uiLbId, ulong xuid)
        {
            this.DeleteXUIDFromLBAsync(uiTitleID, uiLbId, xuid, null);
        }

        /// <remarks/>
        public void DeleteXUIDFromLBAsync(uint uiTitleID, uint uiLbId, ulong xuid, object userState)
        {
            if ((this.DeleteXUIDFromLBOperationCompleted == null))
            {
                this.DeleteXUIDFromLBOperationCompleted = new System.Threading.SendOrPostCallback(this.OnDeleteXUIDFromLBOperationCompleted);
            }
            this.InvokeAsync("DeleteXUIDFromLB", new object[] {
                    uiTitleID,
                    uiLbId,
                    xuid}, this.DeleteXUIDFromLBOperationCompleted, userState);
        }

        private void OnDeleteXUIDFromLBOperationCompleted(object arg)
        {
            if ((this.DeleteXUIDFromLBCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.DeleteXUIDFromLBCompleted(this, new DeleteXUIDFromLBCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/DeleteXUIDFromAllLBs", RequestNamespace = "http://websvc.xboxlive.com/Stats/", ResponseNamespace = "http://websvc.xboxlive.com/Stats/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public DeleteXUIDStatus DeleteXUIDFromAllLBs(uint uiTitleID, ulong xuid)
        {
            object[] results = this.Invoke("DeleteXUIDFromAllLBs", new object[] {
                    uiTitleID,
                    xuid});
            return ((DeleteXUIDStatus)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginDeleteXUIDFromAllLBs(uint uiTitleID, ulong xuid, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("DeleteXUIDFromAllLBs", new object[] {
                    uiTitleID,
                    xuid}, callback, asyncState);
        }

        /// <remarks/>
        public DeleteXUIDStatus EndDeleteXUIDFromAllLBs(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((DeleteXUIDStatus)(results[0]));
        }

        /// <remarks/>
        public void DeleteXUIDFromAllLBsAsync(uint uiTitleID, ulong xuid)
        {
            this.DeleteXUIDFromAllLBsAsync(uiTitleID, xuid, null);
        }

        /// <remarks/>
        public void DeleteXUIDFromAllLBsAsync(uint uiTitleID, ulong xuid, object userState)
        {
            if ((this.DeleteXUIDFromAllLBsOperationCompleted == null))
            {
                this.DeleteXUIDFromAllLBsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnDeleteXUIDFromAllLBsOperationCompleted);
            }
            this.InvokeAsync("DeleteXUIDFromAllLBs", new object[] {
                    uiTitleID,
                    xuid}, this.DeleteXUIDFromAllLBsOperationCompleted, userState);
        }

        private void OnDeleteXUIDFromAllLBsOperationCompleted(object arg)
        {
            if ((this.DeleteXUIDFromAllLBsCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.DeleteXUIDFromAllLBsCompleted(this, new DeleteXUIDFromAllLBsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/GetLBList", RequestNamespace = "http://websvc.xboxlive.com/Stats/", ResponseNamespace = "http://websvc.xboxlive.com/Stats/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)]
        public LBInfo[] GetLBList(uint TitleID, out uint ValidSeconds)
        {
            object[] results = this.Invoke("GetLBList", new object[] {
                    TitleID});
            ValidSeconds = ((uint)(results[1]));
            return ((LBInfo[])(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetLBList(uint TitleID, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetLBList", new object[] {
                    TitleID}, callback, asyncState);
        }

        /// <remarks/>
        public LBInfo[] EndGetLBList(System.IAsyncResult asyncResult, out uint ValidSeconds)
        {
            object[] results = this.EndInvoke(asyncResult);
            ValidSeconds = ((uint)(results[1]));
            return ((LBInfo[])(results[0]));
        }

        /// <remarks/>
        public void GetLBListAsync(uint TitleID)
        {
            this.GetLBListAsync(TitleID, null);
        }

        /// <remarks/>
        public void GetLBListAsync(uint TitleID, object userState)
        {
            if ((this.GetLBListOperationCompleted == null))
            {
                this.GetLBListOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetLBListOperationCompleted);
            }
            this.InvokeAsync("GetLBList", new object[] {
                    TitleID}, this.GetLBListOperationCompleted, userState);
        }

        private void OnGetLBListOperationCompleted(object arg)
        {
            if ((this.GetLBListCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetLBListCompleted(this, new GetLBListCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/GetLBListByType", RequestNamespace = "http://websvc.xboxlive.com/Stats/", ResponseNamespace = "http://websvc.xboxlive.com/Stats/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)]
        public LBInfo[] GetLBListByType(uint TitleID, LBType LeaderboardType, out uint ValidSeconds)
        {
            object[] results = this.Invoke("GetLBListByType", new object[] {
                    TitleID,
                    LeaderboardType});
            ValidSeconds = ((uint)(results[1]));
            return ((LBInfo[])(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetLBListByType(uint TitleID, LBType LeaderboardType, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetLBListByType", new object[] {
                    TitleID,
                    LeaderboardType}, callback, asyncState);
        }

        /// <remarks/>
        public LBInfo[] EndGetLBListByType(System.IAsyncResult asyncResult, out uint ValidSeconds)
        {
            object[] results = this.EndInvoke(asyncResult);
            ValidSeconds = ((uint)(results[1]));
            return ((LBInfo[])(results[0]));
        }

        /// <remarks/>
        public void GetLBListByTypeAsync(uint TitleID, LBType LeaderboardType)
        {
            this.GetLBListByTypeAsync(TitleID, LeaderboardType, null);
        }

        /// <remarks/>
        public void GetLBListByTypeAsync(uint TitleID, LBType LeaderboardType, object userState)
        {
            if ((this.GetLBListByTypeOperationCompleted == null))
            {
                this.GetLBListByTypeOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetLBListByTypeOperationCompleted);
            }
            this.InvokeAsync("GetLBListByType", new object[] {
                    TitleID,
                    LeaderboardType}, this.GetLBListByTypeOperationCompleted, userState);
        }

        private void OnGetLBListByTypeOperationCompleted(object arg)
        {
            if ((this.GetLBListByTypeCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetLBListByTypeCompleted(this, new GetLBListByTypeCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/EnumerateLB", RequestNamespace = "http://websvc.xboxlive.com/Stats/", ResponseNamespace = "http://websvc.xboxlive.com/Stats/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public DetailedLBResults EnumerateLB(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries, out uint ValidSeconds)
        {
            object[] results = this.Invoke("EnumerateLB", new object[] {
                    TitleID,
                    LBID,
                    StartIndex,
                    MaxEntries});
            ValidSeconds = ((uint)(results[1]));
            return ((DetailedLBResults)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginEnumerateLB(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("EnumerateLB", new object[] {
                    TitleID,
                    LBID,
                    StartIndex,
                    MaxEntries}, callback, asyncState);
        }

        /// <remarks/>
        public DetailedLBResults EndEnumerateLB(System.IAsyncResult asyncResult, out uint ValidSeconds)
        {
            object[] results = this.EndInvoke(asyncResult);
            ValidSeconds = ((uint)(results[1]));
            return ((DetailedLBResults)(results[0]));
        }

        /// <remarks/>
        public void EnumerateLBAsync(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries)
        {
            this.EnumerateLBAsync(TitleID, LBID, StartIndex, MaxEntries, null);
        }

        /// <remarks/>
        public void EnumerateLBAsync(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries, object userState)
        {
            if ((this.EnumerateLBOperationCompleted == null))
            {
                this.EnumerateLBOperationCompleted = new System.Threading.SendOrPostCallback(this.OnEnumerateLBOperationCompleted);
            }
            this.InvokeAsync("EnumerateLB", new object[] {
                    TitleID,
                    LBID,
                    StartIndex,
                    MaxEntries}, this.EnumerateLBOperationCompleted, userState);
        }

        private void OnEnumerateLBOperationCompleted(object arg)
        {
            if ((this.EnumerateLBCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.EnumerateLBCompleted(this, new EnumerateLBCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/GetLBNearGamerTag", RequestNamespace = "http://websvc.xboxlive.com/Stats/", ResponseNamespace = "http://websvc.xboxlive.com/Stats/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public DetailedLBResults GetLBNearGamerTag(uint TitleID, uint LBID, string GamerTag, uint NumAbove, uint NumBelow, out uint ValidSeconds)
        {
            object[] results = this.Invoke("GetLBNearGamerTag", new object[] {
                    TitleID,
                    LBID,
                    GamerTag,
                    NumAbove,
                    NumBelow});
            ValidSeconds = ((uint)(results[1]));
            return ((DetailedLBResults)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetLBNearGamerTag(uint TitleID, uint LBID, string GamerTag, uint NumAbove, uint NumBelow, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetLBNearGamerTag", new object[] {
                    TitleID,
                    LBID,
                    GamerTag,
                    NumAbove,
                    NumBelow}, callback, asyncState);
        }

        /// <remarks/>
        public DetailedLBResults EndGetLBNearGamerTag(System.IAsyncResult asyncResult, out uint ValidSeconds)
        {
            object[] results = this.EndInvoke(asyncResult);
            ValidSeconds = ((uint)(results[1]));
            return ((DetailedLBResults)(results[0]));
        }

        /// <remarks/>
        public void GetLBNearGamerTagAsync(uint TitleID, uint LBID, string GamerTag, uint NumAbove, uint NumBelow)
        {
            this.GetLBNearGamerTagAsync(TitleID, LBID, GamerTag, NumAbove, NumBelow, null);
        }

        /// <remarks/>
        public void GetLBNearGamerTagAsync(uint TitleID, uint LBID, string GamerTag, uint NumAbove, uint NumBelow, object userState)
        {
            if ((this.GetLBNearGamerTagOperationCompleted == null))
            {
                this.GetLBNearGamerTagOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetLBNearGamerTagOperationCompleted);
            }
            this.InvokeAsync("GetLBNearGamerTag", new object[] {
                    TitleID,
                    LBID,
                    GamerTag,
                    NumAbove,
                    NumBelow}, this.GetLBNearGamerTagOperationCompleted, userState);
        }

        private void OnGetLBNearGamerTagOperationCompleted(object arg)
        {
            if ((this.GetLBNearGamerTagCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetLBNearGamerTagCompleted(this, new GetLBNearGamerTagCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/GetLBForGamerTags", RequestNamespace = "http://websvc.xboxlive.com/Stats/", ResponseNamespace = "http://websvc.xboxlive.com/Stats/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public LBResults GetLBForGamerTags(uint TitleID, uint LBID, string[] GamerTagList, out uint ValidSeconds)
        {
            object[] results = this.Invoke("GetLBForGamerTags", new object[] {
                    TitleID,
                    LBID,
                    GamerTagList});
            ValidSeconds = ((uint)(results[1]));
            return ((LBResults)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetLBForGamerTags(uint TitleID, uint LBID, string[] GamerTagList, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetLBForGamerTags", new object[] {
                    TitleID,
                    LBID,
                    GamerTagList}, callback, asyncState);
        }

        /// <remarks/>
        public LBResults EndGetLBForGamerTags(System.IAsyncResult asyncResult, out uint ValidSeconds)
        {
            object[] results = this.EndInvoke(asyncResult);
            ValidSeconds = ((uint)(results[1]));
            return ((LBResults)(results[0]));
        }

        /// <remarks/>
        public void GetLBForGamerTagsAsync(uint TitleID, uint LBID, string[] GamerTagList)
        {
            this.GetLBForGamerTagsAsync(TitleID, LBID, GamerTagList, null);
        }

        /// <remarks/>
        public void GetLBForGamerTagsAsync(uint TitleID, uint LBID, string[] GamerTagList, object userState)
        {
            if ((this.GetLBForGamerTagsOperationCompleted == null))
            {
                this.GetLBForGamerTagsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetLBForGamerTagsOperationCompleted);
            }
            this.InvokeAsync("GetLBForGamerTags", new object[] {
                    TitleID,
                    LBID,
                    GamerTagList}, this.GetLBForGamerTagsOperationCompleted, userState);
        }

        private void OnGetLBForGamerTagsOperationCompleted(object arg)
        {
            if ((this.GetLBForGamerTagsCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetLBForGamerTagsCompleted(this, new GetLBForGamerTagsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/GetLBDetailsForGamerTags", RequestNamespace = "http://websvc.xboxlive.com/Stats/", ResponseNamespace = "http://websvc.xboxlive.com/Stats/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public DetailedLBResults GetLBDetailsForGamerTags(uint TitleID, uint LBID, string[] GamerTagList, out uint ValidSeconds)
        {
            object[] results = this.Invoke("GetLBDetailsForGamerTags", new object[] {
                    TitleID,
                    LBID,
                    GamerTagList});
            ValidSeconds = ((uint)(results[1]));
            return ((DetailedLBResults)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetLBDetailsForGamerTags(uint TitleID, uint LBID, string[] GamerTagList, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetLBDetailsForGamerTags", new object[] {
                    TitleID,
                    LBID,
                    GamerTagList}, callback, asyncState);
        }

        /// <remarks/>
        public DetailedLBResults EndGetLBDetailsForGamerTags(System.IAsyncResult asyncResult, out uint ValidSeconds)
        {
            object[] results = this.EndInvoke(asyncResult);
            ValidSeconds = ((uint)(results[1]));
            return ((DetailedLBResults)(results[0]));
        }

        /// <remarks/>
        public void GetLBDetailsForGamerTagsAsync(uint TitleID, uint LBID, string[] GamerTagList)
        {
            this.GetLBDetailsForGamerTagsAsync(TitleID, LBID, GamerTagList, null);
        }

        /// <remarks/>
        public void GetLBDetailsForGamerTagsAsync(uint TitleID, uint LBID, string[] GamerTagList, object userState)
        {
            if ((this.GetLBDetailsForGamerTagsOperationCompleted == null))
            {
                this.GetLBDetailsForGamerTagsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetLBDetailsForGamerTagsOperationCompleted);
            }
            this.InvokeAsync("GetLBDetailsForGamerTags", new object[] {
                    TitleID,
                    LBID,
                    GamerTagList}, this.GetLBDetailsForGamerTagsOperationCompleted, userState);
        }

        private void OnGetLBDetailsForGamerTagsOperationCompleted(object arg)
        {
            if ((this.GetLBDetailsForGamerTagsCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetLBDetailsForGamerTagsCompleted(this, new GetLBDetailsForGamerTagsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/GetMLBByXUID", RequestNamespace = "http://websvc.xboxlive.com/Stats/", ResponseNamespace = "http://websvc.xboxlive.com/Stats/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public DetailedMLBResults GetMLBByXUID(uint TitleID, ulong puid, uint[] LBIDs)
        {
            object[] results = this.Invoke("GetMLBByXUID", new object[] {
                    TitleID,
                    puid,
                    LBIDs});
            return ((DetailedMLBResults)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetMLBByXUID(uint TitleID, ulong puid, uint[] LBIDs, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetMLBByXUID", new object[] {
                    TitleID,
                    puid,
                    LBIDs}, callback, asyncState);
        }

        /// <remarks/>
        public DetailedMLBResults EndGetMLBByXUID(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((DetailedMLBResults)(results[0]));
        }

        /// <remarks/>
        public void GetMLBByXUIDAsync(uint TitleID, ulong puid, uint[] LBIDs)
        {
            this.GetMLBByXUIDAsync(TitleID, puid, LBIDs, null);
        }

        /// <remarks/>
        public void GetMLBByXUIDAsync(uint TitleID, ulong puid, uint[] LBIDs, object userState)
        {
            if ((this.GetMLBByXUIDOperationCompleted == null))
            {
                this.GetMLBByXUIDOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetMLBByXUIDOperationCompleted);
            }
            this.InvokeAsync("GetMLBByXUID", new object[] {
                    TitleID,
                    puid,
                    LBIDs}, this.GetMLBByXUIDOperationCompleted, userState);
        }

        private void OnGetMLBByXUIDOperationCompleted(object arg)
        {
            if ((this.GetMLBByXUIDCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetMLBByXUIDCompleted(this, new GetMLBByXUIDCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/EnumerateTeamLB", RequestNamespace = "http://websvc.xboxlive.com/Stats/", ResponseNamespace = "http://websvc.xboxlive.com/Stats/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public DetailedLBResults EnumerateTeamLB(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries, out uint ValidSeconds)
        {
            object[] results = this.Invoke("EnumerateTeamLB", new object[] {
                    TitleID,
                    LBID,
                    StartIndex,
                    MaxEntries});
            ValidSeconds = ((uint)(results[1]));
            return ((DetailedLBResults)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginEnumerateTeamLB(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("EnumerateTeamLB", new object[] {
                    TitleID,
                    LBID,
                    StartIndex,
                    MaxEntries}, callback, asyncState);
        }

        /// <remarks/>
        public DetailedLBResults EndEnumerateTeamLB(System.IAsyncResult asyncResult, out uint ValidSeconds)
        {
            object[] results = this.EndInvoke(asyncResult);
            ValidSeconds = ((uint)(results[1]));
            return ((DetailedLBResults)(results[0]));
        }

        /// <remarks/>
        public void EnumerateTeamLBAsync(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries)
        {
            this.EnumerateTeamLBAsync(TitleID, LBID, StartIndex, MaxEntries, null);
        }

        /// <remarks/>
        public void EnumerateTeamLBAsync(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries, object userState)
        {
            if ((this.EnumerateTeamLBOperationCompleted == null))
            {
                this.EnumerateTeamLBOperationCompleted = new System.Threading.SendOrPostCallback(this.OnEnumerateTeamLBOperationCompleted);
            }
            this.InvokeAsync("EnumerateTeamLB", new object[] {
                    TitleID,
                    LBID,
                    StartIndex,
                    MaxEntries}, this.EnumerateTeamLBOperationCompleted, userState);
        }

        private void OnEnumerateTeamLBOperationCompleted(object arg)
        {
            if ((this.EnumerateTeamLBCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.EnumerateTeamLBCompleted(this, new EnumerateTeamLBCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/GetTeamLBNearTeamName", RequestNamespace = "http://websvc.xboxlive.com/Stats/", ResponseNamespace = "http://websvc.xboxlive.com/Stats/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public DetailedLBResults GetTeamLBNearTeamName(uint TitleID, uint LBID, string TeamName, uint NumAbove, uint NumBelow, out uint ValidSeconds)
        {
            object[] results = this.Invoke("GetTeamLBNearTeamName", new object[] {
                    TitleID,
                    LBID,
                    TeamName,
                    NumAbove,
                    NumBelow});
            ValidSeconds = ((uint)(results[1]));
            return ((DetailedLBResults)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetTeamLBNearTeamName(uint TitleID, uint LBID, string TeamName, uint NumAbove, uint NumBelow, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetTeamLBNearTeamName", new object[] {
                    TitleID,
                    LBID,
                    TeamName,
                    NumAbove,
                    NumBelow}, callback, asyncState);
        }

        /// <remarks/>
        public DetailedLBResults EndGetTeamLBNearTeamName(System.IAsyncResult asyncResult, out uint ValidSeconds)
        {
            object[] results = this.EndInvoke(asyncResult);
            ValidSeconds = ((uint)(results[1]));
            return ((DetailedLBResults)(results[0]));
        }

        /// <remarks/>
        public void GetTeamLBNearTeamNameAsync(uint TitleID, uint LBID, string TeamName, uint NumAbove, uint NumBelow)
        {
            this.GetTeamLBNearTeamNameAsync(TitleID, LBID, TeamName, NumAbove, NumBelow, null);
        }

        /// <remarks/>
        public void GetTeamLBNearTeamNameAsync(uint TitleID, uint LBID, string TeamName, uint NumAbove, uint NumBelow, object userState)
        {
            if ((this.GetTeamLBNearTeamNameOperationCompleted == null))
            {
                this.GetTeamLBNearTeamNameOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetTeamLBNearTeamNameOperationCompleted);
            }
            this.InvokeAsync("GetTeamLBNearTeamName", new object[] {
                    TitleID,
                    LBID,
                    TeamName,
                    NumAbove,
                    NumBelow}, this.GetTeamLBNearTeamNameOperationCompleted, userState);
        }

        private void OnGetTeamLBNearTeamNameOperationCompleted(object arg)
        {
            if ((this.GetTeamLBNearTeamNameCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetTeamLBNearTeamNameCompleted(this, new GetTeamLBNearTeamNameCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/GetTeamLBForTeamNames", RequestNamespace = "http://websvc.xboxlive.com/Stats/", ResponseNamespace = "http://websvc.xboxlive.com/Stats/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public LBResults GetTeamLBForTeamNames(uint TitleID, uint LBID, string[] TeamNameList, out uint ValidSeconds)
        {
            object[] results = this.Invoke("GetTeamLBForTeamNames", new object[] {
                    TitleID,
                    LBID,
                    TeamNameList});
            ValidSeconds = ((uint)(results[1]));
            return ((LBResults)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetTeamLBForTeamNames(uint TitleID, uint LBID, string[] TeamNameList, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetTeamLBForTeamNames", new object[] {
                    TitleID,
                    LBID,
                    TeamNameList}, callback, asyncState);
        }

        /// <remarks/>
        public LBResults EndGetTeamLBForTeamNames(System.IAsyncResult asyncResult, out uint ValidSeconds)
        {
            object[] results = this.EndInvoke(asyncResult);
            ValidSeconds = ((uint)(results[1]));
            return ((LBResults)(results[0]));
        }

        /// <remarks/>
        public void GetTeamLBForTeamNamesAsync(uint TitleID, uint LBID, string[] TeamNameList)
        {
            this.GetTeamLBForTeamNamesAsync(TitleID, LBID, TeamNameList, null);
        }

        /// <remarks/>
        public void GetTeamLBForTeamNamesAsync(uint TitleID, uint LBID, string[] TeamNameList, object userState)
        {
            if ((this.GetTeamLBForTeamNamesOperationCompleted == null))
            {
                this.GetTeamLBForTeamNamesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetTeamLBForTeamNamesOperationCompleted);
            }
            this.InvokeAsync("GetTeamLBForTeamNames", new object[] {
                    TitleID,
                    LBID,
                    TeamNameList}, this.GetTeamLBForTeamNamesOperationCompleted, userState);
        }

        private void OnGetTeamLBForTeamNamesOperationCompleted(object arg)
        {
            if ((this.GetTeamLBForTeamNamesCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetTeamLBForTeamNamesCompleted(this, new GetTeamLBForTeamNamesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/GetTeamLBDetailsForTeamNames", RequestNamespace = "http://websvc.xboxlive.com/Stats/", ResponseNamespace = "http://websvc.xboxlive.com/Stats/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public DetailedLBResults GetTeamLBDetailsForTeamNames(uint TitleID, uint LBID, string[] TeamNameList, out uint ValidSeconds)
        {
            object[] results = this.Invoke("GetTeamLBDetailsForTeamNames", new object[] {
                    TitleID,
                    LBID,
                    TeamNameList});
            ValidSeconds = ((uint)(results[1]));
            return ((DetailedLBResults)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetTeamLBDetailsForTeamNames(uint TitleID, uint LBID, string[] TeamNameList, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetTeamLBDetailsForTeamNames", new object[] {
                    TitleID,
                    LBID,
                    TeamNameList}, callback, asyncState);
        }

        /// <remarks/>
        public DetailedLBResults EndGetTeamLBDetailsForTeamNames(System.IAsyncResult asyncResult, out uint ValidSeconds)
        {
            object[] results = this.EndInvoke(asyncResult);
            ValidSeconds = ((uint)(results[1]));
            return ((DetailedLBResults)(results[0]));
        }

        /// <remarks/>
        public void GetTeamLBDetailsForTeamNamesAsync(uint TitleID, uint LBID, string[] TeamNameList)
        {
            this.GetTeamLBDetailsForTeamNamesAsync(TitleID, LBID, TeamNameList, null);
        }

        /// <remarks/>
        public void GetTeamLBDetailsForTeamNamesAsync(uint TitleID, uint LBID, string[] TeamNameList, object userState)
        {
            if ((this.GetTeamLBDetailsForTeamNamesOperationCompleted == null))
            {
                this.GetTeamLBDetailsForTeamNamesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetTeamLBDetailsForTeamNamesOperationCompleted);
            }
            this.InvokeAsync("GetTeamLBDetailsForTeamNames", new object[] {
                    TitleID,
                    LBID,
                    TeamNameList}, this.GetTeamLBDetailsForTeamNamesOperationCompleted, userState);
        }

        private void OnGetTeamLBDetailsForTeamNamesOperationCompleted(object arg)
        {
            if ((this.GetTeamLBDetailsForTeamNamesCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetTeamLBDetailsForTeamNamesCompleted(this, new GetTeamLBDetailsForTeamNamesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Stats/EnumerateLBRaw", RequestNamespace = "http://websvc.xboxlive.com/Stats/", ResponseNamespace = "http://websvc.xboxlive.com/Stats/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public RawLBResults EnumerateLBRaw(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries, out uint ValidSeconds)
        {
            object[] results = this.Invoke("EnumerateLBRaw", new object[] {
                    TitleID,
                    LBID,
                    StartIndex,
                    MaxEntries});
            ValidSeconds = ((uint)(results[1]));
            return ((RawLBResults)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginEnumerateLBRaw(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("EnumerateLBRaw", new object[] {
                    TitleID,
                    LBID,
                    StartIndex,
                    MaxEntries}, callback, asyncState);
        }

        /// <remarks/>
        public RawLBResults EndEnumerateLBRaw(System.IAsyncResult asyncResult, out uint ValidSeconds)
        {
            object[] results = this.EndInvoke(asyncResult);
            ValidSeconds = ((uint)(results[1]));
            return ((RawLBResults)(results[0]));
        }

        /// <remarks/>
        public void EnumerateLBRawAsync(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries)
        {
            this.EnumerateLBRawAsync(TitleID, LBID, StartIndex, MaxEntries, null);
        }

        /// <remarks/>
        public void EnumerateLBRawAsync(uint TitleID, uint LBID, uint StartIndex, uint MaxEntries, object userState)
        {
            if ((this.EnumerateLBRawOperationCompleted == null))
            {
                this.EnumerateLBRawOperationCompleted = new System.Threading.SendOrPostCallback(this.OnEnumerateLBRawOperationCompleted);
            }
            this.InvokeAsync("EnumerateLBRaw", new object[] {
                    TitleID,
                    LBID,
                    StartIndex,
                    MaxEntries}, this.EnumerateLBRawOperationCompleted, userState);
        }

        private void OnEnumerateLBRawOperationCompleted(object arg)
        {
            if ((this.EnumerateLBRawCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.EnumerateLBRawCompleted(this, new EnumerateLBRawCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        public new void CancelAsync(object userState)
        {
            base.CancelAsync(userState);
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://websvc.xboxlive.com/Stats/")]
    public enum DeleteXUIDStatus
    {

        /// <remarks/>
        Success,

        /// <remarks/>
        Warning_No_OP,

        /// <remarks/>
        Error_Invalid_Xuid,

        /// <remarks/>
        Error_Invalid_Title,

        /// <remarks/>
        Error_Invalid_Lb_ID,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://websvc.xboxlive.com/Stats/")]
    public partial class LBInfo
    {

        private uint lBIDField;

        private LBResetType resetTypeField;

        private StatsLocalizedName[] localizedLBNameField;

        private LBAttributeInfo[] attributeInfoField;

        /// <remarks/>
        public uint LBID
        {
            get
            {
                return this.lBIDField;
            }
            set
            {
                this.lBIDField = value;
            }
        }

        /// <remarks/>
        public LBResetType ResetType
        {
            get
            {
                return this.resetTypeField;
            }
            set
            {
                this.resetTypeField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)]
        public StatsLocalizedName[] LocalizedLBName
        {
            get
            {
                return this.localizedLBNameField;
            }
            set
            {
                this.localizedLBNameField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)]
        public LBAttributeInfo[] AttributeInfo
        {
            get
            {
                return this.attributeInfoField;
            }
            set
            {
                this.attributeInfoField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://websvc.xboxlive.com/Stats/")]
    public enum LBResetType
    {

        /// <remarks/>
        Never,

        /// <remarks/>
        Weekly,

        /// <remarks/>
        Monthly,

        /// <remarks/>
        Bimonthly,

        /// <remarks/>
        Quarterly,

        /// <remarks/>
        Semiannually,

        /// <remarks/>
        Annually,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://websvc.xboxlive.com/Stats/")]
    public partial class StatsLocalizedName
    {

        private string localeField;

        private string displayNameField;

        /// <remarks/>
        public string Locale
        {
            get
            {
                return this.localeField;
            }
            set
            {
                this.localeField = value;
            }
        }

        /// <remarks/>
        public string DisplayName
        {
            get
            {
                return this.displayNameField;
            }
            set
            {
                this.displayNameField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://websvc.xboxlive.com/Stats/")]
    public partial class RawLBAttribute
    {

        private uint idField;

        private object vField;

        /// <remarks/>
        public uint ID
        {
            get
            {
                return this.idField;
            }
            set
            {
                this.idField = value;
            }
        }

        /// <remarks/>
        public object V
        {
            get
            {
                return this.vField;
            }
            set
            {
                this.vField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://websvc.xboxlive.com/Stats/")]
    public partial class RawLBEntry
    {

        private string gField;

        private uint rField;

        private RawLBAttribute[] aField;

        /// <remarks/>
        public string G
        {
            get
            {
                return this.gField;
            }
            set
            {
                this.gField = value;
            }
        }

        /// <remarks/>
        public uint R
        {
            get
            {
                return this.rField;
            }
            set
            {
                this.rField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)]
        public RawLBAttribute[] A
        {
            get
            {
                return this.aField;
            }
            set
            {
                this.aField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://websvc.xboxlive.com/Stats/")]
    public partial class RawLBResults
    {

        private RawLBEntry[] entriesField;

        private System.DateTime lBLastResetDateField;

        private uint totalLBEntriesField;

        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)]
        public RawLBEntry[] Entries
        {
            get
            {
                return this.entriesField;
            }
            set
            {
                this.entriesField = value;
            }
        }

        /// <remarks/>
        public System.DateTime LBLastResetDate
        {
            get
            {
                return this.lBLastResetDateField;
            }
            set
            {
                this.lBLastResetDateField = value;
            }
        }

        /// <remarks/>
        public uint TotalLBEntries
        {
            get
            {
                return this.totalLBEntriesField;
            }
            set
            {
                this.totalLBEntriesField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://websvc.xboxlive.com/Stats/")]
    public partial class DetailedMLBEntry
    {

        private uint lBIDField;

        private uint rField;

        private LBEntryAttribute[] fField;

        private System.DateTime lBLastResetDateField;

        private uint totalLBEntriesField;

        /// <remarks/>
        public uint LBID
        {
            get
            {
                return this.lBIDField;
            }
            set
            {
                this.lBIDField = value;
            }
        }

        /// <remarks/>
        public uint R
        {
            get
            {
                return this.rField;
            }
            set
            {
                this.rField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)]
        public LBEntryAttribute[] F
        {
            get
            {
                return this.fField;
            }
            set
            {
                this.fField = value;
            }
        }

        /// <remarks/>
        public System.DateTime LBLastResetDate
        {
            get
            {
                return this.lBLastResetDateField;
            }
            set
            {
                this.lBLastResetDateField = value;
            }
        }

        /// <remarks/>
        public uint TotalLBEntries
        {
            get
            {
                return this.totalLBEntriesField;
            }
            set
            {
                this.totalLBEntriesField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://websvc.xboxlive.com/Stats/")]
    public partial class LBEntryAttribute
    {

        private string idField;

        private string vField;

        /// <remarks/>
        public string ID
        {
            get
            {
                return this.idField;
            }
            set
            {
                this.idField = value;
            }
        }

        /// <remarks/>
        public string V
        {
            get
            {
                return this.vField;
            }
            set
            {
                this.vField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://websvc.xboxlive.com/Stats/")]
    public partial class DetailedMLBResults
    {

        private DetailedMLBEntry[] entriesField;

        private string gField;

        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)]
        public DetailedMLBEntry[] Entries
        {
            get
            {
                return this.entriesField;
            }
            set
            {
                this.entriesField = value;
            }
        }

        /// <remarks/>
        public string G
        {
            get
            {
                return this.gField;
            }
            set
            {
                this.gField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://websvc.xboxlive.com/Stats/")]
    public partial class LBEntry
    {

        private string gField;

        private uint rField;

        /// <remarks/>
        public string G
        {
            get
            {
                return this.gField;
            }
            set
            {
                this.gField = value;
            }
        }

        /// <remarks/>
        public uint R
        {
            get
            {
                return this.rField;
            }
            set
            {
                this.rField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://websvc.xboxlive.com/Stats/")]
    public partial class LBResults
    {

        private LBEntry[] entriesField;

        private System.DateTime lBLastResetDateField;

        private uint totalLBEntriesField;

        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)]
        public LBEntry[] Entries
        {
            get
            {
                return this.entriesField;
            }
            set
            {
                this.entriesField = value;
            }
        }

        /// <remarks/>
        public System.DateTime LBLastResetDate
        {
            get
            {
                return this.lBLastResetDateField;
            }
            set
            {
                this.lBLastResetDateField = value;
            }
        }

        /// <remarks/>
        public uint TotalLBEntries
        {
            get
            {
                return this.totalLBEntriesField;
            }
            set
            {
                this.totalLBEntriesField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://websvc.xboxlive.com/Stats/")]
    public partial class DetailedLBEntry
    {

        private string gField;

        private uint rField;

        private LBEntryAttribute[] fField;

        /// <remarks/>
        public string G
        {
            get
            {
                return this.gField;
            }
            set
            {
                this.gField = value;
            }
        }

        /// <remarks/>
        public uint R
        {
            get
            {
                return this.rField;
            }
            set
            {
                this.rField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)]
        public LBEntryAttribute[] F
        {
            get
            {
                return this.fField;
            }
            set
            {
                this.fField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://websvc.xboxlive.com/Stats/")]
    public partial class DetailedLBResults
    {

        private DetailedLBEntry[] entriesField;

        private System.DateTime lBLastResetDateField;

        private uint totalLBEntriesField;

        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)]
        public DetailedLBEntry[] Entries
        {
            get
            {
                return this.entriesField;
            }
            set
            {
                this.entriesField = value;
            }
        }

        /// <remarks/>
        public System.DateTime LBLastResetDate
        {
            get
            {
                return this.lBLastResetDateField;
            }
            set
            {
                this.lBLastResetDateField = value;
            }
        }

        /// <remarks/>
        public uint TotalLBEntries
        {
            get
            {
                return this.totalLBEntriesField;
            }
            set
            {
                this.totalLBEntriesField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://websvc.xboxlive.com/Stats/")]
    public partial class LBAttributeInfo
    {

        private string idField;

        private AttributeUnit unitField;

        private StatsLocalizedName[] localizedAttrNameField;

        /// <remarks/>
        public string ID
        {
            get
            {
                return this.idField;
            }
            set
            {
                this.idField = value;
            }
        }

        /// <remarks/>
        public AttributeUnit Unit
        {
            get
            {
                return this.unitField;
            }
            set
            {
                this.unitField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)]
        public StatsLocalizedName[] LocalizedAttrName
        {
            get
            {
                return this.localizedAttrNameField;
            }
            set
            {
                this.localizedAttrNameField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://websvc.xboxlive.com/Stats/")]
    public enum AttributeUnit
    {

        /// <remarks/>
        Integer,

        /// <remarks/>
        Float,

        /// <remarks/>
        Percent,

        /// <remarks/>
        GamerTag,

        /// <remarks/>
        TimeStamp,

        /// <remarks/>
        MilliSeconds,

        /// <remarks/>
        TenMilliSeconds,

        /// <remarks/>
        HundredMilliSeconds,

        /// <remarks/>
        Seconds,

        /// <remarks/>
        Minutes,

        /// <remarks/>
        Hours,

        /// <remarks/>
        Days,

        /// <remarks/>
        String,

        /// <remarks/>
        Team,

        /// <remarks/>
        MaxAttributeUnit,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://websvc.xboxlive.com/Stats/")]
    public enum LBType
    {

        /// <remarks/>
        Regular,

        /// <remarks/>
        RegularTeam,

        /// <remarks/>
        CompetitionTemplate,

        /// <remarks/>
        CompetitionTemplateTeam,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void DeleteXUIDFromLBCompletedEventHandler(object sender, DeleteXUIDFromLBCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class DeleteXUIDFromLBCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal DeleteXUIDFromLBCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public DeleteXUIDStatus Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((DeleteXUIDStatus)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void DeleteXUIDFromAllLBsCompletedEventHandler(object sender, DeleteXUIDFromAllLBsCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class DeleteXUIDFromAllLBsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal DeleteXUIDFromAllLBsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public DeleteXUIDStatus Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((DeleteXUIDStatus)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetLBListCompletedEventHandler(object sender, GetLBListCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetLBListCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetLBListCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public LBInfo[] Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((LBInfo[])(this.results[0]));
            }
        }

        /// <remarks/>
        public uint ValidSeconds
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[1]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetLBListByTypeCompletedEventHandler(object sender, GetLBListByTypeCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetLBListByTypeCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetLBListByTypeCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public LBInfo[] Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((LBInfo[])(this.results[0]));
            }
        }

        /// <remarks/>
        public uint ValidSeconds
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[1]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void EnumerateLBCompletedEventHandler(object sender, EnumerateLBCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class EnumerateLBCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal EnumerateLBCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public DetailedLBResults Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((DetailedLBResults)(this.results[0]));
            }
        }

        /// <remarks/>
        public uint ValidSeconds
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[1]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetLBNearGamerTagCompletedEventHandler(object sender, GetLBNearGamerTagCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetLBNearGamerTagCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetLBNearGamerTagCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public DetailedLBResults Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((DetailedLBResults)(this.results[0]));
            }
        }

        /// <remarks/>
        public uint ValidSeconds
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[1]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetLBForGamerTagsCompletedEventHandler(object sender, GetLBForGamerTagsCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetLBForGamerTagsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetLBForGamerTagsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public LBResults Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((LBResults)(this.results[0]));
            }
        }

        /// <remarks/>
        public uint ValidSeconds
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[1]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetLBDetailsForGamerTagsCompletedEventHandler(object sender, GetLBDetailsForGamerTagsCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetLBDetailsForGamerTagsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetLBDetailsForGamerTagsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public DetailedLBResults Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((DetailedLBResults)(this.results[0]));
            }
        }

        /// <remarks/>
        public uint ValidSeconds
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[1]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetMLBByXUIDCompletedEventHandler(object sender, GetMLBByXUIDCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetMLBByXUIDCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetMLBByXUIDCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public DetailedMLBResults Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((DetailedMLBResults)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void EnumerateTeamLBCompletedEventHandler(object sender, EnumerateTeamLBCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class EnumerateTeamLBCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal EnumerateTeamLBCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public DetailedLBResults Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((DetailedLBResults)(this.results[0]));
            }
        }

        /// <remarks/>
        public uint ValidSeconds
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[1]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetTeamLBNearTeamNameCompletedEventHandler(object sender, GetTeamLBNearTeamNameCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetTeamLBNearTeamNameCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetTeamLBNearTeamNameCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public DetailedLBResults Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((DetailedLBResults)(this.results[0]));
            }
        }

        /// <remarks/>
        public uint ValidSeconds
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[1]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetTeamLBForTeamNamesCompletedEventHandler(object sender, GetTeamLBForTeamNamesCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetTeamLBForTeamNamesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetTeamLBForTeamNamesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public LBResults Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((LBResults)(this.results[0]));
            }
        }

        /// <remarks/>
        public uint ValidSeconds
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[1]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetTeamLBDetailsForTeamNamesCompletedEventHandler(object sender, GetTeamLBDetailsForTeamNamesCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetTeamLBDetailsForTeamNamesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetTeamLBDetailsForTeamNamesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public DetailedLBResults Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((DetailedLBResults)(this.results[0]));
            }
        }

        /// <remarks/>
        public uint ValidSeconds
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[1]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void EnumerateLBRawCompletedEventHandler(object sender, EnumerateLBRawCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class EnumerateLBRawCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal EnumerateLBRawCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public RawLBResults Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((RawLBResults)(this.results[0]));
            }
        }

        /// <remarks/>
        public uint ValidSeconds
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[1]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\WebReferences\WidgetUserAccount\Reference.cs ===
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.312
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace ServerTestFramework.Web.UserAccount {
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Web.Services;
using System.Web.Services.Protocols;
using System.Xml.Serialization;

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 


/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Web.Services.WebServiceBindingAttribute(Name="UserAccountSoap", Namespace="http://websvc.xboxlive.com/UserAccount/")]
public partial class UserAccount : ServerTestFramework.Web.STFSoapHttpClientProtocol {
    
    private System.Threading.SendOrPostCallback LinkUserOperationCompleted;
    
    private System.Threading.SendOrPostCallback LinkedGamerTagsOperationCompleted;
    
    private System.Threading.SendOrPostCallback GetUserSettingsOperationCompleted;
    
    private System.Threading.SendOrPostCallback SetInfoSharingOperationCompleted;
    
    private System.Threading.SendOrPostCallback GetAccountStatusOperationCompleted;
    
    private System.Threading.SendOrPostCallback GetUserAuthorizationOperationCompleted;
    
    private System.Threading.SendOrPostCallback CreateWholesaleAccountOperationCompleted;
    
    /// <remarks/>
    public UserAccount() {
        this.ComputeUrl("wcusers", "/useraccount/useraccount.asmx");
    }
    
    /// <remarks/>
    public event LinkUserCompletedEventHandler LinkUserCompleted;
    
    /// <remarks/>
    public event LinkedGamerTagsCompletedEventHandler LinkedGamerTagsCompleted;
    
    /// <remarks/>
    public event GetUserSettingsCompletedEventHandler GetUserSettingsCompleted;
    
    /// <remarks/>
    public event SetInfoSharingCompletedEventHandler SetInfoSharingCompleted;
    
    /// <remarks/>
    public event GetAccountStatusCompletedEventHandler GetAccountStatusCompleted;
    
    /// <remarks/>
    public event GetUserAuthorizationCompletedEventHandler GetUserAuthorizationCompleted;
    
    /// <remarks/>
    public event CreateWholesaleAccountCompletedEventHandler CreateWholesaleAccountCompleted;
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/UserAccount/LinkUser", RequestNamespace="http://websvc.xboxlive.com/UserAccount/", ResponseNamespace="http://websvc.xboxlive.com/UserAccount/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public bool LinkUser([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] WebID, string GamerTag, bool Owner, string PhonePrefix, string PhoneNumber, string PhoneExtension, string PostalCode, string CardHolder, string CardNumber) {
        object[] results = this.Invoke("LinkUser", new object[] {
                    WebID,
                    GamerTag,
                    Owner,
                    PhonePrefix,
                    PhoneNumber,
                    PhoneExtension,
                    PostalCode,
                    CardHolder,
                    CardNumber});
        return ((bool)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginLinkUser(byte[] WebID, string GamerTag, bool Owner, string PhonePrefix, string PhoneNumber, string PhoneExtension, string PostalCode, string CardHolder, string CardNumber, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("LinkUser", new object[] {
                    WebID,
                    GamerTag,
                    Owner,
                    PhonePrefix,
                    PhoneNumber,
                    PhoneExtension,
                    PostalCode,
                    CardHolder,
                    CardNumber}, callback, asyncState);
    }
    
    /// <remarks/>
    public bool EndLinkUser(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((bool)(results[0]));
    }
    
    /// <remarks/>
    public void LinkUserAsync(byte[] WebID, string GamerTag, bool Owner, string PhonePrefix, string PhoneNumber, string PhoneExtension, string PostalCode, string CardHolder, string CardNumber) {
        this.LinkUserAsync(WebID, GamerTag, Owner, PhonePrefix, PhoneNumber, PhoneExtension, PostalCode, CardHolder, CardNumber, null);
    }
    
    /// <remarks/>
    public void LinkUserAsync(byte[] WebID, string GamerTag, bool Owner, string PhonePrefix, string PhoneNumber, string PhoneExtension, string PostalCode, string CardHolder, string CardNumber, object userState) {
        if ((this.LinkUserOperationCompleted == null)) {
            this.LinkUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnLinkUserOperationCompleted);
        }
        this.InvokeAsync("LinkUser", new object[] {
                    WebID,
                    GamerTag,
                    Owner,
                    PhonePrefix,
                    PhoneNumber,
                    PhoneExtension,
                    PostalCode,
                    CardHolder,
                    CardNumber}, this.LinkUserOperationCompleted, userState);
    }
    
    private void OnLinkUserOperationCompleted(object arg) {
        if ((this.LinkUserCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.LinkUserCompleted(this, new LinkUserCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/UserAccount/LinkedGamerTags", RequestNamespace="http://websvc.xboxlive.com/UserAccount/", ResponseNamespace="http://websvc.xboxlive.com/UserAccount/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public LinkInfo[] LinkedGamerTags([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] WebID) {
        object[] results = this.Invoke("LinkedGamerTags", new object[] {
                    WebID});
        return ((LinkInfo[])(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginLinkedGamerTags(byte[] WebID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("LinkedGamerTags", new object[] {
                    WebID}, callback, asyncState);
    }
    
    /// <remarks/>
    public LinkInfo[] EndLinkedGamerTags(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((LinkInfo[])(results[0]));
    }
    
    /// <remarks/>
    public void LinkedGamerTagsAsync(byte[] WebID) {
        this.LinkedGamerTagsAsync(WebID, null);
    }
    
    /// <remarks/>
    public void LinkedGamerTagsAsync(byte[] WebID, object userState) {
        if ((this.LinkedGamerTagsOperationCompleted == null)) {
            this.LinkedGamerTagsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnLinkedGamerTagsOperationCompleted);
        }
        this.InvokeAsync("LinkedGamerTags", new object[] {
                    WebID}, this.LinkedGamerTagsOperationCompleted, userState);
    }
    
    private void OnLinkedGamerTagsOperationCompleted(object arg) {
        if ((this.LinkedGamerTagsCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.LinkedGamerTagsCompleted(this, new LinkedGamerTagsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/UserAccount/GetUserSettings", RequestNamespace="http://websvc.xboxlive.com/UserAccount/", ResponseNamespace="http://websvc.xboxlive.com/UserAccount/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public uint GetUserSettings([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] WebID, string GamerTag) {
        object[] results = this.Invoke("GetUserSettings", new object[] {
                    WebID,
                    GamerTag});
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetUserSettings(byte[] WebID, string GamerTag, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetUserSettings", new object[] {
                    WebID,
                    GamerTag}, callback, asyncState);
    }
    
    /// <remarks/>
    public uint EndGetUserSettings(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((uint)(results[0]));
    }
    
    /// <remarks/>
    public void GetUserSettingsAsync(byte[] WebID, string GamerTag) {
        this.GetUserSettingsAsync(WebID, GamerTag, null);
    }
    
    /// <remarks/>
    public void GetUserSettingsAsync(byte[] WebID, string GamerTag, object userState) {
        if ((this.GetUserSettingsOperationCompleted == null)) {
            this.GetUserSettingsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetUserSettingsOperationCompleted);
        }
        this.InvokeAsync("GetUserSettings", new object[] {
                    WebID,
                    GamerTag}, this.GetUserSettingsOperationCompleted, userState);
    }
    
    private void OnGetUserSettingsOperationCompleted(object arg) {
        if ((this.GetUserSettingsCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.GetUserSettingsCompleted(this, new GetUserSettingsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/UserAccount/SetInfoSharing", RequestNamespace="http://websvc.xboxlive.com/UserAccount/", ResponseNamespace="http://websvc.xboxlive.com/UserAccount/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public bool SetInfoSharing([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] WebID, string GamerTag, bool acceptMSInfo, bool acceptPartnerInfo) {
        object[] results = this.Invoke("SetInfoSharing", new object[] {
                    WebID,
                    GamerTag,
                    acceptMSInfo,
                    acceptPartnerInfo});
        return ((bool)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSetInfoSharing(byte[] WebID, string GamerTag, bool acceptMSInfo, bool acceptPartnerInfo, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SetInfoSharing", new object[] {
                    WebID,
                    GamerTag,
                    acceptMSInfo,
                    acceptPartnerInfo}, callback, asyncState);
    }
    
    /// <remarks/>
    public bool EndSetInfoSharing(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((bool)(results[0]));
    }
    
    /// <remarks/>
    public void SetInfoSharingAsync(byte[] WebID, string GamerTag, bool acceptMSInfo, bool acceptPartnerInfo) {
        this.SetInfoSharingAsync(WebID, GamerTag, acceptMSInfo, acceptPartnerInfo, null);
    }
    
    /// <remarks/>
    public void SetInfoSharingAsync(byte[] WebID, string GamerTag, bool acceptMSInfo, bool acceptPartnerInfo, object userState) {
        if ((this.SetInfoSharingOperationCompleted == null)) {
            this.SetInfoSharingOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetInfoSharingOperationCompleted);
        }
        this.InvokeAsync("SetInfoSharing", new object[] {
                    WebID,
                    GamerTag,
                    acceptMSInfo,
                    acceptPartnerInfo}, this.SetInfoSharingOperationCompleted, userState);
    }
    
    private void OnSetInfoSharingOperationCompleted(object arg) {
        if ((this.SetInfoSharingCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.SetInfoSharingCompleted(this, new SetInfoSharingCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/UserAccount/GetAccountStatus", RequestNamespace="http://websvc.xboxlive.com/UserAccount/", ResponseNamespace="http://websvc.xboxlive.com/UserAccount/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public UserAccountStatus GetAccountStatus([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] WebID, string GamerTag) {
        object[] results = this.Invoke("GetAccountStatus", new object[] {
                    WebID,
                    GamerTag});
        return ((UserAccountStatus)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetAccountStatus(byte[] WebID, string GamerTag, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetAccountStatus", new object[] {
                    WebID,
                    GamerTag}, callback, asyncState);
    }
    
    /// <remarks/>
    public UserAccountStatus EndGetAccountStatus(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((UserAccountStatus)(results[0]));
    }
    
    /// <remarks/>
    public void GetAccountStatusAsync(byte[] WebID, string GamerTag) {
        this.GetAccountStatusAsync(WebID, GamerTag, null);
    }
    
    /// <remarks/>
    public void GetAccountStatusAsync(byte[] WebID, string GamerTag, object userState) {
        if ((this.GetAccountStatusOperationCompleted == null)) {
            this.GetAccountStatusOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetAccountStatusOperationCompleted);
        }
        this.InvokeAsync("GetAccountStatus", new object[] {
                    WebID,
                    GamerTag}, this.GetAccountStatusOperationCompleted, userState);
    }
    
    private void OnGetAccountStatusOperationCompleted(object arg) {
        if ((this.GetAccountStatusCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.GetAccountStatusCompleted(this, new GetAccountStatusCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/UserAccount/GetUserAuthorization", RequestNamespace="http://websvc.xboxlive.com/UserAccount/", ResponseNamespace="http://websvc.xboxlive.com/UserAccount/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public UserAuthorization GetUserAuthorization(uint titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webId, string gamerTag) {
        object[] results = this.Invoke("GetUserAuthorization", new object[] {
                    titleId,
                    webId,
                    gamerTag});
        return ((UserAuthorization)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetUserAuthorization(uint titleId, byte[] webId, string gamerTag, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetUserAuthorization", new object[] {
                    titleId,
                    webId,
                    gamerTag}, callback, asyncState);
    }
    
    /// <remarks/>
    public UserAuthorization EndGetUserAuthorization(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((UserAuthorization)(results[0]));
    }
    
    /// <remarks/>
    public void GetUserAuthorizationAsync(uint titleId, byte[] webId, string gamerTag) {
        this.GetUserAuthorizationAsync(titleId, webId, gamerTag, null);
    }
    
    /// <remarks/>
    public void GetUserAuthorizationAsync(uint titleId, byte[] webId, string gamerTag, object userState) {
        if ((this.GetUserAuthorizationOperationCompleted == null)) {
            this.GetUserAuthorizationOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetUserAuthorizationOperationCompleted);
        }
        this.InvokeAsync("GetUserAuthorization", new object[] {
                    titleId,
                    webId,
                    gamerTag}, this.GetUserAuthorizationOperationCompleted, userState);
    }
    
    private void OnGetUserAuthorizationOperationCompleted(object arg) {
        if ((this.GetUserAuthorizationCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.GetUserAuthorizationCompleted(this, new GetUserAuthorizationCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/UserAccount/CreateWholesaleAccount", RequestNamespace="http://websvc.xboxlive.com/UserAccount/", ResponseNamespace="http://websvc.xboxlive.com/UserAccount/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public CreateWholesaleAccountResponse CreateWholesaleAccount(CreateWholesaleAccountRequest request) {
        object[] results = this.Invoke("CreateWholesaleAccount", new object[] {
                    request});
        return ((CreateWholesaleAccountResponse)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCreateWholesaleAccount(CreateWholesaleAccountRequest request, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CreateWholesaleAccount", new object[] {
                    request}, callback, asyncState);
    }
    
    /// <remarks/>
    public CreateWholesaleAccountResponse EndCreateWholesaleAccount(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((CreateWholesaleAccountResponse)(results[0]));
    }
    
    /// <remarks/>
    public void CreateWholesaleAccountAsync(CreateWholesaleAccountRequest request) {
        this.CreateWholesaleAccountAsync(request, null);
    }
    
    /// <remarks/>
    public void CreateWholesaleAccountAsync(CreateWholesaleAccountRequest request, object userState) {
        if ((this.CreateWholesaleAccountOperationCompleted == null)) {
            this.CreateWholesaleAccountOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCreateWholesaleAccountOperationCompleted);
        }
        this.InvokeAsync("CreateWholesaleAccount", new object[] {
                    request}, this.CreateWholesaleAccountOperationCompleted, userState);
    }
    
    private void OnCreateWholesaleAccountOperationCompleted(object arg) {
        if ((this.CreateWholesaleAccountCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.CreateWholesaleAccountCompleted(this, new CreateWholesaleAccountCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    public new void CancelAsync(object userState) {
        base.CancelAsync(userState);
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/UserAccount/")]
public partial class LinkInfo {
    
    private string gamerTagField;
    
    private bool ownerField;
    
    /// <remarks/>
    public string GamerTag {
        get {
            return this.gamerTagField;
        }
        set {
            this.gamerTagField = value;
        }
    }
    
    /// <remarks/>
    public bool Owner {
        get {
            return this.ownerField;
        }
        set {
            this.ownerField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/UserAccount/")]
public partial class CreateWholesaleAccountResponse {
    
    private int userPuidHighField;
    
    private int userPuidLowField;
    
    private string gamertagField;
    
    private string passwordField;
    
    /// <remarks/>
    public int userPuidHigh {
        get {
            return this.userPuidHighField;
        }
        set {
            this.userPuidHighField = value;
        }
    }
    
    /// <remarks/>
    public int userPuidLow {
        get {
            return this.userPuidLowField;
        }
        set {
            this.userPuidLowField = value;
        }
    }
    
    /// <remarks/>
    public string gamertag {
        get {
            return this.gamertagField;
        }
        set {
            this.gamertagField = value;
        }
    }
    
    /// <remarks/>
    public string password {
        get {
            return this.passwordField;
        }
        set {
            this.passwordField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/UserAccount/")]
public partial class PhoneInfo {
    
    private string phonePrefixField;
    
    private string phoneNumberField;
    
    private string phoneExtensionField;
    
    /// <remarks/>
    public string phonePrefix {
        get {
            return this.phonePrefixField;
        }
        set {
            this.phonePrefixField = value;
        }
    }
    
    /// <remarks/>
    public string phoneNumber {
        get {
            return this.phoneNumberField;
        }
        set {
            this.phoneNumberField = value;
        }
    }
    
    /// <remarks/>
    public string phoneExtension {
        get {
            return this.phoneExtensionField;
        }
        set {
            this.phoneExtensionField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/UserAccount/")]
public partial class AddressInfo {
    
    private string street1Field;
    
    private string street2Field;
    
    private string cityField;
    
    private string districtField;
    
    private string stateField;
    
    private string postalCodeField;
    
    /// <remarks/>
    public string street1 {
        get {
            return this.street1Field;
        }
        set {
            this.street1Field = value;
        }
    }
    
    /// <remarks/>
    public string street2 {
        get {
            return this.street2Field;
        }
        set {
            this.street2Field = value;
        }
    }
    
    /// <remarks/>
    public string city {
        get {
            return this.cityField;
        }
        set {
            this.cityField = value;
        }
    }
    
    /// <remarks/>
    public string district {
        get {
            return this.districtField;
        }
        set {
            this.districtField = value;
        }
    }
    
    /// <remarks/>
    public string state {
        get {
            return this.stateField;
        }
        set {
            this.stateField = value;
        }
    }
    
    /// <remarks/>
    public string postalCode {
        get {
            return this.postalCodeField;
        }
        set {
            this.postalCodeField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/UserAccount/")]
public partial class CreateWholesaleAccountRequest {
    
    private ulong offerIdField;
    
    private string firstNameField;
    
    private string lastNameField;
    
    private AddressInfo addressInfoField;
    
    private PhoneInfo phoneInfoField;
    
    private string emailField;
    
    private byte countryIdField;
    
    private ushort languageIdField;
    
    private System.DateTime birthdateField;
    
    private string memberNameField;
    
    private string externalReferenceIdField;
    
    private byte[] reservedBytesField;
    
    /// <remarks/>
    public ulong offerId {
        get {
            return this.offerIdField;
        }
        set {
            this.offerIdField = value;
        }
    }
    
    /// <remarks/>
    public string firstName {
        get {
            return this.firstNameField;
        }
        set {
            this.firstNameField = value;
        }
    }
    
    /// <remarks/>
    public string lastName {
        get {
            return this.lastNameField;
        }
        set {
            this.lastNameField = value;
        }
    }
    
    /// <remarks/>
    public AddressInfo addressInfo {
        get {
            return this.addressInfoField;
        }
        set {
            this.addressInfoField = value;
        }
    }
    
    /// <remarks/>
    public PhoneInfo phoneInfo {
        get {
            return this.phoneInfoField;
        }
        set {
            this.phoneInfoField = value;
        }
    }
    
    /// <remarks/>
    public string email {
        get {
            return this.emailField;
        }
        set {
            this.emailField = value;
        }
    }
    
    /// <remarks/>
    public byte countryId {
        get {
            return this.countryIdField;
        }
        set {
            this.countryIdField = value;
        }
    }
    
    /// <remarks/>
    public ushort languageId {
        get {
            return this.languageIdField;
        }
        set {
            this.languageIdField = value;
        }
    }
    
    /// <remarks/>
    public System.DateTime birthdate {
        get {
            return this.birthdateField;
        }
        set {
            this.birthdateField = value;
        }
    }
    
    /// <remarks/>
    public string memberName {
        get {
            return this.memberNameField;
        }
        set {
            this.memberNameField = value;
        }
    }
    
    /// <remarks/>
    public string externalReferenceId {
        get {
            return this.externalReferenceIdField;
        }
        set {
            this.externalReferenceIdField = value;
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
    public byte[] reservedBytes {
        get {
            return this.reservedBytesField;
        }
        set {
            this.reservedBytesField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/UserAccount/")]
public partial class UserAuthorization {
    
    private bool acceptedTermsOfServiceField;
    
    private bool isVoiceBannedField;
    
    private bool isSuspendedField;
    
    private bool[] privilegesField;
    
    private uint[] servicesField;
    
    /// <remarks/>
    public bool acceptedTermsOfService {
        get {
            return this.acceptedTermsOfServiceField;
        }
        set {
            this.acceptedTermsOfServiceField = value;
        }
    }
    
    /// <remarks/>
    public bool isVoiceBanned {
        get {
            return this.isVoiceBannedField;
        }
        set {
            this.isVoiceBannedField = value;
        }
    }
    
    /// <remarks/>
    public bool isSuspended {
        get {
            return this.isSuspendedField;
        }
        set {
            this.isSuspendedField = value;
        }
    }
    
    /// <remarks/>
    public bool[] privileges {
        get {
            return this.privilegesField;
        }
        set {
            this.privilegesField = value;
        }
    }
    
    /// <remarks/>
    public uint[] services {
        get {
            return this.servicesField;
        }
        set {
            this.servicesField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/UserAccount/")]
public partial class UserAccountStatus {
    
    private bool acceptMSInfoField;
    
    private bool acceptPartnerInfoField;
    
    private bool forceNameChangeField;
    
    private bool voiceBannedField;
    
    private System.DateTime voiceBannedUntilField;
    
    private bool nicknameBannedField;
    
    private bool accountSuspendedField;
    
    private System.DateTime accountSuspendedUntilField;
    
    /// <remarks/>
    public bool acceptMSInfo {
        get {
            return this.acceptMSInfoField;
        }
        set {
            this.acceptMSInfoField = value;
        }
    }
    
    /// <remarks/>
    public bool acceptPartnerInfo {
        get {
            return this.acceptPartnerInfoField;
        }
        set {
            this.acceptPartnerInfoField = value;
        }
    }
    
    /// <remarks/>
    public bool forceNameChange {
        get {
            return this.forceNameChangeField;
        }
        set {
            this.forceNameChangeField = value;
        }
    }
    
    /// <remarks/>
    public bool voiceBanned {
        get {
            return this.voiceBannedField;
        }
        set {
            this.voiceBannedField = value;
        }
    }
    
    /// <remarks/>
    public System.DateTime voiceBannedUntil {
        get {
            return this.voiceBannedUntilField;
        }
        set {
            this.voiceBannedUntilField = value;
        }
    }
    
    /// <remarks/>
    public bool nicknameBanned {
        get {
            return this.nicknameBannedField;
        }
        set {
            this.nicknameBannedField = value;
        }
    }
    
    /// <remarks/>
    public bool accountSuspended {
        get {
            return this.accountSuspendedField;
        }
        set {
            this.accountSuspendedField = value;
        }
    }
    
    /// <remarks/>
    public System.DateTime accountSuspendedUntil {
        get {
            return this.accountSuspendedUntilField;
        }
        set {
            this.accountSuspendedUntilField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void LinkUserCompletedEventHandler(object sender, LinkUserCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class LinkUserCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal LinkUserCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public bool Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((bool)(this.results[0]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void LinkedGamerTagsCompletedEventHandler(object sender, LinkedGamerTagsCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class LinkedGamerTagsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal LinkedGamerTagsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public LinkInfo[] Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((LinkInfo[])(this.results[0]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void GetUserSettingsCompletedEventHandler(object sender, GetUserSettingsCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class GetUserSettingsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal GetUserSettingsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public uint Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((uint)(this.results[0]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void SetInfoSharingCompletedEventHandler(object sender, SetInfoSharingCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class SetInfoSharingCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal SetInfoSharingCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public bool Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((bool)(this.results[0]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void GetAccountStatusCompletedEventHandler(object sender, GetAccountStatusCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class GetAccountStatusCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal GetAccountStatusCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public UserAccountStatus Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((UserAccountStatus)(this.results[0]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void GetUserAuthorizationCompletedEventHandler(object sender, GetUserAuthorizationCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class GetUserAuthorizationCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal GetUserAuthorizationCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public UserAuthorization Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((UserAuthorization)(this.results[0]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void CreateWholesaleAccountCompletedEventHandler(object sender, CreateWholesaleAccountCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class CreateWholesaleAccountCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal CreateWholesaleAccountCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public CreateWholesaleAccountResponse Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((CreateWholesaleAccountResponse)(this.results[0]));
        }
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\WebReferences\xbos2\reference.cs ===
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3603
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace ServerTestFramework.LiveService.Billing.WebService2 {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="BillingSoap", Namespace="urn:schemas-xbox-com:billing-data")]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(WireData))]
    public partial class Billing : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback TestConnectionOperationCompleted;
        
        private System.Threading.SendOrPostCallback PurchaseMediaOffersOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetPurchaseStatusOperationCompleted;
        
        private System.Threading.SendOrPostCallback FindMediaInstanceUrlsOperationCompleted;
        
        private System.Threading.SendOrPostCallback VerifyTokenOperationCompleted;
        
        private System.Threading.SendOrPostCallback CancelSubscriptionOperationCompleted;
        
        private System.Threading.SendOrPostCallback GamertagEnumerateOperationCompleted;
        
        private System.Threading.SendOrPostCallback SubscriptionEnumerateOperationCompleted;
        
        private System.Threading.SendOrPostCallback PurchaseBillingOfferOperationCompleted;
        
        private System.Threading.SendOrPostCallback PurchaseGamertagOperationCompleted;
        
        /// <remarks/>
        public Billing() {
            this.Url = "http://localhost:10090/xbos/billing.asmx";
        }
        
        /// <remarks/>
        public event TestConnectionCompletedEventHandler TestConnectionCompleted;
        
        /// <remarks/>
        public event PurchaseMediaOffersCompletedEventHandler PurchaseMediaOffersCompleted;
        
        /// <remarks/>
        public event GetPurchaseStatusCompletedEventHandler GetPurchaseStatusCompleted;
        
        /// <remarks/>
        public event FindMediaInstanceUrlsCompletedEventHandler FindMediaInstanceUrlsCompleted;
        
        /// <remarks/>
        public event VerifyTokenCompletedEventHandler VerifyTokenCompleted;
        
        /// <remarks/>
        public event CancelSubscriptionCompletedEventHandler CancelSubscriptionCompleted;
        
        /// <remarks/>
        public event GamertagEnumerateCompletedEventHandler GamertagEnumerateCompleted;
        
        /// <remarks/>
        public event SubscriptionEnumerateCompletedEventHandler SubscriptionEnumerateCompleted;
        
        /// <remarks/>
        public event PurchaseBillingOfferCompletedEventHandler PurchaseBillingOfferCompleted;
        
        /// <remarks/>
        public event PurchaseGamertagCompletedEventHandler PurchaseGamertagCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:billing-data/TestConnection", RequestNamespace="urn:schemas-xbox-com:billing-data", ResponseNamespace="urn:schemas-xbox-com:billing-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string TestConnection(string inputMessage) {
            object[] results = this.Invoke("TestConnection", new object[] {
                        inputMessage});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginTestConnection(string inputMessage, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("TestConnection", new object[] {
                        inputMessage}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndTestConnection(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void TestConnectionAsync(string inputMessage) {
            this.TestConnectionAsync(inputMessage, null);
        }
        
        /// <remarks/>
        public void TestConnectionAsync(string inputMessage, object userState) {
            if ((this.TestConnectionOperationCompleted == null)) {
                this.TestConnectionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnTestConnectionOperationCompleted);
            }
            this.InvokeAsync("TestConnection", new object[] {
                        inputMessage}, this.TestConnectionOperationCompleted, userState);
        }
        
        private void OnTestConnectionOperationCompleted(object arg) {
            if ((this.TestConnectionCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.TestConnectionCompleted(this, new TestConnectionCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:billing-data/PurchaseMediaOffers", RequestNamespace="urn:schemas-xbox-com:billing-data", ResponseNamespace="urn:schemas-xbox-com:billing-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void PurchaseMediaOffers(ulong userPuid, ulong machinePuid, string[] offerIds, int[] mediaTypes, uint[] expectedPrices, PaymentTypeEnum paymentType, string paymentInstrumentId, string billingToken, int storeId) {
            this.Invoke("PurchaseMediaOffers", new object[] {
                        userPuid,
                        machinePuid,
                        offerIds,
                        mediaTypes,
                        expectedPrices,
                        paymentType,
                        paymentInstrumentId,
                        billingToken,
                        storeId});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginPurchaseMediaOffers(ulong userPuid, ulong machinePuid, string[] offerIds, int[] mediaTypes, uint[] expectedPrices, PaymentTypeEnum paymentType, string paymentInstrumentId, string billingToken, int storeId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("PurchaseMediaOffers", new object[] {
                        userPuid,
                        machinePuid,
                        offerIds,
                        mediaTypes,
                        expectedPrices,
                        paymentType,
                        paymentInstrumentId,
                        billingToken,
                        storeId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndPurchaseMediaOffers(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void PurchaseMediaOffersAsync(ulong userPuid, ulong machinePuid, string[] offerIds, int[] mediaTypes, uint[] expectedPrices, PaymentTypeEnum paymentType, string paymentInstrumentId, string billingToken, int storeId) {
            this.PurchaseMediaOffersAsync(userPuid, machinePuid, offerIds, mediaTypes, expectedPrices, paymentType, paymentInstrumentId, billingToken, storeId, null);
        }
        
        /// <remarks/>
        public void PurchaseMediaOffersAsync(ulong userPuid, ulong machinePuid, string[] offerIds, int[] mediaTypes, uint[] expectedPrices, PaymentTypeEnum paymentType, string paymentInstrumentId, string billingToken, int storeId, object userState) {
            if ((this.PurchaseMediaOffersOperationCompleted == null)) {
                this.PurchaseMediaOffersOperationCompleted = new System.Threading.SendOrPostCallback(this.OnPurchaseMediaOffersOperationCompleted);
            }
            this.InvokeAsync("PurchaseMediaOffers", new object[] {
                        userPuid,
                        machinePuid,
                        offerIds,
                        mediaTypes,
                        expectedPrices,
                        paymentType,
                        paymentInstrumentId,
                        billingToken,
                        storeId}, this.PurchaseMediaOffersOperationCompleted, userState);
        }
        
        private void OnPurchaseMediaOffersOperationCompleted(object arg) {
            if ((this.PurchaseMediaOffersCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.PurchaseMediaOffersCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:billing-data/GetPurchaseStatus", RequestNamespace="urn:schemas-xbox-com:billing-data", ResponseNamespace="urn:schemas-xbox-com:billing-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public PurchaseStatus[] GetPurchaseStatus(ulong userPuid, string[] offerIds) {
            object[] results = this.Invoke("GetPurchaseStatus", new object[] {
                        userPuid,
                        offerIds});
            return ((PurchaseStatus[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPurchaseStatus(ulong userPuid, string[] offerIds, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPurchaseStatus", new object[] {
                        userPuid,
                        offerIds}, callback, asyncState);
        }
        
        /// <remarks/>
        public PurchaseStatus[] EndGetPurchaseStatus(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((PurchaseStatus[])(results[0]));
        }
        
        /// <remarks/>
        public void GetPurchaseStatusAsync(ulong userPuid, string[] offerIds) {
            this.GetPurchaseStatusAsync(userPuid, offerIds, null);
        }
        
        /// <remarks/>
        public void GetPurchaseStatusAsync(ulong userPuid, string[] offerIds, object userState) {
            if ((this.GetPurchaseStatusOperationCompleted == null)) {
                this.GetPurchaseStatusOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetPurchaseStatusOperationCompleted);
            }
            this.InvokeAsync("GetPurchaseStatus", new object[] {
                        userPuid,
                        offerIds}, this.GetPurchaseStatusOperationCompleted, userState);
        }
        
        private void OnGetPurchaseStatusOperationCompleted(object arg) {
            if ((this.GetPurchaseStatusCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetPurchaseStatusCompleted(this, new GetPurchaseStatusCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:billing-data/FindMediaInstanceUrls", RequestNamespace="urn:schemas-xbox-com:billing-data", ResponseNamespace="urn:schemas-xbox-com:billing-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public MediaInstanceUrl[] FindMediaInstanceUrls(string[] mediaInstanceIds, ulong userPuid) {
            object[] results = this.Invoke("FindMediaInstanceUrls", new object[] {
                        mediaInstanceIds,
                        userPuid});
            return ((MediaInstanceUrl[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginFindMediaInstanceUrls(string[] mediaInstanceIds, ulong userPuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("FindMediaInstanceUrls", new object[] {
                        mediaInstanceIds,
                        userPuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public MediaInstanceUrl[] EndFindMediaInstanceUrls(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((MediaInstanceUrl[])(results[0]));
        }
        
        /// <remarks/>
        public void FindMediaInstanceUrlsAsync(string[] mediaInstanceIds, ulong userPuid) {
            this.FindMediaInstanceUrlsAsync(mediaInstanceIds, userPuid, null);
        }
        
        /// <remarks/>
        public void FindMediaInstanceUrlsAsync(string[] mediaInstanceIds, ulong userPuid, object userState) {
            if ((this.FindMediaInstanceUrlsOperationCompleted == null)) {
                this.FindMediaInstanceUrlsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnFindMediaInstanceUrlsOperationCompleted);
            }
            this.InvokeAsync("FindMediaInstanceUrls", new object[] {
                        mediaInstanceIds,
                        userPuid}, this.FindMediaInstanceUrlsOperationCompleted, userState);
        }
        
        private void OnFindMediaInstanceUrlsOperationCompleted(object arg) {
            if ((this.FindMediaInstanceUrlsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.FindMediaInstanceUrlsCompleted(this, new FindMediaInstanceUrlsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:billing-data/VerifyToken", RequestNamespace="urn:schemas-xbox-com:billing-data", ResponseNamespace="urn:schemas-xbox-com:billing-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public VerifyTokenResults VerifyToken(ulong userPuid, ulong machinePuid, string billingToken, int storeId) {
            object[] results = this.Invoke("VerifyToken", new object[] {
                        userPuid,
                        machinePuid,
                        billingToken,
                        storeId});
            return ((VerifyTokenResults)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginVerifyToken(ulong userPuid, ulong machinePuid, string billingToken, int storeId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("VerifyToken", new object[] {
                        userPuid,
                        machinePuid,
                        billingToken,
                        storeId}, callback, asyncState);
        }
        
        /// <remarks/>
        public VerifyTokenResults EndVerifyToken(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((VerifyTokenResults)(results[0]));
        }
        
        /// <remarks/>
        public void VerifyTokenAsync(ulong userPuid, ulong machinePuid, string billingToken, int storeId) {
            this.VerifyTokenAsync(userPuid, machinePuid, billingToken, storeId, null);
        }
        
        /// <remarks/>
        public void VerifyTokenAsync(ulong userPuid, ulong machinePuid, string billingToken, int storeId, object userState) {
            if ((this.VerifyTokenOperationCompleted == null)) {
                this.VerifyTokenOperationCompleted = new System.Threading.SendOrPostCallback(this.OnVerifyTokenOperationCompleted);
            }
            this.InvokeAsync("VerifyToken", new object[] {
                        userPuid,
                        machinePuid,
                        billingToken,
                        storeId}, this.VerifyTokenOperationCompleted, userState);
        }
        
        private void OnVerifyTokenOperationCompleted(object arg) {
            if ((this.VerifyTokenCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.VerifyTokenCompleted(this, new VerifyTokenCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:billing-data/CancelSubscription", RequestNamespace="urn:schemas-xbox-com:billing-data", ResponseNamespace="urn:schemas-xbox-com:billing-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void CancelSubscription(ulong userPuid, ulong machinePuid, ulong offerId, bool undoDelayedCancel) {
            this.Invoke("CancelSubscription", new object[] {
                        userPuid,
                        machinePuid,
                        offerId,
                        undoDelayedCancel});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCancelSubscription(ulong userPuid, ulong machinePuid, ulong offerId, bool undoDelayedCancel, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CancelSubscription", new object[] {
                        userPuid,
                        machinePuid,
                        offerId,
                        undoDelayedCancel}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCancelSubscription(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void CancelSubscriptionAsync(ulong userPuid, ulong machinePuid, ulong offerId, bool undoDelayedCancel) {
            this.CancelSubscriptionAsync(userPuid, machinePuid, offerId, undoDelayedCancel, null);
        }
        
        /// <remarks/>
        public void CancelSubscriptionAsync(ulong userPuid, ulong machinePuid, ulong offerId, bool undoDelayedCancel, object userState) {
            if ((this.CancelSubscriptionOperationCompleted == null)) {
                this.CancelSubscriptionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCancelSubscriptionOperationCompleted);
            }
            this.InvokeAsync("CancelSubscription", new object[] {
                        userPuid,
                        machinePuid,
                        offerId,
                        undoDelayedCancel}, this.CancelSubscriptionOperationCompleted, userState);
        }
        
        private void OnCancelSubscriptionOperationCompleted(object arg) {
            if ((this.CancelSubscriptionCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CancelSubscriptionCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:billing-data/GamertagEnumerate", RequestNamespace="urn:schemas-xbox-com:billing-data", ResponseNamespace="urn:schemas-xbox-com:billing-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public GamertagEnumerateResult GamertagEnumerate(ulong userPuid, PaymentTypeEnum paymentType, uint titleId) {
            object[] results = this.Invoke("GamertagEnumerate", new object[] {
                        userPuid,
                        paymentType,
                        titleId});
            return ((GamertagEnumerateResult)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGamertagEnumerate(ulong userPuid, PaymentTypeEnum paymentType, uint titleId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GamertagEnumerate", new object[] {
                        userPuid,
                        paymentType,
                        titleId}, callback, asyncState);
        }
        
        /// <remarks/>
        public GamertagEnumerateResult EndGamertagEnumerate(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((GamertagEnumerateResult)(results[0]));
        }
        
        /// <remarks/>
        public void GamertagEnumerateAsync(ulong userPuid, PaymentTypeEnum paymentType, uint titleId) {
            this.GamertagEnumerateAsync(userPuid, paymentType, titleId, null);
        }
        
        /// <remarks/>
        public void GamertagEnumerateAsync(ulong userPuid, PaymentTypeEnum paymentType, uint titleId, object userState) {
            if ((this.GamertagEnumerateOperationCompleted == null)) {
                this.GamertagEnumerateOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGamertagEnumerateOperationCompleted);
            }
            this.InvokeAsync("GamertagEnumerate", new object[] {
                        userPuid,
                        paymentType,
                        titleId}, this.GamertagEnumerateOperationCompleted, userState);
        }
        
        private void OnGamertagEnumerateOperationCompleted(object arg) {
            if ((this.GamertagEnumerateCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GamertagEnumerateCompleted(this, new GamertagEnumerateCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:billing-data/SubscriptionEnumerate", RequestNamespace="urn:schemas-xbox-com:billing-data", ResponseNamespace="urn:schemas-xbox-com:billing-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public SubscriptionEnumerateResults SubscriptionEnumerate(ulong userPuid, ulong machinePuid, uint offerType, uint paymentType, uint titleId, bool queryForNew, bool queryForRenewals, bool queryForCurrent, bool queryForCancelled, bool queryForSuspended) {
            object[] results = this.Invoke("SubscriptionEnumerate", new object[] {
                        userPuid,
                        machinePuid,
                        offerType,
                        paymentType,
                        titleId,
                        queryForNew,
                        queryForRenewals,
                        queryForCurrent,
                        queryForCancelled,
                        queryForSuspended});
            return ((SubscriptionEnumerateResults)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSubscriptionEnumerate(ulong userPuid, ulong machinePuid, uint offerType, uint paymentType, uint titleId, bool queryForNew, bool queryForRenewals, bool queryForCurrent, bool queryForCancelled, bool queryForSuspended, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SubscriptionEnumerate", new object[] {
                        userPuid,
                        machinePuid,
                        offerType,
                        paymentType,
                        titleId,
                        queryForNew,
                        queryForRenewals,
                        queryForCurrent,
                        queryForCancelled,
                        queryForSuspended}, callback, asyncState);
        }
        
        /// <remarks/>
        public SubscriptionEnumerateResults EndSubscriptionEnumerate(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((SubscriptionEnumerateResults)(results[0]));
        }
        
        /// <remarks/>
        public void SubscriptionEnumerateAsync(ulong userPuid, ulong machinePuid, uint offerType, uint paymentType, uint titleId, bool queryForNew, bool queryForRenewals, bool queryForCurrent, bool queryForCancelled, bool queryForSuspended) {
            this.SubscriptionEnumerateAsync(userPuid, machinePuid, offerType, paymentType, titleId, queryForNew, queryForRenewals, queryForCurrent, queryForCancelled, queryForSuspended, null);
        }
        
        /// <remarks/>
        public void SubscriptionEnumerateAsync(ulong userPuid, ulong machinePuid, uint offerType, uint paymentType, uint titleId, bool queryForNew, bool queryForRenewals, bool queryForCurrent, bool queryForCancelled, bool queryForSuspended, object userState) {
            if ((this.SubscriptionEnumerateOperationCompleted == null)) {
                this.SubscriptionEnumerateOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSubscriptionEnumerateOperationCompleted);
            }
            this.InvokeAsync("SubscriptionEnumerate", new object[] {
                        userPuid,
                        machinePuid,
                        offerType,
                        paymentType,
                        titleId,
                        queryForNew,
                        queryForRenewals,
                        queryForCurrent,
                        queryForCancelled,
                        queryForSuspended}, this.SubscriptionEnumerateOperationCompleted, userState);
        }
        
        private void OnSubscriptionEnumerateOperationCompleted(object arg) {
            if ((this.SubscriptionEnumerateCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SubscriptionEnumerateCompleted(this, new SubscriptionEnumerateCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:billing-data/PurchaseBillingOffer", RequestNamespace="urn:schemas-xbox-com:billing-data", ResponseNamespace="urn:schemas-xbox-com:billing-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void PurchaseBillingOffer(ulong userPuid, ulong machinePuid, ulong offerId, uint paymentType, string paymentInstrumentId, string billingToken) {
            this.Invoke("PurchaseBillingOffer", new object[] {
                        userPuid,
                        machinePuid,
                        offerId,
                        paymentType,
                        paymentInstrumentId,
                        billingToken});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginPurchaseBillingOffer(ulong userPuid, ulong machinePuid, ulong offerId, uint paymentType, string paymentInstrumentId, string billingToken, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("PurchaseBillingOffer", new object[] {
                        userPuid,
                        machinePuid,
                        offerId,
                        paymentType,
                        paymentInstrumentId,
                        billingToken}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndPurchaseBillingOffer(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void PurchaseBillingOfferAsync(ulong userPuid, ulong machinePuid, ulong offerId, uint paymentType, string paymentInstrumentId, string billingToken) {
            this.PurchaseBillingOfferAsync(userPuid, machinePuid, offerId, paymentType, paymentInstrumentId, billingToken, null);
        }
        
        /// <remarks/>
        public void PurchaseBillingOfferAsync(ulong userPuid, ulong machinePuid, ulong offerId, uint paymentType, string paymentInstrumentId, string billingToken, object userState) {
            if ((this.PurchaseBillingOfferOperationCompleted == null)) {
                this.PurchaseBillingOfferOperationCompleted = new System.Threading.SendOrPostCallback(this.OnPurchaseBillingOfferOperationCompleted);
            }
            this.InvokeAsync("PurchaseBillingOffer", new object[] {
                        userPuid,
                        machinePuid,
                        offerId,
                        paymentType,
                        paymentInstrumentId,
                        billingToken}, this.PurchaseBillingOfferOperationCompleted, userState);
        }
        
        private void OnPurchaseBillingOfferOperationCompleted(object arg) {
            if ((this.PurchaseBillingOfferCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.PurchaseBillingOfferCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:billing-data/PurchaseGamertag", RequestNamespace="urn:schemas-xbox-com:billing-data", ResponseNamespace="urn:schemas-xbox-com:billing-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public uint PurchaseGamertag(ulong userPuid, ulong machinePuid, System.Guid offerGuid, PaymentTypeEnum paymentType, string gamertag, string token) {
            object[] results = this.Invoke("PurchaseGamertag", new object[] {
                        userPuid,
                        machinePuid,
                        offerGuid,
                        paymentType,
                        gamertag,
                        token});
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginPurchaseGamertag(ulong userPuid, ulong machinePuid, System.Guid offerGuid, PaymentTypeEnum paymentType, string gamertag, string token, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("PurchaseGamertag", new object[] {
                        userPuid,
                        machinePuid,
                        offerGuid,
                        paymentType,
                        gamertag,
                        token}, callback, asyncState);
        }
        
        /// <remarks/>
        public uint EndPurchaseGamertag(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((uint)(results[0]));
        }
        
        /// <remarks/>
        public void PurchaseGamertagAsync(ulong userPuid, ulong machinePuid, System.Guid offerGuid, PaymentTypeEnum paymentType, string gamertag, string token) {
            this.PurchaseGamertagAsync(userPuid, machinePuid, offerGuid, paymentType, gamertag, token, null);
        }
        
        /// <remarks/>
        public void PurchaseGamertagAsync(ulong userPuid, ulong machinePuid, System.Guid offerGuid, PaymentTypeEnum paymentType, string gamertag, string token, object userState) {
            if ((this.PurchaseGamertagOperationCompleted == null)) {
                this.PurchaseGamertagOperationCompleted = new System.Threading.SendOrPostCallback(this.OnPurchaseGamertagOperationCompleted);
            }
            this.InvokeAsync("PurchaseGamertag", new object[] {
                        userPuid,
                        machinePuid,
                        offerGuid,
                        paymentType,
                        gamertag,
                        token}, this.PurchaseGamertagOperationCompleted, userState);
        }
        
        private void OnPurchaseGamertagOperationCompleted(object arg) {
            if ((this.PurchaseGamertagCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.PurchaseGamertagCompleted(this, new PurchaseGamertagCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.FlagsAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:billing-data")]
    public enum PaymentTypeEnum {
        
        /// <remarks/>
        CreditCard = 1,
        
        /// <remarks/>
        Token = 2,
        
        /// <remarks/>
        Points = 4,
        
        /// <remarks/>
        Wholesale = 8,
        
        /// <remarks/>
        Untrusted = 16,
        
        /// <remarks/>
        All = 32,
        
        /// <remarks/>
        NoTokens = 64,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:billing-data")]
    public partial class PurchaseStatus {
        
        private System.Guid offerIdField;
        
        private PurchaseStatusEnum statusField;
        
        /// <remarks/>
        public System.Guid offerId {
            get {
                return this.offerIdField;
            }
            set {
                this.offerIdField = value;
            }
        }
        
        /// <remarks/>
        public PurchaseStatusEnum status {
            get {
                return this.statusField;
            }
            set {
                this.statusField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:billing-data")]
    public enum PurchaseStatusEnum {
        
        /// <remarks/>
        OfferIdNotFound,
        
        /// <remarks/>
        TransactionPending,
        
        /// <remarks/>
        TransactionSuccessful,
        
        /// <remarks/>
        TransactionFailed,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:billing-data")]
    public partial class PriceInfo {
        
        private uint paymentTypeField;
        
        private byte taxTypeField;
        
        private int wholePriceField;
        
        private int fractionalPriceField;
        
        private string priceTextField;
        
        /// <remarks/>
        public uint PaymentType {
            get {
                return this.paymentTypeField;
            }
            set {
                this.paymentTypeField = value;
            }
        }
        
        /// <remarks/>
        public byte TaxType {
            get {
                return this.taxTypeField;
            }
            set {
                this.taxTypeField = value;
            }
        }
        
        /// <remarks/>
        public int WholePrice {
            get {
                return this.wholePriceField;
            }
            set {
                this.wholePriceField = value;
            }
        }
        
        /// <remarks/>
        public int FractionalPrice {
            get {
                return this.fractionalPriceField;
            }
            set {
                this.fractionalPriceField = value;
            }
        }
        
        /// <remarks/>
        public string PriceText {
            get {
                return this.priceTextField;
            }
            set {
                this.priceTextField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:billing-data")]
    public partial class SubscriptionInfo {
        
        private ulong offerIdField;
        
        private string offerNameField;
        
        private uint offerTypeField;
        
        private byte relationTypeField;
        
        private byte convertModeField;
        
        private string instanceIdField;
        
        private uint titleIdField;
        
        private uint titleCategoryField;
        
        private string titleNameField;
        
        private ushort gameRatingField;
        
        private byte durationField;
        
        private byte frequencyField;
        
        private byte tierProvidedField;
        
        private byte tierRequiredField;
        
        private string sellTextField;
        
        private ulong relatedOfferIdField;
        
        private ushort responseFlagsField;
        
        private int subscriptionStatusIdField;
        
        private PriceInfo priceField;
        
        /// <remarks/>
        public ulong OfferId {
            get {
                return this.offerIdField;
            }
            set {
                this.offerIdField = value;
            }
        }
        
        /// <remarks/>
        public string OfferName {
            get {
                return this.offerNameField;
            }
            set {
                this.offerNameField = value;
            }
        }
        
        /// <remarks/>
        public uint OfferType {
            get {
                return this.offerTypeField;
            }
            set {
                this.offerTypeField = value;
            }
        }
        
        /// <remarks/>
        public byte RelationType {
            get {
                return this.relationTypeField;
            }
            set {
                this.relationTypeField = value;
            }
        }
        
        /// <remarks/>
        public byte ConvertMode {
            get {
                return this.convertModeField;
            }
            set {
                this.convertModeField = value;
            }
        }
        
        /// <remarks/>
        public string InstanceId {
            get {
                return this.instanceIdField;
            }
            set {
                this.instanceIdField = value;
            }
        }
        
        /// <remarks/>
        public uint TitleId {
            get {
                return this.titleIdField;
            }
            set {
                this.titleIdField = value;
            }
        }
        
        /// <remarks/>
        public uint TitleCategory {
            get {
                return this.titleCategoryField;
            }
            set {
                this.titleCategoryField = value;
            }
        }
        
        /// <remarks/>
        public string TitleName {
            get {
                return this.titleNameField;
            }
            set {
                this.titleNameField = value;
            }
        }
        
        /// <remarks/>
        public ushort GameRating {
            get {
                return this.gameRatingField;
            }
            set {
                this.gameRatingField = value;
            }
        }
        
        /// <remarks/>
        public byte Duration {
            get {
                return this.durationField;
            }
            set {
                this.durationField = value;
            }
        }
        
        /// <remarks/>
        public byte Frequency {
            get {
                return this.frequencyField;
            }
            set {
                this.frequencyField = value;
            }
        }
        
        /// <remarks/>
        public byte TierProvided {
            get {
                return this.tierProvidedField;
            }
            set {
                this.tierProvidedField = value;
            }
        }
        
        /// <remarks/>
        public byte TierRequired {
            get {
                return this.tierRequiredField;
            }
            set {
                this.tierRequiredField = value;
            }
        }
        
        /// <remarks/>
        public string SellText {
            get {
                return this.sellTextField;
            }
            set {
                this.sellTextField = value;
            }
        }
        
        /// <remarks/>
        public ulong RelatedOfferId {
            get {
                return this.relatedOfferIdField;
            }
            set {
                this.relatedOfferIdField = value;
            }
        }
        
        /// <remarks/>
        public ushort ResponseFlags {
            get {
                return this.responseFlagsField;
            }
            set {
                this.responseFlagsField = value;
            }
        }
        
        /// <remarks/>
        public int SubscriptionStatusId {
            get {
                return this.subscriptionStatusIdField;
            }
            set {
                this.subscriptionStatusIdField = value;
            }
        }
        
        /// <remarks/>
        public PriceInfo Price {
            get {
                return this.priceField;
            }
            set {
                this.priceField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:billing-data")]
    public partial class SubscriptionEnumerateResults {
        
        private SubscriptionInfo[] subscriptionInfosField;
        
        private int offersTotalField;
        
        /// <remarks/>
        public SubscriptionInfo[] SubscriptionInfos {
            get {
                return this.subscriptionInfosField;
            }
            set {
                this.subscriptionInfosField = value;
            }
        }
        
        /// <remarks/>
        public int OffersTotal {
            get {
                return this.offersTotalField;
            }
            set {
                this.offersTotalField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:billing-data")]
    public partial class XboxOfferInfo {
        
        private ulong offerIdField;
        
        private int offerTypeIdField;
        
        /// <remarks/>
        public ulong offerId {
            get {
                return this.offerIdField;
            }
            set {
                this.offerIdField = value;
            }
        }
        
        /// <remarks/>
        public int offerTypeId {
            get {
                return this.offerTypeIdField;
            }
            set {
                this.offerTypeIdField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:billing-data")]
    public partial class EmsOfferInfo {
        
        private System.Guid offerIdField;
        
        private System.Guid mediaIdField;
        
        private int mediaTypeField;
        
        /// <remarks/>
        public System.Guid offerId {
            get {
                return this.offerIdField;
            }
            set {
                this.offerIdField = value;
            }
        }
        
        /// <remarks/>
        public System.Guid mediaId {
            get {
                return this.mediaIdField;
            }
            set {
                this.mediaIdField = value;
            }
        }
        
        /// <remarks/>
        public int mediaType {
            get {
                return this.mediaTypeField;
            }
            set {
                this.mediaTypeField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:billing-data")]
    public partial class VerifyTokenResults {
        
        private EmsOfferInfo emsOfferInfoField;
        
        private XboxOfferInfo xboxOfferInfoField;
        
        /// <remarks/>
        public EmsOfferInfo emsOfferInfo {
            get {
                return this.emsOfferInfoField;
            }
            set {
                this.emsOfferInfoField = value;
            }
        }
        
        /// <remarks/>
        public XboxOfferInfo xboxOfferInfo {
            get {
                return this.xboxOfferInfoField;
            }
            set {
                this.xboxOfferInfoField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(OfferPrice))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(XRLObject2))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(GamertagContentInfo))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(GamertagEnumerateResult))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(TypedMediaUrl))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(MediaInstanceUrl))]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:billing-data")]
    public partial class WireData {
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:billing-data")]
    public partial class OfferPrice : WireData {
        
        private uint paymentTypeField;
        
        private byte taxTypeField;
        
        private int wholePriceField;
        
        private int fractionalPriceField;
        
        private ushort priceTextLengthField;
        
        private string priceTextField;
        
        /// <remarks/>
        public uint paymentType {
            get {
                return this.paymentTypeField;
            }
            set {
                this.paymentTypeField = value;
            }
        }
        
        /// <remarks/>
        public byte taxType {
            get {
                return this.taxTypeField;
            }
            set {
                this.taxTypeField = value;
            }
        }
        
        /// <remarks/>
        public int wholePrice {
            get {
                return this.wholePriceField;
            }
            set {
                this.wholePriceField = value;
            }
        }
        
        /// <remarks/>
        public int fractionalPrice {
            get {
                return this.fractionalPriceField;
            }
            set {
                this.fractionalPriceField = value;
            }
        }
        
        /// <remarks/>
        public ushort priceTextLength {
            get {
                return this.priceTextLengthField;
            }
            set {
                this.priceTextLengthField = value;
            }
        }
        
        /// <remarks/>
        public string priceText {
            get {
                return this.priceTextField;
            }
            set {
                this.priceTextField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(GamertagContentInfo))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(GamertagEnumerateResult))]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:billing-data")]
    public partial class XRLObject2 : WireData {
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:billing-data")]
    public partial class GamertagContentInfo : XRLObject2 {
        
        private System.Guid offerIDField;
        
        private ushort offerNameLengthField;
        
        private string offerNameField;
        
        private uint offerTypeField;
        
        private int sellTextLengthField;
        
        private string sellTextField;
        
        private System.DateTime maxStartDateField;
        
        private byte pricesLengthField;
        
        private OfferPrice[] pricesField;
        
        /// <remarks/>
        public System.Guid offerID {
            get {
                return this.offerIDField;
            }
            set {
                this.offerIDField = value;
            }
        }
        
        /// <remarks/>
        public ushort offerNameLength {
            get {
                return this.offerNameLengthField;
            }
            set {
                this.offerNameLengthField = value;
            }
        }
        
        /// <remarks/>
        public string offerName {
            get {
                return this.offerNameField;
            }
            set {
                this.offerNameField = value;
            }
        }
        
        /// <remarks/>
        public uint offerType {
            get {
                return this.offerTypeField;
            }
            set {
                this.offerTypeField = value;
            }
        }
        
        /// <remarks/>
        public int sellTextLength {
            get {
                return this.sellTextLengthField;
            }
            set {
                this.sellTextLengthField = value;
            }
        }
        
        /// <remarks/>
        public string sellText {
            get {
                return this.sellTextField;
            }
            set {
                this.sellTextField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime maxStartDate {
            get {
                return this.maxStartDateField;
            }
            set {
                this.maxStartDateField = value;
            }
        }
        
        /// <remarks/>
        public byte pricesLength {
            get {
                return this.pricesLengthField;
            }
            set {
                this.pricesLengthField = value;
            }
        }
        
        /// <remarks/>
        public OfferPrice[] prices {
            get {
                return this.pricesField;
            }
            set {
                this.pricesField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:billing-data")]
    public partial class GamertagEnumerateResult : XRLObject2 {
        
        private ushort offersReturnedField;
        
        private GamertagContentInfo[] infosField;
        
        private uint offersTotalField;
        
        /// <remarks/>
        public ushort offersReturned {
            get {
                return this.offersReturnedField;
            }
            set {
                this.offersReturnedField = value;
            }
        }
        
        /// <remarks/>
        public GamertagContentInfo[] infos {
            get {
                return this.infosField;
            }
            set {
                this.infosField = value;
            }
        }
        
        /// <remarks/>
        public uint offersTotal {
            get {
                return this.offersTotalField;
            }
            set {
                this.offersTotalField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:billing-data")]
    public partial class TypedMediaUrl : WireData {
        
        private int typeField;
        
        private uint lengthField;
        
        private string urlField;
        
        /// <remarks/>
        public int type {
            get {
                return this.typeField;
            }
            set {
                this.typeField = value;
            }
        }
        
        /// <remarks/>
        public uint length {
            get {
                return this.lengthField;
            }
            set {
                this.lengthField = value;
            }
        }
        
        /// <remarks/>
        public string url {
            get {
                return this.urlField;
            }
            set {
                this.urlField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:billing-data")]
    public partial class MediaInstanceUrl : WireData {
        
        private System.Guid mediaIdField;
        
        private System.Guid mediaInstanceIdField;
        
        private ulong packageSizeField;
        
        private ulong installSizeField;
        
        private byte[] symKeyField;
        
        private byte[] pubKeyField;
        
        private uint packageTypeField;
        
        private uint fileCountField;
        
        private TypedMediaUrl[] urlsField;
        
        /// <remarks/>
        public System.Guid mediaId {
            get {
                return this.mediaIdField;
            }
            set {
                this.mediaIdField = value;
            }
        }
        
        /// <remarks/>
        public System.Guid mediaInstanceId {
            get {
                return this.mediaInstanceIdField;
            }
            set {
                this.mediaInstanceIdField = value;
            }
        }
        
        /// <remarks/>
        public ulong packageSize {
            get {
                return this.packageSizeField;
            }
            set {
                this.packageSizeField = value;
            }
        }
        
        /// <remarks/>
        public ulong installSize {
            get {
                return this.installSizeField;
            }
            set {
                this.installSizeField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public byte[] symKey {
            get {
                return this.symKeyField;
            }
            set {
                this.symKeyField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public byte[] pubKey {
            get {
                return this.pubKeyField;
            }
            set {
                this.pubKeyField = value;
            }
        }
        
        /// <remarks/>
        public uint packageType {
            get {
                return this.packageTypeField;
            }
            set {
                this.packageTypeField = value;
            }
        }
        
        /// <remarks/>
        public uint fileCount {
            get {
                return this.fileCountField;
            }
            set {
                this.fileCountField = value;
            }
        }
        
        /// <remarks/>
        public TypedMediaUrl[] urls {
            get {
                return this.urlsField;
            }
            set {
                this.urlsField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void TestConnectionCompletedEventHandler(object sender, TestConnectionCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class TestConnectionCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal TestConnectionCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void PurchaseMediaOffersCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetPurchaseStatusCompletedEventHandler(object sender, GetPurchaseStatusCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetPurchaseStatusCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetPurchaseStatusCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public PurchaseStatus[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((PurchaseStatus[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void FindMediaInstanceUrlsCompletedEventHandler(object sender, FindMediaInstanceUrlsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class FindMediaInstanceUrlsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal FindMediaInstanceUrlsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public MediaInstanceUrl[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((MediaInstanceUrl[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void VerifyTokenCompletedEventHandler(object sender, VerifyTokenCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class VerifyTokenCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal VerifyTokenCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public VerifyTokenResults Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((VerifyTokenResults)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CancelSubscriptionCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GamertagEnumerateCompletedEventHandler(object sender, GamertagEnumerateCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GamertagEnumerateCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GamertagEnumerateCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public GamertagEnumerateResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((GamertagEnumerateResult)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SubscriptionEnumerateCompletedEventHandler(object sender, SubscriptionEnumerateCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SubscriptionEnumerateCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SubscriptionEnumerateCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public SubscriptionEnumerateResults Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((SubscriptionEnumerateResults)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void PurchaseBillingOfferCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void PurchaseGamertagCompletedEventHandler(object sender, PurchaseGamertagCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class PurchaseGamertagCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal PurchaseGamertagCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public uint Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((uint)(this.results[0]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\WebReferences\WidgetStorage\Reference.cs ===
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.42
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace ServerTestFramework.Web.Storage {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="StorageSoap", Namespace="http://websvc.xboxlive.com/Storage/")]
    public partial class Storage : ServerTestFramework.Web.STFSoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback GetTitleQuotaOperationCompleted;
        
        private System.Threading.SendOrPostCallback ReadUserFileOperationCompleted;
        
        private System.Threading.SendOrPostCallback ReadTitleFileOperationCompleted;
        
        private System.Threading.SendOrPostCallback WriteUserFileOperationCompleted;
        
        private System.Threading.SendOrPostCallback WriteTitleFileOperationCompleted;
        
        private System.Threading.SendOrPostCallback DeleteUserFileOperationCompleted;
        
        private System.Threading.SendOrPostCallback DeleteTitleFileOperationCompleted;
        
        private System.Threading.SendOrPostCallback RevokeTitleFileOperationCompleted;
        
        private System.Threading.SendOrPostCallback RevokeUserFileOperationCompleted;
        
        private System.Threading.SendOrPostCallback EnumerateTitleFilesOperationCompleted;
        
        /// <remarks/>
        public Storage() {
            this.ComputeUrl("wcstorage", "/storage/storage.asmx");
        }
        
        /// <remarks/>
        public event GetTitleQuotaCompletedEventHandler GetTitleQuotaCompleted;
        
        /// <remarks/>
        public event ReadUserFileCompletedEventHandler ReadUserFileCompleted;
        
        /// <remarks/>
        public event ReadTitleFileCompletedEventHandler ReadTitleFileCompleted;
        
        /// <remarks/>
        public event WriteUserFileCompletedEventHandler WriteUserFileCompleted;
        
        /// <remarks/>
        public event WriteTitleFileCompletedEventHandler WriteTitleFileCompleted;
        
        /// <remarks/>
        public event DeleteUserFileCompletedEventHandler DeleteUserFileCompleted;
        
        /// <remarks/>
        public event DeleteTitleFileCompletedEventHandler DeleteTitleFileCompleted;
        
        /// <remarks/>
        public event RevokeTitleFileCompletedEventHandler RevokeTitleFileCompleted;
        
        /// <remarks/>
        public event RevokeUserFileCompletedEventHandler RevokeUserFileCompleted;
        
        /// <remarks/>
        public event EnumerateTitleFilesCompletedEventHandler EnumerateTitleFilesCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Storage/GetTitleQuota", RequestNamespace="http://websvc.xboxlive.com/Storage/", ResponseNamespace="http://websvc.xboxlive.com/Storage/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public QuotaInfo GetTitleQuota(uint titleID) {
            object[] results = this.Invoke("GetTitleQuota", new object[] {
                        titleID});
            return ((QuotaInfo)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetTitleQuota(uint titleID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetTitleQuota", new object[] {
                        titleID}, callback, asyncState);
        }
        
        /// <remarks/>
        public QuotaInfo EndGetTitleQuota(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((QuotaInfo)(results[0]));
        }
        
        /// <remarks/>
        public void GetTitleQuotaAsync(uint titleID) {
            this.GetTitleQuotaAsync(titleID, null);
        }
        
        /// <remarks/>
        public void GetTitleQuotaAsync(uint titleID, object userState) {
            if ((this.GetTitleQuotaOperationCompleted == null)) {
                this.GetTitleQuotaOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetTitleQuotaOperationCompleted);
            }
            this.InvokeAsync("GetTitleQuota", new object[] {
                        titleID}, this.GetTitleQuotaOperationCompleted, userState);
        }
        
        private void OnGetTitleQuotaOperationCompleted(object arg) {
            if ((this.GetTitleQuotaCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetTitleQuotaCompleted(this, new GetTitleQuotaCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Storage/ReadUserFile", RequestNamespace="http://websvc.xboxlive.com/Storage/", ResponseNamespace="http://websvc.xboxlive.com/Storage/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public ReadFileInfo ReadUserFile(uint titleID, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webID, string gamerTag, string fileName, System.DateTime ifModifiedSinceDate) {
            object[] results = this.Invoke("ReadUserFile", new object[] {
                        titleID,
                        webID,
                        gamerTag,
                        fileName,
                        ifModifiedSinceDate});
            return ((ReadFileInfo)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginReadUserFile(uint titleID, byte[] webID, string gamerTag, string fileName, System.DateTime ifModifiedSinceDate, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ReadUserFile", new object[] {
                        titleID,
                        webID,
                        gamerTag,
                        fileName,
                        ifModifiedSinceDate}, callback, asyncState);
        }
        
        /// <remarks/>
        public ReadFileInfo EndReadUserFile(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((ReadFileInfo)(results[0]));
        }
        
        /// <remarks/>
        public void ReadUserFileAsync(uint titleID, byte[] webID, string gamerTag, string fileName, System.DateTime ifModifiedSinceDate) {
            this.ReadUserFileAsync(titleID, webID, gamerTag, fileName, ifModifiedSinceDate, null);
        }
        
        /// <remarks/>
        public void ReadUserFileAsync(uint titleID, byte[] webID, string gamerTag, string fileName, System.DateTime ifModifiedSinceDate, object userState) {
            if ((this.ReadUserFileOperationCompleted == null)) {
                this.ReadUserFileOperationCompleted = new System.Threading.SendOrPostCallback(this.OnReadUserFileOperationCompleted);
            }
            this.InvokeAsync("ReadUserFile", new object[] {
                        titleID,
                        webID,
                        gamerTag,
                        fileName,
                        ifModifiedSinceDate}, this.ReadUserFileOperationCompleted, userState);
        }
        
        private void OnReadUserFileOperationCompleted(object arg) {
            if ((this.ReadUserFileCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ReadUserFileCompleted(this, new ReadUserFileCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Storage/ReadTitleFile", RequestNamespace="http://websvc.xboxlive.com/Storage/", ResponseNamespace="http://websvc.xboxlive.com/Storage/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public ReadFileInfo ReadTitleFile(uint titleID, string fileName, System.DateTime ifModifiedSinceDate) {
            object[] results = this.Invoke("ReadTitleFile", new object[] {
                        titleID,
                        fileName,
                        ifModifiedSinceDate});
            return ((ReadFileInfo)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginReadTitleFile(uint titleID, string fileName, System.DateTime ifModifiedSinceDate, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ReadTitleFile", new object[] {
                        titleID,
                        fileName,
                        ifModifiedSinceDate}, callback, asyncState);
        }
        
        /// <remarks/>
        public ReadFileInfo EndReadTitleFile(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((ReadFileInfo)(results[0]));
        }
        
        /// <remarks/>
        public void ReadTitleFileAsync(uint titleID, string fileName, System.DateTime ifModifiedSinceDate) {
            this.ReadTitleFileAsync(titleID, fileName, ifModifiedSinceDate, null);
        }
        
        /// <remarks/>
        public void ReadTitleFileAsync(uint titleID, string fileName, System.DateTime ifModifiedSinceDate, object userState) {
            if ((this.ReadTitleFileOperationCompleted == null)) {
                this.ReadTitleFileOperationCompleted = new System.Threading.SendOrPostCallback(this.OnReadTitleFileOperationCompleted);
            }
            this.InvokeAsync("ReadTitleFile", new object[] {
                        titleID,
                        fileName,
                        ifModifiedSinceDate}, this.ReadTitleFileOperationCompleted, userState);
        }
        
        private void OnReadTitleFileOperationCompleted(object arg) {
            if ((this.ReadTitleFileCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ReadTitleFileCompleted(this, new ReadTitleFileCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Storage/WriteUserFile", RequestNamespace="http://websvc.xboxlive.com/Storage/", ResponseNamespace="http://websvc.xboxlive.com/Storage/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void WriteUserFile(uint titleID, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webID, string gamerTag, string fileName, FileContentTypeEnum contentType, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] data, System.DateTime expirationDate) {
            this.Invoke("WriteUserFile", new object[] {
                        titleID,
                        webID,
                        gamerTag,
                        fileName,
                        contentType,
                        data,
                        expirationDate});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginWriteUserFile(uint titleID, byte[] webID, string gamerTag, string fileName, FileContentTypeEnum contentType, byte[] data, System.DateTime expirationDate, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("WriteUserFile", new object[] {
                        titleID,
                        webID,
                        gamerTag,
                        fileName,
                        contentType,
                        data,
                        expirationDate}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndWriteUserFile(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void WriteUserFileAsync(uint titleID, byte[] webID, string gamerTag, string fileName, FileContentTypeEnum contentType, byte[] data, System.DateTime expirationDate) {
            this.WriteUserFileAsync(titleID, webID, gamerTag, fileName, contentType, data, expirationDate, null);
        }
        
        /// <remarks/>
        public void WriteUserFileAsync(uint titleID, byte[] webID, string gamerTag, string fileName, FileContentTypeEnum contentType, byte[] data, System.DateTime expirationDate, object userState) {
            if ((this.WriteUserFileOperationCompleted == null)) {
                this.WriteUserFileOperationCompleted = new System.Threading.SendOrPostCallback(this.OnWriteUserFileOperationCompleted);
            }
            this.InvokeAsync("WriteUserFile", new object[] {
                        titleID,
                        webID,
                        gamerTag,
                        fileName,
                        contentType,
                        data,
                        expirationDate}, this.WriteUserFileOperationCompleted, userState);
        }
        
        private void OnWriteUserFileOperationCompleted(object arg) {
            if ((this.WriteUserFileCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.WriteUserFileCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Storage/WriteTitleFile", RequestNamespace="http://websvc.xboxlive.com/Storage/", ResponseNamespace="http://websvc.xboxlive.com/Storage/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void WriteTitleFile(uint titleID, string fileName, FileContentTypeEnum contentType, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] data, System.DateTime expirationDate) {
            this.Invoke("WriteTitleFile", new object[] {
                        titleID,
                        fileName,
                        contentType,
                        data,
                        expirationDate});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginWriteTitleFile(uint titleID, string fileName, FileContentTypeEnum contentType, byte[] data, System.DateTime expirationDate, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("WriteTitleFile", new object[] {
                        titleID,
                        fileName,
                        contentType,
                        data,
                        expirationDate}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndWriteTitleFile(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void WriteTitleFileAsync(uint titleID, string fileName, FileContentTypeEnum contentType, byte[] data, System.DateTime expirationDate) {
            this.WriteTitleFileAsync(titleID, fileName, contentType, data, expirationDate, null);
        }
        
        /// <remarks/>
        public void WriteTitleFileAsync(uint titleID, string fileName, FileContentTypeEnum contentType, byte[] data, System.DateTime expirationDate, object userState) {
            if ((this.WriteTitleFileOperationCompleted == null)) {
                this.WriteTitleFileOperationCompleted = new System.Threading.SendOrPostCallback(this.OnWriteTitleFileOperationCompleted);
            }
            this.InvokeAsync("WriteTitleFile", new object[] {
                        titleID,
                        fileName,
                        contentType,
                        data,
                        expirationDate}, this.WriteTitleFileOperationCompleted, userState);
        }
        
        private void OnWriteTitleFileOperationCompleted(object arg) {
            if ((this.WriteTitleFileCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.WriteTitleFileCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Storage/DeleteUserFile", RequestNamespace="http://websvc.xboxlive.com/Storage/", ResponseNamespace="http://websvc.xboxlive.com/Storage/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void DeleteUserFile(uint titleID, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webID, string gamerTag, string fileName) {
            this.Invoke("DeleteUserFile", new object[] {
                        titleID,
                        webID,
                        gamerTag,
                        fileName});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginDeleteUserFile(uint titleID, byte[] webID, string gamerTag, string fileName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("DeleteUserFile", new object[] {
                        titleID,
                        webID,
                        gamerTag,
                        fileName}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndDeleteUserFile(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void DeleteUserFileAsync(uint titleID, byte[] webID, string gamerTag, string fileName) {
            this.DeleteUserFileAsync(titleID, webID, gamerTag, fileName, null);
        }
        
        /// <remarks/>
        public void DeleteUserFileAsync(uint titleID, byte[] webID, string gamerTag, string fileName, object userState) {
            if ((this.DeleteUserFileOperationCompleted == null)) {
                this.DeleteUserFileOperationCompleted = new System.Threading.SendOrPostCallback(this.OnDeleteUserFileOperationCompleted);
            }
            this.InvokeAsync("DeleteUserFile", new object[] {
                        titleID,
                        webID,
                        gamerTag,
                        fileName}, this.DeleteUserFileOperationCompleted, userState);
        }
        
        private void OnDeleteUserFileOperationCompleted(object arg) {
            if ((this.DeleteUserFileCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.DeleteUserFileCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Storage/DeleteTitleFile", RequestNamespace="http://websvc.xboxlive.com/Storage/", ResponseNamespace="http://websvc.xboxlive.com/Storage/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void DeleteTitleFile(uint titleID, string fileName) {
            this.Invoke("DeleteTitleFile", new object[] {
                        titleID,
                        fileName});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginDeleteTitleFile(uint titleID, string fileName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("DeleteTitleFile", new object[] {
                        titleID,
                        fileName}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndDeleteTitleFile(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void DeleteTitleFileAsync(uint titleID, string fileName) {
            this.DeleteTitleFileAsync(titleID, fileName, null);
        }
        
        /// <remarks/>
        public void DeleteTitleFileAsync(uint titleID, string fileName, object userState) {
            if ((this.DeleteTitleFileOperationCompleted == null)) {
                this.DeleteTitleFileOperationCompleted = new System.Threading.SendOrPostCallback(this.OnDeleteTitleFileOperationCompleted);
            }
            this.InvokeAsync("DeleteTitleFile", new object[] {
                        titleID,
                        fileName}, this.DeleteTitleFileOperationCompleted, userState);
        }
        
        private void OnDeleteTitleFileOperationCompleted(object arg) {
            if ((this.DeleteTitleFileCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.DeleteTitleFileCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Storage/RevokeTitleFile", RequestNamespace="http://websvc.xboxlive.com/Storage/", ResponseNamespace="http://websvc.xboxlive.com/Storage/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void RevokeTitleFile(uint titleID, string fileName) {
            this.Invoke("RevokeTitleFile", new object[] {
                        titleID,
                        fileName});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRevokeTitleFile(uint titleID, string fileName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RevokeTitleFile", new object[] {
                        titleID,
                        fileName}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndRevokeTitleFile(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void RevokeTitleFileAsync(uint titleID, string fileName) {
            this.RevokeTitleFileAsync(titleID, fileName, null);
        }
        
        /// <remarks/>
        public void RevokeTitleFileAsync(uint titleID, string fileName, object userState) {
            if ((this.RevokeTitleFileOperationCompleted == null)) {
                this.RevokeTitleFileOperationCompleted = new System.Threading.SendOrPostCallback(this.OnRevokeTitleFileOperationCompleted);
            }
            this.InvokeAsync("RevokeTitleFile", new object[] {
                        titleID,
                        fileName}, this.RevokeTitleFileOperationCompleted, userState);
        }
        
        private void OnRevokeTitleFileOperationCompleted(object arg) {
            if ((this.RevokeTitleFileCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.RevokeTitleFileCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Storage/RevokeUserFile", RequestNamespace="http://websvc.xboxlive.com/Storage/", ResponseNamespace="http://websvc.xboxlive.com/Storage/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void RevokeUserFile(uint titleID, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] webID, string gamerTag, string fileName) {
            this.Invoke("RevokeUserFile", new object[] {
                        titleID,
                        webID,
                        gamerTag,
                        fileName});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRevokeUserFile(uint titleID, byte[] webID, string gamerTag, string fileName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RevokeUserFile", new object[] {
                        titleID,
                        webID,
                        gamerTag,
                        fileName}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndRevokeUserFile(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void RevokeUserFileAsync(uint titleID, byte[] webID, string gamerTag, string fileName) {
            this.RevokeUserFileAsync(titleID, webID, gamerTag, fileName, null);
        }
        
        /// <remarks/>
        public void RevokeUserFileAsync(uint titleID, byte[] webID, string gamerTag, string fileName, object userState) {
            if ((this.RevokeUserFileOperationCompleted == null)) {
                this.RevokeUserFileOperationCompleted = new System.Threading.SendOrPostCallback(this.OnRevokeUserFileOperationCompleted);
            }
            this.InvokeAsync("RevokeUserFile", new object[] {
                        titleID,
                        webID,
                        gamerTag,
                        fileName}, this.RevokeUserFileOperationCompleted, userState);
        }
        
        private void OnRevokeUserFileOperationCompleted(object arg) {
            if ((this.RevokeUserFileCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.RevokeUserFileCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Storage/EnumerateTitleFiles", RequestNamespace="http://websvc.xboxlive.com/Storage/", ResponseNamespace="http://websvc.xboxlive.com/Storage/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public FileEnumerationInfo[] EnumerateTitleFiles(uint titleID, string fileQuery, System.DateTime ifModifiedSince) {
            object[] results = this.Invoke("EnumerateTitleFiles", new object[] {
                        titleID,
                        fileQuery,
                        ifModifiedSince});
            return ((FileEnumerationInfo[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginEnumerateTitleFiles(uint titleID, string fileQuery, System.DateTime ifModifiedSince, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("EnumerateTitleFiles", new object[] {
                        titleID,
                        fileQuery,
                        ifModifiedSince}, callback, asyncState);
        }
        
        /// <remarks/>
        public FileEnumerationInfo[] EndEnumerateTitleFiles(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((FileEnumerationInfo[])(results[0]));
        }
        
        /// <remarks/>
        public void EnumerateTitleFilesAsync(uint titleID, string fileQuery, System.DateTime ifModifiedSince) {
            this.EnumerateTitleFilesAsync(titleID, fileQuery, ifModifiedSince, null);
        }
        
        /// <remarks/>
        public void EnumerateTitleFilesAsync(uint titleID, string fileQuery, System.DateTime ifModifiedSince, object userState) {
            if ((this.EnumerateTitleFilesOperationCompleted == null)) {
                this.EnumerateTitleFilesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnEnumerateTitleFilesOperationCompleted);
            }
            this.InvokeAsync("EnumerateTitleFiles", new object[] {
                        titleID,
                        fileQuery,
                        ifModifiedSince}, this.EnumerateTitleFilesOperationCompleted, userState);
        }
        
        private void OnEnumerateTitleFilesOperationCompleted(object arg) {
            if ((this.EnumerateTitleFilesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.EnumerateTitleFilesCompleted(this, new EnumerateTitleFilesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Storage/")]
    public partial class QuotaInfo {
        
        private ulong maxFileSizeField;
        
        private ulong totalBytesMaxField;
        
        private ulong totalBytesUsedField;
        
        private uint totalFilesMaxField;
        
        private uint totalFilesUsedField;
        
        /// <remarks/>
        public ulong MaxFileSize {
            get {
                return this.maxFileSizeField;
            }
            set {
                this.maxFileSizeField = value;
            }
        }
        
        /// <remarks/>
        public ulong TotalBytesMax {
            get {
                return this.totalBytesMaxField;
            }
            set {
                this.totalBytesMaxField = value;
            }
        }
        
        /// <remarks/>
        public ulong TotalBytesUsed {
            get {
                return this.totalBytesUsedField;
            }
            set {
                this.totalBytesUsedField = value;
            }
        }
        
        /// <remarks/>
        public uint TotalFilesMax {
            get {
                return this.totalFilesMaxField;
            }
            set {
                this.totalFilesMaxField = value;
            }
        }
        
        /// <remarks/>
        public uint TotalFilesUsed {
            get {
                return this.totalFilesUsedField;
            }
            set {
                this.totalFilesUsedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Storage/")]
    public partial class FileEnumerationInfo {
        
        private uint titleIDField;
        
        private uint titleVersionField;
        
        private string gamerTagField;
        
        private byte userCountryIDField;
        
        private uint fileSizeField;
        
        private System.DateTime creationDateField;
        
        private System.DateTime modifiedDateField;
        
        private string fileNameField;
        
        private FileContentTypeEnum fileContentTypeField;
        
        /// <remarks/>
        public uint TitleID {
            get {
                return this.titleIDField;
            }
            set {
                this.titleIDField = value;
            }
        }
        
        /// <remarks/>
        public uint TitleVersion {
            get {
                return this.titleVersionField;
            }
            set {
                this.titleVersionField = value;
            }
        }
        
        /// <remarks/>
        public string GamerTag {
            get {
                return this.gamerTagField;
            }
            set {
                this.gamerTagField = value;
            }
        }
        
        /// <remarks/>
        public byte UserCountryID {
            get {
                return this.userCountryIDField;
            }
            set {
                this.userCountryIDField = value;
            }
        }
        
        /// <remarks/>
        public uint FileSize {
            get {
                return this.fileSizeField;
            }
            set {
                this.fileSizeField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime CreationDate {
            get {
                return this.creationDateField;
            }
            set {
                this.creationDateField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime ModifiedDate {
            get {
                return this.modifiedDateField;
            }
            set {
                this.modifiedDateField = value;
            }
        }
        
        /// <remarks/>
        public string FileName {
            get {
                return this.fileNameField;
            }
            set {
                this.fileNameField = value;
            }
        }
        
        /// <remarks/>
        public FileContentTypeEnum FileContentType {
            get {
                return this.fileContentTypeField;
            }
            set {
                this.fileContentTypeField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Storage/")]
    public enum FileContentTypeEnum {
        
        /// <remarks/>
        Package,
        
        /// <remarks/>
        Blob,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Storage/")]
    public partial class ReadFileInfo {
        
        private bool fileNotModifiedField;
        
        private uint titleIDField;
        
        private uint titleVersionField;
        
        private string gamerTagField;
        
        private byte userCountryIDField;
        
        private uint fileSizeField;
        
        private System.DateTime creationDateField;
        
        private byte[] fileDataField;
        
        private FileContentTypeEnum fileContentTypeField;
        
        /// <remarks/>
        public bool FileNotModified {
            get {
                return this.fileNotModifiedField;
            }
            set {
                this.fileNotModifiedField = value;
            }
        }
        
        /// <remarks/>
        public uint TitleID {
            get {
                return this.titleIDField;
            }
            set {
                this.titleIDField = value;
            }
        }
        
        /// <remarks/>
        public uint TitleVersion {
            get {
                return this.titleVersionField;
            }
            set {
                this.titleVersionField = value;
            }
        }
        
        /// <remarks/>
        public string GamerTag {
            get {
                return this.gamerTagField;
            }
            set {
                this.gamerTagField = value;
            }
        }
        
        /// <remarks/>
        public byte UserCountryID {
            get {
                return this.userCountryIDField;
            }
            set {
                this.userCountryIDField = value;
            }
        }
        
        /// <remarks/>
        public uint FileSize {
            get {
                return this.fileSizeField;
            }
            set {
                this.fileSizeField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime CreationDate {
            get {
                return this.creationDateField;
            }
            set {
                this.creationDateField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public byte[] FileData {
            get {
                return this.fileDataField;
            }
            set {
                this.fileDataField = value;
            }
        }
        
        /// <remarks/>
        public FileContentTypeEnum FileContentType {
            get {
                return this.fileContentTypeField;
            }
            set {
                this.fileContentTypeField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetTitleQuotaCompletedEventHandler(object sender, GetTitleQuotaCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetTitleQuotaCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetTitleQuotaCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public QuotaInfo Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((QuotaInfo)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ReadUserFileCompletedEventHandler(object sender, ReadUserFileCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ReadUserFileCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ReadUserFileCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public ReadFileInfo Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ReadFileInfo)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ReadTitleFileCompletedEventHandler(object sender, ReadTitleFileCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ReadTitleFileCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ReadTitleFileCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public ReadFileInfo Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ReadFileInfo)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void WriteUserFileCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void WriteTitleFileCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void DeleteUserFileCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void DeleteTitleFileCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void RevokeTitleFileCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void RevokeUserFileCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void EnumerateTitleFilesCompletedEventHandler(object sender, EnumerateTitleFilesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class EnumerateTitleFilesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal EnumerateTitleFilesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public FileEnumerationInfo[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((FileEnumerationInfo[])(this.results[0]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\WebWidget\RequestInfo.cs ===
using System;

namespace ServerTestFramework.WebWidget
{
	public class RequestInfo
	{
		public string SubjectName;
		public string ClientIPPort;
		public string RequestId;

		public RequestInfo()
		{
			SubjectName = "DebugPartner";
			ClientIPPort = "1.1.1.1:1000";
			RequestId = "CAFEBABEDEADBEEF";
		}

		public RequestInfo(string subjectName)
		{
			SubjectName = subjectName;
			ClientIPPort = "1.1.1.1:1000";
			RequestId = "CAFEBABEDEADBEEF";
		}

		public RequestInfo(string subjectName, string clientIPPort, string requestId)
		{
			SubjectName = subjectName;
			ClientIPPort = clientIPPort;
			RequestId = requestId;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\WebReferences\Xbos_History\SvcProviderWrapper.cs ===
ï»¿using System;
using System.Net;
using System.Net.Security;
using System.Text;
using System.Security.Cryptography.X509Certificates;
using System.Text.RegularExpressions;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.STS;
//using ServerTestFramework.LiveService.FakeAAInfoNameSpace;
using xonline.common.config;
using xonline.common.protocol;

using ServerTestFramework.LiveService.UserAccount.WebService;
using xonline.common.service;
using ServerTestFramework.LiveService.FakeAAInfoNameSpace;
 
namespace ServerTestFramework.LiveService.Billing.History.WebService 
{
    public class SvcProviderWrapper : History {
        public static int   TimeOut=25000;
        public static int   ConcurrentCalls=0;
        public string       ErrorString="";
        public ulong        ReturnCode=99;

        static protected Regex RegexXCBKReturn1=new Regex(@"<ResponseInfo><ErrorCode/><ResponseClass>(?<responseClass>(.)+)</ResponseClass><ResponseMessage/></ResponseInfo>");
        static protected Regex RegexXCBKReturn2=new Regex(@"<ResponseInfo><ErrorCode>(?<errorCode>(.)+)</ErrorCode><ResponseClass>(?<responseClass>(.)+)</ResponseClass><ResponseMessage/></ResponseInfo>");

        public string AlternateMusicNetUrl = null;
        public string AlternateBillingUrl = null;
        public string InjectedScsError = null;
        public string AlternateDmpUrl = null;

        public string ServerAddr;
        public ulong PassportPuid;
        public ulong Xuid;
        public ulong MachinePuid;
        public uint TitleId;

        static public void Initialize()
        {
            //ServicePointManager.CertificatePolicy=new MyCertPolicy();
            ServicePointManager.ServerCertificateValidationCallback += delegate(
                object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors)
            {
                if (sslPolicyErrors != SslPolicyErrors.None)
                {
                    Console.WriteLine("Security Support Provider Interface (SSPI) Status Code = " + sslPolicyErrors.ToString());
                }
                return true;
            };
        }
        
        new public string TestConnection(string inputMessage) {
            string results;
            results = base.TestConnection(inputMessage);

            return results;
        }
        
        new public System.Xml.XmlNode Execute(string methodName, string[] Names, string[] Values, int PageSize, int PageNum, ulong UserPuid, ulong MachinePuid) {
            System.Xml.XmlNode results;       
            results = base.Execute(
                        methodName,
                        Names,
                        Values,
                        PageSize,
                        PageNum,
                        UserPuid,
                        MachinePuid);
            return results;
        }
        
        new public System.Xml.XmlNode Query(string methodName, string[] Names, string[] Values, ulong UserPuid, ulong MachinePuid) {
            System.Xml.XmlNode results;       
            results = base.Query(
                        methodName,
                        Names,
                        Values,
                        UserPuid,
                        MachinePuid);
            return results;
        }
#if false
        public SvcProviderWrapper() : this(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering))
        {
            ;
        }

        public SvcProviderWrapper(ulong passportPuid, ulong xuid, ulong machinePuid, uint titleId) : this(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering))
        {
            PassportPuid = passportPuid;
            Xuid = xuid;
            MachinePuid = machinePuid;
            TitleId = titleId;
            TimeOut = 60000;
        }

        public SvcProviderWrapper(ulong _passportPuid) : this(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering))
        {
            PassportPuid = _passportPuid;
        }

        private SvcProviderWrapper(System.Net.IPEndPoint ServerEP)
        {
            string ServerAddrPort;
            ServicePointManager.DefaultConnectionLimit=220;
            base.Timeout=TimeOut;

            ServerAddr = ServerEP.Address.ToString();
            ServerAddrPort = ServerAddr;
            if (ServerEP.Port != 80)
            {
                ServerAddrPort += ":" + ServerEP.Port;
            }

            base.Url="http://"+ServerAddrPort+"/xbos/history.asmx";
        }

        private SvcProviderWrapper(LiveServer Server)
        {
            ServicePointManager.DefaultConnectionLimit=220;
            base.Timeout=TimeOut;

            ServerAddr = Server.EPDefault.Address.ToString();
            base.Url="http://"+Server.IPToString()+"/xbos/history.asmx";
        }

        override protected WebRequest GetWebRequest(Uri url)
        {
            WebRequest wr = base.GetWebRequest(new Uri(Url));

            if (AlternateMusicNetUrl != null)
                wr.Headers.Add("AlternateMusicNetUrl", AlternateMusicNetUrl);
            if (AlternateBillingUrl != null)
                wr.Headers.Add("AlternateBillingUrl", AlternateBillingUrl);
            if (InjectedScsError != null)
                wr.Headers.Add("InjectedScsError", InjectedScsError);
            if (AlternateDmpUrl != null)
                wr.Headers.Add("AlternateDmpUrl", AlternateDmpUrl);

            FakeAAInfo fakeAAInfo = new FakeAAInfo();
            fakeAAInfo.PassportPuid = PassportPuid;

            STSUtil.GetSecurityTicketParameters gstParam = new STSUtil.GetSecurityTicketParameters();
            gstParam.Puid0 = PassportPuid.ToString();
            gstParam.Xuid0 = Xuid.ToString();
            gstParam.MachineID = MachinePuid.ToString();
            gstParam.TitleID = TitleId.ToString();
            gstParam.Certificate = new X509Certificate2("sts.test.xboxlive.com.pfx","XblRocks!");
            fakeAAInfo.SamlToken = STSUtil.GetSecurityTicket(gstParam);
            
            xonline.common.service.AAInfo.MarshallToHeaders(wr.Headers, fakeAAInfo);

            return wr;
        }       
#endif
        public SvcProviderWrapper(ulong _passportPuid) : this(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering))
        {
            PassportPuid = _passportPuid;
        }

        private SvcProviderWrapper(System.Net.IPEndPoint ServerEP)
        {
            string ServerAddrPort;
            ServicePointManager.DefaultConnectionLimit=220;
            base.Timeout=TimeOut;

            ServerAddr = ServerEP.Address.ToString();
            ServerAddrPort = ServerAddr;
            if (ServerEP.Port != 80)
            {
                ServerAddrPort += ":" + ServerEP.Port;
            }

            base.Url="http://"+ServerAddrPort+"/xbos/history.asmx";
        }

        private SvcProviderWrapper(LiveServer Server)
        {
            ServicePointManager.DefaultConnectionLimit=220;
            base.Timeout=TimeOut;

            ServerAddr = Server.EPDefault.Address.ToString();
            base.Url="http://"+Server.IPToString()+"/xbos/history.asmx";
        }

        override protected WebRequest GetWebRequest(Uri url)
        {
            HttpWebRequest wr = (HttpWebRequest) base.GetWebRequest(new Uri(Url));

            if (AlternateMusicNetUrl != null)
                wr.Headers.Add("AlternateMusicNetUrl", AlternateMusicNetUrl);
            if (AlternateBillingUrl != null)
                wr.Headers.Add("AlternateBillingUrl", AlternateBillingUrl);
            if (InjectedScsError != null)
                wr.Headers.Add("InjectedScsError", InjectedScsError);
            if (AlternateDmpUrl != null)
                wr.Headers.Add("AlternateDmpUrl", AlternateDmpUrl);

            if (wr.Headers[XHttpHdr.AUTHZ] == null)
            {
                FakeAAInfo aainfo = new FakeAAInfo(PassportPuid);
                wr.Headers.Add(XHttpHdr.AUTHZ, aainfo.ConvertToHttpHeaderValue());
            }

            wr.KeepAlive = false;
            
            return wr;
        }

    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\WebWidget\WCGeneralInfo.cs ===
using System;
using System.IO;
using System.Net;
using System.Security.Cryptography.X509Certificates;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Web.GeneralInfo;
using ServerTestFramework.LiveService;
using xonline.common.config;

namespace ServerTestFramework.WebWidget
{
	public class WCGeneralInfo : GeneralInfo
	{
		protected RequestInfo requestInfo = null;

		public WCGeneralInfo() : this(Global.XEnv.GetVirtualInterface(VirtualInterface.wcgeneral))
		{
		}

		public WCGeneralInfo(LiveServer ls) : this(ls.EPDefault)
		{
		}

		public WCGeneralInfo(IPEndPoint endpoint)
		{
			Url = "http://" + endpoint.ToString() + "/GeneralInfo/GeneralInfo.asmx";
			requestInfo = new RequestInfo();
		}

		public WCGeneralInfo(IPEndPoint endpoint, CertificateEntry certificate)
		{
			Url = "https://" + endpoint.ToString() + "/GeneralInfo/GeneralInfo.asmx";
			this.ClientCertificates.Add(new X509Certificate(certificate.Cert));
		}

		public WCGeneralInfo(IPEndPoint endpoint, X509Certificate certificate)
		{
			Url = "https://" + endpoint.ToString() + "/GeneralInfo/GeneralInfo.asmx";
			this.ClientCertificates.Add(certificate);
		}

		public WCGeneralInfo(IPEndPoint endpoint, RequestInfo requestInfo)
		{
			Url = "http://" + endpoint.ToString() + "/GeneralInfo/GeneralInfo.asmx";
			this.requestInfo = requestInfo;
		}

		override protected WebRequest GetWebRequest(Uri url)
		{
			WebRequest wr = base.GetWebRequest(new Uri(Url));

			if (requestInfo != null)
			{
				wr.Headers.Add("Subject-Name", requestInfo.SubjectName);
				wr.Headers.Add("Client-IP-Port", requestInfo.ClientIPPort);
				wr.Headers.Add("RequestId", requestInfo.RequestId);
			}

			return wr;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\WebWidget\WCInitializer.cs ===
using System;
using System.Collections;
using System.Data.SqlClient;
using System.Net;
using System.Text.RegularExpressions;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using xonline.common.config;
using ServerTestFramework.LiveService.UserAccount;

namespace ServerTestFramework.WebWidget
{
    public class Initializer
    {
        private static Initializer init = new Initializer();

        public static void Initialize()
        {
            if (init != null)
            {
                if (init.LoadDB())
                {
                    // We need to hit the sites to load the assemblies before attempting reload
                    //init.HitWebCaches(); jacobr- deprecated health.ashx can do this now
//                  init.ReloadWebCaches();
                }
                init = null;
            }
        }

        private bool LoadDB()
        {
            // Establish a connection to the NPDB
            SqlConnection conn = new SqlConnection("Data Source="+Global.XEnv.GetServerListByInterface(Interface.npdb)[0]+";Integrated Security =true;Initial Catalog=webdb");          
            
            try
            {
                ConsoleX.Write("Connecting to NPDB...");
                conn.Open();
                ConsoleX.ClearLine();

                int count = (int)new SqlCommand("select count(*) from webdb..t_title_info where i_title_id = 0xc0fe1000", conn).ExecuteScalar();
                if (count > 0)
                {
                    ConsoleX.WriteLine("Data has already been loaded for WCTest.");
                    return false;
                }

                ConsoleX.WriteLine("Loading WCTest data into the database...");

                RunQueries(conn);
            }
            catch (SqlException e)
            {
                ConsoleX.WriteLine(CC.YELLOW, "Failed to load data for WCTest.\n" + e.Message);
            }
            finally
            {
                conn.Close();
            }

            return true;
        }

        private void Q(SqlConnection conn, string s)
        {
            new SqlCommand(s, conn).ExecuteNonQuery();
        }

        private void Q(SqlConnection conn, string s, params object[] args)
        {
            new SqlCommand(string.Format(s, args), conn).ExecuteNonQuery();
        }

        private void RunQueries(SqlConnection conn)
        {
            // Titles
            Q(conn, "insert into t_title_info (i_title_id, ti_esrb_rating, i_cluster_id, vc_default_locale) values (0xc0fe7000, 2, 1, N'en-US')");
            Q(conn, "insert into t_title_info (i_title_id, ti_esrb_rating, i_cluster_id, vc_default_locale) values (0xc0fe3000, 2, 1, N'en-US')");
            Q(conn, "insert into t_title_info (i_title_id, ti_esrb_rating, i_cluster_id, vc_default_locale) values (0xc0fe1000, 2, 1, N'en-US')");
            Q(conn, "insert into t_title_info (i_title_id, ti_esrb_rating, i_cluster_id, vc_default_locale) values (0xc0fe0000, 2, 1, N'en-US')");
            Q(conn, "insert into t_title_info (i_title_id, ti_esrb_rating, i_cluster_id, vc_default_locale) values (0xc0feA000, 2, 1, N'en-US')");  // No one has access to this title

            // Title Names
            foreach (string[] lang in GetLanguages())
                Q(conn, "insert into t_title_name_info (i_title_id, vc_locale_id, vc_display_name) values (0xc0fe1000, N'{0}', N'WCTestTitle1 in {1}')", lang[0], lang[1]);
            Q(conn, "insert into t_title_name_info (i_title_id, vc_locale_id, vc_display_name) values (0xc0fe7000, N'en-US', N'WCTestTitle2 permission 7')");
            Q(conn, "insert into t_title_name_info (i_title_id, vc_locale_id, vc_display_name) values (0xc0fe3000, N'en-US', N'WCTestTitle3 permission 3')");
            Q(conn, "insert into t_title_name_info (i_title_id, vc_locale_id, vc_display_name) values (0xc0fe0000, N'en-US', N'WCTestTitle4 permission 0')");
            Q(conn, "insert into t_title_name_info (i_title_id, vc_locale_id, vc_display_name) values (0xc0feA000, N'en-US', N'WCTestTitle5 no permissions')");

            // Partner Groups
            Q(conn, "insert into t_partner_groups (i_partner_group_id, vc_description) values (3, N'WCTest Group 1')");

            // Partners
            Q(conn, "insert into t_partners (i_partner_id, i_partner_group_id, vc_subject_name, i_cred_type, vc_description) values (44, 3, N'WCTest1', 1, N'WCTest client 1')");
            Q(conn, "insert into t_partners (i_partner_id, i_partner_group_id, vc_subject_name, i_cred_type, vc_description) values (45, 3, N'WCTest2', 1, N'WCTest client 2')");
            Q(conn, "insert into t_partners (i_partner_id, i_partner_group_id, vc_subject_name, i_cred_type, vc_description) values (46, 3, N'WCTest3', 1, N'WCTest client 3')");  // Only has permission to GetLBDetailsRaw
            Q(conn, "insert into t_partners (i_partner_id, i_partner_group_id, vc_subject_name, i_cred_type, vc_description) values (47, 3, N'WCTest4', 1, N'WCTest client 4')");  // Using different permissions for the same user on a different partner
            Q(conn, "insert into t_partners (i_partner_id, i_partner_group_id, vc_subject_name, i_cred_type, vc_description) values (48, 3, N'WCTest5', 1, N'WCTest client 5')");  // No IPs allowed

            string[] apis = GetAPIs();
            // Partner Allowed APIs
            foreach (string api in apis)
                Q(conn, "insert into t_partner_allowed_apis (i_partner_id, vc_api_name) values (44, N'{0}')", api);
            foreach (string api in apis)
                if (api != "Stats.EnumerateLBRaw")
                    Q(conn, "insert into t_partner_allowed_apis (i_partner_id, vc_api_name) values (45, N'{0}')", api);
            Q(conn, "insert into t_partner_allowed_apis (i_partner_id, vc_api_name) values (46, N'Stats.EnumerateLBRaw')");
            Q(conn, "insert into t_partner_allowed_apis (i_partner_id, vc_api_name) values (47, N'GeneralInfo.GetTitleList')");
            Q(conn, "insert into t_partner_allowed_apis (i_partner_id, vc_api_name) values (48, N'GeneralInfo.GetTitleList')");

            // Partner Allowed titles
            Q(conn, "insert into t_partner_allowed_titles (i_partner_id, i_title_id, i_title_privilege) values (44, 0xc0fe7000, 7)");
            Q(conn, "insert into t_partner_allowed_titles (i_partner_id, i_title_id, i_title_privilege) values (44, 0xc0fe3000, 3)");
            Q(conn, "insert into t_partner_allowed_titles (i_partner_id, i_title_id, i_title_privilege) values (44, 0xc0fe1000, 1)");
            Q(conn, "insert into t_partner_allowed_titles (i_partner_id, i_title_id, i_title_privilege) values (44, 0xc0fe0000, 0)");
            Q(conn, "insert into t_partner_allowed_titles (i_partner_id, i_title_id, i_title_privilege) values (45, 0xc0fe1000, 1)");
            Q(conn, "insert into t_partner_allowed_titles (i_partner_id, i_title_id, i_title_privilege) values (46, 0xc0fe1000, 1)");
            Q(conn, "insert into t_partner_allowed_titles (i_partner_id, i_title_id, i_title_privilege) values (47, 0xc0fe1000, 0)");
            Q(conn, "insert into t_partner_allowed_titles (i_partner_id, i_title_id, i_title_privilege) values (48, 0xc0fe1000, 0)");

            // Partner IPs
            Q(conn, "insert into t_partner_ips (i_partner_id, i_ip, i_mask) values (44, 0x{0}, 0x{1})", Hexer.IPHex("10.10.1.242"), Hexer.IPHex("0.0.0.0")); // from any 10.12.x.x
            Q(conn, "insert into t_partner_ips (i_partner_id, i_ip, i_mask) values (45, 0x{0}, 0x{1})", Hexer.IPHex("10.10.1.24"), Hexer.IPHex("255.255.255.255")); // only from 10.10.1.242
            Q(conn, "insert into t_partner_ips (i_partner_id, i_ip, i_mask) values (45, 0x{0}, 0x{1})", Hexer.IPHex("157.56.13.40"), Hexer.IPHex("255.255.255.255")); // only from 157.56.13.40
            Q(conn, "insert into t_partner_ips (i_partner_id, i_ip, i_mask) values (45, 0x{0}, 0x{1})", Hexer.IPHex("172.27.130.121"), Hexer.IPHex("255.255.255.255")); // only from 172.27.130.121
            Q(conn, "insert into t_partner_ips (i_partner_id, i_ip, i_mask) values (45, 0x{0}, 0x{1})", Hexer.IPHex("10.12.0.0"), Hexer.IPHex("255.255.0.0")); // from any 10.12.x.x
            Q(conn, "insert into t_partner_ips (i_partner_id, i_ip, i_mask) values (46, 0x{0}, 0x{1})", Hexer.IPHex("10.10.1.242"), Hexer.IPHex("0.0.0.0")); // from any 10.12.x.x
            Q(conn, "insert into t_partner_ips (i_partner_id, i_ip, i_mask) values (47, 0x{0}, 0x{1})", Hexer.IPHex("10.10.1.242"), Hexer.IPHex("0.0.0.0")); // from any 10.12.x.x

            // Leaderboards
            for (int j = 0; j < 10; j++)
                Q(conn, "insert into t_leaderboard_info (i_title_id, i_lb_id, ti_reset_type, i_entries_per_cache_line, i_expiration_seconds) values (0xC0FE1000, {0}, 0, 100, 900)", j);

            foreach (string[] lang in GetLanguages())
                Q(conn, "insert into t_leaderboard_name_info (i_title_id, i_lb_id, vc_locale_id, vc_display_name) values (0xC0FE1000, 0, '{0}', N'WCTest LB1 in {1}')", lang[0], lang[1]);

            for (int j = 1; j < 10; j++)
                Q(conn, "insert into t_leaderboard_name_info (i_title_id, i_lb_id, vc_locale_id, vc_display_name) values (0xC0FE1000, {0}, 'en-US', N'WCTest LB{0}')", j);

            // Leaderboard #0 attributes in other languages
            Q(conn, "insert into t_leaderboard_formatted_attribute_info (i_title_id, i_lb_id, vc_name, i_type, vc_formula) values (0xC0FE1000, 0, 'ID-WCT-0', 0, 'attr[0]')");
            foreach (string[] lang in GetLanguages())
                Q(conn, "insert into t_leaderboard_formatted_attribute_name_info (i_title_id, i_lb_id, vc_name, vc_locale_id, vc_display_name) values (0xC0FE1000, 0, 'ID-WCT-0', '{0}', N'ID-WCT-0 in {1}')", lang[0], lang[1]);

            // Leaderboard #1-9 attributes
            for (int j = 1; j < 10; j++)
            {
                for (int i = 0; i < 11; i++)
                {
                    Q(conn, "insert into t_leaderboard_formatted_attribute_info (i_title_id, i_lb_id, vc_name, i_type, vc_formula) values (0xC0FE1000, {0}, 'ID-WCT-{0}-{1}', {1}, 'attr[{1}]')", j, i);
                    Q(conn, "insert into t_leaderboard_formatted_attribute_name_info (i_title_id, i_lb_id, vc_name, vc_locale_id, vc_display_name) values (0xC0FE1000, {0}, 'ID-WCT-{0}-{1}', 'en-US', N'WCTest LB{0} type {2}')", j, i, AttrType(i));
                }
            }
        }

        private string[] GetAPIs()
        {
            ArrayList al = new ArrayList();

            al.Add("GeneralInfo.GetTitleList");
            al.Add("Presence.GetFriends");
            al.Add("Presence.GetRecentPlayers");
            al.Add("Stats.EnumerateLB");
            al.Add("Stats.EnumerateLBRaw");
            al.Add("Stats.GetLBDetailsForGamerTags");
            al.Add("Stats.GetLBForGamerTags");
            al.Add("Stats.GetLBList");
            al.Add("Stats.GetLBNearGamerTag");
            al.Add("UserAccount.GetUserAuthorization");
            al.Add("UserAccount.GetUserSettings");
            al.Add("UserAccount.LinkedGamerTags");
            al.Add("UserAccount.LinkUser");

            return (string[])al.ToArray(typeof(string));
        }

        private string[][] GetLanguages()
        {
            return new string[][] {
                                     new string[] {"en-US", "English"},
                                     new string[] {"zh-CH", "??"},
                                     new string[] {"jp-JP", "???"},
                                     new string[] {"sr-SR", "??????"},
                                     new string[] {"es-SP", "Espaol"}};
        }

        private string AttrType(int i)
        {
            return ((ServerTestFramework.Web.Stats.AttributeUnit)i).ToString();
        }
/* DEPRECATE--jacobr
        public void HitWebCaches()
        {
            ConsoleX.Write("Verifing WebCaches are started...");

            // HACK!!!  - Quick fix shotgun blast
            // Loop using list of IP's for Utility Widget becuase it includes all.
            // If any widgets get more than one server this breaks because the widget-util
            // in stf.xml lists VIPs
            foreach (string serverIP in Global.Env.UtilityWebCacheServer.TextFront)
            {
                LiveServer server = new LiveServer("webcache", serverIP);

                uint validSeconds;
                UacsCommon uacs = new UacsCommon();
                Owner owner = uacs.GenerateOwner();
                ulong puid = 0;  // we could generate a new account first but we don't need to for this to work

                try {new WCGeneralInfo(server).GetTitleList(out validSeconds);}
                catch {}

                try {new WCUserAccount(server).LinkUser(puid, true, owner);} catch {}

                try {new WCPresence(IPEndPoint.Parse(serverIP)).GetFriends(puid, owner.gamertag, out validSeconds);} catch {}

                try {new WCStats(server).GetLBList(0xC0FE1000, out validSeconds);} catch {}
            }

            ConsoleX.ClearLine();
        }
*/

/* Depricate: WCUtilWrapper moved to Stftests\WCUtilTest - a-jolyn 09/19/2005

        public void ReloadWebCaches()
        {
            ConsoleX.Write("Reloading WebCaches.");

            ArrayList threads = new ArrayList();
            // HACK!!!  - Quick fix shotgun blast
            // Loop using list of IP's for Utility Widget becuase it includes all.
            // If any widgets get more than one server this breaks because the widget-util
            // in stf.xml lists VIPs
            foreach (IPEndPoint address in Global.Env.UtilityWebCacheServer.EPFront)
            {
                foreach (string widget in new string[] {"wcusers", "wcgeneral", "wcsignature", "WCUtilWrapper"})
                {
                    threads.Add(Reloader.Run(address.Address, widget, "ReloadTitles", @"Title reload complete. We now have \d+ titles loaded"));
                    threads.Add(Reloader.Run(address.Address, widget, "ReloadPartners", @"Partner reload complete. We now have \d+ partners loaded"));
                }
            }

            int numCompleted = 0;
            while (numCompleted < threads.Count)
            {
                ConsoleX.ClearLine();
                ConsoleX.Write("Reloading WebCaches.  " + numCompleted + "/" + threads.Count + " completed.");
                numCompleted = 0;
                foreach (Thread t in threads)
                    if (t.ThreadState == ThreadState.Stopped)
                        numCompleted++;
                Thread.Sleep(500);
            }

            ConsoleX.ClearLine();
            ConsoleX.Write("Reloading WCUtilWrappers.");
            new ServerTestFramework.Web.UtilWrapper.WCUtilWrapper().ReloadTitlesAndPartners();

            ConsoleX.ClearLine();
            ConsoleX.WriteLine("WebCaches reloaded.");
        }
*/
        class Reloader
        {
            private IPAddress address;
            private string widget;
            private string command;
            private string expected;

            private Reloader(IPAddress address, string widget, string command, string expected)
            {
                this.address = address;
                this.widget = widget;
                this.command = command;
                this.expected = expected;
            }

            private void Reload()
            {
                try
                {
                    string response = ManagementConsole.Execute(address.ToString(), "e :" + widget + " " + command);
                    if (!new Regex(expected).Match(response).Success)
                        throw new UnexpectedTestResultException("WebCache xmgmt " + command + " failed.");
                }
                catch (ApplicationException)
                {
                }
            }

            public static Thread Run(IPAddress address, string widget, string command, string expected)
            {
                Reloader rel = new Reloader(address, widget, command, expected);
                Thread t = ThreadMaker.CreateThread(rel.Reload);
                t.Start();
                return t;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\WebWidget\WCAlerts.cs ===
using System;
using System.IO;
using System.Net;
using System.Security.Cryptography.X509Certificates;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Web.Alert;
using ServerTestFramework.LiveService;
using xonline.common.config;

namespace ServerTestFramework.WebWidget
{
	public class WCAlertsWidget : Alerts
	{
		protected RequestInfo requestInfo = null;

		public WCAlertsWidget() : this(Global.XEnv.GetVirtualInterface(VirtualInterface.wcalerts))
		{
		}

		public WCAlertsWidget(LiveServer ls) : this(ls.EPDefault)
		{
		}

		public WCAlertsWidget(RequestInfo requestInfo)
		{
			Url = "http://" + Global.XEnv.GetVirtualInterface(VirtualInterface.wcalerts).ToString() + "/Alerts/Alerts.asmx";
			this.requestInfo = requestInfo;
		}

		public WCAlertsWidget(IPEndPoint endpoint)
		{
			Url = "http://" + endpoint.ToString() + "/Alerts/Alerts.asmx";
			requestInfo = new RequestInfo();
		}

		public WCAlertsWidget(IPEndPoint endpoint, CertificateEntry certificate)
		{
			Url = "https://" + endpoint.ToString() + "/Alerts/Alerts.asmx";
			this.ClientCertificates.Add(new X509Certificate(certificate.Cert));
		}

		public WCAlertsWidget(IPEndPoint endpoint, X509Certificate certificate)
		{
			Url = "https://" + endpoint.ToString() + "/Alerts/Alerts.asmx";
			this.ClientCertificates.Add(certificate);
		}

		public WCAlertsWidget(IPEndPoint endpoint, RequestInfo requestInfo)
		{
			Url = "http://" + endpoint.ToString() + "/Alerts/Alerts.asmx";
			this.requestInfo = requestInfo;
		}

		override protected WebRequest GetWebRequest(Uri url)
		{
			WebRequest wr = base.GetWebRequest(new Uri(Url));

			if (requestInfo != null)
			{
				wr.Headers.Add("Subject-Name", requestInfo.SubjectName);
				wr.Headers.Add("Client-IP-Port", requestInfo.ClientIPPort);
				wr.Headers.Add("RequestId", requestInfo.RequestId);
			}

			return wr;
		}

		public bool CheckAlerts(AddSubscriptions AlertsReturn1, ExistingSubscriptions AlertsReturn2, uint SubSize)
		{
			// Ensure the sizes are correct
			if(AlertsReturn1.contentSubscriptions.Length != SubSize ||
				AlertsReturn1.liveSubscriptions.Length != SubSize ||
				AlertsReturn2.contentSubscriptions.Length != SubSize ||
				AlertsReturn2.liveSubscriptions.Length != SubSize)
				return false;

			// If any part of the Alert Subscriptions don't match return false
			for(uint j = 0; j < SubSize; j++)
			{
				if(
					// AlertsReturn1.contentSubscriptions[j].subscriptionID != AlertsReturn2.contentSubscriptions[j].subscriptionID ||
					AlertsReturn1.contentSubscriptions[j].type != AlertsReturn2.contentSubscriptions[j].type ||
					!AlertsReturn1.contentSubscriptions[j].locale.Equals(AlertsReturn2.contentSubscriptions[j].locale) ||
					// AlertsReturn1.liveSubscriptions[j].subscriptionID != AlertsReturn2.liveSubscriptions[j].subscriptionID ||
					AlertsReturn1.liveSubscriptions[j].type != AlertsReturn2.liveSubscriptions[j].type ||
					// !AlertsReturn1.liveSubscriptions[j].name.Equals(AlertsReturn2.liveSubscriptions[j].name) ||
					!AlertsReturn1.liveSubscriptions[j].locale.Equals(AlertsReturn2.liveSubscriptions[j].locale))
					return false;
			}

			return true;
		}

		public bool CheckAlerts(ExistingSubscriptions AlertsReturn1, ExistingSubscriptions AlertsReturn2, uint SubSize)
		{
			// Ensure the sizes are correct
			if(AlertsReturn1.contentSubscriptions.Length != SubSize ||
				AlertsReturn1.liveSubscriptions.Length != SubSize ||
				AlertsReturn2.contentSubscriptions.Length != SubSize ||
				AlertsReturn2.liveSubscriptions.Length != SubSize)
				return false;

			// If any part of the Alert Subscriptions don't match return false
			for(uint j = 0; j < SubSize; j++)
			{
				if(
					AlertsReturn1.contentSubscriptions[j].subscriptionID != AlertsReturn2.contentSubscriptions[j].subscriptionID ||
					AlertsReturn1.contentSubscriptions[j].type != AlertsReturn2.contentSubscriptions[j].type ||
					!AlertsReturn1.contentSubscriptions[j].locale.Equals(AlertsReturn2.contentSubscriptions[j].locale) ||
					AlertsReturn1.liveSubscriptions[j].subscriptionID != AlertsReturn2.liveSubscriptions[j].subscriptionID ||
					AlertsReturn1.liveSubscriptions[j].type != AlertsReturn2.liveSubscriptions[j].type ||
					!AlertsReturn1.liveSubscriptions[j].name.Equals(AlertsReturn2.liveSubscriptions[j].name) ||
					!AlertsReturn1.liveSubscriptions[j].locale.Equals(AlertsReturn2.liveSubscriptions[j].locale))
					return false;
			}

			return true;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\WebWidget\WCPresence.cs ===
using System;
using System.IO;
using System.Net;
using System.Security.Cryptography.X509Certificates;
using ServerTestFramework;
using ServerTestFramework.Web.Presence;
using ServerTestFramework.LiveService;
using xonline.common.config;

namespace ServerTestFramework.WebWidget
{
	public class WCPresence : Presence
	{
		protected RequestInfo requestInfo;

		public WCPresence() : this(Global.XEnv.GetVirtualInterface(VirtualInterface.wcpresence))
		{
		}

		public WCPresence(LiveServer ls) : this(ls.EPDefault)
		{
		}

		public WCPresence(IPEndPoint endpoint)
		{
			Url = "http://" + endpoint.ToString() + "/Presence/Presence.asmx";
			requestInfo = new RequestInfo();
		}

		public WCPresence(IPEndPoint endpoint, CertificateEntry certificate)
		{
			Url = "https://" + endpoint.ToString() + "/Presence/Presence.asmx";
			this.ClientCertificates.Add(new X509Certificate(certificate.Cert));
		}

		public WCPresence(IPEndPoint endpoint, RequestInfo requestInfo)
		{
			Url = "http://" + endpoint.ToString() + "/Presence/Presence.asmx";
			this.requestInfo = requestInfo;
		}

		override protected WebRequest GetWebRequest(Uri url)
		{
			WebRequest wr = base.GetWebRequest(new Uri(Url));

			if (requestInfo != null)
			{
				wr.Headers.Add("Subject-Name", requestInfo.SubjectName);
				wr.Headers.Add("Client-IP-Port", requestInfo.ClientIPPort);
				wr.Headers.Add("RequestId", requestInfo.RequestId);
			}

			return wr;
		}

		public FriendsInfo GetFriends( ulong puid, string gamerTag, out uint validSeconds)
		{
			byte[] webID = WCUserAccount.PuidToWebID( puid );
			return GetFriends(webID, gamerTag, out validSeconds);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\WebWidget\WCProfile.cs ===
using System;
using System.IO;
using System.Net;
using System.Security.Cryptography.X509Certificates;
using ServerTestFramework;
using ServerTestFramework.Web.Profile;
using ServerTestFramework.LiveService;
using xonline.common.config;

namespace ServerTestFramework.WebWidget
{
	public class WCProfile : Profile
	{
		protected RequestInfo requestInfo;

		public WCProfile() : this(Global.XEnv.GetVirtualInterface(VirtualInterface.wcprofile))
		{
		}

		public WCProfile(LiveServer ls) : this(ls.EPDefault)
		{
		}

		public WCProfile(IPEndPoint endpoint)
		{
			Url = "http://" + endpoint.ToString() + "/Profile/Profile.asmx";
			requestInfo = new RequestInfo();
		}

		public WCProfile(IPEndPoint endpoint, CertificateEntry certificate)
		{
			Url = "https://" + endpoint.ToString() + "/Profile/Profile.asmx";
			this.ClientCertificates.Add(new X509Certificate(certificate.Cert));
		}

		public WCProfile(IPEndPoint endpoint, RequestInfo requestInfo)
		{
			Url = "http://" + endpoint.ToString() + "/Profile/Profile.asmx";
			this.requestInfo = requestInfo;
		}

		override protected WebRequest GetWebRequest(Uri url)
		{
			WebRequest wr = base.GetWebRequest(new Uri(Url));

			if (requestInfo != null)
			{
				wr.Headers.Add("Subject-Name", requestInfo.SubjectName);
				wr.Headers.Add("Client-IP-Port", requestInfo.ClientIPPort);
				wr.Headers.Add("RequestId", requestInfo.RequestId);
			}

			return wr;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\WebReferences\Xbos_History\Reference.cs ===
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4959
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace ServerTestFramework.LiveService.Billing.History.WebService {
    using System.Xml.Serialization;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Diagnostics;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="HistorySoap", Namespace="urn:schemas-xbox-com:billing-history-data")]
    public partial class History : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback TestConnectionOperationCompleted;
        
        private System.Threading.SendOrPostCallback ExecuteOperationCompleted;
        
        private System.Threading.SendOrPostCallback QueryOperationCompleted;
        
        /// <remarks/>
        public History() {
            this.Url = "http://localhost:10090/xbos/history.asmx";
        }
        
        /// <remarks/>
        public event TestConnectionCompletedEventHandler TestConnectionCompleted;
        
        /// <remarks/>
        public event ExecuteCompletedEventHandler ExecuteCompleted;
        
        /// <remarks/>
        public event QueryCompletedEventHandler QueryCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:billing-history-data/TestConnection", RequestNamespace="urn:schemas-xbox-com:billing-history-data", ResponseNamespace="urn:schemas-xbox-com:billing-history-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string TestConnection(string inputMessage) {
            object[] results = this.Invoke("TestConnection", new object[] {
                        inputMessage});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginTestConnection(string inputMessage, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("TestConnection", new object[] {
                        inputMessage}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndTestConnection(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void TestConnectionAsync(string inputMessage) {
            this.TestConnectionAsync(inputMessage, null);
        }
        
        /// <remarks/>
        public void TestConnectionAsync(string inputMessage, object userState) {
            if ((this.TestConnectionOperationCompleted == null)) {
                this.TestConnectionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnTestConnectionOperationCompleted);
            }
            this.InvokeAsync("TestConnection", new object[] {
                        inputMessage}, this.TestConnectionOperationCompleted, userState);
        }
        
        private void OnTestConnectionOperationCompleted(object arg) {
            if ((this.TestConnectionCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.TestConnectionCompleted(this, new TestConnectionCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:billing-history-data/Execute", RequestNamespace="urn:schemas-xbox-com:billing-history-data", ResponseNamespace="urn:schemas-xbox-com:billing-history-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public System.Xml.XmlNode Execute(string methodName, string[] Names, string[] Values, int PageSize, int PageNum, ulong UserPuid, ulong MachinePuid) {
            object[] results = this.Invoke("Execute", new object[] {
                        methodName,
                        Names,
                        Values,
                        PageSize,
                        PageNum,
                        UserPuid,
                        MachinePuid});
            return ((System.Xml.XmlNode)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginExecute(string methodName, string[] Names, string[] Values, int PageSize, int PageNum, ulong UserPuid, ulong MachinePuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("Execute", new object[] {
                        methodName,
                        Names,
                        Values,
                        PageSize,
                        PageNum,
                        UserPuid,
                        MachinePuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.Xml.XmlNode EndExecute(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.Xml.XmlNode)(results[0]));
        }
        
        /// <remarks/>
        public void ExecuteAsync(string methodName, string[] Names, string[] Values, int PageSize, int PageNum, ulong UserPuid, ulong MachinePuid) {
            this.ExecuteAsync(methodName, Names, Values, PageSize, PageNum, UserPuid, MachinePuid, null);
        }
        
        /// <remarks/>
        public void ExecuteAsync(string methodName, string[] Names, string[] Values, int PageSize, int PageNum, ulong UserPuid, ulong MachinePuid, object userState) {
            if ((this.ExecuteOperationCompleted == null)) {
                this.ExecuteOperationCompleted = new System.Threading.SendOrPostCallback(this.OnExecuteOperationCompleted);
            }
            this.InvokeAsync("Execute", new object[] {
                        methodName,
                        Names,
                        Values,
                        PageSize,
                        PageNum,
                        UserPuid,
                        MachinePuid}, this.ExecuteOperationCompleted, userState);
        }
        
        private void OnExecuteOperationCompleted(object arg) {
            if ((this.ExecuteCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ExecuteCompleted(this, new ExecuteCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:billing-history-data/Query", RequestNamespace="urn:schemas-xbox-com:billing-history-data", ResponseNamespace="urn:schemas-xbox-com:billing-history-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public System.Xml.XmlNode Query(string methodName, string[] Names, string[] Values, ulong UserPuid, ulong MachinePuid) {
            object[] results = this.Invoke("Query", new object[] {
                        methodName,
                        Names,
                        Values,
                        UserPuid,
                        MachinePuid});
            return ((System.Xml.XmlNode)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginQuery(string methodName, string[] Names, string[] Values, ulong UserPuid, ulong MachinePuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("Query", new object[] {
                        methodName,
                        Names,
                        Values,
                        UserPuid,
                        MachinePuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.Xml.XmlNode EndQuery(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.Xml.XmlNode)(results[0]));
        }
        
        /// <remarks/>
        public void QueryAsync(string methodName, string[] Names, string[] Values, ulong UserPuid, ulong MachinePuid) {
            this.QueryAsync(methodName, Names, Values, UserPuid, MachinePuid, null);
        }
        
        /// <remarks/>
        public void QueryAsync(string methodName, string[] Names, string[] Values, ulong UserPuid, ulong MachinePuid, object userState) {
            if ((this.QueryOperationCompleted == null)) {
                this.QueryOperationCompleted = new System.Threading.SendOrPostCallback(this.OnQueryOperationCompleted);
            }
            this.InvokeAsync("Query", new object[] {
                        methodName,
                        Names,
                        Values,
                        UserPuid,
                        MachinePuid}, this.QueryOperationCompleted, userState);
        }
        
        private void OnQueryOperationCompleted(object arg) {
            if ((this.QueryCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.QueryCompleted(this, new QueryCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void TestConnectionCompletedEventHandler(object sender, TestConnectionCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class TestConnectionCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal TestConnectionCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ExecuteCompletedEventHandler(object sender, ExecuteCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ExecuteCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ExecuteCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public System.Xml.XmlNode Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.Xml.XmlNode)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void QueryCompletedEventHandler(object sender, QueryCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class QueryCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal QueryCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public System.Xml.XmlNode Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.Xml.XmlNode)(this.results[0]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\WebWidget\WCMessaging.cs ===
using System;
using System.IO;
using System.Net;
using System.Security.Cryptography.X509Certificates;
using ServerTestFramework;
using ServerTestFramework.Web.Messaging;
using ServerTestFramework.LiveService;
using xonline.common.config;

namespace ServerTestFramework.WebWidget
{
	public class WCMessaging : MessagingImpl
	{
		protected RequestInfo requestInfo;

		public WCMessaging() : this(Global.XEnv.GetVirtualInterface(VirtualInterface.wcmessaging))
		{
		}

		public WCMessaging(LiveServer ls) : this(ls.EPDefault)
		{
		}

		public WCMessaging(IPEndPoint endpoint)
		{
			Url = "http://" + endpoint.ToString() + "/Messaging/Messaging.asmx";
			requestInfo = new RequestInfo();
		}

		public WCMessaging(IPEndPoint endpoint, CertificateEntry certificate)
		{
			Url = "https://" + endpoint.ToString() + "/Messaging/Messaging.asmx";
			this.ClientCertificates.Add(new X509Certificate(certificate.Cert));
		}

		public WCMessaging(IPEndPoint endpoint, X509Certificate certificate)
		{
			Url = "https://" + endpoint.ToString() + "/Messaging/Messaging.asmx";
			this.ClientCertificates.Add(certificate);
		}

		public WCMessaging(IPEndPoint endpoint, RequestInfo requestInfo)
		{
			Url = "http://" + endpoint.ToString() + "/Messaging/Messaging.asmx";
			this.requestInfo = requestInfo;
		}


		override protected WebRequest GetWebRequest(Uri url)
		{
			WebRequest wr = base.GetWebRequest(new Uri(Url));

			if (requestInfo != null)
			{
				wr.Headers.Add("Subject-Name", requestInfo.SubjectName);
				wr.Headers.Add("Client-IP-Port", requestInfo.ClientIPPort);
				wr.Headers.Add("RequestId", requestInfo.RequestId);
			}

			return wr;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\WebWidget\WCStats.cs ===
using System;
using System.IO;
using System.Net;
using System.Security.Cryptography.X509Certificates;
using ServerTestFramework;
using ServerTestFramework.Web.Stats;
using ServerTestFramework.LiveService;
using xonline.common.config;

namespace ServerTestFramework.WebWidget
{
	public class WCStats : Stats
	{
		protected RequestInfo requestInfo = null;

		public WCStats() : this(Global.XEnv.GetVirtualInterface(VirtualInterface.wcstats))
		{
		}

		public WCStats(IPEndPoint endpoint)
		{
			Url = "http://" + endpoint.ToString() + "/Stats/Stats.asmx";
			requestInfo = new RequestInfo();
		}

		public WCStats(IPEndPoint endpoint, CertificateEntry certificate)
		{
			Url = "https://" + endpoint.ToString() + "/Stats/Stats.asmx";
			this.ClientCertificates.Add(new X509Certificate(certificate.Cert));
		}

		public WCStats(IPEndPoint endpoint, X509Certificate certificate)
		{
			Url = "https://" + endpoint.ToString() + "/Stats/Stats.asmx";
			this.ClientCertificates.Add(certificate);
		}

		public WCStats(IPEndPoint endpoint, RequestInfo requestInfo)
		{
			Url = "http://" + endpoint.ToString() + "/Stats/Stats.asmx";
			this.requestInfo = requestInfo;
		}

		override protected WebRequest GetWebRequest(Uri url)
		{
			WebRequest wr = base.GetWebRequest(new Uri(Url));

			if (requestInfo != null)
			{
				wr.Headers.Add("Subject-Name", requestInfo.SubjectName);
				wr.Headers.Add("Client-IP-Port", requestInfo.ClientIPPort);
				wr.Headers.Add("RequestId", requestInfo.RequestId);
			}

			return wr;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\WebWidget\WCSignature.cs ===
using System;
using System.IO;
using System.Net;
using System.Security.Cryptography.X509Certificates;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Web.SignatureWidget;
using ServerTestFramework.LiveService;
using xonline.common.config;

namespace ServerTestFramework.WebWidget
{
	public class WCSignature : Signature
	{
		protected RequestInfo requestInfo = null;

		public WCSignature() : this(Global.XEnv.GetVirtualInterface(VirtualInterface.wcgeneral))
		{
		}

		public WCSignature(LiveServer ls) : this(ls.EPDefault)
		{
		}

		public WCSignature(IPEndPoint endpoint)
		{
			Url = "http://" + endpoint.ToString() + "/Signature/Signature.asmx";
			requestInfo = new RequestInfo();
		}

		public WCSignature(IPEndPoint endpoint, CertificateEntry certificate)
		{
			Url = "https://" + endpoint.ToString() + "/Signature/Signature.asmx";
			this.ClientCertificates.Add(new X509Certificate(certificate.Cert));
		}

		public WCSignature(IPEndPoint endpoint, X509Certificate certificate)
		{
			Url = "https://" + endpoint.ToString() + "/Signature/Signature.asmx";
			this.ClientCertificates.Add(certificate);
		}

		public WCSignature(IPEndPoint endpoint, RequestInfo requestInfo)
		{
			Url = "http://" + endpoint.ToString() + "/Signature/Signature.asmx";
			this.requestInfo = requestInfo;
		}

		override protected WebRequest GetWebRequest(Uri url)
		{
			WebRequest wr = base.GetWebRequest(new Uri(Url));

			if (requestInfo != null)
			{
				wr.Headers.Add("Subject-Name", requestInfo.SubjectName);
				wr.Headers.Add("Client-IP-Port", requestInfo.ClientIPPort);
				wr.Headers.Add("RequestId", requestInfo.RequestId);
			}

			return wr;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\WebWidget\WCQuery.cs ===
using System;
using System.IO;
using System.Net;
using System.Security.Cryptography.X509Certificates;
using System.Xml;
using System.Web.Services;
using ServerTestFramework;
using ServerTestFramework.Web.Query;
using ServerTestFramework.LiveService;
using xonline.common.config;

namespace ServerTestFramework.WebWidget
{
	public class WCQuery : Query
	{
		protected RequestInfo requestInfo = null;

		public WCQuery() : this(Global.XEnv.GetVirtualInterface(VirtualInterface.wcquery))
		{
		}

		public WCQuery(IPEndPoint endpoint)
		{
			Url = "http://" + endpoint.ToString() + "/query/query.asmx";
			requestInfo = new RequestInfo();
		}

		public WCQuery(IPEndPoint endpoint, CertificateEntry certificate)
		{
			Url = "https://" + endpoint.ToString() + "/query/query.asmx";
			this.ClientCertificates.Add(new X509Certificate(certificate.Cert));
		}

		public WCQuery(IPEndPoint endpoint, X509Certificate certificate)
		{
			Url = "https://" + endpoint.ToString() + "/query/query.asmx";
			this.ClientCertificates.Add(certificate);
		}

		public WCQuery(IPEndPoint endpoint, RequestInfo requestInfo)
		{
			Url = "http://" + endpoint.ToString() + "/query/query.asmx";
			this.requestInfo = requestInfo;
		}

		public System.UInt64 WidgetAdd(System.UInt32 titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webId, string gamerTag, string teamName, System.UInt32 datasetId, QueryAttribute[] attributes)
		{
			return Add(titleId,webId,gamerTag,teamName,datasetId,attributes);
		}

		public void WidgetUpdate(System.UInt32 titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webId, string gamerTag, string teamName, System.UInt32 datasetId, System.UInt32 procIndex, QueryAttribute[] attributes)
		{
			Update(titleId,webId,gamerTag,teamName,datasetId,procIndex,attributes);
		}

		public void WidgetUpdateId(System.UInt32 titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webId, string gamerTag, string teamName, System.UInt32 datasetId, System.UInt32 procIndex, System.UInt64 entityId, QueryAttribute[] attributes)
		{
			UpdateId(titleId,webId,gamerTag,teamName,datasetId,procIndex,entityId,attributes);
		}

		public SearchResponse WidgetSearch(System.UInt32 titleId, System.UInt32 datasetId, System.UInt32 procIndex, System.UInt32 page, System.UInt32 resultsPerPage, QueryAttributeSpec[] specs, QueryAttribute[] attributes)
		{
			return Search(titleId,datasetId,procIndex,page,resultsPerPage,specs,attributes);
		}

		public FindFromIdsResponse WidgetFindFromIds(System.UInt32 titleId, System.UInt32 datasetId, System.UInt32 procIndex, QueryAttributeSpec[] specs, System.UInt64[] entityIds)
		{
			return FindFromIds(titleId,datasetId,procIndex,specs,entityIds);
		}

		public void WidgetRemove(System.UInt32 titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webId, string gamerTag, string teamName, System.UInt32 datasetId, System.UInt32 procIndex, QueryAttribute[] attributes)
		{
			Remove(titleId,webId,gamerTag,teamName,datasetId,procIndex,attributes);
		}

		public void WidgetRemoveId(System.UInt32 titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webId, string gamerTag, string teamName, System.UInt32 datasetId, System.UInt64 entityId)
		{
			RemoveId(titleId,webId,gamerTag,teamName,datasetId,entityId);
		}

		public void WidgetSelect(System.UInt32 titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webId, string gamerTag, string teamName, System.UInt32 datasetId, System.UInt64 entityId, System.UInt32 action, QueryAttribute[] attributes)
		{
			Select(titleId,webId,gamerTag,teamName,datasetId,entityId,action,attributes);
		}

		public string WidgetGetXQSConfig(System.UInt32 titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webId, System.UInt64 haveVersion)
		{
			return GetXQSConfig(titleId,webId,haveVersion);
		}

		public System.UInt64 WidgetCompetitionCreate(System.UInt32 titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webId, string gamerTag, string teamName, System.UInt32 datasetId, QueryAttribute[] attributes)
		{
			return CompetitionCreate(titleId,webId,gamerTag,teamName,datasetId,attributes);
		}

		public System.UInt64 WidgetCompetitionCreateSingleElimination(
			System.UInt32 titleId,
			[System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webId,
			string gamerTag,
			string teamName,
			System.UInt32 datasetId,
			System.UInt32 cPrivateSlots,
			System.UInt32 cPublicSlots,
			System.UInt32 cMinimumPlayers,
			System.DateTime dtRegistrationOpen,
			System.DateTime dtRegistrationClose,
			System.DateTime dtCompetitionStart,
			System.DateTime dtRoundOneStart,
			System.DateTime dtRoundOneEnd,
			System.UInt32 dwMatchReminderAdvanceMinutes,
			System.UInt32 UnitOrMask,
			System.UInt32 Interval,
			bool fTeamCompetition,
			System.UInt32 dwTeamSize,
			QueryAttribute[] additionalAttributes)
		{
			return CompetitionCreateSingleElimination(
				titleId, webId, gamerTag, teamName, datasetId, cPrivateSlots, cPublicSlots,
				cMinimumPlayers, dtRegistrationOpen, dtRegistrationClose, dtCompetitionStart,
				dtRoundOneStart, dtRoundOneEnd, dwMatchReminderAdvanceMinutes, UnitOrMask,
				Interval, fTeamCompetition, dwTeamSize, additionalAttributes);
		}

		public SearchResponse WidgetCompetitionSearch(System.UInt32 titleId, System.UInt32 datasetId, System.UInt32 queryId, System.UInt32 page, System.UInt32 resultsPerPage, QueryAttributeSpec[] specs, QueryAttribute[] attributes)
		{
			return CompetitionSearch(titleId,datasetId,queryId,page,resultsPerPage,specs,attributes);
		}

		public void WidgetCompetitionManageEntrant(System.UInt32 titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webId, string gamerTag, System.UInt32 action, string teamName, System.UInt32 datasetId, System.UInt64 competitionId, QueryAttribute[] attributes)
		{
			CompetitionManageEntrant(titleId,webId,gamerTag,action,teamName,datasetId,competitionId,attributes);
		}

		public void WidgetCompetitionCancel(System.UInt32 titleId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webId, string gamerTag, string teamName, System.UInt32 datasetId, System.UInt64 competitionId)
		{
			CompetitionCancel(titleId,webId,gamerTag,teamName,datasetId,competitionId);
		}

		public SearchResponse WidgetCompetitionTopology(System.UInt32 titleId, System.UInt32 datasetId, System.UInt64 competitionId, System.UInt32 page, System.UInt32 resultsPerPage, System.Int64 startingEventId, System.Int64 endingEventId, QueryAttributeSpec[] specs)
		{
			return CompetitionTopology(titleId,datasetId,competitionId,page,resultsPerPage,startingEventId,endingEventId,specs);
		}

		public SearchResponse WidgetCompetitionTopologySingleElimination(System.UInt32 titleId, System.UInt32 datasetId, System.UInt64 competitionId, System.UInt64 originEventId, System.UInt32 roundsForward, System.UInt32 roundsBackward, System.UInt32 topWidth, QueryAttributeSpec[] specs)
		{
			return CompetitionTopologySingleElimination(titleId,datasetId,competitionId,originEventId,roundsForward,roundsBackward,topWidth,specs);
		}

		override protected WebRequest GetWebRequest(Uri url)
		{
			WebRequest wr = base.GetWebRequest(new Uri(Url));

			if (requestInfo != null)
			{
				wr.Headers.Add("Subject-Name", requestInfo.SubjectName);
				wr.Headers.Add("Client-IP-Port", requestInfo.ClientIPPort);
				wr.Headers.Add("RequestId", requestInfo.RequestId);
			}

			return wr;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\WebWidget\WCUserAccount.cs ===
using System;
using System.IO;
using System.Net;
using System.Security.Cryptography.X509Certificates;
using ServerTestFramework;
using ServerTestFramework.Web.UserAccount;
using ServerTestFramework.LiveService;
using xonline.common.config;
using ServerTestFramework.LiveService.UserAccount;

namespace ServerTestFramework.WebWidget
{
	public class WCUserAccount : UserAccount
	{
		protected RequestInfo requestInfo;

		public WCUserAccount() : this(Global.XEnv.GetVirtualInterface(VirtualInterface.wcusers))
		{
		}

		public WCUserAccount(LiveServer ls) : this(ls.EPDefault)
		{
		}

		public WCUserAccount(RequestInfo requestInfo)
		{
			Url = "http://" + Global.XEnv.GetVirtualInterface(VirtualInterface.wcusers).ToString() + "/UserAccount/UserAccount.asmx";
			this.requestInfo = requestInfo;
		}

		public WCUserAccount(IPEndPoint endpoint)
		{
			Url = "http://" + endpoint.ToString() + "/UserAccount/UserAccount.asmx";
			requestInfo = new RequestInfo();
		}

		public WCUserAccount(IPEndPoint endpoint, CertificateEntry certificate)
		{
			Url = "https://" + endpoint.ToString() + "/UserAccount/UserAccount.asmx";
			this.ClientCertificates.Add(new X509Certificate(certificate.Cert));
		}

		public WCUserAccount(IPEndPoint endpoint, X509Certificate certificate)
		{
			Url = "https://" + endpoint.ToString() + "/UserAccount/UserAccount.asmx";
			this.ClientCertificates.Add(certificate);
		}

		public WCUserAccount(IPEndPoint endpoint, RequestInfo requestInfo)
		{
			Url = "http://" + endpoint.ToString() + "/UserAccount/UserAccount.asmx";
			this.requestInfo = requestInfo;
		}

		public static byte[] PuidToWebID( ulong puid )
		{
			MemoryStream ms = new MemoryStream();
			BinaryWriter bw = new BinaryWriter(ms);
			bw.Write( puid );
			return ms.ToArray();
		}

		public bool LinkUser(ulong puid, bool linkOwner, Owner owner)
		{
			byte[] webID = PuidToWebID( puid );
			return LinkUser(webID, linkOwner, owner);
		}

		public bool LinkUser(byte[] webID, bool linkOwner, Owner owner)
		{
			return LinkUser(
				webID,
				owner.gamertag,
				linkOwner,
				owner.phonePrefix,
				owner.phoneNumber,
				owner.phoneExtension,
				owner.postalCode,
				owner.cardHolder,
				owner.cardNumber);
		}

		override protected WebRequest GetWebRequest(Uri url)
		{
			WebRequest wr = base.GetWebRequest(new Uri(Url));

			if (requestInfo != null)
			{
				wr.Headers.Add("Subject-Name", requestInfo.SubjectName);
				wr.Headers.Add("Client-IP-Port", requestInfo.ClientIPPort);
				wr.Headers.Add("RequestId", requestInfo.RequestId);
			}

			return wr;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\XBanc\XBanc.cs ===
using System;
using System.Reflection;
using System.Net;
using System.Collections;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Security.Permissions;

using ServerTestFramework.Utilities;

using xonline.common.protocol;
using xonline.common.service;

namespace ServerTestFramework.LiveService
{
    public interface IXBanc
    {
        bool ValidateKey(byte[] key);
        bool ValidateValue(byte[] value);
        uint Query(byte[] key, out byte[] value);
        uint Insert(byte[] key, byte[] value);
        uint Insert(byte[] key, byte[] value, uint absoluteSeconds, uint slidingSeconds);
        uint Remove(byte[] key);
        uint Remove(byte[] key, bool matchExact);
        uint SetData(byte[] key, byte[] value, uint absoluteSeconds, uint slidingSeconds);
        void Dispose();
    }

    public class XBancWrapper : IXBanc
    {
        private XBanc xb = null;

        public bool ValidateKey(byte[] key)
        {
            return xb.ValidateKey(key);
        }

        public bool ValidateValue(byte[] value)
        {
            return xb.ValidateValue(value);
        }

        public uint Query(byte[] key, out byte[] value)
        {
            return xb.Query(key, out value);
        }

        public uint Insert(byte[] key, byte[] value)
        {
            return xb.Insert(key, value, 0, 0);
        }

        public uint Insert(byte[] key, byte[] value, uint absoluteSeconds, uint slidingSeconds)
        {
            return xb.Insert(key, value, absoluteSeconds, slidingSeconds);
        }

        public uint Remove(byte[] key)
        {
            return xb.Remove(key, true);
        }

        public uint Remove(byte[] key, bool matchExact)
        {
            return xb.Remove(key, matchExact);
        }

        public uint SetData(byte[] key, byte[] value, uint absoluteSeconds, uint slidingSeconds)
        {
            return xb.SetData(key, value, absoluteSeconds, slidingSeconds);
        }

        public void Dispose()
        {

        }

        public XBancWrapper()
        {
            xb = new XBanc();
        }
    }

    public class XBancRemoteConnection : MarshalByRefObject, IXBanc
    {
        private XBanc xb = null;

        // prevent lifetime services from destroying our instance...
        [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)]
        public override object InitializeLifetimeService()
        {
            return null;
        }

        public bool ValidateKey(byte[] key)
        {
            return xb.ValidateKey(key);
        }

        public bool ValidateValue(byte[] value)
        {
            return xb.ValidateValue(value);
        }

        public uint Query(byte[] key, out byte[] value)
        {
            return xb.Query(key, out value);    
        }

        public uint Insert(byte[] key, byte[] value)
        {
            return xb.Insert(key, value, 0, 0);
        }

        public uint Insert(byte[] key, byte[] value, uint absoluteSeconds, uint slidingSeconds)
        {
            return xb.Insert(key, value, absoluteSeconds, slidingSeconds);          
        }

        public uint Remove(byte[] key)
        {
            return xb.Remove(key, true);
        }

        public uint Remove(byte[] key, bool matchExact)
        {
            return xb.Remove(key, matchExact);          
        }

        public uint SetData(byte[] key, byte[] value, uint absoluteSeconds, uint slidingSeconds)
        {
            return xb.SetData(key, value, absoluteSeconds, slidingSeconds);           
        }

        public void Dispose()
        {
            XBancConnectionManager.ReturnXBancConnection(this);
        }

        public XBancRemoteConnection()
        {
            xb = new XBanc();
        }
    }

    public enum XBancConnectionType : uint
    {
        XBANC_CONNECTION_LOCAL = 0,
        XBANC_CONNECTION_REMOTE = 1
    }

    public class XBancConnectionManager
    {
        public static IXBanc GetXBancConnection(XBancConnectionType connectionType)
        {
            if (connectionType == XBancConnectionType.XBANC_CONNECTION_LOCAL)
            {
                return new XBancWrapper();
            }
            else
            {
                if (_poolXBancConnections == null)
                {
                    lock (typeof(XBancConnectionManager))
                    {
                        if (_poolXBancConnections == null)
                        {
                            CreatePool(100);
                        }
                    }
                }
                return (IXBanc)_poolXBancConnections.Obtain();
            }
        }

        public static void ReturnXBancConnection(IXBanc connection)
        {
               _poolXBancConnections.Insert(connection);
               
        }

        private static void CreatePool( int poolSize )
        {
            _poolXBancConnections = new FastPool(poolSize * 2, poolSize /* queueSize for object contention */ );


            for (int iConns = 0; iConns < poolSize; iConns++)
            {
               string dllPath = AppDomain.CurrentDomain.BaseDirectory.Remove(AppDomain.CurrentDomain.BaseDirectory.LastIndexOf("\\")) + "\\Suites\\";

               AppDomainSetup setup = new AppDomainSetup();
               setup.ApplicationBase = AppDomain.CurrentDomain.BaseDirectory;
               setup.ApplicationName = "XBancRemote";
               setup.PrivateBinPath = AppDomain.CurrentDomain.BaseDirectory + ";" + dllPath + ";" + AppDomain.CurrentDomain.SetupInformation.PrivateBinPath;
               setup.DisallowPublisherPolicy = true;

                    AppDomain domain = AppDomain.CreateDomain("XBancRemote", null, setup);
                // get an instance of the cross domain test suite loader
                XBancRemoteConnection remoteConnection = (XBancRemoteConnection)domain.CreateInstanceFromAndUnwrap(typeof(XBancRemoteConnection).Module.Name,
                        typeof(XBancRemoteConnection).FullName);

                // insert initialized XBanc Connections Objects into the pool.
                _poolXBancConnections.Insert(remoteConnection);
            }
        }

        private static FastPool _poolXBancConnections = null;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\WebWidget\WCStorage.cs ===
using System;
using System.IO;
using System.Net;
using System.Security.Cryptography.X509Certificates;
using ServerTestFramework;
using ServerTestFramework.Web.Storage;
using ServerTestFramework.LiveService;
using xonline.common.config;

namespace ServerTestFramework.WebWidget
{
	public class WCStorage : Storage
	{
		protected RequestInfo requestInfo = null;

		public WCStorage() : this(Global.XEnv.GetVirtualInterface(VirtualInterface.wcstorage))
		{
		}

		public WCStorage(IPEndPoint endpoint)
		{
			Url = "http://" + endpoint.ToString() + "/Storage/Storage.asmx";
			requestInfo = new RequestInfo();
		}

		public WCStorage(IPEndPoint endpoint, CertificateEntry certificate)
		{
			Url = "https://" + endpoint.ToString() + "/Storage/Storage.asmx";
			this.ClientCertificates.Add(new X509Certificate(certificate.Cert));
		}

		public WCStorage(IPEndPoint endpoint, X509Certificate certificate)
		{
			Url = "https://" + endpoint.ToString() + "/Storage/Storage.asmx";
			this.ClientCertificates.Add(certificate);
		}

		public WCStorage(IPEndPoint endpoint, RequestInfo requestInfo)
		{
			Url = "http://" + endpoint.ToString() + "/Storage/Storage.asmx";
			this.requestInfo = requestInfo;
		}

		override protected WebRequest GetWebRequest(Uri url)
		{
			WebRequest wr = base.GetWebRequest(new Uri(Url));

			if (requestInfo != null)
			{
				wr.Headers.Add("Subject-Name", requestInfo.SubjectName);
				wr.Headers.Add("Client-IP-Port", requestInfo.ClientIPPort);
				wr.Headers.Add("RequestId", requestInfo.RequestId);
			}

			return wr;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\WebWidget\WCTeams.cs ===
using System;
using System.IO;
using System.Net;
using System.Security.Cryptography.X509Certificates;
using ServerTestFramework;
using ServerTestFramework.Web.Teams;
using ServerTestFramework.LiveService;
using xonline.common.config;

namespace ServerTestFramework.WebWidget
{
	public class WCTeams : Teams
	{
		protected RequestInfo requestInfo;

		public WCTeams() : this(Global.XEnv.GetVirtualInterface(VirtualInterface.wcteams))
		{
		}

		public WCTeams(LiveServer ls) : this(ls.EPDefault)
		{
		}

		public WCTeams(IPEndPoint endpoint)
		{
			Url = "http://" + endpoint.ToString() + "/Teams/Teams.asmx";
			requestInfo = new RequestInfo();
		}

		public WCTeams(IPEndPoint endpoint, X509Certificate certificate)
		{
			Url = "https://" + endpoint.ToString() + "/Teams/Teams.asmx";
			this.ClientCertificates.Add(certificate);
		}

		public WCTeams(IPEndPoint endpoint, CertificateEntry certificate)
		{
			Url = "https://" + endpoint.ToString() + "/Teams/Teams.asmx";
			this.ClientCertificates.Add(new X509Certificate(certificate.Cert));
		}

		public WCTeams(IPEndPoint endpoint, RequestInfo requestInfo)
		{
			Url = "http://" + endpoint.ToString() + "/Teams/Teams.asmx";
			this.requestInfo = requestInfo;
		}


		override protected WebRequest GetWebRequest(Uri url)
		{
			WebRequest wr = base.GetWebRequest(new Uri(Url));

			if (requestInfo != null)
			{
				wr.Headers.Add("Subject-Name", requestInfo.SubjectName);
				wr.Headers.Add("Client-IP-Port", requestInfo.ClientIPPort);
				wr.Headers.Add("RequestId", requestInfo.RequestId);
			}

			return wr;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\XConnSrv\Buffer.cs ===
using System;
using System.Threading;
using System.Runtime.InteropServices;


namespace ServerTestFramework.LiveService.XConnSrv
{
    // The purpose of this class is to provide byte buffers that may be frequently
    // pinned (and for long periods) without confusing the garbage collector.  The garbage collector
    // has a hard time with pinned objects and will frequently decide not to collapse memory
    // if it is too fragmented with pinned objects.  This can lead to a state where it never
    // collapses memory, quickly exhausting all the memory on a machine.
    //
    // The buffers provided by this class come out of large byte arrays.  They're
    // large enough that they get allocated on the "large object" heap, which is an additional heap
    // used by the framework to allocate large objects on, preventing them from having to be moved during
    // compaction of the regular heap.  Since large objects are never relocated anyway, pinning them
    // has no effect on garbage collection.
    //
    // Note that the buffer will not be zeroed when you get it.
    //
    // You must free the buffer or your app will leak!  It won't get garbage collected - a list is maintained
    // of all in-use buffers.
    public sealed class PinnableBuffer
    {
        private PinnableBuffer(BackingBuffer arb, int i, int cb)
        {
            this.arb = arb;
            this.i = i;
            this.cb = cb;
        }

        public byte[] Buffer
        {
            get
            {
                return arb.Buffer;
            }
        }

        // Note: Buffer is always the whole buffer.  Pointer already has Index added in.
        public unsafe byte* Pointer
        {
            get
            {
                return arb.Pointer + i;
            }
        }

        public int Index
        {
            get
            {
                return i;
            }
        }

        public int Length
        {
            get
            {
                return cb;
            }
        }

        public void Free()
        {
            if(cb == 0)
                return;

            try
            {
                if (ProtocolConnectionBase.s_fCountersInitialized)
                {
                    ProtocolConnectionCounters.Total.FreeBytes.IncrementBy(cb);
                }
            }
            catch
            {
                // ignore if counters are not installed
                ProtocolConnectionBase.s_fCountersInitialized = false;
            }

            lock(arb)
            {
                fAllocated = false;

                PinnableBuffer pNextChanged = null;
                PinnableBuffer pPrevChanged = null;

                if(pNext != null && !pNext.fAllocated)
                {
                    pNext.i = i;
                    pNext.cb += cb;
                    cb = 0;

                    pNext.pPrev = pPrev;
                    if(pPrev != null)
                        pPrev.pNext = pNext;

                    pNextChanged = pNext;
                }

                if(pPrev != null && !pPrev.fAllocated)
                {
                    pPrev.cb += pPrev.pNext.cb;
                    pPrev.pNext.cb = 0;

                    pPrev.pNext = pPrev.pNext.pNext;
                    if(pPrev.pNext != null)
                        pPrev.pNext.pPrev = pPrev;

                    pPrevChanged = pPrev;
                }

                arb.AdjustInFree(pNextChanged);
                arb.AdjustInFree(pPrevChanged);
                arb.AddToFree(this);

                arb.TryClaim();
            }
        }


        private readonly BackingBuffer arb;
        private volatile int i;
        private volatile int cb;

        private PinnableBuffer pNext;
        private PinnableBuffer pPrev;
        private PinnableBuffer pNextFree;
        private PinnableBuffer pPrevFree;

        private bool fAllocated;


        // static interface

        static PinnableBuffer()
        {
            // start with one backing buffer
            s_lBuffers = new BackingBuffer();
            s_pFirstOptimalBuffer = s_lBuffers;

            // default optimal buffer size: 256 bytes
            s_cbOptimalSize = 256;
        }

        public static PinnableBuffer Alloc(int cb)
        {
            // make them always dword-aligned
            cb = (cb + 3) & 0x7ffffffc;

            if(cb > BackingBuffer.BackingBufferSize)
                throw new ArgumentException("Requested PinnableBuffer size of " + cb.ToString() +
                    " exceeds BackingBuffer size of " + BackingBuffer.BackingBufferSize + " bytes.", "cb");
            if(cb < 0)
                throw new ArgumentException("Negative-size buffer requested.", "cb");
            if(cb == 0)
                return new PinnableBuffer(s_lBuffers, 0, 0);

            BackingBuffer pCur = s_lBuffers;
            if(cb >= s_cbOptimalSize)
                pCur = s_pFirstOptimalBuffer;

            while(true)
            {
                PinnableBuffer oPB = pCur.TryGetBuffer(cb);
                if(oPB != null)
                    return oPB;

                pCur = pCur.Next;
            }
        }

        public static int OptimalSize
        {
            get
            {
                return s_cbOptimalSize;
            }

            set
            {
                lock(s_lBuffers)
                {
                    lock(typeof(BackingBuffer))
                    {
                        s_cbOptimalSize = (value + 3) & 0x7ffffffc;
                        s_pFirstOptimalBuffer = s_lBuffers;
                        s_fFirstOptimalUnclaimed = !s_lBuffers.CanClaim;
                    }
                }
            }
        }

        private static int s_cbOptimalSize;


        // backing buffers
        private readonly static BackingBuffer s_lBuffers;
        private static BackingBuffer s_pFirstOptimalBuffer;
        private static bool s_fFirstOptimalUnclaimed;


        private class BackingBuffer
        {
            public BackingBuffer() :
                this(null)
            { }

            public const uint BackingBufferSize = 460800;    // 450k -> 2^11 * 3^2 * 5^2

            public BackingBuffer(BackingBuffer oPrev)
            {
                if(oPrev != null)
                    nBuffer = oPrev.nBuffer + 1;

                syNext = new object();

                arb = new byte[BackingBufferSize];  // 450k -> 2^11 * 3^2 * 5^2
                try
                {
                    if (ProtocolConnectionBase.s_fCountersInitialized)
                    {
                        ProtocolConnectionCounters.Total.FreeBytes.IncrementBy(arb.Length);
                        ProtocolConnectionCounters.Total.BackingBuffers.Increment();
                    }
                }
                catch
                {
                    // ignore if counters are not installed
                    ProtocolConnectionBase.s_fCountersInitialized = false;
                }

                lFree = new PinnableBuffer(this, 0, arb.Length);

                // just pin it and get it over with, consumers won't have to pin it themselves
                harb = GCHandle.Alloc(arb, GCHandleType.Pinned);
                parb = Marshal.UnsafeAddrOfPinnedArrayElement(arb, 0);
            }

            ~BackingBuffer()
            {
                if(harb.IsAllocated)
                    harb.Free();
            }

            public byte[] Buffer
            {
                get
                {
                    return arb;
                }
            }

            public unsafe byte* Pointer
            {
                get
                {
                    byte* parbx = (byte*) (void*) parb;
                    GC.KeepAlive(this);     // per FxCop, not sure if it's necessary
                    return parbx;
                }
            }

            public int BufferNumber
            {
                get
                {
                    return nBuffer;
                }
            }

            // call while lock held on BackingBuffer
            public bool CanClaim
            {
                get
                {
                    return (lFree == null ? 0 : lFree.cb) >= s_cbOptimalSize;
                }
            }

            // call while lock held on BackingBuffer
            public void TryClaim()
            {
                if(CanClaim && (s_pFirstOptimalBuffer.BufferNumber > nBuffer || s_fFirstOptimalUnclaimed))
                    lock(typeof(BackingBuffer))
                        if(CanClaim && (s_pFirstOptimalBuffer.BufferNumber > nBuffer || s_fFirstOptimalUnclaimed))
                        {
                            s_pFirstOptimalBuffer = this;
                            s_fFirstOptimalUnclaimed = false;
                        }
            }

            public PinnableBuffer TryGetBuffer(int cb)
            {
                if(!Monitor.TryEnter(this))
                    return null;

                try
                {
                    if(lFree == null || lFree.Length < cb)
                        return null;

                    try
                    {
                        if (ProtocolConnectionBase.s_fCountersInitialized)
                        {
                            ProtocolConnectionCounters.Total.FreeBytes.IncrementBy(-cb);
                        }
                    }
                    catch
                    {
                        // ignore if counters are not installed
                        ProtocolConnectionBase.s_fCountersInitialized = false;
                    }

                    PinnableBuffer oPB;
                    if(lFree.cb == cb)
                    {
                        oPB = lFree;
                        lFree = lFree.pNextFree;
                        if(lFree != null)
                            lFree.pPrevFree = null;
                        oPB.pNextFree = null;
                    }
                    else
                    {
                        oPB = new PinnableBuffer(this, lFree.i + lFree.cb - cb, cb);
                        oPB.pPrev = lFree;
                        oPB.pNext = lFree.pNext;
                        lFree.pNext = oPB;
                        if(oPB.pNext != null)
                            oPB.pNext.pPrev = oPB;
                        lFree.cb -= cb;
                    }
                    oPB.fAllocated = true;

                    AdjustInFree(lFree);

                    if(object.ReferenceEquals(this, s_pFirstOptimalBuffer) && !s_fFirstOptimalUnclaimed && !CanClaim)
                        lock(typeof(BackingBuffer))
                            if(object.ReferenceEquals(this, s_pFirstOptimalBuffer))
                                s_fFirstOptimalUnclaimed = true;

                    TryClaim();

                    return oPB;
                }
                finally
                {
                    Monitor.Exit(this);
                }
            }

            // call while BackingBuffer is locked
            public void AdjustInFree(PinnableBuffer oPB)
            {
                if(oPB == null)
                    return;

                if(oPB.cb == 0 || (oPB.pPrevFree != null && oPB.pPrevFree.cb < oPB.cb) || (oPB.pNextFree != null && oPB.pNextFree.cb > oPB.cb))
                {
                    if(oPB.pPrevFree == null)
                        lFree = oPB.pNextFree;
                    else
                        oPB.pPrevFree.pNextFree = oPB.pNextFree;
                    if(oPB.pNextFree != null)
                        oPB.pNextFree.pPrevFree = oPB.pPrevFree;
                }
                else
                    return;

                if(oPB.cb == 0)
                    return;

                PinnableBuffer pCur = oPB;
                while(pCur.pPrevFree != null && pCur.pPrevFree.cb < oPB.cb)
                    pCur = pCur.pPrevFree;
                if(!object.ReferenceEquals(oPB, pCur))
                {
                    oPB.pPrevFree = pCur.pPrevFree;
                    oPB.pNextFree = pCur;

                    if(oPB.pPrevFree == null)
                        lFree = oPB;
                    else
                        oPB.pPrevFree.pNextFree = oPB;
                    oPB.pNextFree.pPrevFree = oPB;

                    return;
                }

                while(pCur.pNextFree != null && pCur.pNextFree.cb > oPB.cb)
                    pCur = pCur.pNextFree;
                if(!object.ReferenceEquals(oPB, pCur))
                {
                    oPB.pPrevFree = pCur;
                    oPB.pNextFree = pCur.pNextFree;

                    if(oPB.pNextFree != null)
                        oPB.pNextFree.pPrevFree = oPB;
                    oPB.pPrevFree.pNextFree = oPB;

                    return;
                }

                throw new InvalidOperationException("Corruption in the BackingBuffer freelist.");
            }

            // call while BackingBuffer is locked
            public void AddToFree(PinnableBuffer oPB)
            {
                if(oPB == null || oPB.cb == 0)
                    return;

                if(oPB.pNextFree != null || oPB.pPrevFree != null)
                    throw new InvalidOperationException("Buffer double-freed.");

                if(lFree == null || lFree.cb <= oPB.cb)
                {
                    oPB.pNextFree = lFree;
                    lFree = oPB;
                    if(oPB.pNextFree != null)
                        oPB.pNextFree.pPrevFree = oPB;
                    return;
                }

                PinnableBuffer pCur = lFree;
                while(pCur.pNextFree != null && pCur.pNextFree.cb > oPB.cb)
                    pCur = pCur.pNextFree;
                oPB.pPrevFree = pCur;
                oPB.pNextFree = pCur.pNextFree;

                if(oPB.pNextFree != null)
                    oPB.pNextFree.pPrevFree = oPB;
                oPB.pPrevFree.pNextFree = oPB;
            }

            public BackingBuffer Next
            {
                get
                {
                    if(pNext != null)
                        return pNext;

                    lock(syNext)
                    {
                        if(pNext == null)
                            pNext = new BackingBuffer(this);
                    }

                    return pNext;
                }
            }


            private readonly byte[] arb;
            private GCHandle harb;
            private IntPtr parb;

            private readonly int nBuffer;
            private PinnableBuffer lFree;

            private BackingBuffer pNext;
            private readonly object syNext;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\XConnSrv\PNUsersBuilder.cs ===
using System;
using System.Collections.Generic;
using System.Threading;
using System.Reflection;
using ServerTestFramework.LiveService.GI;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.UserAccount;
using xonline.common.diagnostics;
using xonline.common.protocol.SubNoti;

using xonline.common.community;
using xonline.common.service;

namespace ServerTestFramework.LiveService.XConnSrv
{
    /// <summary>
    /// A class to hold custom event info for when a user is created within the PNUsers Builder
    /// </summary>
    public class PNUserCreationEventArgs : EventArgs
    {
        private PNUser user;

        public PNUserCreationEventArgs(PNUser u)
        {
            user = u;
        }

        public PNUser User
        {
            get { return user; }
            set { user = value; }
        }
    }

    /// <summary>
    /// 
    /// This class is used to create PNUsers with different options including: friend/peer status, online/offline, same/remote console, and presence privacy settings.
    /// 
    /// Sample usage:
    ///
    ///     // Create a single user
    ///     PNUser[] users = PNUsersBuilder.GetLiveXenonUsers(1, true, true);
    ///
    ///     // Create users
    ///     PNUsersBuilder pnub = new PNUsersBuilder();
    ///     pnub.Online_Friends = 5;
    ///     pnub.Offline_Friends_PrivFriends = 2;
    ///     pnub.Online_Peers_SameConsole_PrivBlocked = 1
    ///     pnub.CreateUsers(users);
    ///     
    ///     // To access your newly created users
    ///     PNUser[] friends = pnub.Friends;
    ///     PNUser[] peers = pnub.Peers;
    ///     
    /// </summary>
    public class PNUsersBuilder
    {
        // Settings representing all user relationship, location, and privacy options to be created with CreateSubscribees
        public uint Online_Friends = 0;
        public uint Online_Friends_PrivBlocked = 0;
        public uint Online_Friends_PrivFriends = 0;
        public uint Online_Friends_SameConsole = 0;
        public uint Online_Friends_SameConsole_PrivBlocked = 0;
        public uint Online_Friends_SameConsole_PrivFriends = 0;

        public uint Online_Peers = 0;
        public uint Online_Peers_PrivBlocked = 0;
        public uint Online_Peers_PrivFriends = 0;
        public uint Online_Peers_SameConsole = 0;
        public uint Online_Peers_SameConsole_PrivBlocked = 0;
        public uint Online_Peers_SameConsole_PrivFriends = 0;

        public uint Offline_Friends = 0;
        public uint Offline_Friends_PrivBlocked = 0;
        public uint Offline_Friends_PrivFriends = 0;
        public uint Offline_Friends_SameConsole = 0;
        public uint Offline_Friends_SameConsole_PrivBlocked = 0;
        public uint Offline_Friends_SameConsole_PrivFriends = 0;

        public uint Offline_Peers = 0;
        public uint Offline_Peers_PrivBlocked = 0;
        public uint Offline_Peers_PrivFriends = 0;
        public uint Offline_Peers_SameConsole = 0;
        public uint Offline_Peers_SameConsole_PrivBlocked = 0;
        public uint Offline_Peers_SameConsole_PrivFriends = 0;

        public class PNUserDetails
        {
            public ulong UserId;
            public int PrivacySetting;
        }

        // List to hold all subscribees
        public List<PNUserDetails> AllCreatedUsers = new List<PNUserDetails>();

        // Lists to store the newly created users by type, so they can be received later if wished for
        private List<PNUser> FriendsPNUserList = new List<PNUser>();
        private List<PNUser> PeersPNUserList = new List<PNUser>();

        // Event declaration
        public event EventHandler<PNUserCreationEventArgs> PNUserCreationEvent;

        #region USER CREATION

        /// <summary>
        /// Creates real Live Xenon users (with presence privacy set to Everyone)
        /// </summary>
        public static PNUser[] GetLiveXenonUsers(uint numUsers, bool alive, bool onSameConsole)
        {
            return GetLiveXenonUsers(numUsers, alive, onSameConsole, CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE);
        }

        /// <summary>
        /// Creates real Live Xenon users with the given privacy
        /// </summary>
        public static PNUser[] GetLiveXenonUsers(uint numUsers, bool alive, bool onSameConsole, int privacy)
        {
            return GetLiveXenonUsers(numUsers, alive, onSameConsole, privacy, true);
        }

        /// <summary>
        /// Creates real Live Xenon users with the given settings
        /// </summary>
        public static PNUser[] GetLiveXenonUsers(uint numUsers, bool alive, bool onSameConsole, int privacy, bool autoProcessNotifications)
        {
            FriendsCommon fc = new FriendsCommon();
            PNUser[] users = fc.CreateXenonUsers(numUsers, false);

            //Get all users on same xbox.
            if (onSameConsole)
            {
                PNXbox box = new PNXbox(autoProcessNotifications);
                for (int i = 0; i < users.Length; i++)
                {
                    users[i].Xbox = box;
                    fc.LogonUser(users[i]);
                }
            }
            else
            {
                for (int i = 0; i < users.Length; i++)
                {
                    PNXbox box = new PNXbox(autoProcessNotifications);
                    users[i].Xbox = box;
                    fc.LogonUser(users[i]);
                }
            }

            // Set privacy, ignore if it is the default
            if (privacy != CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE)
            {
                for (int i = 0; i < users.Length; ++i)
                {
                    SetPrivacy(users[i], privacy);
                    fc.LogoffUser(users[i]);
                    fc.LogonUser(users[i]);
                }
            }

            if (!alive)
            {
                for (int i = 0; i < users.Length; i++)
                {
                    fc.LogoffUser(users[i]);
                }

            }
            Global.RO.Info("Created " + numUsers.ToString() + " as required.");
            return users;
        }

        /// <summary>
        /// Changes the privacy of the given user in the database
        /// </summary>
        public static void SetPrivacy(PNUser user, int privacy)
        {
            if (privacy == 0) // Blocked
            {
                SetPrivilege(user, XOn.XPRIVILEGE_PRESENCE, false);
                SetPrivilege(user, XOn.XPRIVILEGE_PRESENCE_FRIENDS_ONLY, false);
            }
            else if (privacy == CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE)
            {
                SetPrivilege(user, XOn.XPRIVILEGE_PRESENCE, true);
                SetPrivilege(user, XOn.XPRIVILEGE_PRESENCE_FRIENDS_ONLY, true);
            }
            else if (privacy == CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS)
            {
                SetPrivilege(user, XOn.XPRIVILEGE_PRESENCE, false);
                SetPrivilege(user, XOn.XPRIVILEGE_PRESENCE_FRIENDS_ONLY, true);
            }
        }

        /// <summary>
        /// Actually sets the privileges for the user
        /// </summary>
        private static void SetPrivilege(PNUser user, uint priv, bool grant)
        {
            // Create a grant request
            XRLXeUpdateParentalControls request = new XRLXeUpdateParentalControls();
            request.UserPuid = user.UserId;
            request.Source = "STF-PRES-FPC";

            ServerTestFramework.LiveService.UserAccount.UserPrivileges grants = new ServerTestFramework.LiveService.UserAccount.UserPrivileges();
            ServerTestFramework.LiveService.UserAccount.UserPrivileges restrictions = new ServerTestFramework.LiveService.UserAccount.UserPrivileges();

            // Populate the new requested privilege
            if (grant)
            {
                grants[(int)priv] = true;
            }
            else
            {
                restrictions[(int)priv] = true;
            }

            request.UserGrantPrivileges = grants.ToArray();
            request.UserRestrictPrivileges = restrictions.ToArray();
            request.ExecuteSafe();

            Thread.Sleep(5000);
        }

        /// <summary>
        /// Event to be triggered when a user is created
        /// </summary>
        protected virtual void OnPNUserCreationEvent(PNUserCreationEventArgs e)
        {
            // Make a temporary copy of the event to avoid possibility of
            // a race condition if the last subscriber unsubscribes
            // immediately after the null check and before the event is raised.
            EventHandler<PNUserCreationEventArgs> handler = PNUserCreationEvent;

            // Event will be null if there are no subscribers
            if (handler != null)
            {
                // Use the () operator to raise the event.
                handler(this, e);
            }
        }

        #endregion // USER CREATION

        #region SUBSCRIBEE RETRIEVAL

        /// <summary>
        /// Gets the list of friends created
        /// </summary>
        public PNUser[] Friends
        {
            get
            {
                return FriendsPNUserList.ToArray();
            }
        }

        /// <summary>
        /// Get the list of peers created
        /// </summary>
        public PNUser[] Peers
        {
            get
            {
                return PeersPNUserList.ToArray();
            }
        }

        /// <summary>
        /// Gets a specific friend subscribee based on their User Id
        /// </summary>
        public PNUser GetFriend(ulong userId)
        {
            foreach (PNUser user in FriendsPNUserList)
            {
                if (user.UserId == userId)
                    return user;
            }

            return null;
        }

        /// <summary>
        /// Gets a specific peer subscribee based on their User Id
        /// </summary>
        public PNUser GetPeer(ulong userId)
        {
            foreach (PNUser user in PeersPNUserList)
            {
                if (user.UserId == userId)
                    return user;
            }

            return null;
        }

        #endregion // SUBSCRIBEE RETRIEVAL

        #region CREATE/ADD SUBSCRIBEES

        /// <summary>
        /// Create all users who will be subscribed to, with no subscribers
        /// </summary>
        public void CreateUsers()
        {
            CreateUsers(new PNUser[] { });
        }

        /// <summary>
        /// Create all users who will be subscribed to, with a single subscriber
        /// </summary>
        public void CreateUsers(PNUser friend)
        {
            CreateUsers(new PNUser[] { friend });
        }

        /// <summary>
        /// Create all users who will be subscribed to, with multiple subscribers
        /// </summary>
        public void CreateUsers(PNUser[] friends)
        {
            PNUser[] users = null;
            FriendsCommon fc = new FriendsCommon();

            Type t = this.GetType();
            MemberInfo[] ms = t.GetMembers();
            FieldInfo[] fi = t.GetFields(BindingFlags.Public | BindingFlags.Instance);

            foreach (FieldInfo f in fi)
            {
                if (f.FieldType.FullName == "System.UInt32" && uint.Parse(f.GetValue(this).ToString()) != 0)
                {
                    bool online = f.Name.StartsWith("Online");
                    bool friend = !f.Name.Contains("Peers");
                    bool sameconsole = f.Name.Contains("SameConsole");
                    bool blocked = f.Name.Contains("PrivBlocked");
                    bool friendsonly = f.Name.Contains("PrivFriends");

                    int privsetting = CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE; //DEFAULT IS OPEN 

                    if (blocked)
                        privsetting = 0; //BLOCKED

                    if (friendsonly)
                        privsetting = CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS;

                    users = GetLiveXenonUsers(uint.Parse(f.GetValue(this).ToString()), online, sameconsole, privsetting, false);

                    foreach (PNUser user in users)
                    {
                        if (friend)
                        {
                            Assert.IsTrue(friends.Length > 0, "CreateSubscribees: Friends were requested to be made, but no subscribers were given to make friends with.");

                            // Make friends with the subscribers
                            foreach (PNUser fr in friends)
                            {
                                fc.MakeFriend(fr, user);
                            }
                            FriendsPNUserList.Add(user);
                        }
                        else
                            PeersPNUserList.Add(user);

                        PNUserDetails sd = new PNUserDetails();
                        sd.UserId = user.UserId;
                        sd.PrivacySetting = privsetting;
                        AllCreatedUsers.Add(sd);


                        // TODO: Insert Creation Event HERE
                        OnPNUserCreationEvent(new PNUserCreationEventArgs(user));
                    }
                }
            }
        }

        #endregion // CREATE/ADD SUBSCRIBEES
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\XConnSrv\ConnectionSrv.cs ===
using System;
using System.Net;
using System.Net.Sockets;
using System.Xml.Serialization;
using System.Collections;
using System.IO;
using System.Reflection;
using System.Text;
using System.Threading;

using xonline.common.protocol.SubNoti;
using xonline.common.config;

namespace ServerTestFramework.LiveService.XConnSrv
{
    public class ConnSrvMessageAsyncResult : IAsyncResult
    {
        public ConnSrvMessageAsyncResult(AsyncCallback fn, uint sequenceNum, ConnSrvConnection connection)
        {
            _fn = fn;
            _seqNum = sequenceNum;
            _connection = connection;
        }

        public object AsyncState
        {
            get
            {
                return _response;
            }
        }

        public WaitHandle AsyncWaitHandle
        {
            get
            {
                return _sy;
            }
        }

        public void Wait(int msTimeOut)
        {
            if (!AsyncWaitHandle.WaitOne(msTimeOut, true))
            {
                TimeOut();
            }
        }

        public void TimeOut()
        {
            _fTimedOut = true;
            _connection.TimeOut(this);
        }

        public void Complete(object state)
        {
            try
            {
                _response = state;
                if (_fn != null)
                {
                    _fn(this);
                }
                _fComplete = true;
            }
            catch (Exception ex)
            {
                _ex = ex;
            }
            finally
            {
                _sy.Set();
            }

        }

        public bool CompletedSynchronously
        {
            get
            {
                return false;
            }
        }

        public bool IsCompleted
        {
            get
            {
                return _fComplete;
            }
        }

        public bool TimedOut
        {
            get
            {
                return _fTimedOut;
            }
        }

        public uint SeqNum
        {
            get
            {
                return _seqNum;
            }
        }

        public Exception Error
        {
            get
            {
                return _ex;
            }
        }

        private object _response;
        private readonly AsyncCallback _fn;
        private readonly uint _seqNum;
        private readonly ConnSrvConnection _connection;
        private bool _fTimedOut = false;
        private ManualResetEvent _sy = new ManualResetEvent(false);
        private bool _fComplete;
        private Exception _ex;
    }

    public class ConnSrvRandomMessageSendContext : ProtocolConnectionBase.SendContextBase
    {
        public override byte[] Buffer
        {
            get
            {
                Random random = new Random();
                int messageLength = random.Next(50, 100);
                byte[] message = new byte[messageLength];
                byte[] entireMessage = new byte[28 + messageLength];
                _length = 28 + messageLength;
                _header.dwTotalSize = (uint)_length;
                unsafe
                {
                    fixed (BASE_MESSAGE_HEADER* pHeader = &_header)
                    {
                        byte* pbHeader = (byte*)pHeader;
                        for (int curByte = 0; curByte < messageLength; curByte++)
                        {
                            entireMessage[curByte] = *pbHeader;
                            pbHeader++;
                        }

                    }
                }
                random.NextBytes(message);
                message.CopyTo(entireMessage, 28);
                return entireMessage;
            }
        }

        public override int Length
        {
            get
            {
                return _length;
            }
        }

        private BASE_MESSAGE_HEADER _header;
        private int _length;
    }

    public class ConnSrvMessageSendContext : ProtocolConnectionBase.SendContextBase
    {
        private readonly byte[] _arb;

        public ConnSrvMessageSendContext(byte[] message)
        {
            _arb = message;
        }

        public override byte[] Buffer
        {
            get
            {
                return _arb;
            }
        }

        public override int Length
        {
            get
            {
                return _arb.Length;
            }
        }

        public override uint SeqNum
        {
            set
            {
                unsafe
                {
                    fixed (byte* pMessage = &_arb[0])
                    {
                        CONNECT_MESSAGE* pConnect = (CONNECT_MESSAGE*)pMessage;
                        pConnect->header.dwSeqNum = value;
                    }
                }
            }
        }
    }

    public class ConnSrvMessageParser : ProtocolSequence
    {
        public ConnSrvMessageParser(IProtocol pParent)
            :
            base(pParent)
        {
            SetProtocols(new IProtocol[] {
                                                     new FixedLengthByteArrayParser(this, c_HEADER_LENGTH),
                                                     new ContentParser(this)
                                                     }
                                                     );

            Anchor = true;
        }

        private bool VerifyHeader()
        {
            byte[] Buffer = Data[0] as byte[];
            if (Buffer == null || Buffer.Length != c_HEADER_LENGTH)
                return false;

            unsafe
            {
                fixed (byte* pBytes = &Header[0])
                {
                    BASE_MESSAGE_HEADER* pHeader = (BASE_MESSAGE_HEADER*)pBytes;
                    _header = *pHeader;
                }
            }
            if (_header.dwTotalSize == 0 || _header.dwSeqNum == 0 || _header.dwProtocolVersion != SubNotiDefs.CURRENT_PROTOCOL_VERSION)
            {
                return false;
            }
            return true;
        }

        public byte[] Header
        {
            get
            {
                return (byte[])Data[0];
            }
        }

        public byte[] Content
        {
            get
            {
                return (byte[])Data[1];
            }
        }

        public uint Length
        {
            get
            {
                return _header.dwTotalSize;
            }
        }

        public uint SeqNum
        {
            get
            {
                return _header.dwSeqNum;
            }
        }

        public BASE_MESSAGE_HEADER ParsedHeader
        {
            get
            {
                return _header;
            }
        }

        public bool IsNotification()
        {
            return _header.dwMessageType >= SubNotiDefs.MIN_NOTIFICATION_TYPE && _header.dwMessageType <= SubNotiDefs.MAX_NOTIFICATION_TYPE;
        }

        public bool IsReply()
        {
            return _header.dwMessageType >= SubNotiDefs.MIN_REPLY_TYPE && _header.dwMessageType <= SubNotiDefs.MAX_REPLY_TYPE;
        }

        private class ContentParser :
             PartialBufferProtocol
        {
            public ContentParser(ConnSrvMessageParser pParent)
                : base(pParent)
            {
                _pParent = pParent;
                fFirstByte = true;
            }

            public unsafe override BufferProtocol Consume(ref byte* parbIn, ref uint cbIn)
            {
                if (fFirstByte)
                {
                    if (!_pParent.VerifyHeader())
                        return null;
                    cbExpected = _pParent.Length - c_HEADER_LENGTH;
                    acbs = new byte[cbExpected];
                    fFirstByte = false;
                }

                if (acbs == null)
                    return null;

                bool fDone = false;
                fixed (byte* pacbsx = &acbs[acccb])
                {
                    byte* pacbs = pacbsx;
                    while (cbIn > 0)
                    {
                        cbIn--;
                        *(pacbs++) = *(parbIn++);
                        acccb++;
                        if (acccb >= cbExpected)
                        {
                            fDone = true;
                            break;
                        }
                    }
                }

                if (fDone)
                {
                    byte[] buffer = acbs;
                    acbs = null;
                    return (BufferProtocol)Chain(buffer);
                }

                return this;
            }

            protected override void OnReset()
            {
                acccb = 0;
                fFirstByte = true;
            }

            private bool fFirstByte;
            private byte[] acbs;
            private int acccb;
            private uint cbExpected;
            private ConnSrvMessageParser _pParent;
        }

        private BASE_MESSAGE_HEADER _header;
        private const int c_HEADER_LENGTH = 24;
    }

    public class ConnSrv
    {
        private static Hashtable hashZTSockets;

        static ConnSrv() 
        {
            hashZTSockets = new Hashtable();
        }

        private ConnSrv() { }

        public static void CreateInstance(string sName, string sHost, int nPort)
        {
            ConnSrv requestedZTSocket = (ConnSrv)hashZTSockets[sName.ToLower()];
            if (requestedZTSocket == null)
            {
                lock (typeof(ConnSrv))
                {
                    requestedZTSocket = (ConnSrv)hashZTSockets[sName.ToLower()];
                    if (requestedZTSocket == null)
                    {
                        requestedZTSocket = new ConnSrv();
                        requestedZTSocket.Init(sHost, nPort);
                        hashZTSockets.Add(sName.ToLower(), requestedZTSocket);
                    }
                }
            }
        }

        public static ConnSrv Lookup(string sHost)
        {
            if (!hashZTSockets.ContainsKey(sHost.ToLower())){
                //IVirtualInterfaceInfo ivii = Config.GetVirtualInterface(VirtualInterface.XConnSrv);
                System.Net.IPEndPoint endPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.XConnSrv);
                CreateInstance(sHost, sHost, endPoint.Port);
            }
            return (ConnSrv)hashZTSockets[sHost.ToLower()];

        }

        private void Init(string sHost, int nPort)
        {
            if(sHost == null)
                throw new ArgumentNullException("sHost");
            if(sHost.Length == 0)
                throw new ArgumentException("The Host cannot be empty.", "sHost");
            if(nPort == 0)
                throw new ArgumentException("The Port cannot be zero.", "nPort");

            try
            {
                // is it an IPAddress?
                IPAddress addr = IPAddress.Parse(sHost);
                s_ep = new IPEndPoint(addr, nPort);
            }
            catch
            {
                // is it a server name?
                IPHostEntry oHost;
                try
                {
                    oHost = Dns.GetHostEntry(sHost);
                }
                catch (Exception ex)
                {
                    throw new InvalidOperationException("Error resolving ZTSockets hostname <" + sHost + ">.", ex);
                }
                if (oHost.AddressList.Length == 0)
                {
                    throw new InvalidOperationException("Nonexistant resolution for ZTSockets hostname <" + sHost + ">.");
                }

                foreach (IPAddress addr in oHost.AddressList)
                {
                    if (addr.AddressFamily == AddressFamily.InterNetwork)
                    {
                        s_ep = new IPEndPoint(addr, nPort);
                        break;
                    }
                }
            }
            if (s_ep == null)
            {
                throw new InvalidOperationException("Nonexistant resolution for ZTSockets hostname <" + sHost + ">.");
            }
        }

        public ConnSrvConnection CreateInstance()
        {
            //Creates the Socket for sending data over TCP.
            Socket s = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp );
    
            // Connects to the host using IPEndPoint.
            s.Connect(s_ep);
            if (!s.Connected)
            {
                throw new InvalidOperationException("Unable to connect to host");
            }
            else
            {
                // set up the socket options
                s.Blocking = false;
                s.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.SendBuffer, 0);
                s.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveBuffer, 0);
            }

            return new ConnSrvConnection(s);
        }

        private IPEndPoint s_ep;
    }

    public class ConnSrvConnection : ProtocolConnectionBase
    {
        public ConnSrvConnection(Socket sk)
            :
            base(sk)
        {
            pCurrentParser = new ConnSrvMessageParser(this);
            _Sending = 0;
        }

        public override IProtocol Current
        {
            get
            {
                return pCurrentParser;
            }
        }

        protected override void OnClose(object oSender, EventArgs oArgs)
        {
            base.OnClose(oSender, oArgs);
            lock (_waitTable.SyncRoot)
            {
                // find it on the wait queue and invoke the callback
                foreach (ConnSrvMessageAsyncResult connSrvAsy in _waitTable)
                {
                    connSrvAsy.Complete(null);
                }
            }
        }

        protected override void OnInit(ref int cReceiveBuffers, ref int cbBytesPerReceive)
        {
            cReceiveBuffers = 5;
            //cbBytesPerReceive = 800;
        }

        protected override void OnSendComplete(ISendContext pctxt, bool fComplete)
        {
            // should queue up items to send and send them in order
            lock (_sendQueue.SyncRoot)
            {
                if (_sendQueue.Count != 0)
                {
                    ISendContext ctxt = _sendQueue.Dequeue() as ISendContext;
                    PostSend(ctxt);
                }
                else
                {
                    Interlocked.Exchange(ref _Sending, 0);
                }
            }

        }

        public IAsyncResult Send(ISendContext pctxt, AsyncCallback fn)
        {
            int sending = Interlocked.Exchange(ref _Sending, 1);
            uint seqNum = (uint)Interlocked.Increment(ref nSeq);
            ConnSrvMessageAsyncResult asy = new ConnSrvMessageAsyncResult(fn, seqNum, this);
            pctxt.SeqNum = seqNum;
            
            // add to a response queue
            lock (_waitTable.SyncRoot)
            {
                _waitTable.Add(asy);
            }

            if (sending == 0)
            {
                // Send the request
                PostSend(pctxt);
            }
            else
            {
                _sendQueue.Enqueue(pctxt);
            }
            return asy;
        }

        // Main protocol handling path.
        public override IProtocol Consume(object oIn)
        {
            ConnSrvMessageParser connSrvMessage = oIn as ConnSrvMessageParser;
            if (connSrvMessage != null)
            {
                if (connSrvMessage.IsNotification())
                {
                    DATA_NOTIFICATION notification = ParseMessage(connSrvMessage) as DATA_NOTIFICATION;
                    if (notification != null)
                    {
                        OnNotification(notification);
                    }
                }
                else if (connSrvMessage.IsReply())
                {
                    ConnSrvMessageAsyncResult request = null;
                    lock (_waitTable.SyncRoot)
                    {
                        // find it on the wait queue and invoke the callback
                        foreach (ConnSrvMessageAsyncResult connSrvAsy in _waitTable)
                        {
                            if (connSrvAsy.SeqNum == connSrvMessage.SeqNum)
                            {
                                request = connSrvAsy;
                                break;
                            }
                        }
                        if (request != null)
                        {
                            _waitTable.Remove(request);
                        }
                    }
                    if (request != null)
                    {
                        request.Complete(ParseMessage(connSrvMessage));
                    }
                }
                else
                {
                    // what is it?
                }
            }

            //ConnSrvRandomMessageSendContext message = new ConnSrvRandomMessageSendContext();
            //PostSend(message);
            Current.Reset();
            return this;
        }

        public void TimeOut(ConnSrvMessageAsyncResult request)
        {
            bool fFound = false;
            lock (_waitTable.SyncRoot)
            {
                // find it on the wait queue and invoke the callback
                foreach (ConnSrvMessageAsyncResult connSrvAsy in _waitTable)
                {
                    if (connSrvAsy.SeqNum == request.SeqNum)
                    {
                        fFound = true;
                        break;
                    }
                }
                if (fFound)
                {
                    _waitTable.Remove(request);
                }
            }
            if (request != null)
            {
                request.Complete(null);
            }
        }

        private object ParseMessage(ConnSrvMessageParser message)
        {
            object response = null;
            switch (message.ParsedHeader.dwMessageType)
            {
                case (uint)MESSAGE_TYPES.eConnectReply:
                    {
                        CONNECT_REPLY connectReply = new CONNECT_REPLY();
                        response = connectReply.ReadBytes(message.Content);
                        break;
                    }
                case (uint)MESSAGE_TYPES.eDisconnectReply:
                    {
                        DISCONNECT_REPLY disconnectReply = new DISCONNECT_REPLY();
                        response = disconnectReply.ReadBytes(message.Content);
                        break;
                    }
                case (uint)MESSAGE_TYPES.eSubscribeReply:
                    {
                        SUBSCRIBE_REPLY subscribeReply = new SUBSCRIBE_REPLY();
                        response = subscribeReply.ReadBytes(message.Content);
                        subscribeReply.header = message.ParsedHeader;
                        break;
                    }
                case (uint)MESSAGE_TYPES.eUnsubscribeReply:
                    {
                        UNSUBSCRIBE_REPLY unsubscribeReply = new UNSUBSCRIBE_REPLY();
                        response = unsubscribeReply.ReadBytes(message.Content);
                        unsubscribeReply.header = message.ParsedHeader;
                        break;
                    }
                case (uint)MESSAGE_TYPES.eQueryReply:
                    {
                        QUERY_REPLY queryReply = new QUERY_REPLY();
                        response = queryReply.ReadBytes(message.Content);
                        break;
                    }
                case (uint)MESSAGE_TYPES.ePublishReply:
                    {
                        PUBLISH_REPLY publishReply = new PUBLISH_REPLY();
                        response = publishReply.ReadBytes(message.Content);
                        break;
                    }
                case (uint)MESSAGE_TYPES.eDataNotification:
                    {
                        DATA_NOTIFICATION dataNotification = new DATA_NOTIFICATION();
                        response = dataNotification.ReadBytes(message.Content);
                        dataNotification.header = message.ParsedHeader;
                        break;

                    }
            }
            return response;
        }

        // Events and supporting classes

        public event NotifiedEventHandler Notified;

        public delegate void NotifiedEventHandler(object oSender, NotifiedEventArgs oArgs);

        public class NotifiedEventArgs :
            EventArgs
        {
            public NotifiedEventArgs(object oIn)
            {
                this.oIn = oIn;
            }

            public object In
            {
                get
                {
                    return oIn;
                }
            }

            private readonly object oIn;
        }

        private void OnNotification(DATA_NOTIFICATION notification)
        {
            if (Notified != null)
            {
                Notified(this, new NotifiedEventArgs(notification));
            }
        }

        private int nSeq;
        private int _Sending;
        private IProtocol pCurrentParser;
        private ArrayList _waitTable = new ArrayList();
        private Queue _sendQueue = Queue.Synchronized(new Queue());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\XConnSrv\ProtocolConnection.cs ===
using System;
using System.Net;
using System.Net.Sockets;
using System.Diagnostics;
using System.Threading;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Collections;
using System.Globalization;

using xonline.common.mgmt;

namespace ServerTestFramework.LiveService.XConnSrv
{
    public interface IConnectionHandler
    {
        void Init(object ki);
        object Context { get; }

        void Close();
        event EventHandler Closed;
    }

    public interface IProtocol
    {
        IProtocol Consume(object oIn);
        IProtocol Current { get; }
        void Reset();
        bool Anchor { get; set; }
    }

    public sealed class UnhandledExceptionVortex
    {
        private UnhandledExceptionVortex() { }


        public static void CatchFrame(CatchCallback fn)
        {
            try
            {
                fn();
            }
            catch (Exception e)
            {
                if (UnhandledException != null)
                    UnhandledException(fn.Target, new UnhandledExceptionEventArgs(e, false));
                else
                    throw;
            }
        }

        public static void CatchAsyncFrame(AsyncCallback fn, IAsyncResult sy)
        {
            try
            {
                fn(sy);
            }
            catch (Exception e)
            {
                if (UnhandledException != null)
                    UnhandledException(fn.Target, new UnhandledExceptionEventArgs(e, false));
                else
                    throw;
            }
        }

        public static void CatchEventFrame(EventHandler fn, object oSender, EventArgs ev)
        {
            try
            {
                fn(oSender, ev);
            }
            catch (Exception e)
            {
                if (UnhandledException != null)
                    UnhandledException(fn.Target, new UnhandledExceptionEventArgs(e, false));
                else
                    throw;
            }
        }

        public static event UnhandledExceptionEventHandler UnhandledException;

        public delegate void CatchCallback();
    }

    public class ParserBase
    {
        public ParserBase(IProtocol pParent)
        {
            if (pParent == null)
                throw new ArgumentNullException("pParent");

            this.pParent = pParent;
        }

        protected ParserBase()
        {
            this.pParent = (IProtocol)this;
        }


        public void Reset()
        {
            if (fResetting)
                return;

            fResetting = true;
            OnReset();
            if (!pParent.Anchor)
                pParent.Reset();
            fResetting = false;
        }

        public bool Anchor
        {
            get
            {
                return fAnchor;
            }

            set
            {
                fAnchor = value;
            }
        }

        public virtual IProtocol Current
        {
            get
            {
                if (fAnchor)
                    return null;

                IProtocol protox = pParent.Current;
                return protox == null || object.ReferenceEquals(protox, this) ? null : protox;
            }
        }

        protected virtual void OnReset() { }

        protected IProtocol Chain(object oRes)
        {
            OnReset();
            pParent = pParent.Consume(oRes);

            if (pParent == null)
                return null;
            if (!fAnchor)
                return (IProtocol)this;
            IProtocol pNew = pParent.Current;
            return pNew == null ? (IProtocol)this : pNew;
        }

        protected IProtocol FindRoot(IProtocol proto)
        {
            IProtocol pLast = null;
            while (proto != null)
            {
                pLast = proto;
                proto = proto.Current;
            }
            return pLast;
        }

        protected IProtocol pParent;

        private bool fAnchor;
        private bool fResetting;
    }

    public abstract class BufferProtocol :
    ParserBase,
    IProtocol
    {
        protected BufferProtocol(IProtocol pParent)
            :
            base(pParent)
        { }

        protected BufferProtocol() { }


        public unsafe abstract BufferProtocol Consume(byte* parbIn, uint cbIn);

        public BufferProtocol Consume(byte[] arbIn)
        {
            return Consume(arbIn, arbIn.Length);
        }

        public unsafe BufferProtocol Consume(byte[] arbIn, int cbIn)
        {
            // stackfix
            fixed (byte* parb = arbIn)
                return Consume(parb, (uint)cbIn);
        }

        IProtocol IProtocol.Consume(object oIn)
        {
            if (oIn.GetType() != typeof(byte[]))
            {
                Debug.WriteLine("Non-byte[] passed to BufferProtocol.", "ProtocolViolation");
                return null;
            }

            return Consume((byte[])oIn);
        }
    }

    public abstract class PartialBufferProtocol : BufferProtocol
    {
        protected PartialBufferProtocol(IProtocol pParent)
            :
            base(pParent)
        { }

        protected PartialBufferProtocol() { }


        public unsafe abstract BufferProtocol Consume(ref byte* parbIn, ref uint cbIn);

        public unsafe override BufferProtocol Consume(byte* parbIn, uint cbIn)
        {
            BufferProtocol protox = Consume(ref parbIn, ref cbIn);
            if (protox == null)
                return null;
            if (cbIn == 0 || parbIn == null)
                return protox;
            return protox.Consume(parbIn, cbIn);
        }
    }

    // simple parser copies bytes directly into a new buffer
    public class FixedLengthByteArrayParser :
        PartialBufferProtocol
    {
        public FixedLengthByteArrayParser(IProtocol pParent, int cbExpected)
            :
            base(pParent)
        {
            if (cbExpected <= 0)
                throw new ArgumentException("Expected byte array length cannot be negative or Zero.", "cbExpected");

            this.cbExpected = cbExpected;
            acbs = new byte[cbExpected];
            acccb = 0;
        }


        public unsafe override BufferProtocol Consume(ref byte* parbIn, ref uint cbIn)
        {
            bool fDone = false;
            fixed (byte* pacbsx = &acbs[acccb])
            {
                byte* pacbs = pacbsx;
                while (cbIn > 0)
                {
                    cbIn--;
                    *(pacbs++) = *(parbIn++);
                    acccb++;
                    if (acccb >= cbExpected)
                    {
                        fDone = true;
                        break;
                    }
                }
            }
            if (fDone)
                return (BufferProtocol)Chain(acbs);

            return this;
        }

        protected override void OnReset()
        {
            acccb = 0;
            acbs = new byte[cbExpected];
        }

        private byte[] acbs;
        private int acccb;
        private int cbExpected;
    }

    public class ProtocolSequence :
    ParserBase,
    IProtocol
    {
        public ProtocolSequence(IProtocol pParent)
            :
            base(pParent)
        {
            Anchor = true;
        }


        public void SetProtocols(IProtocol[] arproto)
        {
            if (arproto == null)
                throw new ArgumentNullException("arproto");
            if (this.arproto != null)
                throw new InvalidOperationException("SetProtocols() has already been called.");

            this.arproto = arproto;
            aro = new object[arproto.Length];

            for (int i = 0; i < arproto.Length; i++)
                arproto[i].Anchor = true;
        }

        public override IProtocol Current
        {
            get
            {
                IProtocol protox = pParent.Current;
                return protox == null || object.ReferenceEquals(protox, this) ? arproto[iCur] : FindRoot(protox);
            }
        }

        public IProtocol Consume(object oIn)
        {
            aro[iCur++] = oIn;
            if (iCur < aro.Length)
                return this;

            if (OnDone())
                return this;
            if (Chain(this) == null)
                return null;
            return this;
        }

        protected virtual bool OnDone()
        {
            return false;
        }

        protected override void OnReset()
        {
            if (iCur < arproto.Length)
                arproto[iCur].Reset();
            iCur = 0;
        }

        public object[] Data
        {
            get
            {
                return aro;
            }
        }


        private IProtocol[] arproto;
        private object[] aro;
        private int iCur;
    }

    public abstract class ProtocolConnectionBase :
        PartialBufferProtocol,
        IConnectionHandler,
        IProtocol
    {
        protected ProtocolConnectionBase(Socket sk)
        {
            try
            {
                if(s_fCountersInitialized)
                {
                    ProtocolConnectionCounters.Total.SocketsOpen.Increment();
                }
            }
            catch
            {
                // ignore if counters are not installed
                s_fCountersInitialized = false;
            }

            this.sk = sk;

            fnSendCallback = new AsyncCallback(SendCallback);
            fnSendCallbackEP = new AsyncCallback(SendCallbackEP);
            fnReceiveCallback = new AsyncCallback(ReceiveCallback);
            fnReceiveCallbackEP = new AsyncCallback(ReceiveCallbackEP);

            syClose = new ReaderWriterLock();
        }

        public void Init(object ki)
        {
            if(Interlocked.Increment(ref fInited) != 1)
                throw new InvalidOperationException("Init() has already been called.");
            if(fClosed)
                throw new ObjectDisposedException("Socket already closed when Init() called.");

            pProto = FindRoot(this) as BufferProtocol;
            if(pProto == null)
                throw new InvalidCastException("ProtocolConnectionBase must have a BufferProtocol as the root protocol.");

            this.ki = ki;

            cbBytesPerReceive = 1600;
            int cReceiveBuffers = 5;
            OnInit(ref cReceiveBuffers, ref cbBytesPerReceive);
            if(cbBytesPerReceive <= 0 || cReceiveBuffers < 2)
                throw new InvalidOperationException("Must have more than one buffer of at least one byte.");

            arctxtReceiveBuffers = new ReceiveContext[cReceiveBuffers];
            arbMasterReceiveBuffer = PinnableBuffer.Alloc(arctxtReceiveBuffers.Length * cbBytesPerReceive);
            weakMasterReceiveBuffer = GCHandle.Alloc(arbMasterReceiveBuffer, GCHandleType.Weak);
            iReceiveExpected = -1;
            cReceivesGoing = arctxtReceiveBuffers.Length;

            lock(arctxtReceiveBuffers)
            {
                for(int i = 0; i < arctxtReceiveBuffers.Length; i++)
                {
                    arctxtReceiveBuffers[i] = new ReceiveContext(i);
                    PostReceive(arctxtReceiveBuffers[i]);
                }
                iReceiveExpected = 0;
            }
        }

        protected virtual void OnInit(ref int cReceiveBuffers, ref int cbBytesPerReceive) { }


        public object Context
        {
            get
            {
                return ki;
            }
        }


        // Typically one or other Consume will be overridden.
        public unsafe override BufferProtocol Consume(ref byte* parbIn, ref uint cbIn)
        {
            return null;
        }

        // If this one is overridden, overridders should call the base in order to fire the event.
        public virtual IProtocol Consume(object oIn)
        {
            if(Consumed != null)
                Consumed(this, new ConsumedEventArgs(oIn));
            return null;
        }


        // Events and supporting classes

        public event ConsumedEventHandler Consumed;

        public delegate void ConsumedEventHandler(object oSender, ConsumedEventArgs oArgs);

        public class ConsumedEventArgs :
            EventArgs
        {
            public ConsumedEventArgs(object oIn)
            {
                this.oIn = oIn;
            }

            public object In
            {
                get
                {
                    return oIn;
                }
            }


            private readonly object oIn;
        }


        public event BytesReceivedEventHandler BytesReceived;

        public delegate void BytesReceivedEventHandler(object oSender, BytesReceivedEventArgs oArgs);

        public class BytesReceivedEventArgs :
            EventArgs
        {
            public BytesReceivedEventArgs(PinnableBuffer arbBuffer, int iOffset, int cbLength)
            {
                this.arbBuffer = arbBuffer;
                this.iOffset = iOffset;
                this.cbLength = cbLength;
            }

            public PinnableBuffer Buffer
            {
                get
                {
                    return arbBuffer;
                }
            }

            public int Offset
            {
                get
                {
                    return iOffset;
                }
            }

            public int Length
            {
                get
                {
                    return cbLength;
                }
            }


            private PinnableBuffer arbBuffer;
            private int iOffset;
            private int cbLength;
        }


        public event EventHandler Closed;

        public virtual void Close()
        {
            if(fClosed)
                return;

            syClose.AcquireWriterLock(-1);
            bool fWasClosed = fClosed;
            fClosed = true;
            try
            {
                if(!fWasClosed)
                    OnClose(this, new EventArgs());
            }
            finally
            {
                syClose.ReleaseWriterLock();
                if(!fWasClosed)
                {
                    try
                    {
                        if(s_fCountersInitialized)
                        {
                            ProtocolConnectionCounters.Total.SocketsOpen.Decrement();
                        }
                    }
                    catch
                    {
                        // ignore if counters are not installed
                        s_fCountersInitialized = false;
                    }
                    sk.Close();
                }
            }
        }

        protected virtual void OnClose(object oSender, EventArgs oArgs)
        {
            if(Closed != null)
                Closed(oSender, oArgs);
        }

        public bool Connected
        {
            get
            {
                return !fClosed;
            }
        }

        ~ProtocolConnectionBase()
        {
            try
            {
                if (s_fCountersInitialized)
                {
                    ProtocolConnectionCounters.Total.SocketsAbandoned.Increment();
                }
            }
            catch
            {
                // ignore if counters are not installed
                s_fCountersInitialized = false;
            }

            if(weakMasterReceiveBuffer.IsAllocated)
            {
                PinnableBuffer arb = (PinnableBuffer) weakMasterReceiveBuffer.Target;
                weakMasterReceiveBuffer.Free();

                if(arb != null)
                    arb.Free();
            }
            try
            {
                if(s_fCountersInitialized)
                {
                    if (!fClosed)
                        ProtocolConnectionCounters.Total.SocketsOpen.Decrement();
                }
            }
            catch
            {
                // ignore if counters are not installed
                s_fCountersInitialized = false;
            }
        }


        public Socket Socket
        {
            get
            {
                return sk;
            }
        }


        protected virtual void OnSendComplete(ISendContext ctxt, bool fSuccess) { }


        public interface ISendContext
        {
            byte[] Buffer { get; }
            int Sent { get; }
            int Length { get; }

            void JustSent(int cb);

            uint SeqNum { set;}
        }

        public abstract class SendContextBase :
            ISendContext
        {
            public abstract byte[] Buffer { get; }
            public abstract int Length { get; }

            public int Sent
            {   
                get
                {
                    return cbSent;
                }
            }

            public void JustSent(int cb)
            {
                if(cbSent + cb > Length)
                    throw new InvalidOperationException("More bytes sent than there are in the buffer.");

                cbSent += cb;
            }

            public virtual uint SeqNum
            {
                set{}
            } 

            protected int cbSent;
        }

        protected class SendContext :
            SendContextBase
        {
            protected SendContext() { }

            public SendContext(byte[] arb) :
                this(arb, 0, arb.Length)
            { }

            public SendContext(byte[] arb, int i, int cb)
            {
                this.arb = arb;
                this.cb = i + cb;
                cbSent = i;
            }

            public override byte[] Buffer
            {
                get
                {
                    return arb;
                }
            }

            public override int Length
            {
                get
                {
                    return cb;
                }
            }


            private byte[] arb;
            private int cb;
        }

        private class ReceiveContext
        {
            public ReceiveContext(int nOrder)
            {
                this.nOrder = nOrder;
            }

            public int nOrder;
            public int cbPending;
        }

        private void DoneReceiving(ReceiveContext ctxt)
        {
            if(ctxt.nOrder == -1)
                throw new InvalidOperationException("Receive buffer doubly-freed.");

            ctxt.nOrder = -1;
            int c = Interlocked.Decrement(ref cReceivesGoing);
            if(c == 0)
            {
                weakMasterReceiveBuffer.Free();
                arbMasterReceiveBuffer.Free();
                arbMasterReceiveBuffer = null;

                OnProtocolShutdown();

                GC.SuppressFinalize(this);
            }
        }

        protected virtual void OnProtocolShutdown() { }


        // helpers

        protected void Shutdown()
        {
            if(fClosed)
                return;

            syClose.AcquireReaderLock(-1);
            try
            {
                if(!fClosed)
                {
                    sk.Shutdown(SocketShutdown.Send);
                    try
                    {
                        if(s_fCountersInitialized)
                        {
                            ProtocolConnectionCounters.Total.SocketShutdown.Increment();
                        }
                    }
                    catch
                    {
                        // ignore if counters are not installed
                        s_fCountersInitialized = false;
                    }
                }
            }
            catch(SocketException)
            {
                syClose.ReleaseReaderLock();
                try
                {
                    if(s_fCountersInitialized)
                    {
                        ProtocolConnectionCounters.Total.SocketExceptions.Increment();
                    }
                }
                catch
                {
                    // ignore if counters are not installed
                    s_fCountersInitialized = false;
                }
                Close();
            }
            catch
            {
                syClose.ReleaseReaderLock();
                try
                {
                    Close();
                }
                catch { }
                throw;
            }
            syClose.ReleaseReaderLock();
        }

        private void PostReceive(ReceiveContext ctxt)
        {
            if(fClosed)
            {
                DoneReceiving(ctxt);
                return;
            }

            bool fWasClosed;
            syClose.AcquireReaderLock(-1);
            try
            {
                fWasClosed = fClosed;
                if(!fWasClosed)
                {
                    sk.BeginReceive(arbMasterReceiveBuffer.Buffer, arbMasterReceiveBuffer.Index + ctxt.nOrder * cbBytesPerReceive,
                        cbBytesPerReceive, SocketFlags.None, fnReceiveCallbackEP, ctxt);
                    try
                    {
                        if (s_fCountersInitialized)
                        {
                            ProtocolConnectionCounters.Total.ReadsPending.Increment();
                        }
                    }
                    catch
                    {
                        // ignore if counters are not installed
                        s_fCountersInitialized = false;
                    }
                }
            }
            catch(SocketException)
            {
                syClose.ReleaseReaderLock();
                try
                {
                    if (s_fCountersInitialized)
                    {
                        ProtocolConnectionCounters.Total.SocketExceptions.Increment();
                    }
                }
                catch
                {
                    // ignore if counters are not installed
                    s_fCountersInitialized = false;
                }
                Close();

                DoneReceiving(ctxt);

                return;
            }
            catch
            {
                syClose.ReleaseReaderLock();
                try
                {
                    Close();
                }
                catch { }
                try
                {
                    DoneReceiving(ctxt);
                }
                catch { }
                throw;
            }
            syClose.ReleaseReaderLock();

            if(fWasClosed)
                DoneReceiving(ctxt);
        }

        protected void PostSend(ISendContext pctxt)
        {
            if(fClosed)
            {
                OnSendComplete(pctxt, false);
                return;
            }

            bool fWasClosed;
            syClose.AcquireReaderLock(-1);
            try
            {
                fWasClosed = fClosed;
                if (!fWasClosed)
                {
                    sk.BeginSend(pctxt.Buffer, pctxt.Sent, pctxt.Length - pctxt.Sent, SocketFlags.None, fnSendCallbackEP, pctxt);
                    try
                    {
                        if (s_fCountersInitialized)
                        {
                            ProtocolConnectionCounters.Total.WritesPending.Increment();
                        }
                    }
                    catch
                    {
                        // ignore if counters are not installed
                        s_fCountersInitialized = false;
                    }                }
            }
            catch(SocketException)
            {
                syClose.ReleaseReaderLock();
                try
                {
                    if(s_fCountersInitialized)
                    {
                        ProtocolConnectionCounters.Total.SocketExceptions.Increment();
                    }
                }
                catch
                {
                    // ignore if counters are not installed
                    s_fCountersInitialized = false;
                }
                Close();

                OnSendComplete(pctxt, false);

                return;
            }
            catch
            {
                syClose.ReleaseReaderLock();
                try
                {
                    Close();
                }
                catch { }
                try
                {
                    OnSendComplete(pctxt, false);
                }
                catch { }
                throw;
            }
            syClose.ReleaseReaderLock();

            if(fWasClosed)
                OnSendComplete(pctxt, false);
        }

        // handlers

        private void ReceiveCallbackEP(IAsyncResult sy)
        {
            UnhandledExceptionVortex.CatchAsyncFrame(fnReceiveCallback, sy);
            try
            {
                if(s_fCountersInitialized)
                {
                    ProtocolConnectionCounters.Total.ReadsPending.Decrement();
                    ProtocolConnectionCounters.Total.ReadsCompleted.Increment();
                }
            }
            catch
            {
                // ignore if counters are not installed
                s_fCountersInitialized = false;
            }
        }

        private void ReceiveCallback(IAsyncResult sy)
        {
            ReceiveContext ctxt = (ReceiveContext) sy.AsyncState;

            if(fClosed)
            {
                DoneReceiving(ctxt);
                return;
            }

            // First find out what happened on this receive.
            int cb = 0;
            syClose.AcquireReaderLock(-1);
            try
            {
                if(!fClosed)
                    cb = sk.EndReceive(sy);
                try
                {
                    if(s_fCountersInitialized)
                    {
                        ProtocolConnectionCounters.Total.BytesRead.IncrementBy(cb);
                    }
                }
                catch
                {
                    // ignore if counters are not installed
                    s_fCountersInitialized = false;
                }
            }
            catch(SocketException)
            {
                syClose.ReleaseReaderLock();
                try
                {
                    Close();
                }
                finally
                {
                    DoneReceiving(ctxt);
                    try
                    {
                        if(s_fCountersInitialized)
                        {
                            ProtocolConnectionCounters.Total.SocketExceptions.Increment();
                        }
                    }
                    catch
                    {
                        // ignore if counters are not installed
                        s_fCountersInitialized = false;
                    }
                }
                return;
            }
            catch
            {
                syClose.ReleaseReaderLock();
                try
                {
                    Close();
                }
                catch { }
                DoneReceiving(ctxt);
                throw;
            }
            syClose.ReleaseReaderLock();

            // If cb is zero, either the socket was already closed or it needs to be.
            if(cb == 0)
            {
                try
                {
                    Close();
                }
                finally
                {
                    DoneReceiving(ctxt);
                }
                return;
            }

            // receives can complete out-of-order, so we need to re-order them.
            // all the buffers are in this circular array.  lock it, and see if we're next.
            // if so, process, otherwise leave it as queued.
            // try not to lock in the regular case.
            if(iReceiveExpected != ctxt.nOrder)
            {
                lock(arctxtReceiveBuffers)
                {
                    if(iReceiveExpected != ctxt.nOrder)
                    {
                        ctxt.cbPending = cb;

                        // If the next buffer is the one being processed, it means we looped,
                        // so all buffers have been exhausted.  Take that as a sign that this guy
                        // should be disconnected (the socket will start thrashing anyway).
                        if((ctxt.nOrder + 1) % arctxtReceiveBuffers.Length == iReceiveExpected)
                        {
                            Close();
                            try
                            {
                                if(s_fCountersInitialized)
                                {
                                    ProtocolConnectionCounters.Total.SocketsThrottled.Increment();
                                }
                            }
                            catch
                            {
                                // ignore if counters are not installed
                                s_fCountersInitialized = false;
                            }
                        }

                        return;
                    }
                }
            }

            // Loop through pending receives.  If something happens, make sure to DoneReceiving() all pending completions.
            try
            {
                while(cb != 0)
                {
                    if(BytesReceived != null)
                        BytesReceived(this, new BytesReceivedEventArgs(arbMasterReceiveBuffer, ctxt.nOrder * cbBytesPerReceive, cb));

                    if(pProto != null)
                    {
                        unsafe
                        {
                            pProto = pProto.Consume(arbMasterReceiveBuffer.Pointer + ctxt.nOrder * cbBytesPerReceive, (uint) cb);
                        }

                        if(pProto == null)
                        {
                            //if(Logger.LogErrorMessages)
                            //{
                            //    unsafe
                            //    {
                            //        string sBytesReceived = new string((sbyte*)(arbMasterReceiveBuffer.Pointer + ctxt.nOrder * cbBytesPerReceive), 0, cb );
                            //        Logger.Warn(313, "Protocol Violation:\r\nReceived Bytes:\r\n" + sBytesReceived);
                            //    }
                            //}

                            try
                            {
                                if(s_fCountersInitialized)
                                {
                                    ProtocolConnectionCounters.Total.ProtocolViolations.Increment();
                                }
                            }
                            catch
                            {
                                // ignore if counters are not installed
                                s_fCountersInitialized = false;
                            }
                            Close();
                        }
                    }

                    // no option but to lock here.  once we increase the target, we have to post our receive
                    // next, so in the same lock.
                    lock(arctxtReceiveBuffers)
                    {
                        ReceiveContext xctxt = ctxt;
                        iReceiveExpected = (iReceiveExpected + 1) % arctxtReceiveBuffers.Length;
                        ctxt = arctxtReceiveBuffers[iReceiveExpected];
                        cb = ctxt.cbPending;
                        if(cb == 0)
                            ctxt = null;
                        else
                            ctxt.cbPending = 0;
                        PostReceive(xctxt);
                    }
                }
            }
            catch
            {
                try
                {
                    Close();
                }
                catch { }

                try
                {
                    if(ctxt != null)
                        DoneReceiving(ctxt);
                }
                catch { }

                lock(arctxtReceiveBuffers)
                {
                    while(true)
                    {
                        iReceiveExpected = (iReceiveExpected + 1) % arctxtReceiveBuffers.Length;
                        ctxt = arctxtReceiveBuffers[iReceiveExpected];
                        if(ctxt.cbPending == 0)
                            break;

                        try
                        {
                            ctxt.cbPending = 0;
                            DoneReceiving(ctxt);
                        }
                        catch { }
                    }
                }

                throw;
            }
        }

        private void SendCallbackEP(IAsyncResult sy)
        {
            UnhandledExceptionVortex.CatchAsyncFrame(fnSendCallback, sy);
            try
            {
                if(s_fCountersInitialized)
                {
                    ProtocolConnectionCounters.Total.WritesPending.Decrement();
                    ProtocolConnectionCounters.Total.SendComplete.Increment();
                }
            }
            catch
            {
                // ignore if counters are not installed
                s_fCountersInitialized = false;
            }
        }

        private void SendCallback(IAsyncResult sy)
        {
            ISendContext pctxt = (ISendContext) sy.AsyncState;
            int cb = 0;

            syClose.AcquireReaderLock(-1);
            try
            {
                if(!fClosed)
                    cb = sk.EndSend(sy);
                try
                {
                    if(s_fCountersInitialized)
                    {
                        ProtocolConnectionCounters.Total.BytesSent.IncrementBy(cb);
                    }
                }
                catch
                {
                    // ignore if counters are not installed
                    s_fCountersInitialized = false;
                }
            }
            catch(SocketException)
            {
                syClose.ReleaseReaderLock();
                try
                {
                    if(s_fCountersInitialized)
                    {
                        ProtocolConnectionCounters.Total.SocketExceptions.Increment();
                    }
                }
                catch
                {
                    // ignore if counters are not installed
                    s_fCountersInitialized = false;
                }

                try
                {
                    Close();
                }
                finally
                {
                    OnSendComplete(pctxt, false);
                }
                return;
            }
            catch
            {
                syClose.ReleaseReaderLock();
                try
                {
                    Close();
                }
                catch { }
                try
                {
                    OnSendComplete(pctxt, false);
                }
                catch { }
                throw;
            }
            syClose.ReleaseReaderLock();

            try
            {
                pctxt.JustSent(cb);
            }
            catch
            {
                try
                {
                    Close();
                }
                catch { }
                try
                {
                    OnSendComplete(pctxt, false);
                }
                catch { }
                throw;
            }
            if(pctxt.Sent < pctxt.Length)
                PostSend(pctxt);
            else
                OnSendComplete(pctxt, true);
        }

        static public bool s_fCountersInitialized = true;
        private readonly Socket sk;
        private object ki;
        private BufferProtocol pProto;
        private int fInited;

        private ReceiveContext[] arctxtReceiveBuffers;
        private int iReceiveExpected;
        private PinnableBuffer arbMasterReceiveBuffer;
        private GCHandle weakMasterReceiveBuffer;
        private int cReceivesGoing;
        private int cbBytesPerReceive;

        private bool fClosed;
        private readonly ReaderWriterLock syClose;

        private readonly AsyncCallback fnSendCallback;
        private readonly AsyncCallback fnSendCallbackEP;
        private readonly AsyncCallback fnReceiveCallback;
        private readonly AsyncCallback fnReceiveCallbackEP;
    }

    [XomPerformanceCounterCategoryAttr( "STF: Connection Server Test", "XBox Live Connection Server Test: Network" )]
    public class ProtocolConnectionCounters : XomPerformanceCounterCategory
    {
        static public ProtocolConnectionCounters Total = new ProtocolConnectionCounters();

        [XomPerformanceCounterAttr(
            "Sockets Open",
            "The number of open sockets.  This counter is a snapshot.",
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter SocketsOpen;

        [XomPerformanceCounterAttr(
            "Sockets Abandoned /sec",
            "The number of socket connections garbage collected before being fully shut down per second.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter SocketsAbandoned;

        [XomPerformanceCounterAttr(
            "Socket Exceptions /sec",
            "The number of SocketException exceptions per second.  (The client is disconnected, although usually this occurs because the client already did.)",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter SocketExceptions;

        [XomPerformanceCounterAttr(
            "Sockets Shut Down /sec",
            "The number of socket connections to have Shutdown() called per second.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter SocketShutdown;

        [XomPerformanceCounterAttr(
           "Socket Reads Pending",
           "The number of outstanding socket reads.  This counter is a snapshot.",
           PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter ReadsPending;

        [XomPerformanceCounterAttr(
            "Bytes Read /sec",
            "The number of bytes read and consumed per second.",
            PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter BytesRead;

        [XomPerformanceCounterAttr(
            "Reads completed /sec",
            "The number of reads completed per second.",
            PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter ReadsCompleted;

        [XomPerformanceCounterAttr(
            "Socket Writes Pending",
            "The number of outstanding socket writes.  This counter is a snapshot.",
            PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter WritesPending;

        [XomPerformanceCounterAttr(
            "Bytes Sent /sec",
            "The number of bytes sent per second.",
            PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter BytesSent;

        [XomPerformanceCounterAttr(
            "Send Completions /sec",
            "The number sends completing per second.",
            PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter SendComplete;

        [XomPerformanceCounterAttr(
            "Socket Protocol Violations /sec",
           "The number of clients disconnected due to protocol violations per second.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter ProtocolViolations;

        [XomPerformanceCounterAttr(
          "Sockets Throttled /sec",
          "The number of socket connections closed due to receive-buffer exhaustion per second.",
           PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter SocketsThrottled;

        [XomPerformanceCounterAttr(
           "Backing Buffer Bytes Free",
           "The number of unused bytes within all allocated backing buffers.  This counter is a snapshot.",
            PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter FreeBytes;

        [XomPerformanceCounterAttr(
           "Backing Buffers Allocated",
           "The number of 75k backing buffers allocated.  This counter is a snapshot.", 
           PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter BackingBuffers;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\XConnSrv\SubscriptionBuilder.cs ===
using System;
using System.Collections.Generic;
using System.Threading;
using System.Reflection;
using ServerTestFramework.LiveService.GI;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.UserAccount;
using xonline.common.diagnostics;
using xonline.common.protocol.SubNoti;
using xonline.common.community;

namespace ServerTestFramework.LiveService.XConnSrv
{
    /// <summary>
    /// This class is used to create correct DATA_OBJECT_SPECIFIERS used for subscriptions with XConnSrv
    /// </summary>
    public class SubscriptionBuilder
    {
        #region GET DATA OBJECT SPECIFIERS

        /// <summary>
        /// Creates a single DATA_OBJECT_SPECIFIER for the given User ID of the given DATA_TYPE to be used for subscriptions
        /// </summary>
        public static DATA_OBJECT_SPECIFIER GetDataObjectSpecifierForSingleUser(DATA_TYPES type, ulong userId)
        {
            DATA_OBJECT_SPECIFIER dos = new DATA_OBJECT_SPECIFIER();
            dos.dwDataSubType = 0;
            dos.qwOwnerXUID = userId;
            dos.wDataType = (ushort)type;
            dos.wObjectSize = 0;

            UserListData userListData = new UserListData(DATA_TYPES.eFriendsList);
            userListData.rgUsers = new UserData[100];
            for (int iUser = 0; iUser < userListData.rgUsers.Length; iUser++)
            {
                userListData.rgUsers[iUser] = new UserData();
            }

            BasicPresence basicPres = new BasicPresence();
            
            RichPresenceData richPres = new RichPresenceData();
            richPres.sRichPresence = new string(' ', 128);

            unsafe
            {
                switch (type)
                {
                    case DATA_TYPES.eFriendsList:
                        {
                            dos.wObjectSize = (ushort)userListData.Size(); // Size for 100 friend

                            break;
                        }
                    case DATA_TYPES.eBasicPresence:
                        {
                            dos.wObjectSize = (ushort)basicPres.Size();

                            break;
                        }
                    case DATA_TYPES.eExtendedPresence:
                        {
                            dos.wObjectSize = (ushort)sizeof(BASE_DATA_HEADER); // TODO

                            break;
                        }
                    case DATA_TYPES.eRichPresenceString:
                        {
                            dos.wObjectSize = (ushort)richPres.Size(); // 256 is the maximum length of Rich Presence string

                            break;
                        }
                    case DATA_TYPES.eBasicProfile:
                        {
                            dos.wObjectSize = (ushort)sizeof(BASE_DATA_HEADER); // TODO

                            break;
                        }
                    case DATA_TYPES.eExtendedProfile:
                        {
                            dos.wObjectSize = (ushort)sizeof(BASE_DATA_HEADER); // TODO

                            break;
                        }
                    case DATA_TYPES.eAvatar:
                        {
                            dos.wObjectSize = (ushort)(sizeof(BASE_DATA_HEADER) + 1000); // TODO
                            dos.dwDataSubType = 4294838225; // Avatar Editor Title Id: FFFE 07D1

                            break;
                        }
                    case DATA_TYPES.ePartyInfo:
                        {
                            dos.wObjectSize = (ushort)sizeof(BASE_DATA_HEADER); // TODO

                            break;
                        }
                }
            }

            return dos;
        }

        /// <summary>
        /// Creates a single DATA_OBJECT_SPECIFIER for the given PNUser of the given DATA_TYPE to be used for subscriptions
        /// </summary>
        public static DATA_OBJECT_SPECIFIER GetDataObjectSpecifierForSingleUser(DATA_TYPES type, PNUser user)
        {
            return GetDataObjectSpecifierForSingleUser(type, user.UserId);
        }

        /// <summary>
        /// Creates a DATA_OBJECT_SPECIFIER array for the given User IDs of the given DATA_TYPE to be used for subscriptions
        /// </summary>
        public static DATA_OBJECT_SPECIFIER[] GetDataObjectSpecifierArrayForUsers(DATA_TYPES type, ulong[] userIds)
        {
            DATA_OBJECT_SPECIFIER[] result = new DATA_OBJECT_SPECIFIER[userIds.Length];
            int i = 0;

            foreach (ulong userId in userIds)
            {
                result[i++] = GetDataObjectSpecifierForSingleUser(type, userId);
            }

            return result;
        }

        /// <summary>
        /// Creates a DATA_OBJECT_SPECIFIER array for the given PNUsers of the given DATA_TYPE to be used for subscriptions
        /// </summary>
        public static DATA_OBJECT_SPECIFIER[] GetDataObjectSpecifierArrayForUsers(DATA_TYPES type, PNUser[] users)
        {
            DATA_OBJECT_SPECIFIER[] result = new DATA_OBJECT_SPECIFIER[users.Length];
            int i = 0;

            foreach (PNUser user in users)
            {
                result[i++] = GetDataObjectSpecifierForSingleUser(type, user);
            }

            return result;
        }

        #endregion // GET DATA OBJECT SPECIFIERS

        #region SUBSCRIBE

        /// <summary>
        /// Subscribe to a user for a given type
        /// </summary>
        public static SUBSCRIBE_REPLY Subscribe(PNConnection connection, DATA_TYPES type, ulong user)
        {
            return Subscribe(connection, type, new ulong[] { user });
        }

        /// <summary>
        /// Subscribe to a user for a given type on the given indicies
        /// </summary>
        public static SUBSCRIBE_REPLY Subscribe(PNConnection connection, int[] userIndicies, DATA_TYPES type, ulong user)
        {
            return Subscribe(connection, userIndicies, type, new ulong[] { user });
        }

        /// <summary>
        /// Subscribe to a user for a given type on the given indicies with the given header flags
        /// </summary>
        public static SUBSCRIBE_REPLY Subscribe(PNConnection connection, int[] userIndicies, uint headerFlags, DATA_TYPES type, ulong user)
        {
            return Subscribe(connection, userIndicies, headerFlags, type, new ulong[] { user });
        }

        /// <summary>
        /// Subscribe to users for the given type
        /// </summary>
        public static SUBSCRIBE_REPLY Subscribe(PNConnection connection, DATA_TYPES type, ulong[] users)
        {
            return connection.Subscribe(GetDataObjectSpecifierArrayForUsers(type, users));
        }

        /// <summary>
        /// Subscribe to users for the given type on the given indicies
        /// </summary>
        public static SUBSCRIBE_REPLY Subscribe(PNConnection connection, int[] userIndicies, DATA_TYPES type, ulong[] users)
        {
            return connection.Subscribe(GetDataObjectSpecifierArrayForUsers(type, users), userIndicies);
        }

        /// <summary>
        /// Subscribe to users for the given type on the given indicies wit hthe given header flags
        /// </summary>
        public static SUBSCRIBE_REPLY Subscribe(PNConnection connection, int[] userIndicies, uint headerFlags, DATA_TYPES type, ulong[] users)
        {
            return connection.Subscribe(GetDataObjectSpecifierArrayForUsers(type, users), userIndicies, headerFlags);
        }

        /// <summary>
        /// Subscribe to a user for a given type
        /// </summary>
        public static SUBSCRIBE_REPLY Subscribe(PNConnection connection, DATA_TYPES type, PNUser user)
        {
            return Subscribe(connection, type, new PNUser[] { user });
        }

        /// <summary>
        /// Subscribe to a user for a given type on the given indicies
        /// </summary>
        public static SUBSCRIBE_REPLY Subscribe(PNConnection connection, int[] userIndicies, DATA_TYPES type, PNUser user)
        {
            return Subscribe(connection, userIndicies, type, new PNUser[] { user });
        }

        /// <summary>
        /// Subscribe to a user for a given type on the given indicies with the given header flags
        /// </summary>
        public static SUBSCRIBE_REPLY Subscribe(PNConnection connection, int[] userIndicies, uint headerFlags, DATA_TYPES type, PNUser user)
        {
            return Subscribe(connection, userIndicies, headerFlags, type, new PNUser[] { user });
        }

        /// <summary>
        /// Subscribe to users for the given type
        /// </summary>
        public static SUBSCRIBE_REPLY Subscribe(PNConnection connection, DATA_TYPES type, PNUser[] users)
        {
            return connection.Subscribe(GetDataObjectSpecifierArrayForUsers(type, users));
        }

        /// <summary>
        /// Subscribe to users for the given type on the given indicies
        /// </summary>
        public static SUBSCRIBE_REPLY Subscribe(PNConnection connection, int[] userIndicies, DATA_TYPES type, PNUser[] users)
        {
            return connection.Subscribe(GetDataObjectSpecifierArrayForUsers(type, users), userIndicies);
        }

        /// <summary>
        /// Subscribe to users for the given type on the given indicies wit hthe given header flags
        /// </summary>
        public static SUBSCRIBE_REPLY Subscribe(PNConnection connection, int[] userIndicies, uint headerFlags, DATA_TYPES type, PNUser[] users)
        {
            return connection.Subscribe(GetDataObjectSpecifierArrayForUsers(type, users), userIndicies, headerFlags);
        }

        /// <summary>
        /// Basic SUBSCRIBE_REPLY verification verificiation verifying number of objects returned
        /// </summary>
        public bool ValidateSubscribeReply(PNConnection connection, SUBSCRIBE_REPLY subscribeReply, DATA_TYPES type, PNUser[] users)
        {
            DATA_OBJECT_SPECIFIER[] subscriptions = GetDataObjectSpecifierArrayForUsers(type, users);

            Assert.IsTrue(subscribeReply.dwNumDataObjects == subscriptions.Length, "NumObjects in reply (" + subscribeReply.dwNumDataObjects +
                ") does not match number of objects in request (" + subscriptions.Length + ")");
            Assert.IsTrue(subscribeReply.rgDataObjects.Length == subscriptions.Length, "Number of objects in reply (" + subscribeReply.rgDataObjects.Length +
                ") does not match the number of objects in request (" + subscriptions.Length + ")");

            for (int j = 0; j < subscriptions.Length; j++)
            {
                bool bFound = false;
                foreach (SUBSCRIPTION_DATA sd in subscribeReply.rgDataObjects)
                {
                    if (sd.qwOwnerXUID == subscriptions[j].qwOwnerXUID && sd.wDataType == subscriptions[j].wDataType)
                    {
                        Assert.IsTrue(subscribeReply.rgDataObjects[j].wDataType == subscriptions[j].wDataType, "Data Type in reply (" + subscribeReply.rgDataObjects[j].wDataType +
                            ") does not match the data type in request (" + subscriptions[j].wDataType + ")");

                        bFound = true;
                        break;
                    }
                }

                Assert.IsTrue(bFound, "Owner XUID was not found in the SUBSCRIBE_REPLY");
            }

            return true;
        }

        #endregion // SUBSCRIBE
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\XConnSrv\XSubNotiProt.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using xonline.common.protocol.SubNoti;
using xonline.common.service.reflection;

namespace ServerTestFramework.LiveService.XConnSrv
{
    // The below is wire data for responses. The above should be identical to the XSubNotiProt in the server directory
    // and may be removed at some point.

    public class SUBSCRIPTION_DATA : WireData
    {
        // Schema version identifier.
        public ushort wObjectSize;

        // schema identifier.  see DATA_TYPES.
        public ushort wDataType;

        // optional subtype for data.  e.g. TitleID for data specific to a title.  Zero if unused.
        public uint dwDataSubType;

        // User who owns the data
        public ulong qwOwnerXUID;

        // Extra flags for this piece of data.
        public uint dwHeaderFlags;

        // the data
        [WireInfo(SizeParam = "wObjectSize")]
        public byte[] data;
        
        public override WireData ReadStream(BinaryReader binaryReader)
        {
            wObjectSize = binaryReader.ReadUInt16();
            wDataType = binaryReader.ReadUInt16();
            dwDataSubType = binaryReader.ReadUInt32();
            qwOwnerXUID = binaryReader.ReadUInt64();
            dwHeaderFlags = binaryReader.ReadUInt32();

            // the rest of wObjectSize is data.. 20 is ushort + ushort + uint + ulong
            data = binaryReader.ReadBytes((int)(wObjectSize - 20));

            return this;
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            // 20 == sizeof(BASE_DATA_HEADER)
            wObjectSize = (ushort)(20 + data.Length);

            binaryWriter.Write(wObjectSize);
            binaryWriter.Write(wDataType);
            binaryWriter.Write(dwDataSubType);
            binaryWriter.Write(qwOwnerXUID);
            binaryWriter.Write(dwHeaderFlags);
            binaryWriter.Write(data);
        }
    }

    public class CONNECT_REPLY : WireData
    {
        // return code.
        public int hr;
    }

    public class DISCONNECT_REPLY : WireData
    {
        // return code.
        public int hr;
    }

    public class SUBSCRIBE_REPLY : WireData
    {
        public int hr;

        // number of objects returned.
        public uint dwNumDataObjects;

        [WireInfo(Serialize = false)]
        public BASE_MESSAGE_HEADER header;

        // the objects returned.  not actually a fixed size array.  each object size is held in BASE_DATA_HEAER.doSpec.dwObjectSize.
        [WireInfo(SizeParam = "dwNumDataObjects")]
        public SUBSCRIPTION_DATA[] rgDataObjects;
    }

    public class UNSUBSCRIBE_REPLY : WireData
    {
        // return code.
        public int hr;
        [WireInfo(Serialize = false)]
        public BASE_MESSAGE_HEADER header;
    }

    public class QUERY_REPLY : WireData
    {
        public int hr;

        // number of objects returned.
        public uint dwNumDataObjects;

        // the objects returned.  not actually a fixed size array.  each object size is held in BASE_DATA_HEAER.doSpec.dwObjectSize.
        [WireInfo(SizeParam = "dwNumDataObjects")]
        public SUBSCRIPTION_DATA[] rgDataObjects;
    }

    public class PUBLISH_REPLY : WireData
    {
        // return code.
        public int hr;
    }

    public class DATA_NOTIFICATION : WireData
    {
        [WireInfo(Serialize = false)]
        public BASE_MESSAGE_HEADER header;

        // number of objects returned.
        public uint dwNumDataObjects;

        // the objects returned.  not actually a fixed size array.  each object size is held in BASE_DATA_HEAER.doSpec.dwObjectSize.
        [WireInfo(SizeParam = "dwNumDataObjects")]
        public SUBSCRIPTION_DATA[] rgDataObjects;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\XConnSrv\FakeMC\MCProtocol.cs ===
using System;
using System.IO;
using System.Collections;
using System.Web;
using System.Text;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace ServerTestFramework.LiveService.XConnSrv.FakeMC
{
    public class MCDefs
    {
        public const uint MC_PROTOCOL_VERSION_CURRENT = 1;
        public const uint MC_MESSAGE_HEADER_SIZE = 16;
    }

    public enum MC_MSG_TYPES
    {
        // request types:
        MCMSG_MIN_REQ           = 1000,
        MCMSG_HELLO_REQ         = 1000,
        MCMSG_GET_SINGLE_REQ    = 1001,
        MCMSG_SET_SINGLE_REQ    = 1002,
        MCMSG_MAX_REQ           = 1002,

        // response types:
        MCMSG_MIN_RESP          = 1100,
        MCMSG_GET_SINGLE_RESP   = 1100,
        MCMSG_NOTIFICATION_RESP = 1101,
        MCMSG_MAX_RESP          = 1101,
    };

    public class MCMessage : global::xonline.common.service.reflection.WireData
    {
        public MCMessageHeader _Header;
        public MCMessageData   _Data;

        public MCMessage()
        {
        }

        public MCMessage(MC_MSG_TYPES eType, MCMessageData Data)
        {
            _Header = new MCMessageHeader(eType);
            _Data = Data;
            _Header.dwMsgLen = (uint)(_Data.Size());
        }

        public override int Size()
        {
            return (_Header != null ? _Header.Size() : 0) + (_Data != null ? _Data.Size() : 0);
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            _Header.WriteStream(binaryWriter);
            _Data.WriteStream(binaryWriter);
        }

        public override global::xonline.common.service.reflection.WireData ReadStream(BinaryReader binaryReader)
        {
            _Header = new MCMessageHeader();
            _Header.ReadStream(binaryReader);

            _Data = MCMessageData.GetInstance(_Header);
            _Data.ReadStream(binaryReader);
            return this;
        }
    }

    public class MCMessageHeader : global::xonline.common.service.reflection.WireData
    {
        public uint dwProtocolVersion;
        public uint dwMsgType;
        public uint dwMsgLen;
        public uint dwSeqNum;

        public MCMessageHeader()
        {
        }

        public MCMessageHeader(MC_MSG_TYPES eType)
        {
            dwProtocolVersion = MCDefs.MC_PROTOCOL_VERSION_CURRENT;
            dwMsgType = (uint)eType;
        }

        public override int Size()
        {
            return (int)MCDefs.MC_MESSAGE_HEADER_SIZE;
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - IGMessageHeader::WriteStream binaryWriter is null");
            }

            binaryWriter.Write(dwProtocolVersion);
            binaryWriter.Write(dwMsgType);
            binaryWriter.Write(dwMsgLen);
            binaryWriter.Write(dwSeqNum);
        }

        public override global::xonline.common.service.reflection.WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - XBancMessageHeader::ReadStream binaryReader is null");
            }

            dwProtocolVersion = binaryReader.ReadUInt32();
            dwMsgType = binaryReader.ReadUInt32();
            dwMsgLen = binaryReader.ReadUInt32();
            dwSeqNum = binaryReader.ReadUInt32();
           
            return this;
        }
    }

    public class MCMessageData : global::xonline.common.service.reflection.WireData
    {
        public static MCMessageData GetInstance(MCMessageHeader Header)
        {
            MCMessageData data = null;
            switch (Header.dwMsgType)
            {
                case (uint)MC_MSG_TYPES.MCMSG_HELLO_REQ:
                    data = new MCHelloMsgData();
                    break;
                case (uint)MC_MSG_TYPES.MCMSG_GET_SINGLE_REQ:
                    data = new MCGetSingleMsgData();
                    break;
                case (uint)MC_MSG_TYPES.MCMSG_SET_SINGLE_REQ:
                    data = new MCSetSingleMsgData();
                    break;
                case (uint)MC_MSG_TYPES.MCMSG_GET_SINGLE_RESP:
                    data = new MCGetSingleResponseData();
                    break;
                case (uint)MC_MSG_TYPES.MCMSG_NOTIFICATION_RESP:
                    data = new MCNotificationResponseData();
                    break;
            }

            return data;
        }
    }

    public class MCHelloMsg : MCMessage
    {
        public MCHelloMsg(string Description)
            : base(MC_MSG_TYPES.MCMSG_HELLO_REQ, new MCHelloMsgData(Description))
        {
        }
    }

    public class MCHelloMsgData : MCMessageData
    {
        [global::xonline.common.service.reflection.WireInfo(NullTerminate = true, ArraySize = 79)]
        public string szDescription;

        public MCHelloMsgData()
        {
        }

        public MCHelloMsgData(string Description)
        {
            szDescription = Description;
        }

        public override int Size()
        {
            return 80;
        }
    }

    public class MCGetSingleMsg : MCMessage
    {
        public MCGetSingleMsg(string key) : base(MC_MSG_TYPES.MCMSG_GET_SINGLE_REQ, new MCGetSingleMsgData(key))
        {
        }
    }

    public class MCGetSingleMsgData : MCMessageData
    {
        public ushort _keyLength; // Includes the '\0'
        [global::xonline.common.service.reflection.WireInfo(SizeParam = "_keyLength", NullTerminate = true)]
        public string _key; // ASCII Null terminated

        public MCGetSingleMsgData()
        {
        }

        public MCGetSingleMsgData(string key)
        {
            if (key != null)
                _keyLength = (ushort)key.Length;
            else
                _keyLength = 0;
            _key = key;
        }

        public override int Size()
        {
            return sizeof(ushort) +
                   ((_key == null) ? 0 : _key.Length);
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }

            binaryWriter.Write(_keyLength);

            if (_key != null)
            {
                binaryWriter.Write(Encoding.ASCII.GetBytes(_key));
            }
        }

        public override global::xonline.common.service.reflection.WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - ReadStream binaryReader is null");
            }

            _keyLength = binaryReader.ReadUInt16();

            if (_keyLength > 0)
            {
                _key = Encoding.ASCII.GetString(binaryReader.ReadBytes((int)_keyLength));
            }

            return this;
        }
    }

    public class MCSetSingleMsg : MCMessage
    {
        public MCSetSingleMsg(string key, byte[] data)
            : base(MC_MSG_TYPES.MCMSG_SET_SINGLE_REQ, new MCSetSingleMsgData(key, data))
        {
        }
    }

    public class MCSetSingleMsgData : MCMessageData
    {
        public ushort _keyLength; // Includes the '\0'
        [global::xonline.common.service.reflection.WireInfo(SizeParam = "_keyLength", NullTerminate = true)]
        public string _key; // ASCII Null terminated

        public uint _dataSize;
        [WireInfo(SizeParam = "_dataSize")]
        public byte[] _data;

        public MCSetSingleMsgData()
        {
        }

        public MCSetSingleMsgData(string key, byte[] data)
        {
            if (key != null)
                _keyLength = (ushort)key.Length;
            else
                _keyLength = 0;
            _key = key;

            if (data != null)
                _dataSize = (uint)data.Length;
            else
                _dataSize = 0;
            _data = data;
        }

        public override int Size()
        {
            return sizeof(ushort) +
                   ((_key == null) ? 0 : _key.Length) +
                   sizeof(uint) +
                   ((_data == null) ? 0 : _data.Length);
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }

            binaryWriter.Write(_keyLength);

            if (_key != null)
            {
                binaryWriter.Write(Encoding.ASCII.GetBytes(_key));
            }

            binaryWriter.Write(_dataSize);

            if (_data != null)
            {
                binaryWriter.Write(_data);
            }
        }

        public override global::xonline.common.service.reflection.WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - ReadStream binaryReader is null");
            }

            _keyLength = binaryReader.ReadUInt16();

            if (_keyLength > 0)
            {
                _key = Encoding.ASCII.GetString(binaryReader.ReadBytes((int)_keyLength));
            }

            _dataSize = binaryReader.ReadUInt32();
            _data = new byte[_dataSize];
            if (_dataSize > 0)
            {
                _data = binaryReader.ReadBytes((int)_dataSize);
            }

            return this;
        }
    }

    public class MCGetSingleResponse : MCMessage
    {
        public MCGetSingleResponse(string key, byte[] data)
            : base(MC_MSG_TYPES.MCMSG_GET_SINGLE_RESP, new MCGetSingleResponseData(key, data))
        {
        }
    }

    public class MCGetSingleResponseData : MCMessageData
    {
        public ushort _keyLength; // Includes the '\0'
        [global::xonline.common.service.reflection.WireInfo(SizeParam = "_keyLength", NullTerminate = true)]
        public string _key; // ASCII Null terminated

        public uint _dataSize;
        [WireInfo(SizeParam = "_dataSize")]
        public byte[] _data;

        public MCGetSingleResponseData()
        {
        }

        public MCGetSingleResponseData(string key, byte[] data)
        {
            if (key != null)
                _keyLength = (ushort)key.Length;
            else
                _keyLength = 0;
            _key = key;

            if (data != null)
                _dataSize = (uint)data.Length;
            else
                _dataSize = 0;
            _data = data;
        }

        public override int Size()
        {
            return sizeof(ushort) +
                   ((_key == null) ? 0 : _key.Length) +
                   sizeof(uint) +
                   ((_data == null) ? 0 : _data.Length);
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }

            binaryWriter.Write(_keyLength);

            if (_key != null)
            {
                binaryWriter.Write(Encoding.ASCII.GetBytes(_key));
            }

            binaryWriter.Write(_dataSize);

            if (_data != null)
            {
                binaryWriter.Write(_data);
            }
        }

        public override global::xonline.common.service.reflection.WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - ReadStream binaryReader is null");
            }

            _keyLength = binaryReader.ReadUInt16();

            if (_keyLength > 0)
            {
                _key = Encoding.ASCII.GetString(binaryReader.ReadBytes((int)_keyLength));
            }

            _dataSize = binaryReader.ReadUInt32();
            _data = new byte[_dataSize];
            if (_dataSize > 0)
            {
                _data = binaryReader.ReadBytes((int)_dataSize);
            }

            return this;
        }
    }

    public class MCNotificationResponse : MCMessage
    {
        public MCNotificationResponse(string[] keys)
            : base(MC_MSG_TYPES.MCMSG_NOTIFICATION_RESP, new MCNotificationResponseData(keys))
        {
        }
    }

    public class MCNotificationResponseData : MCMessageData
    {
        public uint _keysSize;

        [WireInfo(SizeParam = "_keysSize")]
        public ushort[] _keysLengths;

        [WireInfo(SizeParam = "_keysSize")]
        public string[] _keys;

        public MCNotificationResponseData()
        {
        }

        public MCNotificationResponseData(string[] keys)
        {
            if (keys != null)
                _keysSize = (ushort)keys.Length;
            else
                _keysSize = 0;

            _keys = keys;

            // Store the lengths of each string
            _keysLengths = new ushort[_keysSize];
            for (int i = 0; i < _keysSize; ++i)
                _keysLengths[i] = (ushort)_keys[i].Length;
        }

        public override int Size()
        {
            int totalSize = 0;

            totalSize += sizeof(uint);

            for (int i = 0; i < _keysSize; ++i)
            {
                if (_keys[i] != null)
                    totalSize += sizeof(ushort) + _keysLengths[i];
            }

            return totalSize;
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - WriteStream binaryWriter is null");
            }

            binaryWriter.Write(_keysSize);

            foreach (ushort length in _keysLengths)
                binaryWriter.Write(length);

            foreach(string key in _keys)
                if(key != null)
                    binaryWriter.Write(Encoding.ASCII.GetBytes(key));
        }

        public override global::xonline.common.service.reflection.WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - ReadStream binaryReader is null");
            }

            _keysSize = binaryReader.ReadUInt32();

            if (_keysSize > 0)
            {
                _keysLengths = new ushort[_keysSize];
                _keys = new string[_keysSize];

                for (int i = 0; i < _keysSize; ++i)
                {
                    _keysLengths[i] = binaryReader.ReadUInt16();
                }

                for (int i = 0; i < _keysSize; ++i)
                {
                    _keys[i] = Encoding.ASCII.GetString(binaryReader.ReadBytes((int)_keysLengths[i]));
                }
            }

            return this;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\XConnSrv\PNConnection.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework.LiveService.FakeSG;
using System.Net;
using System.Net.Sockets;
using ServerTestFramework.LiveService.XConnSrv;
using xonline.common.protocol.SubNoti;
using xonline.common.config;
using xonline.common.community;

namespace ServerTestFramework.LiveService.XConnSrv
{
    public class PNConnection
    {
        public enum PNConnectionState : uint
        {
            NOT_CONNECTED = 0,
            CONNECTING = 1,
            CONNECTED = 2
        }

        private uint _userIndexFlags;
        private ulong[] _userIds;
        private ulong _xboxId;
        private bool _reconnect;
        private ConnSrvConnection _connection;
        private PNConnectionState _state;
        private readonly string _server;

        //Create 4 dictionary for 4 users.

        public List<Dictionary<ulong, DATA_OBJECT_SPECIFIER>> SubscribedUsers = new List<Dictionary<ulong, DATA_OBJECT_SPECIFIER>>(4);

        private static int s_msTimeOut = 30000;

        public static string ConfiguredServer
        {
            get
            {
                IVirtualInterfaceInfo info = Config.GetVirtualInterface(VirtualInterface.XConnSrv, Config.SiteId);
                return info.IPAddressString;
                
                //System.Net.IPEndPoint endPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.XConnSrv);
                //VirtualInterfaceInfo info = (VirtualInterfaceInfo)Config.GetVirtualInterface(VirtualInterface.XConnSrv);
                //info.IPAddress = endPoint.Address;
                //return info.IPAddressString;
            }
        }

        public PNConnection() : this(ConfiguredServer, 0) { }

        public PNConnection(string server) : this(server, 0) { }

        public PNConnection(ulong xboxId) : this(ConfiguredServer, xboxId) { }

        public PNConnection(ulong xboxId, bool notificationsEnabled) : this(ConfiguredServer, xboxId, notificationsEnabled) { }

        public PNConnection(bool notificationsEnabled) : this(ConfiguredServer, 0, notificationsEnabled) { }

        public PNConnection(string server, ulong xboxId) : this(server, xboxId, true) { }

        public PNConnection(string server, ulong xboxId, bool notificationsEnabled)
        {
            _server = server;
            _connection = null;
            _xboxId = xboxId;
            _state = PNConnectionState.NOT_CONNECTED;

            EstablishConnection();

            //Add 4 dictionary for four possible users on the connection. 
            SubscribedUsers.Add(new Dictionary<ulong, DATA_OBJECT_SPECIFIER>());
            SubscribedUsers.Add(new Dictionary<ulong, DATA_OBJECT_SPECIFIER>());
            SubscribedUsers.Add(new Dictionary<ulong, DATA_OBJECT_SPECIFIER>());
            SubscribedUsers.Add(new Dictionary<ulong, DATA_OBJECT_SPECIFIER>());

            _connection.Closed += new EventHandler(OnClosed);

            if (notificationsEnabled == true)
            {
                // subscribe to notifications
                _connection.Notified += new ConnSrvConnection.NotifiedEventHandler(OnNotification);
            }

            _connection.Init(this);
        }

        public void EstablishConnection()
        {
            if (_connection != null)
            {
                // make an effort to close the old one
                try
                {
                    _connection.Close();
                    _connection = null;
                }
                catch { }
            }

            _state = PNConnectionState.CONNECTING;
            _connection = ConnSrv.Lookup(_server).CreateInstance();
        }

        public bool Connected
        {
            get
            {
                //Console.WriteLine(_state.ToString());
                if (_connection != null)
                    return this._connection.Socket.Connected;
                else
                    return false;
            }
        }

        private void SyncWaitWithTimeout(IAsyncResult result)
        {
            ConnSrvMessageAsyncResult request = result as ConnSrvMessageAsyncResult;
            if (request != null)
            {
                request.Wait(s_msTimeOut);
                if (request.TimedOut)
                {
                    throw new TimeoutException("Sync Request Timed Out");
                }
            }
        }

        public CONNECT_REPLY Connect(int[] rgUserIndices, ulong[] rgUserIds)
        {
            return Connect(rgUserIndices, rgUserIds, false);
        }

        public CONNECT_REPLY Connect(int[] rgUserIndices, ulong[] rgUserIds, bool reconnect)
        {
            _userIndexFlags = SubNotiDefs.UserIndicesToFlags(rgUserIndices);
            _userIds = rgUserIds;
            _reconnect = reconnect;
            return Connect();
        }

        public CONNECT_REPLY Connect(bool reconnect)
        {
            _reconnect = reconnect;
            return Connect();
        }

        public CONNECT_REPLY Connect()
        {
            IAsyncResult result = BeginConnect(new AsyncCallback(OnConnect));
            SyncWaitWithTimeout(result);
            CONNECT_REPLY response = result.AsyncState as CONNECT_REPLY;
            return response;
        }

        public IAsyncResult BeginConnect(int[] rgUserIndices, ulong[] rgUserIds, bool reconnect, AsyncCallback fn)
        {
            _reconnect = reconnect;
            return BeginConnect(rgUserIndices, rgUserIds, fn);
        }

        public IAsyncResult BeginConnect(int[] rgUserIndices, ulong[] rgUserIds, AsyncCallback fn)
        {
            _userIndexFlags = SubNotiDefs.UserIndicesToFlags(rgUserIndices);
            _userIds = rgUserIds;
            return BeginConnect(fn);
        }

        public IAsyncResult BeginConnect(AsyncCallback fn)
        {
            if (_xboxId != 0)
            {
                if (GlobalFakeSG.FakeSG != null)
                {
                    // Setup SG Auth if needed
                    CSGInfo slot = new CSGInfo();
                    GlobalFakeSG.FakeSG.LoadSlot(ref slot, _xboxId);

                    slot.port = (ushort)((IPEndPoint)_connection.Socket.LocalEndPoint).Port;
                    GlobalFakeSG.FakeSG.PutSlot(ref slot, ((IPEndPoint)_connection.Socket.LocalEndPoint).Address);
                }
            }

            return SendConnectMsg(fn);
        }

        private IAsyncResult SendConnectMsg(AsyncCallback fn)
        {
            byte[] message = null;
            unsafe
            {
                message = new byte[sizeof(CONNECT_MESSAGE) + sizeof(ulong) * _userIds.Length];
                fixed (byte* pMessage = &message[0])
                {
                    CONNECT_MESSAGE* pConnect = (CONNECT_MESSAGE*)pMessage;
                    pConnect->header.dwUserIndexFlags = _userIndexFlags;
                    pConnect->header.dwTotalSize = (uint)message.Length;
                    pConnect->header.dwProtocolVersion = SubNotiDefs.CURRENT_PROTOCOL_VERSION;
                    pConnect->header.dwMessageType = (int)MESSAGE_TYPES.eConnect;
                    pConnect->header.dwHeaderFlags = _reconnect ? (uint)SubNotiDefs.XONLINE_CONNSRV_CONNECT_RECONNECT : 0;
                    pConnect->wNumUsers = (ushort)_userIds.Length;

                    // Add the users' XUIDS to the message
                    ulong* pData = (ulong*)(pMessage + sizeof(CONNECT_MESSAGE));
                    for (int i = 0; i < _userIds.Length; ++i)
                    {
                        *pData = _userIds[i];
                        pData++;
                    }
                }
            }
            ConnSrvMessageSendContext hsctxt = new ConnSrvMessageSendContext(message);
            IAsyncResult asy = _connection.Send(hsctxt, fn);

            return asy;
        }

        public void OnConnect(IAsyncResult asy)
        {
            CONNECT_REPLY reply = EndConnect(asy);
            if (reply != null && reply.hr == 0)
            {
                _state = PNConnectionState.CONNECTED;
            }
            else
            {
                _state = PNConnectionState.NOT_CONNECTED;
            }
        }

        public CONNECT_REPLY EndConnect(IAsyncResult asy)
        {
            CONNECT_REPLY response = asy.AsyncState as CONNECT_REPLY;
            return response;
        }

        public void Disconnect()
        {
            _state = PNConnectionState.NOT_CONNECTED;
            if (_connection != null)
            {
                ConnSrvConnection connection = _connection;
                _connection = null;
                connection.Close();
            }
        }

        public DISCONNECT_REPLY Disconnect(uint reason, int[] userIndices)
        {
            _userIndexFlags = SubNotiDefs.UserIndicesToFlags(userIndices);
            return Disconnect(reason);
        }

        public DISCONNECT_REPLY Disconnect(uint reason)
        {
            IAsyncResult result = BeginDisconnect(reason, new AsyncCallback(OnDisconnect));
            SyncWaitWithTimeout(result);
            DISCONNECT_REPLY response = result.AsyncState as DISCONNECT_REPLY;
            return response;
        }

        public IAsyncResult BeginDisconnect(uint dwReason, AsyncCallback fn)
        {
            byte[] message = null;
            unsafe
            {
                message = new byte[sizeof(DISCONNECT_MESSAGE)];
                fixed (byte* pMessage = &message[0])
                {
                    DISCONNECT_MESSAGE* pDisconnect = (DISCONNECT_MESSAGE*)pMessage;
                    pDisconnect->header.dwUserIndexFlags = _userIndexFlags;
                    pDisconnect->header.dwTotalSize = (uint)message.Length;
                    pDisconnect->header.dwProtocolVersion = SubNotiDefs.CURRENT_PROTOCOL_VERSION;
                    pDisconnect->header.dwMessageType = (int)MESSAGE_TYPES.eDisconnect;
                    pDisconnect->header.dwHeaderFlags = 0;

                    pDisconnect->dwReason = dwReason;
                }
            }

            ConnSrvMessageSendContext hsctxt = new ConnSrvMessageSendContext(message);
            IAsyncResult asy = _connection.Send(hsctxt, fn);

            return asy;
        }

        public void OnDisconnect(IAsyncResult asy)
        {
            DISCONNECT_REPLY reply = EndDisconnect(asy);
            //TODO: Commenting it for now. We need a way to ask server to see if the connection exists or not.
            //_state = PNConnectionState.NOT_CONNECTED;
        }

        public DISCONNECT_REPLY EndDisconnect(IAsyncResult asy)
        {
            DISCONNECT_REPLY response = asy.AsyncState as DISCONNECT_REPLY;
            return response;
        }

        public SUBSCRIBE_REPLY Subscribe(DATA_OBJECT_SPECIFIER[] rgDataObjects, int[] rgUserIndices, uint headerFlags)
        {
            IAsyncResult result = BeginSubscribe(rgDataObjects, SubNotiDefs.UserIndicesToFlags(rgUserIndices), headerFlags, new AsyncCallback(OnSubscribe));
            SyncWaitWithTimeout(result);
            SUBSCRIBE_REPLY response = result.AsyncState as SUBSCRIBE_REPLY;
            return response;
        }

        public SUBSCRIBE_REPLY Subscribe(DATA_OBJECT_SPECIFIER[] rgDataObjects, int[] rgUserIndices)
        {
            IAsyncResult result = BeginSubscribe(rgDataObjects, SubNotiDefs.UserIndicesToFlags(rgUserIndices), 0, new AsyncCallback(OnSubscribe));
            SyncWaitWithTimeout(result);
            SUBSCRIBE_REPLY response = result.AsyncState as SUBSCRIBE_REPLY;
            //Get the data from header that who called subscribe.
            int[] userIndices = SubNotiDefs.UserFlagsToIndices(response.header.dwUserIndexFlags);
            if (response.hr == HResult.S_OK)
            {
                //Get the dos from response, and add it to our collection for later use.
                for (int i = 0; i < response.dwNumDataObjects; i++)
                {
                    DATA_OBJECT_SPECIFIER doSpec = new DATA_OBJECT_SPECIFIER();
                    doSpec.qwOwnerXUID = response.rgDataObjects[i].qwOwnerXUID;
                    doSpec.wDataType = response.rgDataObjects[i].wDataType;
                    doSpec.dwDataSubType = response.rgDataObjects[i].dwDataSubType;
                    doSpec.wObjectSize = response.rgDataObjects[i].wObjectSize;
                    //Add it to dictionary for that user.
                    for (int j = 0; j < userIndices.Length; j++)
                    {
                        //SubscribedUsers[userIndices[j]].Add(SubNotiDefs.GetDataKeyString(doSpec), doSpec);
                    }
                }
            }
            return response;
        }

        public SUBSCRIBE_REPLY Subscribe(DATA_OBJECT_SPECIFIER[] rgDataObjects)
        {
            return this.Subscribe(rgDataObjects, SubNotiDefs.UserFlagsToIndices(_userIndexFlags));
        }

        public IAsyncResult BeginSubscribe(DATA_OBJECT_SPECIFIER[] rgDataObjects, uint userIndexFlags, uint headerFlags, AsyncCallback fn)
        {
            byte[] message = null;
            unsafe
            {
                uint numDataObjects = (uint)rgDataObjects.Length;
                message = new byte[sizeof(SUBSCRIBE_MESSAGE) + numDataObjects * sizeof(DATA_OBJECT_SPECIFIER)];
                fixed (byte* pMessage = &message[0])
                {
                    SUBSCRIBE_MESSAGE* pSubscribe = (SUBSCRIBE_MESSAGE*)pMessage;
                    pSubscribe->header.dwUserIndexFlags = userIndexFlags;
                    pSubscribe->header.dwTotalSize = (uint)message.Length;
                    pSubscribe->header.dwProtocolVersion = SubNotiDefs.CURRENT_PROTOCOL_VERSION;
                    pSubscribe->header.dwMessageType = (int)MESSAGE_TYPES.eSubscribe;
                    pSubscribe->header.dwHeaderFlags = headerFlags;

                    pSubscribe->dwNumDataObjects = numDataObjects;
                    DATA_OBJECT_SPECIFIER* pData = (DATA_OBJECT_SPECIFIER*)(pMessage + sizeof(SUBSCRIBE_MESSAGE));
                    for (int i = 0; i < numDataObjects; i++)
                    {
                        *pData = rgDataObjects[i];
                        pData++;
                    }
                }
            }

            ConnSrvMessageSendContext hsctxt = new ConnSrvMessageSendContext(message);
            IAsyncResult asy = _connection.Send(hsctxt, fn);

            return asy;
        }

        public void OnSubscribe(IAsyncResult asy)
        {
            SUBSCRIBE_REPLY reply = EndSubscribe(asy);
        }

        public SUBSCRIBE_REPLY EndSubscribe(IAsyncResult asy)
        {
            SUBSCRIBE_REPLY response = asy.AsyncState as SUBSCRIBE_REPLY;

            Global.RO.Info("Successfully subscribed to " + response.dwNumDataObjects + " items.");

            return response;
        }

        public UNSUBSCRIBE_REPLY Unsubscribe(DATA_OBJECT_SPECIFIER[] rgDataObjects, int[] rgUserIndices)
        {
            IAsyncResult result = BeginUnsubscribe(rgDataObjects, SubNotiDefs.UserIndicesToFlags(rgUserIndices), new AsyncCallback(OnUnsubscribe));
            SyncWaitWithTimeout(result);
            UNSUBSCRIBE_REPLY response = result.AsyncState as UNSUBSCRIBE_REPLY;
            //Remove user from our collection if s_ok
            if (response.hr == HResult.S_OK)
            {
                for (int i = 0; i < rgDataObjects.Length; i++)
                {
                    for (int j = 0; j < rgUserIndices.Length; j++)
                    {
                        //SubscribedUsers[rgUserIndices[j]].Remove(SubNotiDefs.GetDataKeyString(rgDataObjects[i]));
                    }
                }
            }
            return response;
        }

        public UNSUBSCRIBE_REPLY Unsubscribe(DATA_OBJECT_SPECIFIER[] rgDataObjects)
        {
            return this.Unsubscribe(rgDataObjects, SubNotiDefs.UserFlagsToIndices(_userIndexFlags));
        }

        public IAsyncResult BeginUnsubscribe(DATA_OBJECT_SPECIFIER[] rgDataObjects, uint userIndexFlags, AsyncCallback fn)
        {
            byte[] message = null;
            unsafe
            {
                uint numDataObjects = (uint)rgDataObjects.Length;
                message = new byte[sizeof(UNSUBSCRIBE_MESSAGE) + numDataObjects * sizeof(DATA_OBJECT_SPECIFIER)];
                fixed (byte* pMessage = &message[0])
                {
                    UNSUBSCRIBE_MESSAGE* pUnsubscribe = (UNSUBSCRIBE_MESSAGE*)pMessage;
                    pUnsubscribe->header.dwUserIndexFlags = userIndexFlags;
                    pUnsubscribe->header.dwTotalSize = (uint)message.Length;
                    pUnsubscribe->header.dwProtocolVersion = SubNotiDefs.CURRENT_PROTOCOL_VERSION;
                    pUnsubscribe->header.dwMessageType = (int)MESSAGE_TYPES.eUnsubscribe;
                    pUnsubscribe->header.dwHeaderFlags = 0;

                    pUnsubscribe->dwNumDataObjects = numDataObjects;
                    DATA_OBJECT_SPECIFIER* pData = (DATA_OBJECT_SPECIFIER*)(pMessage + sizeof(UNSUBSCRIBE_MESSAGE));
                    for (int i = 0; i < numDataObjects; i++)
                    {
                        *pData = rgDataObjects[i];
                        pData++;
                    }
                }
            }

            ConnSrvMessageSendContext hsctxt = new ConnSrvMessageSendContext(message);
            IAsyncResult asy = _connection.Send(hsctxt, fn);

            return asy;
        }

        public void OnUnsubscribe(IAsyncResult asy)
        {
            UNSUBSCRIBE_REPLY reply = EndUnsubscribe(asy);
        }

        public UNSUBSCRIBE_REPLY EndUnsubscribe(IAsyncResult asy)
        {
            UNSUBSCRIBE_REPLY response = asy.AsyncState as UNSUBSCRIBE_REPLY;
            return response;
        }

        public QUERY_REPLY Query(DATA_OBJECT_SPECIFIER[] rgDataObjects)
        {
            IAsyncResult result = BeginQuery(rgDataObjects, new AsyncCallback(OnQuery));
            SyncWaitWithTimeout(result);
            QUERY_REPLY response = result.AsyncState as QUERY_REPLY;
            return response;
        }

        public IAsyncResult BeginQuery(DATA_OBJECT_SPECIFIER[] rgDataObjects, AsyncCallback fn)
        {
            byte[] message = null;
            unsafe
            {
                uint numDataObjects = (uint)rgDataObjects.Length;
                message = new byte[sizeof(QUERY_MESSAGE) + numDataObjects * sizeof(DATA_OBJECT_SPECIFIER)];
                fixed (byte* pMessage = &message[0])
                {
                    QUERY_MESSAGE* pQuery = (QUERY_MESSAGE*)pMessage;
                    pQuery->header.dwUserIndexFlags = _userIndexFlags;
                    pQuery->header.dwTotalSize = (uint)message.Length;
                    pQuery->header.dwProtocolVersion = SubNotiDefs.CURRENT_PROTOCOL_VERSION;
                    pQuery->header.dwMessageType = (int)MESSAGE_TYPES.eQuery;
                    pQuery->header.dwHeaderFlags = 0;

                    pQuery->dwNumDataObjects = numDataObjects;
                    DATA_OBJECT_SPECIFIER* pData = (DATA_OBJECT_SPECIFIER*)(pMessage + sizeof(QUERY_MESSAGE));
                    for (int i = 0; i < numDataObjects; i++)
                    {
                        *pData = rgDataObjects[i];
                        pData++;
                    }
                }
            }

            ConnSrvMessageSendContext hsctxt = new ConnSrvMessageSendContext(message);
            IAsyncResult asy = _connection.Send(hsctxt, fn);

            return asy;
        }

        public void OnQuery(IAsyncResult asy)
        {
            EndQuery(asy);
        }

        public QUERY_REPLY EndQuery(IAsyncResult asy)
        {
            QUERY_REPLY response = asy.AsyncState as QUERY_REPLY;
            return response;
        }

        /// <summary>
        /// Used to publish the given data w/ corresponding DATA_OBJECT_SPECIFIER to Acceleration
        /// </summary>
        /// <param name="rgDataObjects">Array of DATA_OBJECT_SPECIFIERs directly corresponding to the same index in the rgData array</param>
        /// <param name="rgData">Array of byte[] holding data for each item to publish</param>
        /// <returns></returns>
        public PUBLISH_REPLY Publish(DATA_OBJECT_SPECIFIER[] rgDataObjects, byte[][] rgData)
        {
            if (rgDataObjects.Length != rgData.Length || rgDataObjects.Length == 0)
                return null;

            IAsyncResult result = BeginPublish(rgDataObjects, rgData, new AsyncCallback(OnPublish));
            SyncWaitWithTimeout(result);
            PUBLISH_REPLY response = result.AsyncState as PUBLISH_REPLY;
            return response;
        }

        public IAsyncResult BeginPublish(DATA_OBJECT_SPECIFIER[] rgDataObjects, byte[][] rgData, AsyncCallback fn)
        {
            byte[] message = null;
            unsafe
            {
                int numDataObjects = rgDataObjects.Length;
                byte[][] rgBlobs = new byte[numDataObjects][];
                int totalSize = sizeof(PUBLISH_MESSAGE);

                // Lets build each of the inner blobs
                for (int doSpec = 0; doSpec < numDataObjects; ++doSpec)
                {
                    byte[] blob = new byte[sizeof(BASE_DATA_HEADER) + rgData[doSpec].Length];
                    
                    // Set up the header
                    fixed (byte* pBlob = &blob[0])
                    {
                        BASE_DATA_HEADER* pHeader = (BASE_DATA_HEADER*)pBlob;
                        pHeader->doSpec = rgDataObjects[doSpec];
                        pHeader->dwHeaderFlags = 0;
                    }

                    // Copy in the data
                    System.Buffer.BlockCopy(rgData[doSpec], 0, blob, sizeof(BASE_DATA_HEADER), rgData[doSpec].Length);

                    totalSize += blob.Length;
                    rgBlobs[doSpec] = blob;
                }

                // Create the epic publish blob
                message = new byte[totalSize];

                // Set up the header
                fixed (byte* pMessage = &message[0])
                {
                    PUBLISH_MESSAGE* pPublish = (PUBLISH_MESSAGE*)pMessage;
                    pPublish->header.dwUserIndexFlags = _userIndexFlags;
                    pPublish->header.dwTotalSize = (uint)message.Length;
                    pPublish->header.dwProtocolVersion = SubNotiDefs.CURRENT_PROTOCOL_VERSION;
                    pPublish->header.dwMessageType = (int)MESSAGE_TYPES.ePublish;
                    pPublish->header.dwHeaderFlags = 0;
                    pPublish->dwNumDataObjects = (uint)numDataObjects;
                }

                // Now copy in all the baby blobs
                int blobOffset = sizeof(PUBLISH_MESSAGE);
                for (int blob = 0; blob < numDataObjects; ++blob)
                {
                    System.Buffer.BlockCopy(rgBlobs[blob], 0, message, blobOffset, rgBlobs[blob].Length);
                    blobOffset += rgBlobs[blob].Length;
                }
            }

            ConnSrvMessageSendContext hsctxt = new ConnSrvMessageSendContext(message);
            IAsyncResult asy = _connection.Send(hsctxt, fn);

            return asy;
        }

        public void OnPublish(IAsyncResult asy)
        {
            EndPublish(asy);
        }

        public PUBLISH_REPLY EndPublish(IAsyncResult asy)
        {
            PUBLISH_REPLY response = asy.AsyncState as PUBLISH_REPLY;
            return response;
        }

        public event ConnSrvConnection.NotifiedEventHandler Notified;
 
        private List<DATA_NOTIFICATION> NotificationRecd = new List<DATA_NOTIFICATION>();

        public List<DATA_NOTIFICATION> NotificationsReceived
        {
            get
            {
                return NotificationRecd;
            }
        }

        private void OnNotification(object oSender, ConnSrvConnection.NotifiedEventArgs args)
        {
            if (oSender != _connection)
            {
                // not the connection we care about.  
                ConnSrvConnection connection = oSender as ConnSrvConnection;
                if (connection != null)
                {
                    // best chance to kill it
                    try
                    {
                        connection.Close();
                    }
                    catch{}
                }
                return;
            }

            // echo the notification to any subscribers
            DATA_NOTIFICATION dn = (DATA_NOTIFICATION)args.In;
            this.NotificationRecd.Add(dn);

            Global.RO.Warn("Notification Received!");
            Global.RO.Warn("  Owner: " + dn.rgDataObjects[0].qwOwnerXUID.ToString("X"));
            Global.RO.Warn("  DataType: " + dn.rgDataObjects[0].wDataType);
            Global.RO.Warn("  ObjectSize: " + dn.rgDataObjects[0].wObjectSize);
            

            if (Notified != null)
            {
                Notified(oSender, args);
            }
        }

        public void ClearNotificationRecievedList()
        {
            this.NotificationRecd.Clear();
        }

        public bool VerifyIndividualNotificationReceived(DATA_OBJECT_SPECIFIER doSpec, uint userIndex, int waitSeconds)
        {
            /*
             * poll for some amount of time.
             * in a loop
             * check the queue if there is anything in there.
             * dequeue it and verify against datakeystring
            */

            int sleepTime = 1000;//mili seconds
            int loopctr = sleepTime * waitSeconds;
            for (int i = 0; i <= loopctr; i+=100)
            {
                foreach (DATA_NOTIFICATION d in this.NotificationRecd)
                {
                    if (d.dwNumDataObjects != 0)
                    {
                        foreach (SUBSCRIPTION_DATA s in d.rgDataObjects)
                        {
                            if (s.qwOwnerXUID == doSpec.qwOwnerXUID &&
                                s.wDataType == doSpec.wDataType &&
                                s.wObjectSize == doSpec.wObjectSize &&
                                (d.header.dwUserIndexFlags & (1 << (int)userIndex)) == (1 << (int)userIndex))
                            {
                                return true;
                            }
                        }
                    }
                }
                System.Threading.Thread.Sleep(100);
            }
            Global.RO.Warn("Notification not found for key: " + CacheUtil.GetDataKeyString(doSpec));
            return false;
        }

        public bool VerifyNotificationsReceived(DATA_OBJECT_SPECIFIER[] doSpecs, uint userIndex, int waitSeconds)
        {
            foreach (DATA_OBJECT_SPECIFIER dos in doSpecs)
            {
                if (! this.VerifyIndividualNotificationReceived(dos, userIndex, waitSeconds))
                    return false;
            }

            return true;
        }

        public bool VerifyNotificationSize(DATA_OBJECT_SPECIFIER doSpec, uint userIndex)
        {
            foreach (DATA_NOTIFICATION d in this.NotificationRecd)
            {
                if (d.dwNumDataObjects != 0)
                {
                    foreach (SUBSCRIPTION_DATA s in d.rgDataObjects)
                    {
                        if (s.qwOwnerXUID == doSpec.qwOwnerXUID && s.wDataType == doSpec.wDataType)
                        {
                            if (s.wObjectSize == doSpec.wObjectSize)
                                return true;
                            else
                                return false;
                        }
                    }
                }
            }
            return false;
        }

        public bool VerifyNotificationPrivacy(int expectedPrivacy)
        {
            if (expectedPrivacy == CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE)
                expectedPrivacy = CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE | CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS;

            foreach (DATA_NOTIFICATION d in this.NotificationRecd)
            {
                if (d.dwNumDataObjects != 0)
                {
                    foreach (SUBSCRIPTION_DATA s in d.rgDataObjects)
                    {
                        if ((s.dwHeaderFlags & expectedPrivacy) != expectedPrivacy)
                        {
                            if (s.data.Length == 0) continue; //offline notification doesn't matter. it is always share everyone.
                            Global.RO.Warn("Notification privacy mismatch. Actual: " + s.dwHeaderFlags + " != Expected: " + expectedPrivacy);
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        public uint GetTotalNotificationsLength()
        {
            return GetTotalNotificationsLength(false);
        }

        public uint GetTotalNotificationsLength(bool filterOffline)
        {
            uint count = 0;
            foreach (DATA_NOTIFICATION d in this.NotificationRecd)
            {
                foreach (SUBSCRIPTION_DATA s in d.rgDataObjects)
                {
                    if (s.data.Length == 0 & filterOffline)
                        continue;
                    if ((s.wDataType == (ushort)DATA_TYPES.eBasicPresence) || (s.wDataType == (ushort)DATA_TYPES.eRichPresenceString))
                        count++;
                }
            }
            return count;
        }

        public SUBSCRIPTION_DATA GetNotification(DATA_OBJECT_SPECIFIER doSpec, bool filterOffline)
        {
            SUBSCRIPTION_DATA result = null;
            foreach (DATA_NOTIFICATION d in this.NotificationRecd)
            {
                if (d.dwNumDataObjects != 0)
                {
                    foreach (SUBSCRIPTION_DATA s in d.rgDataObjects)
                    {
                        if (s.qwOwnerXUID == doSpec.qwOwnerXUID && s.wDataType == doSpec.wDataType)
                        {
                            if (s.wObjectSize == doSpec.wObjectSize)
                            {
                                result = s;
                                break;
                            }
                        }
                    }
                }
            }

            if (result != null && filterOffline && result.data.Length == 0) //offline notif has data length of 0
                result = null;

            return result;
        }
        public SUBSCRIPTION_DATA GetNotification(DATA_OBJECT_SPECIFIER doSpec)
        {
            return GetNotification(doSpec, false);
        }

        public void OnClosed(object oSender, EventArgs o)
        {
            if (oSender != _connection)
            {
                // don't care
                return;
            }
            Global.RO.Debug("Connection closed. Good bye.");
            this._state = PNConnectionState.NOT_CONNECTED;
        }

        public IPAddress ClientIPAddr {
            get
            {
                IPEndPoint ipe = (IPEndPoint)_connection.Socket.LocalEndPoint;
                return ipe.Address;
            }
        }

        public int ClientIPPort
        {
            get
            {
                IPEndPoint ipe = (IPEndPoint)_connection.Socket.LocalEndPoint;
                return ipe.Port;
            }
        }

        public PNConnectionState State
        {
            get
            {
                return _state;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\XCrypto\XRLXCryptoDecrypt.cs ===
using System;
using System.Net;
using System.IO;
using System.Collections;
using System.Security.Cryptography;
using System.Globalization;
using ServerTestFramework;
using xonline.common.config;
using xonline.common.protocol;

namespace ServerTestFramework.LiveService.XCrypto
{
    public class XRLXCryptoDecrypt : XRLPayload<XCryptoDecryptRequest, XCryptoDecryptResponse>
    {
        public override bool Execute()
        {
            return base.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xcrypto_int));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\XConnSrv\FakeMC\FakeMemCache.cs ===
ï»¿using System;
using System.Net;
using System.Collections;
using System.Collections.Generic;
using Microsoft.Data.Caching;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using xonline.common.config;
using xonline.common.service;

using ServerTestFramework.Utilities;

namespace ServerTestFramework.LiveService.XConnSrv.FakeMC
{
    public abstract class PresenceCacheBase
    {
        public abstract byte[] Get(string key);
        public abstract void Set(string key, byte[] data);
    }
    public class FakeMemCache : PresenceCacheBase
    {

        #region Events

        public enum FMC_DataChanges
        {
            FMC_Add,
            FMC_Delete,
            FMC_Update
        }

        public class DataChangeEventArgs : EventArgs
        {
            public DataChangeEventArgs(FMC_DataChanges changeType, string key, byte[] data)
            {
                _changeType = changeType;
                _key = key;
                _data = data;
            }
            public FMC_DataChanges ChangeType
            {
                get
                {
                    return _changeType;
                }
            }

            public string Key
            {
                get
                {
                    return _key;
                }
            }

            public byte[] Data
            {
                get
                {
                    return _data;
                }
            }

            private readonly FMC_DataChanges _changeType;
            private readonly string _key;
            private readonly byte[] _data;
        }

        public event DataChangeEventHandler DataChanged;
        public delegate void DataChangeEventHandler(object oSender, DataChangeEventArgs oArgs);
        #endregion


        public Dictionary<string, byte[]> _cache = new Dictionary<string, byte[]>();

        /// <summary>
        /// Default Constructor
        /// </summary>
        public FakeMemCache()
        {
        }

        /// <summary>
        /// Used to get the data associated with a given key
        /// </summary>
        /// <param name="key">key for desired data</param>
        /// <returns>byte[] of data, null if invalid key</returns>
        public override byte[] Get(string key)
        {
            byte[] data = null;
            try
            {
                data = _cache[key];
            }
            catch (Exception)
            {
                //if (key == null)
                //    throw new ArgumentNullException("Null keys are not allowed.", e);
                //else
                //    throw new KeyNotFoundException("Key " + key + " not found in Dictionary.", e);
            }

            return data;
        }

        /// <summary>
        /// Sets the data for the given key. A new entry will be created if the key doesn't exist.
        /// </summary>
        /// <param name="key">key for data</param>
        /// <param name="data">data to be set</param>
        public override void Set(string key, byte[] data)
        {
            if (key != null)
            {
                DataChangeEventArgs args = null;
                if (data == null)
                {
                    args = new DataChangeEventArgs(FMC_DataChanges.FMC_Delete, key, data);
                    _cache.Remove(key);
                }
                else if (_cache.ContainsKey(key))
                {
                    args = new DataChangeEventArgs(FMC_DataChanges.FMC_Update, key, data);
                    _cache[key] = data;
                }
                else
                {
                    args = new DataChangeEventArgs(FMC_DataChanges.FMC_Add, key, data);
                    _cache[key] = data;
                }

                if (DataChanged != null)
                {
                    DataChanged(this, args);
                }
            }
        }
    }

    public class VelocityCache : PresenceCacheBase
    {
        private DataCache VelCache;
        public VelocityCache()
        {
            //This will send the velocity traces to xonline.
            DataCacheLogSink consoleBasedSink = new DataCacheLogSink(DataCacheSinkType.CONSOLE, System.Diagnostics.TraceLevel.Warning);
            List<DataCacheLogSink> sinkList = new List<DataCacheLogSink>(1);
            sinkList.Add(consoleBasedSink);
            DataCacheFactory.CreateLogSinks(sinkList);

            //Get XNotiCache details from npdb
            IPEndPoint[] tmp = Global.XEnv.GetInterface(Interface.XNotiCache);
            DataCacheServerEndpoint[] rgEndpoints = new DataCacheServerEndpoint[tmp.Length];
            for (int iServer = 0; iServer < tmp.Length; iServer++)
            {
                rgEndpoints[iServer] = new DataCacheServerEndpoint(tmp[iServer].Address.ToString(), tmp[iServer].Port, "DistributedCacheService");
            }

            //Create CacheFactory and Create Cache.
            DataCacheFactory s_CacheFactory = new DataCacheFactory(rgEndpoints, true, false);
            VelCache = s_CacheFactory.GetCache(Interface.XNotiCache);
        }

        public VelocityCache(string velocityServer, int cachePort, string cacheName)
        {
            //Non npdb cache creation
            DataCacheServerEndpoint spEnd = new DataCacheServerEndpoint(velocityServer, cachePort, "DistributedCacheService");//should we hardcode this DistributedCacheService????
            DataCacheFactory factory = new DataCacheFactory(new DataCacheServerEndpoint[] { spEnd }, true, false);
            VelCache = factory.GetCache(cacheName);
        }

        public override byte[] Get(string key)
        {
            byte[] data = null;
            try
            {
                DataCacheItem i = VelCache.GetCacheItem(key);
                data = (byte[]) i.Value;
            }
            catch (Exception e)
            {
                throw new KeyNotFoundException("Key " + key + " not found in Velocity.", e);
            }

            return data;
        }

        public override void Set(string key, byte[] data)
        {
            if (key != null)
            {
                if (data == null)
                {
                    //remove
                    VelCache.Remove(key);
                }
                else if (VelCache.GetCacheItem(key) != null)
                {
                    //update
                    VelCache.Put(key, data);
                }
                else
                {
                    //add
                    VelCache.Add(key, data);
                }
            }
        }
    }

    public class AccelerationCache : PresenceCacheBase
    {
        private Acceleration aCache;
        public AccelerationCache()
        {
            System.Reflection.Assembly ass ;
            unsafe
	        {
                ass = System.Reflection.Assembly.GetAssembly(typeof(xonline.common.service.Acceleration));
	        }
            xonline.common.mgmt.XomPerformanceCounterCategory.InitPerfCtrs(ass);
            aCache = new Acceleration(Interface.NotificationCache);
        }

        public override byte[] Get(string key)
        {
            System.Text.ASCIIEncoding  encoding = new System.Text.ASCIIEncoding();
            byte[] keyBytes = encoding.GetBytes(key);
            byte[] result;

            uint hr = aCache.Query(keyBytes, out result);
            
            if (! HResult.Succeeded(hr))
            {
               throw new HResultException(hr, "Query returned hr = 0x" + hr.ToString("X"));
            }

            return result;
        }

        public override void Set(string key, byte[] data)
        {
            if (key != null)
            {
                System.Text.ASCIIEncoding  encoding = new System.Text.ASCIIEncoding();
                byte[] keyBytes = encoding.GetBytes(key);

                if (data == null)
                {
                    //remove
                    aCache.Remove(keyBytes);
                }
                else
                {
                    //add/edit
                    aCache.SetData(keyBytes, data, 0, 0);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\XConnSrv\FakeMC\MCServerNetwork.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Diagnostics;

namespace ServerTestFramework.LiveService.XConnSrv.FakeMC
{

    public class MCServerNetwork
    {
        private static MCServerNetwork _Network = null;
        private static ushort TCPPort = 3075;
        public static PresenceCacheBase _memCache ;
       
        public static void Initialize()
        {
            if (_Network != null)
                throw new Exception("MCServerNetwork already initialized");
            _memCache = new AccelerationCache();
            Global.RO.Info("AccelerationCache Initialized.");
        }
        public static void Shutdown()
        {
            _Network.Stop();
        }

        private Socket _Socket;
        private Hashtable EstablishedConnections = new Hashtable();
        private ArrayList PendingConnections = new ArrayList();

        public void Stop()
        {
            _Socket.Close();
            _Socket = null;
        }

        public void StartListening()
        {
            _Socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            _Socket.Blocking = false;

            _Socket.Bind(new IPEndPoint(IPAddress.Any, TCPPort));
            _Socket.Listen(5);

            _Socket.BeginAccept(new AsyncCallback(this.OnAcceptComplete), this);
        }

        private void OnAcceptComplete(IAsyncResult ar)
        {
            // Wrap the incoming socket in a connection object
            if (null != _Socket)
            {
                Socket s = _Socket.EndAccept(ar);

                OnClientAccepted(s);

                // Prepare the next accept
                _Socket.BeginAccept(new AsyncCallback(this.OnAcceptComplete), this);
            }
        }

        // Called from the accept socket to add new client connections
        private void OnClientAccepted(Socket socket)
        {
            lock (this)
            {
                Connection conn = new Connection(socket);
                PendingConnections.Add(conn);
                // this will register itself when the connection becomes established(after hello)
                new MessageHandler(this, conn);
            }
        }

        public void OnClientEstablished(MessageHandler msgHandler)
        {
            lock (this)
            {
                PendingConnections.Remove(msgHandler.Connection);
                string ClientKey = msgHandler.ClientKey;
                if (EstablishedConnections.ContainsKey(ClientKey))
                {
                    MessageHandler oldMsgHandler = EstablishedConnections[ClientKey] as MessageHandler;
                    oldMsgHandler.AttachConnection(msgHandler.Connection);
                    msgHandler.DetatchConnection();
                }
                else
                {
                    EstablishedConnections.Add(ClientKey, msgHandler);
                }
            }
        }

        public byte[] GetData(string key)
        {
            return _memCache.Get(key);
        }

        public void SetData(string key, byte[] data)
        {
            _memCache.Set(key, data);
        }

        public static void Notify(MCNotificationResponse resp)
        {
            foreach (MessageHandler handler in _Network.EstablishedConnections.Values)
            {
                handler.SendMessage(resp);
            }
        }
    }

    public class MessageHandler
    {
        private MCServerNetwork _Network = null;
        private Connection _Connection = null;
        private string _ClientKey = null;
        private const uint MaxDeferredQueueSize = 2048;
        private Queue _DeferredMessageQueue = Queue.Synchronized(new Queue());
        private int Sending = 0;

        public MessageHandler(MCServerNetwork Network, Connection Conn)
        {
            AttachConnection(Conn);
            _Network = Network;
        }

        public void AttachConnection(Connection Conn)
        {
            if (_Connection != null)
            {
                _Connection.Disconnect();
                DetatchConnection();
            }

            _Connection = Conn;
            _Connection.Received += new Connection.ReceivedEventHandler(OnReceivedEventHandler);
            _Connection.SentNotification += new Connection.Sent(OnSent);



            // start to send 
            OnSent(_Connection);
        }

        public void DetatchConnection()
        {
            if (_Connection != null)
            {
                _Connection.Received -= new Connection.ReceivedEventHandler(OnReceivedEventHandler);
                _Connection.SentNotification -= new Connection.Sent(OnSent);
                _Connection = null;
            }
        }



        private void OnReceivedEventHandler(object oSender, Connection.ReceivedEventArgs oArgs)
        {
            if (_Connection != oSender)
            {
                return;
            }

            switch (oArgs.MessageType)
            {
                // Just a test message for now
                case MC_MSG_TYPES.MCMSG_HELLO_REQ:
                    {
                        MCHelloMsgData msgData = oArgs.MessageData as MCHelloMsgData;
                        this._ClientKey = msgData.szDescription;
                        _Network.OnClientEstablished(this);

                        // TODO: Debug output
                        Console.WriteLine("HELLO: " + msgData.szDescription);
                    }
                    break;
                // Requests data for the contained key
                case MC_MSG_TYPES.MCMSG_GET_SINGLE_REQ:
                    {
                        MCGetSingleMsgData msgData = oArgs.MessageData as MCGetSingleMsgData;
                        byte[] data = _Network.GetData(msgData._key);

                        _Connection.OnGetRequest(this);

                        // TODO: Debug output
                        string debugOutput = "GET SINGLE: key=" + msgData._key + " (size " + msgData._keyLength + ") data=";
                        if (data != null)
                        {
                            foreach (byte b in data)
                                debugOutput += b + ", ";
                            debugOutput += "(size " + data.Length + ")";
                        }
                        else
                            debugOutput += "NULL";
                        Console.WriteLine(debugOutput);

                        // Send response
                        MCMessage message = new MCGetSingleResponse(msgData._key, data);
                        message._Header.dwSeqNum = oArgs.SequenceNumber;
                        SendMessage(message);
                        //SendMessage(new MCNotificationResponse(new string[] { "a", "ab", "abc" }));
                    }
                    break;
                case MC_MSG_TYPES.MCMSG_SET_SINGLE_REQ:
                    {
                        MCSetSingleMsgData msgData = oArgs.MessageData as MCSetSingleMsgData;
                        _Network.SetData(msgData._key, msgData._data);

                        _Connection.OnSetRequest(this);

                        // TODO: Debug output
                        string debugOutput = "SET SINGLE: key=" + msgData._key + " (size " + msgData._keyLength + ") data=";
                        if (msgData._data != null)
                            foreach(byte b in msgData._data)
                                debugOutput += b + ", ";
                        debugOutput += "(size " + msgData._dataSize + ")";
                        Console.WriteLine(debugOutput);
                    }
                    break;
            }

        }

        public void SendMessage(MCMessage Message)
        {
            int sending = Interlocked.Exchange(ref Sending, 1);
            // we are connected and we aren't waiting on a send
            if (_Connection.Connected && sending == 0)
            {
                _Connection.SendMessage(Message);
            }
            else
            {
                lock (_DeferredMessageQueue.SyncRoot)
                {
                    if (Sending == 0)
                    {
                        _Connection.SendMessage(Message);
                    }
                    else
                    {
                        _DeferredMessageQueue.Enqueue(Message);
                    }
                }
            }
        }

        private void OnSent(object oSender)
        {
            if (_Connection != oSender)
            {
                return;
            }
            lock(_DeferredMessageQueue.SyncRoot)
            {
                if (_Connection.Connected && _DeferredMessageQueue.Count > 0)
                {
                    MCMessage Message = _DeferredMessageQueue.Dequeue() as MCMessage;
                    if (Message != null)
                    {
                        _Connection.SendMessage(Message);
                    }
                }
                else
                {
                    Interlocked.Exchange(ref Sending, 0);
                }
            }
        }

        public string ClientKey
        {
            get
            {
                return _ClientKey;
            }
        }

        public Connection Connection
        {
            get
            {
                return _Connection;
            }
        }
    }

    public class Connection
    {
        private const int DefaultContextBufferSize = 512;
        private MCMessageHeader _Header = null;
        private MCMessageData _Data = null;
        
        // Context used to track async message completions
        // for send
        private class SendContext
        {
            public byte[] Payload;
            public int Pending;
        }

        public enum State
        {
            Disconnected,
            Disconnecting,
            Connecting,
            Connected
        }

        // Connection settings
        private Socket _Socket;

        // Local packet queue
        private State _State;
        private Exception _Exception;
        private byte[] _Scratch;
        private MemoryStream _ReadBuffer;

        #region Events

        public class ReceivedEventArgs : EventArgs
        {
            public ReceivedEventArgs(MC_MSG_TYPES messageType, MCMessageData Data, uint sequenceNumber)
            {
                this.messageType = messageType;
                this.Data = Data;
                this.sequenceNumber = sequenceNumber;
            }
            public MC_MSG_TYPES MessageType
            {
                get
                {
                    return messageType;
                }
            }

            public object MessageData
            {
                get
                {
                    return Data;
                }
            }

            public uint SequenceNumber
            {
                get
                {
                    return sequenceNumber;
                }
            }

            private readonly MC_MSG_TYPES messageType;
            private readonly MCMessageData Data;
            private readonly uint sequenceNumber;
        }
        
        public event ReceivedEventHandler Received;
        public delegate void ReceivedEventHandler(object oSender, ReceivedEventArgs oArgs);

        public Sent SentNotification;
        public delegate void Sent(object oSender);

        public static event GetRequestEventHandler GetRequest;
        public delegate void GetRequestEventHandler(object oSender);

        public static event SetRequestEventHandler SetRequest;
        public delegate void SetRequestEventHandler(object oSender);
        
        #endregion

        //
        // Property accessors
        //
        public bool Connected
        {
            get
            {
                return State.Disconnected != _State && State.Disconnecting != _State;
            }
        }

        public bool IsDisconnected
        {
            get
            {
                return State.Disconnected == _State;
            }
        }

        public State SocketState
        {
            get
            {
                return _State;
            }
        }

        public bool IsDiconnected
        {
            get
            {
                return State.Disconnected == _State;
            }
        }

        public Connection(Socket socket)        
        {
            _Scratch = new byte[DefaultContextBufferSize * 4];
            _ReadBuffer = new MemoryStream(DefaultContextBufferSize);
            AttachSocket(socket);
            StartReading((int)MCDefs.MC_MESSAGE_HEADER_SIZE);
        }

        public void AttachSocket(Socket socket)
        {
            _Exception = null;
            _Socket = socket;

            if (null != _Socket && _Socket.Connected)
            {
                _State = State.Connected;
                _Socket.Blocking = false;
                _Socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.SendBuffer, 0);
                _Socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveBuffer, 0);
            }
            else
            {
                _State = State.Disconnected;
            }
        }

        public void Disconnect()
        {
            if (null != _Socket && _Socket.Connected)
            {
                _State = State.Disconnecting;
                _Socket.Shutdown(SocketShutdown.Send);
                try
                {
                    _Socket.BeginReceive(_Scratch, 0, _Scratch.Length, 0, new AsyncCallback(this.OnReceiveComplete), this);
                }
                catch
                {
                    // Socket was either intentionally closed locally by a previous call to disconnect
                    // or closed by the remote party 
                    _State = State.Disconnected;
                    _Socket = null;
                }
            }
            else
            {
                try
                {
                    Socket s = _Socket;

                    // Clear members first in case the close throws
                    _Socket = null;
                    _State = State.Disconnected;

                    if (null != s)
                    {
                        s.Close();
                    }
                }
                catch (Exception)
                {
                    // Ignore errors here on final shutdown
                }
            }
        }

        public void SendMessage(MCMessage msg)
        {
            SendContext ctx = new SendContext();

            // Turn the stream into a payload and push it to the async socket
            ctx.Payload = (byte[])msg;
            ctx.Pending = ctx.Payload.Length;

            _Socket.BeginSend(
                    ctx.Payload,
                    0,
                    ctx.Pending,
                    0,
                    new AsyncCallback(this.OnSendComplete),
                    ctx);
        }
        
        private void OnSendComplete(IAsyncResult ar)
        {
            try
            {
                int written = _Socket.EndSend(ar);
                SendContext ctx = ar.AsyncState as SendContext;

                if (null == ctx)
                {
                    throw new ApplicationException("Invalid context async result state was null");
                }

                ctx.Pending -= written;

                if (ctx.Pending < 0)
                {
                    throw new ApplicationException("Invalid send, sent more bytes than were pending on context.");
                }
                else if (ctx.Pending > 0)
                {
                    // Continue sending payload
                    _Socket.BeginSend(
                        ctx.Payload,
                        ctx.Payload.Length - ctx.Pending,
                        ctx.Pending,
                        0,
                        new AsyncCallback(this.OnSendComplete),
                        ctx);
                }
                else
                {
                    // message complete
                    if (SentNotification != null)
                    {
                        SentNotification(this);
                    }
                }
         
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        public void StartReading(int Size)
        {
            if (State.Connected == _State || State.Disconnecting == _State)
            {
                _Socket.BeginReceive(_Scratch, 0, Size > _Scratch.Length ? _Scratch.Length : Size, 0, new AsyncCallback(this.OnReceiveComplete), this);
            }
            else
            {
                throw new ApplicationException(
                        String.Format("Invalid connection state: {0} for StartReading() (requires Connected or Disconnecting)",
                            _State.ToString()));
            }
        }

        private void OnReceiveComplete(IAsyncResult ar)
        {
            try
            {
                int received = 0;

                if (null != _Socket)
                {
                    received = _Socket.EndReceive(ar);
                }

                if (0 == received)
                {
                    // Socket was either intentionally closed locally by a previous call to disconnect
                    // or closed by the remote party 
                    _State = State.Disconnected;
                    Disconnect();
                    return;
                }

                if (_State != State.Connected)
                {
                    return;
                }

                if (received > _Scratch.Length)
                {
                    throw new Exception("Invalid receive, received bytes exceeds scratch buffer size");
                }

                // Buffer reads at the end of the read buffer
                _ReadBuffer.Seek(0, SeekOrigin.End);
                _ReadBuffer.Write(_Scratch, 0, received);
                // Parse header if we don't have it yet
                if (_Header == null)
                {
                    if (_ReadBuffer.Length == MCDefs.MC_MESSAGE_HEADER_SIZE)
                    {
                        _Header = new MCMessageHeader();
                        _ReadBuffer.Seek(0, SeekOrigin.Begin);
                        _Header.ReadStream(_ReadBuffer);
                        _ReadBuffer.SetLength(0);
                        StartReading((int)(_Header.dwMsgLen));
                    }
                    else if(_ReadBuffer.Length > MCDefs.MC_MESSAGE_HEADER_SIZE)
                    {
                        // this shouldn't happen.  
                        throw new Exception("This Shouldn't Happen");
                    }
                    else
                    {
                        // read the rest
                        StartReading((int)(MCDefs.MC_MESSAGE_HEADER_SIZE - _ReadBuffer.Length));
                    }
                }
                else
                {
                    if (_ReadBuffer.Length == _Header.dwMsgLen)
                    {
                        _Data = MCMessageData.GetInstance(_Header);
                        _ReadBuffer.Seek(0, SeekOrigin.Begin);
                        _Data.ReadStream(_ReadBuffer);
                        _ReadBuffer.SetLength(0);

                        // Do something with the Data
                        ReceivedEventArgs rea = new ReceivedEventArgs((MC_MSG_TYPES)_Header.dwMsgType, _Data, _Header.dwSeqNum);
                        if (Received != null)
                        {
                            Received(this, rea);
                        }

                        // Start all over again
                        _Header = null;
                        _Data = null;
                        StartReading((int)(MCDefs.MC_MESSAGE_HEADER_SIZE));
                    }
                    else if (_ReadBuffer.Length > _Header.dwMsgLen)
                    {
                        // this shouldn't happen.  
                        throw new Exception("This Shouldn't Happen");
                    }
                    else
                    {
                        // read the rest
                        StartReading((int)(_Header.dwMsgLen - _ReadBuffer.Length));
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        public void OnGetRequest(object sender)
        {
            if (GetRequest != null)
            {
                GetRequest(sender);
            }
        }

        public void OnSetRequest(object sender)
        {
            if (SetRequest != null)
            {
                SetRequest(sender);
            }
        }

        // 
        // Internal interface
        //
        private void HandleException(Exception ex)
        {
            _Exception = ex;
            Disconnect();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\XCrypto\XRLXCryptoSign.cs ===
using System;
using System.Net;
using System.IO;
using System.Collections;
using System.Security.Cryptography;
using System.Globalization;
using ServerTestFramework;
using xonline.common.config;
using xonline.common.protocol;

namespace ServerTestFramework.LiveService.XCrypto
{
    public class XRLXCryptoSign : XRLPayload<XCryptoSignRequest, XCryptoSignResponse>
    {
        public override bool Execute()
        {
            return base.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xcrypto_int));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\XCrypto\XRLXCryptoVerifyConsolePak.cs ===
using System;
using System.Net;
using System.IO;
using System.Collections;
using System.Security.Cryptography;
using System.Globalization;
using ServerTestFramework;
using xonline.common.config;
using xonline.common.protocol;

namespace ServerTestFramework.LiveService.XCrypto
{
    public class XRLXCryptoVerifyConsolePak : XRLPayload<XCryptoVerifyConsolePakRequest, XCryptoVerifyConsolePakResponse>
    {
        public override bool Execute()
        {
            return base.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xcrypto_int));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\XCrypto\XRLXCryptoEncrypt.cs ===
using System;
using System.Net;
using System.IO;
using System.Collections;
using System.Security.Cryptography;
using System.Globalization;
using ServerTestFramework;
using xonline.common.config;
using xonline.common.protocol;

namespace ServerTestFramework.LiveService.XCrypto
{
    public class XRLXCryptoEncrypt : XRLPayload<XCryptoEncryptRequest, XCryptoEncryptResponse>
    {
        public override bool Execute()
        {
            return base.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xcrypto_int));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\XCrypto\XRLXCryptoVerifySignature.cs ===
using System;
using System.Net;
using System.IO;
using System.Collections;
using System.Security.Cryptography;
using System.Globalization;
using ServerTestFramework;
using xonline.common.config;
using xonline.common.protocol;

namespace ServerTestFramework.LiveService.XCrypto
{
    public class XRLXCryptoVerifySignature : XRLPayload<XCryptoVerifySignatureRequest, XCryptoVerifySignatureResponse>
    {
        public override bool Execute()
        {
            return base.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xcrypto_int));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\xsts\xrlissuetoken.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Net.Sockets;
using System.Net;
using System.Runtime.InteropServices;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.LiveService;

using xonline.common.config;
using xonline.common.core.etx;
using xonline.common.utilities;

namespace ServerTestFramework.LiveService.XSTS
{
    /// <summary>
    /// Summary description for XRLLogString.
    /// </summary>
    public class XSTSIssueXRL : XRLPayload
    {
        [WireInfo(Serialize = false)]
        private static String requestBase;

        [WireInfo(Serialize = false)] //Hide me!
        public string RPUrl;
        
        [WireInfo(Serialize = false)] //Hide me!
        public ushort rstLength;
        
        [XRLPayloadFld(SizeParam = "rstLength")]
        public string rst;

        public RSTGenerator RstGen { get; set; }

        static XSTSIssueXRL()
        {
            requestBase = File.ReadAllText(@"SuitesData\XSTS\issuerequestbase.xml");
        }

        public XSTSIssueXRL()
        {
            RstGen = new RSTGenerator();
            ServiceId = XOService.XSts;
            this.Slot.AddService(XOService.XSts);
        }

        protected override string GetServiceName()
        {
            return @"/xsts/xsts.svc/IWSTrust13";
        }
        
        override public bool Execute()
        {                        
            return Execute(RstGen.BuildRST());
        }
        
        public bool Execute(String rstBase)
        {
            rst = String.Format(requestBase, Guid.NewGuid(), GetServiceName(), rstBase);
            this.rstLength = (UInt16)rst.Length;

            if (RPUrl != null)
               RstGen.AppliesTo = new System.ServiceModel.EndpointAddress(RPUrl);

            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xsts));
        }

        protected override void ReadResponse(MemoryStream responseStream)
        {
            // override this so base class doesn't throw exception
            // this is really handled by Execute
        }
        
        public override byte[] GenerateHttpHeader(IPEndPoint endPoint, MemoryStream reqStream)
        {
            StringBuilder header = new StringBuilder();
            
            header.AppendFormat("POST {0} HTTP/1.0\r\n", GetServiceName());
            header.Append("Relja: true\r\n");  // This header was requested by SLamb to differentiate tools/tests and real clients
            header.AppendFormat("Host: {0}\r\n", endPoint);            
            header.Append("Content-Type: application/soap+xml\r\n");
            header.AppendFormat("User-Agent: {0}/0.10.4715\r\n", ((int)ServiceId).ToString("x"));
            header.Append(CustomHeader);
            header.AppendFormat("Content-Length: {0}\r\n\r\n", reqStream.Length);

            return Encoding.ASCII.GetBytes(header.ToString());            
        }
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\XTOU\XRLGetLanguagesForCountry.cs ===
using System.Net;               // IPEndPoint
using System.IO;                // MemoryStream
using xonline.common.config;    // VirtualInterface

namespace ServerTestFramework.LiveService.XTOU
{
    public class XRLGetLanguagesForCountry : XRLPayload
    {
        public byte countryId;

        public XRLGetLanguagesForCountry()
        {
        }

        protected override string GetServiceName()
        {
            return "/xtou/GetLanguagesForCountry.ashx";
        }

        public bool Execute(out XRLGetLanguagesForCountryResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xtou), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLGetLanguagesForCountryResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLGetLanguagesForCountryResponse Response)
        {
            MemoryStream reqStream = new MemoryStream(512);
            WriteStream(reqStream);

            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";

            bool uRet = false;
            bool bRet = InternalExecute(endPoint, reqStream);

            Response = null;
            if (bRet)
            {
                if ((xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0))
                {
                    Response = new XRLGetLanguagesForCountryResponse();
                    Response.SchemaVersion = this.SchemaVersion;
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XtouLanguageDefinition : XRLPayload
    {
        public int languageId;

        public ushort languageNameLength = 0;

        [WireInfo(SizeParam = "languageNameLength")]
        public string languageName;
    }

    public class XRLGetLanguagesForCountryResponse : XRLPayload
    {
        public ushort count;
        [WireInfo(SizeParam = "count")]
        public XtouLanguageDefinition[] languageDefinitions;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\ZuneSignIn\UserAccountServiceWrapper.cs ===
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Net;
using System.Web.Services;
using System.Web.Services.Protocols;
using System.Xml.Serialization;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using xonline.common.config;
using ServerTestFramework.LiveService.FakeAAInfoNameSpace;
using xonline.common.service;

namespace ServerTestFramework.LiveService.ZuneSignIn
{


    public class UserAccountServiceWrapper : UserAccountService
    {
        public string AlternateMusicNetUrl = null;
        public string AlternateBillingUrl = null;
        public string InjectedScsError = null;
        public string AlternateDmpUrl = null;

        public ulong PassportPuid = 0;
        public string IPAddress = "";

        public  UpdateHttpHeaderDelegate UpdateHttpHeader ;

        public delegate void UpdateHttpHeaderDelegate(WebRequest request);


        public UserAccountServiceWrapper(ulong passportPuid, string ipAddress)
        {
            this.PassportPuid = passportPuid;
            this.IPAddress = ipAddress;

            IPEndPoint endpoint = 
                Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs);
            this.Url = "http://" + endpoint.ToString() + 
                "/xuacs/useraccount.asmx";            
        }
        
        public UserAccountServiceWrapper(ulong passportPuid) : 
            this(passportPuid,  
                 Dns.GetHostEntry(Dns.GetHostName()).AddressList[0].ToString())
        {            
        }

        public UserAccountServiceWrapper() : this(0)
        {
        }
                
        protected override WebRequest GetWebRequest (Uri uri)
        {
            WebRequest wr = base.GetWebRequest(uri);

            FakeAAInfo fakeAAInfo = new FakeAAInfo(this.PassportPuid, this.IPAddress);
            AAInfo.MarshallToHeaders(wr.Headers, fakeAAInfo);

            if (AlternateMusicNetUrl != null)
                wr.Headers.Add("AlternateMusicNetUrl", AlternateMusicNetUrl);
            if (AlternateBillingUrl != null)
                wr.Headers.Add("AlternateBillingUrl", AlternateBillingUrl);
            if (InjectedScsError != null)
                wr.Headers.Add("InjectedScsError", InjectedScsError);
            if (AlternateDmpUrl != null)
                wr.Headers.Add("AlternateDmpUrl", AlternateDmpUrl);                

            if (UpdateHttpHeader != null)
                UpdateHttpHeader(wr);
            return wr;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveConfig\AppLogReader.cs ===
using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Linq;

using xonline.common.config;

using ServerTestFramework;

namespace ServerTestFramework.LiveService
{
    /// <summary>
    /// This class, given a component, and a call to GetLogs, will provide server applogs for a given time range. 
    /// If you want to add additional folders to pull from for a component, check out the GetComponentFolderNames method.
    /// </summary>
    public class AppLogReader
    {
        private string componentName;

        /// <summary>
        /// Standard constructor, takes a component name.
        /// </summary>
        /// <param name="componentName"></param>
        public AppLogReader(string componentName)
        {
            if (String.IsNullOrEmpty(componentName))
                throw new ArgumentException("Component name must not be null or empty.");
            this.componentName = componentName;
        }

        /// <summary>
        /// After the object has been initialized against a specific component, this method grabs logs from the servers 
        /// associated with that component, filtering only the files and lines beginning with sTime and ending with eTime.
        /// Times should be in UTC to match the server log times. If not, they will be converted to UTC using DateTime.ToUniversalTime
        /// </summary>
        /// <param name="sTimeUtc"></param>
        /// <param name="eTimeUtc"></param>
        /// <returns></returns>
        public List<ServerAppLogs> GetLogs(DateTime sTime, DateTime eTime)
        {
            sTime = sTime.ToUniversalTime();
            eTime = eTime.ToUniversalTime();
            List<ServerAppLogs> compiledLogs = new List<ServerAppLogs>();
            IPEndPoint[] ipEps = ManagementListener.GetXmgmtEndPoints(componentName);            

            foreach (IPEndPoint ipEp in ipEps)
            {
                List<FileInfo> logFiles = GetLogFiles(ipEp);

                //From the full list of matching logfiles, select only the ones with a lastwritetime greater than or equal 
                //to the start time-1 hour, and a creation time earlier than the end time +1 hour. +- 1 hour added for edge 
                //cases where certain logs seem to be written out with inaccurate creation, modified and last accessed time stamps.
                //+-1 gives it a little room for error.
                var files = from lf in logFiles
                            where lf.LastWriteTimeUtc >= sTime.AddHours(-1) && lf.CreationTimeUtc <= eTime.AddHours(1)
                            orderby lf.LastWriteTime ascending
                            select lf;

                //For now we're just grabbing the address, this could be a machine name later if we want it.
                ServerAppLogs saLogs = new ServerAppLogs(componentName, ipEp.Address.ToString());
                
                foreach (FileInfo f in files)
                {
                    string[] logLines = ReadAllLines(f.FullName, sTime, eTime);
                    saLogs.AddLines(logLines);
                }

                compiledLogs.Add(saLogs);                    
            }

            return compiledLogs;
        }

        /// <summary>
        /// Gets the log files that we need to go over for a given component.
        /// </summary>
        /// <param name="ipEp"></param>
        /// <returns></returns>
        private List<FileInfo> GetLogFiles(IPEndPoint ipEp)
        {
            List<FileInfo> files = new List<FileInfo>();
            string[] componentFolderNames = GetComponentFolderNames();                        
            string logroot = Global.XEnv.GetSetting("setup_logroot");

            foreach (string cfn in componentFolderNames)
            {
                string configPath = String.Format(@"\\{0}\{1}\app\{2}", ipEp.Address, logroot.Replace(":", "$"), cfn);
                DirectoryInfo dInfo = new DirectoryInfo(configPath);
                files.AddRange(dInfo.GetFiles("*.log", SearchOption.AllDirectories));
            }           
            
            return files;
        }
        
        /// <summary>
        /// Maps a component to a folder name(s)
        /// </summary>
        /// <returns></returns>
        private string[] GetComponentFolderNames()
        {
            string[] res;
            switch (componentName)
            {
                case "sgsvc":
                    res = new string[] {"SG"};
                    break;
                case "kdcsvc":
                    res = new string[] { "xkdc", "XMACS", "ASkdc" };
                    break;
                default:
                    //Managed components follow this scheme for the most part.
                    res = new string[] { componentName };
                    break;
            }
            return res;
        }

        /// <summary>
        /// File.ReadAllLines yells when XomLogging is actively still writing to a file (a common case).
        /// Plus we want to filter on the timestamp.
        /// </summary>
        /// <param name="path"></param>
        /// <param name="sTime"></param>
        /// <param name="eTime"></param>
        /// <returns></returns>
        private string[] ReadAllLines(string path, DateTime sTime, DateTime eTime)
        {
            List<String> lines = new List<string>();
            using (FileStream fs = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
            using (StreamReader sr = new StreamReader(fs))
            {                
                while (!sr.EndOfStream)
                {
                    string line = sr.ReadLine();
                    if (!String.IsNullOrEmpty(line))
                    {
                        DateTime parsedTime;
                        int dtLen = line.IndexOf("|");
                        if (dtLen < 0)
                            dtLen = line.Length;

                        if (DateTime.TryParse(line.Substring(0, dtLen), out parsedTime))
                        {
                            if (parsedTime > eTime)
                                break;

                            if (parsedTime >= sTime)
                                lines.Add(line);
                        }
                    }
                }                
            }                        

            return lines.ToArray();
        }
    }

    /// <summary>
    /// Server applog data for a single machine.
    /// </summary>
    public class ServerAppLogs
    {
        public string serverName { get; protected set; }
        public string componentName { get; protected set; }
        public List<string> LogLines { get; protected set; }


        public ServerAppLogs(string componentName, string serverName)
        {
            this.componentName = componentName;
            this.serverName = serverName;
            this.LogLines = new List<string>();
        }

        public void AddLines(IEnumerable<string> logLines)
        {
            this.LogLines.AddRange(logLines);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveConfig\AttrAliasesLive.cs ===
using System;

namespace ServerTestFramework
{
    /// <summary>
    /// This attribute can be applied to TestGroup or TestCase
    /// it stands for "Developer Verfication Test"
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=false, Inherited=true)]
    public class DVTAttribute: TestTagAttribute
    {
        public DVTAttribute(): base("DVT")
        {
        }
    }

    /// <summary>
    /// This attribute can be applied to TestGroup or TestCase
    /// it stands for "Build Verfication Test"
    /// </summary>
    [AttributeUsage(AttributeTargets.Class|AttributeTargets.Method, AllowMultiple=false, Inherited=true)]
    public class BVTAttribute: TestTagAttribute
    {
        public BVTAttribute(): base("BVT")
        {
        }
    }

    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = true, Inherited = true)]
    public class OwnerAttribute: TestTagAttribute
    {
        public const string TagName="Owner";

        public OwnerAttribute(string owner): base(TagName, owner)
        {
        }
    }

    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = false, Inherited = true)]
    public class TestFrequencyAttribute: TestTagAttribute
    {
        public const string TagName="Frequency";

        public TestFrequencyAttribute(string frequency): base(TagName, frequency)
        {
        }
    }

    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = false, Inherited = true)]
    public class TestCasePriorityAttribute: TestTagAttribute
    {
        public const string TagName="Priority";

        public TestCasePriorityAttribute(int priority): base(TagName, priority.ToString())
        {
        }
    }

    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = true, Inherited = true)]
    public class EnvRequirementAttribute: TestTagAttribute
    {
        public const string TagName="EnvRequirement";

        public EnvRequirementAttribute(string envRequirement): base(TagName, envRequirement)
        {
        }
    }

    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = false, Inherited = true)]
    public class FeatureAreaAttribute: TestTagAttribute
    {
        public const string TagName="FeatureArea";

        public FeatureAreaAttribute(string featureArea): base(TagName, featureArea)
        {
        }
    }

    /// <summary>
    /// This attribute controls if the test node and all its child nodes are locale Agnostic.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = true)]
    public class LocaleAgnosticAttribute : TestTagAttribute
    {
        public LocaleAgnosticAttribute(bool isAgnostic)
            : base("LocaleAgnostic", isAgnostic)
        {
        }
    }

    /// <summary>
    /// This attribute controls if the test node and all its child notes will be run against
    /// all supported Live Countries and language
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = true)]
    public class AllCountryLanguageAttribute : TestTagAttribute
    {
        public AllCountryLanguageAttribute(bool isAll)
            : base("AllCountryLanguage", isAll)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\xsts\RSTGenerator.cs ===
ï»¿using System;
using System.IO;
using System.Xml;
using System.Xml.Linq;

using System.Collections.Generic;
using System.Linq;
using System.Text;

using System.ServiceModel.Security;
using Microsoft.IdentityModel.Tokens.Saml2;
using Microsoft.IdentityModel.Tokens;
using Microsoft.IdentityModel.Protocols;
using Microsoft.IdentityModel.Protocols.WSFederation;
using Microsoft.IdentityModel.Protocols.WSTrust;
using Microsoft.IdentityModel.Claims;
using Microsoft.IdentityModel.SecurityTokenService;

namespace ServerTestFramework.LiveService.XSTS
{
    public class RSTGenerator : RequestSecurityToken
    {
        public string XuidOverride
        {
            get;
            set;
        }

        public bool UseDelegationToken
        {
            get;
            set;
        }

        public string BodyOverride
        {
            get;
            set;
        }

        public RSTGenerator()
        {            
        }        

        public string BuildRST()
        {
            if (BodyOverride == null)
            {
                WSTrust13RequestSerializer serializer = new WSTrust13RequestSerializer();

                var rstString = new StringBuilder();
                using (XmlWriter writer = new XmlTextWriter(new StringWriter(rstString)))
                {
                    serializer.WriteXml(this, writer, new WSTrustSerializationContext());
                }

                return rstString.ToString();
            }
            else
                return BodyOverride;
        }

        public string BuildFormattedRST()
        {
            string rawRST = BuildRST();
            if (!String.IsNullOrEmpty(rawRST))            
                return XElement.Parse(rawRST.ToString()).ToString();
            else           
                return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveConfig\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveConfig\CountryLanguage.cs ===
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Threading;
using System.Xml;
using ServerTestFramework.Utilities;

namespace ServerTestFramework
{
    /// <summary>
    /// The class is used for Local Agnostic testing
    /// </summary>
    public class CountryLanguage
    {
        public int CultureId { get; set; }
        public int CatalogCultureId { get; set; }
        public byte CountryId { get; set; }
        public ushort LanguageId { get; set; }
        public ushort LiveLanguageId { get; set; }
        public string FriendlyName { get; set; }
        public string LocaleCode { get; set; }

        public CountryLanguage( int cultureId, byte countryId, ushort languageId, ushort liveLanguageId, string friendlyName, string localeCode )
            : this( cultureId, countryId, languageId, liveLanguageId, friendlyName, localeCode, cultureId )
        {
        }

        public CountryLanguage( int cultureId, byte countryId, ushort languageId, ushort liveLanguageId, string friendlyName, string localeCode, int catalogCultureId )
        {
            CultureId = cultureId;
            CatalogCultureId = catalogCultureId;
            CountryId = countryId;
            LanguageId = languageId;
            LiveLanguageId = liveLanguageId;
            FriendlyName = friendlyName;
            LocaleCode = localeCode;
        }

        // 26 + 9
        public static readonly CountryLanguage[] AllLiveCultures = new CountryLanguage[] 
        {
            new CountryLanguage(3079, 5, 3, 3, "German (Austria)", "de-AT"),
            new CountryLanguage(3081, 6, 1, 1, "English (Australia)", "en-AU"),
            new CountryLanguage(2067, 8, 1, 16, "Dutch (Belgium)", "nl-BE"),
            new CountryLanguage(2060, 8, 4, 4, "French (Belgium)", "fr-BE"),
            new CountryLanguage(1046, 13, 9, 9, "Portuguese (Brazil)", "pt-BR"),
            new CountryLanguage(4105, 16, 1, 1, "English (Canada)", "en-CA"),
            new CountryLanguage(3084, 16, 4, 4, "French (Canada)", "fr-CA"),
            new CountryLanguage(2055, 18, 3, 3, "German (Switzerland)", "de-CH"),
            new CountryLanguage(4108, 18, 4, 4, "French (Switzerland)", "fr-CH"),
            new CountryLanguage(13322, 19, 5, 5, "Spanish (Chile)", "es-CL"),
            //new CountryLanguage(2052, 20, 10, 10, "Chinese (PRC)", "zh-CN"),
            new CountryLanguage(9226, 21, 5, 5, "Spanish (Colombia)", "es-CO"),
            new CountryLanguage(1029, 23, 1, 18, "Czech (Czech Republic)", "cs-CZ"),
            new CountryLanguage(1031, 24, 3, 3, "German (Germany)", "de-DE"),
            new CountryLanguage(1030, 25, 1, 13, "Danish (Denmark)", "da-DK"),
            new CountryLanguage(3082, 31, 5, 5, "Spanish (Spain)", "es-ES"),
            new CountryLanguage(1035, 32, 1, 14, "Finnish (Finland)", "fi-FI"),
            new CountryLanguage(1036, 34, 4, 4, "French (France)", "fr-FR"),
            new CountryLanguage(2057, 35, 1, 1, "English (United Kingdom)", "en-GB"),
            new CountryLanguage(1032, 37, 1, 19, "Greek (Greece)", "el-GR"),
            new CountryLanguage(103076, 39, 1, 1, "English (Hong Kong S.A.R.)", "en-HK", 15369),
            new CountryLanguage(3076, 39, 8, 8, "Chinese (Hong Kong S.A.R.)", "zh-HK"),
            new CountryLanguage(1038, 42, 1, 20, "Hungarian (Hungary)", "hu-HU"),
            new CountryLanguage(6153, 44, 1, 1, "English (Ireland)", "en-IE"),
            new CountryLanguage(101081, 46, 1, 1, "English (India)", "en-IN", 16393),
            new CountryLanguage(1040, 50, 6, 6, "Italian (Italy)", "it-IT"),
            new CountryLanguage(1041, 53, 2, 2, "Japanese (Japan)", "ja-JP"),
            new CountryLanguage(1042, 56, 7, 7, "Korean (Korea)", "ko-KR"),
            new CountryLanguage(2058, 71, 5, 5, "Spanish (Mexico)", "es-MX"),
            new CountryLanguage(1043, 74, 1, 16, "Dutch (Netherlands)", "nl-NL"),
            new CountryLanguage(1044, 75, 1, 15, "Norwegian (Norway)", "nb-NO"),
            new CountryLanguage(5129, 76, 1, 1, "English (New Zealand)", "en-NZ"),
            new CountryLanguage(1045, 82, 11, 11, "Polish (Poland)", "pl-PL"),
            new CountryLanguage(2070, 84, 9, 9, "Portuguese (Portugal)", "pt-PT"),
            new CountryLanguage(1049, 88, 12, 12, "Russian (Russian Federation)", "ru-RU"),
            new CountryLanguage(1053, 90, 1, 17, "Swedish (Sweden)", "sv-SE"),
            new CountryLanguage(104100, 91, 1, 1, "English (Singapore)", "en-SG", 18441),
            new CountryLanguage(1028, 101, 8, 8, "Chinese (Taiwan)", "zh-TW"),
            new CountryLanguage(1033, 103, 1, 1, "English (United States)", "en-US"),
            new CountryLanguage(7177, 109, 1, 1, "English (South Africa)", "en-ZA")
        };

        public static int[] GetAllCultureIds()
        {
            List<int> list = new List<int>();
            foreach (CountryLanguage cl in AllLiveCultures)
            {
                list.Add(cl.CultureId);
            }
            return list.ToArray();
        }

        public static byte[] GetAllCountryIds()
        {
            List<byte> list = new List<byte>();
            foreach (CountryLanguage cl in AllLiveCultures)
            {
                if (!list.Contains(cl.CountryId))
                {
                    list.Add(cl.CountryId);
                }
            }
            return list.ToArray();
        }

        public static CountryLanguage GetRandomCountryLanguage()
        {
            ServerTestFramework.Core.Utilities.RandomEx random = new ServerTestFramework.Core.Utilities.RandomEx();
            int index = random.Next(0, AllLiveCultures.Length - 1);

            return AllLiveCultures[index];
        }

        public static string GetLocaleCode(byte countryId, ushort languageId)
        {
            foreach (CountryLanguage cl in AllLiveCultures)
            {
                if (countryId == cl.CountryId && languageId == cl.LanguageId)
                {
                    return cl.LocaleCode;
                }
            }
            return null;
        }

        public static int GetCultureId(byte countryId, ushort languageId)
        {
            return GetCultureId( countryId, languageId, false );
        }

        public static int GetCultureId( byte countryId, ushort languageId, bool getCatalogCulture )
        {
            foreach (CountryLanguage cl in AllLiveCultures)
            {
                if (countryId == cl.CountryId && languageId == cl.LanguageId)
                {
                    if ( getCatalogCulture )
                    {
                        return cl.CatalogCultureId;
                    }
                    else
                    {
                        return cl.CultureId;
                    }
                }
            }
            return 0;
        }

        public static ushort GetFirstLanguageFromCountry(byte countryId)
        {
            foreach (CountryLanguage cl in AllLiveCultures)
            {
                if (countryId == cl.CountryId)
                {
                    return cl.LanguageId;
                }
            }
            return 0;
        }

        public static ushort GetLiveLanguageId(byte countryId, ushort languageId)
        {
            foreach (CountryLanguage cl in AllLiveCultures)
            {
                if (countryId == cl.CountryId && languageId == cl.LanguageId)
                {
                    return cl.LiveLanguageId;
                }
            }
            return 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveConfig\AttrExceptsLive.cs ===
//live-specific attributes and exceptions

using System;
using ServerTestFramework.LiveService;

namespace ServerTestFramework
{
    /// <summary>
    /// Custom Exception class to carry and identify failures with an HResult
    /// </summary>
    public class HResultException : Exception
    {
        public override string Message
        {
            get {
                return base.Message + ": " + Global.XErrToString(HR);
            }
        }
        public uint HR; 
        public HResultException( uint hr ) : base() { HR = hr; }
        public HResultException( uint hr, string message) : base(message) { HR = hr; }
        public HResultException( uint hr, string message, Exception inner) : base(message, inner) { HR = hr; }
    }

    /// <summary>
    /// Custom Exception class to carry and identify failures with an X-Err
    /// </summary>
    public class XErrException : Exception
    {
        public uint XErr; 
        public XErrException( uint xErr ) : base() { XErr = xErr; }
        public XErrException( uint xErr, string message) : base(message) { XErr = xErr; }
        public XErrException( uint xErr, string message, Exception inner) : base(message, inner) { XErr = xErr; }
    }

    /// <summary> Indicates that the test tree should be regenerated if the current environment changes.  Only applicable to the top-level node of a tree. </summary>
    [AttributeUsage(AttributeTargets.Class, Inherited=true, AllowMultiple=false)]
    public class ReloadOnEnvironmentChangeAttribute: Attribute
    {
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveConfig\IDeepCloneable.cs ===
namespace ServerTestFramework.LiveService
{
	public interface IDeepCloneable
	{
		object DeepClone();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\xsts\XSTSUtil.cs ===
using System;
using System.Threading;
using System.Diagnostics;
using System.Net;
using System.Net.Cache;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.IdentityModel.Tokens;
using System.IdentityModel.Selectors;
using System.IO;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.ServiceModel.Security;
using System.Text;
using System.Linq;
using System.Xml;
using System.Xml.Linq;
using System.Net.Sockets;
using System.Net.Security;

using xonline.common.service;
using xonline.common.utilities2;
using xonline.common.config;

using Microsoft.XboxLive.Auth.Claims;

using Microsoft.IdentityModel.Claims;
using Microsoft.IdentityModel.Protocols.WSTrust;
using Microsoft.IdentityModel.Tokens;
using Microsoft.IdentityModel.Tokens.Saml2;
using Microsoft.IdentityModel.SecurityTokenService;

using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.Auth.RPSTicketGen;
using ServerTestFramework.LiveService.Auth;

namespace ServerTestFramework.LiveService.XSTS
{
    public static class XstsUtil
    {
        private const string XstsCertificateIdentifier = "xsts.xboxlive.com";
        private const string RelyingPartyCertificateIdentifier = "cert.internal_relying_party";        
        
        private static X509Certificate2 XSTSSigningCert;
        private static X509Certificate2 XboxLiveEncryptingCert;
        
        /// <summary>
        /// Gets the XSTS signing certificate as defined by the site.xml file.
        /// </summary>
        /// <returns>An X509Certificate2 containing the certificate.</returns>
        public static X509Certificate2 GetXstsSigningCertificate()
        {
            if (XSTSSigningCert == null)
            {
                XSTSSigningCert = GetCertificateFromSecureShare(XstsCertificateIdentifier);
            }

            return XSTSSigningCert;
        }

        /// <summary>
        /// Gets the relyinfg party encrypting certificate as defined by the site.xml file.
        /// </summary>
        /// <returns>An X509Certificate2 containing the certificate.</returns>
        public static X509Certificate2 GetXstsEncryptingCertificate()
        {
            if (XboxLiveEncryptingCert == null)
            {
                XboxLiveEncryptingCert = GetCertificateFromSecureShare(RelyingPartyCertificateIdentifier);
            }
            
            return XboxLiveEncryptingCert;            
        }

        /// <summary>
        /// Gets the XSTS signing certificate as defined by the site.xml file.
        /// </summary>
        /// <returns>An X509Certificate2 containing the certificate.</returns>
        public static X509Certificate2 GetCertificateFromSecureShare(string identifier)
        {
            // find site.xml
            string secure_unc = Config.GetSetting(Setting.setup_secureUNC);
            string site_xml_path = Path.Combine(secure_unc, "site.xml");

            if (!File.Exists(site_xml_path))
            {
                throw new InvalidOperationException("Cannot find site.xml in secure share (" + site_xml_path + ").");
            }

            XmlDocument site_xml = new XmlDocument();

            //Pre-reading site.xml to avoid locking it. This is to alleviate file locking concerns in shared test environments. (request from the deployment team)
            //I'm not sure if XmlLoad keeps a lock on the file or not for the lifetime of the object, so just read the string just in case. 
            site_xml.LoadXml(File.ReadAllText(site_xml_path)); 

            // get cert xml elements
            XmlNode cert_element = site_xml.SelectSingleNode("/Site/Certificates/SSLCert[@Identifier='" +
                identifier + "']");

            if (cert_element == null)
            {
                throw new InvalidDataException("Cannot find the STS SSLCert in site.xml (" + site_xml_path + ").");
            }

            XmlNode file_attr = cert_element.SelectSingleNode("@File");

            if (file_attr == null)
            {
                throw new InvalidDataException("Cannot find the STS SSLCert in site.xml (" + site_xml_path + ").");
            }

            XmlNode password_element = cert_element.SelectSingleNode("Password");

            // bring it together
            string cert_path = Path.Combine(secure_unc, file_attr.Value);
            
            string password = (password_element == null ? "" : password_element.InnerText);            

            //Again, to alleviate concerns about file locking in environments, just guarantee a quick read of the data (request from the deployment team).            
            X509Certificate2 cert = new X509Certificate2(File.ReadAllBytes(cert_path), password);

            return cert;
        }

        /// <summary>
        /// Removes the master key via xkeymgr.exe
        /// </summary>
        public static void RemoveMasterKey()
        {
            ProcessStartInfo info = new ProcessStartInfo("xkeymgr.exe", "removemk 1");
            Process ps = Process.Start(info);
            ps.WaitForExit();
            ps.Close();
        }

        /// <summary>
        /// Checks to see if the master key is already installed on the client
        /// </summary>
        /// <returns>true of installed otherwise false</returns>
        public static bool IsMasterKeyInstalled()
        {
            bool keyInstalled = true;
            ProcessStartInfo info = new ProcessStartInfo("xkeymgr.exe", "dumpmk 1");
            info.RedirectStandardError = true;
            info.UseShellExecute = false;
            Process ps = Process.Start(info);
            ps.WaitForExit();
            string szerr = ps.StandardError.ReadToEnd();
            if (szerr.Contains("0x80090016"))
            {
                keyInstalled = false;
            }
            ps.Close();
            return keyInstalled;
        }

        /// <summary>
        /// Installs the master key on the local client
        /// </summary>
        public static void InstallMasterKey()
        {
            string secure_unc = Config.GetSetting(Setting.setup_secureUNC);
            string masterKeyPath = Path.Combine(secure_unc, "MasterKeyV1.prv");

            ProcessStartInfo info = new ProcessStartInfo("xkeymgr.exe", "storemk " + masterKeyPath);
            Process ps = Process.Start(info);
            ps.WaitForExit();
            ps.Close();
        }
    }
    
    public class XSTSSaml2Token
    {
        // Constants
        const String DEFAULTISSUERNAME = "xsts.xboxlive.com";
        const String DEFAULTSUBJECTURI = "urn:oasis:names:tc:SAML:2.0:cm:bearer";
        const String DEFAULTAPPLIESTOADDRESS = "http://localhost/CacheService/CacheService.svc";
        const double DEFAULTNOTONORAFTER = 4; 

        // Members
        private X509Certificate2 m_SigningCert; 
        private X509Certificate2 m_EncryptingCert; 

        private X509AsymmetricSecurityKey m_EncryptingKey = null;
        private Saml2SecurityToken m_SecurityToken = null;

        /// <summary>
        /// Expose the assertion directly in case someone wants to fudge around with it manually,
        /// especially for negative test cases.        
        /// </summary>
        public Saml2Assertion Assertion
        {
            get
            {
                return m_SecurityToken.Assertion;
            }            
        }

        public bool Encrypt
        {
            get;
            set;
        }


        /// <summary>
        /// Class representing XSTS Saml2 Token.  A default token will be generated.
        /// </summary>
        /// <param name="signingKey">Saml2Token signing key</param>
        public XSTSSaml2Token(X509Certificate2 signingCert, X509Certificate2 encryptingCert)
        {            
            m_SigningCert = signingCert;
            m_EncryptingCert = encryptingCert;

            // Initialize Security Token
            SetDefaultSecurityToken();
            SetCredentials();
        }

        /// <summary>
        /// Class representing XSTS Saml2 Token.  A default token will be generated.
        /// </summary>
        /// <param name="signingKey">Saml2Token signing key</param>
        public XSTSSaml2Token(X509Certificate2 signingCert) : this(signingCert, XstsUtil.GetXstsEncryptingCertificate())
        {            
        }

        /// <summary>
        /// Makes up some claims and values
        /// </summary>
        public void GenerateClaims()
        {
            m_SecurityToken = new Saml2SecurityToken(new Saml2Assertion(new Saml2NameIdentifier(DEFAULTISSUERNAME)));

            // Default Assertions and claims
            m_SecurityToken.Assertion.Subject = new Saml2Subject(new Saml2SubjectConfirmation(new System.Uri(DEFAULTSUBJECTURI)));

            this.AddAttribute(AuthClaimTypes.DeviceId, "FA00FFFFFFFFFFFF", ClaimValueTypes.HexBinary);
            this.AddAttribute(AuthClaimTypes.FlowToken, "2775B7313111D777", ClaimValueTypes.HexBinary);
            this.AddAttribute(AuthClaimTypes.PartnerXuid, "4CBFC226D066EF9357AF0AD81B669092B04F4B6A", ClaimValueTypes.HexBinary);

            this.AddAttribute(AuthClaimTypes.DeviceType, "Xbox360", ClaimValueTypes.String);
            this.AddAttribute(AuthClaimTypes.AgeGroup, "Adult", ClaimValueTypes.String);
            this.AddAttribute(AuthClaimTypes.Gamertag, "MyFirstTokenGamertag", ClaimValueTypes.String);
            this.AddAttribute(AuthClaimTypes.Status, "Ok", ClaimValueTypes.String);
            this.AddAttribute(AuthClaimTypes.Tier, "Gold", ClaimValueTypes.String);

            this.AddAttribute(AuthClaimTypes.TitleId, "4294836224", ClaimValueTypes.Integer);
            this.AddAttribute(AuthClaimTypes.TitleVersion, "1", ClaimValueTypes.Integer);
            this.AddAttribute(AuthClaimTypes.Country, "103", ClaimValueTypes.Integer);
            this.AddAttribute(AuthClaimTypes.Language, "1", ClaimValueTypes.Integer);
            this.AddAttribute(AuthClaimTypes.Puid, "985160461755820", ClaimValueTypes.Integer);
            this.AddAttribute(AuthClaimTypes.Xuid, "2533274790395915", ClaimValueTypes.Integer);

            this.AddAttribute(AuthClaimTypes.ClientIpPort, "10.124.130.54:65535", AuthClaimValueTypes.IpAddress);

            this.AddAttribute(AuthClaimTypes.Privileges, "255", AuthClaimValueTypes.IntegerArray);            
            

            // Default Assertion Conditions
            Saml2Conditions conditions = new Saml2Conditions();
            conditions.NotBefore = DateTime.Now;
            conditions.NotOnOrAfter = DateTime.Now.AddHours(DEFAULTNOTONORAFTER);
            conditions.AudienceRestrictions.Add(new Saml2AudienceRestriction(new System.Uri(DEFAULTAPPLIESTOADDRESS)));

            // Apply Defaults to Security Token
            m_SecurityToken.Assertion.Conditions = conditions;
            SetCredentials();
        }

        /// <summary>
        /// Makes up some claims and values, specifically claims that are for the http://xboxlive.com applies to.
        /// </summary>
        public void GenerateXboxLiveClaims ()
        {
            m_SecurityToken = new Saml2SecurityToken(new Saml2Assertion(new Saml2NameIdentifier(DEFAULTISSUERNAME)));

            // Default Assertions and claims
            m_SecurityToken.Assertion.Subject = new Saml2Subject(new Saml2SubjectConfirmation(new System.Uri(DEFAULTSUBJECTURI)));

            this.AddAttribute(AuthClaimTypes.DeviceId, "FA00FFFFFFFFFFFF", ClaimValueTypes.HexBinary);
            this.AddAttribute(AuthClaimTypes.DeviceType, "Xbox360", ClaimValueTypes.String);

            this.AddAttribute(AuthClaimTypes.FlowToken, "2775B7313111D777", ClaimValueTypes.HexBinary);

            this.AddAttribute(AuthClaimTypes.TitleId, "4294836224", ClaimValueTypes.Integer);
            this.AddAttribute(AuthClaimTypes.TitleVersion, "1", ClaimValueTypes.Integer);

            this.AddAttribute(AuthClaimTypes.AgeGroup, "Adult", ClaimValueTypes.String);
            this.AddAttribute(AuthClaimTypes.ClientIpPort, "10.124.130.54:65535", AuthClaimValueTypes.IpAddress);
            this.AddAttribute(AuthClaimTypes.Country, "103", ClaimValueTypes.Integer);
            this.AddAttribute(AuthClaimTypes.Gamertag, "MyFirstGamertag", ClaimValueTypes.String);
            this.AddAttribute(AuthClaimTypes.Language, "1", ClaimValueTypes.Integer);
            this.AddAttribute(AuthClaimTypes.Privileges, 
                "220,221,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,245,246,247,248,249,250,251,252,253,254,255",
                AuthClaimValueTypes.IntegerArray);
            this.AddAttribute(AuthClaimTypes.Puid, "985160461755820", ClaimValueTypes.Integer);
            this.AddAttribute(AuthClaimTypes.Status, "Ok", ClaimValueTypes.String);
            this.AddAttribute(AuthClaimTypes.Tier, "Gold", ClaimValueTypes.String);
            this.AddAttribute(AuthClaimTypes.Xuid, "2533274790395915", ClaimValueTypes.Integer);

            // Default Assertion Conditions
            Saml2Conditions conditions = new Saml2Conditions();
            conditions.NotBefore = DateTime.Now;
            conditions.NotOnOrAfter = DateTime.Now.AddHours(DEFAULTNOTONORAFTER);
            conditions.AudienceRestrictions.Add(new Saml2AudienceRestriction(new System.Uri(DEFAULTAPPLIESTOADDRESS)));

            // Apply Defaults to Security Token
            m_SecurityToken.Assertion.Conditions = conditions;
            SetCredentials();
        }

        /// <summary>
        /// Private method to set the default security token
        /// </summary>
        private void SetDefaultSecurityToken()
        {
            m_SecurityToken = new Saml2SecurityToken(new Saml2Assertion(new Saml2NameIdentifier(DEFAULTISSUERNAME)));

            // Default Assertions
            m_SecurityToken.Assertion.Subject = new Saml2Subject(new Saml2SubjectConfirmation(new System.Uri(DEFAULTSUBJECTURI)));

            // Default Assertion Conditions
            Saml2Conditions conditions = new Saml2Conditions();
            conditions.NotBefore = DateTime.Now;
            conditions.NotOnOrAfter = DateTime.Now.AddHours(DEFAULTNOTONORAFTER);
            conditions.AudienceRestrictions.Add(new Saml2AudienceRestriction(new System.Uri(DEFAULTAPPLIESTOADDRESS)));

            // Apply Defaults to Security Token
            m_SecurityToken.Assertion.Conditions = conditions;            
        }        

        private void SetCredentials()
        {
            X509SecurityToken token = new X509SecurityToken(m_SigningCert);
            SecurityKeyIdentifierClause signingSkic = token.CreateKeyIdentifierClause<X509IssuerSerialKeyIdentifierClause>();
            SecurityKeyIdentifier signingSki = new SecurityKeyIdentifier(signingSkic);        
            
            if (Encrypt && m_EncryptingCert != null)
            {
                SecurityKeyIdentifierClause encryptingClause = new X509RawDataKeyIdentifierClause(m_EncryptingCert);
                SecurityKeyIdentifier encryptingSki = new SecurityKeyIdentifier(encryptingClause);
                m_EncryptingKey = (X509AsymmetricSecurityKey)encryptingSki.CreateKey();
            }            

            if (m_SecurityToken != null)
            {
                m_SecurityToken.Assertion.SigningCredentials = new X509SigningCredentials(m_SigningCert, signingSki);
                if (Encrypt && m_EncryptingCert != null)
                    m_SecurityToken.Assertion.EncryptingCredentials = new EncryptedKeyEncryptingCredentials(m_EncryptingCert);
            }
        }        

        /// <summary>
        /// Add an existing Saml2Attribute to the token
        /// </summary>
        /// <param name="attribute">The Saml2Attribute to be added</param>
        public void AddAttribute(Saml2Attribute attribute)
        {
            if (m_SecurityToken == null)
            {
                throw new Exception("Cannot add attributes to a null Security Token (m_SecurityToken is null)");
            }

            //Let's use one statement for now. This may change in the future 
            //but for now one statement encompasses all of our claims.
            if (m_SecurityToken.Assertion.Statements.Count > 0)
                ((Saml2AttributeStatement)m_SecurityToken.Assertion.Statements[0]).Attributes.Add(attribute);
            else
                m_SecurityToken.Assertion.Statements.Add(new Saml2AttributeStatement(attribute));            
        }

        /// <summary>
        /// Add a Saml2Attribute via a name/value pair
        /// </summary>
        /// <param name="name">name to be added</param>
        /// <param name="value">value to be added</param>
        public void AddAttribute(String name, String value)
        {
            AddAttribute(new Saml2Attribute(name, value));
        }

        /// <summary>
        /// Add a Saml2Attribute via a name
        /// </summary>
        /// <param name="name">name to be added</param>
        /// <param name="value">value to be added</param>
        public void AddAttribute(String name)
        {
            AddAttribute(new Saml2Attribute(name));
        }

        /// <summary>
        /// Add a Saml2Attribute via a name/value pair + type
        /// </summary>
        /// <param name="name">name to be added</param>
        /// <param name="value">value to be added</param>
        public void AddAttribute(String name, String value, string type)
        {
            Saml2Attribute attr = new Saml2Attribute(name, value);
            attr.AttributeValueXsiType = type;
            AddAttribute(attr);
        }

        /// <summary> Adds an attribute and automatically determines and sets the type based on the attribute name. </summary>
        public void AddAutoTypedAttribute(string name, string value)
        {
            string type = Microsoft.XboxLive.Auth.Claims.AuthClaimTypes.ValueTypes.Get(name);
            if (type == null)
            {
                Global.RO.Debug("Unknown type for claim attribute name " + name + ".  Defaulting to string.");
                type = ClaimValueTypes.String;
            }

            AddAttribute(name, value, type);
        }

        /// <summary>
        /// Convert the XSTSSaml2Token to a String
        /// </summary>
        /// <returns>XElement parsed String</returns>
        public override String ToString()
        {
            Saml2SecurityTokenHandler tokenHandler = new Saml2SecurityTokenHandler();
            SetCredentials();
            StringBuilder tokenString = new StringBuilder();
            tokenHandler.WriteToken(new XmlTextWriter(new StringWriter(tokenString)), m_SecurityToken);

            return tokenString.ToString();
        }       
    }

    public class XSTSAASG
    {        
        static string requestBase;
        public static X509Certificate2 RelyingPartyCert = XstsUtil.GetXstsEncryptingCertificate();
        public string RPUrl;
        public string SneakyXBL20;
        public string AuthorizationHdr;

        public HttpStatusCode StatusCode;
        public string XErr;

        const string xmacsRpsSite = "kdc.test.xboxlive.com"; //default to test environments
	    const string XSTS_PATH = "/XSts/xsts.svc/IWSTrust13";

        #region WP7ClientCert config
        private X509Certificate2 ClientCertificate;
        public bool UseSSL { get; set; }
        public bool UseCert { get; set; }
        public static bool _CertCheckDisabled { get; set; }
        public static RemoteCertificateValidationCallback AllGood = null;
        #endregion 

        private string clientCertNameOverride = "_default_";
        private bool clientCertNameOverriden;        
        public string ClientCertNameOverride
        {
            get
            {
                return clientCertNameOverride;
            }

            set
            {
                clientCertNameOverriden = true;
                clientCertNameOverride = value;
            }
        }

        private string clientCertThumbprintOverride = "_default_";
        private bool clientCertThumbprintOverriden;
        public string ClientCertThumbprintOverride
        {
            get
            {
                return clientCertThumbprintOverride;
            }

            set
            {
                clientCertThumbprintOverriden = true;
                clientCertThumbprintOverride = value;
            }
        }

        static XSTSAASG()
        {
            AllGood = delegate(object sender, System.Security.Cryptography.X509Certificates.X509Certificate certificate,
                                            System.Security.Cryptography.X509Certificates.X509Chain chain,
                                            System.Net.Security.SslPolicyErrors sslPolicyErrors)
            {
                return true; // **** Always accept
            };
        }

        public XSTSAASG()
        {
            UseSSL = false;
            UseCert = false;

            if (String.IsNullOrEmpty(requestBase))
            {
                using (FileStream fs = new FileStream(@"SuitesData\XSTS\issuerequestbase.xml", FileMode.Open))
                using (StreamReader sr = new StreamReader(fs))
                {
                    requestBase = sr.ReadToEnd();
                }
            }
        }

        private string GetRequestUrl()
        {
            string url;
            IPEndPoint viIP;
                        
            viIP = Global.XEnv.GetVirtualInterface(Interface.authsg);
            url = "http://" + viIP.ToString() + XSTS_PATH;
            
            return url;
        }

        public string SendHTTPRequest(RSTGenerator gen, string memberName, long puid, X509Certificate2 clientCertificate)
        {
            ClientCertificate = clientCertificate;

            //Customize this later if tests require it.
            UseSSL = clientCertificate != null;
            UseCert = UseSSL;
            //@@

            String reqUrl = GetRequestUrl();
            string ticket = GetPassportTicketSelfGen(memberName, puid);

            NameValueCollection headers = new NameValueCollection();

            if (!gen.UseDelegationToken)
            {
                if (!String.IsNullOrEmpty(SneakyXBL20))
                {
                    headers.Add("Authorization", "XBL2.0 x=" + SneakyXBL20);
                }
                else if (!String.IsNullOrEmpty(AuthorizationHdr))
                {
                    headers.Add("Authorization", string.Format(AuthorizationHdr, ticket));
                }
                else
                {
                    headers.Add("Authorization", "WLID1.0 t=" + ticket);
                    AAInfoWrapper info = new AAInfoWrapper();

                    AAInfo.MarshallToHeaders(headers, info);
                }
            }
            
            if (gen.UseDelegationToken || clientCertNameOverriden || clientCertThumbprintOverriden)
            {
	            headers.Add(XHttpHdr.LOADBALANCER_ISSSL, "true");

                if (clientCertNameOverriden && ClientCertNameOverride != "_default_")
                {
                    if (ClientCertNameOverride != null)
                    {
                        headers.Add(XHttpHdr.CERT_SUBJECT, ClientCertNameOverride);                        
                    }
                }
                else 
                {
                    headers.Add(XHttpHdr.CERT_SUBJECT, RelyingPartyCert.SubjectName.Name);                    
                }

                if (clientCertThumbprintOverriden && ClientCertThumbprintOverride != "_default_")
                {
                    if (ClientCertThumbprintOverride != null)
                    {
                        headers.Add(XHttpHdr.CERT_THUMBPRINT, ClientCertThumbprintOverride);
                    }
                }
                else
                {
                    headers.Add(XHttpHdr.CERT_THUMBPRINT, RelyingPartyCert.Thumbprint);
                }
            }

            if (!String.IsNullOrEmpty(RPUrl))
            {
                gen.AppliesTo = new System.ServiceModel.EndpointAddress(RPUrl);
            }

            string rst = String.Format(requestBase, Guid.NewGuid(), XSTS_PATH, gen.BuildRST());            

            byte[] content = System.Text.ASCIIEncoding.ASCII.GetBytes(rst);

            return PostRequest(reqUrl, "POST", content, true, headers);
        }

        public WebRequest GetWebRequestForAA(Uri uri)
        {
            // override uri to point at the AuthSG virtual interface
            string scheme_part = uri.GetLeftPart(UriPartial.Scheme);
            IPEndPoint authsg_ipe = Global.XEnv.GetVirtualInterface(VirtualInterface.authsg);
            if (UseSSL)
            {
                scheme_part = scheme_part.Replace(Uri.UriSchemeHttp, Uri.UriSchemeHttps);
                authsg_ipe = Global.XEnv.GetVirtualInterface(VirtualInterface.authsg_ssl);

                // Also, disable certificate checking
                if (!_CertCheckDisabled)
                {
                    System.Net.ServicePointManager.ServerCertificateValidationCallback +=
                        delegate(object sender, System.Security.Cryptography.X509Certificates.X509Certificate certificate,
                                                System.Security.Cryptography.X509Certificates.X509Chain chain,
                                                System.Net.Security.SslPolicyErrors sslPolicyErrors)
                        {
                            return true; // **** Always accept
                        };
                    _CertCheckDisabled = true;
                }
            }

            string authsg_vi = authsg_ipe.ToString();
            string new_uri = scheme_part + authsg_vi + uri.PathAndQuery;
            Uri newUri = new Uri(new_uri);

            HttpWebRequest ans = WebRequest.Create(newUri) as HttpWebRequest;

            if (UseSSL && UseCert)
            {
                
                {
                    // Use this bit of .Net specific trickery to enable our use of whatever client certificate we want in
                    // HttpWebRequest.  See this documentation on SslStream http://msdn.microsoft.com/en-us/library/ms145057.aspx
                    // The Note down below mentions this "technique" of caching an SSL state
                    TcpClient tcp = new TcpClient(authsg_ipe.Address.ToString(), authsg_ipe.Port);
                    SslStream ssl = new SslStream(tcp.GetStream(), false, AllGood, PickMyCert);
                    ssl.AuthenticateAsClient(authsg_ipe.Address.ToString(), new X509CertificateCollection(new X509Certificate[] { ClientCertificate }),
                        System.Security.Authentication.SslProtocols.Default, false);

                    // create a request that we don't care about
                    HttpClient.Request req = new HttpClient.Request(authsg_vi, uri.PathAndQuery);

                    ssl.Write(req.ToBytes());
                    ssl.Flush();
                    // this read is necessary to force the client certificate
                    ssl.Read(new byte[1], 0, 1);
                    ssl.Close();
                }
                
                ans.ClientCertificates.Add(ClientCertificate);
            }
            return ans;
        }        

        private X509Certificate PickMyCert(object sender, string targetHost, X509CertificateCollection localCertificates,
            X509Certificate remoteCertificate, string[] acceptableIssuers)
        {
            return ClientCertificate;
        }

        public string GetPassportTicketSelfGen(string memberName, long puid)
        {
            return AuthClientBase.GetAAPassportTicketSelfGen(memberName, puid);
        }

        /// <summary>
        /// Posts an HTTP request to a given endpoint.
        /// </summary>
        /// <param name="url"></param>
        /// <param name="method"></param>
        /// <param name="content"></param>
        /// <param name="fKeepAlive"></param>
        /// <returns></returns>
        private string PostRequest(string url, string method, byte[] content, bool fKeepAlive, NameValueCollection headers)
        {            
            try
            {                
                HttpWebRequest webreq = (HttpWebRequest)GetWebRequestForAA(new Uri(url));
                Global.RO.Debug("HTTP Request: {0}", webreq.RequestUri.ToString());
                webreq.CachePolicy = new RequestCachePolicy(RequestCacheLevel.BypassCache);
                webreq.UserAgent = "XSTSTest/0.1";

                webreq.KeepAlive = fKeepAlive;
                webreq.Method = method;
                webreq.Timeout = 20000;
                webreq.ContentType = "application/soap+xml; charset=utf-8"; // @@@?                                
                webreq.ContentLength = content == null ? 0 : content.Length;

                if (headers != null)
                    webreq.Headers.Add(headers);                
                
                //IFLC header                
                if (!String.IsNullOrEmpty(webreq.Address.Query))
                {
                    byte[] queryStringBytes = System.Text.Encoding.UTF8.GetBytes(webreq.Address.Query.Substring(1));
                    MemoryStream streamQuery = new MemoryStream(queryStringBytes);
                    string sig = LogCollectorCrypto.CreateSignature(streamQuery);
                    webreq.Headers.Add("X-IFLCDIGEST", sig);
                }


                // Set all headers prior to this!
                if (content != null)
                {
                    // This initiates the send, btw                    
                    webreq.GetRequestStream().Write(content, 0, content.Length);
                }

                // Finish and get response
                HttpWebResponse webresp = (HttpWebResponse)webreq.GetResponse();

                // Read body
                StreamReader sr = new StreamReader(webresp.GetResponseStream());
                string contentResponse = sr.ReadToEnd();

                StatusCode = webresp.StatusCode;
                XErr = webresp.Headers["X-Err"];

                webresp.Close();
                sr.Close();

                return contentResponse;
            }
            catch (WebException we)
            {
                // We throw, so no need to print this
                // ro.Error("Got WebException:\n{0}", we.ToString());
                Global.RO.Warn("WebException: {0}, Status {1}", we.Message, we.Status);

                if (we.Response != null)
                {
                    StreamReader sr = null;
                    try
                    {
                        Global.RO.Debug("WebException Response headers:\n{0}", we.Response.Headers);

                        //                     sr = new StreamReader(we.Response.GetResponseStream());
                        //                     String s = sr.ReadToEnd();

                    }
                    finally
                    {
                        we.Response.Close();
                        if (sr != null)
                            sr.Close();
                    }
                }

                throw;
            }
        }
        /// <summary>
        /// This class exposes the protected fields of an AAInfo object for writing.
        /// Ripped right out of sts test and modified for my convenience.
        /// </summary>
        public class AAInfoWrapper : xonline.common.service.AAInfo
        {
            // Expose the constructor
            public AAInfoWrapper()
                : base()
            {
                _ipAddressInternet = "";
                _certDeviceId = "";
                _samlToken = "";
            }

            // These properties are serialized to the AuthZ header
            public new ulong PassportPuid { get { return _passportPuid; } set { _passportPuid = value; } }
            public new string IpAddressInternet { set { _ipAddressInternet = value; } }
            public new Floken FlowToken { set { _flowToken = value; } }
            public new ulong? LiveXuid { set { _liveXuid = value; } }
            public new ulong PassportCId { get { return _passportCId; } set { _passportCId = value; } }
            public new DateTime NotAfter { get { return _notAfterDateTime; } set { _notAfterDateTime = value; } }
            public new DateTime IssueInstant { get { return _issueInstantDateTime; } set { _issueInstantDateTime = value; } }
            public new string CertDeviceId { get { return _certDeviceId; } set { _certDeviceId = value; } }
            public string SamlToken { get { return _samlToken; } set { _samlToken = value; } }

            // These properties are not serialized
            public xonline.common.service.XblSamlToken SamlSecurityToken { set { _xblSamlToken = value; } }
            public new System.Net.IPAddress OriginatingIP { set { _originatingIP = value; } }
            public new byte? CountryId { set { _countryId = value; } }
            public new System.Collections.BitArray UserPrivileges { set { _userPrivileges = value; } }

            #region AAInfo Abstract Members

            // No need to implement these.

            protected override void PopulateLiveXuid()
            {
                throw new NotImplementedException();
            }

            protected override void PopulateUserInfo()
            {
                throw new NotImplementedException();
            }

            protected override void PopulateUserPrivileges()
            {
                throw new NotImplementedException();
            }

            #endregion
        }
    }

    public class LogCollectorCrypto
    {

        private static readonly byte[] keyMask = new byte[] 
        {
            0xbb, 0xe9, 0x98, 0x69, 0xb9, 0x8d, 0xc8, 0xfd, 
            0x8a, 0x69, 0x19, 0xb9, 0x09, 0x88, 0xc8, 0xfd,
            0x2b, 0x09, 0xd9, 0x69, 0x39, 0xa9
        };
        private static readonly byte[] protectedKey = new byte[]
        {
            0xa7, 0x80, 0xa9, 0x04, 0x22, 0x4f, 0xd6, 0x1e, 0x03, 0x5f, 0x51, 0x02, 0xae, 0x34, 0xcb, 0x7a
        };

        private static byte[] GetKey()
        {
            byte[] signingKey = new byte[protectedKey.Length];

            for (int i = 0; i < protectedKey.Length; i++)
            {
                signingKey[i] = (byte)(keyMask[i] ^ protectedKey[i]);
            }

            return signingKey;
        }

        public static bool VerifySignature(byte[] signature, Stream content)
        {
            using (HMACSHA1 hasher = new HMACSHA1(GetKey()))
            {
                content.Seek(0, SeekOrigin.Begin);
                byte[] computedSignature = hasher.ComputeHash(content);

                if (computedSignature.Length != signature.Length)
                {
                    return false;
                }

                for (uint currentByte = 0; currentByte < computedSignature.Length; ++currentByte)
                {
                    if (signature[currentByte] != computedSignature[currentByte])
                    {
                        return false;
                    }
                }
            }
            return true;
        }

        public static string CreateSignature(Stream content)
        {
            using (HMACSHA1 hasher = new HMACSHA1(GetKey()))
            {
                byte[] computedSignature = hasher.ComputeHash(content);

                System.Text.StringBuilder sb = new System.Text.StringBuilder();
                foreach (byte chunk in computedSignature)
                {
                    sb.Append(chunk.ToString("X2"));
                }

                return sb.ToString();
            }
        }
    }

    public class SimpleXSTSClient
    {
        private Uri audienceUri;
        private Saml2SecurityToken token;
        private string tokenString;
        private KdcUser user;
        public int UserIndex
        {
            get;
            set;
        }        
        
        public SimpleXSTSClient()
        {
            UserIndex = 0;        
        }

        public string GetClaimValue(string claimType)
        {
            if (token != null && token is Saml2SecurityToken)
            {
                Saml2SecurityToken t = (Saml2SecurityToken)token;
                List<Saml2Statement> statements = new List<Saml2Statement>(t.Assertion.Statements);

                if (statements.Count > 1 || statements.Count < 0)
                    throw new Exception("Expected only 1 SAML statement. Found " + statements.Count);
                foreach (Saml2Statement statement in statements)
                {
                    if (statement is Saml2AttributeStatement)
                    {
                        Saml2AttributeStatement attribStatement = (Saml2AttributeStatement)statement;

                        foreach (Saml2Attribute attrib in attribStatement.Attributes)
                            if (attrib.Name == claimType)
                                return attrib.Values[0];
                    }
                }
            }
            return null;
        }

        #region Token Getting/Creating helpers
        /// <summary>
        /// Gets a token from the STS. Grabs a string then parses it. 
        /// Some useful references:     
        /// WSTrust13Constants.RequestTypes.X    
        /// WSTrust13Constants.KeyTypes.X    
        /// Microsoft.IdentityModel.Tokens.SecurityTokenTypes.X    
        /// </summary>
        /// <returns></returns>
        public SecurityToken GetTokenFromSTS(RSTGenerator gen)
        {            
            string tokenString = GetTokenStringFromSTS(gen);        
            return ParseToken(tokenString);
        }

        public string GetTokenStringFromSTS(RSTGenerator gen)
        {
            if (user == null)
            {
                user = new KdcUser();
                user.CreateUser(false);
            }

            return GetTokenStringFromSTS(gen, user);
        }

        public string GetTokenStringFromSTS(RSTGenerator gen, KdcUser user)
        {
            if (this.user != user)
                this.user = user;

            CSGInfo slot = GetSlot();
            slot.SetUserPuid(0, user.UserID);
            tokenString = GetTokenStringFromSTS(gen, slot, 0);
            //Store the parsed token.
            token = ParseToken(tokenString);
            return tokenString;
        }       

        /// <summary>
        /// Generates a request to the STS, fills in some values for the SGInfo, then grabs the token as a string. 
        /// Not the full response, just the token. Some useful references:     
        /// WSTrust13Constants.RequestTypes.X    
        /// WSTrust13Constants.KeyTypes.X    
        /// Microsoft.IdentityModel.Tokens.SecurityTokenTypes.X    
        /// </summary>
        /// <returns></returns>
        public string GetTokenStringFromSTS(RSTGenerator gen, CSGInfo slot, int userIndex)
        {
            string tokenString = null;
            string responseXml;

            audienceUri = gen.AppliesTo.Uri;           
            
            XSTSIssueXRL xrl = new XSTSIssueXRL();            
            
            
            slot.SetTier(0, XOn.XONLINE_TIER_GOLD);
            slot.SetRegionInfo(XOn.XONLINE_COUNTRY_UNITED_STATES, XOn.XC_LANGUAGE_ENGLISH);
            

            xrl.RPUrl = gen.AppliesTo.Uri.ToString();            

            Puid p = (Puid)slot.GetUserPuid(UserIndex); //For formatting
            if (null == gen.AdditionalContext)
            {
                gen.AdditionalContext = new AdditionalContext();
                if (gen.XuidOverride == null)
                    gen.AdditionalContext.Items.Add(new ContextItem(new Uri(AuthClaimTypes.Xuid), p.ToString()));
                else
                    gen.AdditionalContext.Items.Add(new ContextItem(new Uri(AuthClaimTypes.Xuid), gen.XuidOverride));
            }

            xrl.RstGen = gen;
            xrl.Slot = slot;
            xrl.ManualSlotSetup = true;
            xrl.Execute();

            byte[] contents;

            if (xrl.xAct.ResponseContents == null)
                contents = xrl.xAct.ErrorContents;
            else
                contents = xrl.xAct.ResponseContents;

            using (MemoryStream ms = new MemoryStream(contents))
            using (StreamReader rdr = new StreamReader(ms))
            {
                responseXml = rdr.ReadToEnd();
            }
            

            XDocument responseXmlDoc = XDocument.Parse(responseXml);
            var descendants = responseXmlDoc.Descendants("{urn:oasis:names:tc:SAML:2.0:assertion}Assertion");
            
            if (descendants.Count() < 1)
                descendants = responseXmlDoc.Descendants("{urn:oasis:names:tc:SAML:2.0:assertion}EncryptedAssertion");
            
            if (descendants.Count() > 0)
            {
                tokenString = descendants.ElementAt(0).ToString(SaveOptions.DisableFormatting);
                Global.RO.Debug(GetFormattedXMLString(tokenString));
            }

            if (tokenString != null) //LOLWUT STF BUG - need to investigate. If I log a null logging seems to stop...
            {
                Global.RO.Debug(tokenString);
            }

            if (tokenString == null)
            {
                Global.RO.Debug("The token was null.");
                throw new Exception(responseXml);
            }                   

            return tokenString;
        }

        public CSGInfo GetSlot()
        {
            CSGInfo slot = new CSGInfo();
            slot.Initialize();
            slot.machinePuid = 0xFA00FFFFFFFFFFFF;
            slot.ClearServices();
            slot.AddService((int)XOService.Vortex);
            slot.AddService((int)XOService.XSts);
            slot.SetPrivilege((int)XOn.XPRIVILEGE_ADD_FRIEND);
            return slot;
        }

         /// <summary>
        /// Turns the token string into a proper SecurityToken object.
        /// </summary>
        /// <param name="xmlString"></param>
        /// <returns></returns>
        public static Saml2SecurityToken ParseToken(string xmlString)
        {
            Saml2SecurityToken token = null;

            using (MemoryStream tokenStream = new MemoryStream())
            using (StreamWriter wr = new StreamWriter(tokenStream))
            {
                wr.Write(xmlString);
                wr.Flush();
                tokenStream.Position = 0;

                List<Saml2SecurityToken> tokens = new List<Saml2SecurityToken>();
                Saml2SecurityTokenHandler h = new Saml2SecurityTokenHandler();
                h.Configuration = new Microsoft.IdentityModel.Tokens.SecurityTokenHandlerConfiguration();

                SecurityTokenHandlerCollection collection = SecurityTokenHandlerCollection.CreateDefaultSecurityTokenHandlerCollection();

                // Create the service token resolver from the service certificate.
                List<SecurityToken> serviceTokens = new List<SecurityToken>();
                // This service certificate is considered to have been defined elsewhere
                serviceTokens.Add(new X509SecurityToken(XstsUtil.GetXstsEncryptingCertificate()));
                SecurityTokenResolver serviceResolver = SecurityTokenResolver.CreateDefaultSecurityTokenResolver(serviceTokens.AsReadOnly(), false);

                h.Configuration.ServiceTokenResolver = serviceResolver;

                // Create the issuer  token resolver from the service certificate.
                List<SecurityToken> issuerTokens = new List<SecurityToken>();
                issuerTokens.Add(new X509SecurityToken(XstsUtil.GetXstsSigningCertificate()));
                SecurityTokenResolver issuerResolver = SecurityTokenResolver.CreateDefaultSecurityTokenResolver(issuerTokens.AsReadOnly(), false);
                h.Configuration.IssuerTokenResolver = issuerResolver;


                token = (Saml2SecurityToken)h.ReadToken(XmlReader.Create(new StringReader(xmlString)));

                //SecurityTokenResolver outOfBandTokenResolver = SecurityTokenResolver.CreateDefaultSecurityTokenResolver(new ReadOnlyCollection<Saml2SecurityToken>(tokens), true);

                //using (XmlReader r = XmlReader.Create(tokenStream))
                //{
                //    token = (Saml2SecurityToken)WSSecurityTokenSerializer.DefaultInstance.ReadToken(r, outOfBandTokenResolver);
                //}
            }
            return token;
        }

        public static RSTGenerator CreateDefaultRST()
        {
            RSTGenerator gen = new RSTGenerator();

            gen.ReplyTo = "http://www.w3.org/2005/08/addressing/anonymous";
            gen.AppliesTo = new System.ServiceModel.EndpointAddress("http://xboxlive.com");
            gen.RequestType = WSTrust13Constants.RequestTypes.Issue;
            gen.TokenType = Microsoft.IdentityModel.Tokens.SecurityTokenTypes.OasisWssSaml2TokenProfile11;
            gen.KeyType = WSTrust13Constants.KeyTypes.Bearer;

            return gen;
        }

        public static string GetFormattedXMLString(string xml)
        {
            XDocument formattedXmlDoc = XDocument.Parse(xml);
            return formattedXmlDoc.ToString();
        }

        #endregion        
    }

    public static class UserCreator
    {
        public static int UserCreateCount = 10;
        public static TimeSpan UserCreateTimeout = TimeSpan.FromMinutes(5);
        public static Queue<KdcUser> sharedUsers = new Queue<KdcUser>();
        public static Int32 totalUsersCreated = 0;

        private static AutoResetEvent userAvailable = new AutoResetEvent(false);
        private static Boolean creatingUsers = false;
        private static Boolean createUsersFailed = false;

        /// <summary>
        /// Provides an easy way to create a bunch of users at the 'same' time so 
        /// that we don't have to wait 30 seconds each time a user is created, we 
        /// just wait in batches.  
        /// </summary>
        /// <param name="createGoldUser">If true, Gold users will be created</param>
        /// <returns>A valid IUser if the creation was successful</returns>
        public static KdcUser GetSharedUser()
        {
            KdcUser newUser = null;

            do
            {
                // If there are no users and nobody is creating users
                if (sharedUsers.Count == 0 && !creatingUsers)
                {
                    if (createUsersFailed)
                    {
                        // This indicates a fatal failure in the user creation thread
                        // This is to allow optimistic retry if we run the tests again later.
                        createUsersFailed = false;
                        throw new UnexpectedTestResultException("Create users thread failed to create any users.");
                    }
                    else
                    {
                        Global.RO.Info("Starting background thread to create users...");

                        // Starting a background thread to create some users
                        new Thread(new ThreadStart(CreateSharedUsers)).Start();

                        // Yield to the new user creation thread
                        Thread.Sleep(100);
                    }
                }

                // We'll wait for the user queue for some length of time 
                // before giving up. This will occur if we just can't create
                // a user, or if the creation thread deadlocked.
                if (Monitor.TryEnter(sharedUsers, UserCreateTimeout))
                {
                    try
                    {
                        if (sharedUsers.Count > 0)
                        {
                            Global.RO.Debug("Got a new user from the queue.");
                            newUser = sharedUsers.Dequeue();
                        }
                    }
                    finally
                    {
                        Monitor.Exit(sharedUsers);
                    }

                    if (newUser == null)
                    {
                        // We didn't get a user yet, but it's probably being 
                        // created so just wait a bit before checking again.
                        Global.RO.Debug("No user available yet.");
                        userAvailable.WaitOne(10000, false);
                    }
                }
                else
                {
                    // This means that we were unable to acquire the lock 
                    // after the given timeout.
                    throw new UnexpectedTestResultException(
                        "Unable to acquire user queue lock.  This indicates a problem creating users.");
                }

            } while (newUser == null);

            return newUser;
        }

        private static void CreateSharedUsers()
        {
            Int32 retriesLeft = 3;
            Int32 usersBeingCreated = 0;
            Int32 xcacheRefreshIntervalMs = 5000;

            try
            {
                creatingUsers = true;

                for (int i = 0; i < UserCreateCount; i++)
                {
                    Global.RO.Debug("Creating user ({0})...", i);
                    try
                    {
                        DateTime startTime = DateTime.UtcNow;
                        Interlocked.Increment(ref usersBeingCreated);

                        KdcUser newUser = new KdcUser();
                        newUser.CreateUser(false);

                        TimeSpan dur = DateTime.UtcNow - startTime;
                        Int32 durMs = (int)dur.TotalMilliseconds;
                        Global.RO.Info("User created in {0}ms.", durMs);

                        // Now we've successfully created a user, spawn a thread to
                        // wait until the user is ready, then queue it up.
                        new Thread((ThreadStart)(() =>
                        {
                            try
                            {
                                Int32 sleepDuration = xcacheRefreshIntervalMs;
                                Global.RO.Info("Sleeping for {0}s until they are picked up by XCache", (Int32)(sleepDuration / 1000));
                                Thread.Sleep(sleepDuration);

                                Interlocked.Increment(ref totalUsersCreated);
                                Global.RO.Debug("User ready, adding to queue ({0})...", totalUsersCreated);
                                ReturnSharedUser(newUser);
                            }
                            finally
                            {
                                // Now we're done creating the user (or we failed)
                                Interlocked.Decrement(ref usersBeingCreated);
                            }

                            // Yield to somebody else so they can get the lock and grab the now ready user
                            System.Threading.Thread.Sleep(0);
                        })).Start();
                    }
                    catch
                    {
                        // We failed user creation, we need to decrement the users being created count
                        Interlocked.Decrement(ref usersBeingCreated);

                        // If we didn't manage to create any users yet
                        if (sharedUsers.Count == 0)
                        {
                            // and there are no retries left
                            if (--retriesLeft < 0)
                            {
                                // Then throw the exception out
                                throw;
                            }
                            else
                            {
                                i--;
                                Global.RO.Warn("User creation failed.  {0} Retries left", retriesLeft);
                            }
                        }
                        else
                        {
                            // But if we made at least one user, then return that user and 
                            // stop creating users for new.  It's probably a transient error 
                            // and we'll try again next time someone asks for a user
                            Global.RO.Warn("Failed to create a user, after at least one was created. Probably a transient error");
                            break;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                // If we're throwing an exception, the user 
                // creation failed so signal that to the users
                createUsersFailed = true;

                // Hmm, STF doesn't catch this exception, just dump it out
                Global.RO.Error("User creation failed.");
                Global.RO.Error(ex.ToString());
                //throw;
            }
            finally
            {
                // We don't want somebody else to come in and try to create some 
                // users, so wait here until the other requests complete
                while (usersBeingCreated > 0)
                {
                    Thread.Sleep(1000);
                }
                Global.RO.Debug("Finished creating users.");

                creatingUsers = false;
            }
        }

        public static void ReturnSharedUser(KdcUser user)
        {
            if (user != null)
            {
                lock (sharedUsers)
                {
                    sharedUsers.Enqueue(user);
                }
                userAvailable.Set();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\ZuneSignIn\UserAccountService.cs ===
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.312
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace ServerTestFramework.LiveService.ZuneSignIn {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="UserAccountSoap", Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class UserAccountService : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback GetPointsBalanceOperationCompleted;
        
        private System.Threading.SendOrPostCallback SignInOperationCompleted;
        
        private System.Threading.SendOrPostCallback TestConnectionOperationCompleted;
        
        /// <remarks/>
        public UserAccountService() {
            this.Url = "http://garyt4:11050/xuacs/useraccount.asmx";
        }
        
        /// <remarks/>
        public event GetPointsBalanceCompletedEventHandler GetPointsBalanceCompleted;
        
        /// <remarks/>
        public event SignInCompletedEventHandler SignInCompleted;
        
        /// <remarks/>
        public event TestConnectionCompletedEventHandler TestConnectionCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/GetPointsBalance", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public GetPointsBalanceResults GetPointsBalance(ulong userPuid) {
            object[] results = this.Invoke("GetPointsBalance", new object[] {
                        userPuid});
            return ((GetPointsBalanceResults)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPointsBalance(ulong userPuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPointsBalance", new object[] {
                        userPuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public GetPointsBalanceResults EndGetPointsBalance(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((GetPointsBalanceResults)(results[0]));
        }
        
        /// <remarks/>
        public void GetPointsBalanceAsync(ulong userPuid) {
            this.GetPointsBalanceAsync(userPuid, null);
        }
        
        /// <remarks/>
        public void GetPointsBalanceAsync(ulong userPuid, object userState) {
            if ((this.GetPointsBalanceOperationCompleted == null)) {
                this.GetPointsBalanceOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetPointsBalanceOperationCompleted);
            }
            this.InvokeAsync("GetPointsBalance", new object[] {
                        userPuid}, this.GetPointsBalanceOperationCompleted, userState);
        }
        
        private void OnGetPointsBalanceOperationCompleted(object arg) {
            if ((this.GetPointsBalanceCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetPointsBalanceCompleted(this, new GetPointsBalanceCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/SignIn", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public SignInResults SignIn() {
            object[] results = this.Invoke("SignIn", new object[0]);
            return ((SignInResults)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSignIn(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SignIn", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public SignInResults EndSignIn(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((SignInResults)(results[0]));
        }
        
        /// <remarks/>
        public void SignInAsync() {
            this.SignInAsync(null);
        }
        
        /// <remarks/>
        public void SignInAsync(object userState) {
            if ((this.SignInOperationCompleted == null)) {
                this.SignInOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSignInOperationCompleted);
            }
            this.InvokeAsync("SignIn", new object[0], this.SignInOperationCompleted, userState);
        }
        
        private void OnSignInOperationCompleted(object arg) {
            if ((this.SignInCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SignInCompleted(this, new SignInCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/TestConnection", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string TestConnection(string inputMessage) {
            object[] results = this.Invoke("TestConnection", new object[] {
                        inputMessage});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginTestConnection(string inputMessage, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("TestConnection", new object[] {
                        inputMessage}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndTestConnection(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void TestConnectionAsync(string inputMessage) {
            this.TestConnectionAsync(inputMessage, null);
        }
        
        /// <remarks/>
        public void TestConnectionAsync(string inputMessage, object userState) {
            if ((this.TestConnectionOperationCompleted == null)) {
                this.TestConnectionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnTestConnectionOperationCompleted);
            }
            this.InvokeAsync("TestConnection", new object[] {
                        inputMessage}, this.TestConnectionOperationCompleted, userState);
        }
        
        private void OnTestConnectionOperationCompleted(object arg) {
            if ((this.TestConnectionCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.TestConnectionCompleted(this, new TestConnectionCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class GetPointsBalanceResults {
        
        private int pointsBalanceField;
        
        private bool aboveLowBalanceField;
        
        private byte dmpAccountStatusField;
        
        /// <remarks/>
        public int PointsBalance {
            get {
                return this.pointsBalanceField;
            }
            set {
                this.pointsBalanceField = value;
            }
        }
        
        /// <remarks/>
        public bool AboveLowBalance {
            get {
                return this.aboveLowBalanceField;
            }
            set {
                this.aboveLowBalanceField = value;
            }
        }
        
        /// <remarks/>
        public byte DmpAccountStatus {
            get {
                return this.dmpAccountStatusField;
            }
            set {
                this.dmpAccountStatusField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class SessionInfo {
        
        private byte[] sessionKeyField;
        
        private string musicNetAuthTokenField;
        
        private string geoCountryCodeField;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public byte[] SessionKey {
            get {
                return this.sessionKeyField;
            }
            set {
                this.sessionKeyField = value;
            }
        }
        
        /// <remarks/>
        public string MusicNetAuthToken {
            get {
                return this.musicNetAuthTokenField;
            }
            set {
                this.musicNetAuthTokenField = value;
            }
        }
        
        /// <remarks/>
        public string GeoCountryCode {
            get {
                return this.geoCountryCodeField;
            }
            set {
                this.geoCountryCodeField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class SubscriptionInfo {
        
        private ulong xboxOfferIdField;
        
        private string billingInstanceIdField;
        
        private string statusField;
        
        private bool hasBillingViolationField;
        
        private bool hasPendingCancelField;
        
        private string musicNetSkuField;
        
        private System.DateTime startDateField;
        
        private System.DateTime endDateField;
        
        /// <remarks/>
        public ulong XboxOfferId {
            get {
                return this.xboxOfferIdField;
            }
            set {
                this.xboxOfferIdField = value;
            }
        }
        
        /// <remarks/>
        public string BillingInstanceId {
            get {
                return this.billingInstanceIdField;
            }
            set {
                this.billingInstanceIdField = value;
            }
        }
        
        /// <remarks/>
        public string Status {
            get {
                return this.statusField;
            }
            set {
                this.statusField = value;
            }
        }
        
        /// <remarks/>
        public bool HasBillingViolation {
            get {
                return this.hasBillingViolationField;
            }
            set {
                this.hasBillingViolationField = value;
            }
        }
        
        /// <remarks/>
        public bool HasPendingCancel {
            get {
                return this.hasPendingCancelField;
            }
            set {
                this.hasPendingCancelField = value;
            }
        }
        
        /// <remarks/>
        public string MusicNetSku {
            get {
                return this.musicNetSkuField;
            }
            set {
                this.musicNetSkuField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime StartDate {
            get {
                return this.startDateField;
            }
            set {
                this.startDateField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime EndDate {
            get {
                return this.endDateField;
            }
            set {
                this.endDateField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class AccountInfo {
        
        private ulong xboxPuidField;
        
        private ulong livePuidField;
        
        private string tagField;
        
        private string countryCodeField;

        private string postalCodeField;
        
        private bool parentallyControlledField;
        
        private byte[] privilegesField;
        
        private uint pointsBalanceField;
        
        /// <remarks/>
        public ulong XboxPuid {
            get {
                return this.xboxPuidField;
            }
            set {
                this.xboxPuidField = value;
            }
        }
        
        /// <remarks/>
        public ulong LivePuid {
            get {
                return this.livePuidField;
            }
            set {
                this.livePuidField = value;
            }
        }
        
        /// <remarks/>
        public string Tag {
            get {
                return this.tagField;
            }
            set {
                this.tagField = value;
            }
        }
        
        /// <remarks/>
        public string CountryCode {
            get {
                return this.countryCodeField;
            }
            set {
                this.countryCodeField = value;
            }
        }


        /// <remarks/>
        public string PostalCode
        {
            get
            {
                return this.postalCodeField;
            }
            set
            {
                this.postalCodeField = value;
            }
        }

        /// <remarks/>
        public bool ParentallyControlled {
            get {
                return this.parentallyControlledField;
            }
            set {
                this.parentallyControlledField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public byte[] Privileges {
            get {
                return this.privilegesField;
            }
            set {
                this.privilegesField = value;
            }
        }
        
        /// <remarks/>
        public uint PointsBalance {
            get {
                return this.pointsBalanceField;
            }
            set {
                this.pointsBalanceField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class ErrorInfo {
        
        private uint hResultField;
        
        private bool tagChangeRequiredField;
        
        private bool acceptedTermsOfServiceField;
        
        private bool accountSuspendedField;
        
        private bool subscriptionLapsedField;
        
        private bool billingUnavailableField;
        
        /// <remarks/>
        public uint HResult {
            get {
                return this.hResultField;
            }
            set {
                this.hResultField = value;
            }
        }
        
        /// <remarks/>
        public bool TagChangeRequired {
            get {
                return this.tagChangeRequiredField;
            }
            set {
                this.tagChangeRequiredField = value;
            }
        }
        
        /// <remarks/>
        public bool AcceptedTermsOfService {
            get {
                return this.acceptedTermsOfServiceField;
            }
            set {
                this.acceptedTermsOfServiceField = value;
            }
        }
        
        /// <remarks/>
        public bool AccountSuspended {
            get {
                return this.accountSuspendedField;
            }
            set {
                this.accountSuspendedField = value;
            }
        }
        
        /// <remarks/>
        public bool SubscriptionLapsed {
            get {
                return this.subscriptionLapsedField;
            }
            set {
                this.subscriptionLapsedField = value;
            }
        }
        
        /// <remarks/>
        public bool BillingUnavailable {
            get {
                return this.billingUnavailableField;
            }
            set {
                this.billingUnavailableField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class SignInResults {
        
        private ErrorInfo errorInfoField;
        
        private AccountInfo accountInfoField;
        
        private SubscriptionInfo subscriptionInfoField;
        
        private SessionInfo sessionInfoField;
        
        /// <remarks/>
        public ErrorInfo ErrorInfo {
            get {
                return this.errorInfoField;
            }
            set {
                this.errorInfoField = value;
            }
        }
        
        /// <remarks/>
        public AccountInfo AccountInfo {
            get {
                return this.accountInfoField;
            }
            set {
                this.accountInfoField = value;
            }
        }
        
        /// <remarks/>
        public SubscriptionInfo SubscriptionInfo {
            get {
                return this.subscriptionInfoField;
            }
            set {
                this.subscriptionInfoField = value;
            }
        }
        
        /// <remarks/>
        public SessionInfo SessionInfo {
            get {
                return this.sessionInfoField;
            }
            set {
                this.sessionInfoField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetPointsBalanceCompletedEventHandler(object sender, GetPointsBalanceCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetPointsBalanceCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetPointsBalanceCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public GetPointsBalanceResults Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((GetPointsBalanceResults)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SignInCompletedEventHandler(object sender, SignInCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SignInCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SignInCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public SignInResults Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((SignInResults)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void TestConnectionCompletedEventHandler(object sender, TestConnectionCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class TestConnectionCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal TestConnectionCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveConfig\NodeTaggingLive.cs ===
using System;
using System.Collections.Generic;
using ServerTestFramework.Utilities;

namespace ServerTestFramework
{
    public class NodeTaggingLive
    {
        private static Dictionary<string, int> FrequencyValues=new Dictionary<string, int>(StringComparer.InvariantCultureIgnoreCase);

        public static void RegisterLiveExpressions()
        {
            //bool functions
            NodeTaggingData.Expression.RegisterCustomBoolFunction(EnvRequirementAttribute.TagName, new NodeTaggingData.Expression.FunctionInformation(OneParamMultiValues_Validate, new NodeTaggingData.Expression.BoolFunctionDelegate(EnvRequirement_Call), EnvRequirementAttribute.TagName+"(values)   Returns true if the node or any parent node's EnvironmentRequirement values are less than the values specified."));
            NodeTaggingData.Expression.RegisterCustomBoolFunction(OwnerAttribute.TagName, new NodeTaggingData.Expression.FunctionInformation(OneParamMultiValues_Validate, new NodeTaggingData.Expression.BoolFunctionDelegate(Owner_Call), OwnerAttribute.TagName+"(values)   Returns true if the nearest node up the tree's Owner value matches any of the values specified."));
            NodeTaggingData.Expression.RegisterCustomBoolFunction(TestFrequencyAttribute.TagName, new NodeTaggingData.Expression.FunctionInformation(OneParamDirectValue_Validate, new NodeTaggingData.Expression.BoolFunctionDelegate(TestFrequency_Call), TestFrequencyAttribute.TagName+"(values)   Returns true if the nearest node up the tree's TestFrequency value is a subset of the specified value.  Valid values are: BVT < Daily < Regression"));

            //frequency values
            FrequencyValues.Add("BVT", 1);
            FrequencyValues.Add("Daily", 2);
            FrequencyValues.Add("Weekly", 2); //old value still accepted for compatability, needs removed eventually
            FrequencyValues.Add("Regression", 3);
            FrequencyValues.Add("Full", 3); //old value still accepted for compatability, needs removed eventually
        }

        //validation of functions
        public static void OneParamMultiValues_Validate(NodeTaggingData.Expression []parameters, string expStr, int expStart, int expEnd)
        {
            if (parameters.Length!=1)
            {
                throw new NodeTaggingData.InvalidExpressionException(expStr, expStart, expEnd, "Function requires exactly 1 parameter.");
            }

            if (!(parameters[0].Type==NodeTaggingData.ExpressionType.Values || parameters[0].Type==NodeTaggingData.ExpressionType.ValuesFunction))
            {
                throw new NodeTaggingData.InvalidExpressionException(expStr, expStart, expEnd, "Function parameter 0 must be a value.");
            }
        }

        //validation of functions
        public static void OneParamDirectValue_Validate(NodeTaggingData.Expression []parameters, string expStr, int expStart, int expEnd)
        {
            if (parameters.Length!=1)
            {
                throw new NodeTaggingData.InvalidExpressionException(expStr, expStart, expEnd, "Function requires exactly 1 parameter.");
            }

            if (!(parameters[0].Type==NodeTaggingData.ExpressionType.Values))
            {
                throw new NodeTaggingData.InvalidExpressionException(expStr, expStart, expEnd, "Function parameter 0 must be a direct value.");
            }
        }

        //implementation of bool functions
        public static bool EnvRequirement_Call(TestNode node, NodeTaggingData.Expression []parameters)
        {
            if (node.ChildrenCount!=0) //only evaluate leaf nodes
            {
                return false;
            }

            //first we consolidate all requirements start from this node and walking up the tree
            Dictionary<string, NodeTaggingData.ValueSet> allBranchTags=node.TaggingData.GetAllTrunkTags();
            if (!allBranchTags.ContainsKey(EnvRequirementAttribute.TagName)) //no requirements so allow it
            {
                return true;
            }

            NodeTaggingData.ValueSet requirements=allBranchTags[EnvRequirementAttribute.TagName];

            //now compare that to the list of values specified that this environment has
            NodeTaggingData.ValueSet availables=parameters[0].EvaluateValues(node);

            foreach (NodeTaggingData.Value req in requirements)
            {
                if (!availables.ContainsValue(req)) //there is a requirement that is not available
                {
                    return false;
                }
            }

            return true;
        }

        public static bool Owner_Call(TestNode node, NodeTaggingData.Expression []parameters)
        {
            if (node.ChildrenCount!=0) //only evaluate leaf nodes
            {
                return false;
            }

            NodeTaggingData.ValueSet actualOwners=node.TaggingData.GetNearestTrunkValues(OwnerAttribute.TagName);
            NodeTaggingData.ValueSet desiredOwners=parameters[0].EvaluateValues(node);

            foreach (NodeTaggingData.Value des in desiredOwners)
            {
                if (actualOwners.ContainsValue(des))
                {
                    return true;
                }
            }

            return false;
        }

        public static bool TestFrequency_Call(TestNode node, NodeTaggingData.Expression []parameters)
        {
            if (node.ChildrenCount!=0) //only evaluate leaf nodes
            {
                return false;
            }

            string specifiedString=parameters[0].EvaluateString(null);
            if (!FrequencyValues.ContainsKey(specifiedString))
            {
                throw new NodeTaggingData.ExpressionEvaluationException(parameters[0].SourceString, parameters[0].SourceStringStart, parameters[0].SourceStringEnd, "Value passed to Frequency was not a valid frequency value: "+specifiedString);
            }
            int specifiedValue=FrequencyValues[specifiedString];

            int nodeValue=int.MaxValue;
            foreach (NodeTaggingData.Value val in GetFrequencyValues(node))
            {
                if (FrequencyValues.ContainsKey(val.ToString()))
                {
                    int cur=FrequencyValues[val.ToString()];
                    if (cur<nodeValue)
                    {
                        nodeValue=cur;
                    }
                }
                else //if it's an invalid value, set to a value that will never be run
                {
                    nodeValue=int.MaxValue-1; //we use -1 because MaxValue indicates that there was no match
                }
            }

            if (nodeValue==int.MaxValue) //if no matches were found, treat it as if it were tagged with regression
            {
                nodeValue=FrequencyValues["Regression"];
            }

            return nodeValue<=specifiedValue;
        }

        // -- TEMPORARY HELPERS: Functions below here are for convencience of using existing attributes until all parts of the system are switched over to understand generic tagging better.  These WILL be deleted at some point.

        //tags that are not part of the existing standard tags
        public static Dictionary<string, NodeTaggingData.ValueSet> GetGenericNodeTags(TestNode node)
        {
            Dictionary<string, NodeTaggingData.ValueSet> allTags=node.TaggingData.GetNearestTrunkTags();
            Dictionary<string, NodeTaggingData.ValueSet> genericTags=new Dictionary<string, NodeTaggingData.ValueSet>(StringComparer.InvariantCultureIgnoreCase);

            foreach (string key in allTags.Keys)
            {
                string lowerKey=key.ToLower();
                if (lowerKey!=OwnerAttribute.TagName.ToLower() && lowerKey!=TestFrequencyAttribute.TagName.ToLower() && lowerKey!=TestCasePriorityAttribute.TagName.ToLower() && lowerKey!=EnvRequirementAttribute.TagName.ToLower() && lowerKey!=FeatureAreaAttribute.TagName.ToLower())
                {
                    genericTags.Add(key, new NodeTaggingData.ValueSet());

                    foreach (NodeTaggingData.Value v in allTags[key])
                    {
                        genericTags[key].Add(v);
                    }
                }
            }

            return genericTags;
        }

        public static NodeTaggingData.ValueSet GetOwnerValues(TestNode node)
        {
            return node.TaggingData.GetNearestTrunkValues(OwnerAttribute.TagName);
        }

        public static NodeTaggingData.ValueSet GetFrequencyValues(TestNode node)
        {
            return node.TaggingData.GetNearestTrunkValues(TestFrequencyAttribute.TagName);
        }

        public static NodeTaggingData.ValueSet GetPriorityValues(TestNode node)
        {
            return node.TaggingData.GetNearestTrunkValues(TestCasePriorityAttribute.TagName);
        }

        public static NodeTaggingData.ValueSet GetRequirementValues(TestNode node)
        {
            return node.TaggingData.GetAllTrunkValues(EnvRequirementAttribute.TagName);
        }

        public static NodeTaggingData.ValueSet GetFeatureAreaValues(TestNode node)
        {
            return node.TaggingData.GetNearestTrunkValues(FeatureAreaAttribute.TagName);
        }

    }; //class NodeTaggingLive
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveConfig\TestNodeLiveBackCompat.cs ===
namespace ServerTestFramework
{
    [StressInstantiate]
    public abstract class TestBase: TestNodeLive
    {
        public TEST_RESULTS ResultCode=TEST_RESULTS.NOT_EXECUTED;

        public TestBase()
        {
        }
        public TestBase(string name): base(name)
        {
        }

        protected virtual void Execute()
        {
        }

        public sealed override void Run()
        {
            ResultCode=TEST_RESULTS.FAILED;

            Execute();

            if (ResultCode==TEST_RESULTS.FAILED)
            {
                throw new UnexpectedTestResultException(FullName+" set result to FAILED.");
            }
            else if (ResultCode==TEST_RESULTS.NOT_EXECUTED)
            {
                throw new DidNotExecuteException(FullName+" set result to NOT_EXECUTED.");
            }
        }

        public override void Run(RUN_TYPE rt)
        {
            if (rt==RUN_TYPE.FUNCTIONAL)
            {
                Global.RO.Warn("TestBase is deprecated.  Please update "+FullName+" to use TestNode instead.");
            }

            base.Run(rt);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveConfig\TestNodeLive.cs ===
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Threading;
using System.Xml;
using ServerTestFramework.Utilities;
using ServerTestFramework.Core.Utilities;

namespace ServerTestFramework
{
    /// <summary>
    /// A small class contains test runtime data.
    /// For now we have country id and language id only
    /// </summary>
    public class TestRunInfo
    {
        public byte CountryId { get; set; }
        public ushort LanguageId { get; set; }

        public TestRunInfo(byte countryId, ushort languageId)
        {
            CountryId = countryId;
            LanguageId = languageId;
        }
    }

    /// <summary>
    /// A static helper class to retrieve attribute values from NodeTaggingData
    /// </summary>
    public static class NodeTaggingDataHelper
    {
        public static bool IsLocaleAgnostic(NodeTaggingData taggingData)
        {
            NodeTaggingData.ValueSet valueSet = taggingData.GetNearestTrunkValues("LocaleAgnostic");
            if (valueSet != null && valueSet.Count > 0)
            {
                return Convert.ToBoolean(valueSet[0].ToString());
            }
            return false;
        }

        public static bool IsAllCountryLanguage(NodeTaggingData taggingData)
        {
            NodeTaggingData.ValueSet valueSet = taggingData.GetNearestTrunkValues("AllCountryLanguage");
            if (valueSet != null && valueSet.Count > 0)
            {
                return Convert.ToBoolean(valueSet[0].ToString());
            }
            return false;
        }
    }

    /// <summary>
    /// The fundamental unit that makes up test groups and test cases for Xbox Live.
    /// A node can be either be executed or can contain any number of other nodes as children.
    /// </summary>
    public class TestNodeLive: TestNode
    {
        //ctors
        public TestNodeLive()
            : base()
        {
        }

        public TestNodeLive(string name)
            : base(name)
        {
        }

        public TestNodeLive(string name, IEnumerable<TestNodeLive> children, bool addFunctionalData, bool addStressData) 
        {
            foreach (TestNodeLive node in children)
            {
                AddChild(node, addFunctionalData, addStressData);
            }
        }

        /// <summary>
        /// Called to execute the test.
        /// </summary>
        public override void Run(RUN_TYPE runType)
        {
            // for AllCountryLanguage and locale agnostic tests, use Run(byte countryId, ushort languageId)
            if (NodeTaggingDataHelper.IsAllCountryLanguage(TaggingData))
            {
                // loop through all supported countries and languages
                foreach (CountryLanguage cc in CountryLanguage.AllLiveCultures)
                {
                    Global.RO.Info("CountryId: {0}, LanguageId: {1}, Name: {2}", cc.CountryId, cc.LanguageId, cc.FriendlyName);
                    TestRunInfo testRunInfo = new TestRunInfo(cc.CountryId, cc.LanguageId);
                    Run(testRunInfo);
                }
            }
            else if (NodeTaggingDataHelper.IsLocaleAgnostic(TaggingData))
            {
                // pick a random valid country and language pair if settings didn't give them values
                byte countryId = 0;     // settings.CountryId;
                ushort languageId = 0;  // settings.LanguageId;
                if (countryId == 0 && languageId == 0)
                {
                    CountryLanguage cc = CountryLanguage.GetRandomCountryLanguage();
                    Global.RO.Info("CountryId: {0}, LanguageId: {1}, Name: {2}", cc.CountryId, cc.LanguageId, cc.FriendlyName);
                    TestRunInfo testRunInfo = new TestRunInfo(cc.CountryId, cc.LanguageId);
                    Run(testRunInfo);
                }
            }
            else
            {
                Run();
            }
        }

        /// <summary>
        /// This one is executed for locale agnostic tests 
        /// and AllCountryLanguage tests (tests are run against all supported countries and languages)
        /// </summary>
        /// <returns>test result</returns>
        public virtual void Run(TestRunInfo testRunInfo)
        {
            throw new System.NotImplementedException("Run method must be implemented in the derived class.");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveConfig\FrameworkGlobals.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Reflection;
using System.Xml;
using System.Net;
using ServerTestFramework.LiveService;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.Runner;  // for StfXmlDoc
using Microsoft.Win32;
using xonline.common.config;
using xonline.common.sql.webstore;

namespace ServerTestFramework
{
    /// <summary>
    /// Provides various statics for the entire framework.
    /// </summary>
    public class Global : InfiniteLifetimeMarshalByRefObject
    {
        public static Global Singleton = new Global();

        static Global()
        {
            CoreGlobal.RegisterInitializationCallback(STFLiveConfigInitialize);
        }

        //this exists only to force the static constructor to run
        public static void ForceConstruct()
        {
        }

        /// Instruction for adding new members to Global:
        /// (this is old... is it still relevant?)
        /// Members should inherit from InfiniteLifetimeMarshalByRefObject so they can be accessed across app domain.
        /// Fields should be and public. And Avoid static fields. Declare a static property to return its value
        /// from the singleton. If you must use MBV values, make sure they're copied into new app domains (see 
        /// RemoteTestSuiteLoader).

        // Settings parsed from stf.xml
        //
        public IPAddress _SGIPMatchAddr = IPAddress.Any;
        public List<EnvironmentSetting> _EnvironmentList = null;   // list of all environments
        private EnvironmentSetting _CurrentEnvironment = null;  // current active environment
        public Hashtable _UserSetHash;
        private Dictionary<string, string> passportLoginUrls = new Dictionary<string, string>();
        public bool _UseMusicNetEmulator = false;    // emulator settings
        public EmulatorFlags emulatorFlags = EmulatorFlags.None;

        //
        private XConfig _XEnv;
        private string _XEnvResetEnv=null; //environment XEnv was last reset with
        public volatile Report _RO;
        private System.Threading.ManualResetEvent environmentResetBlocker=new System.Threading.ManualResetEvent(false);
        private static bool reloadSuitesOnEnvironmentChange=false;

        // when creating new passport this domain is used. WLID may change the reserved domains,
        // so try to isolate the domain to a single place
        public const string PassportMemberDomain = "@xbltest.com";

        //these events are triggered when the environment is about to be changed and after it has been successfully changed
        public event EnvironmentChangedDelegate EnvironmentChangedBeginEvent;
        public event EnvironmentChangedDelegate EnvironmentChangedSuccessEvent;
        public delegate void EnvironmentChangedDelegate(string newEnvironmentName);

        //locks
        private static object _XEnvResetLock=new object();
        private static object _ROInitLock=new object();

        //
        public static StfXmlDoc Config
        {
            get { return CoreGlobal.Config; }
            set { CoreGlobal.Config=value; }
        }

        public static string DefaultConfigFile
        {
            get{ return CoreGlobal.DefaultConfigFile; }
            set { CoreGlobal.DefaultConfigFile = value; }
        }

        public static IPAddress SGIPMatchAddr
        {
            get { return Singleton._SGIPMatchAddr; }
            set { Singleton._SGIPMatchAddr = value; }
        }

        public static List<EnvironmentSetting> EnvironmentList
        {
            get { return Singleton._EnvironmentList; }
            set { Singleton._EnvironmentList = value; }
        }

        public static EnvironmentSetting CurrentEnvironment
        {
            get { return Singleton._CurrentEnvironment; }
            set //This accessor must be fast to run, and shouldn't cause any network connections or delays.  You cannot assume the value set here is accessible.
            {
                Singleton._CurrentEnvironment = value;
                xonline.common.config.Config.NpdbServer = value.NpdbIp;
                UpdateWebstoreSite();
                System.Environment.SetEnvironmentVariable("XBL_CONFIG_SERVER", value.NpdbIp);
                System.Environment.SetEnvironmentVariable("XBL_CONFIG_DATABASE", value.NpdbName);
            }
        }

        public static Report RO
        {
            get 
            {
                //lazy-init it if needed
                if (Singleton._RO == null)
                {
                    lock (_ROInitLock)
                    {
                        if (Singleton._RO == null)
                        {
                            Singleton._RO = new Report("Log");
                        }
                    }
                }
                //
                return Singleton._RO;
            }
            set { Singleton._RO = value; }
        }

        //returns true if we are running from an environment with internal (npdb/uodb/etc) access
        public static bool IsEnvironmentInternal
        {
            get
            {
                bool missingNpdb = (Global.CurrentEnvironment == null || Global.CurrentEnvironment.NpdbIp==null || Global.CurrentEnvironment.NpdbIp.Length==0);
                return !missingNpdb;
            }
        }

        //access the environment config
        public static XConfig XEnv
        {
            get
            {
                lock (_XEnvResetLock)
                {
                    if (Singleton._XEnvResetEnv==null || Singleton._XEnvResetEnv!=Singleton._CurrentEnvironment.Environment)
                    {
                        ResetEnvironment();
                    }
                }
                return Singleton._XEnv;
            }
            set
            {
                lock (_XEnvResetLock)
                {
                    Singleton._XEnv = value;
                    Singleton._XEnvResetEnv=null;
                }
            }
        }

        // Holds BulkUserSet objects
        public static Hashtable UserSetHash
        {
            get { return Singleton._UserSetHash; }
            set { Singleton._UserSetHash = value; }
        }

        public static string PassportLoginUrl
        {
            get 
            { 
                string ret;
                if(Singleton.passportLoginUrls.TryGetValue(CurrentEnvironment.Environment, out ret))
                {
                    return ret;
                }
                else
                {
                    Global.RO.Warn("Unable to find passportloginurl for [" + CurrentEnvironment.Environment + "] in stf.xml");
                    return String.Empty;
                }
            }
        }

        public static EmulatorFlags EmulatorFlags
        {
            get
            {
                return Singleton.emulatorFlags;
            }
        }

        // emulator settings
        public static bool UseMusicNetEmulator
        {
            get { return Singleton._UseMusicNetEmulator; }
            set { Singleton._UseMusicNetEmulator = value; }
        }

        public static void ResetEnvironment ()
        {
            ResetEnvironment(false);
        }

        // Resets environment settings (based on CurrentEnvironment)
        public static void ResetEnvironment(bool force)
        {
            Singleton.environmentResetBlocker.Reset(); //block threads until environment is ready

            try
            {
                if (!force)
                {
                    //if environment hasn't changed, don't reset.
                    if ((Singleton._XEnvResetEnv != null && Singleton._XEnvResetEnv == Singleton._CurrentEnvironment.Environment) ||
                        (Singleton._XEnvResetEnv == "None" && !IsEnvironmentInternal))
                    {
                        return;
                    }
                }

                if (Global.CurrentEnvironment==null || Global.CurrentEnvironment.Environment==null || Global.CurrentEnvironment.Environment.Length==0)
                {
                    Global.RO.Info("Ressetting to no environment.");
                    Singleton._XEnvResetEnv="None";
                }
                else
                {
                    Global.RO.Info("Resetting environment to "+Global.CurrentEnvironment.Environment+"...");
                    Singleton._XEnvResetEnv=Singleton._CurrentEnvironment.Environment;
                }

                //trigger the change begin event
                try
                {
                    if (Singleton.EnvironmentChangedBeginEvent!=null)
                    {
                        Singleton.EnvironmentChangedBeginEvent(Singleton._CurrentEnvironment.Environment);
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("Exception calling event for resetting environment: "+e);
                }

                //We don't want any failure here to totally bring stf down, so do it carefully 1 piece at a time.
                try
                {
                    XEnv.InitializeTestServer();
                }
                catch (Exception e)
                {
                    Global.RO.Warn("XEnv.InitializeTestServer failed. Exception:\n" + e.Message + "\n" + e.StackTrace);
                }

                try
                {
                    XEnv.Initialize(Config);
                }
                catch (Exception e)
                {
                    Global.RO.Fatal("Error in XEnv Initialize. EXception:\n" + e.Message + "\n" + e.StackTrace);
                }

                //
                UpdateWebstoreSite();

                //trigger the changed success event
                try
                {
                    if (Singleton.EnvironmentChangedSuccessEvent!=null)
                    {
                        Singleton.EnvironmentChangedSuccessEvent(Singleton._CurrentEnvironment.Environment);
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("Exception calling event after a successful environment reset: "+e);
                }
            }
            finally
            {
                Singleton.environmentResetBlocker.Set(); //unblock all waiting threads
            }
        }

        // Updates the webstore sitename to match the currently set environment.
        public static void UpdateWebstoreSite()
        {
            if (Global.CurrentEnvironment==null || Global.CurrentEnvironment.WebstoreSiteOverride==null || Global.CurrentEnvironment.WebstoreSiteOverride.Length==0)
                WSClient.SiteName="";
            else
                WSClient.SiteName=Global.CurrentEnvironment.WebstoreSiteOverride+"\\";
        }

        // Internal initialize after we have a valid xml document (Global.Config)
        private static void STFLiveConfigInitialize()
        {
             // Initialize static members (otherwise this is done when the assembly loads
            // and we have very little control over exceptions)
            //Certificates = new CertificateHash();
            XEnv = new XConfig();

            WSClient.SiteName="SiteNameNotSet"; //don't let them succeed against potentially the wrong environment

            // Load the IP that will be used to match the list of local IPs to see what to use
            // as the SG's IP
            XmlElement clientIpEl = (XmlElement)Config.SelectSingleNode("/stf/config/clientip");
            if(clientIpEl != null)
            {
                string strMatchAttr = clientIpEl.GetAttribute("match");
                if(strMatchAttr != null)
                    SGIPMatchAddr = IPAddress.Parse(strMatchAttr);
            }

            // BulkUserSet stuff -- can be specified in the XML file like such:
            //
            // <stf>
            //   <config>
            //         <bulkusers basepuid="0x900000021e39c" count="100000" prefix="bu" tag="xenon"/>
            //   </config>
            // </stf>
            //
            //  basepuid - base puid, in hex, of the userset
            //     count - number of users in userset
            //    prefix - the 2-letter user prefix, default from BulkUser.exe is "bu"
            //       tag - user-defined tag for identifying this userset. I'd recommend "xenon"
            //             for Xenon users, "xbox" for Xbox1 users, or something indicating which
            //             group this is. 
            //  You are allowed to have multiple <bulkuser> tags in the XML file. They are retrieved
            //  in code with the GetUserSet(tag) call - pass in the tag for the set you want.
            //
            XmlNodeList bulkusernodes = Config.GetElementsByTagName("bulkusers");
            if (bulkusernodes != null && bulkusernodes.Count > 0)
            {
                UserSetHash = new Hashtable(bulkusernodes.Count);
                for (int i = 0; i < bulkusernodes.Count; i++)
                {
                    XmlNode n = bulkusernodes.Item(i);
                    // Required
                    string basepuidstr = (n.Attributes["basepuid"] == null) ? null : n.Attributes["basepuid"].Value;
                    string countstr = (n.Attributes["count"] == null) ? null : n.Attributes["count"].Value;
                    if (basepuidstr == null || countstr == null)
                    {
                        RO.Warn("<bulkusers> tag format in XML config file is incorrect");
                    }

                    // Optional
                    string tagstr = (n.Attributes["tag"] == null) ? "" : n.Attributes["tag"].Value.ToLower();
                    string prefix = (n.Attributes["prefix"] == null) ? "bu" : n.Attributes["prefix"].Value;

                    // Create set of users
                    ulong basepuid_ulong = 0;
                    uint count_uint = 0;
                    BulkUserSetBase us = null;

                    try
                    {
                        basepuid_ulong = Convert.ToUInt64(basepuidstr, 16);
                        count_uint = uint.Parse(countstr);
                        us = new BulkUserSetBase(prefix, basepuid_ulong, count_uint);
                    }
                    catch (Exception e)
                    {
                        // just in case
                        us = null;
                        RO.Warn("INVALID: BulkUserSet[{0}]: prefix={1}, basepuid={2}, count={3}, tag={4}\n{5}", i, prefix, basepuidstr, countstr, tagstr, 
                            e.ToString());
                    }

                    if (us != null)
                    {
                        RO.Debug("BulkUserSet[{0}]: prefix={1}, basepuid=0x{2:X}, count={3}, tag={4}", i, us.Prefix, us.Base, us.Count, tagstr);

                        // Add to hash
                        UserSetHash[tagstr] = us;
                    }
                }
            }

            //
            // Parse ConfigEnv environment settings
            //
            XmlNodeList configenvNodes = Config.GetElementsByTagName("configenv");
            if (configenvNodes != null && configenvNodes.Count > 0)
            {
                EnvironmentList = new List<EnvironmentSetting>(configenvNodes.Count);
                for (int i = 0 ; i < configenvNodes.Count; ++i)
                {
                    XmlNode n = configenvNodes.Item(i);
                    string env = (n.Attributes["environment"]==null?null:n.Attributes["environment"].Value);
                    string npdbip = (n.Attributes["npdbip"]==null?null:n.Attributes["npdbip"].Value);
                    string npdbname = (n.Attributes["npdbname"]==null?"npdb":n.Attributes["npdbname"].Value);
                    string webstoresite = (n.Attributes["webstoresite"]==null?null:n.Attributes["webstoresite"].Value);
                    string isXblobString = (n.Attributes["isxblob"]==null?"false":n.Attributes["isxblob"].Value);
                    bool isXblob=false;
                    if (!bool.TryParse(isXblobString, out isXblob))
                    {
                        RO.Warn("Invalid bool value for isxblob: "+isXblobString);
                    }

                    if (EnvironmentList.Any(e => e.Environment == env))
                    {
                        RO.Warn("A duplicate environment name was found: {0}\n  Discarding: {1}\n  Keeping   : {2}",
                            env, npdbip, EnvironmentList.Find(e => e.Environment == env).NpdbIp);
                        continue;
                    }

                    EnvironmentList.Add(new EnvironmentSetting(env, npdbip, npdbname, webstoresite, isXblob));
                }

                //We won't set any by default.  This prevents people from accidently running against the wrong environment.
                //CurrentEnvironment=null; //EnvironmentList[0];
            }
            else
            {
                RO.Warn("No <configenv> tags found in config XML, you really should define one");
            }

            //
            XmlNodeList passportNodeList = Config.GetElementsByTagName("passportloginurl");
            if (passportNodeList != null)
            {
                foreach(XmlNode node in passportNodeList)
                {
                    Singleton.passportLoginUrls.Add(node.Attributes["environment"].Value,node.InnerText);
                }
            }

            XmlElement emulatorFlagSetting = Global.Config.SelectSingleNode("//setting[@name=\"EmulatorFlags\"]") as XmlElement;
            if (emulatorFlagSetting != null)
            {
                string flags = emulatorFlagSetting.GetAttribute("value");
                if (flags != null)
                {
                    Singleton.emulatorFlags = (EmulatorFlags)Int32.Parse(flags);
                }
            }

            // Update webstore's site initially
            UpdateWebstoreSite();

            // emulator settings
            XmlElement musicNetSetting = Global.Config.SelectSingleNode("//setting[@name=\"UseMusicNetEmulator\"]") as XmlElement;
            if (musicNetSetting != null)
            {
                string boolvalue = musicNetSetting.GetAttribute("value").ToLower();
                if (boolvalue != null)
                {
                    if (boolvalue.ToLower() == "true" || boolvalue.ToLower() == "1")
                        UseMusicNetEmulator = true;
                    else if (boolvalue.ToLower() == "false" || boolvalue.ToLower() == "0")
                        UseMusicNetEmulator = false;
                }
            }

            //register core event handlers
            CoreGlobal.TestNodeTreePreload += HandleSuitePreload;
            CoreGlobal.TestNodeTreeLoaded+=HandleSuiteLoaded;

            //Register our tagging expressions with STFCore
            NodeTaggingLive.RegisterLiveExpressions();
        }

        //called whenever a test tree is constructed
        private static void HandleSuiteLoaded(TestNode root)
        {
            if (!reloadSuitesOnEnvironmentChange && root.HasAttribute(typeof(ReloadOnEnvironmentChangeAttribute)))
            {
                reloadSuitesOnEnvironmentChange=true;
                Singleton.EnvironmentChangedSuccessEvent+=HandleEnvironmentChangeTestReload;
            }
        }

        private static void HandleSuitePreload (CoreGlobal.TestNodeTreeSourceInfo sourceInfo)
        {
            if (!string.IsNullOrEmpty(sourceInfo.AssemblyFile))
            {
                string fileName = sourceInfo.AssemblyFile;

                //see if there's an xml file with the same name as the module
                string xmlName = "";
                if (fileName.ToLower().EndsWith(".dll") || fileName.ToLower().EndsWith(".exe"))
                {
                    xmlName = fileName.Substring(0, fileName.Length - 4);
                    xmlName += ".xml";

                    if (System.IO.File.Exists(xmlName))
                    {
                        //merge the config into STFLive
                        RO.Debug("Merging STFLive XML associated with module: " + xmlName);
                        try
                        {
                            Global.Config.ConditionalMerge(new StfXmlDoc(xmlName), "/stf", xmlName);
                        }
                        catch (Exception e)
                        {
                            RO.Error("Exception loading xml file " + xmlName + ": " + e);
                        }
                    }
                }
            }
        }

        //called when a the environment is changed and we need to cause test trees to be reloaded
        private static void HandleEnvironmentChangeTestReload(string environmentName)
        {
            Global.RO.Debug("Reloading test trees because the environment changed and a suite requires it.");
            CoreGlobal.CallReloadAllTestTrees();
        }

        /// <summary> This call will block until an environment is initially set in STFLiveConfig, or until the environment reset finishes if in the middle of a reset. </summary>
        public static void BlockUntilEnvironmentIsReady()
        {
            Singleton.environmentResetBlocker.WaitOne();
        }

        /// <summary>
        /// Returns the BulkUserSet, if specified in the XML file. Grabs either the
        /// userset with tag "" or the first user set, if "" is not found.
        /// </summary>
        /// <returns></returns>
        static public BulkUserSetBase GetUserSet()
        {
            // Return the first entry in the hash, regardless of the tag
            if (UserSetHash == null || UserSetHash.Count <= 0)
                throw new StfException("No BulkUserSet configured, please add a valid <bulkusers> tag to stf.xml");

            // First check for the tagless case
            if (UserSetHash.ContainsKey(""))
                return (BulkUserSetBase)UserSetHash[""];

            // Otherwise let's pick something. This is the only way I know of to get a 
            // value, any value.  Which value you get depends on the hashtable layout, 
            // but at least you'll get something.
            foreach (object o in UserSetHash.Values)
            {
                return (BulkUserSetBase)o;
            }

            // Nothing found. This is bad, should have been caught above.
            throw new StfException("GetUserSet: no value found in collection, this shouldn't have made it here");
        }

        /// <summary>
        /// Returns the BulkUserSet, if specified in the XML file, for the given tag. This is
        /// user-settable, in the XML file, and allows for distinct user sets. You may want
        /// to create some Xenon and Xbox users, or partition them manually, etc.
        /// </summary>
        /// <param name="tag"></param>
        /// <returns></returns>
        static public BulkUserSetBase GetUserSet(string tag)
        {
            string key = tag.ToLower();
            if (UserSetHash == null)
                throw new StfException("No BulkUserSet configured, please add a <bulkusers> tag to stf.xml");
            if (!UserSetHash.ContainsKey(key))
                throw new StfException("No BulkUserSet exists in the hash with the tag \"{0}\"", key);
            return (BulkUserSetBase)UserSetHash[key];
        }

        /// <summary>
        /// Returns an XML node for the "settingsgroup" node matching the current environment choice
        /// </summary>
        /// <returns></returns>
        static public XmlElement GetEnvironmentSettingsGroup()
        {
            string envName = "None";
            if (Global.CurrentEnvironment != null)
            {
                envName = Global.CurrentEnvironment.Environment;
            }

            string xpath = "//settingsgroup[@environment=\"" + envName + "\"]";
            XmlElement el = Config.SelectSingleNode(xpath) as XmlElement;
            return el;
        }

        /// <summary>
        /// Returns an XML node for the "settingsgroup" node with the given name
        /// </summary>
        /// <param name="name"></param>
        /// <returns></returns>
        static public XmlElement GetSettingsGroup(string name)
        {
            string xpath = "//settingsgroup[@name=\"" + name + "\"]";
            XmlElement el = Config.SelectSingleNode(xpath) as XmlElement;
            return el;
        }

        /// <summary>
        /// Converts an XErr returned by the server to a string (long live reflection!)
        /// </summary>
        /// <param name="XErr">Error code returned by the XOnline servers</param>
        /// <returns>A human readable string</returns>
        static public string XErrToString(uint XErr)
        {
            HResult hr = XErr;

            return String.Format("{0}: {1}", hr.ToString(), 
                hr.Name ?? "Unknown server error code, XOn.cs is out of date!");
        }
    }

    public class CertificateEntry
    {
        public enum CertType {X509, PKCS12, RootCA};

        public string Name;
        public byte[] Cert;
        public CertType Type = CertType.X509;
        public bool Install = false;

        public CertificateEntry(string name, byte[] cert)
        {
            this.Name = name;
            this.Cert = cert;
        }

        public CertificateEntry(string name, byte[] cert, CertType type, bool install)
        {
            this.Name = name;
            this.Cert = cert;
            this.Type = type;
            this.Install = install;
        }

        public override string ToString()
        {
            return (Type == CertType.X509 ? "X509" : "PKCS#12") + ": " + Name;
        }
    }

    [Serializable]
    public class EnvironmentSetting
    {
        public string Environment;
        public string NpdbIp;
        public string NpdbName;
        public string WebstoreSiteOverride;
        public bool   IsXblob;

        public EnvironmentSetting(string environment, string npdbIp, string npdbName, string webstoreSite, bool isXblob)
        {
            Environment=environment;
            NpdbIp=npdbIp;
            NpdbName=npdbName;
            WebstoreSiteOverride=webstoreSite;
            IsXblob=isXblob;
        }

        public override string ToString()
        {
            return 
                "Environment="+Environment+
                " NpdbIp="+NpdbIp+
                " NpdbName="+NpdbName+
                " WebstoreSiteOverride="+WebstoreSiteOverride+
                " IsXblob="+IsXblob;
        }
    }

    [Flags]
    public enum EmulatorFlags
    {
        None = 0x0,
        Wmis = 0x1,
        SyncCastTransaction = 0x2,
        SyncCastLicense = 0x4,
        All = Wmis | SyncCastTransaction | SyncCastLicense
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveConfig\XConfig.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Xml;
using System.Net;
using System.Data;
using System.Data.SqlClient;
using System.Text;
using xonline.common.config;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.LiveService
{

    public class ConfigInfo
    {
        public string environment;
        public int siteid;
        public string server;
        public string component;
        public string settingName;
        public string settingvalue = null;
        public bool isStale;
        public DateTime lastEventTime;
        public string settingnewValue = null;

        public string ErrorStr = null;

        public override string ToString()
        {
            return String.Format("[{0}, {1}] [{2}, {3}, {4}] [{5}, {6}, {7}] [{8}] {9}",
                                 environment,
                                 siteid,

                                 server,
                                 component,
                                 settingName,

                                 settingvalue,
                                 settingnewValue,
                                 isStale,

                                 lastEventTime,

                                 (ErrorStr == null ? "" : ErrorStr));
        }
    }

    /// <summary>
    /// Summary description for XConfig.
    /// </summary>
    public class XConfig : InfiniteLifetimeMarshalByRefObject
    {
        internal Report RO=new Report("XConfig");

        Hashtable VInterfaceOverride = new Hashtable();
        Hashtable InterfaceOverride = new Hashtable();

        public XConfig()
        {
        }

        public string GetEnv()
        {
            return Config.Environment;
        }

        public void Initialize(XmlDocument config)
        {
            // load configdb settings
            if (!Global.IsEnvironmentInternal)
            {
                RO.Info("No default Npdb setting specified.");
                Config.NpdbServer = null;
            }
            else
            {
                Config.NpdbServer = Global.CurrentEnvironment.NpdbIp;
                try
                {
                    RO.Info("Using Npdb address {0}", Config.NpdbServer);
                }
                catch
                {
                    RO.Debug("Npdb server not found.");
                }
            }

            //Code to build override map.
            XmlNodeList Node = config.GetElementsByTagName("interfaces");
            if (Node != null && Node.Count >= 1)
            {
                for (int nodeIdx = 0; nodeIdx < Node.Count; nodeIdx++)
                {
                    XmlNodeList Interfaces = Node[nodeIdx].ChildNodes;
                    for (int i = 0; i < Interfaces.Count; i++)
                    {
                        if (Interfaces[i].Name == "interface")
                        {
                            ArrayList ipOverrides = new ArrayList();
                            string intname = Interfaces[i].Attributes["name"].Value;
                            int port = Convert.ToInt32(Interfaces[i].Attributes["port"].Value);

                            XmlNodeList Ilist = Interfaces[i].ChildNodes;
                            for (int j = 0; j < Ilist.Count; j++)
                            {
                                if (Ilist[j].Name == "vip")
                                {
                                    System.Net.IPAddress ip = System.Net.IPAddress.Parse(Ilist[j].InnerText);
                                    if (!VInterfaceOverride.Contains(intname.Trim()))
                                    {
                                        VInterfaceOverride.Add(intname.Trim(), new System.Net.IPEndPoint(ip, port));
                                    }
                                    else
                                    {
                                        VInterfaceOverride[intname.Trim()] = new System.Net.IPEndPoint(ip, port);
                                        //RO.Warn("Duplicate VIP entry found for interface " + intname.Trim() + ".");
                                    }
                                }
                                else if (Ilist[j].Name == "ip")
                                {
                                    System.Net.IPAddress ip = System.Net.IPAddress.Parse(Ilist[j].InnerText);
                                    ipOverrides.Add(new System.Net.IPEndPoint(ip, port));

                                }
                                else
                                {
                                    RO.Info(" Invalid Tag in Interface" + intname + " with name " + Ilist[j].Name);
                                }
                            }

                            if (ipOverrides.Count > 0)
                            {
                                InterfaceOverride[intname.Trim()] = ipOverrides;
                            }

                        }
                        else if (Interfaces[i].Name == "#comment")
                        {
                            continue;
                        }
                        else
                        {
                            RO.Info(" Invalid Tag in Interfaces with name " + Interfaces[i].Name);
                        }
                    }
                }
            }
            RO.Debug("Overridden vinterfaces: {0}", GetOverriddenVInterfaces());
            RO.Debug("Overridden interfaces: {0}", GetOverriddenInterfaces());
        }

        public string GetOverriddenVInterfaces()
        {
            StringBuilder sb = new StringBuilder();
            int iter = 0;
            foreach (object key in VInterfaceOverride.Keys)
            {
                IPEndPoint ip = (IPEndPoint)VInterfaceOverride[key];
                if (iter == 0)
                    sb.Append((string)key + "/" + ip.ToString());
                else
                    sb.Append(", " + (string)key + "/" + ip.ToString());
                iter++;
            }
            return sb.ToString();
        }
        
        public string GetOverriddenInterfaces()
        {
            StringBuilder sb = new StringBuilder();
            int iter = 0;
            foreach (object key in InterfaceOverride.Keys)
            {
                string ips = null;
                ArrayList ipsArray = (ArrayList)InterfaceOverride[key]; 
                for (int i = 0; i < ipsArray.Count; i++)
                {
                    ips += "/" + ((IPEndPoint)ipsArray[i]).ToString();
                }
                if (iter == 0)
                    sb.Append((string)key + ips);
                else
                    sb.Append(", " + (string)key + ips);
                iter++;
            }
            return sb.ToString();
        }

        // check npdb accessibility for each npdb
        private static ArrayList isNpdbAccessible = new ArrayList();

        /// <summary>
        /// Does a relatively quick check for whether we can talk to the NPDB machine or not.
        /// The timeout period for making an NPDB call (via SQL) when the server is not available
        /// is over 1 minute on my machine. This should time out in a couple of seconds. That is
        /// oh-so-much more tolerable.
        /// </summary>
        public static void CheckNpdbAccessibility()
        {
            //if the ip is an empty string, then we have no npdb to connect to, so don't try
            if (!Global.IsEnvironmentInternal)
            {
                throw new ServerTestFramework.Utilities.TimeoutException("No NPDB to access.");
            }

            // If we've already successfully checked, we don't need to do it again. If we
            // really did lose connectivity, then something bad happened and a long timeout
            // with "good" error message is acceptable.  If we've unsuccessfully checked,
            // then we'll keep checking in the hopes that connectivity was restored. I guess
            // this makes sense.
            if (isNpdbAccessible.Contains(Config.NpdbServer))
                return;

            // This should timeout faster than CommonConfig
            IPHostEntry hostInfo;
            try
            {
                hostInfo = System.Net.Dns.GetHostEntry(Config.NpdbServer);
            }
            catch (System.Net.Sockets.SocketException)
            {
                // No host returned, probably means we can't access the NPDB server
                throw new ServerTestFramework.Utilities.TimeoutException("Timed out looking up NPDB server address");
            }
            if (hostInfo.AddressList.Length <= 0)
            {
                // No host returned, probably means we can't access the NPDB server
                throw new ServerTestFramework.Utilities.TimeoutException("Timed out looking up NPDB server address");
            }
            isNpdbAccessible.Add(Config.NpdbServer);
        }

        // InitializeTestServer should only be done once for each npdb
        private static ArrayList testServerInitialized = new ArrayList();

        public void InitializeTestServer()
        {
            //if we're on an external environment, we can't access npdb, so give up now.
            if (!Global.IsEnvironmentInternal)
            {
                return;
            }

            // Override the default site ID for your test server, this is a hack to fool
            // other pieces of code using the config object, otherwise they lookup
            // their virtual interfaces using Config.SiteId which by default is 0.
            // I added this so that I could integrate the CryptoMgr stuff for bulkuser
            // creation.  --jacobr

            if (testServerInitialized.Contains(Config.NpdbServer))
                return;

            // No matter what happens now, we don't really want to attempt it again if 
            // something fails. If it fails, that's it, no second chances.
            testServerInitialized.Add(Config.NpdbServer);

            //if the ip is an empty string, then it was different than the global view of it.
            if (Config.NpdbServer==null || Config.NpdbServer.Length==0)
            {
                RO.Fatal("STF npdb setting and commonconfig npdb settings are mismatched.  This should never happen.");
            }

            //
            Npdb npdb = new Npdb();
            try
            {
                npdb.ConnectToServer();
            }
            catch (DatabaseException de)
            {
                RO.Error("Unable to connect to NPDB:\n"+de);
                return;
            }
            catch (SqlException se)
            {
                RO.Error("Unable to connect to NPDB:\n"+se);
                return;
            }


            // Check for existence of test server first
            SqlDataReader reader = null;
            bool skipInsert = false;
            try
            {
                npdb.ReadData("select * from t_servers where vc_server = \'" + Config.Server + "\' and vc_environment=\'" + Config.Environment + "\'", out reader);
                skipInsert = reader.HasRows;
            }
            catch (Exception ex)
            {
                RO.Error("Npdb.ReadData() failed: {0}", ex.ToString());
            }
            finally
            {
                if (null != reader && !reader.IsClosed)
                {
                    reader.Close();
                }
            }

            // No need to insert another unique server one exists for this machine already
            // and it will find the correct SiteId
            if (!skipInsert)
            {
                string stmt = "insert into t_servers (vc_environment, vc_server, i_site_id, vc_server_state) values (" +
                    "\'" + Config.Environment + "\', " +
                    "\'" + Config.Server + "\', " +
                    Config.MainSiteId.ToString() + ", " +
                    "\'offline\')";

                if (0 == npdb.IssueCommand(stmt))
                {
                    RO.Error("Failed to insert test server. Failed SQL command: {0}", stmt);
                }
            }
        }

        /// <summary>
        /// A separate list of virtual interface overrides that can be changed programmatically.
        /// </summary>
        private Dictionary<string, IPEndPoint> _virtualInterfaceRedirections = null;

        /// <summary>
        /// Will override all GetVirtualInterface calls for the given vinterface names to the specified IP endpoints.
        /// The port will be changed only if it isn't IPEndPoint.MinPort (0).
        /// 
        /// The Dictionary is assumed to be invariant; making changes to it after passing it in can result in
        /// thread safety issues.  To change the redirections, create a new Dictionary.
        /// </summary>
        /// <param name="destinations">The pairs of vinterface names and their new address.</param>
        public void RedirectVirtualInterfaces (Dictionary<string, IPEndPoint> destinations)
        {
            _virtualInterfaceRedirections = destinations;
        }

        //
        public IPEndPoint GetVirtualInterface(string InterfaceName)
        {
            IPEndPoint temp = null;
            string name = InterfaceName.Trim();
            if (VInterfaceOverride.Contains(name))
            {
                temp = (IPEndPoint)VInterfaceOverride[name];
                temp = new IPEndPoint(temp.Address, temp.Port);
            }
            else
            {
                try
                {
                    CheckNpdbAccessibility();
                }
                catch (ServerTestFramework.Utilities.TimeoutException)
                {
                    RO.Warn("Unable to communicate with NPDB. Maybe you need to have an explicit virtual interface override in stf.xml?");
                    RO.Debug("stf.xml override example in /stf/interfaces/ path:");
                    RO.Debug("\t\t<interface name='{0}' port='0'>", name);
                    RO.Debug("\t\t\t<vip>0.0.0.0</vip>");
                    RO.Debug("\t\t</interface>");
                    throw;
                }
                IVirtualInterfaceInfo tmp = (IVirtualInterfaceInfo)Config.GetVirtualInterface(InterfaceName, Site.main);
                temp = new IPEndPoint(tmp.IPAddress, tmp.Port);
            }

            // check for virtual interface redirection
            IPEndPoint new_ip;
            Dictionary<string, IPEndPoint> virs = _virtualInterfaceRedirections;
            if (virs != null && virs.TryGetValue(name, out new_ip))
            {
                temp.Address = new_ip.Address;
                if (new_ip.Port != IPEndPoint.MinPort)
                {
                    temp.Port = new_ip.Port;
                }
            }

            return temp;
        }

        //
        public IPEndPoint GetVirtualInterface(string InterfaceName, int SiteId)
        {
            IPEndPoint temp = null;
            string name = InterfaceName.Trim();
            if (VInterfaceOverride.Contains(name))
            {
                temp = (IPEndPoint)VInterfaceOverride[name];
                temp = new IPEndPoint(temp.Address, temp.Port);
            }
            else
            {
                try
                {
                    CheckNpdbAccessibility();
                }
                catch (ServerTestFramework.Utilities.TimeoutException)
                {
                    RO.Warn("Unable to communicate with NPDB. Maybe you need to have an explicit virtual interface override in stf.xml?");
                    RO.Debug("stf.xml override example in /stf/interfaces/ path:");
                    RO.Debug("\t\t<interface name='{0}' port='0'>", name);
                    RO.Debug("\t\t\t<vip>0.0.0.0</vip>");
                    RO.Debug("\t\t</interface>");
                    throw;
                }
                IVirtualInterfaceInfo tmp = (IVirtualInterfaceInfo)Config.GetVirtualInterface(InterfaceName, SiteId);
                temp = new IPEndPoint(tmp.IPAddress, tmp.Port);
            }

            // check for virtual interface redirection
            IPEndPoint new_ip;
            Dictionary<string, IPEndPoint> virs = _virtualInterfaceRedirections;
            if (virs != null && virs.TryGetValue(name, out new_ip))
            {
                temp.Address = new_ip.Address;
                if (new_ip.Port != IPEndPoint.MinPort)
                {
                    temp.Port = new_ip.Port;
                }
            }

            return temp;
        }

        public string[] GetServerListByComponent(string component)
        {
            string[] retval = null;
            string name = component.ToString();
            if (InterfaceOverride.Contains(name.Trim()))
            {
                ArrayList serverList = (ArrayList)InterfaceOverride[name.Trim()];
                string[] servers = new string[serverList.Count];

                for (int i = 0; i < serverList.Count; i++)
                {
                    IPHostEntry hostInfo = Dns.GetHostEntry(((IPEndPoint)serverList[i]).Address);
                    string[] names = hostInfo.HostName.Split(new char[] { '.' });
                    if (names != null && names.Length > 1)
                        servers[i] = names[0];
                }
                retval = servers;
            }
            else
            {
                CheckNpdbAccessibility();
                string InterfaceName = name;
                if (InterfaceName == "cron")
                {
                    InterfaceName = "cron_int";
                }
                retval = Config.GetServerListByInterface(InterfaceName);
            }
            return retval;
        }

        public string[] GetServerListByInterface(string InterfaceName)
        {
            string[] retval = null;
            string name = InterfaceName.ToString();
            if (InterfaceOverride.Contains(name.Trim()))
            {
                ArrayList serverList = (ArrayList)InterfaceOverride[name.Trim()];
                string[] servers = new string[serverList.Count];

                for (int i = 0; i < serverList.Count; i++)
                {
                    IPHostEntry hostInfo = Dns.GetHostEntry(((IPEndPoint)serverList[i]).Address);
                    string[] names = hostInfo.HostName.Split(new char[] { '.' });
                    if (names != null && names.Length >= 1)
                        servers[i] = names[0];
                }
                retval = servers;
            }
            else
            {
                CheckNpdbAccessibility();
                retval = Config.GetServerListByInterface(InterfaceName);
            }
            return retval;
        }

        public IPEndPoint[] GetBucketMappedInterface(string iface)
        {
            uint i;
            CheckNpdbAccessibility();

            uint BucketCount = Config.GetBucketCount(iface);
            uint ServerCount = 0;
            Hashtable hash   = new Hashtable();

            // For each bucket find the interface and add an endpoint for it
            for (i = 0; i < BucketCount; ++i)
            {
                // Loookup the correct endpoint for the interface and bucket index
                IInterfaceInfo interfaceInfo = null;
                IBucketServer bucketServer = Config.GetBucketServer(iface, i);
                if (bucketServer.NextServerStart >= DateTime.Now)
                {
                    interfaceInfo = bucketServer.NextServer;
                }
                else
                {
                    interfaceInfo = bucketServer.CurrentServer;
                }

                // If we haven't seen this endpoint we'll cache it
                if(!hash.Contains(interfaceInfo.IPAddress))
                {
                    ServerCount++;
                    hash[interfaceInfo.IPAddress] = new IPEndPoint(interfaceInfo.IPAddress, interfaceInfo.Port);
                }
            }

            if(0 == ServerCount)
            {
                throw new StfException("Zero unique servers found in the bucket map");
            }

            // Collapse the hash values ICollection into an array 
            i = 0;
            IPEndPoint []endpoints = new IPEndPoint[ServerCount];
            foreach(IPEndPoint ep in hash.Values)
            {
                endpoints[i++] = ep;
            }

            return endpoints;
        }

        public IPEndPoint[] GetInterface(string InterfaceName)
        {
            IPEndPoint[] IPs = null;

            string name = InterfaceName.ToString();
            if (InterfaceOverride.Contains(name.Trim()))
            {
                ArrayList serverList = (ArrayList)InterfaceOverride[name.Trim()];
                IPs = new IPEndPoint[serverList.Count];
                serverList.CopyTo(IPs, 0);
            }
            else
            {
                CheckNpdbAccessibility();
                string[] servers = Config.GetServerListByInterface(InterfaceName);
                ArrayList serverList = new ArrayList();

                foreach (string server in servers)
                {
                    IInterfaceInfo tmp = Config.GetInterface(server, InterfaceName);
                    // Don't add interfaces that are disabled
                    if (!tmp.NicDisabled)
                        serverList.Add(new IPEndPoint(tmp.IPAddress, tmp.Port));
                }
                IPs = new IPEndPoint[serverList.Count];
                serverList.CopyTo(IPs, 0);
            }

            return IPs;
        }


        public IPEndPoint GetInterface(string InterfaceName, string server)
        {
            IPEndPoint IP = null;

            string name = InterfaceName.ToString();
            if (InterfaceOverride.Contains(name.Trim()))
            {
                ArrayList serverList = (ArrayList)InterfaceOverride[name.Trim()];

                for (int i = 0; i < serverList.Count; i++)
                {
                    IPHostEntry hostInfo = Dns.GetHostEntry(((IPEndPoint)serverList[i]).Address);
                    string[] names = hostInfo.HostName.Split(new char[] { '.' });
                    if (names != null && names.Length >= 1)
                    {
                        if(server== names[0])
                        {
                            IP=(IPEndPoint)serverList[i];
                            break;
                        }
                    }
                }
                
            }
            else
            {
                IInterfaceInfo tmp = Config.GetInterface(server, InterfaceName);
                IP = new IPEndPoint(tmp.IPAddress, tmp.Port);
            }

            return IP;
        }

        public void ExecuteXmgmtCommand(string InterfaceName, string Command)
        {
            ExecuteXmgmtCommand(InterfaceName, Command, 0);
        }

        public void ExecuteXmgmtCommand(string InterfaceName, string Command, int TotalRetries)
        {
            bool failed = false;
            int currentRetries = 0;

            // check if stf.xml has  any overides
            string outparam = null;
            string name = InterfaceName.ToString();
            if (InterfaceOverride.Contains(name.Trim()))
            {
                ArrayList serverList = (ArrayList)InterfaceOverride[name.Trim()];
                for (int i = 0; i < serverList.Count; i++)
                {
overriden_retry:
                    try
                    {
                        IPHostEntry hostInfo = Dns.GetHostEntry(((IPEndPoint)serverList[i]).Address);
                        string[] names = hostInfo.HostName.Split(new char[] { '.' });
                        if (names != null && names.Length >= 1)
                            name = names[0];
                        Global.RO.Info(name);
                        IInterfaceInfo mgmti = Config.GetInterface(name, Interface.xmgmtsrv);
                        Global.RO.Info(mgmti.IPAddress + ":" + mgmti.Port);
                        ManagementConsole.Execute(new IPEndPoint(mgmti.IPAddress, mgmti.Port), Command, out outparam);
                        if (outparam != null && outparam.Length > 1)
                        {
                            Global.RO.Debug(outparam);
                        }
                        failed = false;
                    }
                    catch (System.Exception e)
                    {
                        if (outparam != null && outparam.Length > 1)
                        {
                            Global.RO.Info(outparam.Trim());
                        }
                        Global.RO.Warn("failed to execute xmgmt command \"" + Command + "\" on " + ((IPEndPoint)serverList[i]).ToString() + " for " + InterfaceName + "(" + name + ")");
                        Global.RO.Warn(e.Message);
                        failed = true;
                    }
                    if (failed)
                    {
                        if (currentRetries < TotalRetries)
                        {
                            currentRetries++;
                            System.Threading.Thread.Sleep(10);
                            goto overriden_retry;
                        }
                    }
                }
            }
            else
            {
                string[] servers = GetServerListByInterface(InterfaceName);
                foreach (string server in servers)
                {
nonoverriden_retry:
                    string ip="";
                    try
                    {
                        IInterfaceInfo tmp = Config.GetInterface(server, Interface.xmgmtsrv);
                        ip=tmp.IPAddress.ToString();
                        ManagementConsole.Execute(new IPEndPoint(tmp.IPAddress, tmp.Port), Command, out outparam);
                        if (outparam != null && outparam.Length > 1)
                        {
                            Global.RO.Debug(outparam.Trim());
                        }
                        failed = false;
                    }
                    catch (System.Exception e)
                    {
                        if (outparam != null && outparam.Length > 1)
                        {
                            Global.RO.Info(outparam);
                        }
                        Global.RO.Warn("failed to execute xmgmt command \"" + Command + "\" on " + server + " for " + InterfaceName + " = " + ip);
                        Global.RO.Warn(e.Message);
                        failed = true;
                    }
                    if (failed)
                    {
                        if (currentRetries < TotalRetries)
                        {
                            currentRetries++;
                            goto nonoverriden_retry;
                        }
                    }
                }
            }
        }

        // Execute a Xmgmt command on a particular server
        // doesn't check if stf.xml has any overides
        public void ExecuteXmgmtCommandOneServer(string serverName, string Command)
        {
            string outparam = null;

            string ip="";
            try
            {
                IInterfaceInfo tmp = Config.GetInterface(serverName, Interface.xmgmtsrv);
                ip=tmp.IPAddress.ToString();
                ManagementConsole.Execute(new IPEndPoint(tmp.IPAddress, tmp.Port), Command, out outparam);
                if (outparam != null && outparam.Length > 1)
                {
                    Global.RO.Debug(outparam.Trim());
                }
            }
            catch (System.Exception)
            {
                if (outparam != null && outparam.Length > 1)
                {
                    Global.RO.Info(outparam);
                }
                Global.RO.Warn("failed to execute xmgmt command \"" + Command + "\" on " + serverName + "(" + ip + ")");
            }
        }

        public bool GetBoolSetting(string _setting)
        {
            return Config.GetBoolSetting(_setting);

        }

        public int GetIntSetting(string _setting)
        {
            return Config.GetIntSetting(_setting);
        }

        public long GetLongSetting(string _setting)
        {
            return Config.GetLongSetting(_setting);
        }

        public double GetDoubleSetting(string _setting)
        {
            return Config.GetDoubleSetting(_setting);
        }

        public string GetSetting(string _setting)
        {
            return Config.GetSetting(_setting);
        }

        public SettingState GetOverrideSettingState(string component, string server, string _setting, int siteId)
        {
            string environ = Config.Environment;
            SettingState tmp = new SettingState(environ, component, server, _setting, siteId);

            using (Npdb npdb = new Npdb())
            {
                npdb.ConnectToServer();

                string gsetsql = "SELECT  [vc_value] FROM [t_setting_overrides] ";
                string whereclause = "WHERE vc_environment= '" + environ + "' AND vc_component='" + component + "' AND i_site_id='" + siteId + "' AND vc_server='" + server + "' AND vc_setting='" + _setting + "'";

                SqlDataReader reader = null;

                try
                {
                    npdb.ReadData(gsetsql + whereclause, out reader);

                    if (reader != null && reader.HasRows)
                    {
                        tmp.wasoverriden = true;

                        // assume ok because of HasRows
                        reader.Read();

                        tmp.oldvalue = reader.GetString(0);

                        if (reader.Read())
                        {
                            throw new Exception("More than one match for override of setting " + _setting + ", please investigate");
                        }
                    }
                }
                finally
                {
                    if (reader != null)
                    {
                        reader.Close();
                    }
                }
            }

            return tmp;
        }

        // this functions add the setting in t_setting_overrides table and returns the old setting.
        public SettingState OverrideSetting(string component, string server, string _setting, string _settingValue)
        {
            return OverrideSetting(component, server, _setting, _settingValue, 1);
        }

        // this functions add the setting in t_setting_overrides table and returns the old setting.
        public SettingState OverrideSetting(string component, string server, string _setting, string _settingValue, int siteId)
        {
            string environ = Config.Environment;
            SettingState tmp = GetOverrideSettingState(component, server, _setting, siteId);

            using (Npdb npdb = new Npdb())
            {
                npdb.ConnectToServer();

                string whereclause = "WHERE vc_environment= '" + environ + "' AND vc_component='" + component + "' AND i_site_id='" + siteId + "' AND vc_server='" + server + "' AND vc_setting='" + _setting + "'";

                if (tmp.wasoverriden)
                {
                    string updatesql = "UPDATE [t_setting_overrides] SET [vc_value]='" + _settingValue + "'";
                    if (npdb.IssueCommand(updatesql + whereclause) < 1)
                        throw new Exception("failed to update setting in t_setting_overrides");

                }
                else
                {
                    string insertsql = "INSERT INTO [t_setting_overrides]([vc_environment], [vc_component], [i_site_id], [vc_server], [vc_setting], [vc_value])";
                    insertsql += "VALUES('" + environ + "','" + component + "','" + siteId + "','" + server + "','" + _setting + "','" + _settingValue + "')";

                    if (npdb.IssueCommand(insertsql) < 1)
                        throw new Exception("failed to insert setting in t_setting_overrides");
                }
            }

            return tmp;
        }

        /// <summary>
        /// Restores the overridden setting to the state that it was before.
        /// </summary>
        /// <param name="state">The state before the override.</param>
        public void RestoreOverrideSettingState (SettingState state)
        {
            using (Npdb npdb = new Npdb())
            {
                npdb.ConnectToServer();

                string whereclause = "WHERE vc_environment= '" + state.Environment + "' AND vc_component='" + state.Component + 
                    "' AND i_site_id='" + state.Site + "' AND vc_server='" + state.Server + "' AND vc_setting='" + state.Setting + "'";

                if (state.wasoverriden)
                {
                    string updatesql = "UPDATE [t_setting_overrides] SET [vc_value]='" + state.oldvalue + "' ";
                    if (npdb.IssueCommand(updatesql + whereclause) < 1)
                        throw new Exception("failed to update setting in t_setting_overrides");
                }
                else
                {
                    string gsetsql = "delete FROM [t_setting_overrides] ";
                    if (npdb.IssueCommand(gsetsql + whereclause) < 1)
                        throw new Exception("failed to delete setting " + state.Setting + " from t_setting_overrides");
                }
            }
        }

        public void DeleteOverrideSetting(string component, string server, string _setting)
        {
            DeleteOverrideSetting(component, server, _setting, 1);
        }

        public void DeleteOverrideSetting(string component, string server, string _setting, int siteId)
        {
            Npdb npdb = null;
            try
            {
                npdb = new Npdb();
                npdb.ConnectToServer();

                string gsetsql = "delete FROM [t_setting_overrides] ";
                string whereclause = "WHERE vc_environment= '" + Config.Environment + "' AND vc_component='" + component + "' AND i_site_id='" + siteId + "' AND vc_server='" + server + "' AND vc_setting='" + _setting + "'";


                if (npdb.IssueCommand(gsetsql + whereclause) < 1)
                    throw new Exception("failed to delete setting " + _setting + " from  t_setting_overrides");



            }
            finally
            {
                if (npdb != null)
                    npdb.Close();
            }

        }

        public MultisettingState GetMultisettingOverrideState(string settingName)
        {
            string env=GetEnv();
            MultisettingState mss=new MultisettingState();
            mss.Environment=env;
            mss.Setting=settingName;

            System.Collections.Generic.List<IndividualMultisettingState> settingValues=new System.Collections.Generic.List<IndividualMultisettingState>();

            string query="select vc_component, i_site_id, vc_server, vc_value, uid_value_id from t_multisetting_overrides where vc_environment='"+env+"' and vc_multisetting='"+settingName+"'";

            using (Npdb npdb=new Npdb())
            {
                npdb.ConnectToServer();
                SqlDataReader reader;
                npdb.ReadData(query, out reader);
                using (reader)
                {
                    while (reader.Read())
                    {
                        IndividualMultisettingState imss=new IndividualMultisettingState();
                        imss.Component=(string)reader[0];
                        imss.Site=(int)reader[1];
                        imss.Server=(string)reader[2];
                        imss.Value=(string)reader[3];
                        imss.Id=(System.Guid)reader[4];
                        settingValues.Add(imss);
                    }
                }
            }

            mss.OldValues=settingValues.ToArray();
            return mss;
        }

        public void RestoreMultisettingOverrideState(MultisettingState oldState)
        {
            ClearMultisettingOverride(oldState.Environment, oldState.Setting);

            foreach (IndividualMultisettingState imss in oldState.OldValues)
            {
                AddMultisettingOverride(oldState.Environment, imss.Component, imss.Site, imss.Server, oldState.Setting, imss.Value); //NOTE: sproc doesn't let is restore imss.Id, but that's ok.
            }
        }

        public void AddMultisettingOverride(string multisetting, string value)
        {
            AddMultisettingOverride(GetEnv(), "ALL", -1, "ALL", multisetting, value);
        }

        public void AddMultisettingOverride(string component, int site, string server, string multisetting, string value)
        {
            AddMultisettingOverride(GetEnv(), component, site, server, multisetting, value);
        }

        public void AddMultisettingOverride(string environment, string component, int site, string server, string multisetting, string value) //NOTE: sproc doesn't us let restore (System.Guid id) but that's ok.
        {
            using (SqlConnection sql = new SqlConnection(Config.NpdbConnectionString))
            {
                sql.Open();

                SqlCommand cmd = new SqlCommand("dbo.p_config_add_multisetting_override");
                cmd.Connection = sql;
                cmd.CommandType = CommandType.StoredProcedure;

                cmd.Parameters.Add("@multisetting", SqlDbType.NVarChar).Value = multisetting;
                cmd.Parameters.Add("@value", SqlDbType.NVarChar).Value = value;
                if ("ALL" != environment)
                    cmd.Parameters.Add("@environment", SqlDbType.NVarChar).Value = environment;
                if ("ALL" != component)
                    cmd.Parameters.Add("@component", SqlDbType.NVarChar).Value = component;
                if (-1 != site)
                    cmd.Parameters.Add("@site_id", SqlDbType.Int).Value = site;
                if ("ALL" != server)
                    cmd.Parameters.Add("@server", SqlDbType.NVarChar).Value = server;

                cmd.ExecuteNonQuery();
            }
        }

        public void ClearMultisettingOverride(string settingName)
        {
            ClearMultisettingOverride(GetEnv(), settingName);
        }

        public void ClearMultisettingOverride(string environment, string settingName)
        {
            StaticNpdb.ExecuteNonQuery("delete from t_multisetting_overrides where vc_environment='"+environment+"' and vc_multisetting='"+settingName+"'");
        }

        /// MultiSettingAdd:
        /// Add a given multisetting to t_multisetting_overrides
        ///
        /// Parameters:
        ///    environment - vc_environment of Live Server environment
        ///    component - vc_component of Live Server component
        ///    site - i_site_id of Live Server site id
        ///    server - vc_server of Live Server server
        ///    multisetting - vc_multisetting to add
        ///    value - vc_value for the multisetting
        ///
        /// Returns n/a
        //The name on this function is misleading (it doesn't affect the base setting, only the overrides), should switch to a more descriptive name
        public void MultiSettingAdd(string environment, string component, string site, string server, string multisetting, string value)
        {
            Global.RO.Warn("XConfig.MultiSettingAdd is deprectaed.  Call AddMultisettingOverride instead.");
            AddMultisettingOverride(environment, component, int.Parse(site), server, multisetting, value);
        }

        /// MultiSettingAddBase:  Add a given multisetting to t_multisettings
        public void MultiSettingAddBase(string multisetting, string value)
        {
            //TODO: Rename this to AddMultisettingBase
            // Brandenburg isn't in R1, so manually edited this out during integrate.
            //if (Global.CurrentEnvironment.ConfigSource == ConfigType.ConfigSvc)
            //{
            //    Global.RO.Warn("MultiSettingAdd not yet implemented for ConfigType.ConfigSvc");
            //}
            //else if (Global.CurrentEnvironment.ConfigSource == ConfigType.NPDB)
            //{
            //    // NPDB 
                string[] servers = Config.GetServerListByInterface(Interface.npdb);
                string srv = servers[0]; // Grab the first server for that connection string
                IInterfaceInfo npdb = Config.GetInterface(srv, Interface.npdb);
                using (SqlConnection sql = new SqlConnection(npdb.SqlConnectionString))
                {
                    sql.Open();

                    SqlCommand cmd = new SqlCommand();
                    cmd.Connection = sql;
                    cmd.CommandType = CommandType.Text;

                    cmd.CommandText += "insert into dbo.t_multisettings (vc_multisetting, vc_value) values (@vc_multisetting, @vc_value)";

                    cmd.Parameters.Add("@vc_multisetting", SqlDbType.NVarChar).Value = multisetting;
                    cmd.Parameters.Add("@vc_value", SqlDbType.NVarChar).Value = value;

                    cmd.ExecuteNonQuery();
                }
            //}
            //else
            //{
            //    throw new Exception("Unable to access environment.");
            //}
        }

        /// MultiSettingDelete: 
        /// Delete a given multisetting from t_multisetting_overrides (for a given environment)      
        ///
        /// Parameters:
        ///    environment - vc_environment of Live Server environment
        ///    component - vc_component of Live Server component
        ///    site - i_site_id of Live Server site id
        ///    server - vc_server of Live Server server
        ///    multisetting - vc_multisetting to delete
        ///
        /// Returns n/a
        public void MultiSettingDelete(string environment, string component, string site, string server, string multisetting)
        {
            //TODO: Rename this to DeleteMultisettingOverride
            using (SqlConnection sql = new SqlConnection(Config.NpdbConnectionString))
            {
                sql.Open();

                SqlCommand cmd = new SqlCommand();
                cmd.Connection = sql;
                cmd.CommandType = CommandType.Text;

                cmd.CommandText = "print 'Deleting Multisetting Override with parameters: @multisetting = ' + @vc_multisetting + ' @environment = ' + @vc_environment + ' @component = ' + @vc_component + ' @siteId = ' + cast(@i_site_id as varchar) + ' @server = ' + @vc_server\n";
                cmd.CommandText += "delete dbo.t_multisetting_overrides " +
                                    "where vc_environment = @vc_environment " +
                                    "and vc_component = @vc_component " +
                                    "and i_site_id = @i_site_id " +
                                    "and vc_server = @vc_server " +
                                    "and vc_multisetting = @vc_multisetting\n";
                cmd.CommandText += "print cast(@@rowcount as varchar) + ' Rows deleted.'";

                cmd.Parameters.Add("@vc_environment", SqlDbType.NVarChar).Value = environment;
                cmd.Parameters.Add("@vc_component", SqlDbType.NVarChar).Value = component;
                cmd.Parameters.Add("@i_site_id", SqlDbType.Int).Value = site;
                cmd.Parameters.Add("@vc_server", SqlDbType.NVarChar).Value = server;
                cmd.Parameters.Add("@vc_multisetting", SqlDbType.NVarChar).Value = multisetting;

                cmd.ExecuteNonQuery();
            }
        }

        /// MultiSettingDelete: 
        /// Delete a specific multisetting from t_multisetting_overrides (for a given environment)      
        ///
        /// Parameters:
        ///    environment - vc_environment of Live Server environment
        ///    component - vc_component of Live Server component
        ///    site - i_site_id of Live Server site id
        ///    server - vc_server of Live Server server
        ///    multisetting - vc_multisetting to delete
        ///    value - vc_value to delete
        ///
        /// Returns n/a
        public void MultiSettingDeleteValue(string environment, string component, string site, string server, string multisetting, string value)
        {
            //TODO: Rename this to DeleteMultisettingOverride
            using (SqlConnection sql = new SqlConnection(Config.NpdbConnectionString))
            {
                sql.Open();

                SqlCommand cmd = new SqlCommand();
                cmd.Connection = sql;
                cmd.CommandType = CommandType.Text;

                cmd.CommandText = "print 'Deleting Multisetting Override with parameters: @multisetting = ' + @vc_multisetting + ' @environment = ' + @vc_environment + ' @component = ' + @vc_component + ' @siteId = ' + cast(@i_site_id as varchar) + ' @server = ' + @vc_server\n";
                cmd.CommandText += "delete dbo.t_multisetting_overrides " +
                                    "where vc_environment = @vc_environment " +
                                    "and vc_component = @vc_component " +
                                    "and i_site_id = @i_site_id " +
                                    "and vc_server = @vc_server " +
                                    "and vc_multisetting = @vc_multisetting\n" + 
                                    "and vc_value = @vc_value\n";
                cmd.CommandText += "print cast(@@rowcount as varchar) + ' Rows deleted.'";

                cmd.Parameters.Add("@vc_environment", SqlDbType.NVarChar).Value = environment;
                cmd.Parameters.Add("@vc_component", SqlDbType.NVarChar).Value = component;
                cmd.Parameters.Add("@i_site_id", SqlDbType.Int).Value = site;
                cmd.Parameters.Add("@vc_server", SqlDbType.NVarChar).Value = server;
                cmd.Parameters.Add("@vc_multisetting", SqlDbType.NVarChar).Value = multisetting;
                cmd.Parameters.Add("@vc_value", SqlDbType.NVarChar).Value = value;

                cmd.ExecuteNonQuery();
            }
        }

        public string[] MultiSettingRead(string multisetting)
        {
            string[] servers = Config.GetServerListByInterface(Interface.npdb);
            string srv = servers[0]; // Grab the first server for that connection string
            return Config.GetMultiSetting(multisetting, srv);
        }

        //process here is a name like "kdcsvc"
        public ConfigInfo GetSettingFromServerProcess(string process, string server, string _setting, bool forceReload)
        {
            string outparam = null;
            //e kdcsvc:XblConfig configcache settings
            string Command = "e "+process+":XblConfig configcache setting " + _setting.ToString();

            IInterfaceInfo tmp = Config.GetInterface(server, Interface.xmgmtsrv);
            IPEndPoint xmgmtsrv = new IPEndPoint(tmp.IPAddress, tmp.Port);

            if (forceReload)
            {
                //e kdcsvc:XblConfig configcacherefresh
                string reloadcmd = "e "+process+":XblConfig configcacherefresh ";
                ManagementConsole.Execute(xmgmtsrv, reloadcmd, out outparam);
            }

            ManagementConsole.Execute(xmgmtsrv, Command, out outparam);

            //out put   ="{testnet,1,XEPOOLIIS015,xstatsfd,stats_AllowAlternateDestination}{false,False,1/1/0001 12:00:00 AM,<null>}";
            return parseConfigCacheStr(outparam);
        }

        //"component" here is a name like "xmacs" or "aamodule" or "xrlscan"
        public ConfigInfo GetSettingFromServer(string component, string server, string _setting, bool forceReload)
        {
            //CheckConfigDataSourceAccessibility();

            string outparam = null;
            string Command = "e :" + component + " configcache setting " + _setting.ToString();
            IInterfaceInfo tmp = Config.GetInterface(server, Interface.xmgmtsrv);
            IPEndPoint xmgmtsrv = new IPEndPoint(tmp.IPAddress, tmp.Port);

            if (forceReload)
            {
                ForceConfigReload(component);
            }

            ManagementConsole.Execute(xmgmtsrv, Command, out outparam);

            //eg out put   ="{setting}{value,isStale,lastEventTime,newValue}\r\n{xarb_GarbageCollectionIntervalInSeconds}{10,False,1/1/0001 12:00:00 AM,<null>}\r\n";
            ConfigInfo info = parseConfigCacheStr(outparam);
            info.server = server;
            info.component = component;
            return info;
        }

        /// <summary>
        /// Uses xmgmt to force a config reload on all servers that expose the given interface.
        /// </summary>
        /// <param name="targetInterface">The interface that needs to reload its config.</param>
        public void ForceConfigReload (string targetInterface)
        {
            ExecuteXmgmtCommand(targetInterface, "e :" + targetInterface + " configcacherefresh");
        }

        public void CheckForUpdates()
        {
            Config.CheckForUpdates();
        }

        protected ConfigInfo parseConfigCacheStr(string data)
        {
            ConfigInfo tmp = new ConfigInfo();
            if (data.StartsWith("Error:"))
            {
                tmp.ErrorStr = data;
                return tmp;
            }


            string[] cinfos = data.Split(new char[] { ',', '{', '}' });

            if (cinfos.Length != 23)
            {
                throw new Exception("Config cache string has bad format: Expecting 23 fields, but received " + cinfos.Length + 
                                    ".  Data follows:" + data);
            }

            //tmp.environment = cinfos[12];
            //tmp.siteid = Int32.Parse(cinfos[13]);
            //tmp.server = cinfos[14];
            //tmp.component = cinfos[15];
            tmp.settingName = cinfos[16];
            tmp.settingvalue = cinfos[18];
            string IsStale = cinfos[19].Trim();
            if (IsStale.ToLower() == "true")
                tmp.isStale = true;
            else
                tmp.isStale = false;


            tmp.lastEventTime = DateTime.Parse(cinfos[20]);
            if ("<null>" == cinfos[21])
                tmp.settingnewValue = null;
            else
                tmp.settingnewValue = cinfos[21];

            return tmp;


        }

        public int GetStorageCacheRefreshTimer(int domainID)
        {
            SqlDataReader reader = null;

            using (SqlConnection sql = new SqlConnection(Config.NpdbConnectionString))
            {
                sql.Open();

                SqlCommand cmd = new SqlCommand();
                cmd.Connection = sql;
                cmd.CommandType = CommandType.Text;

                try
                {
                    cmd.CommandText = String.Format("select i_read_cache_seconds from t_storage_domains where i_domain_id={0} and vc_environment={1}", domainID, GetEnv());
                    reader = cmd.ExecuteReader();
                }
                catch (Exception) // If the environment doesn't exist
                {
                    cmd.CommandText = String.Format("select i_read_cache_seconds from t_storage_domains where i_domain_id={0} and vc_environment='ALL'", domainID);
                    reader = cmd.ExecuteReader();
                }

                reader.Read();
                int result = reader.GetInt32(reader.GetOrdinal("i_read_cache_seconds"));
                reader.Close();
                return result;
            }

        }

        public void SetStorageCacheRefreshTimer(int domainID, int refreshTimer)
        {
            SqlDataReader reader = null;
            using (SqlConnection sql = new SqlConnection(Config.NpdbConnectionString))
            {
                sql.Open();

                SqlCommand cmd = new SqlCommand();
                cmd.Connection = sql;
                cmd.CommandType = CommandType.Text;

                // First, we need to check to see if our environment has a setting on the table
                cmd.CommandText = String.Format("select i_read_cache_seconds from t_storage_domains where i_domain_id={0} and vc_environment='{1}'", domainID, GetEnv());

                reader = cmd.ExecuteReader();
                if (!reader.Read()) // Our environment is not in the table
                {
                    reader.Close();
                    cmd.CommandText = String.Format("select * from t_storage_domains where i_domain_id={0} and vc_environment='ALL'", domainID);
                    reader = cmd.ExecuteReader();
                    if (!reader.Read())
                    {
                        reader.Close();
                        throw new Exception("There is no storage domain with i_domain_id=" + domainID);
                    }

                    string values = "";

                    for (int i = 0; i < reader.FieldCount; i++)
                    {
                        if (!values.Equals("")) // Not the beginning
                            values += ",";

                        bool quote = false;
                        if (reader.GetName(i).StartsWith("vc_")) // Needs to be wrapped in quotes
                            quote = true;

                        if (quote) values += "'";

                        string value = reader.GetValue(i).ToString();

                        if (value.Equals("")) 
                        {
                            value = "0";
                        }
                        else if (value.Equals("ALL")) // This is the one parameter we want to change.
                        {
                             value=GetEnv();
                        }

                        values += value;
                        if (quote) values += "'";
                    }

                    reader.Close();
                    cmd.CommandText = "insert into t_storage_domains values (" + values + ")";
                    cmd.ExecuteNonQuery();

                } // Our environment is now on the table                                        


                reader.Close();
                cmd.CommandText = String.Format("update t_storage_domains set i_read_cache_seconds={0} where i_domain_id={1} and vc_environment='{2}'", refreshTimer, domainID, GetEnv());
                cmd.ExecuteNonQuery();
                
            }

        }
    }


    public class SettingState
    {
        public string oldvalue = null;
        public bool wasoverriden = false;

        public string Environment;
        public string Component;
        public string Server;
        public string Setting;
        public int Site;

        public SettingState () { }

        public SettingState (string environment, string component, string server, string setting, int site)
        {
            Environment = environment;
            Component = component;
            Server = server;
            Setting = setting;
            Site = site;
        }
    }

    public class IndividualMultisettingState
    {
        public string Component;
        public string Server;
        public int Site;
        public System.Guid Id;
        public string Value;
    }

    public class MultisettingState
    {
        public IndividualMultisettingState []OldValues;
        public string Environment;
        public string Setting;
    }

    public class ConfigTestBase : TestBase
    {
        public static string component;
        private string _component;
        public static string Interface = null;
        public string setting;
        public string settingval;
        public bool forceReload = true;
        public bool IsSettingDynamic = true;

        public ConfigTestBase()
        {
            _component = component;
        }

        public ConfigTestBase(string _setting, string settingvalue, bool IsDynamic)
            : base(_setting.ToString())
        {
            _component = component;
            setting = _setting;
            settingval = settingvalue;
            IsSettingDynamic = IsDynamic;
        }

        public ConfigTestBase(string _setting, string settingvalue)
            : base(_setting.ToString())
        {
            _component = component;
            setting = _setting;
            settingval = settingvalue;
        }

        public ConfigTestBase(string componentOverride, string _setting, string settingvalue)
            : base(_setting.ToString())
        {
            _component = componentOverride;
            setting = _setting;
            settingval = settingvalue;
        }

        public virtual void Initialize()
        {
        }

        override protected void Execute()
        {

            Initialize();
            SettingState overridenSet = null;
            string[] server = null; ;

            try
            {
                if(Interface ==null)
                    Interface=_component;
                server = Global.XEnv.GetServerListByInterface(Interface);
                if (server != null && server.Length >= 1)
                {
                    overridenSet = Global.XEnv.OverrideSetting(_component, server[0], setting, settingval);
                    ConfigInfo srvCfgInfo = Global.XEnv.GetSettingFromServer(_component, server[0], setting, forceReload);
                    Verify(srvCfgInfo, overridenSet.oldvalue);
                }
                else
                    throw new Exception("No servers listed under this component " + _component);
            }
            finally
            {
                //
                if (overridenSet !=null && overridenSet.wasoverriden)
                {
                    if (server != null && server.Length >= 1)
                        Global.XEnv.OverrideSetting(_component, server[0], setting, overridenSet.oldvalue);
                }
                else
                {
                    if (server != null && server.Length >= 1)
                        Global.XEnv.DeleteOverrideSetting(_component, server[0], setting);
                }
            }
            ResultCode = TEST_RESULTS.PASSED;
        }

        public virtual void Verify(ConfigInfo srvCfgInfo, string OldSettingVal)
        {

            if (srvCfgInfo.ErrorStr != null)
                throw new Exception(srvCfgInfo.ErrorStr);

            if (IsSettingDynamic)
            {
                if (srvCfgInfo.settingvalue != settingval || srvCfgInfo.settingnewValue != null || srvCfgInfo.isStale != false)
                    throw new Exception("Server failed to dynamicly pickup setting (" + srvCfgInfo.settingName + ")");


            }
            else
            {
                if (srvCfgInfo.settingvalue != OldSettingVal || srvCfgInfo.settingnewValue != settingval || srvCfgInfo.isStale != true)
                    throw new Exception("Server dynamicly picked setting (" + srvCfgInfo.settingName + ") that needed restart");

            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveConfig\ManagementConsole.cs ===
using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;

using xonline.common.config;

using ServerTestFramework;

namespace ServerTestFramework.LiveService
{
    /// <summary>
    /// Summary description for ManagementConsole.
    /// </summary>
    public class ManagementConsole
    {
        private const int MGMT_SEND_TIMEOUT = 5 * 1000;
        private const int MGMT_RECV_TIMEOUT = 30 * 1000;
        private const int MGMT_PORT = 4100;
        static Regex regexSize = new Regex(@"Size=(?<size>[^/n]*)");
        static Regex regexResult = new Regex(@"Result=(?<size>[^/n]*)");

        public static int sendTimeout = MGMT_SEND_TIMEOUT;
        public static int receiveTimeout = MGMT_RECV_TIMEOUT;

        public static Report MCReport = new Report("ManagementConsole");

        public ManagementConsole()
        {
        }

        static public string Execute(string target, string command)
        {
            string ret = String.Empty;
            Execute(target, command, out ret);
            return ret;
        }

        static public bool Execute(string target, string command, out string text)
        {
            uint hr = 0x8015190d;
            TcpClient client = new TcpClient();
            text = string.Empty;
            command = command + "\n";

            MCReport.Debug(String.Format("Executing command: {0}", command));

            //
            //  Set timeouts so we don't hang on management commands.
            //

            client.SendTimeout = sendTimeout;
            client.ReceiveTimeout = receiveTimeout;

            client.NoDelay = true;
            client.Connect(target, MGMT_PORT);

            NetworkStream stream = client.GetStream();
            TextReader reader = new StreamReader(stream);

            if (stream.CanWrite && stream.CanRead)
            {
                byte[] sendBytes = Encoding.ASCII.GetBytes(command);

                stream.Write(sendBytes, 0, sendBytes.Length);

                while (true)
                {
                    string t = reader.ReadLine();
                    if (t == null || t.Length == 0)
                        break;

                    //check the result match.
                    Match resultMatch = regexResult.Match(t);
                    if (resultMatch.Length > 0)
                    {
                        hr = Convert.ToUInt32(resultMatch.Groups[1].Value);
                        break;
                    }

                    Match sizeMatch = regexSize.Match(t);
                    if (sizeMatch.Length == 0)
                    {
                        // Size line not parsed, this must be an error
                        return false;
                    }

                    int dataLength = Convert.ToInt32(sizeMatch.Groups[1].Value);
                    char[] buffer = new char[dataLength];

                    reader.Read(buffer, 0, dataLength);
                    StringBuilder SB = new StringBuilder(dataLength);
                    SB.Append(buffer);
                    text = text + SB.ToString();
                }
            }

            client.Close();

            return HResult.S_OK == hr;
        }

        /// <summary>
        /// Returns a list of all process IDs in of the specified process name for a specific subProcess.
        /// </summary>
        /// <param name="target">The endpoint to query.</param>
        /// <param name="process">The process name, or null for no limitation.</param>
        /// <param name="subProcess">The component name.</param>
        public static int[] GetProcessIDs (IPEndPoint target, string process, string subProcess)
        {
            string lowerProcess = (process != null ? process.ToLower() : null);
            string lowerSubProcess = subProcess.ToLower();

            System.Collections.Generic.List<int> pidList = new List<int>();

            //First execute list to get a list of all processes
            string list;
            if (!Execute(target, "list", out list))
            {
                MCReport.Warn("xmgmt list command failed on " + target.Address + ": " + list);
                return new int[0];
            }

            //Find the lines that contains the pid of the entry we want.  It will look something like: w3wp.exe(2708) AAIFDReflector
            string[] listLines = list.Split(new char[] { '\n' });
            foreach (string line in listLines)
            {
                string lowerLine = line.ToLower();
                lowerLine = lowerLine.Replace("\r", ""); //we don't care about these

                if ((lowerProcess == null || lowerLine.StartsWith(lowerProcess)) && lowerLine.EndsWith(lowerSubProcess))
                {
                    //extract the pid from that line
                    int indFirstParen = lowerLine.IndexOf("(");
                    int indLastParen = lowerLine.IndexOf(")");

                    if (indFirstParen == -1 || indLastParen == -1)
                    {
                        MCReport.Warn("GetProcessIDs: Unexpected format trying to parse process ID out of line, will skip it: " + lowerLine);
                    }
                    else
                    {
                        string pidString = lowerLine.Substring(indFirstParen + 1, indLastParen - indFirstParen - 1);
                        int pid = int.Parse(pidString);
                        pidList.Add(pid);
                    }
                }
            }

            return pidList.ToArray();
        }

        /// <summary>
        /// Returns a list of all process IDs in w3wp for a specific subProcess.
        /// </summary>
        public static int[] GetIISProcessIDs (IPEndPoint target, string subProcess)
        {
            return GetProcessIDs(target, "w3wp", subProcess);
        }

        /// <summary>
        /// Executes a management command on every machine of a specific type, for a specific process.  This will
        ///   prepend the subCommand you provide with "e processid:", where processid is the process id of subProcess.
        /// For example, target might be the ip for xtou_int to get you the pool box that xtou lives on, subProcess
        ///   might be "xtou" to get you the w3wp process id for xtou, and subCommand might be "xrlscan reload".  The
        ///   final command that gets executed then would be something like: "e 12345:xrlscan reload".
        /// </summary>
        public static bool ExecuteOnProcess (IPEndPoint target, string process, string subProcess, string subCommand, out string text)
        {
            //get all proccess IDs for the subProcess... We expect only 1.
            int[] pids = GetProcessIDs(target, process, subProcess);

            if (pids.Length == 0)
            {
                text = "No process id for " + (process != null ? process + ":" : "") + subProcess + 
                    " seems to be running on " + target.Address + " right now.";
                return false;
            }
            else if (pids.Length > 1)
            {
                MCReport.Warn("ExecuteOnProcess: More than one entry found that matches process " + 
                    (process != null ? process + ":" : "") + subProcess + ".  Only the first entry will be used.");
            }

            //build the command and execute it
            string command = "e " + pids[0] + ":" + subCommand;
            return Execute(target, command, out text);
        }

        /// <summary>
        /// Executes a management command on every machine of a specific type, for a specific IIS process.  This will
        ///   prepend the subCommand you provide with "e processid:", where processid is the process id of subProcess.
        /// For example, target might be the ip for xtou_int to get you the pool box that xtou lives on, subProcess
        ///   might be "xtou" to get you the w3wp process id for xtou, and subCommand might be "xrlscan reload".  The
        ///   final command that gets executed then would be something like: "e 12345:xrlscan reload".
        /// </summary>
        public static bool ExecuteOnIISProcess (IPEndPoint target, string subProcess, string subCommand, out string text)
        {
            return ExecuteOnProcess(target, "w3wp", subProcess, subCommand, out text);
        }

        /// <summary>
        /// Executes a management command against all servers of a given interface for a specific process
        /// </summary>
        /// <param name="interfaceName">The interface upon which to execute the command</param>
        /// <param name="process">The process to search for to determine the PID</param>
        /// <param name="subProcess">The sub-process to search for to determine the PID</param>
        /// <param name="subCommand">The command to execute</param>
        /// <param name="text">A list of all of the output generated by the commands</param>
        /// <returns>The boolean AND of the result of all the executions</returns>
        public static bool ExecuteOnAllProcess (String interfaceName, string process, string subProcess, string subCommand, out string text)
        {
            bool result = true;
            String executeText = String.Empty;
            StringBuilder outText = new StringBuilder();

            // Get all servers associated with the given interface
            IPEndPoint[] endPoints = ManagementListener.GetXmgmtEndPoints(interfaceName);

            // For each interface, execute the provided command
            foreach (IPEndPoint endPoint in endPoints)
            {
                result &= ExecuteOnProcess(endPoint, process, subProcess, subCommand, out executeText);
                executeText = executeText.Trim();
                if (executeText.Length > 0)
                {
                    outText.AppendLine(executeText);
                }
            }

            text = outText.ToString();

            return result;
        }

        /// <summary>
        /// Executes a management command against all servers of a given interface for a specific IIS Process
        /// </summary>
        /// <param name="interfaceName">The interface upon which to execute the command</param>
        /// <param name="subProcess">The process to search for to determine the PID</param>
        /// <param name="subCommand">The command to execute</param>
        /// <param name="text">A list of all of the output generated by the commands</param>
        /// <returns>The boolean AND of the result of all the executions</returns>
        public static bool ExecuteOnAllIISProcess (String interfaceName, string subProcess, string subCommand, out string text)
        {
            return ExecuteOnAllProcess(interfaceName, "w3wp", subProcess, subCommand, out text);
        }

        /// <summary>
        /// Opens a connection to the specified management server.
        /// </summary>
        /// <param name="target">The ip address to execute against.</param>
        /// <returns>A TcpClient that is connected to the management server.</returns>
        public static TcpClient OpenManagementConnection (IPEndPoint target)
        {
            TcpClient client = new TcpClient();

            //
            //  Set five second send and receive timeouts so we don't hang on management commands.
            //

            client.SendTimeout = sendTimeout;
            client.ReceiveTimeout = receiveTimeout;

            client.NoDelay = true;

            try
            {
                target.Port = MGMT_PORT;
                client.Connect(target);
            }
            catch (SocketException ex)
            {
                // Wrap the socket exception with something that tells us which target we
                // were trying to connect to 
                throw new UnexpectedTestResultException("Could not connect to management target: " +
                    target.ToString(), ex);
            }

            return client;
        }

        /// <summary>
        /// Executes a management command against the given endpoint's ip address.  Does not actually use the port
        /// specified by the endpoint.
        /// </summary>
        /// <param name="target">The ip address to execute against.</param>
        /// <param name="command">The command to execute.</param>
        /// <param name="text">The response from executing the command.</param>
        /// <returns>True if the command executed successfully, false if it did not.</returns>
        static public bool Execute(IPEndPoint target, string command, out string text)
        {
            bool bReturn = false;
            TcpClient client = null;
            text = "";

            try
            {
                client = OpenManagementConnection(target);
                uint hr = Execute(client, command, out text);
                if (HResult.S_OK == hr)
                {
                    bReturn = true;
                }
                else
                {
                    MCReport.Error("Management command failed: {0}, HR: 0x{1:x} on {2}",
                                   command.Trim(), hr, target.ToString());
                }
            }
            catch (ManagementConsoleException)
            {
            }
            finally
            {
                if (client != null)
                { 
                    client.Close();
                }
            }

            return bReturn;
        }

        /// <summary>
        /// Executes a management command against the given connection, which must already be established.
        /// </summary>
        /// <param name="client">The connection to execute against.</param>
        /// <param name="command">The command to execute.</param>
        /// <param name="text">The response from executing the command.</param>
        /// <returns>The result of executing the command.</returns>
        public static uint Execute(TcpClient client, string command, out string text)
        {
            uint hr = 0x8015190d;
            StringBuilder SB = new StringBuilder();
            text = "";
            command = command + "\n";

            MCReport.Debug(String.Format("Executing command: {0}", command));

            NetworkStream stream = client.GetStream();

            try
            {
                TextReader reader = new StreamReader(stream);

                if (!stream.CanWrite || !stream.CanRead)
                {
                    throw new ManagementConsoleException("Cannot read and write to client stream.");
                }

                byte[] sendBytes = Encoding.ASCII.GetBytes(command);
                stream.Write(sendBytes, 0, sendBytes.Length);

                // 2 ways out, a result line or a line without a proper beginning
                while (true)
                {
                    string t = reader.ReadLine();
                    Match sizeMatch = regexSize.Match(t);
                    Match resultMatch = regexResult.Match(t);

                    if (resultMatch.Length > 0)
                    {
                        hr = Convert.ToUInt32(resultMatch.Groups[1].Value);
                        goto lbDone;
                    }

                    if (sizeMatch.Length == 0)
                    {
                        // Size line not parsed, this must be an error
                        goto lbDone;
                    }

                    int dataLength = Convert.ToInt32(sizeMatch.Groups[1].Value);
                    char[] buffer = new char[dataLength];
                    int totalRead = 0;

                    //read the data in
                    System.DateTime readStartTime = System.DateTime.UtcNow;
                    while (totalRead < dataLength)
                    {
                        int timeoutInMS = receiveTimeout - (int)(System.DateTime.UtcNow - readStartTime).TotalMilliseconds;
                        if (timeoutInMS <= 0)
                        {
                            throw new ManagementConsoleException("Timed out waiting for expected data from the stream.");
                        }
                        stream.ReadTimeout = timeoutInMS;

                        totalRead += reader.Read(buffer, totalRead, dataLength - totalRead);
                    }

                    SB.Append(buffer);
                }

            lbDone:
                text = SB.ToString();

                

                return hr;
            }
            finally
            {
                // This seems to actually close the TCP connection as well
                //stream.Close();
            }
        }

        /// <summary>
        /// Executes a management command against all servers of a given interface.
        /// </summary>
        /// <param name="interfaceName">The interface upon which to execute the command</param>
        /// <param name="command">The command to execute</param>
        /// <returns>The boolean AND of the result of all the executions</returns>
        public static bool ExecuteOnAll(String interfaceName, string command, out string text)
        {
            bool result = true;
            String executeText = String.Empty;
            StringBuilder outText = new StringBuilder();

            IPEndPoint[] endPoints = ManagementListener.GetXmgmtEndPoints(interfaceName);

            foreach (IPEndPoint endPoint in endPoints)
            {
                result &= Execute(endPoint, command, out executeText);
                executeText = executeText.Trim();
                if (executeText.Length > 0)
                {
                    outText.AppendLine(executeText);
                }
            }

            text = outText.ToString();

            return result;
        }

        /// <summary>
        /// A container for a response from an xmgmt command.
        /// </summary>
        public class XmgmtResponse
        {
            public string InterfaceName;
            public string Command;
            public IPEndPoint EndPoint;
            public bool Result;
            public string Response;
        }

        /// <summary>
        /// Executes a management command against all servers of a given interface.
        /// Yields results, thus requiring the entire list to be enumerated in order to be fully executed.
        /// </summary>
        /// <param name="interfaceName">The interface upon which to execute the command</param>
        /// <param name="command">The command to execute</param>
        /// <returns>An IEnumerable&lt;XmgmtResponse&gt; that contains the results of the execution.</returns>
        public static IEnumerable<XmgmtResponse> ExecuteOnAll (String interfaceName, string command)
        {
            IPEndPoint[] endPoints = ManagementListener.GetXmgmtEndPoints(interfaceName);

            foreach (IPEndPoint endPoint in endPoints)
            {
                XmgmtResponse ans = new XmgmtResponse();
                ans.InterfaceName = interfaceName;
                ans.Command = command;
                ans.EndPoint = endPoint;

                ans.Result = Execute(endPoint, command, out ans.Response);

                yield return ans;
            }
        }
    }

    /// <summary>
    /// Attaches to a remote management console and receives trace/logs from it.
    /// </summary>
    public static class ManagementListener
    {        
        #region Sockets

        /// <summary>A 'connection' to a management server.</summary>
        private class Connection
        {
            public IPEndPoint RemoteEP = null;
            public IPEndPoint LocalEP = null;
            public TcpClient TcpClient = null;
            public Socket Socket = null;
            public object TargetLock = new object();

            public byte[] Buffer = new byte[9216]; 
            public Dictionary<string, ListenerCallback> Callbacks = new Dictionary<string, ListenerCallback>();

            public int RefCount = 0;
        }

        /// <summary>The sockets used for all connections.</summary>
        private static Dictionary<IPEndPoint, Connection> _sockets = new Dictionary<IPEndPoint, Connection>();

        /// <summary>
        /// Gets the Connection for a given endpoint.
        /// </summary>
        /// <param name="endpoint">The remote endpoint of the connection.</param>
        /// <returns>The Connection object for the endpoint.</returns>
        private static Connection GetConnectionForEndpoint(IPEndPoint endpoint)
        {
            lock (_sockets)
            {
                // have we already got a connection to that server?
                if (_sockets.ContainsKey(endpoint))
                {
                    return _sockets[endpoint];
                }

                // create the connection
                Connection conn = new Connection();
                conn.RemoteEP = endpoint;


                // including a TCP connection to the server
                conn.TcpClient = new TcpClient();

                conn.TcpClient.NoDelay = true;
                conn.TcpClient.SendTimeout = ManagementConsole.sendTimeout;
                conn.TcpClient.ReceiveTimeout = ManagementConsole.receiveTimeout;

                conn.TcpClient.Connect(endpoint);

                // and the socket
                conn.Socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
                conn.Socket.ReceiveBufferSize = 8192 * 4;
                conn.Socket.Bind(new IPEndPoint(((IPEndPoint)conn.TcpClient.Client.LocalEndPoint).Address, 0));
                conn.LocalEP = (IPEndPoint)conn.Socket.LocalEndPoint;

                // remember to actually put it in the cache...
                _sockets.Add(endpoint, conn);

                return conn;
            }
        }

        /// <summary>
        /// Increments the ref count on the connection.
        /// </summary>
        /// <param name="conn">The connection to acquire.</param>
        private static void AcquireConnection(Connection conn)
        {
            // if this is the first one, we need to start listening
            if (Interlocked.CompareExchange(ref conn.RefCount, 1, 0) == 0)
            {
                conn.Socket.BeginReceive(conn.Buffer, 0, conn.Buffer.Length, SocketFlags.None,
                    BeginReceiveCallback, conn);
            }
            else
            {
                Interlocked.Increment(ref conn.RefCount);
            }
        }

        /// <summary>
        /// Receives datagrams from the socket, parses them, and passes them along to the listeners.
        /// </summary>
        /// <param name="result">The async result object.</param>
        private static void BeginReceiveCallback(IAsyncResult result)
        {
            Connection conn = (Connection)result.AsyncState;            
            try
            {
                // we are going to assume that 1 packet == 1 call through this function
                // we are probably wrong for some case, oh well find it through use
                int read = conn.Socket.EndReceive(result);

                if (read == 0)
                {
                    Global.RO.Warn("ManagementListener did not receive any data for {0}", conn.RemoteEP);
                }
                else
                {                        
                    Encoding enc = Encoding.UTF8;
                    //Global.RO.Info(enc.GetString(conn.Buffer, 0, read)); //Took this out because high throughput cases logging so much 
                                                                           //caused themselves to drop some of these packets.                    
                    Datagram packet = new Datagram();
                    int start = 0, semi = -1;

                    packet.RemoteEP = conn.RemoteEP;

                    // process
                    for (start = ++semi; semi < read; ++semi) { if (conn.Buffer[semi] == (byte)';') { break; } }
                    if (semi >= read) { Global.RO.Error("Failed to find process in datagram."); goto next; }
                    packet.Process = enc.GetString(conn.Buffer, start, semi - start);

                    // process id/domain
                    for (start = ++semi; semi < read; ++semi) { if (conn.Buffer[semi] == (byte)';') { break; } }
                    if (semi >= read) { Global.RO.Error("Failed to find process id/domain in datagram."); goto next; }

                    string potential_domain_value = enc.GetString(conn.Buffer, start, semi - start);
                    if (!int.TryParse(potential_domain_value, out packet.ProcessID))
                    {
                        // failed to parse the int, so this is a domain string
                        packet.Domain = potential_domain_value;
                        packet.IsManaged = true;
                    }

                    // component
                    for (start = ++semi; semi < read; ++semi) { if (conn.Buffer[semi] == (byte)';') { break; } }
                    if (semi >= read) { Global.RO.Error("Failed to find component in datagram."); goto next; }
                    packet.Component = enc.GetString(conn.Buffer, start, semi - start);

                    // thread id
                    for (start = ++semi; semi < read; ++semi) { if (conn.Buffer[semi] == (byte)';') { break; } }
                    if (semi >= read) { Global.RO.Error("Failed to find thread id in datagram."); goto next; }
                    packet.ThreadID = int.Parse(enc.GetString(conn.Buffer, start, semi - start));

                    // area
                    for (start = ++semi; semi < read; ++semi) { if (conn.Buffer[semi] == (byte)';') { break; } }
                    if (semi >= read) { Global.RO.Error("Failed to find area in datagram."); goto next; }
                    packet.Area = enc.GetString(conn.Buffer, start, semi - start);

                    // level
                    for (start = ++semi; semi < read; ++semi) { if (conn.Buffer[semi] == (byte)';') { break; } }
                    if (semi >= read) { Global.RO.Error("Failed to find level in datagram."); goto next; }
                    packet.Level = int.Parse(enc.GetString(conn.Buffer, start, semi - start));

                    // event id
                    for (start = ++semi; semi < read; ++semi) { if (conn.Buffer[semi] == (byte)';') { break; } }
                    if (semi >= read) { Global.RO.Error("Failed to find event id in datagram."); goto next; }
                    packet.EventID = int.Parse(enc.GetString(conn.Buffer, start, semi - start));

                    // Flow token
                    for (start = ++semi; semi < read; ++semi) { if (conn.Buffer[semi] == (byte)':') { break; } }
                    if (semi >= read) { Global.RO.Error("Failed to find flowtoken in datagram."); goto next; }
                    packet.Flowtoken = enc.GetString(conn.Buffer, start, semi - start);

                    // text
                    if (++semi >= read || conn.Buffer[semi] != (byte)':')
                    {
                        Global.RO.Error("Expecting two colons before log line.");
                        goto next;
                    }

                    if (++semi >= read)
                    {
                        packet.Text = "";
                    }
                    else
                    {
                        packet.Text = enc.GetString(conn.Buffer, semi, read - semi);
                    }

                    // get callback and call it
                    string listen_id = ConstructListenerID(packet.Component, packet.Area);
                    
                    
                    //We updated Xom remote in CL563046 - some tests might be looking for process name 
                    //instead of component name. Keeping this to avoid breaking cases. 
                    string oldListen_id = ConstructListenerID(packet.Process, packet.Area);                    
                                                                                                
                    ListenerCallback callback;

                    if (conn.Callbacks.TryGetValue(listen_id, out callback))
                    {
                        callback(packet);
                    }
                    else
                    {
                        if (conn.Callbacks.TryGetValue(oldListen_id, out callback))
                        {
                            Global.RO.Warn("Matched the datagram to a listener based on process name. This may indicate a mismatch between process name and component name.");
                            callback(packet);
                        }
                        else
                        {
                            Global.RO.Warn("Received datagram with no listener callback: {0}", packet);
                        }
                    }
                }
            }
            catch (ObjectDisposedException)
            {
                // this is standard if the socket got closed on us, no need to spam about it
                // for now we are going to assume that this occured because of DestroyConnection
                return;
            }
            catch (Exception e)
            {
                Global.RO.Error("ManagementListener encountered an error in BeginReceiveCallback:\r\n{0}\r\n{1}",
                    e.Message, e.StackTrace);
            }

        next:
            // we want to do this even if we have an error, but not as a finally, 
            // in case the socket has been shut down
            try
            {
                conn.Socket.BeginReceive(conn.Buffer, 0, conn.Buffer.Length, SocketFlags.None,
                    BeginReceiveCallback, conn);
            }
            catch (ObjectDisposedException)
            {
                // this is standard if the socket got closed on us, no need to spam about it
                // for now we are going to assume that this occured because of DestroyConnection
                return;
            }
            catch (Exception e)
            {
                Global.RO.Error("ManagementListener encountered an error in BeginReceiveCallback, " +
                    "Listeners on {2} have been abandoned:\r\n{0}\r\n{1}",
                    e.Message, e.StackTrace, conn.RemoteEP);
                DestroyConnection(conn);
            }
        }

        /// <summary>
        /// Decrements the ref count on the connection.
        /// </summary>
        /// <param name="conn">The connection to release.</param>
        /// <returns>True if the connection was destroyed, false if not.</returns>
        private static bool ReleaseConnection(Connection conn)
        {
            Interlocked.Decrement(ref conn.RefCount);

            // shut it down
            if (conn.RefCount <= 0)
            {
                DestroyConnection(conn);
                return true;
            }

            return false;
        }

        /// <summary>
        /// Destroys the given connection.
        /// </summary>
        /// <param name="conn">The connection to destroy.</param>
        private static void DestroyConnection(Connection conn)
        {
            try
            {
                lock (_sockets)
                {
                    if (_sockets.ContainsKey(conn.RemoteEP))
                    {
                        if (conn.TcpClient.Connected)
                        {
                            conn.TcpClient.GetStream().Close();
                            conn.TcpClient.Close();
                        }
                        
                        conn.Socket.Close();
                        _sockets.Remove(conn.RemoteEP);

                        foreach (KeyValuePair<string, ListenerCallback> kvp in conn.Callbacks)
                        {
                            if (kvp.Value != null)
                            {
                                kvp.Value(null);
                            }
                        }

                    }
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("ManagementListener encountered an error in DestroyConnection:\r\n{0}\r\n{1}",
                    e.Message, e.StackTrace);
            }
        }

        #endregion

        #region Management Help

        /// <summary>
        /// Constructs the target string given the two endpoints.
        /// </summary>
        /// <param name="remote">The management server endpoint.</param>
        /// <param name="local">The local listener endpoint.</param>
        /// <returns>A string that should be unique to the connection.</returns>
        private static string ConstructTargetString(IPEndPoint remote, IPEndPoint local)
        {
            return remote.ToString() + "to" + local.ToString();
        }

        /// <summary>
        /// Constructs an ID that should be unique to component and area.
        /// </summary>
        /// <param name="component">The component.</param>
        /// <param name="area">The area.</param>
        /// <returns>A string that should be unique to component and area.</returns>
        private static string ConstructListenerID(string component, string area)
        {
            return component.ToLower() + "|" + area.ToLower();
        }

        /// <summary>
        /// Checks for the target under the component on the server.
        /// </summary>
        /// <param name="client">The connection to the management server to check.</param>
        /// <param name="component">The component to check.</param>
        /// <param name="target">The target to check for.</param>
        /// <returns>True if the target is found, false if not.</returns>
        private static bool CheckForTarget(TcpClient client, string component, string target)
        {
            string command = String.Format("e :{0} lt", component);
            string response;

            uint result = ManagementConsole.Execute(client,
                command,
                out response);

            if (result != HResult.S_OK)
            {
                throw new ManagementListenerException("Could not execute '" + command + "' against " +
                    client.Client.RemoteEndPoint.ToString(), response);
            }

            return response.Contains(target);
        }

        /// <summary>
        /// Checks if the target is assigned to any areas under the component on the server.
        /// </summary>
        /// <param name="client">The connection to the management server to check.</param>
        /// <param name="component">The component to check.</param>
        /// <param name="target">The target to check for.</param>
        /// <returns>True if the target is assigned, false if not.</returns>
        private static bool CheckForTargetAreas(TcpClient client, string component, string target)
        {
            string command = String.Format("e :{0} la", component);
            string response;

            uint result = ManagementConsole.Execute(client,
                command,
                out response);

            if (result != HResult.S_OK)
            {
                throw new ManagementListenerException("Could not execute '" + command + "' against " +
                    client.Client.RemoteEndPoint.ToString(), response);
            }

            return response.Contains(target.ToLower());
        }

        /// <summary>
        /// Checks if the area is assigned to a component
        /// </summary>
        /// <param name="client">The connection to the management server to check.</param>
        /// <param name="component">The component to check.</param>
        /// <param name="area">The area to check for.</param>
        /// <returns>True if the area is assigned, false if not.</returns>
        private static bool CheckForArea(TcpClient client, string component, string area)
        {
            string command = String.Format("e :{0} la", component);
            string response;

            uint result = ManagementConsole.Execute(client,
                command,
                out response);

            if (result != HResult.S_OK)
            {
                throw new ManagementListenerException("Could not execute '" + command + "' against " +
                    client.Client.RemoteEndPoint.ToString(), response);
            }

            return response.Contains(area.ToLower());
        }

        /// <summary>
        /// Checks whether the component is managed or unmanaged.
        /// </summary>
        /// <param name="client">The connection to the management server to check.</param>
        /// <param name="component">The component to check.</param>
        /// <returns>True if the component is managed, false if not.</returns>
        private static bool IsComponentManaged(TcpClient client, string component)
        {
            string command = String.Format("e :{0} help", component);
            string response;

            uint result = ManagementConsole.Execute(client,
                command,
                out response);

            if (result != HResult.S_OK)
            {
                throw new ManagementListenerException("Could not execute '" + command + "' against " +
                    client.Client.RemoteEndPoint.ToString(), response);
            }

            return response.Contains("SetContextOnly");
        }

#if false
        /// <summary>
        /// Cleans up all targets for the given connection.
        /// </summary>
        /// <param name="conn">The connection to clean up.</param>
        private static void RemoveTargets (Connection conn)
        {
            string target = ConstructTargetString(conn.RemoteEP, conn.LocalEP);
            string response;

            foreach (string component in conn.Components)
            {
                bool result = ManagementConsole.Execute(conn.RemoteEP,
                    String.Format("e :{0} DeleteTarget {1}", component, target),
                    out response);

                if (!result || !response.StartsWith("Target deleted."))
                {
                    Global.RO.Warn("Unable to delete target '{0}' for component '{2}' on remote server '{1}'.  " +
                        "Response: {3}", target, conn.RemoteEP, component, response);
                }
            }

            conn.Components.Clear();
        }
#endif

        #endregion

        /// <summary>A packet of data received from the management server.</summary>
        public class Datagram
        {
            public IPEndPoint RemoteEP = null;

            // shared between managed/unmanaged
            public string Process = null;
            // assembly gets put here in managed
            public string Component = null;
            public int ThreadID = 0;
            public string Area = null;
            public int Level = 0;
            // message id from managed, may be the same thing...
            public int EventID = 0;
            public string Flowtoken = String.Empty;
            public string Text = null;

            // unique to unmanaged version
            public int ProcessID = 0;

            // unique to managed version
            public string Domain = null;

            public bool IsManaged = false;

            /// <summary>Can be used to store data useful to a consumer of the service.</summary>
            public object UserData = null;

            public override string ToString()
            {
                StringBuilder sb = new StringBuilder();

                return String.Format("From {0}::{1}({2}) {3}[{4}]::{5}-{6}({7}) {8}::{9}", Nullify(RemoteEP), Nullify(Process), 
                                                                                           Nullify(ProcessID), Nullify(Component),
                                                                                           Nullify(ThreadID), Nullify(Area),
                                                                                           Nullify(Level), Nullify(EventID),
                                                                                           Nullify(Flowtoken), Nullify(Text));                
            }

            private string Nullify(Object o) 
            {
                string s = o.ToString();
                return (!String.IsNullOrEmpty(s)) ? s : "<null>"; 
            }
        }

        /// <summary>
        /// Create a new Target
        /// </summary>
        /// <param name="endpoint">The remote management server.</param>
        /// <param name="target">The name of the target.</param>
        /// <param name="targetParameters">The parameters assoicated with the target.</param>
        /// <param name="component">The component to listen to.</param>
        /// <param name="area">The area to listen to.</param>
        /// <param name="callback">The location to send received datagrams.</param>
        public static void CreateTarget(IPEndPoint endpoint, string component, string target, string targetParameters, string area, ListenerCallback callback)
        {
            Connection conn = GetConnectionForEndpoint(endpoint);

            try
            {
                AcquireConnection(conn);

                string response;
                uint result = 0;

                lock (conn.TargetLock)
                {
                    if (!CheckForTarget(conn.TcpClient, component, target))
                    {
                        result = ManagementConsole.Execute(conn.TcpClient,
                            String.Format("e :{0} NewTarget {1} {2}",
                                component, target, targetParameters), out response);

                        // accept either managed or unmanaged response here
                        if (result != HResult.S_OK ||
                            !(response.StartsWith("Target " + target + " was created successfully.") || response.StartsWith("Added target " + target)))
                        {
                            throw new ManagementListenerException("Unable to create target on remote server " +
                                endpoint.ToString(), response);
                        }
                    }

                    result = ManagementConsole.Execute(conn.TcpClient,
                        String.Format("e :{0} AddTarget {1} {2}",
                            component, target, area),
                        out response);

                    // accept either managed or unmanaged response here
                    if (result != HResult.S_OK ||
                        !(response.StartsWith("Target " + target + " assigned to area " + area) ||
                        response.StartsWith("Target '" + target + "' assigned to area '" + area + "'")))
                    {
                        throw new ManagementListenerException("Unable to add target to area on remote server " +
                            endpoint.ToString(), response);
                    }

                    //Check for about 5 seconds that your target was added.
                    int tries = 0;
                    while (tries < 10 && !CheckForTarget(endpoint, component, target)) 
                    {
                        Thread.Sleep(500);
                        tries++; 
                    }
                    
                    //Check one last time after the retries.
                    if (!CheckForTarget(endpoint, component, target))
                    {
                        throw new ManagementListenerException("Unable to add target to area on remote server " +
                            endpoint.ToString(), response);
                    }                        
                }
            }
            catch
            {
                ReleaseConnection(conn);
                throw;
            }
        }

        /// <summary>
        /// Remove the target.  This does not delete the target, just removes it
        /// </summary>
        /// <param name="endpoint">The remote management server.</param>
        /// <param name="target">The targetname.</param>
        /// <param name="component">The component to stop.</param>
        /// <param name="area">The area to stop.</param>
        /// <param name="callback">The location passed in to Listen.</param>
        public static void RemoveTarget(IPEndPoint endpoint, string component, string target, string area, ListenerCallback callback)
        {
            Connection conn = GetConnectionForEndpoint(endpoint);

            try
            {
                string response;

                lock (conn.TargetLock)
                {
                    uint result = ManagementConsole.Execute(conn.TcpClient,
                        String.Format("e :{0} RemoveTarget {1} {2}",
                            component, target, area),
                        out response);

                    if (result != HResult.S_OK ||
                        !(response.StartsWith("Target removed.") ||
                        response.StartsWith("Target '" + target + "' removed from area '" + area + "'")))
                    {
                        throw new ManagementListenerException("Unable to remove target from area on remote server " +
                            endpoint.ToString(), response);
                    }
                }
            }
            catch
            {
                ReleaseConnection(conn);
            }
        }

        /// <summary>
        /// Stops listening on a remote management server.
        /// </summary>
        /// <param name="endpoint">The remote management server.</param>
        /// <param name="target">The name of the target.</param>
        /// <param name="component">The component to stop.</param>
        /// <param name="area">The area to stop.</param>
        /// <param name="callback">The location passed in to Listen.</param>
        public static void DeleteTargetIfNotUsed(IPEndPoint endpoint, string component, string target, string area, ListenerCallback callback)
        {
            Connection conn = GetConnectionForEndpoint(endpoint);

            try
            {
                string response;
                uint result = 0;
                lock (conn.TargetLock)
                {
                    // target is no longer assigned, lets get rid of it
                    if (!CheckForTargetAreas(conn.TcpClient, component, target))
                    {
                        result = ManagementConsole.Execute(conn.TcpClient,
                            String.Format("e :{0} DeleteTarget {1}",
                                component, target),
                            out response);

                        if (result != HResult.S_OK ||
                            !(response.StartsWith("Target deleted.") ||
                            response.StartsWith("Removed " + target + " from targets list")))
                        {
                            throw new ManagementListenerException("Unable to delete target from remote server " +
                                endpoint.ToString(), response);
                        }
                    }
                }
            }
            finally
            {
                ReleaseConnection(conn);
            }
        }

        /// <summary>
        /// Create a new Area
        /// </summary>
        /// <param name="endpoint">The remote management server.</param>
        /// <param name="area">The name of the target.</param>
        /// <param name="areaSettings">The parameters assoicated with the target.</param>
        /// <param name="component">The component to add to.</param>
        /// <param name="callback">The location to send received datagrams.</param>
        public static void CreateArea(IPEndPoint endpoint, string component, string area, string areaSettings, ListenerCallback callback)
        {
            Connection conn = GetConnectionForEndpoint(endpoint);

            try
            {
                AcquireConnection(conn);

                string response;
                uint result = 0;

                lock (conn.TargetLock)
                {
                    if (!CheckForArea(conn.TcpClient, component, area))
                    {
                        result = ManagementConsole.Execute(conn.TcpClient,
                            String.Format("e :{0} NewArea {1} {2}",
                                component, area, areaSettings), out response);

                        // accept either managed or unmanaged response here
                        if (result != HResult.S_OK ||
                            !(response.StartsWith("Area \"" + area + "\" created.")))
                        {
                            throw new ManagementListenerException("Unable to create area on remote server " +
                                endpoint.ToString(), response);
                        }
                    }
                }
            }
            catch
            {
                ReleaseConnection(conn);
                throw;
            }
        }

        /// <summary>
        /// Delete area.
        /// </summary>
        /// <param name="endpoint">The remote management server.</param>
        /// <param name="area">The area.</param>
        /// <param name="component">The component containing area.</param>
        /// <param name="callback">The location passed in to Listen.</param>
        public static void DeleteArea(IPEndPoint endpoint, string component, string area, ListenerCallback callback)
        {
            Connection conn = GetConnectionForEndpoint(endpoint);

            try
            {
                string response;

                lock (conn.TargetLock)
                {
                    uint result = ManagementConsole.Execute(conn.TcpClient,
                        String.Format("e :{0} DeleteArea {1}",
                            component, area),
                        out response);

                    if (result != HResult.S_OK ||
                        !(response.StartsWith("Area removed.") ||
                        response.StartsWith("Area \"" + area + "\" removed.")))
                    {
                        throw new ManagementListenerException("Unable to remove target from area on remote server " +
                            endpoint.ToString(), response);
                    }
                }
            }
            finally
            {
                ReleaseConnection(conn);
            }
        }

        /// <summary>
        /// A callback for the Listener, called every time a datagram is received.
        /// Done on .Net worker threads, please be quick in consuming them and realize that multiple callbacks
        /// can occur at once on different threads.  Receiving a null datagram means that no more will be received.
        /// </summary>
        /// <param name="datagram">The packet of data received.</param>
        public delegate void ListenerCallback(Datagram datagram);

        /// <summary>
        /// Initiate listening on a remote management server.
        /// </summary>
        /// <param name="endpoint">The remote management server.</param>
        /// <param name="component">The component to listen to.</param>
        /// <param name="area">The area to listen to.</param>
        /// <param name="callback">The location to send received datagrams.</param>
        public static void Listen(IPEndPoint endpoint, string component, string area, ListenerCallback callback)
        {
            Connection conn = GetConnectionForEndpoint(endpoint);

            try
            {
                AcquireConnection(conn);

                string target = ConstructTargetString(endpoint, conn.LocalEP);
                bool component_managed = IsComponentManaged(conn.TcpClient, component);
                string targetParameters = String.Format("type=Remote;Address={0}{1}{2}",
                                conn.LocalEP.Address, (component_managed ? ";Port=" : ":"), conn.LocalEP.Port);

                CreateTarget(endpoint, component, target, targetParameters, area, callback);

                // wire up callback
                string listen_id = ConstructListenerID(component, area);

                if (!conn.Callbacks.ContainsKey(listen_id))
                {
                    conn.Callbacks[listen_id] = callback;
                }
                else
                {
                    conn.Callbacks[listen_id] = (ListenerCallback)Delegate.Combine(conn.Callbacks[listen_id], callback);
                }
            }
            catch
            {
                ReleaseConnection(conn);
                throw;
            }
        }

        /// <summary>
        /// Stops listening on a remote management server.
        /// </summary>
        /// <param name="endpoint">The remote management server.</param>
        /// <param name="component">The component to stop.</param>
        /// <param name="area">The area to stop.</param>
        /// <param name="callback">The location passed in to Listen.</param>
        public static void Stop(IPEndPoint endpoint, string component, string area, ListenerCallback callback)
        {
            
            Connection conn = GetConnectionForEndpoint(endpoint);

            try
            {
                string target = ConstructTargetString(endpoint, conn.LocalEP);

                RemoveTarget(endpoint, component, target, area, callback);
                DeleteTargetIfNotUsed(endpoint, component, target, area, callback);

                // unwire callback
                string listen_id = ConstructListenerID(component, area);

                conn.Callbacks[listen_id] = (ListenerCallback)Delegate.Remove(conn.Callbacks[listen_id], callback);
            }
            finally
            {
                ReleaseConnection(conn);
            }
        }

        /// <summary>
        /// Retrieves a list of endpoints for xmgmt for all servers of a specific interface.
        /// </summary>
        public static IPEndPoint[] GetXmgmtEndPoints(string interfaceName)
        {
            string []servers=Global.XEnv.GetServerListByInterface(interfaceName);
            List<IPEndPoint> eps = new List<IPEndPoint>();
            foreach (string serv in servers)
            {
                eps.Add(Global.XEnv.GetInterface(Interface.xmgmtsrv, serv));
            }
            return eps.ToArray();
        }

        /// <summary>
        /// Checks for the target under the component on the server.
        /// </summary>
        /// <param name="endpoint">The remote management server.</param>
        /// <param name="component">The component to check.</param>
        /// <param name="target">The target to check for.</param>
        /// <returns>True if the target is found, false if not.</returns>
        public static bool CheckForTarget(IPEndPoint endpoint, string component, string target)
        {
            bool result = false;
            Connection conn = GetConnectionForEndpoint(endpoint);

            try
            {
                AcquireConnection(conn);

                lock (conn.TargetLock)
                {
                    result = CheckForTarget(conn.TcpClient, component, target);
                }
            }
            catch
            {
                result = false;
            }
            finally
            {
                ReleaseConnection(conn);
            }
            return result;
        }

        /// <summary>
        /// Checks if the target is assigned to any areas under the component on the server.
        /// </summary>
        /// <param name="endpoint">The remote management server.</param>
        /// <param name="component">The component to check.</param>
        /// <param name="target">The target to check for.</param>
        /// <returns>True if the target is assigned, false if not.</returns>
        public static bool CheckForTargetAreas(IPEndPoint endpoint, string component, string target)
        {
            bool result = false;
            Connection conn = GetConnectionForEndpoint(endpoint);

            try
            {
                AcquireConnection(conn);

                lock (conn.TargetLock)
                {
                    result = CheckForTargetAreas(conn.TcpClient, component, target);
                }
            }
            catch
            {
                result = false;
            }
            finally
            {
                ReleaseConnection(conn);
            }
            return result;
        }

        /// <summary>
        /// Checks for area
        /// </summary>
        /// <param name="endpoint">The remote management server.</param>
        /// <param name="component">The component to check.</param>
        /// <param name="area">The area to check for.</param>
        /// <returns>True if the area is assigned, false if not.</returns>
        public static bool CheckForArea(IPEndPoint endpoint, string component, string area)
        {
            bool result = false;
            Connection conn = GetConnectionForEndpoint(endpoint);

            try
            {
                AcquireConnection(conn);

                lock (conn.TargetLock)
                {
                    result = CheckForArea(conn.TcpClient, component, area);
                }
            }
            catch
            {
                result = false;
            }
            finally
            {
                ReleaseConnection(conn);
            }
            return result;
        }

    }

    /// <summary>
    /// An exception in the ManagementConsole class.
    /// </summary>
    public class ManagementConsoleException : Exception
    {
        public ManagementConsoleException(string message) : base(message) { }
    }

    /// <summary>
    /// An exception in the ManagementListener class.
    /// </summary>
    public class ManagementListenerException : Exception
    {
        /// <summary>The xmgmt response associated with this exception, if any.</summary>
        public string XmgmtResponse = null;

        public ManagementListenerException(string message) : base(message) { }
        public ManagementListenerException(string message, string xmgmtResponse) : base(message) { XmgmtResponse = xmgmtResponse; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveConfig\XmgmtC.cs ===
using System;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Text.RegularExpressions;

namespace ServerTestFramework.LiveService
{
	public class XmgmtC
	{
		public static string SendReceiveSingle(string send, IPAddress ip)
		{
			TcpClient tcpClient = new TcpClient();
			tcpClient.ReceiveTimeout = 4000;
			tcpClient.SendTimeout = 2000;
			tcpClient.Connect(new IPEndPoint(ip, 4100));

			using (NetworkStream stream = tcpClient.GetStream())
			{
				byte[] data;
				data = Encoding.ASCII.GetBytes(send + "\n");
				stream.Write(data, 0, data.Length);

				try
				{
					data = new byte[tcpClient.ReceiveBufferSize];
					stream.Read(data, 0, data.Length);
				}
				catch (System.IO.IOException e)
				{
					throw new ApplicationException("Xmgmt error: can not retrieve response from server.", e);
				}

				string response = GetResponse(data);

				stream.Read(data, 0, data.Length);

				uint result = GetResult(data);
				if (result != 0)
					throw new ApplicationException("Xmgmt error: " + result.ToString() + ".");

				data = Encoding.ASCII.GetBytes("q\n");
				stream.Write(data, 0, data.Length);
				
				return response;
			}
		}

		static string GetResponse(byte[] data)
		{
			//Size=38
			//Reload successful for XKDC provider.
			string s = Encoding.ASCII.GetString(data);

			Match match = new Regex(@"^Size=(\d+)\r\n([^\0]+)").Match(s);
			if (!match.Success)
				throw new Exception("Xmgmt error: Not a validly formatted response.");

			return match.Groups[2].Value;
		}

		static uint GetResult(byte[] data)
		{
			//Result=0
			string s = Encoding.ASCII.GetString(data);

			Match match = new Regex(@"Result=(\d+)\r\n").Match(s);
			if (!match.Success)
				throw new Exception("Xmgmt error: Not a validly formatted response.");

			return Convert.ToUInt32(match.Groups[1].Value);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveConfig\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveConfig\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveConfig\Database\DatabaseException.cs ===
using System;
using System.Data;
using System.Data.SqlTypes;
using System.Data.SqlClient;
using System.Data.Common;
using System.Text;

namespace ServerTestFramework.Database
{
	/// <summary>
	/// Helper exception for database related errors
	/// </summary>
	public class DatabaseException : Exception
	{
		string _dbmsg;

		public override string Message
		{
			get
			{
				if(_dbmsg != null)
					return _dbmsg;
				else
					return base.Message;
			}
		}

		/// <summary>
		/// Construct a new database exception describing all of the errors
		/// </summary>
		/// <param name="conn">Database connection that threw the error</param>
		/// <param name="ex">Sql exception object to be described</param>
		public DatabaseException(SqlConnection conn, SqlException sqlex) : base()
		{
			StringBuilder msg = new StringBuilder(256);
			msg.Append("DatabaseException: ");
			msg.Append(sqlex.ToString());
			msg.Append(": ");
			msg.Append(conn.ConnectionString);
			msg.Append(": ");
			for (int i=0; i < sqlex.Errors.Count; i++)
			{
				msg.Append("Error: ");
				msg.Append(sqlex.Errors[i].ToString());
				msg.Append("\n");
			}
			_dbmsg = msg.ToString();
		}

		/// <summary>
		/// Construct a new database exception for the given connection.
		/// </summary>
		/// <param name="conn">Database connection that threw the error</param>
		/// <param name="message">Specific message to attach to the exception</param>
		public DatabaseException(SqlConnection conn, string message) : base()
		{
			StringBuilder msg = new StringBuilder(256);
			msg.Append("DatabaseException: ");
			msg.Append(conn.ConnectionString);
			msg.Append(": ");
			msg.Append(message);
			_dbmsg = msg.ToString();
		}
		
		/// <summary>
		/// Construct a new database exception.
		/// </summary>
		/// <param name="message">Specific message to attach to the exception</param>
		public DatabaseException(string message) : base(message)
		{
			_dbmsg = null;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveConfig\Database\BulkUserSet.cs ===
using System;
using System.Text;

namespace ServerTestFramework.Database
{
    ///
    /// Class to represent a set of bulk users. These users a represented as a base
    /// ID and are gauranteed to have a few useful properties:
    /// 
    /// 1: PUIDs in the range Base + [0,n) offset where Base is the base offset of the set
    ///     and n is the count of users in the set.
    /// 2: Web Puids in the range 0x0001ffffffffffff + BaseLow + [0,n] where BaseLow is the lo 32 bit
    ///     value of the PUID. This is done to gaurantee unique web IDs that are distiguishable from
    ///     normal user PUIDs.
    /// 3: Gamertags where the first 2 bytes are the passed in prefix, and the last 13 bytes are a base
    ///     32 encoding of the PUID. This is done to allow username/puid calculation from the PUID/gamertag 
    ///     without database reads. Use the built-in methods this class for help in doing this.
    ///
    public class BulkUserSetBase
    {
        // Base32 encoding/decoding tables.
        static protected byte []_EncTab;
        static protected byte []_DecTab;
        static BulkUserSetBase()
        {
            _GenerateTables();
        }

        public ulong OfferId;
        public System.Guid OfferInstanceIdGuid;
        public System.Guid OfferIdGuid;

        // Prefix append to all gamertags in set. 
        protected string _Prefix;

        // Base PUID of set.
        public ulong Base;

        // Number of PUIDs in set.
        public uint Count;

        // Country that these users were created in
        public byte Country;


        public string Prefix
        {
            get 
            {
                return _Prefix;
            }
            set 
            {
                _Prefix = value;
                if(_Prefix.Length > 2)
                {
                    _Prefix.Remove(2,_Prefix.Length-2);
                }
            }
        }

        public uint BaseHigh
        {
            get 
            {
                return (uint)((Base >> 32) & 0xffffffff);
            }
        }
        public uint BaseLow
        {
            get 
            {
                return (uint)(Base & 0xffffffff);
            }
        }

        public BulkUserSetBase(BulkUserSetBase b)
        {
            OfferId = b.OfferId;
            OfferInstanceIdGuid = b.OfferInstanceIdGuid;
            OfferIdGuid = b.OfferIdGuid;
            Prefix = b.Prefix;
            Base = b.Base;
            Count = b.Count;
            Country = b.Country;
        }

        public BulkUserSetBase(string prefix)
        {
            Base = 0;
            Count = 0;
            Country = 0;
            Prefix = prefix;
        }

        public BulkUserSetBase(string prefix, ulong basepuid, uint usercount)
        {
            Base = basepuid;
            Count = usercount;
            Country = 103;  // default to US
            Prefix = prefix;
        }

        // Accessors used with indexes
        public ulong IndexToPuid(uint index)
        {
            _CheckIndex(index);
            return Base + index;
        }

        public string IndexToGamertag(uint index)
        {
            _CheckIndex(index);
            ulong puid = Base + index;
            byte[] data = _ConvertPuidToBytes(puid);
            byte[] encdata = _Base32Encode(data);

            // Convert the data using ASCII encoding	
            string gamertag = Prefix + new ASCIIEncoding().GetString(encdata);
            return gamertag;
        }

        // Accessors used with puids
        public uint PuidToIndex(ulong puid)
        {
            _CheckPuid(puid);
            uint offset = (uint)(puid - Base);

            return offset;
        }

        public string PuidToGamertag(ulong puid)
        {
            byte []data = _ConvertPuidToBytes(puid);
            byte []encdata = _Base32Encode(data);

            // Convert the data using ASCII encoding
            ASCIIEncoding enc = new ASCIIEncoding();
            string str = enc.GetString(encdata);

            return Prefix + str;
        }

        // Accessors used with gamertags
        public uint GamertagToIndex(string gamertag)
        {
            ulong puid = GamertagToPuid(gamertag);
            return PuidToIndex(puid);
        }

        public ulong GamertagToPuid(string gamertag)
        {
            char[] charData = gamertag.ToCharArray(2, gamertag.Length - 2);
            byte[] encData = new byte[charData.Length];

            for(int i = 0; i < charData.Length; ++i)
            {
                encData[i] = (byte)(charData[i] & 0xff);
            }

            byte[] decData = _Base32Decode(encData);
            ulong puid = _ConvertBytesToPuid(decData);

            return puid;
        }

        protected void _CheckIndex(uint index)
        {
            if(index >= Count)
            {
                throw new ArgumentException("Index out of range");
            }
        }

        protected void _CheckPuid(ulong puid)
        {	
            if(puid < Base)
            {
                throw new ArgumentException("PUID: " + puid.ToString("x") + " is less than base: " + Base.ToString("x"));
            }
            if(puid - Base > UInt32.MaxValue)
            {
                throw new ArgumentException("PUID: " + puid.ToString("x") + " is more than base + Uint32.MaxValue: " + Base.ToString("x"));
            }
        }

        protected static byte[] _ConvertPuidToBytes(ulong puid)
        {
            // Write the puid's webID bytes
            byte[] data = new byte[8];
            for(int i = 0; i < 8; ++i)
            {
                data[i] = (byte)((puid >> (i<<3)) & 0xff);
            }

            return data;
        }

        protected static ulong _ConvertBytesToPuid(byte[] data)
        {
            ulong accum = 0;
            for(int i = 0; i < 8; ++i)
            {
                accum |= ((ulong)data[i] << (i<<3));
            }

            return accum;
        }

        protected static void _GenerateTables()
        {
            _DecTab = new byte[256];
            _EncTab = new byte[32];
            int count = 0;
            for(byte i = (byte)'a'; i <= 'z'; i++)
            {
                _DecTab[i] = (byte)count;
                _EncTab[count++] = i;
            }
            for(byte i = (byte)'0'; i < '6'; ++i)
            {
                _DecTab[i] = (byte)count;
                _EncTab[count++] = i;
            }
        }

        protected static byte[] _Base32Encode(byte[] data)
        {
            // Encode 5 bits of the input at once
            //byte mask = 0x1f; 
            //byte offset = 0;
            int tabIndex = 0;
            int i = 0;
            int j = 0;
            int bits = 0;
            int dstlen = (data.Length * 8)/5;
            ulong cursor = 0;

            if(((data.Length*8) % 5) != 0)
            {
                dstlen++;
            }

            byte []dstdata = new byte[dstlen];

            while(i < data.Length)
            {
                // read up to 64 bits into the cursor
                while(bits < 57 && i < data.Length)
                {
                    cursor <<= 8;
                    cursor |= data[i++];
                    bits += 8;
                }

                // write 5 bit chunks from the cursor
                while(bits > 4)
                {
                    tabIndex = (int)((cursor >> (bits-5)) & 0x1f);
                    dstdata[j++] = _EncTab[tabIndex];
                    bits -= 5;
                }
            }

            // write any remainder
            if(bits > 0)
            {
                tabIndex = (int)((cursor & (ulong)~(0x1f << bits)) & 0x1f);
                dstdata[j++] = _EncTab[tabIndex];
            }

            return dstdata;
        }

        protected static byte[] _Base32Decode(byte[] data)
        {
            int bits = 0;
            int i = 0;
            int j = 0;
            ulong cursor = 0;
            int dstlen = (data.Length*5)/8;

            if(((data.Length*5) % 8) != 0)
            {
                dstlen++;
            }

            byte []dstdata = new byte[dstlen];

            while(i < data.Length)
            {
                // read up to 40 bits into the cursor
                while(bits < 36 && i < data.Length)
                {
                    cursor <<= 5;
                    cursor |= _DecTab[data[i++]];
                    bits += 5;
                }

                // write 8 bit chunks from the cursor
                while(bits > 8)
                {
                    byte c = (byte)((cursor >> (bits-8)) & 0xff);
                    dstdata[j++] = c;
                    bits -= 8;
                }
            }

            // write any remainder
            if(bits > 0)
            {
                byte c = (byte)((cursor & (ulong)~(0xff << bits)) & 0xff);
                dstdata[j++] = c;
            }

            return dstdata;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveConfig\Database\Npdb.cs ===
/* Npdb wrapper class */

using System;
using System.Data;
using System.Data.SqlTypes;
using System.Data.SqlClient;
using System.Data.Common;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Runtime.InteropServices;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;

using xonline.common.config;

namespace ServerTestFramework.Database
{
    /// <summary>
    /// Collection of strings, each representing the name of a server.  This enforces a type on the collection.
    /// </summary>
    public class ServerNames : CollectionBase
    {
        public ServerNames() {}

        public string this[int index]
        {
            get { return List[index] as string; }
            set { List[index] = value; }
        }

        public int Add(string val)
        {
            return List.Add(val);
        }

        public bool Contains(string val)
        {
            return List.Contains(val);
        }

        public void Remove(string val)
        {
            List.Remove(val);
        }
    }

    public class InterfaceBucket
    {
        public string Environment;
        public string Interface;
        public UInt32 TitleId;
        public Int32 Bucket;
        public string Server;
        public string NextServer;
        public DateTime MigrationStart;
        public string Info1;
        public string Info2;
        public string Info3;
        public string Info4;

        public override bool Equals(object obj)
        {
            if (obj is InterfaceBucket)
            {
                return
                    (
                    (obj as InterfaceBucket).TitleId == TitleId &&
                    (obj as InterfaceBucket).Bucket == Bucket &&
                    (obj as InterfaceBucket).Environment == Environment &&
                    (obj as InterfaceBucket).Interface == Interface &&
                    (obj as InterfaceBucket).Server == Server &&
                    (obj as InterfaceBucket).NextServer == NextServer &&
                    (obj as InterfaceBucket).Info1 == Info1 &&
                    (obj as InterfaceBucket).Info2 == Info2 &&
                    (obj as InterfaceBucket).Info3 == Info3 &&
                    (obj as InterfaceBucket).Info4 == Info4
                    );
            }

            return false;
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public override string ToString()
        {
            return String.Format("Environment[{0}] Interface[{1}] TitleId[0x{2:x}] Bucket[{3}] Server[{4}] NextServer[{5}] " +
                "MigrationStart[{6}] Info1[{7}] Info2[{8}] Info3[{9}] Info4[{10}]",
                Environment, Interface, TitleId, Bucket, Server, NextServer, MigrationStart, Info1, Info2, Info3, Info4);
        }
    }

    public class InterfaceBucketCollection : CollectionBase
    {
        public InterfaceBucket this[int index]
        {
            get { return List[index] as InterfaceBucket; }
            set { List[index] = value; }
        }

        public int Add(InterfaceBucket val)
        {
            return List.Add(val);
        }

        public bool Contains(InterfaceBucket val)
        {
            return List.Contains(val);
        }

        public void Remove(InterfaceBucket val)
        {
            List.Remove(val);
        }
    }

    /// <summary>
    /// This is a wrapper class for talking to the NPDB.
    /// </summary>
    [ComVisible(false)]
    public class Npdb : IDisposable
    {
        protected SqlConnection _conn;
        protected string _serverName;
        protected string _databaseName;

        public Npdb()
        {
        }

        public void ConnectToServer(string serverName)
        {
            IInterfaceInfo interfaceInfo = Config.GetInterface(serverName, Interface.npdb);
            ConnectToServer(serverName, interfaceInfo.DBName);
        }

        public void ConnectToServer(string serverName, string databaseName)
        {
            try
            {
                _serverName = serverName;
                _databaseName = databaseName;
                _conn = new SqlConnection("server="+_serverName+";database="+_databaseName+";Integrated Security=SSPI"); 
                _conn.Open();
            }
            catch(SqlException sqlex)
            {
                throw new DatabaseException(_conn, sqlex);
            }
        }

        public void ConnectToServer()
        {
            try
            {
                _serverName = Config.NpdbServer;
                _databaseName = Config.NpdbDatabase;
                _conn = new SqlConnection(Config.NpdbConnectionString);
                _conn.Open();
            }
            catch(SqlException sqlex)
            {
                throw new DatabaseException(_conn, sqlex);
            }
        }

        public SqlCommand CreateCommand()
        {
            return _conn.CreateCommand();
        }

        public void Close()
        {
            // locking on a possibly null object is a bad idea, but instead of trying to fix the entire class
            // I am just protecting us a little more
            if (_conn != null)
            {
                lock (_conn)
                {
                    // m_SqlConnection could be null
                    if (_conn != null && _conn.State != ConnectionState.Closed)
                    {
                        try
                        {
                            _conn.Close();
                        }
                        catch
                        {
                            // do nothing
                        }
                        _conn = null;
                    }
                }
            }
        }

        public ulong AllocatePuids(uint bucket, uint blocksize, BulkUserSetBase userSet)
        {
            return AllocatePuids(bucket, blocksize, userSet, 0);
        }

        public ulong AllocatePuids(uint bucket, uint blocksize, BulkUserSetBase userSet, ulong basePuid)
        {
            lock(_conn)
            {
                // call p_puid_get_next_id
                SqlCommand cmd = new SqlCommand("p_puid_get_next_id", _conn);
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.Add("RETURN_CODE", SqlDbType.SmallInt).Direction = ParameterDirection.ReturnValue;
                cmd.Parameters.Add("@bi_next_id", SqlDbType.BigInt).Direction = ParameterDirection.Output;
                cmd.Parameters.Add("@i_bucket_id", SqlDbType.Int).Value = bucket;
                cmd.Parameters.Add("@i_req_block_size", SqlDbType.Int).Value = blocksize;
                if (basePuid!=0)
                {
                    cmd.Parameters.Add("@bi_base", SqlDbType.BigInt).Value = (long)basePuid;
                }

                SqlDataReader reader = cmd.ExecuteReader();
                reader.Read();
                reader.Close();

                // Not a HRESULT
                int retcode = (int)cmd.Parameters["RETURN_CODE"].Value;
                if(0 != retcode)
                {
                    string msg = "";
                    switch(retcode)
                    {
                        case -1000:
                            msg = "DBCriticalError";
                            break;
                        case -1018:
                            msg = "ErrorBadArgument";
                            break;
                        case -1019:
                            msg = "IDGenTranCountExist";
                            break;
                        case -1020:
                            msg = "IDGenDepleted";
                            break;

                    }
                    throw new Exception("AllocatePuids() sql command failed with retcode: " + retcode + ": " + msg);
                }

                Int64 nextPuid = (Int64)cmd.Parameters["@bi_next_id"].Value;

                if (userSet!=null)
                {
                    Global.RO.Debug("AllocatePuids(): next puid: " + nextPuid.ToString() + ", blocksize: " + blocksize);
                    userSet.Base = (ulong)nextPuid;
                    userSet.Count = blocksize;
                }

                return (ulong)nextPuid;
            }
        }

        /// <summary>
        /// Retrieves all servers that exist for a specified environment and interface.
        /// </summary>
        /// <param name="environment">Environment to query for.</param>
        /// <param name="interface">Interface to query for.</param>
        /// <returns>A Collection of strings, each containing the name of a server exposing the interface.</returns>
        public ServerNames GetServerListByInterface(string environment, string iface)
        {
            ServerNames servers = new ServerNames();
            lock(_conn)
            {
                SqlCommand command = null;

                command = _conn.CreateCommand();
                SqlCommand cmd = new SqlCommand("p_config_get_server_list_by_interface", _conn);
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.Parameters.Add("RETURN_CODE", SqlDbType.SmallInt).Direction = ParameterDirection.ReturnValue;
                cmd.Parameters.Add("@vc_environment", SqlDbType.NVarChar).Value = environment;
                cmd.Parameters.Add("@vc_interface", SqlDbType.NVarChar).Value = iface;

                SqlDataReader reader = cmd.ExecuteReader();
                try {
                    while (reader.Read())
                    {
                        servers.Add(reader.GetString(reader.GetOrdinal("vc_server")));
                    }
                    
                }                
                finally
                {
                    if (reader != null)
                    {
                        reader.Close();
                    }
                }
            }

            return servers;
        }

        /// <summary>
        /// Retrieves all interface buckets for a specified Title ID
        /// </summary>
        /// <param name="titleId">Title Id</param>
        /// <returns>A collection of InterfaceBucket objects.</returns>
        public InterfaceBucketCollection GetInterfaceBuckets(uint titleId)
        {
            InterfaceBucketCollection buckets = null;

            lock(_conn)
            {
                SqlCommand command = null;

                command = _conn.CreateCommand();
                command.CommandType = CommandType.Text;
                command.CommandText = "SELECT * FROM t_interface_buckets WHERE i_title_id=0x" + titleId.ToString("x8");

                buckets = GetInterfaceBuckets(command);
            }

            return buckets == null ? new InterfaceBucketCollection() : buckets;
        }

        /// <summary>
        /// Retrieves interface buckets for a specific Title id in a specific environment.
        /// </summary>
        /// <param name="titleId">Title Id</param>
        /// <param name="environment">Environment name (eg: "testnet")</param>
        /// <returns>A collection of InterfaceBucket objects</returns>
        public InterfaceBucketCollection GetInterfaceBuckets(uint titleId, string environment)
        {
            InterfaceBucketCollection buckets = null;

            lock(_conn)
            {
                SqlCommand command = null;

                command = _conn.CreateCommand();
                command.CommandType = CommandType.Text;
                command.CommandText = "SELECT * FROM t_interface_buckets WHERE i_title_id=0x" + titleId.ToString("x8") +
                    " AND vc_environment = '" + environment + "'";

                buckets = GetInterfaceBuckets(command);
            }

            return buckets == null ? new InterfaceBucketCollection() : buckets;
        }

        /// <summary>
        /// Retrieves all interface buckets for a specified environment
        /// </summary>
        /// <param name="environment">Environment name (eg: "testnet")</param>
        /// <returns>A collection of InterfaceBucket objects</returns>
        public InterfaceBucketCollection GetInterfaceBuckets(string environment)
        {
            InterfaceBucketCollection buckets = null;

            lock(_conn)
            {
                SqlCommand command = null;

                command = _conn.CreateCommand();
                command.CommandType = CommandType.Text;
                command.CommandText = "SELECT * FROM t_interface_buckets WHERE vc_environment = '" + environment + "'";

                buckets = GetInterfaceBuckets(command);
            }

            return buckets == null ? new InterfaceBucketCollection() : buckets;
        }

        /// <summary>
        /// Retrieves interface buckets based on the environment name and interface
        /// </summary>
        /// <param name="environment">Environment name (eg: "testnet")</param>
        /// <param name="interfaceName">Interface name (eg: "libsvr")</param>
        /// <returns>A collection of InterfaceBucket objects</returns>
        public InterfaceBucketCollection GetInterfaceBuckets(string environment, string interfaceName)
        {
            InterfaceBucketCollection buckets = null;

            lock(_conn)
            {
                SqlCommand command = null;

                command = _conn.CreateCommand();
                command.CommandType = CommandType.Text;
                command.CommandText = "SELECT * FROM t_interface_buckets WHERE vc_environment='" + environment +
                    "' AND vc_interface='" + interfaceName + "'";

                buckets = GetInterfaceBuckets(command);
            }

            return buckets == null ? new InterfaceBucketCollection() : buckets;
        }

        /// <summary>
        /// Private method that does the actual work to retrieve the interface buckets based on the given command.
        /// </summary>
        /// <param name="command">An SqlCommand object that defines a query for interface retrieval</param>
        /// <returns>
        /// If successful, a collection of InterfaceBucket objects. NULL if an error occurs or if the given
        /// command produced no results.
        /// </returns>
        private InterfaceBucketCollection GetInterfaceBuckets(SqlCommand command)
        {
            InterfaceBucketCollection buckets = new InterfaceBucketCollection();
            SqlDataReader reader = null;

            if (command == null)
            {
                return null;
            }

            reader = command.ExecuteReader();
            try
            {
                while (reader.Read())
                {
                    InterfaceBucket bucket = new InterfaceBucket();
                    bucket.Environment = reader.GetString(reader.GetOrdinal("vc_environment"));
                    bucket.Interface = reader.GetString(reader.GetOrdinal("vc_interface"));
                    bucket.TitleId = (uint)reader.GetInt32(reader.GetOrdinal("i_title_id"));
                    bucket.Bucket = reader.GetInt32(reader.GetOrdinal("i_bucket"));
                    bucket.Server = reader.GetString(reader.GetOrdinal("vc_server"));
                    bucket.NextServer = reader.GetString(reader.GetOrdinal("vc_next_server"));
                    bucket.MigrationStart = reader.GetDateTime(reader.GetOrdinal("dt_migration_start"));
                    bucket.Info1 = reader.GetString(reader.GetOrdinal("vc_info1"));
                    bucket.Info2 = reader.GetString(reader.GetOrdinal("vc_info2"));
                    bucket.Info3 = reader.GetString(reader.GetOrdinal("vc_info3"));
                    bucket.Info4 = reader.GetString(reader.GetOrdinal("vc_info4"));
                    buckets.Add(bucket);
                }
            }
            finally
            {
                if (reader != null)
                {
                    reader.Close();
                }
            }

            return buckets;
        }

        public object ExecuteScalar(string sql)
        {
            object value = null;

            try 
            {
                SqlCommand command = new SqlCommand(sql, _conn);
                value = ExecuteScalar(command);
            }
            catch(SqlException sqlex)
            {
                throw new DatabaseException(_conn, sqlex);
            }

            return value;
        }

        public object ExecuteScalar(SqlCommand cmd)
        {
            return cmd.ExecuteScalar();
        }

        public int IssueCommand(string sql)
        {
            int affected = 0;

            try 
            {
                SqlCommand command = new SqlCommand(sql, _conn);
                affected = command.ExecuteNonQuery();
            }
            catch(SqlException sqlex)
            {
                throw new DatabaseException(_conn, sqlex);
            }

            return affected;
        }

        public void ReadData(SqlCommand cmd, out SqlDataReader reader)
        {
            try
            {
                reader = cmd.ExecuteReader();

                if (reader == null)
                {
                    throw new DatabaseException(_conn, "Execute reader failed");
                }
            }
            catch (SqlException sqlex)
            {
                throw new DatabaseException(_conn, sqlex);
            }
        }

        public void ReadData(string sql, out SqlDataReader reader)
        {
            SqlCommand command = new SqlCommand(sql, _conn);
            ReadData(command, out reader);
        }

        #region IDisposable Members

        void IDisposable.Dispose ()
        {
            Close();
        }

        #endregion
    }

    /// <summary> This is a wrapper class for talking to the NPDB healthchecks. </summary>
    [ComVisible(false)]
    public class NpdbHealthchecks: Npdb
    {
        /// <summary>
        /// Retreive a list of healthcheck URLs for all server and components
        /// </summary>
        /// <returns>A list of healthcheck URLs</returns>
        public List<String> GetServerHealthchecks()
        {
            return GetServerHealthchecks(null, null);
        }

        /// <summary>
        /// Retreive a list of healthcheck URLs for all components on a specific
        /// server
        /// </summary>
        /// <param name="server">The server to check</param>
        /// <returns>A list of healthchek URLs for the given server</returns>
        public List<String> GetServerHealthchecks(String server)
        {
            return GetServerHealthchecks(server, null);
        }

        /// <summary>
        /// Retreive a list of healthcheck URLs for all components on a specific
        /// server
        /// </summary>
        /// <param name="server">The server to check</param>
        /// <param name="component">The component to check</param>
        /// <returns>A list of healthchek URLs for the given server/component</returns>
        public List<String> GetServerHealthchecks(String server, String component)
        {
            List<String> serverHealthcheckUrls = new List<string>();
            String healthcheckUrl;

            lock (_conn)
            {
                SqlDataReader reader = null;
                SqlCommand command = null;

                try
                {
                    command = _conn.CreateCommand();
                    command.CommandType = CommandType.StoredProcedure;
                    command.CommandText = "p_config_get_server_healthchecks";
                    command.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

                    if (!String.IsNullOrEmpty(server))
                    {
                        command.Parameters.Add("vc_server", SqlDbType.VarChar).Value = server;
                    }

                    if (!String.IsNullOrEmpty(component))
                    {
                        command.Parameters.Add("vc_component", SqlDbType.VarChar).Value = component;
                    }

                    reader = command.ExecuteReader();

                    while (reader.Read())
                    {
                        healthcheckUrl = (String)reader["vc_healthcheck_url"];
                        serverHealthcheckUrls.Add(healthcheckUrl);
                    }
                }
                finally
                {
                    if (reader != null && !reader.IsClosed)
                    {
                        reader.Close();
                    }
                }
            }

            return serverHealthcheckUrls;
        }
    }

    /// <summary> This is a wrapper for the Npdb class, with static methods that can be directly called to get results. </summary>
    public class StaticNpdb
    {
        public static int ExecuteNonQuery(string query)
        {
            using (Npdb npdb=new Npdb())
            {
                npdb.ConnectToServer();
                return npdb.IssueCommand(query);
            }
        }

        public static object ExecuteScalar(string query)
        {
            using (Npdb npdb=new Npdb())
            {
                npdb.ConnectToServer();
                return npdb.ExecuteScalar(query);
            }
        }

        public static object ExecuteScalar(SqlCommand cmd)
        {
            using (Npdb npdb = new Npdb())
            {
                npdb.ConnectToServer();
                return npdb.ExecuteScalar(cmd);
            }
        }

        public static List<string[]> ExecuteQueryGetMultiple(string commandText)
        {
            using (Npdb npdb = new Npdb())
            {
                npdb.ConnectToServer();
                SqlDataReader reader;
                npdb.ReadData(commandText, out reader);

                int columns = reader.FieldCount;

                List<string[]> queryResults = new List<string[]>();
                while (reader.Read())
                {
                    List<string> row = new List<string>();
                    for (int i = 0; i < columns; ++i)
                    {
                        row.Add(reader[i].ToString());
                    }

                    queryResults.Add(row.ToArray());
                }
                reader.Close();

                return queryResults; 
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveConfig\Utilities\DeterministicRandom.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace ServerTestFramework.STFLive.Utilities
{
    /// <summary>
    /// Generates random numbers, but keeps track of enough information to recreate any specific event.
    /// </summary>
    public class DeterministicRandom
    {
        /// <summary>The random number generator.</summary>
        protected Random _rand = null;
        /// <summary>The value used to seed the generator.</summary>
        protected int _seed = -1;
        /// <summary>The number of times a function was called on the generator.</summary>
        protected ulong _iterations = 0;

        /// <summary>
        /// Creates a new DeterministicRandom using the current time as a seed value.
        /// </summary>
        public DeterministicRandom ()
        {
            _seed = Math.Abs((int) DateTime.Now.Ticks);
            _rand = new Random(_seed);
        }

        /// <summary>
        /// Creates a new DeterministicRandom using the given value as a seed.
        /// </summary>
        /// <param name="seed">The value to use as a seed.</param>
        public DeterministicRandom (int seed)
        {
            _seed = (seed == -1 ? Math.Abs((int) DateTime.Now.Ticks) : seed);
            _rand = new Random(_seed);
        }

        /// <summary>
        /// Gets or sets the seed value.  Setting the value to -1 causes a time based number to be chosen.
        /// </summary>
        public int Seed
        {
            get { return _seed; }
            set
            {
                _seed = (value == -1 ? Math.Abs((int) DateTime.Now.Ticks) : value);
                Reset();
            }
        }

        /// <summary>
        /// Gets the number of times a function was called on the generator.
        /// </summary>
        public ulong Iterations
        {
            get { return _iterations; }
            set
            {
                if (value < _iterations)
                {
                    Reset();
                }

                lock (_rand)
                {
                    for (; _iterations < value; ++_iterations)
                    {
                        _rand.Next();
                    }
                }
            }
        }

        /// <summary>
        /// Resets the state of the DeterministicRandom.
        /// </summary>
        public void Reset ()
        {
            lock (_rand)
            {
                _rand = new Random(_seed);
                _iterations = 0;
            }
        }

        /// <summary>
        /// Gets a random int in the range [minValue, maxValue).
        /// </summary>
        /// <param name="minValue">The inclusive minimum value to generate.</param>
        /// <param name="maxValue">The exclusive maximum value to generate.</param>
        /// <returns>An integer in the range [minValue, maxValue).</returns>
        public int Next (int minValue, int maxValue)
        {
            if (minValue > maxValue)
            {
                throw new ArgumentOutOfRangeException("minValue cannot be greater than maxValue.");
            }

            if (minValue == maxValue)
            {
                return minValue;
            }

            // will maxValue - minValue overflow?
            if (minValue < 0 && int.MaxValue - maxValue < -minValue)
            {
                uint diff = ((uint) maxValue) + ((uint) (-minValue));
                uint val = (uint) (NextLong() >> 8);
                return (int) (((uint) minValue) + (val % diff));
            }
            else
            {
                int diff = maxValue - minValue;
                int val = Next();
                return minValue + (val % diff);
            }
        }

        /// <summary>
        /// Gets a random int in the range [0, maxValue).
        /// </summary>
        /// <param name="maxValue">The exclusive maximum value to generate.</param>
        /// <returns>An integer in the range [0, maxValue).</returns>
        public int Next (int maxValue)
        {
            if (maxValue < 0)
            {
                throw new ArgumentOutOfRangeException("maxValue cannot be less than zero.");
            }

            return Next() % maxValue;
        }

        /// <summary>
        /// Gets a random int.
        /// </summary>
        /// <returns>An int in the range [0, int.MaxValue).</returns>
        public int Next ()
        {
            lock (_rand)
            {
                ++_iterations;
                return _rand.Next();
            }
        }

        /// <summary>
        /// Gets a random byte.
        /// </summary>
        /// <returns>A random byte in the range [0, 255].</returns>
        public byte NextByte ()
        {
            return (byte) ((Next() >> 8) & 0xFF);
        }

        /// <summary>
        /// Gets a random long.
        /// </summary>
        /// <returns>A random long in the range [0, long.MaxValue).</returns>
        public long NextLong ()
        {
            int[] vals = new int[3];

            lock (_rand)
            {
                _iterations += 3;
                vals[0] = _rand.Next();
                vals[1] = _rand.Next();
                vals[2] = _rand.Next();
            }

            ulong ans, temp;

            // shift out to get high dword
            ans = (ulong) vals[0];
            ans <<= 32;
            // get low dword
            temp = (ulong) vals[1];
            temp &= 0x7FFFFFFF;
            ans |= temp;
            // overwrite bit 31 and 32 because they aren't random
            // 31 because it is always zero
            // 32 because it is slightly biased towards zero
            temp = (ulong) vals[2];
            temp >>= 16;
            temp &= 0x3;
            temp <<= 31;
            ans &= 0xFFFFFFFE7FFFFFFF;
            ans |= temp;

            return (long) ans;
        }

        /// <summary>
        /// Gets a random double.
        /// </summary>
        /// <returns>A double in the range [0, 1)</returns>
        public double NextDouble ()
        {
            return ((double) NextLong()) / ((double) long.MaxValue);
        }

        /// <summary>
        /// Fills the given array with random bytes.
        /// </summary>
        /// <param name="bytes">The array to fill with random bytes.</param>
        public void NextBytes (byte[] bytes)
        {
            int lenOdd = bytes.Length % 2;
            int lenInInts = bytes.Length / 2 + lenOdd;
            int[] ints = new int[lenInInts];

            lock (_rand)
            {
                for (int i = 0; i < lenInInts; ++i)
                {
                    ints[i] = _rand.Next();
                }
                _iterations += (ulong) lenInInts;
            }

            for (int i = 0, j = lenInInts - lenOdd; i < j; ++i)
            {
                bytes[2 * i] = (byte) ((ints[i] >> 8) & 0xFF);
                bytes[2 * i + 1] = (byte) ((ints[i] >> 16) & 0xFF);
            }

            if (lenOdd == 1)
            {
                bytes[bytes.Length - 1] = (byte) ((ints[ints.Length - 1] >> 8) & 0xFF);
            }
        }

        /// <summary>
        /// Changes random bytes in an array to random values.
        /// </summary>
        /// <param name="data">The array of bytes to change.</param>
        /// <param name="iterations">The number of times to change a random byte.</param>
        public void MutateBytes (byte[] data, int iterations)
        {
            MutateBytes(data, 0, data.Length, iterations);
        }

        /// <summary>
        /// Changes random bytes in an array to random values.
        /// </summary>
        /// <param name="data">The array of bytes to change.</param>
        /// <param name="length">The number of bytes after offset to consider for change.</param>
        /// <param name="iterations">The number of times to change a random byte.</param>
        public void MutateBytes (byte[] data, int length, int iterations)
        {
            MutateBytes(data, 0, length, iterations);
        }

        /// <summary>
        /// Changes random bytes in an array to random values.
        /// </summary>
        /// <param name="data">The array of bytes to change.</param>
        /// <param name="offset">The offset from the beginning of the array to start from.</param>
        /// <param name="length">The number of bytes after offset to consider for change.</param>
        /// <param name="iterations">The number of times to change a random byte.</param>
        public void MutateBytes (byte[] data, int offset, int length, int iterations)
        {
            byte temp = 0;

            for (int i = 0; i < iterations; ++i)
            {
                int idx = Next(offset, length);

                byte val;
                if (i % 2 == 0)
                {
                    int itemp = Next();
                    temp = (byte) ((itemp >> 8) & 0xFF);
                    val = (byte) ((itemp >> 16) & 0xFF);
                }
                else
                {
                    val = temp;
                }

                data[idx] = val;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveConfig\Utilities\ValueCheck.cs ===
//live-specific version

using System;
using System.Text;

namespace ServerTestFramework.Utilities
{
    /// <summary>
    /// Class containing overloaded Test methods that compare a value with another taht was expected 
    /// and throw descriptive ExpectedValueCheckExceptions when they don't match.
    /// </summary>
    public class ValueCheck: ServerTestFramework.Core.Utilities.ValueCheck
    {
        public static void TestHR(string name, uint expected, uint got)
        {
            if( expected != got ) 
            {
                throw new ExpectedValueCheckException(name, Global.XErrToString(expected), Global.XErrToString(got));
            }
        }

        public static void TestHR(string name, uint []expected, uint got)
        {
            TestAny(name, expected, got);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveConfig\Utilities\FakeLogVault.cs ===
using System;
using System.Collections.Generic;

using ServerTestFramework.LiveService;

namespace ServerTestFramework.Utilities
{
    /// <summary> Uses xmgmt remote output to generate a log-vault like directory for a component. </summary>
    public class FakeLogVault: IDisposable
    {
        /// <summary> Sets up creation of local files from xmgmtc output for a set of areas on all servers for an (xmgmt accessible) list of IPs.  If flushIntervalInSeconds is 0, flushing must be called manually. </summary>
        public FakeLogVault(string serverInterfaceName, string xmgmtComponentName, string []areas, string localPath, uint flushIntervalInSeconds)
        {
            System.Net.IPEndPoint []eps=ManagementListener.GetXmgmtEndPoints(serverInterfaceName);
            if (eps.Length==0)
            {
                throw new System.Exception("No servers found for interface: "+serverInterfaceName);
            }

            Startup(serverInterfaceName, eps, xmgmtComponentName, areas, localPath, flushIntervalInSeconds);
        }

        /// <summary> Sets up creation of local files from xmgmtc output for a set of areas on all servers for an (xmgmt accessible) interface.  If flushIntervalInSeconds is 0, flushing must be called manually. </summary>
        public FakeLogVault(System.Net.IPEndPoint []eps, string xmgmtComponentName, string []areas, string localPath, uint flushIntervalInSeconds)
        {
            Startup("", eps, xmgmtComponentName, areas, localPath, flushIntervalInSeconds);
        }

        private void Startup(string serverInterfaceName, System.Net.IPEndPoint []eps, string xmgmtComponentName, string []areas, string localPath, uint flushIntervalInSeconds)
        {
            if (localPath=="")
            {
                localPath=".\\";
            }
            else if (!localPath.EndsWith("\\"))
            {
                localPath+="\\";
            }
            System.IO.Directory.CreateDirectory(localPath);

            if (serverInterfaceName=="")
            {
                serverInterfaceName="IP";
            }

            interfaceName=serverInterfaceName;
            path=localPath;
            flushInterval=flushIntervalInSeconds;
            componentName=xmgmtComponentName;

            //start listening
            System.Net.IPEndPoint lastEP=null;
            try
            {
                foreach (string area in areas)
                {
                    foreach (System.Net.IPEndPoint ep in eps)
                    {
                        lastEP=ep;
                        ListeningEntry le=new ListeningEntry();
                        le.area=area;
                        le.ep=ep;
                        listeners.AddLast(le);

                        ManagementListener.Listen(ep, componentName, area, ListenerCallback);
                    }
                }
            }
            catch (Exception e)
            {
                Global.RO.Warn("FakeLogVault exception starting on "+lastEP+": "+e);

                Dispose();
                throw;
            }

            //start bg processing of logs
            if (flushIntervalInSeconds>0)
            {
                thread=ThreadMaker.CreateThread(ThreadProc);
                thread.Start();
            }
        }

        /// <summary> Stops collecting output and flushes anything remaining. </summary>
        public void Dispose()
        {
            //stop all inputs
            foreach (ListeningEntry le in listeners)
            {
                try
                {
                    ManagementListener.Stop(le.ep, componentName, le.area, ListenerCallback);
                }
                catch (System.Exception e)
                {
                    Global.RO.Warn("Exception trying to stop xmgmt listener at "+le.ep+" on "+componentName+" for area "+le.area+": "+e);
                }
            }

            //kill the thread
            running=false;
            if (thread!=null)
            {
                thread.Join();
            }

            //flush anything left
            FlushLogs();
        }

        /// <summary> Flushes all collected logs to files.  Returns the list of files that were written to.  </summary>
        public string[] FlushLogs()
        {
            System.DateTime now=System.DateTime.UtcNow;

            List<string> fileList=new List<string>();

            foreach (ListeningEntry le in listeners)
            {
                string fname=path+componentName+"_"+le.area+"_"+lastFlush.ToString("yyyy'-'mm'-'dd'+'hh'-'mm'-'ss")+".txt";

                lock (le.logLock)
                {
                    if (le.logLines.Count>0)
                    {
                        try
                        {
                            System.IO.StreamWriter sw=System.IO.File.AppendText(fname);
                            foreach (string line in le.logLines)
                            {
                                sw.WriteLine(line);
                            }
                            sw.Close();

                            fileList.Add(fname);
                        }
                        catch (System.Exception e)
                        {
                            Global.RO.Warn("FakeLogVault: Exception adding logline to file "+fname+": "+e);
                        }
                        finally
                        {
                            le.logLines.Clear();
                        }
                    }
                }
            }

            lastFlush=now;
            return fileList.ToArray();
        }

        //callback for when we receive data from the server
        private void ListenerCallback(ManagementListener.Datagram datagram)
        {
            if (datagram.Component.ToLower()!=componentName.ToLower())
            {
                Global.RO.Warn("FakeLogVault: Received xmgmt log from unexpected component.  Expected "+componentName+" but the log had "+datagram.Component);
                return;
            }

            //find the appropriate listener
            foreach (ListeningEntry le in listeners)
            {
                if (le.ep==datagram.RemoteEP && le.area.ToLower()==datagram.Area.ToLower())
                {
                    lock (le.logLock)
                    {
                        //rebuild the logline as it would appear on the server.
                        //TODO: Is there any way to get the server's view of the time on this?
                        string logline=System.DateTime.UtcNow.ToString("yyyy'/'MM'/'dd HH':'mm':'ss'.'fff");
                        logline+="|";
                        logline+=datagram.Text;
                        le.logLines.Add(logline);
                    }

                    return;
                }
            }

            Global.RO.Warn("FakeLogVault: Unhandled logline received: "+datagram);
        }

        //process loglines and dumps them to a file at the regular interval
        private void ThreadProc()
        {
            while (running)
            {
                if ((System.DateTime.UtcNow-lastFlush).TotalSeconds>flushInterval)
                {
                    FlushLogs();
                }

                System.Threading.Thread.Sleep(1000);
            }
        }

        private class ListeningEntry
        {
            public System.Net.IPEndPoint ep;
            public string area;

            public List<string> logLines=new List<string>();
            public object logLock=new object();
        };

        //settings:
        private string interfaceName;
        private string componentName;
        private string path;
        private uint flushInterval;
        private LinkedList<ListeningEntry> listeners=new LinkedList<ListeningEntry>();
        public DateTime lastFlush=System.DateTime.UtcNow;
        System.Threading.Thread thread=null;

        volatile bool running=true;
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\ToolsTestBase.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.UserAccount;
using xonline.common.config;

namespace ServerTestFramework.STFTools
{
    abstract public class ToolsTestBase : TestBase 
    {
        // Prop XBOX 1 Title: livetitle /deployxbox /xboxpath:"4D530064.xbox" /ltcpath:"4D530064_LTC.xml" /xscpath:"4D530064.xsc" /xmspath:"4D530064.xms"
        void PropXbox1Title(uint TitleID, string XBoxPath, string LTCPath, string XSCPath, string XMSPath)
        {
            LiveTitle liveTitle = new LiveTitle();
            liveTitle.XBOXPath = XBoxPath;
            liveTitle.LTCPath = LTCPath;
            liveTitle.XSCPath = XSCPath;
            liveTitle.XMSPath = XMSPath;
            liveTitle.DeployXbox1Title(TitleID);
        }

        /// <summary>
        /// Create a user.  Returns a UODB.Database.UserInfo, defined in UtilityClasses.cs
        /// </summary>
        /// <returns>A UserInfo, defined in UODB.cs</returns>
        public UserInfo CreateUser()
        {
            XeUser user = new XeUser(true);
            ulong puid = user.Create();
            UserInfo uInfo;
            UodbWS.GetUserInfo(puid, out uInfo);
            Global.RO.Info("Account created is " + puid);
            return uInfo;
        }

        #region Offer functions
        /// <summary>
        /// Removes an offer from the system, reversing LiveOffer
        /// </summary>
        /// <param name="OfferId">OfferId of the offer to be removed</param>
        public void OfferRemove(ulong OfferId)
        {
            ServerTestFramework.LiveService.Billing.ContentOfferLoader.CleanOffers(OfferId);
        }
        #endregion

        #region Content Functions
        /// <summary>
        /// Removes Content from a site.  Does not report failure content is missing.
        /// </summary>
        /// <param name="titleId"></param>
        /// <param name="contentId"></param>
        /// <param name="site"></param>
        public static void ContentRemove(uint titleId, string contentId, int site)
        {
            string contentFilePath = ContentGetPath(titleId, contentId, site);
            if (File.Exists(contentFilePath))
            {
                Console.WriteLine("Found old content download package, deleting {0}", contentFilePath);
                File.Delete(contentFilePath);
            }
        }

        /// <summary>
        /// Checks to see if a content package is uploaded to a site
        /// </summary>
        /// <param name="titleId"></param>
        /// <param name="contentId"></param>
        /// <param name="site"></param>
        /// <returns>True if package is present</returns>
        public static bool ContentVerify(uint titleId, string contentId, int site)
        {
            string contentFilePath = ContentGetPath(titleId, contentId, site);
            if (!File.Exists(contentFilePath))
            {
                Console.WriteLine("Content package failed to copy to location:");
                Console.WriteLine(contentFilePath);
                return false;
            }
            return true;
        }

        /// <summary>
        /// Returns the expected path to the package stored in the content download directory
        /// </summary>
        /// <param name="titleId"></param>
        /// <param name="contentId"></param>
        /// <param name="site"></param>
        /// <returns></returns>
        private static string ContentGetPath(uint titleId, string contentId, int site)
        {
            IVirtualInterfaceInfo info;
            info = Config.GetVirtualInterface(VirtualInterface.download, site);

            string contentDownloadLocation = ContentGetDownloadShare(site);
            string contentFilePath = Path.Combine(contentDownloadLocation, titleId.ToString("x"));
            contentFilePath = Path.Combine(contentFilePath, contentId + ".xcp");
            return contentFilePath;
        }

        /// <summary>
        /// Returns a UNC path to the share where content downloads are stored.  These are
        /// referred to by site.
        /// </summary>
        /// <remarks>
        /// This code is directly lifted from the LiveContent tool's DownloadServerList.cs
        /// </remarks>
        /// <param name="siteNum">The ID of the content download site.</param>
        private static string ContentGetDownloadShare(int siteNum)
        {
            string[] serverList = null;
            serverList = Config.GetServerListByInterface(Interface.download_share);

            //Names not yet cached
            for (int c = 0; c < serverList.Length; c++)
            {
                IInterfaceInfo info;
                string shareName;
                int siteId;

                info = Config.GetInterface(serverList[c], Interface.download_share);
                Config.GetServerInfo(serverList[c], out siteId);

                if (siteNum == siteId)
                {
                    shareName = String.Format("\\\\{0}{1}\\",
                        info.IPAddressString,
                        info.Sharename);

                    if ((null == shareName) || (0 == shareName.Length))
                    {
                        throw new Exception("Invalid share name found when searching for content download server!");
                    }

                    if ('\\' != shareName[shareName.Length - 1])
                        shareName += "\\";
                    return shareName;
                }
            }
            //no matches!
            throw new Exception("No share name found when searching for content download server!");
        }
        #endregion

        #region Stats Functions
        /// <summary>
        /// Removes all leaderboards for the Title
        /// </summary>
        /// <param name="TitleID">unique TitleID in hex 0xXXXXXXXX</param>
        /// <returns>output of the LiveStats tool</returns>
        public static string StatsRemove(uint TitleID)
        {
            LiveStats liveStats = new LiveStats();
            liveStats.DeleteLeaderboards(TitleID);
            return liveStats.Output;
        }

        /// <summary>
        /// Deploys Xbox1 Leaderboards
        /// </summary>
        /// <param name="TitleID">unique TitleID in hex 0xXXXXXXXX</param>
        /// <param name="force">determines whether to use /force</param>
        /// <returns>output of the LiveStats tool</returns>
        public static string StatsDeployXbox1Stats(uint TitleID, bool force)
        {
            LiveStats liveStats = new LiveStats();
            liveStats.DeployXbox1Leaderboard(TitleID, force);
            return liveStats.Output;
        }

        /// <summary>
        /// Deploys Xbox 360 Leaderboards
        /// </summary>
        /// <param name="TitleID">unique TitleID in hex 0xXXXXXXXX</param>
        /// <param name="force">determines whether to use /force</param>
        /// <returns>output of the LiveStats tool</returns>
        public static string StatsDeployXbox360Stats(uint TitleID, bool force)
        {
            LiveStats liveStats = new LiveStats();
            liveStats.DeployXbox360Leaderboard(TitleID, force);
            return liveStats.Output;
        }

        /// <summary>
        /// Deploy Web Only Leaderboards
        /// </summary>
        /// <param name="TitleID">unique TitleID in hex 0xXXXXXXXX</param>
        /// <returns>output of the LiveStats tool</returns>
        public static string StatsDeployWebOnlyLeaderboard(uint TitleID)
        {
            LiveStats liveStats = new LiveStats();
            liveStats.DeployWebOnlyLeaderboard(TitleID);
            return liveStats.Output;
        }

        /// <summary>
        /// Move a single or ALL leaderboards from one server to another
        /// </summary>
        /// <param name="TitleID">unique TitleID in hex 0xXXXXXXXX</param>
        /// <param name="LeaderboardId">unique ID for a leaderboard</param>
        /// <param name="SourceServer">name of source server of the leaderboard</param>
        /// <param name="DestServer">name of the destination server</param>
        /// <returns>output of the LiveStats tool</returns>
        public static string StatsMoveLeaderboard(uint TitleID, int LeaderboardId, string SourceServer, string DestServer)
        {
            LiveStats liveStats = new LiveStats();
            liveStats.MoveLeaderboard(TitleID, LeaderboardId, SourceServer, DestServer);
            return liveStats.Output;
        }

        /// <summary>
        /// Returns the Leaderboard Configuration of a Title
        /// </summary>
        /// <param name="TitleID">unique TitleID in hex 0xXXXXXXXX</param>
        /// <returns>array of strings, each string is a leaderboard information</returns>
        public static string[] StatsReportConfiguration(uint TitleID)
        {
            LiveStats liveStats = new LiveStats();
            return liveStats.ReportConfiguration(TitleID);
        }

        /// <summary>
        /// Resets the Leaderboard data for a specific Leaderboard
        /// </summary>
        /// <param name="TitleID">unique TitleID in hex 0xXXXXXXXX</param>
        /// <param name="LeaderboardId">unique ID of the leaderboard</param>
        /// <returns>output of the LiveStats tool</returns>
        public static string StatsResetLeaderboard(uint TitleID, int LeaderboardId)
        {
            LiveStats liveStats = new LiveStats();
            liveStats.ResetLeaderboard(TitleID, LeaderboardId);
            return liveStats.Output;
        }

        /// <summary>
        /// Resets the leaderboard data for all leaderboards of a title
        /// </summary>
        /// <param name="TitleID">unique TitleID in hex 0xXXXXXXXX</param>
        /// <returns>output of the LiveStats tool</returns>
        public static string StatsResetAllLeaderboards(uint TitleID)
        {
            LiveStats liveStats = new LiveStats();
            liveStats.ResetAllLeaderboards(TitleID);
            return liveStats.Output;
        }

        /// <summary>
        /// Reloads the stats front door
        /// </summary>
        /// <returns>output of the LiveStats tool</returns>
        public static string StatsReloadFrontDoor()
        {
            LiveStats liveStats = new LiveStats();
            liveStats.ReloadFrontDoor();
            return liveStats.Output;
        }

        /// <summary>
        /// Reloads the stats web front door
        /// </summary>
        /// <returns>output of the LiveStats tool</returns>
        public static string StatsReloadWebStats()
        {
            LiveStats liveStats = new LiveStats();
            liveStats.ReloadWebStats();
            return liveStats.Output;
        }
        #endregion

        #region Match Functions
        /// <summary>
        /// Used for clearing out the XMatch Databases for a specific titleID
        /// Currently p_match_title_delete in npdb only works for xbox 1 titles, when that is 
        /// fixed to also do 360 titles, we can use that instead of duplicating that effort in
        /// ClearMatchConfiguration.  
        /// </summary>
        /// <param name="titleID">The TitleID to have it's Tables and SP's removed from XMatch DB</param>
        public static void MatchClearAllDB(uint titleID)
        {
            Database.XMatch matchDB = new ServerTestFramework.Database.XMatch();

            string[] servers = Config.GetServerListByInterface(Interface.xmatch);
            if (servers[0].Trim() != "")
            {
                foreach (string server in servers)
                {
                    matchDB.ConnectToServer(server);
                    matchDB.ClearMatchConfiguration(titleID);
                    matchDB.Close();
                }
            }
        }
        #endregion

        #region SystemCheck Functions
        /// <summary>
        /// Runs systemcheck against an inputfile and outputs the result (xml) file
        /// </summary>
        /// <param name="ConfigFile">inputfile with 1 healthcheck url per line</param>
        /// <param name="OutputFile">output file with the returns from the health urls</param>
        /// <param name="Threads">number of threads to run checks in parallel (must be positive)</param>
        /// <param name="Timeout">time before the systemcheck tool gives up</param>
        /// <returns>output of the sytemcheck tool</returns>
        public static string SystemCheckRunSystemCheck(string ConfigFile, string OutputFile, string Threads, string Timeout)
        {
            SystemCheck sysCheckTool = new SystemCheck();
            sysCheckTool.ConfigFilePath = ConfigFile;
            sysCheckTool.OutFilePath = OutputFile;
            sysCheckTool.CallUrl(Threads, Timeout);

            return sysCheckTool.Output;
        }

        /// <summary>
        /// Runs systemcheck against an inputfile and outputs the result (xml) file with default threads and timeout
        /// </summary>
        /// <param name="ConfigFile">inputfile with 1 healthcheck url per line</param>
        /// <param name="OutputFile">output file with the returns from the health urls</param>
        /// <returns>output of the sytemcheck tool</returns>
        public static string SystemCheckRunSystemCheck(string ConfigFile, string OutputFile)
        {
            SystemCheck sysCheckTool = new SystemCheck();
            sysCheckTool.ConfigFilePath = ConfigFile;
            sysCheckTool.OutFilePath = OutputFile;
            sysCheckTool.CallUrl();

            return sysCheckTool.Output;
        }

        /// <summary>
        /// Reloads all frontdoors
        /// </summary>
        /// <returns>output of the sytemcheck tool</returns>
        public static string SystemCheckReloadFrontDoors()
        {
            SystemCheck sysCheckTool = new ServerTestFramework.STFTools.SystemCheck();
            sysCheckTool.Reloadfd();

            return sysCheckTool.Output;
        }

        /// <summary>
        /// Reloads all frontdoors (times out if no response after Timeout)
        /// </summary>
        /// <param name="Timeout">time before the systemcheck tool gives up</param>
        /// <returns>output of the sytemcheck tool</returns>
        public static string SystemCheckReloadFrontDoors(string Timeout)
        {
            SystemCheck sysCheckTool = new ServerTestFramework.STFTools.SystemCheck();
            sysCheckTool.Reloadfd(Timeout);

            return sysCheckTool.Output;
        }
        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup\ToolsTestBase.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.UserAccount;
using xonline.common.config;

namespace ServerTestFramework.STFTools
{
    abstract public class ToolsTestBase : TestBase 
    {
        // Prop XBOX 1 Title: livetitle /deployxbox /xboxpath:"4D530064.xbox" /ltcpath:"4D530064_LTC.xml" /xscpath:"4D530064.xsc" /xmspath:"4D530064.xms"
        void PropXbox1Title(uint TitleID, string XBoxPath, string LTCPath, string XSCPath, string XMSPath)
        {
            LiveTitle liveTitle = new LiveTitle();
            liveTitle.XBOXPath = XBoxPath;
            liveTitle.LTCPath = LTCPath;
            liveTitle.XSCPath = XSCPath;
            liveTitle.XMSPath = XMSPath;
            liveTitle.DeployXbox1Title(TitleID);
        }

        /// <summary>
        /// Create a user.  Returns a UODB.Database.UserInfo, defined in UtilityClasses.cs
        /// </summary>
        /// <returns>A UserInfo, defined in UODB.cs</returns>
        public UserInfo CreateUser()
        {
            XeUser user = new XeUser(true);
            ulong puid = user.Create();
            UserInfo uInfo;
            UodbWS.GetUserInfo(puid, out uInfo);
            Global.RO.Info("Account created is " + puid);
            return uInfo;
        }

        #region Offer functions
        /// <summary>
        /// Removes an offer from the system, reversing LiveOffer
        /// </summary>
        /// <param name="OfferId">OfferId of the offer to be removed</param>
        public void OfferRemove(ulong OfferId)
        {
            ServerTestFramework.LiveService.Billing.ContentOfferLoader.CleanOffers(OfferId);
        }
        #endregion

        #region Content Functions
        /// <summary>
        /// Removes Content from a site.  Does not report failure content is missing.
        /// </summary>
        /// <param name="titleId"></param>
        /// <param name="contentId"></param>
        /// <param name="site"></param>
        public static void ContentRemove(uint titleId, string contentId, int site)
        {
            string contentFilePath = ContentGetPath(titleId, contentId, site);
            if (File.Exists(contentFilePath))
            {
                Console.WriteLine("Found old content download package, deleting {0}", contentFilePath);
                File.Delete(contentFilePath);
            }
        }

        /// <summary>
        /// Checks to see if a content package is uploaded to a site
        /// </summary>
        /// <param name="titleId"></param>
        /// <param name="contentId"></param>
        /// <param name="site"></param>
        /// <returns>True if package is present</returns>
        public static bool ContentVerify(uint titleId, string contentId, int site)
        {
            string contentFilePath = ContentGetPath(titleId, contentId, site);
            if (!File.Exists(contentFilePath))
            {
                Console.WriteLine("Content package failed to copy to location:");
                Console.WriteLine(contentFilePath);
                return false;
            }
            return true;
        }

        /// <summary>
        /// Returns the expected path to the package stored in the content download directory
        /// </summary>
        /// <param name="titleId"></param>
        /// <param name="contentId"></param>
        /// <param name="site"></param>
        /// <returns></returns>
        private static string ContentGetPath(uint titleId, string contentId, int site)
        {
            IVirtualInterfaceInfo info;
            info = Config.GetVirtualInterface(VirtualInterface.download, site);

            string contentDownloadLocation = ContentGetDownloadShare(site);
            string contentFilePath = Path.Combine(contentDownloadLocation, titleId.ToString("x"));
            contentFilePath = Path.Combine(contentFilePath, contentId + ".xcp");
            return contentFilePath;
        }

        /// <summary>
        /// Returns a UNC path to the share where content downloads are stored.  These are
        /// referred to by site.
        /// </summary>
        /// <remarks>
        /// This code is directly lifted from the LiveContent tool's DownloadServerList.cs
        /// </remarks>
        /// <param name="siteNum">The ID of the content download site.</param>
        private static string ContentGetDownloadShare(int siteNum)
        {
            string[] serverList = null;
            serverList = Config.GetServerListByInterface(Interface.download_share);

            //Names not yet cached
            for (int c = 0; c < serverList.Length; c++)
            {
                IInterfaceInfo info;
                string shareName;
                int siteId;

                info = Config.GetInterface(serverList[c], Interface.download_share);
                Config.GetServerInfo(serverList[c], out siteId);

                if (siteNum == siteId)
                {
                    shareName = String.Format("\\\\{0}{1}\\",
                        info.IPAddressString,
                        info.Sharename);

                    if ((null == shareName) || (0 == shareName.Length))
                    {
                        throw new Exception("Invalid share name found when searching for content download server!");
                    }

                    if ('\\' != shareName[shareName.Length - 1])
                        shareName += "\\";
                    return shareName;
                }
            }
            //no matches!
            throw new Exception("No share name found when searching for content download server!");
        }
        #endregion

        #region Stats Functions
        /// <summary>
        /// Removes all leaderboards for the Title
        /// </summary>
        /// <param name="TitleID">unique TitleID in hex 0xXXXXXXXX</param>
        /// <returns>output of the LiveStats tool</returns>
        public static string StatsRemove(uint TitleID)
        {
            LiveStats liveStats = new LiveStats();
            liveStats.DeleteLeaderboards(TitleID);
            return liveStats.Output;
        }

        /// <summary>
        /// Deploys Xbox1 Leaderboards
        /// </summary>
        /// <param name="TitleID">unique TitleID in hex 0xXXXXXXXX</param>
        /// <param name="force">determines whether to use /force</param>
        /// <returns>output of the LiveStats tool</returns>
        public static string StatsDeployXbox1Stats(uint TitleID, bool force)
        {
            LiveStats liveStats = new LiveStats();
            liveStats.DeployXbox1Leaderboard(TitleID, force);
            return liveStats.Output;
        }

        /// <summary>
        /// Deploys Xbox 360 Leaderboards
        /// </summary>
        /// <param name="TitleID">unique TitleID in hex 0xXXXXXXXX</param>
        /// <param name="force">determines whether to use /force</param>
        /// <returns>output of the LiveStats tool</returns>
        public static string StatsDeployXbox360Stats(uint TitleID, bool force)
        {
            LiveStats liveStats = new LiveStats();
            liveStats.DeployXbox360Leaderboard(TitleID, force);
            return liveStats.Output;
        }

        /// <summary>
        /// Deploy Web Only Leaderboards
        /// </summary>
        /// <param name="TitleID">unique TitleID in hex 0xXXXXXXXX</param>
        /// <returns>output of the LiveStats tool</returns>
        public static string StatsDeployWebOnlyLeaderboard(uint TitleID)
        {
            LiveStats liveStats = new LiveStats();
            liveStats.DeployWebOnlyLeaderboard(TitleID);
            return liveStats.Output;
        }

        /// <summary>
        /// Move a single or ALL leaderboards from one server to another
        /// </summary>
        /// <param name="TitleID">unique TitleID in hex 0xXXXXXXXX</param>
        /// <param name="LeaderboardId">unique ID for a leaderboard</param>
        /// <param name="SourceServer">name of source server of the leaderboard</param>
        /// <param name="DestServer">name of the destination server</param>
        /// <returns>output of the LiveStats tool</returns>
        public static string StatsMoveLeaderboard(uint TitleID, int LeaderboardId, string SourceServer, string DestServer)
        {
            LiveStats liveStats = new LiveStats();
            liveStats.MoveLeaderboard(TitleID, LeaderboardId, SourceServer, DestServer);
            return liveStats.Output;
        }

        /// <summary>
        /// Returns the Leaderboard Configuration of a Title
        /// </summary>
        /// <param name="TitleID">unique TitleID in hex 0xXXXXXXXX</param>
        /// <returns>array of strings, each string is a leaderboard information</returns>
        public static string[] StatsReportConfiguration(uint TitleID)
        {
            LiveStats liveStats = new LiveStats();
            return liveStats.ReportConfiguration(TitleID);
        }

        /// <summary>
        /// Resets the Leaderboard data for a specific Leaderboard
        /// </summary>
        /// <param name="TitleID">unique TitleID in hex 0xXXXXXXXX</param>
        /// <param name="LeaderboardId">unique ID of the leaderboard</param>
        /// <returns>output of the LiveStats tool</returns>
        public static string StatsResetLeaderboard(uint TitleID, int LeaderboardId)
        {
            LiveStats liveStats = new LiveStats();
            liveStats.ResetLeaderboard(TitleID, LeaderboardId);
            return liveStats.Output;
        }

        /// <summary>
        /// Resets the leaderboard data for all leaderboards of a title
        /// </summary>
        /// <param name="TitleID">unique TitleID in hex 0xXXXXXXXX</param>
        /// <returns>output of the LiveStats tool</returns>
        public static string StatsResetAllLeaderboards(uint TitleID)
        {
            LiveStats liveStats = new LiveStats();
            liveStats.ResetAllLeaderboards(TitleID);
            return liveStats.Output;
        }

        /// <summary>
        /// Reloads the stats front door
        /// </summary>
        /// <returns>output of the LiveStats tool</returns>
        public static string StatsReloadFrontDoor()
        {
            LiveStats liveStats = new LiveStats();
            liveStats.ReloadFrontDoor();
            return liveStats.Output;
        }

        /// <summary>
        /// Reloads the stats web front door
        /// </summary>
        /// <returns>output of the LiveStats tool</returns>
        public static string StatsReloadWebStats()
        {
            LiveStats liveStats = new LiveStats();
            liveStats.ReloadWebStats();
            return liveStats.Output;
        }
        #endregion

        #region Match Functions
        /// <summary>
        /// Used for clearing out the XMatch Databases for a specific titleID
        /// Currently p_match_title_delete in npdb only works for xbox 1 titles, when that is 
        /// fixed to also do 360 titles, we can use that instead of duplicating that effort in
        /// ClearMatchConfiguration.  
        /// </summary>
        /// <param name="titleID">The TitleID to have it's Tables and SP's removed from XMatch DB</param>
        public static void MatchClearAllDB(uint titleID)
        {
            Database.XMatch matchDB = new ServerTestFramework.Database.XMatch();

            string[] servers = Config.GetServerListByInterface(Interface.xmatch);
            if (servers[0].Trim() != "")
            {
                foreach (string server in servers)
                {
                    matchDB.ConnectToServer(server);
                    matchDB.ClearMatchConfiguration(titleID);
                    matchDB.Close();
                }
            }
        }
        #endregion

        #region SystemCheck Functions
        /// <summary>
        /// Runs systemcheck against an inputfile and outputs the result (xml) file
        /// </summary>
        /// <param name="ConfigFile">inputfile with 1 healthcheck url per line</param>
        /// <param name="OutputFile">output file with the returns from the health urls</param>
        /// <param name="Threads">number of threads to run checks in parallel (must be positive)</param>
        /// <param name="Timeout">time before the systemcheck tool gives up</param>
        /// <returns>output of the sytemcheck tool</returns>
        public static string SystemCheckRunSystemCheck(string ConfigFile, string OutputFile, string Threads, string Timeout)
        {
            SystemCheck sysCheckTool = new SystemCheck();
            sysCheckTool.ConfigFilePath = ConfigFile;
            sysCheckTool.OutFilePath = OutputFile;
            sysCheckTool.CallUrl(Threads, Timeout);

            return sysCheckTool.Output;
        }

        /// <summary>
        /// Runs systemcheck against an inputfile and outputs the result (xml) file with default threads and timeout
        /// </summary>
        /// <param name="ConfigFile">inputfile with 1 healthcheck url per line</param>
        /// <param name="OutputFile">output file with the returns from the health urls</param>
        /// <returns>output of the sytemcheck tool</returns>
        public static string SystemCheckRunSystemCheck(string ConfigFile, string OutputFile)
        {
            SystemCheck sysCheckTool = new SystemCheck();
            sysCheckTool.ConfigFilePath = ConfigFile;
            sysCheckTool.OutFilePath = OutputFile;
            sysCheckTool.CallUrl();

            return sysCheckTool.Output;
        }

        /// <summary>
        /// Reloads all frontdoors
        /// </summary>
        /// <returns>output of the sytemcheck tool</returns>
        public static string SystemCheckReloadFrontDoors()
        {
            SystemCheck sysCheckTool = new ServerTestFramework.STFTools.SystemCheck();
            sysCheckTool.Reloadfd();

            return sysCheckTool.Output;
        }

        /// <summary>
        /// Reloads all frontdoors (times out if no response after Timeout)
        /// </summary>
        /// <param name="Timeout">time before the systemcheck tool gives up</param>
        /// <returns>output of the sytemcheck tool</returns>
        public static string SystemCheckReloadFrontDoors(string Timeout)
        {
            SystemCheck sysCheckTool = new ServerTestFramework.STFTools.SystemCheck();
            sysCheckTool.Reloadfd(Timeout);

            return sysCheckTool.Output;
        }
        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\XLASTUtility.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using ServerTestFramework.STFTools.ConfigFiles;

namespace ServerTestFramework.STFTools
{
    public static class XLASTUtility
    {
        public static LocalizedString GetString(XboxLiveSubmissionProject xlast, ushort stringId)
        {
            if (null == xlast)
                throw new ArgumentNullException("xlast");

            foreach (LocalizedString str in xlast.GameConfigProject.LocalizedStrings.LocalizedStringCollection)
            {
                if (str.id == stringId)
                    return str;
            }
            return null;
        }

        public static string GetDefaultStringTranslation(XboxLiveSubmissionProject xlast, ushort stringId)
        {
            if (null == xlast)
                throw new ArgumentNullException("xlast");

            return GetStringTranslation(xlast, stringId, xlast.GameConfigProject.LocalizedStrings.defaultLocale);
        }

        public static string GetDefaultStringTranslation(XboxLiveSubmissionProject xlast, string friendlyName)
        {
            if (null == xlast)
                throw new ArgumentNullException("xlast");

            return GetStringTranslation(xlast, friendlyName, xlast.GameConfigProject.LocalizedStrings.defaultLocale);
        }

        public static string GetStringTranslation(XboxLiveSubmissionProject xlast, ushort stringId, string locale)
        {
            if (null == xlast)
                throw new ArgumentNullException("xlast");

            foreach (LocalizedString str in xlast.GameConfigProject.LocalizedStrings.LocalizedStringCollection)
            {
                if (str.id == stringId)
                {
                    foreach (Translation trans in str.TranslationCollection)
                    {
                        if (String.Compare(trans.locale, locale, true) == 0)
                            return trans.Value;
                    }
                }
            }

            return null;
        }

        public static string GetStringTranslation(XboxLiveSubmissionProject xlast, string friendlyName, string locale)
        {
            if (null == xlast)
                throw new ArgumentNullException("xlast");

            foreach (LocalizedString str in xlast.GameConfigProject.LocalizedStrings.LocalizedStringCollection)
            {
                if (String.Compare(str.friendlyName, friendlyName, true) == 0)
                {
                    foreach (Translation trans in str.TranslationCollection)
                    {
                        if (String.Compare(trans.locale, locale, true) == 0)
                            return trans.Value;
                    }
                }
            }

            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup\XLASTUtility.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using ServerTestFramework.STFTools.ConfigFiles;

namespace ServerTestFramework.STFTools
{
    public static class XLASTUtility
    {
        public static LocalizedString GetString(XboxLiveSubmissionProject xlast, ushort stringId)
        {
            if (null == xlast)
                throw new ArgumentNullException("xlast");

            foreach (LocalizedString str in xlast.GameConfigProject.LocalizedStrings.LocalizedStringCollection)
            {
                if (str.id == stringId)
                    return str;
            }
            return null;
        }

        public static string GetDefaultStringTranslation(XboxLiveSubmissionProject xlast, ushort stringId)
        {
            if (null == xlast)
                throw new ArgumentNullException("xlast");

            return GetStringTranslation(xlast, stringId, xlast.GameConfigProject.LocalizedStrings.defaultLocale);
        }

        public static string GetDefaultStringTranslation(XboxLiveSubmissionProject xlast, string friendlyName)
        {
            if (null == xlast)
                throw new ArgumentNullException("xlast");

            return GetStringTranslation(xlast, friendlyName, xlast.GameConfigProject.LocalizedStrings.defaultLocale);
        }

        public static string GetStringTranslation(XboxLiveSubmissionProject xlast, ushort stringId, string locale)
        {
            if (null == xlast)
                throw new ArgumentNullException("xlast");

            foreach (LocalizedString str in xlast.GameConfigProject.LocalizedStrings.LocalizedStringCollection)
            {
                if (str.id == stringId)
                {
                    foreach (Translation trans in str.TranslationCollection)
                    {
                        if (String.Compare(trans.locale, locale, true) == 0)
                            return trans.Value;
                    }
                }
            }

            return null;
        }

        public static string GetStringTranslation(XboxLiveSubmissionProject xlast, string friendlyName, string locale)
        {
            if (null == xlast)
                throw new ArgumentNullException("xlast");

            foreach (LocalizedString str in xlast.GameConfigProject.LocalizedStrings.LocalizedStringCollection)
            {
                if (String.Compare(str.friendlyName, friendlyName, true) == 0)
                {
                    foreach (Translation trans in str.TranslationCollection)
                    {
                        if (String.Compare(trans.locale, locale, true) == 0)
                            return trans.Value;
                    }
                }
            }

            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup\ClientTools\EmulatorUtil.cs ===
ï»¿using System;
using System.IO;
using System.Text;
using System.Net;

namespace ServerTestFramework.STFTools
{
    /// <summary>
    /// Utility class for emulator.
    /// </summary>
    public class EmulatorUtil
    {
        public static bool IsEmulatorUp(string emulatorType)
        {            
            string url = null;
            if (String.IsNullOrEmpty(emulatorType))
            {
                return true;
            }
            string template = "http://"+ System.Net.Dns.GetHostName() +"/MusicNetEmulator/";
            switch (emulatorType.Trim().ToLower())
            {
                case "ppsaprofile":
                    url = template + "ppsaProfileEmulator.asmx";
                    break;
                case "ppsacredential":
                    url = template + "ppsaCredentialEmulator.asmx";                    
                    break;
                case "abch":
                    url = template + "abchEmulator.asmx";                    
                    break;
                case "aggregator":
                    url = template + "AggregatorEmulator.asmx";
                    break;
                case "bdk":
                    url = template + "BdkEmulator.asmx";
                    break;
                case "controller":
                    url = template + "Controller.asmx";
                    break;
                case "dmp":
                    url = template + "DMPEmulator.asmx";
                    break;
                case "multirating":
                    url = template + "MultiRatingEmulator.asmx";
                    break;
                case "musicnet":
                    url = template + "MusicNetEmulator.asmx";
                    break;
                case "nicknamelistener":
                    url = template + "NickNameListenerEmulator.asmx";
                    break;
                case "singlerating":
                    url = template + "SingleRatingEmulator.asmx";
                    break;
                case "ups":
                    url = template + "upsEmulator.asmx";
                    break;
                default:
                    break;
            }
            if (String.IsNullOrEmpty(url))
            {
                return true;
            }
            try
            {
                // Create a request to the passed URI.   
                HttpWebRequest req = (HttpWebRequest)WebRequest.Create(url);
                req.Credentials = CredentialCache.DefaultNetworkCredentials;

                // Get the response object.   
                HttpWebResponse webResponse = (HttpWebResponse)req.GetResponse();
                
                return true;
            }
            catch (Exception e)
            {
                Global.RO.Error(String.Format("Check emulator {0} failed and threw exception {1}.", emulatorType, e.Message));
                return false;
            }  
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup\ClientTools\LiveContent.cs ===
using System;
using System.IO;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.STFTools
{
	/// <summary>
	/// Utility class for running the LiveContent tool.
	/// </summary>
	public class LiveContent
	{
		
		private ProcessWrapper _liveContentProcess;
		const string _defaultLiveContentPath = "D:\\webroot\\xbltools";
	
		//Info about the files to be propped
		private string _packagePath = "";
		private uint _titleId = 0;
		private string _offerPath = "";
		private ulong _offerId = 0;
		private string _offerPath2 = "";
		private ulong _offerId2 = 0;

		//flag arguments
		private string _isDefaultOffer = "";
	        private string _useDefaultOffer = "";
		private const string _overwrite = "/overwrite";  //This should always be on.
		private string _sites = "/site:1";
		private string _startDateFlag = "";
		private string _endDateFlag = "";
		private string _shares = "";
		private string _xrls = "";
		
		public enum updateType {selective, global, noflag};
		private string _updateFlag = "";
			
		public enum dbType {all, uodb, productdb, noflag};
		private string _targetFlag = "";

        public enum platformType { xbox1, xenon, pc };

		public LiveContent()
		{
			_liveContentProcess = new ProcessWrapper("LiveContent", Path.Combine(_defaultLiveContentPath, "LiveContent.exe"));
		}

		/// <summary>
		/// Define a non-default location for the LiveContent exe.  This location includes the exe in the path.
		/// </summary>
		/// <param name="liveContentPath">
		/// Path to the executable, including the exe filename.
		/// </param>
		public LiveContent(string liveContentPath) : this()
		{
			_liveContentProcess.ExecutablePath = Path.GetFullPath(liveContentPath);
		}

		public int Timeout {
			get { return _liveContentProcess.ExecutionTimeout; }
			set { _liveContentProcess.ExecutionTimeout = value; }
		}

		/// <summary>
		/// Gets the output after the LiveContent process has been run.
		/// </summary>
		public string Output
		{
			get { return _liveContentProcess.Output; }
		}

		/// <summary>
		/// Gets or sets the /_isDefaultOffer flag for a future run of LiveContent.
		/// </summary>
		public bool IsDefaultOffer
		{
			get { return (_isDefaultOffer != "");  }
			set { _isDefaultOffer = value ? "/isdefaultOffer:yes" : ""; }
		}

        /// <summary>
        /// Gets or sets the /usedefaultoffer flag for a future run of LiveContent
        /// </summary>
        public bool UseDefaultOffer
        {
            get { return (_useDefaultOffer != ""); }
            set { _useDefaultOffer = value ? "/usedefaultoffer" : ""; }
        }

		/// <summary>
		/// Gets or sets the site flag for a future run of LiveContent.
		/// </summary>
		public string Sites
		{
			get { return _sites;  }
			set { _sites = value; }
		}

		/// <summary>
		/// Gets or sets the start date flag for a future run of LiveContent.
		/// </summary>
		public string StartDateFlag
		{
			get { return _startDateFlag;  }
			set { _startDateFlag = value; }
		}

		/// <summary>
		/// Gets or sets the end date flag for a future run of LiveContent.
		/// </summary>
		public string EndDateFlag
		{
			get { return _endDateFlag;  }
			set { _endDateFlag = value; }
		}

		/// <summary>
		/// Gets or sets the _shares flag for a future run of LiveContent.
		/// </summary>
		public string Shares
		{
			get { return _shares;  }
			set { _shares = value; }
		}

		/// <summary>
		/// Gets or sets the _sites flag for a future run of LiveContent.
		/// </summary>
		public string Xrls
		{
			get { return _xrls;  }
			set { _xrls = value; }
		}

		/// <summary>
		/// Sets the update flag for a future run of LiveContent.
		/// </summary>
		/// <param name="type">
		/// Possible choices for the /update: option.
		/// </param>
		public void setUpdateFlag(updateType type)
		{
			switch (type) 
			{
				case updateType.selective:
					_updateFlag = "/update:selective";
					break;
				case updateType.global:
					_updateFlag = "/update:full";
					break;
				case updateType.noflag:
					_updateFlag= "";
					break;
			}
		}

		/// <summary>
		/// Sets the package and associated titleID for a future run of LiveContent.
		/// </summary>
		/// <param name="path">
		/// File path which will be passed in the /package: argument.
		/// </param>
		/// <param name="_titleId">
		/// OfferId which will be passed in the /titleid: argument.
		/// </param>
		public void SetPackageFile(string path, uint _titleId) 
		{
			_packagePath = path;
			this._titleId=_titleId;
		}
		
		/// <summary>
		/// Sets the optional first offer and its associated offerID
		/// for a future run of LiveContent.
		/// </summary>
		/// <param name="path">
		/// File path which will be passed in the /offerfile: argument.
		/// </param>
		/// <param name="_offerId">
		/// OfferId which will be passed in the /offerid: argument.
		/// </param>
		public void SetOfferFile(string path, ulong _offerId) 
		{
			_offerPath = path;
			this._offerId = _offerId;
		}

		/// <summary>
		/// Sets the optional second offer and its associated offerID
		/// for a future run of LiveContent.
		/// </summary>
		/// <param name="path">
		/// File path which will be passed in the /offerfile2: argument.
		/// </param>
		/// <param name="_offerId">
		/// OfferId which will be passed in the /offerid2: argument.
		/// </param>
		public void SetOfferFile2(string path, ulong _offerId)
		{
			_offerPath2 = path;
			this._offerId2=_offerId;
		}

		/// <summary>
		/// Sets the _targetFlag string from the given dbType.
		/// </summary>
		/// <param name="selectedDB">
		/// Possible choices for the /targetDB: option.
		/// </param>
		public void setTargetFlag(dbType selectedDB) 
		{
			switch (selectedDB)
			{
				case dbType.uodb:
					_targetFlag = "/targetdb:uodb";
					break;
				case dbType.productdb:
					_targetFlag = "/targetdb:productdb";
					break;
				case dbType.all:
					_targetFlag = "/targetdb:all";
					break;
				case dbType.noflag:
					_targetFlag = "";
					break;
			}
		}
		/// <summary>
		/// Returns a combined string of all the flags used when propping 
		/// content(and not autoupdates).  If in the future flags are added, they should be 
		/// added to this string as well.
		/// </summary>
		private string CombineFlagsForContent() 
		{
			return _isDefaultOffer + " " +
		        _useDefaultOffer + " " +
				_overwrite + " " +
				_sites + " " +
				_startDateFlag + " " +
				_endDateFlag + " " +
				_updateFlag + " " +
				_targetFlag;
		}

		/// <summary>
		/// Expects SetPackageFile to be set.  Optionally expects SetOfferFile, SetOfferFile2, 
		/// IsDefaultOffer, etc. to be called to set other parameters.  WARNING:Content files
		/// require an offer file, and should not be run without them.
		/// </summary>
		public void Deploy360Package() 
		{
			string arguments = "/action:build ";
			if ((_packagePath== "") || (_titleId == 0)) 
			{
				//TODO: error out somehow.
			} 
			else { arguments += String.Format("/package:{0} /titleid:0x{1:x} ", _packagePath, _titleId); }

			if (_offerPath != "" && !UseDefaultOffer) 
			{
				arguments += String.Format("/offerfile:{0} /offerid:{1:x} ", _offerPath, _offerId);
			}

			if (_offerPath2 != "" && !UseDefaultOffer)
			{
				arguments += String.Format("/offerfile2:{0} /offerid2:{1:x} ", _offerPath2, _offerId2);
			}
			arguments += CombineFlagsForContent();

			if (_liveContentProcess.Run(arguments) != 0) /* || (grep some kind of error string in output) */
				throw new LiveContentException("Prop of Xbox360 Content or AutoUpdate failed.", _liveContentProcess.Output);			
		}

		/// <summary>
		/// Expects SetPackageFile to be set.  Optionally expects SetOfferFile and
		/// IsDefaultOffer to be called to set other parameters.
		/// </summary>
		public void DeployXbox1Content() 
		{
			string arguments = "/action:xbox1content ";

			if ((_packagePath== "") || (_titleId == 0)) 
			{
				//TODO: error out somehow.
			} 
			else { arguments += String.Format("/package:{0} /titleid:0x{1:x} ", _packagePath, _titleId); }

			if (_offerPath != "") 
			{
				arguments += String.Format("/offerfile:{0} /offerid:{1:x} ", _offerPath, _offerId);
			}
			arguments += CombineFlagsForContent();

			if (_liveContentProcess.Run(arguments) != 0) /* || (grep some kind of error string in output) */
				throw new LiveContentException("Prop of Xbox1 Content failed.", _liveContentProcess.Output);			
		}		

		/// <summary>
		/// Deploys an xbox1 AutoUpdate.  This expects SetPackageFile to be called beforehand.
		/// Arguments it does not use will be dropped.
		/// </summary>
		public void DeployXbox1AutoUpdate() 
		{
			string arguments = "/action:xbox1update ";
			if ((_packagePath== "") || (_titleId == 0)) 
			{
				//TODO: error out somehow.
			} 
			else { arguments += String.Format("/package:{0} /titleid:0x{1:x} " + _sites + " " + _updateFlag + " ", _packagePath, _titleId); }
			arguments += _overwrite + " ";
		
			if (_liveContentProcess.Run(arguments) != 0) /* || (grep some kind of error string in output) */
				throw new LiveContentException("Prop of Xbox1 AutoUpdate failed.", _liveContentProcess.Output);			
		}

		/// <summary>
		/// Converts a selective update into a global autoupdate.
		/// </summary>
		/// <param name="_titleId">
		/// The titleid to apply this change.
		/// </param>
		/// <param name="oldVersion">
		/// The version number that the selective update begins.
		/// </param>
		/// <param name="newVersion">
		/// The version number to which the selective update will update.
		/// </param>
        /// <param name="platform">
        /// The platform this update applies.
        /// </param>
        public void MakeAutoUpdateFull(uint titleId, uint oldVersion, uint newVersion, platformType platform) 
		{
			string arguments = "/action:makefull ";
			arguments += String.Format("/titleid:0x{0:x} /package:{1:x}{2:x} ", titleId, Hex8(oldVersion), Hex8(newVersion));
            switch (platform)
            {
                case platformType.xbox1:
                    arguments += "/platform:xbox1 ";
                    break;
                case platformType.xenon:
                    arguments += "/platform:xenon ";
                    break;
                case platformType.pc:
                    arguments += "/platform:pc ";
                    break;
            }
			arguments += _sites;
			if (_liveContentProcess.Run(arguments) != 0) /* || (grep some kind of error string in output) */
				throw new LiveContentException("Attempt to make selective update a global one failed.", _liveContentProcess.Output);
		}

        /// <summary>
        /// Makes a zero paded hex value.  ie 00000101
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        private string Hex8(uint value)
        {
            string newVal;
            newVal = String.Format("0000000{0:x}", value);
            return newVal.Substring(newVal.Length - 8);
        }

		/// <summary>
		/// Runs LiveContent with a string of command-line arguments and nothing else.
		/// </summary>
		/// <param name="arguments">
		/// String of command line arguments.
		/// </param>
		public void RunWithOnlyStringArguments(string arguments) 
		{
			if (_liveContentProcess.Run(arguments) != 0) /* || (grep some kind of error string in output) */
				throw new LiveContentException("Run with specific user arguments failed.", _liveContentProcess.Output);			
		}
	}
	
	public class LiveContentException : ProcessException
	{
		public LiveContentException() : base("LiveContent") {}
		public LiveContentException(string message) : base("LiveContent", message) {}
		public LiveContentException(string message, Exception innerException) : base("LiveContent", message, innerException) {}
		public LiveContentException(string message, string output) : base("LiveContent", message, output) {}
		public LiveContentException(string message, string output, Exception innerException) :
			base("LiveContent", message, output, innerException) {}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup\ClientTools\LiveMatch.cs ===
using System;
using System.IO;
using System.Diagnostics;
using System.Text;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.STFTools
{
    /// <summary>
    /// Utility class for running the LiveMatch tool.
    /// </summary>
    public class LiveMatch : ClientToolBase
    {
        private string _scriptFile = "";
        private bool _noReloadFrontDoors = false;
        private int _typeID = -1;
        private int _modeID = -1;
        private int _rrID = -1;

        public LiveMatch() : base(Path.Combine(DefaultBasePath, "LiveMatch.exe")) { }
        public LiveMatch(string liveMatchPath) : base(liveMatchPath) { }
        public LiveMatch(string liveMatchPath, bool isRemote) : base(liveMatchPath, isRemote) { }
        public LiveMatch(string liveMatchPath, bool isRemote, string remoteServer) : base(liveMatchPath, isRemote, remoteServer) { }

        /// <summary>
        /// Gets or sets the name of the SQL file generated when using the /script option.
        /// </summary>
        public string ScriptFile
        {
            get { return _scriptFile; }
            set { _scriptFile = (value == null ? "" : value); }
        }

        /// <summary>
        /// Gets or sets the typeid
        /// </summary>
        public int TypeID
        {
            get { return _typeID; }
            set { _typeID = value; }
        }

        /// <summary>
        /// Gets or sets the modeid
        /// </summary>
        public int ModeID
        {
            get { return _modeID; }
            set { _modeID = value; }
        }

        /// <summary>
        /// Gets or sets the rrid
        /// </summary>
        public int RRID
        {
            get { return _rrID; }
            set { _rrID = value; }
        }

        /// <summary>
        /// Turn on or off the /noreload option.  Defaults at false so that it does not use switch.
        /// </summary>
        public bool NoReloadFrontDoors
        {
            get { return _noReloadFrontDoors; }
            set { _noReloadFrontDoors = value; }
        }

        /// <summary>
        /// Deploys the matchmaking database(s) for the current title.
        /// </summary>
        /// <param name="dropTable">
        /// Flag indicating whether to drop the current match table.
        /// </param>
        /// <param name="scriptSQL">
        /// Flag indicating whether to write the SQL commands to a local file instead of to the databases.
        /// The name of the file can be specified using the ScriptFile property.
        /// </param>
        public void DeployMatchServer(uint titleId, bool dropTable, bool scriptSQL, bool removeMode , string newModeServer)
        {
            StringBuilder arguments = new StringBuilder(128);

            arguments.AppendFormat("/DeployMatch /titleid:0x{0:x}", titleId);

            if (dropTable)
            {
                arguments.Append(" /droptable");
            }

            if (scriptSQL)
            {
                arguments.AppendFormat(" /script:{0}", _scriptFile);
            }

            // If the _noReloadFrontDoors is true, then specify /noreload
            if (_noReloadFrontDoors)
            {
                arguments.Append(" /noreload");
            }

            if (removeMode)
            {
                arguments.Append(" /removemode");
            }

            if ((newModeServer != null) && (newModeServer != ""))
            {
                arguments.AppendFormat(" /newmodeserver:{0}", newModeServer);
            }

            RunThrowOnFailure<LiveMatchException>(arguments.ToString(), "Matchmaking configuration failed.");
        }


        /// <summary>
        /// Used for different migrations for an interface bucket
        /// </summary>
        /// <param name="titleID">TitleId used for migration</param>
        /// <param name="migrationState">
        /// 0 = StartMigrationForBucket
        /// 1 = MigrationStatusForBucket
        /// 2 = ExpediteMigrationForBucket
        /// 3 = EndMigrationForBucket
        /// </param>
        /// <param name="destServerName">Destination server, only required for StartMigrationForBucket</param>
        public void MatchMigrationBucket(uint titleID, int migrationState, string destServerName)
        {
            StringBuilder arguments = new StringBuilder(128);

            arguments.AppendFormat("/titleid:0x{0:x}", titleID);

            switch (migrationState)
            {
                case 0:
                    arguments.Append(" /StartMigrationForBucket");
                    break;
                case 1:
                    arguments.Append(" /MigrationStatusForBucket");
                    break;
                case 2:
                    arguments.Append(" /ExpediteMigrationForBucket");
                    break;
                case 3:
                    arguments.Append(" /EndMigrationForBucket");
                    break;
                default:
                    break;
            }

            if (_typeID != -1)
            {
                arguments.AppendFormat(" /type:{0}", _typeID);
            }

            if (_modeID != -1)
            {
                arguments.AppendFormat(" /mode:{0}", _modeID);
            }

            if (_rrID != -1)
            {
                arguments.AppendFormat(" /rrid:{0}", _rrID);
            }

            if ((destServerName != null) && (destServerName != ""))
            {
                arguments.AppendFormat(" /dest:{0}", destServerName);
            }

            RunThrowOnFailure<LiveMatchException>(arguments.ToString(), "Matchmaking configuration failed.");
        }

        /// <summary>
        /// Used for different title migrations
        /// </summary>
        /// <param name="titleID">TitleId used for migration</param>
        /// <param name="migrationState">
        /// 0 = StartMigrationForTitle
        /// 1 = MigrationStatusForTitle
        /// 2 = ExpediteMigrationForTitle
        /// 3 = EndMigrationForTitle
        /// </param>
        /// <param name="destServerName">Destination server, only required for StartMigrationForBucket</param>
        public void MatchMigrationTitle(uint titleID, int migrationState, string sourceServerName, string destServerName)
        {
            StringBuilder arguments = new StringBuilder(128);

            arguments.AppendFormat("/titleid:0x{0:x}", titleID);

            switch (migrationState)
            {
                case 0:
                    arguments.Append(" /StartMigrationForTitle");
                    break;
                case 1:
                    arguments.Append(" /MigrationStatusForTitle");
                    break;
                case 2:
                    arguments.Append(" /ExpediteMigrationForTitle");
                    break;
                case 3:
                    arguments.Append(" /EndMigrationForTitle");
                    break;
                default:
                    break;
            }

            if ((sourceServerName != null) && (sourceServerName != ""))
            {
                arguments.AppendFormat(" /source:{0}", sourceServerName);
            }

            if ((destServerName != null) && (destServerName != ""))
            {
                arguments.AppendFormat(" /dest:{0}", destServerName);
            }

            RunThrowOnFailure<LiveMatchException>(arguments.ToString(), "Matchmaking configuration failed.");
        }

        #region ServerMigrationCutForFall
        /*
        /// <summary>
        /// Used for different migrations for a server migration
        /// </summary>
        /// <param name="titleID">TitleId used for migration</param>
        /// <param name="migrationState">
        /// 0 = StartMigrationForServer
        /// 1 = MigrationStatusForServer
        /// 2 = ExpediteMigrationForServer
        /// 3 = EndMigrationForServer
        /// </param>
        /// <param name="destServerName">Destination server, only required for StartMigrationForServer</param>
        public void MatchMigrationServer(uint titleID, int migrationState, string sourceServerName, string destServerName)
        {
            StringBuilder arguments = new StringBuilder(128);

            arguments.AppendFormat("/titleid:0x{0:x}", titleID);

            switch (migrationState)
            {
                case 0:
                    arguments.Append(" /StartMigrationForServer");
                    break;
                case 1:
                    arguments.Append(" /MigrationStatusForServer");
                    break;
                case 2:
                    arguments.Append(" /ExpediteMigrationForServer");
                    break;
                case 3:
                    arguments.Append(" /EndMigrationForServer");
                    break;
                default:
                    break;
            }

            if ((sourceServerName != null) && (sourceServerName != ""))
            {
                arguments.AppendFormat(" /source:{0}", sourceServerName);
            }

            if ((destServerName != null) && (destServerName != ""))
            {
                arguments.AppendFormat(" /dest:{0}", destServerName);
            }

            if (_liveMatchProcess.Run(arguments.ToString()) != 0)
                throw new LiveMatchException("Matchmaking configuration failed.", _liveMatchProcess.Output);
        }
        */
        #endregion

        /// <summary>
        /// Used for adding a RR bucket to an existing type/mode
        /// </summary>
        /// <param name="titleID">TitleId used for migration</param>
        /// <param name="serverName">The server that is going to be added for round robin</param>
        public void MatchAddRRBucket(uint titleID, string serverName)
        {
            StringBuilder arguments = new StringBuilder(128);

            arguments.AppendFormat("/AddRRBucket /titleid:0x{0:x}", titleID);

            if (_typeID != -1)
            {
                arguments.AppendFormat(" /type:{0}", _typeID);
            }

            if (_modeID != -1)
            {
                arguments.AppendFormat(" /mode:{0}", _modeID);
            }

            if ((serverName != null) && (serverName != ""))
            {
                arguments.AppendFormat(" /server:{0}", serverName);
            }

            RunThrowOnFailure<LiveMatchException>(arguments.ToString(), "Matchmaking configuration failed.");
        }

        /// <summary>
        /// Used to begin draining the top round robined bucket.  Draining buckets no longer add
        /// sessions to them.
        /// </summary>
        /// <param name="titleID">TitleId used for migration</param>
        public void MatchDrainTopRRBucket(uint titleID)
        {
            StringBuilder arguments = new StringBuilder(128);

            arguments.AppendFormat("/drainTopRRBucket /titleid:0x{0:x}", titleID);

            if (_typeID != -1)
            {
                arguments.AppendFormat(" /type:{0}", _typeID);
            }

            if (_modeID != -1)
            {
                arguments.AppendFormat(" /mode:{0}", _modeID);
            }

            RunThrowOnFailure<LiveMatchException>(arguments.ToString(), "Matchmaking configuration failed.");
        }

        /// <summary>
        /// Used to begin draining the top round robined bucket.  Draining buckets no longer add
        /// sessions to them.
        /// </summary>
        /// <param name="titleID">TitleId used for migration</param>
        public void MatchRemoveTopRRBucket(uint titleID, bool force)
        {
            StringBuilder arguments = new StringBuilder(128);

            arguments.AppendFormat("/removeTopRRBucket /titleid:0x{0:x}", titleID);

            if (_typeID != -1)
            {
                arguments.AppendFormat(" /type:{0}", _typeID);
            }

            if (_modeID != -1)
            {
                arguments.AppendFormat(" /mode:{0}", _modeID);
            }

            if (force)
            {
                arguments.Append(" /force");
            }

            RunThrowOnFailure<LiveMatchException>(arguments.ToString(), "Matchmaking configuration failed.");
        }


        /// <summary>
        /// Adds a new matchmaking server.
        /// </summary>
        /// <param name="serverName">
        /// Name of the server to which matchmaking tables and queries will be added.
        /// </param>
        public void AddMatchServer(uint xboxtitleID, string serverName)
        {
            RunThrowOnFailure<LiveMatchException>(String.Format("/titleid:0x{0:x} /add:{1}", xboxtitleID, serverName), "Failed to add match server.");
        }

        /// <summary>
        /// Deletes an existing matchmaking server.
        /// </summary>
        /// <param name="serverName">
        /// Name of the server to remove from the match titles table.
        /// </param>
        public void DeleteMatchServer(uint xboxtitleID, string serverName)
        {
            RunThrowOnFailure<LiveMatchException>(String.Format("/titleid:0x{0:x} /delete:{1}", xboxtitleID, serverName), "Failed to delete match server.");
        }

        /// <summary>
        /// Allows direct passing of Arguments on command line to LiveMatch, primarily used for negative testing.
        /// </summary>
        /// <param name="arguments">String to pass to LiveMatch</param>
        public void RunLiveMatch(string arguments)
        {
            RunThrowOnFailure<LiveMatchException>(arguments, "LiveMatch failed");
        }

        /// <summary>
        /// Static method for running Live Match with the default settings of titleid and the droptable option.
        /// </summary>
        /// <param name="titleID">The TitleID to which you want to run LiveMatch for</param>
        public static void RunLiveMatchDefault(uint titleID)
        {
            LiveMatch liveMatch = new LiveMatch();
            liveMatch.RunThrowOnFailure<LiveMatchException>(String.Format("/titleid:0x{0:x} /droptable", titleID), "Live Match Default failed.");
        }

    }

    public class LiveMatchException : ProcessException
    {
        public LiveMatchException(string message, string output) : base("LiveMatch", message, output) {}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup\ClientTools\ClientToolBase.cs ===
using System;
using System.IO;
using System.Diagnostics;
using System.Reflection;
using ServerTestFramework.Utilities;
using Microsoft.Win32;

namespace ServerTestFramework.STFTools
{
    /// <summary>
    /// Base class for all client tool wrappers
    /// </summary>
    abstract public class ClientToolBase
    {
        public const string DefaultBasePath = @"D:\Webroot\xbltools";
        public readonly string ToolPath;

        private ProcessWrapper m_Process;
        private string m_RemoteServer = null;

        public ClientToolBase(string toolPath) : this(toolPath, false, null) { }

        public ClientToolBase(string toolPath, bool isRemote) : this(toolPath, isRemote, isRemote ? GetToolServer() : null) {}

        public ClientToolBase(string toolPath, bool isRemote, string remoteServer)
        {
            ToolPath = toolPath;

            if (isRemote)
            {
                m_RemoteServer = remoteServer;
                m_Process = new ProcessWrapper(Path.GetFileNameWithoutExtension(ToolPath) + " (Remote)", "psexec.exe");
                AcceptPsExecEula();
            }
            else
            {
                m_Process = new ProcessWrapper(Path.GetFileNameWithoutExtension(ToolPath), ToolPath);
            }
        }

        /// <summary>
        /// Standard Error for the completed process
        /// </summary>
        public string StandardError
        {
            get
            {
                return m_Process.Error;
            }
        }

        /// <summary>
        /// Standard Output for the completed process
        /// </summary>
        public string StandardOutput
        {
            get
            {
                return m_Process.Output;
            }
        }

        /// <summary>
        /// Gets the first server for the toolsmgmtsrv interface
        /// </summary>
        /// <returns>Server name</returns>
        private static string GetToolServer()
        {
            string[] toolServers = Global.XEnv.GetServerListByInterface("toolsmgmtsrv"); // TODO: Put this into xonline.common.config.Interface

            if (toolServers.Length < 1)
                throw new Exception("Could not find server for \"toolsmgmtsrv\" interface");

            return toolServers[0];
        }

        /// <summary>
        /// Sets the flag in the registry saying that we accepted the PsExec license agreement.
        /// Without this, the first execution pops up an Accept/Decline UI that currently can't
        /// be overridden on the command line.
        /// </summary>
        private void AcceptPsExecEula()
        {
            const string psExecSubKey = @"Software\Sysinternals\PsExec";
            const string psExecValueName = "EulaAccepted";

            RegistryKey psExecKey = Registry.CurrentUser.OpenSubKey(psExecSubKey, true);

            if (psExecKey == null)
            {
                psExecKey = Registry.CurrentUser.CreateSubKey(psExecSubKey);
            }

            int eulaAccepted = (int)psExecKey.GetValue(psExecValueName, 0);

            if (eulaAccepted != 1)
            {
                psExecKey.SetValue(psExecValueName, 1, RegistryValueKind.DWord);
            }
        }

        /// <summary>
        /// Executes the tool with the given arguments
        /// </summary>
        /// <param name="args">Arguments for the tool</param>
        /// <returns>Process exit code</returns>
        public int Run(string args)
        {
            if (String.IsNullOrEmpty(m_RemoteServer))
            {
                // Local run
                return m_Process.Run(args);
            }
            else
            {
                // Remote run, marshal real parameters to psexec
                return m_Process.Run(String.Format("\\\\{0} {1} {2}", m_RemoteServer, ToolPath, args));
            }
        }

        /// <summary>
        /// Executes the tool with the given arguments and throws an exception if the
        /// exit code is non-zero.
        /// </summary>
        /// <typeparam name="T">Type of exception to throw</typeparam>
        /// <param name="args">Arguments for the tool</param>
        /// <param name="message">Error message</param>
        public void RunThrowOnFailure<T>(string args, string message) where T : ProcessException
        {
            int exitCode = Run(args);

            if (exitCode != 0)
            {
                // Special case the scenario where psexec couldn't start the binary
                if (StandardError.Contains("could not start " + ToolPath))
                {
                    message = String.Format("Could not start {0} on server {1}.  Is the path correct?", ToolPath, m_RemoteServer);
                }

                // This preserves the pattern of each client tool wrapper specifying
                // its own Exception when the tool fails.  Having all tools simply
                // throw a ProcessException is much simpler and still readable, but
                // that is too big a change for now.
                T ex = (T)Activator.CreateInstance(typeof(T), message, StandardOutput);
                throw ex;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup\ClientTools\LiveOffer.cs ===
/*
TODO: 
	- Add 585207D1 Peg PC subscription to Positive Tests
	- add BitFilter Neg case: Filter set to 0 should error as well as multiple set (Schema error)
	- add Mis-sized PNG case
*/
using System;
using System.IO;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

namespace ServerTestFramework.STFTools
{
	/// <summary>
	/// Utility class for running the LiveOffer tool.
	/// </summary>
	public class LiveOffer
	{
		private ProcessWrapper _liveOfferProcess;
		private const string _defaultLiveOfferPath = "D:\\webroot\\xbltools";
		public enum dbType {all, uodb, productdb, noflag};
		public bool noTransaction;

		public LiveOffer()
		{
			_liveOfferProcess = new ProcessWrapper("LiveOffer", Path.Combine(_defaultLiveOfferPath, "LiveOffer.exe"));
		}

		public LiveOffer(string liveOfferPath) : this()
		{
			_liveOfferProcess.ExecutablePath = Path.GetFullPath(liveOfferPath);
		}

		public string Output
		{
			get { return _liveOfferProcess.Output; }
		}

		/// <summary>
		/// Returns the appropriate string for the given dbType.
		/// </summary>
		public string DbTypeToString(dbType db) 
		{
            // Attribute not currently supported by LiveOffer. May come-back someday.
            /*
			switch (db) 
			{
				case dbType.uodb:
					return "-targetdb:uodb";
				case dbType.productdb:
					return "-targetdb:productdb";
				case dbType.all:
					return "-targetdb:all";
				case dbType.noflag:
			}
			throw new LiveOfferException("Invalid type(" + db + ") given to LiveOffer.cs::DbTypeToString");
            */

            return "";
		}
		/// <summary>
		/// Reloads the front doors.  Offers are cached and will not be seen unless the 
		/// this occurs--however, LiveOffer will by default reload the front doors after
		/// every prop.
		/// </summary>
		public void ReloadFrontDoors() 
		{
			string arguments = "-action:reload";
			if (_liveOfferProcess.Run(arguments) != 0) /* || (grep some kind of error string in output) */
				throw new LiveOfferException("Reload of front doors failed.", _liveOfferProcess.Output);			
		}
		/// <summary>
		/// Checks if the given XML file follows the format given in the file LiveOffer.xsd
		/// </summary>
		/// <param name="filePath">File to be validated.</param>
		public void Validate360Offer(string filePath) 
		{
			string arguments = String.Format("-action:validate -file:{0}", filePath);
			if (_liveOfferProcess.Run(arguments) != 0) /* || (grep some kind of error string in output) */
				throw new LiveOfferException("Xbox 360 offer validation failed.", _liveOfferProcess.Output);
		}

		/// <summary>
		/// Checks if the given XML file follows the format given in the file Xbox1Offer.xsd
		/// </summary>
		/// <param name="filePath">File to be validated.</param>
		public void ValidateXboxOffer(string filePath)
		{
			string arguments = String.Format("-action:validatexbox -file:{0}", filePath);
			if (_liveOfferProcess.Run(arguments) != 0) /* || (grep some kind of error string in output) */
				throw new LiveOfferException("Xbox offer validation failed.", _liveOfferProcess.Output);
		}

        /// <summary>
        /// Checks if a offer is propped.
        /// </summary>
        public static bool CheckIfOfferIsPropped(ulong offerID)
        {
            bool isPropped = false;
            try
            {
                string query = "select count(*) from t_offers WHERE bi_offer_id=" + (long)offerID;
                int rows = (int)UodbWS.ExecuteSQLSelectCount(query);
                if (rows != 0) isPropped = true;
            }
            catch (Exception e)
            {
                Global.RO.Error("UodbWS.ExecuteSQLSelectCount threw while trying to check offer " + offerID.ToString("x") + ": " + e.Message + "\nWill assume this indicates that it is not propped.");
            }
            return isPropped;
        }

		/// <summary>
		/// Places an Xbox360 offer file on the Live service.  This populates a large number of tables 
		/// that begin with uodb..t_offer.
		/// </summary>
		/// <param name="filePath">Path to the offer file.</param>
		/// <param name="titleId">Titleid the offer is related to.</param>
		/// <param name="targetDBs">Flag determining which DBs should be updated</param>
		/// <param name="overwriteDMPSettings">If they exist, clobber existing DMP settings.</param>
		public void Prop360Offer(string filePath, uint titleId, dbType targetDBs, bool overwriteDMPSettings) 
		{
			string arguments = String.Format("-action:prop -file:{0} -titleid:{1:x} {2} {3} {4}", filePath, titleId,
				DbTypeToString(targetDBs), overwriteDMPSettings ? "-overwriteDMPSettings" : "", noTransaction ? "-noTransaction":"");
			int res = _liveOfferProcess.Run(arguments);
			if (res != 0) /* || (grep some kind of error string in output) */
				{
				throw new LiveOfferException(String.Format("Prop of Xbox 360 offer failed. ({0})",res), _liveOfferProcess.Output);
				}
		}

		/// <summary>
		/// Places an Xbox1 offer file on the Live service.  This populates a distinctly different set of tables
		/// than in the XBox360 case.
		/// </summary>
		/// <param name="filePath">Path to the offer file.</param>
		/// <param name="titleId">Titleid the offer is related to.</param>
		/// <param name="targetDBs">Flag determining which DBs should be updated</param>
		/// <param name="overwriteDMPSettings">If they exist, clobber existing DMP settings.</param>
		public void PropXboxOffer(string filePath, uint titleId, dbType targetDBs, bool overwriteDMPSettings) 
		{
			string arguments = String.Format("-action:propxbox -file:{0} -titleid:{1:x} {2} {3} {4}", filePath, titleId,
				DbTypeToString(targetDBs), overwriteDMPSettings ? "-overwriteDMPSettings" : "", noTransaction ? "-noTransaction":"");
			if (_liveOfferProcess.Run(arguments) != 0) /* || (grep some kind of error string in output) */
				throw new LiveOfferException("Prop of Xbox offer failed.", _liveOfferProcess.Output);
		}

		/// <summary>
		/// Removes an offer from the Live service.  Requires an offerid.  This is only available on the
		/// debug build of LiveOffer.
		/// </summary>
		/// <param name="offerid">The offerId to remove.</param>
		public void NukeOffer(ulong offerid) {
			string arguments = String.Format("-action:nukeOffer -offerid:{0:x}", offerid);
			if (_liveOfferProcess.Run(arguments) != 0) /* || (grep some kind of error string in output) */
				throw new LiveOfferException("Prop of Xbox offer failed.", _liveOfferProcess.Output);
		}

		/// <summary>
		/// Removes all offers from the Live service under a certain title.  Requires a titleid.  This
		/// is only available on the debug build of LiveOffer.
		/// </summary>
		/// <param name="titleid">The titleId whose offers will be removed.</param>
		public void NukeAllOffers(uint titleid) {
			string arguments = String.Format("-action:nukeAllOffers -titleid:{0:x}", titleid);
			if (_liveOfferProcess.Run(arguments) != 0) /* || (grep some kind of error string in output) */
				throw new LiveOfferException("Prop of Xbox offer failed.", _liveOfferProcess.Output);
		}
		//automation for "nukealloffersforalltitles" is deliberately not included"
	}

	public class LiveOfferException : ProcessException
	{
		public LiveOfferException() : base("LiveOffer") {}
		public LiveOfferException(string message) : base("LiveOffer", message) {}
		public LiveOfferException(string message, Exception innerException) : base("LiveOffer", message, innerException) {}
		public LiveOfferException(string message, string output) : base("LiveOffer", message, output) {}
		public LiveOfferException(string message, string output, Exception innerException) :
			base("LiveOffer", message, output, innerException) {}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup\ClientTools\LiveTitle.cs ===
using System;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml;
using System.Xml.Serialization;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.STFTools.ConfigFiles;
using xonline.common.config;
using xonline.common.protocol;

namespace ServerTestFramework.STFTools
{
    /// <summary>
    /// Utility class for running the LiveTitle tool.
    /// </summary>
    public class LiveTitle
    {
        const string DefaultLiveTitlePath = "D:\\webroot\\xbltools";

        private string _ltcPath = "";
        private string _xlastPath = "";
        private string _xscPath = "";
        private string _xboxPath = "";
        private string _xmsPath = "";
        private string _marketplacePath = "";
        private string _lbServer = "";
        private string _matchServers = "";
        private ProcessWrapper _liveTitleProcess;
        private Report _report;

        public LiveTitle()
        {
            _liveTitleProcess = new ProcessWrapper("LiveTitle", Path.Combine(DefaultLiveTitlePath, "LiveTitle.exe"));
            _liveTitleProcess.SetEnvironmentVariable("XBL_CONFIG_SERVER", Global.CurrentEnvironment.NpdbIp);
            _liveTitleProcess.Verbose = true;
            _report = new Report("LiveTitle");

            try
            {
                string [] servers = Global.XEnv.GetServerListByInterface(Interface.lbsvr);
                if (servers.Length > 0)
                {
                    _lbServer = servers[0];
                }
                else
                {
                    _report.Warn("The leaderboard server list is empty!");
                }

                servers = Global.XEnv.GetServerListByInterface(Interface.xmatch);
                if (servers.Length > 0)
                {
                    _matchServers = servers[0];
                }
                else
                {
                    _report.Warn("The matchmaking server list is empty!");
                }
            }
            catch (Exception e)
            {
                _report.Error("Exception while populating server list: " + e.Message);
            }
        }

        public LiveTitle(string liveTitlePath) : this()
        {
            LiveTitlePath = liveTitlePath;
        }

        /// <summary>
        /// Gets or sets the fully-qualified name of the LiveTitle executable.
        /// </summary>
        public string LiveTitlePath
        {
            get { return _liveTitleProcess.ExecutablePath; }
            set
            {
                _liveTitleProcess.ExecutablePath = Path.GetFullPath(value);
                _liveTitleProcess.WorkingDirectory = Path.GetDirectoryName(_liveTitleProcess.ExecutablePath);
            }
        }

        /// <summary>
        /// Gets or sets the working directory for LiveTitle
        /// </summary>
        public string WorkingDirectory
        {
            get { return _liveTitleProcess.WorkingDirectory; }
            set
            {
                if (value != null)
                {
                    _liveTitleProcess.WorkingDirectory = Path.GetFullPath(value);
                }
                else
                {
                    _liveTitleProcess.WorkingDirectory = null;
                }
            }
        }

        /// <summary>
        /// Gets or sets the fully-qualified name of the LTC file used during title 
        /// deployment.
        /// </summary>
        public string LTCPath
        {
            get { return _ltcPath; }
            set
            {
                if (value != null)
                {
                    _ltcPath = Path.GetFullPath(value);
                }
                else
                {
                    _ltcPath = "";
                }
            }
        }

        /// <summary>
        /// Xbox 360 LTC file creation and title deployment.
        /// </summary>
        public string XlastPath
        {
            get { return _xlastPath; }
            set
            {
                if (value != null)
                {
                    _xlastPath = Path.GetFullPath(value);
                }
                else
                {
                    _xlastPath = "";
                }
            }
        }

        /// <summary>
        /// Gets or sets the fully-qualified name of the Marketplace file used to deploy a Marketplace-only title.
        /// </summary>
        public string MarketplacePath
        {
            get { return _marketplacePath; }
            set
            {
                if (value != null)
                {
                    _marketplacePath = Path.GetFullPath(value);
                }
                else
                {
                    _marketplacePath = "";
                }
            }
        }

        /// <summary>
        /// Gets or sets the fully-qualified name of the XSC file used during Xbox1 LTC 
        /// file creation and title deployment.
        /// </summary>
        public string XSCPath
        {
            get { return _xscPath; }
            set
            {
                if (value != null)
                {
                    _xscPath = Path.GetFullPath(value);
                }
                else
                {
                    _xscPath = "";
                }
            }
        }

        /// <summary>
        /// Gets or sets the fully-qualified name of the XBOX file used during Xbox1 LTC 
        /// file creation and title deployment.
        /// </summary>
        public string XBOXPath
        {
            get { return _xboxPath; }
            set
            {
                if (value != null)
                {
                    _xboxPath = Path.GetFullPath(value);
                }
                else
                {
                    _xboxPath = "";
                }
            }
        }

        /// <summary>
        /// Gets or sets the fully-qualified name of the XMS file used during Xbox1 title 
        /// deployment (optional).
        /// </summary>
        public string XMSPath
        {
            get { return _xmsPath; }
            set
            {
                if (value != null)
                {
                    _xmsPath = Path.GetFullPath(value);
                }
                else
                {
                    _xmsPath = "";
                }
            }
        }

        /// <summary>
        /// Gets or sets the leaderboard server used during LTC file creation.
        /// </summary>
        public string LeaderboardServer
        {
            get { return _lbServer; }
            set { _lbServer = value; }
        }

        /// <summary>
        /// Gets or sets the semi-colon delimited list of match servers used during LTC 
        /// file creation.
        /// </summary>
        public string MatchServers
        {
            get { return _matchServers; }
            set { _matchServers = value; }
        }

        /// <summary>
        /// Gets the output text from the most recent run of LiveTitle.
        /// </summary>
        public string Output
        {
            get { return _liveTitleProcess.Output; }
        }

        /// <summary>
        /// Exposes the Execution Timeout value for the underlying Process wrapper.
        /// </summary>
        public int ExecutionTimeout
        {
            get { return _liveTitleProcess.ExecutionTimeout; }
            set { _liveTitleProcess.ExecutionTimeout = value; }
        }

        /// <summary>
        /// Runs LiveTitle to create an LTC file for an Xbox 360 title.
        /// </summary>
        public void CreateXbox360LTCFile()
        {
            CreateXbox360LTCFile(0, 0);
        }

        /// <summary>
        /// Runs LiveTitle with a title id and a disc id to create an LTC file for an Xbox 360 title.
        /// </summary>
        /// <param name="titleId">Title ID to specify with the /titleid parameter. Optional.</param>
        /// <param name="discId">Disc ID to specify with the /discid parameter. Optional.</param>
        public void CreateXbox360LTCFile(uint titleId, uint discId)
        {
            int exitCode;
            StringBuilder arguments = new StringBuilder();
            
            arguments.AppendFormat("/livetitledefault /xlastpath:{0} /lbs:{1} /matchsvr:{2}",
                _xlastPath, _lbServer, _matchServers);
            if (titleId != 0)
            {
                arguments.AppendFormat(" /titleid:0x{0:x}", titleId);
            }

            if (discId != 0)
            {
                arguments.AppendFormat(" /discid:0x{0:x}", discId);
            }

            exitCode = _liveTitleProcess.Run(arguments.ToString());
            if (exitCode == 0)
            {
                _ltcPath = GetLTCPath(_liveTitleProcess.Output);
            }
            else
            {
                throw new LiveTitleException("LiveTitle failed to create the LTC file.", _liveTitleProcess.Output);
            }
        }

        /// <summary>
        /// DeployXbox360Title will run LiveTitle with the /deploy command-line argument.  
        /// If the
        /// LTCPath property does not point to an existing LTC file, then 
        /// CreateXbox360LTCFile
        /// will be called first to generate the LTC file before trying to deploy.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <param name="deployImages">
        /// Flag indicating whether the /images argument should appear on the command 
        /// line.
        /// It is highly recommended that this be set to True for initial deployments.
        /// </param>
        /// <param name="contentUpdate">
        /// Flag indicating whether the /contentupdate argument should be added to the 
        /// command line.
        /// </param>
        /// <param name="version">
        /// Initial version of the title.
        /// </param>
        public void DeployXbox360Title(uint titleId, bool deployImages, bool contentUpdate, uint version)
        {
            int exitCode;
            StringBuilder arguments = new StringBuilder();
            
            // Make sure the LTC file exists - if not, create one
            if (!File.Exists(_ltcPath))
            {
                CreateXbox360LTCFile(0, 0);
            }

            arguments.AppendFormat("/deploy /xlastpath:{0} /ltcpath:{1}", _xlastPath, _ltcPath);
            if (deployImages)
            {
                arguments.Append(" /images");
            }
            if (contentUpdate)
            {
                arguments.Append(" /contentupdate");
            }
            arguments.AppendFormat(" /version:0x{0:X8}", version);

            exitCode = _liveTitleProcess.Run(arguments.ToString());
            if (exitCode != 0)
            {
                throw new LiveTitleException("Xbox 360 Title deployment failed.", _liveTitleProcess.Output);
            }

            // Validate the data has made it into NPDB
            ValidateTitleData(titleId);
        }

        /// <summary>
        /// Deploys an Xbox 360 title without the optional /version parameter.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <param name="deployImages">Images parameter flag</param>
        /// <param name="contentUpdate">Content Update parameter flag</param>
        public void DeployXbox360Title(uint titleId, bool deployImages, bool contentUpdate)
        {
            int exitCode;
            StringBuilder arguments = new StringBuilder();

            // Make sure the LTC file exists - if not, create one
            if (!File.Exists(_ltcPath))
            {
                CreateXbox360LTCFile(0, 0);
            }

            arguments.AppendFormat("/deploy /xlastpath:{0} /ltcpath:{1}", _xlastPath, _ltcPath);
            if (deployImages)
            {
                arguments.Append(" /images");
            }
            if (contentUpdate)
            {
                arguments.Append(" /contentupdate");
            }

            exitCode = _liveTitleProcess.Run(arguments.ToString());
            if (exitCode != 0)
            {
                throw new LiveTitleException("Xbox 360 Title deployment failed.", _liveTitleProcess.Output);
            }

            // Validate the data has made it into NPDB
            ValidateTitleData(titleId);
        }

        /// <summary>
        /// Deploys an Xbox 360 title with images.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        public void DeployXbox360Title(uint titleId)
        {
            DeployXbox360Title(titleId, true, false);
        }

        /// <summary>
        /// Creates an LTC file for an Xbox1 title.
        /// </summary>
        public void CreateXbox1LTCFile()
        {
            int exitCode;
            StringBuilder arguments = new StringBuilder();

            arguments.AppendFormat("/xboxdefault /xboxpath:{0} /lbs:{1}", _xboxPath, _lbServer);
            if (_xscPath.Length > 0)
            {
                arguments.AppendFormat(" /xscpath:{0}", _xscPath);
            }

            if (_matchServers != null && _matchServers.Length > 0)
            {
                arguments.AppendFormat(" /matchsvr:{0}", _matchServers);
            }

            exitCode = _liveTitleProcess.Run(arguments.ToString());
            if (exitCode == 0)
            {
                _ltcPath = GetLTCPath(_liveTitleProcess.Output);
            }
            else
            {
                throw new LiveTitleException("LiveTitle failed to create the LTC file.", _liveTitleProcess.Output);
            }
        }

        /// <summary>
        /// Deploys an Xbox1 title, creating the default LTC file, if needed.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        public void DeployXbox1Title(uint titleId)
        {
            if (!File.Exists(_ltcPath))
            {
                CreateXbox1LTCFile();
            }

            StringBuilder arguments = new StringBuilder();
            arguments.AppendFormat("/deployxbox /xboxpath:{0} /ltcpath:{1}", _xboxPath, _ltcPath);
            if (_xscPath.Length > 0)
            {
                arguments.AppendFormat(" /xscpath:{0}", _xscPath);
            }
            if (_xmsPath.Length > 0)
            {
                arguments.AppendFormat(" /xmspath:{0}", _xmsPath);
            }

            if (_liveTitleProcess.Run(arguments.ToString()) != 0)
            {
                throw new LiveTitleException("Xbox1 title deployment failed.", _liveTitleProcess.Output);
            }

            // Verify the data made it into NPDB
            ValidateTitleData(titleId);
        }
        public void DeployXbox1Title(uint titleId, uint version)
        {
            if (!File.Exists(_ltcPath))
            {
                CreateXbox1LTCFile();
            }

            StringBuilder arguments = new StringBuilder();
            arguments.AppendFormat("/deployxbox /xboxpath:{0} /ltcpath:{1}", _xboxPath, _ltcPath);
            if (_xscPath.Length > 0)
            {
                arguments.AppendFormat(" /xscpath:{0}", _xscPath);
            }
            if (_xmsPath.Length > 0)
            {
                arguments.AppendFormat(" /xmspath:{0}", _xmsPath);
            }
            arguments.AppendFormat(" /version:0x{0:X8}", version);

            if (_liveTitleProcess.Run(arguments.ToString()) != 0)
            {
                throw new LiveTitleException("Xbox1 title deployment failed.", _liveTitleProcess.Output);
            }

            // Verify the data made it into NPDB
            ValidateTitleData(titleId);
        }

        /// <summary>
        /// Deploys an Xbox 360 Marketplace-only title.
        /// </summary>
        /// <param name="titleId">Title Id</param>
        /// <param name="images">
        /// Flag indicating whether the /images parameter should appear on the command line.
        /// </param>
        public void DeployMarketplaceOnlyTitle(uint titleId, bool images)
        {
            StringBuilder arguments = new StringBuilder();
            arguments.AppendFormat("/deploy /marketplacepath:{0}", _marketplacePath);
            if (images)
            {
                arguments.Append(" /images");
            }

            if (_liveTitleProcess.Run(arguments.ToString()) != 0)
            {
                throw new LiveTitleException("Marketplace-only title deployment failed.", _liveTitleProcess.Output);
            }
        }

        /// <summary>
        /// Locks the game configuration for an Xbox 360 title.
        /// </summary>
        public void LockTitle()
        {
            if (_liveTitleProcess.Run(String.Format("/lock /xlastpath:{0}", _xlastPath)) != 0)
            {
                throw new LiveTitleException("Locking " + _xlastPath + " failed.", _liveTitleProcess.Output);
            }
        }

        /// <summary>
        /// Reports the existing versions for the specified title id.
        /// </summary>
        /// <param name="titleId">The title id</param>
        /// <returns>An array of version strings in the form "base,update,beta"</returns>
        public string [] ReportTitleVersion(uint titleId)
        {
            string [] baseVersions = null;
            Regex r = new Regex(titleId.ToString() + "( )+[0-9]+( )+[0-9]+( )+[0-9]+");
            int i = 0;

            if (_liveTitleProcess.Run(String.Format("/reportver /titleid:0x{0:X}", titleId)) == 0)
            {
                MatchCollection matches = r.Matches(_liveTitleProcess.Output);
                baseVersions = new string[matches.Count];
                foreach (Match row in matches)
                {
                    string[] version = row.Value.Split(new char[1] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
                    baseVersions[i++] = String.Format("{0}:{1},{2},{3}", version[0], version[1], version[2], version[3]);
                }
            }
            else
            {
                throw new LiveTitleException("Version reporting failed.", _liveTitleProcess.Output);
            }

            return baseVersions;
        }

        /// <summary>
        /// Adds a base version entry to UODB for the specified title.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <param name="baseVersion">New base version to add for this title</param>
        /// <param name="consoleType">The console type. May be Xbox1, Xenon, or PC</param>
        public void AddTitleBaseVersion(uint titleId, uint baseVersion, ConsoleTypeEnum consoleType)
        {
            if (_liveTitleProcess.Run(String.Format("/addbasever /titleid:0x{0:x} /version:0x{1:x} /platform:{2}",
                titleId, baseVersion, consoleType.ToString())) != 0)
            {
                throw new LiveTitleException("Adding a base version failed.", _liveTitleProcess.Output);
            }
        }

        /// <summary>
        /// Deletes a base version entry from UODB for the specified title.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <param name="baseVersion">Base version to remove</param>
        /// <param name="consoleType">The console type. May be Xbox1, Xenon, or PC</param>
        public void DeleteTitleBaseVersion(uint titleId, uint baseVersion, ConsoleTypeEnum consoleType)
        {
            if (_liveTitleProcess.Run(String.Format("/delbasever /titleid:0x{0:x} /version:0x{1:x} /platform:{2}",
                titleId, baseVersion, consoleType.ToString())) != 0)
            {
                throw new LiveTitleException("Deleting a base version failed.", _liveTitleProcess.Output);
            }
        }

        /// <summary>
        /// Adds a base version entry to UODB for the specified title.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <param name="baseVersion">New base version to add for this title</param>
        /// <param name="consoleType">The console type. May be Xbox1, Xenon, or PC</param>
        public static void AddBaseVersion(uint titleId, uint version, ConsoleTypeEnum consoleType)
        {
            ProcessWrapper liveTitle = new ProcessWrapper("LiveTitle", LiveTitle.DefaultLiveTitlePath);
            if (liveTitle.Run(String.Format("/delbasever /titleid:0x{0:x} /version:0x{1:x} /platform:{2}",
                titleId, version, consoleType.ToString())) != 0)
            {
                throw new LiveTitleException("Deleting a base version failed.", liveTitle.Output);
            }
        }

        /// <summary>
        /// Deletes a base version entry from UODB for the specified title.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <param name="baseVersion">Base version to remove</param>
        /// <param name="consoleType">The console type. May be Xbox1, Xenon, or PC</param>
        public static void DeleteBaseVersion(uint titleId, uint version, ConsoleTypeEnum consoleType)
        {
            ProcessWrapper liveTitle = new ProcessWrapper("LiveTitle", LiveTitle.DefaultLiveTitlePath);
            if (liveTitle.Run(String.Format("/delbasever /titleid:0x{0:x} /version:0x{1:x} /platform:{2}",
                titleId, version, consoleType.ToString())) != 0)
            {
                throw new LiveTitleException("Deleting a base version failed.", liveTitle.Output);
            }
        }

        /// <summary>
        /// Props a title.  If no path is specified it will be copied from titlevault.
        /// </summary>
        public static void PropTitle(uint titleID, uint version, AuthContext.ClientTypes clientType)
        {
            PropTitle(titleID, version, clientType, null);
        }
        public static void PropTitle(uint titleID, uint version, AuthContext.ClientTypes clientType, string filePath)
        {
            //fix path
            string titleStringNo0x = String.Format("{0:X8}", titleID);

            if (filePath == null || filePath.Length == 0)
            {
                // Retrieve the path to the current environment's Titlevault
                filePath = Config.GetSetting(Setting.titlevault_root);
                if (filePath == null || filePath.Length == 0)
                {
                    throw new LiveTitleException("Unable to get the path to the TitleVault in the " + Global.CurrentEnvironment.Environment + " environment.");
                }
                filePath = Path.Combine(filePath, titleStringNo0x);
            }

            // Check the existence of this title's directory in Titlevault
            if (!Directory.Exists(filePath))
            {
                throw new LiveTitleException("No files exist in the Titlevault for title id 0x" + titleStringNo0x);
            }

            // Copy the title files to a local temp directory (because you're not allowed to prop from Titlevault)
            string tempTitlePath = "LiveTitleTempFiles\\title\\" + titleStringNo0x + "\\";
            System.IO.Directory.CreateDirectory(tempTitlePath);
            int numCopied = 0;
            foreach (string fname in System.IO.Directory.GetFiles(filePath))
            {
                string baseFName = System.IO.Path.GetFileName(fname);
                string srcFile = filePath + "\\" + baseFName;
                string dstFile = tempTitlePath + baseFName;
                //Global.RO.Debug("copying file: "+srcFile+" TO "+dstFile);
                System.IO.File.Copy(srcFile, dstFile, true);
                ++numCopied;
            }
            if (numCopied == 0)
            {
                throw new LiveTitleException("Could not find files for title " + titleStringNo0x + " to prop from " + filePath);
            }
            else
            {
                Global.RO.Debug("Copied " + numCopied + " files for title " + titleStringNo0x + " to a local temp store.");
            }

            //deploy it
            LiveTitle lt = new LiveTitle();
            lt.LTCPath = tempTitlePath + titleStringNo0x + ".ltc";
            lt.XlastPath = tempTitlePath + titleStringNo0x + ".xlast";
            //lt.XSCPath=tempTitlePath+titleStringNo0x+".xsc";
            lt.XBOXPath = tempTitlePath + titleStringNo0x + ".xbox";
            lt.XMSPath = tempTitlePath + titleStringNo0x + ".xms";

            if (clientType == AuthContext.ClientTypes.Xenon)
            {
                lt.DeployXbox360Title(titleID, true, true, version);
            }
            else if (clientType == AuthContext.ClientTypes.Xbox)
            {
                lt.DeployXbox1Title(titleID, version);
            }
            else if (clientType == AuthContext.ClientTypes.Panorama)
            {
                lt.DeployXbox360Title(titleID, true, true, version);
            }
            else
            {
                throw new LiveTitleException("Unhandled platform type specified when trying to deploy title " + titleStringNo0x);
            }

            //
            Global.RO.Debug("Propped title 0x" + titleStringNo0x + " version " + version + ".");
        }

        /// <summary>
        /// Checks if a title is propped.
        /// </summary>
        public static bool CheckIfTitleIsPropped(uint titleID)
        {
            bool isPropped=false;
            try
            {
                string query="select count(*) from t_titles WHERE i_title_id="+(int)titleID;
                int rows=(int)UodbWS.ExecuteSQLSelectCount(query);
                if (rows!=0) isPropped=true;
            }
            catch (Exception e)
            {
                Global.RO.Error("UodbWS.ExecuteSQLSelectCount threw while trying to check title "+titleID+": "+e.Message+"\nWill assume this indicates that it is not propped.");
            }
            return isPropped;
        }
        public static bool CheckIfTitleIsPropped(uint titleID, uint version)
        {
            //see if the title is there at all
            bool isPropped=CheckIfTitleIsPropped(titleID);            

            //if it is, is this version propped?
            if (isPropped)
            {
                try
                {
                    string query="select count(*) from t_title_versions WHERE i_title_id="+(int)titleID+" and i_base_version="+(int)version;
                    int rows=(int)UodbWS.ExecuteSQLSelectCount(query);
                    if (rows==0) isPropped=false;
                }
                catch (Exception e)
                {
                    Global.RO.Error("UodbWS.ExecuteSQLSelectCount threw while trying to check version "+version+" of title "+titleID+": "+e.Message+"\nWill assume this indicates that it is not propped.");
                    isPropped=false;
                }
            }

            return isPropped;
        }

        /// <summary>
        /// Checks if a title is propped, and if not, props it.  If no path is specified it will be copied from stressnet titlevault.
        /// </summary>
        public static void CheckAndPropTitle(uint titleID, uint version, AuthContext.ClientTypes clientType, string filePath)
        {
            if (!CheckIfTitleIsPropped(titleID,version))
            {
                Global.RO.Debug("Title 0x{0:X8} version "+version+" is not propped.  Will try to prop it.", titleID);
                PropTitle(titleID,version,clientType,filePath);
            }
            else
            {
                Global.RO.Debug("Title 0x{0:X8} version "+version+" is already propped.", titleID);
            }
        }

        /// <summary>
        /// Performs basic validation that the title deployment succeeded.
        /// </summary>
        private void ValidateTitleData(uint titleId)
        {
            NpdbUtility npdb = new NpdbUtility();
            LiveTitleConfigRow ltcRow;
            GameConfigRow gcRow;

            npdb.ConnectToServer();
            try
            {
                npdb.GetGameConfig(titleId, out gcRow);
                ltcRow = npdb.GetLiveTitleConfig(titleId);

                if (gcRow == null || ltcRow == null)
                {
                    throw new LiveTitleException("Unable to get title data from NPDB.", _liveTitleProcess.Output);
                }
            }
            catch (DatabaseException dEx)
            {
                throw new LiveTitleException("Unable to verify title data.", _liveTitleProcess.Output, dEx);
            }
            finally
            {
                npdb.Close();
            }
        }

        private string GetLTCPath(string liveTitleOutput)
        {
            Regex reg = new Regex("[0-9a-fA-F]{8}_ltc.xml");
            Match match = reg.Match(liveTitleOutput);
            string ltcPath = "";

            if (match.Success)
            {
                // The LTC file is created in the current directory

                ltcPath = Path.Combine(_liveTitleProcess.WorkingDirectory, match.Value);
                if (!File.Exists(ltcPath))
                {
                    throw new LiveTitleException("Unable to find the LTC file at " + ltcPath);
                }
            }
            else
            {
                throw new LiveTitleException("Unable to find the LTC file name in the LiveTitle output.",
                    liveTitleOutput);
            }

            return ltcPath;
        }
    }

    public class LiveTitleException : ProcessException
    {
        public LiveTitleException() : base("LiveTitle") {}
        public LiveTitleException(string message) : base("LiveTitle", message) {}
        public LiveTitleException(string message, Exception innerException) : base("LiveTitle", message, innerException) {}
        public LiveTitleException(string message, string liveTitleOutput) : base("LiveTitle", message, liveTitleOutput) {}
        public LiveTitleException(string message, string liveTitleOutput, Exception innerException) :
            base("LiveTitle", liveTitleOutput, message, innerException) {}

        public override string Message
        {
            get { return string.Format("{0}\r\nLiveTitle Output:\r\n{1}\r\nEnd LiveTitle Output\r\n",
                      base.Message, base.ProcessOutput); }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup\ClientTools\LiveStats.cs ===
using System;
using System.IO;
using System.Diagnostics;
using System.Text;
using System.Collections;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.STFTools
{
    /// <summary>
    /// Utility class for running the LiveStats tool.
    /// </summary>
    public class LiveStats
    {
	    // Some commands allow the leaderboard id to be "ALL".
	    // Use this constant to specify that value.
	    public const int ALL_LEADERBOARDS = -1;
        const string DefaultLiveStatsPath = "D:\\webroot\\xbltools";

        private ProcessWrapper _liveStatsProcess;
        private Report _report;

		public LiveStats()
		{
            _liveStatsProcess = new ProcessWrapper("LiveStats", Path.Combine(DefaultLiveStatsPath, "LiveStats.exe"));
            _report = new Report("LiveStats");
        }

		public LiveStats(string liveStatsPath) : this()
		{
			_liveStatsProcess.ExecutablePath = Path.GetFullPath(liveStatsPath);
		}

		/// <summary>
		/// Gets or sets the fully-qualified name of the LiveStats executable.
		/// </summary>
		public string LiveStatsPath
		{
			get { return _liveStatsProcess.ExecutablePath; }
            set
            {
                _liveStatsProcess.ExecutablePath = Path.GetFullPath(value);
                _liveStatsProcess.WorkingDirectory = Path.GetDirectoryName(_liveStatsProcess.ExecutablePath);
            }
        }

        /// <summary>
        /// Gets or sets the working directory for LiveStats
        /// </summary>
        public string WorkingDirectory
        {
            get { return _liveStatsProcess.WorkingDirectory; }
            set
            {
                if (value != null)
                {
                    _liveStatsProcess.WorkingDirectory = Path.GetFullPath(value);
                }
                else
                {
                    _liveStatsProcess.WorkingDirectory = null;
                }
            }
        }

        /// <summary>
        /// Gets or sets the number of milliseconds to allow LiveStats to run before killing the process.
        /// </summary>
        public int Timeout
        {
            get { return _liveStatsProcess.ExecutionTimeout; }
            set { _liveStatsProcess.ExecutionTimeout = value; }
        }

        /// <summary>
        /// Gets the output text from the most recent run of LiveStats.
        /// </summary>
        public string Output
        {
            get { return _liveStatsProcess.Output; }
        }

		/// <summary>
		/// Deploys the leaderboards for an Xbox1 title.
		/// </summary>
		/// <param name="force">Flag indicating whether or not to include the /force argument.</param>
		public void DeployXbox1Leaderboard(uint titleId, bool force)
		{
			string arguments = String.Format("/deployxboxlb /titleid:0x{0:x8}", titleId);

			if (force)
				arguments += " /force";

			if (_liveStatsProcess.Run(arguments) != 0)
				throw new LiveStatsException("Deploying an Xbox1 leaderboard failed.", _liveStatsProcess.Output);
		}

		/// <summary>
		/// Deploys the leaderboards for an Xbox 360 title.
		/// </summary>
		/// <param name="force">Flag indicating whether or not to include the /force argument.</param>
		public void DeployXbox360Leaderboard(uint titleId, bool force)
		{
			string arguments = String.Format("/deploylb /titleid:0x{0:x8}", titleId);

			if (force)
				arguments += " /force";

			if (_liveStatsProcess.Run(arguments) != 0)
				throw new LiveStatsException("Deploying an Xbox 360 leaderboard failed.", _liveStatsProcess.Output);
		}

		/// <summary>
		/// Deletes the leaderboards from the Web DB and re-deploys them.
		/// </summary>
		public void DeployWebOnlyLeaderboard(uint titleId)
		{
			if (_liveStatsProcess.Run(String.Format("/deploywebdbonlylb /titleid:0x{0:x8}", titleId)) != 0)
				throw new LiveStatsException("Deploying to Web only failed.", _liveStatsProcess.Output);
		}

		/// <summary>
		/// Moves one or all leaderboards from one server to another.
		/// </summary>
		/// <param name="leaderboardId">
		/// ID of the leaderboard to move. Use the ALL_LEADERBOARDS constant to move all leaderboards.
		/// </param>
		/// <param name="sourceServer">
		/// The name of the server on which the leaderboard currently resides.
		/// </param>
		/// <param name="destServer">
		/// The name of the server to which the leaderboard will be moved.
		/// </param>
		public void MoveLeaderboard(uint titleId, int leaderboardId, string sourceServer, string destServer)
		{
			if (_liveStatsProcess.Run(String.Format("/movelb /titleid:0x{0:x8} /lbid:{1} /source:{2} /dest:{3}",
				titleId, (leaderboardId == ALL_LEADERBOARDS ? "ALL" : leaderboardId.ToString()),
				sourceServer, destServer)) != 0)
			{
				throw new LiveStatsException("Leaderboard move failed.", _liveStatsProcess.Output);
			}
		}

        /// <summary>
        /// Reports the leaderboard configuration for a title.
        /// </summary>
        /// <param name="leaderboardId">
        /// The ID of the leaderboard to report.
        /// </param>
        public string[] ReportConfiguration(uint titleId)
		{
            ArrayList lbArray = new ArrayList();
            string [] returnString;
            int stringEndLoc;

            if (_liveStatsProcess.Run(String.Format("/reportconfiguration /titleid:0x{0:x8}",
                titleId)) != 0)
            {
                throw new LiveStatsException("Report Configuration failed.", _liveStatsProcess.Output);
            }

            // Parse the output for the leaderboard information
            if (_liveStatsProcess.Output.IndexOf("No leaderboards are configured in NPDB for titleID") > 0)
                return null;
            string parseOutput = _liveStatsProcess.Output;
            if (parseOutput.IndexOf("ServerName") < 0)
            {
                // Couldn't find the list of leaderboards
                return null;
            }

            // Find the Start of the Leadboard List and End, We're includind the Column header bar for now. To remove just skip the first line.
            parseOutput = parseOutput.Substring(parseOutput.IndexOf("ServerName"));
            parseOutput = parseOutput.Substring(0, parseOutput.LastIndexOf("Succesfully Executed reportconfiguration") - 2); // -2 to remove the blank line at the end
            //_report.Debug("Leaderboard List:{0}{1}", Environment.NewLine, parseOutput);

            // Find the End of the first leaderboard line and start getting entries
            stringEndLoc = parseOutput.IndexOf(Environment.NewLine);
            while (stringEndLoc > 0) // Once the first char is new line we're at the end of the list or we're at the end
            {
                // Get the First line and add it to the array list
                lbArray.Add(parseOutput.Substring(0, stringEndLoc));
                //_report.Debug("Entry {0}: {1}", lbArray.Count, lbArray[lbArray.Count-1]);

                // Trim the First line out of the remaining string and get the next End of Line Char loc
                parseOutput = parseOutput.Substring(stringEndLoc + 2);
                stringEndLoc = parseOutput.IndexOf(Environment.NewLine);
            }

            returnString = (string []) lbArray.ToArray(typeof(string));
            return returnString;
		}

		/// <summary>
		/// Resets the data for a single leaderboard.
		/// </summary>
		/// <param name="leaderboardId">
		/// The ID of the leaderboard to reset.
		/// </param>
		public void ResetLeaderboard(uint titleId, int leaderboardId)
		{
			if (_liveStatsProcess.Run(String.Format("/resetlb /titleid:0x{0:x8} /lbid:{1}",
				titleId, (leaderboardId == ALL_LEADERBOARDS ? "ALL" : leaderboardId.ToString()))) != 0)
			{
				throw new LiveStatsException("Reset leaderboard failed.", _liveStatsProcess.Output);
			}
		}

		/// <summary>
		/// Resets the data for all leaderboards in the current title.
		/// </summary>
		public void ResetAllLeaderboards(uint titleId)
		{
			if (_liveStatsProcess.Run(String.Format("/resettitle /titleid:0x{0:x8}", titleId)) != 0)
				throw new LiveStatsException("Reset all leaderboards failed.", _liveStatsProcess.Output);
		}

		/// <summary>
		/// Deletes all stats data and leaderboard definitions for the current title.
		/// </summary>
		public void DeleteLeaderboards(uint titleId)
		{
			if (_liveStatsProcess.Run(String.Format("/deletetitle /titleid:0x{0:x8}", titleId)) != 0)
				throw new LiveStatsException("Delete leaderboards failed.", _liveStatsProcess.Output);
		}

		/// <summary>
		/// Reloads the Stats front door.
		/// </summary>
		public void ReloadFrontDoor()
		{
			if (_liveStatsProcess.Run("/reloadfrontdoor") != 0)
				throw new LiveStatsException("Reload front door failed.", _liveStatsProcess.Output);
		}

		/// <summary>
		/// Reloads the Web stats front door.
		/// </summary>
		public void ReloadWebStats()
		{
			if (_liveStatsProcess.Run("/reloadwebstats") != 0)
				throw new LiveStatsException("Reload web stats failed.", _liveStatsProcess.Output);
		}

        /// <summary>
        /// Sets up a clean clips CRON job for the specified Xbox360 title id
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <param name="hoursFromNow">The number of hours to wait before running the CRON job.</param>
        public void CleanClip(uint titleId, int hoursFromNow)
        {
            if (_liveStatsProcess.Run(string.Format("/cleanclip /titleid:0x{0:x8} /hoursfromnow:{1}",
                titleId, hoursFromNow)) != 0)
            {
                throw new LiveStatsException("CleanClip failed.", _liveStatsProcess.Output);
            }
        }

        /// <summary>
        /// Sets up a clean clips CRON job for the specified Xbox1 title id
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <param name="hoursFromNow">The number of hours to wait before running the CRON job.</param>
        public void CleanXboxClip(uint titleId, int hoursFromNow)
        {
            if (_liveStatsProcess.Run(string.Format("/cleanxboxclip /titleid:0x{0:x8} /hoursfromnow:{1}",
                titleId, hoursFromNow)) != 0)
            {
                throw new LiveStatsException("CleanXboxClip failed.", _liveStatsProcess.Output);
            }
        }

        public void SetToReadOnly(uint titleId, int leaderboardId, string server)
        {
            StringBuilder args = new StringBuilder();

            args.AppendFormat("/settoreadonly /titleid:0x{0:x8} /lbid:{1} /server:{2}", titleId,
                leaderboardId == LiveStats.ALL_LEADERBOARDS ? "ALL" : leaderboardId.ToString(), server);
            if (_liveStatsProcess.Run(args.ToString()) != 0)
            {
                throw new LiveStatsException("SetToReadOnly failed.", _liveStatsProcess.Output);
            }
        }

        public void SetToReadWrite(uint titleId, int leaderboardId, string server)
        {
            StringBuilder args = new StringBuilder();

            args.AppendFormat("/settoreadwrite /titleid:0x{0:x8} /lbid:{1} /server:{2}", titleId,
                leaderboardId == LiveStats.ALL_LEADERBOARDS ? "ALL" : leaderboardId.ToString(), server);
            if (_liveStatsProcess.Run(args.ToString()) != 0)
            {
                throw new LiveStatsException("SetToReadWrite failed.", _liveStatsProcess.Output);
            }
        }

        public void Unload(uint titleId, int leaderboardId, string server)
        {
            StringBuilder args = new StringBuilder();

            args.AppendFormat("/unload /titleid:0x{0:x8} /lbid:{1} /server:{2}", titleId,
                leaderboardId == LiveStats.ALL_LEADERBOARDS ? "ALL" : leaderboardId.ToString(), server);
            if (_liveStatsProcess.Run(args.ToString()) != 0)
            {
                throw new LiveStatsException("Unload failed.", _liveStatsProcess.Output);
            }
        }

        public void Load(uint titleId, int leaderboardId, string server)
        {
            StringBuilder args = new StringBuilder();

            args.AppendFormat("/load /titleid:0x{0:x8} /lbid:{1} /server:{2}", titleId,
                leaderboardId == LiveStats.ALL_LEADERBOARDS ? "ALL" : leaderboardId.ToString(), server);
            if (_liveStatsProcess.Run(args.ToString()) != 0)
            {
                throw new LiveStatsException("Load failed.", _liveStatsProcess.Output);
            }
        }
	}

	public class LiveStatsException : ProcessException
	{
		public LiveStatsException() : base("LiveStats") {}
		public LiveStatsException(string message) : base("LiveStats", message) {}
		public LiveStatsException(string message, Exception innerException) : base("LiveStats", message, innerException) {}
		public LiveStatsException(string message, string output) : base("LiveStats", message, output) {}
		public LiveStatsException(string message, string output, Exception innerException) :
			base("LiveStats", message, output, innerException) {}

        public override string Message
        {
            get { return string.Format("{0}\r\nLiveStats Output:\r\n{1}\r\nEnd LiveStats Output\r\n",
                      base.Message, base.ProcessOutput); }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup\ClientTools\QuickEnforce.cs ===
using System;
using System.IO;
using ServerTestFramework.Utilities;
namespace ServerTestFramework.STFTools
{
	/// <summary>
	/// Utility class for running the QuickEnforce tool.
	/// </summary>
	public class QuickEnforce
	{
		private ProcessWrapper _quickEnforceProcess;
		const string DefaultQuickEnforcePath = "D:\\webroot\\xbltools";  //where is it?

		public QuickEnforce()
		{
			_quickEnforceProcess = new ProcessWrapper("QuickEnforce", DefaultQuickEnforcePath);

		}
		public QuickEnforce(string quickEnforcePath) : this()
		{
			_quickEnforceProcess.ExecutablePath = Path.GetFullPath(quickEnforcePath);
		}

        public void EnforceUsers(string SQLServer, string EnforcementDB, string reportEmailAddy,
							string SMTP, int delayBetweenEnforcements, string custURL,
							string certPath) 
		{
			string commandArgs = "";
			commandArgs += String.Format("/SQLE {0}", SQLServer);
			commandArgs += String.Format(" /DBEN {0}", EnforcementDB);
			commandArgs += String.Format(" /MAIL {0}", reportEmailAddy);
			commandArgs += String.Format(" /SMTP {0}", SMTP);
			commandArgs += String.Format(" /WAIT {0}", delayBetweenEnforcements);
			commandArgs += String.Format(" /CURL {0}", custURL);
			commandArgs += String.Format(" /CERT {0}", certPath);
			if (_quickEnforceProcess.Run(commandArgs) != 0)
				throw new LiveStatsException("QuickEnforce failed.", _quickEnforceProcess.Output);
		}

	}

	
	public class QuickEnforceException : ProcessException
	{
		public QuickEnforceException() : base("QuickEnforce") {}
		public QuickEnforceException(string message) : base("QuickEnforce", message) {}
		public QuickEnforceException(string message, Exception innerException) : base("QuickEnforce", message, innerException) {}
		public QuickEnforceException(string message, string QuickEnforceOutput) : base("QuickEnforce", message, QuickEnforceOutput) {}
		public QuickEnforceException(string message, string QuickEnforceOutput, Exception innerException) :
			base("QuickEnforce", QuickEnforceOutput, message, innerException) {}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup\ClientTools\SPUT.cs ===
using System;
using System.IO;
using System.Diagnostics;
using System.Text;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.STFTools
{
	/// <summary>
	/// Utility class for running SPUT.
	/// </summary>
	public class SPUT
	{
        const string DefaultSPUTPath = "D:\\webroot\\xbltools";

        private ProcessWrapper _SPUTProcess;
        private string _csvFile = "";

        public SPUT()
		{
            _SPUTProcess = new ProcessWrapper("SPUT", Path.Combine(DefaultSPUTPath, "SPUT.exe"));
        }

        public SPUT(string toolPath) : this()
        {
        _SPUTProcess.ExecutablePath = Path.GetFullPath(toolPath);
        }

        /// <summary>
        /// Gets or sets path to SPUT
        /// </summary>
        public string SPUTPath
        {
            get { return _SPUTProcess.ExecutablePath; }
            set { _SPUTProcess.ExecutablePath = value; }
        }

        /// <summary>
        /// Gets or sets the CSV File to use when running SPUT.  Can be NULL.
        /// </summary>
        public string CSVFile
        {
            get { return _csvFile; }
            set { _csvFile = value; }
        }

        /// <summary>
        /// Gets the output text from the most recent run of SPUT.
        /// </summary>
        public string Output
        {
            get { return _SPUTProcess.Output; }
        }

        /// <summary>
        /// Writes the titleID for the specified serialNum to the table
        /// </summary>
        /// <param name="serialNum">The serial number of the Xbox</param>
        /// <param name="titleID">The title ID or value to set.  Must have length of 1,4 or 8.</param>
        public void ChangeTitleID(string serialNum, string titleID)
        {
            string args = String.Format("/serialNum:{0} /titleid:{1}", serialNum, titleID);
            if (_SPUTProcess.Run(args) != 0)
            {
                throw new SPUTException("SPUT Failed.", _SPUTProcess.Output);
            }
        }

        /// <summary>
        /// Lookup the titleID associated with an xbox.
        /// </summary>
        /// <param name="serialNum">The serial number of the Xbox</param>
        /// <returns>Output returned from SPUT.</returns>
        public string DumpTitleID(string serialNum)
        {
            string titleID;
            string args = String.Format("/serialNum:{0} /dump", serialNum);
            if (_SPUTProcess.Run(args) != 0)
            {
                throw new SPUTException("SPUT Failed.", _SPUTProcess.Output);
            }
            titleID = _SPUTProcess.Output;
            titleID = titleID.Substring(titleID.IndexOf(":")+1).Trim();
            return titleID;
        }

        /// <summary>
        /// Runs SPUT specifying CSV File
        /// </summary>
        /// <param name="fileName">CSV file to be used</param>
        public void RunSPUTFile(string fileName)
        {
            RunSPUTFile(fileName, null);
        }

        /// <summary>
        /// Runs SPUT specifying File that is set in CSVFIle Property
        /// </summary>
        public void RunSPUTFile()
        {
            RunSPUTFile(_csvFile, null);
        }

        /// <summary>
        /// Runs SPUT specifying File and TitleID to use
        /// </summary>
        /// <param name="fileName">CSV File of Serial numbers</param>
        /// <param name="titleID">Title ID to use or override</param>
        public void RunSPUTFile(string fileName, string titleID)
        {
            string args;
            if (titleID == null)
            {
                args = String.Format("/file:{0}", fileName);
            }
            else
            {
                args = String.Format("/file:{0} /titleid:{1}", fileName, titleID);
            }

            if (_SPUTProcess.Run(args) != 0)
            {
                throw new SPUTException("SPUT Failed.", _SPUTProcess.Output);
            }
        }

        /// <summary>
        /// Allows running SPUT with custom argument string.
        /// Mainly used for negative testing.
        /// </summary>
        /// <param name="arguments">Argument string to be used when calling SPUT.</param>
        public void RunSPUT(string arguments)
        {
            if (_SPUTProcess.Run(arguments) != 0)
            {
                throw new SPUTException("SPUT Failed.", _SPUTProcess.Output);
            }
        }

	}

    public class SPUTException : ProcessException
    {
        public SPUTException() : base("SPUT") {}
        public SPUTException(string message) : base("SPUT", message) {}
        public SPUTException(string message, Exception innerException) : base("SPUT", message, innerException) {}
        public SPUTException(string message, string output) : base("SPUT", message, output) {}
        public SPUTException(string message, string output, Exception innerException) :
            base("SPUT", message, output, innerException) {}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup\ClientTools\spac.cs ===
using System;
using System.IO;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.STFTools
{
    public enum SPACReturnCode
    {
        Success = 0,
        BadUsage,
        NonFatalError,
        FatalError
    };

	/// <summary>
	/// Utility class that runs the SPA Compiler (SPAC) tool.
	/// </summary>
	/// <remarks>
	/// Unlike many of the other tools, SPAC supports multiple return codes. Therefore, all the
	/// methods that execute SPAC will not raise exceptions on failure, but rather simply return
	/// the exit code from the tool itself. It is the caller's responsibility to check this code
	/// and take the appropriate action.
	/// </remarks>
	public class SPAC
	{
        const string DefaultSpacPath = @"D:\webroot\xbltools";

        private ProcessWrapper _spacProcess;
        private string _xlastPath;
        private string _headerFile;
        private string _spaFile;
        private string _configOverrideFile;
        private bool _noLogo;
        private bool _verbose;
        private bool _noSpa;
        private bool _noHeader;
        private string _unCompileOutFile;

        /// <summary>
        /// Creates a SPAC object and initializes the process wrapper to the default SPAC path.
        /// </summary>
		public SPAC()
		{
            _spacProcess = new ProcessWrapper("SPAC", Path.Combine(DefaultSpacPath, "spac.exe"));

            // Set the values for the default command line
            _noLogo = true;
            _verbose = true;
            _noSpa = false;
            _noHeader = false;
		}

        /// <summary>
        /// Gets or sets the full path of the SPAC executable.
        /// </summary>
        public string SpacPath
        {
            get { return _spacProcess.ExecutablePath; }
            set
            {
                _spacProcess.ExecutablePath = Path.GetFullPath(value);
                _spacProcess.WorkingDirectory = Path.GetDirectoryName(value);
            }
        }

        /// <summary>
        /// Gets or sets the name of the working directory under which SPAC will be run.
        /// </summary>
        public string WorkingDirectory
        {
            get { return _spacProcess.WorkingDirectory; }
            set
            {
                if (value != null)
                {
                    _spacProcess.WorkingDirectory = Path.GetFullPath(value);
                }
                else
                {
                    _spacProcess.WorkingDirectory = null;
                }
            }
        }

        /// <summary>
        /// Gets or sets the name of the XLAST file to compile.
        /// </summary>
        public string XlastPath
        {
            get { return _xlastPath; }
            set
            {
                if (value != null)
                {
                    _xlastPath = Path.GetFullPath(value);
                }
                else
                {
                    _xlastPath = null;
                }
            }
        }

        /// <summary>
        /// Gets or sets the optional name of the header file that SPAC outputs when compiling an XLAST file.
        /// </summary>
        public string HeaderFile
        {
            get { return _headerFile; }
            set
            {
                if (value != null)
                {
                    _headerFile = Path.GetFullPath(value);
                }
                else
                {
                    _headerFile = null;
                }
            }
        }

        /// <summary>
        /// Gets or sets the optional name of the SPA file that SPAC outputs when compiling an XLAST file.
        /// </summary>
        public string SpaFile
        {
            get { return _spaFile; }
            set
            {
                if (value != null)
                {
                    _spaFile = Path.GetFullPath(value);
                }
                else
                {
                    _spaFile = null;  
                }
            }
        }

        /// <summary>
        /// Gets or sets the optional name of a file containing configuration overrides.
        /// </summary>
        public string ConfigOverrideFile
        {
            get { return _configOverrideFile; }
            set
            {
                if (value != null)
                {
                    _configOverrideFile = Path.GetFullPath(value);
                }
                else
                {
                    _configOverrideFile = null;
                }
            }
        }

		
        /// <summary>
        /// Gets or sets the name of the decompiled output file 
        /// </summary>
        public string UncompileOutputFile
        {
            get { return _unCompileOutFile; }
            set
            {
                if (value != null)
                {
                    _unCompileOutFile = Path.GetFullPath(value);
                }
                else
                {
                    _unCompileOutFile = null;
                }
            }
        }


        /// <summary>
        /// Gets the output text of SPAC.
        /// </summary>
        public string Output
        {
            get { return _spacProcess.Output; }
        }

        /// <summary>
        /// Gets or sets the default value for the -nologo option.
        /// </summary>
        public bool NoLogo
        {
            get { return _noLogo; }
            set { _noLogo = value; }
        }

        /// <summary>
        /// Gets or sets the default value of the -verbose option.
        /// </summary>
        public bool Verbose
        {
            get { return _verbose; }
            set { _verbose = value; }
        }

        /// <summary>
        /// Gets or sets the default value of the -nospa option.
        /// </summary>
        public bool NoSpa
        {
            get { return _noSpa; }
            set { _noSpa = value; }
        }

        /// <summary>
        /// Gets or sets the default value of the -noh option.
        /// </summary>
        public bool NoHeader
        {
            get { return _noHeader; }
            set { _noHeader = value; }
        }

        /// <summary>
        /// Compiles an XLAST file using the default parameter values.
        /// </summary>
        /// <returns>
        /// One of the four possible SPAC return codes:
        ///     0       Success
        ///     1       Bad Usage
        ///     2       Non-Fatal Error
        ///     3       Fatal Error
        /// </returns>
        public SPACReturnCode Compile()
        {
            return Compile(_noLogo, _verbose, _noSpa, _noHeader);
        }

        /// <summary>
        /// Allows the default nospa and noh parameter values to be overridden when compiling an XLAST file.
        /// </summary>
        /// <param name="noSpa">Flag indicating whether or not a SPA file should be generated.</param>
        /// <param name="noHeader">Flag indicating whether or not a SPA.H file should be generated.</param>
        /// <returns>
        /// One of the four possible SPAC return codes:
        ///     0       Success
        ///     1       Bad Usage
        ///     2       Non-Fatal Error
        ///     3       Fatal Error
        /// </returns>
        public SPACReturnCode Compile(bool noSpa, bool noHeader)
        {
            return Compile(_noLogo, _verbose, noSpa, noHeader);
        }

        /// <summary>
        /// Allows all the default flag parameter values to be overridden when compiling an XLAST file.
        /// </summary>
        /// <param name="noLogo">Flag indicating whether the copyright message is printed when SPAC is run.</param>
        /// <param name="verbose">Flag specifying whether the compile output should be normal or verbose.</param>
        /// <param name="noSpa">Flag indicating whether or not a SPA file should be generated.</param>
        /// <param name="noHeader">Flag indicating whether or not a SPA.H file should be generated.</param>
        /// <returns>
        /// One of the four possible SPAC return codes:
        ///     0       Success
        ///     1       Bad Usage
        ///     2       Non-Fatal Error
        ///     3       Fatal Error
        /// </returns>
        public SPACReturnCode Compile(bool noLogo, bool verbose, bool noSpa, bool noHeader)
        {
            StringBuilder args = new StringBuilder();

            if (noLogo) args.Append("/nologo ");
            if (verbose) args.Append("/verbose ");
            if (noSpa) args.Append("/nospa ");
            if (noHeader) args.Append("/noh ");
            if (_spaFile != null && _spaFile.Length > 0) args.AppendFormat("/o {0} ", _spaFile);
            if (_headerFile != null && _headerFile.Length > 0) args.AppendFormat("/h {0} ", _headerFile);
            if (_configOverrideFile != null && _configOverrideFile.Length > 0) args.AppendFormat("/config {0} ", _configOverrideFile);

            args.Append(_xlastPath);

            return (SPACReturnCode)_spacProcess.Run(args.ToString());
        }

		
        /// <summary>
        /// UnCompiles a SPA file using the default parameter values.
        /// </summary>
        /// <returns>
        /// One of the four possible SPAC return codes:
        ///     0       Success
        ///     1       Bad Usage
        ///     2       Non-Fatal Error
        ///     3       Fatal Error
        /// </returns>
        public SPACReturnCode UnCompile()
        {
              StringBuilder args = new StringBuilder();

        	if (_spaFile != null && _spaFile.Length > 0) args.AppendFormat("/u {0} ", _spaFile);
		if (_unCompileOutFile != null && _unCompileOutFile.Length > 0) args.AppendFormat("/o {0}", _unCompileOutFile);
              return (SPACReturnCode)_spacProcess.Run(args.ToString());
        }


        /// <summary>
        /// Executes SPAC to output the XSD file it is using to validate XLAST files.
        /// </summary>
        /// <param name="xsdFile">Name of the XSD file to create.</param>
        /// <returns>
        /// One of the four possible SPAC return codes:
        ///     0       Success
        ///     1       Bad Usage
        ///     2       Non-Fatal Error
        ///     3       Fatal Error
        /// </returns>
        public SPACReturnCode OutputXSD(string xsdFile)
        {
            return (SPACReturnCode)_spacProcess.Run("/nologo /xsd " + xsdFile);
        }

        /// <summary>
        /// Reports the version information of a given SPA file.
        /// </summary>
        /// <param name="spaFile">Name of the SPA file for which version information is to be reported.</param>
        /// <returns>
        /// One of the four possible SPAC return codes:
        ///     0       Success
        ///     1       Bad Usage
        ///     2       Non-Fatal Error
        ///     3       Fatal Error
        /// 
        /// The version information will be found in the output text.
        /// </returns>
        public SPACReturnCode ReportSPAVersion(string spaFile)
        {
            return (SPACReturnCode)_spacProcess.Run("/nologo /u " + spaFile);
        }
	}
/*
    public class SPACException : ProcessException
    {
        public SPACException() : base("SPAC") {}
        public SPACException(string message) : base("SPAC", message) {}
        public SPACException(string message, Exception innerException) : base("SPAC", message, innerException) {}
        public SPACException(string message, string spacOutput) : base("SPAC", message, spacOutput) {}
        public SPACException(string message, string spacOutput, Exception innerException) :
            base("SPAC", spacOutput, message, innerException) {}

        public override string Message
        {
            get 
            {
                return string.Format("{0}\r\nSPAC Output:\r\n{1}\r\nEnd SPAC Output\r\n",
                      base.Message, base.ProcessOutput);
            }
        }

    }
*/
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup\ClientTools\MsgTool.cs ===
using System;
using System.IO;
using System.Diagnostics;
using System.Text;
using ServerTestFramework.Utilities;
using System.Collections;

namespace ServerTestFramework.STFTools
{
    /// <summary>
    /// Utility class for running MsgTool.
    /// </summary>
    public class MsgTool
    {
        const string DefaultMsgToolPath = @"D:\webroot\xbltools";

        private ProcessWrapper _MsgToolProcess;
        
        public MsgTool()
        {
            _MsgToolProcess = new ProcessWrapper("MsgTool", Path.Combine(DefaultMsgToolPath, "MsgTool.exe"));
        }

        public MsgTool(string toolPath) : this()
        {
            _MsgToolProcess.ExecutablePath = Path.GetFullPath(toolPath);
        }

        /// <summary>
        /// Gets or sets path to MsgTool
        /// </summary>
        public string MsgToolPath
        {
            get { return _MsgToolProcess.ExecutablePath; }
            set { _MsgToolProcess.ExecutablePath = value; }
        }

        /// <summary>
        /// Gets the output text from the most recent run of MsgTool.
        /// </summary>
        public string Output
        {
            get { return _MsgToolProcess.Output; }
        }


        /// <summary>
        /// Adds a string to the table.
        /// </summary>
        /// <param name="stringID">ID of the string to be added</param>
        /// <param name="text">The text of the string in the appropriate language.</param>
        /// <param name="lang">The language of this instance of the message.</param>
        /// <remarks> Command Line: 
        /// MSGTOOL /addstring /id:[id] /text:[text] /lang:[language]<br/> 
        /// You must add a string to the table before you send it via SystemMessage, UserMessage,
        /// or TitleMessage since these take the ID of the string.<br/>
        /// Msgtool generates the following for this command line:
        /// D:\msgtool /addstring /id:50001 /text:"This is a test." /lang:1
        /// <code>
        /// Adding string - id:50001,lang:1,text:This is a test.
        /// String Service address 10.20.1.5:11020
        /// String Service address 10.20.1.5:11020
        /// 
        /// 
        /// String added successfully.
        /// 
        /// </code></remarks>
        public void AddString(uint stringID, string text, StringLanguage lang)
        {
            string args = String.Format("/addstring /id:{0} /text:\"{1}\" /lang:{2}", stringID, text, (int)lang);
            if (_MsgToolProcess.Run(args) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }

        // MSGTOOL /addsystemmsg /id:[id] /expiration:[expiration] /recommended
        /// <summary>
        /// Sends a string to all users when they sign in their language or the default.
        /// Has the recommended option for sending to Xbox 1.
        /// </summary>
        /// <param name="stringID">ID of the string to be sent</param>
        /// <param name="expiration">When this message will expire from the server</param>
        /// <param name="recommended">Xbox 1 setting.  No effect on Xbox 360</param>
        /// <remarks>Add system message generates the following output from the command line:
        /// msgtool /addsystemmsg /id:50001 /expiration:"5/17/2006"
        /// <code>
        /// Checking for existence of string 50001...
        /// Adding system message - id:50001,expiration:5/17/2006
        /// System message added successfully.
        /// 
        /// </code>
        /// </remarks>
        public void SendSystemMsg(uint stringID, string expiration, bool recommended)
        {
            string args = String.Format("/addsystemmsg /id:{0} /expiration:{1}", stringID, expiration);
            if (recommended)
            {
                args=String.Concat(args, " /recommended");
            }
            if (_MsgToolProcess.Run(args) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }

        /// <summary>
        /// Sends a string to all users when they sign in their language or the default.
        /// Defaults as required on Xbox1.
        /// </summary>
        /// <param name="stringID">ID of the string to be sent</param>
        /// <param name="expiration">When this message will expire from the server</param>
        /// <remarks>Command Line: MSGTOOL /addsystemmsg /id:[id] /expiration:[expiration]<br/>
        /// Adds the specified string to the table to be sent to all users.
        /// Add system message generates the following output from the command line:
        /// msgtool /addsystemmsg /id:50001 /expiration:"5/17/2006"
        /// <code>
        /// Checking for existence of string 50001...
        /// Adding system message - id:50001,expiration:5/17/2006
        /// System message added successfully.
        /// 
        /// </code>
        /// </remarks>
        public void SendSystemMsg(uint stringID, string expiration)
        {
            string args = String.Format("/addsystemmsg /id:{0} /expiration:{1}", stringID, expiration);
            if (_MsgToolProcess.Run(args) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }

        // MSGTOOL /enumsysmsg
        /// <summary>
        /// Enumerate all the System Messages in the queue
        /// </summary>
        /// <returns>MessageEntries collection of the sent messages</returns>
        /// <remarks>
        /// Return is formatted like this: (Blank line appears to be output before and after.
        /// <code>
        ///     
        /// Enumerating System Messages...
        /// 
        /// TitleID, MsgID, Sent, ExpireDate, Description
        /// 0, 1074107393, 5/16/2006 10:45:58 PM, 5/16/2006 11:59:58 PM, Xbox Live
        ///
        /// End Enumeration.
        ///         
        /// </code> OR <code>
        ///       
        /// Enumerating System Messages...
        /// There were no messages in the system message queue.
        ///        
        /// </code>                                         */
        /// </remarks>
        public MessageEntries EnumSystemMsg()
        {
            MessageEntries sysMsgs = new MessageEntries();

            if (_MsgToolProcess.Run("/enumsysmsg") != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
            String[] output=_MsgToolProcess.Output.Split('\n');
            if (output[2] == "There were no messages in the system message queue.")
            {
                return sysMsgs;
            }
            int idx = 4;
            while (idx < output.Length && output[idx].Trim() != "")
            {
                sysMsgs.Add(new MessageEntry(output[idx]));
                idx++;
            }
            
            return sysMsgs;
        }

        // MSGTOOL /addtitlemsg /id:[id] /title:[titleid] /expiration:[expiration] [/recommended]
        /// <summary>
        /// Sends a message to all users of a specified title
        /// </summary>
        /// <param name="stringID">ID of previously added string to be sent</param>
        /// <param name="titleID">TitleID</param>
        /// <param name="expiration">Expiration date of the message</param>
        /// <remarks>The following was generated from this command line: msgtool /addtitlemsg /id:50001 /title:0xFFFE07D0 /expiration:"5/20/2006"
        /// <code>
        /// Checking for existence of string 50001...
        /// Adding title message - title:0xFFFE07D0,id:50001,expiration:5/20/2006
        /// Title message added successfully.
        /// 
        /// </code>
        /// </remarks>
        public void SendTitleMsg(uint stringID, uint titleID, string expiration)
        {
            string args = String.Format("/addtitlemsg /id:{0} /title:0x{1:x} /expiration:{2}", stringID, titleID, expiration);
            if (_MsgToolProcess.Run(args) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }
        /// <summary>
        /// Sends a message to all users of a specified title
        /// </summary>
        /// <param name="stringID">ID of previously added string to be sent</param>
        /// <param name="titleID">TitleID</param>>
        /// <param name="expiration">Expiration date of the message</param>
        /// <param name="recommended">Xbox1 recommended message or required</param>
        /// <remarks>The following was generated from this command line: msgtool /addtitlemsg /id:50001 /title:0xFFFE07D0 /expiration:"5/20/2006"
        /// <code>
        /// Checking for existence of string 50001...
        /// Adding title message - title:0xFFFE07D0,id:50001,expiration:5/20/2006
        /// Title message added successfully.
        /// 
        /// </code>
        /// </remarks>
        public void SendTitleMsg(uint stringID, uint titleID, string expiration, bool recommended)
        {
            string args = String.Format("/addtitlemsg /id:{0} /title:0x{1:x} /expiration:{2}", stringID, titleID, expiration);
            if (recommended)
            {
                args=String.Concat(args, " /recommended");
            }
            if (_MsgToolProcess.Run(args) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }

        // MSGTOOL /enumtitlemsg /title:[titleid]
        /// <summary>
        /// Enumerate all the System Messages in the queue
        /// </summary>
        /// <returns>MessageEntries collection of the sent messages</returns>
        /// <remarks>
        /// Return is formatted like this: (Blank line appears to be output before and after.
        /// <code>
        ///     
        /// Enumerating System Messages...
        /// 
        /// TitleID, MsgID, Sent, ExpireDate, Description
        /// 0, 1074107393, 5/16/2006 10:45:58 PM, 5/16/2006 11:59:58 PM, Xbox Live
        ///
        /// End Enumeration.
        ///         
        /// </code> OR <code>
        ///       
        /// Enumerating System Messages...
        /// There were no messages in the system message queue.
        ///        
        /// </code>                                         */
        /// </remarks>
        public MessageEntries EnumTitleMsg(uint titleID)
        {
            MessageEntries titleMsgs = new MessageEntries();
            
            if (_MsgToolProcess.Run(String.Format("/enumtitlemsg /title:0x{0:x}",titleID)) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
            String[] output=_MsgToolProcess.Output.Split('\n');
            if (output[2] == "There were no messages in the system message queue.")
            {
                return titleMsgs;
            }
            int idx = 4;
            while (idx < output.Length && output[idx].Trim() != "")
            {
                titleMsgs.Add(new MessageEntry(output[idx]));
                idx++;
            }
            return titleMsgs;
        }

        // MSGTOOL /deletemsg /id:[id] /title:[[titleid | 0]]
        /// <summary>
        /// Deletes a message that was added with the Send functions
        /// </summary>
        /// <param name="messageID">ID of the message.  This is returned from the enumMsg methods</param>
        /// <param name="titleID">TitleID of the Message.  Use 0 for system messages</param>
        /// <remarks>
        /// The following message is output, no matter if the message is deleted, the titleID or the Message isn't found.
        /// <code>
        /// System or title message was successfully deleted or revoked.
        /// 
        /// </code>
        /// </remarks>
        public void DeleteMsg(uint messageID, uint titleID)
        {
            string args;
            if (titleID == 0)
            {
                args = String.Format("/deletemsg /id:{0} /title:0", messageID);
            }
            else
            {
                args = String.Format("/deletemsg /id:{0} /title:0x{1:x}", messageID, titleID);
            }
            if (_MsgToolProcess.Run(args) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }

        // MSGTOOL /revokemsg /id:[id] /title:[[titleid | 0]]
        /// <summary>
        /// Revokes a message that was added with the Send functions.  Removes any sent instances as well.
        /// </summary>
        /// <param name="messageID">ID of the message.  This is returned from the enumMsg methods</param>
        /// <param name="titleID">TitleID of the Message.  Use 0 for system messages</param>
        /// <remarks>
        /// The following was generated using this command line: msgtool /revokemsg /id:1074107393 /title:0
        /// <code>
        /// System or title message was successfully deleted or revoked.
        /// 
        /// </code>
        /// This same output is generated even if the id does not exist.
        /// </remarks>
        public void RevokeMsg(uint messageID, uint titleID)
        {
            string args;
            if (titleID == 0)
            {
                args = String.Format("/revokemsg /id:{0} /title:0", messageID);
            }
            else
            {
                args = String.Format("/revokemsg /id:{0} /title:0x{1:x}", messageID, titleID);
            }
            if (_MsgToolProcess.Run(args) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }

        // MSGTOOL /addusermsg /id:[id] [ /user:[puid] | /usertag:[tag] ] /expiration:[expiration] [/recommended]
        /// <summary>
        /// Adds a message for a specified User by PUID
        /// </summary>
        /// <param name="stringID">ID of String to be sent to user</param>
        /// <param name="userPUID">User's PUID</param>
        /// <param name="expiration">Message Expiration Date</param>
        /// <remarks>
        /// The following output was generated from this command line: msgtool /addusermsg /id:50001 /user:2533274801615275 /expiration:"5/24/2006" /recommended
        /// <code>
        /// Checking user information ...
        /// Checking for existence of string 50001...
        /// Adding user message - user:2533274801615275,id:50001,expiration:5/24/2006
        /// User message added successfully.
        /// 
        /// </code>
        /// </remarks>
        public void SendUserMsg(uint stringID, ulong userPUID, string expiration)
        {
            string args = String.Format("/addtitlemsg /id:{0} /user:{1} /expiration:{2}", stringID, userPUID, expiration);
            if (_MsgToolProcess.Run(args) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }
        /// <summary>
        /// Send a message for specified user on XBox 1 setting recommended by PUID
        /// </summary>
        /// <param name="stringID">ID of String to be sent to user</param>
        /// <param name="userPUID">User's PUID</param>
        /// <param name="expiration">Message Expiration Date</param>
        /// <param name="recommended">XBox 1 switch to make recommended or required</param>
        /// <remarks>
        /// The following output was generated from this command line: msgtool /addusermsg /id:50001 /usertag:coerwyn /expiration:"5/24/2006"
        /// <code>
        /// Checking user information ...
        /// Checking for existence of string 50001...
        /// Adding user message - user:2533274801615275,id:50001,expiration:5/24/2006
        /// User message added successfully.
        /// 
        /// </code>
        /// </remarks>
        public void SendUserMsg(uint stringID, ulong userPUID, string expiration, bool recommended)
        {
            string args = String.Format("/addtitlemsg /id:{0} /user:{1} /expiration:{2}", stringID, userPUID, expiration);
            if (recommended)
            {
                args=String.Concat(args, " /recommended");
            }
            if (_MsgToolProcess.Run(args) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }
        /// <summary>
        /// Adds a message for a specified User by GamerTag
        /// </summary>
        /// <param name="stringID">ID of String to be sent to user</param>
        /// <param name="gamerTag">User's GamerTag</param>
        /// <param name="expiration">Message Expiration Date</param>
        /// <remarks>
        /// The following output was generated from this command line: msgtool /addusermsg /id:50001 /usertag:coerwyn /expiration:"5/24/2006"
        /// <code>
        /// Checking user information ...
        /// Checking for existence of string 50001...
        /// Adding user message - user:2533274801615275,id:50001,expiration:5/24/2006
        /// User message added successfully.
        /// 
        /// </code>
        /// </remarks>
        public void SendUserMsg(uint stringID, string gamerTag, string expiration)
        {
            string args = String.Format("/addusermsg /id:{0} /usertag:{1} /expiration:{2}", stringID, gamerTag, expiration);
            if (_MsgToolProcess.Run(args) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }
        /// <summary>
        /// Send a message for specified user on XBox 1 setting recommended by PUID
        /// </summary>
        /// <param name="stringID">ID of String to be sent to user</param>
        /// <param name="gamerTag">User's PUID</param>
        /// <param name="expiration">Message Expiration Date</param>
        /// <param name="recommended">XBox 1 switch to make recommended or required</param>
        /// <remarks>
        /// The following output was generated from this command line: msgtool /addusermsg /id:50001 /usertag:coerwyn /expiration:"5/24/2006"
        /// <code>
        /// Checking user information ...
        /// Checking for existence of string 50001...
        /// Adding user message - user:2533274801615275,id:50001,expiration:5/24/2006
        /// User message added successfully.
        /// 
        /// </code>
        /// </remarks>
        public void SendUserMsg(uint stringID, string gamerTag, string expiration, bool recommended)
        {
            string args = String.Format("/addusermsg /id:{0} /usertag:{1} /expiration:{2}", stringID, gamerTag, expiration);
            if (recommended)
            {
                args=String.Concat(args, " /recommended");
            }
            if (_MsgToolProcess.Run(args) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }

        // MSGTOOL /enumusermsg [ /user:[puid] | /usertag:[tag] ]
        /// <summary>
        /// Enumerates the messages for a user from their PUID
        /// </summary>
        /// <param name="puid">PUID of the user</param>
        /// <returns>A collection of UserMessages</returns>
        /// <remarks>The following was returned by the command line: msgtool /enumusermsg /user:2533274801615275
        /// <code>
        /// Checking user information ...
        /// 
        /// SenderID, SentTime, MessageID, MFlg, SenderTitleID, ExpireDate
        /// 0, 5/22/2006 4:52:24 PM, 2, 1, 4294836224, 5/24/2006 12:00:24 AM
        /// 
        /// End Enumeration.
        /// 
        /// </code>
        /// </remarks>
        public UserMessages EnumUserMsg(ulong puid)
        {
            UserMessages userMsgs = new UserMessages();
            
            if (_MsgToolProcess.Run(String.Format("/enumusermsg /user:{0}",puid)) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
            String[] output=_MsgToolProcess.Output.Split('\n');
            if (output[1] == "There were no messages in this user's message queue.")
            {
                return userMsgs;
            }
            int idx = 3;
            while (idx < output.Length && output[idx].Trim() != "")
            {
                userMsgs.Add(new UserMessage(output[idx]));
                idx++;
            }
            return userMsgs;
        }

        /// <summary>
        /// Returns a list of user messages from a specified gamerTag
        /// </summary>
        /// <param name="gamerTag">User's gamertag</param>
        /// <returns>Collection of UserMessages</returns>
        /// <remarks>The following was returned by the command line: msgtool /enumusermsg /usertag:coerwyn
        /// <code>
        /// Checking user information ...
        /// 
        /// SenderID, SentTime, MessageID, MFlg, SenderTitleID, ExpireDate
        /// 0, 5/22/2006 4:52:24 PM, 2, 1, 4294836224, 5/24/2006 12:00:24 AM
        /// 
        /// End Enumeration.
        /// 
        /// </code>
        /// </remarks>
        public UserMessages EnumUserMsg(string gamerTag)
        {
            UserMessages userMsgs = new UserMessages();
            
            if (_MsgToolProcess.Run(String.Format("/enumusermsg /usertag:{0}",gamerTag)) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
            String[] output=_MsgToolProcess.Output.Split('\n');
            if (output[1] == "There were no messages in this user's message queue.")
            {
                return userMsgs;
            }
            int idx = 3;
            while (idx < output.Length && output[idx].Trim() != "")
            {
                userMsgs.Add(new UserMessage(output[idx]));
                idx++;
            }
            return userMsgs;
        }

        // MSGTOOL /deleteusermsg /id:[id] [ /user:[puid] | /usertag:[tag] ]
        /// <summary>
        /// Deletes a user message using the Message ID and PUID.
        /// </summary>
        /// <param name="MsgId">Message ID returned from EnumMessage function</param>
        /// <param name="puid">User's PUID</param>
        /// <remarks>This command line generated the following output: msgtool /deleteusermsg /id:2 /user:2533274801615275
        /// <code>
        /// Checking user information ...
        /// Successfully deleted message ID 2 from the queue of user 2533274801615275
        /// 
        /// </code>
        /// </remarks>
        public void DeleteUserMsg(uint MsgId, ulong puid)
        {
            string args = String.Format("/deleteusermsg /id:{0} /user:{1}", MsgId, puid);
            if (_MsgToolProcess.Run(args) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }

        /// <summary>
        /// Deletes a user message using the Message ID and GamerTag
        /// </summary>
        /// <param name="MsgId">Message ID returned from EnumMessage function</param>
        /// <param name="gamerTag">User's GamerTag</param>
        /// <remarks>This command line generated the following output: msgtool /deleteusermsg /id:2 /usertag:coerwyn
        /// <code>
        /// Checking user information ...
        /// Successfully deleted message ID 2 from the queue of user 2533274801615275
        /// 
        /// </code>
        /// </remarks>
        public void DeleteUserMsg(uint MsgId, string gamerTag)
        {
            string args = String.Format("/deleteusermsg /id:{0} /usertag:{1}", MsgId, gamerTag);
            if (_MsgToolProcess.Run(args) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }

        /// <summary>
        /// Allows running MsgTool with custom argument string.
        /// Mainly used for negative testing.
        /// </summary>
        /// <param name="arguments">Argument string to be used when calling MsgTool.</param>
        public void RunMsgTool(string arguments)
        {
            if (_MsgToolProcess.Run(arguments) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }

        /// <summary>
        /// Runs MsgTool taking an XML file of messages and recipients.
        /// </summary>
        /// <param name="XMLFile">XML File path</param>
        public void XMLMessage(string XMLFile)
        {
            _MsgToolProcess.ExecutionTimeout = 6000;  // Boost timeout to 100 mins
            if (_MsgToolProcess.Run(String.Format(@"/addxmlmsg /xml:{0}", XMLFile)) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }

        /// <summary>
        /// Runs MsgTool taking an XML file of messages and recipients and *only* validates the XML format.
        /// </summary>
        /// <param name="XMLFile">XML File path</param>
        public void CheckXMLMessage(string XMLFile)
        {
            _MsgToolProcess.ExecutionTimeout = 6000;  // Boost timeout to 100 mins
            if (_MsgToolProcess.Run(String.Format(@"/addxmlmsg /xml:{0} /validatexml", XMLFile)) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }
    }

    /// <summary>
    /// Language Enum for the strings in MsgTool
    /// </summary>
    public enum StringLanguage
    {
    english=1,
    japanese,
    german,
    french,
    spanish,
    italian,
    korean,
    chinese,
    portuguese
    }

    /// <summary>
    /// Exception class for MsgTool runner
    /// </summary>
    public class MsgToolException : ProcessException
    {
        public MsgToolException() : base("MsgTool") {}
        public MsgToolException(string message) : base("MsgTool", message) {}
        public MsgToolException(string message, Exception innerException) : base("MsgTool", message, innerException) {}
        public MsgToolException(string message, string output) : base("MsgTool", message, output) {}
        public MsgToolException(string message, string output, Exception innerException) :
            base("MsgTool", message, output, innerException) {}
    }

    /// <summary>
    /// A Row returned from the Enum functions of MsgTool of what messages are sent.
    /// </summary>
    public class MessageEntry
    {
        // TitleID, MsgID, Sent, ExpireDate, Description
        public uint titleID;
        public uint msgID;
        public DateTime sentDate;
        public DateTime expireDate;
        public string description;

        /// <summary>
        /// Creates a new MsgTool Message line from a string that MsgTool returns.
        /// </summary>
        /// <param name="entry">Formatted String from MsgTool</param>
        /// <remarks>The tool returns each row like "TitleID, MsgID, Sent, ExpireDate, Description"</remarks>
        public MessageEntry(string entry)
        {
            string[] fields = entry.Split(',');
            if (fields.Length == 5)
            {
                titleID = Convert.ToUInt32(fields[0]);
                msgID = Convert.ToUInt32(fields[1]);
                sentDate = Convert.ToDateTime(fields[2]);
                expireDate = Convert.ToDateTime(fields[3]);
                description = fields[4];
            }
        }
        /// <summary>
        /// Tests if object is equal to this MessageEntry
        /// </summary>
        /// <param name="obj">Object to test</param>
        /// <returns>True if both objects are the same</returns>
        public override bool Equals(object obj)
        {
            if (obj is MessageEntry)
            {
                return
                    (
                    ((MessageEntry)obj).titleID == titleID &&
                    ((MessageEntry)obj).msgID == msgID &&
                    ((MessageEntry)obj).sentDate == sentDate &&
                    ((MessageEntry)obj).expireDate == expireDate &&
                    ((MessageEntry)obj).description == description 
                    );
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// Gets the hashcode for this instance
        /// </summary>
        /// <returns>Hashcode</returns>
        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

    }

    /// <summary>
    /// Collection of MessageEntry objects
    /// </summary>
    public class MessageEntries : CollectionBase
    {
        public MessageEntries() {}

        /// <summary>
        /// Indexer for MessageEntries
        /// </summary>
        public MessageEntry this[int index]
        {
            get { return List[index] as MessageEntry; }
            set { List[index] = value; }
        }

        /// <summary>
        /// Adds a MessageEntry to the collection
        /// </summary>
        /// <param name="val">MessageEntry to add</param>
        /// <returns>Index of MessageEntry</returns>
        public int Add(MessageEntry val)
        {
            return List.Add(val);
        }

        /// <summary>
        /// Tests if MessageEntry is in the collection
        /// </summary>
        /// <param name="val">MessageEntry to test</param>
        /// <returns>True if it is already in the collection</returns>
        public bool Contains(MessageEntry val)
        {
            return List.Contains(val);
        }

        /// <summary>
        /// Removes a MessageEntry from the collection
        /// </summary>
        /// <param name="val">MessageEntry to remove</param>
        public void Remove(MessageEntry val)
        {
            List.Remove(val);
        }
    }

    /// <summary>
    /// A Message for a particular User.  Returned in the collection from the EnumUserMsg function.
    /// </summary>
    public class UserMessage
    {
        // SenderID, SentTime, MessageID, MFlg, SenderTitleID, ExpireDate
        public uint senderID;
        public uint titleID;
        public uint msgID;
        public int MFlag;
        public DateTime sentDate;
        public DateTime expireDate;

        /// <summary>
        /// Creates a new MsgTool User Message line from a string that MsgTool enumUserMsg returns.
        /// </summary>
        /// <param name="entry">Formatted String from MsgTool</param>
        /// <remarks>The tool returns each row like "SenderID, SentTime, MessageID, MFlg, SenderTitleID, ExpireDate"</remarks>
        public UserMessage(string entry)
        {
            string[] fields = entry.Split(',');
            if (fields.Length == 6)
            {
                senderID = Convert.ToUInt32(fields[0]);
                sentDate = Convert.ToDateTime(fields[1]);
                msgID = Convert.ToUInt32(fields[2]);
                MFlag = Convert.ToInt32(fields[3]);
                titleID = Convert.ToUInt32(fields[4]);
                expireDate = Convert.ToDateTime(fields[5]);
                
            }
        }

        /// <summary>
        /// Determines if this UserMessage is equal to another object
        /// </summary>
        /// <param name="obj">Object to be tested</param>
        /// <returns>True if they are equal</returns>
        public override bool Equals(object obj)
        {
            if (obj is UserMessage)
            {
                return
                    (
                    ((UserMessage)obj).senderID == senderID &&
                    ((UserMessage)obj).sentDate == sentDate &&
                    ((UserMessage)obj).msgID == msgID &&
                    ((UserMessage)obj).MFlag == MFlag &&
                    ((UserMessage)obj).titleID == titleID &&
                    ((UserMessage)obj).expireDate == expireDate
                    );
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// Gets the hashcode for this object
        /// </summary>
        /// <returns>The hashcode</returns>
        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

    }

    /// <summary>
    /// Collection of UserMessage objects
    /// </summary>
    public class UserMessages : CollectionBase
    {
        public UserMessages() {}

        /// <summary>
        /// Indexer for UserMessage
        /// </summary>
        public UserMessage this[int index]
        {
            get { return List[index] as UserMessage; }
            set { List[index] = value; }
        }

        /// <summary>
        /// Adds a new UserMessage to the collection
        /// </summary>
        /// <param name="val">UserMessage to add</param>
        /// <returns>Index of message</returns>
        public int Add(UserMessage val)
        {
            return List.Add(val);
        }

        /// <summary>
        /// Tests if a UserMessage is already in the collection
        /// </summary>
        /// <param name="val">UserMessage to test</param>
        /// <returns>True if UserMessage is in the collection</returns>
        public bool Contains(UserMessage val)
        {
            return List.Contains(val);
        }

        /// <summary>
        /// Removes a UserMessage from the collection
        /// </summary>
        /// <param name="val">UserMessage to remove</param>
        public void Remove(UserMessage val)
        {
            List.Remove(val);
        }
    }
}
/* ------------------------------
 Microsoft Windows [Version 5.2.3790]
(C) Copyright 1985-2003 Microsoft Corp.

C:\Documents and Settings\a-johnk>path
PATH=C:\WINNT\system32;C:\WINNT;C:\WINNT\System32\Wbem;C:\Program Files\Microsoft ADS\bin;C:\Program Files\Microsoft ADS\tools;C:\
Program Files\Dell\SysMgt\oma\bin;C:\Program Files\Microsoft SQL Server\80\Tools\BINN;D:\webroot\xbltools

C:\Documents and Settings\a-johnk>dir
 Volume in drive C is Win2K
 Volume Serial Number is CC80-D514

 Directory of C:\Documents and Settings\a-johnk

05/12/2006  10:41 PM    <DIR>          .
05/12/2006  10:41 PM    <DIR>          ..
05/11/2006  10:13 PM    <DIR>          Desktop
05/11/2006  05:12 PM    <DIR>          Favorites
05/11/2006  09:48 PM    <DIR>          My Documents
08/11/2004  12:02 PM    <DIR>          Start Menu
08/11/2004  12:03 PM                 0 Sti_Trace.log
               1 File(s)              0 bytes
               6 Dir(s)   6,599,094,272 bytes free

C:\Documents and Settings\a-johnk>msgtool

Tool to add messages to the Xbox Live Messaging Service

Usage:
    MSGTOOL /addstring /id:<id> /text:<text> /lang:<language>
    MSGTOOL /addsystemmsg /id:<id> /expiration:<expiration> [/recommended]
    MSGTOOL /enumsysmsg
    MSGTOOL /addtitlemsg /id:<id> /title:<titleid> /expiration:<expiration> [/recommended]
    MSGTOOL /enumtitlemsg /title:<titleid>
    MSGTOOL /deletemsg /id:<id> /title:[<titleid | 0>]
    MSGTOOL /revokemsg /id:<id> /title:[<titleid | 0>]
    MSGTOOL /addusermsg /id:<id> [ /user:<puid> | /usertag:<tag> ] /expiration:<expiration> [/recommended]
    MSGTOOL /enumusermsg [ /user:<puid> | /usertag:<tag> ]
    MSGTOOL /deleteusermsg /id:<id> [ /user:<puid> | /usertag:<tag> ]

Definitions:
    <id>         - A numerical identifier for the string (in decimal)
    <user>       - Unique Xbox Live identifier for the desired user (in decimal)
    <usertag>    - Unique Xbox Live gamertag for the desired user
    <titleid>    - Unique Xbox Live identifier for the desired title (in decimal)
                   If title ID is in Hex notation, it must start with 0x (zero, then x)
                   Note: for /deletemsg or /revokemsg, use titleid 0 to delete system messages
    <language>   - Language of the given text string - 1=english
                                                       2=japanese
                                                       3=german
                                                       4=french
                                                       5=spanish
                                                       6=italian
                                                       7=korean
                                                       8=chinese
                                                       9=portuguese
    <text>       - Text for the message
    <expiration> - Date and time when the message will expire - Example: "10/31/2002"
                   Remember that dates for Live are in the UTC time zone (+8 from PST).
    recommended  - Specifies that the message is a recommended message. By default, messages
                   are marked as required.
                   Note: The Xbox 360 simply shows both recommended and required messages
                   in the message center. There is no enforced viewing of messages sent by
                   this tool. Special messages (such as voice bans) are sent through the
                   CUST front door that performs extra work to force the Xbox 360 to read
                   them. Recommended and required messages are still honored by the Xbox 1
                   dashboard

Description:
    Adding a message is a two step process. Typically, the message you are sending will
    be of a type that we commonly send, so you can skip the first step and simply use the known
    string ID in the second step.

    First, you need to add the message string to the string service in all required languages
    using the msgtool /addstring syntax.

    Second, you need to associate the string ID with the appropriate queue (system, title
    or user) using the msgtool /addXXXmsg syntax.

Examples:
    Adding a string for English:
    msgtool /addstring /id:50000 /text:"Message" /lang:1

    Adding a system message which uses the above string, expiring two days from now:
    msgtool /addsystemmsg /id:50000 /expiration:"5/17/2006"

    Adding a system-title message for users of title 1431502860:
    msgtool /addtitlemsg /id:50000 /title:1431502860 /expiration:"5/17/2006"

    Adding a system-title message for same title above, using Hex notation (Note the 0x):
    msgtool /addtitlemsg /id:50000 /title:0x5553000C /expiration:"5/17/2006"

    Adding a Recommended User message using user's PUID :
    msgtool /addusermsg /id:50000 /user:27517529866 /expiration:"5/17/2006" /recommended

    Adding a Required User message using user's Gamertag (Note: it's /usertag, not /user):
    msgtool /addusermsg /id:50000 /usertag:CreativeGamertag /expiration:"5/17/2006"

    Enumerating a User's messages using user's Gamertag:
    msgtool /enumusermsg /usertag:CreativeGamertag

    Enumerating title messages:
    msgtool /enumtitlemsg /title:0x5553000C

    Enumerating system messages:
    msgtool /enumsysmsg

    Deleting a title message:
    msgtool /deletemsg /id:<msgid> /title:0x5553000C

    Revoking a system message:
    msgtool /revokemsg /id:<msgid> /title:0

        Note: 'deleting' a system message means deleting it from the system message
        table so it will no longer be delivered to users when they sign in.
        'revoking' a system message means deleting it from the system message
        table so it will no longer be delivered to users when they sign in AND
        deleting all instances of it from user message table that have already
        been delivered.

    Deleting a message from a User's message queue:
    --> Do an /enumusermsg first, then use the msgid you get in the call below
    msgtool /deleteusermsg /user:27517529866  /id:<msgid>


C:\Documents and Settings\a-johnk>msgtool /addstring /id:50000 /text:"This is a test." /lang:1
Adding string - id:50000,lang:1,text:This is a test.
String Service address 10.20.1.5:11020
String Service address 10.20.1.5:11020


String added successfully.

C:\Documents and Settings\a-johnk>msgtool /addstring /id:50001 /text:"This is a test." /lang:1
Adding string - id:50001,lang:1,text:This is a test.
String Service address 10.20.1.5:11020
String Service address 10.20.1.5:11020


String added successfully.

C:\Documents and Settings\a-johnk>msgtool /enumsysmsg

Enumerating System Messages...
There were no messages in the system message queue.

C:\Documents and Settings\a-johnk>msgtool /addsystemmsg /id:50001 /expiration:"5/17/2006"
Checking for existence of string 50001...
Adding system message - id:50001,expiration:5/17/2006
System message added successfully.

C:\Documents and Settings\a-johnk>msgtool /enumsysmsg

Enumerating System Messages...

TitleID, MsgID, Sent, ExpireDate, Description
0, 1074107393, 5/16/2006 10:45:58 PM, 5/16/2006 11:59:58 PM, Xbox Live

End Enumeration.


C:\Documents and Settings\a-johnk>msgtool /revokemsg /id:50001 /title:0
System or title message was successfully deleted or revoked.

C:\Documents and Settings\a-johnk>msgtool /enumsysmsg

Enumerating System Messages...

TitleID, MsgID, Sent, ExpireDate, Description
0, 1074107393, 5/16/2006 10:45:58 PM, 5/16/2006 11:59:58 PM, Xbox Live

End Enumeration.


C:\Documents and Settings\a-johnk>msgtool /revokemsg /id:1074107393 /title:0
System or title message was successfully deleted or revoked.

C:\Documents and Settings\a-johnk>msgtool /enumsysmsg

Enumerating System Messages...
There were no messages in the system message queue.

C:\Documents and Settings\a-johnk>msgtool /enumtitlemsg /title:0

Error: An error occurred while attempting to use the TitleID supplied.
       Please check format and try again.

Exception text is: Invalid title id '0'

C:\Documents and Settings\a-johnk>msgtool /addtitlemsg /id:50001 /title:0xFFFE07D0 /expiration:"5/20/2006"
Checking for existence of string 50001...
Adding title message - title:0xFFFE07D0,id:50001,expiration:5/20/2006
Title message added successfully.

C:\Documents and Settings\a-johnk>msgtool /enumtitlemsg /title:0xFFFE07D0

Enumerating Messages for Title: 4294838224 ...

TitleID, MsgID, Sent, ExpireDate, Description
4294838224, 1074107394, 5/19/2006 4:21:07 PM, 5/20/2006 12:00:07 AM, Xbox Live

End Enumeration.


C:\Documents and Settings\a-johnk>msgtool /enumtitlemsg /title:0xFFFE07D1

Enumerating Messages for Title: 4294838225 ...
There were no messages in the system message queue.

C:\Documents and Settings\a-johnk>msgtool /addusermsg /id:50001 /usertag:coerwyn /expiration:"5/20/2006"
Checking user information ...
Checking for existence of string 50001...
Adding user message - user:2533274801615275,id:50001,expiration:5/20/2006
User message added successfully.

C:\Documents and Settings\a-johnk>msgtool /enumusermsg /usertag:coerwyn
Checking user information ...

SenderID, SentTime, MessageID, MFlg, SenderTitleID, ExpireDate
0, 5/19/2006 8:11:05 PM, 1, 1, 4294836224, 5/20/2006 12:00:05 AM

End Enumeration.


C:\Documents and Settings\a-johnk>
 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup\ClientTools\VoucherMgr.cs ===
using System;
using System.IO;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.STFTools
{
	/// <summary>
	/// Utility class for running the VoucherMgr tool.
	/// </summary>
	public class VoucherMgr
	{
            private ProcessWrapper _voucherMgrProcess;
            private const string _defaultVoucherMgrPath = "D:\\webroot\\xbltools";
            static public string InvalidEMSOfferId;

            public bool IsEmsOfferId(string offerId)
            {

                try
                {
                    if (offerId == InvalidEMSOfferId) return true;
                    Guid guidId = new Guid(offerId);
                    return true;
                }
                catch
                {
                    return false;
                }
            }

            public VoucherMgr() {
                _voucherMgrProcess = new ProcessWrapper("VoucherMgr", Path.Combine(_defaultVoucherMgrPath, "VoucherMgr.exe"));
            }

            public VoucherMgr(string voucherMgrPath) : this()
            {
                _voucherMgrProcess.ExecutablePath = Path.GetFullPath(voucherMgrPath);
            }

            public string Output
            {
                get { return _voucherMgrProcess.Output; }
            }

            

            public void Import(string key_or_file, bool isFile, string emsofferid, int mediatype, string espofferid, int useCount,
                   int useSCG, uint consoleVer)
            {
                Import(key_or_file, isFile, emsofferid, mediatype, espofferid, useCount, useSCG, consoleVer, -1, -1, -1);
            }

            public void Import(string key_or_file, bool isFile, string emsofferid, int mediatype, string espofferid, int useCount,
                   int useSCG, uint consoleVer, int minseq,
                   int maxseq, int retries)
            {
                string arguments = "/import ";
                arguments += CreateKeyOrFileArg(key_or_file, isFile);
                arguments += "/emsofferid:" + emsofferid + " ";
                arguments += "/mediatype:" + mediatype + " ";
                arguments += "/espofferid:" + espofferid + " ";

                arguments += "/usecount:" + useCount + " ";
                arguments += "/SCG:" + useSCG + " ";
                arguments += "/consoleVer:" + consoleVer + " ";
                arguments += CreateMinMaxArg(minseq, maxseq);
                if (retries != -1)
                {
                    arguments += "/retries:" + retries + " ";
                }
                if (_voucherMgrProcess.Run(arguments) != 0)
                {
                    throw new VoucherMgrException("VoucherMgr exited with error.", _voucherMgrProcess.Output);
                }
            }

            public void Import(string key_or_file, bool isFile, string offerid, int mediatype, int useCount,
                               int useSCG, uint consoleVer)
            {
                Import(key_or_file, isFile, offerid, mediatype, useCount, useSCG, consoleVer, -1, -1, -1);
            }

            public void ImportOld(string key_or_file, bool isFile, string offerid, int useCount,
                   int useSCG, uint consoleVer)
            {
                ImportOld(key_or_file, isFile, offerid, useCount, useSCG, consoleVer, -1, -1, -1);
            }

            public void Import(string key_or_file, bool isFile, string offerid, int mediatype, int useCount, 
                               int useSCG, uint consoleVer, int minseq,
                               int maxseq, int retries) {
                string arguments = "/import ";
                arguments += CreateKeyOrFileArg(key_or_file, isFile);

                if (IsEmsOfferId(offerid))
                {
                    arguments += "/emsofferid:" + offerid + " ";
                    arguments += "/mediatype:" + mediatype + " ";
                }
                else
                    arguments += "/espofferid:" + offerid + " ";

                arguments += "/usecount:" + useCount + " ";
                arguments += "/SCG:" + useSCG + " ";
                arguments += "/consoleVer:" + consoleVer + " ";
                arguments += CreateMinMaxArg(minseq, maxseq);
                if (retries != -1) {
                    arguments += "/retries:" + retries + " ";
                }
                if (_voucherMgrProcess.Run(arguments) != 0) {
                    throw new VoucherMgrException("VoucherMgr exited with error.", _voucherMgrProcess.Output);
                }
            }

            public void ImportOld(string key_or_file, bool isFile, string offerid, int useCount,
                   int useSCG, uint consoleVer, int minseq,
                   int maxseq, int retries)
            {
                string arguments = "/import ";
                arguments += CreateKeyOrFileArg(key_or_file, isFile);


                arguments += "/offerid:" + offerid + " ";

                arguments += "/usecount:" + useCount + " ";
                arguments += "/SCG:" + useSCG + " ";
                arguments += "/consoleVer:" + consoleVer + " ";
                arguments += CreateMinMaxArg(minseq, maxseq);
                if (retries != -1)
                {
                    arguments += "/retries:" + retries + " ";
                }
                if (_voucherMgrProcess.Run(arguments) != 0)
                {
                    throw new VoucherMgrException("VoucherMgr exited with error.", _voucherMgrProcess.Output);
                }
            }            
            public void Disable(string key_or_file, bool isFile) {
                Disable(key_or_file, isFile, -1, -1);
            }

            public void Disable(string key_or_file, bool isFile, int minseq, int maxseq) {
                string arguments = "/disable ";
                arguments += CreateKeyOrFileArg(key_or_file, isFile);
                arguments += CreateMinMaxArg(minseq, maxseq);
                if (_voucherMgrProcess.Run(arguments) != 0) {
                    throw new VoucherMgrException("VoucherMgr exited with error.", _voucherMgrProcess.Output);
                }
            }

            public void Enable(string key_or_file, bool isFile) {
                Enable(key_or_file, isFile, -1, -1);
            }

            public void Enable(string key_or_file, bool isFile, int minseq, int maxseq) {
                string arguments = "/enable ";
                arguments += CreateKeyOrFileArg(key_or_file, isFile);
                arguments += CreateMinMaxArg(minseq, maxseq);
                if (_voucherMgrProcess.Run(arguments) != 0) {
                    throw new VoucherMgrException("VoucherMgr exited with error.", _voucherMgrProcess.Output);
                }
            }

            public void Delete(string key_or_file, bool isFile, string offerid) {
                Delete(key_or_file, isFile, offerid, -1, -1, -1);
            }


            public void Delete(string key_or_file, bool isFile, string offerid,  
                               int minseq, int maxseq, int retries) {
                string arguments = "/delete ";
                arguments += CreateKeyOrFileArg(key_or_file, isFile);
                if (offerid != "") {
                    if (IsEmsOfferId(offerid)) {
                        arguments += "/emsofferid:" + offerid + " ";
                    }
                    else
                        arguments += "/espofferid:" + offerid + " ";
                }
                arguments += CreateMinMaxArg(minseq, maxseq);
                if (retries != -1) {
                    arguments += "/retries:" + retries + " ";
                }
                if (_voucherMgrProcess.Run(arguments) != 0) {
                    throw new VoucherMgrException("VoucherMgr exited with error.", _voucherMgrProcess.Output);
                }
            }

        public void Delete(string key_or_file, bool isFile, string emsofferid, string espofferid,
               int minseq, int maxseq, int retries)
        {
            string arguments = "/delete ";
            arguments += CreateKeyOrFileArg(key_or_file, isFile);


            if (emsofferid != "")
                arguments += "/emsofferid:" + emsofferid + " ";
            
            if(espofferid !="")
                    arguments += "/espofferid:" + espofferid + " ";

           
            arguments += CreateMinMaxArg(minseq, maxseq);
            if (retries != -1)
            {
                arguments += "/retries:" + retries + " ";
            }
            if (_voucherMgrProcess.Run(arguments) != 0)
            {
                throw new VoucherMgrException("VoucherMgr exited with error.", _voucherMgrProcess.Output);
            }
        }


            public string View(string key_or_file, bool isFile, int minseq, int maxseq) {
                string arguments = "/view ";
                arguments += CreateKeyOrFileArg(key_or_file, isFile);
                arguments += CreateMinMaxArg(minseq, maxseq);
                if (_voucherMgrProcess.Run(arguments) != 0) {
                    throw new VoucherMgrException("VoucherMgr exited with error.", _voucherMgrProcess.Output);
                }
                return _voucherMgrProcess.Output;
            }

            public string Summary() {
                string arguments = "/summary";
                if (_voucherMgrProcess.Run(arguments) != 0) {
                    throw new VoucherMgrException("VoucherMgr exited with error.", _voucherMgrProcess.Output);
                }
                return _voucherMgrProcess.Output;
            }

            public string EmsSummary()
            {
                string arguments = "/emssummary";
                if (_voucherMgrProcess.Run(arguments) != 0)
                {
                    throw new VoucherMgrException("VoucherMgr exited with error.", _voucherMgrProcess.Output);
                }
                return _voucherMgrProcess.Output;
            }

            private string CreateKeyOrFileArg(string key_or_file, bool isFile) {
                if (isFile) {
                    return "/file:" + key_or_file + " ";
                } else {
                    return "/key:" + key_or_file + " ";
                }
            }

            private string CreateMinMaxArg(int minseq, int maxseq) {
                string returnedArgs = "";
                if (minseq != -1) {
                    returnedArgs += "/minseq:" + minseq + " ";
                }
                if (maxseq != -1) {
                    returnedArgs += "/maxseq:" + maxseq + " ";
                }
                return returnedArgs;
            }

            public string ArbitraryCommand(string args) {
                if (_voucherMgrProcess.Run(args) != 0) {
                    throw new VoucherMgrException("VoucherMgr exited with error.", _voucherMgrProcess.Output);
                }
                return _voucherMgrProcess.Output;
            }


        }



	public class VoucherMgrException : ProcessException
	{
		public VoucherMgrException() : base("VoucherMgr") {}
		public VoucherMgrException(string message) : base("VoucherMgr", message) {}
		public VoucherMgrException(string message, Exception innerException) : base("VoucherMgr", message, innerException) {}
		public VoucherMgrException(string message, string output) : base("VoucherMgr", message, output) {}
		public VoucherMgrException(string message, string output, Exception innerException) :
			base("VoucherMgr", message, output, innerException) {}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup\ClientTools\SystemCheck.cs ===
using System;
using System.IO;
using System.Diagnostics;
using System.Text;
using System.Collections;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.STFTools
{
    /// <summary>
    /// Utility class for running the SystemCheck tool.
    /// </summary>
    public class SystemCheck
    {
        const string DefaultSystemCheckPath = "D:\\webroot\\xbltools";
        const string DefaultThreads = "5";
        const string DefaultTimeout = "60000";

        private string _configfilePath = "";
        private string _outfilePath = "";
        private ProcessWrapper _systemCheckProcess;
        private Report _report;

        public SystemCheck()
        {
            _systemCheckProcess = new ProcessWrapper("SystemCheck", Path.Combine(DefaultSystemCheckPath, "SystemCheck.exe"));
            _report = new Report("SystemCheck");
        }

        public SystemCheck(string systemCheckPath)
            : this()
        {
            SystemCheckPath = systemCheckPath;
        }

        /// <summary>
        /// Gets or sets the fully-qualified name of the SystemCheck executable.
        /// </summary>
        public string SystemCheckPath
        {
            get { return _systemCheckProcess.ExecutablePath; }
            set
            {
                _systemCheckProcess.ExecutablePath = Path.GetFullPath(value);
                _systemCheckProcess.WorkingDirectory = Path.GetDirectoryName(_systemCheckProcess.ExecutablePath);
            }
        }

        /// <summary>
        /// Gets or sets the working directory for SystemCheck
        /// </summary>
        public string WorkingDirectory
        {
            get { return _systemCheckProcess.WorkingDirectory; }
            set
            {
                if (value != null)
                {
                    _systemCheckProcess.WorkingDirectory = Path.GetFullPath(value);
                }
                else
                {
                    _systemCheckProcess.WorkingDirectory = null;
                }
            }
        }

        /// <summary>
        /// Gets or sets the number of milliseconds to allow LiveStats to run before killing the process.
        /// </summary>
        public int Timeout
        {
            get { return _systemCheckProcess.ExecutionTimeout; }
            set { _systemCheckProcess.ExecutionTimeout = value; }
        }

        /// <summary>
        /// Gets or sets the fully-qualified name of the Config file used during SystemCheck running 
        /// </summary>
        public string ConfigFilePath
        {
            get { return _configfilePath; }
            set
            {
                if (value != null)
                {
                    _configfilePath = Path.GetFullPath(value);
                }
                else
                {
                    _configfilePath = "";
                }
            }
        }

        /// <summary>
        /// Gets or sets the fully-qualified name of the Output file used during SystemCheck running 
        /// </summary>
        public string OutFilePath
        {
            get { return _outfilePath; }
            set
            {
                if (value != null)
                {
                    _outfilePath = Path.GetFullPath(value);
                }
                else
                {
                    _outfilePath = "";
                }
            }
        }

        /// <summary>
        /// Gets the output text from the most recent run of SystemCheck.
        /// </summary>
        public string Output
        {
            get { return _systemCheckProcess.Output; }
        }

        /// <summary>
        /// Runs SystemCheck with /reloadfd parameter to reload the front doord.
        /// </summary>
        public void Reloadfd()
        {
            Reloadfd("");
        }

        /// <summary>
        /// Runs SystemCheck with /reloadfd parameter to reload the front doord.
        /// </summary>
        /// <param name="timeout">timeout (in ms) to specify with the /timeout parameter. Optional.</param>
        public void Reloadfd(string timeout)
        {
            int exitCode;
            StringBuilder arguments = new StringBuilder();

            arguments.AppendFormat("/reloadfd");

            if (timeout != "")
            {
                arguments.AppendFormat(" /timeout:{0}", timeout);
            }

            exitCode = _systemCheckProcess.Run(arguments.ToString());
            if (exitCode == 0)
            {
                _report.Debug(_systemCheckProcess.Output);
            }
            else
            {
                throw new SystemCheckException("SystemCheck failed to Reload the Front Doors.", _systemCheckProcess.Output);
            }
        }

        /// <summary>
        /// Runs SystemCheck with a configfile and outputfile.
        /// </summary>
        public void CallUrl()
        {
            CallUrl(DefaultThreads, DefaultTimeout);
        }

        /// <summary>
        /// Runs SystemCheck with a configfile and outputfile.
        /// </summary>
        /// <param name="threads"># of threads to speciffy with the /threads parameter. Optional.</param>
        /// <param name="timeout">timeout (in ms) to specify with the /timeout parameter. Optional.</param>
        public void CallUrl(uint threads, uint timeout)
        {
            CallUrl(threads.ToString(), timeout.ToString());
        }

        /// <summary>
        /// Runs SystemCheck with a configfile, # of threads, timout, and outputfile.
        /// </summary>
        /// <param name="threads"># of threads to speciffy with the /threads parameter. Optional.</param>
        /// <param name="timeout">timeout (in ms) to specify with the /timeout parameter. Optional.</param>
        public void CallUrl(string threads, string timeout)
        {
            int exitCode;
            StringBuilder arguments = new StringBuilder();

            arguments.AppendFormat("/configfile:{0} /threads:{1} /timeout:{2}", _configfilePath, threads, timeout);

            if (_outfilePath != "")
            {
                arguments.AppendFormat(" /outfile:{0}", _outfilePath);
            }

            exitCode = _systemCheckProcess.Run(arguments.ToString());
            // SystemCheck returns 1 on success and -1 on failure.
            if (exitCode != 1)
            {
                throw new SystemCheckException("SystemCheck failed to run.", _systemCheckProcess.Output);
            }
        }


    }

    public class SystemCheckException : ProcessException
    {
        public SystemCheckException() : base("SystemCheck") { }
        public SystemCheckException(string message) : base("SystemCheck", message) { }
        public SystemCheckException(string message, Exception innerException) : base("SystemCheck", message, innerException) { }
        public SystemCheckException(string message, string output) : base("SystemCheck", message, output) { }
        public SystemCheckException(string message, string output, Exception innerException)
            :
            base("SystemCheck", message, output, innerException) { }

        public override string Message
        {
            get
            {
                return string.Format("{0}\r\nSystemCheck Output:\r\n{1}\r\nEnd SystemCheck Output\r\n",
                    base.Message, base.ProcessOutput);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup\ConfigFiles\ConfigFileSerializer.cs ===
using System;
using System.IO;
using System.Xml;
using System.Xml.Serialization;

/// <summary>
/// Utility class for serializing and deserializing various configuration files.
/// </summary>
public static class ConfigFileSerializer
{
    public static object FromXml(Type configFileType, string configFilePath)
    {
        if (null == configFilePath)
        {
            throw new ArgumentNullException("configFilePath");
        }

        if (!File.Exists(configFilePath))
        {
            return null;
        }

        object configObj = null;
        StreamReader reader = null;
        using (reader = new StreamReader(configFilePath))
        {
            XmlTextReader xmlReader = null;
            XmlSerializer serializer = null;
            using (xmlReader = new XmlTextReader(reader))
            {
                serializer = new XmlSerializer(configFileType);
                configObj = serializer.Deserialize(xmlReader);
            }
        }

        return configObj;
    }

    public static void ToXml(string configFilePath, object configObject)
    {
        if (null == configFilePath)
        {
            throw new ArgumentNullException("configFilePath");
        }

        if (configObject == null)
            return;

        /*
         * We need to go through the pain of creating an XmlDocument from
         * the serialized XML stream so that when we can duplicate the
         * format of the config file when it's saved from the tools.
         */
        XmlDocument doc = new XmlDocument();
        using (XmlTextWriter xtw = new XmlTextWriter(configFilePath, System.Text.Encoding.Unicode))
        {
            xtw.Formatting = Formatting.Indented;
            xtw.Indentation = 2;
            xtw.IndentChar = ' ';

            XmlSerializer serializer = new XmlSerializer(configObject.GetType());
            using (StringWriter sw = new StringWriter())
            {
                serializer.Serialize(sw, configObject);
                doc.LoadXml(sw.ToString());
                doc.Save(xtw);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup\ConfigFiles\LiveTitleConfig.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.IO;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;

namespace ServerTestFramework.STFTools.ConfigFiles
{
    public enum Generation
    {
        Unknown = 0,
        Xbox,
        Xenon
    }

    public struct LtcDeclarations
    {
        public const string SchemaVersion = "http://www.xboxlive.com/livetitleconfig";
    }

    [XmlType(Namespace=LtcDeclarations.SchemaVersion)]
    [XmlRoot(Namespace=LtcDeclarations.SchemaVersion, IsNullable=false)]
    public class LiveTitleConfig
    {
        public Generation   TitleGeneration;
        public uint         TitleID;
        public bool         AllowCrossPlatformPlay;

        //stats related
        public int          StatsMaxReads;
        public int          StatsMaxWrites;
        public int          StatsMaxLeaderboards;
        public bool         BountyExempt;
        public float        MuSigmaBeta;
        public float        MuSigmaTau;


        //Achievement related
        public int          MinAchievements;
        public int          MaxAchievements;
        public int          MinAchievementsWithCred;
        public int          MaxAchievementsWithCred;
        public int          MinCred;
        public int          MaxCred;
        public int          MaxUniqueAchImages;
        public int          MaxContexts;
        public int          MaxContextValues;

        public int          MaxGamerPictures;
        public int          MaxProperties;
        public int          MaxRichPresenceModes;
        public int          MaxGameModes;
        public bool         TitlePictureRequired;
        public bool         TitleMarketplacePictureRequired;

        //Alternate titleids
        public int          TitleRegion;
        public int          DiscMediaID;
        public int          LiveTitleID;
        public int          AlternateTitleID1;
        public int          AlternateTitleID2;
        public int          AlternateTitleID3;
        public int          AlternateTitleID4;
        public int          Service1;
        public int          Service1AltID;
        public int          Service2;
        public int          Service2AltID;
        public int          Service3;
        public int          Service3AltID;
        public int          Service4;
        public int          Service4AltID;

        public const uint   SkillLBIDBase = 0xfffe0000;
        public const uint   RankedLBIDBase = 0xffff0000;

        // match related
        [XmlElement("MatchServerList", typeof(string))]
        public string       MatchServerList;

        [XmlElement("MatchExpiration", typeof(Int32))]
        public int          MatchExpiration;

        [XmlElement("MatchDeleteDelaySeconds", typeof(Int32))]
        public int MatchDeleteDelaySeconds;

        [XmlElement("MatchSessionLimitJobExists", typeof(Boolean))]
        public bool MatchSessionLimitJobExists;

        [XmlElement("MatchSessionLimitEnabled", typeof(Boolean))]
        public bool MatchSessionLimitEnabled;

        [XmlElement("MatchSessionMaxAvail", typeof(Int32))]
        public int MatchSessionMaxAvail;

        [XmlElement("MatchSessionTruncateLevelAvail", typeof(Int32))]
        public int MatchSessionTruncateLevelAvail;

        [XmlElement("MatchSessionWarnLevelAvail", typeof(Int32))]
        public int MatchSessionWarnLevelAvail;

        [XmlElement("MatchSessionMaxUnavail", typeof(Int32))]
        public int MatchSessionMaxUnavail;

        [XmlElement("MatchSessionTruncateLevelUnavail", typeof(Int32))]
        public int MatchSessionTruncateLevelUnavail;

        [XmlElement("MatchSessionWarnLevelUnavail", typeof(Int32))]
        public int MatchSessionWarnLevelUnavail;

        [XmlElement("MatchSessionCleanupPeriodMinutes", typeof(Int32))]
        public int MatchSessionCleanupPeriodMinutes;

        [XmlElement("MatchSessionCleanupOffsetMinutes", typeof(Int32))]
        public int MatchSessionCleanupOffsetMinutes;

        // Miscellaneous section...
        [XmlElement("clusterid", typeof(string))]
        public string       ClusterId;

        [XmlElement("locale", typeof(string))]
        public string       Locale;

        [XmlElement(ElementName="LeaderboardConfigs", Type=typeof(LeaderboardConfigs), IsNullable=false, Form=XmlSchemaForm.Qualified, Namespace=LtcDeclarations.SchemaVersion)]
        public LeaderboardConfigs LeaderboardConfigs;

        /// <summary>
        /// Creates a LiveTitleConfig object from an LTC file
        /// </summary>
        /// <param name="ltcFile">Path and name of the LTC file to de-serialize.</param>
        /// <returns>A LiveTitleConfig object that represents the file.</returns>
        public static LiveTitleConfig FromXml(string ltcFile)
        {
            if (ltcFile == null)
            {
                throw new ArgumentNullException("ltcFile");
            }

            if (!File.Exists(ltcFile))
            {
                return null;
            }

            LiveTitleConfig ltc = null;
            StreamReader reader = null;
            try
            {
                reader = new StreamReader(ltcFile);
                ltc = FromXml(reader);
            }
            finally
            {
                if (reader != null)
                {
                    reader.Close();
                }
            }

            return ltc;
        }

        /// <summary>
        /// Deserializes LTC XML into a LiveTitleConfig object.
        /// </summary>
        /// <param name="xml">A TextReader object that holds the LTC XML.</param>
        /// <returns>A LiveTitleConfig object that represents the LTC data</returns>
        public static LiveTitleConfig FromXml(TextReader xml)
        {
            if (xml == null)
            {
                return null;
            }

            XmlTextReader xmlReader = null;
            XmlSerializer serializer = null;
            LiveTitleConfig ltc = null;
            try
            {
                xmlReader = new XmlTextReader(xml);
                serializer = new XmlSerializer(typeof(LiveTitleConfig));
                ltc = (serializer.Deserialize(xmlReader) as LiveTitleConfig);
            }
            finally
            {
                if (xmlReader != null)
                {
                    xmlReader.Close();
                }
            }

            return ltc;
        }

        /// <summary>
        /// Serailizes the LiveTitleConfig object to an LTC file
        /// </summary>
        /// <param name="ltcFile">Path and name of the target LTC file</param>
        public void ToXml(string ltcFile)
        {
            if (ltcFile == null)
            {
                throw new ArgumentNullException("ltcFile");
            }

            /*
             * We need to go through the pain of creating an XmlDocument from
             * the serialized XML stream so that when we can duplicate the
             * format of the LTC file when it's saved from LiveTitle.
             */
            StringWriter sw = new StringWriter();
            XmlDocument doc = new XmlDocument();
            XmlTextWriter xtw = new XmlTextWriter(ltcFile, System.Text.Encoding.Unicode);
            xtw.Formatting = Formatting.Indented;
            xtw.Indentation = 2;
            xtw.IndentChar = ' ';
            try
            {
                XmlSerializer serializer = new XmlSerializer(typeof(LiveTitleConfig));
                serializer.Serialize(sw, this);
                doc.LoadXml(sw.ToString());
                doc.Save(xtw);
            }
            finally
            {
                xtw.Close();
                sw.Close();
            }
        }
    }

    [XmlType(TypeName="LeaderboardConfigs",Namespace=LtcDeclarations.SchemaVersion),Serializable]
    public class LeaderboardConfigs
    {
        [XmlElement(ElementName="LeaderboardConfig",Type=typeof(LeaderboardConfig),IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=LtcDeclarations.SchemaVersion)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public LeaderboardConfigCollection _leaderboardConfigCollection;

        [XmlIgnore]
        public LeaderboardConfigCollection LeaderboardConfigCollection
        {
            get
            {
                if (_leaderboardConfigCollection == null) _leaderboardConfigCollection = new LeaderboardConfigCollection();
                return _leaderboardConfigCollection;
            }
            set { _leaderboardConfigCollection = value; }
        }

        public LeaderboardConfigs()
        {
        }
    }

    [Serializable]
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public class LeaderboardConfigCollection : ArrayList
    {
        public LeaderboardConfig Add(LeaderboardConfig obj)
        {
            base.Add(obj);
            return obj;
        }

        public LeaderboardConfig Add()
        {
            return Add(new LeaderboardConfig());
        }

        public void Insert(int index, LeaderboardConfig obj)
        {
            base.Insert(index, obj);
        }

        public void Remove(LeaderboardConfig obj)
        {
            base.Remove(obj);
        }

        new public LeaderboardConfig this[int index]
        {
            get { return base[index] as LeaderboardConfig; }
            set { base[index] = value; }
        }

        public LeaderboardConfigCollection()
        {
        }
    }

    public class LeaderboardConfig
    {
        [XmlAttribute()]
        public int LeaderboardID;

        [XmlAttribute()]
        public string HostingLbs;

        [XmlAttribute()]
        public bool IsCompetition = false;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup\ClientTools\WSTRunner.cs ===
using System;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml;
using System.Xml.Serialization;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.STFTools.ConfigFiles;
using xonline.common.config;
using xonline.common.protocol;

namespace ServerTestFramework.STFTools
{
    /// <summary>
    /// Utility class for running the WSTRunner tool.
    /// </summary>
    public class WSTRunner
    {
        const string DefaultWSTRunnerPath = "D:\\webroot\\xbltools";

        private string _manifestPath = "";
        private string _deploymentPath = "";
        private ProcessWrapper _wstRunnerProcess;
        private Report _report;

        public WSTRunner()
        {
            _wstRunnerProcess = new ProcessWrapper("WSTRunner", Path.Combine(DefaultWSTRunnerPath, "WSTRunner.exe"));
            //_wstRunnerProcess.SetEnvironmentVariable("XBL_CONFIG_SERVER", Global.DefaultNpdbSetting.ip);
            _wstRunnerProcess.Verbose = true;
            _report = new Report("WSTRunner");
        }

        public WSTRunner(string wstRunnerPath)
            : this()
        {
            WSTRunnerPath = wstRunnerPath;
        }

        /// <summary>
        /// Gets or sets the fully-qualified name of the WSTRunner executable.
        /// </summary>
        public string WSTRunnerPath
        {
            get { return _wstRunnerProcess.ExecutablePath; }
            set
            {
                _wstRunnerProcess.ExecutablePath = Path.GetFullPath(value);
                _wstRunnerProcess.WorkingDirectory = Path.GetDirectoryName(_wstRunnerProcess.ExecutablePath);
            }
        }

        /// <summary>
        /// Gets or sets the working directory for WSTRunner
        /// </summary>
        public string WorkingDirectory
        {
            get { return _wstRunnerProcess.WorkingDirectory; }
            set
            {
                if (value != null)
                {
                    _wstRunnerProcess.WorkingDirectory = Path.GetFullPath(value);
                }
                else
                {
                    _wstRunnerProcess.WorkingDirectory = null;
                }
            }
        }

        /// <summary>
        /// Gets or sets the fully-qualified name of the Manifest file used during database 
        /// deployment.
        /// </summary>
        public string ManifestFilePath
        {
            get { return _manifestPath; }
            set
            {
                if (value != null)
                {
                    _manifestPath = Path.GetFullPath(value);
                }
                else
                {
                    _manifestPath = "";
                }
            }
        }

        /// <summary>
        /// Gets or sets the fully-qualified name of the Deployment file used during database 
        /// deployment.
        /// </summary>
        public string DeploymentFilePath
        {
            get { return _deploymentPath; }
            set
            {
                if (value != null)
                {
                    _deploymentPath = Path.GetFullPath(value);
                }
                else
                {
                    _deploymentPath = "";
                }
            }
        }

        /// <summary>
        /// Gets the output text from the most recent run of WSTRunner.
        /// </summary>
        public string Output
        {
            get { return _wstRunnerProcess.Output; }
        }

        /// <summary>
        /// Exposes the Execution Timeout value for the underlying Process wrapper.
        /// </summary>
        public int ExecutionTimeout
        {
            get { return _wstRunnerProcess.ExecutionTimeout; }
            set { _wstRunnerProcess.ExecutionTimeout = value; }
        }

        /// <summary>
        /// Runs WSTRunner to setup a database using the provided manifest and deployment files.
        /// </summary>
        /// <param name="manifestFile">Manifest File to be used with the /m parameter. Required.</param>
        /// <param name="deploymentFile">Deployment File to be used with the /d parameter. Required.</param>
        public void WSTRunnerSetup(string manifestFile, string deploymentFile)
        {
            this.ManifestFilePath = manifestFile;
            this.DeploymentFilePath = deploymentFile;

            WSTRunnerSetup();
        }

        /// <summary>
        /// Runs WSTRunner to setup a database using the provided manifest and deployment files.
        /// </summary>
        public void WSTRunnerSetup()
        {
            int exitCode;
            StringBuilder arguments = new StringBuilder();

            arguments.AppendFormat("/setup");
            if (_manifestPath.Length > 0)
            {
                arguments.AppendFormat(" /m {0}", _manifestPath);
            }
            if (_deploymentPath.Length > 0)
            {
                arguments.AppendFormat(" /d {0}", _deploymentPath);
            }

            exitCode = _wstRunnerProcess.Run(arguments.ToString());
            if (exitCode != 0)
            {
                throw new WSTRunnerException("WSTRunner failed to setup the database.", _wstRunnerProcess.Output);
            }
        }

        /// <summary>
        /// Runs WSTRunner to drop a database using the provided manifest and deployment files.
        /// </summary>
        /// <param name="manifestFile">Manifest File to be used with the /m parameter. Required.</param>
        /// <param name="deploymentFile">Deployment File to be used with the /d parameter. Required.</param>
        public void WSTRunnerDrop(string manifestFile, string deploymentFile)
        {
            this.ManifestFilePath = manifestFile;
            this.DeploymentFilePath = deploymentFile;

            WSTRunnerSetup();
        }

        /// <summary>
        /// Runs WSTRunner to drop a database using the provided manifest and deployment files.
        /// </summary>
        public void WSTRunnerDrop()
        {
            int exitCode;
            StringBuilder arguments = new StringBuilder();

            arguments.AppendFormat("/drop");
            if (_manifestPath.Length > 0)
            {
                arguments.AppendFormat(" /m {0}", _manifestPath);
            }
            if (_deploymentPath.Length > 0)
            {
                arguments.AppendFormat(" /d {0}", _deploymentPath);
            }

            exitCode = _wstRunnerProcess.Run(arguments.ToString());
            if (exitCode != 0)
            {
                throw new WSTRunnerException("WSTRunner failed to drop the database.", _wstRunnerProcess.Output);
            }
        }

        /// <summary>
        /// Runs WSTRunner to manually allow invalid parameter variations.
        /// </summary>
        public void WSTRunnerManualParam(bool setupParam, bool dropParam, bool mParam, string manifestFile, bool dParam, string deploymentFile)
        {
            int exitCode;
            StringBuilder arguments = new StringBuilder();

            if (setupParam == true)
            {
                arguments.AppendFormat(" /setup");
            }
            if (dropParam == true)
            {
                arguments.AppendFormat(" /drop");
            }
            if (mParam == true)
            {
                arguments.AppendFormat(" /m");
            }
            if (manifestFile != null)
            {
                arguments.AppendFormat(" {0}", manifestFile);
            }
            if (dParam == true)
            {
                arguments.AppendFormat(" /d");
            }
            if (deploymentFile != null)
            {
                arguments.AppendFormat(" {0}", deploymentFile);
            }

            exitCode = _wstRunnerProcess.Run(arguments.ToString());
            if (exitCode != 0)
            {
                throw new WSTRunnerException("WSTRunner failed to drop the database.", _wstRunnerProcess.Output);
            }
        }

        /// <summary>
        /// Runs WSTRunner to manually allow invalid parameter variations.
        /// </summary>
        public void WSTRunnerManualParam(params string[] args)
        {
            int exitCode;
            StringBuilder arguments = new StringBuilder();

            if (args != null)
            {
                for (int i = 0; i < args.Length; i++)
                {
                    arguments.AppendFormat(" {0}", args[i]);
                }
            }

            exitCode = _wstRunnerProcess.Run(arguments.ToString());
            if (exitCode != 0)
            {
                throw new WSTRunnerException("WSTRunner failed to drop the database.", _wstRunnerProcess.Output);
            }
        }

        /// <summary>
        /// Runs WSTRunner to manually allow invalid parameter variations.
        /// </summary>
        public void WSTRunnerManualParam(string commandLine)
        {
            int exitCode;

            exitCode = _wstRunnerProcess.Run(commandLine);
            if (exitCode != 0)
            {
                throw new WSTRunnerException("WSTRunner failed to drop the database.", _wstRunnerProcess.Output);
            }
        }
    }

    public class WSTRunnerException : ProcessException
    {
        public WSTRunnerException() : base("WSTRunner") { }
        public WSTRunnerException(string message) : base("WSTRunner", message) { }
        public WSTRunnerException(string message, Exception innerException) : base("WSTRunner", message, innerException) { }
        public WSTRunnerException(string message, string wstRunnerOutput) : base("WSTRunner", message, wstRunnerOutput) { }
        public WSTRunnerException(string message, string wstRunnerOutput, Exception innerException)
            :
            base("WSTRunner", wstRunnerOutput, message, innerException) { }

        public override string Message
        {
            get
            {
                return string.Format("{0}\r\nWSTRunner Output:\r\n{1}\r\nEnd WSTRunner Output\r\n",
                    base.Message, base.ProcessOutput);
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup\ClientTools\XblCfg.cs ===
using System;
using System.IO;
using System.Diagnostics;
using System.Text;
using System.Net;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;

using xonline.common.config;

namespace ServerTestFramework.STFTools
{
    /// <summary>
    /// Utility class for running XblCfg
    /// </summary>
    public class XblCfg
    {
        // Known blob names
        public const string Blobs_DrmWhitelist      = "xbos_wmdrm_whitelist";

        // Search the path?
        const string DefaultXblCfgPath = "";


        private static int          XblCfgInstance = 0;
        private ProcessWrapper      _Process;
        private string              _TempFile;

        public XblCfg()
        {
            _Process = new ProcessWrapper("XblCfg", Path.Combine(DefaultXblCfgPath, "XblCfg.exe"));
            int id = System.Threading.Interlocked.Increment(ref XblCfgInstance);
            _TempFile = "xblcfg_temp_" + id + ".txt";

            // Turn off verbose output in ProcessWrapper
            ProcessWrapper.ro.DisableFilter(Report.DEBUG);
            ProcessWrapper.ro.DisableFilter(Report.INFO);
        }

        public XblCfg(string toolPath) : this()
        {
            _Process.ExecutablePath = Path.GetFullPath(toolPath);
        }

        /// <summary>
        /// Gets or sets path to XblCfg
        /// </summary>
        public string XblCfgPath
        {
            get { return _Process.ExecutablePath; }
            set { _Process.ExecutablePath = value; }
        }

        /// <summary>
        /// Gets the output text from the most recent run of XblCfg.
        /// </summary>
        public string Output
        {
            get { return _Process.Output; }
        }

        /// <summary>
        /// Add blob to npdb..t_config_blobs
        /// </summary>
        /// <param name="name">The name of the blob</param>
        /// <param name="blob">The blob data</param>
        public void AddBlob(string name, byte[] blob)
        {
            if (blob == null)
                return;

            File.WriteAllBytes(_TempFile, blob);

            try
            {
                string args = String.Format(
                    "-blob -add -name:{0} -file:{1}",
                    name,
                    _TempFile);

                if (_Process.Run(args) != 0)
                {
                    throw new XblCfgException("XblCfg Failed.", _Process.Output);
                }
            }
            finally
            {
                if (File.Exists(_TempFile))
                    File.Delete(_TempFile);
            }
        }

        /// <summary>
        /// Delete blob in npdb..t_config_blobs
        /// </summary>
        /// <param name="name">The name of the blob to delete</param>
        public void DeleteBlob(string name)
        {
            string args = String.Format(
                "-blob -delete -name:{0}",
                name);

            if (_Process.Run(args) != 0)
            {
                throw new XblCfgException("XblCfg Failed.", _Process.Output);
            }
        }

        /// <summary>
        /// Gets blob from npdb..t_config_blobs
        /// </summary>
        /// <param name="name">The name of the blob</param>
        /// <param name="blob">The blob data retrieved</param>
        public void GetBlob(string name, out byte[] blob)
        {
            blob = null;
            try
            {
                string args = String.Format(
                    "-blob -get -name:{0} -file:{1}",
                    name,
                    _TempFile);

                if (_Process.Run(args) != 0)
                {
                    throw new XblCfgException("XblCfg Failed.", _Process.Output);
                }
                
                if (File.Exists(_TempFile))
                    blob = File.ReadAllBytes(_TempFile);
            }
            finally
            {
                if (File.Exists(_TempFile))
                    File.Delete(_TempFile);
            }
        }


        /// <summary>
        /// Allows running XblCfg with custom argument string.
        /// Mainly used for negative testing.
        /// </summary>
        /// <param name="arguments">Argument string to be used when calling XblCfg.</param>
        public void RunXblCfg(string arguments)
        {
            if (_Process.Run(arguments) != 0)
            {
                throw new XblCfgException("XblCfg Failed.", _Process.Output);
            }
        }


        /// <summary>
        /// Reloads the xbos servers after changing the wmdrm whitelist blob.
        /// Helper function.
        /// </summary>
        public void ReloadWmdrmSettings()
        {
            IPEndPoint[] serverIps = Global.XEnv.GetInterface(Interface.xbos_int);
            foreach (IPEndPoint ip in serverIps)
            {
                string response;
                ManagementConsole.Execute(ip, "e :xbos reloadwmdrmsettings", out response);
                //Global.RO.Debug("[Xmgmt] Executed \"e :xbos reloadwmdrmsettings\" on 
                //{0}, response: {1}", ip.ToString(), response);
            }
        }



    }

    public class XblCfgException : ProcessException
    {
        public XblCfgException() : base("XblCfg") {}
        public XblCfgException(string message) : base("XblCfg", message) {}
        public XblCfgException(string message, Exception innerException) : base("XblCfg", message, innerException) {}
        public XblCfgException(string message, string output) : base("XblCfg", message, output) {}
        public XblCfgException(string message, string output, Exception innerException) :
            base("XblCfg", message, output, innerException) {}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup\ConfigFiles\MarketplaceConfig.cs ===
// Copyright 2004, Microsoft Corporation
// Sample Code - Use restricted to terms of use defined in the accompanying license agreement (EULA.doc)

//--------------------------------------------------------------
// Autogenerated by XSDObjectGen version 1.4.2.1
// Schema file: MarketplaceConfig.xsd
// Creation Date: 3/10/2006 9:57:00
//--------------------------------------------------------------

using System;
using System.IO;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;
using System.Collections;
using System.ComponentModel;

namespace ServerTestFramework.STFTools.ConfigFiles
{

	public struct MktPlaceDeclarations
	{
		public const string SchemaVersion = "http://www.xboxlive.com/xlast";
	}

	[XmlRoot(ElementName="XboxLiveSubmissionProject",Namespace=MktPlaceDeclarations.SchemaVersion,IsNullable=false),Serializable]
	public class XboxLiveMarketplaceProject
	{

		[XmlAttribute(AttributeName="Version",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __Version;
		
		[XmlIgnore]
		public string Version
		{ 
			get { return __Version; }
			set { __Version = value; }
		}

		[XmlElement(Type=typeof(MarketplaceConfigProject),ElementName="MarketplaceConfigProject",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=MktPlaceDeclarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public MarketplaceConfigProject __MarketplaceConfigProject;
		
		[XmlIgnore]
		public MarketplaceConfigProject MarketplaceConfigProject
		{
			get
			{
				if (__MarketplaceConfigProject == null) __MarketplaceConfigProject = new MarketplaceConfigProject();		
				return __MarketplaceConfigProject;
			}
			set {__MarketplaceConfigProject = value;}
		}

		public XboxLiveMarketplaceProject()
		{
		}

        public static XboxLiveMarketplaceProject FromXml(string marketplaceFile)
        {
            if (marketplaceFile == null)
            {
                throw new ArgumentNullException("marketplaceFile");
            }
            
            if (!File.Exists(marketplaceFile))
            {
                return null;
            }

            StreamReader reader = null;
            XmlTextReader xmlReader = null;
            XmlSerializer serializer = null;
            XboxLiveMarketplaceProject marketplace = null;
            try
            {
                reader = new StreamReader(marketplaceFile);
                xmlReader = new XmlTextReader(reader);
                serializer = new XmlSerializer(typeof(XboxLiveMarketplaceProject));
                marketplace = (serializer.Deserialize(xmlReader) as XboxLiveMarketplaceProject);
            }
            finally
            {
                if (xmlReader != null)
                {
                    xmlReader.Close();
                }
                if (reader != null)
                {
                    reader.Close();
                }
            }

            return marketplace;
        }

        public void ToXml(string marketplaceFile)
        {
            if (marketplaceFile == null)
            {
                throw new ArgumentNullException("marketplaceFile");
            }

            /*
             * We need to go through the pain of creating an XmlDocument from
             * the serialized XML stream so that when we can duplicate the
             * format of the Marketplace file when it's saved from XLAST.
             */
            StringWriter sw = new StringWriter();
            XmlDocument doc = new XmlDocument();
            XmlTextWriter xtw = new XmlTextWriter(marketplaceFile, System.Text.Encoding.Unicode);
            xtw.Formatting = Formatting.Indented;
            xtw.Indentation = 1;
            xtw.IndentChar = (char)0x9;
            try
            {
                XmlSerializer serializer = new XmlSerializer(typeof(XboxLiveMarketplaceProject));
                serializer.Serialize(sw, this);
                doc.LoadXml(sw.ToString());
                doc.Save(xtw);
            }
            finally
            {
                xtw.Close();
                sw.Close();
            }
        }
	}

	[XmlType(TypeName="MarketplaceConfigProject",Namespace=MktPlaceDeclarations.SchemaVersion),Serializable]
	public class MarketplaceConfigProject
	{

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="titleId",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __titleId;
		
		[XmlIgnore]
		public string titleId
		{ 
			get { return __titleId; }
			set { __titleId = value; }
		}

		[XmlAttribute(AttributeName="titleName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __titleName;
		
		[XmlIgnore]
		public string titleName
		{ 
			get { return __titleName; }
			set { __titleName = value; }
		}

		[XmlAttribute(AttributeName="titleType",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __titleType;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __titleTypeSpecified;
		
		[XmlIgnore]
		public uint titleType
		{ 
			get { return __titleType; }
			set { __titleType = value; __titleTypeSpecified = true; }
		}

		[XmlAttribute(AttributeName="name",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __name;
		
		[XmlIgnore]
		public string name
		{ 
			get { return __name; }
			set { __name = value; }
		}

		[XmlAttribute(AttributeName="projectVersion",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __projectVersion;
		
		[XmlIgnore]
		public string projectVersion
		{ 
			get { return __projectVersion; }
			set { __projectVersion = value; }
		}

		[XmlAttribute(AttributeName="schemaVersion",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __schemaVersion;
		
		[XmlIgnore]
		public string schemaVersion
		{ 
			get { return __schemaVersion; }
			set { __schemaVersion = value; }
		}

		[XmlElement(Type=typeof(LocalizedStrings),ElementName="LocalizedStrings",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=MktPlaceDeclarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public LocalizedStrings __LocalizedStrings;
		
		[XmlIgnore]
		public LocalizedStrings LocalizedStrings
		{
			get
			{
				if (__LocalizedStrings == null) __LocalizedStrings = new LocalizedStrings();		
				return __LocalizedStrings;
			}
			set {__LocalizedStrings = value;}
		}

		[XmlElement(Type=typeof(Images),ElementName="Images",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=MktPlaceDeclarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Images __Images;
		
		[XmlIgnore]
		public Images Images
		{
			get
			{
				if (__Images == null) __Images = new Images();		
				return __Images;
			}
			set {__Images = value;}
		}

		[XmlElement(Type=typeof(ProductInformation),ElementName="ProductInformation",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=MktPlaceDeclarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ProductInformation __ProductInformation;
		
		[XmlIgnore]
		public ProductInformation ProductInformation
		{
			get
			{
				if (__ProductInformation == null) __ProductInformation = new ProductInformation();		
				return __ProductInformation;
			}
			set {__ProductInformation = value;}
		}

		public MarketplaceConfigProject()
		{
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup\XLASTFactory\Achievements.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework.STFTools.ConfigFiles;

namespace ServerTestFramework.STFTools
{
    public partial class XLASTFactory
    {
        public void AddAchievements(XboxLiveSubmissionProject xlast, uint count, uint totalCred)
        {
            ushort credPerAchievment = (ushort)(count > 1 ? totalCred / count : totalCred);

            for (uint i = 1; i <= count; i++)
            {
                bool showUnachieved = (_rnd.Next() % 2) != 0;
                int type = _rnd.Next((int)achievementType.Completion, (int)achievementType.Other + 1);
                int imageId = _rnd.Next(1, 11);

                // Make sure we use up all the cred
                if (i == count)
                {
                    credPerAchievment += (ushort)(totalCred - (credPerAchievment * count));
                }

                AddAchievement(xlast, (achievementType)type, credPerAchievment, string.Format("AchievementImage{0:d02}.png", imageId), showUnachieved);
            }
        }

        public void AddAchievement(XboxLiveSubmissionProject xlast)
        {
            bool showUnachieved = (_rnd.Next() % 2) != 0;
            int type = _rnd.Next((int)achievementType.Completion, (int)achievementType.Other + 1);
            int imageId = _rnd.Next(1, 11);

            AddAchievement(xlast, (achievementType)type, 0, String.Format("AchievementImage{0:d02}.png", imageId), showUnachieved);
        }

        public void AddAchievement(XboxLiveSubmissionProject xlast, achievementType type, ushort cred, string imagePath, bool showUnachieved)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            Achievement ach = new Achievement();
            ach.clsid = AchievementCLSID;
            ach.id = xlast.GameConfigProject.Achievements.nextId;
            ach.achievementType = type;
            ach.cred = cred;
            ach.friendlyName = "Achievement" + ach.id.ToString("d3");
            ach.imageId = AddImage(xlast, imagePath);
            ach.titleStringId = AddString(xlast, ach.friendlyName + " Title String");
            ach.descriptionStringId = AddString(xlast, ach.friendlyName + " Description String");
            ach.showUnachieved = showUnachieved;
            if (showUnachieved)
            {
                ach.unachievedStringId = AddString(xlast, ach.friendlyName + " Unachieved String");
            }
            xlast.GameConfigProject.Achievements.Add(ach);
            xlast.GameConfigProject.Achievements.nextId++;
        }

        private void CreateAchievements(XboxLiveSubmissionProject xlast)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            xlast.GameConfigProject.Achievements.clsid = AchievementsCLSID;
            xlast.GameConfigProject.Achievements.nextId = 1;

            // If this is an Arcade title, we must provide exactly 12 Achievements with 200 cred
            if (xlast.GameConfigProject.titleType == (uint)XLASTTitleType.ArcadeTitle)
            {
                AddAchievements(xlast, 12, 200);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup\ConfigFiles\XmlOfferFile.cs ===
using System;
using System.Xml;

namespace ServerTestFramework.STFTools.ConfigFiles
{
    /// <summary>
    /// Wrapper for common operations on offer files.
    /// </summary>
    public class XmlOfferFile
    {
        private XmlDocument _offerXml;
        private XmlNamespaceManager _nsmgr;
        public enum platform{xbox1, xbox360};

		/// <summary>
		/// Create a representation of an xml offer file which can be accessed through
		/// XPATH calls.
		/// </summary>
		/// <param name="filename">File to open.</param>
		/// <param name="consoleType">Console type for this xml offer file.  Necessary because
		/// they use different namespaces.</param>
        public XmlOfferFile(string filename, platform consoleType)
        {
            _offerXml = new XmlDocument();
            _offerXml.Load(filename);
            _nsmgr = new XmlNamespaceManager(_offerXml.NameTable);
            if (consoleType == platform.xbox1) {
                _nsmgr.AddNamespace("xbo", "http://www.xboxlive.com/xboxoffer");
            } else if (consoleType == platform.xbox360) {
                _nsmgr.AddNamespace("xbo", "http://www.xboxlive.com/offer");                
            }
        }

		/// <summary>
		/// Returns the contentID of this offer.
		/// </summary>
        public string getContentId() 
        {
            XmlNode contentIdNode;
            XmlElement root = _offerXml.DocumentElement;
            contentIdNode=root.SelectSingleNode("xbo:content/xbo:contentID", _nsmgr);

            return contentIdNode.InnerXml.Substring(2);
        }

	        
		/// <summary>
		/// Returns a nodelist of nodes that match this xpath query.
		/// </summary>
		/// <param name="xpath">XPATH pointing to nodes to select.</param>
		/// <returns>XMLNodeList containing all nodes matched, or null if there are none.</returns>
		public XmlNodeList MultipleQuery(string xpath) {
            XmlNodeList ansList;
            XmlElement root = _offerXml.DocumentElement;
            ansList = root.SelectNodes(xpath, _nsmgr);
            if (ansList.Count == 0) {
                Global.RO.Warn("Warning:Multiple Xpath query has retrieved zero nodes.  Xpath query is:");
                Global.RO.Warn(xpath);
            }

            return ansList;
		}

		/// <summary>
		/// Returns the first XmlNode that matches the given XPATH.
		/// </summary>
		/// <param name="xpath">XPATH pointing to the node to select.</param>
		/// <returns>XmlNode of selected node, or null if there is no match.</returns>
        public XmlNode ArbitraryXpath(string xpath) {
            XmlNode contentIdNode;
            XmlElement root = _offerXml.DocumentElement;
            contentIdNode=root.SelectSingleNode(xpath, _nsmgr);
            if (contentIdNode == null) {
                Global.RO.Warn("Warning:Xpath query has retrieved zero nodes.  Xpath query is:");
                Global.RO.Warn(xpath);
            }
            return contentIdNode;
        }

        
		/// <summary>
		/// Takes a node already selected from this offer file, and selects from it again.  Required
		/// here because it needs the namespace manager.
		/// </summary>
		/// <param name="node">Node to select from.</param>
		/// <param name="xpath">XPATH to use relative to this node.</param>
		/// <returns>New XmlNode, relative from the given one.  Returns null if there is no match.</returns>
        public XmlNode RelativeXpath(XmlNode node, string xpath) {
            XmlNode ansNode = node.SelectSingleNode(xpath, _nsmgr);
            if (ansNode == null) {
                Global.RO.Warn("Warning:Relative Xpath query has retrieved zero nodes.  Xpath query is:");
                Global.RO.Warn(xpath);
            }
            return ansNode;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup\XLASTFactory\Contexts.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework.STFTools.ConfigFiles;

namespace ServerTestFramework.STFTools
{
    public partial class XLASTFactory
    {
        private const string GAME_TYPE_CONTEXT_ID = "0x0000800A";

        public void AddContexts(XboxLiveSubmissionProject xlast, int count, int maxValues)
        {
            for (int i = 1; i <= count; i++)
            {
                string id = AddContext(xlast);
                int values = _rnd.Next(1, maxValues + 1);

                for (int j = 1; j <= values; j++)
                {
                    AddContextValue(xlast, id, string.Format("Context{0:d3}Value{1:d3}",i, j));
                }
                if (values > 1)
                {
                    SetContextDefaultValue(xlast, id, (ushort)_rnd.Next(0, values));
                }
                else
                {
                    SetContextDefaultValue(xlast, id, 0);
                }
            }
        }

        public string AddContext(XboxLiveSubmissionProject xlast)
        {
            Context ctx = new Context();
            uint id = UInt32.Parse(xlast.GameConfigProject.Contexts.nextId.Substring(2), System.Globalization.NumberStyles.HexNumber);

            ctx.clsid = ContextCLSID;
            ctx.id = "0x" + id.ToString("X8");
            ctx.friendlyName = "Context" + id.ToString();
            ctx.stringId = AddString(xlast, ctx.friendlyName + " string.");
            ctx.defaultValue = 0;
            xlast.GameConfigProject.Contexts.Add(ctx);
            xlast.GameConfigProject.Contexts.nextId = "0x" + (id + 1).ToString("X8");
            return ctx.id;
        }

        public void AddContextValue(XboxLiveSubmissionProject xlast, string id, string name)
        {
            Context ctx = GetContext(xlast, id);
            if (ctx != null)
            {
                ContextValue ctxValue = new ContextValue();
                ctxValue.friendlyName = name;
                ctxValue.stringId = AddString(xlast, name + " String.");
                ctxValue.value = (ushort)ctx.Count;
                ctx.Add(ctxValue);
            }
        }

        public void SetContextDefaultValue(XboxLiveSubmissionProject xlast, string id, ushort defaultValue)
        {
            Context ctx = GetContext(xlast, id);
            if (ctx != null)
            {
                ctx.defaultValue = defaultValue;
            }
        }

        private Context GetContext(XboxLiveSubmissionProject xlast, string id)
        {
            foreach (Context ctx in xlast.GameConfigProject.Contexts)
            {
                if (string.Compare(ctx.id, id, true) == 0)
                    return ctx;
            }
            return null;
        }

        private void CreateContexts(XboxLiveSubmissionProject xlast)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            xlast.GameConfigProject.Contexts.clsid = ContextsCLSID;
            xlast.GameConfigProject.Contexts.nextId = "0x00000000";

            Context newCtx = new Context();
            newCtx.clsid = ContextCLSID;
            newCtx.id = GAME_TYPE_CONTEXT_ID;
            newCtx.defaultValue = 0;
            newCtx.friendlyName = "GAME_TYPE";
            newCtx.stringId = (ushort)XLASTDefaultString.X_STRINGID_GAMETYPE;

            ContextValue ctxValue = new ContextValue();
            ctxValue.friendlyName = "RANKED";
            ctxValue.stringId = (ushort)XLASTDefaultString.X_STRINGID_RANKED;
            ctxValue.value = 0;
            newCtx.Add(ctxValue);

            ctxValue = new ContextValue();
            ctxValue.friendlyName = "STANDARD";
            ctxValue.stringId = (ushort)XLASTDefaultString.X_STRINGID_STANDARD;
            ctxValue.value = 1;
            newCtx.Add(ctxValue);

            xlast.GameConfigProject.Contexts.Add(newCtx);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup\ConfigFiles\XmlOfferMap.cs ===
using System;
using System.Collections;
using System.IO;
using System.Xml;

namespace ServerTestFramework.STFTools.ConfigFiles
{
	/// <summary>
	/// Represents a mapping from an XML Offer file to the database entry it should
	/// correspond to.
	/// </summary>
    public class XmlOfferMap {
        ArrayList tests;
        Hashtable maps;


		/// <summary>
		/// Generate an XmlOfferMap, which will contain a parsed version of the map file.
		/// </summary>
		/// <param name="filename">Path to the offer map file.</param>
        public XmlOfferMap(string filename) {
            tests = new ArrayList();
            maps = new Hashtable();

            //Preprocess--grab the entire offer map and store it in a structure.
            StreamReader offerMapStream = File.OpenText(filename);
            String line;
            line = offerMapStream.ReadLine();
            while (line != null) {
                if (line.StartsWith("MAPDEFINITION")) { //this is a mapping of xpath, followed by
                                                       //string number pairs.  It is a simple conversion of 
													   //string to number, as is required by some offer fields.
                    string xpath = GetWord(line, 1);
                    Hashtable newMap = new Hashtable();
                    line = offerMapStream.ReadLine();
                    while (!line.StartsWith("END")) {
                        newMap.Add(GetWord(line,0), GetWord(line, 1));
                        line = offerMapStream.ReadLine();
                    }
                    line = offerMapStream.ReadLine();
                    maps.Add(xpath, newMap);
                    continue;
                }
                if (line.StartsWith("TABLE")) { //this is the start of a TableMapping--a table, followed by where all the
												//columns of that table map to in the offer file.
                    TableMapping newTest = new TableMapping(GetWord(line, 1));
                    ParseMultipleRowsInfo(offerMapStream, newTest, GetWord(line,2));

                    line = offerMapStream.ReadLine(); //we should now be reading the first map of
                                                      //Xpath to column name
                    while (!line.StartsWith("END")) {
                        if (line.StartsWith("CONSTANT") ||
                            line.StartsWith("MAP")) {
                            EntryMapping newMap = new EntryMapping(GetWord(line, 1), GetWord(line,2), GetWord(line,3));
                            newMap.flag = GetWord(line, 0);
                            newTest.dataMappings.Add(newMap);
                        } else if (!line.StartsWith("#")) {
                            EntryMapping newMap = new EntryMapping(GetWord(line, 0), GetWord(line,1), GetWord(line,2));
                            newTest.dataMappings.Add(newMap);
                        }
                        line = offerMapStream.ReadLine();
                    }
                    tests.Add(newTest);
                    line = offerMapStream.ReadLine();
                    continue;
                }
                if ((line.Equals("")) || (line.StartsWith("#"))) {
                    line = offerMapStream.ReadLine();
                    continue;
                }
                //if we get down here, we're parsing something we're not expecting.  Fail unhappily.
                Global.RO.Error("Unrecognized line:" + line);
                throw new Exception("Parse error in XmlOfferMap.cs: Unexpected data(neither comment, blank, nor recognized keyword");
            }
            offerMapStream.Close();
	}

		/// <summary>
		/// Parse the MANYROWS and ONEROW keywords.
		/// The MANYROWS keyword at the end of a table definition means that there will be
		/// multiple nodes that match the XPATH.  Each matching node corresponds to a separate
		/// row in the table.  A ONEROW keyword indicates that each field will be searched once,
		/// and matched against only one row in the database.
		/// </summary>
		/// <param name="offerMapStream">The offer map file</param>
		/// <param name="test">The table mapping to create</param>
		/// <param name="keyword">An optional keyword</param>
        private void ParseMultipleRowsInfo(StreamReader offerMapStream, TableMapping test, string keyword) {
            if (keyword.Equals("MANYROWS")) 
            {
                String line = offerMapStream.ReadLine();
                if (!line.StartsWith("LIST")) 
                {
                    throw new Exception("Parse error in XmlOfferMap.cs: Expecting LIST keyword after MANYROWS keyword");
                } 
                else 
                {
                    test.listQuery = GetWord(line, 1);
                    test.optionalTest = "";
                }
            } 
            else if (keyword.Equals("ONEROW")) 
            {
                test.listQuery = "";
                test.optionalTest = "";
 
            } 
            else if (keyword.Equals("OPTIONAL"))
            {
                test.listQuery = "";
                String line = offerMapStream.ReadLine();
                if (!line.StartsWith("TEST"))
                {
                    throw new Exception("Parse error in XmlOfferGapMap.cs: Expecting TEST keyword after OPTIONAL TABLE declared.");
                }
                else
                {
                    test.optionalTest = GetWord(line,1);
                }
            }
            else throw new Exception("Parse error in XmlOfferMap.cs: Table description must be MANYROWS, ONEROW or OPTIONAL");
        }

    
        //Get the num-th word in this line.  Words are separated by tabs, spaces, or newlines.
        public static string GetWord(string input, int num) {
            int curchar = 0;
            while (num > 0) {
                //skip a word
                while (!IsWhitespace(input[curchar])) {
                    curchar++;
                    if (curchar >= input.Length) {
                        Global.RO.Error("Error, attempt to read " + num  + " words, but line does not contain that many words.");
                        Global.RO.Error("Line text is:" + input);
                    }
                }
                //skip some spaces
                while (IsWhitespace(input[curchar])) {
                    curchar++;
                    if (curchar >= input.Length) {
                        Global.RO.Error("Error, attempt to read " + num  + " words, but line does not contain that many words.");
                        Global.RO.Error("Line text is:" + input);
                    }
                }
                num --;  //we've skipped a word.
            }
            int beginWord = curchar;
            while ((curchar < input.Length) && 
                   (!IsWhitespace(input[curchar]))) {
                curchar++;
            }
            return input.Substring(beginWord, curchar - beginWord);
        }

        public static bool IsWhitespace(char c) {
            return (c == ' ') || (c == '\n') || (c == '\t');
        }

		/// <summary>
		/// Combine the stored data of a map with the offer file to create a SELECT query.  This query should
		/// isolate a row in the database, and is expected to return precisely one entry.
		/// </summary>
		/// <param name="offer">The offer file to which this map will be applied.</param>
		/// <returns>An ArrayList of strings, each one SQL query that should return one row.</returns>
        public ArrayList CreateQueries(XmlOfferFile offer) {
            ArrayList queriesToReturn = new ArrayList();
            foreach (TableMapping test in tests) {
                // Skip over the table if the test node is set and the doesn't exist in the offer...
                if ((test.optionalTest.Equals(""))||(offer.ArbitraryXpath(test.optionalTest)!=null))
                {
                    if (test.listQuery.Equals("")) 
                    {
                        AddSingleQueryString(offer, test, queriesToReturn);
                    } 
                    else 
                    {
                        AddMultipleQueryStrings(offer, test, queriesToReturn);
                    }
                }
            }
            return queriesToReturn;
        }

        
		/// <summary>
		/// Given a table described by a MANYROWS keyword, add multiple SQL queries, one for each
		/// corresponding tag found in the offer file.  Add each of them to queriesToReturn.
		/// </summary>
		/// <param name="offer">Offer this map is appliped to.</param>
		/// <param name="test">Table being checked.</param>
		/// <param name="queriesToReturn">A list of queries that will have strings added.</param>
        public void AddMultipleQueryStrings(XmlOfferFile offer, TableMapping test, ArrayList queriesToReturn) {
            bool quiet = false;
            XmlNodeList offerNodes = offer.MultipleQuery(test.listQuery); //all nodes that match the
                                                                          //LIST xpath
            //go through each node, forming a query off of each.
            if (offerNodes.Count >= 100) {  //let's not go overboard.
                Global.RO.Warn("Over 100 queries generated for this MANYROWS command.  Suppressing query output.");
                quiet = true;
            }
            foreach (XmlNode node in offerNodes) {
                String query = "SELECT COUNT(*) FROM " + test.tableName + " WHERE ";
                bool firstClause = true;
                foreach (EntryMapping dataMap in test.dataMappings) {
                    if (!firstClause) {
                        query += " AND ";
                    }
                    query += GenerateOneWhereClause(offer, dataMap, node);
                    firstClause = false;
                }
                if (!quiet) {
                    Global.RO.Warn(query);
                }
                queriesToReturn.Add(query);                
            }
        }

        
		/// <summary>
		/// Given a ONEROW table description, add the SQL query string that would be used to verify
		/// this row is present in the DB.  Add the string to queriesToReturn.
		/// </summary>
		/// <param name="offer">Offer this map is appliped to.</param>
		/// <param name="test">Table being checked.</param>
		/// <param name="queriesToReturn">A list of queries that will have one string added.</param>
        public void AddSingleQueryString(XmlOfferFile offer, TableMapping test, ArrayList queriesToReturn) {
            String query = "SELECT COUNT(*) FROM " + test.tableName + " WHERE ";
            bool firstClause = true;
            foreach (EntryMapping dataMap in test.dataMappings) {
                if (!firstClause) {
                    query += " AND ";
                }
                query += GenerateOneWhereClause(offer, dataMap, null);
                firstClause = false;
            }
            Global.RO.Warn(query);
            queriesToReturn.Add(query);
        }

		/// <summary>
		/// Used when generating an SQL select query.  This iterates through all the fields that should
		/// be checked.  For each one it pulls the appropriate data out of the offer file, using the XPATH for
		/// that field.  It returns a boolean test to determine if the data in the db matches that of the offer file.
		/// </summary>
		/// <param name="offer">Offer this map is appliped to.</param>
		/// <param name="dataMap">A single instance of mapping one XPATH in the offer file to one field in the DB.</param>
		/// <param name="multipleQueryNode">If the table was defined using MANYROWS, the XPATH is taken relative to this node.</param>
		/// <returns>A string to be added to a where clause.  e.g. "bi_offer_id = 0xfffe07d100000001"</returns>
		public string GenerateOneWhereClause(XmlOfferFile offer, EntryMapping dataMap, XmlNode multipleQueryNode) {
            string whereClause = "";
            string expectedValue;

            //handle specific flags
            if (dataMap.flag.Equals("CONSTANT")) {
                expectedValue = dataMap.offerXmlXPATH;  //if constant, the XPATH is actually the value.
            } else if (multipleQueryNode != null) {
                //this means we want a relative XPATH, from a given node.
                expectedValue = offer.RelativeXpath(multipleQueryNode, dataMap.offerXmlXPATH).InnerXml;
            } else {
                //otherwise it's arbitrary, from the top.
                expectedValue = offer.ArbitraryXpath(dataMap.offerXmlXPATH).InnerXml;
            }
            if (dataMap.flag.Equals("MAP")) {
                if (maps[dataMap.offerXmlXPATH] == null) {
                    Global.RO.Warn("Warning:There is no MAPDEFINITION for the given xpath, " + dataMap.offerXmlXPATH);
                }
                expectedValue = (string) ((Hashtable) maps[dataMap.offerXmlXPATH])[expectedValue];
            }

            //handle datatype-specific issues
            if (dataMap.dataType.Equals("datetime")) {  //trim off everything from the dot onwards.
                //expectedValue = expectedValue.Substring(0, expectedValue.IndexOf('.'));
                DateTime dt = Convert.ToDateTime(expectedValue);
                expectedValue = dt.ToString("s");
            }

            whereClause += dataMap.columnName + " = ";
            if (dataMap.NeedsQuotes()) {
                whereClause += "\'" + expectedValue + "\'";
            } else {
                whereClause += expectedValue;
            }
            return whereClause;
        }

    }

	/// <summary>
	/// A mapping of the fields of one table with the XPATHs that locate those fields in an offer file.
	/// </summary>
	public class TableMapping {
        public string tableName;
        public ArrayList dataMappings;
        public string listQuery;  //this is optional.  If MANYROWS is used to define the table,
                                  //then we expect multiple tags of the same name.  This XPATH query
                                  //will select them all.  The data mappings will be relative,
                                  //unless they have a keyword STATIC
        public string optionalTest;  // Makes this Table optional.  Should be an xpath statement.  
                                     // If it returns NULL, it will skip the check on this table.

        public TableMapping(string tableName) {
            this.tableName = tableName;
            dataMappings = new ArrayList();
            listQuery = null; //must be set during parse.
            optionalTest = null;
        }
    }

	//a mapping of one particular field to one particular XPATH.
    public class EntryMapping {
        public string offerXmlXPATH;
        public string dataType;
        public string columnName;
        public string flag;

        public EntryMapping (string offerXmlXPATH, string dataType, string columnName) {
            this.offerXmlXPATH = offerXmlXPATH;
            this.dataType = dataType;
            this.columnName = columnName;
            this.flag = "";
        }
        //returns true if this data type needs quotes in the SQL query.
        public bool NeedsQuotes() {
            return (dataType.StartsWith("datetime")) ||
                (dataType.IndexOf("char") != -1);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup\ConfigFiles\XboxConfig.cs ===
// Copyright 2004, Microsoft Corporation
// Sample Code - Use restricted to terms of use defined in the accompanying license agreement (EULA.doc)

//--------------------------------------------------------------
// Autogenerated by XSDObjectGen version 1.4.2.1
// Schema file: xboxConfig.xsd
// Creation Date: 2/24/2006 11:01:59
//--------------------------------------------------------------

using System;
using System.IO;
using System.Xml;
using System.Xml.Serialization;
using System.Collections;
using System.Xml.Schema;
using System.ComponentModel;

namespace ServerTestFramework.STFTools.ConfigFiles
{

	public struct XboxDeclarations
	{
		public const string SchemaVersion = "";
	}


	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class XboxLocalizedStringCollection : ArrayList
	{
		public XboxLocalizedString Add(XboxLocalizedString obj)
		{
			base.Add(obj);
			return obj;
		}

		public XboxLocalizedString Add()
		{
			return Add(new XboxLocalizedString());
		}

		public void Insert(int index, XboxLocalizedString obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(XboxLocalizedString obj)
		{
			base.Remove(obj);
		}

		new public XboxLocalizedString this[int index]
		{
			get { return (XboxLocalizedString) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class XboxTranslationCollection : ArrayList
	{
		public XboxTranslation Add(XboxTranslation obj)
		{
			base.Add(obj);
			return obj;
		}

		public XboxTranslation Add()
		{
			return Add(new XboxTranslation());
		}

		public void Insert(int index, XboxTranslation obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(XboxTranslation obj)
		{
			base.Remove(obj);
		}

		new public XboxTranslation this[int index]
		{
			get { return (XboxTranslation) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class XboxConfigurationCollection : ArrayList
	{
		public XboxConfiguration Add(XboxConfiguration obj)
		{
			base.Add(obj);
			return obj;
		}

		public XboxConfiguration Add()
		{
			return Add(new XboxConfiguration());
		}

		public void Insert(int index, XboxConfiguration obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(XboxConfiguration obj)
		{
			base.Remove(obj);
		}

		new public XboxConfiguration this[int index]
		{
			get { return (XboxConfiguration) base[index]; }
			set { base[index] = value; }
		}
	}


    /// <summary>
    /// Root class for deserializing an Xbox 1 configuration file (.XBOX).
    /// </summary>
	[XmlRoot(ElementName="XboxConfiguration",IsNullable=false),Serializable]
	public class XboxConfiguration
	{

		[XmlElement(Type=typeof(XboxGameConfig),ElementName="GameConfig",IsNullable=false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public XboxGameConfig _GameConfig;
		
		[XmlIgnore]
		public XboxGameConfig GameConfig
		{
			get
			{
				if (_GameConfig == null) _GameConfig = new XboxGameConfig();		
				return _GameConfig;
			}
			set {_GameConfig = value;}
		}

		[XmlElement(Type=typeof(XboxLocalizedStrings),ElementName="LocalizedStrings",IsNullable=false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public XboxLocalizedStrings _LocalizedStrings;
		
		[XmlIgnore]
		public XboxLocalizedStrings LocalizedStrings
		{
			get
			{
				if (_LocalizedStrings == null) _LocalizedStrings = new XboxLocalizedStrings();		
				return _LocalizedStrings;
			}
			set {_LocalizedStrings = value;}
		}

		[XmlElement(ElementName="Bounty",IsNullable=false,DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public bool _Bounty;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public bool _BountySpecified;
		
		[XmlIgnore]
		public bool Bounty
		{ 
			get { return _Bounty; }
			set { _Bounty = value; _BountySpecified = true; }
		}

		[XmlElement(Type=typeof(XboxWebdbInfo),ElementName="WebdbInfo",IsNullable=false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public XboxWebdbInfo _WebdbInfo;
		
		[XmlIgnore]
		public XboxWebdbInfo WebdbInfo
		{
			get
			{
				if (_WebdbInfo == null) _WebdbInfo = new XboxWebdbInfo();		
				return _WebdbInfo;
			}
			set {_WebdbInfo = value;}
		}

		[XmlElement(Type=typeof(XboxProductInformation),ElementName="ProductInformation",IsNullable=false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public XboxProductInformation _ProductInformation;
		
		[XmlIgnore]
		public XboxProductInformation ProductInformation
		{
			get
			{
				if (_ProductInformation == null) _ProductInformation = new XboxProductInformation();		
				return _ProductInformation;
			}
			set {_ProductInformation = value;}
		}

		public XboxConfiguration()
		{
		}

        /// <summary>
        /// Static method to deserialize an XBOX file into a hierarchy of objects.
        /// </summary>
        /// <param name="xboxFile">The name of the XBOX file to deserialize.</param>
        /// <returns>An XboxConfiguration object that describes the XBOX file.</returns>
        public static XboxConfiguration FromXml(string xboxFile)
        {
            if (xboxFile == null)
            {
                throw new ArgumentNullException("xboxFile");
            }
            
            if (!File.Exists(xboxFile))
            {
                return null;
            }

            StreamReader reader = null;
            XboxConfiguration xbox = null;
            try
            {
                reader = new StreamReader(xboxFile);
                xbox = FromXml(reader);
            }
            finally
            {
                if (reader != null)
                {
                    reader.Close();
                }
            }

            return xbox;
        }

        /// <summary>
        /// Static method to deserialize an XBOX XML stream into a hierarchy of objects.
        /// </summary>
        /// <param name="xboxFile">A TextReader object that contains the raw XML of an XBOX file.</param>
        /// <returns>An XboxConfiguration object that describes the XBOX file.</returns>
        public static XboxConfiguration FromXml(TextReader xboxXml)
        {
            XmlTextReader xmlReader = null;
            XmlSerializer serializer = null;
            XboxConfiguration xbox = null;
            try
            {
                xmlReader = new XmlTextReader(xboxXml);
                serializer = new XmlSerializer(typeof(XboxConfiguration));
                xbox = (serializer.Deserialize(xmlReader) as XboxConfiguration);
            }
            finally
            {
                if (xmlReader != null)
                {
                    xmlReader.Close();
                }
            }

            return xbox;
        }

        /// <summary>
        /// Serializes the object hierarchy out to an XBOX file.
        /// </summary>
        /// <param name="xboxFile">The name of the XBOX file to create.</param>
        public void ToXml(string xboxFile)
        {
            if (xboxFile == null)
            {
                throw new ArgumentNullException("xboxFile");
            }

            StreamWriter stream = new StreamWriter(xboxFile);
            StringWriter sw = new StringWriter();
            try
            {
                XmlSerializer serializer = new XmlSerializer(typeof(XboxConfiguration));
                serializer.Serialize(sw, this);
                stream.WriteLine(sw);
            }
            finally
            {
                stream.Close();
                sw.Close();
            }
        }
	}


	[XmlType(TypeName="GameConfig"),Serializable]
	public class XboxGameConfig
	{

		[XmlAttribute(AttributeName="version",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string _version;
		
		[XmlIgnore]
		public string Version
		{ 
			get { return _version; }
			set { _version = value; }
		}

		[XmlAttribute(AttributeName="titleId",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string _titleId;
		
		[XmlIgnore]
		public string TitleId
		{ 
			get { return _titleId; }
			set { _titleId = value; }
		}

		[XmlAttribute(AttributeName="titleName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string _titleName;
		
		[XmlIgnore]
		public string TitleName
		{ 
			get { return _titleName; }
			set { _titleName = value; }
		}

		[XmlAttribute(AttributeName="name",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string _name;
		
		[XmlIgnore]
		public string Name
		{ 
			get { return _name; }
			set { _name = value; }
		}

		[XmlAttribute(AttributeName="projectVersion",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string _projectVersion;
		
		[XmlIgnore]
		public string ProjectVersion
		{ 
			get { return _projectVersion; }
			set { _projectVersion = value; }
		}

		public XboxGameConfig()
		{
		}
	}


	[XmlType(TypeName="LocalizedStrings"),Serializable]
	public class XboxLocalizedStrings
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return LocalizedStringCollection.GetEnumerator();
		}

		public XboxLocalizedString Add(XboxLocalizedString obj)
		{
			return LocalizedStringCollection.Add(obj);
		}

		[XmlIgnore]
		public XboxLocalizedString this[int index]
		{
			get { return (XboxLocalizedString) LocalizedStringCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return LocalizedStringCollection.Count; }
        }

        public void Clear()
		{
            LocalizedStringCollection.Clear();
        }

		public XboxLocalizedString Remove(int index) 
		{ 
            XboxLocalizedString obj = LocalizedStringCollection[index];
            LocalizedStringCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            LocalizedStringCollection.Remove(obj);
        }

		[XmlElement(Type=typeof(XboxLocalizedString),ElementName="LocalizedString",IsNullable=false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public XboxLocalizedStringCollection _LocalizedStringCollection;
		
		[XmlIgnore]
		public XboxLocalizedStringCollection LocalizedStringCollection
		{
			get
			{
				if (_LocalizedStringCollection == null) _LocalizedStringCollection = new XboxLocalizedStringCollection();
				return _LocalizedStringCollection;
			}
			set {_LocalizedStringCollection = value;}
		}

		public XboxLocalizedStrings()
		{
		}
	}


	[XmlType(TypeName="XboxLocalizedString"),Serializable]
	public class XboxLocalizedString
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return TranslationCollection.GetEnumerator();
		}

		public XboxTranslation Add(XboxTranslation obj)
		{
			return TranslationCollection.Add(obj);
		}

		[XmlIgnore]
		public XboxTranslation this[int index]
		{
			get { return (XboxTranslation) TranslationCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return TranslationCollection.Count; }
        }

        public void Clear()
		{
            TranslationCollection.Clear();
        }

		public XboxTranslation Remove(int index) 
		{ 
            XboxTranslation obj = TranslationCollection[index];
            TranslationCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            TranslationCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="id",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string _id;
		
		[XmlIgnore]
		public string Id
		{ 
			get { return _id; }
			set { _id = value; }
		}

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string _friendlyName;
		
		[XmlIgnore]
		public string FriendlyName
		{ 
			get { return _friendlyName; }
			set { _friendlyName = value; }
		}

		[XmlElement(Type=typeof(XboxTranslation),ElementName="Translation",IsNullable=true)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public XboxTranslationCollection _TranslationCollection;
		
		[XmlIgnore]
		public XboxTranslationCollection TranslationCollection
		{
			get
			{
				if (_TranslationCollection == null) _TranslationCollection = new XboxTranslationCollection();
				return _TranslationCollection;
			}
			set {_TranslationCollection = value;}
		}

		public XboxLocalizedString()
		{
		}
	}


	[XmlType(TypeName="XboxTranslation"),Serializable]
	public class XboxTranslation
	{

		[XmlAttribute(AttributeName="locale",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string _locale;
		
		[XmlIgnore]
		public string Locale
		{ 
			get { return _locale; }
			set { _locale = value; }
		}

		[XmlText(DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string _Value;
		
		[XmlIgnore]
		public string Value
		{ 
			get { return _Value; }
			set { _Value = value; }
		}

		public XboxTranslation()
		{
		}
	}


	[XmlType(TypeName="XboxWebdbInfo"),Serializable]
	public class XboxWebdbInfo
	{

		[XmlElement(ElementName="ESRB",IsNullable=false,DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string _ESRB;
		
		[XmlIgnore]
		public string ESRB
		{ 
			get { return _ESRB; }
			set { _ESRB = value; }
		}

		[XmlElement(ElementName="ClusterID",IsNullable=false,DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string _ClusterID;
		
		[XmlIgnore]
		public string ClusterID
		{ 
			get { return _ClusterID; }
			set { _ClusterID = value; }
		}

		[XmlElement(ElementName="DefaultLocale",IsNullable=false,DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string _DefaultLocale;
		
		[XmlIgnore]
		public string DefaultLocale
		{ 
			get { return _DefaultLocale; }
			set { _DefaultLocale = value; }
		}

		public XboxWebdbInfo()
		{
		}
	}


	[XmlType(TypeName="XboxProductInformation"),Serializable]
	public class XboxProductInformation
	{

		[XmlElement(Type=typeof(XboxPublisher),ElementName="Publisher",IsNullable=false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public XboxPublisher _Publisher;
		
		[XmlIgnore]
		public XboxPublisher Publisher
		{
			get
			{
				if (_Publisher == null) _Publisher = new XboxPublisher();		
				return _Publisher;
			}
			set {_Publisher = value;}
		}

		public XboxProductInformation()
		{
		}
	}


	[XmlType(TypeName="XboxPublisher"),Serializable]
	public class XboxPublisher
	{

		[XmlAttribute(AttributeName="name",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string _name;
		
		[XmlIgnore]
		public string Name
		{ 
			get { return _name; }
			set { _name = value; }
		}

		public XboxPublisher()
		{
		}
	}


	[XmlRoot(ElementName="NewDataSet",IsNullable=false),Serializable]
	public class NewDataSet
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return XboxConfigurationCollection.GetEnumerator();
		}

		public XboxConfiguration Add(XboxConfiguration obj)
		{
			return XboxConfigurationCollection.Add(obj);
		}

		[XmlIgnore]
		public XboxConfiguration this[int index]
		{
			get { return (XboxConfiguration) XboxConfigurationCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return XboxConfigurationCollection.Count; }
        }

        public void Clear()
		{
            XboxConfigurationCollection.Clear();
        }

		public XboxConfiguration Remove(int index) 
		{ 
            XboxConfiguration obj = XboxConfigurationCollection[index];
            XboxConfigurationCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            XboxConfigurationCollection.Remove(obj);
        }

		[XmlElement(Type=typeof(XboxConfiguration),ElementName="XboxConfiguration",IsNullable=false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public XboxConfigurationCollection _XboxConfigurationCollection;
		
		[XmlIgnore]
		public XboxConfigurationCollection XboxConfigurationCollection
		{
			get
			{
				if (_XboxConfigurationCollection == null) _XboxConfigurationCollection = new XboxConfigurationCollection();
				return _XboxConfigurationCollection;
			}
			set {_XboxConfigurationCollection = value;}
		}

		public NewDataSet()
		{
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup\ConfigFiles\XscConfig.cs ===
using System;
using System.IO;
using System.Xml;
using System.Xml.Serialization;
using System.Collections;
using System.Xml.Schema;
using System.ComponentModel;

namespace ServerTestFramework.STFTools.ConfigFiles
{
    public struct XscDeclarations
    {
        public const string SchemaVersion = "http://www.xboxlive.com";
    }

    [Serializable]
    public enum ContainerType
    {
        [XmlEnum("individual")] Individual,
        [XmlEnum("units")] Units,
        [XmlEnum("competitions")] Competitions
    }

    [XmlType(IncludeInSchema=false)]
    public enum ContainerClassChoices
    {
        Leaderboard,
        LeaderboardTemplate
    }

    /// <summary>
    /// Root class for the Xbox1 Leaderboard Configuration (XSC) file hierarchy.
    /// </summary>
    [XmlRoot(ElementName="Title",Namespace=XscDeclarations.SchemaVersion,IsNullable=false),Serializable]
    public class XboxLeaderboardConfiguration
    {
        [XmlAttribute(AttributeName="TitleID",DataType="string")]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public string _titleId;

        /// <summary>
        /// The value ot the TitleID attribute of the Title element
        /// </summary>
        [XmlIgnore]
        public string TitleId
        {
            get { return _titleId; }
            set { _titleId = value; }
        }

        [XmlAttribute(AttributeName="UnitLeaderboardDecayConstant", DataType="int")]
        public int _unitLeaderboardDecayConstant;

        /// <summary>
        /// The value of the UnitLeaderboardDecayConstant attribute of the Title element
        /// </summary>
        [XmlIgnore]
        public int UnitLeaderboardDecayConstant
        {
            get { return _unitLeaderboardDecayConstant; }
            set { _unitLeaderboardDecayConstant = value; }
        }

        [XmlAttribute(AttributeName="Version",DataType="string")]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public string _version;

        /// <summary>
        /// The value of the Version attribute of the Title element
        /// </summary>
        [XmlIgnore]
        public string Version
        {
            get { return _version; }
            set { _version = value; }
        }

        [XmlAttribute(AttributeName="Default_Locale",DataType="string")]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public string _defaultLocale;

        /// <summary>
        /// The value of the Default_Locale attribute of the Title element
        /// </summary>
        [XmlIgnore]
        public string DefaultLocale
        {
            get { return _defaultLocale; }
            set { _defaultLocale = value; }
        }

        [XmlElement(Type=typeof(XscLeaderboardContainer),ElementName="LeaderboardContainer",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=XscDeclarations.SchemaVersion)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public XscLeaderboardContainerCollection _leaderboardContainers;

        /// <summary>
        /// Collection of XscLeaderboardContainer objects that represent the three possible types of leaderboards in the file
        /// </summary>
        [XmlIgnore]
        public XscLeaderboardContainerCollection LeaderboardContainers
        {
            get
            {
                if (_leaderboardContainers == null) _leaderboardContainers = new XscLeaderboardContainerCollection();
                return _leaderboardContainers;
            }
            set { _leaderboardContainers = value; }
        }

        public XboxLeaderboardConfiguration()
        {
        }

        /// <summary>
        /// Static method to deserialize an XSC file into a class hierarchy
        /// </summary>
        /// <param name="xscFile">Full path and filename of the XSC file to deserialize</param>
        /// <returns>Returns an XboxLeaderboardConfiguration object defining the XSC file</returns>
        /// <example>
        /// XboxLeaderboardConfiguration xsc = XboxLeaderboardConfiguration.FromXml("FFFFAB08.XSC");
        /// </example>
        public static XboxLeaderboardConfiguration FromXml(string xscFile)
        {
            if (xscFile == null)
            {
                throw new ArgumentNullException("xscFile");
            }
            
            if (!File.Exists(xscFile))
            {
                return null;
            }

            StreamReader reader = null;
            XboxLeaderboardConfiguration xsc = null;
            try
            {
                reader = new StreamReader(xscFile);
                xsc = FromXml(reader);
            }
            finally
            {
                if (reader != null)
                {
                    reader.Close();
                }
            }

            return xsc;
        }

        /// <summary>
        /// Static method to deserialize raw XSC xml into a class hierarchy
        /// </summary>
        /// <param name="xscXml">A TextReader-derived object that contains the XSC XML to deserialize</param>
        /// <returns>Returns an XboxLeaderboardConfiguration object defining the XSC XML</returns>
        /// <example>
        /// StreamReader reader = new StreamReader("FFFFAB08.XSC");
        /// XboxLeaderboardConfiguration xsc = XboxLeaderboardConfiguration.FromXml(reader);
        /// </example>
        public static XboxLeaderboardConfiguration FromXml(TextReader xscXml)
        {
            if (xscXml == null)
            {
                return null;
            }

            XmlTextReader xmlReader = null;
            XmlSerializer serializer = null;
            XboxLeaderboardConfiguration xsc = null;
            try
            {
                xmlReader = new XmlTextReader(xscXml);
                serializer = new XmlSerializer(typeof(XboxLeaderboardConfiguration));
                xsc = (serializer.Deserialize(xmlReader) as XboxLeaderboardConfiguration);
            }
            finally
            {
                if (xmlReader != null)
                {
                    xmlReader.Close();
                }
            }

            return xsc;
        }

        /// <summary>
        /// Serializes Xbox1 leaderboard configuration data into an XSC file
        /// </summary>
        /// <param name="xscFile">Full path and filename to which the XML data should be serialized</param>
        public void ToXml(string xscFile)
        {
            if (xscFile == null)
            {
                throw new ArgumentNullException("xscFile");
            }

            StreamWriter stream = new StreamWriter(xscFile);
            StringWriter sw = new StringWriter();
            try
            {
                XmlSerializer serializer = new XmlSerializer(typeof(XboxLeaderboardConfiguration));
                serializer.Serialize(sw, this);
                stream.WriteLine(sw);
            }
            finally
            {
                stream.Close();
                sw.Close();
            }
        }
    }

    /// <summary>
    /// A collection of Leaderboard Containers in an XSC file.
    /// </summary>
    [Serializable]
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public class XscLeaderboardContainerCollection : ArrayList
    {
        /// <summary>
        /// Adds an existing XscLeaderboardContainer object to the collection
        /// </summary>
        /// <param name="obj">An existing XscLeaderboardContainer object</param>
        /// <returns>The added object</returns>
        public XscLeaderboardContainer Add(XscLeaderboardContainer obj)
        {
            base.Add(obj);
            return obj;
        }

        /// <summary>
        /// Creates a new XscLeaderboardContainer object and adds it to the collection
        /// </summary>
        /// <returns>The newly created object</returns>
        public XscLeaderboardContainer Add()
        {
            return Add(new XscLeaderboardContainer());
        }

        /// <summary>
        /// Inserts an existing XscLeaderboardContainer object into the collection
        /// </summary>
        /// <param name="index">0-based index at which the XscLeaderboardContainer object should be inserted</param>
        /// <param name="obj">The XscLeaderboardContainer object to insert</param>
        public void Insert(int index, XscLeaderboardContainer obj)
        {
            base.Insert(index, obj);
        }

        /// <summary>
        /// Removes the first occurance of the specified XscLeaderboardContainer object from the collection
        /// </summary>
        /// <param name="obj">The XscLeaderboardContainer object to remove</param>
        public void Remove(XscLeaderboardContainer obj)
        {
            base.Remove(obj);
        }

        new public XscLeaderboardContainer this[int index]
        {
            get { return base[index] as XscLeaderboardContainer; }
            set { base[index] = value; }
        }
    }

    [XmlType(TypeName="LeaderboardContainer",Namespace=XscDeclarations.SchemaVersion),Serializable]
    public class XscLeaderboardContainer
    {
        [XmlAttribute(AttributeName="type")]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public ContainerType _type;

        [XmlIgnore]
        public ContainerType Type
        {
            get { return _type; }
            set { _type = value; }
        }

        [XmlIgnore]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public ContainerClassChoices [] _ContainerClassTypes;

        [XmlElement(Type=typeof(XscLeaderboard),ElementName="Leaderboard",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=XscDeclarations.SchemaVersion)]
        [XmlElement(Type=typeof(XscLeaderboard),ElementName="LeaderboardTemplate",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=XscDeclarations.SchemaVersion)]
        [XmlChoiceIdentifier("_ContainerClassTypes")]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public XscLeaderboard [] _leaderboards;

        [XmlIgnore]
        public XscLeaderboard [] Leaderboards
        {
            get { return _leaderboards; }
            set { _leaderboards = value; }
        }

        public XscLeaderboardContainer()
        {
        }
    }

    [Serializable]
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public class XscLeaderboardCollection : ArrayList
    {
        public XscLeaderboard Add(XscLeaderboard obj)
        {
            base.Add(obj);
            return obj;
        }

        public XscLeaderboard Add()
        {
            return Add(new XscLeaderboard());
        }

        public void Insert(int index, XscLeaderboard obj)
        {
            base.Insert(index, obj);
        }

        public void Remove(XscLeaderboard obj)
        {
            base.Remove(obj);
        }

        new public XscLeaderboard this[int index]
        {
            get { return base[index] as XscLeaderboard; }
            set { base[index] = value; }
        }
    }

    [XmlType(TypeName="Leaderboard",Namespace=XscDeclarations.SchemaVersion),Serializable]
    public class XscLeaderboard
    {
        [XmlAttribute(AttributeName="ID",DataType="unsignedShort")]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public ushort _id;

        [XmlIgnore]
        public ushort Id
        {
            get { return _id; }
            set { _id = value; }
        }

        [XmlElement("Reset", typeof(ushort))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public ushort _reset;

        [XmlIgnore]
        public ushort Reset
        {
            get { return _reset; }
            set { _reset = value; }
        }

        [XmlElement("TopOneHundred", typeof(Boolean))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public bool _topOneHundred;

        [XmlIgnore]
        public bool TopOneHundred
        {
            get { return _topOneHundred; }
            set { _topOneHundred = value; }
        }

        [XmlElement("DecayDays", typeof(ushort))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public ushort _decayDays;

        [XmlIgnore]
        public ushort DecayDays
        {
            get { return _decayDays; }
            set { _decayDays = value; }
        }

        [XmlElement("TeamsLeaderboard", typeof(Boolean))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public bool _teamsLeaderboard;

        [XmlIgnore]
        public bool TeamsLeaderboard
        {
            get { return _teamsLeaderboard; }
            set { _teamsLeaderboard = value; }
        }

        [XmlElement("Arbitrate", typeof(Boolean))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public bool _arbitrated;

        [XmlIgnore]
        public bool Arbitrated
        {
            get { return _arbitrated; }
            set { _arbitrated = value; }
        }

        [XmlElement(ElementName="Attachments", Type=typeof(XscAttachments), IsNullable=false, Form=XmlSchemaForm.Qualified, Namespace=XscDeclarations.SchemaVersion)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public XscAttachments _attachments;

        [XmlIgnore]
        public XscAttachments Attachments
        {
            get { return _attachments; }
            set { _attachments = value; }
        }

        [XmlElement(ElementName="ELO", Type=typeof(XscElo), IsNullable=false, Form=XmlSchemaForm.Qualified, Namespace=XscDeclarations.SchemaVersion)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public XscElo _elo;

        [XmlIgnore]
        public XscElo Elo
        {
            get { return _elo; }
            set { _elo = value; }
        }

        [XmlElement(ElementName="Names", Type=typeof(XscNames), IsNullable=false, Form=XmlSchemaForm.Qualified, Namespace=XscDeclarations.SchemaVersion)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public XscNames _names;

        [XmlIgnore]
        public XscNames Names
        {
            get { return _names; }
            set { _names = value; }
        }

        [XmlElement(ElementName="FormattedValues", Type=typeof(XscFormattedValues), IsNullable=false, Form=XmlSchemaForm.Qualified, Namespace=XscDeclarations.SchemaVersion)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public XscFormattedValues _formattedValues;

        [XmlIgnore]
        public XscFormattedValues FormattedValues
        {
            get { return _formattedValues; }
            set { _formattedValues = value; }
        }

        [XmlElement(ElementName="RawAttributes", Type=typeof(XscRawAttributes), IsNullable=false, Form=XmlSchemaForm.Qualified, Namespace=XscDeclarations.SchemaVersion)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public XscRawAttributes _rawAttributes;

        [XmlIgnore]
        public XscRawAttributes RawAttributes
        {
            get { return _rawAttributes; }
            set { _rawAttributes = value; }
        }

        public XscLeaderboard()
        {
        }
    }

    [XmlType(TypeName="Attachments",Namespace=XscDeclarations.SchemaVersion),Serializable]
    public class XscAttachments
    {
        [XmlElement("Uploads", typeof(ushort))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public ushort _uploads;

        [XmlIgnore]
        public ushort Uploads
        {
            get { return _uploads; }
            set { _uploads = value; }
        }

        [XmlElement("Size", typeof(ushort))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public ushort _size;

        [XmlIgnore]
        public ushort Size
        {
            get { return _size; }
            set { _size = value; }
        }

        public XscAttachments()
        {
        }
    }

    [XmlType(TypeName="ELO",Namespace=XscDeclarations.SchemaVersion),Serializable]
    public class XscElo
    {
        [XmlElement("InitialPlayerRating", typeof(uint))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public uint _initialPlayerRating;

        [XmlIgnore]
        public uint InitialPlayerRating
        {
            get { return _initialPlayerRating; }
            set { _initialPlayerRating = value; }
        }

        [XmlElement("RatingScaleFactor", typeof(ushort))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public ushort _ratingScaleFactor;

        [XmlIgnore]
        public ushort RatingScaleFactor
        {
            get { return _ratingScaleFactor; }
            set { _ratingScaleFactor = value; }
        }

        [XmlElement("ExponentialBase", typeof(string))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public string _exponentialBase;

        [XmlIgnore]
        public string ExponentialBase
        {
            get { return _exponentialBase; }
            set { _exponentialBase = value; }
        }

        [XmlElement("MaxWeightRatingRangeArray", typeof(XscMaxWeightRatingRangeArray))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public XscMaxWeightRatingRangeArray _maxWeightRatingRangeArray;

        [XmlIgnore]
        public XscMaxWeightRatingRangeArray MaxWeightRatingRangeArray
        {
            get { return _maxWeightRatingRangeArray; }
            set { _maxWeightRatingRangeArray = value; }
        }

        public XscElo()
        {
        }
    }

    [XmlType(TypeName="MaxWeightRatingRangeArray",Namespace=XscDeclarations.SchemaVersion),Serializable]
    public class XscMaxWeightRatingRangeArray
    {
        [XmlElement(ElementName="MaxWeightRatingRange",Type=typeof(XscMaxWeightRatingRange),IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=XscDeclarations.SchemaVersion)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public XscMaxWeightRatingRangeCollection _maxWeightRatingRanges;

        [XmlIgnore]
        public XscMaxWeightRatingRangeCollection MaxWeightRatingRanges
        {
            get { return _maxWeightRatingRanges; }
            set { _maxWeightRatingRanges = value; }
        }

        public XscMaxWeightRatingRangeArray()
        {
        }
    }

    [Serializable]
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public class XscMaxWeightRatingRangeCollection : ArrayList
    {
        public XscMaxWeightRatingRange Add(XscMaxWeightRatingRange obj)
        {
            base.Add(obj);
            return obj;
        }

        public XscMaxWeightRatingRange Add()
        {
            return Add(new XscMaxWeightRatingRange());
        }

        public void Insert(int index, XscMaxWeightRatingRange obj)
        {
            base.Insert(index, obj);
        }

        public void Remove(XscMaxWeightRatingRange obj)
        {
            base.Remove(obj);
        }

        new public XscMaxWeightRatingRange this[int index]
        {
            get { return base[index] as XscMaxWeightRatingRange; }
            set { base[index] = value; }
        }

        public XscMaxWeightRatingRangeCollection()
        {
        }
    }

    [XmlType(TypeName="MaxWeightRatingRange",Namespace=XscDeclarations.SchemaVersion),Serializable]
    public class XscMaxWeightRatingRange
    {
        [XmlAttribute(AttributeName="start", DataType="unsignedInt")]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public uint _start;

        [XmlIgnore]
        public uint Start
        {
            get { return _start; }
            set { _start = value; }
        }

        [XmlAttribute(AttributeName="maxweight", DataType="unsignedShort")]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public ushort _maxWeight;

        [XmlIgnore]
        public ushort MaxWeight
        {
            get { return _maxWeight; }
            set { _maxWeight = value; }
        }

        public XscMaxWeightRatingRange()
        {
        }
    }

    [XmlType(TypeName="Names",Namespace=XscDeclarations.SchemaVersion),Serializable]
    public class XscNames
    {
        [XmlElement(ElementName="LocalizedName",Type=typeof(XscLocalizedName),IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=XscDeclarations.SchemaVersion)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public XscLocalizedNameCollection _localizedNames;

        [XmlIgnore]
        public XscLocalizedNameCollection LocalizedNames
        {
            get
            {
                if (_localizedNames == null) _localizedNames = new XscLocalizedNameCollection();
                return _localizedNames;
            }
            set { _localizedNames = value; }
        }

        public XscNames()
        {
        }
    }

    [Serializable]
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public class XscLocalizedNameCollection : ArrayList
    {
        public XscLocalizedName Add(XscLocalizedName obj)
        {
            base.Add(obj);
            return obj;
        }

        public XscLocalizedName Add()
        {
            return Add(new XscLocalizedName());
        }

        public void Insert(int index, XscLocalizedName obj)
        {
            base.Insert(index, obj);
        }

        public void Remove(XscLocalizedName obj)
        {
            base.Remove(obj);
        }

        new public XscLocalizedName this[int index]
        {
            get { return base[index] as XscLocalizedName; }
            set { base[index] = value; }
        }

        public XscLocalizedNameCollection()
        {
        }
    }

    [XmlType(TypeName="LocalizedName",Namespace=XscDeclarations.SchemaVersion),Serializable]
    public class XscLocalizedName
    {
        [XmlElement("Name", typeof(string))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public string _name;

        [XmlIgnore]
        public string Name
        {
            get { return _name; }
            set { _name = value; }
        }

        [XmlElement("Locale", typeof(string))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public string _locale;

        [XmlIgnore]
        public string Locale
        {
            get { return _locale; }
            set { _locale = value; }
        }

        public XscLocalizedName()
        {
        }
    }

    [XmlType(TypeName="FormattedValues",Namespace=XscDeclarations.SchemaVersion),Serializable]
    public class XscFormattedValues
    {
        [XmlElement(ElementName="FormattedValue",Type=typeof(XscFormattedValue),IsNullable=true,Form=XmlSchemaForm.Qualified,Namespace=XscDeclarations.SchemaVersion)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public XscFormattedValueCollection _formattedValues;

        [XmlIgnore]
        public XscFormattedValueCollection FormattedValues
        {
            get { return _formattedValues; }
            set { _formattedValues = value; }
        }

        public XscFormattedValues()
        {
        }
    }

    [Serializable]
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public class XscFormattedValueCollection : ArrayList
    {
        public XscFormattedValue Add(XscFormattedValue obj)
        {
            base.Add(obj);
            return obj;
        }

        public XscFormattedValue Add()
        {
            return Add(new XscFormattedValue());
        }

        public void Insert(int index, XscFormattedValue obj)
        {
            base.Insert(index, obj);
        }

        public void Remove(XscFormattedValue obj)
        {
            base.Remove(obj);
        }

        new public XscFormattedValue this[int index]
        {
            get { return base[index] as XscFormattedValue; }
            set { base[index] = value; }
        }

        public XscFormattedValueCollection()
        {
        }
    }

    [XmlType(TypeName="FormattedValue",Namespace=XscDeclarations.SchemaVersion),Serializable]
    public class XscFormattedValue
    {
        [XmlElement(ElementName="Names",Type=typeof(XscNames),IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=XscDeclarations.SchemaVersion)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public XscNames _names;

        [XmlIgnore]
        public XscNames Names
        {
            get
            {
                if (_names == null) _names = new XscNames();
                return _names;
            }
            set { _names = value; }
        }

        [XmlElement("NameID",typeof(ushort))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public ushort _nameId;

        [XmlIgnore]
        public ushort NameId
        {
            get { return _nameId; }
            set { _nameId = value; }
        }

        [XmlElement("Type",typeof(string))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public string _type;

        [XmlIgnore]
        public string Type
        {
            get { return _type; }
            set { _type = value; }
        }

        [XmlElement("FriendlyAdminName",typeof(string))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public string _friendlyAdminName;

        [XmlIgnore]
        public string FriendlyAdminName
        {
            get { return _friendlyAdminName; }
            set { _friendlyAdminName = value; }
        }

        [XmlElement("Formula", typeof(string))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public string _formula;

        [XmlIgnore]
        public string Formula
        {
            get { return _formula.Trim(); }
            set { _formula = value; }
        }

        public XscFormattedValue()
        {
        }
    }

    [XmlType(TypeName="Formula",Namespace=XscDeclarations.SchemaVersion),Serializable]
    public class XscFormula
    {
        [XmlElement("!", typeof(string))]
        public string _cdata;

        [XmlIgnore]
        public string CData
        {
            get { return _cdata; }
            set { _cdata = value; }
        }

        public XscFormula()
        {
        }
    }

    [XmlType(TypeName="RawAttributes",Namespace=XscDeclarations.SchemaVersion),Serializable]
    public class XscRawAttributes
    {
        [XmlElement(ElementName="Attribute",Type=typeof(XscAttribute),IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=XscDeclarations.SchemaVersion)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public XscRawAttributeCollection _rawAttributes;

        [XmlIgnore]
        public XscRawAttributeCollection RawAttributes
        {
            get
            {
                if (_rawAttributes == null) _rawAttributes = new XscRawAttributeCollection();
                return _rawAttributes;
            }
            set { _rawAttributes = value; }
        }
    }

    [Serializable]
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public class XscRawAttributeCollection : ArrayList
    {
        public XscAttribute Add(XscAttribute obj)
        {
            base.Add(obj);
            return obj;
        }

        public XscAttribute Add()
        {
            return Add(new XscAttribute());
        }

        public void Insert(int index, XscAttribute obj)
        {
            base.Insert(index, obj);
        }

        public void Remove(XscAttribute obj)
        {
            base.Remove(obj);
        }

        new public XscAttribute this[int index]
        {
            get { return base[index] as XscAttribute; }
            set { base[index] = value; }
        }

        public XscRawAttributeCollection()
        {
        }
    }

    [XmlType(TypeName="Attribute",Namespace=XscDeclarations.SchemaVersion),Serializable]
    public class XscAttribute
    {
        [XmlElement("PUID", typeof(Boolean))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public bool _puid;

        [XmlIgnore]
        public bool Puid
        {
            get { return _puid; }
            set { _puid = value; }
        }

        [XmlElement("Index", typeof(ushort))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public ushort _index;

        [XmlIgnore]
        public ushort Index
        {
            get { return _index; }
            set { _index = value; }
        }

        public XscAttribute()
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup\XLASTFactory\GameModes.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework.STFTools.ConfigFiles;

namespace ServerTestFramework.STFTools
{
    public partial class XLASTFactory
    {
        private const string GAME_MODE_ID = "0x0000800B";

        public void AddGameModes(XboxLiveSubmissionProject xlast, int count)
        {
            for (int i = 0; i < count; i++)
            {
                AddGameMode(xlast);
            }
        }

        public void AddGameMode(XboxLiveSubmissionProject xlast, string name, ushort value, byte drawProbability)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            GameMode gameMode = new GameMode();
            gameMode.friendlyName = name;
            gameMode.stringId = AddString(xlast, name + " string");
            gameMode.value = value;
            gameMode.drawProbability = drawProbability;
            xlast.GameConfigProject.GameModes.Add(gameMode);
        }

        public void SetGameModeDefaultValue(XboxLiveSubmissionProject xlast, ushort defaultValue)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            xlast.GameConfigProject.GameModes.defaultValue = defaultValue;
        }

        private ushort AddGameMode(XboxLiveSubmissionProject xlast)
        {
            ushort value = (ushort)xlast.GameConfigProject.GameModes.Count;
            byte draw = (byte)_rnd.Next(0, 101);
            AddGameMode(xlast, "GameMode" + value.ToString("d3"), value, draw);
            return value;
        }

        private void CreateGameModes(XboxLiveSubmissionProject xlast)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            xlast.GameConfigProject.GameModes.clsid = GameModesCLSID;
            SetGameModeDefaultValue(xlast, AddGameMode(xlast));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup\ConfigFiles\XlastConfigV03.cs ===
// Copyright 2004, Microsoft Corporation
// Sample Code - Use restricted to terms of use defined in the accompanying license agreement (EULA.doc)

//--------------------------------------------------------------
// Autogenerated by XSDObjectGen version 1.4.2.1
// Schema file: gi.03.xsd
// Creation Date: 6/19/2007 12:58:07
//--------------------------------------------------------------

using System;
using System.Xml.Serialization;
using System.Collections;
using System.Xml.Schema;
using System.ComponentModel;

namespace ServerTestFramework.STFTools.ConfigFiles
{

	public struct Declarations
	{
		public const string SchemaVersion = "http://www.xboxlive.com/xlast";
	}

	[Serializable]
	public enum type23
	{
		[XmlEnum(Name="Ascending")] Ascending,
		[XmlEnum(Name="Descending")] Descending,
		[XmlEnum(Name="Near")] Near,
		[XmlEnum(Name="Far")] Far
	}

	[Serializable]
	public enum resetType
	{
		[XmlEnum(Name="Weekly")] Weekly,
		[XmlEnum(Name="Biweekly")] Biweekly,
		[XmlEnum(Name="Monthly")] Monthly,
		[XmlEnum(Name="Bimonthly")] Bimonthly,
		[XmlEnum(Name="Annually")] Annually,
		[XmlEnum(Name="Never")] Never
	}

	[Serializable]
	public enum MatchFilterItemType
	{
		[XmlEnum(Name="Attribute")] Attribute,
		[XmlEnum(Name="Parameter")] Parameter,
		[XmlEnum(Name="Constant")] Constant,
		[XmlEnum(Name="ContextValue")] ContextValue
	}

    [Serializable]
    public enum type
    {
        [XmlEnum(Name = "Min")] Min,
        [XmlEnum(Name = "Max")] Max,
        [XmlEnum(Name = "Sum")] Sum,
        [XmlEnum(Name = "Last")] Last
    }

	[Serializable]
	public enum type234
	{
		[XmlEnum(Name="Normal")] Normal,
		[XmlEnum(Name="Average")] Average,
		[XmlEnum(Name="Sum")] Sum,
		[XmlEnum(Name="Minimum")] Minimum,
		[XmlEnum(Name="Maximum")] Maximum,
		[XmlEnum(Name="Count")] Count
	}

	[Serializable]
	public enum achievementType
	{
		[XmlEnum(Name="Completion")] Completion,
		[XmlEnum(Name="Leveling")] Leveling,
		[XmlEnum(Name="Unlock")] Unlock,
		[XmlEnum(Name="Event")] @Event,
		[XmlEnum(Name="Tournament")] Tournament,
		[XmlEnum(Name="Checkpoint")] Checkpoint,
		[XmlEnum(Name="Other")] Other
	}

	[Serializable]
	public enum type2
	{
		[XmlEnum(Name="Normal")] Normal,
		[XmlEnum(Name="Findfromid")] Findfromid,
		[XmlEnum(Name="Aggregate")] Aggregate
	}

	[Serializable]
	public enum ArcadeLeaderboardSortType
	{
		[XmlEnum(Name="Ascending")] Ascending,
		[XmlEnum(Name="Descending")] Descending
	}


	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class FeatureCollection : ArrayList
	{
		public Feature Add(Feature obj)
		{
			base.Add(obj);
			return obj;
		}

		public Feature Add()
		{
			return Add(new Feature());
		}

		public void Insert(int index, Feature obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Feature obj)
		{
			base.Remove(obj);
		}

		new public Feature this[int index]
		{
			get { return (Feature) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class PlatformCollection : ArrayList
	{
		public Platform Add(Platform obj)
		{
			base.Add(obj);
			return obj;
		}

		public Platform Add()
		{
			return Add(new Platform());
		}

		public void Insert(int index, Platform obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Platform obj)
		{
			base.Remove(obj);
		}

		new public Platform this[int index]
		{
			get { return (Platform) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class ConstantCollection : ArrayList
	{
		public Constant Add(Constant obj)
		{
			base.Add(obj);
			return obj;
		}

		public Constant Add()
		{
			return Add(new Constant());
		}

		public void Insert(int index, Constant obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Constant obj)
		{
			base.Remove(obj);
		}

		new public Constant this[int index]
		{
			get { return (Constant) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class PictureCollection : ArrayList
	{
		public Picture Add(Picture obj)
		{
			base.Add(obj);
			return obj;
		}

		public Picture Add()
		{
			return Add(new Picture());
		}

		public void Insert(int index, Picture obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Picture obj)
		{
			base.Remove(obj);
		}

		new public Picture this[int index]
		{
			get { return (Picture) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class ReturnCollection : ArrayList
	{
		public @Return Add(@Return obj)
		{
			base.Add(obj);
			return obj;
		}

		public @Return Add()
		{
			return Add(new @Return());
		}

		public void Insert(int index, @Return obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(@Return obj)
		{
			base.Remove(obj);
		}

		new public @Return this[int index]
		{
			get { return (@Return) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class ParameterCollection : ArrayList
	{
		public Parameter Add(Parameter obj)
		{
			base.Add(obj);
			return obj;
		}

		public Parameter Add()
		{
			return Add(new Parameter());
		}

		public void Insert(int index, Parameter obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Parameter obj)
		{
			base.Remove(obj);
		}

		new public Parameter this[int index]
		{
			get { return (Parameter) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class TranslationCollection : ArrayList
	{
		public Translation Add(Translation obj)
		{
			base.Add(obj);
			return obj;
		}

		public Translation Add()
		{
			return Add(new Translation());
		}

		public void Insert(int index, Translation obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Translation obj)
		{
			base.Remove(obj);
		}

		new public Translation this[int index]
		{
			get { return (Translation) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class GameModeCollection : ArrayList
	{
		public GameMode Add(GameMode obj)
		{
			base.Add(obj);
			return obj;
		}

		public GameMode Add()
		{
			return Add(new GameMode());
		}

		public void Insert(int index, GameMode obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(GameMode obj)
		{
			base.Remove(obj);
		}

		new public GameMode this[int index]
		{
			get { return (GameMode) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class AttributeCollection : ArrayList
	{
		public Attribute Add(Attribute obj)
		{
			base.Add(obj);
			return obj;
		}

		public Attribute Add()
		{
			return Add(new Attribute());
		}

		public void Insert(int index, Attribute obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Attribute obj)
		{
			base.Remove(obj);
		}

		new public Attribute this[int index]
		{
			get { return (Attribute) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class RatingCollection : ArrayList
	{
		public Rating Add(Rating obj)
		{
			base.Add(obj);
			return obj;
		}

		public Rating Add()
		{
			return Add(new Rating());
		}

		public void Insert(int index, Rating obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Rating obj)
		{
			base.Remove(obj);
		}

		new public Rating this[int index]
		{
			get { return (Rating) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class FilterCollection : ArrayList
	{
		public Filter Add(Filter obj)
		{
			base.Add(obj);
			return obj;
		}

		public Filter Add()
		{
			return Add(new Filter());
		}

		public void Insert(int index, Filter obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Filter obj)
		{
			base.Remove(obj);
		}

		new public Filter this[int index]
		{
			get { return (Filter) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class SortOperationCollection : ArrayList
	{
		public SortOperation Add(SortOperation obj)
		{
			base.Add(obj);
			return obj;
		}

		public SortOperation Add()
		{
			return Add(new SortOperation());
		}

		public void Insert(int index, SortOperation obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(SortOperation obj)
		{
			base.Remove(obj);
		}

		new public SortOperation this[int index]
		{
			get { return (SortOperation) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class PresenceModeCollection : ArrayList
	{
		public PresenceMode Add(PresenceMode obj)
		{
			base.Add(obj);
			return obj;
		}

		public PresenceMode Add()
		{
			return Add(new PresenceMode());
		}

		public void Insert(int index, PresenceMode obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(PresenceMode obj)
		{
			base.Remove(obj);
		}

		new public PresenceMode this[int index]
		{
			get { return (PresenceMode) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class LocalizedStringCollection : ArrayList
	{
		public LocalizedString Add(LocalizedString obj)
		{
			base.Add(obj);
			return obj;
		}

		public LocalizedString Add()
		{
			return Add(new LocalizedString());
		}

		public void Insert(int index, LocalizedString obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(LocalizedString obj)
		{
			base.Remove(obj);
		}

		new public LocalizedString this[int index]
		{
			get { return (LocalizedString) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class ContextValueCollection : ArrayList
	{
		public ContextValue Add(ContextValue obj)
		{
			base.Add(obj);
			return obj;
		}

		public ContextValue Add()
		{
			return Add(new ContextValue());
		}

		public void Insert(int index, ContextValue obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(ContextValue obj)
		{
			base.Remove(obj);
		}

		new public ContextValue this[int index]
		{
			get { return (ContextValue) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class ViewFieldTypeCollection : ArrayList
	{
		public ServerTestFramework.STFTools.ConfigFiles.ViewFieldType Add(ServerTestFramework.STFTools.ConfigFiles.ViewFieldType obj)
		{
			base.Add(obj);
			return obj;
		}

		public ServerTestFramework.STFTools.ConfigFiles.ViewFieldType Add()
		{
			return Add(new ServerTestFramework.STFTools.ConfigFiles.ViewFieldType());
		}

		public void Insert(int index, ServerTestFramework.STFTools.ConfigFiles.ViewFieldType obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(ServerTestFramework.STFTools.ConfigFiles.ViewFieldType obj)
		{
			base.Remove(obj);
		}

		new public ServerTestFramework.STFTools.ConfigFiles.ViewFieldType this[int index]
		{
			get { return (ServerTestFramework.STFTools.ConfigFiles.ViewFieldType) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class AchievementCollection : ArrayList
	{
		public Achievement Add(Achievement obj)
		{
			base.Add(obj);
			return obj;
		}

		public Achievement Add()
		{
			return Add(new Achievement());
		}

		public void Insert(int index, Achievement obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Achievement obj)
		{
			base.Remove(obj);
		}

		new public Achievement this[int index]
		{
			get { return (Achievement) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class PropertyCollection : ArrayList
	{
		public Property Add(Property obj)
		{
			base.Add(obj);
			return obj;
		}

		public Property Add()
		{
			return Add(new Property());
		}

		public void Insert(int index, Property obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Property obj)
		{
			base.Remove(obj);
		}

		new public Property this[int index]
		{
			get { return (Property) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class SupportedLocaleCollection : ArrayList
	{
		public SupportedLocale Add(SupportedLocale obj)
		{
			base.Add(obj);
			return obj;
		}

		public SupportedLocale Add()
		{
			return Add(new SupportedLocale());
		}

		public void Insert(int index, SupportedLocale obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(SupportedLocale obj)
		{
			base.Remove(obj);
		}

		new public SupportedLocale this[int index]
		{
			get { return (SupportedLocale) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class StatsViewCollection : ArrayList
	{
		public StatsView Add(StatsView obj)
		{
			base.Add(obj);
			return obj;
		}

		public StatsView Add()
		{
			return Add(new StatsView());
		}

		public void Insert(int index, StatsView obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(StatsView obj)
		{
			base.Remove(obj);
		}

		new public StatsView this[int index]
		{
			get { return (StatsView) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class QueryCollection : ArrayList
	{
		public Query Add(Query obj)
		{
			base.Add(obj);
			return obj;
		}

		public Query Add()
		{
			return Add(new Query());
		}

		public void Insert(int index, Query obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Query obj)
		{
			base.Remove(obj);
		}

		new public Query this[int index]
		{
			get { return (Query) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class GenreCollection : ArrayList
	{
		public Genre Add(Genre obj)
		{
			base.Add(obj);
			return obj;
		}

		public Genre Add()
		{
			return Add(new Genre());
		}

		public void Insert(int index, Genre obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Genre obj)
		{
			base.Remove(obj);
		}

		new public Genre this[int index]
		{
			get { return (Genre) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class ImageCollection : ArrayList
	{
		public Image Add(Image obj)
		{
			base.Add(obj);
			return obj;
		}

		public Image Add()
		{
			return Add(new Image());
		}

		public void Insert(int index, Image obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Image obj)
		{
			base.Remove(obj);
		}

		new public Image this[int index]
		{
			get { return (Image) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class ContextCollection : ArrayList
	{
		public Context Add(Context obj)
		{
			base.Add(obj);
			return obj;
		}

		public Context Add()
		{
			return Add(new Context());
		}

		public void Insert(int index, Context obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Context obj)
		{
			base.Remove(obj);
		}

		new public Context this[int index]
		{
			get { return (Context) base[index]; }
			set { base[index] = value; }
		}
	}



	[XmlType(TypeName="ViewAxisType",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class ViewAxisType
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return FieldCollection.GetEnumerator();
		}

		public ServerTestFramework.STFTools.ConfigFiles.ViewFieldType Add(ServerTestFramework.STFTools.ConfigFiles.ViewFieldType obj)
		{
			return FieldCollection.Add(obj);
		}

		[XmlIgnore]
		public ServerTestFramework.STFTools.ConfigFiles.ViewFieldType this[int index]
		{
			get { return (ServerTestFramework.STFTools.ConfigFiles.ViewFieldType) FieldCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return FieldCollection.Count; }
        }

        public void Clear()
		{
            FieldCollection.Clear();
        }

		public ServerTestFramework.STFTools.ConfigFiles.ViewFieldType Remove(int index) 
		{ 
            ServerTestFramework.STFTools.ConfigFiles.ViewFieldType obj = FieldCollection[index];
            FieldCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            FieldCollection.Remove(obj);
        }

		[XmlElement(Type=typeof(ServerTestFramework.STFTools.ConfigFiles.ViewFieldType),ElementName="Field",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ViewFieldTypeCollection __FieldCollection;
		
		[XmlIgnore]
		public ViewFieldTypeCollection FieldCollection
		{
			get
			{
				if (__FieldCollection == null) __FieldCollection = new ViewFieldTypeCollection();
				return __FieldCollection;
			}
			set {__FieldCollection = value;}
		}

		public ViewAxisType()
		{
		}

		public void MakeSchemaCompliant()
		{
			if (FieldCollection.Count == 0)
			{
				ViewFieldType _c = FieldCollection.Add();
				_c.MakeSchemaCompliant();
			}
			else foreach (ViewFieldType _c in FieldCollection) _c.MakeSchemaCompliant();
		}
	}


	[XmlType(TypeName="PropertyFieldType",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class PropertyFieldType
	{

		[XmlAttribute(AttributeName="id",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __id;
		
		[XmlIgnore]
		public string id
		{ 
			get { return __id; }
			set { __id = value; }
		}

		[XmlElement(Type=typeof(Aggregation),ElementName="Aggregation",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Aggregation __Aggregation;
		
		[XmlIgnore]
		public Aggregation Aggregation
		{
			get
			{
				if (__Aggregation == null) __Aggregation = new Aggregation();		
				return __Aggregation;
			}
			set {__Aggregation = value;}
		}

		public PropertyFieldType()
		{
		}

		public void MakeSchemaCompliant()
		{
			Aggregation.MakeSchemaCompliant();
		}
	}


	[XmlType(TypeName="Aggregation",Namespace=Declarations.SchemaVersion),Serializable]
	public class Aggregation
	{

		[XmlAttribute(AttributeName="type")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public type __type;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __typeSpecified;
		
		[XmlIgnore]
		public type type
		{ 
			get { return __type; }
			set { __type = value; __typeSpecified = true; }
		}

		public Aggregation()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="NonValidatedElement",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class NonValidatedElement
	{

		[XmlAnyElement()]
		public System.Xml.XmlElement[] Any;

		public NonValidatedElement()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="ContextFieldType",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class ContextFieldType
	{

		[XmlAttribute(AttributeName="id",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __id;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __idSpecified;
		
		[XmlIgnore]
		public uint id
		{ 
			get { return __id; }
			set { __id = value; __idSpecified = true; }
		}

		public ContextFieldType()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="ViewFieldType",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class ViewFieldType
	{

		[XmlAttribute(AttributeName="attributeId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __attributeId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __attributeIdSpecified;
		
		[XmlIgnore]
		public ushort attributeId
		{ 
			get { return __attributeId; }
			set { __attributeId = value; __attributeIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		[XmlAttribute(AttributeName="hidden",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __hidden;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __hiddenSpecified;
		
		[XmlIgnore]
		public bool hidden
		{ 
			get { return __hidden; }
			set { __hidden = value; __hiddenSpecified = true; }
		}

		[XmlAttribute(AttributeName="stringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __stringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __stringIdSpecified;
		
		[XmlIgnore]
		public ushort stringId
		{ 
			get { return __stringId; }
			set { __stringId = value; __stringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="ordinal",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __ordinal;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __ordinalSpecified;
		
		[XmlIgnore]
		public ushort ordinal
		{ 
			get { return __ordinal; }
			set { __ordinal = value; __ordinalSpecified = true; }
		}

		[XmlAttribute(AttributeName="arcadeLeaderboard",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __arcadeLeaderboard;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __arcadeLeaderboardSpecified;
		
		[XmlIgnore]
		public bool arcadeLeaderboard
		{ 
			get { return __arcadeLeaderboard; }
			set { __arcadeLeaderboard = value; __arcadeLeaderboardSpecified = true; }
		}

		[XmlAttribute(AttributeName="arcadeSort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ServerTestFramework.STFTools.ConfigFiles.ArcadeLeaderboardSortType __arcadeSort;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __arcadeSortSpecified;
		
		[XmlIgnore]
		public ServerTestFramework.STFTools.ConfigFiles.ArcadeLeaderboardSortType arcadeSort
		{ 
			get { return __arcadeSort; }
			set { __arcadeSort = value; __arcadeSortSpecified = true; }
		}

		[XmlAttribute(AttributeName="arcadeStringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __arcadeStringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __arcadeStringIdSpecified;
		
		[XmlIgnore]
		public ushort arcadeStringId
		{ 
			get { return __arcadeStringId; }
			set { __arcadeStringId = value; __arcadeStringIdSpecified = true; }
		}

		[XmlElement(Type=typeof(ServerTestFramework.STFTools.ConfigFiles.ContextFieldType),ElementName="Context",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ServerTestFramework.STFTools.ConfigFiles.ContextFieldType __Context;
		
		[XmlIgnore]
		public ServerTestFramework.STFTools.ConfigFiles.ContextFieldType Context
		{
			get
			{
				if (__Context == null) __Context = new ServerTestFramework.STFTools.ConfigFiles.ContextFieldType();		
				return __Context;
			}
			set {__Context = value;}
		}

		[XmlElement(Type=typeof(ServerTestFramework.STFTools.ConfigFiles.PropertyFieldType),ElementName="Property",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ServerTestFramework.STFTools.ConfigFiles.PropertyFieldType __Property;
		
		[XmlIgnore]
		public ServerTestFramework.STFTools.ConfigFiles.PropertyFieldType Property
		{
			get
			{
				if (__Property == null) __Property = new ServerTestFramework.STFTools.ConfigFiles.PropertyFieldType();		
				return __Property;
			}
			set {__Property = value;}
		}

		public ViewFieldType()
		{
			arcadeLeaderboard = false;
			arcadeSort = ServerTestFramework.STFTools.ConfigFiles.ArcadeLeaderboardSortType.Ascending;
		}

		public void MakeSchemaCompliant()
		{
			Context.MakeSchemaCompliant();
			Property.MakeSchemaCompliant();
		}
	}


	[XmlRoot(ElementName="XboxLiveSubmissionProject",Namespace=Declarations.SchemaVersion,IsNullable=false),Serializable]
	public class XboxLiveSubmissionProject
	{

		[XmlAttribute(AttributeName="Version",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __Version;
		
		[XmlIgnore]
		public string Version
		{ 
			get { return __Version; }
			set { __Version = value; }
		}

		[XmlElement(Type=typeof(GameConfigProject),ElementName="GameConfigProject",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public GameConfigProject __GameConfigProject;
		
		[XmlIgnore]
		public GameConfigProject GameConfigProject
		{
			get
			{
				if (__GameConfigProject == null) __GameConfigProject = new GameConfigProject();		
				return __GameConfigProject;
			}
			set {__GameConfigProject = value;}
		}

		public XboxLiveSubmissionProject()
		{
		}

		public void MakeSchemaCompliant()
		{
			GameConfigProject.MakeSchemaCompliant();
		}
	}


	[XmlType(TypeName="GameConfigProject",Namespace=Declarations.SchemaVersion),Serializable]
	public class GameConfigProject
	{

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="titleId",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __titleId;
		
		[XmlIgnore]
		public string titleId
		{ 
			get { return __titleId; }
			set { __titleId = value; }
		}

		[XmlAttribute(AttributeName="titleName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __titleName;
		
		[XmlIgnore]
		public string titleName
		{ 
			get { return __titleName; }
			set { __titleName = value; }
		}

		[XmlAttribute(AttributeName="titleType",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __titleType;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __titleTypeSpecified;
		
		[XmlIgnore]
		public uint titleType
		{ 
			get { return __titleType; }
			set { __titleType = value; __titleTypeSpecified = true; }
		}

		[XmlAttribute(AttributeName="multiplayer",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __multiplayer;
		
		[XmlIgnore]
		public string multiplayer
		{ 
			get { return __multiplayer; }
			set { __multiplayer = value; }
		}

		[XmlAttribute(AttributeName="name",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __name;
		
		[XmlIgnore]
		public string name
		{ 
			get { return __name; }
			set { __name = value; }
		}

		[XmlAttribute(AttributeName="projectVersion",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __projectVersion;
		
		[XmlIgnore]
		public string projectVersion
		{ 
			get { return __projectVersion; }
			set { __projectVersion = value; }
		}

		[XmlAttribute(AttributeName="schemaVersion",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __schemaVersion;
		
		[XmlIgnore]
		public string schemaVersion
		{ 
			get { return __schemaVersion; }
			set { __schemaVersion = value; }
		}

		[XmlElement(Type=typeof(LocalizedStrings),ElementName="LocalizedStrings",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public LocalizedStrings __LocalizedStrings;
		
		[XmlIgnore]
		public LocalizedStrings LocalizedStrings
		{
			get
			{
				if (__LocalizedStrings == null) __LocalizedStrings = new LocalizedStrings();		
				return __LocalizedStrings;
			}
			set {__LocalizedStrings = value;}
		}

		[XmlElement(Type=typeof(GameModes),ElementName="GameModes",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public GameModes __GameModes;
		
		[XmlIgnore]
		public GameModes GameModes
		{
			get
			{
				if (__GameModes == null) __GameModes = new GameModes();		
				return __GameModes;
			}
			set {__GameModes = value;}
		}

		[XmlElement(Type=typeof(Contexts),ElementName="Contexts",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Contexts __Contexts;
		
		[XmlIgnore]
		public Contexts Contexts
		{
			get
			{
				if (__Contexts == null) __Contexts = new Contexts();		
				return __Contexts;
			}
			set {__Contexts = value;}
		}

		[XmlElement(Type=typeof(Images),ElementName="Images",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Images __Images;
		
		[XmlIgnore]
		public Images Images
		{
			get
			{
				if (__Images == null) __Images = new Images();		
				return __Images;
			}
			set {__Images = value;}
		}

		[XmlElement(Type=typeof(Achievements),ElementName="Achievements",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Achievements __Achievements;
		
		[XmlIgnore]
		public Achievements Achievements
		{
			get
			{
				if (__Achievements == null) __Achievements = new Achievements();		
				return __Achievements;
			}
			set {__Achievements = value;}
		}

		[XmlElement(Type=typeof(Properties),ElementName="Properties",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Properties __Properties;
		
		[XmlIgnore]
		public Properties Properties
		{
			get
			{
				if (__Properties == null) __Properties = new Properties();		
				return __Properties;
			}
			set {__Properties = value;}
		}

		[XmlElement(Type=typeof(Presence),ElementName="Presence",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Presence __Presence;
		
		[XmlIgnore]
		public Presence Presence
		{
			get
			{
				if (__Presence == null) __Presence = new Presence();		
				return __Presence;
			}
			set {__Presence = value;}
		}

		[XmlElement(Type=typeof(StatsViews),ElementName="StatsViews",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public StatsViews __StatsViews;
		
		[XmlIgnore]
		public StatsViews StatsViews
		{
			get
			{
				if (__StatsViews == null) __StatsViews = new StatsViews();		
				return __StatsViews;
			}
			set {__StatsViews = value;}
		}

		[XmlElement(Type=typeof(Matchmaking),ElementName="Matchmaking",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Matchmaking __Matchmaking;
		
		[XmlIgnore]
		public Matchmaking Matchmaking
		{
			get
			{
				if (__Matchmaking == null) __Matchmaking = new Matchmaking();		
				return __Matchmaking;
			}
			set {__Matchmaking = value;}
		}

		[XmlElement(Type=typeof(ProductInformation),ElementName="ProductInformation",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ProductInformation __ProductInformation;
		
		[XmlIgnore]
		public ProductInformation ProductInformation
		{
			get
			{
				if (__ProductInformation == null) __ProductInformation = new ProductInformation();		
				return __ProductInformation;
			}
			set {__ProductInformation = value;}
		}

		[XmlElement(Type=typeof(GamerPictures),ElementName="GamerPictures",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public GamerPictures __GamerPictures;
		
		[XmlIgnore]
		public GamerPictures GamerPictures
		{
			get
			{
				if (__GamerPictures == null) __GamerPictures = new GamerPictures();		
				return __GamerPictures;
			}
			set {__GamerPictures = value;}
		}

		public GameConfigProject()
		{
		}

		public void MakeSchemaCompliant()
		{
			LocalizedStrings.MakeSchemaCompliant();
			GameModes.MakeSchemaCompliant();
			Presence.MakeSchemaCompliant();
		}
	}


	[XmlType(TypeName="LocalizedStrings",Namespace=Declarations.SchemaVersion),Serializable]
	public class LocalizedStrings
	{

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="nextId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __nextId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __nextIdSpecified;
		
		[XmlIgnore]
		public ushort nextId
		{ 
			get { return __nextId; }
			set { __nextId = value; __nextIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="defaultLocale",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __defaultLocale;
		
		[XmlIgnore]
		public string defaultLocale
		{ 
			get { return __defaultLocale; }
			set { __defaultLocale = value; }
		}

		[XmlElement(Type=typeof(SupportedLocale),ElementName="SupportedLocale",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public SupportedLocaleCollection __SupportedLocaleCollection;
		
		[XmlIgnore]
		public SupportedLocaleCollection SupportedLocaleCollection
		{
			get
			{
				if (__SupportedLocaleCollection == null) __SupportedLocaleCollection = new SupportedLocaleCollection();
				return __SupportedLocaleCollection;
			}
			set {__SupportedLocaleCollection = value;}
		}

		[XmlElement(Type=typeof(LocalizedString),ElementName="LocalizedString",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public LocalizedStringCollection __LocalizedStringCollection;
		
		[XmlIgnore]
		public LocalizedStringCollection LocalizedStringCollection
		{
			get
			{
				if (__LocalizedStringCollection == null) __LocalizedStringCollection = new LocalizedStringCollection();
				return __LocalizedStringCollection;
			}
			set {__LocalizedStringCollection = value;}
		}

		public LocalizedStrings()
		{
		}

		public void MakeSchemaCompliant()
		{
			if (SupportedLocaleCollection.Count == 0)
			{
				SupportedLocale _c = SupportedLocaleCollection.Add();
				_c.MakeSchemaCompliant();
			}
			else foreach (SupportedLocale _c in SupportedLocaleCollection) _c.MakeSchemaCompliant();
			if (LocalizedStringCollection.Count == 0)
			{
				LocalizedString _c = LocalizedStringCollection.Add();
				_c.MakeSchemaCompliant();
			}
			else foreach (LocalizedString _c in LocalizedStringCollection) _c.MakeSchemaCompliant();
		}
	}


	[XmlType(TypeName="SupportedLocale",Namespace=Declarations.SchemaVersion),Serializable]
	public class SupportedLocale
	{

		[XmlAttribute(AttributeName="locale",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __locale;
		
		[XmlIgnore]
		public string locale
		{ 
			get { return __locale; }
			set { __locale = value; }
		}

		public SupportedLocale()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="LocalizedString",Namespace=Declarations.SchemaVersion),Serializable]
	public class LocalizedString
	{

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		[XmlAttribute(AttributeName="id",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __id;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __idSpecified;
		
		[XmlIgnore]
		public ushort id
		{ 
			get { return __id; }
			set { __id = value; __idSpecified = true; }
		}

		[XmlElement(Type=typeof(Translation),ElementName="Translation",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public TranslationCollection __TranslationCollection;
		
		[XmlIgnore]
		public TranslationCollection TranslationCollection
		{
			get
			{
				if (__TranslationCollection == null) __TranslationCollection = new TranslationCollection();
				return __TranslationCollection;
			}
			set {__TranslationCollection = value;}
		}

		[XmlElement(Type=typeof(LocalizedStringPresence),ElementName="Presence",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public LocalizedStringPresence __Presence;
		
		[XmlIgnore]
		public LocalizedStringPresence Presence
		{
			get
			{
				if (__Presence == null) __Presence = new LocalizedStringPresence();		
				return __Presence;
			}
			set {__Presence = value;}
		}

		public LocalizedString()
		{
		}

		public void MakeSchemaCompliant()
		{
			if (TranslationCollection.Count == 0)
			{
				Translation _c = TranslationCollection.Add();
				_c.MakeSchemaCompliant();
			}
			else foreach (Translation _c in TranslationCollection) _c.MakeSchemaCompliant();
		}
	}


	[XmlType(TypeName="Translation",Namespace=Declarations.SchemaVersion),Serializable]
	public class Translation
	{

		[XmlAttribute(AttributeName="locale",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __locale;
		
		[XmlIgnore]
		public string locale
		{ 
			get { return __locale; }
			set { __locale = value; }
		}

		[XmlText(DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __Value;
		
		[XmlIgnore]
		public string Value
		{ 
			get { return __Value; }
			set { __Value = value; }
		}

		public Translation()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="LocalizedStringPresence",Namespace=Declarations.SchemaVersion),Serializable]
	public class LocalizedStringPresence
	{

		public LocalizedStringPresence()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="GameModes",Namespace=Declarations.SchemaVersion),Serializable]
	public class GameModes
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return GameModeCollection.GetEnumerator();
		}

		public GameMode Add(GameMode obj)
		{
			return GameModeCollection.Add(obj);
		}

		[XmlIgnore]
		public GameMode this[int index]
		{
			get { return (GameMode) GameModeCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return GameModeCollection.Count; }
        }

        public void Clear()
		{
            GameModeCollection.Clear();
        }

		public GameMode Remove(int index) 
		{ 
            GameMode obj = GameModeCollection[index];
            GameModeCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            GameModeCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="defaultValue",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __defaultValue;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __defaultValueSpecified;
		
		[XmlIgnore]
		public ushort defaultValue
		{ 
			get { return __defaultValue; }
			set { __defaultValue = value; __defaultValueSpecified = true; }
		}

		[XmlElement(Type=typeof(GameMode),ElementName="GameMode",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public GameModeCollection __GameModeCollection;
		
		[XmlIgnore]
		public GameModeCollection GameModeCollection
		{
			get
			{
				if (__GameModeCollection == null) __GameModeCollection = new GameModeCollection();
				return __GameModeCollection;
			}
			set {__GameModeCollection = value;}
		}

		public GameModes()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="GameMode",Namespace=Declarations.SchemaVersion),Serializable]
	public class GameMode
	{

		[XmlAttribute(AttributeName="value",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __value;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __valueSpecified;
		
		[XmlIgnore]
		public ushort @value
		{ 
			get { return __value; }
			set { __value = value; __valueSpecified = true; }
		}

		[XmlAttribute(AttributeName="stringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __stringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __stringIdSpecified;
		
		[XmlIgnore]
		public ushort stringId
		{ 
			get { return __stringId; }
			set { __stringId = value; __stringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		[XmlAttribute(AttributeName="drawProbability",DataType="unsignedByte")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public byte __drawProbability;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __drawProbabilitySpecified;
		
		[XmlIgnore]
		public byte drawProbability
		{ 
			get { return __drawProbability; }
			set { __drawProbability = value; __drawProbabilitySpecified = true; }
		}

		public GameMode()
		{
			__drawProbabilitySpecified = true;
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Contexts",Namespace=Declarations.SchemaVersion),Serializable]
	public class Contexts
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return ContextCollection.GetEnumerator();
		}

		public Context Add(Context obj)
		{
			return ContextCollection.Add(obj);
		}

		[XmlIgnore]
		public Context this[int index]
		{
			get { return (Context) ContextCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return ContextCollection.Count; }
        }

        public void Clear()
		{
            ContextCollection.Clear();
        }

		public Context Remove(int index) 
		{ 
            Context obj = ContextCollection[index];
            ContextCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            ContextCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="nextId",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __nextId;
		
		[XmlIgnore]
		public string nextId
		{ 
			get { return __nextId; }
			set { __nextId = value; }
		}

		[XmlElement(Type=typeof(Context),ElementName="Context",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ContextCollection __ContextCollection;
		
		[XmlIgnore]
		public ContextCollection ContextCollection
		{
			get
			{
				if (__ContextCollection == null) __ContextCollection = new ContextCollection();
				return __ContextCollection;
			}
			set {__ContextCollection = value;}
		}

		public Contexts()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Context",Namespace=Declarations.SchemaVersion),Serializable]
	public class Context
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return ContextValueCollection.GetEnumerator();
		}

		public ContextValue Add(ContextValue obj)
		{
			return ContextValueCollection.Add(obj);
		}

		[XmlIgnore]
		public ContextValue this[int index]
		{
			get { return (ContextValue) ContextValueCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return ContextValueCollection.Count; }
        }

        public void Clear()
		{
            ContextValueCollection.Clear();
        }

		public ContextValue Remove(int index) 
		{ 
            ContextValue obj = ContextValueCollection[index];
            ContextValueCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            ContextValueCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="defaultValue",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __defaultValue;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __defaultValueSpecified;
		
		[XmlIgnore]
		public ushort defaultValue
		{ 
			get { return __defaultValue; }
			set { __defaultValue = value; __defaultValueSpecified = true; }
		}

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		[XmlAttribute(AttributeName="id",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __id;
		
		[XmlIgnore]
		public string id
		{ 
			get { return __id; }
			set { __id = value; }
		}

		[XmlAttribute(AttributeName="stringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __stringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __stringIdSpecified;
		
		[XmlIgnore]
		public ushort stringId
		{ 
			get { return __stringId; }
			set { __stringId = value; __stringIdSpecified = true; }
		}

		[XmlElement(Type=typeof(ContextValue),ElementName="ContextValue",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ContextValueCollection __ContextValueCollection;
		
		[XmlIgnore]
		public ContextValueCollection ContextValueCollection
		{
			get
			{
				if (__ContextValueCollection == null) __ContextValueCollection = new ContextValueCollection();
				return __ContextValueCollection;
			}
			set {__ContextValueCollection = value;}
		}

		public Context()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="ContextValue",Namespace=Declarations.SchemaVersion),Serializable]
	public class ContextValue
	{

		[XmlAttribute(AttributeName="value",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __value;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __valueSpecified;
		
		[XmlIgnore]
		public ushort @value
		{ 
			get { return __value; }
			set { __value = value; __valueSpecified = true; }
		}

		[XmlAttribute(AttributeName="stringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __stringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __stringIdSpecified;
		
		[XmlIgnore]
		public ushort stringId
		{ 
			get { return __stringId; }
			set { __stringId = value; __stringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		public ContextValue()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Images",Namespace=Declarations.SchemaVersion),Serializable]
	public class Images
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return ImageCollection.GetEnumerator();
		}

		public Image Add(Image obj)
		{
			return ImageCollection.Add(obj);
		}

		[XmlIgnore]
		public Image this[int index]
		{
			get { return (Image) ImageCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return ImageCollection.Count; }
        }

        public void Clear()
		{
            ImageCollection.Clear();
        }

		public Image Remove(int index) 
		{ 
            Image obj = ImageCollection[index];
            ImageCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            ImageCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlElement(Type=typeof(Image),ElementName="Image",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ImageCollection __ImageCollection;
		
		[XmlIgnore]
		public ImageCollection ImageCollection
		{
			get
			{
				if (__ImageCollection == null) __ImageCollection = new ImageCollection();
				return __ImageCollection;
			}
			set {__ImageCollection = value;}
		}

		public Images()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Image",Namespace=Declarations.SchemaVersion),Serializable]
	public class Image
	{

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		[XmlAttribute(AttributeName="id",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __id;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __idSpecified;
		
		[XmlIgnore]
		public uint id
		{ 
			get { return __id; }
			set { __id = value; __idSpecified = true; }
		}

		[XmlElement(ElementName="Path",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __Path;
		
		[XmlIgnore]
		public string Path
		{ 
			get { return __Path; }
			set { __Path = value; }
		}

		public Image()
		{
			Path = string.Empty;
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Achievements",Namespace=Declarations.SchemaVersion),Serializable]
	public class Achievements
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return AchievementCollection.GetEnumerator();
		}

		public Achievement Add(Achievement obj)
		{
			return AchievementCollection.Add(obj);
		}

		[XmlIgnore]
		public Achievement this[int index]
		{
			get { return (Achievement) AchievementCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return AchievementCollection.Count; }
        }

        public void Clear()
		{
            AchievementCollection.Clear();
        }

		public Achievement Remove(int index) 
		{ 
            Achievement obj = AchievementCollection[index];
            AchievementCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            AchievementCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="nextId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __nextId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __nextIdSpecified;
		
		[XmlIgnore]
		public ushort nextId
		{ 
			get { return __nextId; }
			set { __nextId = value; __nextIdSpecified = true; }
		}

		[XmlElement(Type=typeof(Achievement),ElementName="Achievement",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public AchievementCollection __AchievementCollection;
		
		[XmlIgnore]
		public AchievementCollection AchievementCollection
		{
			get
			{
				if (__AchievementCollection == null) __AchievementCollection = new AchievementCollection();
				return __AchievementCollection;
			}
			set {__AchievementCollection = value;}
		}

		public Achievements()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Achievement",Namespace=Declarations.SchemaVersion),Serializable]
	public class Achievement
	{

		[XmlAttribute(AttributeName="achievementType")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public achievementType __achievementType;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __achievementTypeSpecified;
		
		[XmlIgnore]
		public achievementType achievementType
		{ 
			get { return __achievementType; }
			set { __achievementType = value; __achievementTypeSpecified = true; }
		}

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="descriptionStringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __descriptionStringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __descriptionStringIdSpecified;
		
		[XmlIgnore]
		public ushort descriptionStringId
		{ 
			get { return __descriptionStringId; }
			set { __descriptionStringId = value; __descriptionStringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		[XmlAttribute(AttributeName="id",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __id;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __idSpecified;
		
		[XmlIgnore]
		public ushort id
		{ 
			get { return __id; }
			set { __id = value; __idSpecified = true; }
		}

		[XmlAttribute(AttributeName="imageId",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __imageId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __imageIdSpecified;
		
		[XmlIgnore]
		public uint imageId
		{ 
			get { return __imageId; }
			set { __imageId = value; __imageIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="showUnachieved",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __showUnachieved;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __showUnachievedSpecified;
		
		[XmlIgnore]
		public bool showUnachieved
		{ 
			get { return __showUnachieved; }
			set { __showUnachieved = value; __showUnachievedSpecified = true; }
		}

		[XmlAttribute(AttributeName="titleStringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __titleStringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __titleStringIdSpecified;
		
		[XmlIgnore]
		public ushort titleStringId
		{ 
			get { return __titleStringId; }
			set { __titleStringId = value; __titleStringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="unachievedStringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __unachievedStringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __unachievedStringIdSpecified;
		
		[XmlIgnore]
		public ushort unachievedStringId
		{ 
			get { return __unachievedStringId; }
			set { __unachievedStringId = value; __unachievedStringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="webDescriptionStringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __webDescriptionStringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __webDescriptionStringIdSpecified;
		
		[XmlIgnore]
		public ushort webDescriptionStringId
		{ 
			get { return __webDescriptionStringId; }
			set { __webDescriptionStringId = value; __webDescriptionStringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="cred",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __cred;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __credSpecified;
		
		[XmlIgnore]
		public ushort cred
		{ 
			get { return __cred; }
			set { __cred = value; __credSpecified = true; }
		}

		public Achievement()
		{
			showUnachieved = true;
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Properties",Namespace=Declarations.SchemaVersion),Serializable]
	public class Properties
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return PropertyCollection.GetEnumerator();
		}

		public Property Add(Property obj)
		{
			return PropertyCollection.Add(obj);
		}

		[XmlIgnore]
		public Property this[int index]
		{
			get { return (Property) PropertyCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return PropertyCollection.Count; }
        }

        public void Clear()
		{
            PropertyCollection.Clear();
        }

		public Property Remove(int index) 
		{ 
            Property obj = PropertyCollection[index];
            PropertyCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            PropertyCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="nextId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __nextId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __nextIdSpecified;
		
		[XmlIgnore]
		public ushort nextId
		{ 
			get { return __nextId; }
			set { __nextId = value; __nextIdSpecified = true; }
		}

		[XmlElement(Type=typeof(Property),ElementName="Property",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public PropertyCollection __PropertyCollection;
		
		[XmlIgnore]
		public PropertyCollection PropertyCollection
		{
			get
			{
				if (__PropertyCollection == null) __PropertyCollection = new PropertyCollection();
				return __PropertyCollection;
			}
			set {__PropertyCollection = value;}
		}

		public Properties()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Property",Namespace=Declarations.SchemaVersion),Serializable]
	public class Property
	{

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="dataSize",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __dataSize;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __dataSizeSpecified;
		
		[XmlIgnore]
		public ushort dataSize
		{ 
			get { return __dataSize; }
			set { __dataSize = value; __dataSizeSpecified = true; }
		}

		[XmlAttribute(AttributeName="id",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __id;
		
		[XmlIgnore]
		public string id
		{ 
			get { return __id; }
			set { __id = value; }
		}

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		[XmlAttribute(AttributeName="stringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __stringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __stringIdSpecified;
		
		[XmlIgnore]
		public ushort stringId
		{ 
			get { return __stringId; }
			set { __stringId = value; __stringIdSpecified = true; }
		}

		[XmlElement(Type=typeof(DefaultValue),ElementName="DefaultValue",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public DefaultValue __DefaultValue;
		
		[XmlIgnore]
		public DefaultValue DefaultValue
		{
			get
			{
				if (__DefaultValue == null) __DefaultValue = new DefaultValue();		
				return __DefaultValue;
			}
			set {__DefaultValue = value;}
		}

		[XmlElement(Type=typeof(Format),ElementName="Format",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Format __Format;
		
		[XmlIgnore]
		public Format Format
		{
			get
			{
				if (__Format == null) __Format = new Format();		
				return __Format;
			}
			set {__Format = value;}
		}

		public Property()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="DefaultValue",Namespace=Declarations.SchemaVersion),Serializable]
	public class DefaultValue
	{

		public DefaultValue()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Format",Namespace=Declarations.SchemaVersion),Serializable]
	public class Format
	{

		[XmlAttribute(AttributeName="decimals",DataType="unsignedByte")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public byte __decimals;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __decimalsSpecified;
		
		[XmlIgnore]
		public byte decimals
		{ 
			get { return __decimals; }
			set { __decimals = value; __decimalsSpecified = true; }
		}

		[XmlAttribute(AttributeName="year",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __year;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __yearSpecified;
		
		[XmlIgnore]
		public bool year
		{ 
			get { return __year; }
			set { __year = value; __yearSpecified = true; }
		}

		[XmlAttribute(AttributeName="month",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __month;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __monthSpecified;
		
		[XmlIgnore]
		public bool month
		{ 
			get { return __month; }
			set { __month = value; __monthSpecified = true; }
		}

		[XmlAttribute(AttributeName="day",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __day;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __daySpecified;
		
		[XmlIgnore]
		public bool day
		{ 
			get { return __day; }
			set { __day = value; __daySpecified = true; }
		}

		[XmlAttribute(AttributeName="hours",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __hours;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __hoursSpecified;
		
		[XmlIgnore]
		public bool hours
		{ 
			get { return __hours; }
			set { __hours = value; __hoursSpecified = true; }
		}

		[XmlAttribute(AttributeName="minutes",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __minutes;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __minutesSpecified;
		
		[XmlIgnore]
		public bool minutes
		{ 
			get { return __minutes; }
			set { __minutes = value; __minutesSpecified = true; }
		}

		[XmlAttribute(AttributeName="seconds",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __seconds;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __secondsSpecified;
		
		[XmlIgnore]
		public bool seconds
		{ 
			get { return __seconds; }
			set { __seconds = value; __secondsSpecified = true; }
		}

		[XmlAttribute(AttributeName="milliseconds",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __milliseconds;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __millisecondsSpecified;
		
		[XmlIgnore]
		public bool milliseconds
		{ 
			get { return __milliseconds; }
			set { __milliseconds = value; __millisecondsSpecified = true; }
		}

		public Format()
		{
			decimals = 2;
			year = true;
			month = true;
			day = true;
			hours = true;
			minutes = true;
			seconds = true;
			milliseconds = true;
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Presence",Namespace=Declarations.SchemaVersion),Serializable]
	public class Presence
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return PresenceModeCollection.GetEnumerator();
		}

		public PresenceMode Add(PresenceMode obj)
		{
			return PresenceModeCollection.Add(obj);
		}

		[XmlIgnore]
		public PresenceMode this[int index]
		{
			get { return (PresenceMode) PresenceModeCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return PresenceModeCollection.Count; }
        }

        public void Clear()
		{
            PresenceModeCollection.Clear();
        }

		public PresenceMode Remove(int index) 
		{ 
            PresenceMode obj = PresenceModeCollection[index];
            PresenceModeCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            PresenceModeCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="nextContextValue",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __nextContextValue;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __nextContextValueSpecified;
		
		[XmlIgnore]
		public ushort nextContextValue
		{ 
			get { return __nextContextValue; }
			set { __nextContextValue = value; __nextContextValueSpecified = true; }
		}

		[XmlElement(Type=typeof(PresenceMode),ElementName="PresenceMode",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public PresenceModeCollection __PresenceModeCollection;
		
		[XmlIgnore]
		public PresenceModeCollection PresenceModeCollection
		{
			get
			{
				if (__PresenceModeCollection == null) __PresenceModeCollection = new PresenceModeCollection();
				return __PresenceModeCollection;
			}
			set {__PresenceModeCollection = value;}
		}

		public Presence()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="PresenceMode",Namespace=Declarations.SchemaVersion),Serializable]
	public class PresenceMode
	{

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="contextValue",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __contextValue;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __contextValueSpecified;
		
		[XmlIgnore]
		public ushort contextValue
		{ 
			get { return __contextValue; }
			set { __contextValue = value; __contextValueSpecified = true; }
		}

		[XmlAttribute(AttributeName="stringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __stringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __stringIdSpecified;
		
		[XmlIgnore]
		public ushort stringId
		{ 
			get { return __stringId; }
			set { __stringId = value; __stringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		public PresenceMode()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="StatsViews",Namespace=Declarations.SchemaVersion),Serializable]
	public class StatsViews
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return StatsViewCollection.GetEnumerator();
		}

		public StatsView Add(StatsView obj)
		{
			return StatsViewCollection.Add(obj);
		}

		[XmlIgnore]
		public StatsView this[int index]
		{
			get { return (StatsView) StatsViewCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return StatsViewCollection.Count; }
        }

        public void Clear()
		{
            StatsViewCollection.Clear();
        }

		public StatsView Remove(int index) 
		{ 
            StatsView obj = StatsViewCollection[index];
            StatsViewCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            StatsViewCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="nextViewId",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __nextViewId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __nextViewIdSpecified;
		
		[XmlIgnore]
		public uint nextViewId
		{ 
			get { return __nextViewId; }
			set { __nextViewId = value; __nextViewIdSpecified = true; }
		}

		[XmlElement(Type=typeof(StatsView),ElementName="StatsView",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public StatsViewCollection __StatsViewCollection;
		
		[XmlIgnore]
		public StatsViewCollection StatsViewCollection
		{
			get
			{
				if (__StatsViewCollection == null) __StatsViewCollection = new StatsViewCollection();
				return __StatsViewCollection;
			}
			set {__StatsViewCollection = value;}
		}

		public StatsViews()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="StatsView",Namespace=Declarations.SchemaVersion),Serializable]
	public class StatsView
	{

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="id",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __id;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __idSpecified;
        
        [XmlAttribute(AttributeName = "platformVisible", DataType = "string")]
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        public string platformVisible;

        [XmlAttribute(AttributeName = "platformVisibleRatingAttributeId", DataType = "unsignedInt")]
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        public System.UInt32 platformVisibleRatingAttributeId;

        [XmlIgnore]
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        public bool platformVisibleRatingAttributeIdSpecified;
		
		[XmlIgnore]
		public uint id
		{ 
			get { return __id; }
			set { __id = value; __idSpecified = true; }
		}

		[XmlAttribute(AttributeName="resetType")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public resetType __resetType;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __resetTypeSpecified;
		
		[XmlIgnore]
		public resetType resetType
		{ 
			get { return __resetType; }
			set { __resetType = value; __resetTypeSpecified = true; }
		}

		[XmlAttribute(AttributeName="stringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __stringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __stringIdSpecified;
		
		[XmlIgnore]
		public ushort stringId
		{ 
			get { return __stringId; }
			set { __stringId = value; __stringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="entryExpiration",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __entryExpiration;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __entryExpirationSpecified;
		
		[XmlIgnore]
		public ushort entryExpiration
		{ 
			get { return __entryExpiration; }
			set { __entryExpiration = value; __entryExpirationSpecified = true; }
		}

		[XmlAttribute(AttributeName="topEntries",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __topEntries;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __topEntriesSpecified;
		
		[XmlIgnore]
		public uint topEntries
		{ 
			get { return __topEntries; }
			set { __topEntries = value; __topEntriesSpecified = true; }
		}

		[XmlAttribute(AttributeName="arbitrated",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __arbitrated;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __arbitratedSpecified;
		
		[XmlIgnore]
		public bool arbitrated
		{ 
			get { return __arbitrated; }
			set { __arbitrated = value; __arbitratedSpecified = true; }
		}

		[XmlAttribute(AttributeName="hidden",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __hidden;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __hiddenSpecified;
		
		[XmlIgnore]
		public bool hidden
		{ 
			get { return __hidden; }
			set { __hidden = value; __hiddenSpecified = true; }
		}

		[XmlAttribute(AttributeName="maxAttachments",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __maxAttachments;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __maxAttachmentsSpecified;
		
		[XmlIgnore]
		public ushort maxAttachments
		{ 
			get { return __maxAttachments; }
			set { __maxAttachments = value; __maxAttachmentsSpecified = true; }
		}

		[XmlAttribute(AttributeName="onlineOnly",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __onlineOnly;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __onlineOnlySpecified;
		
		[XmlIgnore]
		public bool onlineOnly
		{ 
			get { return __onlineOnly; }
			set { __onlineOnly = value; __onlineOnlySpecified = true; }
		}

		[XmlAttribute(AttributeName="flipAxes",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __flipAxes;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __flipAxesSpecified;
		
		[XmlIgnore]
		public bool flipAxes
		{ 
			get { return __flipAxes; }
			set { __flipAxes = value; __flipAxesSpecified = true; }
		}

		[XmlAttribute(AttributeName="viewType",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __viewType;
		
		[XmlIgnore]
		public string viewType
		{ 
			get { return __viewType; }
			set { __viewType = value; }
		}

		[XmlElement(Type=typeof(ServerTestFramework.STFTools.ConfigFiles.ViewAxisType),ElementName="Columns",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ServerTestFramework.STFTools.ConfigFiles.ViewAxisType __Columns;
		
		[XmlIgnore]
		public ServerTestFramework.STFTools.ConfigFiles.ViewAxisType Columns
		{
			get
			{
				if (__Columns == null) __Columns = new ServerTestFramework.STFTools.ConfigFiles.ViewAxisType();		
				return __Columns;
			}
			set {__Columns = value;}
		}

		public StatsView()
		{
		}

		public void MakeSchemaCompliant()
		{
			Columns.MakeSchemaCompliant();
		}
	}


	[XmlType(TypeName="Matchmaking",Namespace=Declarations.SchemaVersion),Serializable]
	public class Matchmaking
	{

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="isV1Title",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __isV1Title;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __isV1TitleSpecified;
		
		[XmlIgnore]
		public bool isV1Title
		{ 
			get { return __isV1Title; }
			set { __isV1Title = value; __isV1TitleSpecified = true; }
		}

		[XmlElement(Type=typeof(Schema),ElementName="Schema",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Schema __Schema;
		
		[XmlIgnore]
		public Schema Schema
		{
			get
			{
				if (__Schema == null) __Schema = new Schema();		
				return __Schema;
			}
			set {__Schema = value;}
		}

		[XmlElement(Type=typeof(Constants),ElementName="Constants",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Constants __Constants;
		
		[XmlIgnore]
		public Constants Constants
		{
			get
			{
				if (__Constants == null) __Constants = new Constants();		
				return __Constants;
			}
			set {__Constants = value;}
		}

		[XmlElement(Type=typeof(Queries),ElementName="Queries",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Queries __Queries;
		
		[XmlIgnore]
		public Queries Queries
		{
			get
			{
				if (__Queries == null) __Queries = new Queries();		
				return __Queries;
			}
			set {__Queries = value;}
		}

		public Matchmaking()
		{
			isV1Title = false;
		}

		public void MakeSchemaCompliant()
		{
			Schema.MakeSchemaCompliant();
			Constants.MakeSchemaCompliant();
			Queries.MakeSchemaCompliant();
		}
	}


	[XmlType(TypeName="Schema",Namespace=Declarations.SchemaVersion),Serializable]
	public class Schema
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return AttributeCollection.GetEnumerator();
		}

		public Attribute Add(Attribute obj)
		{
			return AttributeCollection.Add(obj);
		}

		[XmlIgnore]
		public Attribute this[int index]
		{
			get { return (Attribute) AttributeCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return AttributeCollection.Count; }
        }

        public void Clear()
		{
            AttributeCollection.Clear();
        }

		public Attribute Remove(int index) 
		{ 
            Attribute obj = AttributeCollection[index];
            AttributeCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            AttributeCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlElement(Type=typeof(Attribute),ElementName="Attribute",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public AttributeCollection __AttributeCollection;
		
		[XmlIgnore]
		public AttributeCollection AttributeCollection
		{
			get
			{
				if (__AttributeCollection == null) __AttributeCollection = new AttributeCollection();
				return __AttributeCollection;
			}
			set {__AttributeCollection = value;}
		}

		public Schema()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Attribute",Namespace=Declarations.SchemaVersion),Serializable]
	public class Attribute
	{

		[XmlAttribute(AttributeName="id",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __id;
		
		[XmlIgnore]
		public string id
		{ 
			get { return __id; }
			set { __id = value; }
		}

		public Attribute()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Constants",Namespace=Declarations.SchemaVersion),Serializable]
	public class Constants
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return ConstantCollection.GetEnumerator();
		}

		public Constant Add(Constant obj)
		{
			return ConstantCollection.Add(obj);
		}

		[XmlIgnore]
		public Constant this[int index]
		{
			get { return (Constant) ConstantCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return ConstantCollection.Count; }
        }

        public void Clear()
		{
            ConstantCollection.Clear();
        }

		public Constant Remove(int index) 
		{ 
            Constant obj = ConstantCollection[index];
            ConstantCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            ConstantCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="nextId",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __nextId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __nextIdSpecified;
		
		[XmlIgnore]
		public uint nextId
		{ 
			get { return __nextId; }
			set { __nextId = value; __nextIdSpecified = true; }
		}

		[XmlElement(Type=typeof(Constant),ElementName="Constant",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ConstantCollection __ConstantCollection;
		
		[XmlIgnore]
		public ConstantCollection ConstantCollection
		{
			get
			{
				if (__ConstantCollection == null) __ConstantCollection = new ConstantCollection();
				return __ConstantCollection;
			}
			set {__ConstantCollection = value;}
		}

		public Constants()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Constant",Namespace=Declarations.SchemaVersion),Serializable]
	public class Constant
	{

		[XmlAttribute(AttributeName="name",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __name;
		
		[XmlIgnore]
		public string name
		{ 
			get { return __name; }
			set { __name = value; }
		}

		[XmlAttribute(AttributeName="id",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __id;
		
		[XmlIgnore]
		public string id
		{ 
			get { return __id; }
			set { __id = value; }
		}

		[XmlAttribute(AttributeName="value",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __value;
		
		[XmlIgnore]
		public string @value
		{ 
			get { return __value; }
			set { __value = value; }
		}

		public Constant()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Queries",Namespace=Declarations.SchemaVersion),Serializable]
	public class Queries
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return QueryCollection.GetEnumerator();
		}

		public Query Add(Query obj)
		{
			return QueryCollection.Add(obj);
		}

		[XmlIgnore]
		public Query this[int index]
		{
			get { return (Query) QueryCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return QueryCollection.Count; }
        }

        public void Clear()
		{
            QueryCollection.Clear();
        }

		public Query Remove(int index) 
		{ 
            Query obj = QueryCollection[index];
            QueryCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            QueryCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="nextId",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __nextId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __nextIdSpecified;
		
		[XmlIgnore]
		public uint nextId
		{ 
			get { return __nextId; }
			set { __nextId = value; __nextIdSpecified = true; }
		}

		[XmlElement(Type=typeof(Query),ElementName="Query",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public QueryCollection __QueryCollection;
		
		[XmlIgnore]
		public QueryCollection QueryCollection
		{
			get
			{
				if (__QueryCollection == null) __QueryCollection = new QueryCollection();
				return __QueryCollection;
			}
			set {__QueryCollection = value;}
		}

		public Queries()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Query",Namespace=Declarations.SchemaVersion),Serializable]
	public class Query
	{

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="id",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __id;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __idSpecified;
		
		[XmlIgnore]
		public uint id
		{ 
			get { return __id; }
			set { __id = value; __idSpecified = true; }
		}

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		[XmlAttribute(AttributeName="maxResults",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __maxResults;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __maxResultsSpecified;
		
		[XmlIgnore]
		public ushort maxResults
		{ 
			get { return __maxResults; }
			set { __maxResults = value; __maxResultsSpecified = true; }
		}

		[XmlAttribute(AttributeName="type")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public type2 __type;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __typeSpecified;
		
		[XmlIgnore]
		public type2 type
		{ 
			get { return __type; }
			set { __type = value; __typeSpecified = true; }
		}

		[XmlAttribute(AttributeName="qosProbe",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __qosProbe;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __qosProbeSpecified;
		
		[XmlIgnore]
		public bool qosProbe
		{ 
			get { return __qosProbe; }
			set { __qosProbe = value; __qosProbeSpecified = true; }
		}

		[XmlAttribute(AttributeName="groupBy",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __groupBy;
		
		[XmlIgnore]
		public string groupBy
		{ 
			get { return __groupBy; }
			set { __groupBy = value; }
		}

		[XmlElement(Type=typeof(Parameters),ElementName="Parameters",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Parameters __Parameters;
		
		[XmlIgnore]
		public Parameters Parameters
		{
			get
			{
				if (__Parameters == null) __Parameters = new Parameters();		
				return __Parameters;
			}
			set {__Parameters = value;}
		}

		[XmlElement(Type=typeof(Filters),ElementName="Filters",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Filters __Filters;
		
		[XmlIgnore]
		public Filters Filters
		{
			get
			{
				if (__Filters == null) __Filters = new Filters();		
				return __Filters;
			}
			set {__Filters = value;}
		}

		[XmlElement(Type=typeof(SortOperations),ElementName="SortOperations",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public SortOperations __SortOperations;
		
		[XmlIgnore]
		public SortOperations SortOperations
		{
			get
			{
				if (__SortOperations == null) __SortOperations = new SortOperations();		
				return __SortOperations;
			}
			set {__SortOperations = value;}
		}

		[XmlElement(Type=typeof(Returns),ElementName="Returns",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Returns __Returns;
		
		[XmlIgnore]
		public Returns Returns
		{
			get
			{
				if (__Returns == null) __Returns = new Returns();		
				return __Returns;
			}
			set {__Returns = value;}
		}

		public Query()
		{
		}

		public void MakeSchemaCompliant()
		{
			Parameters.MakeSchemaCompliant();
			Filters.MakeSchemaCompliant();
			SortOperations.MakeSchemaCompliant();
			Returns.MakeSchemaCompliant();
		}
	}


	[XmlType(TypeName="Parameters",Namespace=Declarations.SchemaVersion),Serializable]
	public class Parameters
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return ParameterCollection.GetEnumerator();
		}

		public Parameter Add(Parameter obj)
		{
			return ParameterCollection.Add(obj);
		}

		[XmlIgnore]
		public Parameter this[int index]
		{
			get { return (Parameter) ParameterCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return ParameterCollection.Count; }
        }

        public void Clear()
		{
            ParameterCollection.Clear();
        }

		public Parameter Remove(int index) 
		{ 
            Parameter obj = ParameterCollection[index];
            ParameterCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            ParameterCollection.Remove(obj);
        }

		[XmlElement(Type=typeof(Parameter),ElementName="Parameter",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ParameterCollection __ParameterCollection;
		
		[XmlIgnore]
		public ParameterCollection ParameterCollection
		{
			get
			{
				if (__ParameterCollection == null) __ParameterCollection = new ParameterCollection();
				return __ParameterCollection;
			}
			set {__ParameterCollection = value;}
		}

		public Parameters()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Parameter",Namespace=Declarations.SchemaVersion),Serializable]
	public class Parameter
	{

		[XmlAttribute(AttributeName="id",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __id;
		
		[XmlIgnore]
		public string id
		{ 
			get { return __id; }
			set { __id = value; }
		}

		public Parameter()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Filters",Namespace=Declarations.SchemaVersion),Serializable]
	public class Filters
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return FilterCollection.GetEnumerator();
		}

		public Filter Add(Filter obj)
		{
			return FilterCollection.Add(obj);
		}

		[XmlIgnore]
		public Filter this[int index]
		{
			get { return (Filter) FilterCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return FilterCollection.Count; }
        }

        public void Clear()
		{
            FilterCollection.Clear();
        }

		public Filter Remove(int index) 
		{ 
            Filter obj = FilterCollection[index];
            FilterCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            FilterCollection.Remove(obj);
        }

		[XmlElement(Type=typeof(Filter),ElementName="Filter",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public FilterCollection __FilterCollection;
		
		[XmlIgnore]
		public FilterCollection FilterCollection
		{
			get
			{
				if (__FilterCollection == null) __FilterCollection = new FilterCollection();
				return __FilterCollection;
			}
			set {__FilterCollection = value;}
		}

		public Filters()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Filter",Namespace=Declarations.SchemaVersion),Serializable]
	public class Filter
	{

		[XmlAttribute(AttributeName="left",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __left;
		
		[XmlIgnore]
		public string left
		{ 
			get { return __left; }
			set { __left = value; }
		}

		[XmlAttribute(AttributeName="leftType")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ServerTestFramework.STFTools.ConfigFiles.MatchFilterItemType __leftType;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __leftTypeSpecified;
		
		[XmlIgnore]
		public ServerTestFramework.STFTools.ConfigFiles.MatchFilterItemType leftType
		{ 
			get { return __leftType; }
			set { __leftType = value; __leftTypeSpecified = true; }
		}

		[XmlAttribute(AttributeName="op",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __op;
		
		[XmlIgnore]
		public string op
		{ 
			get { return __op; }
			set { __op = value; }
		}

		[XmlAttribute(AttributeName="right",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __right;
		
		[XmlIgnore]
		public string right
		{ 
			get { return __right; }
			set { __right = value; }
		}

		[XmlAttribute(AttributeName="rightType")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ServerTestFramework.STFTools.ConfigFiles.MatchFilterItemType __rightType;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __rightTypeSpecified;
		
		[XmlIgnore]
		public ServerTestFramework.STFTools.ConfigFiles.MatchFilterItemType rightType
		{ 
			get { return __rightType; }
			set { __rightType = value; __rightTypeSpecified = true; }
		}

		public Filter()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="SortOperations",Namespace=Declarations.SchemaVersion),Serializable]
	public class SortOperations
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return SortOperationCollection.GetEnumerator();
		}

		public SortOperation Add(SortOperation obj)
		{
			return SortOperationCollection.Add(obj);
		}

		[XmlIgnore]
		public SortOperation this[int index]
		{
			get { return (SortOperation) SortOperationCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return SortOperationCollection.Count; }
        }

        public void Clear()
		{
            SortOperationCollection.Clear();
        }

		public SortOperation Remove(int index) 
		{ 
            SortOperation obj = SortOperationCollection[index];
            SortOperationCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            SortOperationCollection.Remove(obj);
        }

		[XmlElement(Type=typeof(SortOperation),ElementName="SortOperation",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public SortOperationCollection __SortOperationCollection;
		
		[XmlIgnore]
		public SortOperationCollection SortOperationCollection
		{
			get
			{
				if (__SortOperationCollection == null) __SortOperationCollection = new SortOperationCollection();
				return __SortOperationCollection;
			}
			set {__SortOperationCollection = value;}
		}

		public SortOperations()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="SortOperation",Namespace=Declarations.SchemaVersion),Serializable]
	public class SortOperation
	{

		[XmlAttribute(AttributeName="id",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __id;
		
		[XmlIgnore]
		public string id
		{ 
			get { return __id; }
			set { __id = value; }
		}

		[XmlAttribute(AttributeName="ordinal",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __ordinal;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __ordinalSpecified;
		
		[XmlIgnore]
		public ushort ordinal
		{ 
			get { return __ordinal; }
			set { __ordinal = value; __ordinalSpecified = true; }
		}

		[XmlAttribute(AttributeName="type")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public type23 __type;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __typeSpecified;
		
		[XmlIgnore]
		public type23 type
		{ 
			get { return __type; }
			set { __type = value; __typeSpecified = true; }
		}

		[XmlAttribute(AttributeName="distanceid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __distanceid;
		
		[XmlIgnore]
		public string distanceid
		{ 
			get { return __distanceid; }
			set { __distanceid = value; }
		}

		public SortOperation()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Returns",Namespace=Declarations.SchemaVersion),Serializable]
	public class Returns
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return ReturnCollection.GetEnumerator();
		}

		public @Return Add(@Return obj)
		{
			return ReturnCollection.Add(obj);
		}

		[XmlIgnore]
		public @Return this[int index]
		{
			get { return (@Return) ReturnCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return ReturnCollection.Count; }
        }

        public void Clear()
		{
            ReturnCollection.Clear();
        }

		public @Return Remove(int index) 
		{ 
            @Return obj = ReturnCollection[index];
            ReturnCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            ReturnCollection.Remove(obj);
        }

		[XmlElement(Type=typeof(Return),ElementName="Return",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ReturnCollection __ReturnCollection;
		
		[XmlIgnore]
		public ReturnCollection ReturnCollection
		{
			get
			{
				if (__ReturnCollection == null) __ReturnCollection = new ReturnCollection();
				return __ReturnCollection;
			}
			set {__ReturnCollection = value;}
		}

		public Returns()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Return",Namespace=Declarations.SchemaVersion),Serializable]
	public class @Return
	{

		[XmlAttribute(AttributeName="id",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __id;
		
		[XmlIgnore]
		public string id
		{ 
			get { return __id; }
			set { __id = value; }
		}

		[XmlAttribute(AttributeName="type")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public type234 __type;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __typeSpecified;
		
		[XmlIgnore]
		public type234 type
		{ 
			get { return __type; }
			set { __type = value; __typeSpecified = true; }
		}

		[XmlAttribute(AttributeName="ordinal",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __ordinal;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __ordinalSpecified;
		
		[XmlIgnore]
		public ushort ordinal
		{ 
			get { return __ordinal; }
			set { __ordinal = value; __ordinalSpecified = true; }
		}

		public @Return()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="ProductInformation",Namespace=Declarations.SchemaVersion),Serializable]
	public class ProductInformation
	{

		[XmlAttribute(AttributeName="offlinePlayersMax",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __offlinePlayersMax;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __offlinePlayersMaxSpecified;
		
		[XmlIgnore]
		public ushort offlinePlayersMax
		{ 
			get { return __offlinePlayersMax; }
			set { __offlinePlayersMax = value; __offlinePlayersMaxSpecified = true; }
		}

		[XmlAttribute(AttributeName="systemLinkPlayersMax",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __systemLinkPlayersMax;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __systemLinkPlayersMaxSpecified;
		
		[XmlIgnore]
		public ushort systemLinkPlayersMax
		{ 
			get { return __systemLinkPlayersMax; }
			set { __systemLinkPlayersMax = value; __systemLinkPlayersMaxSpecified = true; }
		}

		[XmlAttribute(AttributeName="livePlayersMax",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __livePlayersMax;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __livePlayersMaxSpecified;
		
		[XmlIgnore]
		public ushort livePlayersMax
		{ 
			get { return __livePlayersMax; }
			set { __livePlayersMax = value; __livePlayersMaxSpecified = true; }
		}

		[XmlAttribute(AttributeName="shortDescriptionStringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __shortDescriptionStringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __shortDescriptionStringIdSpecified;
		
		[XmlIgnore]
		public ushort shortDescriptionStringId
		{ 
			get { return __shortDescriptionStringId; }
			set { __shortDescriptionStringId = value; __shortDescriptionStringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="sellTextStringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __sellTextStringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __sellTextStringIdSpecified;
		
		[XmlIgnore]
		public ushort sellTextStringId
		{ 
			get { return __sellTextStringId; }
			set { __sellTextStringId = value; __sellTextStringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="publisherStringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __publisherStringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __publisherStringIdSpecified;
		
		[XmlIgnore]
		public ushort publisherStringId
		{ 
			get { return __publisherStringId; }
			set { __publisherStringId = value; __publisherStringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="developerStringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __developerStringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __developerStringIdSpecified;
		
		[XmlIgnore]
		public ushort developerStringId
		{ 
			get { return __developerStringId; }
			set { __developerStringId = value; __developerStringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="genreTextStringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __genreTextStringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __genreTextStringIdSpecified;
		
		[XmlIgnore]
		public ushort genreTextStringId
		{ 
			get { return __genreTextStringId; }
			set { __genreTextStringId = value; __genreTextStringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="arcadeDescriptionStringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __arcadeDescriptionStringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __arcadeDescriptionStringIdSpecified;
		
		[XmlIgnore]
		public ushort arcadeDescriptionStringId
		{ 
			get { return __arcadeDescriptionStringId; }
			set { __arcadeDescriptionStringId = value; __arcadeDescriptionStringIdSpecified = true; }
		}

		[XmlElement(Type=typeof(Rating),ElementName="Rating",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public RatingCollection __RatingCollection;
		
		[XmlIgnore]
		public RatingCollection RatingCollection
		{
			get
			{
				if (__RatingCollection == null) __RatingCollection = new RatingCollection();
				return __RatingCollection;
			}
			set {__RatingCollection = value;}
		}

		[XmlElement(Type=typeof(Genre),ElementName="Genre",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public GenreCollection __GenreCollection;
		
		[XmlIgnore]
		public GenreCollection GenreCollection
		{
			get
			{
				if (__GenreCollection == null) __GenreCollection = new GenreCollection();
				return __GenreCollection;
			}
			set {__GenreCollection = value;}
		}

		[XmlElement(Type=typeof(Feature),ElementName="Feature",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public FeatureCollection __FeatureCollection;
		
		[XmlIgnore]
		public FeatureCollection FeatureCollection
		{
			get
			{
				if (__FeatureCollection == null) __FeatureCollection = new FeatureCollection();
				return __FeatureCollection;
			}
			set {__FeatureCollection = value;}
		}

		[XmlElement(Type=typeof(Platform),ElementName="Platform",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public PlatformCollection __PlatformCollection;
		
		[XmlIgnore]
		public PlatformCollection PlatformCollection
		{
			get
			{
				if (__PlatformCollection == null) __PlatformCollection = new PlatformCollection();
				return __PlatformCollection;
			}
			set {__PlatformCollection = value;}
		}

		public ProductInformation()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Rating",Namespace=Declarations.SchemaVersion),Serializable]
	public class Rating
	{

		[XmlAttribute(AttributeName="ratingSystemId",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __ratingSystemId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __ratingSystemIdSpecified;
		
		[XmlIgnore]
		public uint ratingSystemId
		{ 
			get { return __ratingSystemId; }
			set { __ratingSystemId = value; __ratingSystemIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="ratingId",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __ratingId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __ratingIdSpecified;
		
		[XmlIgnore]
		public uint ratingId
		{ 
			get { return __ratingId; }
			set { __ratingId = value; __ratingIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="imageId",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __imageId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __imageIdSpecified;
		
		[XmlIgnore]
		public uint imageId
		{ 
			get { return __imageId; }
			set { __imageId = value; __imageIdSpecified = true; }
		}

		[XmlElement(ElementName="Description",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __Description;
		
		[XmlIgnore]
		public string Description
		{ 
			get { return __Description; }
			set { __Description = value; }
		}

		public Rating()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Genre",Namespace=Declarations.SchemaVersion),Serializable]
	public class Genre
	{

		[XmlAttribute(AttributeName="genreId",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __genreId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __genreIdSpecified;
		
		[XmlIgnore]
		public uint genreId
		{ 
			get { return __genreId; }
			set { __genreId = value; __genreIdSpecified = true; }
		}

		public Genre()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Feature",Namespace=Declarations.SchemaVersion),Serializable]
	public class Feature
	{

		[XmlAttribute(AttributeName="name",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __name;
		
		[XmlIgnore]
		public string name
		{ 
			get { return __name; }
			set { __name = value; }
		}

		[XmlAttribute(AttributeName="enabled",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __enabled;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __enabledSpecified;
		
		[XmlIgnore]
		public bool enabled
		{ 
			get { return __enabled; }
			set { __enabled = value; __enabledSpecified = true; }
		}

		public Feature()
		{
			enabled = true;
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Platform",Namespace=Declarations.SchemaVersion),Serializable]
	public class Platform
	{

		[XmlAttribute(AttributeName="name",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __name;
		
		[XmlIgnore]
		public string name
		{ 
			get { return __name; }
			set { __name = value; }
		}

		[XmlAttribute(AttributeName="id",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __id;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __idSpecified;
		
		[XmlIgnore]
		public uint id
		{ 
			get { return __id; }
			set { __id = value; __idSpecified = true; }
		}

		public Platform()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="GamerPictures",Namespace=Declarations.SchemaVersion),Serializable]
	public class GamerPictures
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return PictureCollection.GetEnumerator();
		}

		public Picture Add(Picture obj)
		{
			return PictureCollection.Add(obj);
		}

		[XmlIgnore]
		public Picture this[int index]
		{
			get { return (Picture) PictureCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return PictureCollection.Count; }
        }

        public void Clear()
		{
            PictureCollection.Clear();
        }

		public Picture Remove(int index) 
		{ 
            Picture obj = PictureCollection[index];
            PictureCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            PictureCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlElement(Type=typeof(Picture),ElementName="Picture",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public PictureCollection __PictureCollection;
		
		[XmlIgnore]
		public PictureCollection PictureCollection
		{
			get
			{
				if (__PictureCollection == null) __PictureCollection = new PictureCollection();
				return __PictureCollection;
			}
			set {__PictureCollection = value;}
		}

		public GamerPictures()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Picture",Namespace=Declarations.SchemaVersion),Serializable]
	public class Picture
	{

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		[XmlAttribute(AttributeName="id",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __id;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __idSpecified;
		
		[XmlIgnore]
		public uint id
		{ 
			get { return __id; }
			set { __id = value; __idSpecified = true; }
		}

		public Picture()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup\XLASTFactory\Images.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework.STFTools.ConfigFiles;

namespace ServerTestFramework.STFTools
{
    public partial class XLASTFactory
    {
        public uint AddImage(XboxLiveSubmissionProject xlast, string imagePath)
        {
            uint id = GetNextImageId(xlast);
            AddImage(xlast, imagePath, id, "Image" + id.ToString("d3"));
            return id;
        }

        public uint AddImage(XboxLiveSubmissionProject xlast, string imagePath, string name)
        {
            uint id = GetNextImageId(xlast);
            AddImage(xlast, imagePath, id, name);
            return id;
        }

        private void AddImage(XboxLiveSubmissionProject xlast, string imagePath, uint id, string friendlyName)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            Image newImage = new Image();
            newImage.Path = imagePath;
            newImage.id = id;
            newImage.friendlyName = friendlyName;
            xlast.GameConfigProject.Images.Add(newImage);
        }

        private void CreateImages(XboxLiveSubmissionProject xlast)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            xlast.GameConfigProject.Images.clsid = ImagesCLSID;
            AddImage(xlast, "GameImage.png", 32768, "X_IMAGEID_GAME");
            AddImage(xlast, "GameMarketplaceImage.png", 32772, "X_IMAGEID_GAME_MARKETPLACE");
        }

        private uint GetNextImageId(XboxLiveSubmissionProject xlast)
        {
            uint id = 0;
            foreach (Image img in xlast.GameConfigProject.Images.ImageCollection)
            {
                if (img.id < 32768)
                    id = Math.Max(id, img.id);
            }

            return id + 1;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveConfig\XOn.cs ===
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Reflection;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;

namespace ServerTestFramework.LiveService
{
    // list of services as defined in xonline.x
    public enum XOService
    {
        InvalidService = 0,
        PresNotification = 1,
        StringService = 2,
        Auto_Update = 3,
        Base_Subscription = 4,
        User_Account = 5,
        Matchmaking = 6,
        Stats = 7,
        Feedback = 8,
        Billing_Offering = 9,
        Lists = 10,
        Tou = 11,
        Signature_Server = 12,
        Query = 13,
        Name_Resolution = 14,
        Storage = 15,
        Arbitration = 16,
        Cron = 17,
        MessagingService = 18,
        Teams = 19,
        NatDetection = 20,
        DRM = 21,
        Massive = 22,
        PCLocator = 23,
        Crypto = 24,
        Liveinfo = 25,
        Connection_Server = 26,
        Ratings = 27,
        TestFD = 28,
        Sts = 29,
        Reflector = 30,
        SocialQuery = 31,
        Vortex = 32,
        XSts = 33,
        Profile = 34,
        Progress = 35,
        MaxService = 35      // update this const while adding new services
    }

    public partial struct HResult : IEquatable<HResult>, IXmlSerializable
    {
        //
        //
        // NOTE: These defines should be a superset of everything defined in XONLINE.X which are exposed to the client
        //
        //


        //
        // standard HRESULTS
        //
        public const uint S_OK = 0x0;
        public const uint S_FALSE = 0x1;
        public const uint E_FAIL = 0x80004005;
        public const uint E_INVALIDARG = 0x80070057;
        public const uint E_ABORT = 0x80004004;
        public const uint E_INVALID_DATA = 0x8007000D;
        public const uint E_OUTOFMEMORY = 0x8007000E;
        public const uint E_ACCESSDENIED = 0x80070005;
        public const uint E_USER_EXISTS = 0x80070524;
        public const uint E_NO_SUCH_USER = 0x80070525;
        public const uint E_UNEXPECTED = 0x8000FFFF;

        //
        // XOnline facility-wide HRESULTS                                            = 0x80150XXX
        //
        public const uint XONLINE_E_OVERFLOW = 0x80150001;
        public const uint XONLINE_E_NO_SESSION = 0x80150002;
        public const uint XONLINE_E_USER_NOT_LOGGED_ON = 0x80150003;
        public const uint XONLINE_E_NO_GUEST_ACCESS = 0x80150004;
        public const uint XONLINE_E_NOT_INITIALIZED = 0x80150005;
        public const uint XONLINE_E_NO_USER = 0x80150006;
        public const uint XONLINE_E_INTERNAL_ERROR = 0x80150007;
        public const uint XONLINE_E_OUT_OF_MEMORY = 0x80150008;
        public const uint XONLINE_E_TASK_BUSY = 0x80150009;
        public const uint XONLINE_E_SERVER_ERROR = 0x8015000A;
        public const uint XONLINE_E_IO_ERROR = 0x8015000B;
        public const uint XONLINE_E_BAD_CONTENT_TYPE = 0x8015000C;
        public const uint XONLINE_E_USER_NOT_PRESENT = 0x8015000D;
        public const uint XONLINE_E_PROTOCOL_MISMATCH = 0x8015000E;
        public const uint XONLINE_E_INVALID_SERVICE_ID = 0x8015000F;
        public const uint XONLINE_E_INVALID_REQUEST = 0x80150010;
        public const uint XONLINE_E_TASK_THROTTLED = 0x80150011;
        public const uint XONLINE_E_TASK_ABORTED_BY_DUPLICATE = 0x80150012;
        public const uint XONLINE_E_INVALID_TITLE_ID = 0x80150013;
        public const uint XONLINE_E_SERVER_CONFIG_ERROR = 0x80150014;
        public const uint XONLINE_E_END_OF_STREAM = 0x80150015;
        public const uint XONLINE_E_ACCESS_DENIED = 0x80150016;
        public const uint XONLINE_E_GEO_DENIED = 0x80150017;
        public const uint XONLINE_E_UNSUPPORTED_METHOD = 0x80150018; // XRL has wiredata request for an old/deprecated API-call received from new flash/client (or viceversa)
        public const uint XONLINE_E_RESOURCE_UNAVAILABLE = 0x80150019; // FastFail blocked the call
        public const uint XONLINE_E_AUTHDATA_MISMATCH = 0x80150020; // values in authdata don't match those in request
        public const uint XONLINE_E_ACCESS_TOKEN_ERROR = 0x80150021; // generic AccessToken error
        public const uint XONLINE_E_HEALTH_ERROR = 0x80150022; // non-specific (catch all) health error
        public const uint XONLINE_E_RESPONSE_ERROR = 0x80150023; // non-specific (catch all) response error
        public const uint XONLINE_E_ACTIVE_AUTH_ERROR = 0x80150024; // non-specific (catch all) active auth error
        public const uint XONLINE_E_MULTIPLE_USERS = 0x80150025; // received multiple users when only one is expected
        public const uint XONLINE_E_CALL_SOURCE_INVALID = 0x80150026;
        public const uint XONLINE_E_DECRYPTION_ERROR = 0x80150027; // error decrypting incoming request
        public const uint XONLINE_E_DESERIALIZATION_ERROR = 0x80150028; // error deserializing incoming request
        public const uint XONLINE_E_SERVICE_KEY_ERROR = 0x80150029; // error accessing service key (generic, look for inner exception, hr)
        public const uint XONLINE_E_MASTER_KEY_ERROR = 0x80150030; // error accessing master key (generic, look for inner exception, hr)

        //
        // SQL errors of various sorts                                               = 0x801501xx
        //
        public const uint XONLINE_E_DATABASE_ERROR = 0x80150100; // unspecified database error
        public const uint XONLINE_E_DATABASE_EXECUTE_ERROR = 0x80150101; // database query failed, typically a sql exception
        public const uint XONLINE_E_DATABASE_RESULT_ERROR = 0x80150102; // too many, too few results, or unexpected return value
        public const uint XONLINE_E_DATABASE_TRANSACTION_ERROR = 0x80150103; // transaction operation has no transaction
        public const uint XONLINE_E_DATABASE_PARAMETER_NOT_FOUND = 0x80150104; // parameter name not found in GetXxxParameter
        public const uint XONLINE_E_DATABASE_DEADLOCK = 0x80150105; // sql detected a deadlock and terminated call
        public const uint XONLINE_E_DATABASE_PARAMETER_INVALID = 0x80150106; // failed sproc specific parameter validation
        public const uint XONLINE_E_DATABASE_FOREIGN_KEY_VIOLATION = 0x80150107; // a SQL operation would have resulted in a foreign key exception
        public const uint XONLINE_E_DATABASE_DUPLICATE_KEY = 0x80150108; // duplicate primary or unique key
        public const uint XONLINE_E_DATABASE_TIMEOUT = 0x80150109; // what it says, the query did not response within a specified time

        //
        // XOnlineLogon HRESULTS                                                     = 0x80151XXX
        //
        // Failures from XOnlineLogon                                                = 0x801510XX
        public const uint XONLINE_E_LOGON_NO_NETWORK_CONNECTION = 0x80151000;

        // XOnlineLogon task successful return states
        public const uint XONLINE_S_LOGON_CONNECTION_ESTABLISHED = 0x001510F0;

        // XOnlineLogon task failure return values
        public const uint XONLINE_E_LOGON_CANNOT_ACCESS_SERVICE = 0x80151001;
        public const uint XONLINE_E_LOGON_UPDATE_REQUIRED = 0x80151002;
        public const uint XONLINE_E_LOGON_SERVERS_TOO_BUSY = 0x80151003;
        public const uint XONLINE_E_LOGON_CONNECTION_LOST = 0x80151004;
        public const uint XONLINE_E_LOGON_KICKED_BY_DUPLICATE_LOGON = 0x80151005;
        public const uint XONLINE_E_LOGON_INVALID_USER = 0x80151006;
        public const uint XONLINE_E_LOGON_FLASH_UPDATE_REQUIRED = 0x80151007;
        public const uint XONLINE_E_LOGON_TITLE_ACTIVATION_REQUIRED = 0x80151008;
        public const uint XONLINE_E_LOGON_USER_TITLE_ACTIVATION_REQUIRED = 0x80151009;
        public const uint XONLINE_E_LOGON_OTHER_TITLE_ACTIVATED = 0x8015100A;
        public const uint XONLINE_E_LOGON_SG_CONNECTION_TERMINATED = 0x8015100B;
        public const uint XONLINE_E_LOGON_SG_CONNECTION_TIMEDOUT = 0x8015100C;
        public const uint XONLINE_E_LOGON_SG_CONNECTION_RESET = 0x8015100D;
        public const uint XONLINE_E_LOGON_SG_CONNECTION_FAILED = 0x8015100E;
        public const uint XONLINE_E_LOGON_USER_NOT_TRUSTED = 0x8015100F;
        public const uint XONLINE_E_LOGON_USER_RPS_EXPIRED = 0x80151010;
        public const uint XONLINE_E_LOGON_PPLOGIN_PASSWORD_PROBLEM = 0x80151011;
        public const uint XONLINE_E_LOGON_PPLOGIN_VERIFICATION_REQUIRED = 0x80151012;
        public const uint XONLINE_E_LOGON_USER_UNKNOWN_TRUST = 0x80151013;
        public const uint XONLINE_E_LOGON_PPLOGIN_MISMATCH = 0x80151014;
        public const uint XONLINE_E_LOGON_SETTINGS_SYNC_FAILED = 0x80151015;
        public const uint XONLINE_E_LOGON_SETTINGS_SYNC_CONFLICT = 0x80151016;
        public const uint XONLINE_E_LOGON_BLOCKED_BY_CURFEW = 0x80151017;

        // Accidentally used in XONLINE_E_ACCOUNTS_XXX                               = 0x8015102A
        // Accidentally used in XONLINE_E_ACCOUNTS_XXX                               = 0x8015102B
        // Accidentally used in XONLINE_E_ACCOUNTS_XXX                               = 0x8015102C
        // Accidentally used in XONLINE_E_ACCOUNTS_XXX                               = 0x8015102D
        // Accidentally used in XONLINE_E_ACCOUNTS_XXX                               = 0x8015102E
        // Accidentally used in XONLINE_E_ACCOUNTS_XXX                               = 0x8015102F
        // Accidentally used in XONLINE_E_ACCOUNTS_XXX                               = 0x80151030
        // Accidentally used in XONLINE_E_ACCOUNTS_XXX                               = 0x80151031
        // Accidentally used in XONLINE_E_ACCOUNTS_XXX                               = 0x80151032

        // Failures from XOnlineSilentLogon
        public const uint XONLINE_E_SILENT_LOGON_DISABLED = 0x80151080;
        public const uint XONLINE_E_SILENT_LOGON_NO_ACCOUNTS = 0x80151081;
        public const uint XONLINE_E_SILENT_LOGON_PASSCODE_REQUIRED = 0x80151082;

        // Service errors after XOnlineLogon task completion                         = 0x801511XX
        public const uint XONLINE_E_LOGON_SERVICE_NOT_REQUESTED = 0x80151100;
        public const uint XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED = 0x80151101;
        public const uint XONLINE_E_LOGON_SERVICE_TEMPORARILY_UNAVAILABLE = 0x80151102;

        // User warnings after XOnlineLogon task completion                          = 0x801512XX
        public const uint XONLINE_S_LOGON_USER_HAS_MESSAGE = 0x001512F0;
        public const uint XONLINE_S_LOGON_USER_MESSAGE_ENUMERATION_NEEDED = 0x001512F1;

        // User errors after XOnlineLogon task completion
        public const uint XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT = 0x80151200;

        // XOnlineChangeLogonUsers task successful return states                     = 0x801513XX
        public const uint XONLINE_S_LOGON_COMMIT_USER_CHANGE = 0x001513F0;
        public const uint XONLINE_S_LOGON_USER_CHANGE_COMPLETE = 0x001513F1;

        // XOnlineChangeLogonUsers task failure return values
        public const uint XONLINE_E_LOGON_CHANGE_USER_FAILED = 0x80151300;

        // Other generic auth related errors                                         = 0x801518XX
        public const uint XONLINE_E_LOGON_MU_NOT_MOUNTED = 0x80151800;
        public const uint XONLINE_E_LOGON_MU_IO_ERROR = 0x80151801;
        public const uint XONLINE_E_LOGON_NOT_LOGGED_ON = 0x80151802;


        // XKDC client errors (error codes ranging from 80151901-8015191A)
        public const uint XONLINE_E_LOGON_NO_IP_ADDRESS = 0x80151901;
        public const uint XONLINE_E_LOGON_NO_DNS_SERVICE = 0x80151902;
        public const uint XONLINE_E_LOGON_DNS_LOOKUP_FAILED = 0x80151903;
        public const uint XONLINE_E_LOGON_DNS_LOOKUP_TIMEDOUT = 0x80151904;
        public const uint XONLINE_E_LOGON_INVALID_XBOX_ONLINE_INFO = 0x80151905;
        public const uint XONLINE_E_LOGON_MACS_FAILED = 0x80151906;
        public const uint XONLINE_E_LOGON_MACS_TIMEDOUT = 0x80151907;
        public const uint XONLINE_E_LOGON_AUTHENTICATION_FAILED = 0x80151908;
        public const uint XONLINE_E_LOGON_AUTHENTICATION_TIMEDOUT = 0x80151909;
        public const uint XONLINE_E_LOGON_AUTHORIZATION_FAILED = 0x8015190A;
        public const uint XONLINE_E_LOGON_AUTHORIZATION_TIMEDOUT = 0x8015190B;
        public const uint XONLINE_E_LOGON_XBOX_ACCOUNT_INVALID = 0x8015190C;
        public const uint XONLINE_E_LOGON_XBOX_ACCOUNT_BANNED = 0x8015190D;
        public const uint XONLINE_E_LOGON_SG_SERVICE_FAILED = 0x8015190E;
        public const uint XONLINE_E_LOGON_PRESENCE_SERVICE_FAILED = 0x8015190F;
        public const uint XONLINE_E_LOGON_PRESENCE_SERVICE_TIMEDOUT = 0x80151910;
        public const uint XONLINE_E_LOGON_TIMEDOUT = 0x80151911;
        public const uint XONLINE_E_LOGON_UNKNOWN_TITLE = 0x80151912;
        public const uint XONLINE_E_LOGON_INTERNAL_ERROR = 0x80151913;
        public const uint XONLINE_E_LOGON_MACHINE_AUTHENTICATION_FAILED = 0x80151914;
        public const uint XONLINE_E_LOGON_TGT_REVOKED = 0x80151915;
        public const uint XONLINE_E_LOGON_CACHE_MISS = 0x80151916;
        public const uint XONLINE_E_LOGON_NOT_UPNP_NAT = 0x80151917;
        public const uint XONLINE_E_LOGON_INCONCLUSIVE_UPNP_NAT = 0x80151918;
        public const uint XONLINE_E_LOGON_UPNP_NAT_HARD_FAILURE = 0x80151919;
        public const uint XONLINE_E_LOGON_UPNP_PORT_UNAVAILABLE = 0x8015191A;
        public const uint XONLINE_E_LOGON_PPLOGIN_OFFLINE = 0x8015191B;
        public const uint XONLINE_E_LOGON_KERBEROS_BIND_FAILURE = 0x8015191C;
        public const uint XONLINE_E_LOGON_LIVE_PORT_UNAVAILABLE = 0x8015191D;
        public const uint XONLINE_E_LOGON_LIVE_PORT_OVERRIDE_UNAVAILABLE = 0x8015191E;
        public const uint XONLINE_E_LOGON_SG_SERVICE_NIC_MISMATCH = 0x8015191F;
        public const uint XONLINE_E_LOGON_WLID_XUID_MISMATCH = 0x80151920;
        public const uint XONLINE_E_LOGON_SU_MANIFEST_MISMATCH = 0x80151921;
        public const uint XONLINE_E_LOGON_SU_FLASH_MISMATCH = 0x80151922;
        public const uint XONLINE_E_LOGON_SYSTEM_UPDATE_REQUIRED = 0x80151923;
        public const uint XONLINE_E_LOGON_UPDATE_NOT_PROPPED = 0x80151924;
        public const uint XONLINE_E_LOGON_LIVEHIVE_FAILED = 0x80151925;
        public const uint XONLINE_E_LOGON_INVALID_CONSOLE_ID = 0x80151926;
        public const uint XONLINE_E_LOGON_XBOX_ACCOUNT_BANNED_TEMP = 0x80151927;
        public const uint XONLINE_E_LOGON_XBOX_ACCOUNT_BANNED_REPAIR = 0x80151928;
        public const uint XONLINE_E_LOGON_DUPLICATE_CONSOLE_ID = 0x80151929;
        public const uint XONLINE_E_LOGON_MISSING_CONSOLE_ID = 0x8015192A;

        //
        // Presence/Notification HRESULTS                                            = 0x801520XX
        //
        public const uint XONLINE_E_NOTIFICATION_ERROR = 0x80152000;
        public const uint XONLINE_E_NOTIFICATION_SERVER_BUSY = 0x80152001;
        public const uint XONLINE_E_NOTIFICATION_LIST_FULL = 0x80152002;
        public const uint XONLINE_E_NOTIFICATION_BLOCKED = 0x80152003;
        public const uint XONLINE_E_NOTIFICATION_FRIEND_PENDING = 0x80152004;
        public const uint XONLINE_E_NOTIFICATION_FLUSH_TICKETS = 0x80152005;
        public const uint XONLINE_E_NOTIFICATION_TOO_MANY_REQUESTS = 0x80152006;
        public const uint XONLINE_E_NOTIFICATION_USER_ALREADY_EXISTS = 0x80152007;
        public const uint XONLINE_E_NOTIFICATION_USER_NOT_FOUND = 0x80152008;
        public const uint XONLINE_E_NOTIFICATION_OTHER_LIST_FULL = 0x80152009;
        public const uint XONLINE_E_NOTIFICATION_SELF = 0x8015200A;
        public const uint XONLINE_E_NOTIFICATION_SAME_TITLE = 0x8015200B;
        public const uint XONLINE_E_NOTIFICATION_NO_TASK = 0x8015200C;
        public const uint XONLINE_E_NOTIFICATION_NO_DATA = 0x8015200D;
        public const uint XONLINE_E_NOTIFICATION_NO_PEER_SUBSCRIBE = 0x0015200E;
        public const uint XONLINE_E_NOTIFICATION_THREAD_ERROR = 0x8015200F; // thread wait timeout
        public const uint XONLINE_E_NOTIFICATION_STATE_ERROR = 0x80152010;
        public const uint XONLINE_S_NOTIFICATION_NO_PEER_SUBSCRIBE = 0x0015200E;

        //
        // Errors returned by Teams                                                  = 0x801521XX
        //
        public const uint XONLINE_E_TEAMS_SERVER_BUSY = 0x80152100;
        public const uint XONLINE_E_TEAMS_TEAM_FULL = 0x80152101;
        public const uint XONLINE_E_TEAMS_MEMBER_PENDING = 0x80152102;
        public const uint XONLINE_E_TEAMS_TOO_MANY_REQUESTS = 0x80152103;
        public const uint XONLINE_E_TEAMS_USER_ALREADY_EXISTS = 0x80152104;
        public const uint XONLINE_E_TEAMS_USER_NOT_FOUND = 0x80152105;
        public const uint XONLINE_E_TEAMS_USER_TEAMS_FULL = 0x80152106;
        public const uint XONLINE_E_TEAMS_SELF = 0x80152107;
        public const uint XONLINE_E_TEAMS_NO_TASK = 0x80152108;
        public const uint XONLINE_E_TEAMS_TOO_MANY_TEAMS = 0x80152109;
        public const uint XONLINE_E_TEAMS_TEAM_ALREADY_EXISTS = 0x8015210A;
        public const uint XONLINE_E_TEAMS_TEAM_NOT_FOUND = 0x8015210B;
        public const uint XONLINE_E_TEAMS_INSUFFICIENT_PRIVILEGES = 0x8015210C;
        public const uint XONLINE_E_TEAMS_NAME_CONTAINS_BAD_WORDS = 0x8015210D;
        public const uint XONLINE_E_TEAMS_DESCRIPTION_CONTAINS_BAD_WORDS = 0x8015210E;
        public const uint XONLINE_E_TEAMS_MOTTO_CONTAINS_BAD_WORDS = 0x8015210F;
        public const uint XONLINE_E_TEAMS_URL_CONTAINS_BAD_WORDS = 0x80152110;
        public const uint XONLINE_E_TEAMS_NOT_A_MEMBER = 0x80152111;
        public const uint XONLINE_E_TEAMS_NO_ADMIN = 0x80152112;

        //
        // XBOS HRESULTS                                                             = 0x801530XX + 0x801531XX
        //
        public const uint XOFF_E_BAD_REQUEST = 0x80153001;
        public const uint XOFF_E_INVALID_USER = 0x80153002;
        public const uint XOFF_E_INVALID_OFFER_ID = 0x80153003;
        public const uint XOFF_E_INELIGIBLE_FOR_OFFER = 0x80153004;
        public const uint XOFF_E_OFFER_EXPIRED = 0x80153005;
        public const uint XOFF_E_SERVICE_UNREACHABLE = 0x80153006;
        public const uint XOFF_E_PURCHASE_BLOCKED = 0x80153007;
        public const uint XOFF_E_PURCHASE_DENIED = 0x80153008;
        public const uint XOFF_E_BILLING_SERVER_ERROR = 0x80153009;
        public const uint XOFF_E_OFFER_NOT_CANCELABLE = 0x8015300A;
        public const uint XOFF_E_NOTHING_TO_CANCEL = 0x8015300B;
        public const uint XOFF_E_ALREADY_OWN_MAX = 0x8015300C;
        public const uint XOFF_E_NO_CHARGE = 0x8015300D;
        public const uint XOFF_E_PERMISSION_DENIED = 0x8015300E;
        public const uint XOFF_E_INVALID_PRODUCT = 0x8015300F;

        public const uint XONLINE_E_BILLING_ERROR = 0x80153000;  // server received incorrectly formatted request
        public const uint XONLINE_E_OFFERING_BAD_REQUEST = 0x80153001;  // server received incorrectly formatted request
        public const uint XONLINE_E_OFFERING_INVALID_USER = 0x80153002;  // cannot find account for this user
        public const uint XONLINE_E_OFFERING_INVALID_OFFER_ID = 0x80153003;  // offer does not exist
        public const uint DEPRECATED_XONLINE_E_OFFERING_INELIGIBLE_FOR_OFFER = 0x80153004;  // )] private /title not allowed to purchase offer
        public const uint XONLINE_E_OFFERING_OFFER_EXPIRED = 0x80153005;  // offer no longer available
        public const uint XONLINE_E_OFFERING_SERVICE_UNREACHABLE = 0x80153006;  // apparent connectivity problems
        public const uint XONLINE_E_OFFERING_PURCHASE_BLOCKED = 0x80153007;  // this user is not allowed to make purchases
        public const uint XONLINE_E_OFFERING_PURCHASE_DENIED = 0x80153008;  // this user's payment is denied by billing provider
        public const uint XONLINE_E_OFFERING_BILLING_SERVER_ERROR = 0x80153009;  // nonspecific billing provider error
        public const uint XONLINE_E_OFFERING_OFFER_NOT_CANCELABLE = 0x8015300A;  // either this offer doesn't exist, or it's marked as un-cancelable
        public const uint XONLINE_E_OFFERING_NOTHING_TO_CANCEL = 0x8015300B;  // this user doesn't have one of these anyways
        public const uint XONLINE_E_OFFERING_ALREADY_OWN_MAX = 0x8015300C;  // this user already owns the maximum allowed
        public const uint XONLINE_E_OFFERING_NO_CHARGE = 0x8015300D;  // this is a free offer; no purchase is necessary
        public const uint XONLINE_E_OFFERING_PERMISSION_DENIED = 0x8015300E;  // permission denied
        public const uint XONLINE_E_OFFERING_NAME_TAKEN = 0x8015300F;  // Name given to XOnlineVerifyNickname is taken (dosen't vet)
        public const uint XONLINE_E_OFFERING_BASE_OFFER_NOT_CANCELABLE = 0x80153010;  // Base subscription not cancelable due to dependent subscriptions
        public const uint XONLINE_E_AUTOUPD_MACHINE_BLOCKED = 0x80153011;  // No autoupd referrals given because machine puid is blocked
        public const uint XONLINE_E_OFFERING_INVALID_OFFER_TYPE = 0x80153012;  // PurchaseSubscription called with non-subscription offer or PurchaseContent called with non-content offer
        public const uint XONLINE_E_OFFERING_INVALID_CONSUME_ITEMS = 0x80153013;  // Consume was called with an asset that had insufficient quantity owned by the user.
        public const uint XONLINE_E_MULTI_PURCHASE_INVALID_OFFER_TYPE = 0x80153014;  // A multi purchase was requested, but not all of the offers were of the allowed type for a multi-purchase
        public const uint XONLINE_E_MULTI_PURCHASE_INVALID_PAYMENT_TYPE = 0x80153015;  // A multi purchase was requested with an unsupported payment type
        public const uint XONLINE_E_OFFERING_PRICE_CHANGED = 0x80153016;  // The client expected a certain price but that price didn't match the server-defined price
        public const uint DEPRECATED_XONLINE_E_OFFERING_NOT_ACQUIRABLE = 0x80153017;  // A purchase was attempted on a video offer which is currently not Acquirable
        public const uint XONLINE_E_PENDING_POINTS_PURCHASE = 0x80153018;  // A points purchase is already pending, and so a new points purchase cannot be started
        public const uint XONLINE_E_OFFERING_SUBSCRIPTION_NOT_FOUND = 0x80153019;  // User has no subscription for given service component or service id
        public const uint XONLINE_E_OFFERING_UNKNOWN_OFFER_TYPE = 0x8015301A;  // Unknown offer type.
        public const uint XONLINE_E_OFFERING_UNKNOWN_PAYMENT_TYPE = 0x8015301B;  // Unknown payment type.
        public const uint DEPRECATED_XONLINE_E_OFFERING_INVALID_SOURCE_MACHINE = 0x8015301C;  // The source machine is not allowed to participate in license transfers of this type
        public const uint DEPRECATED_XONLINE_E_OFFERING_INVALID_DEST_MACHINE = 0x8015301D;  // The destination machine is not allowed to participate in license transfers of this type
        public const uint DEPRECATED_XONLINE_S_OTHER_LICENSE_TRANSFER_FAILED = 0x0015301E;  // Success code indicating that the license transfer succeeded for the calling user, but one or more licenses on the box belonging to other users could not be migrated.
        public const uint XONLINE_S_USER_OWNS_NO_LICENSES = 0x0015301F;  // Success code indicating that the license transfer aborted for the calling user because he does not own any licenses on the old console.
        public const uint XONLINE_E_MEDIA_INSTANCE_NOT_ACQUIRABLE = 0x80153020;  // Success code indicating that the license transfer aborted for the calling user because he does not own any licenses on the old console.
        public const uint XONLINE_E_PURCHASE_PENDING = 0x80153021;  // The user has a pending purchase transaction already.  Please wait and try again later.
        public const uint XONLINE_E_OFFERING_OFFER_MISCONFIGURED = 0x80153022;  // offer exists but is misconfigured in some way
        public const uint XONLINE_E_OFFERING_OFFER_NOT_VISIBLE = 0x80153023;  // offer exists but has a visibilityDate in the future
        public const uint XONLINE_E_OFFERING_VISIBLITY_STATUS_NOT_ALLOWED = 0x80153024;  // offer exists but has a visibilityStatusId that does not allow purchase
        public const uint XONLINE_E_OFFERING_GRANTS_NOTHING = 0x80153025;  // offer exists but currently grants no mediaInstances, so purchase was blocked
        public const uint XONLINE_E_OFFERING_INVALID_PAYMENT_TYPE = 0x80153026;  // offer does not allow the given payment type
        public const uint XONLINE_E_OFFERING_MEDIA_TYPE_MISMATCH = 0x80153027;  // offer media type in the catalog does not match the given media type
        public const uint XONLINE_E_MULTI_PURCHASE_INVALID_PLATFORM_TYPE = 0x80153028;  // A multi purchase was requested from a platform type that either could not be determed or is unsupported.
        public const uint XONLINE_E_BILLING_NOT_CONNECTED = 0x80153029;  // connection to billing system is not configured
        public const uint XONLINE_E_OFFERING_MISSING_RESULTS = 0x8015302A;  // expected additional results from sproc
        public const uint XONLINE_E_OFFERING_PAYMENT_INFO_TOO_LONG = 0x8015302B;  // length of payment info exceeds width of database columsn
        public const uint XONLINE_E_OFFERING_MIGRATION_ERROR = 0x8015302C;  // error migrating xbox1 offer to xenon offer
        public const uint XONLINE_E_GEOFENCING_LOOKUP_ERROR = 0x8015302D;  // geofencing returned an exception during lookup
        public const uint XONLINE_E_GEOFENCING_RETURNED_NULL = 0x8015302E;  // returned null from IP lookup
        public const uint XONLINE_E_OFFERING_VERIFY_TOKEN_ERROR = 0x8015302F;  // exception while verifying token
        public const uint XONLINE_E_BILLING_USER_QUEUED = 0x80153030;  // operation not allowed because user is queued
        public const uint XONLINE_E_BILLING_KEY_NOT_FOUND = 0x80153031;  // billing provider key is not configured
        public const uint XONLINE_E_BILLING_COUNTRY_ID_NOT_FOUND = 0x80153032;  // invalid country id
        public const uint XONLINE_E_BILLING_LOCALE_NOT_FOUND = 0x80153033;  // locale not found
        public const uint XONLINE_E_BILLING_QUEUED_ACCOUNT_NOT_FOUND = 0x80153034;  // error loading billing queue item
        public const uint XONLINE_E_OFFERING_AUTOUPD_ERROR = 0x80153035;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_BANNER_LIST_ERROR = 0x80153036;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_CONTENT_AVAILABLE_ERROR = 0x80153037;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_CONTENT_DETAILS_ERROR = 0x80153038;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_CONTENT_ENUMERATE_ERROR = 0x80153039;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_CONTENT_HISTORY_ERROR = 0x8015303A;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_CONTENT_REFERRAL_ERROR = 0x8015303B;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_CONTENT_UPDATE_ERROR = 0x8015303C;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_ENUMERATE_GENRES_ERROR = 0x8015303D;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_ENUMERATE_TITLES_ERROR = 0x8015303E;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_FIND_MEDIA_INSTANCE_URLS_ERROR = 0x8015303F;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_GET_TITLE_ACTIVATION_ERROR = 0x80153040;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_GET_TITLE_DETAILS_ERROR = 0x80153041;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_IN_GAME_CONTENT_AVAILABLE_ERROR = 0x80153042;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_IN_GAME_CONTENT_ENUMERATE_ERROR = 0x80153043;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_DETAILS_ERROR = 0x80153044;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_DETAILS_NO_USER_ERROR = 0x80153045;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_SUBSCRIPTION_DETAILS_ERROR = 0x80153046;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_CANCEL_ERROR = 0x80153047;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_PURCHASE_OFFERS_ERROR = 0x80153048;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_SUBSCRIPTION_ENUMERATE_ERROR = 0x80153049;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_VERIFY_NICKNAME_ERROR = 0x8015304A;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_CONTENT_REFRESH_LICENSE_ERROR = 0x8015304B;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_GET_POINTS_PURCHASE_STATUS_ERROR = 0x8015304C;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_GET_REVOCATION_LIST_ERROR = 0x8015304D;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_OFFER_PURCHASE_ERROR = 0x8015304E;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_PURCHASE_MUSIC_ERROR = 0x8015304F;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_CREATE_CERTIFICATE_ERROR = 0x80153050;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_PURCHASE_GAMERTAG_ERROR = 0x80153051;  // non-specific (catch all) api error
        public const uint XONLINE_E_BILLING_PAYMENT_INFO_NOT_FOUND_ERROR = 0x80153052;  // payment info not found
        public const uint XONLINE_E_BILLING_FRIENDLY_NAME_NOT_FOUND_ERROR = 0x80153053;  // friendly name not found
        public const uint XONLINE_E_BILLING_CANNOT_SPECIFY_ANNIVERSARY_DATE_ERROR = 0x80153054;  // anniversary date was specified
        public const uint XONLINE_E_BILLING_CANNOT_SPECIFY_ACCOUNT_ID_ERROR = 0x80153055;  // account id was specified
        public const uint XONLINE_E_BILLING_CANNOT_SPECIFY_PAYMENT_ID_ERROR = 0x80153056;  // payment instrument id was specified
        public const uint XONLINE_E_BILLING_AREA_CODE_NOT_FOUND_ERROR = 0x80153057;  // area code not found
        public const uint XONLINE_E_BILLING_PHONE_NUMBER_NOT_FOUND_ERROR = 0x80153058;  // phone number not found
        public const uint XONLINE_E_BILLING_ADDRESS_NOT_FOUND_ERROR = 0x80153059;  // address not found
        public const uint XONLINE_E_BILLING_ACCOUNT_HOLDER_NAME_NOT_FOUND_ERROR = 0x8015305A;  // account holder name not found
        public const uint XONLINE_E_BILLING_ACCOUNT_NUMBER_NOT_FOUND_ERROR = 0x8015305B;  // account number not found
        public const uint XONLINE_E_BILLING_EXPIRATION_DATE_NOT_FOUND_ERROR = 0x8015305C;  // expiration date not found
        public const uint XONLINE_E_BILLING_BAD_CREDIT_CARD_TYPE_ERROR = 0x8015305D;  // bad credit card type
        public const uint XONLINE_E_BILLING_BRANCH_CODE_NOT_FOUND_ERROR = 0x8015305E;  // expiration date not found
        public const uint XONLINE_E_BILLING_EXTERNAL_REFERENCE_ID_NOT_FOUND = 0x8015305F;  // external reference id not found
        public const uint XONLINE_E_BILLING_WHOLESALE_PARTNER_NOT_FOUND = 0x80153060;  // wholesale partner id not found
        public const uint XONLINE_E_BILLING_ENCRYPTED_PASSWORD_NOT_FOUND = 0x80153061;  // encrypted password id not found
        public const uint XONLINE_E_BILLING_STREET_1_NOT_FOUND_ERROR = 0x80153062;  // street 1 id not found
        public const uint XONLINE_E_BILLING_CITY_NOT_FOUND_ERROR = 0x80153063;  // city id not found
        public const uint XONLINE_E_BILLING_COUNTRY_CODE_NOT_FOUND_ERROR = 0x80153064;  // country code not found
        public const uint XONLINE_E_BILLING_CHILD_CONTENT_PURCHASE_NOT_ALLOWED = 0x80153065;  // child accounts not allowed to purchase content in the user's country
        public const uint XONLINE_E_BILLING_CALCULATE_TAX_ERROR = 0x80153066;  // non-specific error calling SCS CalculateTax
        public const uint XONLINE_E_BILLING_SUBMIT_ORDER_ERROR = 0x80153067;  // non-specific error calling SCS SubmitOrder
        public const uint XONLINE_E_BILLING_SCS_SQL_TRANSACTION_FAILED = 0x80153068;  // a SQL transaction failed during an SCS SubmitOrder purchase
        public const uint XONLINE_E_BILLING_SCS_TRANSACTION_NOT_FOUND = 0x80153069;  // the SCS SubmitOrder tracking guid could not be found
        public const uint XONLINE_E_BILLING_SCS_TRANSACTION_CANCELLED = 0x8015306A;  // the SCS SubmitOrder tracking guid has already been cancelled
        public const uint XONLINE_E_BILLING_SCS_TRANSACTION_UNEXPECTED_STATE = 0x8015306B;  // the SCS SubmitOrder tracking guid was found with an unexpected status id
        public const uint XONLINE_E_BILLING_CHILD_OFFER_PURCHASE_NOT_ALLOWED = 0x8015306C;  // child accounts not allowed to purchase offer in user's country
        public const uint XONLINE_E_OFFERING_ASSET_CONSUME_ERROR = 0x8015306D;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_ASSET_ENUMERATE_ERROR = 0x8015306E;  // non-specific (catch all) api error
        public const uint XONLINE_E_OFFERING_SIGN_ASSETS_ERROR = 0x8015306F;  // non-specific (catch all) api error
        public const uint XONLINE_E_BILLING_FINBUS_MISSING_XNA_CREATOR_ID_ERROR = 0x80153070;  // Media purchased is of type XNA Community Game but catalog looking did not find an XNA Creator Id
        public const uint XONLINE_E_BILLING_CTP_COMMUNICATION_ERROR = 0x80153075;  // Error raised when we communication exception is received from CTP
        public const uint XONLINE_E_BILLING_CTP_VALIDATION_RENEWAL_ERROR = 0x80153076;   //Renewal Path Error
        public const uint XONLINE_E_BILLING_CTP_INVALIDRESPONSE = 0x80153077;   //Multiple nodes returned for Purchase call.Should not be happening.
        public const uint XONLINE_E_BILLING_CTP_AUTHORIZATION = 0x80153078;   //CTP Auth error
        public const uint XONLINE_E_BILLING_CTP_INVALID_PAYMENT = 0x80153079;   //Payment instrument errors
        public const uint XONLINE_E_BILLING_CTP_INVALID_TRACKING_GUID = 0x8015307A;   //Invalid Tracking Guid
        public const uint XONLINE_E_BILLING_CTP_INVALID_PAYMENTPROVIDER = 0x8015307B;   //Invalid Payment Provider
        public const uint XONLINE_E_BILLING_CTP_INVALID_CALLINGPARTNER = 0x8015307C;   //Invalid Calling partner
        public const uint XONLINE_E_BILLING_CTP_INVALID_ITEM = 0x8015307D;   //Invalid Purchase Item passed
        public const uint XONLINE_E_BILLING_CTP_INVALID_TRANSACTIONSTATUS = 0x8015307E;   //Invalid Transaction status
        public const uint XONLINE_E_BILLING_CTP_UNKNOWN = 0x8015307F;   //Unknown Error
        public const uint XONLINE_E_BILLING_CTP_INVALID_OFFER_NOTFOUND = 0x80153080;   //OfferId not found for Billing OfferId
        public const uint XONLINE_E_BILLING_CTP_NOTSUPPORTED_MEDIATYPE = 0x80153081;   //Mediatype not supported
        public const uint XONLINE_E_BILLING_CTP_INVALID_TOKEN = 0x80153082;   //Token is invalid
        public const uint XONLINE_E_BILLING_CTP_INVALID_SUB_OFFER_COUNT = 0x80153083;   //More than one offer found for subscription purchase
        public const uint XONLINE_E_OFFERING_GET_LEGACYOFFER_ERROR = 0x80153084;   //Error encountered looking up legacy offerId
        public const uint XONLINE_E_OFFERING_GET_OFFERINSTANCE_ERROR = 0x80153085;   //Error looking up the mapping for OfferInstance and Offer
        public const uint XONLINE_E_OFFERING_INVALID_RENEWAL = 0x80153086;   //No renewal path existing
        public const uint XONLINE_E_OFFERING_MULTIPLE_RENEWAL = 0x80153087;   //Multiple renewal path existing
        public const uint XONLINE_E_BILLING_CTP_INVALID_TIMEEXTENSION = 0x80153088;   //Time Extension passed is invalid
        public const uint XONLINE_E_BILLING_CTP_RATING_RULES_ERROR = 0x80153089;   //Invalid rating rules
        public const uint XONLINE_E_BILLING_CTP_INVALID_MODE = 0x8015308A;   //CTP Convert mode is invalid.Renewal not supported
        public const uint XONLINE_E_BILLING_CTP_NO_RETRYABLE_PURCHASE = 0x8015308B;   //No retryable items in CTP queue
        public const uint XONLINE_E_BILLING_CTP_TRANSACTION_NOT_FOUND = 0x8015308C;   //No transaction found update
        public const uint XONLINE_E_BILLING_CTP_RETRY_INTERVAL_EXCEEDED = 0x8015308D;   //Retry interval exceeded
        public const uint XONLINE_E_BILLING_CTP_TRANSACTION_SQL_ERROR = 0x8015308E;   //Unknown SQL error
        public const uint XONLINE_E_BILLING_CTP_QUEUE_ITERATOR_ERROR = 0x8015308F;   //Cannot build Queue Iterator
        public const uint XONLINE_E_BILLING_CTP_QUEUE_PURCHASE_INTENT_FAILURE = 0x80153090;   //Error creating CTP Purchase intent
        public const uint XONLINE_E_BILLING_SUBSCRIPTION_CREDIT_VALUE_MAPPING_ERROR = 0x80153091;   //Error loading CTP SubscriptionCreditValue mapping
        public const uint XONLINE_E_BILLING_BAD_CREDIT_VALUE = 0x80153092;   //Negative credit value configured
        public const uint XONLINE_E_OFFERING_GET_OFFERINGGUID_ERROR = 0x80153093;   //Error encountered looking up mapping for legacy id to guid
        public const uint XONLINE_E_OFFERING_GET_LEGACYID_ERROR = 0x80153094;   //Error encountered looking up mapping for guid to legacy id
        public const uint XONLINE_E_BILLING_CTP_PARTNERCONFIG_UNKNOWN_ERROR = 0x80153095;   // Error encountered during CTP Partner Configuration
        public const uint XONLINE_E_BILLING_CTP_INVALID_OVERRIDDEN_PRICE = 0x80153096;   // Overridden Price is negative
        public const uint XONLINE_E_BILLING_NOUNLIST_NOT_CONFIGURED = 0x80153097;   // Noun List not configured for country id
        public const uint XONLINE_E_BILLING_ADJECTIVELIST_NOT_CONFIGURED = 0x80153098;   // Adjective List not configured for country id
        public const uint XONLINE_E_OFFERING_FAMILY_TO_CLASSIC_DOWNGRADE_NOT_ALLOWED = 0x80153099;  // Family Gold users cannot purchase a Classic Gold subscription. They must wait for their subscription to expire to Silver before they can downgrade to Gold.
        public const uint XONLINE_E_BILLING_CTP_DIRECT_DEBIT_NOT_SUPPORTED = 0x8015309A;   // Direct Debit operation like convert is not supported in Mega API
        public const uint XONLINE_E_OFFERING_FAMILY_DEPENDENT_PURCHASE_NOT_ALLOWED = 0x8015309B;   // Family Gold dependents cannot purchase classic gold or family gold subscriptions
        public const uint XONLINE_E_OFFERING_FAMILY_CHILD_PURCHASE_NOT_ALLOWED = 0x8015309C;   // Child/Juvenille users cannot purchase family gold subscriptions
        public const uint XONLINE_E_OFFERING_ALREADY_OWN_MAX_MACHINE = 0x8015309D;   // PPV offer has already been purchased within the past 24 hours on the same machine/device i.e. this user already owns the maximum allowed on the machine -- see also XONLINE_E_OFFERING_ALREADY_OWN_MAX
        public const uint XONLINE_E_OFFERING_LICENSE_AVAILABLE = 0x8015309E;   // There is an existing license available that has not been downloaded and acknowledged for that offer -- see also XONLINE_E_OFFERING_ALREADY_OWN_MAX
        public const uint XONLINE_E_BILLING_CTP_INVALID_PRICE = 0x8015309F;   //Price passed from console does not match compute only
        public const uint XONLINE_E_BILLING_INVALID_TRACKING_GUID = 0x801530A0;   // Transaction id passed is not valid for this API or user

        //
        // XBOS success HRESULTS                                                     = 0x001531XX
        //
        public const uint XONLINE_S_OFFERING_NEW_CONTENT = 0x00153101;
        public const uint XONLINE_S_OFFERING_NO_NEW_CONTENT = 0x00153102;

        //
        // Internal DMP HRESULTS                                                     = 0x801532XX
        //
        public const uint XONLINE_E_DMP_TRANSACTION_CANCELLED = 0x80153200;  // the DMP transaction was cancelled
        public const uint XONLINE_E_DMP_CANT_GRANT_LICENSE = 0x80153201;  // there was an error adding a row to t_licenses
        public const uint XONLINE_E_DMP_CANT_REMOVE_LICENSE = 0x80153202;  // there was an error removing a row from t_licenses
        public const uint XONLINE_E_DMP_CANT_MARK_PURCHASE_CANCELLED = 0x80153203;  // there was an error marking a DMP transaction as cancelled
        public const uint XONLINE_E_DMP_CANCEL_SUCCESSFULL = 0x80153204;  // the call to CancelPurchaseItem returned successfully
        public const uint XONLINE_E_DMP_CANCEL_TRANS_NOT_FOUND = 0x80153205;  // the call to CancelPurchaseItem returned "transaction not found"
        public const uint XONLINE_E_DMP_CANT_MARK_PURCHASE_SUCCESS = 0x80153206;  // there was an error marking a DMP transaction as successfull
        public const uint XONLINE_E_DMP_UNEXPECTED_STATE = 0x80153207;  // the DMP transaction service encountered an unexpected state
        public const uint XONLINE_E_DMP_TRANSACTION_NOT_FOUND = 0x80153208;  // the DMP transaction guid could not be found in the table
        public const uint XONLINE_S_DMP_TRANSACTION_ALREADY_CANCELLED = 0x00153209;  // the DMP transaction has already been cancelled
        public const uint XONLINE_S_DMP_NO_CANCELABLE_TRANSACTIONS = 0x0015320A;  // there are no DMP purchase transactions to be cancelled
        public const uint XONLINE_E_DMP_CANT_MARK_PURCHASE_CANCEL_FAILED = 0x8015320B;  // there was an error marking a DMP transaction as cancelFailed
        public const uint XONLINE_S_DMP_NO_RETRYABLE_REWARD = 0x0015320C;  // there are no DMP reward transactions to be retriedg
        public const uint XONLINE_E_DMP_INVALID_REWARD = 0x8015320D;  // the reward does not exist or is misconfigured
        public const uint XONLINE_E_DMP_SQL_TRANSACTION_FAILED = 0x8015320E;  // a transaction failed to complete during a DMP operation
        public const uint XONLINE_S_DMP_RETRY_INTERVAL_EXCEEDED = 0x0015320F;  // a transaction was moved more to failure state because the retry interval was exceeded
        public const uint XONLINE_E_DMP_E_DELEGATE_NOT_SUPPORTED = 0x80153210;  // delegation not supported
        public const uint XONLINE_E_DMP_E_DESTINATION_ZERO = 0x80153211;  // error in destination puid's account
        public const uint XONLINE_E_DMP_E_INVALID_DESTINATION_ACCOUNT = 0x80153212;  // destination billing account is invalid
        public const uint XONLINE_E_DMP_E_MAX_BALANCE_TRANSFER_PROVISIONAL_EXCEEDED = 0x80153213;  // transfer maximum exceeded
        public const uint XONLINE_E_DMP_E_SOURCE_TRANSFER_PUIDS_SAME = 0x80153214;  // source and destination puids are the same
        public const uint XONLINE_E_DMP_E_SOURCE_ZERO = 0x80153215;  // error in source puid's account
        public const uint XONLINE_E_DMP_E_ZERO_NEGTIVE_TRANSFER = 0x80153216;  // error when source has zero points in account
        public const uint XONLINE_E_DMP_E_RISK_UNEXPECTED_RESULT = 0x80153217;  // Unexpected error in Risk data


        //
        // Internal XBOS HRESULTS                                                    = 0x801533XX
        //
        public const uint XONLINE_S_NO_RETRYABLE_SCS_PURCHASES = 0x00153300;  // there are no retryable SCS::PurchaseItem transactions
        public const uint XONLINE_E_SCS_TRANSACTION_NOT_FOUND = 0x80153301;  // the SCS transaction guid could not be found in the table
        public const uint XONLINE_E_CONTENT_NOT_FOUND = 0x80153302;  // Content not found
        public const uint XONLINE_E_MACHINE_ID_NOT_FOUND = 0x80153303;  // Machine id not found

        // DMP-specific XBOS HRESULTS                                                = 0x801534XX

        // internal hresults
        public const uint XONLINE_E_DMP_E_STATUS_UNREGISTERED = 0x80153400; // User is not registered with DMP.
        public const uint XONLINE_E_DMP_E_ORIGINAL_TRANSACTION_NOT_FOUND = 0x80153401; // The original record was not found, possibly archived
        public const uint XONLINE_E_DMP_E_DUPLICATE_EXTERNAL_ORDER_ID = 0x80153402; // returned from OrderItems if a duplicate orderId was passed into wcmusic.  Calling GetOrderByExternalOrderId should be called to get the updated status on that transaction, if needed.  Otherwise a new externalOrderID needs to be generated.

        // hresults that the client must be able to handle
        public const uint XONLINE_E_DMP_E_UNKNOWN_ERROR = 0x80153410; // Generic DMP error.  See server event log for specific details about what went wrong.
        public const uint XONLINE_E_DMP_E_REQUEST_CANNOT_BE_COMPLETED = 0x80153411; // The request cannot be completed due to user state. If the user is disabled then AddPromotionalBalance cannot be called upon that user.
        public const uint XONLINE_E_DMP_E_INSUFFICIENT_BALANCE = 0x80153412; // There is not sufficient balance to support this transaction
        public const uint XONLINE_E_DMP_E_MAX_BALANCE_EXCEEDED = 0x80153413; // The result point balance will exceed the policy max balance
        public const uint XONLINE_E_DMP_E_MAX_ACQUISITION_EXCEEDED = 0x80153414; // The point amount exceeds the policy max acquisition limit per transaction
        public const uint XONLINE_E_DMP_E_MAX_CONSUMPTION_EXCEEDED = 0x80153415; // The user consumption per period of time would exceed the policy limit
        public const uint XONLINE_E_DMP_E_NO_MORE_PROMO_POINTS = 0x80153416; // There are no more points to distribute for this tenant sku combination. All the promo points for this partner's promotional SKU are gone already!
        public const uint XONLINE_E_DMP_E_PROMOTION_LIMIT_LIFE_MAX = 0x80153417; // The promotional points user obtained would exceed the sku limit. There is a configurable per user limit on each promotion. The partner sets it in offer modeling time
        public const uint XONLINE_E_DMP_E_PROMO_EXPIRED = 0x80153418; // The promotional SKU has expired. The enddate for a promo is a configured limit set by the partner. If a request comes in after that configured deadline then the request is rejected
        public const uint XONLINE_E_DMP_E_MAX_ACQUISITIONPERSPAN_EXCEEDED = 0x80153419; // User attempt to acquire more points than is allowed in a given time span
        public const uint XONLINE_E_DMP_E_TARGETTRANSFER_INITIATED_WITHIN_NO_TRANSFER_WINDOW = 0x8015341A; // TransferBalance initiated within the no transfer window for the target account
        public const uint XONLINE_E_DMP_E_COUNTRY_CODE_MISMATCH = 0x8015341B; // TransferBalance failed because DMP source and destination accounts are in different countries
        public const uint XONLINE_E_DMP_E_USER_REGISTERED = 0x8015341C; // RegisterUser called for user already registered with DMP
        public const uint XONLINE_E_DMP_E_UNKNOWNSERVER_ERROR = 0x8015341D; // Unknown Server Error.
        public const uint XONLINE_E_DMP_E_SYSTEM_INTERNAL_ERROR = 0x8015341E; // A system internal error has occurred.
        public const uint XONLINE_E_DMP_E_INVALID_SOURCE_ACCOUNT = 0x8015341F; // Source Account is not in Active State for the Transaction.
        public const uint XONLINE_E_DMP_E_USER_DISABLED = 0x80153420; // User is disabled.
        public const uint XONLINE_E_DMP_E_PROMO_POINTS_UNAVAILIABLE = 0x80153421; // Promo points is unavailable
        public const uint XONLINE_E_DMP_E_INVALID_SKU = 0x80153422; // Sku passed for DMP purchase is invalid

        //
        // XCBK HRESULTS                                                             = 0x801535XX
        //
        public const uint XCBK_E_INVALID_SVC_COMPONENT = 0x80153500;
        public const uint XCBK_E_SUBSCRIPTION_NOT_FOUND = 0x80153501;
        public const uint XCBK_E_KEY_NOT_FOUND_IN_MESSAGE = 0x80153502;
        public const uint XCBK_E_SETTING_KEY_NOT_FOUND = 0x80153503;
        public const uint XCBK_E_UNAUTHORIZED_REQUEST = 0x80153504;
        public const uint XCBK_E_UNKNOWN_ERROR = 0x80153505;
        public const uint XCBK_E_SUBSCRIPTION_ACCOUNT_MISMATCH = 0x80153506;

        //
        // Diet Orange HResults                                                      = 0x8015360X
        //
        public const uint XONLINE_E_ORANGE_INVALID_REQUEST = 0x80153601;

        // MusicNet-specific XBOS HRESULTS                                           = 0x801537XX

        public const uint XONLINE_E_MUSICNET_BEGIN_ERROR_RANGE = 0x80153700; // marks beginning of musicnet-related error codes

        public const uint XONLINE_E_MUSICNET_UNKNOWN_ERROR = 0x80153700; // Generic MusicNet error.  See server event log for specific details about what went wrong.
        public const uint XONLINE_S_MUSICNET_NO_RETRYABLE_PURCHASE_ASSETS = 0x00153701; // no retryable MusicNet.PurchaseAssets transactions were found
        public const uint XONLINE_E_MUSICNET_TRANSACTION_NOT_FOUND = 0x80153702; // the transaction guid could not be found in the table
        public const uint XONLINE_E_MUSICNET_ORDERITEMS_ITEMS_WITH_ERRORS = 0x80153703; // a musicnet.orderitems call returned a non-empty itemsWithErrors
        public const uint XONLINE_E_MUSICNET_INVALID_ORDER_ID = 0x80153704; // musicnet already has processed the transaction with the specified order id (209)
        public const uint XONLINE_E_MUSICNET_ACCOUNT_SUSPENDED_OR_CLOSED = 0x80153705; // the musicnet account referenced has been suspended or is closed (424)
        public const uint XONLINE_E_MUSICNET_ACCOUNT_ALREADY_SUBSCRIBER = 0x80153706; // the musicnet account already has an active subscription offer. (216)
        public const uint XONLINE_E_MUSICNET_INVALID_CANCEL_REQUEST = 0x80153707; // Invalid cancelation request.  This account is already canceled. (204)
        public const uint XONLINE_E_MUSICNET_SUBSCRIPTION_ACCOUNT_CLOSED = 0x80153708; // Subscription account closed. (233)
        public const uint XONLINE_E_MUSICNET_INVALID_SKU_NUMBER = 0x80153709; // Invalid SKU number. (207)
        public const uint XONLINE_E_MUSICNET_INVALID_TRANSACTION_DATE = 0x8015370A; // Transaction date is in the future. Request denied. (206)
        public const uint XONLINE_E_MUSICNET_ACCOUNT_CANCELED = 0x8015370B; // This account is canceled.  Requested operation not allowed. (205)
        public const uint XONLINE_E_MUSICNET_INVALID_RESUME_REQUEST = 0x8015370C; // Invalid resume request. This account is already active. (203)
        public const uint XONLINE_E_MUSICNET_CANNOT_CHANGE_OFFER = 0x8015370D; // Cannot change to an offer that is the same as the current offer. (202)
        public const uint XONLINE_E_MUSICNET_ACCOUNT_HAS_EXPIRED_TRIAL = 0x8015370E; // This account has an expired trial. Cannot change the queued offer. (201)
        public const uint XONLINE_E_MUSICNET_ACCOUNT_ALREADY_HAS_TRIAL = 0x8015370F; // Already have a trial. (228)
        public const uint XONLINE_E_MUSICNET_TRIAL_OFFER_EXPIRED = 0x80153710; // Trial offer has expired. (210)
        public const uint XONLINE_E_MUSICNET_MAXIMUM_PURCHASE_COMPONENTS_EXCEEDED = 0x80153711; // Maximum number of purchase components per order exceeded. (229)
        public const uint XONLINE_E_MUSICNET_DUPLICATE_USER_NAME = 0x80153712; // Duplicate user name found (25)
        public const uint XONLINE_E_MUSICNET_INSUFFICIENT_FREE_TRACKS = 0x80153713; // Insufficient free tracks remain to complete purchase (432)
        public const uint XONLINE_E_MUSICNET_ACCOUNT_ALREADY_HAS_QUEUED_OFFER = 0x80153714; // Account already has a queued subscription offer (212)
        public const uint XONLINE_E_MUSICNET_INVALID_SUBSCRIPTION_FREE_PURCHASE = 0x80153715; // Invalid subscription free purchase type(434)
        public const uint XONLINE_E_MUSICNET_CONTENT_RIGHT_UNAVAILABLE = 0x80153716; // Content right not available for requested component(312)
        public const uint XONLINE_E_MUSICNET_END_ERROR_RANGE = 0x801537FF; // marks end of musicnet-related error codes

        // WMIS-specific XBOS HRESULTS                                               = 0x801538XX

        public const uint XONLINE_E_WMIS_UNKNOWN_ERROR = 0x80153800; // Generic WMIS error.  See server event log for specific details about what went wrong.
        public const uint XONLINE_E_WMIS_PURCHASE_DETAILS_NULL = 0x80153801; // WMIS is returning null on a GetVideoPurchaseDetails call.
        public const uint XONLINE_E_WMIS_UNKNOWN_ERROR_CONSOLE = 0x80153802; // Generic WMIS error on the console side.  The server should never return this error.
        public const uint DEPRECATED_XONLINE_E_WMIS_EMPTY_TITLE_TEXT = 0x80153803; // WMIS GetVideoPurchaseDetails returned an invalid empty title text field.

        // SyncCast-specific XBOS HRESULTS                                           = 0x801539XX
        public const uint DEPRECATED_XONLINE_E_SYNCCAST_UNKNOWN_ERROR = 0x80153900; // Generic SyncCast error.  See server event log for specific details about what went wrong.
        public const uint DEPRECATED_XONLINE_E_SYNCCAST_LICENSE_TOO_LARGE = 0x80153901; // SyncCast has returned a license too large to return to the client.
        public const uint DEPRECATED_XONLINE_E_SYNCCAST_LICENSE_EMPTY = 0x80153902; // SyncCast has returned an empty license when an exception was expected
        public const uint DEPRECATED_XONLINE_E_SYNCCAST_CLIENT_CERT_INVALID = 0x80153903; // Client cert is missing or invalid
        public const uint DEPRECATED_XONLINE_E_SYNCCAST_CLIENT_CERT_ACCESS_DENIED = 0x80153904; // Client cert access denied on the web service or the offer
        public const uint DEPRECATED_XONLINE_E_SYNCCAST_INVALID_OFFER_ACTION = 0x80153905; // An invalid action was requested for the given offer
        public const uint DEPRECATED_XONLINE_E_SYNCCAST_REACHED_COUNTER_LIMIT = 0x80153906; // Attempted to fulfill a request beyond the counter limit
        public const uint DEPRECATED_XONLINE_E_SYNCCAST_REACHED_EXPIRATION_DATE = 0x80153907; // Attempted to fulfill a request beyond the expiration date
        public const uint DEPRECATED_XONLINE_E_SYNCCAST_EMPTY_DEVICE_NAME = 0x80153908; // An empty device name was provided

        public const uint DEPRECATED_XONLINE_E_SYNCCAST_PLAYER_APP_REVOKED = 0x80153A00; // The player application has been revoked
        public const uint DEPRECATED_XONLINE_E_SYNCCAST_PLAYER_APP_SECURITY_UPGRADE = 0x80153A01; // A security upgrade id required for the player application
        public const uint DEPRECATED_XONLINE_E_SYNCCAST_DEVICE_REVOKED = 0x80153A02; // The device has been revoked


        // DRM License specific HRESULTS
        public const uint DEPRECATED_XONLINE_E_NO_VALID_LICENSE = 0x80153B01; // No license was available to acquire.
        public const uint DEPRECATED_XONLINE_E_VOD_LICENSE_EXPIRED = 0x80153B02; // Could not issue license as the VOD license acquisition window has closed
        public const uint DEPRECATED_XONLINE_E_NO_SCOID = 0x80153B03; // Could not retrieve SyncCast OfferId from WMIS
        public const uint DEPRECATED_XONLINE_E_VOD_INVALID_MACHINE = 0x80153B04; // Invalid machine.  Can only issue licenses to the purchasing machine.
        public const uint DEPRECATED_XONLINE_E_VOD_LICENSE_DELIVERED = 0x80153B05; // License has already been delivered and acknowledged

        // Internal FinBus HRESULTS                                                  = 0x80153CXX
        //

        public const uint XONLINE_S_FINBUS_NO_RETRYABLE_TRANSACTIONS = 0x00153C00;  // there are no retryable FinBus transactions in the t_finbus_transactions table
        public const uint XONLINE_E_FINBUS_TRANSACTION_NOT_FOUND = 0x80153C01;  // the FinBus transation does not exist in the t_finbus_transactions table
        public const uint XONLINE_E_FINBUS_SQL_TRANSACTION_FAILED = 0x80153C02;  // a SQL transaction using the t_finbus_transactions_table failed
        public const uint XONLINE_E_FINBUS_REDEMPTION_TRANSACTION_FAILED = 0x80153C03;  // there was an error updating the FinBus item's status to Pending from PrePending
        public const uint XONLINE_S_FINBUS_RETRY_INTERVAL_EXCEEDED = 0x00153C04;  // a FinBus transaction was moved more to failure state becuase the retry interval was exceeded
        public const uint XONLINE_E_FINBUS_HEALTH_CHECK_ERROR = 0x80153C05;  // Error calling the finbus health check
        public const uint XONLINE_E_FINBUS_FAST_FAIL_ERROR = 0x80153C06;  // Fast fail error when calling FinBus endpoint
        public const uint XONLINE_E_FINBUS_PUBLISH_MESSAGE_ERROR = 0x80153C07;  // non-specific (catch all) FinBus PublishMessage error
        public const uint XONLINE_E_FINBUS_IS_SERVICE_ALIVE_ERROR = 0x80153C08;  // non-specific (catch all) FinBus IsServiceAlive error

        // Tracked API HRESULTs                                                      = 0x80153DXX
        public const uint XONLINE_E_TRACKED_API_DUPLICATE_TRACKING_GUID = 0x80153D00;  // duplicate tracking guid found
        public const uint XONLINE_E_TRACKED_API_DATABASE_ERROR = 0x80153D01;  // error recording tracked api to database

        //
        // xuacs HRESULTS                                                            = 0x801540XX
        //
        public const uint XONLINE_S_ACCOUNTS_NAME_TAKEN = 0x00000010;

        public const uint XONLINE_E_ACCOUNTS_NAME_TAKEN = 0x80154000;
        public const uint XONLINE_E_ACCOUNTS_INVALID_KINGDOM = 0x80154001;
        public const uint XONLINE_E_ACCOUNTS_INVALID_USER = 0x80154002;
        public const uint XONLINE_E_ACCOUNTS_BAD_CREDIT_CARD = 0x80154003;
        public const uint XONLINE_E_ACCOUNTS_BAD_BILLING_ADDRESS = 0x80154004;
        public const uint XONLINE_E_ACCOUNTS_ACCOUNT_BANNED = 0x80154005;
        public const uint XONLINE_E_ACCOUNTS_PERMISSION_DENIED = 0x80154006;
        public const uint XONLINE_E_ACCOUNTS_INVALID_VOUCHER = 0x80154007;
        public const uint XONLINE_E_ACCOUNTS_DATA_CHANGED = 0x80154008; // unexpected modifications made during request.  commit is aborted to avoid overwriting modifcations.
        public const uint XONLINE_E_ACCOUNTS_VOUCHER_ALREADY_USED = 0x80154009;
        public const uint XONLINE_E_ACCOUNTS_OPERATION_BLOCKED = 0x8015400A;
        public const uint XONLINE_E_ACCOUNTS_POSTAL_CODE_REQUIRED = 0x8015400B;
        public const uint XONLINE_E_ACCOUNTS_TRY_AGAIN_LATER = 0x8015400C;
        public const uint XONLINE_E_ACCOUNTS_NOT_A_RENEWAL_OFFER = 0x8015400D;
        public const uint XONLINE_E_ACCOUNTS_RENEWAL_IS_LOCKED = 0x8015400E;
        public const uint XONLINE_E_ACCOUNTS_VOUCHER_REQUIRED = 0x8015400F;
        public const uint XONLINE_E_ACCOUNTS_ALREADY_DEPROVISIONED = 0x80154010;
        public const uint XONLINE_E_ACCOUNTS_INVALID_PRIVILEGE = 0x80154011;
        public const uint XONLINE_E_ACCOUNTS_INVALID_SIGNED_PASSPORT_PUID = 0x80154012;
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_ALREADY_LINKED = 0x80154013;
        public const uint XONLINE_E_ACCOUNTS_MIGRATE_NOT_XBOX1_USER = 0x80154014;
        public const uint XONLINE_E_ACCOUNTS_MIGRATE_BAD_SUBSCRIPTION = 0x80154015;
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_NOT_LINKED = 0x80154016;
        public const uint XONLINE_E_ACCOUNTS_NOT_XENON_USER = 0x80154017;
        public const uint XONLINE_E_ACCOUNTS_CREDIT_CARD_REQUIRED = 0x80154018;
        public const uint XONLINE_E_ACCOUNTS_MIGRATE_NOT_XBOXCOM_USER = 0x80154019;
        public const uint XONLINE_E_ACCOUNTS_NOT_A_VOUCHER_OFFER = 0x8015401A;
        public const uint XONLINE_E_ACCOUNTS_REACHED_TRIAL_OFFER_LIMIT = 0x8015401B; // Can't use trial offer because the limit for this console has already been reached
        public const uint XONLINE_E_ACCOUNTS_XBOX1_MANAGEMENT_BLOCKED = 0x8015401C; // A Xenon user is not allowed to access certain features (such as account management) from an xbox1 console
        public const uint XONLINE_E_ACCOUNTS_OFFLINE_XUID_ALREADY_USED = 0x8015401D; // The provided offline xuid has already been used to create an account
        public const uint XONLINE_E_ACCOUNTS_BILLING_PROVIDER_TIMEOUT = 0x8015401E; // The billing provider operation timed out
        public const uint XONLINE_E_ACCOUNTS_MIGRATION_OFFER_NOT_FOUND = 0x8015401F; // The billing offer id for the Xbox1 migration offer was not found
        public const uint XONLINE_E_ACCOUNTS_UNDER_AGE = 0x80154020; // Request cannot be processed because user is under-age.
        public const uint XONLINE_E_ACCOUNTS_XBOX1_LOGON_BLOCKED = 0x80154021; // The user account is restricted from signing on with Xbox1 titles
        public const uint XONLINE_E_ACCOUNTS_VOUCHER_INVALID_FOR_TIER = 0x80154022; // The voucher supplied is valid but not for the user's tier
        public const uint XONLINE_E_ACCOUNTS_SWITCH_PASSPORT_QUEUED = 0x80154023; // The SwitchUserPassport operation was interrupted due to SCS or DB error and will be retried
        public const uint XONLINE_E_ACCOUNTS_SERVICE_NOT_PROVISIONED = 0x80154024; // The user account is not provisioned for this service type
        public const uint XONLINE_E_ACCOUNTS_ACCOUNT_UNBAN_BLOCKED = 0x80154025; // The user account has been permantely banned and cannot be revoked by a CUST tool
        public const uint XONLINE_E_ACCOUNTS_SWITCH_PASSPORT_INELIGIBLE = 0x80154026; // The user has switched passports less than 30 days ago
        public const uint XONLINE_E_ACCOUNTS_ADDITIONAL_DATA_REQUIRED = 0x80154027; // The user has not provided address or phone information for XeSetAccountInfo
        public const uint XONLINE_E_ACCOUNTS_SWITCH_PASSPORT_SCS_PENDING = 0x80154028; // The user has a pending SCS points purchase request
        public const uint XONLINE_E_ACCOUNTS_SWITCH_PASSPORT_NO_BIRTHDATE = 0x80154029; // The user has no birthdate present in their Passport profile
        // NOTE - THE NUMBERS BELOW ARE OUT OF ORDER, BUT WE RELEASED IT SO IT STAYS
        public const uint XONLINE_E_ACCOUNTS_GRADUATE_USER_NO_PRIVILEGE = 0x8015102A; // User does not have privilege to graduate
        public const uint XONLINE_E_ACCOUNTS_GRADUATE_USER_NOT_CHILD = 0x8015102B; // User does not have a child account
        public const uint XONLINE_E_ACCOUNTS_GRADUATE_USER_NOT_ADULT = 0x8015102C; // User is not an adult (in their country)
        public const uint XONLINE_E_ACCOUNTS_GRADUATE_USER_NO_PI = 0x8015102D; // Client didn't specify payment instrument when one was required
        public const uint XONLINE_E_ACCOUNTS_GRADUATE_USER_PI_MISMATCH = 0x8015102E; // User supplied existing payment instrument but personal information does not match
        public const uint XONLINE_E_ACCOUNTS_GRADUATE_USER_ALREADY = 0x8015102F; // User supplied is already graduated
        public const uint XONLINE_E_ACCOUNTS_SWITCH_PASSPORT_ADULT_TO_CHILD = 0x80154030; // The user has an adult account but is trying to switch to a juvenile Passport
        public const uint XONLINE_E_ACCOUNTS_GRADUATE_USER_QUEUED = 0x80151031; // Graduation of the user was queued
        public const uint XONLINE_E_ACCOUNTS_SWITCH_PASSPORT_NEW_PASSPORT_INELIGIBLE = 0x80151032; // Cannot switch ownership of the specified account
        // NOTE - THE NUMBERS ABOVE ARE OUT OF ORDER, BUT WE RELEASED IT SO IT STAYS
        public const uint XONLINE_E_ACCOUNTS_NO_AUTHENTICATION_DATA = 0x80154033; // no authentication data was provided
        public const uint XONLINE_E_ACCOUNTS_CLIENT_TYPE_CONFIG_ERROR = 0x80154034; // npdb configuration of client types in t_multisettings is invalid
        public const uint XONLINE_E_ACCOUNTS_CLIENT_TYPE_MISSING = 0x80154035; // client type is missing,  was not provided
        public const uint XONLINE_E_ACCOUNTS_CLIENT_TYPE_INVALID = 0x80154036; // client type provided is invalid
        public const uint XONLINE_E_ACCOUNTS_COUNTRY_NOT_AUTHORIZED = 0x80154037; // service type / client type combination is not authorized for specified country
        public const uint XONLINE_E_ACCOUNTS_TAG_CHANGE_REQUIRED = 0x80154038; // account is required to change their gamertag
        public const uint XONLINE_E_ACCOUNTS_ACCOUNT_SUSPENDED = 0x80154039; // account is otherwise disabled, banned, suspended, etc. and requires management
        public const uint XONLINE_E_ACCOUNTS_TERMS_OF_SERVICE_NOT_ACCEPTED = 0x8015403A; // account is otherwise disabled, banned, suspended, etc. and requires management
        public const uint XONLINE_E_ACCOUNTS_SET_NO_AGE_OUT_QUEUED = 0x8015403B; // set passport no age out flag operation has been queued
        public const uint XONLINE_E_BILLING_USERACCOUNT_USER_NOT_FOUND = 0x8015403C; // User not found in GetANID call.
        public const uint XONLINE_E_BILLING_USERACCOUNT_INVALID_CLIENT = 0x8015403D; // Invalid client in GetANID call.
        public const uint XONLINE_E_BILLING_USERACCOUNT_XUID_DOES_NOT_MATCH_USER = 0x8015403E; // Xuid does not match user in GetANID call.
        public const uint XONLINE_E_ACCOUNTS_MIGRATION_ERROR = 0x8015403F; // unspecified error migrating an XBOX 1 offer
        public const uint XONLINE_E_ACCOUNTS_PUID_TO_ANID_ERROR = 0x80154040; // unspecified error converting puid to anid
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_LOAD_USER_ERROR = 0x80154041; // Error loading user by pasport puid
        public const uint XONLINE_E_ACCOUNTS_SWITCH_PASSPORT_ERROR = 0x80154042; // unspecified error switching user passport
        public const uint XONLINE_E_ACCOUNTS_OFFLINE_XUID = 0x80154043; // offline xuid prevents operation
        public const uint XONLINE_E_ACCOUNTS_RECOVER_ACCOUNT_ERROR = 0x80154044; // unspecified error recovering account
        public const uint XONLINE_E_ACCOUNTS_RENEWAL_ERROR = 0x80154045; // unspecified subscription renewal error
        public const uint XONLINE_E_BILLING_USERACCOUNT_CONTACTLIST_GAMERTAGS_ERROR = 0x80154046; // Failed to talk to ABCH.
        public const uint XONLINE_E_ACCOUNTS_PUID_TO_ANID_FAILED = 0x80154047; // Couldn't transform a puid to an anid.
        public const uint XONLINE_E_ACCOUNTS_UPDATE_XBOX_COM_ACTIVITY_ERROR = 0x80154048; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_UPS_GET_PROFILE_ERROR = 0x80154059; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_UPS_UPDATE_PROFILE_ERROR = 0x8015404A; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_SET_ACCOUNT_INFO_ERROR = 0x8015404B; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_ADD_PAYMENT_INSTRUMENT_ERROR = 0x8015404C; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_GET_ENCRYPTED_PROXY_PARAMETERS_ERROR = 0x8015404D; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_GET_FRIEND_MEMBER_NAME_ERROR = 0x8015404E; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_GET_PUID_FROM_MEMBER_NAME_ERROR = 0x8015404F; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_GET_SECRET_QUESTIONS_ERROR = 0x80154050; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_LOGIN_ERROR = 0x80154051; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_TERMS_OF_SERVICE_ERROR = 0x80154052; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_ACCOUNT_STATUS_ERROR = 0x80154053; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_ARGO_SIGN_IN_ERROR = 0x80154054; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_ARGO_AUTHENTICATE_ACCOUNT_ERROR = 0x80154055; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_CHANGE_SUBSCRIPTION_PAYMENT_INSTRUMENT_ERROR = 0x80154056; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_CLEAR_SUBSCRIPTIONS_ERROR = 0x80154057; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_CREATE_ACCOUNT_ERROR = 0x80154058; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_DISABLE_SUBSCRIPTION_ERROR = 0x80154059; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_ENUMERATE_ELIGIBLE_ERROR = 0x8015405A; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_ANID_ERROR = 0x8015405B; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_LINKED_GAMERTAG_ERROR = 0x8015405C; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_NO_AGE_OUT_ERROR = 0x8015405D; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_PAYMNET_INFO_ERROR = 0x8015405E; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_PAYMENT_INSTRUMENTS_ERROR = 0x8015405F; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_POSTAL_CODE_ERROR = 0x80154060; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_SUBSCRIPTION_STATUS_ERROR = 0x80154061; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_USER_INFO_ERROR = 0x80154062; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GRADUATE_USER_ERROR = 0x80154063; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_LINK_ACCOUNT_ERROR = 0x80154064; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_MIGRATE_USER_ERROR = 0x80154065; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_GET_USER_DATA_ERROR = 0x80154066; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_REMOVE_PAYMENT_INSTRUMENT_ERROR = 0x80154067; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_RESERVE_NAME_ERROR = 0x80154068; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_RESTORE_ACCOUNT_ERROR = 0x80154069; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_SET_NO_AGE_OUT_ERROR = 0x80154070; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_TERMS_OF_USE_ERROR = 0x80154071; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_SET_PAYMENT_INFO_ERROR = 0x80154072; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_SET_ACCOUNT_STATUS_ERROR = 0x80154073; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_SET_USER_PIN_ERROR = 0x80154074; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_SET_USER_SETTINGS_ERROR = 0x80154075; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_TROUBLESHOOT_ACCOUNT_ERROR = 0x80154076; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_UPDATE_PARENTAL_CONTROLS_ERROR = 0x80154077; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_UPDATE_PAYMENT_INSTRUMENT_ERROR = 0x80154078; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_VERIFY_BILLING_INFO_ERROR = 0x80154079; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_VERIFY_BILLING_PIN_ERROR = 0x8015407A; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_VERIFY_PARENT_CREDIT_CARD_ERROR = 0x8015407B; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_VERIFY_VOUCHER_ERROR = 0x8015407C; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_VERIFY_VOUCHER_GET_OFFER_ERROR = 0x8015407D; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_WEB_GET_USER_SETTINGS_ERROR = 0x8015407E; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_ACKNOWLEDGE_DOWNGRADE_ERROR = 0x8015407F; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_ACCOUNT_INFO_ERROR = 0x80154080; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_ACCOUNT_INFO_FROM_PASSPORT_ERROR = 0x80154081; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_POINTS_BALANCE_ERROR = 0x80154082; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_USER_SUBSCRIPTION_DETAILS_ERROR = 0x80154083; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_USER_TYPE_ERROR = 0x80154084; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_USER_WEB_INFO_ERROR = 0x80154085; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_CHANGE_PASSWORD_ERROR = 0x80154086; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_CREATE_ERROR = 0x80154087; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_GET_BUDDY_GAMERTAG_ERROR = 0x80154088; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_RESERVE_GAMERTAG_ERROR = 0x80154089; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_PASSPORT_GET_MEMBER_NAME_ERROR = 0x8015408A; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_PAYPAL_UNSUPPORTED_COUNTRY = 0x8015408B; // PayPal not supported in user's country
        public const uint XONLINE_E_ACCOUNTS_CANNOT_REPLACE_VALID_PASSPORT = 0x8015408D;
        public const uint XONLINE_E_ACCOUNTS_REPLACE_OWNER_PASSPORT_ERROR = 0x8015408E; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_REPLACE_USER_PASSPORT_ERROR = 0x8015408F; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_REPLACE_PASSPORT_QUEUED = 0x80154090; // The XeReplaceUserPassport operation was interrupted due to SCS or DB error and will be retried
        public const uint XONLINE_E_ACCOUNTS_GET_USER_TENURE_ERROR = 0x80154091; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_USER_TENURE_DATABASE_ERROR = 0x80154092;
        public const uint XONLINE_E_ACCOUNTS_SWITCH_USER_DATE_OF_BIRTH_ERROR = 0x80154093; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_SWITCH_OWNER_PASSPORT_ERROR = 0x80154094; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_INVALID_OWNER_PASSPORT_ERROR = 0x80154095;
        public const uint XONLINE_E_ACCOUNTS_GET_SUBSCRIPTION_INFO_ERROR = 0x80154096; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_GET_BILLING_NOTIFICATIONS_ERROR = 0x80154097; // no notifications found
        public const uint XONLINE_E_ACCOUNTS_USER_GET_ACCOUNT_INFO_ERROR = 0x80154098; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_USER_OPTED_OUT = 0x80154099;
        public const uint XONLINE_E_ACCOUNTS_GET_USER_TENURE_NO_POLICY = 0x8015409A; // a configuration error
        public const uint XONLINE_E_ACCOUNTS_GET_USER_TENURE_NO_TENURE = 0x8015409B;
        public const uint XONLINE_E_ACCOUNTS_GET_USER_TENURE_NO_LEVELS = 0x8015409C; // a configuration error
        public const uint XONLINE_E_ACCOUNTS_GET_USER_TENURE_NO_MILESTONES = 0x8015409D; // a configuration error
        public const uint XONLINE_I_ACCOUNTS_GET_USER_TENURE_NO_NEXT_MILESTONE = 0x0015409E; // a configuration error
        public const uint XONLINE_E_ACCOUNTS_GET_SUBSCRIPTION_INFO_SILVER_USER = 0x8015409F; // User is a silver account...
        public const uint XONLINE_E_ACCOUNTS_CANNOT_UNGRADUATE_USER = 0x801540A0; // cannot change a user's birthday from adult to child
        public const uint XONLINE_E_ACCOUNTS_INVALID_AGE = 0x801540A1; // cannot change a user's birthday to a date in the future, or long ago
        public const uint XONLINE_E_ACCOUNTS_MAX_ACCOUNTS_REACHED = 0x801540A2; // Max number of xbox accounts created from a machine has been reached
        public const uint XONLINE_E_ACCOUNTS_GENERATE_GAMERTAG_ERROR = 0x801540A3; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_USER_FREE_GAMERTAG_CHANGE_NOT_ELIGIBLE_ERROR = 0x801540A4; // User is not eligible for Free gamertag change
        public const uint XONLINE_E_ACCOUNTS_GET_CONSOLE_TRUST_LEVEL = 0x801540A5; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_SET_CONSOLE_TRUST_LEVEL = 0x801540A6; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_INVALID_CONSOLE_TRUST_LEVEL = 0x801540A7; // Console Trust Level outside valid range
        public const uint XONLINE_E_ACCOUNTS_CREATE_MOBILE_ACCOUNT_ERROR = 0x801540A8; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_ENUM_FAMILY_MEMBERS_ERROR = 0x801540A9; // Error occurred during call to EnumFamilyMembers API
        public const uint XONLINE_E_ACCOUNTS_ADD_DEPENDENT_ERROR = 0x801540AA; // Error occurred during call to AddDependent API
        public const uint XONLINE_E_ACCOUNTS_INVALID_FAMILY_SUBSCRIPTION = 0x801540AB; // No corresponding family subscription offer found in catalog.
        public const uint XONLINE_E_ACCOUNTS_INVALID_DEPENDENT_BASE = 0x801540AC; // Dependent does not have base subscription
        public const uint XONLINE_E_ACCOUNTS_INVALID_DEPENDENT_TIER = 0x801540AD; // Dependent is not silver
        public const uint XONLINE_E_ACCOUNTS_UNKNOWN_ERROR_CHANGE_STATE = 0x801540AE; // Unknow error changing the state
        public const uint XONLINE_E_ACCOUNTS_UNKNOWN_ERROR_MOVE_DEP_SUBSCRIPTION = 0x801540AF; // Unknow error moving dependent subscription
        public const uint XONLINE_E_ACCOUNTS_INVALID_COUNTRYID = 0x801540B0; // CountryDictionary.CountryCode returns null
        public const uint XONLINE_E_ACCOUNTS_INVALID_GAMERTAG = 0x801540B1; // VerifyGamerTag rejected gamertag
        public const uint XONLINE_E_ACCOUNTS_BIRTHDATE_INVALID = 0x801540B2; // Birthdate Invalid (future)
        public const uint XONLINE_E_ACCOUNTS_FORBIDDEN_GAMERTAG = 0x801540B3; // VetName failed for gamertag
        public const uint XONLINE_E_ACCOUNTS_FAMILY_GOLD_ASSIGNMENT_INELIGIBLE_ERROR = 0x801540B4; // User is not elegible to be granted dependent gold right in family subscription
        public const uint XONLINE_E_ACCOUNTS_GET_PARENTAL_CONTROLS_ERROR = 0x801540B5; // Error in parental controls
        public const uint XONLINE_E_ACCOUNTS_GET_DEPENDENT_SIGNED_PUID_ERROR = 0x801540B6; // Error in GetDependentSignedPuid
        public const uint XONLINE_E_ACCOUNTS_GET_BASE_SUBSCRIPTION_ERROR = 0x801540B7; // No Base subscription for the user
        public const uint XONLINE_E_ACCOUNTS_MULTIPLE_ACTIVE_BASE_SUBSCRIPTION = 0x801540B8; // Multiple Active base subscription
        public const uint XONLINE_E_ACCOUNTS_NO_ACTIVE_BASE_SUBSCRIPTION = 0x801540B9; // No Active base subscription
        public const uint XONLINE_E_ACCOUNTS_INVALID_FAMILYGOLD_CONVERTION_VALUE = 0x801540BA; // Invalid value configured for Family gold convertion value
        public const uint XONLINE_E_ACCOUNTS_FAMILY_GOLD_NOT_DEPENDENT_ERROR = 0x801540BB; // User is not a dependent and can't be granted a gold seat in a family subscription
        public const uint XONLINE_E_ACCOUNTS_FAMILY_GOLD_NO_SEATS_REMAIN_ERROR = 0x801540BC; // A dependent can't be assigned a gold seat in a family subscription because no seats remain.
        public const uint XONLINE_E_ACCOUNTS_FAMILY_GOLD_ALREADY_ASSIGNED_ERROR = 0x801540BD; // A dependent can't be assigned a gold seat because they already occupy one
        public const uint XONLINE_E_ACCOUNTS_FAMILY_GOLD_BILLING_REGION_ERROR = 0x801540BE; // A dependent can't be assigned a gold seat because their billing region does not match the owner's
        public const uint XONLINE_E_ACCOUNTS_FAMILY_GOLD_COOLDOWN_ERROR = 0x801540BF; // A dependent can't be assigned a gold seat because the cooldown period has no expired
        public const uint XONLINE_E_ACCOUNTS_FAMILY_GOLD_TOO_MANY_USERS_ERROR = 0x801540C0; // A dependent can't be assigned a gold seat because too many dependents have been assigned to gold seats recently
        public const uint XONLINE_E_ACCOUNTS_FAMILY_GOLD_UNTRUSTED_CONSOLE_ERROR = 0x801540C1; // A dependent can't be assigned a gold seat because the console is not trusted
        public const uint XONLINE_E_ACCOUNTS_INVALID_MACHINEPUID = 0x801540C2; // Can't find the specified machine
        public const uint XONLINE_E_ACCOUNTS_INVALID_BETA_GROUPID = 0x801540C3; // Can't find the specified beta group
        public const uint XONLINE_E_ACCOUNTS_POINTS_TRANSFER_ERROR = 0x801540C4; // Unkown error transfering points balance
        public const uint XONLINE_E_ACCOUNTS_INVALID_DEPENDENT_PRIMARY = 0x801540C5; // There is no parent child relationship between users
        public const uint XONLINE_E_ACCOUNTS_SWITCH_USER_COUNTRY_ERROR = 0x801540C7; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_SWITCH_USER_COUNTRY_INELIGIBLE = 0x801540C8; // The user has switched countries less than one year ago
        public const uint XONLINE_E_ACCOUNTS_SWITCH_USER_COUNTRY_INVALID_COUNTRY = 0x801540C9; // The country requested is not a LIVE-enabled country
        public const uint XONLINE_E_ACCOUNTS_FAMILY_GOLD_DEPENDENT_HAS_FAMILY = 0x801540CA; // A dependent can't be added because they have a family membership.
        public const uint XONLINE_E_ACCOUNTS_GET_PARENTAL_CONTROL_GROUP_TEMPLATES_ERROR = 0x801540CB; // Error in GetParentalControlGroupTemplates
        public const uint XONLINE_E_ACCOUNTS_GET_USER_PARENTAL_CONTROL_GROUP_ERROR = 0x801540CC; // Error in GetUserParentalControlGroup
        public const uint XONLINE_E_ACCOUNTS_SWITCH_USER_COUNTRY_INVALID_LOCALE = 0x801540CD; // The locale requested is not a valid LIVE locale
        public const uint XONLINE_S_ACCOUNTS_SWITCH_USER_COUNTRY_SAME_COUNTRY = 0x001540CE; // The user requested a switch to the country already associated with their account
        public const uint XONLINE_E_ACCOUNTS_SWITCH_USER_COUNTRY_TRY_AGAIN = 0x801540CF; // The operation was interrupted or timed out. Retry the call to determine the result.
        public const uint XONLINE_E_ACCOUNTS_UPDATE_PARENTAL_CONTROL_GROUP_ERROR = 0x801540D0; // Error in UpdateParentalControlGroup
        public const uint XONLINE_E_ACCOUNTS_NEGATIVE_POINTS_VALUE = 0x801540D1; // Negative points value passed
        public const uint XONLINE_E_ACCOUNTS_SWITCH_USER_COUNTRY_ADULT_TO_CHILD = 0x801540D2; // The user switching is an adult but would be a child in the new country.
        public const uint XONLINE_E_ACCOUNTS_SWITCH_USER_COUNTRY_DATABASE_ERROR = 0x801540D3; // Database error as part of executing SwitchUserCountry
        public const uint XONLINE_E_ACCOUNTS_SWITCH_USER_COUNTRY_NO_MIGRATION_OFFER = 0x801540D4; // No migration offer found for SwitchUserCountry
        public const uint XONLINE_E_ACCOUNTS_SWITCH_USER_COUNTRY_SUSPENDED_SUBSCRIPTION = 0x801540D5; // SwitchUserCountry does not allow migration for users with Xbox subscription which is suspended or expired
        public const uint XONLINE_E_ACCOUNTS_SWITCH_USER_COUNTRY_NON_XBOX_SUBSCRIPTION = 0x801540D6; // SwitchUserCountry does not allow migration for users with non-Xbox subscriptions such as Zune Pass, XNA Creators' Club, etc.
        public const uint XONLINE_E_ACCOUNTS_SWITCH_USER_COUNTRY_CHILD_ACCOUNT = 0x801540D7; // SwitchUserCountry does not allow child accounts to migrate
        public const uint XONLINE_E_ACCOUNTS_SWITCH_USER_COUNTRY_FAMILY_ACCOUNT = 0x801540D8; // SwitchUserCountry does not allow family accounts to migrate
        public const uint XONLINE_E_ACCOUNTS_GET_DEPENDENT_POINTS_BALANCE_ERROR = 0x801540D9; // Unkown error getting dependent point balance
        public const uint XONLINE_E_ACCOUNTS_DEPENDENT_MOVE_SUBSCRIPTION = 0x801540DA; // Error when moving dependents subscription
        public const uint XONLINE_E_ACCOUNTS_CREDENTIAL_LIST_BY_NAME_ERROR = 0x801540DB; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_USER_GET_AGE_ERROR = 0x801540DC; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_USER_GET_AGE_GROUP_ERROR = 0x801540DD; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_DEPENDENT_USER_IS_OWNER = 0x801540DE; // Error while creating owner a dependent user
        public const uint XONLINE_E_ACCOUNTS_OWNER_IS_DEPENDENT = 0x801540DF; // Error while creating dependent user as owner
        public const uint XONLINE_E_CREATE_BULK_USER_ERROR = 0x801540E0; // non-specific (catch all) api error
        public const uint XONLINE_E_ACCOUNTS_SWITCH_OWNER_PASSPORT_USER_INELIGIBLE = 0x801540E7; // user attempting to switch owner passport puids does not meet certain requirements

        // MSN RR-specific XBOS HRESULTS                                             = 0x801541XX
        public const uint XONLINE_E_MSNRR_BEGIN_ERROR_RANGE = 0x80154100; // marks beginning of msnrr-related error codes

        public const uint XONLINE_E_MSNRR_UNKNOWN_ERROR = 0x80154100; // Generic MSNRR error.  See server event log for specific details about what went wrong.
        public const uint XONLINE_E_MSNRR_INVALID_CONTENT_TYPE_ID = 0x80154101; // Invalid content type id. This error also occurs if content type does not have a rating attribute or review field.
        public const uint XONLINE_E_MSNRR_INVALID_ITEM_ID = 0x80154102; // Invalid item id
        public const uint XONLINE_E_MSNRR_PUID_CANNOT_BE_ZERO = 0x80154103; // PUID cannot be zero
        public const uint XONLINE_E_MSNRR_USE_MULTIPLE_RATING = 0x80154104; // Content type has multiple rating attribute ids, use the Multiple Rating Interface.
        public const uint XONLINE_E_MSNRR_INVALID_TRANSACTION_TOKEN = 0x80154105; // Token does not match request parameters, start over with no token.


        // Token related HRESULTS                                                    = 0x801542XX
        public const uint XONLINE_E_TOKEN_UNKNOWN_ERROR = 0x80154200; // Generic token error.  See server event log for specific details about what went wrong.
        public const uint XONLINE_E_TOKEN_FILE_NOT_FOUND = 0x80154201; // Token File Not Found
        public const uint XONLINE_E_TOKEN_REQUESTED_TOKENS_EXCEEDS_MAXIMUM_ALLOWABLE = 0x80154202;
        public const uint XONLINE_E_TOKEN_INVALID_START_PARAMETER = 0x80154203;
        public const uint XONLINE_E_TOKEN_MALFORMED_TOKEN_ENTRY_FOUND = 0x80154204;
        public const uint XONLINE_E_TOKEN_MALFORMED_5X5_TOKEN_CODE_FOUND = 0x80154205;
        public const uint XONLINE_E_TOKEN_FILE_COULD_NOT_BE_DECRYPTED = 0x80154206;
        public const uint XONLINE_E_TOKEN_EOF_REACHED_BEFORE_ALL_TOKENS_RETRIEVED = 0x80154207;
        public const uint XONLINE_E_TOKEN_JOB_NOT_IN_REQUIRED_STATE = 0x80154208;
        public const uint XONLINE_E_TOKEN_NOT_YET_REDEEMABLE = 0x80154209; // token cannot be redeemed yet because the token category is not flagged as redeemable
        public const uint XONLINE_E_TOKEN_LOAD_SCS_ERROR = 0x80154210;

        // Token category related HRESULTS                                           = 0x8015421X;
        public const uint XONLINE_E_TOKEN_DUPLICATE_CATEGORY_NAME = 0x80154211; // A duplicate token category name is found when trying to create a new token category.
        public const uint XONLINE_E_TOKEN_NO_CATEGORY_FOUND = 0x80154212; // Cannot find the token category.
        public const uint XONLINE_E_TOKEN_CATEGORY_READ_ONLY_PROPERTY_CHANGE = 0x80154213; // The "read only" properties of token category cannot be changed.
        // Token Job related HRESULTS
        public const uint XONLINE_E_TOKEN_JOB_DATABASE_ERROR = 0x80154220; // Unexpected database error manipulating Token Job in NPDB
        public const uint XONLINE_E_TOKEN_JOB_NOT_FOUND = 0x80154221; // Token Job either not present or not currently in Pending or abandoned state
        // Token sequence number HRESULTS
        public const uint XONLINE_E_TOKEN_SEQUENCE_NUMBER_INVALID_INDEX = 0x80154231; // We can't generate sequence number because the index is too large.
        public const uint XONLINE_E_TOKEN_EXPIRED_TOKEN_CATEGORY = 0x80154232; // Tokens cannot be generated for an expired token category

        //
        // Notification HRESULTS                                                     = 0x801550XX
        //
        public const uint XONLINE_E_NOTIFICATION_BAD_CONTENT_TYPE = 0x80155000;
        public const uint XONLINE_E_NOTIFICATION_REQUEST_TOO_SMALL = 0x80155001;
        public const uint XONLINE_E_NOTIFICATION_INVALID_MESSAGE_TYPE = 0x80155002;
        public const uint XONLINE_E_NOTIFICATION_NO_ADDRESS = 0x80155003;
        public const uint XONLINE_E_NOTIFICATION_INVALID_PUID = 0x80155004;
        public const uint XONLINE_E_NOTIFICATION_NO_CONNECTION = 0x80155005;
        public const uint XONLINE_E_NOTIFICATION_SEND_FAILED = 0x80155006;
        public const uint XONLINE_E_NOTIFICATION_RECV_FAILED = 0x80155007;
        public const uint XONLINE_E_NOTIFICATION_MESSAGE_TRUNCATED = 0x80155008;

        //
        // Match Service HRESULTS                                                    = 0x801551XX
        //
        public const uint XONLINE_E_MATCH_INVALID_SESSION_ID = 0x80155100;  // specified session id does not exist
        public const uint XONLINE_E_MATCH_INVALID_TITLE_ID = 0x80155101;  // specified title id is zero, or does not exist
        public const uint XONLINE_E_MATCH_INVALID_DATA_TYPE = 0x80155102;  // attribute ID or parameter type specifies an invalid data type
        public const uint XONLINE_E_MATCH_REQUEST_TOO_SMALL = 0x80155103;  // the request did not meet the minimum length for a valid request
        public const uint XONLINE_E_MATCH_REQUEST_TRUNCATED = 0x80155104;  // the self described length is greater than the actual buffer size
        public const uint XONLINE_E_MATCH_INVALID_SEARCH_REQ = 0x80155105;  // the search request was invalid
        public const uint XONLINE_E_MATCH_INVALID_OFFSET = 0x80155106;  // one of the attribute/parameter offsets in the request was invalid.  Will be followed by the zero based offset number.
        public const uint XONLINE_E_MATCH_INVALID_ATTR_TYPE = 0x80155107;  // the attribute type was something other than user or session
        public const uint XONLINE_E_MATCH_INVALID_VERSION = 0x80155108;  // bad protocol version in request
        public const uint XONLINE_E_MATCH_OVERFLOW = 0x80155109;  // an attribute or parameter flowed past the end of the request
        public const uint XONLINE_E_MATCH_INVALID_RESULT_COL = 0x8015510A;  // referenced stored procedure returned a column with an unsupported data type
        public const uint XONLINE_E_MATCH_INVALID_STRING = 0x8015510B;  // string with length-prefix of zero, or string with no terminating null
        public const uint XONLINE_E_MATCH_STRING_TOO_LONG = 0x8015510C;  // string exceeded 400 characters
        public const uint XONLINE_E_MATCH_BLOB_TOO_LONG = 0x8015510D;  // blob exceeded 800 bytes
        public const uint XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID = 0x80155110;  // attribute id is invalid
        public const uint XONLINE_E_MATCH_SESSION_ALREADY_EXISTS = 0x80155112;  // session id already exists in the db
        public const uint XONLINE_E_MATCH_CRITICAL_DB_ERR = 0x80155115;  // critical error in db
        public const uint XONLINE_E_MATCH_NOT_ENOUGH_COLUMNS = 0x80155116;  // search result set had too few columns
        public const uint XONLINE_E_MATCH_PERMISSION_DENIED = 0x80155117;  // incorrect permissions set on search sp
        public const uint XONLINE_E_MATCH_INVALID_PART_SCHEME = 0x80155118;  // title specified an invalid partitioning scheme
        public const uint XONLINE_E_MATCH_INVALID_PARAM = 0x80155119;  // bad parameter passed to sp
        public const uint XONLINE_E_MATCH_DATA_TYPE_MISMATCH = 0x8015511D;  // data type specified in attr id did not match type of attr being set
        public const uint XONLINE_E_MATCH_SERVER_ERROR = 0x8015511E;  // error on server not correctable by client
        public const uint XONLINE_E_MATCH_NO_USERS = 0x8015511F;  // no authenticated users in search request.
        public const uint XONLINE_E_MATCH_INVALID_BLOB = 0x80155120;  // invalid blob attribute
        public const uint XONLINE_E_MATCH_TOO_MANY_USERS = 0x80155121;  // too many users in search request
        public const uint XONLINE_E_MATCH_INVALID_FLAGS = 0x80155122;  // invalid flags were specified in a search request
        public const uint XONLINE_E_MATCH_PARAM_MISSING = 0x80155123;  // required parameter not passed to sp
        public const uint XONLINE_E_MATCH_TOO_MANY_PARAM = 0x80155124;  // too many paramters passed to sp or in request structure
        public const uint XONLINE_E_MATCH_DUPLICATE_PARAM = 0x80155125;  // a paramter was passed to twice to a search procedure
        public const uint XONLINE_E_MATCH_TOO_MANY_ATTR = 0x80155126;  // too many attributes in the request structure
        public const uint XONLINE_E_MATCH_CONCURRENT_REQ_CONFLICT = 0x80155127;  // this request conflicted with another that was in progress
        public const uint XONLINE_E_MATCH_SESSION_TYPE_MISMATCH = 0x80155128;  // this request was operation of a row type (breadcrumb vs. sandwich) which mismatched.
        public const uint XONLINE_E_MATCH_LOCK_ALREADY_RELEASED = 0x80155129;  // the session was expected to be locked, but it was actually unlocked..

        //
        // Session API HRESULTS                                                      = 0x801552XX
        //
        public const uint XONLINE_E_SESSION_NOT_FOUND = 0x80155200;   // the specified session was not found
        public const uint XONLINE_E_SESSION_INSUFFICIENT_PRIVILEGES = 0x80155201;   // the requester does not have permissions to perform this operation

        //
        // Audit API HRESULTS                                                        = 0x80155300 - 0x8015537F
        // These don't ever go on the wire.
        //
        public const uint XONLINE_E_AUDIT_INVALID_SUBSYSTEM = 0x80155300;   // use specified unknown subsystem
        public const uint XONLINE_E_AUDIT_NO_SETTING = 0x80155301;   // npdb setting for subsystem does not defined
        public const uint XONLINE_E_AUDIT_LOG_FAILURE = 0x80155302;   // error writing to audit log (database)

        //
        // Fse API HRESULTS                                                          = 0x80155380 - 0x801553FF
        //
        public const uint XONLINE_E_FSE_ERROR = 0x80155380;   // generic unhandled fse exception
        public const uint XONLINE_E_FSE_BOOKMARK_INVALID_SETTING = 0x80155381;   // invalid bookmark setting (range)
        public const uint XONLINE_E_FSE_BOOKMARK_NO_SETTING = 0x80155382;   // missing bookmark setting

        public const uint XONLINE_E_FSE_HANDLER_MISSING = 0x80155388;   // application page or result handler is missing
        public const uint XONLINE_E_FSE_HANDLER_CREATE_ERROR = 0x80155389;   // unhandled application exception derializing result
        public const uint XONLINE_E_FSE_HANDLER_MERGE_ERROR = 0x8015538A;   // unhandled application exception merge pages
        public const uint XONLINE_E_FSE_HANDLER_EXTRACT_ERROR = 0x8015538B;   // unhandled application exception extracting from page
        public const uint XONLINE_E_FSE_HANDLER_SPLIT_ERROR = 0x8015538C;   // unhandled application exception splitting page

        public const uint XONLINE_E_FSE_CACHE_INVALID_EXPIRATION = 0x80155390;   // invalid cache expriation time
        public const uint XONLINE_E_FSE_CACHE_KEY_TOO_LONG = 0x80155391;   // cache key is longer than xbanc configuration setting
        public const uint XONLINE_S_FSE_CACHE_ENTRY_FOUND = 0x00155392;   // cache entry found successfully
        public const uint XONLINE_E_FSE_CACHE_TIMEOUT = 0x80155393;   // timeout waiting for cache entry
        public const uint XONLINE_E_FSE_CACHE_ERROR = 0x80155394;   // exception thrown out of xbanc proxy
        public const uint XONLINE_E_FSE_CACHE_QUERY_ERROR = 0x80155395;   // exception thrown out of xbanc proxy
        public const uint XONLINE_E_FSE_CACHE_INSERT_ERROR = 0x80155396;   // exception thrown out of xbanc proxy

        public const uint XONLINE_E_FSE_CONFIG_METHOD_NOT_FOUND = 0x801553A0;   // configured method was not found
        public const uint XONLINE_E_FSE_CONFIG_NO_INTERFACE = 0x801553A1;   // no interface for configured method
        public const uint XONLINE_E_FSE_CONFIG_PARAM_ERROR = 0x801553A2;   // parameter configuration is invalid (couldn't be parsed)
        public const uint XONLINE_E_FSE_CONFIG_UNKNOWN_TYPE = 0x801553A3;   // unknown parameter type (won't be able to convert)
        public const uint XONLINE_E_FSE_CONFIG_MIN_OCCURS_INVALID = 0x801553A4;   // minOccurs < 0
        public const uint XONLINE_E_FSE_CONFIG_MAX_OCCURS_INVALID = 0x801553A5;   // maxOccurs < 1
        public const uint XONLINE_E_FSE_CONFIG_OCCURENCE_INVERSION = 0x801553A6;   // minOccurs > maxOccurs
        public const uint XONLINE_E_FSE_CONFIG_DUPLICATE_DELEGATE = 0x801553A7;   // parameter delegate already exists
        public const uint XONLINE_E_FSE_CONFIG_PAGE_SIZE_INVALID = 0x801553A8;   // cache page size or db page size are invalid

        public const uint XONLINE_E_FSE_DATABASE_ERROR = 0x801553B0;   // generic database error
        public const uint XONLINE_E_FSE_DATABASE_CONNECT_ERROR = 0x801553B1;   // generic database connection error
        public const uint XONLINE_E_FSE_DATABASE_EXECUTE_ERROR = 0x801553B2;   // generic database execute error

        public const uint XONLINE_E_FSE_METHOD_ERROR = 0x801553C0;   // generic method error
        public const uint XONLINE_E_FSE_METHOD_NOT_FOUND = 0x801553C1;   // method called by user does not exist
        public const uint XONLINE_E_FSE_METHOD_RETRY_COUNT_EXCEEDED = 0x801553C2;   // retry count exceeded when calling database
        public const uint XONLINE_E_FSE_METHOD_RESULT_NOT_PAGED = 0x801553C3;   // error constructing paged result

        public const uint XONLINE_E_FSE_PARAM_LIST_INVALID = 0x801553D0;   // number of names and values do not match
        public const uint XONLINE_E_FSE_PARAM_MISSING = 0x801553D1;   // missing required (non-optional) parameter
        public const uint XONLINE_E_FSE_PARAM_UNEXPECTED = 0x801553D2;   // extra unrecognized / unexpected parameter
        public const uint XONLINE_E_FSE_PARAM_INTERNAL_ERROR = 0x801553D3;   // internal programming error
        public const uint XONLINE_E_FSE_PARAM_TOO_MANY = 0x801553D4;   // too many parameters
        public const uint XONLINE_E_FSE_PARAM_INVALID_VALUE = 0x801553D5;   // invalid param value (fails regex checks)
        public const uint XONLINE_E_FSE_PARAM_CONVERSION_ERROR = 0x801553D6;   // error converting value to configured type
        public const uint XONLINE_E_FSE_PARAM_DELEGATE_FAILURE = 0x801553D7;   // a parameter modifying delegate defined by the application threw an exception
        public const uint XONLINE_E_FSE_PARAM_IS_NULL = 0x801553D8;   // required parameter is null
        public const uint XONLINE_E_FSE_PARAM_TOO_FEW = 0x801553D9;   // number of values are is too few
        public const uint XONLINE_E_FSE_PARAM_INTERNAL = 0x801553DA;   // supplied parameter is internal only
        public const uint XONLINE_E_FSE_PARAM_RESERVED = 0x801553DB;   // supplied parameter name is reserved

        public const uint XONLINE_E_FSE_BIN_ERROR_EXECUTING = 0x801553E0;   // Error executing the FsePlugin
        public const uint XONLINE_E_FSE_BIN_ERROR_CONSTRUCTING = 0x801553E1;   // Error contructing the FsePlugin

        //
        // Catalog Stored Procedure HRESULTS                                         = 0x80155400 - 0x8015547F
        //
        public const uint XONLINE_E_CATALOG_INVALID_DETAIL_VIEW = 0x80155400;   // detail view value is invalid
        public const uint XONLINE_E_CATALOG_INVALID_OFFER_FILTER_LEVEL = 0x80155401;   // offer filter level value is invalid
        public const uint XONLINE_E_CATALOG_INVALID_ORDER_BY = 0x80155402;   // order by value is invalid
        public const uint XONLINE_E_CATALOG_INVALID_ORDER_DIRECTION = 0x80155403;   // order direction value is invalid
        public const uint XONLINE_E_CATALOG_INVALID_RANKING_TYPE = 0x80155404;   // invalid ranking type in full text search
        public const uint XONLINE_E_CATALOG_INVALID_LOCALE = 0x80155405;   // invalid locale in full text search
        public const uint XONLINE_E_CATALOG_INVALID_VIDEO_FILTER = 0x80155406;   // invalid video filter in FindVideos
        public const uint XONLINE_E_CATALOG_INVALID_EDITORIAL_PRIV = 0x80155407;   // invalid editorial privilege

        public const uint XONLINE_E_CATALOG_INVALID_SETTING = 0x80155410;   // catalog service could not process a setting update
        public const uint XONLINE_E_CATALOG_ERROR = 0x80155411;   // unspecified catalog error
        public const uint XONLINE_E_CATALOG_DESERIALIZATION_ERROR = 0x80155412;   // could not deserialize catalog result
        public const uint XONLINE_E_CATALOG_SUBSCRIPTIONS_INVALID_ARGS = 0x80155413;   // Invalid Argument passed to FindSubscriptionProducts API

        // Service Tunnel HRESULTS                                                   = 0x80155480 - 0x801554FF

        public const uint XONLINE_E_SVCTUNNEL_ERROR = 0x80155480; // unspecified svctunnel error
        public const uint XONLINE_E_SVCTUNNEL_TIMEOUT = 0x80155481; // svctunnel timeout error
        public const uint XONLINE_E_SVCTUNNEL_GET_USER_INFO_ERROR = 0x80155482; // unspecified svctunnel get user info error
        public const uint XONLINE_E_SVCTUNNEL_SEND_USER_FEEDBACK_ERROR = 0x80155483; // unspecified svctunnel send feedback error
        public const uint XONLINE_E_SVCTUNNEL_GET_GAMERTAG_ERROR = 0x80155484; // unspecified svctunnel get gamertag error
        public const uint XONLINE_E_SVCTUNNEL_GET_USER_ID_ERROR = 0x80155485; // unspecified svctunnel get user id error
        public const uint XONLINE_E_SVCTUNNEL_GET_FRIENDS_ERROR = 0x80155486; // unspecified svctunnel get friends error
        public const uint XONLINE_E_SVCTUNNEL_GET_MESSAGES_ERROR = 0x80155487; // unspecified svctunnel get messages error
        public const uint XONLINE_E_SVCTUNNEL_FRIEND_REQUEST_ERROR = 0x80155488; // unspecified svctunnel friend request error
        public const uint XONLINE_E_SVCTUNNEL_GAME_INVITE_ERROR = 0x80155489; // unspecified svctunnel game invite error
        public const uint XONLINE_E_SVCTUNNEL_MUTE_USER_ERROR = 0x8015548A; // unspecified svctunnel mute user error
        public const uint XONLINE_E_SVCTUNNEL_SET_NOTIFICATION_ERROR = 0x8015548B; // unspecified svctunnel set notification error

        //
        // XCrypto HRESULTS                                                          = 0x801555XX
        //
        public const uint XONLINE_E_XCRYPTO_ERROR = 0x80155500;   // Generic error
        public const uint XONLINE_E_XCRYPTO_CONFIG_ERROR = 0x80155501;   // NPDB configuration error.
        public const uint XONLINE_E_XCRYPTO_KEY_ERROR = 0x80155502;   // Error creating crypto key.
        public const uint XONLINE_E_XCRYPTO_CACHE_ERROR = 0x80155503;   // Error creating / refreshing a cache.  Most likely due to a key error.
        public const uint XONLINE_E_XCRYPTO_REQUEST_FAILED = 0x80155504;   // An xcrypto request has failed.
        public const uint XONLINE_E_XCRYPTO_NCIPHER_ERROR = 0x80155505;   // Error calling down into nCipher wrap, which goes down to the nCipher hardware device.

        //
        // Messaging Service HRESULTS                                                = 0x80155AXX
        //
        public const uint XONLINE_E_MESSAGE_INVALID_MESSAGE_ID = 0x80155A01;   // the specified message was not found
        public const uint XONLINE_E_MESSAGE_PROPERTY_DOWNLOAD_REQUIRED = 0x80155A02;   // the property was too large to fit into the details block, it must be retrieved separately using XOnlineMessageDownloadAttachmentxxx
        public const uint XONLINE_E_MESSAGE_PROPERTY_NOT_FOUND = 0x80155A03;   // the specified property tag was not found
        public const uint XONLINE_E_MESSAGE_NO_VALID_SENDS_TO_REVOKE = 0x80155A04;   // no valid sends to revoke were found
        public const uint XONLINE_E_MESSAGE_NO_MESSAGE_DETAILS = 0x80155A05;   // the specified message does not have any details
        public const uint XONLINE_E_MESSAGE_INVALID_TITLE_ID = 0x80155A06;   // an invalid title ID was specified
        public const uint XONLINE_E_MESSAGE_SENDER_BLOCKED = 0x80155A07;   // a send failed because the recipient has blocked the sender
        public const uint XONLINE_E_MESSAGE_MAX_DETAILS_SIZE_EXCEEDED = 0x80155A08;   // the property couldn't be added because the maximum details size would be exceeded
        public const uint XONLINE_E_MESSAGE_INVALID_MESSAGE_TYPE = 0x80155A09;
        public const uint XONLINE_E_MESSAGE_USER_OPTED_OUT = 0x80155A0A;
        public const uint XONLINE_E_MESSAGE_INSUFFICIENT_PRIVILEGES = 0x80155A0B;   // the sender does not have permissions to send this message
        public const uint XONLINE_E_MESSAGE_UNDELIVERABLE = 0x80155A0C;   // the recipient does not have permissions to receive this message
        public const uint XONLINE_E_MESSAGE_THROTTLED = 0x80155A0D;  // the sender has sent too many messages today.
        // Success codes returned by Messages                                        = 0x00155AXX
        public const uint XONLINE_S_MESSAGE_PENDING_SYNC = 0x00155A01;   // updated message list is currently being retrieved (after logon or disabling summary refresh), returned results may be out of date

        //
        // Errors returned by uodb procs                                             = 0x801560XX
        //
        public const uint XONLINE_E_UODB_KEY_ALREADY_EXISTS = 0x80156000;  // service key already exists when attempting to insert key
        public const uint XONLINE_E_UODB_INEXISTENT_TITLE_ID = 0x80156001;
        public const uint XONLINE_E_UODB_KEY_NOT_FOUND = 0x80156002;
        public const uint XONLINE_E_SERVICE_KEY_NOT_FOUND = 0x80156002;
        public const uint XONLINE_E_UODB_INEXISTENT_OFFER_ID = 0x80156003;
        public const uint XONLINE_E_SERVICE_KEY_IMPORT_ERROR = 0x80156004;
        public const uint XONLINE_E_UODB_INVALID_SUBSCRIPTION_PAYMENT_TYPE = 0x80156005;
        public const uint XONLINE_E_UODB_DUPLICATE_SUBSCRIPTION_INFO = 0x80156006;

        //
        // Query service HRESULTS                                                    = 0x801561XX
        //
        public const uint XONLINE_E_QUERY_ERROR = 0x80156100; // unspecified query error
        public const uint XONLINE_E_QUERY_QUOTA_FULL = 0x80156101; // this user or team's quota for the dataset is full.  you must remove an entity first.
        public const uint XONLINE_E_QUERY_ENTITY_NOT_FOUND = 0x80156102; // the requested entity didn't exist in the provided dataset.
        public const uint XONLINE_E_QUERY_PERMISSION_DENIED = 0x80156103; // the user tried to update or delete an entity that he didn't own.
        public const uint XONLINE_E_QUERY_ATTRIBUTE_TOO_LONG = 0x80156104; // attribute passed exceeds schema definition
        public const uint XONLINE_E_QUERY_UNEXPECTED_ATTRIBUTE = 0x80156105; // attribute passed was a bad param for the database operation
        public const uint XONLINE_E_QUERY_RETHROW_ERROR = 0x80156106; // rethrow the original exception (used internally only)
        public const uint XONLINE_E_QUERY_INVALID_ACTION = 0x80156107; // the specified action (or dataset) doesn't have a select action associated with it.
        public const uint XONLINE_E_QUERY_SPEC_COUNT_MISMATCH = 0x80156108; // the provided number of QUERY_ATTRIBUTE_SPECs doesn't match the number returned by the procedure
        public const uint XONLINE_E_QUERY_DATASET_NOT_FOUND = 0x80156109; // The specified dataset id was not found.
        public const uint XONLINE_E_QUERY_PROCEDURE_NOT_FOUND = 0x8015610A; // The specified proc index was not found.
        public const uint XONLINE_E_QUERY_DUPLICATE_ENTRY = 0x8015610B; // An entry already exists that conflicts with the unique data index specified for this dataset
        public const uint XONLINE_E_QUERY_RETRY = 0x8015610C; // Retry if possible

        //
        // Competitions plugin HRESULTS                                              = 0x801562XX
        //
        public const uint XONLINE_E_COMP_ERROR = 0x80156200; // Unspecified comp error
        public const uint XONLINE_E_COMP_ACCESS_DENIED = 0x80156202; // The specified source (client) is not permitted to execute this method
        public const uint XONLINE_E_COMP_REGISTRATION_CLOSED = 0x80156203; // The competition is closed to registration
        public const uint XONLINE_E_COMP_FULL = 0x80156204; // The competition has reached it's max enrollment
        public const uint XONLINE_E_COMP_NOT_REGISTERED = 0x80156205; // The user or team isn't registered for the competition
        public const uint XONLINE_E_COMP_CANCELLED = 0x80156206; // The competition has been cancelled, and the operation is invalid.
        public const uint XONLINE_E_COMP_CHECKIN_TIME_INVALID = 0x80156207; // The user is attempting to checkin to an event outside the allowed time.
        public const uint XONLINE_E_COMP_CHECKIN_BAD_EVENT = 0x80156208; // The user is attempting to checkin to an event in which they are not a valid participant.
        public const uint XONLINE_E_COMP_CHECKIN_EVENT_SCORED = 0x80156209; // The user is attempting to checkin to an event which has already been scored by the service (user has forfeited or been ejected)
        public const uint XONLINE_S_COMP_CHECKIN_EVENT_SCORED = 0x00156209; // The user is attempting to checkin to an event but the users event has been updated. Re-query for a new event
        public const uint XONLINE_E_COMP_UNEXPECTED = 0x80156210; // Results from the Database are unexpected or inconsistent with the current operation.
        public const uint XONLINE_E_COMP_TOPOLOGY_ERROR = 0x80156216; // The topology request cannot be fulfilled by the server
        public const uint XONLINE_E_COMP_TOPOLOGY_PENDING = 0x80156217; // The topology request has not completed yet
        public const uint XONLINE_E_COMP_CHECKIN_TOO_EARLY = 0x80156218; // The user is attempting to checkin to an event outside the allowed time.
        public const uint XONLINE_E_COMP_ALREADY_REGISTERED = 0x80156219; // The user has already registered for this competition
        public const uint XONLINE_E_COMP_INVALID_ENTRANT_TYPE = 0x8015621A; // A team was specified for a non-team competition, or a user was specified for a team competition
        public const uint XONLINE_E_COMP_TOO_LATE = 0x8015621B; // The time alloted for performing the requested action has already passed.
        public const uint XONLINE_E_COMP_TOO_EARLY = 0x8015621C; // The specified action cannot yet be peformed.
        public const uint XONLINE_E_COMP_NO_BYES_AVAILABLE = 0x8015621D; // No byes remain to be granted
        public const uint XONLINE_E_COMP_SERVICE_OUTAGE = 0x8015621E; // A service outage has occured, try again in a bit
        public const uint XONLINE_S_COMP_SERVICE_OUTAGE = 0x0000000F; // A service outage was detected, evevnts were successfully rescheduled.  (used by cron/logging only)

        //
        // v1 Message Service HRESULTS                                               = 0x801570XX
        //
        public const uint XONLINE_E_MSGSVR_INVALID_REQUEST = 0x80157001; // request type was not one of the expected values

        //
        // String Service HRESULTS                                                   = 0x801571XX
        //
        public const uint XONLINE_E_STRING_ERROR = 0x80157100;  // unspecified error
        public const uint XONLINE_E_STRING_TOO_LONG = 0x80157101; // the string was longer than the allowed maximum
        public const uint XONLINE_E_STRING_OFFENSIVE_TEXT = 0x80157102; // the string contains offensive text
        public const uint XONLINE_E_STRING_NO_DEFAULT_STRING = 0x80157103; // returned by AddString when no string of the language specified as the default is found
        public const uint XONLINE_E_STRING_INVALID_LANGUAGE = 0x80157104; // returned by AddString when an invalid language is specified for a string
        public const uint XONLINE_E_STRING_LANGUAGE_DUPLICATE = 0x80157105; // returned by AddString when a language is specified more than once in a single request
        public const uint XONLINE_E_STRING_ADD_STRING_ERROR = 0x80157106;  // unspecified error in stringsvr add string
        public const uint XONLINE_E_STRING_GET_STRING_ERROR = 0x80157107;  // unspecified error in stringsvr get string
        public const uint XONLINE_E_STRING_LOAD_STRING_ERROR = 0x80157108;  // unspecified error in stringsvr load string
        public const uint XONLINE_E_STRING_LOG_STRING_ERROR = 0x80157109;  // unspecified error in stringsvr log string
        public const uint XONLINE_E_STRING_TITLE_ID_ERROR = 0x8015710A;  // unspecified error in stringsvr v1titleid
        public const uint XONLINE_E_STRING_VET_STRING_ERROR = 0x8015710B;  // unspecified error in stringsvr vet string

        //
        // Alerts Service HRESULTS                                                   = 0x801572XX
        //
        public const uint XONLINE_E_ALERTS_SUBSCRIPTION_NOT_FOUND = 0x80157201;   // user attempted to operate on a subscriptionid not present in the DB
        public const uint XONLINE_E_ALERTS_SUBSCRIBER_NOT_FOUND = 0x80157202;   // user attempted to operate on a subscriber not present in the DB

        //
        // Support (cxsuppapi) Service HRESULTS                                      = 0x801573XX
        //
        public const uint XONLINE_E_SUPPORT_ERROR = 0x80157300;   // unspecified support error

        //
        // Feedback Service HRESULTS                                                 = 0x801580XX
        //
        public const uint XONLINE_E_FEEDBACK_ERROR = 0x80158000;
        public const uint XONLINE_E_FEEDBACK_NULL_TARGET = 0x80158001;
        public const uint XONLINE_E_FEEDBACK_BAD_TYPE = 0x80158002;
        public const uint XONLINE_E_FEEDBACK_USER_NOT_FOUND = 0x80158003;
        public const uint XONLINE_E_FEEDBACK_CANNOT_LOG = 0x80158006;
        public const uint XONLINE_E_FEEDBACK_REVIEW_INVALID = 0x80158007;
        public const uint XONLINE_E_FEEDBACK_DATABASE_ERROR = 0x80158008;
        public const uint XONLINE_E_FEEDBACK_REVIEW_LIMIT_EXCEEDED = 0x80158009;
        public const uint XONLINE_E_FEEDBACK_GET_AGGREGATE_REVIEW_ERROR = 0x8015800A;
        public const uint XONLINE_E_FEEDBACK_USER_NOT_PRESENT = 0x8015800B;
        public const uint XONLINE_E_FEEDBACK_SUBMIT_COMPLAINT_ERROR = 0x8015800C;
        public const uint XONLINE_E_FEEDBACK_SUBMIT_REVIEW_ERROR = 0x8015800D;

        //
        // Lists Service HRESULTS                                                    = 0x801581XX
        //
        public const uint XONLINE_E_LISTS_ERROR = 0x80158100; // non-specific (catch-all) component error
        public const uint XONLINE_E_LISTS_PROPERTIES_TOO_LONG = 0x80158101; // list properties XML exceeds maximum length (1000)
        public const uint XONLINE_E_LISTS_INVALID_XML = 0x80158102; // XML failed schema validation
        public const uint XONLINE_E_LISTS_MALFORMED_XML = 0x80158103; // XML not well-formed
        public const uint XONLINE_E_LISTS_ID_MUST_BE_WILDCARD = 0x80158104; // list ID must be wildcard when list type is wildcard
        public const uint XONLINE_E_LISTS_ITEM_TOO_LONG = 0x80158105; // list item XML exceeds maximum length
        public const uint XONLINE_E_LISTS_DUPLICATE_IDS = 0x80158106; // arguments contain duplicate item IDs
        public const uint XONLINE_E_LISTS_EMPTY_PARAMETER = 0x80158107; // null or empty parameter array
        public const uint XONLINE_E_LISTS_NONEXISTENT_LIST_TYPE = 0x80158108; // nonexistent list type
        public const uint XONLINE_E_LISTS_TOO_MANY_INSTANCES = 0x80158109; // new list would exceed maximum instances
        public const uint XONLINE_E_LISTS_NAME_TOO_LONG = 0x8015810A; // list name exceeds maximum length (100)
        public const uint XONLINE_E_LISTS_NONEXISTENT_LIST = 0x80158110; // nonexistent list instance
        public const uint XONLINE_E_LISTS_TOO_MANY_ITEMS = 0x80158111; // new items would exceed maximum items
        public const uint XONLINE_E_LISTS_DUPLICATE_ITEM = 0x80158112; // item with given ID already exists in the list
        public const uint XONLINE_E_LISTS_NONEXISTENT_ITEM = 0x80158113; // nonexistent list item
        public const uint XONLINE_E_LISTS_DUPLICATE_INDEX = 0x80158114; // duplicate index given
        public const uint XONLINE_E_LISTS_INVALID_INDEX = 0x80158115; // invalid index given
        public const uint XONLINE_E_LISTS_DUPLICATE_LIST = 0x80158116; // user already has list with given name
        public const uint XONLINE_E_LISTS_INVALID_PAGE_SIZE = 0x80158117; // invalid page size (1 <= pageSize <= max results)
        public const uint XONLINE_E_LISTS_INCONSISTENT_VIEW = 0x80158118; // timestamp argument does not match list timestamp
        public const uint XONLINE_E_LISTS_INVALID_ORDER = 0x80158119; // invalid order direction (1 ascending, 2 descending)
        public const uint XONLINE_E_LISTS_API_MISMATCH = 0x80158120; // lists of this type should use a different API set

        public const uint XONLINE_E_LISTS_CREATE_LIST_ERROR = 0x80158180; // non-specific (catch-all) api error
        public const uint XONLINE_E_LISTS_DELETE_ITEMS_ERROR = 0x80158181; // non-specific (catch-all) api error
        public const uint XONLINE_E_LISTS_DELETE_LIST_ERROR = 0x80158182; // non-specific (catch-all) api error
        public const uint XONLINE_E_LISTS_GRANT_ACCESS_ERROR = 0x80158183; // non-specific (catch-all) api error
        public const uint XONLINE_E_LISTS_INSERT_ITEMS_ERROR = 0x80158184; // non-specific (catch-all) api error
        public const uint XONLINE_E_LISTS_MODIFY_ITEMS_ERROR = 0x80158185; // non-specific (catch-all) api error
        public const uint XONLINE_E_LISTS_MODIFY_LIST_ERROR = 0x80158186; // non-specific (catch-all) api error
        public const uint XONLINE_E_LISTS_QUERY_ITEMS_ERROR = 0x80158187; // non-specific (catch-all) api error
        public const uint XONLINE_E_LISTS_QUERY_LISTS_ERROR = 0x80158188; // non-specific (catch-all) api error
        public const uint XONLINE_E_LISTS_REVOKE_ACCESS_ERROR = 0x80158189; // non-specific (catch-all) api error
        public const uint XONLINE_E_LISTS_MOVE_ITEMS_ERROR = 0x8015818A; // non-specific (catch-all) api error

        public const uint XONLINE_E_DOWNLOAD_QUEUE_CREATE_QUEUE_ERROR = 0x801581C0; // non-specific (catch-all) api error
        public const uint XONLINE_E_DOWNLOAD_QUEUE_DELETE_ITEMS_ERROR = 0x801581C1; // non-specific (catch-all) api error
        public const uint XONLINE_E_DOWNLOAD_QUEUE_DELETE_QUEUE_ERROR = 0x801581C2; // non-specific (catch-all) api error (not used)
        public const uint XONLINE_E_DOWNLOAD_QUEUE_GRANT_ACCESS_ERROR = 0x801581C3; // non-specific (catch-all) api error
        public const uint XONLINE_E_DOWNLOAD_QUEUE_INSERT_ITEMS_ERROR = 0x801581C4; // non-specific (catch-all) api error
        public const uint XONLINE_E_DOWNLOAD_QUEUE_MODIFY_ITEMS_ERROR = 0x801581C5; // non-specific (catch-all) api error
        public const uint XONLINE_E_DOWNLOAD_QUEUE_MODIFY_QUEUE_ERROR = 0x801581C6; // non-specific (catch-all) api error
        public const uint XONLINE_E_DOWNLOAD_QUEUE_QUERY_ITEMS_ERROR = 0x801581C7; // non-specific (catch-all) api error
        public const uint XONLINE_E_DOWNLOAD_QUEUE_QUERY_QUEUES_ERROR = 0x801581C8; // non-specific (catch-all) api error
        public const uint XONLINE_E_DOWNLOAD_QUEUE_REVOKE_ACCESS_ERROR = 0x801581C9; // non-specific (catch-all) api error
        public const uint XONLINE_E_DOWNLOAD_QUEUE_MOVE_ITEMS_ERROR = 0x801581CA; // non-specific (catch-all) api error

        //
        // Stats HRESULTS                                                            = 0x801590XX
        //
        public const uint XONLINE_E_STAT_ERROR = 0x80159000;  // unspecified stat error
        public const uint XONLINE_E_STAT_BAD_REQUEST = 0x80159001;  // server received incorrectly formatted request.
        public const uint XONLINE_E_STAT_INVALID_TITLE_OR_LEADERBOARD = 0x80159002;  // title or leaderboard id were not recognized by the server.
        public const uint XONLINE_E_STAT_USER_NOT_FOUND = 0x80159003;  // user not found.
        public const uint XONLINE_E_STAT_TOO_MANY_SPECS = 0x80159004;  // too many stat specs in a request.
        public const uint XONLINE_E_STAT_TOO_MANY_STATS = 0x80159005;  // too manu stats in a spec.
        public const uint XONLINE_E_STAT_SET_FAILED_0 = 0x80159100;  // set operation failed on spec index 0
        public const uint XONLINE_E_STAT_PERMISSION_DENIED = 0x80159200;  // operation failed because of credentials. UserId is not logged in or this operation is not supported in production (e.g. userId=0 in XOnlineStatReset)
        public const uint XONLINE_E_STAT_LEADERBOARD_WAS_RESET = 0x80159201;  // operation failed because user was logged on before the leaderboard was reset.
        public const uint XONLINE_E_STAT_INVALID_ATTACHMENT = 0x80159202;  // attachment is invalid.
        public const uint XONLINE_S_STAT_CAN_UPLOAD_ATTACHMENT = 0x00159203;  // Use XOnlineStatWriteGetResults to get a handle to upload a attachment.
        public const uint XONLINE_E_STAT_TOO_MANY_PARAMETERS = 0x80159204;
        public const uint XONLINE_E_STAT_TOO_MANY_PROCEDURES = 0x80159205;
        public const uint XONLINE_E_STAT_NOT_ENOUGH_PARAMETERS = 0x80159208;
        public const uint XONLINE_E_STAT_INVALID_PROCEDURE = 0x80159209;
        public const uint XONLINE_E_STAT_EXCEEDED_WRITE_READ_LIMIT = 0x8015920a;
        public const uint XONLINE_E_STAT_LEADERBOARD_READONLY = 0x8015920b;
        public const uint XONLINE_E_STAT_MUSIGMA_ARITHMETIC_OVERFLOW = 0x8015920c;
        public const uint XONLINE_E_STAT_READ_NO_SPEC = 0x8015920d;
        public const uint XONLINE_E_STAT_MUSIGMA_NO_GAME_MODE = 0x8015920e;  // no game mode found for this leaderboard
        public const uint XONLINE_E_STAT_MISSING_RESULTS = 0x8015920f;  // not enough results returned from lb server
        public const uint XONLINE_E_STAT_EXTRA_RESULTS = 0x80159210;  // too many results returned from lb server
        public const uint XONLINE_E_STAT_SERVER_NOT_FOUND = 0x80159211;  // server not found
        public const uint XONLINE_E_STAT_ACHIEVEMENTS_NOT_SUPPORTED = 0x80159212;  // achievements not supported for title/platform
        public const uint XONLINE_E_STAT_AVATAR_ASSETS_NOT_SUPPORTED = 0x80159213;  // avatar assets not supported for title/platform
        public const uint XONLINE_E_STAT_CONSOLE_LIST_NOT_SUPPORTED = 0x80159214;  // console audit list not supported for platform
        public const uint XONLINE_E_STAT_CONSOLE_LIST_EMPTY = 0x80159215;  // console audit list is empty

        //
        // XSUPPAPI HRESULTS                                                         = 0x8015A0XX
        //
        public const uint XSUPP_E_EMAIL_ALREADY_SENT = 0x8015A000;
        public const uint XSUPP_E_INVALID_PUID_OR_SUB = 0x8015A001;
        public const uint XSUPP_E_INVALID_EMAIL_SENT_DATE = 0x8015A002;
        public const uint XSUPP_E_INVALID_SUBSCRIPTION_CODE = 0x8015A003;
        public const uint XSUPP_E_USER_DOES_NOT_OWN_OFFER = 0x8015A004;
        public const uint XSUPP_E_TOO_MANY_EXTRA_LICENSES = 0x8015A005;
        public const uint XSUPP_E_LICENSE_INCREMENT_GENERIC_ERROR = 0x8015A006;
        public const uint XSUPP_E_OWNER_PASSPORT_SWAP_CHILD_ONLY = 0x8015A007;
        public const uint XSUPP_E_NO_NEW_PASSPORT_SPECIFIED = 0x8015A008;
        public const uint XSUPP_E_USER_PASSPORT_SWAP = 0x8015A009;
        public const uint XSUPP_E_OWNER_PASSPORT_SWAP = 0x8015A00A;
        public const uint XSUPP_E_USER_DATE_OF_BIRTH_SWAP = 0x8015A00B;
        public const uint XSUPP_E_NEW_PASSPORT_MEMBER_NAME_MISMATCH = 0x8015A00C;
        public const uint XSUPP_E_INVALID_NEW_PASSPORT_MEMBER_NAME = 0x8015A00D;
        public const uint XSUPP_E_MULTIPLE_CREDENTIALS_FOR_THIS_MEMBER_NAME = 0x8015A00E;
        public const uint XSUPP_E_USER_NOT_FOUND = 0x8015A00F;
        public const uint XSUPP_E_USER_MACHINE_NOT_FOUND = 0x8015A010;
        public const uint XSUPP_E_USER_UNIQUE_MACHINE_NOT_FOUND = 0x8015A011;

        //
        // Signature Service HRESULTS                                                = 0x8015b0XX
        //
        public const uint XONLINE_E_SIGNATURE_ERROR = 0x8015b000;   // unspecified signature error
        public const uint XONLINE_E_SIGNATURE_VER_INVALID_SIGNATURE = 0x8015b001;   // presented signature does not match
        public const uint XONLINE_E_SIGNATURE_VER_UNKNOWN_KEY_VER = 0x8015b002;   // signature key version specified is not found among the valid signature keys
        public const uint XONLINE_E_SIGNATURE_VER_UNKNOWN_SIGNATURE_VER = 0x8015b003;   // signature version is unknown, currently only version 1 is supported
        public const uint XONLINE_E_SIGNATURE_BANNED_XBOX = 0x8015b004;   // signature is not calculated or revoked because Xbox is banned
        public const uint XONLINE_E_SIGNATURE_BANNED_USER = 0x8015b005;   // signature is not calculated or revoked because at least one user is banned
        public const uint XONLINE_E_SIGNATURE_BANNED_TITLE = 0x8015b006;   // signature is not calculated or revoked because the given title and version is banned
        public const uint XONLINE_E_SIGNATURE_BANNED_DIGEST = 0x8015b007;   // signature is not calculated or revoked because the digest is banned
        public const uint XONLINE_E_SIGNATURE_GET_BAD_AUTH_DATA = 0x8015b008;   // fail to retrieve AuthData from SG, returned by GetSigningKey api
        public const uint XONLINE_E_SIGNATURE_SERVICE_UNAVAILABLE = 0x8015b009;   // fail to retrieve a signature server master key, returned by GetSigningKey or SignOnBehalf api
        public const uint XONLINE_E_SIGNATURE_LICENSE_NOT_ACQUIRABLE = 0x8015b00a;   // AcquireMediaLicenses will not be able to acquire the license without a state change (like repurchase)
        public const uint XONLINE_E_SIGNATURE_LICENSE_COUNT_EXCEEDED = 0x8015B00B;   // The user already has the limit of licenses allowed.
        public const uint XONLINE_E_SIGNATURE_LICENSE_TRANSFER_BAD_COMMAND = 0x8015B00C;   // Tried to send a command that is inconsistent with the curent state of the transfer.
        //      public const uint XONLINE_E_SIGNATURE_LICENSE_TRANSFER_UNAUTHORIZED          = 0x8015B00D;   // The user requesting a transfer is not authorized due to a missing profile setting.
        public const uint XONLINE_E_SIGNATURE_CERTIFICATE_INVALID = 0x8015B00E;   // this is what we return to the user for invalid certificates
        public const uint XONLINE_E_SIGNATURE_CERTIFICATE_USAGE_INVALID = 0x8015B00F;   // this an internal only code
        public const uint XONLINE_E_SIGNATURE_CERTIFICATE_CHAIN_INVALID = 0x8015B010;   // this an internal only code
        public const uint XONLINE_E_SIGNATURE_CERTIFICATE_EXPIRED = 0x8015B011;   // this an internal only code
        public const uint XONLINE_E_SIGNATURE_PLAYREADY_DEVICE_CERT_EMPTY = 0x8015B012;   // The playready device certificate we generated is empty (internal only)
        public const uint XONLINE_E_SIGNATURE_PLAYREADY_DEVICE_CERT_TOO_BIG = 0x8015B013;   // The playready device certificate we generated is too big (internal only)
        public const uint XONLINE_E_SIGNATURE_PLAYREADY_DEVICE_CERT_FAILED = 0x8015B014;   // Failed to generate a playready device certificate. This is what we return to the caller.

        // non-specific (catch-all) signature API errors
        public const uint XONLINE_E_SIGNATURE_ACKNOWLEDGE_LICENSE_DELIVERY_ERROR = 0x8015b080; // non-specific acknowldege license delivery error
        public const uint XONLINE_E_SIGNATURE_ACQUIRE_MEDIA_LICENSES_ERROR = 0x8015b081; // non-specific acquire media licenses error
        public const uint XONLINE_E_SIGNATURE_CREATE_CERTIFICATE_ERROR = 0x8015b082; // non-specific create certificate error
        public const uint XONLINE_E_SIGNATURE_GET_AA_INFO_ERROR = 0x8015b083; // non-specific get aa info error
        public const uint XONLINE_E_SIGNATURE_GET_SIGNED_HEADER_ERROR = 0x8015b084; // non-specific get signed header error
        public const uint XONLINE_E_SIGNATURE_GENERATE_LICENSE_RESPONSE_ERROR = 0x8015b085; // non-specific generate license response error
        public const uint XONLINE_E_SIGNATURE_REFRESH_GAME_LICENSE_ERROR = 0x8015b086; // non-specific refresh game license error
        public const uint XONLINE_E_SIGNATURE_TRANSFER_USER_LICENSES_ERROR = 0x8015b087; // non-specific transfer user licenses error
        public const uint XONLINE_E_SIGNATURE_VALIDATE_CERTIFICATE_ERROR = 0x8015b089; // non-specific validate certificate error

        //
        // Arbitration HRESULTS                                                      = 0x8015b1XX
        //
        public const uint XONLINE_E_ARBITRATION_SERVICE_UNAVAILABLE = 0x8015b101; // Service temporarily unavailable
        public const uint XONLINE_E_ARBITRATION_INVALID_REQUEST = 0x8015b102; // The request is invalidly formatted
        public const uint XONLINE_E_ARBITRATION_SESSION_NOT_FOUND = 0x8015b103; // The session is not found or has expired
        public const uint XONLINE_E_ARBITRATION_REGISTRATION_FLAGS_MISMATCH = 0x8015b104; // The session was registered with different flags by another Xbox
        public const uint XONLINE_E_ARBITRATION_REGISTRATION_SESSION_TIME_MISMATCH = 0x8015b105; // The session was registered with a different session time by another Xbox
        public const uint XONLINE_E_ARBITRATION_REGISTRATION_TOO_LATE = 0x8015b106; // Registration came too late, the session has already been arbitrated
        public const uint XONLINE_E_ARBITRATION_NEED_TO_REGISTER_FIRST = 0x8015b107; // Must register in seesion first, before any other activity
        public const uint XONLINE_E_ARBITRATION_TIME_EXTENSION_NOT_ALLOWED = 0x8015b108; // Time extension of this session not allowed, or session is already arbitrated
        public const uint XONLINE_E_ARBITRATION_INCONSISTENT_FLAGS = 0x8015b109; // Inconsistent flags are used in the request
        public const uint XONLINE_E_ARBITRATION_INCONSISTENT_COMPETITION_STATUS = 0x8015b10A; // Whether the session is a competition is inconsistent between registration and report
        public const uint XONLINE_E_ARBITRATION_REPORT_ALREADY_CALLED = 0x8015b10B; // Report call for this session already made by this client
        public const uint XONLINE_E_ARBITRATION_TOO_MANY_XBOXES_IN_SESSION = 0x8015b10C; // Only up to 255 Xboxes can register in a session
        public const uint XONLINE_E_ARBITRATION_1_XBOX_1_USER_SESSION_NOT_ALLOWED = 0x8015b10D; // Single Xbox single user sessions should not be arbitrated
        public const uint XONLINE_E_ARBITRATION_REPORT_TOO_LARGE = 0x8015b10E; // The stats or query submission is too large
        public const uint XONLINE_E_ARBITRATION_INVALID_TEAMTICKET = 0x8015b10F; // An invalid team ticket was submitted

        //
        // Arbitration success HRESULTS
        //
        public const uint XONLINE_S_ARBITRATION_INVALID_XBOX_SPECIFIED = 0x0015b1F0; // Invalid/duplicate Xbox specified in lost connectivity or suspicious info. Never the less, this report is accepted
        public const uint XONLINE_S_ARBITRATION_INVALID_USER_SPECIFIED = 0x0015b1F1; // Invalid/duplicate user specified in lost connectivity or suspicious info. Never the less, this report is accepted
        public const uint XONLINE_S_ARBITRATION_DIFFERENT_RESULTS_DETECTED = 0x0015b1F2; // Differing result submissions have been detected in this session. Never the less, this report submission is accepted

        //
        // Storage Service HRESULTS                                                  = 0x8015C0XX
        //
        public const uint XONLINE_E_STORAGE_ERROR = 0x8015c000; // non-specific storage error
        public const uint XONLINE_E_STORAGE_INVALID_REQUEST = 0x8015c001; // Request is invalid
        public const uint XONLINE_E_STORAGE_ACCESS_DENIED = 0x8015c002; // Client doesn't have the rights to upload the file
        public const uint XONLINE_E_STORAGE_FILE_IS_TOO_BIG = 0x8015c003; // File is too big
        public const uint XONLINE_E_STORAGE_FILE_NOT_FOUND = 0x8015c004; // File not found
        public const uint XONLINE_E_STORAGE_INVALID_ACCESS_TOKEN = 0x8015c005; // Access token signature is invalid
        public const uint XONLINE_E_STORAGE_CANNOT_FIND_PATH = 0x8015c006; // name resolution failed
        public const uint XONLINE_E_STORAGE_FILE_IS_ELSEWHERE = 0x8015c007; // redirection request
        public const uint XONLINE_E_STORAGE_INVALID_STORAGE_PATH = 0x8015c008; // Invalid storage path
        public const uint XONLINE_E_STORAGE_INVALID_FACILITY = 0x8015c009; // Invalid facility code
        public const uint XONLINE_E_STORAGE_UNKNOWN_DOMAIN = 0x8015c00A; // Name resolver has no idea where to send you.
        public const uint XONLINE_E_STORAGE_SYNC_TIME_SKEW = 0x8015c00B; // SyncDomain timestamp skew
        public const uint XONLINE_E_STORAGE_SYNC_TIME_SKEW_LOCALTIME = 0x8015c00C; // SyncDomain timestamp appears to be localtime
        public const uint XONLINE_E_STORAGE_QUOTA_EXCEEDED = 0x8015c00D; // Quota exceeded for storage domain
        public const uint XONLINE_E_STORAGE_FILE_ALREADY_EXISTS = 0x8015c011; // File already exists and storage domain does not allow overwrites
        public const uint XONLINE_E_STORAGE_DATABASE_ERROR = 0x8015c012; // Unknown database error
        public const uint XONLINE_S_STORAGE_FILE_NOT_MODIFIED = 0x0015c013; // File hasn't been modified since given date
        public const uint XONLINE_E_STORAGE_INVALID_PATH = 0x8015c014; // Invalid file path
        public const uint XONLINE_E_STORAGE_TITLE_FILES_NOT_FOUND = 0x8015c015; // No storage files were found for the specified title

        //
        // Live Info Service HRESULTS                                                = 0x8015C1XX
        //
        public const uint XONLINE_E_LIVEINFO_ERROR = 0x8015C100;
        public const uint XONLINE_E_LIVEINFO_HIVE_INVALID_CONFIG = 0x8015c101; // Config name is invalid
        public const uint XONLINE_E_LIVEINFO_HIVE_ERROR_LOADING_CONFIG = 0x8015C102; // Error occured loading config
        public const uint XONLINE_E_LIVEINFO_CLIENT_ERROR = 0x8015C103; // General error for client failures

        //
        // Lsp HRESULTS                                                              = 0x8015C2xx
        //
        public const uint XONLINE_E_LSP_ERROR = 0x8015C200;
        public const uint XONLINE_E_LSP_BUCKET_INTERFACE_CONFIG_ERROR = 0x8015C201; // Bucket Interface not configured

        //
        // Passport HRESULTS (mapped from idsapi/passport return codes) 0x8015d0XX
        //
        public const uint XONLINE_E_PASSPORT_ERROR = 0x8015d000; // generic passport error for when we can't find a mapping
        public const uint XONLINE_E_PASSPORT_NAME_ALREADY_TAKEN = 0x8015d001; // Failed to create passport: name already taken
        public const uint XONLINE_E_PASSPORT_WRONG_NAME_OR_PASSWORD = 0x8015d002; // Wrong password and/or membername dose not exist.
        public const uint XONLINE_E_PASSPORT_LOCKED_OUT = 0x8015d003; // The credential is locked out.
        public const uint XONLINE_E_PASSPORT_FORCE_RENAME = 0x8015d004; // The credential is in a forced renamed state
        public const uint XONLINE_E_PASSPORT_FORCE_CHANGE_PASSWORD = 0x8015d005; // The password has to be changed.
        public const uint XONLINE_E_PASSPORT_FORCE_CHANGE_SQ_SA = 0x8015d006; // The secret question and answer has to be changed.
        public const uint XONLINE_E_PASSPORT_PASSWORD_EXPIRED = 0x8015d007; // The password for the account has expired.
        public const uint XONLINE_E_PASSPORT_REQUIRE_EMAIL_VALIDATION = 0x8015d008; // The account is blocked pending email address validation.
        public const uint XONLINE_E_FORBIDDEN_WORD = 0x8015d009; // String contained words that are forbidden by namespace administrator, examine input.
        public const uint XONLINE_E_PASSWORD_BLANK = 0x8015d00a; // The password is blank.
        public const uint XONLINE_E_PASSWORD_TOO_SHORT = 0x8015d00b; // The password is too short
        public const uint XONLINE_E_PASSWORD_TOO_LONG = 0x8015d00c; // The password is too long
        public const uint XONLINE_E_PASSWORD_CONTAINS_MEMBER_NAME = 0x8015d00d; // The password contains the member name.
        public const uint XONLINE_E_PASSWORD_CONTAINS_INVALID_CHARACTERS = 0x8015d00e; // The password contains invalid characters.
        public const uint XONLINE_E_SQ_CONTAINS_PASSWORD = 0x8015d00f; // The secret question contains the password.
        public const uint XONLINE_E_SA_CONTAINS_PASSWORD = 0x8015d010; // The answer for the secret question contains the password.
        public const uint XONLINE_E_PASSWORD_CONTAINS_SA = 0x8015d011; // The password validation code detected the answer to the secret question in the password.
        public const uint XONLINE_E_SQ_CONTAINS_SA = 0x8015d015; // The secret question contains the answer.
        public const uint XONLINE_E_SA_TOO_SHORT = 0x8015d017;
        public const uint XONLINE_E_SA_CONTAINS_SQ = 0x8015d018; // The answer to the secret question contains that question.
        public const uint XONLINE_E_SA_CONTAINS_MEMBER_NAME = 0x8015d019; // The answer for the secret question contains the member name.
        public const uint XONLINE_E_MEMBER_NAME_TOO_SHORT = 0x8015d01a; // The signin name is too short.
        public const uint XONLINE_E_MEMBER_NAME_INVALID = 0x8015d01b; // The signin name is incomplete or has invalid characters.
        public const uint XONLINE_E_PASSPORT_INVALID_DOMAIN = 0x8015d01c; // Cannot create EASI passport on reserved domain (e.g. hotmail.com)
        public const uint XONLINE_E_PASSPORT_INVALID_POSTAL_CODE = 0x8015d01d; // The postal code specified is invalid
        public const uint XONLINE_E_PASSPORT_SQ_TOO_SHORT = 0x8015d01f; // Secret question is too short
        public const uint XONLINE_E_PASSPORT_SQ_TOO_LONG = 0x8015d020; // Secret question is too long
        public const uint XONLINE_E_PASSPORT_KIDS_ACCOUNT_NO_CONSENT = 0x8015d021; // The PP Kids account does not have consent
        public const uint XONLINE_E_PASSPORT_SITE_NOT_AUTHORIZED = 0x8015d022; // xbox live service is not authorized to call the passport api

        // errors above are translations of passport errors
        // update PassportHelper.IsUserError() as necessary
        // errors below are xonline error codes

        public const uint XONLINE_E_PASSPORT_INVALID_ID = 0x8015d080; // passport could not find id (passport puid)
        public const uint XONLINE_E_PASSPORT_INVALID_RESPONSE = 0x8015d081; // passport could not find id (passport puid)
        public const uint XONLINE_E_PASSPORT_TOO_MANY_SECRET_QUESTIONS = 0x8015d082; // too many secret questions
        public const uint XONLINE_E_PASSPORT_TIMEOUT = 0x8015d083; // timeout talking to passport
        public const uint XONLINE_E_PASSPORT_NO_SECRET_QUESTIONS = 0x8015d084; // no secret questions for country and language
        public const uint XONLINE_E_PASSPORT_NO_DATA = 0x8015d085; // passport could not find any data to return
        public const uint XONLINE_E_PASSPORT_ASM_KEY_NOT_FOUND = 0x8015d086; // key sent to passport is not valid (old version, expired, etc.)


        public const uint XONLINE_E_UPS_ERROR = 0x8015d100; // error talking to UPS
        public const uint XONLINE_E_UPS_TIMEOUT_ERROR = 0x8015d101; // timeout error talking to UPS
        public const uint XONLINE_E_UPS_GET_PROFILE_ERROR = 0x8015d102; // non-specific (catch-all) error calling get profile
        public const uint XONLINE_E_UPS_UPDATE_PROFILE_ERROR = 0x8015d103; // non-specific (catch-all) error calling update profile

        //
        //RATINGS hresults                                                           = Ox8015d2xx
        //
        public const uint XONLINE_E_RATINGS_UNKNOWNERROR = 0x8015D200; //Unhandled/unknownError
        public const uint XONLINE_E_RATINGS_INVALID_COUNTRY = 0x8015D201; //Invalid country passed
        public const uint XONLINE_E_RATINGS_INVALID_USER = 0x8015D203; //Invalid user not presetn in UODB
        public const uint XONLINE_E_RATINGS_INVALID_RATING = 0x8015D204; //Invalid Rating value (<0 or >5)
        public const uint XONLINE_E_RATINGS_INVALID_MEDIATYPE = 0x8015D205; //Invalid Mediatype which cannot be rated
        public const uint XONLINE_E_RATINGS_MSN_ERROR = 0x8015D206; //General Error saving the rating
        public const uint XONLINE_E_RATINGS_UNKNOWNCATALOG_ERROR = 0x8015D207; //Unknown Catalog error cannling getbasicmediainfo
        public const uint XONLINE_E_RATINGS_MULTISETTING_ERROR = 0x8015D208; //Error getting the Multisettign for ratings mediatypes
        public const uint XONLINE_E_RATINGS_MEDIATYPE_VALIDATION = 0x8015D209; //Error validatign the mediatype for ratigns
        public const uint XONLINE_E_RATINGS_ERROR_GETUSER = 0x8015D20A; //Error getting the user details
        public const uint XONLINE_E_RATINGS_ERROR_MEDIAGET = 0x8015D20B; //Error getting thr Media Information from Catalog
        public const uint XONLINE_E_RATINGS_CONTENTTYPE_SETTING_ERROR = 0x8015D20C; //Error retrieving contentTypesetting from npdb
        public const uint XONLINE_E_RATINGS_CONTENTTYPE_MAPPING_ERROR = 0x8015D20D; //Error mapping contentType to Mediatype
        public const uint XONLINE_E_RATINGS_MSN_CONNECTION_ERROR = 0x8015D20E; //Error connecting to MSN Ratings service
        public const uint XONLINE_E_RATINGS_CRON_UNKNOWN_ERROR = 0x8015D20F; //Unknown Error in MSNRRAverages CRON plug-in
        public const uint XONLINE_E_RATINGS_CRON_SAVE_AVERAGE_ERROR = 0x8015D211; //Error saving Rating averages
        public const uint XONLINE_E_RATINGS_CRON_TRANSACTION_DATE_ERROR = 0x8015D212; //Error retrieving TransactionDate
        public const uint XONLINE_E_RATINGS_CRON_NPDB_SETTING_ERROR = 0x8015D213; //Error retrieving npdb setting
        public const uint XONLINE_E_RATINGS_CRON_TRANSACTION_DATE_SAVE_ERROR = 0x8015D214; //Error saving transaction date
        public const uint XONLINE_E_RATINGS_MISSING_COUNTRY_CODE_ON_GET_MEDIA_INFO = 0x8015D215; //GetMediaInfo invoked without specifying countryCode when retrieving user aggregate
        public const uint XONLINE_E_RATINGS_MISSING_MEDIA_ID_ON_GET_MEDIA_INFO = 0x8015D216; //GetMediaInfo invoked with empty/null guid for media id
        public const uint XONLINE_E_RATINGS_INVALID_MEDIA = 0x8015D217; //Media Queried for does not exist in the catalog

        //
        //ContentIngestion WebService                                                = 0x8015d3xx
        //
        public const uint XONLINE_E_CONTENTINGESTION_UNKNOWNERROR = 0x8015d300; //Unhandled/Unknown Error
        public const uint XONLINE_E_CONTENTINGESTION_INVALIDARGS = 0x8015d301; //Invalid Argument Specified


        //
        // Reflector HRESULTS                                                        = 0x8015d4xx
        //
        public const uint XONLINE_E_REFLECTOR_GENERIC_ERROR = 0x8015D400; // Generic error
        public const uint XONLINE_E_REFLECTOR_NO_TOKEN = 0x8015D401; // The user does not have a token for the specified network Id


        //
        //MigrateUser HRESULTS                                                       = 0x8015d5xx
        //
        public const uint XONLINE_E_MIGRATEUSER_GENERIC_ERROR = 0x8015D500; // generic error
        public const uint XONLINE_E_MIGRATEUSER_USER_DOES_NOT_EXIST_ERROR = 0x8015D501; // specified user does not exist
        public const uint XONLINE_E_MIGRATEUSER_FAILED_TO_LOAD_USER_ERROR = 0x8015D502; // failed to load the user for some reason.
        public const uint XONLINE_E_MIGRATEUSER_FAILED_TO_WRITE_XML_ERROR = 0x8015D503; // failed to write the user's data to xml for some reason.
        public const uint XONLINE_E_MIGRATEUSER_FAILED_TO_READ_XML_ERROR = 0x8015D504; // failed to read the user's data from xml for some reason.
        public const uint XONLINE_E_MIGRATEUSER_FAILED_TO_CREATE_USER_ERROR = 0x8015D505; // failed to create the user for some reason.
        public const uint XONLINE_E_MIGRATEUSER_USER_ALREADY_EXISTS_ERROR = 0x8015D506; // specified user already exists
        public const uint XONLINE_E_MIGRATEUSER_WRITE_TO_PROD_ERROR = 0x8015D507; // can't write a user to prod

        //TESTFD hresults                                                            = 0x8015d6xx
        //
        public const uint XONLINE_E_TESTFD_GENERIC_ERROR = 0x8015D600; // generic error
        public const uint XONLINE_E_TESTFD_API_NOT_AVAILABLE_ERROR = 0x8015D601; // insufficient permissions to access this API
        public const uint XONLINE_E_TESTFD_INVALID_DATABASE_ERROR = 0x8015D602; // database specified could not be found
        public const uint XONLINE_E_TESTFD_INVALID_TABLE_ERROR = 0x8015D603; // table specified could not be found
        public const uint XONLINE_E_TESTFD_INVALID_COLUMN_ERROR = 0x8015D604; // column specified could not be found
        public const uint XONLINE_E_TESTFD_INVALID_VALUE_ERROR = 0x8015D605; // value for specified column invalid
        public const uint XONLINE_E_TESTFD_INVALID_SQL_ERROR = 0x8015D606; // invalid sql statement
        public const uint XONLINE_E_TESTFD_BAD_COMMAND_ERROR = 0x8015D607; // command failed
        public const uint XONLINE_E_TESTFD_COMMAND_TIMEOUT_ERROR = 0x8015D608; // command took longer than expected to run
        public const uint XONLINE_E_TESTFD_BAD_PARTITION_ERROR = 0x8015D609; // invalid partition parameter
        public const uint XONLINE_E_TESTFD_BAD_PARTITION_HASH_TYPE_ERROR = 0x8015D60A; // invalid partition hashtype parameter
        public const uint XONLINE_E_TESTFD_SQL_NO_VALUE_ERROR = 0x8015D60B; // no value returned for a sql query
        public const uint XONLINE_E_TESTFD_NOT_ENOUGH_TITLES_PROPPED = 0x8015D60C; // not enough titles are propped to the environment to fufil the request

        // Social query HRESULTs
        public const uint XONLINE_E_SOCIAL_QUERY_GENERIC_ERROR = 0x8015D700; // generic error

        //Cert Grabber hresults                                                      = 0x8015d8xx

        //
        public const uint XONLINE_E_CERT_GRABBER_FAILED_TO_GET_NEW_CERT = 0x8015D800; // failed to query/retrieve the latest cert
        public const uint XONLINE_E_CERT_GRABBER_FAILED_TO_PARSE_NEW_CERT = 0x8015D801; // failed to parse the latest cert
        public const uint XONLINE_E_CERT_GRABBER_FAILED_TO_UPDATE_CERT = 0x8015D802; // failed to update npdb with the latest cert

        //XTOU hresults                                                              = 0x8015d9xx
        //
        public const uint XONLINE_E_XTOU_GETTERMSOFUSE_GENERIC_ERROR = 0x8015D900; // generic error for GetTermsOfUse
        public const uint XONLINE_E_XTOU_GETTERMSOFUSE_URL_PARSE_ERROR = 0x8015D901; // GetTermsOfUse failed to parse the URL
        public const uint XONLINE_E_XTOU_GETTERMSOFUSE_URL_GET_FILE_ERROR = 0x8015D902; // GetTermsOfUse failed to retrieve a TOU file from the database
        public const uint XONLINE_E_XTOU_GETLANGUAGESFORCOUNTRY_GENERIC_ERROR = 0x8015D903; // generic error for GetLanguagesForCountry

        //
        // Passport RPS HRESULTS
        //
        public const uint XONLINE_E_RPS_NOT_INITIALIZED = 0x8015e200; // RPS is not initialized. Other RPS methods can be called only after the RPS.Initialize method has succeeded.
        public const uint XONLINE_E_RPS_FAILED_TO_CREATE_DOM = 0x8015e201; // Failed to create DOM object.
        public const uint XONLINE_E_RPS_INTERNAL_ERROR = 0x8015e202; // Internal program or unexpected error. Could also be caused by programming or configuration error.
        public const uint XONLINE_E_RPS_INVALID_OBJECT_ID = 0x8015e203; // The object ID is invalid. This condition can be caused by an internal RPS error or an error from a custom component.
        public const uint XONLINE_E_RPS_OBJECT_ID_CANNOT_OVERWRITE = 0x8015e204; // The object ID cannot be overridden. Custom component only: this error is caused by an attempt to override an object that cannot be overridden.
        public const uint XONLINE_E_RPS_FAILED_TO_TLS = 0x8015e205; // TLS (thread local storage) call failed. The system is in a bad state. TlsAlloc failed.
        public const uint XONLINE_E_RPS_XML_FILE_ERROR = 0x8015e206; // XML file error. RPS has encountered an invalid XML configuration file.
        public const uint XONLINE_E_RPS_READ_ONLY = 0x8015e207; // Property is read only. This error is caused by an attempt to write to a read-only property bag.
        public const uint XONLINE_E_RPS_SERVER_CONFIG_ALREADY_INITTED = 0x8015e208; // The server configuration has already been initialized. This condition is caused by an internal RPS error.
        public const uint XONLINE_E_RPS_INVALIDCONFIG = 0x8015e209; // Invalid configuration.
        public const uint XONLINE_E_RPS_CERT_NOT_FOUND = 0x8015e20a; // Certificate cannot be found. A certificate required for the operation was not found.
        public const uint XONLINE_E_RPS_SKIBUFFER_TOO_SMALL = 0x8015e20b; // Buffer for subject key identifier (SKI) is too small. This condition is caused by an internal RPS error or an invalid certificate with a large SKI.
        public const uint XONLINE_E_RPS_FILE_TOO_LARGE = 0x8015e20c; // File is too large. This condition is caused by large certificate file. The maximum size is 512 kilobytes.
        public const uint XONLINE_E_RPS_INVALID_DATATYPE = 0x8015e20d; // Data type is invalid. The data type is different from the expected data type.
        public const uint XONLINE_E_RPS_MORE_DATA = 0x8015e20e; // Insufficient data buffer.
        public const uint XONLINE_E_RPS_INVALID_SIGNATURE = 0x8015e20f; // Signatures do not match.
        public const uint XONLINE_E_RPS_ENCRYPTEDKEY_TOO_LARGE = 0x8015e211; // The encrypted key data is too large. The maximum size is 1024 bytes.
        public const uint XONLINE_E_RPS_DATA_INTEGRITY_CHECK_FAILED = 0x8015e212; // The data integrity check failed. There was a hash mismatch.
        public const uint XONLINE_E_RPS_CERT_WITHOUT_PRIVATE_KEY = 0x8015e214; // The certificate used for decryption did not have private key.
        public const uint XONLINE_E_RPS_NET_CONFIG_CACHE_ALREADY_INITTED = 0x8015e215; // Network configuration cache has already been initialized. Caused by an internal RPS error.
        public const uint XONLINE_E_RPS_DOMAIN_ATTRIBUTE_NOT_FOUND = 0x8015e216; // The requested domain attribute was not found in RPSNetwork.xml.
        public const uint XONLINE_E_RPS_INVALIDDATA = 0x8015e217; // The data to pack or unpack is not valid RPS data.
        public const uint XONLINE_E_RPS_TICKET_NOT_INITIALIZED = 0x8015e218; // Ticket was not initialized.
        public const uint XONLINE_E_RPS_TICKET_CANNOT_BE_INITIALIZED_MORE_THAN_ONCE = 0x8015e219; // Ticket has already been initialized. A ticket object cannot be reused.
        public const uint XONLINE_E_RPS_SAML_ASSERTION_MISSINGDATA = 0x8015e21a; // A SAML assertion or WebSSO ticket is missing a data member. Invalid assertion.
        public const uint XONLINE_E_RPS_INVALID_TIMEWINDOW = 0x8015e21b; // Invalid time window. The time window parameter in the site configuration or supplied as an input parameter is either too large or too small.
        public const uint XONLINE_E_RPS_HTTP_BODY_REQUIRED = 0x8015e21d; // The HTTP body is required to authenticate. The application should call the method again with the HTTP body.
        public const uint XONLINE_E_RPS_INVALID_TICKET_TYPE = 0x8015e21e; // The ticket type is invalid. This condition could be caused by an incorrect ticket type or a switching of the RPSAuth and RPSSecAuth cookies.
        public const uint XONLINE_E_RPS_INVALID_SLIDINGWINDOW = 0x8015e21f; // Sliding time window is invalid. The input parameter for the sliding time window must be smaller than the parameter for the time window. These values can come from site configuration or method arguments.
        public const uint XONLINE_E_RPS_REASON_INVALID_AUTHMETHOD = 0x8015e220; // The Validate call failed because the AuthMethod check failed.
        public const uint XONLINE_E_RPS_NO_SUCH_PROFILE_ATTRIBUTE = 0x8015e222; // The attribute index requested is greater than the attribute count in the profile schema.
        public const uint XONLINE_E_RPS_INVALID_PROFILESCHEMA_TYPE = 0x8015e223; // The data type requested is not defined in the profile schema. The data type is not supported.
        public const uint XONLINE_E_RPS_FAILED_DOWNLOAD = 0x8015e224; // The RPS service failed to download RPSNetwork.xml.
        public const uint XONLINE_E_RPS_INVALID_SITEID = 0x8015e226; // The SiteId does not match the Ticket TargetId or audience.
        public const uint XONLINE_E_RPS_BASE64DECODE_FAILED = 0x8015e227; // Failed to do base64 decoding.
        public const uint XONLINE_E_RPS_REASON_TIMEWINDOW_EXPIRED = 0x8015e228; // The Validate call failed because the time window expired.
        public const uint XONLINE_E_RPS_REASON_SLIDINGWINDOW_EXPIRED = 0x8015e229; // The Validate call failed because the sliding time window expired.
        public const uint XONLINE_E_RPS_CERT_INVALID_KEY_SPEC = 0x8015e22a; // The certificate private key has an invalid key spec. The key spec should be AT_KEYEXCHANGE.
        public const uint XONLINE_E_RPS_INTERNAL_ERROR_CODE_UNSET_IN_EXCEPTION = 0x8015e22b; // Internal program error.
        public const uint XONLINE_E_RPS_REASON_INVALID_AUTHINSTANT_DATATYPE = 0x8015e22c; // An invalid AuthInstant data type was encountered during time-window validation.
        public const uint XONLINE_E_RPS_REASON_HTTPS_OR_ENCRYPTED_TICKET_NEEDED = 0x8015e22d; // HTTPS or an encrypted ticket is needed.
        public const uint XONLINE_E_RPS_REASON_INCORRECT_IV_BYTES = 0x8015e22e; // HTTPS or an encrypted ticket is needed.
        public const uint XONLINE_E_RPS_REASON_PASSPORT_F_ERROR_ENCOUNTERED = 0x8015e22f; // Passport f-code error was encountered in the query string.
        public const uint XONLINE_E_RPS_NO_SESSION_KEY = 0x8015e230; // There is no session key in the ticket.
        public const uint XONLINE_E_RPS_INVALID_COOKIE_NAME = 0x8015e231; // The reserved cookie name is specified.
        public const uint XONLINE_E_RPS_INVALID_AUTHPOLICY = 0x8015e232; // The AuthPolicy parameter in site configuration or input parameter is invalid or missing. Check the RPSNetwork.xml file for valid AuthPolicy names.
        public const uint XONLINE_E_RPS_INVALID_ENCRYPT_ALGID = 0x8015e233; // The encryption method algId is invalid.
        public const uint XONLINE_E_RPS_REASON_POST_TICKET_TIMEWINDOW_EXPIRED = 0x8015e234; // Post ticket time window expired. Ticket could be reposted.
        public const uint XONLINE_E_RPS_TICKET_HAS_NO_SESSIONKEY = 0x8015e235; // The ticket does not have a session key.
        public const uint XONLINE_E_RPSDATA_DATA_TOO_LARGE = 0x8015e400; // The data is larger than the RPSData limit.
        public const uint XONLINE_E_RPSDATA_INVALID_DATATYPE = 0x8015e401; // The data type in the data schema is not supported.
        public const uint XONLINE_E_RPSDATA_MORE_DATA = 0x8015e402; // The data buffer is insufficient.
        public const uint XONLINE_E_RPSDATA_INVALID_DATAOFFSET = 0x8015e403; // The data offset is too large or invalid.
        public const uint XONLINE_E_RPSDATA_INVALIDDATA = 0x8015e404; // The data is invalid.


        //
        //
        // NOTE: For new services, please use a range of 100 return codes, preferably between some existing services
        //
        //


        //
        // Billing Service HRESULTS                                                  = 0x80160000 - 0x8016FFFF
        //

        // IMPORTANT: DO NOT INTRODUCE ANY HRESULT VALUES IN THE RANGE: 0x80160000-0x8016ffff!
        //
        // The const definitions for the SCS/Billing HRESULTS are no longer defined here
        // but instead are autogenerated from the SCS bdkerror.xml file using an XSL script.
        //
        // Previously, this list was hand-generated or built from quick-and-dirty Perl script
        // that was not part of the build environment.  By making sure these errors are
        // always generated from the errors defined by current SCS SDK, the Xbox translations
        // of those errors should never lag too far behind SCS.
        //

        // Unfortunately, two Xbox-specific errors were introduced into this range which the
        // client now has a dependency on.  At present, SCS is not returning either of these
        // two error codes but if they ever do, code will need to be introduced to the BdkError
        // constructor to recognize and re-map them or there will be a potential ambiguity as to
        // what this error actually means.
        public const uint XONLINE_E_BILLING_PAYMENT_INSTRUMENT_CHANGES_RESTRICTED = 0x8016148b;  // Payment instrument changes are restricted through user (or tier or offer) privilege
        public const uint XONLINE_E_BILLING_PASSPORT_SWITCHING_RESTRICTED = 0x8016148c;  // Payment instrument changes are restricted through user (or tier or offer) privilege

        // GRARGH!!!!! 
        // The following error codes are the old billing error codes that were removed.
        // However, apparently much of the test code still uses these error codes though I'm
        // unable to find the associated billing error values so I'm not sure how the service
        // can actually be returning these values.  Stuff like this prevents the move of STF
        // to use the service versions of HResult and assocated classes.

        public const uint XONLINE_E_BILLING_EXCEEDS_MAXIMUM_DURATION = 0x8016a0fa;  // Error subscription duration exceeds max duration.
        public const uint XONLINE_E_BILLING_AUTHORIZATION_FAILED = 0x80167611;  // Credit card authorization failed.
        public const uint XONLINE_E_BILLING_TOKEN_NOT_VALID_FOR_OFFERING = 0x8016a04b;  // The token Id specified is not valid for the given offering.
        public const uint XONLINE_E_BILLING_STATE_ZIP_CITY_INVALID2 = 0x8016ea71;  // VERAZIP: Invalid state code/ZIP code/city name combination.
        public const uint XONLINE_E_BILLING_DUPLICATE_TRACKING_GUID = 0x80164e75;  // Duplicate tracking GUID.
        public const uint XONLINE_E_BILLING_INVALID_PAYMENT_INSTRUMENT_TYPE = 0x801675c8;  // Invalid payment instrument type.
        public const uint XONLINE_E_BILLING_CREDIT_CARD_EXPIRED = 0x80167531;  // Credit card has already expired.
        public const uint XONLINE_E_BILLING_INVALID_PAYMENT_METHOD_ID = 0x80169cf9;  // Invalid payment instrument ID.
        public const uint XONLINE_E_BILLING_OFFERING_REQUIRES_PI = 0x80169e89;  // Offering requires a payment instrument.
        public const uint XONLINE_E_BILLING_INVALID_CONVERSION = 0x80169e4d;  // Either there is no path between the current offering and the target offering or the path does not match the calling mode (Convert or Renew).
        public const uint XONLINE_E_BILLING_COUNTRY_CURRENCY_PI_MISMATCH = 0x801675c1;  // Country/currency/payment instrument type mismatch.
        public const uint XONLINE_E_BILLING_STATE_ZIP_CITY_INVALID = 0x8016ea70;  // VERAZIP: Invalid state code/ZIP code/city name combinations. Both state code/ZIP code and state code/city name were incorrect.
        public const uint XONLINE_E_BILLING_INVALID_EMAIL_ADDRESS = 0x80169ea2;  // Invalid e-mail address.
        public const uint XONLINE_E_BILLING_INVALID_CREDIT_CARD_NUMBER = 0x80167530;  // Invalid credit card number.
        public const uint XONLINE_E_BILLING_STATE_ZIP_INVALID = 0x8016ea6e;  // VERAZIP: Invalid state code/ZIP code combination.
        public const uint XONLINE_E_BILLING_PAYMENT_PROVIDER_CONNECTION_TIMEOUT = 0x8016767f;  // Payment provider connection timed out.
        public const uint XONLINE_E_BILLING_UNKNOWN_SERVER_FAILURE = 0x8016271f;  // Unknown server failure. API name: %2, Error code: 0x%3, Error description: %1.
        public const uint XONLINE_E_BILLING_NOPERMISSION = 0x80162711;  // Access denied.
        public const uint XONLINE_E_BILLING_REQUIRED_FIELD_MISSING = 0x80169c45;  // Required field missing.
        public const uint XONLINE_E_BILLING_MULTIPLE_CITIES_FOUND = 0x8016ea8a;  // VERAZIP: City has multiple ZIP codes.
        public const uint XONLINE_E_BILLING_STATE_INVALID = 0x8016ea6c;  // VERAZIP: Invalid state code.
        public const uint XONLINE_E_BILLING_ZIP_INVALID = 0x8016ea6b;  // VERAZIP: Invalid ZIP code.
        public const uint XONLINE_E_BILLING_BADZIP = 0x80162725;  // Invalid ZIP code.
        public const uint XONLINE_E_BILLING_USAGE_COUNT_FOR_TOKEN_EXCEEDED = 0x801613c9;  // The usage for the specified token has been exceeded.
        public const uint XONLINE_E_BILLING_DD_INVALID_BRANCHCODE_FORMAT = 0x8016763e;  // Invalid branch code format.
        public const uint XONLINE_E_BILLING_ADDITIONAL_ACCOUNT_DATA_REQUIRED = 0x8016aba5;  // The account requires additional attributes before performing the operation.
        public const uint XONLINE_E_BILLING_INVALID_WHOLESALE_PARTNER = 0x80167684;  // The wholesale partner specified is invalid.
        public const uint XONLINE_E_BILLING_ACCOUNT_CLOSED = 0x80169dd1;  // Account is already closed.
        public const uint XONLINE_E_BILLING_INVALID_TOKEN_SPECIFIED = 0x8016138d;  // Token passed is Invalid.
        public const uint XONLINE_E_BILLING_UNKNOWN_ERROR = 0x8016CE52;



        //
        // Private server-internal HRESULTS (never exposed to clients)
        // (range of 0x8017xxxx)
        //
        public const uint XONLINE_E_PUID_IS_MACHINE = 0x80170000;

        // tools management server
        public const uint TOOLS_SERVER_E_FILE_NOT_FOUND = 0x80170100; // tools service failed to find a file on file share to be propped to the data center
        public const uint TOOLS_SERVER_E_SD_ADD_FAILED = 0x80170101; // tools service failed to add a file to title manager repository
        public const uint TOOLS_SERVER_E_SD_SUBMIT_FAILED = 0x80170102; // tools service failed to submit a file into title manager repository
        public const uint TOOLS_SERVER_E_TMR_STATS = 0x80170103; // title manager failed to prop the package
        public const uint TOOLS_SERVER_E_INTERRUPTED_TASK = 0x80170104; // tools service was stopped while processing a job. The job should be rolled back manually
        public const uint TOOLS_SERVER_E_INVALID_TITLE_ID = 0x80170105; // tools service cannot process the job because title id is invalid

        //
        // livecache hresult (not exposed to consoles)                               = 0x80171xxx
        //
        public const uint XONLINE_E_LIVECACHE_EMPTY_RESULT = 0x80171001; // live service replied with empty result, this should not happen
        public const uint XONLINE_E_LIVECACHE_FORWARD_FAILED = 0x80171002; // failed to forward the request to live service: failed to connect or not getting response
        public const uint XONLINE_E_LIVECACHE_OFFLINE = 0x80171003; // the requested service has been turned off at livecache
        public const uint XONLINE_E_LIVECACHE_USER_OVERHEAT = 0x80171004; // too many requests from this same user within the current hour
        public const uint XONLINE_E_LIVECACHE_INEXIST_KEY = 0x80171005; // the key specified in LoadData request was not found, timed out?
        public const uint XONLINE_E_LIVECACHE_MAX_HEADER_COLLECTION_LIMIT = 0x80171006; // max header limit exceeded.


        //
        // wcmusic hresults (exposed to mtv, not consoles)                              = 0x80172xxx
        //
        public const uint XONLINE_E_WCMUSIC_TEST_FAULT = 0x80172000; // returned by TestConnection in order to test throwing faults
        public const uint XONLINE_E_WCMUSIC_ACCOUNT_SUSPENDED = 0x80172001; // returned by orderItems if account is suspended because of unconfirmed free trial
        public const uint XONLINE_E_WCMUSIC_INSUFFICIENT_BALANCE = 0x80172002; // returned by orderItems if no points available
        public const uint XONLINE_E_WCMUSIC_ITEM_ALREADY_PURCHASED = 0x80172003; // returned by orderItems if repurchaseOverride is false, which it never is currently
        public const uint XONLINE_E_WCMUSIC_ITEM_UNAVAILABLE = 0x80172004; // returned by orderItems if the component is unavailable from MusicNet
        public const uint XONLINE_E_WCMUSIC_TOO_MANY_ITEMS = 0x80172005; // returnded by orderItems if item count > 100
        public const uint XONLINE_E_WCMUSIC_NOT_SUSPENDED_BY_PARTNER = 0x80172006; // returned by orderItems if account is suspended manually by Customer Service Rep, or returned by resumeAccount if account is suspended manually by a Customer Service Rep
        public const uint XONLINE_E_WCMUSIC_ACCOUNT_NOT_ELIGIBLE = 0x80172007; // returned by AuthenticateAccount if user is not eligible for the Argo service due to country, age, restrictions, etc.
        public const uint XONLINE_E_WCMUSIC_ACCOUNT_NOT_PROVISIONED = 0x80172008; // returned by AuthenticateAccount if user has not been provisioned for Argo service
        public const uint XONLINE_E_WCMUSIC_INVALID_ARGUMENT = 0x80172009; // returned when an argument passed in to the API was not allowed/expected.
        public const uint XONLINE_E_WCMUSIC_TRANSACTION_PENDING = 0x8017200A; // returned from OrderItems when something went wrong and the purchase transaction is in an inderterminate state.  Calling GetOrderByExternalOrderId should be called to get the updated status on the transaction.
        public const uint XONLINE_E_WCMUSIC_DUPLICATE_EXTERNAL_ORDER_ID = 0x8017200B; // returned from OrderItems if a duplicate orderId was passed into wcmusic.  Calling GetOrderByExternalOrderId should be called to get the updated status on that transaction, if needed.  Otherwise a new externalOrderID needs to be generated.
        public const uint XONLINE_E_WCMUSIC_RPS_TICKET_EXPIRED = 0x8017200C; // returned from AuthenticateAccount when the Passport RPS ticket has expired
        public const uint XONLINE_E_WCMUSIC_INVALID_RETAILER_ID = 0x8017200D; // returned by any API that takes a retailerID, if the value specified was not expected
        public const uint XONLINE_E_WCMUSIC_MAX_CONSUMPTION_EXCEEDED = 0x8017200E; // returned by orderItems if the maximum number of points (defined by DMP policy) has been reached for the user making the purchase
        public const uint XONLINE_E_WCMUSIC_ACCOUNT_REQUIRES_MANAGEMENT = 0x8017200F; // returned if the account is otherwise disabled, banned, suspended, etc. and requires management on Argo.com
        public const uint XONLINE_E_WCMUSIC_ACCOUNT_INVALID_USER = 0x80172010; // returned if the RPS ticket is valid but for a user without an account
        public const uint XONLINE_E_WCMUSIC_MUSICNET_ERROR = 0x80172011; // returned if there was some sort of error returned from MusicNet
        public const uint XONLINE_E_WCMUSIC_MUSICNET_COMMUNICATION_ERROR = 0x80172012; // returned if there was communication error talking to musicnet


        //
        // Sts hresults                                                                 = 0x80173xxx
        //
        public const uint XONLINE_E_STS_ERROR = 0x80173000; // Unsepecified STS error
        public const uint XONLINE_E_STS_CONFIGURATION_ERROR = 0x80173001; // STS configuration error
        public const uint XONLINE_E_STS_INVALID_ARGUMENT = 0x80173002; // STS invalid argument error
        public const uint XONLINE_E_STS_INVALID_PLATFORM_TYPE = 0x80173003; // STS token requested for unsupported platform type

        //
        // ConfigDB hresults                                                            = 0x80174xxx
        //
        public const uint XONLINE_E_CONFIGDB_INVALID_COMPONENT = 0x80174000; // Caller specified a component name that does not exist in t_components
        public const uint XONLINE_E_CONFIGDB_INVALID_INSTANCE = 0x80174001; // Caller specified an instance name that does not exist in t_instances
        public const uint XONLINE_E_CONFIGDB_NO_DEFAULT_INSTANCE = 0x80174002; // This operation cannot be completed without a default instance specified in t_instances
        public const uint XONLINE_E_CONFIGDB_INVALID_SERVER = 0x80174003; // Caller specified a server name that does not exist in t_servers
        public const uint XONLINE_E_CONFIGDB_INVALID_SETTING = 0x80174004; // Caller specified a setting name that does not exist in t_settings
        public const uint XONLINE_E_CONFIGDB_INVALID_PARENT = 0x80174005; // Caller specified an instance that is already a child and cannot be used as a parent instance.
        public const uint XONLINE_E_CONFIGDB_CANNOT_DEMOTE_PARENT = 0x80174006; // Parent instances cannot be demoted back into children.
        public const uint XONLINE_E_CONFIGDB_INVALID_INTERFACE = 0x80174007; // Caller specified an interface that does not exist in t_interfaces.
        public const uint XONLINE_E_CONFIGDB_NAME_TOO_LONG = 0x80174008; // Caller specified a named item (component, server, setting, etc.) whose name exceeeded the allowable limit.
        public const uint XONLINE_E_CONFIGDB_NO_PARAMETERS_SPECIFIED = 0x80174009; // Call specified no parameters where at least one is required.

        /// <summary>
        /// Catalog Watcher Events                                                      = 0x80175xxx
        /// </summary>
        public const uint XONLINE_E_CATALOGWATCHER_INVALID_ID = 0x80175000; // The ID does not exist in the database
        public const uint XONLINE_E_CATALOGWATCHER_PRODUCER_ERROR = 0x80175001; // Generic producer error
        public const uint XONLINE_E_CATALOGWATCHER_PUBLISHER_ERROR = 0x80175002; // Generic publisher error
        public const uint XONLINE_E_CATALOGWATCHER_WATCHER_ERROR = 0x80175003; // Generic Watcher error
        public const uint XONLINE_E_CATALOGWATCHER_ESPPUBLISHER_FAST_OPERATION_ERROR = 0x80175004; // ESP operation error
        public const uint XONLINE_E_CATALOGWATCHER_ESPPUBLISHER_FAST_OPERATION_WARNING = 0x80175005; // ESP operation warning
        public const uint XONLINE_E_CATALOGWATCHER_INVALID_DESTINATION_NAME = 0x80175006; // The destination name is invalid
        public const uint XONLINE_E_CATALOGWATCHER_INVALID_RESOURCE_NAME = 0x80175007; // The resource name is invalid
        public const uint XONLINE_E_CATALOGWATCHER_PRODUCER_INVALID_QUEUE_OPERATION = 0x80175008; // The producer did not add anything to the queue
        public const uint XONLINE_E_CATALOGWATCHER_PUBLISHER_UPDATE_LSN_FAILED = 0x80175009; // The publisher could not update the LSN
        public const uint XONLINE_E_CATALOGWATCHER_PUBLISHER_INVALID_QUEUE_OPERATION = 0x8017500A; // The publisher did not dequeue
        public const uint XONLINE_E_CATALOGWATCHER_ESPPUBLISHER_INCORRECT_LSN_ORDER = 0x8017500B; // LSN's were not in monotonically increasing order
        public const uint XONLINE_E_CATALOGWATCHER_MEDIA_EXTRACTOR_MISSING_DOCUMENT = 0x8017500C; // Missing Document
        public const uint XONLINE_E_CATALOGWATCHER_NULL_DOCUMENT_IN_QUEUE = 0x8017500D; // Null document in queue
        public const uint XONLINE_E_CATALOGWATCHER_ZERO_QUEUE_SIZE = 0x8017500E; // Queue is being initialized with size 0
        public const uint XONLINE_E_CATALOGWATCHER_GENERATE_DOCUMENTS_INVALID_COUNT = 0x8017500F; // Count of <= 0 passed to GenerateDocuments
        public const uint XONLINE_E_CATALOGWATCHER_PRODUCER_NOT_INITIALIZED_CORRECTLY = 0x80175010; // Producer not initialized correctly
        public const uint XONLINE_E_CATALOGWATCHER_PUBLISHER_NEGATIVE_BUCKET = 0x80175011; // Bucket identifier is negative
        public const uint XONLINE_E_CATALOGWATCHER_PUBLISHER_NULL_DOCUMENT = 0x80175012; // Document is null
        public const uint XONLINE_E_CATALOGWATCHER_NULL_LSN = 0x80175013; // LSN is null
        public const uint XONLINE_E_CATALOGWATCHER_INVALID_INPUT_PARAMETER = 0x80175014; // Invalid input parameter
        public const uint XONLINE_E_CATALOGWATCHER_MISSING_PARAMETER = 0x80175015; // Missing input parameter
        public const uint XONLINE_E_CATALOGWATCHER_COMMAND_FAILURE = 0x80175016; // Generic Command Failure
        public const uint XONLINE_E_CATALOGWATCHER_PRODUCER_INVALID_STATE = 0x80175017; // Producer method has been invoked either without initializing or after an exception was thrown.
        public const uint XONLINE_E_CATALOGWATCHER_PRODUCER_NO_PDLC_CONFIG = 0x80175018; // pdlc_mediatypes setting is absent in t_multisettings in npdb
        public const uint XONLINE_E_CATALOGWATCHER_PRODUCER_NO_RATEABLE_CONFIG = 0x80175019; // ratings_mediatypes setting is absent in t_multisettings in npdb
        public const uint XONLINE_E_CATALOGWATCHER_PRODUCER_NOT_AN_INTEGER_SETTING = 0x8017501A; // The setting is not an integer
        public const uint XONLINE_E_CATALOGWATCHER_PRODUCER_NO_EXEMPTGCFORTITLES = 0x8017501B; // Missing exempt game content for titles multisetting
        public const uint XONLINE_E_CATALOGWATCHER_PRODUCER_NO_EXEMPTMEDIATYPES = 0x8017501C; // Missing exempt media types multisetting
        public const uint XONLINE_E_CATALOGWATCHER_DOCUMENT_TOO_LARGE = 0x8017501D; // Document has been generated that is larger then FAST ESP can store

        ///<summary>
        ///Mix Common HResults                                                          = 0x80176xxx
        ///</summary>
        public const uint XONLINE_E_MIX_UNKNOWNERROR = 0x80176000; // Unknown Error
        public const uint XONLINE_E_MIX_ENTITYFRAMEWORK_CONNECTION_ERROR = 0x80176001; // SQL & Entity Framework Connection Error
        public const uint XONLINE_E_MIX_CONFIGUREPRODUCT = 0x80176002; // Configure Product Error
        public const uint XONLINE_E_MIX_GETPRODUCT = 0x80176003; // Get Product Error
        public const uint XONLINE_E_MIX_CONFIGUREOFFER = 0x80176004; // Configure Offer Error
        public const uint XONLINE_E_MIX_GETOFFER = 0x80176005; // Get Offer Error
        public const uint XONLINE_E_MIX_WEBSGVALIDATIONERROR = 0x80176006; // WebSG Validation Error
        public const uint XONLINE_E_MIX_ARGUMENT_NULL = 0x80176007; // Null input to mix
        public const uint XONLINE_E_MIX_ARGUMENT_NULL_INTERNAL = 0x80176008; // Null input within mix
        public const uint XONLINE_E_MIX_NOT_FOUND_IN_CATALOG = 0x80176009; // Item not found in catalog
        public const uint XONLINE_E_MIX_INVALID_MEDIA_RELATIONSHIP_TYPE = 0x8017600A; // MediaRelationShipType is invalid
        public const uint XONLINE_E_MIX_INVALID_OFFER_RELATIONSHIP_TYPE = 0x8017600B; // Offer relationship type is invalid
        public const uint XONLINE_E_MIX_NEW_MEDIA_FOR_EXISTING_OFFER = 0x8017600C; // New media id given for existing offer
        public const uint XONLINE_E_MIX_NEW_OFFER_FOR_EXISTING_OFFERINSTANCE = 0x8017600D; // New offer id given for existing offer instance
        public const uint XONLINE_E_MIX_INVALID_DURATION_TYPE = 0x8017600E; // DurationType is Invalid
        public const uint XONLINE_E_MIX_INVALID_OFFER_RELATIONSHIP_MEDIA = 0x8017600F; // related Medias are Invalid
        public const uint XONLINE_E_MIX_INVALID_OFFERTYPE_MEDIA = 0x80176010; // Offertype and MediaIds mismatch
        public const uint XONLINE_E_MIX_INVALID_TITLE_ID = 0x80176011; // Invalid Title ID Used
        public const uint XONLINE_E_MIX_INVALID_LEADERBOARD_ID = 0x80176012; // Invalid Leaderboard ID Used
        public const uint XONLINE_E_MIX_INVALID_XLAST = 0x80176013; // Invalid Xlast Used
        public const uint XONLINE_E_MIX_DECOMPRESSION_ERROR = 0x80176014; // Decompression error when decompressing xlast
        public const uint XONLINE_E_MIX_INVALID_VERSION = 0x80176015; // Invalid Version Used
        public const uint XONLINE_E_MIX_INVALID_PLATFORM = 0x80176016; // Invalid Platform Used
        public const uint XONLINE_E_MIX_INVALID_FILE_TYPE = 0x80176017; // Invalid File Type Used
        public const uint XONLINE_E_MIX_INVALID_GUID = 0x80176018; // Empty GUID Used
        public const uint XONLINE_E_MIX_GAMEATTRIBUTE_INVALID_PROPERTY = 0x80176019; // Unknown game attribute property encountered
        public const uint XONLINE_E_MIX_GAMEATTRIBUTE_INVALID_PROPERTY_TYPE = 0x8017601A; // Unknown game attribute property type encountered
        public const uint XONLINE_E_MIX_GAMEATTRIBUTE_INVALID_PROPERTY_VALUE = 0x8017601B; // Unknown game attribute property value encountered
        public const uint XONLINE_E_MIX_MEDIALOCALEMAPS_INVALID_MAPPING = 0x8017601C; // Invalid mapping encountered processing MediaLocaleMaps
        public const uint XONLINE_E_MIX_INVALID_CONSUMABLE_QUANTITY = 0x8017601D; // Invalid quantity for game consumable offer
        public const uint XONLINE_E_MIX_FORBIDDEN_ENVIRONMENT = 0x8017601E; // Environment not allowed
        public const uint XONLINE_E_MIX_INVALID_MEDIATYPE = 0x8017601F; // Invalid MediaType used for a Product
        public const uint XONLINE_E_MIX_NEW_LIVEOFFERID_FOR_EXISTING_OFFER = 0x80176020; // Attempt to change a live offer id mapping
        public const uint XONLINE_E_MIX_UNIQUE_RATINGSYSTEMS_ERROR = 0x80176021; // The rating list contains at least more than one instance from the same rating system
        public const uint XONLINE_E_MIX_PRODUCT_LOCALIZATION_NOT_FOUND = 0x80176022; // No localization text for this product is found the particular country for the offer instance
        public const uint XONLINE_E_MIX_CONCURRENCY_ERROR = 0x80176023; // Concurrency issue occured in Entity Framework
        public const uint XONLINE_E_MIX_INVALID_SERVICE_TYPE = 0x80176024; // invalid service type - xbox or zune
        public const uint XONLINE_E_MIX_INVALID_SUBSCRIPTION_TYPE = 0x80176025; // invalid subscription type - base, game, content
        public const uint XONLINE_E_MIX_INVALID_TIER = 0x80176026; // invalid tier (0, 3, 6 ...)
        public const uint XONLINE_E_MIX_INVALID_SERVICE_PRIVILEGE_SET = 0x80176027; // invalid service privilege set (e.g. gold, silver, family, zune pass, phantasy star ...)
        public const uint XONLINE_E_MIX_CATALOG_CONSTRAINT_ERROR = 0x80176028; // Catalog SQL Constraint error occured
        public const uint XONLINE_E_MIX_ZERO_GUID_NOT_ALLOWED = 0x80176029; // The API does not support empty guids.
        public const uint XONLINE_E_MIX_GROUP_DOES_NOT_EXIST = 0x8017602A; // The group requested does not exist.
        public const uint XONLINE_E_MIX_INVALID_PRODUCTFAMILY = 0x8017602B; //product ->offerInstance mapping is happening even before service sets are defined
        public const uint XONLINE_E_MIX_INVALID_SKU_DELETE = 0x8017602C; // Invalid sku delete operation
        public const uint XONLINE_E_MIX_DUPLICATE_GROUP_NAME_NOT_ALLOWED = 0x8017602D; // Group names must be unique
        public const uint XONLINE_E_MIX_INVALID_GROUP_NAME = 0x8017602E; // The group name is invalid.
        public const uint XONLINE_E_MIX_INVALID_GROUP_CREATOR = 0x8017602F; // The group creator is invalid.
        public const uint XONLINE_E_MIX_ARGUMENT_EMPTY = 0x80176030; // Empty string passed into mix that needs to be filled in
        public const uint XONLINE_E_MIX_INVALID_CONFIG = 0x80176031; // Invalid combination of configuration parameters.
        public const uint XONLINE_E_MIX_STATS_FORCE_REQUIRED = 0x80176032; // Leaderboard update needs force parameter to be successful
        public const uint XONLINE_E_MIX_MATCH_MISSING_REMOVE_MODE = 0x80176033; // MixMatch attemped to remove a mode with removeMode set to false
        public const uint XONLINE_E_MIX_MATCH_NEW_MODE_FOUND = 0x80176034; // MixMatch found a new mode added to the XLAST. This must be configured manually.
        public const uint XONLINE_E_MIX_MATCH_SQL_EXCEPTION = 0x80176035; // MixMatch encountered a SQL exception. This may be due to dropTable being set to false.
        public const uint XONLINE_E_MIX_GROUP_MUST_BE_EMPTY = 0x80176036; // The operation is not valid unless the group is empty.
        public const uint XONLINE_E_MIX_STRING_TOO_LONG = 0x80176037; // A string parameter is too long
        public const uint XONLINE_E_MIX_MACHINE_NOT_IN_GROUP = 0x80176038; // The machine was not in the given group.
        public const uint XONLINE_E_MIX_CANNOT_MIGRATE_TO_SELF = 0x80176039; // Cannot migrate a group to itself.
        public const uint XONLINE_E_MIX_DUPLICATE_XRL_NOT_ALLOWED = 0x8017603A; // Duplicate title update location XRLs aren't allowed.
        public const uint XONLINE_E_MIX_FRONT_DOOR_RESET_ERROR = 0x8017603B; // Front Door Reset Error
        public const uint XONLINE_E_MIX_DUPLICATE_APP_NOT_ALLOWED = 0x8017603C; // Duplicate App Not Allowed
        public const uint XONLINE_E_MIX_ARRAY_TOO_LONG = 0x80176040; // An array parameter is too long
        public const uint XONLINE_E_MIX_DUPLICATE_RANK_NOT_ALLOWED = 0x80176041; // Duplicate title update location ranks aren't allowed.
        public const uint XONLINE_E_MIX_OFFER_INVALID_SUBSCRIPTIONFAMILY_CONFIG = 0x80176042; // Wrong LiveSubscriptionFamily Configuration
        public const uint XONLINE_E_MIX_OFFER_INVALID_SUBSCRIPTION_CONFIG = 0x80176043; // Wrong LiveSubscription Configuration
        public const uint XONLINE_E_MIX_OFFER_NO_TIER_FOUND = 0x80176044; // No tier found
        public const uint XONLINE_E_MIX_OFFER_NO_FREQUENCY_FOUND = 0x80176045; // No Offer frequency found
        public const uint XONLINE_E_MIX_OFFER_ERROR_FAMILY_INGESTION = 0x80176046; //No family content ingestion supported
        public const uint XONLINE_E_MIX_OFFER_ERROR_LEGACY_OFFER = 0x80176047; //No Legacy offer mapping
        public const uint XONLINE_E_MIX_DUPLICATE_CONTENTID = 0x80176048; // A ContentId can only be associated with one MediaInstance/ProductPackage
        public const uint XONLINE_E_MIX_ERROR_INGESTING_MANIFEST = 0x80176049; // There was an error ingesting a new Etx manifest
        public const uint XONLINE_E_MIX_INVALID_VISIBILITY_STATUS = 0x80176050; // Invalid visibilitystatus (only allows 3,5 through mix)
        public const uint XONLINE_E_MIX_PRODUCT_DUPLICATE_IMAGE_INSTANCE_ID = 0x80176051; // Duplicate Image Instance Id (ImageId, Lcid, SizeId, FormatId) not allowed through MIX
        public const uint XONLINE_E_MIX_OPERATION_NOT_SUPPORTED = 0x80176052; // Operation not supported or not yet implemented.

        ///<summary>
        ///FML Common HResults                                                          = 0x80177xxx
        ///<summary>
        public const uint XONLINE_E_FML_UNKNOWN_ERROR = 0x80177000; // Unknown Error
        public const uint XONLINE_E_FML_ALREADY_EXECUTING = 0x80177001; // Trying to start a new job while a job is currently executing.
        public const uint XONLINE_E_FML_ARGUMENT_NOT_FOUND = 0x80177002; // An argument was not found during the running of a job.
        public const uint XONLINE_E_FML_JOB_FAILED = 0x80177003; // A job encountered an exception and was stopped.
        public const uint XONLINE_E_FML_OPERATION_FAILED = 0x80177004; // A job encountered an exception and was stopped.

        /// <summary>
        /// FAST ESP Engine Events                                                      = 0x80178xxx
        /// </summary>
        public const uint XONLINE_E_ESP_ENGINE_UNKNOWN_ERROR = 0x80178000; // Unknown error
        public const uint XONLINE_E_ESP_ENGINE_INVALID_PARAMETER = 0x80178001; // An invalid datatype was used
        public const uint XONLINE_E_ESP_ENGINE_INVALID_SYNTAX = 0x80178002; // Invalid syntax used for value type
        public const uint XONLINE_E_ESP_ENGINE_INVALID_DATA_TYPE = 0x80178003; // Invalid data type was used
        public const uint XONLINE_E_ESP_ENGINE_PARAMETER_NOT_FOUND = 0x80178004; // Could not find the parameter in the filter criteria
        public const uint XONLINE_E_ESP_ENGINE_INVALID_RULE = 0x80178005; // Rule could not be processed and had invalid data
        public const uint XONLINE_E_ESP_ENGINE_SEARCH_TERM_TO_LONG = 0x80178006; // Search term used is beyond the proper length allowed
        public const uint XONLINE_E_ESP_ENGINE_INVALID_PARAMETER_GROUPING = 0x80178007; // An invalid grouping of parameters was used

        /// <summary>
        /// Marketplace Catalog Events                                                  = 0x80179xxx
        /// </summary>
        public const uint XONLINE_E_MARKETPLACECATALOG_UNKNOWN_ERROR = 0x80179000; // Unknown error
        public const uint XONLINE_E_MARKETPLACECATALOG_PARAMETER_MISSING = 0x80179001; // A parameter is missing
        public const uint XONLINE_E_MARKETPLACECATALOG_BAD_FORMAT = 0x80179002; // A parameter is not formatted properly
        public const uint XONLINE_E_MARKETPLACECATALOG_DETAIL_LEVEL_MISSING = 0x80179003; // A detail level is missing for a search hit

        //
        // XboxLive Token HRESULTS
        //
        public const uint XONLINE_E_XBOXLIVETOKEN_INVALID_VERSION = 0x80180000; // Token Major or Minor version number invalid
        public const uint XONLINE_E_XBOXLIVETOKEN_INVALID_ISSUER = 0x80180001; // Token Issuer invalid
        public const uint XONLINE_E_XBOXLIVETOKEN_INVALID_STATEMENT_COUNT = 0x80180002; // Token contains an unexpected number of statements
        public const uint XONLINE_E_XBOXLIVETOKEN_INVALID_STATEMENT_TYPE = 0x80180003; // Token statement is not of the expected type
        public const uint XONLINE_E_XBOXLIVETOKEN_INVALID_THUMBPRINT = 0x80180004; // Token not signed by expected certificate
        public const uint XONLINE_E_XBOXLIVETOKEN_INVALID_CLIENTTHUMBPRINT = 0x80180005; // Token not being used with the certificate for which it was issued
        public const uint XONLINE_E_XBOXLIVETOKEN_INVALID_PLATFORMTYPE = 0x80180006; // Platform type not valid or inconsistent with token claims

        public const uint XONLINE_E_XBOXLIVETOKEN_CERT_CONFIG = 0x80180020; // Configuration problem caused GetCertificate failure

        //
        // Active Auth HRESULTS
        //
        public const uint XONLINE_E_AAINFO_TOKEN_DATA_NOTFOUND = 0x80180101; // AA Token Data not found
        public const uint XONLINE_E_AAINFO_TOKEN_FIELD_NOTVALID = 0x80180102; // AA Token field not valid with Token


        //DO NOT ADD EVENTS IN 0x80190000 to 0x8019FFFF.These are new ctp error codes
        // This event is a CTP event that used in test code
        public const uint XONLINE_E_CTP_BDK_E_EXCEEDS_MAXIMUM_DURATION = 0x80190218;  // "Error subscription duration exceeds max duration." 



        // implementation to make this behave like a value type

        private uint _value;


        private HResult(uint value)
        {
            _value = value;
        }


        public override int GetHashCode()
        {
            return _value.GetHashCode();
        }


        public override string ToString()
        {
            // the one way to display an HResult
            return "0x" + _value.ToString("X08");
        }


        public bool HasName
        {
            get { return _nameMap.ContainsKey(_value); }
        }

        public string Name
        {
            get
            {
                string s = null;
                if (!_nameMap.TryGetValue(_value, out s))
                {
                    s = ToString();
                }
                return s;
            }
        }

        public static implicit operator HResult(uint value)
        {
            return new HResult(value);
        }

        public static implicit operator uint(HResult hResult)
        {
            // convert a HResult to uint
            return hResult._value;
        }

        #region IEquatable<HResult> Members


        public bool Equals(HResult other)
        {
            return _value == other._value;
        }

        #endregion

        public static HResult Parse(string s)
        {
            if (s.StartsWith("0x", true, CultureInfo.CurrentCulture)) s = s.Substring(2);
            return new HResult(Convert.ToUInt32(s, 16));
        }


        public static bool TryParse(string s, out HResult hr)
        {
            try
            {
                hr = HResult.Parse(s);
                return true;
            }
            catch
            {
                hr = new HResult(0);
                return false;
            }
        }

        #region IXmlSerializable Members

        public void ReadXml(XmlReader reader)
        {
            _value = (uint)XmlConvert.ToUInt32(reader.ReadElementContentAsString());
        }

        public void WriteXml(XmlWriter writer)
        {
            writer.WriteValue(_value.ToString());
        }

        public XmlSchema GetSchema()
        {
            return (null);
        }

        #endregion

        public static XmlQualifiedName HResultSchema(XmlSchemaSet xs)
        {
            return new XmlQualifiedName("unsignedInt", XmlSchema.Namespace);
        }

        public bool IsFailure()
        {
            return (_value >> 31 == 1);
        }

        public bool IsSuccess()
        {
            return (_value >> 31 == 0);
        }

        public bool IsOk()
        {
            return (_value == HResult.S_OK);
        }

        public static bool Failed(HResult hr)
        {
            return hr.IsFailure();
        }

        public static bool Succeeded(HResult hr)
        {
            return hr.IsSuccess();
        }

        static Dictionary<uint, string> _nameMap;
        static HResult()
        {
            _nameMap = new Dictionary<uint, string>();

            try
            {
                foreach (FieldInfo f in typeof(HResult).GetFields(BindingFlags.Static | BindingFlags.DeclaredOnly | BindingFlags.Public))
                {
                    if (f.IsLiteral)
                    {
                        uint hr = (uint)f.GetValue(null);
                        _nameMap[hr] = f.Name;
                    }
                }
            }
            catch (Exception)
            {
                // Nothing really to do, dictionary will just be empty
            }
        }
    }

    /// <summary>
    /// This XOn derived class is provided here exclusively so that
    /// anyone that imports ServerTestFramework.LiveService is able
    /// to access the XOn class without having to add an additional
    /// using statement.  This should eventually be removed.
    /// </summary>
    public class XOn : xonline.common.service.XOn { }

    /// <summary>
    /// Provides methods to query and update the userflags array in
    /// a user object.
    /// </summary>
    /// <remarks>
    /// The user flags are layed out as follows
    ///   BitArray: XXLLLLLP TTTTSNBV CCCCCCCC DDDOOOGG 
    ///     L - User Language
    ///     P - Parentally Controlled
    ///     T - TierId
    ///     S - Shared Content
    ///     N - Nickname
    ///     B - Purchase
    ///     V - User Voice
    ///     C - CountryId
    ///     D - Disconnect Rating
    ///     O - nO show rating
    ///     G - Guest Number
    ///     X - Unused (should be zero)
    /// </remarks>
    public class UserFlagsUtil
    {
        /// <summary>
        /// The mask for the user flag which indicates if the user is a guest
        /// </summary>
        public const uint XONLINE_USER_GUEST_MASK = 0x00000003;

        /// <summary>
        /// The mask for the user flag which indicates the UserNoShowRating
        /// </summary>
        public const uint XONLINE_USER_NOSHOW_RATING_MASK = 0x0000001C;

        /// <summary>
        /// The mask for the user flag which indicates the UserDisconnectRating
        /// </summary>
        public const uint XONLINE_USER_DISCONNECT_RATING_MASK = 0x000000E0;

        /// <summary>
        /// The mask for the user country id in the user flags
        /// </summary>
        public const uint XONLINE_USER_COUNTRY_MASK = 0x0000ff00;

        /// <summary>
        /// The mask for the user flag which indicates if user voice is disabled
        /// </summary>
        public const uint XONLINE_USER_VOICE_MASK = 0x00010000;
        
        /// <summary>
        /// The mask for the user flag which indicates if user purchase is disabled
        /// </summary>
        public const uint XONLINE_USER_PURCHASE_MASK = 0x00020000;
        
        /// <summary>
        /// The mask for the user flag which indicates if user nickname is disabled
        /// </summary>
        public const uint XONLINE_USER_NICKNAME_MASK = 0x00040000;
        
        /// <summary>
        /// The mask for the user flag which indicates if shared content is disabled
        /// </summary>
        public const uint XONLINE_USER_SHARED_CONTENT_MASK = 0x00080000;

        /// <summary>
        /// The mask for the user TierId in the user flags
        /// </summary>
        public const uint XONLINE_USER_TIERID_MASK = 0x00F00000;
        
        /// <summary>
        /// The mask for the user flag which indicates if the account is parentally controlled
        /// </summary>
        public const uint XONLINE_USER_PARENTAL_CONTROLLED = 0x01000000;

        /// <summary>
        /// The mask for the user langage in the user flags
        /// </summary>
        public const uint XONLINE_USER_LANGUAGE_MASK = 0x3E000000;

        // These values represent the shift counts for various data fields in the user flags
        public const int XONLINE_USER_GUEST_SHIFT = 0;
        public const int XONLINE_USER_NOSHOW_RATING_SHIFT = 2;
        public const int XONLINE_USER_DISCONNECT_RATING_SHIFT = 5;
        public const int XONLINE_USER_COUNTRY_SHIFT = 8;
        public const int XONLINE_USER_TIERID_SHIFT = 20;
        public const int XONLINE_USER_LANGUAGE_SHIFT = 25;

        public static uint UserGuestNumber(uint dwUserFlags)
        {
            return (((dwUserFlags) & XONLINE_USER_GUEST_MASK) >> XONLINE_USER_GUEST_SHIFT);
        }
        public static uint UserNoShowRating(uint dwUserFlags)
        {
            return (((dwUserFlags) & XONLINE_USER_NOSHOW_RATING_MASK) >> XONLINE_USER_NOSHOW_RATING_SHIFT);
        }
        public static uint UserDisconnectRating(uint dwUserFlags)
        {
            return (((dwUserFlags) & XONLINE_USER_DISCONNECT_RATING_MASK) >> XONLINE_USER_DISCONNECT_RATING_SHIFT);
        }
        public static uint UserCountryId(uint dwUserFlags)
        {
            return (((dwUserFlags) & XONLINE_USER_COUNTRY_MASK) >> XONLINE_USER_COUNTRY_SHIFT);
        }
        public static uint UserTierId(uint dwUserFlags)
        {
            return (((dwUserFlags) & XONLINE_USER_TIERID_MASK) >> XONLINE_USER_TIERID_SHIFT);
        }
        public static uint UserLanguageId(uint dwUserFlags)
        {
            return (((dwUserFlags) & XONLINE_USER_LANGUAGE_MASK) >> XONLINE_USER_LANGUAGE_SHIFT);
        }
        public static bool IsUserVoiceAllowed(uint dwUserFlags)
        {
            return (((dwUserFlags) & XONLINE_USER_VOICE_MASK) == 0);
        }
        public static bool IsUserPurchaseAllowed(uint dwUserFlags)
        {
            return (((dwUserFlags) & XONLINE_USER_PURCHASE_MASK) == 0);
        }
        public static bool IsUserNicknameAllowed(uint dwUserFlags)
        {
            return (((dwUserFlags) & XONLINE_USER_NICKNAME_MASK) == 0);
        }
        public static bool IsUserSharedContentAllowed(uint dwUserFlags)
        {
            return (((dwUserFlags) & XONLINE_USER_SHARED_CONTENT_MASK) == 0);
        }
        public static bool IsUserParentalControlled(uint dwUserFlags)
        {
            return (((dwUserFlags) & XONLINE_USER_PARENTAL_CONTROLLED) != 0);
        }
        public static bool IsUserGuest(uint dwUserFlags)
        {
            return (((dwUserFlags) & XONLINE_USER_GUEST_MASK) != 0);
        }

        public static uint SetUserGuestNumber(uint dwUserFlags, uint guestNumber)
        {
            dwUserFlags &= ~XONLINE_USER_GUEST_MASK;
            dwUserFlags |= ((guestNumber << XONLINE_USER_GUEST_SHIFT) & XONLINE_USER_GUEST_MASK);
            return dwUserFlags;
        }
        public static uint SetUserNoShowRating(uint dwUserFlags, uint noShowRating)
        {
            dwUserFlags &= ~XONLINE_USER_NOSHOW_RATING_MASK;
            dwUserFlags |= ((noShowRating << XONLINE_USER_NOSHOW_RATING_SHIFT) & XONLINE_USER_NOSHOW_RATING_MASK);
            return dwUserFlags;
        }
        public static uint SetUserDisconnectRating(uint dwUserFlags, uint disconnectRating)
        {
            dwUserFlags &= ~XONLINE_USER_DISCONNECT_RATING_MASK;
            dwUserFlags |= ((disconnectRating << XONLINE_USER_DISCONNECT_RATING_SHIFT) & XONLINE_USER_DISCONNECT_RATING_MASK);
            return dwUserFlags;
        }
        public static uint SetUserCountryId(uint dwUserFlags, uint countryId)
        {
            dwUserFlags &= ~XONLINE_USER_COUNTRY_MASK;
            dwUserFlags |= ((countryId << XONLINE_USER_COUNTRY_SHIFT) & XONLINE_USER_COUNTRY_MASK);
            return dwUserFlags;
        }
        public static uint SetUserTierId(uint dwUserFlags, uint tierId)
        {
            dwUserFlags &= ~XONLINE_USER_TIERID_MASK;
            dwUserFlags |= ((tierId << XONLINE_USER_TIERID_SHIFT) & XONLINE_USER_TIERID_MASK);
            return dwUserFlags;
        }
        public static uint SetUserLanguageId(uint dwUserFlags, uint languageId)
        {
            dwUserFlags &= ~XONLINE_USER_LANGUAGE_MASK;
            dwUserFlags |= ((languageId << XONLINE_USER_LANGUAGE_SHIFT) & XONLINE_USER_LANGUAGE_MASK);
            return dwUserFlags;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup\XLASTFactory\GamerPictures.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework.STFTools.ConfigFiles;

namespace ServerTestFramework.STFTools
{
    public partial class XLASTFactory
    {
        private const uint GAMERPIC_SMALL = 0x00010000;
        private const uint GAMERPIC_LARGE = 0x00020000;

        public void AddGamerPicture(XboxLiveSubmissionProject xlast, string smallImage, string largeImage)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            // Make sure the CLSID is set
            if (null == xlast.GameConfigProject.GamerPictures.clsid)
            {
                CreateGamerPictures(xlast);
            }

            Picture gamerPic = new Picture();
            Picture largePic = new Picture();
            uint imageId;

            // Gamer pictures start at ID 2 (for some reason)
            gamerPic.id = (uint)xlast.GameConfigProject.GamerPictures.Count + 2;
            gamerPic.friendlyName = "GamerPic" + (xlast.GameConfigProject.GamerPictures.Count + 2).ToString("d3");

            // Each Gamer Picture consists of two images - small and large
            imageId = GAMERPIC_SMALL | gamerPic.id;
            AddImage(xlast, smallImage, imageId, gamerPic.friendlyName + "_SMALL");

            imageId = GAMERPIC_LARGE | gamerPic.id;
            AddImage(xlast, largeImage, imageId, gamerPic.friendlyName + "_LARGE");

            // Finally add the GamerPic element
            xlast.GameConfigProject.GamerPictures.Add(gamerPic);
        }

        private void CreateGamerPictures(XboxLiveSubmissionProject xlast)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            xlast.GameConfigProject.GamerPictures.clsid = GamerPicturesCLSID;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup\XLASTFactory\Presence.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework.STFTools.ConfigFiles;

namespace ServerTestFramework.STFTools
{
    public partial class XLASTFactory
    {
        public PresenceMode AddPresence(XboxLiveSubmissionProject xlast)
        {
            PresenceMode newMode = new PresenceMode();

            newMode.clsid = PresenceModeCLSID;
            newMode.contextValue = xlast.GameConfigProject.Presence.nextContextValue;
            newMode.friendlyName = "RichPresenceString" + newMode.contextValue.ToString("d3");
            newMode.stringId = AddString(xlast, newMode.friendlyName + " String.");
            xlast.GameConfigProject.Presence.Add(newMode);
            xlast.GameConfigProject.Presence.nextContextValue++;
            return newMode;
        }

        private void CreatePresence(XboxLiveSubmissionProject xlast)
        {
            xlast.GameConfigProject.Presence.clsid = PresenceCLSID;
            xlast.GameConfigProject.Presence.nextContextValue = 0;

            // XLAST files without at least one Presence mode are invalid, so add one.
            AddPresence(xlast);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup1\XLASTUtility.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using ServerTestFramework.STFTools.ConfigFiles;

namespace ServerTestFramework.STFTools
{
    public static class XLASTUtility
    {
        public static LocalizedString GetString(XboxLiveSubmissionProject xlast, ushort stringId)
        {
            if (null == xlast)
                throw new ArgumentNullException("xlast");

            foreach (LocalizedString str in xlast.GameConfigProject.LocalizedStrings.LocalizedStringCollection)
            {
                if (str.id == stringId)
                    return str;
            }
            return null;
        }

        public static string GetDefaultStringTranslation(XboxLiveSubmissionProject xlast, ushort stringId)
        {
            if (null == xlast)
                throw new ArgumentNullException("xlast");

            return GetStringTranslation(xlast, stringId, xlast.GameConfigProject.LocalizedStrings.defaultLocale);
        }

        public static string GetDefaultStringTranslation(XboxLiveSubmissionProject xlast, string friendlyName)
        {
            if (null == xlast)
                throw new ArgumentNullException("xlast");

            return GetStringTranslation(xlast, friendlyName, xlast.GameConfigProject.LocalizedStrings.defaultLocale);
        }

        public static string GetStringTranslation(XboxLiveSubmissionProject xlast, ushort stringId, string locale)
        {
            if (null == xlast)
                throw new ArgumentNullException("xlast");

            foreach (LocalizedString str in xlast.GameConfigProject.LocalizedStrings.LocalizedStringCollection)
            {
                if (str.id == stringId)
                {
                    foreach (Translation trans in str.TranslationCollection)
                    {
                        if (String.Compare(trans.locale, locale, true) == 0)
                            return trans.Value;
                    }
                }
            }

            return null;
        }

        public static string GetStringTranslation(XboxLiveSubmissionProject xlast, string friendlyName, string locale)
        {
            if (null == xlast)
                throw new ArgumentNullException("xlast");

            foreach (LocalizedString str in xlast.GameConfigProject.LocalizedStrings.LocalizedStringCollection)
            {
                if (String.Compare(str.friendlyName, friendlyName, true) == 0)
                {
                    foreach (Translation trans in str.TranslationCollection)
                    {
                        if (String.Compare(trans.locale, locale, true) == 0)
                            return trans.Value;
                    }
                }
            }

            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup\XLASTFactory\Matchmaking.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework.STFTools.ConfigFiles;

namespace ServerTestFramework.STFTools
{
    public partial class XLASTFactory
    {
        public void AddMatchAttribute(XboxLiveSubmissionProject xlast, uint attributeId)
        {
            AddMatchAttribute(xlast, "0x" + attributeId.ToString("X8"));
        }

        public void AddMatchAttribute(XboxLiveSubmissionProject xlast, string attributeId)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            if (null == xlast.GameConfigProject.Matchmaking.clsid)
            {
                CreateMatchmaking(xlast);
            }

            ServerTestFramework.STFTools.ConfigFiles.Attribute newAttrib = new ServerTestFramework.STFTools.ConfigFiles.Attribute();
            newAttrib.id = attributeId;
            xlast.GameConfigProject.Matchmaking.Schema.Add(newAttrib);
        }

        public void AddMatchConstant(XboxLiveSubmissionProject xlast, int value)
        {
            AddMatchConstant(xlast, XLASTPropertyType.Integer, value.ToString());
        }

        public void AddMatchConstant(XboxLiveSubmissionProject xlast, long value)
        {
            AddMatchConstant(xlast, XLASTPropertyType.LongInteger, value.ToString());
        }

        public void AddMatchConstant(XboxLiveSubmissionProject xlast, float value)
        {
            AddMatchConstant(xlast, XLASTPropertyType.Float, value.ToString("f6"));
        }

        public void AddMatchConstant(XboxLiveSubmissionProject xlast, double value)
        {
            AddMatchConstant(xlast, XLASTPropertyType.LongFloat, value.ToString("f6"));
        }

        public void AddMatchConstant(XboxLiveSubmissionProject xlast, DateTime value)
        {
            AddMatchConstant(xlast, XLASTPropertyType.DateTime, value.ToShortDateString());
        }

        private void AddMatchConstant(XboxLiveSubmissionProject xlast, XLASTPropertyType type, string value)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            if (null == xlast.GameConfigProject.Matchmaking.clsid)
            {
                CreateMatchmaking(xlast);
            }

            Constant newConst = new Constant();
            newConst.id = String.Format("0x{0}500{1}", (uint)type, xlast.GameConfigProject.Matchmaking.Constants.nextId.ToString("d04"));
            newConst.value = value;
            newConst.name = String.Format("MatchConstant{0:d03}", xlast.GameConfigProject.Matchmaking.Constants.nextId + 1);
            xlast.GameConfigProject.Matchmaking.Constants.Add(newConst);
            xlast.GameConfigProject.Matchmaking.Constants.nextId++;
        }

        public uint AddMatchQuery(XboxLiveSubmissionProject xlast, ushort maxResults, type2 queryType, bool qosProbe)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            if (null == xlast.GameConfigProject.Matchmaking.clsid)
            {
                CreateMatchmaking(xlast);
            }

            Query newQuery = new Query();
            newQuery.clsid = QueryCLSID;
            // The Query element is weird: the nextId attribute actually bahaves more like a maxId value.
            // Because of this, we need to use the collection count as the id.
            newQuery.id = (uint)xlast.GameConfigProject.Matchmaking.Queries.QueryCollection.Count;
            newQuery.groupBy = "0xFFFFFFFF";
            newQuery.friendlyName = String.Format("MatchQuery{0:d03}", newQuery.id + 1);
            newQuery.maxResults = maxResults;
            newQuery.type = queryType;
            newQuery.qosProbe = qosProbe;

            xlast.GameConfigProject.Matchmaking.Queries.QueryCollection.Add(newQuery);
            xlast.GameConfigProject.Matchmaking.Queries.nextId = newQuery.id;
            
            // Every query requires Game Type and Game Mode return values
            AddMatchQueryReturnValue(xlast, newQuery.id, GAME_TYPE_CONTEXT_ID, type234.Normal);
            AddMatchQueryReturnValue(xlast, newQuery.id, GAME_MODE_ID, type234.Normal);

            return newQuery.id;
        }

        public void AddMatchQueryReturnValue(XboxLiveSubmissionProject xlast, uint queryId, string id, type234 returnType)
        {
            Query query = FindQuery(xlast, queryId);
            if (query == null)
            {
                throw new StfException("Query id {0} doesn't exist in the XLAST file.", queryId);
            }

            Return newReturn = new Return();
            newReturn.id = id;
            newReturn.type = returnType;
            newReturn.ordinal = (ushort)query.Returns.Count;
            query.Returns.Add(newReturn);
        }

        public void AddMatchQueryParameter(XboxLiveSubmissionProject xlast, uint queryId, string id)
        {
        }

        private void CreateMatchmaking(XboxLiveSubmissionProject xlast)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            xlast.GameConfigProject.Matchmaking.clsid = MatchmakingCLSID;
            xlast.GameConfigProject.Matchmaking.Constants.clsid = ConstantsCLSID;
            xlast.GameConfigProject.Matchmaking.Constants.nextId = 0;
            xlast.GameConfigProject.Matchmaking.Schema.clsid = SchemaCLSID;
            AddMatchAttribute(xlast, GAME_TYPE_CONTEXT_ID);
            AddMatchAttribute(xlast, GAME_MODE_ID);
            AddMatchAttribute(xlast, GAMER_ZONE_PROPERTY_ID);
            AddMatchAttribute(xlast, GAMER_COUNTRY_PROPERTY_ID);
            AddMatchAttribute(xlast, LANGUAGE_PROPERTY_ID);
            AddMatchAttribute(xlast, GAMER_RATING_PROPERTY_ID);
            AddMatchAttribute(xlast, GAMER_MU_PROPERTY_ID);
            AddMatchAttribute(xlast, GAMER_SIGMA_PROPERTY_ID);
            AddMatchAttribute(xlast, GAMER_PUID_PROPERTY_ID);
            AddMatchAttribute(xlast, AFFILIATE_VALUE_PROPERTY_ID);
            AddMatchAttribute(xlast, GAMER_HOSTNAME_PROPERTY_ID);
            AddMatchAttribute(xlast, PLATFORM_TYPE_PROPERTY_ID);
            AddMatchAttribute(xlast, PLATFORM_LOCK_PROPERTY_ID);
            xlast.GameConfigProject.Matchmaking.Queries.clsid = QueriesCLSID;
            xlast.GameConfigProject.Matchmaking.Queries.nextId = 0;
        }

        private Query FindQuery(XboxLiveSubmissionProject xlast, uint queryId)
        {
            foreach (Query query in xlast.GameConfigProject.Matchmaking.Queries.QueryCollection)
            {
                if (query.id == queryId)
                    return query;
            }

            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup\XLASTFactory\LocalizedStrings.cs ===
u s i n g   S y s t e m ; 
 
 u s i n g   S y s t e m . C o l l e c t i o n s . G e n e r i c ; 
 
 u s i n g   S y s t e m . I O ; 
 
 u s i n g   S y s t e m . X m l ; 
 
 u s i n g   S y s t e m . X m l . S e r i a l i z a t i o n ; 
 
 u s i n g   S y s t e m . T e x t ; 
 
 u s i n g   S e r v e r T e s t F r a m e w o r k . S T F T o o l s . C o n f i g F i l e s ; 
 
 
 
 n a m e s p a c e   S e r v e r T e s t F r a m e w o r k . S T F T o o l s 
 
 { 
 
         p u b l i c   e n u m   X L A S T D e f a u l t S t r i n g   :   u s h o r t 
 
         { 
 
                 X _ S T R I N G I D _ G A M E T Y P E   =   3 2 5 1 2 , 
 
                 X _ S T R I N G I D _ R A N K E D , 
 
                 X _ S T R I N G I D _ S T A N D A R D , 
 
                 X _ S T R I N G I D _ G A M E R N A M E , 
 
                 X _ S T R I N G I D _ R A N K C O L , 
 
                 X _ S T R I N G I D _ R A N K , 
 
                 X _ S T R I N G I D _ G A M E R N A M E C O L , 
 
                 X _ S T R I N G I D _ G A M E R _ Z O N E , 
 
                 X _ S T R I N G I D _ G A M E R _ C O U N T R Y , 
 
                 X _ S T R I N G I D _ L A N G U A G E , 
 
                 X _ S T R I N G I D _ G A M E R _ R A T I N G , 
 
                 X _ S T R I N G I D _ G A M E R _ M U , 
 
                 X _ S T R I N G I D _ G A M E R _ S I G M A , 
 
                 X _ S T R I N G I D _ G A M E R _ P U I D , 
 
                 X _ S T R I N G I D _ A F F I L I A T E _ V A L U E , 
 
                 X _ S T R I N G I D _ G A M E R _ H O S T N A M E , 
 
                 X _ S T R I N G I D _ P L A T F O R M _ T Y P E , 
 
                 X _ S T R I N G I D _ P L A T F O R M _ L O C K , 
 
                 X _ S T R I N G I D _ T I T L E N A M E   =   3 2 7 6 8 
 
         } 
 
 
 
         p u b l i c   p a r t i a l   c l a s s   X L A S T F a c t o r y 
 
         { 
 
                 p r i v a t e   D i c t i o n a r y < u s h o r t ,   L i s t < s t r i n g > >   _ d e f a u l t S t r i n g s ; 
 
                 p r i v a t e   X L A S T L a n g u a g e   _ d e f a u l t L a n g u a g e ; 
 
                 p r i v a t e   s t a t i c   s t r i n g [ ]   L o c a l e S t r i n g s   =   n e w   s t r i n g [ ] 
 
                         {   " e n - U S " ,   " f r - F R " ,   " d e - D E " ,   " i t - I T " ,   " j a - J P " ,   " k o - K R " ,   " p l - P L " ,   " p t - P T " ,   " r u - R U " ,   " e s - E S " ,   " z h - C H T "   } ; 
 
 
 
                 p r i v a t e   v o i d   I n i t L o c a l i z e d S t r i n g s ( ) 
 
                 { 
 
                         _ d e f a u l t S t r i n g s   =   n e w   D i c t i o n a r y < u s h o r t ,   L i s t < s t r i n g > > ( ) ; 
 
                         L i s t < s t r i n g >   t r a n s l a t i o n s ; 
 
 
 
                         / /   G a m e   T y p e 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " G a m e   T y p e " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " T y p e   d e   j e u " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " S p i e l t y p " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " T i p o   d i   g i o c o " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " 000n0.z^" ) ; 
 
                         t r a n s l a t i o n s . A d d ( "   X" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " T y p   g r y " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " T i p o   d e   J o g o " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " "8?  83@K" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " T i p o   d e   p a r t i d a " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " J2b^W" ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ G A M E T Y P E ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   R a n k e d 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " R a n k e d   M a t c h " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " P a r t i e   a v e c   C l a s s e m e n t " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " R a n g l i s t e n - S p i e l " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " P a r t i t a   C l a s s i f i c a t a " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " 000  000" ) ; 
 
                         t r a n s l a t i o n s . A d d ( "   X" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " P o j e d y n e k   r a n k i n g o w y " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " P a r t i d a   p o r   R a n k i n g " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " >41>@  ?>  C@>2=N" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " P a r t i d a   I g u a l a d a " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " I{}M
\" ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ R A N K E D ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   S t a n d a r d 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " P l a y e r   M a t c h " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " M i s e   e n   R e l a t i o n " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " M i t s p i e l e r - S u c h e " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " P a r t i t a   d e l   G i o c a t o r e " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " 00000  000" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " tÇ´  X" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " P o j e d y n e k   g r a c z y " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " P a r t i d a   p o r   J o g a d o r " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " >41>@  83@>:>2" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " P a r t i d a   d e   J u g a d o r " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " s[M
\" ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ S T A N D A R D ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   G a m e r   N a m e 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " G a m e r   N a m e " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " N o m   d u   j o u e u r " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " S p i e l e r n a m e " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " N o m e   g i o c a t o r e " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " 0000
T" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " t8  tÇ" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " N a z w a   g r a c z a " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " N o m e   d o   J o g a d o r " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " <O  83@>:0" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " N o m b r e   d e l   j u g a d o r " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " s[Y
T" ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ G A M E R N A M E ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   G a m e r   N a m e   C o l 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " G a m e r   N a m e " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " N o m   d u   j o u e u r " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " S p i e l e r n a m e " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " N o m e   g i o c a t o r e " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " 0000
T" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " t8  tÇ" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " N a z w a   g r a c z a " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " N o m e   d o   J o g a d o r " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " <O  83@>:0" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " N o m b r e   d e l   j u g a d o r " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " s[Y
T" ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ G A M E R N A M E C O L ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   R a n k 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " R a n k " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " R a n g " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " E i n s t u f u n g " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " C l a s s i f i c a " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " 000" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " R a n k i n g " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " C l a s s i f i c a   o " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " 5AB>" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " C l a s i f i c a r " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " I{}" ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ R A N K ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   R a n k   C o l 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " R a n k " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " R a n g " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " E i n s t u f u n g " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " C l a s s i f i c a " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " 000" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " R a n k i n g " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " C l a s s i f i c a   o " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " 5AB>" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " C l a s i f i c a r " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " I{}" ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ R A N K C O L ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   G a m e r   Z o n e 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " G a m e r   Z o n e " ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ G A M E R _ Z O N E ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   G a m e r   C o u n t r y 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " G a m e r   C o u n t r y " ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ G A M E R _ C O U N T R Y ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   L a n g u a g e 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " L a n g u a g e " ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ L A N G U A G E ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   G a m e r   R a t i n g 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " G a m e r   R a t i n g " ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ G A M E R _ R A T I N G ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   G a m e r   M u 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " G a m e r   M u " ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ G A M E R _ M U ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   G a m e r   S i g m a 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " G a m e r   S i g m a " ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ G A M E R _ S I G M A ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   G a m e r   P U I D 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " G a m e r   P U I D " ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ G A M E R _ P U I D ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   A f f i l i a t e   V a l u e 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " A f f i l i a t e   V a l u e " ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ A F F I L I A T E _ V A L U E ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   G a m e r   H o s t   N a m e 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " G a m e r   H o s t   N a m e " ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ G A M E R _ H O S T N A M E ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   P l a t f o r m   T y p e 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " P l a t f o r m   T y p e " ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ P L A T F O R M _ T Y P E ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   P l a t f o r m   L o c k 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " P l a t f o r m   L o c k " ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ P L A T F O R M _ L O C K ,   t r a n s l a t i o n s ) ; 
 
                 } 
 
 
 
                 p r i v a t e   v o i d   C r e a t e L o c a l i z e d S t r i n g s ( X b o x L i v e S u b m i s s i o n P r o j e c t   x l a s t ,   X L A S T L a n g u a g e   d e f a u l t L a n g u a g e ) 
 
                 { 
 
                         i f   ( x l a s t   ! =   n u l l ) 
 
                         { 
 
                                 _ d e f a u l t L a n g u a g e   =   d e f a u l t L a n g u a g e ; 
 
                                 x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s   =   n e w   L o c a l i z e d S t r i n g s ( ) ; 
 
                                 x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . c l s i d   =   L o c a l i z e d S t r i n g s C L S I D ; 
 
                                 x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . d e f a u l t L o c a l e   =   L o c a l e S t r i n g s [ ( i n t ) d e f a u l t L a n g u a g e ] ; 
 
                                 x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . S u p p o r t e d L o c a l e C o l l e c t i o n . A d d ( ) . l o c a l e   =   L o c a l e S t r i n g s [ ( i n t ) d e f a u l t L a n g u a g e ] ; 
 
                                 x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . n e x t I d   =   1 ; 
 
 
 
                                 u s h o r t [ ]   d e f I d s   =   ( u s h o r t [ ] ) E n u m . G e t V a l u e s ( t y p e o f ( X L A S T D e f a u l t S t r i n g ) ) ; 
 
                                 f o r e a c h   ( u s h o r t   i d   i n   d e f I d s ) 
 
                                 { 
 
                                         A d d D e f a u l t S t r i n g ( x l a s t ,   ( X L A S T D e f a u l t S t r i n g ) i d ,   d e f a u l t L a n g u a g e ) ; 
 
                                 } 
 
                         } 
 
                 } 
 
 
 
                 p u b l i c   v o i d   A d d L a n g u a g e ( X b o x L i v e S u b m i s s i o n P r o j e c t   x l a s t ,   X L A S T L a n g u a g e   l a n g ) 
 
                 { 
 
                         i f   ( x l a s t   = =   n u l l ) 
 
                                 t h r o w   n e w   A r g u m e n t N u l l E x c e p t i o n ( " x l a s t " ) ; 
 
 
 
                         S u p p o r t e d L o c a l e   l o c a l e   =   n u l l ; 
 
 
 
                         i f   ( x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . S u p p o r t e d L o c a l e C o l l e c t i o n   = =   n u l l ) 
 
                         { 
 
                                 x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . S u p p o r t e d L o c a l e C o l l e c t i o n   =   n e w   S u p p o r t e d L o c a l e C o l l e c t i o n ( ) ; 
 
                         } 
 
                         e l s e 
 
                         { 
 
                                 f o r   ( i n t   i   =   0 ;   i   <   x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . S u p p o r t e d L o c a l e C o l l e c t i o n . C o u n t ;   i + + ) 
 
                                 { 
 
                                         i f   ( x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . S u p p o r t e d L o c a l e C o l l e c t i o n [ i ] . l o c a l e   = =   L o c a l e S t r i n g s [ ( i n t ) l a n g ] ) 
 
                                         { 
 
                                                 l o c a l e   =   x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . S u p p o r t e d L o c a l e C o l l e c t i o n [ i ] ; 
 
                                                 b r e a k ; 
 
                                         } 
 
                                 } 
 
                         } 
 
 
 
                         i f   ( l o c a l e   = =   n u l l ) 
 
                         { 
 
                                 l o c a l e   =   x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . S u p p o r t e d L o c a l e C o l l e c t i o n . A d d ( ) ; 
 
                                 l o c a l e . l o c a l e   =   L o c a l e S t r i n g s [ ( i n t ) l a n g ] ; 
 
 
 
                                 / /   G o   t h r o u g h   e a c h   s t r i n g   a n d   a d d   t h e   d e f a u l t   v a l u e   f o r   t h i s   n e w   l a n g u a g e 
 
                                 f o r e a c h   ( L o c a l i z e d S t r i n g   l o c S t r i n g   i n   x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . L o c a l i z e d S t r i n g C o l l e c t i o n ) 
 
                                 { 
 
                                         A d d T r a n s l a t i o n ( l o c S t r i n g ,   l a n g ,   G e t D e f a u l t S t r i n g V a l u e ( l o c S t r i n g . i d ,   l a n g ) ) ; 
 
                                 } 
 
                         } 
 
                 } 
 
 
 
                 p u b l i c   u s h o r t   A d d S t r i n g ( X b o x L i v e S u b m i s s i o n P r o j e c t   x l a s t ,   s t r i n g   i n i t i a l V a l u e ) 
 
                 { 
 
                         r e t u r n   A d d S t r i n g ( x l a s t ,   " S t r i n g "   +   x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . n e x t I d . T o S t r i n g ( " d 3 " ) ,   i n i t i a l V a l u e ) ; 
 
                 } 
 
 
 
                 p u b l i c   u s h o r t   A d d S t r i n g ( X b o x L i v e S u b m i s s i o n P r o j e c t   x l a s t ,   s t r i n g   f r i e n d l y N a m e ,   s t r i n g   i n i t i a l V a l u e ) 
 
                 { 
 
                         i f   ( x l a s t   = =   n u l l ) 
 
                                 t h r o w   n e w   A r g u m e n t N u l l E x c e p t i o n ( " x l a s t " ) ; 
 
 
 
                         L o c a l i z e d S t r i n g   n e w S t r i n g   =   x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . L o c a l i z e d S t r i n g C o l l e c t i o n . A d d ( ) ; 
 
                         n e w S t r i n g . c l s i d   =   L o c a l i z e d S t r i n g C L S I D ; 
 
                         n e w S t r i n g . i d   =   x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . n e x t I d ; 
 
                         n e w S t r i n g . f r i e n d l y N a m e   =   f r i e n d l y N a m e ; 
 
 
 
                         f o r e a c h   ( S u p p o r t e d L o c a l e   l o c a l e   i n   x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . S u p p o r t e d L o c a l e C o l l e c t i o n ) 
 
                         { 
 
                                 A d d T r a n s l a t i o n ( n e w S t r i n g ,   l o c a l e . l o c a l e ,   i n i t i a l V a l u e ) ; 
 
                         } 
 
 
 
                         x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . n e x t I d + + ; 
 
                         r e t u r n   n e w S t r i n g . i d ; 
 
                 } 
 
 
 
                 p u b l i c   v o i d   M o d i f y S t r i n g ( X b o x L i v e S u b m i s s i o n P r o j e c t   x l a s t ,   u s h o r t   s t r i n g I d ,   X L A S T L a n g u a g e   l a n g ,   s t r i n g   n e w V a l u e ) 
 
                 { 
 
                         i f   ( x l a s t   = =   n u l l ) 
 
                                 t h r o w   n e w   A r g u m e n t N u l l E x c e p t i o n ( " x l a s t " ) ; 
 
 
 
                         / /   F i n d   t h e   s t r i n g   i n   q u e s t i o n 
 
                         L o c a l i z e d S t r i n g   l o c S t r i n g   =   F i n d L o c a l i z e d S t r i n g ( x l a s t ,   s t r i n g I d ) ; 
 
                         i f   ( l o c S t r i n g   ! =   n u l l ) 
 
                         { 
 
                                 / /   U p d a t e   t h e   g i v e n   t r a n s l a t i o n   o f   t h i s   s t r i n g 
 
                                 f o r e a c h   ( T r a n s l a t i o n   t r a n s   i n   l o c S t r i n g . T r a n s l a t i o n C o l l e c t i o n ) 
 
                                 { 
 
                                         i f   ( t r a n s . l o c a l e   = =   L o c a l e S t r i n g s [ ( i n t ) l a n g ] ) 
 
                                         { 
 
                                                 t r a n s . V a l u e   =   n e w V a l u e ; 
 
                                         } 
 
                                 } 
 
                         } 
 
                 } 
 
 
 
                 p r i v a t e   v o i d   A d d D e f a u l t S t r i n g ( X b o x L i v e S u b m i s s i o n P r o j e c t   x l a s t ,   X L A S T D e f a u l t S t r i n g   d e f S t r i n g ,   X L A S T L a n g u a g e   l a n g ) 
 
                 { 
 
                         L o c a l i z e d S t r i n g   l o c S t r i n g   =   n u l l ; 
 
 
 
                         / /   I f   t h e   s t r i n g   d o e s n ' t   y e t   e x i s t   i n   t h e   X L A S T   f i l e ,   c r e a t e   i t 
 
                         f o r   ( i n t   i   =   0 ;   i   <   x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . L o c a l i z e d S t r i n g C o l l e c t i o n . C o u n t ;   i + + ) 
 
                         { 
 
                                 i f   ( x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . L o c a l i z e d S t r i n g C o l l e c t i o n [ i ] . i d   = =   ( u s h o r t ) d e f S t r i n g ) 
 
                                 { 
 
                                         l o c S t r i n g   =   x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . L o c a l i z e d S t r i n g C o l l e c t i o n [ i ] ; 
 
                                         b r e a k ; 
 
                                 } 
 
                         } 
 
 
 
                         i f   ( l o c S t r i n g   = =   n u l l ) 
 
                         { 
 
                                 l o c S t r i n g   =   x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . L o c a l i z e d S t r i n g C o l l e c t i o n . A d d ( ) ; 
 
                                 l o c S t r i n g . c l s i d   =   L o c a l i z e d S t r i n g C L S I D ; 
 
                                 l o c S t r i n g . i d   =   ( u s h o r t ) d e f S t r i n g ; 
 
                                 l o c S t r i n g . f r i e n d l y N a m e   =   E n u m . G e t N a m e ( t y p e o f ( X L A S T D e f a u l t S t r i n g ) ,   d e f S t r i n g ) ; 
 
                         } 
 
 
 
                         / /   A d d   t h e   s p e c i f i e d   l a n g u a g e   t o   t h e   l i s t   o f   t r a n s l a t i o n s 
 
                         T r a n s l a t i o n   l o c T r a n s   =   n u l l ; 
 
                         i f   ( l o c S t r i n g . T r a n s l a t i o n C o l l e c t i o n   = =   n u l l ) 
 
                         { 
 
                                 l o c S t r i n g . T r a n s l a t i o n C o l l e c t i o n   =   n e w   T r a n s l a t i o n C o l l e c t i o n ( ) ; 
 
                         } 
 
                         e l s e 
 
                         { 
 
                                 f o r   ( i n t   i   =   0 ;   i   <   l o c S t r i n g . T r a n s l a t i o n C o l l e c t i o n . C o u n t ;   i + + ) 
 
                                 { 
 
                                         i f   ( l o c S t r i n g . T r a n s l a t i o n C o l l e c t i o n [ i ] . l o c a l e   = =   L o c a l e S t r i n g s [ ( i n t ) l a n g ] ) 
 
                                         { 
 
                                                 l o c T r a n s   =   l o c S t r i n g . T r a n s l a t i o n C o l l e c t i o n [ i ] ; 
 
                                                 b r e a k ; 
 
                                         } 
 
                                 } 
 
                         } 
 
 
 
                         i f   ( l o c T r a n s   = =   n u l l ) 
 
                         { 
 
                                 l o c T r a n s   =   l o c S t r i n g . T r a n s l a t i o n C o l l e c t i o n . A d d ( ) ;   
 
                                 l o c T r a n s . l o c a l e   =   L o c a l e S t r i n g s [ ( i n t ) l a n g ] ; 
 
                                 l o c T r a n s . V a l u e   =   G e t D e f a u l t S t r i n g V a l u e ( ( u s h o r t ) d e f S t r i n g ,   l a n g ) ; 
 
                         } 
 
                 } 
 
 
 
                 p r i v a t e   v o i d   A d d T r a n s l a t i o n ( L o c a l i z e d S t r i n g   l o c S t r i n g ,   X L A S T L a n g u a g e   l a n g ,   s t r i n g   v a l u e ) 
 
                 { 
 
                         A d d T r a n s l a t i o n ( l o c S t r i n g ,   L o c a l e S t r i n g s [ ( i n t ) l a n g ] ,   v a l u e ) ; 
 
                 } 
 
 
 
                 p r i v a t e   v o i d   A d d T r a n s l a t i o n ( L o c a l i z e d S t r i n g   l o c S t r i n g ,   s t r i n g   l o c a l e ,   s t r i n g   v a l u e ) 
 
                 { 
 
                         T r a n s l a t i o n   t r a n s   =   l o c S t r i n g . T r a n s l a t i o n C o l l e c t i o n . A d d ( ) ; 
 
                         t r a n s . l o c a l e   =   l o c a l e ; 
 
                         i f   ( v a l u e   ! =   n u l l ) 
 
                                 t r a n s . V a l u e   =   v a l u e ; 
 
                         e l s e 
 
                                 t r a n s . V a l u e   =   l o c a l e   +   "   s t r i n g . " ; 
 
                 } 
 
 
 
                 p r i v a t e   s t r i n g   G e t D e f a u l t S t r i n g V a l u e ( u s h o r t   s t r i n g I d ,   X L A S T L a n g u a g e   l a n g ) 
 
                 { 
 
                         i f   ( _ d e f a u l t S t r i n g s . C o n t a i n s K e y ( s t r i n g I d ) ) 
 
                         { 
 
                                 L i s t < s t r i n g >   t r a n s l a t i o n s   =   _ d e f a u l t S t r i n g s [ s t r i n g I d ] ; 
 
                                 i f   ( t r a n s l a t i o n s . C o u n t   >   1 ) 
 
                                 { 
 
                                         r e t u r n   t r a n s l a t i o n s [ ( i n t ) l a n g ] ; 
 
                                 } 
 
                                 e l s e 
 
                                 { 
 
                                         r e t u r n   t r a n s l a t i o n s [ 0 ] ; 
 
                                 } 
 
                         } 
 
 
 
                         r e t u r n   L o c a l e S t r i n g s [ ( i n t ) l a n g ]   +   "   s t r i n g . " ; 
 
                 } 
 
 
 
                 p r i v a t e   L o c a l i z e d S t r i n g   F i n d L o c a l i z e d S t r i n g ( X b o x L i v e S u b m i s s i o n P r o j e c t   x l a s t ,   u s h o r t   s t r i n g I d ) 
 
                 { 
 
                         f o r e a c h   ( L o c a l i z e d S t r i n g   s t r   i n   x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . L o c a l i z e d S t r i n g C o l l e c t i o n ) 
 
                         { 
 
                                 i f   ( s t r . i d   = =   s t r i n g I d ) 
 
                                         r e t u r n   s t r ; 
 
                         } 
 
                         r e t u r n   n u l l ; 
 
                 } 
 
         } 
 
 } 
 
 
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup1\ClientTools\ClientToolBase.cs ===
using System;
using System.IO;
using System.Diagnostics;
using System.Reflection;
using ServerTestFramework.Utilities;
using Microsoft.Win32;

namespace ServerTestFramework.STFTools
{
    /// <summary>
    /// Base class for all client tool wrappers
    /// </summary>
    abstract public class ClientToolBase
    {
        public const string DefaultBasePath = @"D:\Webroot\xbltools";
        public readonly string ToolPath;

        private ProcessWrapper m_Process;
        private string m_RemoteServer = null;

        public ClientToolBase(string toolPath) : this(toolPath, false, null) { }

        public ClientToolBase(string toolPath, bool isRemote) : this(toolPath, isRemote, isRemote ? GetToolServer() : null) {}

        public ClientToolBase(string toolPath, bool isRemote, string remoteServer)
        {
            ToolPath = toolPath;

            if (isRemote)
            {
                m_RemoteServer = remoteServer;
                m_Process = new ProcessWrapper(Path.GetFileNameWithoutExtension(ToolPath) + " (Remote)", "psexec.exe");
                AcceptPsExecEula();
            }
            else
            {
                m_Process = new ProcessWrapper(Path.GetFileNameWithoutExtension(ToolPath), ToolPath);
            }
        }

        /// <summary>
        /// Standard Error for the completed process
        /// </summary>
        public string StandardError
        {
            get
            {
                return m_Process.Error;
            }
        }

        /// <summary>
        /// Standard Output for the completed process
        /// </summary>
        public string StandardOutput
        {
            get
            {
                return m_Process.Output;
            }
        }

        /// <summary>
        /// Gets the first server for the toolsmgmtsrv interface
        /// </summary>
        /// <returns>Server name</returns>
        private static string GetToolServer()
        {
            string[] toolServers = Global.XEnv.GetServerListByInterface("toolsmgmtsrv"); // TODO: Put this into xonline.common.config.Interface

            if (toolServers.Length < 1)
                throw new Exception("Could not find server for \"toolsmgmtsrv\" interface");

            return toolServers[0];
        }

        /// <summary>
        /// Sets the flag in the registry saying that we accepted the PsExec license agreement.
        /// Without this, the first execution pops up an Accept/Decline UI that currently can't
        /// be overridden on the command line.
        /// </summary>
        private void AcceptPsExecEula()
        {
            const string psExecSubKey = @"Software\Sysinternals\PsExec";
            const string psExecValueName = "EulaAccepted";

            RegistryKey psExecKey = Registry.CurrentUser.OpenSubKey(psExecSubKey, true);

            if (psExecKey == null)
            {
                psExecKey = Registry.CurrentUser.CreateSubKey(psExecSubKey);
            }

            int eulaAccepted = (int)psExecKey.GetValue(psExecValueName, 0);

            if (eulaAccepted != 1)
            {
                psExecKey.SetValue(psExecValueName, 1, RegistryValueKind.DWord);
            }
        }

        /// <summary>
        /// Executes the tool with the given arguments
        /// </summary>
        /// <param name="args">Arguments for the tool</param>
        /// <returns>Process exit code</returns>
        public int Run(string args)
        {
            if (String.IsNullOrEmpty(m_RemoteServer))
            {
                // Local run
                return m_Process.Run(args);
            }
            else
            {
                // Remote run, marshal real parameters to psexec
                return m_Process.Run(String.Format("\\\\{0} {1} {2}", m_RemoteServer, ToolPath, args));
            }
        }

        /// <summary>
        /// Executes the tool with the given arguments and throws an exception if the
        /// exit code is non-zero.
        /// </summary>
        /// <typeparam name="T">Type of exception to throw</typeparam>
        /// <param name="args">Arguments for the tool</param>
        /// <param name="message">Error message</param>
        public void RunThrowOnFailure<T>(string args, string message) where T : ProcessException
        {
            int exitCode = Run(args);

            if (exitCode != 0)
            {
                // Special case the scenario where psexec couldn't start the binary
                if (StandardError.Contains("could not start " + ToolPath))
                {
                    message = String.Format("Could not start {0} on server {1}.  Is the path correct?", ToolPath, m_RemoteServer);
                }

                // This preserves the pattern of each client tool wrapper specifying
                // its own Exception when the tool fails.  Having all tools simply
                // throw a ProcessException is much simpler and still readable, but
                // that is too big a change for now.
                T ex = (T)Activator.CreateInstance(typeof(T), message, StandardOutput);
                throw ex;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup1\ClientTools\EmulatorUtil.cs ===
ï»¿using System;
using System.IO;
using System.Text;
using System.Net;

namespace ServerTestFramework.STFTools
{
    /// <summary>
    /// Utility class for emulator.
    /// </summary>
    public class EmulatorUtil
    {
        public static bool IsEmulatorUp(string emulatorType)
        {            
            string url = null;
            if (String.IsNullOrEmpty(emulatorType))
            {
                return true;
            }
            string template = "http://"+ System.Net.Dns.GetHostName() +"/MusicNetEmulator/";
            switch (emulatorType.Trim().ToLower())
            {
                case "ppsaprofile":
                    url = template + "ppsaProfileEmulator.asmx";
                    break;
                case "ppsacredential":
                    url = template + "ppsaCredentialEmulator.asmx";                    
                    break;
                case "abch":
                    url = template + "abchEmulator.asmx";                    
                    break;
                case "aggregator":
                    url = template + "AggregatorEmulator.asmx";
                    break;
                case "bdk":
                    url = template + "BdkEmulator.asmx";
                    break;
                case "controller":
                    url = template + "Controller.asmx";
                    break;
                case "dmp":
                    url = template + "DMPEmulator.asmx";
                    break;
                case "multirating":
                    url = template + "MultiRatingEmulator.asmx";
                    break;
                case "musicnet":
                    url = template + "MusicNetEmulator.asmx";
                    break;
                case "nicknamelistener":
                    url = template + "NickNameListenerEmulator.asmx";
                    break;
                case "singlerating":
                    url = template + "SingleRatingEmulator.asmx";
                    break;
                case "ups":
                    url = template + "upsEmulator.asmx";
                    break;
                default:
                    break;
            }
            if (String.IsNullOrEmpty(url))
            {
                return true;
            }
            try
            {
                // Create a request to the passed URI.   
                HttpWebRequest req = (HttpWebRequest)WebRequest.Create(url);
                req.Credentials = CredentialCache.DefaultNetworkCredentials;

                // Get the response object.   
                HttpWebResponse webResponse = (HttpWebResponse)req.GetResponse();
                
                return true;
            }
            catch (Exception e)
            {
                Global.RO.Error(String.Format("Check emulator {0} failed and threw exception {1}.", emulatorType, e.Message));
                return false;
            }  
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup\XLASTFactory\Properties.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework.STFTools.ConfigFiles;

namespace ServerTestFramework.STFTools
{
    public enum XLASTPropertyType : uint
    {
        Integer = 1,
        LongInteger,
        LongFloat,
        String,
        Float,
        DateTime = 7
    }

    public partial class XLASTFactory
    {
        private const uint RATING_PROPERTY_ID = 0x20000001;
        private const uint RANK_PROPERTY_ID = 0x10008001;
        private const uint GAMERNAME_PROPERTY_ID = 0x40008002;
        private const uint GAMER_ZONE_PROPERTY_ID = 0x10008101;
        private const uint GAMER_COUNTRY_PROPERTY_ID = 0x10008102;
        private const uint LANGUAGE_PROPERTY_ID = 0x10008103;
        private const uint GAMER_RATING_PROPERTY_ID = 0x50008104;
        private const uint GAMER_MU_PROPERTY_ID = 0x30008105;
        private const uint GAMER_SIGMA_PROPERTY_ID = 0x30008106;
        private const uint GAMER_PUID_PROPERTY_ID = 0x20008107;
        private const uint AFFILIATE_VALUE_PROPERTY_ID = 0x20008108;
        private const uint GAMER_HOSTNAME_PROPERTY_ID = 0x40008109;
        private const uint PLATFORM_TYPE_PROPERTY_ID = 0x10008201;
        private const uint PLATFORM_LOCK_PROPERTY_ID = 0x10008202;

        public void AddProperties(XboxLiveSubmissionProject xlast, int count)
        {
            for (int i = 1; i <= count; i++)
            {
                XLASTPropertyType type = GetRandomPropertyType();
                AddProperty(xlast, type);
            }
        }

        public string AddProperty(XboxLiveSubmissionProject xlast, XLASTPropertyType propertyType)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            string newId;
            uint id = ((uint)propertyType << 28) | xlast.GameConfigProject.Properties.nextId;
            string name = "Property" + xlast.GameConfigProject.Properties.nextId.ToString("d3");
            ushort stringId = AddString(xlast, name + " string");
            newId = AddProperty(xlast, id, stringId, propertyType, name);

            return newId;
        }

        public string AddProperty(XboxLiveSubmissionProject xlast, uint id, ushort stringId, XLASTPropertyType propertyType, string friendlyName)
        {
            Property newProperty = new Property();

            newProperty.clsid = PropertyCLSID;
            newProperty.id = "0x" + id.ToString("X8");
            newProperty.stringId = stringId;
            newProperty.friendlyName = friendlyName;
            switch (propertyType)
            {
                case XLASTPropertyType.DateTime:
                    newProperty.dataSize = 8;
                    newProperty.Format.year = true;
                    newProperty.Format.month = true;
                    newProperty.Format.day = true;
                    newProperty.Format.hours = true;
                    newProperty.Format.minutes = true;
                    newProperty.Format.seconds = true;
                    newProperty.Format.milliseconds = true;
                    break;
                case XLASTPropertyType.Float:
                    newProperty.dataSize = 4;
                    newProperty.Format.decimals = 2;
                    break;
                case XLASTPropertyType.Integer:
                    newProperty.dataSize = 4;
                    newProperty.Format.hours = false;
                    newProperty.Format.minutes = false;
                    newProperty.Format.seconds = false;
                    newProperty.Format.milliseconds = false;
                    break;
                case XLASTPropertyType.LongFloat:
                    newProperty.dataSize = 8;
                    newProperty.Format.decimals = 2;
                    break;
                case XLASTPropertyType.LongInteger:
                    newProperty.dataSize = 8;
                    newProperty.Format.hours = false;
                    newProperty.Format.minutes = false;
                    newProperty.Format.seconds = false;
                    newProperty.Format.milliseconds = false;
                    break;
                case XLASTPropertyType.String:
                    newProperty.dataSize = 0;
                    break;
            }
            xlast.GameConfigProject.Properties.Add(newProperty);
            xlast.GameConfigProject.Properties.nextId++;

            return newProperty.id;
        }

        private void CreateProperties(XboxLiveSubmissionProject xlast)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            xlast.GameConfigProject.Properties.clsid = PropertiesCLSID;
            xlast.GameConfigProject.Properties.nextId = 1;

            AddProperty(xlast, RANK_PROPERTY_ID, (ushort)XLASTDefaultString.X_STRINGID_RANK, XLASTPropertyType.Integer, "RANK");
            AddProperty(xlast, GAMERNAME_PROPERTY_ID, (ushort)XLASTDefaultString.X_STRINGID_GAMERNAME, XLASTPropertyType.String, "GAMERNAME");
            AddProperty(xlast, GAMER_ZONE_PROPERTY_ID, (ushort)XLASTDefaultString.X_STRINGID_GAMER_ZONE, XLASTPropertyType.Integer, "GAMERZONE");
            AddProperty(xlast, GAMER_COUNTRY_PROPERTY_ID, (ushort)XLASTDefaultString.X_STRINGID_GAMER_COUNTRY, XLASTPropertyType.Integer, "GAMERCOUNTRY");
            AddProperty(xlast, LANGUAGE_PROPERTY_ID, (ushort)XLASTDefaultString.X_STRINGID_LANGUAGE, XLASTPropertyType.Integer, "LANGUAGE");
            AddProperty(xlast, GAMER_RATING_PROPERTY_ID, (ushort)XLASTDefaultString.X_STRINGID_GAMER_RATING, XLASTPropertyType.Float, "GAMERRATING");
            AddProperty(xlast, GAMER_MU_PROPERTY_ID, (ushort)XLASTDefaultString.X_STRINGID_GAMER_MU, XLASTPropertyType.LongFloat, "GAMERMU");
            AddProperty(xlast, GAMER_SIGMA_PROPERTY_ID, (ushort)XLASTDefaultString.X_STRINGID_GAMER_SIGMA, XLASTPropertyType.LongFloat, "GAMERSIGMA");
            AddProperty(xlast, GAMER_PUID_PROPERTY_ID, (ushort)XLASTDefaultString.X_STRINGID_GAMER_PUID, XLASTPropertyType.LongInteger, "GAMERPUID");
            AddProperty(xlast, AFFILIATE_VALUE_PROPERTY_ID, (ushort)XLASTDefaultString.X_STRINGID_AFFILIATE_VALUE, XLASTPropertyType.LongInteger, "AFFILIATEVALUE");
            AddProperty(xlast, GAMER_HOSTNAME_PROPERTY_ID, (ushort)XLASTDefaultString.X_STRINGID_GAMER_HOSTNAME, XLASTPropertyType.String, "GAMERHOSTNAME");
            AddProperty(xlast, PLATFORM_TYPE_PROPERTY_ID, (ushort)XLASTDefaultString.X_STRINGID_PLATFORM_TYPE, XLASTPropertyType.String, "PLATFORMTYPE");
            AddProperty(xlast, PLATFORM_LOCK_PROPERTY_ID, (ushort)XLASTDefaultString.X_STRINGID_PLATFORM_LOCK, XLASTPropertyType.String, "PLATFORMLOCK");

            // We need to add a well-known long int property to be used as the rating column in leaderboards
            AddProperty(xlast, RATING_PROPERTY_ID, AddString(xlast, "Rating"), XLASTPropertyType.LongInteger, "Rating");
        }

        private XLASTPropertyType GetRandomPropertyType()
        {
            int val;
            do
            {
                // There is no property ID 6 and string properties (ID 4) are not allowed by users.
                val = _rnd.Next((int)XLASTPropertyType.Integer, (int)XLASTPropertyType.DateTime + 1);
            } while (val == 4 || val == 6);

            return (XLASTPropertyType)val;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup\XLASTFactory\StatsViews.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework.STFTools.ConfigFiles;

namespace ServerTestFramework.STFTools
{
    public partial class XLASTFactory
    {
        // This gets set to a single string ID for the required rating column in all leaderboards.
        private ushort _ratingColumnStringId = 0;

        public uint AddStatsView(XboxLiveSubmissionProject xlast, resetType reset, ushort entryExpiration, ushort maxAttachments, bool hidden, bool arbitrated, bool top100)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            if (null == xlast.GameConfigProject.StatsViews.clsid)
            {
                CreateStatsViews(xlast);
            }

            StatsView newView = new StatsView();
            newView.clsid = StatsViewCLSID;
            newView.resetType = reset;
            newView.entryExpiration = entryExpiration;
            newView.maxAttachments = maxAttachments;
            newView.hidden = hidden;
            newView.arbitrated = arbitrated;
            newView.onlineOnly = false;
            newView.topEntries = top100 ? 100 : uint.MaxValue;
            newView.id = xlast.GameConfigProject.StatsViews.nextViewId;
            newView.friendlyName = String.Format("StatsView{0:d03}", newView.id);
            newView.viewType = "Leaderboard";
            newView.stringId = AddString(xlast, String.Format("{0} Name", newView.friendlyName));
            xlast.GameConfigProject.StatsViews.Add(newView);
            xlast.GameConfigProject.StatsViews.nextViewId++;

            // Every leaderboard must have a Rank column, a Gamer Name column and a Rating column
            AddStatsViewColumn(newView, "0x10008001", type.Last, false, false, (ushort)XLASTDefaultString.X_STRINGID_RANKCOL, 65535);
            AddStatsViewColumn(newView, "0x40008002", type.Last, false, false, (ushort)XLASTDefaultString.X_STRINGID_GAMERNAMECOL, 65533);
            AddStatsViewColumn(newView, "0x" + RATING_PROPERTY_ID.ToString("X8"), type.Last, false, true, _ratingColumnStringId, 65534);

            // If this is an Arcade title, add another column to be the one required Arcade Leaderboard column
            if (xlast.GameConfigProject.titleType == (uint)XLASTTitleType.ArcadeTitle)
            {
                string propertyId = AddProperty(xlast, XLASTPropertyType.Integer);
                ushort arcadeStringId = AddString(xlast, "Arcade Leaderboard Column");
                AddStatsViewColumn(FindStatsView(xlast, newView.id), propertyId, type.Last, false, false, arcadeStringId,
                    GetNextAttributeId(newView.Columns.FieldCollection), true, ArcadeLeaderboardSortType.Ascending, arcadeStringId);
            }

            return newView.id;
        }

        /// <summary>
        /// Adds a Context field to a StatsView (leaderboard)
        /// </summary>
        /// <param name="xlast">The xlast file object.</param>
        /// <param name="viewId">The ID of the StatView to which the column will be added.</param>
        /// <param name="contextId">The ID of the existing Context to use.</param>
        /// <param name="hidden">Flag indicating whether this column is hidden.</param>
        public void AddStatsViewColumn(XboxLiveSubmissionProject xlast, uint viewId, string contextId, bool hidden)
        {
            StatsView statsView = FindStatsView(xlast, viewId);
            if (statsView == null)
            {
                throw new StfException("Unable to find a StatsView with the id {0}", viewId);
            }

            ViewFieldType newField = new ViewFieldType();
            newField.ordinal = (ushort)statsView.Columns.FieldCollection.Count;
            newField.friendlyName = String.Format("StatsViewColumn{0:d03}", newField.ordinal);
            newField.stringId = AddString(xlast, newField.friendlyName + " Name");
            newField.hidden = hidden;
            newField.Context.id = UInt32.Parse(contextId.Substring(2), System.Globalization.NumberStyles.HexNumber);
            newField.attributeId = GetNextAttributeId(statsView.Columns.FieldCollection);

            statsView.Columns.FieldCollection.Add(newField);
        }

        /// <summary>
        /// Adds a Property field to a StatsView (leaderboard)
        /// </summary>
        /// <param name="xlast">The xlast file object.</param>
        /// <param name="viewId">The ID of the StatView to which the Property will be added.</param>
        /// <param name="propertyId">The ID of the existing Property to use.</param>
        /// <param name="aggregationType">The aggregation type to use for this column.</param>
        /// <param name="hidden">A flag indicating whether this column is hidden.</param>
        /// <param name="rank">A flag indicating whether this column is used for ranking.</param>
        public void AddStatsViewColumn(XboxLiveSubmissionProject xlast, uint viewId, string propertyId, type aggregationType, bool hidden, bool rank)
        {
            StatsView statsView = FindStatsView(xlast, viewId);
            if (statsView == null)
            {
                throw new StfException("Unable to find a StatsView with the id {0}", viewId);
            }

            ushort stringId = AddString(xlast, String.Format("StatsViewColumn{0:d03}", statsView.Columns.FieldCollection.Count));
            ushort attributeId = rank ? (ushort)65534 : GetNextAttributeId(statsView.Columns.FieldCollection);
            AddStatsViewColumn(statsView, propertyId, aggregationType, hidden, rank, stringId, attributeId);
        }

        /// <summary>
        /// Adds a number of StatsViews to an XLAST file.
        /// </summary>
        /// <param name="xlast">An XLAST file object.</param>
        /// <param name="count">The number of StatsViews to add to the XLAST file object.</param>
        public void AddStatsViews(XboxLiveSubmissionProject xlast, uint count)
        {
            int reset;
            ushort entryExpiration;
            ushort maxAttachments;
            bool hidden;
            bool arbitrated;
            bool top100;
            int columnCount;
            uint viewId;

            for (int i = 0; i < count; i++)
            {
                reset = _rnd.Next((int)resetType.Weekly, (int)resetType.Never + 1);
                entryExpiration = (ushort)_rnd.Next(0, ((int)ushort.MaxValue) + 1);
                maxAttachments = (ushort)_rnd.Next(0, ((int)ushort.MaxValue) + 1);
                hidden = (_rnd.Next(1, 101) > 90);          // 10% chance of being hidden
                arbitrated = (_rnd.Next(1, 101) > 60);      // 40% chance of being arbitrated
                top100 = (_rnd.Next(1, 101) > 50);          // 50% chance of being Top 100
                columnCount = _rnd.Next(0, 11);

                viewId = AddStatsView(xlast, (resetType)reset, entryExpiration, maxAttachments, hidden, arbitrated, top100);
                AddStatsViewColumns(xlast, viewId, columnCount);
            }
        }

        /// <summary>
        /// Adds a number of columns to a specified StatsView.
        /// </summary>
        /// <param name="xlast">An XLAST file object.</param>
        /// <param name="viewId">The ID os the StatsView to which the columns will be added.</param>
        /// <param name="count">The number of columns to add.</param>
        public void AddStatsViewColumns(XboxLiveSubmissionProject xlast, uint viewId, int count)
        {
            PropertyCollection properties = FindAvailableProperties(xlast);
            ContextCollection contexts = FindAvailableContexts(xlast);
            bool hidden = (_rnd.Next(1, 101) > 90);
            int index;

            // If there are no Contexts available for use, add some
            if (contexts.Count == 0)
            {
                AddContexts(xlast, 3, 4);
                contexts = FindAvailableContexts(xlast);
            }

            // If there are no Properties available for use, add some
            if (properties.Count == 0)
            {
                AddProperties(xlast, 5);
                properties = FindAvailableProperties(xlast);
            }

            for (int i = 0; i < count; i++)
            {
                if (_rnd.Next(1, 101) > 50)
                {
                    // Create a Context column
                    index = _rnd.Next(0, contexts.Count);
                    AddStatsViewColumn(xlast, viewId, contexts[index].id, hidden);
                }
                else
                {
                    // Create a Property column
                    index = _rnd.Next(0, properties.Count);
                    type aggregationType = (type)_rnd.Next((int)type.Min, (int)type.Last + 1);
                    AddStatsViewColumn(xlast, viewId, properties[index].id, aggregationType, hidden, false);
                }
            }
        }

        // Since every new leaderboard requires two well-known columns, this is provided to specify
        // the correct string ID and attribute ID for the columns.
        private void AddStatsViewColumn(
            StatsView statsView,
            string propertyId,
            type aggregationType,
            bool hidden,
            bool rank,
            ushort stringId,
            ushort attributeId)
        {
            AddStatsViewColumn(statsView, propertyId, aggregationType, hidden, rank, stringId, attributeId, false, ArcadeLeaderboardSortType.Ascending, 0);
        }
        
        private void AddStatsViewColumn(
            StatsView statsView,
            string propertyId,
            type aggregationType,
            bool hidden,
            bool rank,
            ushort stringId,
            ushort attributeId,
            bool arcadeLeaderboard,
            ArcadeLeaderboardSortType arcadeSort,
            ushort arcadeStringId)
        {
            ViewFieldType newField = new ViewFieldType();
            newField.ordinal = (ushort)statsView.Columns.FieldCollection.Count;
            newField.friendlyName = String.Format("StatsViewColumn{0:d03}", newField.ordinal);
            newField.stringId = stringId;
            newField.hidden = hidden;
            newField.Property.id = propertyId;
            newField.Property.Aggregation.type = aggregationType;
            newField.attributeId = attributeId;
            if (arcadeLeaderboard)
            {
                newField.arcadeLeaderboard = arcadeLeaderboard;
                newField.arcadeSort = arcadeSort;
                newField.arcadeStringId = arcadeStringId;
            }

            statsView.Columns.FieldCollection.Add(newField);
        }

        private void CreateStatsViews(XboxLiveSubmissionProject xlast)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            xlast.GameConfigProject.StatsViews.clsid = StatsViewsCLSID;
            xlast.GameConfigProject.StatsViews.nextViewId = 1;

            // Add a string for the required Rating column
            _ratingColumnStringId = AddString(xlast, "RatingColumn_NAME", "Rating");

            // Arcade titles are the only ones that require a leaderboard
            if (xlast.GameConfigProject.titleType == (uint)XLASTTitleType.ArcadeTitle)
            {
                AddStatsViews(xlast, 1);
            }
        }

        private StatsView FindStatsView(XboxLiveSubmissionProject xlast, uint viewId)
        {
            foreach (StatsView view in xlast.GameConfigProject.StatsViews.StatsViewCollection)
            {
                if (view.id == viewId)
                    return view;
            }
            return null;
        }

        private ushort GetNextAttributeId(ViewFieldTypeCollection fields)
        {
            ushort attributeId = 0;
            foreach (ViewFieldType field in fields)
            {
                if ((short)field.attributeId > 0)
                    attributeId = field.attributeId;
            }
            return ++attributeId;
        }

        private ContextCollection FindAvailableContexts(XboxLiveSubmissionProject xlast)
        {
            ContextCollection contexts = new ContextCollection();

            // Walk the list of Contexts to find ones available to be leaderboard columns
            foreach (Context ctx in xlast.GameConfigProject.Contexts.ContextCollection)
            {
                uint id = UInt32.Parse(ctx.id.Substring(2), System.Globalization.NumberStyles.HexNumber);
                if ((id & 0x0000F000) == 0)
                {
                    contexts.Add(ctx);
                }
            }

            return contexts;
        }

        private PropertyCollection FindAvailableProperties(XboxLiveSubmissionProject xlast)
        {
            PropertyCollection properties = new PropertyCollection();

            // Walk the list of properties to find ones available to be leaderboard columns
            foreach (Property property in xlast.GameConfigProject.Properties.PropertyCollection)
            {
                uint id = UInt32.Parse(property.id.Substring(2), System.Globalization.NumberStyles.HexNumber);
                XLASTPropertyType type = (XLASTPropertyType)(id >> 28);
                id = id & 0x0000FFFF;
                if (id < 0x8000 && type != XLASTPropertyType.Float && type != XLASTPropertyType.DateTime)
                {
                    properties.Add(property);
                }
            }

            return properties;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup\XLASTFactory\ProductInformation.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework.STFTools.ConfigFiles;

namespace ServerTestFramework.STFTools
{
    public enum XLASTPlatform
    {
        Xbox360 = 2,
        PC = 4
    }

    public enum XLASTGenre : uint
    {
        Other = 101,
        Action,             // 102
        Adventure,          // 103
        Compilations,       // 104
        Family,             // 105
        Fighting,           // 106
        Music = 108,        // 108
        Platform,           // 109
        Racing,             // 110
        RolePlaying,        // 111
        Shooter,            // 112
        Simulation,         // 113
        Sports,             // 114
        Strategy,           // 115
        DemoTitle=701       // Genre required for Demo titles
    }

    public enum XLASTArcadeGenre : uint
    {
        Arcade = 11600,     // This one is required for all Arcade titles
        ActionArcade,       // 11601
        CardAndBoard,       // 11602
        CoinOpClassics,     // 11603
        PuzzleAndWord,      // 11604
        BarSports,          // 11605
        StrategyAndSims,    // 11606
        ConsoleClassics,    // 11607
        GameShows,          // 11608
        FamilyGames,        // 11609
        Trivia,             // 11610
        SportsGames,        // 11611
        PartyGames,         // 11612
        RacingGames,        // 11613
        RolePlayingGames,   // 11614
        CameraEnabled       // 11615
    }

    public enum XLASTFeature : uint
    {
        Camera = 1,
        CoOp,
        CustomSoundtrack,
        Dolby51,
        HardDriveEnhanced,
        HardDriveRequired,
        LiveAware,
        LiveClans,
        LiveCoOp,
        LiveDownloads,
        LiveFriends,
        LiveMessaging,
        LiveMultiplayer,
        LiveScoreboard,
        LiveServiceProxy,
        LiveStats,
        LiveTournaments,
        LiveVoice,
        LiveVoiceMessaging,
        MemoryUnit,
        MultiplayerVersus,
        Peripherals,
        PremiumOffers,
        SystemLink,
        UserCreatableContent,
        Xbox2Support,
        XboxSupport
    }

    public enum XLASTRating : uint
    {
        ESRB_EC = 1,
        ESRB_E,
        ESRB_E10,
        ESRB_T,
        ESRB_M,
        ESRB_AO,
        ESRB_RP,
        PEGI_3 = 11,
        PEGI_7,
        PEGI_12,
        PEGI_16,
        PEGI_18,
        PEGIFinland_3 = 21,
        PEGIFinland_7,
        PEGIFinland_12,
        PEGIFinland_16,
        PEGIFinland_18,
        PEGIPortugal_4 = 31,
        PEGIPortugal_6,
        PEGIPortugal_12,
        PEGIPortugal_16,
        PEGIPortugal_18,
        PEGIBBFC_3 = 41,
        PEGIBBFC_U,
        PEGIBBFC_7,
        PEGIBBFC_PG,
        PEGIBBFC_12,
        PEGIBBFC_15,
        PEGIBBFC_16,
        PEGIBBFC_18,
        CERO_AllAges = 51,
        CERO_12,
        CERO_15,
        CERO_17,
        CERO_Standard,
        CERO_18,
        USK_All = 61,
        USK_6,
        USK_12,
        USK_16,
        USK_NoYouth,
        OFLCAus_G = 71,
        OFLCAus_G8,
        OFLCAus_M15,
        OFLCAus_MA15,
        OFLCAus_RC,
        OFLCNZ_G = 81,
        OFLCNZ_G8,
        OFLCNZ_M15,
        OFLCNZ_MA15,
        OFLCNZ_RC,
        KMRB_All = 91,
        KMRB_12,
        KMRB_15,
        KMRB_18,
        Brazil_All = 101,
        Brazil_12,
        Brazil_14,
        Brazil_16,
        Brazil_18,
        FPB_All = 111,
        FPB_PG,
        FPB_10,
        FPB_13,
        FPB_16,
        FPB_18
    }

    public enum XLASTRatingSystem : uint
    {
        ESRB = 0,
        PEGI,
        PEGIFinland,
        PEGIPortugal,
        PEGIBBFC,
        CERO,
        USK,
        OFLCAustralia,
        OFLCNewZealand,
        KMRB,
        Brazil,
        FPB
    }

    public partial class XLASTFactory
    {
        public void SetPlatform(XboxLiveSubmissionProject xlast, XLASTPlatform platform)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            Platform newPlatform = new Platform();
            newPlatform.name = Enum.GetName(typeof(XLASTPlatform), platform);
            newPlatform.id = (uint)platform;

            if (!xlast.GameConfigProject.ProductInformation.PlatformCollection.Contains(newPlatform))
            {
                xlast.GameConfigProject.ProductInformation.PlatformCollection.Add(newPlatform);
            }
        }

        public void AddGenre(XboxLiveSubmissionProject xlast, XLASTGenre genre)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            Genre newGenre = new Genre();
            newGenre.genreId = (uint)genre * 1000000;

            // Only add the Genre if it doesn't already exist
            if (!ContainsGenre(xlast.GameConfigProject.ProductInformation.GenreCollection, newGenre.genreId))
            {
                xlast.GameConfigProject.ProductInformation.GenreCollection.Add(newGenre);
            }
        }

        public void AddArcadeGenre(XboxLiveSubmissionProject xlast, XLASTArcadeGenre arcadeGenre)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            Genre newGenre = new Genre();
            newGenre.genreId = (uint)arcadeGenre * 10000;

            // Only add the Genre if it doesn't already exist
            if (!ContainsGenre(xlast.GameConfigProject.ProductInformation.GenreCollection, newGenre.genreId))
            {
                xlast.GameConfigProject.ProductInformation.GenreCollection.Add(newGenre);
            }
        }

        public void AddRating(XboxLiveSubmissionProject xlast, XLASTRating rating)
        {
            AddRating(xlast, rating, 0, null);
        }

        public void AddRating(XboxLiveSubmissionProject xlast, XLASTRating rating, uint imageId, string description)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            uint ratingSystem = (uint)((uint)rating / 10);
            Rating newRating = new Rating();
            newRating.ratingSystemId = ratingSystem;
            newRating.ratingId = (uint)rating;
            newRating.Description = description;
            newRating.imageId = imageId;
            if (!ContainsRating(xlast.GameConfigProject.ProductInformation.RatingCollection, newRating))
            {
                xlast.GameConfigProject.ProductInformation.RatingCollection.Add(newRating);
            }
        }

        public void AddAllRatings(XboxLiveSubmissionProject xlast)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            // Add one of each rating system
            uint[] systems = (uint[])Enum.GetValues(typeof(XLASTRatingSystem));
            foreach (uint sys in systems)
            {
                AddRating(xlast, GetRandomRating((XLASTRatingSystem)sys));
            }
        }

        public void AddFeature(XboxLiveSubmissionProject xlast, XLASTFeature feature)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            Feature newFeature = new Feature();
            newFeature.name = Enum.GetName(typeof(XLASTFeature), feature);
            newFeature.enabled = true;
            if (!ContainsFeature(xlast.GameConfigProject.ProductInformation.FeatureCollection, newFeature))
            {
                xlast.GameConfigProject.ProductInformation.FeatureCollection.Add(newFeature);
            }
        }

        public void AddFeatures(XboxLiveSubmissionProject xlast, int count)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            for (int i = 0; i < count; i++)
            {
                AddFeature(xlast, (XLASTFeature)_rnd.Next((int)XLASTFeature.Camera, (int)XLASTFeature.XboxSupport + 1));
            }
        }

        public void AddProductInformation(XboxLiveSubmissionProject xlast)
        {
            int i;
            int count;

            if (xlast.GameConfigProject.titleType == (uint)XLASTTitleType.ArcadeTitle)
            {
                string desc;
                uint imageId;

                // Genres
                count = _rnd.Next(1, 8);
                for (i = 0; i < count; i++)
                {
                    AddArcadeGenre(xlast, GetRandomArcadeGenre());
                }

                // Ratings
                count = _rnd.Next(1, 11);
                for (i = 0; i < count; i++)
                {
                    if (_rnd.Next(1, 101) > 50)
                    {
                        desc = _rnd.GenerateUnicodeString(10, 128, false);
                    }
                    else
                    {
                        desc = "";
                    }
                    imageId = (uint)_rnd.Next(0, xlast.GameConfigProject.Images.Count);
                    AddRating(xlast, GetRandomRating(GetRandomRatingSystem()), imageId, desc);
                }
            }
            else
            {
                // Genres
                if (xlast.GameConfigProject.titleType != (uint)XLASTTitleType.DemoTitle)
                {
                    count = _rnd.Next(1, 8);
                    for (i = 0; i < count; i++)
                    {
                        AddGenre(xlast, GetRandomGenre());
                    }
                }

                // Ratings
                count = _rnd.Next(1, 21);
                for (i = 0; i < count; i++)
                {
                    AddRating(xlast, GetRandomRating(GetRandomRatingSystem()));
                }
            }

            // Features
            count = _rnd.Next(1, 14);
            AddFeatures(xlast, count);
        }

        private void CreateProductInformation(XboxLiveSubmissionProject xlast)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            xlast.GameConfigProject.ProductInformation.developerStringId = AddString(xlast, "Developer String");
            xlast.GameConfigProject.ProductInformation.publisherStringId = AddString(xlast, "Publisher String");
            xlast.GameConfigProject.ProductInformation.sellTextStringId = AddString(xlast, "SellText String");
            xlast.GameConfigProject.ProductInformation.genreTextStringId = AddString(xlast, "Genre String");
            xlast.GameConfigProject.ProductInformation.offlinePlayersMax = 0;
            xlast.GameConfigProject.ProductInformation.livePlayersMax = 0;
            xlast.GameConfigProject.ProductInformation.systemLinkPlayersMax = 0;
            SetPlatform(xlast, XLASTPlatform.Xbox360);

            switch (xlast.GameConfigProject.titleType)
            {
                case (uint)XLASTTitleType.ArcadeTitle:
                    xlast.GameConfigProject.ProductInformation.arcadeDescriptionStringId = AddString(xlast, "Arcade Description String");
                    AddArcadeGenre(xlast, XLASTArcadeGenre.Arcade);
                    AddArcadeGenre(xlast, GetRandomArcadeGenre());
                    break;
                case (uint)XLASTTitleType.FullGame:
                    AddGenre(xlast, GetRandomGenre());
                    break;
                case (uint)XLASTTitleType.DemoTitle:
                    AddGenre(xlast, XLASTGenre.DemoTitle);
                    break;
                case (uint)XLASTTitleType.SystemTitle:
                    break;
            }
        }

        private XLASTGenre GetRandomGenre()
        {
            int val;

            do
            {
                val = _rnd.Next((int)XLASTGenre.Other, (int)XLASTGenre.Strategy + 1);
            } while (val == 107);

            return (XLASTGenre)val;
        }

        private XLASTArcadeGenre GetRandomArcadeGenre()
        {
            return (XLASTArcadeGenre)_rnd.Next((int)XLASTArcadeGenre.ActionArcade, (int)XLASTArcadeGenre.CameraEnabled + 1);
        }

        private XLASTRating GetRandomRating(XLASTRatingSystem ratingSystem)
        {
            int rating;
            int upperBound = 1;

            switch (ratingSystem)
            {
                case XLASTRatingSystem.PEGI:
                case XLASTRatingSystem.PEGIFinland:
                case XLASTRatingSystem.PEGIPortugal:
                case XLASTRatingSystem.USK:
                case XLASTRatingSystem.OFLCAustralia:
                case XLASTRatingSystem.OFLCNewZealand:
                case XLASTRatingSystem.Brazil:
                    upperBound = 6;
                    break;
                case XLASTRatingSystem.CERO:
                case XLASTRatingSystem.FPB:
                    upperBound = 7;
                    break;
                case XLASTRatingSystem.ESRB:
                    upperBound = 8;
                    break;
                case XLASTRatingSystem.PEGIBBFC:
                    upperBound = 9;
                    break;
            }
            rating = _rnd.Next(1, upperBound);
            return (XLASTRating)(((int)ratingSystem * 10) + rating);
        }

        private XLASTRatingSystem GetRandomRatingSystem()
        {
            return (XLASTRatingSystem)_rnd.Next((int)XLASTRatingSystem.ESRB, (int)XLASTRatingSystem.FPB + 1);
        }

        private bool ContainsGenre(GenreCollection genres, uint genreId)
        {
            foreach (Genre g in genres)
            {
                if (g.genreId == genreId)
                    return true;
            }
            return false;
        }

        private bool ContainsRating(RatingCollection ratings, Rating rating)
        {
            foreach (Rating r in ratings)
            {
                if (r.ratingSystemId == rating.ratingSystemId)
                    return true;
            }
            return false;
        }

        private bool ContainsFeature(FeatureCollection features, Feature feature)
        {
            foreach (Feature f in features)
            {
                if (String.Compare(f.name, feature.name, true) == 0)
                    return true;
            }
            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup1\ClientTools\LiveOffer.cs ===
/*
TODO: 
	- Add 585207D1 Peg PC subscription to Positive Tests
	- add BitFilter Neg case: Filter set to 0 should error as well as multiple set (Schema error)
	- add Mis-sized PNG case
*/
using System;
using System.IO;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

namespace ServerTestFramework.STFTools
{
	/// <summary>
	/// Utility class for running the LiveOffer tool.
	/// </summary>
	public class LiveOffer
	{
		private ProcessWrapper _liveOfferProcess;
		private const string _defaultLiveOfferPath = "D:\\webroot\\xbltools";
		public enum dbType {all, uodb, productdb, noflag};
		public bool noTransaction;

		public LiveOffer()
		{
			_liveOfferProcess = new ProcessWrapper("LiveOffer", Path.Combine(_defaultLiveOfferPath, "LiveOffer.exe"));
		}

		public LiveOffer(string liveOfferPath) : this()
		{
			_liveOfferProcess.ExecutablePath = Path.GetFullPath(liveOfferPath);
		}

		public string Output
		{
			get { return _liveOfferProcess.Output; }
		}

		/// <summary>
		/// Returns the appropriate string for the given dbType.
		/// </summary>
		public string DbTypeToString(dbType db) 
		{
            // Attribute not currently supported by LiveOffer. May come-back someday.
            /*
			switch (db) 
			{
				case dbType.uodb:
					return "-targetdb:uodb";
				case dbType.productdb:
					return "-targetdb:productdb";
				case dbType.all:
					return "-targetdb:all";
				case dbType.noflag:
			}
			throw new LiveOfferException("Invalid type(" + db + ") given to LiveOffer.cs::DbTypeToString");
            */

            return "";
		}
		/// <summary>
		/// Reloads the front doors.  Offers are cached and will not be seen unless the 
		/// this occurs--however, LiveOffer will by default reload the front doors after
		/// every prop.
		/// </summary>
		public void ReloadFrontDoors() 
		{
			string arguments = "-action:reload";
			if (_liveOfferProcess.Run(arguments) != 0) /* || (grep some kind of error string in output) */
				throw new LiveOfferException("Reload of front doors failed.", _liveOfferProcess.Output);			
		}
		/// <summary>
		/// Checks if the given XML file follows the format given in the file LiveOffer.xsd
		/// </summary>
		/// <param name="filePath">File to be validated.</param>
		public void Validate360Offer(string filePath) 
		{
			string arguments = String.Format("-action:validate -file:{0}", filePath);
			if (_liveOfferProcess.Run(arguments) != 0) /* || (grep some kind of error string in output) */
				throw new LiveOfferException("Xbox 360 offer validation failed.", _liveOfferProcess.Output);
		}

		/// <summary>
		/// Checks if the given XML file follows the format given in the file Xbox1Offer.xsd
		/// </summary>
		/// <param name="filePath">File to be validated.</param>
		public void ValidateXboxOffer(string filePath)
		{
			string arguments = String.Format("-action:validatexbox -file:{0}", filePath);
			if (_liveOfferProcess.Run(arguments) != 0) /* || (grep some kind of error string in output) */
				throw new LiveOfferException("Xbox offer validation failed.", _liveOfferProcess.Output);
		}

        /// <summary>
        /// Checks if a offer is propped.
        /// </summary>
        public static bool CheckIfOfferIsPropped(ulong offerID)
        {
            bool isPropped = false;
            try
            {
                string query = "select count(*) from t_offers WHERE bi_offer_id=" + (long)offerID;
                int rows = (int)UodbWS.ExecuteSQLSelectCount(query);
                if (rows != 0) isPropped = true;
            }
            catch (Exception e)
            {
                Global.RO.Error("UodbWS.ExecuteSQLSelectCount threw while trying to check offer " + offerID.ToString("x") + ": " + e.Message + "\nWill assume this indicates that it is not propped.");
            }
            return isPropped;
        }

		/// <summary>
		/// Places an Xbox360 offer file on the Live service.  This populates a large number of tables 
		/// that begin with uodb..t_offer.
		/// </summary>
		/// <param name="filePath">Path to the offer file.</param>
		/// <param name="titleId">Titleid the offer is related to.</param>
		/// <param name="targetDBs">Flag determining which DBs should be updated</param>
		/// <param name="overwriteDMPSettings">If they exist, clobber existing DMP settings.</param>
		public void Prop360Offer(string filePath, uint titleId, dbType targetDBs, bool overwriteDMPSettings) 
		{
			string arguments = String.Format("-action:prop -file:{0} -titleid:{1:x} {2} {3} {4}", filePath, titleId,
				DbTypeToString(targetDBs), overwriteDMPSettings ? "-overwriteDMPSettings" : "", noTransaction ? "-noTransaction":"");
			int res = _liveOfferProcess.Run(arguments);
			if (res != 0) /* || (grep some kind of error string in output) */
				{
				throw new LiveOfferException(String.Format("Prop of Xbox 360 offer failed. ({0})",res), _liveOfferProcess.Output);
				}
		}

		/// <summary>
		/// Places an Xbox1 offer file on the Live service.  This populates a distinctly different set of tables
		/// than in the XBox360 case.
		/// </summary>
		/// <param name="filePath">Path to the offer file.</param>
		/// <param name="titleId">Titleid the offer is related to.</param>
		/// <param name="targetDBs">Flag determining which DBs should be updated</param>
		/// <param name="overwriteDMPSettings">If they exist, clobber existing DMP settings.</param>
		public void PropXboxOffer(string filePath, uint titleId, dbType targetDBs, bool overwriteDMPSettings) 
		{
			string arguments = String.Format("-action:propxbox -file:{0} -titleid:{1:x} {2} {3} {4}", filePath, titleId,
				DbTypeToString(targetDBs), overwriteDMPSettings ? "-overwriteDMPSettings" : "", noTransaction ? "-noTransaction":"");
			if (_liveOfferProcess.Run(arguments) != 0) /* || (grep some kind of error string in output) */
				throw new LiveOfferException("Prop of Xbox offer failed.", _liveOfferProcess.Output);
		}

		/// <summary>
		/// Removes an offer from the Live service.  Requires an offerid.  This is only available on the
		/// debug build of LiveOffer.
		/// </summary>
		/// <param name="offerid">The offerId to remove.</param>
		public void NukeOffer(ulong offerid) {
			string arguments = String.Format("-action:nukeOffer -offerid:{0:x}", offerid);
			if (_liveOfferProcess.Run(arguments) != 0) /* || (grep some kind of error string in output) */
				throw new LiveOfferException("Prop of Xbox offer failed.", _liveOfferProcess.Output);
		}

		/// <summary>
		/// Removes all offers from the Live service under a certain title.  Requires a titleid.  This
		/// is only available on the debug build of LiveOffer.
		/// </summary>
		/// <param name="titleid">The titleId whose offers will be removed.</param>
		public void NukeAllOffers(uint titleid) {
			string arguments = String.Format("-action:nukeAllOffers -titleid:{0:x}", titleid);
			if (_liveOfferProcess.Run(arguments) != 0) /* || (grep some kind of error string in output) */
				throw new LiveOfferException("Prop of Xbox offer failed.", _liveOfferProcess.Output);
		}
		//automation for "nukealloffersforalltitles" is deliberately not included"
	}

	public class LiveOfferException : ProcessException
	{
		public LiveOfferException() : base("LiveOffer") {}
		public LiveOfferException(string message) : base("LiveOffer", message) {}
		public LiveOfferException(string message, Exception innerException) : base("LiveOffer", message, innerException) {}
		public LiveOfferException(string message, string output) : base("LiveOffer", message, output) {}
		public LiveOfferException(string message, string output, Exception innerException) :
			base("LiveOffer", message, output, innerException) {}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup1\ClientTools\QuickEnforce.cs ===
using System;
using System.IO;
using ServerTestFramework.Utilities;
namespace ServerTestFramework.STFTools
{
	/// <summary>
	/// Utility class for running the QuickEnforce tool.
	/// </summary>
	public class QuickEnforce
	{
		private ProcessWrapper _quickEnforceProcess;
		const string DefaultQuickEnforcePath = "D:\\webroot\\xbltools";  //where is it?

		public QuickEnforce()
		{
			_quickEnforceProcess = new ProcessWrapper("QuickEnforce", DefaultQuickEnforcePath);

		}
		public QuickEnforce(string quickEnforcePath) : this()
		{
			_quickEnforceProcess.ExecutablePath = Path.GetFullPath(quickEnforcePath);
		}

        public void EnforceUsers(string SQLServer, string EnforcementDB, string reportEmailAddy,
							string SMTP, int delayBetweenEnforcements, string custURL,
							string certPath) 
		{
			string commandArgs = "";
			commandArgs += String.Format("/SQLE {0}", SQLServer);
			commandArgs += String.Format(" /DBEN {0}", EnforcementDB);
			commandArgs += String.Format(" /MAIL {0}", reportEmailAddy);
			commandArgs += String.Format(" /SMTP {0}", SMTP);
			commandArgs += String.Format(" /WAIT {0}", delayBetweenEnforcements);
			commandArgs += String.Format(" /CURL {0}", custURL);
			commandArgs += String.Format(" /CERT {0}", certPath);
			if (_quickEnforceProcess.Run(commandArgs) != 0)
				throw new LiveStatsException("QuickEnforce failed.", _quickEnforceProcess.Output);
		}

	}

	
	public class QuickEnforceException : ProcessException
	{
		public QuickEnforceException() : base("QuickEnforce") {}
		public QuickEnforceException(string message) : base("QuickEnforce", message) {}
		public QuickEnforceException(string message, Exception innerException) : base("QuickEnforce", message, innerException) {}
		public QuickEnforceException(string message, string QuickEnforceOutput) : base("QuickEnforce", message, QuickEnforceOutput) {}
		public QuickEnforceException(string message, string QuickEnforceOutput, Exception innerException) :
			base("QuickEnforce", QuickEnforceOutput, message, innerException) {}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup1\ToolsTestBase.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.UserAccount;
using xonline.common.config;

namespace ServerTestFramework.STFTools
{
    abstract public class ToolsTestBase : TestBase 
    {
        // Prop XBOX 1 Title: livetitle /deployxbox /xboxpath:"4D530064.xbox" /ltcpath:"4D530064_LTC.xml" /xscpath:"4D530064.xsc" /xmspath:"4D530064.xms"
        void PropXbox1Title(uint TitleID, string XBoxPath, string LTCPath, string XSCPath, string XMSPath)
        {
            LiveTitle liveTitle = new LiveTitle();
            liveTitle.XBOXPath = XBoxPath;
            liveTitle.LTCPath = LTCPath;
            liveTitle.XSCPath = XSCPath;
            liveTitle.XMSPath = XMSPath;
            liveTitle.DeployXbox1Title(TitleID);
        }

        /// <summary>
        /// Create a user.  Returns a UODB.Database.UserInfo, defined in UtilityClasses.cs
        /// </summary>
        /// <returns>A UserInfo, defined in UODB.cs</returns>
        public UserInfo CreateUser()
        {
            XeUser user = new XeUser(true);
            ulong puid = user.Create();
            UserInfo uInfo;
            UodbWS.GetUserInfo(puid, out uInfo);
            Global.RO.Info("Account created is " + puid);
            return uInfo;
        }

        #region Offer functions
        /// <summary>
        /// Removes an offer from the system, reversing LiveOffer
        /// </summary>
        /// <param name="OfferId">OfferId of the offer to be removed</param>
        public void OfferRemove(ulong OfferId)
        {
            ServerTestFramework.LiveService.Billing.ContentOfferLoader.CleanOffers(OfferId);
        }
        #endregion

        #region Content Functions
        /// <summary>
        /// Removes Content from a site.  Does not report failure content is missing.
        /// </summary>
        /// <param name="titleId"></param>
        /// <param name="contentId"></param>
        /// <param name="site"></param>
        public static void ContentRemove(uint titleId, string contentId, int site)
        {
            string contentFilePath = ContentGetPath(titleId, contentId, site);
            if (File.Exists(contentFilePath))
            {
                Console.WriteLine("Found old content download package, deleting {0}", contentFilePath);
                File.Delete(contentFilePath);
            }
        }

        /// <summary>
        /// Checks to see if a content package is uploaded to a site
        /// </summary>
        /// <param name="titleId"></param>
        /// <param name="contentId"></param>
        /// <param name="site"></param>
        /// <returns>True if package is present</returns>
        public static bool ContentVerify(uint titleId, string contentId, int site)
        {
            string contentFilePath = ContentGetPath(titleId, contentId, site);
            if (!File.Exists(contentFilePath))
            {
                Console.WriteLine("Content package failed to copy to location:");
                Console.WriteLine(contentFilePath);
                return false;
            }
            return true;
        }

        /// <summary>
        /// Returns the expected path to the package stored in the content download directory
        /// </summary>
        /// <param name="titleId"></param>
        /// <param name="contentId"></param>
        /// <param name="site"></param>
        /// <returns></returns>
        private static string ContentGetPath(uint titleId, string contentId, int site)
        {
            IVirtualInterfaceInfo info;
            info = Config.GetVirtualInterface(VirtualInterface.download, site);

            string contentDownloadLocation = ContentGetDownloadShare(site);
            string contentFilePath = Path.Combine(contentDownloadLocation, titleId.ToString("x"));
            contentFilePath = Path.Combine(contentFilePath, contentId + ".xcp");
            return contentFilePath;
        }

        /// <summary>
        /// Returns a UNC path to the share where content downloads are stored.  These are
        /// referred to by site.
        /// </summary>
        /// <remarks>
        /// This code is directly lifted from the LiveContent tool's DownloadServerList.cs
        /// </remarks>
        /// <param name="siteNum">The ID of the content download site.</param>
        private static string ContentGetDownloadShare(int siteNum)
        {
            string[] serverList = null;
            serverList = Config.GetServerListByInterface(Interface.download_share);

            //Names not yet cached
            for (int c = 0; c < serverList.Length; c++)
            {
                IInterfaceInfo info;
                string shareName;
                int siteId;

                info = Config.GetInterface(serverList[c], Interface.download_share);
                Config.GetServerInfo(serverList[c], out siteId);

                if (siteNum == siteId)
                {
                    shareName = String.Format("\\\\{0}{1}\\",
                        info.IPAddressString,
                        info.Sharename);

                    if ((null == shareName) || (0 == shareName.Length))
                    {
                        throw new Exception("Invalid share name found when searching for content download server!");
                    }

                    if ('\\' != shareName[shareName.Length - 1])
                        shareName += "\\";
                    return shareName;
                }
            }
            //no matches!
            throw new Exception("No share name found when searching for content download server!");
        }
        #endregion

        #region Stats Functions
        /// <summary>
        /// Removes all leaderboards for the Title
        /// </summary>
        /// <param name="TitleID">unique TitleID in hex 0xXXXXXXXX</param>
        /// <returns>output of the LiveStats tool</returns>
        public static string StatsRemove(uint TitleID)
        {
            LiveStats liveStats = new LiveStats();
            liveStats.DeleteLeaderboards(TitleID);
            return liveStats.Output;
        }

        /// <summary>
        /// Deploys Xbox1 Leaderboards
        /// </summary>
        /// <param name="TitleID">unique TitleID in hex 0xXXXXXXXX</param>
        /// <param name="force">determines whether to use /force</param>
        /// <returns>output of the LiveStats tool</returns>
        public static string StatsDeployXbox1Stats(uint TitleID, bool force)
        {
            LiveStats liveStats = new LiveStats();
            liveStats.DeployXbox1Leaderboard(TitleID, force);
            return liveStats.Output;
        }

        /// <summary>
        /// Deploys Xbox 360 Leaderboards
        /// </summary>
        /// <param name="TitleID">unique TitleID in hex 0xXXXXXXXX</param>
        /// <param name="force">determines whether to use /force</param>
        /// <returns>output of the LiveStats tool</returns>
        public static string StatsDeployXbox360Stats(uint TitleID, bool force)
        {
            LiveStats liveStats = new LiveStats();
            liveStats.DeployXbox360Leaderboard(TitleID, force);
            return liveStats.Output;
        }

        /// <summary>
        /// Deploy Web Only Leaderboards
        /// </summary>
        /// <param name="TitleID">unique TitleID in hex 0xXXXXXXXX</param>
        /// <returns>output of the LiveStats tool</returns>
        public static string StatsDeployWebOnlyLeaderboard(uint TitleID)
        {
            LiveStats liveStats = new LiveStats();
            liveStats.DeployWebOnlyLeaderboard(TitleID);
            return liveStats.Output;
        }

        /// <summary>
        /// Move a single or ALL leaderboards from one server to another
        /// </summary>
        /// <param name="TitleID">unique TitleID in hex 0xXXXXXXXX</param>
        /// <param name="LeaderboardId">unique ID for a leaderboard</param>
        /// <param name="SourceServer">name of source server of the leaderboard</param>
        /// <param name="DestServer">name of the destination server</param>
        /// <returns>output of the LiveStats tool</returns>
        public static string StatsMoveLeaderboard(uint TitleID, int LeaderboardId, string SourceServer, string DestServer)
        {
            LiveStats liveStats = new LiveStats();
            liveStats.MoveLeaderboard(TitleID, LeaderboardId, SourceServer, DestServer);
            return liveStats.Output;
        }

        /// <summary>
        /// Returns the Leaderboard Configuration of a Title
        /// </summary>
        /// <param name="TitleID">unique TitleID in hex 0xXXXXXXXX</param>
        /// <returns>array of strings, each string is a leaderboard information</returns>
        public static string[] StatsReportConfiguration(uint TitleID)
        {
            LiveStats liveStats = new LiveStats();
            return liveStats.ReportConfiguration(TitleID);
        }

        /// <summary>
        /// Resets the Leaderboard data for a specific Leaderboard
        /// </summary>
        /// <param name="TitleID">unique TitleID in hex 0xXXXXXXXX</param>
        /// <param name="LeaderboardId">unique ID of the leaderboard</param>
        /// <returns>output of the LiveStats tool</returns>
        public static string StatsResetLeaderboard(uint TitleID, int LeaderboardId)
        {
            LiveStats liveStats = new LiveStats();
            liveStats.ResetLeaderboard(TitleID, LeaderboardId);
            return liveStats.Output;
        }

        /// <summary>
        /// Resets the leaderboard data for all leaderboards of a title
        /// </summary>
        /// <param name="TitleID">unique TitleID in hex 0xXXXXXXXX</param>
        /// <returns>output of the LiveStats tool</returns>
        public static string StatsResetAllLeaderboards(uint TitleID)
        {
            LiveStats liveStats = new LiveStats();
            liveStats.ResetAllLeaderboards(TitleID);
            return liveStats.Output;
        }

        /// <summary>
        /// Reloads the stats front door
        /// </summary>
        /// <returns>output of the LiveStats tool</returns>
        public static string StatsReloadFrontDoor()
        {
            LiveStats liveStats = new LiveStats();
            liveStats.ReloadFrontDoor();
            return liveStats.Output;
        }

        /// <summary>
        /// Reloads the stats web front door
        /// </summary>
        /// <returns>output of the LiveStats tool</returns>
        public static string StatsReloadWebStats()
        {
            LiveStats liveStats = new LiveStats();
            liveStats.ReloadWebStats();
            return liveStats.Output;
        }
        #endregion

        #region Match Functions
        /// <summary>
        /// Used for clearing out the XMatch Databases for a specific titleID
        /// Currently p_match_title_delete in npdb only works for xbox 1 titles, when that is 
        /// fixed to also do 360 titles, we can use that instead of duplicating that effort in
        /// ClearMatchConfiguration.  
        /// </summary>
        /// <param name="titleID">The TitleID to have it's Tables and SP's removed from XMatch DB</param>
        public static void MatchClearAllDB(uint titleID)
        {
            Database.XMatch matchDB = new ServerTestFramework.Database.XMatch();

            string[] servers = Config.GetServerListByInterface(Interface.xmatch);
            if (servers[0].Trim() != "")
            {
                foreach (string server in servers)
                {
                    matchDB.ConnectToServer(server);
                    matchDB.ClearMatchConfiguration(titleID);
                    matchDB.Close();
                }
            }
        }
        #endregion

        #region SystemCheck Functions
        /// <summary>
        /// Runs systemcheck against an inputfile and outputs the result (xml) file
        /// </summary>
        /// <param name="ConfigFile">inputfile with 1 healthcheck url per line</param>
        /// <param name="OutputFile">output file with the returns from the health urls</param>
        /// <param name="Threads">number of threads to run checks in parallel (must be positive)</param>
        /// <param name="Timeout">time before the systemcheck tool gives up</param>
        /// <returns>output of the sytemcheck tool</returns>
        public static string SystemCheckRunSystemCheck(string ConfigFile, string OutputFile, string Threads, string Timeout)
        {
            SystemCheck sysCheckTool = new SystemCheck();
            sysCheckTool.ConfigFilePath = ConfigFile;
            sysCheckTool.OutFilePath = OutputFile;
            sysCheckTool.CallUrl(Threads, Timeout);

            return sysCheckTool.Output;
        }

        /// <summary>
        /// Runs systemcheck against an inputfile and outputs the result (xml) file with default threads and timeout
        /// </summary>
        /// <param name="ConfigFile">inputfile with 1 healthcheck url per line</param>
        /// <param name="OutputFile">output file with the returns from the health urls</param>
        /// <returns>output of the sytemcheck tool</returns>
        public static string SystemCheckRunSystemCheck(string ConfigFile, string OutputFile)
        {
            SystemCheck sysCheckTool = new SystemCheck();
            sysCheckTool.ConfigFilePath = ConfigFile;
            sysCheckTool.OutFilePath = OutputFile;
            sysCheckTool.CallUrl();

            return sysCheckTool.Output;
        }

        /// <summary>
        /// Reloads all frontdoors
        /// </summary>
        /// <returns>output of the sytemcheck tool</returns>
        public static string SystemCheckReloadFrontDoors()
        {
            SystemCheck sysCheckTool = new ServerTestFramework.STFTools.SystemCheck();
            sysCheckTool.Reloadfd();

            return sysCheckTool.Output;
        }

        /// <summary>
        /// Reloads all frontdoors (times out if no response after Timeout)
        /// </summary>
        /// <param name="Timeout">time before the systemcheck tool gives up</param>
        /// <returns>output of the sytemcheck tool</returns>
        public static string SystemCheckReloadFrontDoors(string Timeout)
        {
            SystemCheck sysCheckTool = new ServerTestFramework.STFTools.SystemCheck();
            sysCheckTool.Reloadfd(Timeout);

            return sysCheckTool.Output;
        }
        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup1\ClientTools\LiveMatch.cs ===
using System;
using System.IO;
using System.Diagnostics;
using System.Text;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.STFTools
{
    /// <summary>
    /// Utility class for running the LiveMatch tool.
    /// </summary>
    public class LiveMatch : ClientToolBase
    {
        private string _scriptFile = "";
        private bool _noReloadFrontDoors = false;
        private int _typeID = -1;
        private int _modeID = -1;
        private int _rrID = -1;

        public LiveMatch() : base(Path.Combine(DefaultBasePath, "LiveMatch.exe")) { }
        public LiveMatch(string liveMatchPath) : base(liveMatchPath) { }
        public LiveMatch(string liveMatchPath, bool isRemote) : base(liveMatchPath, isRemote) { }
        public LiveMatch(string liveMatchPath, bool isRemote, string remoteServer) : base(liveMatchPath, isRemote, remoteServer) { }

        /// <summary>
        /// Gets or sets the name of the SQL file generated when using the /script option.
        /// </summary>
        public string ScriptFile
        {
            get { return _scriptFile; }
            set { _scriptFile = (value == null ? "" : value); }
        }

        /// <summary>
        /// Gets or sets the typeid
        /// </summary>
        public int TypeID
        {
            get { return _typeID; }
            set { _typeID = value; }
        }

        /// <summary>
        /// Gets or sets the modeid
        /// </summary>
        public int ModeID
        {
            get { return _modeID; }
            set { _modeID = value; }
        }

        /// <summary>
        /// Gets or sets the rrid
        /// </summary>
        public int RRID
        {
            get { return _rrID; }
            set { _rrID = value; }
        }

        /// <summary>
        /// Turn on or off the /noreload option.  Defaults at false so that it does not use switch.
        /// </summary>
        public bool NoReloadFrontDoors
        {
            get { return _noReloadFrontDoors; }
            set { _noReloadFrontDoors = value; }
        }

        /// <summary>
        /// Deploys the matchmaking database(s) for the current title.
        /// </summary>
        /// <param name="dropTable">
        /// Flag indicating whether to drop the current match table.
        /// </param>
        /// <param name="scriptSQL">
        /// Flag indicating whether to write the SQL commands to a local file instead of to the databases.
        /// The name of the file can be specified using the ScriptFile property.
        /// </param>
        public void DeployMatchServer(uint titleId, bool dropTable, bool scriptSQL, bool removeMode , string newModeServer)
        {
            StringBuilder arguments = new StringBuilder(128);

            arguments.AppendFormat("/DeployMatch /titleid:0x{0:x}", titleId);

            if (dropTable)
            {
                arguments.Append(" /droptable");
            }

            if (scriptSQL)
            {
                arguments.AppendFormat(" /script:{0}", _scriptFile);
            }

            // If the _noReloadFrontDoors is true, then specify /noreload
            if (_noReloadFrontDoors)
            {
                arguments.Append(" /noreload");
            }

            if (removeMode)
            {
                arguments.Append(" /removemode");
            }

            if ((newModeServer != null) && (newModeServer != ""))
            {
                arguments.AppendFormat(" /newmodeserver:{0}", newModeServer);
            }

            RunThrowOnFailure<LiveMatchException>(arguments.ToString(), "Matchmaking configuration failed.");
        }


        /// <summary>
        /// Used for different migrations for an interface bucket
        /// </summary>
        /// <param name="titleID">TitleId used for migration</param>
        /// <param name="migrationState">
        /// 0 = StartMigrationForBucket
        /// 1 = MigrationStatusForBucket
        /// 2 = ExpediteMigrationForBucket
        /// 3 = EndMigrationForBucket
        /// </param>
        /// <param name="destServerName">Destination server, only required for StartMigrationForBucket</param>
        public void MatchMigrationBucket(uint titleID, int migrationState, string destServerName)
        {
            StringBuilder arguments = new StringBuilder(128);

            arguments.AppendFormat("/titleid:0x{0:x}", titleID);

            switch (migrationState)
            {
                case 0:
                    arguments.Append(" /StartMigrationForBucket");
                    break;
                case 1:
                    arguments.Append(" /MigrationStatusForBucket");
                    break;
                case 2:
                    arguments.Append(" /ExpediteMigrationForBucket");
                    break;
                case 3:
                    arguments.Append(" /EndMigrationForBucket");
                    break;
                default:
                    break;
            }

            if (_typeID != -1)
            {
                arguments.AppendFormat(" /type:{0}", _typeID);
            }

            if (_modeID != -1)
            {
                arguments.AppendFormat(" /mode:{0}", _modeID);
            }

            if (_rrID != -1)
            {
                arguments.AppendFormat(" /rrid:{0}", _rrID);
            }

            if ((destServerName != null) && (destServerName != ""))
            {
                arguments.AppendFormat(" /dest:{0}", destServerName);
            }

            RunThrowOnFailure<LiveMatchException>(arguments.ToString(), "Matchmaking configuration failed.");
        }

        /// <summary>
        /// Used for different title migrations
        /// </summary>
        /// <param name="titleID">TitleId used for migration</param>
        /// <param name="migrationState">
        /// 0 = StartMigrationForTitle
        /// 1 = MigrationStatusForTitle
        /// 2 = ExpediteMigrationForTitle
        /// 3 = EndMigrationForTitle
        /// </param>
        /// <param name="destServerName">Destination server, only required for StartMigrationForBucket</param>
        public void MatchMigrationTitle(uint titleID, int migrationState, string sourceServerName, string destServerName)
        {
            StringBuilder arguments = new StringBuilder(128);

            arguments.AppendFormat("/titleid:0x{0:x}", titleID);

            switch (migrationState)
            {
                case 0:
                    arguments.Append(" /StartMigrationForTitle");
                    break;
                case 1:
                    arguments.Append(" /MigrationStatusForTitle");
                    break;
                case 2:
                    arguments.Append(" /ExpediteMigrationForTitle");
                    break;
                case 3:
                    arguments.Append(" /EndMigrationForTitle");
                    break;
                default:
                    break;
            }

            if ((sourceServerName != null) && (sourceServerName != ""))
            {
                arguments.AppendFormat(" /source:{0}", sourceServerName);
            }

            if ((destServerName != null) && (destServerName != ""))
            {
                arguments.AppendFormat(" /dest:{0}", destServerName);
            }

            RunThrowOnFailure<LiveMatchException>(arguments.ToString(), "Matchmaking configuration failed.");
        }

        #region ServerMigrationCutForFall
        /*
        /// <summary>
        /// Used for different migrations for a server migration
        /// </summary>
        /// <param name="titleID">TitleId used for migration</param>
        /// <param name="migrationState">
        /// 0 = StartMigrationForServer
        /// 1 = MigrationStatusForServer
        /// 2 = ExpediteMigrationForServer
        /// 3 = EndMigrationForServer
        /// </param>
        /// <param name="destServerName">Destination server, only required for StartMigrationForServer</param>
        public void MatchMigrationServer(uint titleID, int migrationState, string sourceServerName, string destServerName)
        {
            StringBuilder arguments = new StringBuilder(128);

            arguments.AppendFormat("/titleid:0x{0:x}", titleID);

            switch (migrationState)
            {
                case 0:
                    arguments.Append(" /StartMigrationForServer");
                    break;
                case 1:
                    arguments.Append(" /MigrationStatusForServer");
                    break;
                case 2:
                    arguments.Append(" /ExpediteMigrationForServer");
                    break;
                case 3:
                    arguments.Append(" /EndMigrationForServer");
                    break;
                default:
                    break;
            }

            if ((sourceServerName != null) && (sourceServerName != ""))
            {
                arguments.AppendFormat(" /source:{0}", sourceServerName);
            }

            if ((destServerName != null) && (destServerName != ""))
            {
                arguments.AppendFormat(" /dest:{0}", destServerName);
            }

            if (_liveMatchProcess.Run(arguments.ToString()) != 0)
                throw new LiveMatchException("Matchmaking configuration failed.", _liveMatchProcess.Output);
        }
        */
        #endregion

        /// <summary>
        /// Used for adding a RR bucket to an existing type/mode
        /// </summary>
        /// <param name="titleID">TitleId used for migration</param>
        /// <param name="serverName">The server that is going to be added for round robin</param>
        public void MatchAddRRBucket(uint titleID, string serverName)
        {
            StringBuilder arguments = new StringBuilder(128);

            arguments.AppendFormat("/AddRRBucket /titleid:0x{0:x}", titleID);

            if (_typeID != -1)
            {
                arguments.AppendFormat(" /type:{0}", _typeID);
            }

            if (_modeID != -1)
            {
                arguments.AppendFormat(" /mode:{0}", _modeID);
            }

            if ((serverName != null) && (serverName != ""))
            {
                arguments.AppendFormat(" /server:{0}", serverName);
            }

            RunThrowOnFailure<LiveMatchException>(arguments.ToString(), "Matchmaking configuration failed.");
        }

        /// <summary>
        /// Used to begin draining the top round robined bucket.  Draining buckets no longer add
        /// sessions to them.
        /// </summary>
        /// <param name="titleID">TitleId used for migration</param>
        public void MatchDrainTopRRBucket(uint titleID)
        {
            StringBuilder arguments = new StringBuilder(128);

            arguments.AppendFormat("/drainTopRRBucket /titleid:0x{0:x}", titleID);

            if (_typeID != -1)
            {
                arguments.AppendFormat(" /type:{0}", _typeID);
            }

            if (_modeID != -1)
            {
                arguments.AppendFormat(" /mode:{0}", _modeID);
            }

            RunThrowOnFailure<LiveMatchException>(arguments.ToString(), "Matchmaking configuration failed.");
        }

        /// <summary>
        /// Used to begin draining the top round robined bucket.  Draining buckets no longer add
        /// sessions to them.
        /// </summary>
        /// <param name="titleID">TitleId used for migration</param>
        public void MatchRemoveTopRRBucket(uint titleID, bool force)
        {
            StringBuilder arguments = new StringBuilder(128);

            arguments.AppendFormat("/removeTopRRBucket /titleid:0x{0:x}", titleID);

            if (_typeID != -1)
            {
                arguments.AppendFormat(" /type:{0}", _typeID);
            }

            if (_modeID != -1)
            {
                arguments.AppendFormat(" /mode:{0}", _modeID);
            }

            if (force)
            {
                arguments.Append(" /force");
            }

            RunThrowOnFailure<LiveMatchException>(arguments.ToString(), "Matchmaking configuration failed.");
        }


        /// <summary>
        /// Adds a new matchmaking server.
        /// </summary>
        /// <param name="serverName">
        /// Name of the server to which matchmaking tables and queries will be added.
        /// </param>
        public void AddMatchServer(uint xboxtitleID, string serverName)
        {
            RunThrowOnFailure<LiveMatchException>(String.Format("/titleid:0x{0:x} /add:{1}", xboxtitleID, serverName), "Failed to add match server.");
        }

        /// <summary>
        /// Deletes an existing matchmaking server.
        /// </summary>
        /// <param name="serverName">
        /// Name of the server to remove from the match titles table.
        /// </param>
        public void DeleteMatchServer(uint xboxtitleID, string serverName)
        {
            RunThrowOnFailure<LiveMatchException>(String.Format("/titleid:0x{0:x} /delete:{1}", xboxtitleID, serverName), "Failed to delete match server.");
        }

        /// <summary>
        /// Allows direct passing of Arguments on command line to LiveMatch, primarily used for negative testing.
        /// </summary>
        /// <param name="arguments">String to pass to LiveMatch</param>
        public void RunLiveMatch(string arguments)
        {
            RunThrowOnFailure<LiveMatchException>(arguments, "LiveMatch failed");
        }

        /// <summary>
        /// Static method for running Live Match with the default settings of titleid and the droptable option.
        /// </summary>
        /// <param name="titleID">The TitleID to which you want to run LiveMatch for</param>
        public static void RunLiveMatchDefault(uint titleID)
        {
            LiveMatch liveMatch = new LiveMatch();
            liveMatch.RunThrowOnFailure<LiveMatchException>(String.Format("/titleid:0x{0:x} /droptable", titleID), "Live Match Default failed.");
        }

    }

    public class LiveMatchException : ProcessException
    {
        public LiveMatchException(string message, string output) : base("LiveMatch", message, output) {}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup1\ClientTools\SPUT.cs ===
using System;
using System.IO;
using System.Diagnostics;
using System.Text;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.STFTools
{
	/// <summary>
	/// Utility class for running SPUT.
	/// </summary>
	public class SPUT
	{
        const string DefaultSPUTPath = "D:\\webroot\\xbltools";

        private ProcessWrapper _SPUTProcess;
        private string _csvFile = "";

        public SPUT()
		{
            _SPUTProcess = new ProcessWrapper("SPUT", Path.Combine(DefaultSPUTPath, "SPUT.exe"));
        }

        public SPUT(string toolPath) : this()
        {
        _SPUTProcess.ExecutablePath = Path.GetFullPath(toolPath);
        }

        /// <summary>
        /// Gets or sets path to SPUT
        /// </summary>
        public string SPUTPath
        {
            get { return _SPUTProcess.ExecutablePath; }
            set { _SPUTProcess.ExecutablePath = value; }
        }

        /// <summary>
        /// Gets or sets the CSV File to use when running SPUT.  Can be NULL.
        /// </summary>
        public string CSVFile
        {
            get { return _csvFile; }
            set { _csvFile = value; }
        }

        /// <summary>
        /// Gets the output text from the most recent run of SPUT.
        /// </summary>
        public string Output
        {
            get { return _SPUTProcess.Output; }
        }

        /// <summary>
        /// Writes the titleID for the specified serialNum to the table
        /// </summary>
        /// <param name="serialNum">The serial number of the Xbox</param>
        /// <param name="titleID">The title ID or value to set.  Must have length of 1,4 or 8.</param>
        public void ChangeTitleID(string serialNum, string titleID)
        {
            string args = String.Format("/serialNum:{0} /titleid:{1}", serialNum, titleID);
            if (_SPUTProcess.Run(args) != 0)
            {
                throw new SPUTException("SPUT Failed.", _SPUTProcess.Output);
            }
        }

        /// <summary>
        /// Lookup the titleID associated with an xbox.
        /// </summary>
        /// <param name="serialNum">The serial number of the Xbox</param>
        /// <returns>Output returned from SPUT.</returns>
        public string DumpTitleID(string serialNum)
        {
            string titleID;
            string args = String.Format("/serialNum:{0} /dump", serialNum);
            if (_SPUTProcess.Run(args) != 0)
            {
                throw new SPUTException("SPUT Failed.", _SPUTProcess.Output);
            }
            titleID = _SPUTProcess.Output;
            titleID = titleID.Substring(titleID.IndexOf(":")+1).Trim();
            return titleID;
        }

        /// <summary>
        /// Runs SPUT specifying CSV File
        /// </summary>
        /// <param name="fileName">CSV file to be used</param>
        public void RunSPUTFile(string fileName)
        {
            RunSPUTFile(fileName, null);
        }

        /// <summary>
        /// Runs SPUT specifying File that is set in CSVFIle Property
        /// </summary>
        public void RunSPUTFile()
        {
            RunSPUTFile(_csvFile, null);
        }

        /// <summary>
        /// Runs SPUT specifying File and TitleID to use
        /// </summary>
        /// <param name="fileName">CSV File of Serial numbers</param>
        /// <param name="titleID">Title ID to use or override</param>
        public void RunSPUTFile(string fileName, string titleID)
        {
            string args;
            if (titleID == null)
            {
                args = String.Format("/file:{0}", fileName);
            }
            else
            {
                args = String.Format("/file:{0} /titleid:{1}", fileName, titleID);
            }

            if (_SPUTProcess.Run(args) != 0)
            {
                throw new SPUTException("SPUT Failed.", _SPUTProcess.Output);
            }
        }

        /// <summary>
        /// Allows running SPUT with custom argument string.
        /// Mainly used for negative testing.
        /// </summary>
        /// <param name="arguments">Argument string to be used when calling SPUT.</param>
        public void RunSPUT(string arguments)
        {
            if (_SPUTProcess.Run(arguments) != 0)
            {
                throw new SPUTException("SPUT Failed.", _SPUTProcess.Output);
            }
        }

	}

    public class SPUTException : ProcessException
    {
        public SPUTException() : base("SPUT") {}
        public SPUTException(string message) : base("SPUT", message) {}
        public SPUTException(string message, Exception innerException) : base("SPUT", message, innerException) {}
        public SPUTException(string message, string output) : base("SPUT", message, output) {}
        public SPUTException(string message, string output, Exception innerException) :
            base("SPUT", message, output, innerException) {}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup1\ClientTools\LiveContent.cs ===
using System;
using System.IO;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.STFTools
{
	/// <summary>
	/// Utility class for running the LiveContent tool.
	/// </summary>
	public class LiveContent
	{
		
		private ProcessWrapper _liveContentProcess;
		const string _defaultLiveContentPath = "D:\\webroot\\xbltools";
	
		//Info about the files to be propped
		private string _packagePath = "";
		private uint _titleId = 0;
		private string _offerPath = "";
		private ulong _offerId = 0;
		private string _offerPath2 = "";
		private ulong _offerId2 = 0;

		//flag arguments
		private string _isDefaultOffer = "";
	        private string _useDefaultOffer = "";
		private const string _overwrite = "/overwrite";  //This should always be on.
		private string _sites = "/site:1";
		private string _startDateFlag = "";
		private string _endDateFlag = "";
		private string _shares = "";
		private string _xrls = "";
		
		public enum updateType {selective, global, noflag};
		private string _updateFlag = "";
			
		public enum dbType {all, uodb, productdb, noflag};
		private string _targetFlag = "";

        public enum platformType { xbox1, xenon, pc };

		public LiveContent()
		{
			_liveContentProcess = new ProcessWrapper("LiveContent", Path.Combine(_defaultLiveContentPath, "LiveContent.exe"));
		}

		/// <summary>
		/// Define a non-default location for the LiveContent exe.  This location includes the exe in the path.
		/// </summary>
		/// <param name="liveContentPath">
		/// Path to the executable, including the exe filename.
		/// </param>
		public LiveContent(string liveContentPath) : this()
		{
			_liveContentProcess.ExecutablePath = Path.GetFullPath(liveContentPath);
		}

		public int Timeout {
			get { return _liveContentProcess.ExecutionTimeout; }
			set { _liveContentProcess.ExecutionTimeout = value; }
		}

		/// <summary>
		/// Gets the output after the LiveContent process has been run.
		/// </summary>
		public string Output
		{
			get { return _liveContentProcess.Output; }
		}

		/// <summary>
		/// Gets or sets the /_isDefaultOffer flag for a future run of LiveContent.
		/// </summary>
		public bool IsDefaultOffer
		{
			get { return (_isDefaultOffer != "");  }
			set { _isDefaultOffer = value ? "/isdefaultOffer:yes" : ""; }
		}

        /// <summary>
        /// Gets or sets the /usedefaultoffer flag for a future run of LiveContent
        /// </summary>
        public bool UseDefaultOffer
        {
            get { return (_useDefaultOffer != ""); }
            set { _useDefaultOffer = value ? "/usedefaultoffer" : ""; }
        }

		/// <summary>
		/// Gets or sets the site flag for a future run of LiveContent.
		/// </summary>
		public string Sites
		{
			get { return _sites;  }
			set { _sites = value; }
		}

		/// <summary>
		/// Gets or sets the start date flag for a future run of LiveContent.
		/// </summary>
		public string StartDateFlag
		{
			get { return _startDateFlag;  }
			set { _startDateFlag = value; }
		}

		/// <summary>
		/// Gets or sets the end date flag for a future run of LiveContent.
		/// </summary>
		public string EndDateFlag
		{
			get { return _endDateFlag;  }
			set { _endDateFlag = value; }
		}

		/// <summary>
		/// Gets or sets the _shares flag for a future run of LiveContent.
		/// </summary>
		public string Shares
		{
			get { return _shares;  }
			set { _shares = value; }
		}

		/// <summary>
		/// Gets or sets the _sites flag for a future run of LiveContent.
		/// </summary>
		public string Xrls
		{
			get { return _xrls;  }
			set { _xrls = value; }
		}

		/// <summary>
		/// Sets the update flag for a future run of LiveContent.
		/// </summary>
		/// <param name="type">
		/// Possible choices for the /update: option.
		/// </param>
		public void setUpdateFlag(updateType type)
		{
			switch (type) 
			{
				case updateType.selective:
					_updateFlag = "/update:selective";
					break;
				case updateType.global:
					_updateFlag = "/update:full";
					break;
				case updateType.noflag:
					_updateFlag= "";
					break;
			}
		}

		/// <summary>
		/// Sets the package and associated titleID for a future run of LiveContent.
		/// </summary>
		/// <param name="path">
		/// File path which will be passed in the /package: argument.
		/// </param>
		/// <param name="_titleId">
		/// OfferId which will be passed in the /titleid: argument.
		/// </param>
		public void SetPackageFile(string path, uint _titleId) 
		{
			_packagePath = path;
			this._titleId=_titleId;
		}
		
		/// <summary>
		/// Sets the optional first offer and its associated offerID
		/// for a future run of LiveContent.
		/// </summary>
		/// <param name="path">
		/// File path which will be passed in the /offerfile: argument.
		/// </param>
		/// <param name="_offerId">
		/// OfferId which will be passed in the /offerid: argument.
		/// </param>
		public void SetOfferFile(string path, ulong _offerId) 
		{
			_offerPath = path;
			this._offerId = _offerId;
		}

		/// <summary>
		/// Sets the optional second offer and its associated offerID
		/// for a future run of LiveContent.
		/// </summary>
		/// <param name="path">
		/// File path which will be passed in the /offerfile2: argument.
		/// </param>
		/// <param name="_offerId">
		/// OfferId which will be passed in the /offerid2: argument.
		/// </param>
		public void SetOfferFile2(string path, ulong _offerId)
		{
			_offerPath2 = path;
			this._offerId2=_offerId;
		}

		/// <summary>
		/// Sets the _targetFlag string from the given dbType.
		/// </summary>
		/// <param name="selectedDB">
		/// Possible choices for the /targetDB: option.
		/// </param>
		public void setTargetFlag(dbType selectedDB) 
		{
			switch (selectedDB)
			{
				case dbType.uodb:
					_targetFlag = "/targetdb:uodb";
					break;
				case dbType.productdb:
					_targetFlag = "/targetdb:productdb";
					break;
				case dbType.all:
					_targetFlag = "/targetdb:all";
					break;
				case dbType.noflag:
					_targetFlag = "";
					break;
			}
		}
		/// <summary>
		/// Returns a combined string of all the flags used when propping 
		/// content(and not autoupdates).  If in the future flags are added, they should be 
		/// added to this string as well.
		/// </summary>
		private string CombineFlagsForContent() 
		{
			return _isDefaultOffer + " " +
		        _useDefaultOffer + " " +
				_overwrite + " " +
				_sites + " " +
				_startDateFlag + " " +
				_endDateFlag + " " +
				_updateFlag + " " +
				_targetFlag;
		}

		/// <summary>
		/// Expects SetPackageFile to be set.  Optionally expects SetOfferFile, SetOfferFile2, 
		/// IsDefaultOffer, etc. to be called to set other parameters.  WARNING:Content files
		/// require an offer file, and should not be run without them.
		/// </summary>
		public void Deploy360Package() 
		{
			string arguments = "/action:build ";
			if ((_packagePath== "") || (_titleId == 0)) 
			{
				//TODO: error out somehow.
			} 
			else { arguments += String.Format("/package:{0} /titleid:0x{1:x} ", _packagePath, _titleId); }

			if (_offerPath != "" && !UseDefaultOffer) 
			{
				arguments += String.Format("/offerfile:{0} /offerid:{1:x} ", _offerPath, _offerId);
			}

			if (_offerPath2 != "" && !UseDefaultOffer)
			{
				arguments += String.Format("/offerfile2:{0} /offerid2:{1:x} ", _offerPath2, _offerId2);
			}
			arguments += CombineFlagsForContent();

			if (_liveContentProcess.Run(arguments) != 0) /* || (grep some kind of error string in output) */
				throw new LiveContentException("Prop of Xbox360 Content or AutoUpdate failed.", _liveContentProcess.Output);			
		}

		/// <summary>
		/// Expects SetPackageFile to be set.  Optionally expects SetOfferFile and
		/// IsDefaultOffer to be called to set other parameters.
		/// </summary>
		public void DeployXbox1Content() 
		{
			string arguments = "/action:xbox1content ";

			if ((_packagePath== "") || (_titleId == 0)) 
			{
				//TODO: error out somehow.
			} 
			else { arguments += String.Format("/package:{0} /titleid:0x{1:x} ", _packagePath, _titleId); }

			if (_offerPath != "") 
			{
				arguments += String.Format("/offerfile:{0} /offerid:{1:x} ", _offerPath, _offerId);
			}
			arguments += CombineFlagsForContent();

			if (_liveContentProcess.Run(arguments) != 0) /* || (grep some kind of error string in output) */
				throw new LiveContentException("Prop of Xbox1 Content failed.", _liveContentProcess.Output);			
		}		

		/// <summary>
		/// Deploys an xbox1 AutoUpdate.  This expects SetPackageFile to be called beforehand.
		/// Arguments it does not use will be dropped.
		/// </summary>
		public void DeployXbox1AutoUpdate() 
		{
			string arguments = "/action:xbox1update ";
			if ((_packagePath== "") || (_titleId == 0)) 
			{
				//TODO: error out somehow.
			} 
			else { arguments += String.Format("/package:{0} /titleid:0x{1:x} " + _sites + " " + _updateFlag + " ", _packagePath, _titleId); }
			arguments += _overwrite + " ";
		
			if (_liveContentProcess.Run(arguments) != 0) /* || (grep some kind of error string in output) */
				throw new LiveContentException("Prop of Xbox1 AutoUpdate failed.", _liveContentProcess.Output);			
		}

		/// <summary>
		/// Converts a selective update into a global autoupdate.
		/// </summary>
		/// <param name="_titleId">
		/// The titleid to apply this change.
		/// </param>
		/// <param name="oldVersion">
		/// The version number that the selective update begins.
		/// </param>
		/// <param name="newVersion">
		/// The version number to which the selective update will update.
		/// </param>
        /// <param name="platform">
        /// The platform this update applies.
        /// </param>
        public void MakeAutoUpdateFull(uint titleId, uint oldVersion, uint newVersion, platformType platform) 
		{
			string arguments = "/action:makefull ";
			arguments += String.Format("/titleid:0x{0:x} /package:{1:x}{2:x} ", titleId, Hex8(oldVersion), Hex8(newVersion));
            switch (platform)
            {
                case platformType.xbox1:
                    arguments += "/platform:xbox1 ";
                    break;
                case platformType.xenon:
                    arguments += "/platform:xenon ";
                    break;
                case platformType.pc:
                    arguments += "/platform:pc ";
                    break;
            }
			arguments += _sites;
			if (_liveContentProcess.Run(arguments) != 0) /* || (grep some kind of error string in output) */
				throw new LiveContentException("Attempt to make selective update a global one failed.", _liveContentProcess.Output);
		}

        /// <summary>
        /// Makes a zero paded hex value.  ie 00000101
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        private string Hex8(uint value)
        {
            string newVal;
            newVal = String.Format("0000000{0:x}", value);
            return newVal.Substring(newVal.Length - 8);
        }

		/// <summary>
		/// Runs LiveContent with a string of command-line arguments and nothing else.
		/// </summary>
		/// <param name="arguments">
		/// String of command line arguments.
		/// </param>
		public void RunWithOnlyStringArguments(string arguments) 
		{
			if (_liveContentProcess.Run(arguments) != 0) /* || (grep some kind of error string in output) */
				throw new LiveContentException("Run with specific user arguments failed.", _liveContentProcess.Output);			
		}
	}
	
	public class LiveContentException : ProcessException
	{
		public LiveContentException() : base("LiveContent") {}
		public LiveContentException(string message) : base("LiveContent", message) {}
		public LiveContentException(string message, Exception innerException) : base("LiveContent", message, innerException) {}
		public LiveContentException(string message, string output) : base("LiveContent", message, output) {}
		public LiveContentException(string message, string output, Exception innerException) :
			base("LiveContent", message, output, innerException) {}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup\XLASTFactory\XLASTFactory.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using System.Xml.Serialization;
using System.Text;
using ServerTestFramework.Utilities;
using ServerTestFramework.STFTools.ConfigFiles;

namespace ServerTestFramework.STFTools
{
    public enum XLASTTitleType
    {
        SystemTitle = 0,
        FullGame,
        DemoTitle,
        ArcadeTitle
    }

    public enum XLASTLanguage
    {
        English = 0,
        French,
        German,
        Italian,
        Japanese,
        Korean,
        Polish,
        Portuguese,
        Russian,
        Spanish,
        TraditionalChinese
    }

    public partial class XLASTFactory
    {
        public static XLASTSchemaVersion SchemaVersion00 = new XLASTSchemaVersion(1, 0);
        public static XLASTSchemaVersion SchemaVersion01 = new XLASTSchemaVersion(1, 1);
        public static XLASTSchemaVersion SchemaVersion02 = new XLASTSchemaVersion(1, 2);
        public static XLASTSchemaVersion SchemaVersion03 = new XLASTSchemaVersion(1, 3);
        
        // These are the CLSIDs used in XLAST files
        private static string GameConfigProjectCLSID = "{77E1A64F-5837-489B-AF8E-E4BA0FDACE7D}";
        private static string LocalizedStringsCLSID = "{BB833025-27FE-4BBD-87B6-DECD32039CED}";
        private static string LocalizedStringCLSID = "{F88D7D87-B2C0-452D-977D-297D70400AFF}";
        private static string PresenceCLSID = "{4EDB88EF-4341-49E4-B0AC-80CEA33F8EB8}";
        private static string PresenceModeCLSID = "{B94DA191-595F-40BB-99F1-3A78DAD90D9F}";
        private static string PropertiesCLSID = "{84CF9B0C-8512-4E46-B20F-D26A55A7AC6E}";
        private static string PropertyCLSID = "{43CE4FA7-6DE9-4F37-A929-49BFE63CBAAA}";
        private static string ContextsCLSID = "{7F6BA3D8-BB76-46CC-AD28-A4E0C8D6E1EF}";
        private static string ContextCLSID = "{7F343825-DBB8-4BC0-ACF2-533263622341}";
        private static string GameModesCLSID = "{A4C90625-725A-4DD2-B26B-E7F33F9DA808}";
        private static string ImagesCLSID = "{5B5F14C2-99F6-409A-BE85-15137524035C}";
        private static string GamerPicturesCLSID = "{3A23EFFB-83E1-415E-A7F2-1BD3004F83F5}";
        private static string AchievementsCLSID = "{42B49E61-A989-4D38-A1E3-74859D420C15}";
        private static string AchievementCLSID = "{3B0C2ED0-B7E7-4129-B35D-A90639E96DAC}";
        private static string StatsViewsCLSID = "{7FD2B836-2D93-490B-96C9-AEE936158AE8}";
        private static string StatsViewCLSID = "{6B341F2D-7A8A-43BC-AABF-949D6B9F28C7}";
        private static string MatchmakingCLSID = "{9D99E88A-2774-422A-8558-9B7487A37732}";
        private static string ConstantsCLSID = "{9DEE98C4-441C-4103-861B-464DF03B36B1}";
        private static string SchemaCLSID = "{7134D48F-9957-4515-850B-A7426E51345F}";
        private static string QueriesCLSID = "{50783AEA-2512-4F78-938B-F8DB911A0F9A}";
        private static string QueryCLSID = "{7FEE4CB1-F3F0-48BF-9CA1-F1B2306E32E3}";

        private RandomEx _rnd = new RandomEx();

        public XLASTFactory()
        {
            InitLocalizedStrings();
        }

        public XboxLiveSubmissionProject Create(XLASTSchemaVersion schema)
        {
            XboxLiveSubmissionProject xlast = new XboxLiveSubmissionProject();
            xlast.Version = "2.00.0000.0";
            xlast.GameConfigProject.clsid = GameConfigProjectCLSID;
            xlast.GameConfigProject.schemaVersion = schema.ToString();
            xlast.GameConfigProject.projectVersion = "1.00.0000.0";
            return xlast;
        }
        public XboxLiveSubmissionProject Create(XLASTSchemaVersion schema, XLASTTitleType titleType)
        {
            XboxLiveSubmissionProject xlast = new XboxLiveSubmissionProject();
            xlast.Version = "2.00.0000.0";
            xlast.GameConfigProject.clsid = GameConfigProjectCLSID;
            xlast.GameConfigProject.schemaVersion = schema.ToString();
            xlast.GameConfigProject.projectVersion = "1.00.0000.0";
            xlast.GameConfigProject.titleType = (uint)titleType;
            return xlast;
        }
        public XboxLiveSubmissionProject Create(XLASTSchemaVersion schema, XLASTTitleType titleType,
            uint titleId, string titleName, XLASTLanguage defaultLanguage)
        {
            XboxLiveSubmissionProject xlast = new XboxLiveSubmissionProject();
            xlast.Version = "2.00.0000.0";
            xlast.GameConfigProject.clsid = GameConfigProjectCLSID;
            xlast.GameConfigProject.schemaVersion = schema.ToString();
            xlast.GameConfigProject.projectVersion = "1.00.0000.0";
            xlast.GameConfigProject.titleType = (uint)titleType;
            xlast.GameConfigProject.titleName = titleName;
            xlast.GameConfigProject.titleId = "0x" + titleId.ToString("X8");

            CreateLocalizedStrings(xlast, defaultLanguage); // This one must come first
            CreateImages(xlast);
            CreateProductInformation(xlast);
            CreatePresence(xlast);
            CreateProperties(xlast);
            CreateContexts(xlast);
            CreateGameModes(xlast);
            CreateAchievements(xlast);
            CreateGamerPictures(xlast);
            CreateMatchmaking(xlast);
            if (titleType == XLASTTitleType.ArcadeTitle)
            {
                CreateStatsViews(xlast);
            }

            return xlast;
        }

        public void UpdateVersion(XboxLiveSubmissionProject xlast)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            string[] ver = xlast.GameConfigProject.projectVersion.Split('.');
            xlast.GameConfigProject.projectVersion = string.Format("{0}.{1}.{2:d4}.{3}", ver[0], ver[1], (ushort.Parse(ver[2]) + 1), ver[3]);
        }

        /// <summary>
        /// Static method to deserialize an XLAST file into a hierarchy of objects.
        /// </summary>
        /// <param name="xlastFile">The name of the XLAST file to deserialize.</param>
        /// <returns>An XboxLiveSubmissionProject object that describes the XLAST file.</returns>
        //public static XboxLiveSubmissionProject FromXml(string xlastFile)
        //{
        //    if (xlastFile == null)
        //    {
        //        throw new ArgumentNullException("xlastFile");
        //    }

        //    if (!File.Exists(xlastFile))
        //    {
        //        return null;
        //    }

        //    StreamReader reader = null;
        //    XboxLiveSubmissionProject xlast = null;
        //    try
        //    {
        //        reader = new StreamReader(xlastFile);
        //        xlast = FromXml(reader);
        //    }
        //    finally
        //    {
        //        if (reader != null)
        //        {
        //            reader.Close();
        //        }
        //    }

        //    return xlast;
        //}

        /// <summary>
        /// Static method to deserialize an XLAST XML stream into a hierarchy of objects.
        /// </summary>
        /// <param name="xlastXml">A TextReader object that contains the raw XML of an XLAST file.</param>
        /// <returns>An XboxLiveSubmissionProject object that describes the XLAST XML data.</returns>
        //public static XboxLiveSubmissionProject FromXml(TextReader xlastXml)
        //{
        //    if (xlastXml == null)
        //    {
        //        return null;
        //    }

        //    XmlTextReader xmlReader = null;
        //    XmlSerializer serializer = null;
        //    XboxLiveSubmissionProject xlast = null;
        //    try
        //    {
        //        xmlReader = new XmlTextReader(xlastXml);
        //        serializer = new XmlSerializer(typeof(XboxLiveSubmissionProject));
        //        xlast = (serializer.Deserialize(xmlReader) as XboxLiveSubmissionProject);
        //    }
        //    finally
        //    {
        //        if (xmlReader != null)
        //        {
        //            xmlReader.Close();
        //        }
        //    }

        //    return xlast;
        //}

        //public static void ToXml(XboxLiveSubmissionProject xlast, string xlastFile)
        //{
        //    if (xlastFile == null)
        //    {
        //        throw new ArgumentNullException("xlastFile");
        //    }
        //    if (xlast == null)
        //    {
        //        throw new ArgumentNullException("xlast");
        //    }

        //    /*
        //     * We need to go through the pain of creating an XmlDocument from
        //     * the serialized XML stream so that when we can duplicate the
        //     * format of the XLAST file when it's saved from XLAST.
        //     */
        //    StringWriter sw = new StringWriter();
        //    XmlDocument doc = new XmlDocument();
        //    XmlTextWriter xtw = new XmlTextWriter(xlastFile, System.Text.Encoding.Unicode);
        //    xtw.Formatting = Formatting.Indented;
        //    xtw.Indentation = 1;
        //    xtw.IndentChar = (char)0x9;
        //    try
        //    {
        //        XmlSerializer serializer = new XmlSerializer(typeof(XboxLiveSubmissionProject));
        //        serializer.Serialize(sw, xlast);
        //        doc.LoadXml(sw.ToString());
        //        doc.Save(xtw);
        //    }
        //    finally
        //    {
        //        xtw.Close();
        //        sw.Close();
        //    }
        //}
    }

    public sealed class XLASTSchemaVersion
    {
        private byte _major;
        private byte _minor;

        public XLASTSchemaVersion(byte major, byte minor)
        {
            _major = major;
            _minor = minor;
        }

        public byte Major
        {
            get { return _major; }
        }

        public byte Minor
        {
            get { return _minor; }
        }

        public override string ToString()
        {
 	         return string.Format("{0}.{1:00}.0000.0", _major, _minor);
        }

        public override bool Equals(object obj)
        {
            if (obj is XLASTSchemaVersion)
            {
                return ((obj as XLASTSchemaVersion)._major == _major &&
                        (obj as XLASTSchemaVersion)._minor == _minor);
            }
            return false;
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup1\ClientTools\LiveStats.cs ===
using System;
using System.IO;
using System.Diagnostics;
using System.Text;
using System.Collections;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.STFTools
{
    /// <summary>
    /// Utility class for running the LiveStats tool.
    /// </summary>
    public class LiveStats
    {
	    // Some commands allow the leaderboard id to be "ALL".
	    // Use this constant to specify that value.
	    public const int ALL_LEADERBOARDS = -1;
        const string DefaultLiveStatsPath = "D:\\webroot\\xbltools";

        private ProcessWrapper _liveStatsProcess;
        private Report _report;

		public LiveStats()
		{
            _liveStatsProcess = new ProcessWrapper("LiveStats", Path.Combine(DefaultLiveStatsPath, "LiveStats.exe"));
            _report = new Report("LiveStats");
        }

		public LiveStats(string liveStatsPath) : this()
		{
			_liveStatsProcess.ExecutablePath = Path.GetFullPath(liveStatsPath);
		}

		/// <summary>
		/// Gets or sets the fully-qualified name of the LiveStats executable.
		/// </summary>
		public string LiveStatsPath
		{
			get { return _liveStatsProcess.ExecutablePath; }
            set
            {
                _liveStatsProcess.ExecutablePath = Path.GetFullPath(value);
                _liveStatsProcess.WorkingDirectory = Path.GetDirectoryName(_liveStatsProcess.ExecutablePath);
            }
        }

        /// <summary>
        /// Gets or sets the working directory for LiveStats
        /// </summary>
        public string WorkingDirectory
        {
            get { return _liveStatsProcess.WorkingDirectory; }
            set
            {
                if (value != null)
                {
                    _liveStatsProcess.WorkingDirectory = Path.GetFullPath(value);
                }
                else
                {
                    _liveStatsProcess.WorkingDirectory = null;
                }
            }
        }

        /// <summary>
        /// Gets or sets the number of milliseconds to allow LiveStats to run before killing the process.
        /// </summary>
        public int Timeout
        {
            get { return _liveStatsProcess.ExecutionTimeout; }
            set { _liveStatsProcess.ExecutionTimeout = value; }
        }

        /// <summary>
        /// Gets the output text from the most recent run of LiveStats.
        /// </summary>
        public string Output
        {
            get { return _liveStatsProcess.Output; }
        }

		/// <summary>
		/// Deploys the leaderboards for an Xbox1 title.
		/// </summary>
		/// <param name="force">Flag indicating whether or not to include the /force argument.</param>
		public void DeployXbox1Leaderboard(uint titleId, bool force)
		{
			string arguments = String.Format("/deployxboxlb /titleid:0x{0:x8}", titleId);

			if (force)
				arguments += " /force";

			if (_liveStatsProcess.Run(arguments) != 0)
				throw new LiveStatsException("Deploying an Xbox1 leaderboard failed.", _liveStatsProcess.Output);
		}

		/// <summary>
		/// Deploys the leaderboards for an Xbox 360 title.
		/// </summary>
		/// <param name="force">Flag indicating whether or not to include the /force argument.</param>
		public void DeployXbox360Leaderboard(uint titleId, bool force)
		{
			string arguments = String.Format("/deploylb /titleid:0x{0:x8}", titleId);

			if (force)
				arguments += " /force";

			if (_liveStatsProcess.Run(arguments) != 0)
				throw new LiveStatsException("Deploying an Xbox 360 leaderboard failed.", _liveStatsProcess.Output);
		}

		/// <summary>
		/// Deletes the leaderboards from the Web DB and re-deploys them.
		/// </summary>
		public void DeployWebOnlyLeaderboard(uint titleId)
		{
			if (_liveStatsProcess.Run(String.Format("/deploywebdbonlylb /titleid:0x{0:x8}", titleId)) != 0)
				throw new LiveStatsException("Deploying to Web only failed.", _liveStatsProcess.Output);
		}

		/// <summary>
		/// Moves one or all leaderboards from one server to another.
		/// </summary>
		/// <param name="leaderboardId">
		/// ID of the leaderboard to move. Use the ALL_LEADERBOARDS constant to move all leaderboards.
		/// </param>
		/// <param name="sourceServer">
		/// The name of the server on which the leaderboard currently resides.
		/// </param>
		/// <param name="destServer">
		/// The name of the server to which the leaderboard will be moved.
		/// </param>
		public void MoveLeaderboard(uint titleId, int leaderboardId, string sourceServer, string destServer)
		{
			if (_liveStatsProcess.Run(String.Format("/movelb /titleid:0x{0:x8} /lbid:{1} /source:{2} /dest:{3}",
				titleId, (leaderboardId == ALL_LEADERBOARDS ? "ALL" : leaderboardId.ToString()),
				sourceServer, destServer)) != 0)
			{
				throw new LiveStatsException("Leaderboard move failed.", _liveStatsProcess.Output);
			}
		}

        /// <summary>
        /// Reports the leaderboard configuration for a title.
        /// </summary>
        /// <param name="leaderboardId">
        /// The ID of the leaderboard to report.
        /// </param>
        public string[] ReportConfiguration(uint titleId)
		{
            ArrayList lbArray = new ArrayList();
            string [] returnString;
            int stringEndLoc;

            if (_liveStatsProcess.Run(String.Format("/reportconfiguration /titleid:0x{0:x8}",
                titleId)) != 0)
            {
                throw new LiveStatsException("Report Configuration failed.", _liveStatsProcess.Output);
            }

            // Parse the output for the leaderboard information
            if (_liveStatsProcess.Output.IndexOf("No leaderboards are configured in NPDB for titleID") > 0)
                return null;
            string parseOutput = _liveStatsProcess.Output;
            if (parseOutput.IndexOf("ServerName") < 0)
            {
                // Couldn't find the list of leaderboards
                return null;
            }

            // Find the Start of the Leadboard List and End, We're includind the Column header bar for now. To remove just skip the first line.
            parseOutput = parseOutput.Substring(parseOutput.IndexOf("ServerName"));
            parseOutput = parseOutput.Substring(0, parseOutput.LastIndexOf("Succesfully Executed reportconfiguration") - 2); // -2 to remove the blank line at the end
            //_report.Debug("Leaderboard List:{0}{1}", Environment.NewLine, parseOutput);

            // Find the End of the first leaderboard line and start getting entries
            stringEndLoc = parseOutput.IndexOf(Environment.NewLine);
            while (stringEndLoc > 0) // Once the first char is new line we're at the end of the list or we're at the end
            {
                // Get the First line and add it to the array list
                lbArray.Add(parseOutput.Substring(0, stringEndLoc));
                //_report.Debug("Entry {0}: {1}", lbArray.Count, lbArray[lbArray.Count-1]);

                // Trim the First line out of the remaining string and get the next End of Line Char loc
                parseOutput = parseOutput.Substring(stringEndLoc + 2);
                stringEndLoc = parseOutput.IndexOf(Environment.NewLine);
            }

            returnString = (string []) lbArray.ToArray(typeof(string));
            return returnString;
		}

		/// <summary>
		/// Resets the data for a single leaderboard.
		/// </summary>
		/// <param name="leaderboardId">
		/// The ID of the leaderboard to reset.
		/// </param>
		public void ResetLeaderboard(uint titleId, int leaderboardId)
		{
			if (_liveStatsProcess.Run(String.Format("/resetlb /titleid:0x{0:x8} /lbid:{1}",
				titleId, (leaderboardId == ALL_LEADERBOARDS ? "ALL" : leaderboardId.ToString()))) != 0)
			{
				throw new LiveStatsException("Reset leaderboard failed.", _liveStatsProcess.Output);
			}
		}

		/// <summary>
		/// Resets the data for all leaderboards in the current title.
		/// </summary>
		public void ResetAllLeaderboards(uint titleId)
		{
			if (_liveStatsProcess.Run(String.Format("/resettitle /titleid:0x{0:x8}", titleId)) != 0)
				throw new LiveStatsException("Reset all leaderboards failed.", _liveStatsProcess.Output);
		}

		/// <summary>
		/// Deletes all stats data and leaderboard definitions for the current title.
		/// </summary>
		public void DeleteLeaderboards(uint titleId)
		{
			if (_liveStatsProcess.Run(String.Format("/deletetitle /titleid:0x{0:x8}", titleId)) != 0)
				throw new LiveStatsException("Delete leaderboards failed.", _liveStatsProcess.Output);
		}

		/// <summary>
		/// Reloads the Stats front door.
		/// </summary>
		public void ReloadFrontDoor()
		{
			if (_liveStatsProcess.Run("/reloadfrontdoor") != 0)
				throw new LiveStatsException("Reload front door failed.", _liveStatsProcess.Output);
		}

		/// <summary>
		/// Reloads the Web stats front door.
		/// </summary>
		public void ReloadWebStats()
		{
			if (_liveStatsProcess.Run("/reloadwebstats") != 0)
				throw new LiveStatsException("Reload web stats failed.", _liveStatsProcess.Output);
		}

        /// <summary>
        /// Sets up a clean clips CRON job for the specified Xbox360 title id
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <param name="hoursFromNow">The number of hours to wait before running the CRON job.</param>
        public void CleanClip(uint titleId, int hoursFromNow)
        {
            if (_liveStatsProcess.Run(string.Format("/cleanclip /titleid:0x{0:x8} /hoursfromnow:{1}",
                titleId, hoursFromNow)) != 0)
            {
                throw new LiveStatsException("CleanClip failed.", _liveStatsProcess.Output);
            }
        }

        /// <summary>
        /// Sets up a clean clips CRON job for the specified Xbox1 title id
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <param name="hoursFromNow">The number of hours to wait before running the CRON job.</param>
        public void CleanXboxClip(uint titleId, int hoursFromNow)
        {
            if (_liveStatsProcess.Run(string.Format("/cleanxboxclip /titleid:0x{0:x8} /hoursfromnow:{1}",
                titleId, hoursFromNow)) != 0)
            {
                throw new LiveStatsException("CleanXboxClip failed.", _liveStatsProcess.Output);
            }
        }

        public void SetToReadOnly(uint titleId, int leaderboardId, string server)
        {
            StringBuilder args = new StringBuilder();

            args.AppendFormat("/settoreadonly /titleid:0x{0:x8} /lbid:{1} /server:{2}", titleId,
                leaderboardId == LiveStats.ALL_LEADERBOARDS ? "ALL" : leaderboardId.ToString(), server);
            if (_liveStatsProcess.Run(args.ToString()) != 0)
            {
                throw new LiveStatsException("SetToReadOnly failed.", _liveStatsProcess.Output);
            }
        }

        public void SetToReadWrite(uint titleId, int leaderboardId, string server)
        {
            StringBuilder args = new StringBuilder();

            args.AppendFormat("/settoreadwrite /titleid:0x{0:x8} /lbid:{1} /server:{2}", titleId,
                leaderboardId == LiveStats.ALL_LEADERBOARDS ? "ALL" : leaderboardId.ToString(), server);
            if (_liveStatsProcess.Run(args.ToString()) != 0)
            {
                throw new LiveStatsException("SetToReadWrite failed.", _liveStatsProcess.Output);
            }
        }

        public void Unload(uint titleId, int leaderboardId, string server)
        {
            StringBuilder args = new StringBuilder();

            args.AppendFormat("/unload /titleid:0x{0:x8} /lbid:{1} /server:{2}", titleId,
                leaderboardId == LiveStats.ALL_LEADERBOARDS ? "ALL" : leaderboardId.ToString(), server);
            if (_liveStatsProcess.Run(args.ToString()) != 0)
            {
                throw new LiveStatsException("Unload failed.", _liveStatsProcess.Output);
            }
        }

        public void Load(uint titleId, int leaderboardId, string server)
        {
            StringBuilder args = new StringBuilder();

            args.AppendFormat("/load /titleid:0x{0:x8} /lbid:{1} /server:{2}", titleId,
                leaderboardId == LiveStats.ALL_LEADERBOARDS ? "ALL" : leaderboardId.ToString(), server);
            if (_liveStatsProcess.Run(args.ToString()) != 0)
            {
                throw new LiveStatsException("Load failed.", _liveStatsProcess.Output);
            }
        }
	}

	public class LiveStatsException : ProcessException
	{
		public LiveStatsException() : base("LiveStats") {}
		public LiveStatsException(string message) : base("LiveStats", message) {}
		public LiveStatsException(string message, Exception innerException) : base("LiveStats", message, innerException) {}
		public LiveStatsException(string message, string output) : base("LiveStats", message, output) {}
		public LiveStatsException(string message, string output, Exception innerException) :
			base("LiveStats", message, output, innerException) {}

        public override string Message
        {
            get { return string.Format("{0}\r\nLiveStats Output:\r\n{1}\r\nEnd LiveStats Output\r\n",
                      base.Message, base.ProcessOutput); }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup1\ClientTools\SystemCheck.cs ===
using System;
using System.IO;
using System.Diagnostics;
using System.Text;
using System.Collections;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.STFTools
{
    /// <summary>
    /// Utility class for running the SystemCheck tool.
    /// </summary>
    public class SystemCheck
    {
        const string DefaultSystemCheckPath = "D:\\webroot\\xbltools";
        const string DefaultThreads = "5";
        const string DefaultTimeout = "60000";

        private string _configfilePath = "";
        private string _outfilePath = "";
        private ProcessWrapper _systemCheckProcess;
        private Report _report;

        public SystemCheck()
        {
            _systemCheckProcess = new ProcessWrapper("SystemCheck", Path.Combine(DefaultSystemCheckPath, "SystemCheck.exe"));
            _report = new Report("SystemCheck");
        }

        public SystemCheck(string systemCheckPath)
            : this()
        {
            SystemCheckPath = systemCheckPath;
        }

        /// <summary>
        /// Gets or sets the fully-qualified name of the SystemCheck executable.
        /// </summary>
        public string SystemCheckPath
        {
            get { return _systemCheckProcess.ExecutablePath; }
            set
            {
                _systemCheckProcess.ExecutablePath = Path.GetFullPath(value);
                _systemCheckProcess.WorkingDirectory = Path.GetDirectoryName(_systemCheckProcess.ExecutablePath);
            }
        }

        /// <summary>
        /// Gets or sets the working directory for SystemCheck
        /// </summary>
        public string WorkingDirectory
        {
            get { return _systemCheckProcess.WorkingDirectory; }
            set
            {
                if (value != null)
                {
                    _systemCheckProcess.WorkingDirectory = Path.GetFullPath(value);
                }
                else
                {
                    _systemCheckProcess.WorkingDirectory = null;
                }
            }
        }

        /// <summary>
        /// Gets or sets the number of milliseconds to allow LiveStats to run before killing the process.
        /// </summary>
        public int Timeout
        {
            get { return _systemCheckProcess.ExecutionTimeout; }
            set { _systemCheckProcess.ExecutionTimeout = value; }
        }

        /// <summary>
        /// Gets or sets the fully-qualified name of the Config file used during SystemCheck running 
        /// </summary>
        public string ConfigFilePath
        {
            get { return _configfilePath; }
            set
            {
                if (value != null)
                {
                    _configfilePath = Path.GetFullPath(value);
                }
                else
                {
                    _configfilePath = "";
                }
            }
        }

        /// <summary>
        /// Gets or sets the fully-qualified name of the Output file used during SystemCheck running 
        /// </summary>
        public string OutFilePath
        {
            get { return _outfilePath; }
            set
            {
                if (value != null)
                {
                    _outfilePath = Path.GetFullPath(value);
                }
                else
                {
                    _outfilePath = "";
                }
            }
        }

        /// <summary>
        /// Gets the output text from the most recent run of SystemCheck.
        /// </summary>
        public string Output
        {
            get { return _systemCheckProcess.Output; }
        }

        /// <summary>
        /// Runs SystemCheck with /reloadfd parameter to reload the front doord.
        /// </summary>
        public void Reloadfd()
        {
            Reloadfd("");
        }

        /// <summary>
        /// Runs SystemCheck with /reloadfd parameter to reload the front doord.
        /// </summary>
        /// <param name="timeout">timeout (in ms) to specify with the /timeout parameter. Optional.</param>
        public void Reloadfd(string timeout)
        {
            int exitCode;
            StringBuilder arguments = new StringBuilder();

            arguments.AppendFormat("/reloadfd");

            if (timeout != "")
            {
                arguments.AppendFormat(" /timeout:{0}", timeout);
            }

            exitCode = _systemCheckProcess.Run(arguments.ToString());
            if (exitCode == 0)
            {
                _report.Debug(_systemCheckProcess.Output);
            }
            else
            {
                throw new SystemCheckException("SystemCheck failed to Reload the Front Doors.", _systemCheckProcess.Output);
            }
        }

        /// <summary>
        /// Runs SystemCheck with a configfile and outputfile.
        /// </summary>
        public void CallUrl()
        {
            CallUrl(DefaultThreads, DefaultTimeout);
        }

        /// <summary>
        /// Runs SystemCheck with a configfile and outputfile.
        /// </summary>
        /// <param name="threads"># of threads to speciffy with the /threads parameter. Optional.</param>
        /// <param name="timeout">timeout (in ms) to specify with the /timeout parameter. Optional.</param>
        public void CallUrl(uint threads, uint timeout)
        {
            CallUrl(threads.ToString(), timeout.ToString());
        }

        /// <summary>
        /// Runs SystemCheck with a configfile, # of threads, timout, and outputfile.
        /// </summary>
        /// <param name="threads"># of threads to speciffy with the /threads parameter. Optional.</param>
        /// <param name="timeout">timeout (in ms) to specify with the /timeout parameter. Optional.</param>
        public void CallUrl(string threads, string timeout)
        {
            int exitCode;
            StringBuilder arguments = new StringBuilder();

            arguments.AppendFormat("/configfile:{0} /threads:{1} /timeout:{2}", _configfilePath, threads, timeout);

            if (_outfilePath != "")
            {
                arguments.AppendFormat(" /outfile:{0}", _outfilePath);
            }

            exitCode = _systemCheckProcess.Run(arguments.ToString());
            // SystemCheck returns 1 on success and -1 on failure.
            if (exitCode != 1)
            {
                throw new SystemCheckException("SystemCheck failed to run.", _systemCheckProcess.Output);
            }
        }


    }

    public class SystemCheckException : ProcessException
    {
        public SystemCheckException() : base("SystemCheck") { }
        public SystemCheckException(string message) : base("SystemCheck", message) { }
        public SystemCheckException(string message, Exception innerException) : base("SystemCheck", message, innerException) { }
        public SystemCheckException(string message, string output) : base("SystemCheck", message, output) { }
        public SystemCheckException(string message, string output, Exception innerException)
            :
            base("SystemCheck", message, output, innerException) { }

        public override string Message
        {
            get
            {
                return string.Format("{0}\r\nSystemCheck Output:\r\n{1}\r\nEnd SystemCheck Output\r\n",
                    base.Message, base.ProcessOutput);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup1\ClientTools\XblCfg.cs ===
using System;
using System.IO;
using System.Diagnostics;
using System.Text;
using System.Net;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;

using xonline.common.config;

namespace ServerTestFramework.STFTools
{
    /// <summary>
    /// Utility class for running XblCfg
    /// </summary>
    public class XblCfg
    {
        // Known blob names
        public const string Blobs_DrmWhitelist      = "xbos_wmdrm_whitelist";

        // Search the path?
        const string DefaultXblCfgPath = "";


        private static int          XblCfgInstance = 0;
        private ProcessWrapper      _Process;
        private string              _TempFile;

        public XblCfg()
        {
            _Process = new ProcessWrapper("XblCfg", Path.Combine(DefaultXblCfgPath, "XblCfg.exe"));
            int id = System.Threading.Interlocked.Increment(ref XblCfgInstance);
            _TempFile = "xblcfg_temp_" + id + ".txt";

            // Turn off verbose output in ProcessWrapper
            ProcessWrapper.ro.DisableFilter(Report.DEBUG);
            ProcessWrapper.ro.DisableFilter(Report.INFO);
        }

        public XblCfg(string toolPath) : this()
        {
            _Process.ExecutablePath = Path.GetFullPath(toolPath);
        }

        /// <summary>
        /// Gets or sets path to XblCfg
        /// </summary>
        public string XblCfgPath
        {
            get { return _Process.ExecutablePath; }
            set { _Process.ExecutablePath = value; }
        }

        /// <summary>
        /// Gets the output text from the most recent run of XblCfg.
        /// </summary>
        public string Output
        {
            get { return _Process.Output; }
        }

        /// <summary>
        /// Add blob to npdb..t_config_blobs
        /// </summary>
        /// <param name="name">The name of the blob</param>
        /// <param name="blob">The blob data</param>
        public void AddBlob(string name, byte[] blob)
        {
            if (blob == null)
                return;

            File.WriteAllBytes(_TempFile, blob);

            try
            {
                string args = String.Format(
                    "-blob -add -name:{0} -file:{1}",
                    name,
                    _TempFile);

                if (_Process.Run(args) != 0)
                {
                    throw new XblCfgException("XblCfg Failed.", _Process.Output);
                }
            }
            finally
            {
                if (File.Exists(_TempFile))
                    File.Delete(_TempFile);
            }
        }

        /// <summary>
        /// Delete blob in npdb..t_config_blobs
        /// </summary>
        /// <param name="name">The name of the blob to delete</param>
        public void DeleteBlob(string name)
        {
            string args = String.Format(
                "-blob -delete -name:{0}",
                name);

            if (_Process.Run(args) != 0)
            {
                throw new XblCfgException("XblCfg Failed.", _Process.Output);
            }
        }

        /// <summary>
        /// Gets blob from npdb..t_config_blobs
        /// </summary>
        /// <param name="name">The name of the blob</param>
        /// <param name="blob">The blob data retrieved</param>
        public void GetBlob(string name, out byte[] blob)
        {
            blob = null;
            try
            {
                string args = String.Format(
                    "-blob -get -name:{0} -file:{1}",
                    name,
                    _TempFile);

                if (_Process.Run(args) != 0)
                {
                    throw new XblCfgException("XblCfg Failed.", _Process.Output);
                }
                
                if (File.Exists(_TempFile))
                    blob = File.ReadAllBytes(_TempFile);
            }
            finally
            {
                if (File.Exists(_TempFile))
                    File.Delete(_TempFile);
            }
        }


        /// <summary>
        /// Allows running XblCfg with custom argument string.
        /// Mainly used for negative testing.
        /// </summary>
        /// <param name="arguments">Argument string to be used when calling XblCfg.</param>
        public void RunXblCfg(string arguments)
        {
            if (_Process.Run(arguments) != 0)
            {
                throw new XblCfgException("XblCfg Failed.", _Process.Output);
            }
        }


        /// <summary>
        /// Reloads the xbos servers after changing the wmdrm whitelist blob.
        /// Helper function.
        /// </summary>
        public void ReloadWmdrmSettings()
        {
            IPEndPoint[] serverIps = Global.XEnv.GetInterface(Interface.xbos_int);
            foreach (IPEndPoint ip in serverIps)
            {
                string response;
                ManagementConsole.Execute(ip, "e :xbos reloadwmdrmsettings", out response);
                //Global.RO.Debug("[Xmgmt] Executed \"e :xbos reloadwmdrmsettings\" on 
                //{0}, response: {1}", ip.ToString(), response);
            }
        }



    }

    public class XblCfgException : ProcessException
    {
        public XblCfgException() : base("XblCfg") {}
        public XblCfgException(string message) : base("XblCfg", message) {}
        public XblCfgException(string message, Exception innerException) : base("XblCfg", message, innerException) {}
        public XblCfgException(string message, string output) : base("XblCfg", message, output) {}
        public XblCfgException(string message, string output, Exception innerException) :
            base("XblCfg", message, output, innerException) {}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup1\ConfigFiles\ConfigFileSerializer.cs ===
using System;
using System.IO;
using System.Xml;
using System.Xml.Serialization;

/// <summary>
/// Utility class for serializing and deserializing various configuration files.
/// </summary>
public static class ConfigFileSerializer
{
    public static object FromXml(Type configFileType, string configFilePath)
    {
        if (null == configFilePath)
        {
            throw new ArgumentNullException("configFilePath");
        }

        if (!File.Exists(configFilePath))
        {
            return null;
        }

        object configObj = null;
        StreamReader reader = null;
        using (reader = new StreamReader(configFilePath))
        {
            XmlTextReader xmlReader = null;
            XmlSerializer serializer = null;
            using (xmlReader = new XmlTextReader(reader))
            {
                serializer = new XmlSerializer(configFileType);
                configObj = serializer.Deserialize(xmlReader);
            }
        }

        return configObj;
    }

    public static void ToXml(string configFilePath, object configObject)
    {
        if (null == configFilePath)
        {
            throw new ArgumentNullException("configFilePath");
        }

        if (configObject == null)
            return;

        /*
         * We need to go through the pain of creating an XmlDocument from
         * the serialized XML stream so that when we can duplicate the
         * format of the config file when it's saved from the tools.
         */
        XmlDocument doc = new XmlDocument();
        using (XmlTextWriter xtw = new XmlTextWriter(configFilePath, System.Text.Encoding.Unicode))
        {
            xtw.Formatting = Formatting.Indented;
            xtw.Indentation = 2;
            xtw.IndentChar = ' ';

            XmlSerializer serializer = new XmlSerializer(configObject.GetType());
            using (StringWriter sw = new StringWriter())
            {
                serializer.Serialize(sw, configObject);
                doc.LoadXml(sw.ToString());
                doc.Save(xtw);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup1\ClientTools\MsgTool.cs ===
using System;
using System.IO;
using System.Diagnostics;
using System.Text;
using ServerTestFramework.Utilities;
using System.Collections;

namespace ServerTestFramework.STFTools
{
    /// <summary>
    /// Utility class for running MsgTool.
    /// </summary>
    public class MsgTool
    {
        const string DefaultMsgToolPath = @"D:\webroot\xbltools";

        private ProcessWrapper _MsgToolProcess;
        
        public MsgTool()
        {
            _MsgToolProcess = new ProcessWrapper("MsgTool", Path.Combine(DefaultMsgToolPath, "MsgTool.exe"));
        }

        public MsgTool(string toolPath) : this()
        {
            _MsgToolProcess.ExecutablePath = Path.GetFullPath(toolPath);
        }

        /// <summary>
        /// Gets or sets path to MsgTool
        /// </summary>
        public string MsgToolPath
        {
            get { return _MsgToolProcess.ExecutablePath; }
            set { _MsgToolProcess.ExecutablePath = value; }
        }

        /// <summary>
        /// Gets the output text from the most recent run of MsgTool.
        /// </summary>
        public string Output
        {
            get { return _MsgToolProcess.Output; }
        }


        /// <summary>
        /// Adds a string to the table.
        /// </summary>
        /// <param name="stringID">ID of the string to be added</param>
        /// <param name="text">The text of the string in the appropriate language.</param>
        /// <param name="lang">The language of this instance of the message.</param>
        /// <remarks> Command Line: 
        /// MSGTOOL /addstring /id:[id] /text:[text] /lang:[language]<br/> 
        /// You must add a string to the table before you send it via SystemMessage, UserMessage,
        /// or TitleMessage since these take the ID of the string.<br/>
        /// Msgtool generates the following for this command line:
        /// D:\msgtool /addstring /id:50001 /text:"This is a test." /lang:1
        /// <code>
        /// Adding string - id:50001,lang:1,text:This is a test.
        /// String Service address 10.20.1.5:11020
        /// String Service address 10.20.1.5:11020
        /// 
        /// 
        /// String added successfully.
        /// 
        /// </code></remarks>
        public void AddString(uint stringID, string text, StringLanguage lang)
        {
            string args = String.Format("/addstring /id:{0} /text:\"{1}\" /lang:{2}", stringID, text, (int)lang);
            if (_MsgToolProcess.Run(args) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }

        // MSGTOOL /addsystemmsg /id:[id] /expiration:[expiration] /recommended
        /// <summary>
        /// Sends a string to all users when they sign in their language or the default.
        /// Has the recommended option for sending to Xbox 1.
        /// </summary>
        /// <param name="stringID">ID of the string to be sent</param>
        /// <param name="expiration">When this message will expire from the server</param>
        /// <param name="recommended">Xbox 1 setting.  No effect on Xbox 360</param>
        /// <remarks>Add system message generates the following output from the command line:
        /// msgtool /addsystemmsg /id:50001 /expiration:"5/17/2006"
        /// <code>
        /// Checking for existence of string 50001...
        /// Adding system message - id:50001,expiration:5/17/2006
        /// System message added successfully.
        /// 
        /// </code>
        /// </remarks>
        public void SendSystemMsg(uint stringID, string expiration, bool recommended)
        {
            string args = String.Format("/addsystemmsg /id:{0} /expiration:{1}", stringID, expiration);
            if (recommended)
            {
                args=String.Concat(args, " /recommended");
            }
            if (_MsgToolProcess.Run(args) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }

        /// <summary>
        /// Sends a string to all users when they sign in their language or the default.
        /// Defaults as required on Xbox1.
        /// </summary>
        /// <param name="stringID">ID of the string to be sent</param>
        /// <param name="expiration">When this message will expire from the server</param>
        /// <remarks>Command Line: MSGTOOL /addsystemmsg /id:[id] /expiration:[expiration]<br/>
        /// Adds the specified string to the table to be sent to all users.
        /// Add system message generates the following output from the command line:
        /// msgtool /addsystemmsg /id:50001 /expiration:"5/17/2006"
        /// <code>
        /// Checking for existence of string 50001...
        /// Adding system message - id:50001,expiration:5/17/2006
        /// System message added successfully.
        /// 
        /// </code>
        /// </remarks>
        public void SendSystemMsg(uint stringID, string expiration)
        {
            string args = String.Format("/addsystemmsg /id:{0} /expiration:{1}", stringID, expiration);
            if (_MsgToolProcess.Run(args) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }

        // MSGTOOL /enumsysmsg
        /// <summary>
        /// Enumerate all the System Messages in the queue
        /// </summary>
        /// <returns>MessageEntries collection of the sent messages</returns>
        /// <remarks>
        /// Return is formatted like this: (Blank line appears to be output before and after.
        /// <code>
        ///     
        /// Enumerating System Messages...
        /// 
        /// TitleID, MsgID, Sent, ExpireDate, Description
        /// 0, 1074107393, 5/16/2006 10:45:58 PM, 5/16/2006 11:59:58 PM, Xbox Live
        ///
        /// End Enumeration.
        ///         
        /// </code> OR <code>
        ///       
        /// Enumerating System Messages...
        /// There were no messages in the system message queue.
        ///        
        /// </code>                                         */
        /// </remarks>
        public MessageEntries EnumSystemMsg()
        {
            MessageEntries sysMsgs = new MessageEntries();

            if (_MsgToolProcess.Run("/enumsysmsg") != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
            String[] output=_MsgToolProcess.Output.Split('\n');
            if (output[2] == "There were no messages in the system message queue.")
            {
                return sysMsgs;
            }
            int idx = 4;
            while (idx < output.Length && output[idx].Trim() != "")
            {
                sysMsgs.Add(new MessageEntry(output[idx]));
                idx++;
            }
            
            return sysMsgs;
        }

        // MSGTOOL /addtitlemsg /id:[id] /title:[titleid] /expiration:[expiration] [/recommended]
        /// <summary>
        /// Sends a message to all users of a specified title
        /// </summary>
        /// <param name="stringID">ID of previously added string to be sent</param>
        /// <param name="titleID">TitleID</param>
        /// <param name="expiration">Expiration date of the message</param>
        /// <remarks>The following was generated from this command line: msgtool /addtitlemsg /id:50001 /title:0xFFFE07D0 /expiration:"5/20/2006"
        /// <code>
        /// Checking for existence of string 50001...
        /// Adding title message - title:0xFFFE07D0,id:50001,expiration:5/20/2006
        /// Title message added successfully.
        /// 
        /// </code>
        /// </remarks>
        public void SendTitleMsg(uint stringID, uint titleID, string expiration)
        {
            string args = String.Format("/addtitlemsg /id:{0} /title:0x{1:x} /expiration:{2}", stringID, titleID, expiration);
            if (_MsgToolProcess.Run(args) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }
        /// <summary>
        /// Sends a message to all users of a specified title
        /// </summary>
        /// <param name="stringID">ID of previously added string to be sent</param>
        /// <param name="titleID">TitleID</param>>
        /// <param name="expiration">Expiration date of the message</param>
        /// <param name="recommended">Xbox1 recommended message or required</param>
        /// <remarks>The following was generated from this command line: msgtool /addtitlemsg /id:50001 /title:0xFFFE07D0 /expiration:"5/20/2006"
        /// <code>
        /// Checking for existence of string 50001...
        /// Adding title message - title:0xFFFE07D0,id:50001,expiration:5/20/2006
        /// Title message added successfully.
        /// 
        /// </code>
        /// </remarks>
        public void SendTitleMsg(uint stringID, uint titleID, string expiration, bool recommended)
        {
            string args = String.Format("/addtitlemsg /id:{0} /title:0x{1:x} /expiration:{2}", stringID, titleID, expiration);
            if (recommended)
            {
                args=String.Concat(args, " /recommended");
            }
            if (_MsgToolProcess.Run(args) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }

        // MSGTOOL /enumtitlemsg /title:[titleid]
        /// <summary>
        /// Enumerate all the System Messages in the queue
        /// </summary>
        /// <returns>MessageEntries collection of the sent messages</returns>
        /// <remarks>
        /// Return is formatted like this: (Blank line appears to be output before and after.
        /// <code>
        ///     
        /// Enumerating System Messages...
        /// 
        /// TitleID, MsgID, Sent, ExpireDate, Description
        /// 0, 1074107393, 5/16/2006 10:45:58 PM, 5/16/2006 11:59:58 PM, Xbox Live
        ///
        /// End Enumeration.
        ///         
        /// </code> OR <code>
        ///       
        /// Enumerating System Messages...
        /// There were no messages in the system message queue.
        ///        
        /// </code>                                         */
        /// </remarks>
        public MessageEntries EnumTitleMsg(uint titleID)
        {
            MessageEntries titleMsgs = new MessageEntries();
            
            if (_MsgToolProcess.Run(String.Format("/enumtitlemsg /title:0x{0:x}",titleID)) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
            String[] output=_MsgToolProcess.Output.Split('\n');
            if (output[2] == "There were no messages in the system message queue.")
            {
                return titleMsgs;
            }
            int idx = 4;
            while (idx < output.Length && output[idx].Trim() != "")
            {
                titleMsgs.Add(new MessageEntry(output[idx]));
                idx++;
            }
            return titleMsgs;
        }

        // MSGTOOL /deletemsg /id:[id] /title:[[titleid | 0]]
        /// <summary>
        /// Deletes a message that was added with the Send functions
        /// </summary>
        /// <param name="messageID">ID of the message.  This is returned from the enumMsg methods</param>
        /// <param name="titleID">TitleID of the Message.  Use 0 for system messages</param>
        /// <remarks>
        /// The following message is output, no matter if the message is deleted, the titleID or the Message isn't found.
        /// <code>
        /// System or title message was successfully deleted or revoked.
        /// 
        /// </code>
        /// </remarks>
        public void DeleteMsg(uint messageID, uint titleID)
        {
            string args;
            if (titleID == 0)
            {
                args = String.Format("/deletemsg /id:{0} /title:0", messageID);
            }
            else
            {
                args = String.Format("/deletemsg /id:{0} /title:0x{1:x}", messageID, titleID);
            }
            if (_MsgToolProcess.Run(args) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }

        // MSGTOOL /revokemsg /id:[id] /title:[[titleid | 0]]
        /// <summary>
        /// Revokes a message that was added with the Send functions.  Removes any sent instances as well.
        /// </summary>
        /// <param name="messageID">ID of the message.  This is returned from the enumMsg methods</param>
        /// <param name="titleID">TitleID of the Message.  Use 0 for system messages</param>
        /// <remarks>
        /// The following was generated using this command line: msgtool /revokemsg /id:1074107393 /title:0
        /// <code>
        /// System or title message was successfully deleted or revoked.
        /// 
        /// </code>
        /// This same output is generated even if the id does not exist.
        /// </remarks>
        public void RevokeMsg(uint messageID, uint titleID)
        {
            string args;
            if (titleID == 0)
            {
                args = String.Format("/revokemsg /id:{0} /title:0", messageID);
            }
            else
            {
                args = String.Format("/revokemsg /id:{0} /title:0x{1:x}", messageID, titleID);
            }
            if (_MsgToolProcess.Run(args) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }

        // MSGTOOL /addusermsg /id:[id] [ /user:[puid] | /usertag:[tag] ] /expiration:[expiration] [/recommended]
        /// <summary>
        /// Adds a message for a specified User by PUID
        /// </summary>
        /// <param name="stringID">ID of String to be sent to user</param>
        /// <param name="userPUID">User's PUID</param>
        /// <param name="expiration">Message Expiration Date</param>
        /// <remarks>
        /// The following output was generated from this command line: msgtool /addusermsg /id:50001 /user:2533274801615275 /expiration:"5/24/2006" /recommended
        /// <code>
        /// Checking user information ...
        /// Checking for existence of string 50001...
        /// Adding user message - user:2533274801615275,id:50001,expiration:5/24/2006
        /// User message added successfully.
        /// 
        /// </code>
        /// </remarks>
        public void SendUserMsg(uint stringID, ulong userPUID, string expiration)
        {
            string args = String.Format("/addtitlemsg /id:{0} /user:{1} /expiration:{2}", stringID, userPUID, expiration);
            if (_MsgToolProcess.Run(args) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }
        /// <summary>
        /// Send a message for specified user on XBox 1 setting recommended by PUID
        /// </summary>
        /// <param name="stringID">ID of String to be sent to user</param>
        /// <param name="userPUID">User's PUID</param>
        /// <param name="expiration">Message Expiration Date</param>
        /// <param name="recommended">XBox 1 switch to make recommended or required</param>
        /// <remarks>
        /// The following output was generated from this command line: msgtool /addusermsg /id:50001 /usertag:coerwyn /expiration:"5/24/2006"
        /// <code>
        /// Checking user information ...
        /// Checking for existence of string 50001...
        /// Adding user message - user:2533274801615275,id:50001,expiration:5/24/2006
        /// User message added successfully.
        /// 
        /// </code>
        /// </remarks>
        public void SendUserMsg(uint stringID, ulong userPUID, string expiration, bool recommended)
        {
            string args = String.Format("/addtitlemsg /id:{0} /user:{1} /expiration:{2}", stringID, userPUID, expiration);
            if (recommended)
            {
                args=String.Concat(args, " /recommended");
            }
            if (_MsgToolProcess.Run(args) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }
        /// <summary>
        /// Adds a message for a specified User by GamerTag
        /// </summary>
        /// <param name="stringID">ID of String to be sent to user</param>
        /// <param name="gamerTag">User's GamerTag</param>
        /// <param name="expiration">Message Expiration Date</param>
        /// <remarks>
        /// The following output was generated from this command line: msgtool /addusermsg /id:50001 /usertag:coerwyn /expiration:"5/24/2006"
        /// <code>
        /// Checking user information ...
        /// Checking for existence of string 50001...
        /// Adding user message - user:2533274801615275,id:50001,expiration:5/24/2006
        /// User message added successfully.
        /// 
        /// </code>
        /// </remarks>
        public void SendUserMsg(uint stringID, string gamerTag, string expiration)
        {
            string args = String.Format("/addusermsg /id:{0} /usertag:{1} /expiration:{2}", stringID, gamerTag, expiration);
            if (_MsgToolProcess.Run(args) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }
        /// <summary>
        /// Send a message for specified user on XBox 1 setting recommended by PUID
        /// </summary>
        /// <param name="stringID">ID of String to be sent to user</param>
        /// <param name="gamerTag">User's PUID</param>
        /// <param name="expiration">Message Expiration Date</param>
        /// <param name="recommended">XBox 1 switch to make recommended or required</param>
        /// <remarks>
        /// The following output was generated from this command line: msgtool /addusermsg /id:50001 /usertag:coerwyn /expiration:"5/24/2006"
        /// <code>
        /// Checking user information ...
        /// Checking for existence of string 50001...
        /// Adding user message - user:2533274801615275,id:50001,expiration:5/24/2006
        /// User message added successfully.
        /// 
        /// </code>
        /// </remarks>
        public void SendUserMsg(uint stringID, string gamerTag, string expiration, bool recommended)
        {
            string args = String.Format("/addusermsg /id:{0} /usertag:{1} /expiration:{2}", stringID, gamerTag, expiration);
            if (recommended)
            {
                args=String.Concat(args, " /recommended");
            }
            if (_MsgToolProcess.Run(args) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }

        // MSGTOOL /enumusermsg [ /user:[puid] | /usertag:[tag] ]
        /// <summary>
        /// Enumerates the messages for a user from their PUID
        /// </summary>
        /// <param name="puid">PUID of the user</param>
        /// <returns>A collection of UserMessages</returns>
        /// <remarks>The following was returned by the command line: msgtool /enumusermsg /user:2533274801615275
        /// <code>
        /// Checking user information ...
        /// 
        /// SenderID, SentTime, MessageID, MFlg, SenderTitleID, ExpireDate
        /// 0, 5/22/2006 4:52:24 PM, 2, 1, 4294836224, 5/24/2006 12:00:24 AM
        /// 
        /// End Enumeration.
        /// 
        /// </code>
        /// </remarks>
        public UserMessages EnumUserMsg(ulong puid)
        {
            UserMessages userMsgs = new UserMessages();
            
            if (_MsgToolProcess.Run(String.Format("/enumusermsg /user:{0}",puid)) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
            String[] output=_MsgToolProcess.Output.Split('\n');
            if (output[1] == "There were no messages in this user's message queue.")
            {
                return userMsgs;
            }
            int idx = 3;
            while (idx < output.Length && output[idx].Trim() != "")
            {
                userMsgs.Add(new UserMessage(output[idx]));
                idx++;
            }
            return userMsgs;
        }

        /// <summary>
        /// Returns a list of user messages from a specified gamerTag
        /// </summary>
        /// <param name="gamerTag">User's gamertag</param>
        /// <returns>Collection of UserMessages</returns>
        /// <remarks>The following was returned by the command line: msgtool /enumusermsg /usertag:coerwyn
        /// <code>
        /// Checking user information ...
        /// 
        /// SenderID, SentTime, MessageID, MFlg, SenderTitleID, ExpireDate
        /// 0, 5/22/2006 4:52:24 PM, 2, 1, 4294836224, 5/24/2006 12:00:24 AM
        /// 
        /// End Enumeration.
        /// 
        /// </code>
        /// </remarks>
        public UserMessages EnumUserMsg(string gamerTag)
        {
            UserMessages userMsgs = new UserMessages();
            
            if (_MsgToolProcess.Run(String.Format("/enumusermsg /usertag:{0}",gamerTag)) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
            String[] output=_MsgToolProcess.Output.Split('\n');
            if (output[1] == "There were no messages in this user's message queue.")
            {
                return userMsgs;
            }
            int idx = 3;
            while (idx < output.Length && output[idx].Trim() != "")
            {
                userMsgs.Add(new UserMessage(output[idx]));
                idx++;
            }
            return userMsgs;
        }

        // MSGTOOL /deleteusermsg /id:[id] [ /user:[puid] | /usertag:[tag] ]
        /// <summary>
        /// Deletes a user message using the Message ID and PUID.
        /// </summary>
        /// <param name="MsgId">Message ID returned from EnumMessage function</param>
        /// <param name="puid">User's PUID</param>
        /// <remarks>This command line generated the following output: msgtool /deleteusermsg /id:2 /user:2533274801615275
        /// <code>
        /// Checking user information ...
        /// Successfully deleted message ID 2 from the queue of user 2533274801615275
        /// 
        /// </code>
        /// </remarks>
        public void DeleteUserMsg(uint MsgId, ulong puid)
        {
            string args = String.Format("/deleteusermsg /id:{0} /user:{1}", MsgId, puid);
            if (_MsgToolProcess.Run(args) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }

        /// <summary>
        /// Deletes a user message using the Message ID and GamerTag
        /// </summary>
        /// <param name="MsgId">Message ID returned from EnumMessage function</param>
        /// <param name="gamerTag">User's GamerTag</param>
        /// <remarks>This command line generated the following output: msgtool /deleteusermsg /id:2 /usertag:coerwyn
        /// <code>
        /// Checking user information ...
        /// Successfully deleted message ID 2 from the queue of user 2533274801615275
        /// 
        /// </code>
        /// </remarks>
        public void DeleteUserMsg(uint MsgId, string gamerTag)
        {
            string args = String.Format("/deleteusermsg /id:{0} /usertag:{1}", MsgId, gamerTag);
            if (_MsgToolProcess.Run(args) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }

        /// <summary>
        /// Allows running MsgTool with custom argument string.
        /// Mainly used for negative testing.
        /// </summary>
        /// <param name="arguments">Argument string to be used when calling MsgTool.</param>
        public void RunMsgTool(string arguments)
        {
            if (_MsgToolProcess.Run(arguments) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }

        /// <summary>
        /// Runs MsgTool taking an XML file of messages and recipients.
        /// </summary>
        /// <param name="XMLFile">XML File path</param>
        public void XMLMessage(string XMLFile)
        {
            _MsgToolProcess.ExecutionTimeout = 6000;  // Boost timeout to 100 mins
            if (_MsgToolProcess.Run(String.Format(@"/addxmlmsg /xml:{0}", XMLFile)) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }

        /// <summary>
        /// Runs MsgTool taking an XML file of messages and recipients and *only* validates the XML format.
        /// </summary>
        /// <param name="XMLFile">XML File path</param>
        public void CheckXMLMessage(string XMLFile)
        {
            _MsgToolProcess.ExecutionTimeout = 6000;  // Boost timeout to 100 mins
            if (_MsgToolProcess.Run(String.Format(@"/addxmlmsg /xml:{0} /validatexml", XMLFile)) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }
    }

    /// <summary>
    /// Language Enum for the strings in MsgTool
    /// </summary>
    public enum StringLanguage
    {
    english=1,
    japanese,
    german,
    french,
    spanish,
    italian,
    korean,
    chinese,
    portuguese
    }

    /// <summary>
    /// Exception class for MsgTool runner
    /// </summary>
    public class MsgToolException : ProcessException
    {
        public MsgToolException() : base("MsgTool") {}
        public MsgToolException(string message) : base("MsgTool", message) {}
        public MsgToolException(string message, Exception innerException) : base("MsgTool", message, innerException) {}
        public MsgToolException(string message, string output) : base("MsgTool", message, output) {}
        public MsgToolException(string message, string output, Exception innerException) :
            base("MsgTool", message, output, innerException) {}
    }

    /// <summary>
    /// A Row returned from the Enum functions of MsgTool of what messages are sent.
    /// </summary>
    public class MessageEntry
    {
        // TitleID, MsgID, Sent, ExpireDate, Description
        public uint titleID;
        public uint msgID;
        public DateTime sentDate;
        public DateTime expireDate;
        public string description;

        /// <summary>
        /// Creates a new MsgTool Message line from a string that MsgTool returns.
        /// </summary>
        /// <param name="entry">Formatted String from MsgTool</param>
        /// <remarks>The tool returns each row like "TitleID, MsgID, Sent, ExpireDate, Description"</remarks>
        public MessageEntry(string entry)
        {
            string[] fields = entry.Split(',');
            if (fields.Length == 5)
            {
                titleID = Convert.ToUInt32(fields[0]);
                msgID = Convert.ToUInt32(fields[1]);
                sentDate = Convert.ToDateTime(fields[2]);
                expireDate = Convert.ToDateTime(fields[3]);
                description = fields[4];
            }
        }
        /// <summary>
        /// Tests if object is equal to this MessageEntry
        /// </summary>
        /// <param name="obj">Object to test</param>
        /// <returns>True if both objects are the same</returns>
        public override bool Equals(object obj)
        {
            if (obj is MessageEntry)
            {
                return
                    (
                    ((MessageEntry)obj).titleID == titleID &&
                    ((MessageEntry)obj).msgID == msgID &&
                    ((MessageEntry)obj).sentDate == sentDate &&
                    ((MessageEntry)obj).expireDate == expireDate &&
                    ((MessageEntry)obj).description == description 
                    );
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// Gets the hashcode for this instance
        /// </summary>
        /// <returns>Hashcode</returns>
        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

    }

    /// <summary>
    /// Collection of MessageEntry objects
    /// </summary>
    public class MessageEntries : CollectionBase
    {
        public MessageEntries() {}

        /// <summary>
        /// Indexer for MessageEntries
        /// </summary>
        public MessageEntry this[int index]
        {
            get { return List[index] as MessageEntry; }
            set { List[index] = value; }
        }

        /// <summary>
        /// Adds a MessageEntry to the collection
        /// </summary>
        /// <param name="val">MessageEntry to add</param>
        /// <returns>Index of MessageEntry</returns>
        public int Add(MessageEntry val)
        {
            return List.Add(val);
        }

        /// <summary>
        /// Tests if MessageEntry is in the collection
        /// </summary>
        /// <param name="val">MessageEntry to test</param>
        /// <returns>True if it is already in the collection</returns>
        public bool Contains(MessageEntry val)
        {
            return List.Contains(val);
        }

        /// <summary>
        /// Removes a MessageEntry from the collection
        /// </summary>
        /// <param name="val">MessageEntry to remove</param>
        public void Remove(MessageEntry val)
        {
            List.Remove(val);
        }
    }

    /// <summary>
    /// A Message for a particular User.  Returned in the collection from the EnumUserMsg function.
    /// </summary>
    public class UserMessage
    {
        // SenderID, SentTime, MessageID, MFlg, SenderTitleID, ExpireDate
        public uint senderID;
        public uint titleID;
        public uint msgID;
        public int MFlag;
        public DateTime sentDate;
        public DateTime expireDate;

        /// <summary>
        /// Creates a new MsgTool User Message line from a string that MsgTool enumUserMsg returns.
        /// </summary>
        /// <param name="entry">Formatted String from MsgTool</param>
        /// <remarks>The tool returns each row like "SenderID, SentTime, MessageID, MFlg, SenderTitleID, ExpireDate"</remarks>
        public UserMessage(string entry)
        {
            string[] fields = entry.Split(',');
            if (fields.Length == 6)
            {
                senderID = Convert.ToUInt32(fields[0]);
                sentDate = Convert.ToDateTime(fields[1]);
                msgID = Convert.ToUInt32(fields[2]);
                MFlag = Convert.ToInt32(fields[3]);
                titleID = Convert.ToUInt32(fields[4]);
                expireDate = Convert.ToDateTime(fields[5]);
                
            }
        }

        /// <summary>
        /// Determines if this UserMessage is equal to another object
        /// </summary>
        /// <param name="obj">Object to be tested</param>
        /// <returns>True if they are equal</returns>
        public override bool Equals(object obj)
        {
            if (obj is UserMessage)
            {
                return
                    (
                    ((UserMessage)obj).senderID == senderID &&
                    ((UserMessage)obj).sentDate == sentDate &&
                    ((UserMessage)obj).msgID == msgID &&
                    ((UserMessage)obj).MFlag == MFlag &&
                    ((UserMessage)obj).titleID == titleID &&
                    ((UserMessage)obj).expireDate == expireDate
                    );
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// Gets the hashcode for this object
        /// </summary>
        /// <returns>The hashcode</returns>
        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

    }

    /// <summary>
    /// Collection of UserMessage objects
    /// </summary>
    public class UserMessages : CollectionBase
    {
        public UserMessages() {}

        /// <summary>
        /// Indexer for UserMessage
        /// </summary>
        public UserMessage this[int index]
        {
            get { return List[index] as UserMessage; }
            set { List[index] = value; }
        }

        /// <summary>
        /// Adds a new UserMessage to the collection
        /// </summary>
        /// <param name="val">UserMessage to add</param>
        /// <returns>Index of message</returns>
        public int Add(UserMessage val)
        {
            return List.Add(val);
        }

        /// <summary>
        /// Tests if a UserMessage is already in the collection
        /// </summary>
        /// <param name="val">UserMessage to test</param>
        /// <returns>True if UserMessage is in the collection</returns>
        public bool Contains(UserMessage val)
        {
            return List.Contains(val);
        }

        /// <summary>
        /// Removes a UserMessage from the collection
        /// </summary>
        /// <param name="val">UserMessage to remove</param>
        public void Remove(UserMessage val)
        {
            List.Remove(val);
        }
    }
}
/* ------------------------------
 Microsoft Windows [Version 5.2.3790]
(C) Copyright 1985-2003 Microsoft Corp.

C:\Documents and Settings\a-johnk>path
PATH=C:\WINNT\system32;C:\WINNT;C:\WINNT\System32\Wbem;C:\Program Files\Microsoft ADS\bin;C:\Program Files\Microsoft ADS\tools;C:\
Program Files\Dell\SysMgt\oma\bin;C:\Program Files\Microsoft SQL Server\80\Tools\BINN;D:\webroot\xbltools

C:\Documents and Settings\a-johnk>dir
 Volume in drive C is Win2K
 Volume Serial Number is CC80-D514

 Directory of C:\Documents and Settings\a-johnk

05/12/2006  10:41 PM    <DIR>          .
05/12/2006  10:41 PM    <DIR>          ..
05/11/2006  10:13 PM    <DIR>          Desktop
05/11/2006  05:12 PM    <DIR>          Favorites
05/11/2006  09:48 PM    <DIR>          My Documents
08/11/2004  12:02 PM    <DIR>          Start Menu
08/11/2004  12:03 PM                 0 Sti_Trace.log
               1 File(s)              0 bytes
               6 Dir(s)   6,599,094,272 bytes free

C:\Documents and Settings\a-johnk>msgtool

Tool to add messages to the Xbox Live Messaging Service

Usage:
    MSGTOOL /addstring /id:<id> /text:<text> /lang:<language>
    MSGTOOL /addsystemmsg /id:<id> /expiration:<expiration> [/recommended]
    MSGTOOL /enumsysmsg
    MSGTOOL /addtitlemsg /id:<id> /title:<titleid> /expiration:<expiration> [/recommended]
    MSGTOOL /enumtitlemsg /title:<titleid>
    MSGTOOL /deletemsg /id:<id> /title:[<titleid | 0>]
    MSGTOOL /revokemsg /id:<id> /title:[<titleid | 0>]
    MSGTOOL /addusermsg /id:<id> [ /user:<puid> | /usertag:<tag> ] /expiration:<expiration> [/recommended]
    MSGTOOL /enumusermsg [ /user:<puid> | /usertag:<tag> ]
    MSGTOOL /deleteusermsg /id:<id> [ /user:<puid> | /usertag:<tag> ]

Definitions:
    <id>         - A numerical identifier for the string (in decimal)
    <user>       - Unique Xbox Live identifier for the desired user (in decimal)
    <usertag>    - Unique Xbox Live gamertag for the desired user
    <titleid>    - Unique Xbox Live identifier for the desired title (in decimal)
                   If title ID is in Hex notation, it must start with 0x (zero, then x)
                   Note: for /deletemsg or /revokemsg, use titleid 0 to delete system messages
    <language>   - Language of the given text string - 1=english
                                                       2=japanese
                                                       3=german
                                                       4=french
                                                       5=spanish
                                                       6=italian
                                                       7=korean
                                                       8=chinese
                                                       9=portuguese
    <text>       - Text for the message
    <expiration> - Date and time when the message will expire - Example: "10/31/2002"
                   Remember that dates for Live are in the UTC time zone (+8 from PST).
    recommended  - Specifies that the message is a recommended message. By default, messages
                   are marked as required.
                   Note: The Xbox 360 simply shows both recommended and required messages
                   in the message center. There is no enforced viewing of messages sent by
                   this tool. Special messages (such as voice bans) are sent through the
                   CUST front door that performs extra work to force the Xbox 360 to read
                   them. Recommended and required messages are still honored by the Xbox 1
                   dashboard

Description:
    Adding a message is a two step process. Typically, the message you are sending will
    be of a type that we commonly send, so you can skip the first step and simply use the known
    string ID in the second step.

    First, you need to add the message string to the string service in all required languages
    using the msgtool /addstring syntax.

    Second, you need to associate the string ID with the appropriate queue (system, title
    or user) using the msgtool /addXXXmsg syntax.

Examples:
    Adding a string for English:
    msgtool /addstring /id:50000 /text:"Message" /lang:1

    Adding a system message which uses the above string, expiring two days from now:
    msgtool /addsystemmsg /id:50000 /expiration:"5/17/2006"

    Adding a system-title message for users of title 1431502860:
    msgtool /addtitlemsg /id:50000 /title:1431502860 /expiration:"5/17/2006"

    Adding a system-title message for same title above, using Hex notation (Note the 0x):
    msgtool /addtitlemsg /id:50000 /title:0x5553000C /expiration:"5/17/2006"

    Adding a Recommended User message using user's PUID :
    msgtool /addusermsg /id:50000 /user:27517529866 /expiration:"5/17/2006" /recommended

    Adding a Required User message using user's Gamertag (Note: it's /usertag, not /user):
    msgtool /addusermsg /id:50000 /usertag:CreativeGamertag /expiration:"5/17/2006"

    Enumerating a User's messages using user's Gamertag:
    msgtool /enumusermsg /usertag:CreativeGamertag

    Enumerating title messages:
    msgtool /enumtitlemsg /title:0x5553000C

    Enumerating system messages:
    msgtool /enumsysmsg

    Deleting a title message:
    msgtool /deletemsg /id:<msgid> /title:0x5553000C

    Revoking a system message:
    msgtool /revokemsg /id:<msgid> /title:0

        Note: 'deleting' a system message means deleting it from the system message
        table so it will no longer be delivered to users when they sign in.
        'revoking' a system message means deleting it from the system message
        table so it will no longer be delivered to users when they sign in AND
        deleting all instances of it from user message table that have already
        been delivered.

    Deleting a message from a User's message queue:
    --> Do an /enumusermsg first, then use the msgid you get in the call below
    msgtool /deleteusermsg /user:27517529866  /id:<msgid>


C:\Documents and Settings\a-johnk>msgtool /addstring /id:50000 /text:"This is a test." /lang:1
Adding string - id:50000,lang:1,text:This is a test.
String Service address 10.20.1.5:11020
String Service address 10.20.1.5:11020


String added successfully.

C:\Documents and Settings\a-johnk>msgtool /addstring /id:50001 /text:"This is a test." /lang:1
Adding string - id:50001,lang:1,text:This is a test.
String Service address 10.20.1.5:11020
String Service address 10.20.1.5:11020


String added successfully.

C:\Documents and Settings\a-johnk>msgtool /enumsysmsg

Enumerating System Messages...
There were no messages in the system message queue.

C:\Documents and Settings\a-johnk>msgtool /addsystemmsg /id:50001 /expiration:"5/17/2006"
Checking for existence of string 50001...
Adding system message - id:50001,expiration:5/17/2006
System message added successfully.

C:\Documents and Settings\a-johnk>msgtool /enumsysmsg

Enumerating System Messages...

TitleID, MsgID, Sent, ExpireDate, Description
0, 1074107393, 5/16/2006 10:45:58 PM, 5/16/2006 11:59:58 PM, Xbox Live

End Enumeration.


C:\Documents and Settings\a-johnk>msgtool /revokemsg /id:50001 /title:0
System or title message was successfully deleted or revoked.

C:\Documents and Settings\a-johnk>msgtool /enumsysmsg

Enumerating System Messages...

TitleID, MsgID, Sent, ExpireDate, Description
0, 1074107393, 5/16/2006 10:45:58 PM, 5/16/2006 11:59:58 PM, Xbox Live

End Enumeration.


C:\Documents and Settings\a-johnk>msgtool /revokemsg /id:1074107393 /title:0
System or title message was successfully deleted or revoked.

C:\Documents and Settings\a-johnk>msgtool /enumsysmsg

Enumerating System Messages...
There were no messages in the system message queue.

C:\Documents and Settings\a-johnk>msgtool /enumtitlemsg /title:0

Error: An error occurred while attempting to use the TitleID supplied.
       Please check format and try again.

Exception text is: Invalid title id '0'

C:\Documents and Settings\a-johnk>msgtool /addtitlemsg /id:50001 /title:0xFFFE07D0 /expiration:"5/20/2006"
Checking for existence of string 50001...
Adding title message - title:0xFFFE07D0,id:50001,expiration:5/20/2006
Title message added successfully.

C:\Documents and Settings\a-johnk>msgtool /enumtitlemsg /title:0xFFFE07D0

Enumerating Messages for Title: 4294838224 ...

TitleID, MsgID, Sent, ExpireDate, Description
4294838224, 1074107394, 5/19/2006 4:21:07 PM, 5/20/2006 12:00:07 AM, Xbox Live

End Enumeration.


C:\Documents and Settings\a-johnk>msgtool /enumtitlemsg /title:0xFFFE07D1

Enumerating Messages for Title: 4294838225 ...
There were no messages in the system message queue.

C:\Documents and Settings\a-johnk>msgtool /addusermsg /id:50001 /usertag:coerwyn /expiration:"5/20/2006"
Checking user information ...
Checking for existence of string 50001...
Adding user message - user:2533274801615275,id:50001,expiration:5/20/2006
User message added successfully.

C:\Documents and Settings\a-johnk>msgtool /enumusermsg /usertag:coerwyn
Checking user information ...

SenderID, SentTime, MessageID, MFlg, SenderTitleID, ExpireDate
0, 5/19/2006 8:11:05 PM, 1, 1, 4294836224, 5/20/2006 12:00:05 AM

End Enumeration.


C:\Documents and Settings\a-johnk>
 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup1\ConfigFiles\MarketplaceConfig.cs ===
// Copyright 2004, Microsoft Corporation
// Sample Code - Use restricted to terms of use defined in the accompanying license agreement (EULA.doc)

//--------------------------------------------------------------
// Autogenerated by XSDObjectGen version 1.4.2.1
// Schema file: MarketplaceConfig.xsd
// Creation Date: 3/10/2006 9:57:00
//--------------------------------------------------------------

using System;
using System.IO;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;
using System.Collections;
using System.ComponentModel;

namespace ServerTestFramework.STFTools.ConfigFiles
{

	public struct MktPlaceDeclarations
	{
		public const string SchemaVersion = "http://www.xboxlive.com/xlast";
	}

	[XmlRoot(ElementName="XboxLiveSubmissionProject",Namespace=MktPlaceDeclarations.SchemaVersion,IsNullable=false),Serializable]
	public class XboxLiveMarketplaceProject
	{

		[XmlAttribute(AttributeName="Version",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __Version;
		
		[XmlIgnore]
		public string Version
		{ 
			get { return __Version; }
			set { __Version = value; }
		}

		[XmlElement(Type=typeof(MarketplaceConfigProject),ElementName="MarketplaceConfigProject",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=MktPlaceDeclarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public MarketplaceConfigProject __MarketplaceConfigProject;
		
		[XmlIgnore]
		public MarketplaceConfigProject MarketplaceConfigProject
		{
			get
			{
				if (__MarketplaceConfigProject == null) __MarketplaceConfigProject = new MarketplaceConfigProject();		
				return __MarketplaceConfigProject;
			}
			set {__MarketplaceConfigProject = value;}
		}

		public XboxLiveMarketplaceProject()
		{
		}

        public static XboxLiveMarketplaceProject FromXml(string marketplaceFile)
        {
            if (marketplaceFile == null)
            {
                throw new ArgumentNullException("marketplaceFile");
            }
            
            if (!File.Exists(marketplaceFile))
            {
                return null;
            }

            StreamReader reader = null;
            XmlTextReader xmlReader = null;
            XmlSerializer serializer = null;
            XboxLiveMarketplaceProject marketplace = null;
            try
            {
                reader = new StreamReader(marketplaceFile);
                xmlReader = new XmlTextReader(reader);
                serializer = new XmlSerializer(typeof(XboxLiveMarketplaceProject));
                marketplace = (serializer.Deserialize(xmlReader) as XboxLiveMarketplaceProject);
            }
            finally
            {
                if (xmlReader != null)
                {
                    xmlReader.Close();
                }
                if (reader != null)
                {
                    reader.Close();
                }
            }

            return marketplace;
        }

        public void ToXml(string marketplaceFile)
        {
            if (marketplaceFile == null)
            {
                throw new ArgumentNullException("marketplaceFile");
            }

            /*
             * We need to go through the pain of creating an XmlDocument from
             * the serialized XML stream so that when we can duplicate the
             * format of the Marketplace file when it's saved from XLAST.
             */
            StringWriter sw = new StringWriter();
            XmlDocument doc = new XmlDocument();
            XmlTextWriter xtw = new XmlTextWriter(marketplaceFile, System.Text.Encoding.Unicode);
            xtw.Formatting = Formatting.Indented;
            xtw.Indentation = 1;
            xtw.IndentChar = (char)0x9;
            try
            {
                XmlSerializer serializer = new XmlSerializer(typeof(XboxLiveMarketplaceProject));
                serializer.Serialize(sw, this);
                doc.LoadXml(sw.ToString());
                doc.Save(xtw);
            }
            finally
            {
                xtw.Close();
                sw.Close();
            }
        }
	}

	[XmlType(TypeName="MarketplaceConfigProject",Namespace=MktPlaceDeclarations.SchemaVersion),Serializable]
	public class MarketplaceConfigProject
	{

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="titleId",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __titleId;
		
		[XmlIgnore]
		public string titleId
		{ 
			get { return __titleId; }
			set { __titleId = value; }
		}

		[XmlAttribute(AttributeName="titleName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __titleName;
		
		[XmlIgnore]
		public string titleName
		{ 
			get { return __titleName; }
			set { __titleName = value; }
		}

		[XmlAttribute(AttributeName="titleType",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __titleType;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __titleTypeSpecified;
		
		[XmlIgnore]
		public uint titleType
		{ 
			get { return __titleType; }
			set { __titleType = value; __titleTypeSpecified = true; }
		}

		[XmlAttribute(AttributeName="name",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __name;
		
		[XmlIgnore]
		public string name
		{ 
			get { return __name; }
			set { __name = value; }
		}

		[XmlAttribute(AttributeName="projectVersion",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __projectVersion;
		
		[XmlIgnore]
		public string projectVersion
		{ 
			get { return __projectVersion; }
			set { __projectVersion = value; }
		}

		[XmlAttribute(AttributeName="schemaVersion",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __schemaVersion;
		
		[XmlIgnore]
		public string schemaVersion
		{ 
			get { return __schemaVersion; }
			set { __schemaVersion = value; }
		}

		[XmlElement(Type=typeof(LocalizedStrings),ElementName="LocalizedStrings",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=MktPlaceDeclarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public LocalizedStrings __LocalizedStrings;
		
		[XmlIgnore]
		public LocalizedStrings LocalizedStrings
		{
			get
			{
				if (__LocalizedStrings == null) __LocalizedStrings = new LocalizedStrings();		
				return __LocalizedStrings;
			}
			set {__LocalizedStrings = value;}
		}

		[XmlElement(Type=typeof(Images),ElementName="Images",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=MktPlaceDeclarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Images __Images;
		
		[XmlIgnore]
		public Images Images
		{
			get
			{
				if (__Images == null) __Images = new Images();		
				return __Images;
			}
			set {__Images = value;}
		}

		[XmlElement(Type=typeof(ProductInformation),ElementName="ProductInformation",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=MktPlaceDeclarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ProductInformation __ProductInformation;
		
		[XmlIgnore]
		public ProductInformation ProductInformation
		{
			get
			{
				if (__ProductInformation == null) __ProductInformation = new ProductInformation();		
				return __ProductInformation;
			}
			set {__ProductInformation = value;}
		}

		public MarketplaceConfigProject()
		{
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup1\ClientTools\LiveTitle.cs ===
using System;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml;
using System.Xml.Serialization;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.STFTools.ConfigFiles;
using xonline.common.config;
using xonline.common.protocol;

namespace ServerTestFramework.STFTools
{
    /// <summary>
    /// Utility class for running the LiveTitle tool.
    /// </summary>
    public class LiveTitle
    {
        const string DefaultLiveTitlePath = "D:\\webroot\\xbltools";

        private string _ltcPath = "";
        private string _xlastPath = "";
        private string _xscPath = "";
        private string _xboxPath = "";
        private string _xmsPath = "";
        private string _marketplacePath = "";
        private string _lbServer = "";
        private string _matchServers = "";
        private ProcessWrapper _liveTitleProcess;
        private Report _report;

        public LiveTitle()
        {
            _liveTitleProcess = new ProcessWrapper("LiveTitle", Path.Combine(DefaultLiveTitlePath, "LiveTitle.exe"));
            _liveTitleProcess.SetEnvironmentVariable("XBL_CONFIG_SERVER", Global.CurrentEnvironment.NpdbIp);
            _liveTitleProcess.Verbose = true;
            _report = new Report("LiveTitle");

            try
            {
                string [] servers = Global.XEnv.GetServerListByInterface(Interface.lbsvr);
                if (servers.Length > 0)
                {
                    _lbServer = servers[0];
                }
                else
                {
                    _report.Warn("The leaderboard server list is empty!");
                }

                servers = Global.XEnv.GetServerListByInterface(Interface.xmatch);
                if (servers.Length > 0)
                {
                    _matchServers = servers[0];
                }
                else
                {
                    _report.Warn("The matchmaking server list is empty!");
                }
            }
            catch (Exception e)
            {
                _report.Error("Exception while populating server list: " + e.Message);
            }
        }

        public LiveTitle(string liveTitlePath) : this()
        {
            LiveTitlePath = liveTitlePath;
        }

        /// <summary>
        /// Gets or sets the fully-qualified name of the LiveTitle executable.
        /// </summary>
        public string LiveTitlePath
        {
            get { return _liveTitleProcess.ExecutablePath; }
            set
            {
                _liveTitleProcess.ExecutablePath = Path.GetFullPath(value);
                _liveTitleProcess.WorkingDirectory = Path.GetDirectoryName(_liveTitleProcess.ExecutablePath);
            }
        }

        /// <summary>
        /// Gets or sets the working directory for LiveTitle
        /// </summary>
        public string WorkingDirectory
        {
            get { return _liveTitleProcess.WorkingDirectory; }
            set
            {
                if (value != null)
                {
                    _liveTitleProcess.WorkingDirectory = Path.GetFullPath(value);
                }
                else
                {
                    _liveTitleProcess.WorkingDirectory = null;
                }
            }
        }

        /// <summary>
        /// Gets or sets the fully-qualified name of the LTC file used during title 
        /// deployment.
        /// </summary>
        public string LTCPath
        {
            get { return _ltcPath; }
            set
            {
                if (value != null)
                {
                    _ltcPath = Path.GetFullPath(value);
                }
                else
                {
                    _ltcPath = "";
                }
            }
        }

        /// <summary>
        /// Xbox 360 LTC file creation and title deployment.
        /// </summary>
        public string XlastPath
        {
            get { return _xlastPath; }
            set
            {
                if (value != null)
                {
                    _xlastPath = Path.GetFullPath(value);
                }
                else
                {
                    _xlastPath = "";
                }
            }
        }

        /// <summary>
        /// Gets or sets the fully-qualified name of the Marketplace file used to deploy a Marketplace-only title.
        /// </summary>
        public string MarketplacePath
        {
            get { return _marketplacePath; }
            set
            {
                if (value != null)
                {
                    _marketplacePath = Path.GetFullPath(value);
                }
                else
                {
                    _marketplacePath = "";
                }
            }
        }

        /// <summary>
        /// Gets or sets the fully-qualified name of the XSC file used during Xbox1 LTC 
        /// file creation and title deployment.
        /// </summary>
        public string XSCPath
        {
            get { return _xscPath; }
            set
            {
                if (value != null)
                {
                    _xscPath = Path.GetFullPath(value);
                }
                else
                {
                    _xscPath = "";
                }
            }
        }

        /// <summary>
        /// Gets or sets the fully-qualified name of the XBOX file used during Xbox1 LTC 
        /// file creation and title deployment.
        /// </summary>
        public string XBOXPath
        {
            get { return _xboxPath; }
            set
            {
                if (value != null)
                {
                    _xboxPath = Path.GetFullPath(value);
                }
                else
                {
                    _xboxPath = "";
                }
            }
        }

        /// <summary>
        /// Gets or sets the fully-qualified name of the XMS file used during Xbox1 title 
        /// deployment (optional).
        /// </summary>
        public string XMSPath
        {
            get { return _xmsPath; }
            set
            {
                if (value != null)
                {
                    _xmsPath = Path.GetFullPath(value);
                }
                else
                {
                    _xmsPath = "";
                }
            }
        }

     